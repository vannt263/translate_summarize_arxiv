{
  "article_text": [
    "the problem of finding the shortest paths between pairs of vertices on a graph is one of the most extensively studied problems in algorithm research .",
    "this problem is formally known as the shortest paths ( sp ) problem and is often categorized into the single source shortest paths ( sssp ) problem and the all pairs shortest paths ( apsp ) problem . as the names suggest , the sssp problem is to compute the shortest paths from one single source vertex to all other vertices on the graph , and the apsp problem is to compute the shortest paths between all possible pairs on the graph .",
    "the most well known algorithm for solving the sssp problem is the algorithm by @xcite that runs in @xmath6 time , where @xmath7 is the number of vertices in a graph .",
    "this algorithm can be enhanced with a priority queue , and if the fibonacci heap @xcite is used to implement the priority queue then the time complexity becomes @xmath8 where @xmath9 is the number of edges in the graph .",
    "if edge costs are integers bounded by @xmath1 , then the sssp problem can be solved in @xmath10 time @xcite using a complex priority queue for integers . for solving the apsp problem , the @xmath11 algorithm by @xcite",
    "is the most well known .",
    "if edges have capacities , the bottleneck of a path is the minimum capacity out of all edge capacities on the path . in other words ,",
    "the bottleneck of a path from vertex @xmath12 to vertex @xmath13 is the maximum amount of flow that can be pushed from @xmath12 to @xmath13 down the path .",
    "finding the paths that give the maximum bottlenecks between pairs of vertices is also a well studied problem and is formally known as the bottleneck paths ( bp ) problem .",
    "the single source bottleneck paths ( ssbp ) problem can be solved with a simple modification to the algorithm by @xcite . for an undirected graph",
    "the all pairs bottleneck paths ( apbp ) problem can be solved in @xmath14 , which is optimal @xcite .",
    "the sp and bp problems are concerned with finding the minimum or the maximum possible values .",
    "however , the shortest path may not give the biggest bottleneck , and the path that gives the maximum bottleneck may not be the shortest path . if the flow demand from a vertex to another vertex is known , then it is clearly beneficial to find the shortest path that can fully accommodate that flow demand .",
    "thus we combine the sp and bp problems to compute the shortest paths for all possible flow amounts .",
    "we call this problem the shortest paths for all flows ( sp - af ) problem . as is common in graph paths problems , we divide the sp - af problem into the single source shortest paths for all flows ( sssp - af ) problem , and the all pairs shortest paths for all flows ( apsp - af ) problem .",
    "there are many obvious real life applications for this new problem , such as routing in computer networks , transportation , logistics , and even planning for emergency evacuations .",
    "the city of christchurch has recently been hit by a series of strong earthquakes , most notably in september 2010 and in february 2011 .",
    "if we consider hundreds of people evacuating from a building in such emergencies , if the amount of people ( flow ) can be predetermined , we can find the shortest route for all people in various locations around the building to their respective evacuation points such that the flow of people can be fully accommodated .",
    "if the flow amounts ( of people ) are not considered in calculating the evacuation routes , congestion may occur at various points in the building that could lead to serious accidents .    in this paper we present algorithms for solving the sssp - af and apsp - af problems on directed graphs with non - negative integer edge costs and real edge capacities that are faster than the straightforward methods .",
    "we first give an algorithm to solve sssp - af on graphs with unit edge costs in @xmath0 time .",
    "we then present two algorithms for solving sssp - af on graphs with non - negative integer edge costs of at most @xmath1 in @xmath2 and @xmath15 time bounds .",
    "finally we show that the main concepts behind the sssp - af algorithms can be extended to solve apsp - af in @xmath4 and @xmath5 time bounds .",
    "let @xmath16 be a directed graph with non - negative integer edge costs bounded by @xmath1 and non - negative real capacities .",
    "let @xmath17 and @xmath18 .",
    "vertices are given by integers such that @xmath19 .",
    "let @xmath20 be the edge from vertex @xmath21 to vertex @xmath22 .",
    "let @xmath23 denote the edge cost ( or distance ) and let @xmath24 denote the edge capacity .",
    "let @xmath25 be the set of vertices that are directly reachable from @xmath13 , and @xmath26 be the set of vertices that can directly reach @xmath13 .",
    "there can be up to @xmath9 distinct capacities if all edge capacities are unique .",
    "we refer to the distinct capacities as maximal flows .",
    "then the sp - af problem is to solve the sp problem for all maximal flows .    for all our algorithms only comparison operations",
    "are performed on the maximal flow values .",
    "therefore the real values of maximal flows can be mapped to integer values without any loss of generality by first sorting the maximal flows in increasing order then assigning incremental integer values starting from 1 .",
    "this allows us to use maximal flow values as indexes of arrays in our algorithms .",
    "we use the computational model that allows comparison - addition operations and random access with @xmath27 bits to be performed in @xmath28 time .",
    "we first consider solving the sp - af problem from a source vertex @xmath29 to all other vertices in @xmath30 .",
    "initially we compute just the distances rather than actual paths then later show that the paths information can be computed in the same time bound .",
    "that is , we first solve the single source shortest distances for all flows ( sssd - af ) problem , then show that the algorithm can be extended to solve the sssp - af problem with no increase in the worst case time complexity .",
    "the sssd - af problem can be defined as the problem of computing the set of all @xmath31 pairs for each destination vertex , where @xmath32 is the shortest distance from @xmath29 and @xmath33 is the maximal flow value .",
    "let @xmath34 $ ] be the set of @xmath31 pairs for the destination vertex @xmath13 .",
    "suppose @xmath31 and @xmath35 both exist in @xmath34 $ ] such that @xmath36",
    ". then we keep @xmath35 _ iff _",
    "@xmath37 , that is , a longer path is only _ useful _ if it can accommodate a greater flow .",
    "if @xmath38 , we keep the pair that gives us the greater flow .",
    "solving sssp - af on the example graph in figure [ fig : graph ] with @xmath39 would result in @xmath40 = \\{(4,2),(5,3),(6,5),(8,6)\\}$ ] .",
    "the straightforward method for solving the sssp - af problem is to iterate through each maximal flow @xmath41 and solving the sssp problem for the sub - graph that only have edges with capacities @xmath41 or greater . on graphs with unit edge costs sssp",
    "can be solved in @xmath42 time with a simple breadth - first - search ( bfs ) , resulting in @xmath43 time bound for solving the sssp - af problem . on graphs with integer edge costs bounded by @xmath1",
    ", we can use the algorithm by @xcite to solve sssp - af in @xmath44 time .",
    "note that sssp - af can not be solved with a simple decremental algorithm , where edges are removed one by one in decreasing order of capacity then the connectivity of all affected vertices are checked .",
    "this method fails because edges with larger capacities may later be required to provide shorter paths for smaller maximal flows .",
    "algorithm [ alg : unit ] solves sssp - af in @xmath0 time by utilizing the fact that even though there are @xmath42 maximal flows , there can only be @xmath45 paths with unique path costs for each destination vertex .",
    "as noted earlier , if multiple paths from @xmath29 to @xmath13 exists with equal path costs , we only need to keep the path that can accommodate the biggest maximal flow out of those paths .",
    "thus for graphs with unit edge costs , even with @xmath9 maximal flows , the size of @xmath34 $ ] is @xmath45 for each @xmath13 .",
    "let @xmath46 $ ] be the bottleneck of a path from @xmath29 to vertex @xmath13 .",
    "let @xmath47 $ ] be a possible distance from @xmath29 to @xmath13 .",
    "let @xmath48 $ ] be a set of vertices that may be added to spanning tree ( spt ) at distance @xmath21 , such that @xmath49 , i.e. one set of vertices exists for each possible distance from @xmath29 .",
    "the algorithm starts off with just @xmath29 in the spt and makes incremental changes to the spt as we iterate through the maximal flow values in increasing order .",
    "the spt is a persistent data structure and we do not build it up from scratch in each iteration . in summary , as we iterate through each maximal flow we cut nodes from the spt that can not accommodate the maximal flow and add the nodes back to the spt at the shortest possible distance from @xmath29 ( the root ) .    [",
    "line : inc1 ] [ line : d ] [ line : b ] [ line : append ] [ line : inc2 ]    algorithm [ alg : unit ] correctly solves sssd - af on directed graphs with unit edge costs .    by iterating from @xmath50",
    "$ ] to @xmath51 $ ] for each maximal flow , we ensure that all vertices are added to the spt at the minimum possible distance from @xmath29 for the maximal flow value in the current iteration . when the minimum possible distance is found for a vertex @xmath13 to be added to the spt ( line [ line : d ] ) , all potential parent nodes , @xmath26 ,",
    "are inspected to ensure that @xmath13 is added to the @xmath52 such that the bottleneck from @xmath29 to @xmath13 is maximized for the given distance ( line [ line : b ] ) .",
    "since @xmath47 $ ] is monotonically increasing ( lines [ line : inc1 ] and [ line : inc2 ] ) , @xmath13 can not be added to the spt multiple times at the same distance .",
    "thus any time a vertex @xmath13 is added to the spt , @xmath53,b[v])$ ] can be appended to @xmath34 $ ] as a @xmath31 pair .",
    "it follows that once we iterate through all maximal flows we have retrieved all relevant @xmath31 pairs .",
    "< 1.5em - 1.5em plus0em minus0.5em height0.75em width0.5em depth0.25em    algorithm [ alg : unit ] runs in @xmath0 worst case time .",
    "we perform lifetime analysis to determine the upper bound of algorithm [ alg : unit ] .",
    "each vertex @xmath13 can be cut from the spt and be re - added to the spt @xmath45 times , once per each possible distance from @xmath29 . cutting / adding @xmath13 from / to the spt takes @xmath28 time , achieved by setting the parent of @xmath13 to either @xmath54 or @xmath12 , respectively .",
    "therefore the total time complexity of all operations involving the spt is @xmath6 .",
    "also there are a total of @xmath14 @xmath31 pairs . before each vertex @xmath13",
    "is added to the spt all incoming edges @xmath55 are inspected .",
    "this results in @xmath42 edges being inspected in total for the entire duration of the algorithm for each possible distance from @xmath29 .",
    "since there are @xmath45 possible distances from @xmath29 , the total time taken for edge inspection is @xmath0 . thus the total worst case time complexity becomes @xmath56 .",
    "< 1.5em - 1.5em plus0em minus0.5em height0.75em width0.5em depth0.25em    [ theorem : int ] there exists an algorithm to solve sssp - af on directed graphs with unit edge costs in @xmath0 time .",
    "there are @xmath45 destination vertices , @xmath42 maximal flows , and the length of each path is @xmath45 . therefore storing all explicit paths as a solution to the sssp - af problem takes @xmath57 , which is too expensive .",
    "as is common in graph paths algorithms , we work around this problem by storing just the _ predecessor _ vertex for storing the path information .",
    "the predecessor vertex for a path from @xmath29 to @xmath13 is the vertex that comes immediately before @xmath13 on the path .",
    "we extend algorithm [ alg : unit ] to store the parent vertex , @xmath12 , alongside the @xmath31 pair in line [ line : append ] i.e. we can extend the @xmath31 pair to the @xmath58 triplet .",
    "then @xmath12 is the predecessor vertex for the shortest path from @xmath29 to @xmath13 that can accommodate flow up to @xmath33 . by using @xmath32 and @xmath12 , any explicit path can be retrieved by recursively following the predecessor vertices in time linear to the path length . clearly",
    "the additional storage of the predecessor vertex does not increase the worst case time complexity of the algorithm .",
    "< 1.5em - 1.5em plus0em minus0.5em height0.75em width0.5em depth0.25em      before we move onto solving the sssp - af problem on graphs with integer edge costs , we review the @xmath59-level cascading bucket system ( cbs ) @xcite .",
    "a detailed review of this data structure has also been provided by @xcite .    in the @xmath59-level cbs the key value @xmath32 is given by : @xmath60 where @xmath61 is the number of buckets ( or length ) of each level .",
    "let @xmath21 be the largest index such that @xmath62 is non - zero .",
    "then an element with key of @xmath32 is inserted into the @xmath63 bucket at level @xmath21 .",
    "the values of @xmath62 for all @xmath64 are calculated only once when an element is inserted , and each insertion takes @xmath65 time .    the _ decrease - key _",
    "operation can be performed by removing the element from the cbs in @xmath28 time , updating the key value , then re - inserting in the same level in @xmath28 time , or re - inserting at a lower level in @xmath66 time where @xmath67 is the difference between the initial level and the new level .",
    "the _ delete - min _ operation is more involved than the _ insert _ or the _ decrease - key _ operations .",
    "we maintain an active pointer at each level , @xmath68 for all @xmath64 , such that @xmath68 is the minimum index of the non - empty bucket at level @xmath21 .",
    "@xmath69 means level @xmath21 is empty . to perform the _ delete - min _ operation , if level 0 is not empty , we simply pick up the minimum non - empty bucket pointed to by @xmath70 .",
    "if level 0 is empty , then we find the lowest non - empty level , @xmath22 , and re - distribute the elements in the @xmath71 bucket into level @xmath72 , then re - distribute the elements in the @xmath73 bucket into level @xmath74 , and so on , until level 0 is non - empty .",
    "this process of repeated re - distribution from a higher level down to lower levels is referred to as _ cascading _ , hence the name for the data structure .",
    "each _ delete - min _ takes @xmath75 time if @xmath76 , and @xmath77 if @xmath78 , where @xmath79 is the maximum key value that the cbs supports .",
    "figure [ fig : cbs ] shows an example of a @xmath80-level cbs that can support key values up to 1399 .",
    "@xmath81 was chosen to make the example easier to understand , since it becomes straightforward to determine the correct bucket for base 10 numbers .",
    "if the element with key equal to 19 is removed from the cbs , @xmath82 becomes 10 , and the next _ delete - min _ operation will trigger the _ cascading _ operation , resulting in elements in @xmath83 to be re - distributed into level 0 .",
    "in section [ sec : ssspaf : unit ] we gave an algorithm to solve sssp - af on directed graphs with unit edge costs in @xmath0 time , that is faster than the straightforward method of @xmath43 .",
    "in this section we present two algorithms to solve sssp - af on directed graphs with non - negative edge costs in @xmath2 and @xmath3 time bounds .",
    "both time bounds are faster than the @xmath44 time bound of the straightforward method for a wide range of values for @xmath1 , @xmath9 and @xmath7 , and have the added benefit of not relying on a complex data structure that is difficult to implement in real life situations .",
    "we note that algorithm [ alg : unit ] can also be used to solve sssp - af in @xmath84 time since the maximum distance from @xmath29 for any vertex for any maximal flow value is @xmath85 .",
    "@xmath84 is a comparatively efficient time bound for dense graphs with small @xmath1 .",
    "the two time bounds of @xmath2 and @xmath3 actually both come from the same algorithm , algorithm [ alg : int ] , but using different data structures to implement the priority queue .",
    "algorithm [ alg : int ] is a natural extension to the well known algorithm by @xcite . for this algorithm",
    "we define the triplet @xmath86 , where @xmath13 is the destination vertex and @xmath32 and @xmath33 are equivalent to the @xmath31 pair as defined in section [ sec : ssspaf ] .",
    "we let @xmath87 $ ] be the current shortest distance from @xmath29 to @xmath13 for the maximal flow value of @xmath33 .",
    "we let @xmath88 be the priority queue for the @xmath86 triplets with @xmath32 as the key where the operations performed on @xmath88 are _ insert _ , _ decrease - key _ and _ delete - min_. in summary , all @xmath0 @xmath86 triplets are added to the priority queue , @xmath88 , then as they are removed one by one , the @xmath31 pair is appended to @xmath34 $ ] if the @xmath31 pair is _ useful _",
    "i.e. @xmath33 is greater than any flow in existing pairs in @xmath34 $ ] .",
    "[ line : while ] [ line : delmin ] [ line : out ] [ line : update ]    @xmath31 in @xmath34 $ ] is correct if @xmath32 is the shortest distance of a path that can push flows up to @xmath33 from @xmath29 to @xmath13 .    [",
    "lem : sssdaf ] algorithm [ alg : int ] correctly solves sssd - af on directed graphs with integer edge costs .",
    "we provide a formal proof by induction .",
    "let @xmath89 be the set of @xmath86 such that @xmath34 $ ] contains the pair @xmath31 , for all @xmath13 , for all @xmath31 pairs .",
    "then in the beginning of each iteration :    1 .",
    "the set of @xmath31 pairs in each @xmath34 $ ] are all correct i.e. all @xmath86 triplets in @xmath89 are correct .",
    "2 .   for any @xmath86 in @xmath88",
    ", @xmath32 is the distance of the shortest path from @xmath29 to @xmath13 that can push @xmath33 only through the path that lies in @xmath89 except for the end point @xmath13 .    basis . before the while - loop begins ( line [ line : while ] ) all are correct , and we suppose the theorem is correct at the beginning of some iteration . then :    1 .",
    "let @xmath90 be the last pair in @xmath34 $ ] .",
    "suppose @xmath31 is appened to @xmath34 $ ] at the end of the loop .",
    "note that @xmath32 values are sorted in increasing order in @xmath34 $ ] .",
    "since @xmath33 is appened only when @xmath91 , there can be no shorter path in @xmath34 $ ] that can push @xmath33 .",
    "thus @xmath31 is appended as a correct pair .",
    "2 .   we remove @xmath86 from @xmath88 in line [ line : delmin ] .",
    "the new distance @xmath92 and flow @xmath93 from @xmath13 to @xmath94 are computed for all possible @xmath94 .",
    "if @xmath95 $ ] , @xmath86 now lies in the path from @xmath29 to @xmath94 , and @xmath96 is added to @xmath88 . since @xmath86 is added to @xmath34 $ ] at the end of the loop",
    ", @xmath92 is the distance of the shortest path from @xmath29 to @xmath94 that can push @xmath33 only through the path that lies in @xmath89 except for the end point @xmath94 .",
    "< 1.5em - 1.5em plus0em minus0.5em height0.75em width0.5em depth0.25em    [ lemma : nc ] algorithm [ alg : int ] can run in @xmath97 worst case time .",
    "we use a one dimensional bucket system to implement q. insert and decrease - key operations can be performed in @xmath28 , resulting in @xmath0 time bound for both operations for the whole algorithm . the delete - min operation",
    "is performed simply by scanning through @xmath88 from @xmath98 to @xmath99 one by one , where @xmath21 is the distance from @xmath29 .",
    "we only have to scan through the distances once , and therefore the time complexity of the delete - min operation for the whole duration of the algorithm is @xmath85 .",
    "each vertex can be inspected exactly once at each maximal flow value .",
    "this means @xmath42 edge inspections are performed per maximal flow value , resulting in @xmath43 for the whole algorithm .",
    "thus we have @xmath100 as the total worst case time complexity of algorithm [ alg : int ] using the one dimensional bucket system to implement the priority queue .",
    "< 1.5em - 1.5em plus0em minus0.5em height0.75em width0.5em depth0.25em    [ lem : cm ] algorithm [ alg : int ] can run in @xmath101 worst case time .",
    "we use @xmath59-level cbs to implement @xmath88 .",
    "since there are a total of @xmath0 @xmath86 triplets to be inserted into @xmath88 , the total time complexities for operations performed on @xmath88 are : @xmath102 for _ insert _ , @xmath102 for _ decrease - key _ , and @xmath103 for _ delete - min _ , where p is the length of each level .",
    "we choose @xmath104 and @xmath105 to implement our @xmath59-level cbs .",
    "then the term @xmath102 dominates and the total time complexity for all three operations involving @xmath88 becomes @xmath106 .",
    "as shown in the proof of lemma [ lemma : nc ] , the total time taken for edge inspection is @xmath107 , resulting in the total worst case time complexity of @xmath101 for algorithm [ alg : int ] using the @xmath59-level cbs to implement the priority queue .",
    "< 1.5em - 1.5em plus0em minus0.5em height0.75em width0.5em depth0.25em    there exists algorithms to solve the sssp - af problem on directed graphs with integer edge costs in @xmath97 or @xmath101 time bounds .",
    "we take the same approach as discussed in the proof of theorem [ theorem : int ] . in line [ line : update ] of algorithm [ alg : int ] , we store @xmath13 as the predecessor vertex alongside the @xmath96 triplet .",
    "< 1.5em - 1.5em plus0em minus0.5em height0.75em width0.5em depth0.25em    note that in the proof of lemma [ lem : cm ] we could have chosen @xmath108 to speed up the algorithm by a polylog factor .",
    "we also note that if @xmath109 then algorithm [ alg : int ] has the time complexity of @xmath107 , thus algorithm [ alg : unit ] has not been made redundant by algorithm [ alg : int ] .",
    "the key achievement in this paper is not to come up with an original data structure but to devise algorithms to successfully utilize existing well known data structures , based on the observation that the maximum distance of any simple path on a graph with integer edge costs bounded by @xmath1 is @xmath85 . from this observation what we have effectively achieved",
    "is to find a method to _",
    "share resources_. that is , instead of having to repeatedly scan over @xmath85 distances for solving sssp for each maximal flow value , we solve sssp for all maximal flows at the same time while sharing the common resource , @xmath88 , thereby allowing us to scan @xmath85 only once .",
    "@xcite used a similar idea to achieve @xmath110 for the apsp problem . in this section",
    "we further extend the idea of sharing common resources to solve the problem of apsp - af .",
    "we let @xmath111[v]$ ] be the currently known shortest distance from vertex @xmath12 to vertex @xmath13 for maximal flow @xmath33 .",
    "we extend the @xmath86 triplet that was defined in section [ sec : ssspaf : int ] to the quadruple @xmath112 , where @xmath12 and @xmath13 are the starting and the ending vertices of a possible path , respectively",
    ". then we can extend algorithm [ alg : int ] to solve the apsd - af problem , as shown in algorithm [ alg : ap ]    [ line : ap : update ]    algorithm [ alg : ap ] correctly solves apsd - af on directed graphs with integer edge costs .",
    "essentially the same argument as the proof of lemma [ lem : sssdaf ] can be applied .",
    "the only differences are that we now have quadruples @xmath112 instead of triplets in @xmath88 and @xmath89 , and we need to go through more iterations as we are solving for all @xmath14 pairs of vertices .",
    "clearly these differences has no impact on the correctness of the algorithm .",
    "< 1.5em - 1.5em plus0em minus0.5em height0.75em width0.5em depth0.25em    algorithm [ alg : ap ] can run in @xmath4 worst case time .",
    "there are @xmath14 pairs of vertices resulting in @xmath57 @xmath112 quadruples .",
    "each vertex pair can be observed exactly once at each maximal flow value hence the number of edge inspections that occur at one maximal flow value is @xmath0 , resulting in the total time bound of @xmath113 for edge inspections . using the one dimensional bucket system to implement @xmath88 , we have @xmath114 as the worst case time complexity .",
    "< 1.5em - 1.5em plus0em minus0.5em height0.75em width0.5em depth0.25em    algorithm [ alg : ap ] can run in @xmath5 worst case time .",
    "we use the @xmath59-level cascading bucket system to implement @xmath88 , where the _ delete - min _ operation now takes @xmath115 time .",
    "we choose @xmath116 and @xmath117 for the total time complexity of the _ delete - min _ operation to become @xmath118 .",
    "thus the total worst case time complexity using the cascading bucket system is @xmath119 .",
    "< 1.5em - 1.5em plus0em minus0.5em height0.75em width0.5em depth0.25em    there exists algorithms to solve the apsp - af problem on directed graphs with integer edge costs in @xmath4 or @xmath5 time bounds .",
    "we take the same approach as before and modify algorithm [ alg : ap ] to store @xmath13 as the predecessor vertex alongside the @xmath120 quadruple in line [ line : ap : update ] .",
    "< 1.5em - 1.5em plus0em minus0.5em height0.75em width0.5em depth0.25em",
    "we have introduced a new graph path problem and provided non - trivial algorithms to solve the new problem that are both practical and faster than the straightforward methods .",
    "the example of evacuation planning has been used in the introduction of the paper to show the relevance of the sp - af problem in real life .",
    "another possible application of the sssp - af problem is in computer networking , as a more sophisticated dynamic routing protocol than the currently commonly used protocols such as rip and ospf . and with the introduction of software defined networking ( sdn ) @xcite",
    ", we can also propose apsp - af as a possible algorithm to calculate the routes in the entire network .",
    "trivial lower bounds of @xmath0 and @xmath57 exist for the sssp - af and apsp - af problems , respectively , on weighted digraphs .",
    "this paper has investigated only graphs with integer edge costs .",
    "can we provide a better time bound than the straightforward @xmath121 for the sssp - af problem on directed graphs with real edge costs ?",
    "is there a faster algorithm on undirected graphs ?",
    "how close can we get to the lower bounds of the sp - af problems ?",
    "we conclude the paper with these open questions and look forward to further research that may address these open problems ."
  ],
  "abstract_text": [
    "<S> we combine the well known shortest paths ( sp ) problem and the bottleneck paths ( bp ) problem to introduce a new problem called the shortest paths for all flows ( sp - af ) problem that has relevance in real life applications . </S>",
    "<S> we first solve the single source shortest paths for all flows ( sssp - af ) problem on directed graphs with unit edge costs in @xmath0 worst case time bound . </S>",
    "<S> we then present two algorithms to solve sssp - af on directed graphs with integer edge costs bounded by @xmath1 in @xmath2 and @xmath3 time bounds . </S>",
    "<S> finally we extend our algorithms for the sssp - af problem to solve the all pairs shortest paths for all flows ( apsp - af ) problem in @xmath4 and @xmath5 time bounds . </S>",
    "<S> all algorithms presented in this paper are practical for implementation .    _ </S>",
    "<S> keywords : _ shortest paths , sp , bottleneck paths , bp , single source shortest paths , sssp , all pairs shortest paths , apsp </S>"
  ]
}