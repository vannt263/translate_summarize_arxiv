{
  "article_text": [
    "the historical evolution of the research on uncertainty in _ logic programming _ ( @xmath1 ) has been described in a recent recollection by v. s. subrahmanian @xcite .",
    "early approaches include the quantitative treatment of uncertainty in the spirit of fuzzy logic , as in van emden s classical paper @xcite and two subsequent papers by subrahmanian @xcite .",
    "the main contribution of @xcite was a rigorous declarative semantics for a @xmath1 language with program clauses of the form @xmath6 , where the head @xmath7 is an atom , the body @xmath8 is a conjunction of atoms , and the so - called _ attenuation _ factor @xmath9 $ ] attached to the clause s implication is used to propagate to the head the certainty factor @xmath10 , where @xmath11 is the minimum of the certainty factors @xmath12 $ ] previously computed for the various atoms occurring in the body . the papers @xcite proposed to use a special lattice @xmath13 in place of the lattice of the real numbers in the interval @xmath14 $ ] under their natural ordering .",
    "@xmath13 includes two isomorphic copies of @xmath14 $ ] whose elements are incomparable under @xmath13 s ordering and can be used separately to represent degrees of _ truth _ and _ falsity _ , respectively , thus enabling a simple treatment of negation .",
    "other main contributions of @xcite were the introduction of annotated program clauses and goals ( later generalized to a much more expressive framework in @xcite ) , as well as goal solving procedures more convenient and powerful than those given in @xcite .",
    "a more recent line of research is _ similarity - based logic programming _ ( briefly , @xmath0 ) as presented in @xcite and previous related works such as @xcite .",
    "this approach also uses the lattice @xmath14 $ ] to deal with uncertainty in the spirit of fuzzy logic .",
    "in contrast to approaches based on annotated clauses , programs in @xmath0 are just sets of definite horn clauses as in classical @xmath1 . however ,",
    "a _ similarity relation _",
    "@xmath2 ( roughly , the fuzzy analog of an equivalence relation ) between predicate and function symbols is used to enable the unification terms that would be not unifiable in the classical sense , measured by some degree @xmath15 $ ] .",
    "there are different proposals for the operational semantics of @xmath0 programs .",
    "one possibility is to apply classical @xmath16 resolution w.r.t . a transformation of the original program @xcite .",
    "alternatively , a @xmath2-based @xmath16-resolution procedure relying on @xmath2-unification can be applied w.r.t . to the original program , as proposed in @xcite .",
    "propositions 7.1 and 7.2 in @xcite state a correspondence between the answers computed by @xmath2-based @xmath16 resolution w.r.t . a given logic program @xmath17 and the answers computed by classical @xmath16 resolution w.r.t .",
    "the two transformed programs @xmath18 ( built by adding to @xmath17 new clauses @xmath2-similar to those in @xmath17 up to the degree @xmath15 $ ] ) and @xmath19 ( built by replacing all the function and predicate symbols in @xmath17 by new symbols that represent equivalence classes modulo @xmath2-similarity up to @xmath20 ) . the @xmath21 system @xcite has been developed to implement @xmath0 and to support applications related to flexible information retrieval from the web .",
    "the aim of the present paper is to show that similarity - based reasoning can be expressed in @xmath3 , a programming scheme for _ qualified _ @xmath1 over a parametrically given _ qualification domain _",
    "@xmath4 recently presented in @xcite as a generalization and improvement of the classical approach by van emden @xcite to @xmath22 @xmath1 .",
    "qualification domains are lattices satisfying certain natural axioms .",
    "they include the lattice @xmath14 $ ] used both in @xcite and in @xcite , as well as other lattices whose elements can be used to qualify logical assertions by measuring their closeness to different kinds of users expectations .",
    "programs in @xmath3 use @xmath4-attenuated clauses of the form @xmath6 where @xmath7 is an atom , @xmath8 a finite conjunction of atoms and @xmath23 is the _ attenuation value _ attached to the clause s implication , used to propagate to the head the _ qualification value _",
    "@xmath24 , where @xmath11 is the infimum in @xmath4 of the qualification values @xmath25 previously computed for the various atoms occurring in the body , and @xmath26 is an _ attenuation operator _ coming with @xmath4 . as reported in @xcite , the classical results in @xmath1 concerning the existence of least herbrand models of programs and the soundness and completeness of the @xmath16 resolution procedure ( see e.g.@xcite ) have been extended to the @xmath3 scheme , and potentially useful instances of the scheme have been implemented on top of the _ constraint functional logic programming _",
    "( @xmath27 ) system @xmath28 @xcite .",
    "the results presented in this paper can be summarized as follows : we consider generalized similarity relations over a set @xmath29 as mappings @xmath30 taking values in the carrier set @xmath31 of an arbitrarily given qualification domain @xmath4 , and we extend @xmath3 to a more expressive scheme @xmath5 with two parameters for programming modulo @xmath2-similarity with @xmath4-attenuated horn clauses .",
    "we present a declarative semantics for @xmath5 and a program transformation mapping each @xmath5 program @xmath17 into a @xmath3 program @xmath32 whose least herbrand model corresponds to that of @xmath17 .",
    "roughly , @xmath32 is built adding to @xmath17 new clauses obtained from the original clauses in @xmath17 by computing various new heads @xmath2-similar to a linearized version of the original head , adding also @xmath2-similarity conditions @xmath33 to the body and suitable clauses for the new predicate @xmath34 to emulate @xmath2-based unification .",
    "thanks to the @xmath32 transformation , the sound and complete procedure for solving goals in @xmath3 by @xmath4-qualified @xmath16 resolution and its implementation in the @xmath28 system @xcite can be used to implement @xmath5 computations , including as a particular case @xmath0 computations in the sense of @xcite .    another recent proposal for reducing the @xmath0 approach in @xcite to a fuzzy @xmath1 paradigm",
    "can be found in @xcite , a paper which relies on the multi - adjoint framework for logic programming ( _ malp _ for short ) previously proposed in @xcite .",
    "_ malp _ is a quite general framework supporting @xmath1 with _ weighted program rules _ over different multi - adjoint lattices , each of which provides a particular choice of operators for implication , conjunction and aggregation of atoms in rule bodies . in comparison to the @xmath3 scheme , the multi - adjoint framework differs in motivation and scope .",
    "multi - adjoint lattices and qualification domains are two different classes of algebraic structures .",
    "concerning declarative and operational semantics , there are also some significant differences between @xmath3 and _ malp_. in particular , _ malp _",
    "s goal solving procedure relies on a costly computation of _ reductant clauses _ , a technique borrowed from @xcite which can be avoided in @xmath3 , as discussed in the concluding section of @xcite .",
    "in spite of these differences , the results in @xcite concerning the emulation of similarity - based can be compared to those in the present paper .",
    "theorem 24 in @xcite shows that every classical logic program @xmath17 can be transformed into a _",
    "program @xmath35 which can be executed using only syntactical unification and emulates the successful computations of @xmath17 using the @xmath16 resolution with @xmath2-based unification introduced in @xcite .",
    "@xmath35 works over a particular multi - adjoint lattice @xmath36 with carrier set @xmath14 $ ] and implication and conjunction operators chosen according to the so - called gdel s semantics @xcite .",
    "@xmath35 also introduces clauses for a binary predicate @xmath34 which emulates @xmath2-based unification , as in our transformation @xmath32 .",
    "nevertheless , @xmath32 is defined for a more general class of programs and uses the @xmath2-similarity predicate @xmath34 only if the source program @xmath17 has some clause whose head is non - linear .",
    "more detailed comparisons between the program transformations @xmath32 , @xmath18 , @xmath19 and @xmath35 will be given in subsection [ sec : ra ] .",
    "the rest of the paper is structured as follows : in section [ domains ] we recall the qualification domains @xmath4 first introduced in @xcite and we define similarity relations @xmath2 over an arbitrary qualification domain . in section [ language ]",
    "we recall the scheme @xmath3 and we introduce its extension @xmath5 with its declarative semantics , given by a logical calculus which characterizes the least herbrand model @xmath37 of each @xmath5 program @xmath17 . in section [ reduction ]",
    "we define the transformation @xmath32 of any given @xmath5 program @xmath17 into a @xmath3 program @xmath32 such that @xmath38 , we give some comparisons to previously known program transformations , and we illustrate the application of @xmath32 to similarity - based computation by means of a simple example . finally , in section [ conclusions ] we summarize conclusions and comparisons to related work and we point to planned lines of future work .",
    "_ qualification domains _ were introduced in @xcite with the aim of using their elements to qualify logical assertions in different ways . in this subsection",
    "we recall their axiomatic definition and some significant examples .",
    "[ defqd ] a _ qualification domain _ is any structure @xmath39 @xmath40 verifying the following requirements :    1 .",
    "@xmath41 is a lattice with extreme points @xmath42 and @xmath43 w.r.t .",
    "the partial ordering @xmath44 . for given elements @xmath45 , we write @xmath46 for the _ greatest lower bound _ ( @xmath47 ) of @xmath48 and @xmath49 and @xmath50 for the _ least upper bound _ ( @xmath51 ) of @xmath48 and @xmath49 .",
    "we also write @xmath52 as abbreviation for @xmath53 .",
    "2 .   @xmath54 , called _ attenuation operation _ , verifies the following axioms : 1 .",
    "@xmath26 is associative , commutative and monotonic w.r.t .",
    "2 .   @xmath55 .",
    "3 .   @xmath56 .",
    "4 .   @xmath57 .",
    "5 .   @xmath58 .    in the rest of the paper",
    ", @xmath4 will generally denote an arbitrary qualification domain . for any finite @xmath59 ,",
    "the @xmath47 of @xmath29 ( noted as @xmath60 ) exists and can be computed as @xmath61 ( which reduces to @xmath43 in the case @xmath62 ) . as an easy consequence of the axioms ,",
    "one gets the identity @xmath63 .",
    "the @xmath3 scheme presented in @xcite supports @xmath1 over a parametrically given qualification domain @xmath4 .",
    "[ somedomains ] some examples of qualification domains are presented below . their intended use for qualifying logical assertions will become more clear in subsection [ qlp ] .    1 .",
    "@xmath64 , where @xmath65 and @xmath66 stand for the two classical truth values _ false _ and _ true _ , @xmath67 is the usual numerical ordering over @xmath68 , and @xmath69 stands for the classical conjunction operation over @xmath68 . attaching @xmath66 to an atomic formula @xmath7",
    "is intended to qualify @xmath7 as ` true ' in the sense of classical @xmath1 .",
    "@xmath70 , where @xmath71 = \\{d \\in { \\mathbb{r}}\\mid 0 \\le d \\le 1\\}$ ] , @xmath72 is the usual numerical ordering , and @xmath73 is the multiplication operation . in this domain ,",
    "the top element @xmath43 is @xmath66 and the greatest lower bound @xmath60 of a finite @xmath74 is the minimum value min(s ) , which is @xmath66 if @xmath75 . attaching an element @xmath76 to an atomic formula @xmath7",
    "is intended to qualify @xmath7 as ` true with certainty degree @xmath77 ' in the spirit of fuzzy logic , as done in the classical paper @xcite by van emden .",
    "the computation of qualifications @xmath77 as certainty degrees in @xmath78 is due to the interpretation of @xmath79 as @xmath80 and @xmath26 as @xmath73 .",
    "@xmath81 , where @xmath82 = \\{d \\in { \\mathbb{r}}\\cup \\{\\infty\\ } \\mid d \\ge 0\\}$ ] , @xmath83 is the reverse of the usual numerical ordering ( with @xmath84 for any @xmath85 ) , and @xmath86 is the addition operation ( with @xmath87 for any @xmath85 ) . in this domain ,",
    "the top element @xmath43 is @xmath65 and the greatest lower bound @xmath60 of a finite @xmath88 is the maximum value max(s ) , which is @xmath65 if @xmath75 . attaching an element @xmath89 to an atomic formula @xmath7",
    "is intended to qualify @xmath7 as ` true with weighted proof depth @xmath48 ' .",
    "the computation of qualifications @xmath48 as weighted proof depths in @xmath90 is due to the interpretation of @xmath79 as @xmath91 and @xmath26 as @xmath86 .",
    "4 .   given 2 qualification domains @xmath92 ( @xmath93 ) , their _ cartesian product _ @xmath94 is @xmath95 , where @xmath96 , the partial ordering @xmath44 is defined as @xmath97 and @xmath98 , @xmath99 , @xmath100 , and the attenuation operator @xmath26 is defined as @xmath101 .",
    "the product of two given qualification domains is always another qualification domain , as proved in @xcite .",
    "intuitively , each value @xmath102 belonging to @xmath94 imposes the qualification @xmath103 _ and also _ the qualification @xmath104 .",
    "for instance , values @xmath105 belonging to @xmath106 impose two qualifications , namely : a certainty degree greater or equal than @xmath77 and a weighted proof depth less or equal than @xmath48 .    for technical reasons that will become apparent in section [ reduction ] , we consider the two structures @xmath107 resp . @xmath108",
    "defined analogously to @xmath78 resp .",
    "@xmath90 , except that @xmath26 behaves as @xmath80 in @xmath107 and as @xmath91 in @xmath108 .",
    "note that almost all the axioms for qualification domains enumerated in definition [ defqd ] hold in @xmath107 and @xmath108 , except that axiom @xmath109 holds only in the relaxed form @xmath110 .",
    "therefore , we will refer to @xmath107 and @xmath108 as _ quasi _ qualification domains .",
    "_ similarity relations _ over a given set @xmath29 have been defined in @xcite and related literature as mappings @xmath111 $ ] that satisfy three axioms analogous to those required for classical equivalence relations .",
    "each value @xmath112 computed by a similarity relation @xmath2 is called the _ similarity degree _ between @xmath113 and @xmath114 . in this paper",
    "we use a natural extension of the definition given in @xcite , allowing elements of an arbitrary qualification domain @xmath4 to serve as similarity degrees . as in @xcite , we are especially interested in similarity relations over sets @xmath29 whose elements are variables and symbols of a given signature .",
    "[ defsr ] let a qualification domain @xmath4 with carrier set @xmath31 and a set @xmath29 be given .    1 .   a _ @xmath4-valued similarity relation _ over @xmath29 is any mapping @xmath30 such that the three following axioms hold for all @xmath115 : 1 .   _ reflexivity : _ @xmath116 .",
    "symmetry : _ @xmath117 .",
    "transitivity : _ @xmath118 .",
    "the mapping @xmath30 defined as @xmath116 for all @xmath119 and @xmath120 for all @xmath121 , @xmath122 is trivially a @xmath4-valued similarity relation called the _",
    "identity_. 3 .",
    "a @xmath4-valued similarity relation @xmath2 over @xmath29 is called _ admissible _ iff @xmath123 ( where the three mutually disjoint sets @xmath124 , @xmath125 and @xmath126 stand for a countably infinite collection of _ variables _ , a set of _ constructor symbols _ and a set of _ predicate symbols _ , respectively ) and the two following requirements are satisfied : 1 .",
    "@xmath2 restricted to @xmath124 behaves as the identity , i.e. @xmath127 for all @xmath128 and @xmath129 for all @xmath130 , @xmath131 .",
    "2 .   @xmath132 holds only if some of the following three cases holds @xmath133 : either @xmath134 are both the same variable ; or else @xmath135 are constructor symbols with the same arity ; or else @xmath136 are predicate symbols with the same arity .",
    "the similarity degrees computed by a @xmath4-valued similarity relation must be interpreted w.r.t",
    ". the intended role of @xmath4-elements as qualification values . for example , let @xmath2 be an admissible similarity relation , and let @xmath137 be two nullary constructor symbols ( i.e. , constants ) . if @xmath2 is @xmath78-valued , then @xmath138 can be interpreted as a _ certainty degree _ for the assertion that @xmath77 and @xmath48 are similar . on the other hand ,",
    "if @xmath2 is @xmath90-valued , then @xmath138 can be interpreted as a _",
    "cost _ to be paid for @xmath77 to play the role of @xmath48 .",
    "these two views are coherent with the different interpretations of the operators @xmath79 and @xmath26 in @xmath78 and @xmath90 , respectively .    in the rest of the paper",
    "we assume that any admissible similarity relation @xmath2 can be extended to act over terms , atoms and clauses .",
    "the extension , also called @xmath2 , can be recursively defined as in @xcite .",
    "the following definition specifies the extension of @xmath2 acting over terms .",
    "the case of atoms and clauses is analogous .",
    "( @xmath2 acting over terms ) .",
    "[ def : er ]    1 .   for @xmath128 and for any term @xmath139 different from @xmath140 : + @xmath127 and @xmath141 .",
    "2 .   for @xmath142 with different arities @xmath143 , @xmath144 : + @xmath145 .",
    "3 .   for @xmath142 with the same arity @xmath143 : + @xmath146 .",
    "in this section we extend our previous scheme @xmath3 to a more expressive scheme called _ similarity - based qualified logic programming _ over @xmath147 abbreviated as @xmath5 which supports both qualification over @xmath4 in the sense of @xcite and @xmath2-based similarity in the sense of @xcite and related research .",
    "subsection [ qlp ] presents a quick review of the main results concerning syntax and declarative semantics of @xmath3 already presented in @xcite , while the extensions needed to conform the new @xmath5 scheme are presented in subsection [ sqlp ] .",
    "@xmath3 was proposed in our previous work @xcite as a generic scheme for qualified logic programming over a given qualification domain @xmath4 . in that scheme , a _ signature _ @xmath148 providing constructor and predicate symbols with given arities is assumed .",
    "_ terms _ are built from constructors and _ variables _ from a countably infinite set @xmath124 ( disjoint from @xmath148 ) and _ atoms _ are of the form @xmath149 ( shortened as @xmath150 or simply @xmath151 ) where @xmath152 is a @xmath143-ary predicate symbol and @xmath153 are terms .",
    "we write @xmath154 , called the _ open herbrand base _ , for the set of all atoms .",
    "a @xmath3 program @xmath17 is a finite set of _",
    "@xmath4-qualified definite horn clauses _ of the form @xmath6 where @xmath7 is an atom , @xmath8 a finite conjunction of atoms and @xmath23 is the _ attenuation value _ attached to the clause s implication .    as explained in @xcite , in our aim to work with qualifications we are not only interested in just proving an atom , but in proving it along with a qualification value .",
    "for this reason , _ @xmath4-qualified atoms _",
    "( @xmath155 where @xmath7 is an atom and @xmath23 ) are introduced to represent the statement that the atom @xmath7 holds for _ at least _ the qualification value @xmath48 . for use in goals to be solved , _ open @xmath4-annotated atoms _",
    "( @xmath156 where @xmath7 is an atom and @xmath157 a _ qualification variable _ intended to take values over @xmath4 ) are also introduced , and a countably infinite set @xmath158 of qualification variables ( disjoint from @xmath124 and @xmath148 ) is postulated .",
    "the _ annotated herbrand base _ over @xmath4 is defined as the set @xmath159 of all @xmath4-qualified atoms .",
    "a _ @xmath4-entailment relation _ over @xmath159 , defined as @xmath160 iff there is some substitution @xmath161 such that @xmath162 and @xmath163 , is used to formally define an _ open herbrand interpretation _ over @xmath4 from now on just an _ interpretation_ as any subset @xmath164 which is closed under @xmath4-entailment .",
    "we write @xmath165 for the family of all interpretations .",
    "the notion of model is such that given any clause @xmath166 in the @xmath3 program @xmath17 , an interpretation @xmath167 is said to be a _ model _ of @xmath168 iff for any substitution @xmath161 and any qualification values @xmath169 such that @xmath170 for all @xmath171 , one has @xmath172 .",
    "the interpretation @xmath167 is also said to be a model of the @xmath3 program @xmath17 ( written as @xmath173 ) iff it happen to be a model of every clause in @xmath17 .    as technique to infer formulas ( or in our case @xmath4-qualified atoms ) from a given @xmath3 program @xmath17 , and following traditional ideas , we consider two alternative ways of formalizing an inference step which goes from the body of a clause to its head : both an interpretation transformer @xmath174 , and a qualified variant of horn logic , noted as @xmath175 , called _ qualified horn logic _ over @xmath4 . as",
    "both methods are equivalent and correctly characterize the least herbrand model of a given program @xmath17 , we will only be recalling the logic @xmath175 , although we encourage the reader to see section 3.2 in @xcite , where the fix - point semantics is explained .",
    "the logic @xmath175 is defined as a deductive system consisting just of one inference rule : @xmath176 , called _",
    "qualified modus ponens _ over @xmath4 . such rule allows us to give the following inference step given that there were some @xmath177 , some substitution @xmath161 such that @xmath162 and @xmath178 for all @xmath171 and some @xmath179 such that @xmath180 : @xmath181 roughly , each @xmath176 inference step using an instance of a program clause @xmath6 has the effect of propagating to the head the _ qualification value _",
    "@xmath24 , where @xmath11 is the infimum in @xmath4 of the qualification values @xmath25 previously computed for the various atoms occurring in the body .",
    "this helps to understand the claims made in example [ somedomains ] above about the intended use of elements of the domains @xmath78 and @xmath90 for qualifying logical assertions .",
    "we use the notations @xmath182 ( resp .",
    "@xmath183 ) to indicate that @xmath155 can be inferred from the clauses in program @xmath17 in finitely many steps ( resp .",
    "@xmath143 steps ) .",
    "the _ least herbrand model of @xmath17 _ happens to be @xmath184 , as proved in @xcite .",
    "[ cols= \" > , < \" , ]     in order to illustrate the use of the transformed program @xmath32 for golving goals w.r.t . the original program @xmath17",
    ", we consider the case where @xmath17 is the @xmath185 program displayed in figure [ fig : example ] .",
    "the transformed program @xmath32 obtained by applying definition [ def : trans ] is shown in figure [ fig : exampletrans ] .",
    "the following observations are useful to understand how the transformation has worked in this simple case :    * the value @xmath43 in the domain @xmath78 corresponds to the real number @xmath66 and hence by reflexivity @xmath186 for any atom in the signature of the program .",
    "therefore , and as a consequence of definition [ def : trans ] , every clause in the original program gives rise to a clause in the transformed program with the same head and with the same body except for a new , first atom @xmath187 .",
    "for instance , clauses 1 , 2 and 3 in figure [ fig : exampletrans ] correspond to the same clause numbers in figure [ fig : example ] .",
    "* apart of the clauses corresponding directly to the original clauses , the program of figure [ fig : exampletrans ] contains new clauses obtained by similarity with some clause heads in the original program .",
    "for instance , lines 4 and 5 are obtained by similarity with clauses at lines 1 and 2 in the original program , respectively . the subindexes at literal @xmath188 correspond to @xmath189 , @xmath190 , respectively .",
    "* analogously , for instance the clause at line 10 ( with head farm(lynx ) ) is obtained by head - similarity with the clause of line 6 in the @xmath185 program ( head domestic(cat ) ) , and the subindex at @xmath188 is obtained from @xmath191 * there is no clause for predicate @xmath34 since all the heads in the original program were already linear and therefore @xmath192 can be left empty in practice . *",
    "the clauses for @xmath188 correspond to the fragment @xmath193 in definition [ def : trans ] .    in the rest of this subsection",
    ", we will show an execution for the goal ` pet(a)#w | w > = 0.50 ` over the program @xmath32 ( see figure [ fig : exampletrans ] ) with the aim of obtaining all those animals that could be considered a ` pet ` for at least a qualification value of @xmath194 .",
    "we are trying this execution in the prototype developed along with @xcite for the instances @xmath195 and @xmath196 .",
    "although this prototype hasnt been released as an integrated part of @xmath28 , you can download the prototype to try this execution .",
    "please notice that the prototype does not automatically do the translation process from a given @xmath5 program @xmath17 to its transformed program @xmath32 , because it was developed mainly for @xcite .",
    "therefore , the transformed program shown in figure [ fig : exampletrans ] has been computed manually .",
    "we will start running @xmath28 and loading the @xmath195 instance with the command ` /qlp(u ) ` :    .... toy > /qlp(u ) ....",
    "this will have the effect of loading the _ real domain constraints library _ and the @xmath195 library into the system , the prompt ` qlp(u ) > ` will appear .",
    "now we have to compile our example program ( assume we have it in a text file called ` animals.qlp ` in ` c:/examples/ ` ) with the command ` /qlptotoy ` ( this command will behave differently based on the actual instance loaded ) .    ....",
    "/qlptotoy(c:/examples / animals ) ....    note that we did nt write the extension of the file because it _ must _ be ` .qlp ` .",
    "this will create the file ` animals.toy ` in the same directory as our former file . and",
    "this one will be an actual @xmath28 program .",
    "we run the program with ` /run(c:/examples / animals ) ` ( again without the extension although this time we are assuming ` .toy ` as extension ) and we should get the following message :    .... process complete ....    and finally we are set to launch our goal with the command ` /qlpgoal ` .",
    "the solutions found for this program and goal are :    .... qlp(u ) > /qlpgoal(pet(a)#w |",
    "w>=0.50 )        { a - > cat ,          w - > 0.5599999999999999 }    sol.1 , more solutions ( y / n / d / a ) [ y ] ?        { a - > cat ,          w - > 0.7200000000000001 }    sol.2 , more solutions ( y / n / d / a ) [ y ] ?        { a - > lynx ,          w - > 0.5760000000000002 }    sol.3 , more solutions ( y / n / d / a ) [ y ] ?        { a - > lynx ,          w - > 0.5760000000000002 }    sol.4 , more solutions ( y / n / d / a ) [ y ] ?",
    "no ....    at this point and if you remember the inference we did in example [ ex : least - model ] for `",
    "pet(lynx)#0.50 ` , we have found a better solution ( as you can see there are two solutions for ` lynx ` , and this is due to the two different ways of proving ` intelligent(lynx ) ` : ` intelligent(lynx)#0.7 ` using clause 19 , and ` intelligent ( lynx)#0.576 ` using clauses 18 and 14 .",
    "similarity - based @xmath1 has been proposed in @xcite and related works to enhance the @xmath1 paradigm with a kind of approximate reasoning which supports flexible information retrieval applications , as argued in @xcite .",
    "this approach keeps the syntax for program clauses as in classical @xmath1 , and supports uncertain reasoning by using a fuzzy similarity relation @xmath2 between symbols in the program s signature .",
    "we have shown that similarity - based @xmath1 as presented in @xcite can be reduced to qualified @xmath1 in the @xmath3 scheme introduced in @xcite , which supports logic programming with attenuated program clauses over a parametrically given domain @xmath4 whose elements qualify logical assertions by measuring their closeness to various users expectations . using generalized similarity relations taking values in the carrier set of an arbitrarily given qualification domain @xmath4",
    ", we have extended @xmath3 to a more expressive scheme @xmath5 with two parameters , for programming modulo @xmath2-similarity with @xmath4-attenuated horn clauses .",
    "we have presented a declarative semantics for @xmath5 programs and a semantics - preserving program transformation which embeds @xmath5 into @xmath3 . as a consequence ,",
    "the sound and complete procedure for solving goals in @xmath3 by @xmath4-qualified @xmath16 resolution and its implementation in the @xmath28 system @xcite can be used to implement @xmath5 computations via the transformation .",
    "our framework is quite general due to the availability of different qualification domains , while the similarity relations proposed in @xcite take fuzzy values in the interval @xmath14 $ ] . in comparison to the multi - adjoint framework proposed in @xcite ,",
    "the @xmath3 and @xmath5 schemes have a different motivation and scope , due to the differences between multi - adjoint algebras and qualification domains as algebraic structures .",
    "in contrast to the goal solving procedure used in the multi - adjoint framework , @xmath4-qualified @xmath16 resolution does not rely on costly computations of reductant clauses and has been efficiently implemented .",
    "as future work , we plan to investigate an extension of the @xmath2-based @xmath16 resolution procedure proposed in @xcite to be used within the @xmath5 scheme , and to develop an extension of this scheme which supports lazy functional programming and constraint programming facilities .",
    "the idea of similarity - based unification has been already applied in @xcite to obtain an extension of _ needed narrowing _ , the main goal solving procedure of functional logic languages . as in the case of @xcite ,",
    "the similarity relations considered in @xcite take fuzzy values in the real interval @xmath14 $ ] .",
    "f. arcelli and f. formato .",
    "likelog : a logic programming language for flexible data retrieval . in _ proceedings of the 1999 acm symposium on applied computing ( sac99 ) _ ,",
    "pages 260 - 267 , new york , ny , usa , 1999 .",
    "acm press .",
    "p. arenas , a.j .",
    "fernndez , a. gil , f.j .",
    "lpez - fraguas , m. rodrguez - artalejo and f. senz - prez .",
    "@xmath197 , a multiparadigm declarative language .",
    "version 2.3.1 , 2007 .",
    "r. caballero and j. snchez ( eds . ) , available at ` http://toy.sourceforge.net ` .",
    "j. medina , m. ojeda - aciego and p. vojt .",
    "multi - adjoint logic programming with continuous semantics . in t.",
    "eiter , w. faber and m. truszczyinski , editors , _ logic programming and non - monotonic reasoning ( lpnmr01 ) _ , volume 2173 of _ lnai _ , pages 351 - 364 .",
    "springer - verlag , 2001 .",
    "j. medina , m. ojeda - aciego and p. vojt . a procedural semantics for multi - adjoint logic programming . in p.",
    "brazdil and a. jorge , editors , _ progress in artificial intelligence ( epia01 ) _ , volume 2258 of _ lnai _ , pages 290 - 297 .",
    "springer - verlag , 2001 .",
    "g. moreno and v. pascual .",
    "programming with fuzzy logic and mathematical functions . in a.p.i .",
    "bloch and a. tettamanzi , editors , _ proceedings of the 6th international workshop on fuzzy logic and applications ( wilf05 ) _ , volume 3849 of _ lnai _ , pages 89 - 98 .",
    "springer - verlag , 2006 .",
    "m. rodrguez - artalejo and c.a .",
    "romero - daz . a generic scheme for qualified logic programming ( technical report sic-1 - 08 ) . technical report , universidad complutense , departamento de sistemas informticos y computacin , madrid , spain , 2008 .",
    "m. rodrguez - artalejo and c.a .",
    "romero - daz . quantitative logic programming revisited . in j. garrigue and m. hermenegildo , editors , _ functional and logic programming ( flops08 ) _ , volume 4989 of _ lncs _ , pages 272 - 288 .",
    "springer - verlag , 2008 .",
    "query processing in quantitative logic programming . in",
    "_ proceedings of the 9th international conference on automated deduction _ ,",
    "volume 310 of _ lncs _ , pages 81 - 100 , london , uk , 1988 .",
    "springer - verlag ."
  ],
  "abstract_text": [
    "<S> _ similarity - based logic programming _ ( briefly , @xmath0 ) has been proposed to enhance the @xmath1 paradigm with a kind of approximate reasoning which supports flexible information retrieval applications . </S>",
    "<S> this approach uses a fuzzy similarity relation @xmath2 between symbols in the program s signature , while keeping the syntax for program clauses as in classical @xmath1 . </S>",
    "<S> another recent proposal is the @xmath3 scheme for _ qualified logic programming _ , an extension of the @xmath1 paradigm which supports approximate reasoning and more . </S>",
    "<S> this approach uses annotated program clauses and a parametrically given domain @xmath4 whose elements qualify logical assertions by measuring their closeness to various users expectations . in this paper </S>",
    "<S> we propose a more expressive scheme @xmath5 which subsumes both @xmath0 and @xmath3 as particular cases . </S>",
    "<S> we also show that @xmath5 programs can be transformed into semantically equivalent @xmath3 programs . as a consequence , </S>",
    "<S> existing @xmath3 implementations can be used to give efficient support for similarity - based reasoning .    </S>",
    "<S> [ constraint and logic languages ] [ algebraic approaches to semantics ]    algorithms , languages , theory    qualification domains , similarity relations </S>"
  ]
}