{
  "article_text": [
    "we study the verification problem for _ parameterized asynchronous shared - memory systems _ @xcite .",
    "these systems consist of a _ leader _ process and arbitrarily many identical _ contributors _ , processes with no identity , running at arbitrary relative speeds.the shared - memory consists of a read / write register that all processes can access to perform either a read operation or a write operation .",
    "the register is bounded : the set of values that can be stored is finite .",
    "read / write operations execute atomically but sequences of operations do not : no process can conduct an atomic sequence of reads and writes while excluding all other processes . in a previous paper @xcite ,",
    "we have studied the complexity of safety verification , which asks to check if a safety property holds no matter how many contributors are present . in a nutshell",
    ", we showed that the problem is conp - complete when both leader and contributors are finite - state automata and pspace - complete when they are pushdown automata .    in this paper",
    "we complete the study of this model by addressing the verification of liveness properties specified as @xmath0-regular languages ( which in particular encompasses ltl model - checking ) . given a property like",
    "`` every request is eventually granted '' and a system with a fixed number of processes , one is often able to guess an upper bound on the maximal number of steps until the request is granted , and replace the property by the safety property `` every request is granted after at most @xmath1 steps . '' in parameterized systems this bound can depend on the ( unbounded ) number of processes , and so reducing liveness to safety , or to finitary reasoning , is not obvious . indeed , for many parameterized models , liveness verification is undecidable even if safety is decidable @xcite .",
    "our results show that there is no large complexity gap between liveness and safety verification : liveness verification ( existence of an infinite computation violating a property ) is np - complete in the finite - state case , and pspace - hard and in nexptime in the pushdown case . in contrast",
    ", remember that liveness checking is already pspace - complete for a _",
    "finite _ number of finite - state machines , and undecidable for a _ fixed _ number of pushdown systems .",
    "thus , not only is liveness verification decidable in the parameterized setting but the complexity of the parameterized problem is _ lower _ than in the non - parameterized case , where all processes are part of the input .",
    "we interpret this as follows : in asynchronous shared - memory systems , the existence of arbitrarily many processes leads to a `` noisy '' environment , in which contributors may hinder progress by replying to past messages from the leader , long after the computation has moved forward to a new phase .",
    "it is known that imperfect communication can _ reduce _ the power of computation and the complexity of verification problems : the best known example are lossy channel systems , for which many verification problems are decidable , while they are undecidable for perfect channels ( see e.g. @xcite ) .",
    "our results reveal another instance of the same phenomenon .",
    "technically , our proof methods are very different from those used for safety verification .",
    "our previous results @xcite relied on a fundamental simulation lemma , inspired by hague s work @xcite , stating that the _ finite _ behaviors of an arbitrary number of contributors can be simulated by a finite number of _ simulators _ , one for each possible value of the register .",
    "unfortunately , the simulation lemma does not extend to infinite behaviors , and so we have to develop new ideas . in the case",
    "in which both leader and contributors are finite - state machines , the np - completeness result is obtained by means of a combination of an abstraction that overapproximates the set of possible infinite behaviors , and a semilinear constraint that allows us to regain precision . the case in which both leader and contributors are pushdown machines is very involved . in a nutshell , we show that pushdown runs in which a parameter called the _ effective stack height _ grows too much can be `` distributed '' into a number of runs with smaller effective stack height .",
    "we then prove that the behaviors of a pushdown machine with a bounded effective stack height can be simulated by an exponentially larger finite - state machine",
    ".    _ related work . _",
    "parameterized verification has been studied extensively , both theoretically and practically .",
    "while very simple variants of the problem are already undecidable @xcite , many non - trivial parameterized models retain decidability .",
    "there is no clear `` rule of thumb '' that allows one to predict what model checking problems are decidable , nor their complexities , other than `` liveness is generally harder than safety . ''",
    "for example , coverability for petri nets  in which finite - state , identityless processes communicate via rendezvous or global shared state is expspace - complete , higher than the pspace - completeness of the non - parameterized version , and verification of liveness properties can be equivalent to petri net reachability , for which we only know non - primitive recursive upper bounds , or even undecidable .",
    "safety verification for extensions to petri nets with reset or transfer , or broadcast protocols , where arbitrarily many finite - state processes communicate through broadcast messages , are non - primitive recursive ; liveness verification is undecidable in all cases @xcite .",
    "thus , our results , which show simultaneously lower complexity than non - parameterized problems , as well as similar complexity for liveness and safety , are quite unexpected .",
    "german and sistla @xcite and aminof _ et al . _",
    "@xcite have studied a parameterized model with rendezvous as communication primitive , where processes are finite - state machines .",
    "model checking the fully symmetrical case  only contributors , no leaders  runs in polynomial time ( other topologies have also been considered @xcite ) , while the asymmetric case with a leader is expspace - complete . in this paper",
    "we study the same problems , but for a shared memory communication primitive .    _ population protocols _",
    "@xcite are another well - studied model of identityless asynchronous finite - state systems communicating via rendezvous .",
    "the semantics of population protocols is given over fair runs , in which every potential interaction that is infinitely often enabled is infinitely often taken . with this semantics ,",
    "population protocols compute exactly the semilinear predicates @xcite . in this paper",
    "we do not study what our model can compute ( in particular , we are agnostic with respect to which fairness assumptions are reasonable ) , but what we can compute or decide about the model .",
    "in this paper , we identify systems with languages .",
    "system actions are modeled as symbols in an alphabet , executions are modeled as infinite words , and the system itself is modeled as the language of its executions .",
    "composition operations that combine systems into larger ones are modeled as operations on languages .",
    "an _ alphabet _ @xmath2 is a finite , non - empty set of _",
    "symbols_. a _ word _ over @xmath2 is a finite sequence over @xmath2 including the empty sequence denoted @xmath3 , and a _ language _ is a set of words",
    "@xmath0-word _ over @xmath2 is an infinite sequence of symbols of @xmath2 , and an _ @xmath0-language _ is a set of @xmath0-words .",
    "we use @xmath4 ( resp .",
    "@xmath5 ) to denote the language of all words ( resp .",
    "@xmath0-words ) over @xmath2 .",
    "when there is no ambiguity , we use `` words '' to refer to words or @xmath0-words .",
    "we do similarly for languages .",
    "let @xmath6 be a sequence over some alphabet , define @xmath7 if @xmath8 is a word ; else ( @xmath6 is an @xmath0-word ) @xmath9 denote the set @xmath10 . elements of @xmath9 are called _",
    "positions_. the _ length _ of a sequence @xmath6 is defined to be @xmath11 and is denoted @xmath12 .",
    "we denote by @xmath13 the symbol of @xmath6 at position @xmath14 if @xmath15 , @xmath3 otherwise .",
    "moreover , let @xmath16 with @xmath17 and @xmath18 denote @xmath19 .",
    "also @xmath20 denotes @xmath21 for words @xmath22 , we say @xmath23 is a _ prefix _ of @xmath24 if either @xmath25 or @xmath26 and there is a @xmath27 such that @xmath28 .    [ [ combining - systems - shuffle . ] ] combining systems : shuffle . + + + + + + + + + + + + + + + + + + + + + + + + + + +    intuitively , the shuffle of systems @xmath29 and @xmath30 is the system interleaving the executions of @xmath29 with those of @xmath30 . given two @xmath0-languages @xmath31 and @xmath32 , their _ shuffle _ , denoted by @xmath33 , is the @xmath0-language over @xmath34 defined as follows .",
    "given two @xmath0-words @xmath35 , we say that @xmath36 is an _ interleaving _ of @xmath37 and @xmath38 if there exist ( possibly empty ) words @xmath39 and @xmath40 such that each @xmath41 is a prefix of @xmath37 , and each @xmath42 is a prefix of @xmath38 , and @xmath43 is an @xmath0-word .",
    "then @xmath44 , where @xmath45 denotes the set of all interleavings of @xmath37 and @xmath38 .",
    "for example , if @xmath46 and @xmath47 , we get @xmath48 .",
    "shuffle is associative and commutative , and so we can write @xmath49 or @xmath50 .    [ [ combining - systems - asynchronous - product . ] ] combining systems : asynchronous product .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the asynchronous product of @xmath31 and @xmath51 also interleaves the executions but , this time , the actions in the common alphabet must now be executed jointly .",
    "the @xmath0-language of the resulting system , called the _ asynchronous product _ of @xmath29 and @xmath30 ,",
    "is denoted by @xmath52 , and defined as follows .",
    "let @xmath53 be the word obtained by erasing from @xmath6 all occurrences of symbols not in @xmath2 .",
    "@xmath54 is the @xmath0-language over the alphabet @xmath55 such that @xmath56 iff @xmath57 and @xmath58 are prefixes of words in @xmath29 and @xmath30 , respectively .",
    "we abuse notation and write @xmath59 instead of @xmath60 when @xmath61 .",
    "for example , let @xmath62 and @xmath63 .",
    "for @xmath64 and @xmath65 we get @xmath66 .",
    "observe that the language @xmath67 depends on @xmath29 , @xmath30 and also on @xmath68 and @xmath69 .",
    "for example , if @xmath70 and @xmath71 , then @xmath72 , but if @xmath73 , then @xmath74 .",
    "so we should more properly write @xmath75 . however , since the alphabets @xmath68 and @xmath69 will be clear from the context , we will omit them .",
    "like shuffle , asynchronous product is also associative and commutative , and so we write @xmath76 .",
    "notice finally that shuffle and asynchronous product coincide if @xmath77 , but usually differ otherwise .",
    "for instance , if @xmath46 and @xmath47 , we get @xmath78 .",
    "we describe systems as combinations of shuffles and asynchronous products , for instance we write @xmath79 . in these expressions",
    "we assume that @xmath80 binds tighter than @xmath81 , and so @xmath82 is the language @xmath83 , and not @xmath84 .",
    "a non - atomic network is an infinite family of systems parameterized by a number @xmath85 .",
    "the @xmath85th element of the family has @xmath86 components communicating through a global store by means of read and write actions .",
    "the store is modeled as an atomic register whose set of possible values is finite .",
    "one of the @xmath86 components is the leader , while the other @xmath85 are the contributors .",
    "all contributors have exactly the same possible behaviors ( they are copies of the same @xmath0-language ) , while the leader may behave differently .",
    "the network is called non - atomic because components can not atomically execute sequences of actions , only one single read or write .    formally , we fix a finite set @xmath87 of _ global values_. a _ read - write alphabet _ is any set of the form @xmath88 , where @xmath89 is a set of _ read _ and _ write ( actions)_. we denote a symbol @xmath90 by @xmath91 and define @xmath92 .",
    "we fix two languages @xmath93 and @xmath94 , called the _ leader _ and the _ contributor _ , with alphabets @xmath95 and @xmath96 , respectively , where @xmath97 are called _ reads _ and @xmath98 are called _",
    "writes_. we write @xmath99 ( respectively , @xmath100 ) to stand for either @xmath101 or @xmath102 ( respectively , @xmath103 or @xmath104 ) .",
    "we further assume that @xmath105 holds for every @xmath106 , else the value @xmath107 is never used and can be removed from @xmath87 .    additionally , we fix an @xmath0-language @xmath108 , called the _ store _ , over @xmath109 .",
    "it models the sequences of read and write operations supported by an atomic register : a write @xmath110 writes @xmath107 to the register , while a read @xmath111 succeeds when the register s current value is @xmath107 .",
    "initially the store is only willing to execute a write .",
    "formally @xmath108 is defined as @xmath112 and any finite prefix thereof .",
    "observe that @xmath108 is completely determined by @xmath113 and @xmath114 .",
    "figure  [ fig : example ] depicts a store with @xmath115 as possible values as the language of a transition system .",
    "\\(a ) ; ( b ) [ above right of = a ] ; ( c ) [ below right of = a ] ; ( a ) edge node[left , font= ] @xmath116 ( b ) ( b ) edge node[left , font= ] @xmath117 ( c ) ( c ) edge node[left , font= ] @xmath118 ( a ) ;    \\(a ) @xmath119 ; ( b ) [ right of = a ] @xmath120 ; ( c ) [ above right of = b , xshift=15 mm ] @xmath121 ; ( d ) [ below right of = b , xshift=15 mm ] @xmath122 ;    \\(a ) edge [ bend left=35 ] node[above , font= ] @xmath123 ( c ) edge node[above , font= ] @xmath124 ( b ) edge [ bend right=35 ] node[below , font= ] @xmath125 ( d ) ( b ) edge [ loop above ] node[above , font= ] @xmath126 ( b ) edge [ bend left=8 ] node[left , pos=0.7,yshift=1 mm , font=]@xmath123 ( c ) edge [ bend left=8 ] node[right , pos=0.5,yshift=1 mm , font=]@xmath125(d ) ( c ) edge [ loop above ] node[left , font= ] @xmath127 ( c ) edge [ bend left=8 ] node[right , pos=0.5,yshift=-1 mm , font=]@xmath124 ( b ) edge [ bend left=8 ] node[right , font=]@xmath125(d ) ( d ) edge [ loop below ] node[left , font= ] @xmath128(d ) edge [ bend left=8 ] node[left , yshift=-1 mm , font=]@xmath124 ( b ) edge [ bend left=8 ] node[left , pos=0.5 , font=]@xmath123(c ) ;    \\(a ) ; ( b ) [ above of = a , xshift= 6 mm ] ; ( c ) [ above of = a , xshift=-6 mm ] ; ( d ) [ right of = a , yshift=5 mm ] ; ( e ) [ right of = a , yshift=-5 mm ] ; ( f ) [ below of = a , xshift = 6 mm ] ; ( g ) [ below of = a , xshift = -6 mm ] ;    \\(a ) edge node[right , pos=0.65 , font= ] @xmath129 ( b ) edge node[above , font= ] @xmath130 ( d ) edge node[right , pos=0.65 , font= ] @xmath131 ( f ) ( b ) edge node[above , font= ] @xmath132 ( c ) ( c ) edge node[left , font= ] @xmath133 ( a ) ( d ) edge node[right , font= ] @xmath133 ( e ) ( e ) edge node[below , font= ] @xmath134 ( a ) ( f ) edge node[below , font= ] @xmath134 ( g ) ( g ) edge node[left , font= ] @xmath132 ( a ) ;    [ def : instancenetwork ] let @xmath135 and @xmath136 be a leader and a contributor , and let @xmath137 .",
    "@xmath85-instance of the @xmath138-network _ is the @xmath0-language  @xmath139  where @xmath140 stands for @xmath141 .",
    "the _ @xmath138-network _",
    "@xmath142 is the @xmath0-language @xmath143 .",
    "we omit the prefix @xmath138 when it is clear from the context .",
    "it follows easily from the properties of shuffle and asynchronous product that @xmath144 , where @xmath145 is an abbreviation of @xmath146 .",
    "next we introduce a notion of _ compatibility _ between a word of the leader and a multiset of words of the contributor ( a multiset because several contributors may execute the same sequence of actions ) .",
    "intuitively , compatibility means that all the words can be interleaved into a legal infinite sequence of reads and writes supported by an atomic register  that is , an infinite sequence belonging to @xmath108 .",
    "formally :    [ def : comprealreachpb ] let @xmath147 , and let @xmath148 be a multiset of words over @xmath149 ( possibly containing multiple copies of a word ) .",
    "we say that @xmath23 is _ compatible _ with @xmath150 iff the @xmath0-language @xmath151 is non - empty .",
    "when @xmath23 and @xmath150 are compatible , there exists a word @xmath152 such that @xmath153 .",
    "we call @xmath154 a _ witness _ of compatibility",
    ".    consider the network with @xmath155 where the leader , store , and contributor languages are given by the infinite paths of the transition systems from figure  [ fig : example ] .",
    "the only @xmath0-word of @xmath156 is @xmath157 and the @xmath0-language of @xmath158 is @xmath159 .",
    "for instance , @xmath160 is compatible with the multiset @xmath150 of @xmath161 @xmath0-words obtained by taking two copies of @xmath162 , @xmath163 and @xmath164 .",
    "the reader may be interested in finding another multiset compatible with @xmath156 and containing only 4 @xmath0-words .",
    "[ [ stuttering - property . ] ] stuttering property .",
    "+ + + + + + + + + + + + + + + + + + + +    intuitively , the stuttering property states that if we take an @xmath0-word of a network @xmath165 and `` stutter '' reads and writes of the contributors , going e.g. from @xmath166 to @xmath167 , the result is again an @xmath0-word of the network .",
    "let @xmath168 be a witness of compatibility of @xmath169 and @xmath170 . pick a set @xmath171 of positions ( viz .",
    "@xmath172 ) such that @xmath173 for each @xmath174 , and pick a number @xmath175 for every @xmath176 .",
    "let @xmath177 be the result of simultaneously replacing each @xmath178 by @xmath179 in @xmath154 .",
    "we have that @xmath180 .",
    "now let @xmath181 , where @xmath182 , @xmath183 , @xmath184 it is easy to see that @xmath185 , and so @xmath23 is compatible with @xmath186 , the multiset consisting of @xmath150 and @xmath187 , and @xmath177 is a witness of compatibility .",
    "an easy consequence of the stuttering property is the _ copycat lemma _  @xcite .",
    "[ lem : extendedmono ] let @xmath169 and let @xmath150 be a multiset of words of @xmath188 . if @xmath23 is compatible with @xmath150 , then @xmath23 is also compatible with @xmath189 for every @xmath190 .",
    "we consider the model checking problem for linear - time properties , that asks , given a network @xmath142 and an @xmath0-regular language @xmath191 , decide whether @xmath192 is non - empty .",
    "we assume @xmath191 is given as a bchi automaton @xmath193 over @xmath113 .",
    "intuitively , @xmath193 is a tester that observes the actions of the leader ; we call this the _ leader model checking problem_. we study the complexity of leader model checking for networks in which the read - write @xmath0-languages @xmath156 and @xmath158 of leader and contributor are generated by an abstract machine , like a finite - state machine ( fsm ) or a pushdown machine ( pdm ) .",
    "( we give formal definitions later . )",
    "more precisely , given two classes of machines ` d ` , ` c ` , we study the model checking problem @xmath194 defined as follows :    machines @xmath195 and @xmath196 , and a bchi automaton @xmath193    is @xmath197 non - empty ?    in the next sections we prove that @xmath198 and @xmath199 are np - complete , while @xmath200 is in nexptime and pspace - hard .",
    "consider the instance of the model checking problem where @xmath156 and @xmath158 are as in figure  [ fig : example ] , and @xmath193 is a bchi automaton recognizing all words over @xmath113 containing infinitely many occurrences of @xmath116 .",
    "since @xmath156 is compatible with a multiset of words of the contributors , @xmath201 is non - empty .",
    "in particular , @xmath202 .",
    "since @xmath203 , we can replace @xmath193 and @xmath204 by a machine @xmath205 with a bchi acceptance condition .",
    "the construction of @xmath205 given @xmath193 and @xmath204 is standard . in what follows , we assume that @xmath204 comes with a bchi acceptance condition and",
    "forget about @xmath193 .",
    "there are two natural variants of the model checking problem , where @xmath206 , i.e. , the alphabet of @xmath193 contains the actions of all contributors , or @xmath207 . in both these variants ,",
    "the automaton a can be used to simulate atomic networks . indeed , if the language of a consists of all sequences of the form @xmath208 , and we design the contributors so that they alternate reads and writes , then the accepting executions are those in which the contributors read a value from the store and write a new value in an atomic step .",
    "so the complexity of the model - checking problem coincides with the complexity for atomic networks ( undecidable for pdms and expspace - complete for fsms ) , and we do not study it further .",
    "we fix some notations . a finite - state machine ( fsm ) @xmath209 over @xmath2 consists of a finite set of states @xmath210 containing an initial state @xmath211 and a transition relation @xmath212 . a word @xmath213 is _ accepted _ by an fsm if there exists a sequence @xmath214 of states such that @xmath215 for all @xmath216 .",
    "we denote by @xmath217 the _ run _ accepting @xmath24 .",
    "a bchi automaton @xmath218 is an fsm @xmath209 together with a set @xmath219 of accepting states .",
    "an @xmath0-word @xmath220 is accepted by a bchi automaton if there is a run @xmath217 such that @xmath221 for infinitely many positions @xmath222 .",
    "the @xmath0-language of a fsm or bchi automaton @xmath193 , denoted by @xmath223 , is the set of @xmath0-words accepted by @xmath193 .    in the rest of the section",
    "we show that @xmath198 is np - complete .",
    "section [ subsec : ts ] defines the infinite transition system associated to a ( ` fsm`,`fsm`)-network . section [ subsec : absts ] introduces an associated finite abstract transition system .",
    "section [ subsec : realiz ] states and proves a lemma ( lemma [ lem : realizability ] ) characterizing the cycles of the abstract transition system that , loosely speaking , can be concretized into infinite executions of the concrete transition system .",
    "membership in np is then proved using the lemma .",
    "np - hardness follows from np - hardness of reachability  @xcite .",
    "we fix a bchi automaton @xmath224 over @xmath113 and an fsm @xmath225 over @xmath114 .",
    "configuration _ is a tuple @xmath226 , where @xmath227 , @xmath228 , and @xmath229 assigns to each state of @xmath230 a natural number .",
    "intuitively , @xmath231 is the current state of @xmath204 ; @xmath107 is a value or the special value @xmath119 , modelling that the store has not been initialized yet , and no process read before some process writes ; finally , @xmath232 is the number of contributors currently at state @xmath233 .",
    "we call @xmath234 a _ population _ of @xmath235 , and write @xmath236 for the _ size _ of @xmath234 .",
    "linear combinations of populations are defined componentwise : for every state @xmath233 , we have @xmath237 .",
    "further , given @xmath233 , we denote by @xmath238 the population @xmath239 if @xmath240 and @xmath241 otherwise , i.e. , the population with one contributor in state @xmath242 and no contributors elsewhere . a configuration is _ accepting _ if the state of @xmath204 is accepting , that is whenever @xmath243 . given a set of populations @xmath244",
    ", we define @xmath245 .",
    "the labelled transition system @xmath246 associated to @xmath201 is defined as follows :    @xmath247 is the set of all configurations , and @xmath248 is the set of initial configurations , given by @xmath249 , where @xmath250 ;    @xmath251 , where    @xmath252 is the set of triples @xmath253 such that @xmath254 is a transition of @xmath204 , viz .",
    "@xmath255 , and one of the following conditions holds :    @xmath256 ; or    @xmath257 , @xmath258 .",
    "@xmath259 is the set of triples @xmath260 such that @xmath261 , and one of the following conditions holds :    @xmath262 , @xmath263 , and @xmath264 ; or    @xmath265 , @xmath263 , @xmath266 , and @xmath264 .",
    "observe that @xmath267 , because the total number of contributors of a population remains constant .",
    "given configurations @xmath268 and @xmath269 , we write @xmath270 if @xmath271 .",
    "we introduce a notation important for lemma [ lem : realizability ] below .",
    "we define @xmath272 .",
    "observe that @xmath273 in cases ( i ) and ( ii ) above , and @xmath274 in cases ( iii ) and ( iv ) .",
    "so @xmath275 depends only on the transition @xmath254 , but not on @xmath234 .",
    "we introduce an _ abstraction function _ @xmath276 that assigns to a set @xmath244 of populations the set of states of @xmath235 populated by @xmath244 .",
    "we also introduce a _ concretization function _ @xmath277 that assigns to a set @xmath278 the set of all populations @xmath234 that only populate states of @xmath210 . formally : @xmath279 it is easy to see that @xmath276 and @xmath277 satisfy @xmath280 and @xmath281 , and so @xmath276 and @xmath277 form a galois connection ( actually , a galois insertion ) . an _ abstract configuration _ is a tuple @xmath282 , where @xmath283 , @xmath228 , and @xmath278 .",
    "we extend @xmath276 and @xmath277 to ( abstract ) configurations in the obvious way .",
    "an abstract configuration is _ accepting _ when the state of @xmath204 is accepting , that is whenever @xmath243 .",
    "given @xmath246 , we define its _ abstraction _ @xmath284",
    "as follows :    @xmath285 is the set of all abstract configurations .",
    "@xmath286 is the initial configuration .",
    "@xmath287 iff there is @xmath288 and @xmath289 such that + @xmath290 and @xmath291 .",
    "observe that the number of abstract configurations is bounded by @xmath292 .",
    "let us point out that our abstract transition system resembles but is different from that of pnueli et al.@xcite .",
    "we write @xmath293 if @xmath294 .",
    "the abstraction satisfies the following properties :    for each @xmath0-path @xmath295 of @xmath296 , there exists an @xmath0-path @xmath297 in @xmath298 such that @xmath299 for all @xmath216 .    if @xmath300 , then @xmath301 . + to prove this claim , consider two cases :    @xmath302 .",
    "then @xmath303 for every population @xmath234 ( because only the leader moves ) .",
    "so @xmath304 .",
    "consider the population @xmath306 .",
    "then @xmath307 , where @xmath308 .",
    "but then @xmath309 , and so @xmath310 , which implies @xmath311 for some @xmath312 .",
    "so in every @xmath0-path @xmath297 of @xmath298 , where @xmath313 , there is an index @xmath14 at which the @xmath314 stabilize , that is , @xmath315 holds for every @xmath316 .",
    "however , the converse of ( a ) does not hold : given a path @xmath297 of @xmath298 , there may be no path @xmath295 in @xmath296 such that @xmath299 for every @xmath317 . consider a contributor machine @xmath230 with two states @xmath318 and one single transition @xmath319 .",
    "then @xmath320 contains the infinite path ( omitting the state of the leader , which plays no role ) : @xmath321 however , the transitions of @xmath296 are of the form @xmath322 , and so @xmath296 has no infinite paths .",
    "we show that the existence of an infinite accepting path in @xmath296 reduces to the existence of a certain lasso path in @xmath320 .",
    "a lasso path consists of a stem and a cycle .",
    "lemma  [ lem : cover ] shows how every abstract finite path ( like the stem ) has a counterpart in @xmath296 .",
    "lemma  [ lem : realizability ] characterizes precisely those cycles in @xmath320 which have an infinite path counterpart in @xmath296 .",
    "let @xmath323 be an abstract configuration of @xmath324 reachable from @xmath325 ( @xmath326 ) .",
    "for every @xmath327 , there exists @xmath328 such that @xmath329 is reachable from @xmath330 and @xmath331 .",
    "[ lem : cover ]    lemma  [ lem : cover ] does not hold for atomic networks . indeed ,",
    "consider a contributor with transitions @xmath332 , where @xmath333 denotes that the read and the write happen in one single atomic step .",
    "then we have ( omitting the state of the leader , which does not play any rle here ) : @xmath334 let @xmath234 be the population putting one contributor in each of @xmath335 .",
    "this population belongs to @xmath336 but no configuration @xmath337 with @xmath338 is reachable from any population that only puts contributors in @xmath211 , no matter how many .",
    "indeed , after the first contributor moves to @xmath339 , no further contributor can follow , and so we can not have contributors simultaneously in both @xmath339 and @xmath340 . on the contrary , in non - atomic networks",
    "the copycat lemma states that what the move by one contributor can always be replicated by arbitrarily many .    we proceed to characterized the cycles of the abstract transition system that can be `` concretized '' .",
    "cycle _ of @xmath298 is a path @xmath341 such that @xmath342 .",
    "a cycle is _ realizable _ if there is an infinite path @xmath343 of @xmath296 such that @xmath344 and @xmath345 for every @xmath316 .",
    "[ lem : realizability ] a cycle @xmath346 of @xmath298 is realizable iff @xmath347 .",
    "[ th : fsafsa ] @xmath198 is np - complete .",
    "np - hardness follows from the np - hardness of reachability @xcite .",
    "we show membership in np with the following high - level nondeterministic algorithm whose correctness relies on lemmas  [ lem : cover ] and [ lem : realizability ] :    1 .",
    "guess a sequence @xmath348 of subsets of @xmath235 such that @xmath349 for all @xmath14 , @xmath350 .",
    "note that @xmath351 .",
    "2 .   compute the set @xmath352 of abstract configurations and the set @xmath353 of abstract transitions between configurations of @xmath354 .",
    "3 .   guess an accepting abstract configuration @xmath355 , that is , an @xmath356 such that @xmath231 is accepting in @xmath204 .",
    "4 .   check that @xmath357 is reachable from the initial abstract configuration @xmath358 by means of abstract transitions of @xmath353 .",
    "5 .   check that the transition system with @xmath354 and @xmath353 as states and transitions contains a cycle @xmath359 such that @xmath360 , @xmath361 and @xmath362 .",
    "we show that the algorithm runs in polynomial time .",
    "first , because the sequence guessed is no longer than @xmath363 , the guess can be done in polynomial time .",
    "next , we give a polynomial algorithm for step ( 5 ) :    compute an fsa of accepting states . ] @xmath364 over the alphabet @xmath365 with @xmath354 as set of states , @xmath353 as set of transitions , @xmath357 as initial state , and @xmath366 as set of final states .",
    "use the polynomial construction of seidl _ et al . _",
    "@xcite to compute an ( existential ) presburger formula @xmath367 for the parikh image of @xmath368 .",
    "the free variables of @xmath367 are in one - to - one correspondence with the transitions of @xmath365 .",
    "denote by @xmath369 the variable corresponding to transition @xmath370 .",
    "compute the formula @xmath371 where @xmath372 and @xmath373 returns",
    "the target and source states of the transition passed in argument .",
    "@xmath374 adds to @xmath367 the realizability condition of lemma [ lem : realizability ] .",
    "check satisfiability of @xmath374 .",
    "this step requires nondterministic polynomial time because satisfiability of an existential presburger formula is in np @xcite .",
    "a pushdown system ( pdm ) @xmath375 over @xmath2 consists of a finite set @xmath210 of states including the initial state @xmath211 , a _ stack alphabet _ @xmath376 including the bottom stack symbol @xmath377 , and a set of _ rules _ @xmath378 which either push or pop as explained below .",
    "pdm - configuration _ @xmath379 consists of a state @xmath380 and a word @xmath381 ( denoting the stack content ) . for @xmath382 , @xmath383 , @xmath384 , @xmath385",
    ", we say a pdm - configuration @xmath386 ( resp .",
    "@xmath387 ) @xmath357-follows @xmath388 if @xmath389 , ( resp .",
    "@xmath390 ) ; we write @xmath391 if @xmath392 @xmath357-follows @xmath379 , and call it a _",
    "transition_. a _ run _",
    "@xmath393 on a word @xmath220 is a sequence of pdm - configurations such that @xmath394 and @xmath395 for all @xmath216 .",
    "we write @xmath396 if there is a run from @xmath268 to @xmath269 .",
    "the language @xmath397 of @xmath398 is the set of all words @xmath399 such that @xmath398 has a run on @xmath24 .",
    "a bchi pdm is a pdm with a set @xmath219 of accepting states .",
    "a word is accepted by a bchi pdm if there is a run on the word for which some state in @xmath400 occurs infinitely often along the pdm - configurations .",
    "the following lemma characterizes accepting runs .",
    "@xcite [ lem : pdacycle ] let @xmath268 be a configuration .",
    "there is an accepting run starting from @xmath268 if there are states @xmath380 , @xmath401 , a stack symbol @xmath402 such that @xmath403 for some @xmath381 and @xmath404 for some @xmath405 .",
    "we now show @xmath406 is decidable , generalizing the proof from section  [ sec : fsafsa ] .",
    "fix a bchi pdm @xmath407 , and a fsm @xmath225 .",
    "configuration _ is a tuple @xmath408 , where @xmath227 , @xmath409 is the stack content , @xmath228 , and @xmath234 is a population .",
    "intuitively , @xmath410 is the pdm - configuration of the leader .",
    "we extend the definitions from section  [ sec : fsafsa ] like accepting configuration in the obvious way .",
    "we define a labeled transition system @xmath411 , where @xmath247 is the set of configurations including the set @xmath412 of initial configurations , and the transition relation @xmath251 , where @xmath259 is as before and @xmath252 is the set of triples @xmath413 such that @xmath254 is a transition ( not a rule ) of @xmath204 , and one of the following conditions holds :    @xmath414 ; or    @xmath415 and @xmath258 .",
    "we define the abstraction @xmath298 of @xmath296 as the obvious generalization of the abstraction in section  [ sec : fsafsa ] .",
    "an accepting path of the ( abstract ) transition system is an infinite path with infinitely many accepting ( abstract ) configurations . as for @xmath416 ,",
    "not every accepting path of the abstract admits a concretization , but we find a realizability condition in terms of linear constraints .",
    "here we use again the polynomial construction of seidl _ et al . _",
    "@xcite mentioned in the proof of theorem [ th : fsafsa ] , this time to compute an ( existential ) presburger formula for the parikh image of a pushdown automaton .",
    "[ th : pdafsa ] @xmath199 is np - complete .",
    "we show how to reduce @xmath200 to @xmath199 .",
    "we first introduce the notion of _ effective stack height _ of a pdm - configuration in a run of a pdm , and define , given a pdm @xmath230 , an fsm @xmath417 that simulates all the runs of @xmath230 of effective stack height @xmath85 .",
    "then we show that , for @xmath418 , where @xmath419 is the size of @xmath230 , the language @xmath420 is empty iff @xmath421 is empty .",
    "consider a run of a pdm that repeatedly pushes symbol on the stack .",
    "the stack height of the configurations is unbounded , but , intuitively , the pdm only uses the topmost stack symbol during the run . to account for this",
    "we define the notion of effective stack height .",
    "let @xmath422 be an infinite run of a pdm on @xmath0-word @xmath24 , where @xmath423 .",
    "the _ dark suffix _ of @xmath424 in @xmath425 , denoted by @xmath426 , is the longest suffix of @xmath427 that is also a proper suffix of @xmath428 for every @xmath316 .",
    "the _ active prefix _ @xmath429 of @xmath427 is the prefix satisfying @xmath430 .",
    "the _ effective stack height _ of @xmath424 in @xmath425 is @xmath431 .",
    "we say that @xmath425 is _",
    "effectively @xmath85-bounded _ ( or simply @xmath85-bounded for the sake of readability ) if every configuration of @xmath425 has an effective stack height of at most @xmath85 .",
    "further , we say that @xmath425 is _ bounded _ if it is @xmath85-bounded for some @xmath432 .",
    "finally , an @xmath0-word of the pdm is _",
    "@xmath85-bounded _ , respectively bounded , if it is the word generated by some @xmath85-bounded , respectively bounded , run ( other runs for the same word may not be bounded ) .",
    "intuitively , the effective stack height measures the actual memory required by the pdm to perform its run .",
    "for example , repeatedly pushing symbols on the stack produces a run with effective stack height 1 . given a position in the run , the elements of the stack that are never popped are those in the longest common suffix of all subsequent stacks .",
    "the first element of that suffix may be read , therefore only the longest _ proper _ suffix is effectively useless , so no configuration along an infinite run has effective stack height @xmath433 .",
    "[ prop : esh1often ] every infinite run of a pdm contains infinitely many positions at which the effective stack height is 1 .",
    "let @xmath434 be any infinite run .",
    "notice that @xmath435 for every @xmath317 , because otherwise the run would not be infinite .",
    "let @xmath247 be the set of positions of the run defined as : @xmath436 iff @xmath437 for every @xmath438 .",
    "observe that @xmath247 is infinite , because the first configuration of minimal stack height , say @xmath439 belongs to it , and so does the first configuration of minimal stack height of the suffix @xmath440 , etc . by construction",
    ", the configuration at every position in @xmath247 has effective stack height @xmath121 .    in a @xmath85-bounded run ,",
    "whenever the stack height exceeds @xmath85 , the @xmath86-th stack symbol will never become the top symbol again , and so it becomes useless .",
    "so , we can construct a finite - state machine @xmath441 recognizing the words of @xmath397 accepted by @xmath85-bounded runs .",
    "given a pdm @xmath442 , the fsm @xmath443 , called the _",
    "@xmath85-restriction of @xmath398 _ , is defined as follows : ( a ) @xmath444 ( a state of @xmath441 consists of a state of @xmath398 and a stack content no longer than @xmath85 ) ; ( b ) @xmath445 is a transition ( not a rule ) of @xmath398 .",
    "[ th : kbounded ] given a pdm @xmath398 , @xmath6 admits a @xmath85-bounded run in @xmath398 iff @xmath446 .",
    "we fix a bchi pdm @xmath204 and a pdm @xmath230 . by theorem",
    "[ th : kbounded ] , in order to reduce @xmath200 to @xmath199 it suffices to prove the following reduction theorem :    [ th : redpdm ] let @xmath447 , where @xmath235 and @xmath448 are the states and stack alphabet of @xmath230 , respectively .",
    "let @xmath449 be the @xmath450-restriction of @xmath230 .",
    "we have : @xmath451 there are pdms @xmath204 , @xmath230 for which @xmath452 holds only for @xmath453",
    ".    theorems [ th : redpdm ] and [ th : pdafsa ] provide an upper bound for @xmath200 .",
    "pspace - hardness of the reachability problem @xcite gives a lower bound .",
    "@xmath200 is in nexptime and pspace - hard . if the contributor is a one counter machine ( with zero - test ) , it is np - complete",
    ".    the proof of theorem  [ th : redpdm ] is very involved . given a run of @xmath204 compatible with a finite multiset of runs of @xmath230 , we construct another run of @xmath204 compatible with a finite multiset of @xmath450-bounded runs of @xmath449 .",
    "( here we extend compatibility to runs : runs are compatible if the words they accept are compatible . )",
    "the proof starts with the distributing lemma , which , loosely speaking , shows how to replace a run of @xmath230 by a multiset of `` smaller '' runs of @xmath230 without the leader `` noticing '' .",
    "after this preliminary result , the first key proof element is the boundedness lemma .",
    "let @xmath454 be an infinite run of @xmath204 compatible with a finite multiset @xmath455 of runs of @xmath230 .",
    "the boundedness lemma states that , for any number @xmath456 , the first @xmath456 steps of @xmath454 are compatible with a ( possibly larger ) multiset @xmath457 of runs of @xmath449 . since the size of @xmath457 may grow with @xmath456 , this lemma does not yet prove theorem  [ th : redpdm ] : it only shows that @xmath454 is compatible with an _ infinite _ multiset of runs of @xmath449 .",
    "this obstacle is overcome in the final step of the proof .",
    "we show that , for a sufficiently large @xmath456 , there are indices @xmath18 such that , not @xmath454 itself , but the run @xmath458 for adequate @xmath14 and @xmath222 is compatible with a _",
    "finite _ multiset of runs of @xmath449 . loosely speaking",
    ", this requires to prove not only that the leader can repeat @xmath459 infinitely often , but also that the runs executed by the instances of @xmath449 while the leader executes @xmath459 can be repeated infinitely often .    _ the distributing lemma .",
    "_ let @xmath460 be a ( finite or infinite ) run of @xmath230 .",
    "let @xmath461 be the pdm - rule of @xmath230 generating the transition @xmath462 .",
    "then @xmath425 is completely determined by @xmath463 and the sequence @xmath464  since @xmath463 is also fixed ( for fixed @xmath230 ) , in the rest of the paper we also sometimes write @xmath465 this notation allows us to speak of @xmath466 , @xmath467 , @xmath468 and @xmath469 .",
    "we say that _ @xmath425 distributes to a multiset @xmath455 of runs of @xmath230 _ if there exists an _ embedding function _ @xmath470 that assigns to each run @xmath471 and to each position @xmath472 a position @xmath473 , and satisfies the following properties :    @xmath474 .",
    "( a rule occurrence in @xmath475 is matched to another occurrence of the same rule in @xmath425 . )",
    "@xmath470 is surjective .",
    "( for every position @xmath476 there is at least one @xmath471 and a position @xmath472 such that @xmath477 , or , informally , @xmath455 `` covers '' @xmath425 . )    if @xmath478 , then @xmath479 .",
    "( so @xmath480 is a scattered subword of @xmath425 . )",
    "[ ex : dist ] let @xmath425 be a run of a pdm @xmath398 . below are two distributions @xmath455 and @xmath481 of @xmath482 . on the left we have @xmath483 , and its embedding function @xmath470 ; on the right @xmath484 , and its function @xmath485 .",
    "@xmath486 @xmath487    ' '' ''    @xmath488 @xmath489    [ lem : distributing ] let @xmath490 , and let @xmath150 be a multiset of words of @xmath491 compatible with @xmath23 .",
    "let @xmath190 and let @xmath425 an accepting run of @xmath24 in @xmath230 that distributes to a multiset @xmath455 of runs of @xmath230 , and let @xmath492 the corresponding multiset of words .",
    "then @xmath493 is also compatible with @xmath23 .",
    "_ the boundedness lemma .",
    "_ we are interested in distributing a multiset of runs of @xmath230 into another multiset with , loosely speaking , `` better '' effective stack height .",
    "fix a run @xmath425 of @xmath230 and a distribution @xmath455 of @xmath425 with embedding function @xmath470 .",
    "in example  [ ex : dist ] , @xmath494 is distributed into @xmath495 , @xmath496 and @xmath497 .",
    "assume @xmath425 is executed by one contributor .",
    "we can replace it by 3 contributors executing @xmath498 , without the rest of the network noticing any difference .",
    "indeed , the three processes can execute @xmath499 immediately after each other , which for the rest of the network is equivalent to the old contributor executing one @xmath499 .",
    "then we replace the execution of @xmath500 by @xmath501 .",
    "we introduce some definitions allowing us to formally describe such facts . given @xmath476 , we denote by @xmath502 the configuration reached by @xmath425 after @xmath85 steps .",
    "we naturally extend this notation to define @xmath503 as the initial configuration .",
    "we denote by @xmath504 the largest position @xmath505 such that @xmath506 ( similarly if none exists , we fix @xmath507 ) .",
    "further , we denote by @xmath508 the configuration reached by @xmath475 after @xmath85 steps of @xmath425 , that is , the configuration reached by @xmath475 after the execution of @xmath509 transitions ; formally , @xmath510 .",
    "[ ex : dist2 ] let @xmath425 , @xmath455 , and @xmath470 as in example  [ ex : dist ] .",
    "assuming that the pdm @xmath398 has one single state @xmath511 , stack symbols @xmath512 such that the three rules @xmath513 and @xmath103 are given by @xmath514 , @xmath515 , and @xmath516 , then we have @xmath517 .",
    "further , @xmath518 , @xmath519 , and @xmath520 . finally ,",
    "@xmath521 , @xmath522 , and @xmath523 .",
    "given @xmath524 and @xmath525 , we say that a distribution @xmath455 of @xmath425 is _ @xmath526-bounded _ if for every @xmath471 and for every @xmath527 , the effective stack height of @xmath528 is bounded by @xmath1 .",
    "further , we say that @xmath455 is _ synchronized _ if for every configuration @xmath529 with effective stack height 1 and for every @xmath471 , @xmath530 ( same control state and same stack content ) , and also has effective stack height 1 . does not necessarily imply that they have the same effective stack height . ]",
    "the boundedness lemma states that there is a constant @xmath450 , depending only on @xmath230 , such that for every run @xmath425 of @xmath230 and for every @xmath524 there is a @xmath531-bounded and synchronized distribution @xmath457 of @xmath425 .",
    "the key of the proof is the following lemma .",
    "[ lem : flattening ] let @xmath532 .",
    "let @xmath425 be a run of @xmath230 and @xmath524 be the first position of @xmath425 such that @xmath533 is not @xmath450-bounded .",
    "then there is a @xmath531-bounded and synchronized distribution of @xmath425 .    _ proof sketch . _",
    "we construct a @xmath531-bounded and synchronized distribution @xmath534 of @xmath425 .",
    "let @xmath535 be the stack content of @xmath536 .",
    "define @xmath537 such that for each @xmath14 , @xmath538 we have @xmath539 and @xmath540 are the configurations immediately after the symbol @xmath541 in @xmath536 is pushed , respectively popped and such that the stack content of each configuration between @xmath542 ( included ) and @xmath543 ( excluded ) equals @xmath544 for some @xmath545 .",
    "we get @xmath546 and @xmath547 for some @xmath548 .",
    "observe that the following holds:@xmath549 .",
    "since @xmath532 , by the pigeonhole principle we find @xmath550 and three indices @xmath551",
    "such that by letting @xmath552 , @xmath553 and @xmath554 , we have : @xmath555\\   ( \\rho)_{{\\overrightarrow{p}}_{j_1 + 1} .. {\\overrightarrow{p}}_{j_2 } } \\ [ q\\alpha w_2 w_1]\\   ( \\rho)_{{\\overrightarrow{p}}_{j_2 + 1} .. {\\overrightarrow{p}}_{j_3 } } \\ [ q\\alpha",
    "w_3 w_2 w_1 ]",
    "\\\\ ( \\rho)_{{\\overrightarrow{p}}_{j_3 + 1} .. {\\overleftarrow{p}}_{j_3 } } \\ [ q'w_3 w_2 w_1]\\   ( \\rho)_{{\\overleftarrow{p}}_{j_3 + 1} .. {\\overleftarrow{p}}_{j_2 } } \\ [ q ' w_2 w_1]\\   ( \\rho)_{{\\overleftarrow{p}}_{j_2 + 1} .. {\\overleftarrow{p}}_{j_1 } } \\ [ q ' w_1]\\   ( \\rho)_{{\\overleftarrow{p}}_{j_1 + 1} .. \\infty}\\enspace .\\end{gathered}\\ ] ] here , the notation indicates that we reach configuration @xmath556 $ ] after @xmath557 , the configuration @xmath558 $ ] after @xmath559 , etc .",
    "now define @xmath560 from @xmath425 by simultaneously deleting @xmath561 and @xmath562 .",
    "we similarly define @xmath563 by deleting @xmath564 and @xmath565 .",
    "the following shows that @xmath560 defines a legal run since it is given by @xmath566\\   ( \\rho)_{{\\overrightarrow{p}}_{j_2 + 1} .. {\\overrightarrow{p}}_{j_3 } } \\ [ q\\alpha w_3 w_1 ] \\\\",
    "( \\rho)_{{\\overrightarrow{p}}_{j_3 + 1} .. {\\overleftarrow{p}}_{j_3 } } \\ [ q ' w_3 w_1]\\   ( \\rho)_{{\\overleftarrow{p}}_{j_3 + 1} .. {\\overleftarrow{p}}_{j_2 } } \\ [ q ' w_1]\\   ( \\rho)_{{\\overleftarrow{p}}_{j_1 + 1} .. \\infty}\\enspace .\\ ] ] a similar reasoning holds for @xmath563 .",
    "finally , one can show that @xmath534 is a @xmath531-bounded and synchronized distribution of @xmath425 .",
    "[ lem : z - n - bounded ] let @xmath567 , and let @xmath425 be a run of @xmath230 . for every @xmath524",
    "there is an @xmath531-bounded and synchronized distribution @xmath457 of @xmath425 .",
    "the proof is by induction on @xmath456 .",
    "the distribution @xmath568 is obtained from @xmath569 by distributing each run @xmath475 of @xmath457 to a @xmath570-bounded run ( applying lemma  [ lem : flattening ] ) .    _ proof sketch of theorem  [ th : redpdm ] . _ given a run @xmath454 of @xmath204 compatible with a finite multiset @xmath150 of runs of @xmath230 , we construct another run @xmath571 of @xmath204 , and a multiset @xmath455 of @xmath450-bounded runs of @xmath449 such that @xmath571 and @xmath455 are compatible as well .",
    "we consider only the special case in which @xmath150 has one single element @xmath425 ( and one single copy of it ) .",
    "since @xmath454 is compatible with @xmath425 , we fix a witness @xmath572 such that @xmath573 .",
    "we construct a `` lasso run '' out of @xmath574 of the form @xmath575^{\\omega } $ ] .",
    "it suffices to find two positions in @xmath574 where the content of the store is the same , the corresponding configurations of the leader are the same , and similarly for each contributor ; the fragment between these two positions can be repeated ( is `` pumpable '' )",
    ".    given a position @xmath14 of @xmath574 , let @xmath576 and @xmath577 denote the corresponding positions in @xmath425 and @xmath454",
    ". in @xmath574 defines position @xmath578 in @xmath454 such that @xmath579 , similarly @xmath580 is defined as satisfying @xmath581 . ]",
    "further , for every @xmath456 let @xmath457 be a @xmath582-bounded and synchronized distribution of @xmath425 with embedding function @xmath470 ( which exists by the boundedness lemma ) .",
    "let @xmath583 denote the multiset of configurations reached by the runs of @xmath457 after @xmath14 steps of @xmath574 .",
    "using proposition  [ prop : esh1often ] and that    the store has a finite number of values ,    @xmath457 is @xmath582-bounded , and    there are only finitely many active prefixes of length at most @xmath450 ,    we can apply the pigeonhole principle to find a sufficiently large number @xmath456 and three positions @xmath584 in @xmath574 satisfying the following properties :    the contents of the store at positions @xmath14 and @xmath85 of @xmath574 coincide .    the configurations @xmath585 and @xmath586 of the leader have effective stack height 1 , same topmost stack symbol and same control state .",
    "further , @xmath454 enters and leaves some accepting state between @xmath577 and @xmath587 .",
    "the configuration @xmath588 has effective stack height 1 .    for every configuration of @xmath589",
    "there is a configuration of @xmath590 with the same control state and active prefix , and vice versa .",
    "condition ( 4 ) means that , after removing the dark suffixes , @xmath589 and @xmath590 contain the same pruned configurations , although possibly a different number of times ( same set , different multisets ) .",
    "if we obtain the same multiset , then the fragment of @xmath574 between positions @xmath14 and @xmath85 is pumpable by ( 1 ) and ( 2 ) , and we are done .",
    "otherwise , we use ( 3 ) and the fact that @xmath457 is synchronized ( which had not been used so far ) to obtain a new distribution in which the multisets coincide .",
    "this is achieved by adding new runs to @xmath457 .",
    "10 [ 1]`#1 `    abdulla , p.a . ,",
    "bertrand , n. , rabinovich , a. , schnoebelen , p. : verification of probabilistic systems with faulty communication .",
    "information and computation 202(2 ) , 105228 ( 2005 )    abdulla , p.a . , cerans , k. , jonsson , b. , tsay , y.k . : general decidability theorems for infinite - state systems .",
    "in : lics@xmath59196 . pp .",
    "ieee computer society ( 1996 )    abdulla , p.a . ,",
    "jonsson , b. : verifying programs with unreliable channels .",
    "information and computation 127(2 ) , 91101 ( 1996 )    aminof , b. , kotek , t. , rubin , s. , spegni , f. , veith , h. : parameterized model checking of rendezvous systems . in : concur@xmath59114 : proc .",
    "25th int .  conf .",
    "on concurrency theory .",
    "lncs , vol . 8704 , pp .",
    "springer ( 2014 )    angluin , d. , aspnes , j. , eisenstat , d. , ruppert , e. : the computational power of population protocols . distributed computing 20(4 ) , 279304 ( 2007 )    apt , k.r . ,",
    "kozen , d.c . : limits for automatic verification of finite - state concurrent systems .",
    "information processing letters 22(6 ) , 307  309 ( 1986 )    bouajjani , a. , esparza , j. , maler , o. : reachability analysis of pushdown automata : application to model - checking . in : concur@xmath59197 : proc .",
    "8th int .",
    "on concurrency theory .",
    "lncs , vol . 1243 , pp .",
    "springer ( 1997 )    esparza , j. , finkel , a. , mayr , r. : on the verification of broadcast protocols . in : lics@xmath59199 .",
    "ieee computer society ( 1999 )    esparza , j. , ganty , p. , majumdar , r. : parameterized verification of asynchronous shared - memory systems . in : cav@xmath59113 : proc .",
    "23rd int .  conf . on computer aided verification .",
    "lncs , vol . 8044 , pp .",
    "springer ( 2013 )    german , s.m . ,",
    "sistla , a.p .",
    ": reasoning about systems with many processes .",
    "journal of acm 39(3 ) , 675735 ( 1992 )    grdel , e. : subclasses of presburger arithmetic and the polynomial - time hierarchy .",
    "56 , 289301 ( 1988 )    hague , m. : parameterised pushdown systems with non - atomic writes . in : proc .  of fsttcs@xmath59111 .",
    "lipics , vol .  13 , pp . 457468 .",
    "schloss dagstuhl ( 2011 )    meyer , r. : on boundedness in depth in the pi - calculus . in : in procedings of ifip tcs 2008 .",
    "ifip , vol .",
    "477489 . springer ( 2008 )    pnueli , a. , xu , j. , zuck , l.d .",
    ": liveness with ( 0 , 1 , infty)-counter abstraction . in : cav@xmath59102 : proc .",
    "14th int .",
    "conf .  on computer aided verification .",
    "lncs , vol . 2404 ,",
    "springer ( 2002 )    verma , k.n . ,",
    "seidl , h. , schwentick , t. : on the complexity of equational horn clauses . in : cade@xmath59105 : 20th int .",
    "conf .  on automated deduction .",
    "lncs , vol .",
    "1831 , pp .",
    "337352 . springer ( 2005 )",
    "for the inductive case ( in which the abstract path has @xmath596 transitions ) , let @xmath597 be the last transition of the path , and assume @xmath598 ( in the case @xmath599 we have @xmath600 and the result follows immediately from the induction hypothesis ) .",
    "let @xmath601 and @xmath602 be the source and target state of @xmath254 , respectively .",
    "it follows from the definition of @xmath603 that : @xmath604 by ( b ) and we have @xmath605 . if @xmath606 then we again get @xmath600 , and the result follows from the induction hypothesis .",
    "so assume @xmath607 .",
    "given an arbitrary population @xmath327 , let @xmath608 and consider the population @xmath609 .",
    "we have @xmath610 , and so @xmath611 . by induction hypothesis",
    ", there exists @xmath612 such that @xmath613 and @xmath614 is reachable from @xmath615 in @xmath296 . since @xmath616 ,",
    "the mapping @xmath617 is non - negative , and therefore a population .",
    "now let @xmath618 contributors of @xmath619 execute @xmath620 ( which is always possible in a non - atomic network ) .",
    "we then have @xmath621 and we are done .",
    "( @xmath622 ) assume the cycle is realizable .",
    "then there is an infinite path @xmath295 of @xmath296 such that @xmath623 and @xmath624 for every @xmath625 , and the transitions match .",
    "let @xmath626 be the population of @xmath424 .",
    "since the number of contributors of a population remains constant across transitions , we have @xmath627 for every @xmath317 . since there are only finitely many different populations of a given size , by the pigeonhole principle there exist @xmath628 such that @xmath629 . since @xmath630 we get @xmath347 .",
    "( @xmath631 ) let @xmath632 for every @xmath633 .",
    "by ( b ) we have @xmath634 , and so all the @xmath314 are equal to @xmath635 .",
    "let @xmath636 and let @xmath637 for every @xmath638 .",
    "then @xmath626 is a population for every @xmath633 , since @xmath639 .",
    "moreover @xmath640 is a path of @xmath296 and , since @xmath347 , we have @xmath641 . so @xmath642 is a cycle of @xmath296 that can be iterated arbitrarily often , which implies that @xmath346 is realizable .",
    "* soundness . *",
    "the algorithm clearly computes a cycle of @xmath298 satisfying the assumptions of lemma  [ lem : realizability ] .",
    "so the cycle is realizable .",
    "let @xmath643 be the realization of the cycle , and let @xmath644 . since @xmath645 is reachable from the initial abstract configuration , by lemma  [ lem : cover ] there exists a configuration @xmath646 reachable from @xmath330 such that @xmath647 .",
    "so the sequence @xmath648 can also be executed from @xmath649 .",
    "since the cycle visits some accepting state @xmath650 infinitely often , @xmath296 has an accepting path .    *",
    "* let @xmath295 be an @xmath0-path of @xmath296 on which the bchi automaton accepts .",
    "since the number of contributors in the populations of the path stays constant , there exist , by the pigeonhole principle , two positions @xmath651 such that @xmath652 , and they are accepting . clearly , we have @xmath653 , hence @xmath654 is also an accepting @xmath0-path of",
    "_ ts_. by ( a ) the path has a counterpart in the abstraction @xmath298 , that is , there exists an @xmath0-path @xmath655 in @xmath298 such that @xmath299 for all @xmath216 .",
    "notice that        and so the abstract path is also accepting . for each @xmath216 , let @xmath313 .",
    "we know from ( b ) that @xmath657 , and so there is a sequence @xmath658 such that for every @xmath317 we have @xmath659 for some @xmath660 .",
    "it follows that every abstract configuration of the path belongs to the set @xmath661 , and every transition to the set @xmath662 .",
    "let @xmath14 after which the @xmath314 stabilize , that is , @xmath315 holds for every @xmath316 .",
    "therefore , there exist numbers @xmath663 such that @xmath664 and some abstract configuration between @xmath656 and @xmath665 is accepting .",
    "so the transition system with @xmath661 as states and @xmath662 as transitions contains a configuration @xmath357 reachable from the initial abstract configuration , and a cycle starting and ending at @xmath357",
    ".    * hardness . *",
    "np - hardness follows from the np - hardness of the safety problem  @xcite , which asks given a finite - state machine @xmath204 for the leader @xmath156 and @xmath230 for the contributor @xmath158both of which are languages of finite words  whether there exists a word of the @xmath666-network @xmath142 that ends with an occurrence of @xmath667 .",
    "we say that @xmath142 is _ safe _ iff it contains no such word .",
    "remark that , for the safety problem , @xmath158 is assumed to be prefix - closed , hence every state of @xmath230 is accepting .",
    "also , we assume without loss of generality that every word of @xmath156 ends with @xmath667 .",
    "the reduction goes as follows , given an instance of the safety problem turn @xmath156 into a @xmath0-language by appending it @xmath668 .",
    "we also turn @xmath158 into a @xmath0-language by appending it @xmath669 where @xmath670 is the corrupted value nobody else can read . at the machine level",
    "this is done by adding to each accepting state of @xmath204 a selfloop labeled with action @xmath671 and interpreting @xmath156 as a bchi automaton . on the other hand",
    "since @xmath158 is prefix closed we have that all its states are accepting .",
    "we turn @xmath230 into a fsm by dropping @xmath400the set of accepting states  and by adding a self - loop labelled @xmath672 to each state .",
    "this concludes the hardness proof .",
    "hardness follows from the np - hardness for @xmath198 .",
    "the non - deterministic polynomial time algorithm is essentially the same as that of theorem  [ th : fsafsa ] , except that we have pushdown systems instead of finite - state systems .",
    "as before , we guess a sequence @xmath348 of subsets of @xmath235 such that @xmath349 for all @xmath14 , @xmath673 .",
    "we construct a bchi pdm whose states @xmath354 are abstract configurations @xmath674 , whose stack alphabet is @xmath675 , whose initial state is @xmath676 , whose accepting states are accepting abstract configurations ( i.e. where @xmath193 is accepting ) , and whose transitions are defined to mimic @xmath298 .",
    "next , we guess an abstract configuration @xmath242 and a stack symbol @xmath277 .",
    "we check if there is a word that takes @xmath677 to @xmath678 for some @xmath409 .",
    "this check is equivalent to pushdown reachability and can be performed in polynomial time  @xcite .",
    "we construct a pda of accepting states . ] @xmath679 over finite words that accepts a word @xmath680 if there is a run on @xmath23 from the starting configuration @xmath681 to a configuration @xmath682 for some @xmath683 that passes through an accepting abstract configuration .",
    "the pda @xmath679 can be computed in polynomial time .    finally , we check if there is a word accepted by the pushdown automaton whose `` weight '' is @xmath684 . for this check , as before ,",
    "we compute an ( existential ) presburger formula @xmath367 for the parikh image of @xmath685",
    ". the free variables of @xmath367 are in one - to - one correspondence with the transitions of the automaton .",
    "we thus adopt the convention that @xmath369 denotes the variable corresponding to transition @xmath370 .",
    "we compute @xmath374 by adding @xmath363 variables and @xmath363 constraints , one per state in @xmath686 : @xmath687 where @xmath688 and @xmath689 returns the target and source states of the transition passed in argument .",
    "add also the constraints @xmath690 to prevent @xmath684 to be returned as a trivial solution . finally , we check satisfiability of @xmath374 and accept if @xmath374 is satisfiable .",
    "this step is in np because satisfiability of an existential presburger formula is in np @xcite .    to see that the algorithm is sound , notice that the algorithm accepts if there is a ( pushdown ) lasso such that the cyclic part has @xmath684 weight . for an initial population that is large enough ( essentially , cubic in the size of the pdm )",
    ", we can execute the operations on the path to the lasso and then execute the cycle to come back to the same configuration as the starting point of the lasso .",
    "this lasso can be pumped infinitely often to produce an accepting run of the bchi pdm .    for completeness",
    ", we use lemma  [ lem : pdacycle ] to deduce that from an accepting run of the bchi pdm , we can find a lasso - shaped path as defined above . by a similar pigeonhole argument as that of lemma  [ lem : realizability ]",
    ", we conclude that we can find a cyclic path whose weight is @xmath684 .",
    "we first prove that if @xmath24 admits an effectively @xmath85-bounded run @xmath425 in @xmath398 then @xmath6 also admits a run in @xmath441 .",
    "let @xmath691 , and let @xmath692 , resp .",
    "@xmath693 , denote the active prefix , resp .",
    "dark suffix , of @xmath427 .",
    "recall that a state of @xmath441 is a pair @xmath694 , where @xmath242 is a state of @xmath398 and @xmath154 is a non - empty stack content of length at most @xmath85 .",
    "we define @xmath698 .",
    "observe that @xmath699 and @xmath700 , therefore the initial state of @xmath441 is in the desired form .",
    "for the definition of @xmath701 , assuming that @xmath696 is already defined , we consider three cases :    the transition @xmath702 pops a symbol @xmath277 .",
    "+ then @xmath703 is a transition of @xmath398 for every @xmath24 , and so , in particular , @xmath704 is a transition of @xmath398 .",
    "moreover , by the definition of an active prefix , we have @xmath705 and thus @xmath706 therefore @xmath696 is also a prefix of @xmath707 . by induction hypothesis , @xmath708 , which implies @xmath709 . setting @xmath701 to be @xmath696",
    "we thus obtain that @xmath710 and finally that @xmath697 is a transition of @xmath441 .",
    "the transition @xmath702 pushes a symbol @xmath277 , and @xmath711 .",
    "+ then @xmath712 is a transition of @xmath398 . since @xmath711",
    ", we have @xmath713 , hence @xmath714 is also a transition of @xmath441 . if @xmath277 is popped later on , then @xmath715 ; so @xmath716 is a transition of @xmath398 , and we set @xmath701 to @xmath696 . if @xmath277 is never popped , then @xmath717 , and we let @xmath701 to be @xmath718 . in both cases , we find that @xmath719 and hence that @xmath720 is a transition of @xmath441 .",
    "the transition @xmath702 pushes a symbol @xmath277 , and @xmath721 .",
    "+ then @xmath722 is a transition of @xmath398 . observe that since @xmath721 we have @xmath723 .",
    "first we show that @xmath724 , if @xmath725 , then @xmath726 , and more importantly @xmath693 is the largest proper suffix of all the @xmath727 , and since @xmath427 is a proper suffix of @xmath728 , @xmath693 is also the largest proper suffix of all the @xmath729 , therefore @xmath730 , so @xmath731 contradicting the hypothesis that the run is effectively @xmath85-bounded .",
    "we can therefore write @xmath732 . since @xmath733 , @xmath734 is a transition of @xmath441 .",
    "if @xmath277 is popped later on , then @xmath715 and @xmath735 .",
    "if @xmath277 is never popped , then @xmath717 , and @xmath736 . in both cases we conclude that @xmath719 , hence that @xmath720 is a transition of @xmath441 .",
    "now we show that if @xmath24 admits a run in @xmath441 , then it admits an effectively @xmath85-bounded run @xmath475 in @xmath398 .",
    "let @xmath737 be a run of @xmath441 for @xmath24 such that @xmath738 for every @xmath317 .",
    "we inductively construct @xmath739 such that @xmath740 is a run of @xmath398 satisfying the following invariant : @xmath741    we start by defining @xmath742 , which trivially satisfies  .",
    "assume @xmath743 is a run of @xmath398 satisfying  , and consider the transition @xmath744 of @xmath441 .",
    "by the definition of the transitions of @xmath441 , there are two possible cases :        the induction is concluded , now we explain the meaning of equation .",
    "first remark that performing a telescope sum , we obtain that for any @xmath755 , @xmath756 . since @xmath757 and @xmath758 , we obtain @xmath759 .",
    "informally it means that the number of symbols in the stack at any position after @xmath14 ca nt be much smaller ( much meaning @xmath85 ) than at position @xmath14 .",
    "thus , at every position @xmath14 , we never eventually pop the @xmath85 top symbols of the stack at that position , as this would yield a configuration after @xmath14 whose stack would be too small and contradict the inequality . therefore the run @xmath475 is effectively @xmath85-bounded .    since @xmath23 is compatible with @xmath150 ,",
    "there exists a witness @xmath760 such that @xmath761 .",
    "since @xmath762 , we have @xmath763 , and so @xmath764 .",
    "therefore there exists an interleaving function , i.e. a bijection @xmath765 , that assigns to each position in each word in @xmath766 a corresponding position in @xmath154 with the same action .",
    "further , the interleaving function satisfies @xmath767 iff @xmath768 .",
    "we have to show that , given @xmath190 , a run @xmath425 of @xmath230 accepting a word @xmath24 , and a distribution @xmath455 of @xmath779 accepting a multiset @xmath492 of words , then @xmath493 is compatible with @xmath23 .",
    "let @xmath470 be the embedding function of the distribution @xmath455 .",
    "we construct a word @xmath177 witnessing that @xmath23 and @xmath493 are compatible .",
    "the word @xmath177 is a stuttering of @xmath154 , that is , it is obtained from @xmath154 by repeating some letters of @xmath154 ; since , by definition of the store , @xmath108 is closed under stuttering , we have @xmath180 .",
    "let @xmath780 , and let @xmath14 be a position of @xmath154 such that @xmath781 for some @xmath782 ( so , loosely speaking , position @xmath222 in the interleaving @xmath154 comes from the word @xmath783 ) .",
    "further , let @xmath85 be the number of runs in @xmath455 such that some position in them is mapped to position @xmath222 by the embedding function @xmath470 ( intuitively , @xmath85 is the number of runs in @xmath455 executing the action at position @xmath222",
    ". then we replace @xmath656 by @xmath784 ( that is , by the word @xmath785 of length @xmath85 ) .          before proving lemma  [",
    "lem : flattening ] and the boundedness lemma we give an example of two distributions of a finite run that decrease the effective stack height , one of them being moreover synchronized .",
    "[ ex : dist3 ] consider the two distributions @xmath455 and @xmath481 of @xmath790 in example  [ ex : dist ] .",
    "further assume that the pdm @xmath398 has one single state @xmath511 , stack symbols @xmath512 such that the three rules @xmath513 and @xmath103 are given by @xmath514 , @xmath515 , and @xmath516 .",
    "figure  [ fig : moredist ] graphically depicts the stack contents of the configurations of the runs ( the control state is always @xmath511 ) , and their respective effective stack heights .",
    "we observe that @xmath425 is effectively @xmath792-bounded .",
    "the distribution @xmath455 is @xmath793-bounded for every @xmath794 , because the configurations @xmath795 have effective stack height at most @xmath120 for every @xmath796 and every @xmath797 .",
    "the distribution is not synchronized .",
    "indeed , the configuration @xmath798 has effective stack height 1 , but @xmath799 .",
    "the distribution @xmath481 is @xmath800-bounded for every @xmath794 and synchronized .",
    "remark that in each of @xmath801 at positions @xmath802 and @xmath803 ( the only two positions at which @xmath425 has effective stack height @xmath121 ) , the stack content is @xmath377 thus effective stack height is 1 .    for convenience ,",
    "when we want to denote that , say , in a run @xmath425 the configurations reached after @xmath804 and @xmath805 are @xmath268 and @xmath269 , we write @xmath806\\ ( \\rho)_{i+1 .. j}\\ [ c']\\ ( \\rho)_{j+1 .. \\infty}$ ] .    we construct a @xmath531-bounded and synchronized distribution @xmath534 of @xmath425 .",
    "let @xmath535 be the stack content of @xmath536 .",
    "define @xmath537 such that for each @xmath14 , @xmath538 we have @xmath539 and @xmath540 are the configurations immediately after the symbol @xmath541 in @xmath536 is pushed , respectively popped and such that the stack content of each configuration between @xmath542 ( included ) and @xmath543 ( excluded ) equals @xmath544 for some @xmath545 .",
    "we get @xmath546 and @xmath547 for some @xmath548 .",
    "observe that the following holds:@xmath549 .",
    "since @xmath532 , by the pigeonhole principle we find @xmath550 and three indices @xmath551 such that by letting @xmath552 , @xmath553 and @xmath554 , we have : @xmath555\\   ( \\rho)_{{\\overrightarrow{p}}_{j_1 + 1} .. {\\overrightarrow{p}}_{j_2 } } \\ [ q\\alpha w_2 w_1]\\   ( \\rho)_{{\\overrightarrow{p}}_{j_2 + 1} .. {\\overrightarrow{p}}_{j_3 } } \\ [ q\\alpha",
    "w_3 w_2 w_1 ] \\\\ ( \\rho)_{{\\overrightarrow{p}}_{j_3 + 1} .. {\\overleftarrow{p}}_{j_3 } } \\ [ q'w_3 w_2 w_1]\\   ( \\rho)_{{\\overleftarrow{p}}_{j_3 + 1} .. {\\overleftarrow{p}}_{j_2 } } \\ [ q ' w_2 w_1]\\   ( \\rho)_{{\\overleftarrow{p}}_{j_2 + 1} .. {\\overleftarrow{p}}_{j_1 } } \\ [ q ' w_1]\\   ( \\rho)_{{\\overleftarrow{p}}_{j_1 + 1} .. \\infty}\\enspace .\\end{gathered}\\ ] ] now define @xmath560 from @xmath425 by simultaneously deleting @xmath561 and @xmath562 .",
    "we similarly define @xmath563 by deleting @xmath564 and @xmath565 .",
    "the following shows that @xmath560 defines a legal run since it is given by @xmath566\\   ( \\rho)_{{\\overrightarrow{p}}_{j_2 + 1} .. {\\overrightarrow{p}}_{j_3 } } \\ [ q\\alpha w_3 w_1 ] \\\\ ( \\rho)_{{\\overrightarrow{p}}_{j_3 + 1} .. {\\overleftarrow{p}}_{j_3 } } \\ [ q ' w_3 w_1]\\   ( \\rho)_{{\\overleftarrow{p}}_{j_3 + 1} .. {\\overleftarrow{p}}_{j_2 } } \\ [ q ' w_1]\\   ( \\rho)_{{\\overleftarrow{p}}_{j_1 + 1} .. \\infty}\\enspace .\\ ] ] a similar reasoning holds for @xmath563 .",
    "we conclude by proving two claims .",
    "[ [ rho_a - rho_b - is - a - zn - bounded - and - synchronized - distribution - of - rho . ] ] @xmath534 is a @xmath531-bounded and synchronized distribution of @xmath425 .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    since the effective stack height of every configuration of @xmath560 ( resp .",
    "@xmath563 ) up to position @xmath809 ( resp .",
    "@xmath810 ) is at most @xmath450 , the distribution is @xmath531-bounded .",
    "finally , observe that we have @xmath811 for every @xmath812 and every @xmath813 .",
    "since all configurations of @xmath425 of effective stack height 1 are in these two areas , the distribution is synchronized .    in order to prove the boundedness lemma ( lemma  [ lem : z - n - bounded ] )",
    ", we introduce a definition that allows us to `` nest '' distributions ( that is , to distribute a run into several runs , and then distribute one of these runs again into several runs ) , while preserving the properties of synchronization and boundedness .",
    "let @xmath814 be a distribution of @xmath425 .",
    "let @xmath471 , and let @xmath815 be a distribution of @xmath475 .",
    "the _ composition _ of @xmath816 and @xmath817 is the distribution @xmath818 of @xmath425 , where the embedding function @xmath819 is defined as follows :              * @xmath825 .",
    "+ if @xmath826 , then , as @xmath470 is a distribution of @xmath425 , we have @xmath827 . by definition of @xmath819",
    ", we get @xmath828 . if @xmath829 , then , since @xmath485 is a distribution , @xmath830 . since @xmath470 is a distribution @xmath831 .",
    "taking @xmath832 , we get @xmath833 .",
    "so , for every @xmath834 , we finally obtain @xmath825 . * surjectivity . +",
    "if @xmath835 , we first exploit the surjectivity of @xmath470 : either there exists @xmath836 , and some @xmath837 such that @xmath838 ( which means that @xmath839 ) or there is some @xmath840 such that @xmath841 . in the latter case , we then exploit the fact that @xmath842 is a distribution of @xmath475 , and deduce that there exists @xmath843 and @xmath844 such that @xmath845 ; hence we have @xmath846 , and so @xmath839 .",
    "* monotonicity .",
    "+ for every @xmath847 , from the monotonicity of @xmath470 we obtain that @xmath848 for every @xmath478 . if @xmath829 , first we derive from the monotonicity of @xmath485 that @xmath849 holds for every @xmath478 .",
    "then , by monotonicity of @xmath470 , we obtain @xmath850 , and so @xmath848 .",
    "let @xmath454 be a run of @xmath204 , and let @xmath851 be a multiset of runs of @xmath230 compatible with @xmath454 .",
    "let @xmath814 be a @xmath852bounded synchronized distribution of @xmath425 .",
    "for every @xmath471 , let @xmath853 be a @xmath854bounded synchronized distribution of @xmath475 .",
    "then @xmath855 is a @xmath856bounded synchronized distribution of @xmath425 .    by repeated application of lemma  [ lem : nesting ]",
    ", @xmath425 can be distributed to @xmath855 .",
    "let @xmath857 be the corresponding embedding function , obtained also by repeated application of lemma  [ lem : nesting ] .",
    "we have to prove that @xmath858 is a synchronized and @xmath859-bounded distribution .",
    "we have to show that @xmath861 ( which we easily deduce from the fact that @xmath862 .",
    "since @xmath470 is synchronized , we deduce that @xmath863 is the same configuration as @xmath864 and has effective stack height 1 .",
    "since @xmath842 is synchronized , @xmath865 is the same configuration as @xmath866 .",
    "we now prove that @xmath858 is @xmath859-bounded .",
    "again , we pick @xmath867 , and let @xmath475 be the corresponding element of @xmath455 .",
    "we have to show that @xmath868 has effective stack height at most @xmath450 for every @xmath869 .",
    "since @xmath870 , by monotonicity we deduce that @xmath871 and we are done .",
    "the proof is by induction on @xmath456 .",
    "if @xmath872 then @xmath873 , because the first configuration of a run has effective height at most 2 ( if the first rule was a push , and that symbol will be later popped ) . since by definition @xmath874 , we get that @xmath425 is @xmath875-bounded .    for the induction step ,",
    "assume that some distribution @xmath876 of @xmath425 is @xmath877-bounded and synchronized , and let @xmath470 be the embedding function of the distribution . if @xmath876 is also @xmath531-bounded , we take @xmath878 , and we are done .",
    "otherwise , there is @xmath879 such that @xmath880 are effectively @xmath450-bounded , but @xmath881 is not .",
    "informally , this means that the @xmath456-th transition of @xmath425 was distributed to @xmath475 .",
    "let @xmath882 be that position in @xmath475 ; formally @xmath883 ( if no such @xmath882 exists , @xmath884 ) . since @xmath882 is the first position of @xmath475 whose configuration is not @xmath450-bounded , we have that @xmath885 are @xmath450-bounded , but @xmath886 is not .",
    "we apply lemma  [ lem : flattening ] to each such @xmath475 and @xmath882 , and get @xmath887-bounded and synchronized distributions for those @xmath475 : @xmath888 .",
    "let @xmath457 be the distribution obtained by replacing in @xmath876 every bad run @xmath475 by @xmath889 .",
    "then @xmath457 is an @xmath531-bounded and synchronized distribution of @xmath425 .",
    "we build a pdm with @xmath890 states and with stack alphabet @xmath891 $ ] , where @xmath892 are distinct prime numbers . with the @xmath893 first states ,",
    "we build a circuit that pushes the word @xmath894 onto the stack .",
    "after that , the pdm leaves this circuit , and enters another one , consisting of @xmath895 states , that pops @xmath895 stack symbols .",
    "the pdm can only leave this circuit from its first state , and only when @xmath377 is the topmost stack symbol ; if and when this condition holds , the pdm moves to the last state , from where it writes victory in the store . it should be clear that , in order to reach the last state , the stack of the pdm must reach a height of at least @xmath896 symbols .",
    "therefore , no run reaching the last state can be distributed into runs exhibiting a lower effective stack height .",
    "we now show that we can further improve this example so as to show that a single instance of the contributor run in parallel with a special leader may reach the last state , but at least two instances of its @xmath450-restriction are required , for at least one of them reaching that state .",
    "it is possible for the leader to be informed whenever a contributor takes a loop ( once in each loop the contributor informs the leader through the store and pauses until it receives acknowledgment through the store ) .",
    "then the contributor asks permission before entering in the last state .",
    "if the leader only grants permission if he was informed exactly a multiple of @xmath897 times of the entrance of some contributor in some loop , then if there is only one contributor , he may reach the victory state by growing a @xmath898-sized stack , which is too large for its @xmath450-restriction .",
    "therefore a single instance of the @xmath450-restricted contributor does not suffice .",
    "at least two are required for an accepting run .",
    "let @xmath6 be a word of @xmath899 and let @xmath150 a be multiset of words of @xmath230 compatible with @xmath6 .",
    "let @xmath154 be a witness of compatibility , and let @xmath900 be the corresponding interleaving function ( as introduced in the proof of the distributing lemma ) . recall that @xmath154 is an interleaving of @xmath6 and @xmath150 , that @xmath901 is the position of @xmath154 at which we find the @xmath14-th letter of @xmath6 , and that @xmath902 is the position of @xmath154 at which we find the @xmath222-th letter of @xmath24 , for every @xmath190 .      * we find a sequence of positions of @xmath154 corresponding to actions of the leader , such that both the run of the leader and @xmath154 can be pumped between any two such positions .",
    "* we take a position far enough in this sequence , say @xmath903 , and distribute all the runs of @xmath455 into a multiset @xmath904 , such that every run of @xmath904 is @xmath450-bounded up to position @xmath456 .",
    "we show the existence of two positions , say @xmath905 , both smaller than @xmath903 , satisfying the following condition .",
    "take the multisets of configurations of the runs of @xmath904 at positions @xmath247 and @xmath906 , and `` prune '' them by removing their dark suffixes .",
    "let @xmath907 and @xmath908 be the resulting multisets of pruned configurations . then @xmath907 and @xmath908 have the same support ( that is , they contain the same elements , although not necessarily the same number of times ) .",
    "* we show that by adding more runs to @xmath904 , we can obtain a new distribution for which the multisets @xmath907 and @xmath908 not only have the same support , but are equal .",
    "we then show that the runs executed by the leader and by the contributors of this new distribution between positions @xmath247 and @xmath906 can be pumped .",
    "this yields a word @xmath909 ( where @xmath910 is the word executed by the leader between positions @xmath247 and @xmath906 ) compatible with a multiset of words of the form @xmath911 ( where @xmath912 are the runs executed by the contributors between positions @xmath247 and @xmath906 ) , and for which we can find a witness of compatibility of the form @xmath913 , where @xmath914 is an interleaving of @xmath786 and @xmath915 , and @xmath916 is an interleaving of @xmath910 and @xmath917    _ step ( 1 ) . _ since @xmath454 is an infinite run of @xmath204 , by proposition [ prop : esh1often ] it contains infinitely many positions of effective stack height @xmath121 . by the pigeonhole principle , from this sequence of positions we can extract an infinite subsequence of configurations with the same control state and topmost stack symbol .",
    "since @xmath454 is also an accepting run of the bchi automaton @xmath193 , we can further extract from this sequence an infinite subsequence such that between any two positions an accepting state of @xmath193 is visited .",
    "let @xmath918 denote the image of this last infinite sequence by @xmath900 .",
    "that is , @xmath918 denotes the infinite sequence of positions of @xmath154 obtained by the procedure above .    now from @xmath918 we extract a subsequence @xmath919 such that between any two elements of it , every run of @xmath455 reaches a configuration with effective stack height 1 .",
    "more formally , for every @xmath14 and for every @xmath920 , there exists @xmath921 such that @xmath922 has effective stack height 1 and @xmath923 . since , by proposition [ prop : esh1often ] , every run of @xmath455 reaches infinitely often such configurations , @xmath919 exists .",
    "this gives us our sequence of positions in @xmath154 .",
    "_ step ( 2)_. let @xmath924 , and let @xmath925 ( that is , @xmath903 is the position of the @xmath254-th element of the sequence @xmath919 ) . for each run @xmath926 ,",
    "let @xmath927 denote an element of @xmath466 such that @xmath928 . by lemma",
    "[ lem : z - n - bounded ] , we can distribute each run @xmath926 into a @xmath929bounded multiset @xmath930 ( with embedding function @xmath931 ) .    for every @xmath932 ,",
    "let @xmath933 be the largest position of @xmath466 such that @xmath934 , and let @xmath935 be the multiset of configurations of @xmath930 at the position corresponding to @xmath933 .",
    "we denote by @xmath936 the result of removing the dark suffixes of the configurations of @xmath937 ) .",
    "we call the result pruned configurations .",
    "if @xmath938 , then , by the definition of @xmath930 , all the active prefixes of @xmath939 are @xmath450-bounded .",
    "so the pruned configurations of @xmath936 consist of a control state and a stack content of length at most @xmath450 , and therefore the number of possible pruned configurations is bounded by @xmath940 .",
    "it follows that that the number of possible sets ( not multisets ! ) of pruned configurations is strictly smaller than @xmath254 .",
    "so by the pigeonhole principle we find two elements @xmath941 and @xmath942 of the sequence @xmath919 , where @xmath943 , such that @xmath944 and @xmath945 have the same support for every @xmath425 , ( i.e. the sets are equal though the multisets may not be ) .",
    "_ step ( 3 ) .",
    "_ we show how to modify the distributions @xmath930 so that the multisets @xmath944 and @xmath945 not only have same support , but are equal .",
    "observe that , even though the multisets are not equal , they have the same cardinality .",
    "we introduce new runs in the distribution to `` balance '' these multisets .",
    "denote by @xmath276 the common support of @xmath944 and @xmath945 .",
    "for every @xmath946 , we find two runs @xmath947 and @xmath948 in @xmath930 such that @xmath949 and @xmath950 have pruned configuration @xmath357 .",
    "now we define a new distribution of @xmath425 to a multiset @xmath951 with embedding function @xmath952 .",
    "the run @xmath953 is such that the pruned configuration @xmath954 is @xmath357 and @xmath955 is @xmath956 : informally @xmath953 does as @xmath947 up to position @xmath957 , and then as @xmath958 from @xmath959 .",
    "formally , @xmath952 is the same as @xmath931 over each @xmath960 , and @xmath961 when @xmath962 and @xmath963 when @xmath964 . observe that since @xmath965 has effective stack height @xmath121 , it is exactly the same configuration as @xmath966 and @xmath967 .",
    "it is also the same configuration as @xmath968 .",
    "so @xmath953 is a run of @xmath230 , and @xmath952 is a synchronized @xmath969-bounded distribution of @xmath425 . by adding to @xmath930 sufficiently many instances of the appropriate @xmath953 , we obtain a new distribution @xmath970 of @xmath425 , such that the two multisets @xmath944 and @xmath945 are the same .    by the distribution lemma ,",
    "the word @xmath6 is compatible with the words of the runs @xmath971 .",
    "let @xmath574 be a witness of compatibility .",
    "consider the fragment of @xmath574 between the positions corresponding to @xmath941 and @xmath942 in @xmath574 .",
    "the content of the store is the same at these two positions .",
    "also , recall that we chose the @xmath919 so that the projection of the fragment onto the actions of the leader can be repeated infinitely often .",
    "denote by @xmath972 the run of the leader consisting of repeating the subrun between positions corresponding to @xmath941 and @xmath942 .",
    "finally , for each @xmath970 , the multiset of pruned configurations of @xmath970 at positions @xmath941 and @xmath942 is the same , each run in @xmath970 has effective stack height @xmath121 at @xmath941 and @xmath942 , and is @xmath450-bounded on that fragment .",
    "this does not mean that for every run @xmath960 the pruned configuration will be the same at those positions , but that there exists a permutation @xmath973 of @xmath930 such that the pruned configuration of @xmath571 at position @xmath941 is the same as @xmath974 at position @xmath942 . denoting @xmath975",
    ", we get that the multiset @xmath976 is a multiset of @xmath450-bounded runs , that is compatible with @xmath972 .",
    "this concludes the proof ."
  ],
  "abstract_text": [
    "<S> we characterize the complexity of liveness verification for parameterized systems consisting of a leader process and arbitrarily many anonymous and identical contributor processes . </S>",
    "<S> processes communicate through a shared , bounded - value register . while each operation on the register is atomic , there is no synchronization primitive to execute a sequence of operations atomically .    </S>",
    "<S> we analyze the case in which processes are modeled by finite - state machines or pushdown machines and the property is given by a bchi automaton over the alphabet of read and write actions of the leader . </S>",
    "<S> we show that the problem is decidable , and has a surprisingly low complexity : it is np - complete when all processes are finite - state machines , and is pspace - hard and in nexptime when they are pushdown machines . </S>",
    "<S> this complexity is lower than for the non - parameterized case : liveness verification of finitely many finite - state machines is pspace - complete , and undecidable for two pushdown machines .    for finite - state machines , our proofs characterize infinite behaviors using existential abstraction and semilinear constraints . for pushdown machines , </S>",
    "<S> we show how contributor computations of high stack height can be simulated by computations of many contributors , each with low stack height . </S>",
    "<S> together , our results characterize the complexity of verification for parameterized systems under the assumptions of anonymity and asynchrony .    </S>",
    "<S> = 1 = 1 </S>"
  ]
}