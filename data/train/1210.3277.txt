{
  "article_text": [
    "_ dynamic networks _ are widely addressed in distributed computing .",
    "contexts of interest are as varied as fault - tolerance , interaction scheduling , dynamic membership , planned mobility , or unpredictable mobility .",
    "the recent emergence of scenarios where entities are truly mobile and can communicate without infrastructure ( e.g. vehicles , satellites , robots , or pedestrian smartphones ) brought to the fore the most versatile of these environments . in these",
    "_ highly _ dynamic networks , changes are not anomalies but rather integral part of the nature of the system .    the need to categorize and understand highly dynamic networks led the engineering community to design a variety of _ mobility models _ , each of which captures a particular context by means of rules that determine how the nodes move and communicate ( see e.g.  @xcite ) .",
    "a popular example includes the well - known _ random waypoint _ model  @xcite .",
    "the main interest of these models is to be able to reproduce experiments and compare different solutions on a relatively fair basis , thereby providing a common ground to solve practical challenges in highly dynamic networks , e.g.  routing and broadcasting  @xcite .    in the same way as mobility models enable to federate practical investigations in highly dynamic networks , _ logical properties _ on the graph dynamics , that is , _ classes of dynamic graphs _",
    ", have the potential to guide a more formal exploration of their analytical aspects .",
    "a number of special classes were recently identified , for instance graphs in which the nodes interact infinitely often ( _ e.g. , _ uniform random scheduler for _ population protocols _",
    "@xcite ) ; graphs whose dynamics is unrestricted but remains connected at any instant  @xcite ; graphs in which there exists a stable connected spanning subgraph in any t - time window ( _ a.k.a",
    ". t - interval connectivity _ )  @xcite ; graphs whose edges appear or disappear with given probabilities  @xcite ; graphs that have a stable root component  @xcite ; graphs whose schedule is periodic  @xcite or guarantees minimal reachability properties  @xcite",
    ". these classes ( among others ) were characterized within a common formal framework and organized into a hierarchy in  @xcite .    in this paper",
    "we are interested in studying specific relationship between some of these classes , namely three subclasses of those networks called _ delay - tolerant networks _ ( dtns ) , in which instant connectivity is never guaranteed , but still connectivity can be achieved over time and space ( see e.g.  @xcite ) .",
    "these classes are :    * class @xmath0of all graphs whose edges can not disappear forever ( _ recurrent edges _ ) .",
    "that is , if an edge appears once and disappears , then it will eventually re - appear at some unknown ( but finite ) date .",
    "it is not required that all pairs of nodes share an edge , but only that the _ footprint _ of all edges forms a connected graph ( otherwise , even temporal connectivity is not guaranteed ) .",
    "this class corresponds to class  6 in  @xcite . *",
    "class @xmath15 ( for _ bounded - recurrent _ edges ) consisting of those graphs with recurrent edges in which the recurrence time can not exceed a given duration @xmath4 . and",
    "again , the footprint is connected .",
    "this class corresponds to class  7 in  @xcite . *",
    "class @xmath16 ( for _ periodic _ edges ) consisting of those graphs in which all topological events ( appearance or disappearance ) repeat identically modulo some period @xmath5 . and",
    "again , the footprint is connected .",
    "this class corresponds to class  8 in  @xcite .    as far as _ inclusion _",
    "is concerned , it clearly holds that @xmath17 , but what about the _ computational relationship _ between these classes ? considering different types of knowledge , namely the number @xmath3 of nodes in the network , a bound @xmath4 on the recurrence time , and ( any multiple of ) the period @xmath5 , we look at the relationship between @xmath18 , @xmath19 , and @xmath20 , where @xmath21 is the set of problems one can solve in class @xmath22 with knowledge @xmath23 .    the investigation is carried out by studying a fundamental problem in distributed computing : _ broadcast _ with termination detection at the emitter ( or tdb ) ; this problem is also known in the literature with different names ( echo , propagation of information with feedback , etc . ) or context ( synchronizers , etc . ) .",
    "it can have at least three distinct definitions in highly dynamic networks : tdb@xmath24 $ ] , in which the date of delivery is minimized at every node ; tdb@xmath25 $ ] , where the number of hops used by the broadcast is minimized relative to every node ; and tdb@xmath26 $ ] , where the overall duration of the broadcast is minimized ( however late the departure be ) . these three metrics were considered in the seminal work by bui - xuan , ferreira , and jarry @xcite where the authors solved the offline problem of computing all shortest , fastest , and foremost journeys from a given node , given a complete schedule of the network .      in this paper",
    "we examine the feasibility and reusability of the solution ( and to some extent , the complexity ) of tdb@xmath24 $ ] , tdb@xmath25 $ ] , and tdb@xmath26$]in @xmath0 , @xmath1 , @xmath2with knowledge @xmath27 , @xmath3 , or @xmath4 .",
    "we additionally draw some observations from existing results in  @xmath2with knowledge @xmath5  @xcite , that complete our general picture of feasibility and reusability of broadcast in the three classes .",
    "here is a short summary of some of the contributionss .",
    "[ [ feasibility ] ] feasibility : + + + + + + + + + + + +    we first show that none of these problems are solvable in any of the classes unless additional knowledge is considered .",
    "we then establish several results , both positive and negative , on the feasibility of tdb@xmath24 $ ] , tdb@xmath25 $ ] , and tdb@xmath26$]in @xmath0 , @xmath1 , and @xmath2 .",
    "in particular , we prove that knowing @xmath3 makes it possible to solve tdb@xmath24$]in @xmath0 , but this is not sufficient to solve tdb@xmath25$]nor tdb@xmath26 $ ] , even in @xmath1 .",
    "tdb@xmath25$]becomes in turn feasible in @xmath1if @xmath4 is known , but this is not sufficient to solve tdb@xmath26 $ ] ; this later problem becomes solvable in @xmath2knowing @xmath5  @xcite .",
    "these results allow us to show that @xmath28    where @xmath21 denotes the set of problems solvable in every @xmath29 with knowledge @xmath23 .",
    "in other words , the computational relationships between these three contexts form a _ strict _ hierarchy .    in the universe @xmath30 of the classes of dynamic networks with knowledge considered here ,",
    "let @xmath31 denote the fact that @xmath32 is  no more difficult \" than @xmath33 , that is , if @xmath33 is solvable in @xmath34 so is @xmath32 ; and let @xmath35 denote the fact that @xmath32 is  less difficult \" than @xmath33 , that is , @xmath31 and there exists @xmath34 in which @xmath32 is solvable but @xmath33 is not .",
    "our results show the existence of a _ strict _ hierarchy between these problems with respect to _ feasibility _ :    @xmath36}\\xspace}\\prec   { { \\textsc{tdb}}\\ensuremath{[shortest]}\\xspace}\\prec     { { \\textsc{tdb}}\\ensuremath{[fastest]}\\xspace}\\ ] ]    these results are summarized in table [ tab : results - feasibility ] .",
    "[ tab : results - feasibility ]    .",
    "feasibility of broadcast with termination detection , depending on the class of dynamic networks ( @xmath37 ) and of knowledge ( @xmath38 ) .",
    "unfeasibility is denoted by @xmath39 .",
    "the feasibility of fastest in @xmath2 with knowledge @xmath5 ( @xmath40 in table ) is from  @xcite . [ cols=\"^,^,^,^,^\",options=\"header \" , ]",
    "consider a system composed of a finite set of @xmath3 entities @xmath41 ( or nodes ) that interact with each other over a ( possibly infinite ) time span @xmath42 called _ lifetime _ of the system , where @xmath43 is the temporal domain ( typically , @xmath44 or @xmath45 for discrete and continuous - time systems , respectively ) . in this paper",
    "we consider a continuous - time setting with @xmath46 .",
    "following  @xcite , we describe the network as a _ time - varying graph _ ( _ tvg _ , for short ) @xmath47 , where @xmath48 is a set of @xmath49 ( possibly _ intermittent _ ) undirected edges such that @xmath50 @xmath51 and @xmath52 have at least one contact over @xmath53 ; @xmath54 ( _ presence function _ ) indicates whether a given edge is _ present _ at a given time ; and @xmath55 ( _ latency function _ ) , indicates the time it takes to cross a given edge ( _ i.e. , _ send a message ) if starting at a given time . in this paper",
    "we assume @xmath56 to be constant over all edges and dates , and call @xmath56 the _ crossing delay _ ; thus we use the shorthand notations @xmath57 .",
    "we also assume that , for every edge @xmath58 , the union of dates when @xmath59 , is a set of disjoint closed time intervals of length at least @xmath56 . finally , the ( static ) graph formed by @xmath41 and @xmath60 , taken alone , is the _ footprint _ of @xmath61 (",
    "also called _ underlying graph _ or _ interaction graph _ ) . in this work , we do not consider the footprint to be a complete graph in general ( some nodes may never interact ) , but we consider it to be connected .",
    "the tvg formalism essentially encompasses that of _ evolving graphs _",
    "@xcite , where @xmath61 is represented as a sequence of graphs @xmath62 each providing a _ snapshot _ of the system at different times ( which correspond either to discrete steps or given dates ) . in comparison , tvgs offer an _ interaction - centric _ view of the network evolution , where the evolution of each edge can be considered irrespective of the global time sequence .",
    "a graph @xmath63 is said to be _ recurrent _ if none of the edges @xmath60 can disappear forever ; that is , for any date @xmath64 and edge @xmath65 , @xmath66 .",
    "strictly speaking , we do not say that an edge must appear infinitely often because here an edge might also remain present continuously ( and this would satisfy the property ) .",
    "let @xmath67 denote the class of recurrent tvgs whose footprint @xmath68 is _",
    "connected_.    a graph @xmath69 is said to be _ time - bounded recurrent _ ( or simply _ bounded _ ) , if there exists a constant @xmath4 such that , for every edge @xmath70 , the time between two successive appearances of @xmath65 is at most @xmath4 .",
    "we denote by @xmath71 the class of time - bounded recurrent tvgs whose footprint is connected .",
    "a graph is said to be _ periodic _ if there exists a constant @xmath5 such that @xmath72 , @xmath73 for every positive integer @xmath74 ; the smallest such @xmath5 is called the _ period _ of the graph .",
    "we denote by @xmath75 the class of periodic tvgs whose footprint is connected .    given a tvg @xmath57 , we consider that @xmath68 is always simple ( no self - loop nor multiple edges ) and that nodes possess unique identifiers .",
    "the set of edges being incident to a node @xmath51 at time @xmath64 is noted @xmath76 ( or simply @xmath77 , when the node is implicit ) . when an edge @xmath78 appears , the entities @xmath79 and @xmath80 can communicate .",
    "the time @xmath56 necessary to transmit a message ( _ crossing delay _ ) is known to the nodes .",
    "the duration of edge presence is assumed to be at least @xmath56 ( _ i.e. , _ long enough to send a message ) .",
    "algorithmically , this allows the following observations :     + 1 .",
    "if a message is sent just after an edge has appeared , the message is guaranteed to be successfully transmitted .",
    "if the recurrence of an edge is bounded by some @xmath4 , then this edge can not disappear for more than @xmath81 .",
    "[ prop : sendappear ]    the appearance and disappearance of edges are instantly detected by the two adjacent nodes ( they are notified of such an event without delay ) . if a message is sent less than @xmath56 before the disappearance of an edge , it is lost . however , since the disappearance of an edge is detected instantaneously , and the crossing delay @xmath56 is known , the sending node can locally determine whether the message was successfully delivered .",
    "we thus authorize the special primitive @xmath82 as a facility to specify that if the message is lost , then it is automatically re - sent upon next appearance of the edge , and this sending is necessarily successful ( property  [ prop : sendappear ] ) .",
    "note that nothing precludes this primitive to be called while the corresponding edge is even absent ( this actually simplifies the expression of some algorithms ) .",
    "a sequence of couples @xmath83 , with @xmath84 and @xmath85 for all @xmath86 , is called a _ journey _ in @xmath61 iff @xmath87 is a walk in @xmath63 and for all @xmath88 , @xmath89 and @xmath90 for all @xmath91 .",
    "we denote by @xmath92 , and @xmath93 , the starting date @xmath94 and last date @xmath95 of @xmath96 , respectively .",
    "journeys can be thought of as _ paths over time _ from a source node to a destination node ( if the journey is finite ) .",
    "let us denote by @xmath97 the set of all finite journeys in a graph @xmath61 .",
    "we will say that node @xmath51 can reach node @xmath52 in @xmath61 , and note @xmath98 ( or simply @xmath99 , if @xmath61 is clear from the context ) , if there exists at least one possible journey from @xmath51 to @xmath52 in @xmath61 . note that the notion of journey is asymmetrical ( @xmath100 ) , regardless of whether edges are directed or undirected .    because journeys take place _ over time _ , they have both a topological length and a temporal length .",
    "the _ topological length _ of @xmath96 is the number @xmath101 of couples in @xmath96 ( i.e. , number of _ hops _ ) , and its _ temporal length _ is its duration @xmath102 .",
    "this yields two distinct definitions of distance in a graph  @xmath61 :    = .5em    the _ topological distance _ from a node @xmath51 to a node @xmath52 at time @xmath64 , noted @xmath103 , is defined as @xmath104 . for a given date @xmath64 , a journey whose departure is @xmath105 and topological length is equal to @xmath103",
    "is called _ shortest _ ;    the _ temporal distance _ from @xmath51 to @xmath52 at time @xmath64 , denoted by @xmath106 is defined as @xmath107 . given a date @xmath64 , a journey whose departure is @xmath105 and arrival is @xmath108 is called _",
    "; if the set @xmath109 has a minimum , say @xmath110 , any journey whose temporal distance is @xmath110 is called the _",
    "fastest_.    informally , a _",
    "foremost _ journey is one that minimizes the date of arrival at destination ; a _ shortest _ journey is one that uses the least number of hops ; and a _",
    "fastest _ journey is one that minimizes the time spent between departure and arrival ( however late the departure be )  @xcite .",
    "we consider the _ distributed _ problem of performing _ broadcast with termination detection _ at the emitter , or tdb , according to the shortest , fastest , or foremost metrics .",
    "tdbin general requires all nodes to receive a message with some information initially held by a single node @xmath79 , called _ source _ or _",
    "emitter _ , and the source to enter a terminal state after all nodes have received the information , within finite time .",
    "a protocol solves tdbin a graph @xmath61 if it solves it for any source @xmath111 and time @xmath112 .",
    "we say that it solves tdbin a class @xmath113 if it solves tdbfor any @xmath114 .",
    "we are interested in three variations of this problem , following the optimality metrics defined above :    * tdb@xmath24 $ ] , where _ each _ node receives the information at the _ earliest _ possible date following its _ creation _ at the emitter ; * tdb@xmath25 $ ] , where each node receives the information within a minimal number of hops from the emitter ; * tdb@xmath26 $ ] , where the overall duration between first global emission and last global reception is minimized .    for each of these problems , we require that the emitter detects termination , however this detection is not subject to the same optimality constraint ( it just has to be finite ) .",
    "tdbthus involves two processes : the actual dissemination of _ information messages _ , and the exchange of typically smaller _ control messages _",
    "used for termination detection , both being considered separately in this paper .",
    "finally , we call _ broadcast tree _ the hierarchy of nodes and edges along which the broadcast takes place , without consideration to the dates when the edges are used ( _ i.e. _ the footprint of the part of the tvg that is used ) . a broadcast tree is said to be _ reusable _ if the same hierarchy of nodes and edges can be purposedly followed to perform a subsequent optimal ( _ i.e. _ foremost , shortest , or fastest ) broadcast .",
    "let us first state a general property on the computational relationship between the main three contexts of interest , namely knowing @xmath3 in @xmath0(noted @xmath12 ) , knowing @xmath4 in @xmath1(noted @xmath13 ) , and knowing @xmath5 in @xmath2(noted @xmath14 ) .",
    "let @xmath115 denote the set of problems solvable in every @xmath116 with knowledge @xmath23 .",
    "@xmath117 [ th : inclusion ]    the right inclusion is straight from the fact that @xmath118 and @xmath5 is a valid bound @xmath4 on the recurrence time .",
    "the left inclusion follows from the facts that @xmath119 and @xmath3 can be inferred in @xmath1if @xmath4 is already known .",
    "this can be done by performing , from any node ( say @xmath51 ) , a depth - first token circulation that will explore the underlying graph @xmath63 over time . having a bounded recurrence time",
    "indeed allows every node to learn the list of its neighbors in @xmath63 within @xmath4 time ( all incident edges must appear within this duration ) .",
    "as the token is circulated to unvisited nodes , these nodes are marked as visited by @xmath51 s token and the token is incremented . upon returning to @xmath51 ,",
    "the token value is @xmath3 .",
    "these inclusions will be shown strict later on .",
    "we now establish a negative result that justifies the need for additional knowledge in order to solve tdbin any of the considered contexts .",
    "in fact we have :    tdbcannot be solved in @xmath16 without additional knowledge .",
    "[ th : imp1 ]    by contradiction , let @xmath120 be an algorithm that solves tdbin @xmath2 .",
    "consider an arbitrary @xmath121 and @xmath111 .",
    "execute @xmath120 in @xmath61 starting at time @xmath122 with @xmath79 as the source .",
    "let @xmath123 be the time when the source terminates ( and thus all nodes have received the information ) .",
    "let @xmath124 such that @xmath125 , @xmath126 for some @xmath127 , for all @xmath128 , @xmath129 for all @xmath58 and @xmath130 .",
    "now , consider @xmath131 for some @xmath132 , and the period of @xmath133 is some @xmath134 .",
    "consider the execution of @xmath120 in @xmath133 starting at time @xmath122 with @xmath79 as the source . since @xmath135 does not appear from @xmath122 to @xmath123 , the execution of @xmath136 at every node in @xmath133 is exactly as at the corresponding node in @xmath61 .",
    "in particular , node @xmath79 will have entered a terminal state at time @xmath123 with node @xmath52 not having received the information , contradicting the correctness of @xmath120 .",
    "we thus have the following corollary , by inclusion of @xmath2 .",
    "tdbcannot be solved in @xmath1nor @xmath0without any additional knowledge .",
    "[ co : imp2 ]    hence , additional knowledge of some kind is required to solve tdbin these classes .",
    "we consider three types of knowledge , namely , the number of nodes @xmath137 , an upper bound @xmath4 on the recurrence time ( when in @xmath15 ) , or the period @xmath5 ( in @xmath2 ) .    to prove some impossibility results on these problems with a given knowledge ( theorems [ th : no - reuse - p - ndelta ] and [ th : neg - shortest - p ] , later in the paper ) , we make use of a specific family of tvgs with the same footprint , and establish some basic limitations they expose .",
    "consider the graph @xmath138 with @xmath139 and @xmath140 .",
    "consider the infinite family @xmath141 of periodic tvgs with footprint @xmath63 where , for each @xmath142 , @xmath143 and @xmath144 is as follows , where @xmath145_j$ ] denotes @xmath64 modulo @xmath146 :    * @xmath147 and @xmath148 are present only during the intervals @xmath149 $ ] with @xmath150 and @xmath151_4 = 0 $ ] ; * @xmath152 is present only during the intervals @xmath149 $ ] where @xmath153 and @xmath145_4 = 2 $ ] ; * if @xmath154 , then @xmath155 is present only during the intervals @xmath149 $ ] where @xmath153 and @xmath145_4 = 3 $ ] . * if @xmath156 , then @xmath155 is present only during the intervals @xmath149 $ ] where @xmath157 and either @xmath145_4 = 3 $ ] or @xmath145_{4(i+1 ) } = 4i+1 $ ] .",
    "notice that @xmath158 and its period is @xmath159 .",
    "also notice that in all of these graphs , @xmath160 and the minimum @xmath4 is 4 .",
    "let test(@xmath161 ) be the problem of observing the evolution of a graph chosen by an adversary from @xmath161 , and deciding in finite time whether or not it is @xmath162 .",
    "test(@xmath161 ) is undecidable .",
    "[ undecidable ]    at any time @xmath64 , the evolution of @xmath163 from time @xmath164 to @xmath64 is indistinguishable from that of any @xmath142 with @xmath165 . since any solution algorithm must terminate in finite time , any decision taken at that time , say @xmath166 , can be made incorrect by the adversary by choosing the graph to be any @xmath142 with @xmath167 if the answer was @xmath163 , and by choosing it to be @xmath168 otherwise .",
    "a knowledge @xmath23 about @xmath169 may reduce the choices of the adversary .",
    "indeed , given enough knowledge , the test problem can become decidable .",
    "the following lemma identifies conditions on @xmath23 for test to be undecidable .",
    "let @xmath170 denote the subset of @xmath169 still available to the adversary in spite of knowledge @xmath23 .    if @xmath171 and @xmath172 , then test@xmath173 is undecidable .",
    "[ lemma ]    since @xmath172 , for any @xmath64 there is always a tvg with @xmath174 in the set @xmath175 , and its evolution from time @xmath164 to @xmath64 is indistinguishable from that of @xmath163 .",
    "since any solution algorithm must terminate in finite time , any decision taken at that time , say @xmath166 , can be made incorrect by the adversary by choosing the graph to be any @xmath176 with @xmath177 if the answer was @xmath163 , and by choosing it to be @xmath168 otherwise . +    as an immediate consequence , we have that @xmath3 and @xmath4 are not sufficient :    test@xmath178 is undecidable .",
    "[ newlemma ]    let @xmath3 and @xmath4 be known . since @xmath3 and @xmath4 are the same for every @xmath142 , then @xmath179 .",
    "thus , by theorem [ undecidable ] , the lemma follows .",
    "solving tdb@xmath24$]in @xmath0or @xmath1clearly requires some sort of flooding , because the very fact of probing a neighbor to determine if it already has the information compromises the possibility to send it in a foremost fashion ( in addition to risking the disappearance of the edge in - between the probe and the real sending ) . as a consequence of theorem  [ th : imp1 ] , this problem can not be solved without knowledge . in this section",
    "we first show that it becomes possible in @xmath0if the number of nodes @xmath137 is known .",
    "the proof is constructive by means of algorithm  [ algo : foremost - recurrent - n ] , whose termination is however not bounded in time .",
    "being in @xmath1with the same knowledge allows its termination to be bounded . knowing @xmath4 instead of @xmath3 in @xmath1then allows us to propose another solution ( described in algorithm  [ algo : foremost - recurrent - delta ] ) that has a lower message complexity .",
    "this complexity can be further improved if both @xmath4 _ and _ @xmath3 are known , as in this case we have the possibility to terminate _",
    "implicitly_.      since",
    "@xmath4 and @xmath5 are not defined for @xmath0 , we need to focus only on the knowledge of @xmath3 .",
    "we show that the problem is solvable when @xmath3 is known .",
    "the algorithm proceeds as follows ( see algorithm  [ algo : foremost - recurrent - n ] for details ) . every time a _ new",
    "_ edge appears locally to an informed node , this node sends the information message onto this edge , and remembers that this edge now leads to an informed node . the first time a node receives the information , it records the sender as parent , transmits the information on its available edges , and sends back a notification message to the parent .",
    "note that these notifications create a parent - relation and thus a converge - cast tree .",
    "each notification is propagated along the converge - cast tree and eventually collected at the emitter .",
    "when the emitter has received @xmath180 notifications , it knows all nodes are informed .",
    "observe that the notification messages are sent using the special primitive @xmath82 discussed in section  [ sec : defs ] , to ensure that the parent eventually receives it even if the edge disappears during the first attempt .",
    "information messages , on the other hand , are sent using the normal @xmath181 primitive .",
    "indeed , if the propagation of such a message fails because the corresponding edge disappears , it simply means that this edge at that particular time did not have to be used ( i.e. , it did not belong to a valid journey ) .",
    "1    @xmath182 @xmath183 @xmath184@xmath185@xmath186@xmath187 @xmath188 @xmath189 @xmath190 @xmath191 @xmath192 @xmath192 @xmath189 @xmath193 @xmath194 @xmath195 @xmath196 @xmath197 @xmath198    when @xmath3 is known , tdb@xmath24$]can be solved in @xmath67 exchanging @xmath199 information messages and @xmath200 control messages , in unbounded time .",
    "[ theo : foremost - r - n - known ]    since a node sends the information to each new appearing edge , it is easy to see , by connectivity of the _ underlying _ graph , that all nodes will eventually receive the information .",
    "the dissemination itself is necessarily foremost because the information is either directly relayed on edges that are present , or sent as soon as a new edge appears . as for termination detection",
    ": every node identifies a unique parent and a converge - cast spanning tree directed towards the source is implicitly constructed ; since every node notifies the source ( through the tree ) and the source knows the total number of nodes , termination is guaranteed . since information messages might traverse every edge in both directions , and an edge can not be traversed twice in the same direction , we have that the number of _ information _ messages is in the worst case @xmath201 .",
    "since every node but the emitter induces a notification that is forwarded up the converge - cast tree to the emitter , the number of _ notification _ messages is the sum of distances in the converge - cast tree between all nodes and the emitter , @xmath202 .",
    "the worst case is when the graph is a line where we have @xmath203 control messages .",
    "regarding time complexity , the termination of the algorithm is unbounded due to the fact that the recurrence of the edges is itself unbounded .    [ [ use - in - subsequent - broadcasts . ] ] use in subsequent broadcasts .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + +    foremost trees are _ time - dependent _ in the sense that they might be optimal for some emission dates and not be so for other dates .",
    "still , they remain _ valid _ trees ( though , possibly non - foremost ones ) regardless of the considered date . as such",
    ", they can be memorized by the nodes in order to be used as _ converge - cast _ trees for termination detection in subsequent broadcasts . indeed , while the broadcast is required to be foremost",
    ", the detection of termination does not have such constraint .",
    "hence , instead of sending a notification each time a new node is informed ( as done previously ) , nodes can notify their parents ( in the converge - cast tree ) if and only if they are themselves informed and have received a notification from each of their children ( in the converge - cast tree ) .",
    "this reduces the number of control messages from @xmath200 to @xmath204 , having only one notification per edge of the converge - cast tree .      if the recurrence time is bounded , then either the knowledge of @xmath3 or an upper bound @xmath4 on the recurrence time can be used to solve the problem ( with various message complexities ) .      since @xmath205",
    ", one can obviously solve tdb@xmath24$]in @xmath15 using algorithm  [ algo : foremost - recurrent - n ] ( and the same observations apply regarding reusability of the converge - cast tree ) . here , however , the termination time becomes bounded due to the fact that the recurrence of edges is itself bounded .",
    "when @xmath3 is known , tdb@xmath24$]can be solved in @xmath15 exchanging @xmath199 information messages and @xmath200 control messages , in @xmath206 time .    since all edges in @xmath60 are recurrent within any @xmath4 time window , the delivery of the information at the last node must occur within @xmath207 global time .",
    "the same property holds for the latest notification , bounding the overall process to a duration of @xmath208 .",
    "the rest follows from theorem  [ theo : foremost - r - n - known ] .",
    "the information dissemination is performed as in algorithm [ algo : foremost - recurrent - n ] , but the termination detection is different . thanks to the time - bound @xmath4 on edge recurrence , a node can discover all of its neighbors within @xmath209 time ( back and forth messages , each on a different @xmath4 period at the worst ) .",
    "this fact can be used by a node to determine whether it is a leaf in the broadcast tree ( _ i.e. , _ if it has not heard back from a potential child within @xmath209 time following its own reception time ) .",
    "this allows the leaves to terminate spontaneously and notify their parent , which recursively terminate after receiving the notifications from all their children and notifying their own parent .",
    "this combination of broadcast - convergecast , originally described in  @xcite , is a standard process for distributed computing in _",
    "static _ graphs .",
    "the temporal adaption for bounded - recurrent tvgs is as follows ( see algorithm  [ algo : foremost - recurrent - delta ] for details ) .",
    "first , everytime a _ new _",
    "edge appears locally to an informed node , this node sends the information on the edge , and records the edge . the first time a node receives the information",
    ", it chooses the sender as parent , memorizes the current time ( in a variable @xmath210 ) , transmits the information on its available edges , and returns an _ affiliation _ message to its parent using the @xmath82 primitive ( starting to build the converge - cast tree ) .",
    "this affiliation message is not relayed further up the tree : it is only intended to inform the parent about the existence of a new child ( so this parent knows it must wait for a future notification by this node ) .",
    "if an informed node has not received any affiliation message after a duration of @xmath209 , then it sends a _ notification _ message to its own parent using the @xmath82 primitive . as for algorithm  [ algo : foremost - recurrent - delta ] ,",
    "if the information message is lost , then it simply means that this edge at that time did not have to be used . on the other hand ,",
    "if the _ affiliation _ message is lost , it must be sent again ( @xmath82 ) . however , in the worst case , the common edge disappears just before the affiliation message is delivered , and reappears less than @xmath211 later ( prop .",
    "[ prop : sendappear ] ) .",
    "the overall back and forth exchange thus remains within @xmath209 time .",
    "if a node has one or more children , it waits until it receives a notification message from each of them , then notifies its parent in the converge - cast tree ( using @xmath82 again ) .",
    "once the emitter has received a notification from each of its children , it knows that all nodes are informed .",
    "1    @xmath182 @xmath212 @xmath183 @xmath184@xmath185@xmath186@xmath187 @xmath213 @xmath188 @xmath189 @xmath191 @xmath192 @xmath192 @xmath189 @xmath214 @xmath193 @xmath194 @xmath215 @xmath216 @xmath192 @xmath196 @xmath198 @xmath197 @xmath217 @xmath197    when @xmath4 is known , tdb@xmath24$]can be solved in @xmath15 exchanging @xmath199 information messages and @xmath204 control message , in @xmath206 time .",
    "correctness follows the same lines of the proof of theorem [ theo : foremost - r - n - known ] .",
    "however the correct construction of a converge - cast spanning tree is guaranteed by the knowledge of @xmath4 ( i.e. , the nodes of the tree that are leaves detect their status because no new edges appear within @xmath4 time ) and the notification starts from the leaves and is aggregated before reaching the source .",
    "the number of information messages is @xmath199 as the exchange of information messages is the same as in algorithm [ algo : foremost - recurrent - n ] , but the number of notification and affiliation messages decreases to @xmath218 .",
    "each node but the emitter sends a single affiliation message ; as for the notification messages , instead of sending a notification as soon as it is informed , each node notifies its parent in the converge - cast tree if and only if it has received a notification from each of its children resulting in one notification message per edge of the tree .",
    "the time complexity of the dissemination itself is the same as for the foremost broadcast when @xmath3 is known ( @xmath207 ) .",
    "the time required for the emitter to subsequently detect termination is an additional @xmath219 in the worst case ( _ i.e. _ self - detection by the leaves , followed by the longest notification chain up the emitter ) .",
    "this gives a total of @xmath220 .",
    "clearly , the number of nodes @xmath3 , which is not _ a priori _ known here , can be obtained through the notification process of the first broadcast ( by having nodes reporting their number of descendants in the tree , while notifying hierarchically ) .",
    "all subsequent broadcasts can thus behave as if both @xmath3 and @xmath4 were known .",
    "next we show this allows to solve the problem without any control messages .      in this case",
    ", the emitter knows an upper bound on the broadcast termination date ; in fact , the broadcast can not last longer than @xmath221 ( this worst case is when the foremost tree is a line ) .",
    "termination detection can thus become implicit after this amount of time , which removes the need for any control message ( whether of affiliation or of notification ) .",
    "when @xmath4 and @xmath3 are known , tdb@xmath24 $ ] can be solved in @xmath15 exchanging @xmath199 information messages and no control messages , in @xmath222 time .",
    "as we have seen , tdb@xmath24$]is feasible even in @xmath8 with knowledge @xmath3 .",
    "however our algorithms in @xmath12 or even in @xmath223 do not provide reusability .",
    "this is not accidental ; in fact , we will now show that achieving reusability in tdb@xmath24 $ ] is _ impossible _ even in @xmath224 .",
    "foremost broadcast trees are not reusable in @xmath224 .",
    "[ th : no - reuse - p - ndelta ]    consider the infinite family @xmath161 of tvgs defined in section [ sec : basic ] . in @xmath162",
    "the foremost journey from @xmath51 to @xmath52 at time @xmath64 is always along the edges @xmath147 and @xmath152 . in @xmath142 , @xmath156 , the foremost journey from @xmath51 to @xmath52 at time @xmath225 with @xmath145_{4i}=0 $ ]",
    "is also along the edges @xmath147 and @xmath152 , _ except _ when @xmath145_{4(i+1)}=0 $ ] , in which case the foremost journey is along the edges @xmath148 and @xmath155 . by lemma [ newlemma ] , even knowing @xmath3 and @xmath4 , the evolution of @xmath162 until time @xmath64 with @xmath145_{4i}=0 $ ] is undistinguishable from that of @xmath142 with @xmath226 .",
    "then , by just observing the evolution until time @xmath64 with @xmath145_{4i}=0 $ ] , it is impossible to decide at that time whether the graph is @xmath162 or not ; hence , it is impossible to decide whether the foremost path from @xmath51 to @xmath52 at that time is @xmath227 ( foremost in @xmath162 ) or @xmath228 ( foremost in @xmath142 with @xmath226 ) .    while @xmath3 and @xmath4 are not sufficient for reusability in @xmath2 , it has been shown in  @xcite that the knowledge of the period @xmath5 is sufficient .",
    "@xcite foremost broadcast trees can be reused for subsequent broadcasts in @xmath6 with knowledge @xmath5 .",
    "[ th : reuse - p - p ]    the basic argument is that a foremost broadcast tree for time @xmath64 remains optimal for all times @xmath229 , where @xmath146 is a positive integer .",
    "recall that the objective of tdb@xmath25$]is to deliver the information to each node within a minimal _ number of hops _ from the emitter , and to have the emitter detect termination within finite time .",
    "we show below that contrary to the foremost case , knowing @xmath3 is insufficient to perform a shortest broadcast in @xmath8 or even in @xmath15 .",
    "this becomes however feasible in @xmath1when @xmath4 is also known .",
    "moreover any shortest tree built at some time @xmath64 will remain optimal in @xmath7 relative to any future emission date @xmath230 .",
    "this feature allows the solution to tdb@xmath25$]to be possibly reused in subsequent broadcasts .      as we will show later ( see theorem  [ th : neg - shortest - p ] ) , knowing @xmath3 is not sufficient to solve tdb@xmath25$]in @xmath2 , and thus also in @xmath1(or @xmath0 ) .",
    "therefore , the only knowledge still of interest are @xmath4 and the combination of @xmath4 and @xmath3 .",
    "the idea is to propagate the message along the edges of a _",
    "breadth_-first spanning tree of the underlying graph .",
    "we present the pseudo - code in algorithm [ algo : shortest - delta ] , and provide the following informal description .    assuming that the message is created at some date @xmath64 , the mechanism consists of authorizing nodes at level @xmath86 in the tree to inform new nodes only between time @xmath231 and @xmath232 ( doing it sooner would lead to a non - shortest tree , while doing it later is pointless because all the edges have necessarily appeared within one @xmath4 ) .",
    "so the broadcast is confined into rounds of duration @xmath4 as follows : whenever a node sends the information to another , it sends a time value that indicates the remaining duration of its round ( that is , the starting date of its own round minus the current time , plus @xmath4 , minus the crossing delay @xmath56 ) , so the receiving node , if it is a new child , knows when it should start informing new nodes in its turn .",
    "for instance in figure  [ fig : roundstart ] when the node @xmath233 attempts to become @xmath234 s parent , node a transmits its own starting date plus @xmath4 minus the current date minus @xmath56 .",
    "this duration corresponds to the exact amount of time the child would have to wait , if the relation is established , before integrating other nodes in turn . if a node does not detect any children before @xmath209 following its own reception date ( same as algorithm  [ algo : foremost - recurrent - delta ] ) , then it detects that it is a leaf and notifies its parent .",
    "otherwise , it waits for the final notifications of all its children , then notifies its parent . as before",
    ", this requires parents to keep track of the number of children they have , and thus children need to send _ affiliation _ messages when they select a parent .",
    "finally , when the emitter has been notified by all its children , it knows the broadcast is terminated .",
    "tdb@xmath25$]can be solved in @xmath15 knowing @xmath4 , exchanging @xmath199 info .",
    "messages and @xmath204 control messages , in @xmath206 time .",
    "[ th : shortest - b ]    the fact that the algorithm constructs a breadth - first ( and thus shortest ) delay - tolerant spanning tree follows from the connectivity over time of the underlying graph and from the knowledge of the duration @xmath4 .",
    "the bound on recurrence is used to enable a rounded process whereby the correct distance of each node to the emitter is detected .",
    "the number of _ information _ messages is @xmath201 as the dissemination process exchanges at most two messages per edge . the number of _ affiliation _ and _ notification _ messages are each of @xmath180 ( one per edge of the tree ) .",
    "the time complexity for the construction of the tree is at most @xmath207 to reach the last node , plus @xmath209 at this node , plus at most @xmath207 to aggregate this node s notification .",
    "( the additional @xmath56 caused by waiting affiliation messages matters only for the last round , since the construction continues in parallel otherwise . )",
    "the total is thus at most @xmath220 .",
    "1    @xmath182 @xmath235 @xmath236@xmath186@xmath237 @xmath183 @xmath184@xmath185@xmath186@xmath187 @xmath238    @xmath239    @xmath240 @xmath192    @xmath192 @xmath193 @xmath241 @xmath215 @xmath242 @xmath196 @xmath217 @xmath197    @xmath189 @xmath243-@xmath244    @xmath217    ( -1,1 ) coordinate ( a ) ; ( a)+(11,0 ) coordinate ( aend ) ; ( -1,0 ) coordinate ( b ) ; ( b)+(11,0 ) coordinate ( bend ) ; ( a ) node[left ] @xmath233 ; ( b ) node[left ] @xmath234 ; ( 0,1 ) node[above , yshift=6pt ] @xmath245 ; ( 3,1 ) node[above , yshift=4pt ] @xmath246 ; ( 8,1 ) node[above , yshift=4pt ] @xmath247 ; ( 8,0 ) node[above , yshift=5pt ] @xmath245 ; ( 3,-.2) node[below , midway ] @xmath56 ( 4,-.2 ) ; ( a)(aend ) ; ( b)(bend ) ; ( 0,1)+(0,.15 ) coordinate ( tmp ) ; ( tmp)+(0,-.3)(tmp ) ; ; ( 3,1)+(0,.15 ) coordinate ( tmp ) ; ( tmp)+(0,-.3)(tmp ) ; ; ( 8,0)+(0,.15 ) coordinate ( tmp ) ; ( tmp)+(0,-.3)(tmp ) ; ; ( 8,1)+(0,.15 ) coordinate ( tmp ) ; ( tmp)+(0,-.3)(tmp ) ; ; ( 3,1)(3,0 ) ; ( 3,1)(4,0 ) ; ( 4,-.06 ) rectangle ( 8,.06 ) ;    [ [ reusability - for - subsequent - broadcasts ] ] reusability for subsequent broadcasts : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    thanks to the fact that shortest trees remain shortest regardless of the emission date , all subsequent broadcasts can be performed within the same , already known tree , which reduces the number of information message from @xmath199 to @xmath204 . moreover , if the depth @xmath248 of the tree is detected through the first notification process , then all subsequent broadcasts can enjoy an implicit termination detection that is itself optimal in time ( after @xmath249 time ) .",
    "no control message is needed .",
    "when both @xmath3 and @xmath4 are known , one can apply the same dissemination procedure as in algorithm [ algo : shortest - delta ] combined with an implicit termination detection that avoids using control messages at all .",
    "indeed , each node learns ( and possibly informs ) all of its neighbors within @xmath4 time .",
    "since the underlying graph is connected , the whole process must then complete within @xmath250 time .",
    "hence , if the emitter knows both @xmath4 and @xmath3 , it can simply wait @xmath250 time , then terminate implicitly .",
    "when @xmath3 and @xmath4 are known , tdb@xmath25$]can be solved in @xmath15 exchanging @xmath199 info .",
    "messages and no control messages , in @xmath206 time",
    ".    however , such a strategy would prevent the emitter from learning the depth @xmath248 of the shortest tree , and thus prevent lowering the termination bound to @xmath251 time .",
    "an alternative solution would be to achieve explicit termination for the first broadcast in order to build a reusable broadcast tree ( and learn its depth @xmath248 in the process ) . in this case ,",
    "dissemination is achieved with @xmath199 information messages , termination detection is achieved similarly to algorithm [ algo : shortest - delta ] with @xmath204 control messages ( where however affiliation messages are not necessary , and the number of control messages would decrease to @xmath180 ) . in this way we would have an increase in control messages , but",
    "the subsequent broadcasts could reuse the broadcast tree for dissemination with @xmath204 information messages , and termination detection could be implicit with no exchange of control message at all after @xmath251 time .",
    "the choice of either solution may depend on the size of an information message and on the expected number of broadcasts planned .",
    "feasibility in @xmath252 is implied by feasibility in @xmath13 and it clearly implies feasibility in @xmath14 .",
    "the only case left to study is feasibility with only knowledge of @xmath3 .",
    "tdb@xmath25$]is not feasible in @xmath2knowing only @xmath3 .",
    "neg - shortest - p ]    by contradiction , let @xmath120 be an algorithm that solves tdb@xmath25 $ ] in @xmath6 with the knowledge of @xmath3 only .",
    "consider an arbitrary @xmath253 and @xmath111 .",
    "execute @xmath120 in @xmath61 starting at time @xmath122 with @xmath79 as the source .",
    "let @xmath123 be the time when the source terminates and @xmath254 the shortest broadcast tree along which broadcast was performed .",
    "let @xmath124 such that @xmath255 , @xmath256 for some @xmath257 , @xmath129 for all @xmath258 , @xmath259 for all @xmath260 , and @xmath261 for some @xmath262 ( we can take the period @xmath5 as large as needed here ) .",
    "consider the execution of @xmath120 in @xmath133 starting at time @xmath122 with @xmath79 as the source .",
    "since @xmath263 does not appear between @xmath122 and @xmath123 , the execution of @xmath136 at every node in @xmath133 will be exactly as at the corresponding node in @xmath61 and terminate with @xmath52 having received the information in more than one hop , contradicting the fact that @xmath254 is a shortest tree , and thus the correctness of @xmath120 .",
    "the requirement for tdb@xmath26$]is to deliver the information to each node using the least amount of time , regardless of the stating date , and to have the emitter detect termination within finite time .",
    "we first show that , contrary to the foremost and shortest cases , knowing @xmath3 and @xmath4 is insufficient to perform a fastest broadcast even in @xmath6 .    tdb@xmath26$]is not feasible in @xmath2with only knowledge of @xmath3 and @xmath4 .",
    "[ th : neg - fastest - n - delta ]    consider the infinite family @xmath161 of tvgs defined in section [ sec : basic ] .",
    "notice that the duration of the fastest journey from @xmath51 to @xmath52 is 3 in @xmath162 while it is 2 in any other @xmath142 . by lemma [ newlemma ] ,",
    "test is undecidable even if both @xmath3 and @xmath4 are known .",
    "it follows that it is undecidable whether the fastest journey from @xmath51 to @xmath52 has length 3 ( in the case of @xmath162 ) or 2 ( for all other @xmath142 ) .",
    "the next question is what knowledge allows the problem to become feasible in @xmath2 .",
    "observe that @xmath264 is a finite set , hence theorem [ lemma ] does not apply .",
    "indeed , it has been shown in @xcite that , if the period @xmath5 is known , tdb@xmath26$]becomes feasible in @xmath2 .",
    "tdb@xmath26$]is feasible in @xmath2with a known period @xmath5 , and the corresponding broadcast tree can be reused as such in the subsequent periods .",
    "[ th : fastest - p ]    we can actually show that tdb@xmath26$]is feasible in @xmath2with the weaker knowledge of an upper bound on the period .",
    "tdb@xmath26$]is feasible in @xmath2with a known upper bound on @xmath5 , and the broadcast tree can be reused for subsequent broadcasts .",
    "the construction of fastest ( broadcast ) trees in  @xcite is based on the observation that achieving a fastest broadcast from some node comes to performing a _",
    "foremost _ broadcast from that node at the time of its minimum _ temporal eccentricity _ , that is , when it takes the minimum time to reach all other nodes .",
    "the algorithm in  @xcite consists of learning this date over a complete period @xmath5 , then build a foremost broadcast tree that starts at that date ( modulo @xmath5 ) . in case of multiplicity ,",
    "any of the minimum values qualifies just as well .",
    "having an upper bound @xmath265 on the period @xmath5 allows for the exact same technique . indeed , any interval of time of length @xmath265 must contain an interval of length @xmath5 , thus the time of minimum eccentricity will be detected .    note that in both cases ( knowing @xmath5 or @xmath266 ) , the broadcast tree that is built remains necessarily optimal in the future , since in @xmath2the network schedule repeats forever .",
    "it can thus be _ memorized _ for subsequent broadcasts , _",
    "i.e. , _ the solution is _ reusable_.",
    "on the basis of this paper results , we can prove the validity of equation  1 by showing the existence of a strict computational hierarchy between @xmath18 , @xmath19 , and @xmath20 .",
    "@xmath267 [ th : strict - inclusion ]    the fact that @xmath117 was observed in theorem  [ th : inclusion ] . to make the left inclusion strict , one has to exhibit a problem @xmath268 such that @xmath269 and @xmath270 . by theorem",
    "[ th : neg - shortest - p ] and theorem  [ th : shortest - b ] , tdb@xmath25$]is one such example . the right inclusion is similarly proven strict , based on the fact that tdb@xmath26$]is in @xmath20 ( theorem  [ th : fastest - p ] ) but it is not in @xmath271 and thus in @xmath272 ( theorem  [ th : neg - fastest - n - delta ] ) .    with regards to the _ feasibility _ of the three broadcast problems investigated here ,",
    "the results established in the previous sections indicate the existence of a strict hierarchy . given a class @xmath22 of tvgs , a knowledge @xmath23 , and two problems @xmath273 ,",
    "let @xmath274 denote the fact that for all @xmath275 , if @xmath33 is feasible in @xmath276 with knowledge @xmath23 , so is @xmath32",
    ".    given a ( possibly infinite ) set @xmath277 of classes of tvgs with given knowledge , let @xmath278 denote the fact that @xmath279 for all @xmath280 .",
    "let @xmath281 denote the fact that @xmath278 and there exists at least one @xmath282 such that @xmath283 but @xmath284 .",
    "let @xmath285 be the universe of all the classes and knowledge considered in this paper .",
    "@xmath9}\\xspace}\\prec_{\\cal u } { { \\textsc{tdb}}\\ensuremath{[shortest]}\\xspace}\\prec_{\\cal u } { { \\textsc{tdb}}\\ensuremath{[fastest]}\\xspace}$ ] [ th : strict - inclusion2 ]    by theorem  [ theo : foremost - r - n - known ] , tdb@xmath24$]is feasible in @xmath12 ( and _ a fortiori _ in @xmath286 and @xmath287 , which are subsets of @xmath288 ) . by theorem  [ th :",
    "inclusion ] , it is also feasible in @xmath13 ( and in all the remaining combinations of @xmath289 , which are subsets of @xmath13 ) .",
    "thus tdb@xmath24$]is feasible in @xmath289 regardless of the class or knowledge considered .",
    "now , by theorem  [ th : neg - shortest - p ] , tdb@xmath25$]is unfeasible in @xmath287 ( among others ) .",
    "thus , we have @xmath9}\\xspace}\\prec_{\\cal u } { { \\textsc{tdb}}\\ensuremath{[shortest]}\\xspace}$ ] . similarly , by theorem  [ th : shortest - b ] , tdb@xmath25$]is feasible in @xmath13 , and thus , among others , in @xmath14 ( theorem  [ th : inclusion ] ) , whereas tdb@xmath26$]is only feasible in @xmath14 ( theorem  [ th : neg - fastest - n - delta ] ) .",
    "it thus also holds that @xmath10}\\xspace}\\prec_{\\cal u } { { \\textsc{tdb}}\\ensuremath{[fastest]}\\xspace}$ ] .    with regards to _ reusability",
    "_ , the relationship between the three broadcast problems is drastically different .",
    "for reusability , let @xmath290 , @xmath291 be the analogous of @xmath292 , @xmath293 defined for feasibility .",
    "furthermore , let @xmath294 if @xmath295 and @xmath296 .    @xmath297}\\xspace}<_{\\cal u } { { \\textsc{tdb}}\\ensuremath{[foremost]}\\xspace}\\equiv_{\\cal u } { { \\textsc{tdb}}\\ensuremath{[fastest]}\\xspace}$ ] [ th:3 ]    tdb@xmath25$]enables reusability in @xmath13 ( see the end of section  [ sec : shortest - delta ] ) and thus in all the stronger contexts @xmath298 , @xmath252,@xmath224 , @xmath299 .",
    "on the other hand , tdb@xmath24 $ ] , although feasible in all of @xmath289 s contexts , enables reusability only in @xmath14 ( theorem  [ th : no - reuse - p - ndelta ] and  [ th : reuse - p - p ] ) . as for tdb@xmath26 $ ] , it is only feasible ( and reusable ) in @xmath14 ( theorems  [ th : neg - fastest - n - delta ] and  [ th : fastest - p ] ) .",
    "theorems  [ th : strict - inclusion2 ] and  [ th:3 ] suggest that the difficulty of these problems is multi - dimensional , in that it depends on the aspect that is looked at ( feasibility _ vs. _ reusability ) . indeed , while tdb@xmath25$]is harder than tdb@xmath24$]in terms of feasibility , it is easier in terms of reusability . on the other hand , tdb@xmath26$]is ( among ) the hardest in both terms .",
    "in this paper we focused on three particular problems ( shortest , fastest , and foremost broadcast ) in three classes of dynamic graphs ( recurrent , time - bounded recurrent , and periodic graphs ) with different types of applicable knowledge ( size of the network , bound on edge recurrence , period , upper bound on period ) . by comparing the feasibility of these problems within each class depending on the available knowledge , we have observed the impact that knowledge has on feasibility and we have understood the computational relationship between the classes in this context .",
    "this has in turn allowed us to observe the relative  difficulty \" of the problems under investigation .    among other things our results",
    "show , for example , the special importance of periodic dynamic graphs with known period , the only combination of class and knowledge ( in the universe considered here ) where fastest broadcast is feasible .",
    "it also stresses the inherent difference between reusability of foremost broadcast ( which is the ",
    "easiest \" problem to solve but is reusable only in periodic graphs with known period ) , and fastest and shortest on the other , which can be reused whenever they can be solved .",
    "another interesting observation stemming from our results is the intrinsic limitation of knowing only the number of nodes , in which case , regardless of the class of graphs considered , only foremost broadcast can be performed ( without being able to reuse it ) .",
    "this study is a first step toward an understanding of computability in dynamic graphs and it opens the door to more general investigations on the computability power of different classes and their relationship with knowledge available to the nodes .",
    "b.  awerbuch and s.  even .",
    "efficient and reliable broadcast is achievable in an eventually connected network . in _ proceedings of the 3rd acm symposium on principles of distributed computing ( podc ) _ , pages 278281 , 1984 .",
    "m.  biely , p.  robinson , and u.  schmid .",
    "agreement in directed dynamic networks . in _ proceedings of the 19th international colloquium on structural information and communication complexity ( sirocco ) _ , 2012 .",
    "a.  casteigts , s.  chaumette , and a.  ferreira .",
    "characterizing topological assumptions of distributed algorithms in dynamic networks . in _ proceedings of 16th int .",
    "colloquium on structural information and communication complexity ( sirocco ) _ , pages 126140 , 2009 .",
    "a.  clementi , a.  monti , f.  pasquale , and r.  silvestri .",
    "information spreading in stationary markovian evolving graphs . in _ proceedings of the 23rd",
    "eee international symposium on parallel & distributed processing(ipdps ) _ , pages 112 , 2009 .      c.  dutta , g.  pandurangan , r.  rajaraman , z.  sun , and e.  viola . on the complexity of information spreading in dynamic networks . in _ proceedings of the 24th annual acm - siam symposium on discrete algorithms ( soda ) _ , pages 717736 , 2013 .",
    "y.  peres , a.  sinclair , p.  sousi , and a.  stauffer .",
    "mobile geometric graphs : detection , coverage and percolation . in _ proceedings of the twenty - second annual acm - siam symposium on discrete algorithms ( soda ) _ , pages 412428 .",
    "siam , 2011 .",
    "w.  zhao , m.  ammar , and e.  zegura . a message ferrying approach for data delivery in sparse mobile ad hoc networks . in _ proceedings of the 5th acm international symposium on mobile ad hoc networking and computing ( mobihoc ) _ ,",
    "pages 187198 , 2004 ."
  ],
  "abstract_text": [
    "<S> highly dynamic networks rarely offer end - to - end connectivity at a given time . yet , connectivity in these networks can be established over time and space , based on temporal analogues of multi - hop paths ( also called _ journeys _ ) . attempting to optimize </S>",
    "<S> the selection of the journeys in these networks naturally leads to the study of three cases : shortest ( minimum hop ) , fastest ( minimum duration ) , and foremost ( earliest arrival ) journeys . </S>",
    "<S> efficient centralized algorithms exists to compute all cases , when the full knowledge of the network evolution is given .    in this paper , we study the _ distributed _ counterparts of these problems , i.e. shortest , fastest , and foremost broadcast with termination detection ( tdb ) , with minimal knowledge on the topology . </S>",
    "<S> we show that the feasibility of each of these problems requires distinct features on the evolution , through identifying three classes of dynamic graphs wherein the problems become gradually feasible : graphs in which the re - appearance of edges is _ recurrent _ ( class @xmath0 ) , _ bounded - recurrent _ ( @xmath1 ) , or _ periodic _ ( @xmath2 ) , together with specific knowledge that are respectively @xmath3 ( the number of nodes ) , @xmath4 ( a bound on the recurrence time ) , and @xmath5 ( the period ) . in these classes it is not required that all pairs of nodes get in contact  only that the overall _ footprint _ of the graph is connected over time .    our results , together with the strict inclusion between @xmath6 , @xmath7 , and @xmath8 , implies a feasibility order among the three variants of the problem , i.e. @xmath9}\\xspace}$ ] requires weaker assumptions on the topology dynamics than @xmath10}\\xspace}$ ] , which itself requires less than @xmath11}\\xspace}$ ] . </S>",
    "<S> reversely , these differences in feasibility imply that the computational powers of @xmath12 , @xmath13 , and @xmath14 also form a strict hierarchy .    </S>",
    "<S> * keywords : * dynamic networks , distributed algorithm , time - varying graphs , delay - tolerant broadcast , recurrent edges . </S>"
  ]
}