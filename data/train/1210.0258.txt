{
  "article_text": [
    "the past few decades have witnessed a surge in interest on the design and analysis of scheduling policies for stochastic networks , e.g. , @xcite .",
    "one of the key insights from this body of work is that natural scheduling policies can lead to instability even when each server is nominally underloaded @xcite .",
    "( there are several notions of stability for stochastic networks , but they intuitively entail that , in some sense , the number of customers in the system does not grow without bounds . )",
    "this insight stimulated a search for tools that can characterize the stability regions of scheduling policies , i.e. , the exact conditions on the arrival and service rates under which a network is stabilized by a policy .",
    "it is the objective of this paper to study a question of a different kind : is it possible to construct a generic , simple , and efficient scheduling policy for stochastic processing networks , which leads to a ( globally ) stable network if all servers are ( locally ) nominally underloaded in some sense ? to our knowledge , we are the first to answer this question within the setting of stochastic processing networks , which constitute a large class of stochastic networks capable of modeling a variety of networked systems for communication , manufacturing , and service systems ( e.g. , @xcite ) . to investigate this question ,",
    "the key is to determine if and how jobs from different parts of the network should be treated differently when they share the same buffer .",
    "various existing scheduling policies are ` throughput optimal ' in the sense that they achieve the largest possible stability region , but these policies suffer from significant drawbacks .",
    "they typically obtain the desired stability by framing the contention resolution between buffers as an appropriate global optimization problem .",
    "this optimization problem requires central coordination between network entities , and it is computationally hard to solve if the network is large .",
    "the resulting policies , such as the max - weight policy @xcite and the back - pressure policy @xcite , are not scalable and can not cope efficiently with large networks . as a result , these throughput optimal policies do not provide a satisfactory answer to the aforementioned question .",
    "the computational challenges surrounding existing throughput optimal policies motivate the search for easily implementable scheduling policies with provable performance guarantees but not necessarily with the throughput optimality property .",
    "this has led to the analysis of simple greedy scheduling policies for a variety of special classes of stochastic processing networks : open multiclass queueing networks @xcite , input - queued switches @xcite , and wireless network models @xcite .",
    "these policies play an important role in this paper , since our most critical assumption roughly requires any local network component to be nominally underloaded under any ` maximal ' greedy scheduling policy .",
    "our main contribution is a randomized scheduling policy for stochastic processing networks which only requires coordination within local components ( e.g. , service stations ) , and which is computationally attractive since it is a kind of priority policy . with high probability , our policy prioritizes jobs which have been least routed , and we therefore call our policy the @xmath0-least routed first served ( @xmath0-lrfs ) policy . here",
    "@xmath1 is a small number which helps to make the meaning of `` high probability '' precise .",
    "our main technical tool is a novel framework to construct a ` global ' lyapunov function for a stochastic processing network through appropriate ` local ' lyapunov functions . if the local lyapunov functions yield stability of the corresponding ` local ' network components , then the global lyapunov function allows us to conclude that the whole network is stable .",
    "a critical feature of our framework is that the lyapunov functions we work with are quadratic . through examples ,",
    "we show that quadratic local lyapunov functions can readily be found for wide classes of networks .",
    "we refer to @xcite for other uses of quadratic lyapunov functions .",
    "our approach to construct an appropriate ` global ' lyapunov function using ` local ' quadratic lyapunov functions contrasts with the popular fluid model methodology for establishing stability of stochastic networks @xcite .",
    "the fluid model framework essentially reduces the question of stochastic stability to a question of a related deterministic ( fluid ) system . in the case of reentrant lines",
    ", our policy reduces to the first buffer first served ( fbfs ) policy , which has been proven to be stable via ` inductive ' fluid arguments @xcite . a similar fluid induction argument",
    "can be expected to work for general multiclass networks ( modulo some technical arguments ) , but a fluid induction argument can not be expected to work in general .",
    "a disadvantage compared to fluid models is that we have to keep track of detailed system behavior such as remaining service times , but therein also lies the power of our approach .",
    "the generality of our framework presents challenges to the use of fluid methods , and instead we work directly with a global lyapunov function .",
    "the connection with fluid techniques is discussed in more detail in section  [ sec : connectionfluid ] .",
    "although we believe that our methodology could be of much wider use , we have chosen to work out two special classes of stochastic processing networks in order to describe the implications of our techniques in relatively simple yet powerful settings : parallel server networks ( including multiclass queueing networks ) and communication network models ( including networks of input - queued switches and wireless networks ) .",
    "our work is related to a paper by bramson @xcite , who shows that open multiclass queueing networks can be stabilized by the earliest due date first served ( eddfs ) policy under the ` local ' condition that every processing unit is nominally underloaded .",
    "however , it is not known whether the eddfs policy achieves similar results beyond the open multiclass queueing network .",
    "in fact , it is _ a priori _ unclear how to formulate a ` local ' condition for general stochastic processing networks ; our notion of ` local ' lyapunov function plays this role in the present paper .",
    "this paper is organized as follows .",
    "section  [ sec : defspn ] introduces the class of stochastic processing networks we study in this paper .",
    "section  [ sec : mainresult ] formally introduces the @xmath0-lrfs policy and presents our main results .",
    "section [ sec : overview ] describes our main idea using a simple network , the rybko - stolyar network @xcite .",
    "we specialize our result to parallel server and communication network models in section  [ sec : application ] .",
    "all proofs are given in section  [ sec : pfthmmain ] .",
    "a stochastic processing network ( spn ) consists of a set @xmath2 of buffers , a set @xmath3 of activities and a set @xmath4 of processors .",
    "each buffer has infinite capacity and holds jobs that await service .",
    "the spns we study in this paper have the feature that activity @xmath5 can only process jobs from a single buffer @xmath6 , and that @xmath7 requires simultaneous possession of a set @xmath8 of processors .",
    "let @xmath9 be the set of activities capable of processing buffer @xmath10 , i.e. , @xmath11 we say that two buffers @xmath10 and @xmath12 are _ activity - interchangeable _ if @xmath13 .",
    "we also say that buffers @xmath10 and @xmath12 are _ processor - independent _ if @xmath14 and @xmath15 are disjoint .",
    "[ [ network - state . ] ] network state .",
    "+ + + + + + + + + + + + + +    we let @xmath16 be the queue length of buffer @xmath10 at time @xmath17 , i.e. , the number of jobs waiting in buffer @xmath10 excluding those being processed .",
    "we write @xmath18 for the sum of the remaining service requirements over all jobs in buffer @xmath10 which are currently being processed at time @xmath17 .",
    "we use @xmath19 to denote the activity level of activity @xmath7 at time @xmath17 , where we assume that @xmath20\\in\\{0,1\\}^j$ ] , meaning that each activity is either fully employed or not employed at all .",
    "thus , we say that the network is _ non - processor - splitting_.    [ [ routing . ] ] routing .",
    "+ + + + + + + +    after departing from a buffer @xmath10 , a job joins buffer @xmath21 with probability @xmath22 and departs from the network with probability @xmath23 ( independently of everything else ) .",
    "we write @xmath24 for the @xmath25 matrix of routing probabilities .",
    "[ [ resource - allocation . ] ] resource allocation .",
    "+ + + + + + + + + + + + + + + + + + + +    each activity @xmath7 decreases the remaining service requirement of the job it is processing at rate @xmath26 if @xmath27 .",
    "it is not allowed for an activity to be interrupted before it finishes the service requirement of the job it is working on , i.e. , the network is _ non - preemptive_. we do not allow for multiple activities to work on the same job simultaneously .",
    "furthermore , we assume that each processor @xmath28 has unit capacity , i.e. , @xmath29 we note that this unit capacity assumption is not restrictive since in our non - processor - splitting network of @xmath30 , a single processor @xmath28 with capacity @xmath31 can be replaced by @xmath32 copies with unit capacity , and identical activity structure inherited from the original processor .",
    "we further define the service rate vector @xmath33\\in \\mathbb{r}_+^i$ ] for a ( scheduling ) vector @xmath34\\in\\{0,1\\}^j$ ] through @xmath35    [ [ external - arrivals . ] ] external arrivals .",
    "+ + + + + + + + + + + + + + + + + +    there are external arrivals to at least one buffer . for @xmath36 ,",
    "let @xmath37 be the number of external jobs arriving at buffer @xmath10 during the time interval @xmath38 .",
    "we assume that @xmath39<\\infty$ ] for all @xmath40 ( i.e. , bounded second moment ) and @xmath41<\\alpha_i , \\]]for constant @xmath42 .",
    "we note that we allow for dependencies in the random processes @xmath43 and @xmath44 for two buffers @xmath10 and @xmath12 . even though it is possible for the @xmath45 to exceed the external arrival rates , it is convenient to interpret @xmath45 as the external arrival rate at buffer @xmath10 . similarly abusing terminology , we let @xmath46 $ ] be the _ effective _ arrival rate vector , i.e. , @xmath47 where @xmath48 $ ] .",
    "we also say that all routes are bounded ( in length ) if @xmath49    [ [ service - requirements . ] ] service requirements .",
    "+ + + + + + + + + + + + + + + + + + + + +    once a job in buffer @xmath10 is selected for processing by activity @xmath50 , it requires service for a random amount of time .",
    "we assume that all service times are independent , and that they are independent of the routing and external arrival processes .",
    "we also suppose that the service time distribution only depends on the buffer from which the job is processed .",
    "writing @xmath51 for a generic processing time at buffer @xmath10 , we assume that @xmath52=m_i\\qquad\\mbox{and}\\qquad e\\left[\\gamma_i^2\\right ] < \\infty,\\]]for constants @xmath53 . let @xmath54 $ ] denote the nominal load , i.e. , @xmath55 .",
    "we write @xmath56 for the ( expected ) immediate workload in buffer @xmath10 , which we define to be @xmath57 this is the expected amount of work in the @xmath10-th buffer given @xmath58 and @xmath59 .",
    "we note that our notion of immediate workload is the conditional expectation of a more common definition , and that immediate workload is defined for each buffer ( as opposed to resource ) .",
    "we say that the network is _ synchronized _ if for all @xmath60 , @xmath61 and @xmath62 , @xmath63 that is , in a synchronized network , arrivals and service completions only occur at integer time epochs .",
    "[ [ maximal - scheduling - policies . ] ] maximal scheduling policies .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + +    we say that activity @xmath7 is _ maximal _ in a ( scheduling ) vector @xmath34\\in \\{0,1\\}^j$ ] if there exists a processor @xmath64 such that @xmath65 i.e. , either activity @xmath7 uses each of the processors in @xmath66 under schedule @xmath67 or it can not be employed without violating the unit capacity constraint for some processor in @xmath66 .",
    "given a non - negative vector @xmath68\\in \\mathbb{r}_+^i$ ] , activity @xmath7 is called _ maximal _ in @xmath67 with respect to @xmath69 if @xmath70 or @xmath7 is maximal in @xmath67 .",
    "an activity is non - maximal if it is not maximal .",
    "if all activities are maximal in @xmath67 with respect to @xmath69 , we simply say that @xmath67 is maximal with respect to @xmath69 .",
    "we write @xmath71 for the set of maximal scheduling vectors with respect to @xmath69 , i.e. , @xmath72 finally , we say that a scheduling policy is maximal if , under the policy , @xmath73 for all @xmath74 .",
    "this section describes the scheduling policies which play a central role in this paper , and presents our main stability result .",
    "[ [ scheduling - policies . ] ] scheduling policies .",
    "+ + + + + + + + + + + + + + + + + + + +    our policies require that each job maintains a ` counter ' for the number of times it has been routed so far , where we follow the convention that counters start from @xmath75 .",
    "the counter of a job is increased even when a job is routed to a buffer it has previously visited , so the counter of a job could differ from the number of different stations it has visited .",
    "we also consider a partition @xmath76 of buffers into components , such that @xmath77 where any two buffers from different components are processor - independent .",
    "one possible choice for the partition is @xmath78 , but , as becomes apparent from the description of our policies below , a finer partition makes our policies more ` distributed ' .",
    "it is important to note that we allow for routing between components .",
    "we assume that each component @xmath79 for @xmath80 maintains a ` timer ' @xmath81 $ ] at time @xmath17 which decreases at unit rate if @xmath82 .    to describe our maximal scheduling policies , we need the following notation .",
    "we write @xmath83 $ ] for the queue length information in component @xmath79 , where @xmath84 is the indicator function of the set @xmath85 , i.e. , @xmath86 the following policy plays a key role throughout this paper .    for each @xmath87 ,",
    "whenever a new arrival and/or service completion occurs at time @xmath17 in component @xmath79 , execute the following algorithm immediately after all arrivals and service completions have occurred :    * find the set @xmath88 of non - maximal activities in @xmath89 with respect to @xmath90 .",
    "* find a job with the smallest counter among those in buffers @xmath91 , where ties are broken arbitrarily .",
    "* choose an arbitrary activity @xmath92 to process the job identified in step 2 ,",
    "i.e. , set @xmath93 . * repeat steps 13 until @xmath89 is maximal with respect to @xmath90 .",
    "we next introduce the maximal scheduling policy which is of primary interest in this paper .",
    "it uses a small parameter @xmath94 in order to deal with unbounded route lengths .",
    "[ def : eplrfs ] for each @xmath87 , whenever a new arrival and/or service completion occurs at time @xmath17 in component @xmath79 , execute the following algorithm immediately after all arrivals and service completions have occurred :    * find a buffer @xmath95 containing a job with the largest counter among those in buffers @xmath79 .",
    "* find the set of non - maximal activities @xmath96 in @xmath89 . *",
    "if @xmath97 and @xmath98 , * * with probability @xmath0 , choose an arbitrary activity @xmath92 to process the job identified in step 1 , i.e. , set @xmath27 . with probability @xmath99 , do nothing .",
    "* * set @xmath100 . *",
    "execute the lrfs policy for component @xmath79 .",
    "we remark that the @xmath0-lrfs policy is identical to the lrfs policy when either @xmath101 or @xmath82 , i.e. , execution of the first three steps is not necessary in these cases .",
    "since we assume that each timer decreases at unit rate , step 3 - 1 can be executed at most once per component in any time interval of unit length .",
    "[ [ the - network - process . ] ] the network process .",
    "+ + + + + + + + + + + + + + + + + + + +    write @xmath102 for the queue length of jobs with counter @xmath103 in buffer @xmath10 at time @xmath17 .",
    "let @xmath104 be the remaining service requirement of the job with counter @xmath103 in buffer @xmath10 at time @xmath17 if it is processed by activity @xmath7 , and set @xmath105 if @xmath7 is not processing a job with counter @xmath103 .",
    "the network state is described by @xmath106~\\in~\\omega_x:=\\left(\\mathbb{z}_+^i\\times \\mathbb{r}_+^{i\\times j}\\right)^{\\infty}\\times [ 0,1]^h.\\ ] ] note that @xmath107 does not encode information on the external arrival processes . in particular",
    ", @xmath108 is non - markovian in general .",
    "we impose the convention that @xmath108 has right - continuous sample paths .",
    "we define a norm on @xmath109 through @xmath110 we assume that @xmath111 where @xmath112 . in synchronized networks ,",
    "one has @xmath113 for all @xmath114 under the @xmath0-lrfs policy .",
    "we refer to the process @xmath115 operating under the @xmath0-lrfs policy as the @xmath0-lrfs process . if @xmath101 , then we simply refer to this process as the lrfs process .",
    "[ [ network - stability . ] ] network stability .",
    "+ + + + + + + + + + + + + + + + + +    this paper uses the following notion of stability .",
    "the @xmath0-lrfs process @xmath108 is called queue - length - stable if @xmath116ds<\\infty,\\ ] ] for any given initial state @xmath117 .",
    "we establish the queue - length - stability by constructing appropriate lyapunov functions . under some additional assumptions on the arrival processes and service time distributions",
    ", these lyapunov functions can also be used to establish positive recurrence of the @xmath0-lrfs process , cf .  condition ( a3 ) in @xcite .",
    "it is outside of the main scope of the current paper to work out the details .",
    "we also remark that our proof can find an explicit finite constant for the right - hand side of , but this requires tedious bookkeeping and we therefore do not carry out this analysis .    to show the desired stability , we need the following notion of a ` local ' lyapunov function .    [ def : local ] we say that @xmath118 is a _ local lyapunov function _ with slack parameter @xmath119 if there exist constants @xmath120 , @xmath121 such that for every pair @xmath122 satisfying @xmath123 , @xmath124 where @xmath125\\in\\mathbb r^{i}$ ] .",
    "the reason for this nomenclature is that in a ` local ' network , i.e. , a network without routing ( @xmath126 ) , the above inequality for @xmath127 provides the desired negative drift condition in the foster - lyapunov criteria @xcite , which implies network stability .",
    "here @xmath128 , @xmath129 , and @xmath130 can be interpreted as the immediate workload , the external workload arrival rate and the workload processing rate at buffer @xmath10 , respectively .",
    "we refer to sections  [ sec : overview ] and [ sec : application ] for examples of local lyapunov functions .",
    "now we are ready to state the main theorem of this paper , which establishes ` global ' stability using a ` local ' quadratic lyapunov function .",
    "[ thm : main ] suppose that there exists a symmetric matrix @xmath131 such that @xmath132 is a local lyapunov function with slack @xmath133 .",
    "then the @xmath0-lrfs process is queue - length - stable if one of the following conditions c1 and c2 is satisfied :    * the network is synchronized and @xmath134 only if buffers @xmath10 and @xmath12 are in the same component .",
    "* @xmath134 only if buffers @xmath10 and @xmath12 are activity - interchangeable and every buffer @xmath10 has an associated activity @xmath50 with @xmath135",
    ".    furthermore , if all routes are bounded , then the lrfs process is queue - length - stable if one of the conditions c1 or c2@xmath136 is satisfied , where    * @xmath134 only if buffers @xmath10 and @xmath12 are activity - interchangeable .",
    "theorem  [ thm : main ] implies that if any maximal policy is ` quadratic ' stable in a stochastic processing network without routing under the external load @xmath137 , then @xmath0-lrfs is stable in a stochastic processing network with routing under nominal load @xmath138 for some small @xmath133 .",
    "section  [ sec : overview ] describes the main idea of the proof , and a full proof is presented in section [ sec : pfthmmain ] .",
    "we remark that the requirement of activity - interchangeable buffers in condition _",
    "c2 _ can be relaxed slightly .",
    "our proof of theorem [ thm : main ] also works when the following relaxed condition _",
    "c3 _ replaces _",
    "* @xmath134 only if for every @xmath50 , there exists @xmath139 such that @xmath140 , and vice versa ( i.e. , for every @xmath141 , there exists @xmath142 such that @xmath140 ) . also , every buffer @xmath10 has an associated activity @xmath50 with @xmath135 .    a corresponding condition _ c3@xmath136 _ can also replace _ c2@xmath136 _ , where _ c3@xmath136 _ does not require the second part of",
    "in this section , we describe the main idea in the proof of theorem [ thm : main ] .",
    "we first present it in a very special network , the rybko - stolyar network @xcite , which allows us to summarize the main idea of the proof at a high level .",
    "we subsequently describe the challenges that have to be overcome to establish our result in the general case , and discuss the feasibility of an approach based on fluid models .",
    "this network consists of four activities associated to four different buffers and two processors .",
    "the first processor is required for activities 1 and 4 , and the second for activities 2 and 3 .",
    "each activity decreases the remaining service requirement of the job it is currently processing at unit rate ( i.e. , @xmath143 ) .",
    "customers ( or jobs ) arrive at the first and third buffers , and traverse the buffers deterministically in the order @xmath144 or @xmath145 .",
    "the service time is deterministic and equal to @xmath146 for buffer @xmath10 , and the external arrival processes ( at the first and third buffers ) are independent poisson processes with rate 1 .",
    "the network is given in figure  [ fig : rybkostolyar ] , and a necessary condition for stability is @xmath147        the network state can be described by @xmath148 , where @xmath58 is the queue length ( i.e. , the number of jobs waiting ) of buffer @xmath10 at time @xmath17 and @xmath59 is the remaining service time of the job currently being processed in buffer @xmath10 at time @xmath17 .",
    "hence @xmath149 if no job is being processed in buffer @xmath10 .",
    "we define a norm through @xmath150 . in this network",
    ", it is known @xcite that if processor 1 prioritizes buffer 4 and processor 2 prioritizes buffer 2 , the network can be unstable even when the necessary condition holds . on the other hand , lrfs prioritizes buffer 1 and 3 , so it reduces to the first buffer first served policy .",
    "this is known to be stable under the necessary stability condition .",
    "we next derive this stability result using our main idea .",
    "assuming lrfs and , we construct an appropriate lyapunov function @xmath151 satisfying @xmath152 & \\leq&-\\gamma    @xmath153 are some constants . by first taking expectations with respect to the distribution of @xmath107 and then integrating over @xmath17 on both sides of the above inequality , we conclude that @xmath154ds&\\leq & \\limsup_{t\\to\\infty } \\frac1{\\gamma}\\left({\\mathcal c}- \\frac{\\int_t^{t+1 } e[{\\mathcal l_{\\mathrm{global}}}(x(s))]ds-\\int_0 ^ 1 e[{\\mathcal l_{\\mathrm{global}}}(x(s))]ds}t\\right)\\nonumber\\\\ & \\leq & \\limsup_{t\\to\\infty } \\frac1{\\gamma}\\left({\\mathcal c}+ \\frac{\\int_0 ^ 1 e\\left[{\\mathcal l_{\\mathrm{global}}}(x(s))\\right ] ds}t\\right)\\nonumber\\\\ & = & \\frac{{\\mathcal c}}{\\gamma}~<~\\infty.\\label{eq : stabilityrybkostolyar}\\end{aligned}\\ ] ]    we now proceed toward constructing the ` global ' lyapunov function @xmath155 satisfying based on a ` local ' quadratic lyapunov function @xmath127 . to this end , we first discuss how to construct the ` local ' quadratic lyapunov function .",
    "consider a single - processor system with two buffers @xmath156 and @xmath157 , deterministic service times given by @xmath158 and @xmath159 , and independent poisson arrival processes with rate @xmath75 at each buffer ( i.e. , the total rate is @xmath160 ) .",
    "hence , a necessary condition for stability is @xmath161 under a maximal ( i.e. , work - conserving ) scheduling policy , the workload @xmath162 at time @xmath17 satisfies @xmath163 where @xmath56 is defined as the immediate workload at buffer @xmath10 as in , @xmath37 is the number of jobs arriving at buffer @xmath10 during the time interval @xmath38 so that @xmath164=t - s$ ] and we define @xmath165 hence , we have @xmath166~\\leq~m_a+m_b- { \\bf 1}^+_{w(t)-1},\\label{eq : singleserver0}\\ ] ] where we use that @xmath167 for @xmath168 $ ] since we assume deterministic service times . using this , it follows that for some finite constant @xmath169 , @xmath170&= & e\\left [ 2w(t)(w(t+1)-w(t))~\\bigg|~w(t)\\right]\\notag\\\\ & ~&\\qquad+ e\\left [ ( w(t+1)-w(t))^2~\\bigg|~w(t)\\right]\\notag\\\\ & \\leq&2w(t ) e\\left[w(t+1)-w(t)~\\bigg|~w(t)\\right]+ { \\mathcal c}\\notag\\\\&\\leq&2w(t)\\left(m_a+m_b-{\\bf 1}^+_{w(t)-1 } \\right)+ { \\mathcal c}\\notag\\\\ & < & -2(1-m_a - m_b)w(t)+{\\mathcal c}+2,\\label{eq : singleserver}\\end{aligned}\\ ] ] where we use @xmath171<\\infty$ ] for the first inequality .",
    "this shows that @xmath172 is a suitable lyapunov function for our ` local ' single - processor system under the necessary stability condition @xmath173 .",
    "this observation on the single - processor system motivates the following quadratic local lyapunov function @xmath118 for the rybko - stolyar network : @xmath174 one can easily check that it satisfies with ( small ) slack @xmath133 under the necessary stability requirements @xmath175 and @xmath176 .",
    "we propose the following global lyapunov function @xmath155 : @xmath177 where the new parameters @xmath178 and @xmath179 shall be defined explicitly .",
    "we remind the reader that our goal is to prove .",
    "first , a similar calculation as for the single - processor case in yields that under the lrfs policy , @xmath180&\\leq & -{\\bf 1}^+_{w_1(t)+v_4(t)-1}+m_1,\\notag \\\\e\\left[w_3(t+1)+v_2(t+1)-w_3(t)-v_2(t)~\\big|~x(t)\\right]&\\leq & -{\\bf 1}^+_{w_3(t)+v_2(t)-1}+m_3.\\notag\\ ] ] hence , as for , one can conclude that for some constant @xmath169 , @xmath181&\\leq & -2(1-m_1)(w_1(t)+v_4(t))+{\\mathcal c},\\notag\\\\ \\label{eq1:globalrybkostolyar}\\\\e\\left[\\left(w_3(t+1)+v_2(t+1)\\right)^2-\\left(w_3(t)+v_2(t)\\right)^2~\\big|~x(t)\\right]&\\leq & -2(1-m_3)(w_3(t)+v_2(t))+{\\mathcal c},\\notag\\\\ \\label{eq2:globalrybkostolyar}\\ ] ] where the precise value of @xmath169 can be different from line to line .",
    "we note that the sum @xmath182 is not a suitable choice for @xmath155 since it does not include @xmath183 and @xmath184 ( or @xmath185 and @xmath186 ) . to address this issue",
    ", we further use @xmath187 we refer to @xmath188 and @xmath189 as the total workload in buffer @xmath160 and @xmath190 , respectively . using this notation , one finds that under the lrfs policy , @xmath191&\\leq & -{\\bf 1}^+_{w_1(t)+w_4(t)-1}+m_1+m_4,\\notag\\\\e\\left[w_3(t+1)+\\widehat w_2(t+1)-w_3(t)-\\widehat w_2(t)~\\big|~x(t)\\right]&\\leq & -{\\bf 1}^+_{w_2(t)+w_3(t)-1}+m_2+m_3.\\notag\\ ] ] the above equalities can be used to obtain ` negative drift terms ' for @xmath185 and @xmath186 , which are missing in and .",
    "namely , for some constant @xmath169 , we obtain @xmath192\\notag\\\\ & & \\qquad\\qquad\\leq~ 2\\left(w_1(t)+\\widehat w_4(t)\\right ) e\\left[w_1(t+1)+\\widehat w_4(t+1 ) -w_1(t)-\\widehat w_4(t)~\\big|~x(t)\\right]+{\\mathcal c}\\notag\\\\ & & \\qquad\\qquad\\leq~2\\left(w_1(t)+\\widehat w_4(t)\\right)\\left(-{\\bf 1}^+_{w_1(t)+w_4(t)-1}+m_1+m_4\\right)+{\\mathcal c}\\notag\\\\ & & \\qquad\\qquad\\leq~-2(1-m_1-m_4)\\left(w_1(t)+ w_4(t)\\right)+2(m_1+m_4)m_4q_3(t)+{\\mathcal c}+2\\notag\\\\ & & \\qquad\\qquad\\leq~-2(1-\\rho_{\\max})\\left(w_1(t)+ w_4(t)\\right)+2m^*\\rho_{\\max } w_3(t)+{\\mathcal c}+2,\\label{eq3:globalrybkostolyar}\\end{aligned}\\ ] ] where @xmath193 and @xmath194 .",
    "similarly , @xmath195\\notag\\\\ & & \\qquad\\qquad\\qquad\\qquad\\qquad\\leq-2(1-\\rho_{\\max})\\left(w_3(t)+ w_2(t)\\right)+2m^*\\rho_{\\max } w_1(t)+{\\mathcal c}+2.\\label{eq4:globalrybkostolyar}\\end{aligned}\\ ] ]    observe that there are positive terms @xmath196 and @xmath197 in and , respectively .",
    "the key idea behind our proof is that the positive terms can be canceled out by appropriately summing , , and . indeed , we define the desired lyapunov function @xmath155 as @xmath198 where we choose @xmath199 . combining , , and , we conclude that @xmath200~\\leq~-2\\xi(1-\\rho_{\\max } )    desired stability .",
    "the preceding subsection presents the main idea behind our construction of a ` global ' lyapunov function @xmath155 using a ` local ' lyapunov function @xmath127 ( i.e. , from the single - processor system ) in the specific example of the rybko - stolyar network .",
    "the construction of @xmath155 relies on summing @xmath127 terms inductively by exploring certain maximality properties of the lrfs policy at each iteration . in general networks",
    "there are several difficulties which do not arise in the rybko - stolyar network , and this section discusses the ideas and arguments needed to overcome them .    a first challenge we have overcome arises in networks with unbounded route lengths ( i.e. , @xmath201 ) . in that case ,",
    "the above inductive procedure does not terminate .",
    "for this reason , we propose a variant of the lrfs policy , the @xmath0-lrfs policy , which occasionally processes a job with the largest counter . intuitively speaking ,",
    "this additional mechanism in @xmath0-lrfs can control the jobs with large counters , whereas lrfs can not .",
    "a second challenge we have surmounted is that the construction of @xmath155 in the rybko - stolyar network starts from a simple local lyapunov function in a single - server system , but it is not clear whether similar arguments go through for general local lyapunov functions and stochastic processing networks .",
    "we require condition _",
    "c2 _ to resolve this issue .",
    "it is readily seen that the local lyapunov function used in the rybko - stolyar network satisfies this condition .",
    "the condition can be relaxed under some additional conditions on the arrival processes and service time distributions .",
    "for example , in synchronized networks , condition _",
    "c1 _ can be used instead of _",
    "c2_.    a further challenge in the general case relates to the definition of @xmath179 . in the rybko - stolyar network",
    ", it is the sum of workloads along a path of buffers , with @xmath10 as the last buffer .",
    "this definition only applies to networks with deterministic routing . in the general case we use several notions of total workload . to allow for stochastic routing",
    ", we construct a new process @xmath202 from @xmath108 with deterministic routing .",
    "this process is essentially identical to @xmath108 , but we enlarge the state space to incorporate routing information .",
    "we construct a lyapunov function @xmath155 for @xmath202 , which we use to establish the stability of @xmath202 and hence the stability of @xmath108 .    in summary",
    ", we construct the lyapunov function @xmath155 for general networks as the sum of three parts : @xmath203 the specific notation used here is not important ; we refer readers to section [ sec : pfthmmain ] for the definitions used .",
    "to prove stability , we need to argue that this function satisfies a so - called negative - drift condition .",
    "the first term , i.e. , the finite sum , comes from the inductive construction under lrfs , appropriately truncated . for the rybko - stolyar network",
    ", this is the only part we need .",
    "the first part produces the desired negative drift for jobs with low counters , but it gives a positive drift in terms of remaining service requirements @xmath204 as a by - product ( albeit not in the rybko - stolyar network under the assumptions of the preceding subsection ) .",
    "the second term in our lyapunov function ( @xmath205 ) has a negative drift and compensates the positive drift incurred by the first term .",
    "the third term in our lyapunov function ( @xmath206 ) controls the high - counter jobs under the mechnism which is present in the @xmath0-lrfs policy but not in the lrfs policy ( step 3 in definition  [ def : eplrfs ] ) .",
    "this additional mechanism allows us to establish a negative drift for the last term . by appropriately weighing each of the three terms",
    ", we derive the desired negative drift condition for the lyapunov function @xmath155 .",
    "as mentioned in the previous subsection , our approach relies on an inductive argument based on job counters . for the rybko - stolyar network and",
    "more generally for multiclass networks , fluid models can be used to give relatively simple proofs of our results .",
    "thus , a more detailed discussion on the connection with fluid models together with its pros and cons is warranted .",
    "the fluid approach consists of two main steps . in the first step , by scaling time and space ,",
    "one proves convergence of the queueing process to the solution of a system of deterministic equations known as the _",
    "fluid model_. in the second step , one proves that this fluid model is stable , i.e. , that it eventually reaches the origin .",
    "stability of the fluid model can be established through the construction of a lyapunov function for the fluid model , or in some cases one can obtain fluid stability through direct methods such as induction .",
    "once fluid stability has been established , one can apply general theorems to deduce that the stochastic model is also stable ( in a certain sense ) , see for instance @xcite .",
    "it might be possible to establish existence of a fluid model and to prove that the stochastic model converges to the fluid model in the setting of the present paper , and it can be expected that our ` global ' lyapunov function should work to prove fluid stability . comparing our approach with this proof strategy ,",
    "a disadvantage of the fluid model is that one needs to establish convergence to the fluid model , while a disadvantage of our approach is that we have to keep track of detailed state information such as residual service times .",
    "another possible approach to establish fluid stability is to use an inductive argument , which may seem particularly attractive given our construction of job counters and the suitability of a induction argument in existing work on fluid models @xcite .",
    "however , this approach has inherent challenges .",
    "the base step in an inductive approach could use the ` local ' lyapunov function @xmath127 to argue that the fluid level of jobs with counter 1 vanishes after some finite time @xmath207 .",
    "it would then use @xmath127 to argue that the fluid level of jobs with counter 2 vanishes after some finite time @xmath208 , and so forth . to carry out this argument",
    ", one has to show that @xmath127 satisfies a certain negative - drift condition under the assumption that high - priority counter 1 jobs vanish on a fluid scale .",
    "the latter only yields a guarantee on the ` average ' or ` long - run ' behavior of the jobs with counter 1 , whereas one needs ` short - term ' network state information to establish the negative - drift condition for jobs with counter 2 . indeed , under our scheduling policy , jobs with counter 1 ( even when vanishing on a fluid scale )",
    "can significantly influence the dynamics of jobs with counter 2 depending on the complexity of the network .",
    "therefore , the base of the induction approach is too weak to be used in the induction step for general networks since one needs more detailed information than the time - average given by the fluid approach .    in special cases such as multiclass networks",
    ", one may not need quadratic lyapunov functions and it may be possible to establish the stability of our counter - based policy using fluid induction without quadratic lyapunov functions .",
    "however , in general ( e.g. , for networks of switches ) , we need quadratic lyapunov functions since they are the only available tool to establish stability for single - hop networks .",
    "in this section , we provide applications of theorem [ thm : main ] to various special stochastic processing networks . we consider parallel server networks ( including multiclass queueing networks ) in section [ sec : mcqn ] and communication networks ( including wireless networks and networks of input - queued switches ) in section [ sec : swn ] .",
    "they are examples of non - synchronized and synchronized networks , respectively . in all of these important examples ,",
    "suitable local lyapunov functions are easy to find .      in this section",
    ", we consider special stochastic processing networks known as _",
    "parallel server networks_. these networks are characterized by the following assumption .    *",
    "each activity is processed by exactly one processor and processes exactly one buffer , i.e. , @xmath209    figure [ fig : psn ] illustrates the relations between buffers , activities and processors in parallel server networks .",
    "our notion of ` parallel server network ' generalizes the well - studied parallel server systems @xcite by adding stochastic routing dynamics between buffers .",
    "it also includes open multiclass queueing networks @xcite as a special case , which additionally require @xmath210 in open multiclass queueing networks , buffers and activities are in one - to - one correspondence and they are referred to as _",
    "classes_. the rybko - stolyar in section [ sec : overview ] is an instance of open multiclass queueing networks .",
    ", three processors @xmath211 and eight activities @xmath212 .",
    "once a job in buffer @xmath213 completes its service requirement , it joins buffer @xmath214 ( i.e. , @xmath215 ) , respectively .",
    "once a job in buffer @xmath216 completes its service requirement , it leaves the network .",
    "the rightmost diagram illustrates a parallel server network consisting of three ` local ' parallel server systems where jobs are routed between local systems .",
    ", width=566 ]    a parallel server network naturally defines a bipartite graph @xmath217 such that each activity in @xmath218 defines an edge between buffers @xmath219 and processors @xmath220 .",
    "requirement of open multiclass queueing networks imposes the additional restriction that each vertex in @xmath219 has degree one .",
    "we further consider the following strengthening of assumption _",
    "@xmath217 is a union of disjoint complete bipartite graphs @xmath221",
    ", i.e. , @xmath222    this assumption implies that two buffers in the same component are activity - interchangeable , even though they may differ with respect to routing , external arrivals or service requirements .",
    "one can easily check that open multiclass queueing networks always satisfy this assumption , while the parallel server networks in figure [ fig : psn ] do not .",
    "a2 _ is useful because it enables us to establish a necessary condition for stability and it allows us to find a suitable local lyapunov function satisfying condition _",
    "c2 _ of theorem [ thm : main ] . however , theorem [ thm : main ] is applicable to general networks as long as one can find a ` good ' local lyapunov function satisfying condition",
    "_ c2_. figure [ fig : psn2 ] gives examples of parallel server networks satisfying assumption _",
    ".,width=529 ]    [ [ necessary - condition - for - stability . ] ] necessary condition for stability .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we now aim to obtain a necessary condition for stability of a parallel server network . under assumption _ a2 _ , a necessary condition to stabilize",
    "the network is that for every @xmath223 , @xmath224 it is clear that the above condition is required for stability since @xmath225 and @xmath226 describe the total nominal load and the maximum processing rate , respectively , at the local component @xmath227 .",
    "[ [ local - lyapunov - function . ] ] local lyapunov function .",
    "+ + + + + + + + + + + + + + + + + + + + + + + +    as in section  [ sec : overview ] , the single - processor example is the main building block .",
    "we define the local lyapunov function as @xmath228 we now show that this function satisfies ( [ eq : localcondition ] ) with some slack @xmath119 as long as the necessary condition for stability is satisfied . for given vectors @xmath68\\in\\mathbb{r}_+^i$ ] and @xmath34\\in\\mathcal m({\\boldsymbol{w}})$ ] , maximality implies that , on writing @xmath229 , @xmath230 where we use assumption _ a2 _ and we recall that @xmath231 if @xmath232 , and @xmath233 otherwise .",
    "thus , we have @xmath234\\\\ & \\leq&{\\mathcal c}+2\\sum_{h\\in{\\mathcal h } } w^{(h)}\\left(\\rho^{(h)}+\\varepsilon\\ , m^{(h)}- s^{(h)}\\right)\\\\ & \\leq&{\\mathcal c}+2\\sum_{h\\in{\\mathcal h } } w^{(h)}\\left(\\rho^{(h)}+\\varepsilon\\ , m^{(h)}- { \\bf 1}^+_{w^{(h)}}\\beta^{(h)}\\right)\\\\ & = & { \\mathcal c}+2\\sum_{h\\in{\\mathcal h } } w^{(h)}\\left(\\rho^{(h)}+\\varepsilon\\ , m^{(h)}-\\beta^{(h)}\\right),\\end{aligned}\\ ] ] where @xmath169 is some constant and we define @xmath235 therefore , @xmath127 is a local lyapunov function with slack @xmath0 for @xmath236 where the right - hand side is positive if holds .",
    "[ [ stability - of - lrfs - policies . ] ] stability of lrfs policies .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + +    we now formulate the main results of this paper for open multiclass networks and parallel server networks . under assumption _",
    "a2 _ , the local lyapunov function satisfies condition _ c2 _ of theorem [ thm : main ] .",
    "therefore , we obtain the following proposition as a corollary . we remind the reader that open multiclass queueing networks are special instances of parallel server networks , and that assumption _ a2",
    "_ automatically holds for these networks .",
    "[ cor : psn ] if a stochastic processing network satisfies assumption _ a2 _ with @xmath237 for all @xmath223 , then    * the @xmath0-lrfs process is queue - length - stable for any @xmath238 * the lrfs process is queue - length - stable if all routes are bounded in length .",
    "we note that the @xmath0-lrfs policy admits a simpler description in a stochastic processing network satisfying assumption _ a2 _ , since a job can be processed by any processor in the partition , i.e. , @xmath88 in definition [ def : eplrfs ] is non - empty whenever a processor is idle and capable of processing a job .",
    "indeed , the @xmath0-lrfs policy reduces to the following work - conserving randomized priority policy : whenever a processor @xmath28 is idle at time @xmath17 and there are jobs capable of being processed by @xmath28 ,    * process a job with the smallest counter with probability @xmath239 , otherwise process a job with the largest counter . * set @xmath100 if @xmath98 ,    where @xmath79 is the ( local ) component of buffers associated with processor @xmath28 .",
    "proposition [ cor : psn ] implies that the @xmath0-lrfs policy can achieve ` almost ' the full capacity region by choosing a small @xmath133 .",
    "our proof of proposition  [ cor : psn ] provides a different proof for some results that have been established using fluid model techniques . for example , in reentrant lines , the @xmath0-lrfs policy for @xmath101 is identical to the well - known first buffer first served ( fbfs ) policy .",
    "our proposition implies that the fbfs policy is throughput optimal in all reentrant lines , which has been proved originally in @xcite .",
    "we now consider examples of synchronized stochastic processing networks described in section [ sec : defspn ] , i.e. , @xmath240 , for all @xmath241 .",
    "in particular , we consider the following additional assumption on synchronized stochastic processing networks .    *",
    "each buffer has exactly one associated activity , i.e. , @xmath242 hence , we write @xmath243 .",
    "we again remark that assumption _ b1 _ facilitates a suitable local lyapunov function for theorem [ thm : main ] .",
    "however , even if assumption _ b1 _ does not hold , theorem [ thm : main ] is applicable to synchronized stochastic processing networks as long as one can find a ` good ' local lyapunov function . synchronized stochastic processing networks satisfying assumption _ b1 _ include various communication network models of unit - sized packets : networks of input - queued switches @xcite , wireless network models with primary interference constraints @xcite and independent - set interference constraints @xcite .",
    "we refer the corresponding references for detailed descriptions of the network models . as a concrete example",
    ", we write out the details of the wireless network model with primary interference constraints .    [ [ wireless - networks - with - primary - interference - constraints . ] ] wireless networks with primary interference constraints .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    consider a network of @xmath223 nodes represented by @xmath244 and a set of directed paths @xmath245 .",
    "unit - size packets arrive at the ingress node of each path as per an exogenous arrival process .",
    "assume that the network is synchronized , i.e. , each packet departs from a node at time @xmath246 and arrives at the next node on its route at time @xmath247 .",
    "the primary interference constraint means that each node can either send or receive ( it can not do both ) one packet at the time . a scheduling policy ( or algorithm )",
    "decides which packets transmit at each ( discrete ) time instance .",
    "figure [ fig : lsn ] illustrates a wireless network of four nodes with primary interference constraints .     and",
    "five paths @xmath248 . there is a buffer on each ( directed ) edge on each path , i.e. , six buffers in total .",
    "unit - size packets arrive at the ingress buffer ( i.e. , the first node ) of each path . in the leftmost diagram ,",
    "two links @xmath249 and @xmath250 are transmitting ( unit - sized ) packets .",
    "once a packet is transmitted , it leaves the network if it arrives at the destination node ( i.e. , the last node on its path ) .",
    "the rightmost diagram illustrates the corresponding stochastic processing network , where the relation between buffers , activities and processors induces a hypergraph ( each buffer requires two processors),width=566 ]    .",
    "[ fig : lsn ]    [ [ necessary - condition - for - stability.-1 ] ] necessary condition for stability .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    as in the parallel server networks , one can obtain the following necessary condition to stabilize a stochastic processing network satisfying assumption _ b1 _ : for all @xmath251 , @xmath252 this is because assumption _ b1 _ implies that each buffer has at most one associated activity , and the processing rate is @xmath75 .    [ [ local - lyapunov - function.-1 ] ] local lyapunov function .",
    "+ + + + + + + + + + + + + + + + + + + + + + + +    we consider the following local lyapunov function:@xmath253 we now proceed toward proving that condition ( [ eq : localcondition ] ) holds . for",
    "given vectors @xmath68\\in\\mathbb{r}_+^i$ ] and @xmath34\\in\\mathcal m({\\boldsymbol{w}})$ ] , maximality implies that @xmath254 thus , we have that , on writing @xmath255 , @xmath256 where @xmath169 is some constant .",
    "therefore , ( [ eq : localcondition ] ) holds if @xmath257 .",
    "the above interval is non - empty as long as @xmath258 for all @xmath259 .",
    "[ [ stability - of - lrfs - policies.-1 ] ] stability of lrfs policies .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + +    we now state the main result for synchronized stochastic networks satisfying assumption _",
    "b1_. since the network is synchronized , we obtain the following proposition as a corollary of theorem [ thm : main ] .",
    "[ cor : sn ] if a stochastic processing network is synchronized and satisfies assumption b1 with @xmath260 for all @xmath259 , then    * the @xmath0-lrfs process is queue - length - stable for any @xmath261 implies that the @xmath0-lrfs policy can achieve a @xmath262 fraction of the capacity region . for networks of input - queued switches",
    "@xcite and wireless networks with primary interference constraints @xcite , it is easy to see that @xmath263 , and hence the @xmath0-lrfs policy achieves 50% of the capacity region . for wireless networks with general independent set constraints @xcite",
    ", @xmath264 is the maximum number of interfering neighbors , i.e. , the maximum degree of the underlying interference graph .    in large - scale networks ,",
    "distributed scheduling schemes with low complexity have gained much attention recently , even though they usually perform worse than centralized ones with high complexity .",
    "we remark that the 50% throughput result of a greedy scheduling algorithm has previously been established for input - queued switches ( i.e. , no routing between buffers ) by dai et al .",
    "proposition [ cor : sn ] generalizes this to ` networks ' of input - queued switches operated under stochastic routing between buffers ( or local switches ) . in wireless networks with primary interference constraints , wu et al .",
    "@xcite establish the 50% throughput result of the lrfs policy assuming deterministic routing ( i.e. , fixed routes between nodes ) , while proposition [ cor : sn ] allows stochastic routing .",
    "to prove the desired stability of the @xmath0-lrfs process @xmath108 , we construct a new process @xmath202 , which is almost identical to @xmath108 , but it has a larger state space . the main idea of the proof is to construct a lyapunov function for the ` larger ' process @xmath202 , which implies the stability of @xmath202 and therefore the stability of @xmath108 .",
    "the description of @xmath202 is as follows .",
    "consider the stochastic processing network setup in section [ sec : defspn ] , and let @xmath265 be the collection of all possible paths of buffers ( allowing repetitions ) of length at most @xmath266 ( i.e. , @xmath267 ) , where @xmath268 is some finite constant to be determined later .",
    "we assume that when a job enters the network , it pre - determines the first @xmath266 buffers on its route . after being processed from these @xmath266 buffers ,",
    "jobs perform the usual stochastic routing as described in section [ sec : defspn ] .",
    "let @xmath269 , @xmath270 and @xmath271 denote the @xmath272-th buffer on path @xmath273 , the number of jobs waiting in buffer @xmath274 and the remaining service requirement of the job in buffer @xmath274 being processed by activity @xmath7 at time @xmath17 , respectively . if activity @xmath7 is not processing a job in buffer @xmath274 , then @xmath275 . furthermore , as before , let @xmath102 be the queue length ( i.e. , the number of jobs waiting for service , excluding those being processed ) with counter @xmath103 in buffer @xmath10 at time @xmath17 .",
    "@xmath104 is defined to be the remaining service requirement of the job with counter @xmath103 in buffer @xmath10 being processed by activity @xmath7 at time @xmath17 .",
    "we then define @xmath276\\in\\omega_y:=\\mathbb{z}_+^{\\infty}\\times \\mathbb{r}_+^{\\infty}\\times [ 0,1]^h,\\end{aligned}\\ ] ] where @xmath277 are positive integers such that @xmath278 , @xmath279 , @xmath280 and @xmath281 .    as for @xmath108",
    ", we impose the convention that @xmath202 has right - continuous sample paths .",
    "we define the norm @xmath282 through @xmath283    one can define a natural projection @xmath24 such that the distribution of @xmath284 is identical to that of @xmath107 and @xmath285 given that @xmath286 is drawn appropriately from the preimage @xmath287 of @xmath288",
    ". intuitively speaking , @xmath202 tosses random coins to determine routes in advance , and since the scheduling decisions of @xmath0-lrfs are independent of these coins , the natural projection of @xmath202 ignoring these pre - determined coin flips provides exactly the dynamics of @xmath108 .",
    "hence , it suffices to prove that the ( bigger ) process @xmath289 is queue - length - stable , i.e. , @xmath290ds<\\infty , \\ ] ] for any given initial state @xmath291 .",
    "in essence , this follows from the following proposition , which is proved in section [ sec : pflem2 ] .",
    "[ lem2 ] if the conditions of theorem [ thm : main ] hold , then there exist constants @xmath292 and a lyapunov function @xmath293 such that for all @xmath294 , @xmath295&\\leq&\\mathcal l_{\\text{\\em global}}(y(t))-\\zeta | y(t)|+\\mathcal c,\\qquad\\mbox{almost surely},\\ ] ] and @xmath296 , where we define the filtration @xmath297 by @xmath298    now we describe how proposition [ lem2 ] implies , and hence the conclusion of theorem [ thm : main ] .",
    "first one can observe that @xmath299<\\infty$ ] since @xmath300 and we assume bounded second moments on arrivals and service times .",
    "since @xmath301 from proposition [ lem2 ] , it follows that @xmath302,e\\left[{\\mathcal l_{\\mathrm{global}}}(y(t))\\right],e\\left[| y(t)|\\right]<\\infty.\\ ] ] combining proposition [ lem2 ] and yields that for all @xmath294 , @xmath303~\\leq~e\\left[{\\mathcal l_{\\mathrm{global}}}(y(t))\\right]-\\zeta e\\left[| y(t)|\\right]+\\mathcal c.\\ ] ]    therefore , we have that for @xmath294 , @xmath304ds&=&\\int^t_n e\\left[{\\mathcal l_{\\mathrm{global}}}(y(s+t))\\right]ds\\\\ & \\leq&\\int^t_n e\\left[{\\mathcal l_{\\mathrm{global}}}(y(s))\\right]ds-\\zeta \\int^t_n e\\left[| y(s)|\\right]ds+\\mathcal c ( t - n),\\end{aligned}\\ ] ] which implies that for @xmath305 , @xmath306ds~\\leq~\\mathcal c+\\frac1{t - n}\\int^{t+n}_n e\\left[{\\mathcal l_{\\mathrm{global}}}(y(s))\\right]ds.\\ ] ] the right - hand side of the above inequality converges to @xmath169 as @xmath307 .",
    "this leads to the desired conclusion .",
    "the choice of @xmath308 in proposition [ lem2 ] comes from our assumption on the external arrival processes in section [ sec : defspn ] , namely , that there exists some @xmath309 such that for all @xmath310 and @xmath294 , @xmath311~\\leq~\\alpha_i.\\ ] ] for notational convenience , we assume @xmath312 in the proof of proposition [ lem2 ] .",
    "namely , we assume that for all @xmath74 , @xmath313~\\leq~\\alpha_i<\\infty.\\ ] ] all the proof arguments are applicable to the general case @xmath314 .",
    "we first define some further notation in section [ sec : not ] .",
    "the skeleton of the proof of proposition [ lem2 ] is described in section [ sec : skeleton ] , and it uses three key lemmas .",
    "the proofs of these lemmas follow .",
    "the quantities defined below are simple functions of the network state @xmath315 .",
    "we use bold symbols to denote vectors of quantities , e.g. , @xmath316 $ ] and @xmath317 $ ] .",
    "[ [ queues . ] ] queues .",
    "+ + + + + + +    for @xmath318 , let @xmath102 , @xmath319 and @xmath320 be the number of waiting jobs with counter @xmath103 , @xmath321 and @xmath322 in buffer @xmath10 at time @xmath17 , respectively .",
    "that is , we set @xmath323 where we recall that @xmath324 if @xmath325 and @xmath326 otherwise .",
    "furthermore , for @xmath327 , we let @xmath328 be the number of waiting jobs with counter @xmath322 ` in or destined for ' buffer @xmath10 at time @xmath17 .",
    "namely , @xmath329 where the first term ` @xmath330 ' and the second term ` @xmath331 ' on the right - hand side count the numbers of waiting jobs currently in buffer @xmath10 and destined for buffer @xmath10 , respectively .",
    "[ [ workloads . ] ] workloads .",
    "+ + + + + + + + + +    let @xmath332 denote the remaining service requirement of the job being processed by activity @xmath7 at time @xmath17 , and @xmath59 the total remaining service requirement of the jobs being processed in buffer @xmath10 at time @xmath17 ( multiple jobs can be processed from the same buffer by different processors ) . similarly , @xmath333 stands for the total remaining service requirement of jobs with counter @xmath103 , @xmath321 , @xmath322 being processed in buffer @xmath10 at time @xmath17 , respectively .",
    "we furthermore define the following quantities :    * if the network is not synchronized , @xmath334 * if the network is synchronized , @xmath335    we use different definitions for these variables depending on whether the network is synchronized or not , since the strategy of the proof differs in each case , e.g. , see section [ sec : pflemkey1 ] .",
    "we also note that in a synchronized network , @xmath336 for @xmath337 .",
    "the quantities @xmath338 and @xmath339 are ( expected ) immediate workloads , since they only involve work that is in buffer @xmath10 at time @xmath17 .",
    "the quantities @xmath340 are ( expected ) total workloads , since they incorporate work currently in the system which will be routed to buffer @xmath10 , regardless where the work resides in the network at time @xmath17 .",
    "[ [ three - types - of - jobs - weights . ] ] three types of jobs & weights .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we distinguish three types of jobs :    * * * jobs with counter @xmath341 * * jobs on a path of length @xmath342 in @xmath343 .",
    "* * jobs on a path of length @xmath344 in @xmath343 .",
    "hence , the counters of jobs of type 2 and 3 can not exceed @xmath266 .",
    "we further note that each job ( regardless whether it is currently being processed or not ) can compute its expected total remaining service requirement in the future ( under the network process @xmath202 ) , and we call this quantity the weight of the job .",
    "namely , if a job is not currently being processed , its weight is @xmath345,\\end{aligned}\\ ] ] which includes the current buffer of the job .",
    "thus , the weight of a waiting job , not currently being processed , can be calculated as follows .",
    "* * * the weight of a waiting job of type 1 in buffer @xmath346 is @xmath347 where @xmath125\\in\\mathbb{r}_+^i$ ] and @xmath348 is the unit vector with zeros except for its @xmath10-th coordinate which equals to one ( both are column vectors ) . *",
    "* the weight of a waiting job of type 2 in buffer @xmath274 on a path @xmath273 of length @xmath266 ( i.e. , @xmath349 ) is @xmath350 where we note that @xmath351 is the last buffer on @xmath273 . * * the weight of a waiting job of type 3 in buffer @xmath274 on a path @xmath273 of length @xmath344 is @xmath352    on the other hand , for jobs currently being processed , each weight is calculated as @xmath353,\\end{aligned}\\ ] ] where the latter number does not include the current buffer of the job .",
    "now let @xmath354 , @xmath355 and @xmath356 be the total weights of jobs of type 1 , 2 and 3 at time @xmath17 , respectively .",
    "these total weights are fully determined by the network state information @xmath315 : @xmath357,\\\\ m_2(t)&=&\\sum_{n\\leq ( i+1)^d , m\\leq d : |p_n|=d}q_{nm}(t)\\left[{\\bf e}_{i_{nd}}^tp(i - p)^{-1}{\\boldsymbol{m}}+\\sum_{k = m}^{d } m_{i_{nk}}\\right]\\\\ & & \\quad+\\sum_{n\\leq ( i+1)^d , m\\leq d , j\\in j : |p_n|=d } { \\bf 1}^+ _ { v^j_{nm}(t)}\\left[v^j_{nm}(t)+{\\bf e}_{i_{nd}}^tp(i - p)^{-1}{\\boldsymbol{m}}+ \\sum_{k = m+1}^{d } m_{i_{nk}}\\right],\\\\ m_3(t)&=&\\sum_{n\\leq ( i+1)^d , m\\leq d :    & & \\qquad+\\sum_{n\\leq ( i+1)^d , m\\leq d , j\\in{\\mathcal j } : |p_n|<d } { \\bf 1}^+ _ { v^j_{nm}(t)}\\left[v^j_{nm}(t)+\\sum_{k = m+1}^{|p_n| } m_{i_{nk}}\\right],\\end{aligned}\\ ] ] where we recall that @xmath231 if @xmath232 , and @xmath233 otherwise .",
    "we state and prove the following three key lemmas , which we prove in section [ sec : pflemkey0 ] , [ sec : pflemkey1 ] and [ sec : pflemkey2 ] , respectively . to simplify notation , we will use @xmath358 to denote a finite constant which only depends on the matrix @xmath359 given in theorem [ thm : main ] or on the predefined network parameters from section [ sec : defspn ] .",
    "its precise value can be different from line to line .",
    "[ lem : key0 ] there exists a constant @xmath360 such that for all @xmath74 , @xmath361&\\leq&\\|{\\boldsymbol{v}}(t)\\|_2 ^ 2   -\\beta_{\\min}\\|{\\boldsymbol{v}}(t)\\|_1 + \\mathcal c ,   \\end{aligned}\\ ] ] where @xmath362 .",
    "[ lem : key1 ] suppose that there exists a symmetric matrix @xmath131 such that @xmath132 is a local lyapunov function with slack @xmath363 , and that either condition c1 or c2@xmath136 from theorem [ thm : main ] holds .",
    "then given @xmath364 , there exist constants @xmath365 such that for all @xmath327 , @xmath74 , @xmath366}\\\\&\\leq&\\mathcal l_{\\text{\\em local}}\\left(\\widehat{{\\boldsymbol{w}}}_{\\leq c}(t)\\right)- \\upsilon \\|{{\\boldsymbol{q}}}_{\\leq c}(t)\\|_1+{\\mathcal c}\\left(\\|{\\boldsymbol{v}}(t)\\|_1+\\|{{\\boldsymbol{q } } } _ { < c}(t)\\|_1 + 1\\right).\\ ] ]    [ lem : key2 ]    consider @xmath133 . if the network is synchronized or if condition c2 from theorem [ thm : main ] holds , then there exist constants @xmath367 and @xmath368 such that for all @xmath74 , @xmath369~\\leq~ \\mathcal g(y(t))^2 -\\gamma_2 \\|{\\boldsymbol{q}}_{>d}(t)\\|_1+{\\mathcal c}\\left(\\|{\\boldsymbol{q}}_{\\leq d}(t)\\|_1+\\|{\\boldsymbol{v}}(t)\\|_1 + 1\\right),\\ ] ] where @xmath370 .",
    "lemma [ lem : key2 ] is not needed for the proof of proposition [ lem2 ] if all routes are bounded .",
    "hence , for networks with bounded routes , @xmath101 is allowed and only condition _",
    "c2@xmath136 _ is needed for the desired stability .",
    "the right - hand sides of the inequalities in lemmas [ lem : key0 ]  [ lem : key2 ] provide ` negative drifts ' on @xmath371 , @xmath372 and @xmath373 , respectively . by appropriately weighing the functions in these three lemmas",
    ", we shall construct an appropriate ( global ) lyapunov function @xmath155 .",
    "to this end , from lemma [ lem : key0 ] , we obtain @xmath374&\\leq &      e\\left[\\|{\\boldsymbol{v}}(t+t-1)\\|_2 ^ 2~|~{\\mathcal f}(t)\\right ]       -\\beta_{\\min}e\\left[\\|{\\boldsymbol{v}}(t+t-1)\\|_1~|~{\\mathcal f}(t)\\right ] + \\mathcal c,\\notag\\\\       & \\leq &      e\\left[\\|{\\boldsymbol{v}}(t+t-1)\\|_2 ^ 2~|~{\\mathcal f}(t)\\right]+{\\mathcal c}\\notag\\\\      & \\leq &      e\\left[\\|{\\boldsymbol{v}}(t+t-2)\\|_2 ^ 2~|~{\\mathcal f}(t)\\right]+2{\\mathcal c}\\notag\\\\      & & \\qquad\\qquad\\dots\\notag\\\\ & \\leq&e\\left[\\|{\\boldsymbol{v}}(t+1)\\|_2 ^ 2~|~{\\mathcal f}(t)\\right]+(t-1){\\mathcal c}\\notag\\\\ & \\leq&\\|{\\boldsymbol{v}}(t)\\|_2 ^",
    "2   -\\beta_{\\min}\\|{\\boldsymbol{v}}(t)\\|_1 + t\\mathcal c,\\label{eq : bvbound1 }   \\end{aligned}\\ ] ] where @xmath375 is the constant from lemma [ lem : key2 ] .",
    "we write this inequality as @xmath376~\\leq~\\frac1{\\beta_{\\min}}\\|{\\boldsymbol{v}}(t)\\|_2 ^ 2   -\\|{\\boldsymbol{v}}(t)\\|_1 + \\mathcal c,\\label{eq1:pfmainthm}\\end{aligned}\\ ] ] where the constant @xmath169 is redefined appropriately .",
    "we now argue that , similarly , lemma  [ lem : key1 ] implies that @xmath377\\notag\\\\ & & \\qquad\\qquad\\qquad\\leq~{{\\mathcal l_{\\mathrm{local}}}}\\left(\\widehat{{\\boldsymbol{w}}}_{\\leq c}(t)\\right)- \\upsilon \\|{{\\boldsymbol{q}}}_{\\leq c}(t)\\|_1+{\\mathcal c}\\left(\\|{\\boldsymbol{v}}(t)\\|_1+\\|{{\\boldsymbol{q } } } _ { < c}(t)\\|_1 + 1\\right),\\label{eq2:pfmainthm}\\end{aligned}\\ ] ] where @xmath169 is some ( large ) constant which may different from the one in lemma [ lem : key1 ] . to see why this holds , we use the same argument that led to ( [ eq : bvbound1 ] ) with the additional observation that , for some constant @xmath378 , @xmath379-\\|{\\boldsymbol{v}}(t)\\|_1\\right)&\\le&{\\mathcal c}',\\label{eq : bvbound2}\\\\      \\sup_{s\\in\\{0,1,\\ldots , t\\ } } \\left(e\\left[\\|{\\boldsymbol{q}}(t+s)\\|_1~|~{\\mathcal f}(t)\\right]-\\|{\\boldsymbol{q}}(t)\\|_1\\right)&\\le&{\\mathcal c}'.\\label{eq : bqbound}\\end{aligned}\\ ] ] here can be derived along the lines of , and follows from and the observation that the change in queue length is majorized by the number of external job arrivals .",
    "we now show that proposition [ lem2 ] follows from these three lemmas , where the last lemma is not needed if all routes are bounded .",
    "we consider the following lyapunov function @xmath155 :    * if all routes are bounded , @xmath380 where we choose @xmath381 such that @xmath382 , and @xmath383 comes from lemma [ lem : key1 ] .",
    "* otherwise , @xmath384 where @xmath383 and @xmath266 is from lemma [ lem : key1 ] and [ lem : key2 ] , respectively , @xmath385 and @xmath169 is a large enough constant chosen so that it can be used for lemma [ lem : key2 ] as well as for and .",
    "we focus on proving proposition [ lem2 ] for the case of unbounded routes , but all arguments go through for the other case . without loss of generality , we assume that @xmath386 the property @xmath301 in proposition [ lem2 ] is readily seen to hold . to derive the negative drift property , we observe that lemma [ lem : key2 ] in conjunction with and imply that @xmath387\\\\   & & \\qquad\\leq{\\mathcal c}^*-2\\mathcal c \\|{{\\boldsymbol{v}}}(t)\\|_1+\\sum_{c=1}^d \\left(\\frac{\\upsilon}{2\\mathcal c}\\right)^c \\big[- \\upsilon \\|{{\\boldsymbol{q}}}_{\\leq c}(t)\\|_1+\\mathcal c \\|{{\\boldsymbol{q } } } _ { < c}(t)\\|_1+\\mathcal c \\|{{\\boldsymbol{v}}}(t)\\|_1\\big]\\\\ & & \\qquad\\qquad -\\frac{\\gamma_2\\xi}{2{\\mathcal c } } \\|{\\boldsymbol{q}}_{>d}(t)\\|_1+\\frac{\\xi}{2}\\left(\\|{\\boldsymbol{q}}_{\\leq d}(t)\\|_1+\\|{\\boldsymbol{v}}(t)\\|_1 + 1\\right)\\\\ & & \\qquad\\leq{\\mathcal c}^*-\\mathcal c \\|{{\\boldsymbol{v}}}(t)\\|_1+\\sum_{c=1}^d \\left(\\frac{\\upsilon}{2\\mathcal c}\\right)^c \\big[- \\upsilon \\|{{\\boldsymbol{q}}}_{\\leq c}(t)\\|_1+\\mathcal c \\|{{\\boldsymbol{q } } } _ { < c}(t)\\|_1\\big]\\\\ & & \\qquad\\qquad -\\frac{\\gamma_2\\xi}{2{\\mathcal c } } \\|{\\boldsymbol{q}}_{>d}(t)\\|_1+\\frac{\\xi}{2}\\left(\\|{\\boldsymbol{q}}_{\\leq d}(t)\\|_1+\\|{\\boldsymbol{v}}(t)\\|_1 + 1\\right),\\end{aligned}\\ ] ] where @xmath388 is some ( large enough ) constant and we use @xmath389 for the last inequality",
    ". the sum in this expression can be bounded as follows : @xmath390}\\\\   & = & -\\upsilon\\sum_{c=1}^d \\left(\\frac{\\upsilon}{2\\mathcal c}\\right)^c \\|{{\\boldsymbol{q}}}_{\\leq c}(t)\\|_1 + \\frac{\\upsilon}2\\sum_{c=1}^d \\left(\\frac{\\upsilon}{2\\mathcal c}\\right)^{c-1 } \\|{{\\boldsymbol{q } } } _ { < c}(t)\\|_1\\\\ & = & -{\\upsilon}\\left(\\frac{\\upsilon}{2{\\mathcal c}}\\right)^d\\|{{\\boldsymbol{q}}}_{\\leq d}(t)\\|_1-\\left ( \\upsilon-\\frac{\\upsilon}2\\right)\\sum_{c=1}^{d-1 } \\left(\\frac{\\upsilon}{2\\mathcal c}\\right)^c \\|{{\\boldsymbol{q}}}_{\\leq c}(t)\\|_1\\\\ & \\leq&- { \\upsilon}\\left(\\frac{\\upsilon}{2{\\mathcal c}}\\right)^d\\|{{\\boldsymbol{q}}}_{\\leq d}(t)\\|_1 ~=~-\\xi\\|{{\\boldsymbol{q}}}_{\\leq d}(t)\\|_1.\\end{aligned}\\ ] ] after combining the preceding two displays , we obtain the desired negative drift property : @xmath391}\\\\ & \\le&{\\mathcal c}^*-\\mathcal c",
    "\\|{{\\boldsymbol{v}}}(t)\\|_1-\\xi\\|{{\\boldsymbol{q}}}_{\\leq d}(t)\\|_1 -\\frac{\\gamma_2\\xi}{2{\\mathcal c } } \\|{\\boldsymbol{q}}_{>d}(t)\\|_1+\\frac{\\xi}{2}\\left(\\|{\\boldsymbol{q}}_{\\leq d}(t)\\|_1+\\|{\\boldsymbol{v}}(t)\\|_1 + 1\\right)\\\\ & \\leq&{\\mathcal c}^*+\\frac{\\xi}2-\\frac{\\gamma_2\\xi}{2{\\mathcal c}}\\left(\\|{{\\boldsymbol{v}}}(t)\\|_1 + \\|{{\\boldsymbol{q}}_{\\leq d}}(t)\\|_1+\\|{{\\boldsymbol{q}}_{>d}}(t)\\|_1\\right)\\\\ & = & { \\mathcal c}^*+\\frac{\\xi}2-\\frac{\\gamma_2\\xi}{2{\\mathcal c}}\\left(\\|{{\\boldsymbol{v}}}(t)\\|_1+\\|{{\\boldsymbol{q}}}(t)\\|_1\\right),\\end{aligned}\\ ] ] where we use @xmath392 and @xmath393 .",
    "this completes the proof of proposition [ lem2 ] .        on the other hand , on the event @xmath405 , @xmath406 hence , combining and , we find that for some constant @xmath407 , @xmath408~\\leq~ v^{j}(t)^2-\\beta_jv^{j}(t)+{\\mathcal c},\\ ] ] which leads to the desired conclusion of lemma [ lem : key0 ] .      for notational convenience , we stick to the case @xmath409 in the conclusion of lemma [ lem : key1 ] .",
    "namely , we show that @xmath410&\\leq&{{\\mathcal l_{\\mathrm{local}}}}\\left(\\widehat{{\\boldsymbol{w}}}_{\\leq c}(0)\\right)- \\upsilon \\|{{\\boldsymbol{q}}}_{\\leq c}(0)\\|_1+{\\mathcal c}\\left(\\|{\\boldsymbol{v}}(0)\\|_1+\\|{{\\boldsymbol{q } } } _ { < c}(0)\\|_1 + 1\\right).\\end{aligned}\\ ] ] however , all arguments go through for general @xmath411 .",
    "[ [ non - synchronized - network . ] ] non - synchronized network .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + +    we first consider the case when the network may not be synchronized .",
    "the first step in the proof is the observation that the schedule @xmath89 under the @xmath0-lrfs policy is always maximal with respect to the vector @xmath68=\\left[m_i q_{i,\\leq c}(t)\\right]$ ] for any @xmath412 .",
    "consequently , since the local quadratic lyapunov function @xmath413 satisfies , we obtain that for @xmath414 $ ] , @xmath415 where we further use the observation that @xmath416 we remind the reader that we write @xmath169 for a finite constant which may differ from line to line .",
    "since we set @xmath417 , it follows that @xmath418 after taking conditional expectations given @xmath419 on both sides in the above inequality , we obtain @xmath420~ \\leq~ -\\eta \\sum_{i\\in i } m_i q_{i,\\leq c}(0)+{\\mathcal c},\\ ] ] where we use that @xmath421\\geq{q}_{\\ell,\\leq c}(0)-{\\mathcal c}'$ ] for @xmath414 $ ] for some constant @xmath378 .",
    "this can be verified by suppressing any arrivals and letting all activities work , and then using the standard fact from renewal theory that any renewal function is finite .",
    "similarly , we obtain from @xmath422\\geq { q}_{\\ell,\\leq c}(0)-{\\mathcal c}'$ ] for @xmath423 $ ] that @xmath424~ \\leq~ -\\eta \\sum_{i\\in i } m_i q_{i,\\leq c}(0)+{\\mathcal c},\\ ] ] where the constant @xmath169 again has to be redefined appropriately .",
    "we leave this inequality for later use .",
    "the second step in the proof is to bound @xmath425 $ ] for fixed @xmath10 .",
    "let @xmath426 be the number of job arrivals contributing to an increase in @xmath427 during the time interval @xmath428 .",
    "then , one can check that for @xmath429 $ ] , @xmath430~\\leq~ \\left(i+p+\\dots + p^c\\right){\\boldsymbol{\\alpha}}~\\leq~{\\boldsymbol{\\lambda}},\\ ] ] since we assume . define the following quantities .    * @xmath431 and @xmath432 are the numbers of jobs in buffer @xmath10 which start their service during the time interval @xmath428 and with counter @xmath322 and @xmath433 , respectively .",
    "* @xmath434 and @xmath435 are the total amounts of service times generated by jobs contributing to @xmath431 and @xmath432 , respectively , again during the time interval @xmath428 .",
    "we stress that the contribution of each job to these quantities may exceed the service time it receives during the interval @xmath428 .",
    "* @xmath436 are the total amounts of service times generated by jobs contributing to @xmath437 due to the lrfs policy ( i.e. , step 4 in definition [ def : eplrfs ] ) . in addition",
    ", we set @xmath438 .",
    "then , we have that @xmath439taking conditional expectations given @xmath419 on both sides , we obtain@xmath440\\notag\\\\ & & \\qquad\\leq m_i\\lambda_i + e\\left[- m_i{d}_{i,\\leq c}+r_{i,\\leq c}~|~{\\mathcal f}(0)\\right]+e\\left[r_{i , > c}~|~{\\mathcal f}(0)\\right ] - e\\left[\\sum_{j\\in { \\mathcal j}_i}\\int^1_0 \\beta_j\\sigma_j(t)\\ , dt~\\bigg|~{\\mathcal f}(0)\\right]\\notag\\\\ & & \\qquad=\\rho_i+e\\left[r_{i , > c}~|~{\\mathcal f}(0)\\right ]   -e\\left[\\sum_{j\\in { \\mathcal j}_i}\\int^1_0 \\beta_j\\sigma_j(t)\\ , dt~\\bigg|~{\\mathcal f}(0)\\right].\\label{eq3:lemkey1}\\end{aligned}\\ ] ]    now we bound @xmath441 $ ] in the above inequality , or equivalently @xmath442+e\\left[r_{i , > c}^{(m)}~\\big|~{\\mathcal f}(0)\\right]$ ] since @xmath443 .",
    "first , one can check that @xmath444~\\leq~\\varepsilon m_i.\\ ] ] this is because the expected number of jobs in buffer @xmath10 which start their service during the time interval @xmath428 due to step 3 - 1 of the @xmath0-lrfs policy in definition [ def : eplrfs ] is at most @xmath0 since each timer @xmath445 is zero at most once during this time interval . on the other hand , to bound @xmath446 $ ] , consider activity - interchangeable buffers @xmath12 and @xmath10 ( which includes @xmath447 ) .",
    "let @xmath448 be the event that every job in the queue @xmath449 ( i.e. , jobs with counter @xmath322 waiting in buffer @xmath12 at time @xmath450 ) starts service during the time interval @xmath451 $ ] .",
    "one can observe that @xmath452 on the complementary event @xmath453 .",
    "we let @xmath454 where @xmath455 are identical random variables with mean @xmath456 and variance @xmath457 .",
    "we first consider the case when @xmath458=m_\\ell ( q_{\\ell,\\leq c}(0)-|{\\mathcal j}_\\ell|)>\\beta_{\\max}|{\\mathcal j}_\\ell|.\\ ] ] since @xmath448 occurs only if at least @xmath459 jobs complete their service requirements , we obtain the following on the event that holds : @xmath460&\\leq&\\pr\\left[n\\leq \\beta_{\\max}|{\\mathcal j}_\\ell|~|~{\\mathcal f}(0)\\right]\\notag\\\\   & = & \\pr\\left[n - e[n~|~q_{\\ell,\\leq c}(0)]\\leq \\beta_{\\max}|{\\mathcal j}_\\ell|-e[n~|~q_{\\ell,\\leq c}(0)]~|~{\\mathcal f}(0)\\right]\\notag\\\\   & \\leq&\\pr\\left[\\big(n - e[n~|~q_{\\ell,\\leq c}(0)]\\big)^2\\geq \\big(e[n~|~q_{\\ell,\\leq c}(0)]-\\beta_{\\max}|{\\mathcal j}_\\ell|\\big)^2~|~{\\mathcal f}(0)\\right]\\notag\\\\ & \\leq&\\frac{\\varsigma_\\ell^2 ( q_{\\ell,\\leq c}(0)-|{\\mathcal j}_\\ell|)}{\\big(e[n~|~q_{\\ell,\\leq c}(0)]-\\beta_{\\max}|{\\mathcal j}_\\ell|\\big)^2}\\notag\\\\ & = & \\frac{\\varsigma_\\ell^2 ( q_{\\ell,\\leq c}(0)-|{\\mathcal j}_\\ell|)}{\\big(m_\\ell(q_{\\ell,\\leq c}(0)-|{\\mathcal j}_\\ell|)-\\beta_{\\max}|{\\mathcal j}_\\ell|\\big)^2}\\notag\\\\ & \\leq&\\frac{{\\mathcal c}}{q_{\\ell,\\leq c}(0)+1},\\label{eq1:lemkey1}\\end{aligned}\\ ] ] where @xmath461 , @xmath169 is some ( finite ) constant depending on @xmath462 and we use markov s inequality in conjunction with . on the event that does not hold , i.e. , when @xmath449 is bounded above by @xmath463",
    ", one can redefine the constant @xmath169 so that holds .",
    "hence , always holds .    using",
    ", it follows that @xmath464&=&e\\left[r_{i , > c}^{(m)}~\\big|~{\\mathcal f}(0)\\right]+e\\left[r_{i , > c}^{(l)}~\\big|~{\\mathcal f}(0)\\right]\\\\ & \\leq&\\varepsilon m_i+ \\pr[\\mathcal e_\\ell~|~{\\mathcal f}(0)]\\cdot e\\left[r_{i , > c}^{(l)}~\\big|~\\mathcal e_\\ell,{\\mathcal f}(0)\\right]\\\\ & \\leq&\\varepsilon m_i+ \\frac{{\\mathcal c}}{q_{\\ell,\\leq c}(0)+1}\\cdot e\\left[r_{i , > c}^{(l)}~\\big|~\\mathcal e_\\ell,{\\mathcal f}(0)\\right]\\\\ & \\leq&\\varepsilon m_i+ \\frac{{\\mathcal c}}{q_{\\ell,\\leq c}(0)+1},\\end{aligned}\\ ] ] where the last inequality requires that the constant @xmath169 has to be redefined appropriately , since @xmath465\\le { \\mathcal c}'$ ] as can be seen using arguments similar to those leading up to .",
    "together with , this leads to @xmath466&\\leq & \\rho_i+\\varepsilon m_i+\\frac{{\\mathcal c}}{q_{\\ell,\\leq c}(0)+1 } -e\\left[\\sum_{j\\in { \\mathcal j}_i}\\int^1_0 \\beta_j\\sigma_j(t)\\ , dt~\\bigg|~{\\mathcal f}(0)\\right],\\label{eq4:lemkey1}\\end{aligned}\\ ] ] for any activity - interchangeable buffers @xmath12 and @xmath10 .    the third step in the proof for the non - synchronized case is to prove the conclusion of lemma [ lem : key1 ] . by a similar argument as in",
    ", the claim follows with @xmath467 after we show that @xmath468~\\leq~- \\eta \\sum_{i\\in{\\mathcal i}}m_i{q}_{i,\\leq c}(0)+ { \\mathcal c}\\sum_{i\\in{\\mathcal i } } \\big[v_i(0)+{q}_{i , < c}(0)+1\\big],\\ ] ] where we use that @xmath469~\\leq~ { \\mathcal c}\\ ] ] for all @xmath470 and some constant @xmath169 . to see that holds , it suffices to show that @xmath471\\leq { \\mathcal c}$ ] by the cauchy - schwarz inequality .",
    "this can be shown using and @xmath472 , e\\left[d_{i,\\leq c}^2~|~{\\mathcal f}(0)\\right ] , e\\left[r_i^2~|~{\\mathcal f}(0)\\right]~\\leq~ { \\mathcal c}\\ ] ] where these bounds can be derived using arguments similar to those leading up to . since @xmath473\\leq{\\mathcal c}$ ] and @xmath474 the inequality in reduces to @xmath475~\\leq~-\\eta \\sum_{i\\in{\\mathcal i}}m_i{q}_{i,\\leq c}(0)+{\\mathcal c}.\\ ] ] we prove this using and in conjuction with condition _",
    "c2@xmath136 _ as follows : @xmath476\\\\ & & \\qquad\\leq~ 2\\sum_{(i,\\ell)\\in { \\mathcal i}\\times{\\mathcal i } } z_{i\\ell}\\,m_\\ell{q}_{\\ell,\\leq c}(0)\\left(\\rho_i+\\varepsilon m_i+\\frac{{\\mathcal c}}{q_{\\ell,\\leq c}(0)+1 } -e\\left[\\sum_{j\\in { \\mathcal j}_i}\\int^1_0 \\beta_j\\sigma_j(t)\\ , dt~\\bigg|~{\\mathcal f}(0)\\right]\\right)\\\\ & & \\qquad\\leq~ 2\\sum_{(i,\\ell)\\in { \\mathcal i}\\times{\\mathcal i } } z_{i\\ell}\\,m_\\ell { q}_{\\ell,\\leq c}(0)\\left(\\rho_i+\\varepsilon m_i -e\\left[\\sum_{j\\in { \\mathcal j}_i}\\int^1_0 \\beta_j\\sigma_j(t)\\ , dt~\\bigg|~{\\mathcal f}(0)\\right]\\right)+{\\mathcal c}\\\\ & & \\qquad\\leq~-\\eta \\sum_{i\\in{\\mathcal i}}m_i{q}_{i,\\leq c}(0)+{\\mathcal c},\\end{aligned}\\ ] ] where we again remind the reader that the constant @xmath169 may differ from line to line .",
    "this completes the proof of lemma [ lem : key1 ] for non - synchronized networks .",
    "[ [ synchronized - network . ] ] synchronized network .",
    "+ + + + + + + + + + + + + + + + + + + + +    now we consider the case when the network is synchronized , i.e. , condition _",
    "c1_. we establish the same three steps as in the non - synchronized case . in the non - synchronized case , we used the fact that the schedule @xmath89 under the @xmath0-lrfs policy is maximal with respect to @xmath477 $ ] , for which we required condition _ c2@xmath136_. in synchronized networks , as a first step in the proof , we use a different ( stronger ) maximality property , which allows us to relax condition _ c2@xmath136 _ to condition _ c1_. to this end , we introduce some necessary notation . we let @xmath478 if activity @xmath7 processes a job with counter @xmath322 at time @xmath17 ( and @xmath479 otherwise ) . since @xmath480 in synchronized networks , we write @xmath481 for @xmath482 .",
    "the main maximality property we use in synchronized networks is that , under the lrfs policy , the schedule @xmath483 $ ] is maximal with respect to @xmath484 $ ] for each component @xmath79 .",
    "together with , this implies that for every partition @xmath79 , @xmath485\\right)~\\leq~-\\eta \\sum_{i\\in{\\mathcal i}}{q}_{i,\\leq c}(0)+{\\mathcal c},\\ ] ] where we let @xmath486 denote the event that at time @xmath450 the @xmath0-lrfs policy for component @xmath79 does not select a job for processing through step 3 - 1 ( see its description in definition [ def : eplrfs ] ) and all selected jobs are due the lrfs policy in step 4 .",
    "we stress that in synchronized networks , every processor completes the service requirement of the job it processes at every integer time @xmath487 and hence @xmath488=1-\\varepsilon$ ] .",
    "inequality is analogous to , which concludes the first step in the non - synchronized case .",
    "we proceed with the analog of the second step from the non - synchronized case , i.e. , bounding @xmath489 $ ] .",
    "we stress that the definition of @xmath490 differs from the one used in non - synchronized networks , see section [ sec : not ] .",
    "scheduling decisions are only made at integer time epochs ( i.e. , @xmath491 ) in synchronized networks , so that @xmath492&= &      e\\left[\\widehat{a}_{i,\\leq c}~|~{\\mathcal f}(0)\\right ]      - \\sum_{j\\in { \\mathcal j}_i } e\\left[\\sigma_{j,\\leq c}~|~{\\mathcal f}(0)\\right]\\notag\\\\ & \\leq&\\rho_i     - \\sum_{j\\in { \\mathcal j}_i } e\\left[\\sigma_{j,\\leq c}~|~{\\mathcal f}(0)\\right]\\notag , \\ ] ] where we again let @xmath426 be the number of job arrivals contributing to an increase in @xmath427 during the time interval @xmath428 .",
    "on writing @xmath493 , we have @xmath494      & \\leq&\\rho_i     - \\sum_{j\\in { \\mathcal j}_i } e\\left[\\sigma_{j,\\leq c}~|~{\\mathcal f}(0)\\right ] .",
    "\\label{eq6 - 1:lemkey1}\\end{aligned}\\ ] ]    the third step in the proof for the synchronized case is to prove the conclusion of lemma [ lem : key1 ] . as in , it suffices to prove that @xmath495~\\leq~-\\eta \\sum_{i\\in{\\mathcal i}}m_i{q}_{i,\\leq c}(0)+{\\mathcal c}.\\ ] ] since @xmath496 and @xmath497 in synchronized networks , this reduces to @xmath498~\\leq~-\\eta \\sum_{i\\in{\\mathcal i}}{q}_{i,\\leq c}(0)+{\\mathcal c}.\\ ] ] combining and , it suffices to show that @xmath499\\right)~\\leq~-\\eta \\sum_{i\\in{\\mathcal i}}{q}_{i,\\leq c}(0)+{\\mathcal c}.\\ ] ] for activity @xmath5 , writing @xmath500 for the component of buffer @xmath403 ( i.e. , @xmath501 ) , we have @xmath502&\\geq &      \\pr\\left[\\mathcal e_{\\mbox{\\tiny lrfs}}^{(h_j)}\\right ]     e\\left[\\sigma_{j,\\leq c}~|~{\\mathcal f}(0),\\mathcal e_{\\mbox{\\tiny lrfs}}^{(h_j)}\\right]\\\\     & = & ( 1-\\varepsilon ) e\\left[\\sigma_{j,\\leq c}~|~{\\mathcal f}(0),\\mathcal e_{\\mbox{\\tiny lrfs}}^{(h_j)}\\right]\\\\      & \\geq &   e\\left[\\sigma_{j,\\leq c}~|~{\\mathcal f}(0),\\mathcal e_{\\mbox{\\tiny lrfs}}^{(h_j)}\\right ] -\\varepsilon.\\end{aligned}\\ ] ] therefore , follows after arguing that @xmath503\\right)~\\leq~-\\eta \\sum_{i\\in{\\mathcal i}}{q}_{i,\\leq c}(0)+{\\mathcal c}.\\ ] ] the above inequality follows from and condition _",
    "c1_. this completes the proof of lemma [ lem : key1 ] for synchronized networks .      for notational convenience",
    ", we again restrict attention to the case @xmath409 in the conclusion of lemma [ lem : key2 ] , namely , we show that for some @xmath504 , @xmath505~\\leq~ \\mathcal g(y(0))^2 -\\gamma_2 \\|{\\boldsymbol{q}}_{>d}(0)\\|_1+{\\mathcal c}\\left(\\|{\\boldsymbol{q}}_{\\leq d}(0)\\|_1+\\|{\\boldsymbol{v}}(0)\\|_1 + 1\\right),\\ ] ] where we recall that @xmath506 all arguments are applicable for general @xmath507 as well .",
    "first observe that @xmath508 can only change through the following events for jobs of type 1 and 2 .    *",
    "* arrivals . * @xmath509 increases when new external arrivals of type 2 occur .",
    "note that there are no such external arrivals for type 1 . *",
    "* routing .",
    "* @xmath509 may increase or decrease when a job with counter @xmath510 ( i.e. , type 1 or 2 ) is routed since the weight ( i.e. , future workload ) of a job conditioned on the buffer to which it has been routed is different from the ( unconditional ) weight before it is routed .",
    "however , @xmath509 does not change when a job with counter @xmath344 ( i.e. , type 2 ) is routed since it is routed deterministically . * * starting service .",
    "* @xmath509 may increase or decrease when a job of type 1 or 2 begins service , generating its service time at this point . assuming the job is served from buffer @xmath10 , then @xmath509 increases if the random service time is larger than its mean @xmath146 , and decreases otherwise . *",
    "* being in service .",
    "* @xmath509 decreases when a job of type 1 or 2 is currently being processed .",
    "now we express @xmath509 as follows : for @xmath511 , @xmath512 where @xmath513 , @xmath514 , @xmath515 and @xmath516 describe the change in @xmath509 in the time interval @xmath517 $ ] due to events of new arrivals , routing , starting service and being in service , respectively .",
    "hence , @xmath518 from our definition of the weights , one can further observe that @xmath519~=~0&&\\qquad e[m_{\\text{s - service}}(t)~|~{\\mathcal f}(0)]~=~0\\notag\\\\ e[m_{\\text{arrival}}(t)~|~{\\mathcal f}(0)]&\\leq & t\\sum_{d = d}^{\\infty } d\\ , m_{\\max}\\,\\|p^d{\\boldsymbol{\\alpha}}\\|_1,\\label{eq00:lemkey2}\\end{aligned}\\ ] ] where we define @xmath520 .",
    "[ [ first - case . ] ] first case .",
    "+ + + + + + + + + + +    on the event @xmath528 , we observe that @xmath529 and @xmath530~\\leq ~\\begin{cases}v^j(0)-\\beta_j t&\\mbox{if}~v^j(0 ) > \\beta_jt\\\\ \\qquad b_{\\text{renewal}}&\\mbox{otherwise}\\end{cases},\\ ] ] where one can find an appropriate constant @xmath531 depending on the variances of the generic service times @xmath532 using the renewal theory ( e.g. , @xmath533/e[\\gamma_i]$ ] from the proof of proposition 6.2 in @xcite ) .",
    "hence , in case there is no @xmath5 satisfying @xmath534 , @xmath535&=&\\sum_{j\\in{\\mathcal j } } e\\left[v^j(t)~|~{\\mathcal f}(0)\\right]\\notag\\\\ & \\leq & j b_{\\text{renewal}}\\notag\\\\ & \\leq&\\|{\\boldsymbol{v}}(0)\\|_1- j b_{\\text{renewal}},\\label{eq1:lemkey2}\\end{aligned}\\ ] ] since @xmath525 . on the other hand ,",
    "if there exists a @xmath536 satisfying @xmath537 , we have @xmath535&=&\\sum_{j\\in{\\mathcal j } } e\\left[v^j(t)~|~{\\mathcal f}(0)\\right]\\notag\\\\ & = & e\\left[v^{j_0}(t)~|~{\\mathcal f}(0)\\right]+ \\sum_{j\\in{\\mathcal j}\\setminus\\{j_0\\ } } e\\left[v^j(t)~|~{\\mathcal f}(0)\\right]\\notag\\\\ & \\leq & v^{j_0}(0)-\\beta_{j_0}t+ \\sum_{j\\in{\\mathcal j}\\setminus\\{j_0\\ } } \\max\\left\\{v^j(0)-\\beta_j t , b_{\\text{renewal}}\\right\\}\\notag\\\\ & \\leq & v^{j_0}(0)-\\beta_{j_0}t+ \\sum_{j\\in{\\mathcal j}\\setminus\\{j_0\\ } } \\left(v^j(0)+b_{\\text{renewal}}\\right)\\notag\\\\ & \\leq&\\|{\\boldsymbol{v}}(0)\\|_1 + j b_{\\text{renewal}}-\\beta_{\\min}t\\notag\\\\ & \\leq&\\|{\\boldsymbol{v}}(0)\\|_1- j b_{\\text{renewal}},\\label{eq2:lemkey2}\\end{aligned}\\ ] ] where we use and choose @xmath538 therefore , in both and , we have @xmath539~\\leq~\\|{\\boldsymbol{v}}(0)\\|_1- j b_{\\text{renewal}}.\\ ] ] using this , it follows that @xmath540&\\leq & e\\left[m(t)-m(0)~|~{\\mathcal f}(0)\\right]+\\gamma_1 e\\left[\\|{\\boldsymbol{v}}(t)\\|_1-\\|{\\boldsymbol{v}}(0)\\|_1~|~{\\mathcal f}(0)\\right]\\\\ & \\leq&e\\left[m_{\\text{arrival}}(t)~|~{\\mathcal f}(0)\\right]-\\gamma_1 j b_{\\text{renewal}}\\\\ & \\leq&t\\sum_{d = d}^{\\infty } d\\ , m_{\\max}\\,\\|p^d{\\boldsymbol{\\alpha}}\\|_1 -\\gamma_1j b_{\\text{renewal}}\\\\ & \\leq&-\\gamma,\\end{aligned}\\ ] ] where we use and now define @xmath541 in terms of @xmath542 as follows : @xmath543 we specify the value of @xmath542 at a later stage in the proof .",
    "this completes the proof of on the first event @xmath544 .",
    "[ [ second - case . ] ] second case .",
    "+ + + + + + + + + + + +    now consider the second event @xmath545 . from our choice of @xmath375 in",
    ", we have @xmath546 which implies that before time @xmath547 , all activities have completed serving the jobs they were serving at time @xmath450 ( and they could have worked on other jobs as well ) .",
    "thus , it follows that @xmath548~\\leq~ j b_{\\text{renewal}}.\\end{aligned}\\ ] ] consider a job with the largest counter ( and hence , contributing to @xmath549 ) at time @xmath450 and let @xmath550 be the component the job belongs to .",
    "define the event @xmath551 that the @xmath0-lrfs policy executes step 3 - 1 ( see the description of @xmath0-lrfs in definition [ def : eplrfs ] ) for this component at least once before time @xmath547 .",
    "let @xmath552 be the subevent that the job identified in step 1 of the policy is selected for processing when step 3 - 1 is carried out for the first time , so that @xmath553=\\varepsilon$ ] . on the event @xmath552 ,",
    "let the random variable @xmath554 denote the activity which is chosen to process this job , and let @xmath555 be the associated service time .",
    "we then have that @xmath556=m_{i_{j^*}}.$ ] observe that @xmath557\\\\ & & \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\leq~\\begin{cases } -m_{i_{j^*}}+x^*-\\beta_{j^ * } & \\mbox{on the event}~",
    "\\{x^*\\geq \\beta_{j^*}\\}\\\\ \\quad\\qquad- m_{i_{j^ * } } & \\mbox{otherwise } \\end{cases}.\\end{aligned}\\ ] ] it thus follows that @xmath558}\\\\ & \\leq&e\\left[-m_{i_{j^*}}+[x^*-\\beta_{j^*}]_+~\\big|~\\mathcal e_{\\text{step 3 - 1}}^*,{\\mathcal f}(0)\\right]\\\\ & \\leq&e\\left[-m_{i_{j^*}}+[x^*-\\beta_{\\min}]_+~\\big|~\\mathcal e_{\\text{step 3 - 1}}^*,{\\mathcal f}(0)\\right]\\\\ & = & e\\left[e\\left[\\left .- m_{i_{j^*}}+[x^*-\\beta_{\\min}]_+~\\big|~j^*,x^*,\\mathcal e_{\\text{step 3 - 1}}^*,{\\mathcal f}(0)\\right]~\\right|~\\mathcal e_{\\text{step 3 - 1}}^*,{\\mathcal f}(0)\\right]\\\\ & \\leq&\\max_{i\\in { \\mathcal i } } e\\left[-m_i+[\\gamma_i-\\beta_{\\min}]_+\\right],\\end{aligned}\\ ] ] where @xmath51 is a generic service time for buffer @xmath10 and @xmath559_+=x$ ] if @xmath560 and @xmath559_+=0 $ ] otherwise .",
    "it is easy to see that @xmath561_+\\right]<0 $ ] for all @xmath10 since @xmath562=m_i>0 $ ] and @xmath563 .",
    "hence , the above inequality implies that @xmath564      ~\\leq~-\\varepsilon \\nu,\\ ] ] with @xmath565_+\\right]>0.\\ ] ]    if the network is synchronized or if the second part of condition _ c2 _ of theorem [ thm : main ] holds , the only way for the event @xmath551 not to occur is that there exists a processor ( for the component @xmath566 ) processing a job constantly during the entire time interval @xmath567 $ ] ( i.e. , the job starts service before time @xmath568 and is still in service at time @xmath547 ) .",
    "recall that before time @xmath547 , every processor completes the service requirement of the job it was processing at time @xmath450 .",
    "hence , in addition to ( [ eq : deft ] ) , if we choose @xmath375 to also satisfy @xmath569 then it follows that @xmath570\\geq \\left(\\frac12\\right)^{k},\\ ] ] where we use the fact that if a processor starts to process a new job in the time interval @xmath571\\subset(0,1]$ ] , its service requirement is at most @xmath572 with probability @xmath573 by the markov inequality . from and , we conclude that @xmath574~\\leq~-\\frac{\\varepsilon \\nu}{2^k}.\\end{aligned}\\ ] ]    from , and , the desired inequality follows as @xmath575\\\\ & & \\qquad\\leq~ e\\left[m(t)-m(0)~|~{\\mathcal f}(0)\\right]+\\gamma_1 e\\left[\\|{\\boldsymbol{v}}(t)\\|_1-\\|{\\boldsymbol{v}}(0)\\|_1~|~{\\mathcal f}(0)\\right]\\\\ & & \\qquad\\leq~ e\\left[m_{\\text{arrival}}(t)~|~{\\mathcal f}(0)\\right]+ e[m_{\\text{s - service}}(t)+m_{\\text{b - service}}(t)~|~{\\mathcal f}(0)]+\\gamma_1j b_{\\text{renewal}}\\\\ & & \\qquad\\leq~ t\\sum_{d = d}^{\\infty } d\\,m_{\\max}\\,\\|p^d{\\boldsymbol{\\alpha}}\\|_1 -\\frac{\\varepsilon \\nu}{2^k}+\\gamma_1j b_{\\text{renewal}}\\\\ & & \\qquad\\leq~ -\\gamma,\\end{aligned}\\ ] ] where for the last inequality we define @xmath576 here we note that @xmath577 as long as @xmath578 ( i.e. , @xmath133 ) .",
    "this completes the proof of on the second event @xmath579 .    [",
    "[ completing - the - proof - of - lemma - lemkey2 . ] ] completing the proof of lemma [ lem : key2 ] .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    now implies that @xmath580&\\leq & 2\\mathcal g(y(0))\\,e[\\mathcal g(y(t))-\\mathcal g(y(0))~|~{\\mathcal f}(0)]+{\\mathcal c}\\\\ & \\leq & 2\\left(-\\gamma { \\bf 1}^+_{\\|{\\boldsymbol{q}}_{>d}(0)\\|_1}+ { \\mathcal c}\\left(1-{\\bf 1}^+_{\\|{\\boldsymbol{q}}_{>d}(0)\\|_1}\\right)\\right ) \\mathcal g(y(0))+{\\mathcal c}\\\\ & = & 2\\left(-(\\gamma+{\\mathcal c } ) { \\bf 1}^+_{\\|{\\boldsymbol{q}}_{>d}(0)\\|_1}+ { \\mathcal c}\\right ) \\mathcal g(y(0))+{\\mathcal c}\\end{aligned}\\ ] ] where one can check @xmath581<\\infty$ ] for the first inequality and the precise value of @xmath169 can be different from line to line .",
    "finally , we define @xmath582 and the conclusion of lemma [ lem : key2 ] follows from @xmath583&\\leq &      2\\left(-(\\gamma+{\\mathcal c } ) { \\bf 1}^+_{\\|{\\boldsymbol{q}}_{>d}(0)\\|_1}+      { \\mathcal c}\\right )      \\mathcal g(y(0))+{\\mathcal c}\\\\ & \\leq & -2\\gamma \\,m_{\\min}\\|{\\boldsymbol{q}}_{>d}(0)\\|_1+{\\mathcal c}\\left(\\|{\\boldsymbol{q}}_{\\leq d}(0)\\|_1+\\|{\\boldsymbol{v}}(0)\\|_1 + 1\\right)\\\\ & = & -\\gamma_2\\|{\\boldsymbol{q}}_{>d}(0)\\|_1+{\\mathcal c}\\left(\\|{\\boldsymbol{q}}_{\\leq d}(0)\\|_1+\\|{\\boldsymbol{v}}(0)\\|_1 + 1\\right),\\end{aligned}\\ ] ] where we use @xmath584 for the case @xmath523 and @xmath585 for the other case @xmath524 ( i.e. , @xmath586 ) .",
    "abd gratefully acknowledges nsf grant eec-0926308 for financial support .",
    "d. shah and d. wischik . switched networks with maximum weight policies : fluid approximation and multiplicative state space collapse . to appear in _ annals of applied probability _",
    ", arxiv preprint arxiv:1004.1995 , 2010 .",
    "l. tassiulas and a. ephremides .",
    "stability properties of constrained queueing systems and scheduling policies for maximum throughput in multihop radio networks . _ ieee transactions on automatic control _ , 37:1936 - 1948 , 1992 ."
  ],
  "abstract_text": [
    "<S> we construct a generic , simple , and efficient scheduling policy for stochastic processing networks , and provide a general framework to establish its stability . </S>",
    "<S> our policy is randomized and prioritized : with high probability it prioritizes jobs which have been least routed through the network . </S>",
    "<S> we show that the network is globally stable under this policy if there exists an appropriate quadratic ` local ' lyapunov function that provides a negative drift with respect to nominal loads at servers . applying this generic framework </S>",
    "<S> , we obtain stability results for our policy in many important examples of stochastic processing networks : open multiclass queueing networks , parallel server networks , networks of input - queued switches , and a variety of wireless network models with interference constraints . </S>",
    "<S> our main novelty is the construction of an appropriate ` global ' lyapunov function from quadratic ` local ' lyapunov functions , which we believe to be of broader interest . </S>"
  ]
}