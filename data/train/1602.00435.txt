{
  "article_text": [
    "matrix multiplication is a basic operation used in many scientific and engineering applications .",
    "there are several potential reasons for erroneous results of computation , in particular erroneous matrix products .",
    "they include software bugs , computational errors by logic circuits and bit - flips in memory . or , if the computation is performed by remote computers or by parallel processors , some errors might be introduced due to faulty communication .    in 1977",
    ", freivalds presented a randomized algorithm for verifying if a matrix @xmath6 is the matrix product of two @xmath0 matrices @xmath7 and @xmath8 running in @xmath9 time @xcite .",
    "his algorithm has been up today one of the most popular examples showing the power of randomization .    in spite of extensive efforts of the algorithmic community to derandomize this algorithm without substantially increasing its time complexity ,",
    "one has solely succeeded partially , either decreasing the number of random bits to a logarithmic one @xcite or using exponentially large numbers and the unrealistic bss computational model @xcite .",
    "one can argue that the latter solutions in different ways hide additional @xmath10 factors . by the way ,",
    "if one can use quantum devices then even an @xmath11-time verification of an @xmath0 matrix product over an integral domain is possible @xcite .",
    "interestingly , the problem of verifying matrix products over the @xmath12 semi - ring seems to be much harder comparing to that over an arbitrary ring .",
    "namely , it admits a truly subcubic algorithm if and only if there is a truly subcubic algorithm for the all - pairs shortest path problem on weighted digraphs ( apsp ) @xcite .",
    "freivalds algorithm has also pioneered a new subarea of the so called certifying algorithms @xcite .",
    "their purpose is to provide besides the output a certificate or easy to verify proof that the output is correct .",
    "the computational cost of the verification should be substantially lower than that incurred by recomputing the output ( perhaps using a different method ) from scratch .    in 1977 ,",
    "when freivalds published his algorithm , the asymptotically fastest known algorithm for arithmetic matrix multiplication was that due to strassen running in @xmath13 time @xcite .",
    "since then the asymptotic running time of fast matrix multiplication algorithms has been gradually improved to @xmath14 at present @xcite which is still substantially super - quadratic .    in this paper , we go one step further and consider a more complex problem of not only verifying a computational result but also correcting it if necessary .",
    "similarly as freivalds , as a subject of our study we choose matrix multiplication .",
    "our approach is very different from that in fault tolerant setting , where one enriches input in order to control the correctness of computation ( e.g. , by check sums in the so called abft method ) @xcite .",
    "instead , we use here an approach resembling methods from combinatorial group testing where one keeps testing larger groups of items in search for multiple targets , see , e.g. @xcite .",
    "first , we provide a simple deterministic algorithm for correcting an @xmath0 matrix product @xmath6 over a ring , with at most one erroneous entry , in @xmath9 time .",
    "it can be regarded as a deterministic version of freivalds algorithm ( section 3 ) .",
    "next , we extend the aforementioned algorithm to include the case when @xmath6 contains at most  @xmath1 erroneous entries .",
    "the extension relies on distributing erroneous entries of @xmath6 into distinct submatrices by deterministically shuffling the columns of @xmath6 and correspondingly the columns of @xmath15 the resulting deterministic algorithm runs in @xmath16 time , where the notation @xmath4 suppresses polylogarithmic terms in @xmath5 and  @xmath1 ( section 4 ) .",
    "then we show how to reduce the time bound to @xmath3 by applying this shuffling approach first with respect to the columns and then with respect to the rows of @xmath6 . in the same section ,",
    "we discuss also a slightly randomized version of the aforementioned algorithm running in @xmath17 expected time using @xmath18 random bits .",
    "next , in section 5 , we present a faster randomized algorithm for correcting @xmath6 in @xmath19 time almost surely ( i.e. , with probability at least @xmath20 for any constant @xmath21 ) , where  @xmath1 is the non - necessarily known number of erroneous entries of @xmath6 .",
    "a slight modification of this algorithm runs in @xmath22 expected time provided that the number of erroneous entries is known .",
    "this is our fastest algorithm for correcting @xmath6 when @xmath1 is very small .",
    "importantly , all our algorithms in sections 3 - 5 are combinatorial ( thus , they do not rely on the known fast algorithms for matrix multiplication or fast polynomial multiplication ) and easy to implement . in section 6 , we present a more advanced algebraic approach based on the _ compressed matrix multiplication _ technique from  @xcite . in effect",
    ", we obtain a randomized algorithm for correcting @xmath6 in @xmath23 time almost surely .",
    "roughly , it asymptotically subsumes the randomized algorithms of section 5 for  @xmath1 larger than @xmath24 and asymptotically matches them up to a polylogarithmic factor for the remaining @xmath25 we conclude with final remarks , where we discuss how some of our randomized algorithms can be also adjusted to the situation when the number of erroneous entries is unknown . for a summary of our results , see table 1 .    [",
    "cols=\"^,^,^\",options=\"header \" , ]     [ table : 1 ] 0.5 cm",
    "let @xmath26 be a semi - ring .",
    "for two @xmath5-dimensional vectors @xmath27 and @xmath28 with coordinates in @xmath29 their dot product @xmath30 over the semi - ring is denoted by @xmath31    for an @xmath32 matrix @xmath33 with entries in @xmath34 its @xmath35-th row @xmath36 is denoted by @xmath37 similarly , the @xmath38-th column @xmath39 of @xmath7 is denoted by @xmath40 given another @xmath41 matrix @xmath42 with entries in @xmath34 the matrix product @xmath43 of @xmath7 with @xmath42 over the semi - ring is a matrix @xmath44 , where @xmath45 for @xmath46",
    "given two matrices @xmath47 of size @xmath32 and @xmath48 respectively , and their possibly erroneous @xmath49 matrix product @xmath6 over a ring , freivalds algorithm picks uniformly at random a vector in @xmath50 and checks if @xmath51 , where @xmath52 stands for a transpose of @xmath53 , i.e. , the column vector corresponding to @xmath53 @xcite . for @xmath54",
    "if the @xmath35-th row of @xmath6 contains an erroneous entry , the @xmath35-th coordinates of the vectors @xmath55 and @xmath56 will differ with probability at least @xmath57    in the special case , when @xmath6 contains a single error , we can simply deterministically set @xmath53 to the vector @xmath58 in the aforementioned freivalds test .",
    "the vectors @xmath55 , @xmath56 will differ in exactly one coordinate whose number equals the number of the row of @xmath6 containing the single erroneous entry .",
    "( note that the assumption that there is only one error is crucial here since otherwise two or more errors in a row of @xmath6 potentially could cancel out their effect so that the dot product of the row with @xmath59 which in this case is just the sum of entries in the row , would be correct . )",
    "then , we can simply compute the @xmath35-th row of the matrix product of @xmath7 and @xmath42 in order to correct @xmath6 .",
    "the time complexity is thus linear with respect to the total number of entries in all three matrices , i.e. , @xmath60 .",
    "more precisely , it takes time @xmath61 to compute @xmath56 , @xmath62 to compute @xmath63 , and finally @xmath64 to compute the product of @xmath7 with @xmath63 .",
    "[ lem : single ] let @xmath65 be three matrices of size @xmath66 @xmath41 and @xmath49 , respectively , over a ring .",
    "suppose that @xmath6 is different from the matrix product  @xmath67 of @xmath7 and @xmath42 exactly in a single entry .",
    "we can identify this entry and correct it in time linear with respect to the total number of entries , i.e. , in @xmath60 time .",
    "in this section , we shall repeatedly use a generalization of the deterministic version of freivalds test applied to detecting single erroneous entries in the previous section .    let @xmath47 be two @xmath0 matrices , and",
    "let @xmath6 be their possibly faulty product matrix with at most  @xmath1 erroneous entries , over some ring .",
    "let @xmath68 and @xmath69 denote matrices resulting from the same permutation of columns in the matrices @xmath6 and @xmath42 .",
    "similarly as in the previous section , the generalized deterministic version of freivalds test verifies rows of @xmath70 but only for a selected set of consecutive columns of the matrix .",
    "such a set of columns will be called a _",
    "strip_.    we shall check each strip of @xmath68 independently for erroneous entries that occur in a single column of the strip . to do this ,",
    "when we determine the vector @xmath71 to be used in the coordinate - wise comparison of @xmath72 with @xmath73 , we set the @xmath35-th coordinate of @xmath71 to @xmath74 if and only if the @xmath35-th column of the matrix @xmath68 belongs to the strip we want to test .",
    "otherwise , we set the coordinate to @xmath75 ( see fig .",
    "[ fig : illustration ] . )     in order to `` extract '' the vertical strip @xmath76 from the matrix @xmath68 . ]    in this way , for each row in a strip , we can detect whether or not the strip row contains a single error .",
    "the time complexity for testing a whole strip in this way is @xmath9 , independently from the number of columns of the strip . if necessary",
    ", we can also correct a single row of a strip by recomputing all its entries in time proportional to @xmath5 times the number of columns in the strip .    our algorithm in this section relies also on the following number theoretical lemma .",
    "[ lem : prime ] let @xmath77 be a set of @xmath78 different indices in @xmath79 there exists a constant  @xmath67 and for each @xmath80 a prime @xmath81 among the first @xmath82 primes such that for @xmath83 , @xmath84    it follows from the chinese remainder theorem , the density of primes and the fact that each index in @xmath85 has @xmath86 bits that there is a constant @xmath87 such that for each pair @xmath88 of distinct indices in @xmath85 there are at most @xmath89 primes @xmath90 such that @xmath91 consequently , for each @xmath92 there are at most @xmath93 primes @xmath90 for which there exists @xmath83 such that @xmath94 thus , it is sufficient to set the constant  @xmath67 to @xmath87 in order to obtain the lemma .    given the generalized deterministic version of freivalds test and lemma [ lem : prime ] , the idea of our algorithm for correcting @xmath6 is simple , see fig .",
    "[ fig : algo ] .    for each prime @xmath90 among the first @xmath95 primes , for @xmath96 the @xmath38-th column is moved into a ( vertical ) strip corresponding to @xmath97 correspondingly , the columns of the matrix @xmath42 are permuted .",
    "* algorithm 1 *    _ input : _ three @xmath0 matrices @xmath98 such that @xmath6 differs from the matrix product of @xmath7 and @xmath42 in at most  @xmath1 entries .",
    "_ output : _ the matrix product of @xmath7 and @xmath15    @xmath99 the set of the first @xmath95 primes ;    @xmath100    * for * each prime @xmath101 * do *    1 .   * for * @xmath102 * do * 1 .   move the @xmath38-th column of @xmath68 into the @xmath103 strip of columns in @xmath104 2",
    "correspondingly move the @xmath38-th column of @xmath69 into the @xmath103 strip of columns in @xmath105 2 .",
    "* for * each strip @xmath76 of @xmath68 * do * 1 .",
    "set @xmath71 to the vector in @xmath106 whose @xmath38-th coordinate is @xmath74 if and only if the @xmath38-th column of @xmath68 belongs to @xmath76 ; 2 .",
    "compute the vectors @xmath72 and @xmath107 3 .   * for * each coordinate @xmath35 in which @xmath72 and @xmath73 are different * do * 1 .",
    "compute the entries in the @xmath35-th row of the strip of @xmath108 corresponding to @xmath76 and correct the @xmath35-th row of @xmath76 in  @xmath67 appropriately .",
    "output @xmath109    let @xmath69 and @xmath68 denote the resulting shuffled matrices .",
    "next , for each strip @xmath76 of @xmath68 , we set @xmath71 to the vector in @xmath110 whose @xmath38-th coordinate is @xmath74 if and only if the @xmath38-th column belongs to @xmath111 we compute and compare coordinate - wise the vectors @xmath72 and @xmath112 note that for @xmath113 if there is a single erroneous entry in the @xmath35-th row of @xmath76 then the vectors @xmath72 , @xmath73 are different in this coordinate . simply , the @xmath35-th coordinate of @xmath73 is just the sum of the entries in the @xmath35-th row of @xmath76 while that coordinate of @xmath72 is the sum of the entries in the @xmath35-th row of the vertical strip of the product of @xmath7 and @xmath69 corresponding to @xmath111    it follows in particular that for each strip which contains only one erroneous column , we shall find all erroneous rows in the strip .",
    "furthermore , we can correct all the erroneous entries in a detected erroneous row of the vertical strip @xmath76 in @xmath114 time by computing @xmath115 dot products of rows of @xmath7 and columns of @xmath116 thus , in particular the correction of a single error in a row of @xmath76 takes @xmath114 time .",
    "it follows from lemma [ lem : prime ] , that for each erroneous column in @xmath117 there is such a prime @xmath90 that the column is a single erroneous column in one of the aforementioned vertical strips of the shuffled matrix @xmath109 hence , all the  @xmath1 errors can be localized and corrected .",
    "[ lem : det ] let @xmath65 be three @xmath0 matrices over a ring .",
    "suppose that @xmath6 is different from the matrix product  @xmath67 of @xmath7 and @xmath42 in at most  @xmath1 entries .",
    "algorithm 1 identifies these erroneous entries and corrects them in @xmath16 time .    the correctness of algorithm 1 ( see fig .  [",
    "fig : algo ] ) follows from the above discussion and lemma [ lem : prime ] .",
    "algorithm 1 iterates over @xmath95 smallest primes . since an upper bound on",
    "the @xmath35-th prime number is @xmath118 for any @xmath119 , it follows that the largest prime considered by the algorithm has size @xmath120 , and hence all these primes can be listed in @xmath121 time .    for a given prime @xmath122 the algorithm tests @xmath90 vertical strips @xmath76 for the containment of rows with single errors by computing the vectors @xmath72 and @xmath73 .",
    "it takes @xmath123 time .    by the upper bounds on the number of considered primes and their size , the total time taken by the tests for all considered primes is @xmath124    the correction of an erroneous entry in a detected erroneous row in a vertical strip @xmath76 takes @xmath123 time",
    "hence , the correction of the at most  @xmath1 erroneous entries in @xmath68 takes @xmath125 time .",
    "the tests and corrections dominate the running time of the algorithm .    in a practical implementation of the algorithm above , one can of course implement the shuffling of the columns without actually copying data from one column to another . for",
    "this purpose one could also define the strips in a different way , i.e. , they do not need to consist of consecutive columns .      in order to decrease the power of  @xmath1 in the upper bound of the time complexity from @xmath126 to @xmath74 , we make the following observation .",
    "consider any column @xmath35 of @xmath6 .",
    "the number of erroneous entries in column @xmath35 that are in rows that have at least @xmath127 erroneous entries is at most @xmath127 .",
    "we start by applying algorithm 1 but only using the smallest @xmath128 primes . in this way",
    "all rows that have at most @xmath127 erroneous entries will be found in total @xmath129 time , and will be fixed in @xmath9 time for each detected erroneous row .",
    "so the time complexity up to this stage is dominated by @xmath3 .",
    "now , we let @xmath130 be the partially corrected matrix and we apply the same procedure but reversing the roles of columns and rows , i.e. , we work with @xmath131 and @xmath132 . since for any row of @xmath132 , all its erroneous entries that were in columns of @xmath132 with at most @xmath127 errors were already corrected , now by the observation , the number of erroneous entries in any row of @xmath132 is at most @xmath133 .",
    "thus algorithm 1 will now find all remaining erroneous rows in time @xmath3 and we can correct them in additional time @xmath134 . hence we obtain the following theorem :    [ theo : det ] let @xmath65 be three @xmath0 matrices over a ring .",
    "suppose that @xmath6 is different from the matrix product  @xmath67 of @xmath7 and @xmath42 in at most  @xmath1 entries .",
    "we can identify these erroneous entries and correct them in @xmath3 time .",
    "we can decrease the power of  @xmath1 in the upper bound of theorem [ theo : det ] from @xmath74 to @xmath135 by using @xmath136 random bits as follows and assuming that the exact number  @xmath1 of erroneous entries in @xmath6 is known .",
    "( the removal of this assumption will be discussed later . )",
    "the idea is that instead of testing systematically a sequence of primes , we start by producing four times as many primes and then choose randomly among them in order to produce the strips .",
    "we call a faulty entry in @xmath6 1-detectable if it lies in a row or column of @xmath6 with at most @xmath137 erroneous entries . from this definition",
    "it follows that most faulty entries are 1-detectable .",
    "more specifically , we call an entry in @xmath6 1-row - detectable , respectively 1-column - detectable , if it lies in a row , respectively column , with at most @xmath137 erroneous entries",
    ".    we will aim at detecting first a constant fraction of the 1-row - detectable ( false ) entries , and then a constant fraction of the 1-column - detectable entries .",
    "for this purpose we start by producing , in a preprocessing phase , the smallest @xmath138 primes ( i.e. , four times as many primes as we did in the deterministic algorithm of theorem [ theo : det ] ) .    to detect sufficiently many 1-row - detectable entries we run one iteration of algorithm 1 , with the difference that we use a prime chosen randomly among the produced @xmath138 smallest primes .",
    "in this way , for each 1-row - detectable entry there is at least a probability 1/2 that it will be detected .",
    "then we repeat once more this procedure but reversing the role of columns and rows , i.e. , by working with @xmath131 and @xmath139 . in this way for each 1-column - detectable entry there is at least a probability 1/2 that it will be detected .    in this way , now each 1-detectable entry has been detected with probability at least 1/2 . by correcting all these detected entries",
    ", we thus reduce the total number of remaining false entries by an expected constant fraction .",
    "thus we can set  @xmath1 to the remaining number of false entries and start over again with the resulting , partially corrected matrix @xmath6 .",
    "we repeat in this way until all erroneous entries are corrected .    the expected time bound for the tests and corrections incurred by the first selected primes dominate the overall expected time complexity .",
    "note that the bound is solely @xmath140    the number of random bits needed to select such a random prime is only @xmath141 for a small @xmath142 this is much less than the logarithmic in @xmath5 number of random bits used in the best known @xmath9-time verification algorithms for matrix multiplication obtained by a partial derandomization of freivalds algorithm @xcite .",
    "the overall number of random bits , if we proceed in this way and use fresh random bits for every new selection of a prime number has to be multiplied by the expected number of the @xmath143 iterations of the algorithm .",
    "thus , it becomes @xmath144 hence , we obtain the following slightly randomized version of theorem [ theo : det ] .",
    "[ theo : few ] let @xmath65 be three @xmath0 matrices over a ring .",
    "suppose that @xmath6 is different from the matrix product  @xmath67 of @xmath7 and @xmath42 in exactly  @xmath1 entries .",
    "there is a randomized algorithm that identifies these erroneous entries and corrects them in @xmath17 expected time using @xmath18 random bits .",
    "if the number  @xmath1 or erroneous entries is not known , then our slightly randomized method can be adapted in order to estimate the number of erroneous columns . since similar issues",
    "arise in connection to another randomized approaches presented in the next chapters , we postpone this discussion to final remarks .",
    "in this section , similarly as in the previous one , we shall apply the original and modified freivalds tests .",
    "first , we apply repeatedly the original freivalds test to the input @xmath0 matrices @xmath145 @xmath8 and @xmath6 and then to their transposes .",
    "these tests allow us to extract a submatrix @xmath146 which very likely contains all erroneous entries of @xmath147 finally , we apply modified freivalds tests to ( vertical ) strips of the submatrix @xmath146 of @xmath147    in contrast with the previous section , the tests are randomized .",
    "the modified test is just a restriction of freivalds original randomized algorithm @xcite to a strip of @xmath146 that detects each erroneous row of a strip with probability at least @xmath148 even if a row contains more than one erroneous entry .",
    "more precisely , the vector @xmath71 used to test a strip of @xmath146 by comparing @xmath149 with @xmath150 , where @xmath151 and @xmath152 are appropriate submatrices of @xmath7 and @xmath8 is set as follows .",
    "suppose that @xmath146 is an @xmath41 matrix .",
    "for @xmath153 the @xmath38-th coordinate of @xmath71 is set to @xmath74 independently with probability @xmath148 if and only if the @xmath38-th column of @xmath6 belongs to the strip we want to test , otherwise the coordinate is set to @xmath75 in this way , for each row in the strip , the test detects whether or not the strip row contains an erroneous entry with probability at least @xmath148 , even if the row contains more than one erroneous entry .",
    "the test for a whole strip takes @xmath9 time , independently of the number of columns of the strip .    using the aforementioned tests",
    ", we shall prove the following theorem .",
    "[ lemma : sqrt - k ] let @xmath7 , @xmath42 and @xmath6 be three @xmath154 matrices over a ring .",
    "suppose that @xmath6 is different from the matrix product  @xmath67 of @xmath7 and @xmath42 in  @xmath1 entries .",
    "there is a randomized algorithm that transforms @xmath6 into the product @xmath155 in @xmath156 time almost surely without assuming any prior knowledge of @xmath25    let us assume for the moment that  @xmath1 is known in advance ( this assumption will be removed later ) . our algorithm ( see algorithm 2 in fig .  [",
    "fig : algo2 ] ) will successively correct the erroneous entries of @xmath6 until @xmath6 will become equal to @xmath155 .",
    "our algorithm consists of two main stages . in the first stage ,",
    "the standard freivalds algorithm is applied iteratively to @xmath145 @xmath8 @xmath6 and then to the transposes of these matrices in order to filter out all the rows and all the columns of @xmath6 containing erroneous entries almost certainly . if the number of the aforementioned rows or columns is less than @xmath157 ( e.g. , when @xmath158 ) then all the entries in the rows or columns of the product @xmath155 are computed and the algorithm halts .",
    "the computation of the aforementioned entries takes @xmath159 time in total .",
    "otherwise , a submatrix @xmath146 of @xmath6 consisting of all entries on the intersection of the aforementioned rows and columns is formed .",
    "it has at most @xmath160 rows and at most @xmath160 columns . in the second stage",
    ", we consider a partition of the columns of @xmath146 into at most @xmath161 strips of equal size , i.e. , consecutive groups of at most @xmath162 columns of @xmath163 we treat each such strip separately and independently . for each strip",
    ", we apply our modification of freivalds test @xmath86 times . in this way",
    ", we can identify almost surely which rows of the tested strip contain at least one error .",
    "( recall that for each iteration and for each strip row , the chance of detecting an error , if it exists , is at least @xmath148 . ) finally , for each erroneous strip row , we compute the correct values for each one of its @xmath164 entries .    * algorithm 2 *    _ input : _ three @xmath0 matrices @xmath98 such that @xmath6 differs from the matrix product of @xmath7 and @xmath42 in at most  @xmath1 entries .",
    "_ output : _ the matrix product of @xmath7 and @xmath42 , almost surely .",
    "run freivalds algorithm @xmath165 times on @xmath166    set @xmath167 to the set of indices of at most  @xmath1 rows of @xmath6 detected to be erroneous ;    if @xmath168 then compute the rows of the product of @xmath7 and @xmath42 whose indices are in @xmath167 , output the product of @xmath7 and @xmath42 , and stop ;    run freivalds algorithm @xmath165 times on @xmath169    set @xmath170 to the set of indices of at most  @xmath1 columns of @xmath6 detected to be erroneous ;    if @xmath171 then compute the columns of the product of @xmath7 and @xmath42 whose indices are in @xmath170 , output the product of @xmath7 and @xmath42 , and stop ;    set @xmath146 to the submatrix of @xmath6 consisting of all entries occurring in the intersection of rows with indices in @xmath167 and columns with indices in @xmath172    if @xmath146 is empty then return @xmath6 and stop ;    set @xmath151 to the submatrix of @xmath7 consisting of all rows with indices in @xmath173    set @xmath152 to the submatrix of @xmath42 consisting of all columns with indices in @xmath172    * for * @xmath174 * do *    1 .",
    "run the strip restriction of freivalds algorithm @xmath165 times on @xmath175 @xmath152 and the @xmath35-th ( vertical ) strip of @xmath176 2 .",
    "for each erroneous strip row found in the @xmath35-th ( vertical ) strip of @xmath6 , compute each entry of this strip row of @xmath146 and update @xmath6 accordingly ;    output @xmath147    in each iteration of the test in step 1 in the algorithm , each erroneous row in @xmath6 will be detected with a probability at least @xmath148 .",
    "hence , for a sufficiently large constant  @xmath67 ( e.g. , c=3 ) all erroneous rows of @xmath6 will be detected almost surely within @xmath165 iterations in step 1 .",
    "analogously , all erroneous columns of @xmath6 will be detected almost surely within @xmath165 iterations in step 3 .",
    "it follows that all the erroneous entries of @xmath6 will belong to the submatrix @xmath146 consisting of all entries on the intersection of the aforementioned rows and columns of @xmath117 almost surely .",
    "recall that @xmath146 has at most @xmath160 rows and at most @xmath160 columns .",
    "next , similarly , in step 7 in the algorithm , each erroneous row in each of the @xmath177 strips of @xmath146 will be detected almost surely .",
    "if we use the straightforward method in order to compute the correct values of an erroneous strip row , then it will take @xmath10 time per entry .",
    "since each strip row of @xmath146 contains @xmath178 entries , the time taken by a strip row becomes @xmath179 .",
    "since there are at most  @xmath1 erroneous strip rows , the total time for correcting all the erroneous strip rows in all strips of @xmath146 is @xmath180 .",
    "the total time taken by the logarithmic number of applications of freivalds tests to @xmath145 @xmath8 @xmath6 in step 1 and to the transposes of these matrices in step 3 is @xmath181 to estimate the total time taken by the logarithmic number of applications of the restrictions of freivalds tests to the @xmath182 vertical strips of @xmath146 in and matrices @xmath151 and @xmath152 in step 7 , recall that @xmath151 has at most @xmath160 rows and @xmath5 columns , @xmath152 has @xmath5 rows and at most @xmath160 columns , while @xmath146 has at most @xmath160 rows and columns .",
    "hence , in particular multiplications of @xmath146 by the restricted test vectors take @xmath183 time in total , which is @xmath180 since @xmath184 in the second stage .",
    "similarly , multiplications of @xmath152 by the restricted test vectors take @xmath185 time in total , which is again @xmath186 note that the @xmath5-coordinate vectors resulting from multiplications of @xmath152 with the restricted test vectors are not any more restricted and potentially each of their coordinates may be non - zero .",
    "therefore , the multiplications of @xmath151 with the aforementioned vectors take @xmath187 time in total , which is @xmath188 .",
    "all this yields an upper time bound of @xmath189 on the total time taken by the tests in both stages ..    in the second stage of algorithm 2 , if we use , instead of the correct number  @xmath1 of erroneous entries , a guessed number @xmath190 which is larger than  @xmath1 , then the time complexity becomes @xmath191 .",
    "this would be asymptotically fine as long as @xmath190 is within a constant factor of  @xmath1 .",
    "on the other hand , if we guess @xmath190 which is much smaller than  @xmath1 , then the length of each erroneous strip row in @xmath146 may become too large .",
    "for this reason , first we have to find an appropriate size @xmath190 for the strips to be used by our algorithm . for this purpose ,",
    "we perform the first stage of algorithm 2 , i.e. , the logarithmic number of original freivalds tests on the input matrices and their transposes .",
    "next , we set @xmath190 to the maximum @xmath192 of the number of erroneous rows and the number of erroneous columns reported by the aforementioned tests , and a small constant , e.g. , @xmath193 then , we multiply our guess by @xmath194 until we reach a good balance . more precisely ,",
    "for each such guessed @xmath190 , without correcting any errors , we consider the partition of the submatrix @xmath146 into @xmath195 strips , and apply our modified test to each strip .",
    "as soon as we discover more than @xmath190 erroneous strip rows in @xmath196 we break the procedure without correcting any errors , and we start over with a four times larger guess @xmath190 .    the aforementioned method of guessing @xmath190 may result in at most @xmath143 wrong guesses until we achieve a good guess .",
    "since we multiply our guess every time with @xmath194 we obtain a geometric progression of the estimated costs of subsequent trials . in this way , the upper bound on the asymptotic complexity of the whole algorithm but the time complexity of the first logarithmic number of original freivalds test is dominated by that of the iteration for the final @xmath197 in this iteration , we test each strip @xmath198 times in order to detect almost surely all erroneous strip rows .",
    "algorithm 2 in the proof of theorem [ lemma : sqrt - k ] can be modified in order to achieve an expected time bound of @xmath199 for correcting all errors , if @xmath1 is known in advance .",
    "in the first stage , we perform only a single test for the matrices @xmath145 @xmath42 and a single test for their transposes .",
    "note that each erroneous entry of  @xmath67 occurs with probability at least @xmath200 in a detected erroneous row of  @xmath67 as well as with probability at least @xmath200 in a detected erroneous column of @xmath201 hence , an erroneous entry occurs with probability at least @xmath202 in the resulting matrix @xmath163 it follows that the expected number of erroneous entries in @xmath146 is at least one fourth of those in @xmath201    next , we modify the second stage of algorithm 2 as follows .",
    "we set the number of vertical strips to @xmath203 next , instead of applying the strip restriction of freivalds algorithm @xmath165 times for each strip , we apply it only once for each strip and correct all erroneous rows which we detect . by counting how many errors",
    "we have corrected , we compute how many errors remain .",
    "then we recurse in the same way on the partially corrected matrix  @xmath67 using as a parameter this new number of errors which remain to be corrected .    during each iteration of the algorithm , each remaining error in  @xmath67 will be detected and corrected with probability at least @xmath204 .",
    "thus , the expected number of remaining errors will decrease at least by the multiplicative factor @xmath205 after each iteration .",
    "it follows that the expected number of iterations is @xmath206 consequently , the total cost of the tests in the first stage becomes @xmath207 for the total time cost of tests and corrections in the second stage , we obtain a geometric progression on the expected time complexity of each iteration , and so the total expected time complexity is dominated by the time taken by the first iteration , which is @xmath208 . thus we obtain the following theorem .",
    "[ theorem : sqrt - k - known ] let @xmath65 be three @xmath0 matrices over a ring .",
    "suppose that @xmath6 is different from the matrix product  @xmath67 of @xmath7 and @xmath42 in exactly  @xmath1 entries .",
    "there is a randomized algorithm that identifies these erroneous entries and corrects them in @xmath22 expected time .",
    "in this section we present a fast randomized algorithm that makes use of the _ compressed matrix multiplication _ technique presented in  @xcite . we choose to give a self - contained and slightly simplified description because we do not need the full power of the framework of  @xcite .    for integer parameters",
    "@xmath209 to be chosen later , the construction uses @xmath210 pairs of hash functions @xmath211 , with @xmath212 , chosen independently from a strongly universal family of hash functions  @xcite .",
    "we will make use of the following property :    [ lem : coll]@xcite    for @xmath213 where @xmath214 we have @xmath215 \\leq 1/s \\enspace .\\ ] ]    our algorithm first computes the following @xmath210 polynomials based on the matrices @xmath216 , @xmath217 , and @xmath218 : @xmath219 for @xmath220 .",
    "multiplication of the polynomials corresponding to @xmath7 and @xmath42 is done efficiently ( over any ring ) using the algorithm of cantor and kaltofen  @xcite , based on the original polynomial multiplication algorithm of schnhage and strassen  @xcite .",
    "let @xmath221 denote the coefficient of @xmath222 in a polynomial @xmath223 .",
    "for each entry @xmath224 of @xmath6 we assess the error term that must be added to @xmath225 as the _ majority element _ of the sequence @xmath226 , @xmath220 .",
    "we will choose @xmath227 and @xmath210 such that with high probability the correction term ( in most cases zero ) appears more than @xmath228 times in the sequence . if there is no such element for some entry @xmath224 the algorithm fails .",
    "suppose @xmath229 is the true matrix product .",
    "expanding the sum ( [ eq : polydef ] ) and reordering the order of summation we get : @xmath230 this means that each coefficient of @xmath231 is a sum of error terms : @xmath232    let @xmath233 be the set of positions of errors .",
    "for @xmath234 : @xmath235 lemma  [ lem : coll ] states that @xmath236 holds with probability at most  @xmath237 . by a union",
    "bound the probability that the sum in ( [ eq : estimator ] ) has at least one nonzero term is at most  @xmath238 .",
    "choosing @xmath239 we get that @xmath240 with probability at least @xmath241 . by chernoff bounds",
    "this implies that after @xmath210 repetitions the probability that @xmath242 does not hold for at least @xmath228 values of @xmath243 is exponentially small in  @xmath210 .",
    "choosing @xmath244 we can achieve an arbitrarily small polynomial error probability in @xmath5 ( even when summed over all entries @xmath35 , @xmath38 ) .",
    "strongly universal hash functions can be selected in constant time and space  @xcite , and evaluated in constant time .",
    "this means that they will not dominate the running time .",
    "time @xmath245 is used to compute the polynomials @xmath246 , @xmath247 , and @xmath248 in ( [ eq : polydef ] ) .",
    "this can be seen by noticing that each entry of @xmath7 , @xmath42 , and @xmath6 occur in one polynomial , and that there are @xmath249 polynomials of degree  @xmath227 .",
    "another component of the running time is the @xmath250 multiplications of degree-@xmath227 polynomials , that each require @xmath251 operations  @xcite .",
    "finally , time @xmath252 is needed to compute the correction term for each entry @xmath224 of @xmath6 based on the sequence @xmath226 . with the choices @xmath253 , @xmath244",
    "the combined number of operations ( algebraic and logical ) is @xmath254    [ thm : compressedmm ] let @xmath7 , @xmath42 and @xmath6 be three @xmath154 matrices over a ring .",
    "suppose that @xmath6 is different from the matrix product  @xmath67 of @xmath7 and @xmath42 in at most  @xmath1 entries .",
    "there is a randomized algorithm that transforms @xmath6 into the product @xmath155 in @xmath23 time , i.e. , @xmath255 time , almost surely .",
    "while the above assumes prior knowledge of  @xmath1 , we observe in final remarks that this assumption can be removed with only a slight increase in running time .",
    "observe that the algorithm of theorem  [ thm : compressedmm ] needs @xmath256 bits of space , which is @xmath257 .",
    "the majority of our randomized algorithms , in particular that from section 6 , can be efficiently adapted to the case when the number  @xmath1 of errors is unknown , proceeding similarly as in the proof of theorem  [ lemma : sqrt - k ] .",
    "first , observe that using a parameter value @xmath190 that is larger than  @xmath1 by a constant factor will yield the same guarantee on correctness and asymptotic running time .",
    "this means that we can try geometrically increasing values of @xmath190 , for example @xmath258 for @xmath259 until the algorithm returns a correct answer within the stated time bound ( using a suitably large constant in place of the big - o notation ) .",
    "correctness is efficiently checked using freivalds technique .",
    "this technique increases the time bound by at most a factor @xmath157 compared to the case where  @xmath1 is known .",
    "furthermore , if @xmath260 the time will be dominated by the last iteration , and we get time bounds identical to the case of known  @xmath1 .    a similar approach can also be used for refining the slightly randomized method of theorem  [ theo : few ] when the number of errors  @xmath1 is not known in advance . however",
    ", if there is no knowledge at all concerning the number of errors , it may be difficult to handle the case when no errors are detected : does this happen because there are no errors at all , or because there are too many errors and we chose a random prime from a too small range , thus failing to isolate 1-detectable false entries ?",
    "for this reason , if there is no known useful upper bound on the remaining number of errors , and we do not detect any errors during a series of iterations , we may have to resort to some of the known algorithms which test whether there are any errors at all  @xcite .",
    "all such known algorithms running in time @xmath9 may need a logarithmic number of random bits , so if  @xmath1 is very small then this may be asymptotically larger than the low number of random bits stated in theorem  [ theo : few ] .",
    "note that the problem of correcting a matrix product is very general . in the extreme case ,",
    "when all entries of the matrix @xmath6 may be mistrusted , it includes the problem of computing the matrix product @xmath261 from scratch .",
    "also , when the matrix  @xmath67 is known to be sparse , i.e. , mostly filled with zeros , then we can set @xmath6 to the all - zeros matrix , and apply our matrix correction algorithms in order to obtain output - sensitive algorithms for matrix multiplication ( the number of non - zero entries in  @xmath67 equals the number of erroneous entries in @xmath6 )",
    ". they will be slower than those known in the literature based on fast rectangular matrix multiplication @xcite ( cf .",
    "@xcite ) .",
    "finally , the general idea of using linear sketches to compute compact summaries of matrix products may be useful in general for correcting matrix products .",
    "for example , iwen and spencer  @xcite show that for complex - valued matrix products there is an efficiently computable linear sketch that allows recovery of the matrix product if the number of nonzeros in each column is bounded by roughly @xmath262 . using linearity one can subtract the linear sketch for @xmath6 to get the linear sketch of @xmath263 , which has  @xmath1 nonzero entries .",
    "if the number of nonzeros in each column of @xmath264 is bounded by @xmath262 , they can all be computed in time @xmath265 .",
    "however , it is not clear for which rings this method will work , so while this is an interesting direction for future research we do not pursue it further here .",
    "christos levcopoulos and andrzej lingas were supported in part by swedish research council grant 621 - 2011 - 6179 .",
    "takeshi tokuyama was supported by jsps grant scientific research ( b ) 15h02665 , jsps scientific research for innovative area 24106007 , and jst erato kawarabayashi big - graph project .",
    "p. wu , c. ding , l. chen , f. gao , t. davies , c. karlsson and z. chen . .",
    "proc . of the 2011 workshop on latest advances in scalable algorithms for large - scale systems ( scala ) held in conjunction with the 24th ieee /",
    "acm international conference on high performance computing , networking , storage and analysis ( sc11 ) , 2011 ."
  ],
  "abstract_text": [
    "<S> we study the problem of efficiently correcting an erroneous product of two @xmath0 matrices over a ring . among other things , </S>",
    "<S> we provide a randomized algorithm for correcting a matrix product with at most  @xmath1 erroneous entries running in @xmath2 time and a deterministic @xmath3-time algorithm for this problem ( where the notation @xmath4 suppresses polylogarithmic terms in @xmath5 and  @xmath1 ) . </S>"
  ]
}