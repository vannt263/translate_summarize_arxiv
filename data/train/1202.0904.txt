{
  "article_text": [
    "the box modality @xmath1 from modal logic has proven its usefulness in logic .",
    "it admits various logical and semantic interpretations in the spirit of ` we know that ' or ` we can prove that ' or ` in the future it will be the case that ' . a nice historical overview of modal logic , which also considers the specific impact of computer science , is in ( * ? ? ?",
    "* subsection  1.7 ) .",
    "cmtt ( contextual modal type theory ) is a typed @xmath0-calculus based via the curry - howard correspondence on the modal logic s4 .",
    "the box modality becomes a type - former , and box types are intuitively interpreted as ` closed syntax of ' .",
    "so cmtt has types for programs that generate cmtt syntax .",
    "because of this , cmtt has been applied to meta - programming , but it has independent interest as a language , designed according to rigorous mathematical principles and in harmony with modal logic , which interprets @xmath1 in a programming rather than a logical context .",
    "box types are types of the syntax of terms .    until now",
    "this has not been backed up by a denotational semantics in which box types really _ are _ populated by the syntax of terms . in this paper",
    ", we do that : our intuitions are realised in the denotational semantics in a direct and natural , and also unexpected , manner .",
    "the denotation is interesting from the point of view of the interface between logic and programming .",
    "furthermore , we exploit the denotation to prove properties of the language , showing how denotations are not only illuminating but can also serve for new proof - methods .",
    "this paper considers two related systems :    the purely modal system , based on box types like @xmath2 .    the contextual modal system , based on ` boxes containing types ' like @xmath3{b}$]the reader might like to think of the contextual system as a multimodal logic ( * ?",
    "? ? * subsection  1.4 ) ( whose modalities are themselves indexed over propositions ) .",
    "broadly speaking , the purely modal system is nicer to study but a little too simple .",
    "the contextual modal system generalises the purely modal system and gives it slightly more expressive power , but it can be a little complicated ; not obscure , just long to write out .",
    "therefore , we open this paper with the modal system , make the main point of our denotation in the simplest and clearest possible manner ",
    "the reader who wants to jump right in and work backwards could do worse than start with the example denotations in subsection  [ subsect.den.letbox ] onwards  and then we consider the contextual system as the maths becomes more advanced .",
    "section  [ sect.box.syntax ] presents syntax and typing of the modal system and section  [ sect.contextual.system ] does the same for the contextual modal system ; section  [ sect.denotations ] gives modal denotations and section  [ sect.contextual.models ] gives contextual modal denotations .",
    "the developments are parallel , but not identical .",
    "where proofs are not very different between the modal and contextual systems , we omit routine repetition .",
    "we consider reduction of the modal system in section  [ sect.reduction ] but not reduction of the contextual system .",
    "also , we develop the important notion of _ shapeliness _ only for the contextual system in section  [ sect.shapely ] ; it is obvious how the modal case would be a special case .",
    "our main technical results are theorems  [ thrm.type.soundness ] and  [ thrm.type.soundness.c ] , and corollary  [ corr.more.c ] .",
    "however , just looking at these results may be misleading ; the key technical ideas that make these results work , and indeed contribute to making them interesting , occur beforehand .",
    "so it might be useful to list some of the key ideas in the paper .",
    "this list is not an exhaustive technical overview , so much as clues for the reader who wants to gain some quick insight and navigate the mathematics . here",
    "are some of the main points that make the mathematics in this paper different and distinctive :    _ inflation _ in the case of @xmath4 in figure  [ fig.denot.types ] , and the ` tail of ' semantics of @xmath5 in figure  [ fig.denot.terms ] .",
    "this is discussed in remark  [ rmrk.why.inflate ] .",
    "proposition  [ prop.rtheta ] and the fact that it is needed for soundness of the denotation .",
    "the remarkable proposition  [ prop.typesub ] , in which valuations get turned into substitutions and closed syntax in the denotation interacts directly with the typing system . this is a kind of dual to the interaction seen in proposition  [ prop.rtheta ] .",
    "the denotation of @xmath6{a}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] in figure  [ fig.denot.types.c ] , which in the context of the rest of the paper is very natural .    the notion of _ shapeliness _ in definition  [ defn.shape ] and the ` soundness result ' proposition  [ prop.shape.r ] .",
    "we discuss all of these in the body of the paper .",
    "one early difficulty the authors of this paper faced was in communication , because we sometimes used terms synonymously without realising that the words were so slippery .",
    "the intuition we give to @xmath2 is self - reflectively _ closed syntax of the language itself_. this is a distinct intuition from ` computations ' , ` code ' , ` values ' , or ` intensions ' , because these are not necessarily intended self - reflectively .",
    "it is very important not to confuse this intuition with apparently similar intuitions expressed as ` code of @xmath7 ' , ` values of @xmath7 ' , ` computations of @xmath7 ' , or ` intension of @xmath7 ' .",
    "these are not quite the same thing",
    ". it may be useful to briefly survey them here :    ` code of @xmath7 ' is an ambiguous term ; this is often understood as precompiled code or bytecode , rather than syntax of the original language .",
    "see @xcite for a system based on that intuition .    `",
    "values of @xmath7 ' is a dangerous intuition and there probably should be a law against it : depending on whom one is speaking with , this could be synonymous in their mind with ` normal forms of @xmath7 ' ( a syntactic notion ) or ` denotations of @xmath7 ' ( a non - syntactic notion ) .",
    "matters become even worse if one s interlocuteur assumes that denotations may be silently added to syntax as constants ( fine for mathematicians ; not so fine for programmers ) .",
    "more than one conversation has been corrupted by the associated misunderstandings .    for",
    "a discussion of ` computation of @xmath7 ' see the related work in the conclusions , where we discuss how this intuition can lead to a notion of moggi - style _",
    "monad_.    ` intension of @xmath7 ' is similar to ` syntax of @xmath7 ' , but significantly more general : there is no requirement that the intension be syntactic , or if it is syntactic , that it be the same calculus .",
    "one could argue that ` intension of ' should also satisfy that the denotation of @xmath8 be identical in some strong sense  e.g .",
    "be the same set as  to that of @xmath2 , since taking an intension twice should reveal no further internal structure .",
    "( this does not match the denotation of this paper . )    an interesting ( and as far as we know unexplored ) model of this intuition might be partial equivalence relations ( * per*s ) , where @xmath2 takes @xmath7 and forms the identity per which is defined where @xmath7 is defined .",
    "famously , pers form a cartesian - closed category ( * ? ? ?",
    "* subsection  3.4.1 ) .    in short : where the reader sees ` @xmath2 ' , they should think ` raw syntax in type @xmath7 ' .",
    "it may be useful now to head off another possible confusion : where the reader sees @xmath9 , they should think ` graph of a function'not ` computable function ' , ` representable function ' , ` syntax of a function ' , or ` code of a function ' .",
    "all of these things are also possible , but in this paper our challence is to create a type system , language , and denotation which are ` epsilon away ' from the simply - typed @xmath0-calculus or ( since we admit a type of truth - values ) higher - order logic  and it just so happens that we also have modal types making precisely its _ own _ syntax into first - class data .",
    "so : we are considering a ` foundations - flavoured ' theory in which @xmath9 represents all possible functions ( in whatever foundation the reader prefers ) from @xmath7 to @xmath10 , and we do not intend this paper to be ` programming - flavoured ' in which @xmath9 represents only that function(-code ) or normal forms that can exist inside some computational device . and , @xmath2 should represent , as much as possible , ` the syntax of our language / logic that types as @xmath7 ' .",
    "we start by presenting the types , terms , and typing relation for the modal type system .",
    "this is the simplest version of the language that we want to give a denotational semantics for .",
    "[ defn.atoms ] fix two countably infinite sets of * variables * @xmath11 and @xmath12",
    ". we will observe a * permutative convention * that @xmath13 will range over distinct variables in @xmath11 and @xmath14 will range over distinct variables in @xmath12 .",
    "we call @xmath15 * atoms * and @xmath16 * unknowns*.    [ defn.types ] define * types * inductively by :    r@  l a::= & o naaa    by convention , if @xmath17 and @xmath18 are sets we will write @xmath19 for the set of functions from @xmath17 to @xmath18 .",
    "this is to avoid any possible confusion between @xmath9 ( which is a type ) and @xmath19 ( which is a set ) .",
    "@xmath20 will be a type of * truth values * ; its denotation will be populated by truth - values @xmath21 .",
    "@xmath22 will be a type of * natural numbers * ; its denotation will be populated by numbers @xmath23 .",
    "@xmath9 is a * function type * ; its denotation will be populated by functions .",
    "@xmath2 is a * modal type * ; its denotation will be populated by syntax .",
    "fix a set of * constants * @xmath24 to each of which is assigned a type @xmath25 .",
    "we write @xmath26 as shorthand for ` @xmath24 is a constant and @xmath27 ' .",
    "we insist that constants include the following : @xmath28 we may also assume constants for @xmath22 , such as @xmath29 , @xmath30 , @xmath31 and @xmath32 , a fixedpoint combinator , we may write @xmath33 for @xmath34 ,  and so on .    we may omit type subscripts where they are clear from context or do not matter .",
    "[ defn.terms ] define * terms * inductively by :    r::= c a x_.r rr r @xmath35x = r@xmath36r    constants @xmath24 are , as standard in the @xmath0-calculus , added as desired to represent logic and computational primitives .",
    "an atom @xmath37 plays the role of a standard @xmath0-calculus variable ; it is @xmath0-abstracted in a typed manner in @xmath38 .",
    "the term @xmath5 means intuitively ` evaluate @xmath17 ' and @xmath39 means intuitively ` the syntax @xmath40 considered itself in the denotation ' .",
    "finally @xmath41 means intuitively ` set @xmath17 to be the syntax calculated by @xmath42 , in @xmath40 ' .",
    "examples of this in action are given and discussed in subsection  [ subsect.some.programs ] .",
    "the effect of @xmath43 ( which is not syntax ) is obtained by @xmath44 .",
    "likewise the effect of @xmath45 ( which is not syntax ) is obtained by @xmath46 .",
    "we _ can not _",
    "emulate @xmath47 using @xmath48 .",
    "the expression ` @xmath49 ' would mean ` evaluate the syntax @xmath37 ' rather than ` evaluate the syntax linked to @xmath37 . '",
    "were syntax , it would not type in the typing system of figure  [ fig.modal.types ] , because @xmath50 would be equal to @xmath51 ( definition  [ defn.hole.free.atoms ] ) .",
    "modal types are inhabited by _ closed _",
    "syntax ( definition  [ defn.hole.free.atoms ] ) . ]    [ defn.hole.free.atoms ] define * free atoms * @xmath52 and * free unknowns * @xmath53 by : @xmath54 { { \\ensuremath{\\mathit{fu}}}}(c ) = & \\varnothing & { { \\ensuremath{\\mathit{fu}}}}(a ) = & \\varnothing \\\\ { { \\ensuremath{\\mathit{fu}}}}({\\lambda{a{:}{a}}.}{s } ) = & { { \\ensuremath{\\mathit{fu}}}}({s } )   & { { \\ensuremath{\\mathit{fu}}}}({r}{s } ) = & { { \\ensuremath{\\mathit{fu}}}}({r } ) \\cup { { \\ensuremath{\\mathit{fu}}}}({s } )    \\\\ { { \\ensuremath{\\mathit{fu}}}}(\\box r ) = & { { \\ensuremath{\\mathit{fu}}}}(r ) & { { \\ensuremath{\\mathit{fu}}}}({{\\ensuremath{\\mathit{let\\,}}}x{=}s{\\ensuremath{\\mathit{\\ in\\,}}}r } ) = & ( { { \\ensuremath{\\mathit{fu}}}}(r){\\setminus}\\{x\\})\\cup{{\\ensuremath{\\mathit{fu}}}}(s ) \\\\ { { \\ensuremath{\\mathit{fu}}}}(x_{\\mvat } ) = & \\ { x \\ } \\end{array}\\ ] ] if @xmath55 then we call @xmath40 * closed*.    we take @xmath37 to be bound in @xmath40 in @xmath38 and @xmath17 to be bound in @xmath40 in @xmath41 , and we take syntax up to @xmath56-equivalence as usual .",
    "we omit definitions but give examples :    @xmath57 .",
    "@xmath58 .",
    "@xmath59 .",
    "as the use of an equality symbol above suggests , we identify terms up to @xmath56-equivalence .. however , studying how best to define syntax is not the emphasis of this paper . ]      [ defn.typing.rules ]    a * typing * is a pair @xmath60 or @xmath61 .    a * typing context *",
    "@xmath62 is a finite partial function from @xmath63 to types .",
    "a * typing sequent * is a tuple @xmath64 of a typing context , a term , and a type .",
    "we use list notation for typing contexts , e.g. @xmath65 is the function mapping @xmath37 to @xmath66 and @xmath18 to @xmath67 ; and @xmath68 means that @xmath69 is defined and @xmath70 .    define the * valid typing sequents * of the modal type system inductively by the rules in figure  [ fig.modal.types ] .",
    "we discuss examples of typable terms in subsection  [ subsect.some.programs ] .",
    "the important rule is @xmath71 , which tells us that if we have some syntax @xmath40 and it has no free atoms , then we can box it as a denotation @xmath39 of box type  any free unknowns @xmath17 in @xmath40/@xmath39 get linked to further boxed syntax , which is expressed by @xmath72 .",
    "@xmath73 \\begin{prooftree } \\gamma , a{:}{a}{\\vdash}r:{b}\\justifies \\gamma{\\vdash}({\\lambda{a{:}{a}}.}r):{a}\\to { b}\\using{\\ensuremath{(\\mathbf{{\\to}i } ) } } \\end{prooftree } & \\begin{prooftree } \\gamma{\\vdash}r':{a}\\to { b}\\quad \\gamma{\\vdash}r:{a}\\justifies \\gamma{\\vdash}r'r:{b}\\using{\\ensuremath{(\\mathbf{{\\to}e } ) } } \\end{prooftree } \\\\[2em ] \\begin{prooftree } \\gamma{\\vdash}r:{a}\\quad ( { { \\ensuremath{\\mathit{fa}}}}(r){=}\\varnothing ) \\justifies \\gamma{\\vdash}\\box r:\\box { a}\\using{\\ensuremath{(\\mathbf{{\\box}i } ) } } \\end{prooftree } & \\begin{prooftree } \\gamma{\\vdash}s{:}\\box{a}\\quad   \\gamma , x{:}\\box{a}{\\vdash}r { :} { b}\\justifies \\gamma{\\vdash}{{\\ensuremath{\\mathit{let\\,}}}x{=}s{\\ensuremath{\\mathit{\\ in\\,}}}r}:{b}\\using{\\ensuremath{(\\mathbf{{\\box}e } ) } } \\end{prooftree } \\\\[2em ] \\begin{prooftree } \\phantom{h } \\justifies \\gamma , x:\\box{a}{\\vdash}x_{\\mvat}:{a}\\using{\\ensuremath{(\\mathbf{ext } ) } } \\end{prooftree } \\end{array}\\ ] ]    we may write @xmath74 just as @xmath75 .",
    "[ nttn.restrict ] if @xmath62 is a typing context and @xmath76 then write @xmath77 for @xmath62 * restricted * to @xmath78 .",
    "this is the partial function which is equal to @xmath62 where it is defined , and @xmath79 .",
    "proposition  [ prop.ws ] combines weakening and strengthening :    [ prop.ws ] if @xmath64 and @xmath80 then @xmath81 .    by a routine induction on @xmath40 .",
    "we are now ready to discuss intuitions about this syntax ; for a more formal treatment see section  [ sect.denotations ] which develops the denotational semantics .",
    "we start with some short examples and then consider more complex terms .      1 .",
    "assume constants @xmath82 and @xmath83 , where @xmath84 is written infix as usual .",
    "then we can type + & .@xmath35x",
    "= a@xmath36(x _ )  :  oo .",
    "+ & .. @xmath35x = a@xmath36@xmath35y = b@xmath36(x_y _ )  :  ooo .",
    "+ & .@xmath35x = a@xmath36(x_x",
    "_ )  :  oo . + intuitively these represents the syntax transformations @xmath85 ,  @xmath86 ,  and @xmath87 .",
    "[ item.t ] this program takes syntax of type @xmath7 and evaluates it : + & .@xmath35x = a@xmath36x _  :  aa + this corresponds to the modal logic axiom @xmath88 .",
    "3 .   expanding on the previous example",
    ", this program takes syntax for a function and an argument , evaluates the syntax and applies the function to the argument : + & .. ( @xmath35x = a@xmath36x_)b  :  ( ab)(ab ) 4 .",
    "[ item.4 ] this program takes syntax of type @xmath7 tagged with @xmath1 , and adds an extra @xmath1 so that it becomes syntax of type @xmath2 : + & .@xmath35x",
    "= a@xmath36x _  :  aa + this corresponds to the modal logic axiom @xmath89 .",
    "we can try to give @xmath91 the type @xmath92 , but we fail because the typing context @xmath93 does not satisfy @xmath94 .",
    "our denotation of figures  [ fig.denot.types ] and  [ fig.denot.terms ] illustrates that it is not in general possible to invert the evaluation map from subsection  [ subsubsection.one.line ] and thus map @xmath7 to @xmath2 .",
    "this is corollary  [ corr.later ] .. ] so    there is a canonical map @xmath95 ( syntax to denotation)we saw this map in part  1 of this example  but    not in general an inverse map @xmath92 ( denotation to syntax ) .",
    "_ axiom k _ , also called the _",
    "normality axiom _ ( * ? ? ?",
    "* definition  1.39 , subsection  1.6 ) ; its type is @xmath96 .    we can write a term of this type . intuitively , the term below takes syntax for a function and syntax for an argument , and produces syntax for the function applied to the argument : @xmath97    [ rmrk.modal ] we exhibited terms of type @xmath95 , @xmath98 , and @xmath96 , so figure  [ fig.modal.types ] implements ( at least ) the deductive power of an intuitionistic variant of s4 ( * ? ? ?",
    "* subsection  4.1 , page  194).[multiblock footnote omitted ]    the reader familiar with category theory may also ask whether @xmath1 can be viewed as a _ comonad _ , since @xmath95 and @xmath98 look like the types of a _ counit _ and _ comultiplication _ ( and perhaps @xmath96 looks like the action of a functor ) .",
    "we return to this in section  [ sect.box.comonad ] .",
    "this is a classic example of meta - programming : write a function that takes a number @xmath99 and returns syntax for the function @xmath100 .    assuming a combinator for primitive recursion over natural numbers and using some standard sugar , the following term implements exponentiation : @xmath101{r@{\\ } l } { \\ensuremath{\\mathit{exp}}}\\ 0\\rightarrow&\\box{\\lambda{b{:}{\\mathbb n}}.}1   \\\\   { \\ensuremath{\\mathit{exp}}}\\ ( { \\ensuremath{\\mathit{succ}}}(n))\\rightarrow&{{\\ensuremath{\\mathit{let\\,}}}x{=}{\\ensuremath{\\mathit{exp}}}\\,n{\\ensuremath{\\mathit{\\ in\\,}}}\\bigl(\\box { \\lambda{b{:}{\\mathbb n}}.}b*(x_{\\mvat}b ) \\bigr ) } .",
    "\\end{array}\\ ] ] however , the term above generates @xmath102-reducts .",
    "the reader can see this because of the ` @xmath103 ' above .",
    "this application @xmath104 is trapped under a @xmath1 and _ will not _ reduce .    looking ahead to the reduction relation in figure  [ fig.reduction ]",
    ", @xmath105 reduces to @xmath106 looking ahead to the denotation of figure  [ fig.denot.terms ] , the denotation of @xmath105 will likewise be @xmath107 in a suitable sense .",
    "we indicate the calculation in subsection  [ subsubsect.exp.denot ] .    the contextual system of section  [ sect.contextual.system ] deals with this particular issue ; see subsection  [ subsubsect.exp.c ] .      [ defn.substitution ]",
    "an * ( atoms-)substitution * @xmath108 is a finite partial function from atoms @xmath109 to terms .",
    "@xmath108 will range over atoms - substitutions .",
    "write @xmath110 for the set @xmath111    write @xmath112 for the * identity * substitution , such that @xmath113 .",
    "write @xmath114 $ ] for the map taking @xmath37 to @xmath115 and undefined elsewhere .    an * ( unknowns-)substitution * @xmath116 is a finite partial function from unknowns @xmath12 to terms such that for every @xmath17 , if @xmath117 then @xmath118 for some @xmath40 with @xmath119 .",
    "@xmath116 will range over unknowns - substitutions .",
    "we write @xmath120 ,  @xmath112 ,  and @xmath121 $ ] just as for atoms - substitutions .",
    "[ defn.fa.sigma ] define @xmath122    [ rmrk.theta.varnothing ] where @xmath116 is defined , it maps @xmath17 specifically to terms the form @xmath39 with @xmath119 .",
    "this is because ` @xmath39 with @xmath119 ' is the syntax inhabiting modal types .",
    "if we consider another class of syntax ( e.g. in the contextual system of section  [ sect.contextual.system ] onwards ) , then the corresponding notion of unknowns - substitution changes in concert with that .",
    "@xmath123 c\\theta=&c & a\\theta=&a \\\\",
    "( rs)\\theta=&(r\\theta)(s\\theta ) & x_{\\mvat}\\theta=&s '   & ( \\theta(x)=\\box s ' ) \\\\",
    "( \\box r)\\theta=&\\box(r\\theta ) & x_{\\mvat}\\theta=&x_{\\mvat}&(x\\not\\in{{{\\ensuremath{\\mathit{dom}}}}}(\\theta ) ) \\\\ ( { \\lambda{c{:}{a}}.}r)\\theta=&{\\lambda{c{:}{a}}.}(r\\theta )   & ( { { \\ensuremath{\\mathit{let\\,}}}y{=}s{\\ensuremath{\\mathit{\\ in\\,}}}r})\\theta=&{{\\ensuremath{\\mathit{let\\,}}}y{=}s\\theta{\\ensuremath{\\mathit{\\ in\\,}}}r\\theta } & ( y\\not\\in{{\\ensuremath{\\mathit{fu}}}}(\\theta ) ) \\end{array}\\ ] ]    definition  [ defn.sub ] describes how atoms and unknowns get instantiated .",
    "we discuss it in remark  [ rmrk.comments.on.sub ] but one point is important above all others : if @xmath124 then @xmath125 is equal to @xmath126 .",
    "so a very simple reduction / computation is ` built in ' to the substitution action for unknowns , that @xmath127 .",
    "is not actually syntax , but if it were , then @xmath127 would be its reduction . ]",
    "[ defn.sub ] define * atoms * and * unknowns * substitution actions @xmath128 and @xmath129 inductively by the rules in figure  [ fig.sub ] .",
    "lemma  [ lemm.fa.rtheta ] illustrates a nice corollary of the point discussed in remark  [ rmrk.theta.varnothing ] .",
    "it will be useful later in proposition  [ prop.typesub ] .",
    "[ lemm.fa.rtheta ] @xmath130 .    by a routine induction on @xmath40 using our assumption of definition  [ defn.substitution ] that if @xmath117 then @xmath131 .",
    "[ rmrk.comments.on.sub ] a few comments on definition  [ defn.sub ] :    the two capture avoidance side - conditions @xmath132 and @xmath133 can always be guaranteed by renaming .",
    "we write @xmath134 .",
    "this is computationally wasteful in the sense that the side - condition @xmath119 on @xmath71 ( figure  [ fig.modal.types ] ) guarantees that for typable terms ( which is what we care about ) @xmath135 .",
    "we prefer to keep basic definitions orthogonal from such optimisations , but this is purely a design choice ( and see the next item in this list ) .",
    "we write @xmath136 without any side - condition that @xmath137 should avoid capture by atoms in @xmath116 .",
    "this is because definition  [ defn.substitution ] insists that @xmath131 always , so there can be no capture to avoid .",
    "recall the definition of @xmath138 $ ] from definition  [ defn.substitution ] .",
    "lemma  [ lemm.standard.fv.sub ] is a standard lemma which will be useful later :    [ lemm.standard.fv.sub ] if @xmath139 then @xmath140=r$ ] .    by a routine induction on @xmath40 .",
    "definition  [ defn.gamma.theta ] and proposition  [ prop.rtheta ] are needed for proposition  [ prop.typesub ] .",
    "[ defn.gamma.theta ] suppose @xmath62 is a typing context and @xmath116 is an unknowns substitution .",
    "write @xmath141 when if @xmath117 then @xmath142 for some @xmath7 and @xmath143 .",
    "proposition  [ prop.rtheta ] is needed for theorem  [ thrm.type.soundness ] ( soundness of the denotation ) .",
    "it is slightly unusual that soundness of typing under substitution should be needed for soundness under taking denotations .",
    "but the syntax is going to be _ part of _ the denotational semantics  that is its point  and",
    "so substitution is part of how this denotation is calculated ( see the case of @xmath39 in figure  [ fig.denot.terms ] ) .",
    "[ prop.rtheta ] suppose @xmath62 is a typing context and @xmath116 is an unknowns substitution and suppose @xmath141 ( definition  [ defn.gamma.theta ] )",
    ". then @xmath64 implies @xmath144 .    by a routine induction on the typing of @xmath40 .",
    "we consider four cases :    _ _ the case of @xmath71.__suppose @xmath64 and @xmath119 so that @xmath145 by @xmath71 . by inductive hypothesis @xmath144 . by lemma  [ lemm.fa.rtheta ]",
    "also @xmath146 .",
    "we use @xmath71 and the fact that @xmath147 , and proposition  [ prop.ws ] .    _ _ the case of @xmath148 for @xmath117.__by assumption in definition  [ defn.substitution ] ,  @xmath149 for some @xmath150 with @xmath151 . by assumption in definition  [ defn.gamma.theta ] @xmath152 . by definition  [ defn.sub ] @xmath153 . by proposition  [ prop.ws ] @xmath154 as required .    _ _ the case of @xmath155.__suppose @xmath156 so that by @xmath155 @xmath157 . by inductive hypothesis @xmath158 .",
    "we use @xmath155 .    _ _ the case of @xmath72.__suppose @xmath159 and @xmath160 so that by @xmath72 @xmath161 . renaming if necessary ,",
    "suppose @xmath162 . by inductive hypothesis @xmath163 and @xmath164 .",
    "we use @xmath72 and the fact that @xmath165 .",
    "we now develop a denotational semantics of the types and terms from definitions  [ defn.types ] and  [ defn.terms ] .",
    "the main definitions are in figures  [ fig.denot.types ] and  [ fig.denot.terms ] .",
    "the design is subtle , so there follows an extended discussion of the definition .",
    "[ defn.interpret.types ] define @xmath166 the * interpretation * of types by induction in figure  [ fig.denot.types ] .",
    "@xmath167    [ rmrk.how.to.interpret.types ] @xmath168 is a pair of truth - values , and @xmath169 is the set of natural numbers .",
    "@xmath170 is a function - space . work . if we chose a smaller , more sophisticated , and more complex notion of function - space here",
    ", then this would actually _ weaken _ the results we then obtain from the semantics . ] no surprises here .",
    "@xmath171 is a pair @xmath172 .",
    "we suggest the reader think of this as    some syntax @xmath39 and and just write @xmath173 , but when we build the contextual system in section  [ sect.contextual.system ] the @xmath1 will fill with bindings ( see definition  [ defn.terms.c ] ) and can not be dropped , so we keep it here . ]    its purported denotation @xmath174 .",
    "we say ` purported ' because there is no restriction that @xmath174 actually be a possible denotation of @xmath40 .",
    "for instance , it is a fact that @xmath175 , and @xmath176 will not be the denotation of any @xmath40 such that @xmath177 ( to check this , unpack definition  [ defn.denot.terms ] below ) .",
    "so our semantics inflates : there are usually elements in @xmath4 that are not the denotation of any closed term",
    ". the reader should remain calm ; there are also usually elements in function - spaces that are not the denotation of any closed term .",
    "the inflated elements in our semantics are an important part of our design .",
    "[ nttn.list.notation ] we will want to talk about nested pairs of the form @xmath178 . accordingly we will use list notation , writing @xmath179 for @xmath180 and @xmath181 for @xmath178 .",
    "see for instance remark  [ rmrk.next.remark ] , figure  [ fig.denot.terms ] , and subsection  [ subsect.den.letbox ] .",
    "[ rmrk.next.remark ] note that as standard , distinct syntax may have equal denotation .",
    "for instance , @xmath182 and @xmath183 are not equal in @xmath184 .",
    "[ rmrk.why.inflate ] why do we inflate ?",
    "surely it is both simpler and more intuitive to take @xmath4 to be @xmath185 .",
    "we could do this , but then later on in definition  [ defn.denot.terms ] we would not be able to give a denotation to terms by induction on their syntax .",
    "the problem is that our types , and terms , are designed to permit generation of syntax at modal type .",
    "thus , our design brief is to allow dynamic ( runtime ) generation of syntax . with the ` intuitive ' definition above",
    ", there is no guarantee of an inductively decreasing quantity ; the runtime can generate syntax of any size . to see this in detail , see subsection  [ subsubsect.explain ] .",
    "the design of @xmath4 in figure  [ fig.denot.types ] gets around this by insisting , at the very moment we assert some denotation of a term @xmath40 of type @xmath2i.e .",
    "some syntax @xmath150 of type @xmath7to simultaneously volunteer a denotation for @xmath150i.e .",
    "an element in the denotation of @xmath7 .",
    "( as mentioned in remark  [ rmrk.how.to.interpret.types ] this denotation might be in some sense mistaken , but perhaps surprisingly that will not matter . )",
    "we now set about interpreting terms in the denotation for types from definition  [ defn.interpret.types ] .",
    "the main definition is definition  [ defn.denot.terms ] .",
    "first , however , we need :    some tools to handle the ` syntax and purported denotation ' design of @xmath4 ( definition  [ defn.hd.tl ] ) ; and    a suitable notion of valuation ( definition  [ defn.valuation ] ) .",
    "we then discuss the design of the definitions .",
    "recall from notation  [ nttn.list.notation ] that we may use list notation and write @xmath186 for @xmath172 .",
    "[ defn.hd.tl ] we define @xmath187 and @xmath188 on @xmath189 ( definition  [ defn.interpret.types ] ) as follows :    if @xmath190 or @xmath184 or @xmath191 then @xmath192 and @xmath193 is undefined .    if @xmath194 then @xmath195 ( first projection ) and @xmath196 ( second projection ) .",
    "[ defn.valuation ] a * valuation * @xmath197 is a finite partial function on @xmath63 .",
    "write @xmath198 $ ] for the valuation such that :    @xmath199)(x)={x}$ ] .",
    "@xmath199)(y)=\\varsigma(y)$ ] if @xmath200 is defined , for all @xmath18 other than @xmath17 .",
    "@xmath199)(a)=\\varsigma(a)$ ] if @xmath201 is defined .",
    "@xmath199)$ ] is undefined otherwise .",
    "define @xmath202 $ ] similarly .",
    "[ defn.gamma.varsigma ] suppose @xmath62 is a typing context and @xmath197 a valuation .",
    "write @xmath203 when :    @xmath204 .    if @xmath205 then @xmath68 for some @xmath7 and @xmath206 .    if @xmath207 then @xmath142 for some @xmath7 and @xmath208 .",
    "[ rmrk.box.values ] unpacking definition  [ defn.interpret.types ] , clause  3 of definition  [ defn.gamma.varsigma ] ( the one for @xmath17 ) means that @xmath209 where @xmath210 and @xmath189 . note also that by the form of the derivation rules in figure  [ fig.modal.types ] , it follows that @xmath211 .",
    "so an intuition for @xmath212 ( cf .",
    "remark  [ rmrk.how.to.interpret.types ] ) is this    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ `` @xmath212 is some closed syntax @xmath150 ( presented as @xmath213 ) , and a candidate denotation for it @xmath189 '' , _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    or more concisely this :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ `` @xmath212 is a pair of syntax and denotation . ''",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    [ defn.varsigmaunknowns ] write @xmath214 for the unknowns substitution ( definition  [ defn.substitution ] ) such that",
    "_ x(x)=@xmath215((x ) )    if @xmath212 is defined , and @xmath214 is undefined otherwise .",
    "[ defn.denot.terms ] for each constant @xmath26 other than @xmath216 , @xmath217 , and @xmath218 fix some interpretation @xmath219 which is an element @xmath220 .",
    "suppose @xmath203 and @xmath64 .",
    "an * interpretation * of terms @xmath221 is defined in figure  [ fig.denot.terms ] .",
    "@xmath222 $ ] and @xmath223 $ ] from definition  [ defn.valuation ] .",
    "@xmath214 from definition  [ defn.varsigmaunknowns ] .",
    "@xmath224$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } ) \\\\ { { { \\llbracket r'r \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}=&{{{\\llbracket r ' \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}\\,{{{\\llbracket r \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } \\\\ { { { \\llbracket \\box r \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}=&(\\box(r\\varsigma_{{\\mathbb x}}))::{{{\\llbracket r \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } \\\\ { { { \\llbracket x_{\\mvat}\\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}=&{{\\ensuremath{\\mathit{tl}}}}(\\varsigma(x ) ) \\\\ { { { \\llbracket { { \\ensuremath{\\mathit{let\\,}}}x{=}s{\\ensuremath{\\mathit{\\ in\\,}}}r } \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}=&{{{\\llbracket r \\rrbracket_{\\scalebox{.8}{$\\varsigma[x{{:=}}{{{\\llbracket s \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}]$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } \\\\ { { { \\llbracket { \\mathsf{isapp}}_{a}\\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}(\\box(r'r''))= & \\top^{{{\\hspace{.00ex}\\scalebox{.55}{${\\ensuremath{\\mathscr h}}$}}}}\\\\ { { { \\llbracket { \\mathsf{isapp}}_{a}\\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}(\\box(r))=&\\bot^{{{\\hspace{.00ex}\\scalebox{.55}{${\\ensuremath{\\mathscr h}}$}}}}&({\\forall r',r''.}r\\neq r'r '' )   \\end{array}\\ ] ]    in subsection  [ subsect.denot.discuss ] we discuss the design of @xmath221 , with examples . in subsection  [ subsect.denot.results ]",
    "we prove some results about it .",
    "the denotations of @xmath216 and @xmath217 are as expected . to give a denotation to an atom @xmath37 , we just look it up using @xmath197 , also as expected .",
    "the definitions of @xmath38 and @xmath225 are also as standard .",
    "as promised in subsection  [ subsect.denot.types ] ,  @xmath226 returns a pair of a syntax and its denotation .",
    "@xmath227 is there to illustrate concretely how we can express programming on syntax of box types : it takes a syntax argument and checks whether it is a syntactic application .",
    "is a function on a set of syntax and we can define whatever operation we can define , on that set .",
    "] of course many other such functions are possible , and if we want them we can add them as further constants ( just as we might add @xmath228 , @xmath229 , and/or recursion as constants , given a type for numbers ) .      to illustrate how figure  [ fig.denot.terms ] works , we calculate the denotation of @xmath230 .",
    "we reason as follows , where for compactness and clarity we write @xmath197 for the valuation @xmath231 $ ] : @xmath232$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } \\\\ = & { { { \\llbracket \\box\\box x_{\\mvat}\\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } \\\\ = & \\box((\\box x_{\\mvat})[x{{:=}}\\box(1{+}2 ) ] ) : : { { { \\llbracket \\box x_{\\mvat}\\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } \\\\ = & \\box\\box(1{+}2 ) : : { { { \\llbracket \\box x_{\\mvat}\\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } \\\\ = & \\box\\box(1{+}2 ) : : \\box(x_{\\mvat}[x{{:=}}\\box(1{+}2 ) ] ) : : { { { \\llbracket x_{\\mvat}\\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } \\\\ = & \\box\\box(1{+}2 ) : : \\box(1{+}2 ) : : { { { \\llbracket x_{\\mvat}\\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } \\\\ = & \\box\\box(1{+}2 ) : : \\box(1{+}2 ) : : { { \\ensuremath{\\mathit{tl}}}}(\\box(1{+}2)::3 ) \\\\ = & \\box\\box(1{+}2 ) : : \\box(1{+}2 ) : : 3   \\end{array}\\ ] ] we leave it to the reader to verify that @xmath233 and that @xmath234=1{+}2 $ ] .",
    "note that ` @xmath235 ' and ` @xmath236 ' are different ; @xmath235 denotes @xmath237 whereas @xmath236 denotes the pair ` the syntax @xmath235 , with associated extension @xmath237 ' . in some very special cases where the set of possible denotations is rather small ( finite or countable )",
    ", the distinction between terms and their denotations can be hard to see , though it is still there .",
    "usually sets of denotations are ` quite large ' and sets of syntax are ` quite small ' , but sometimes this relationship is reversed : there are ` somewhat more ' terms denoting numbers , than numbers and @xmath238 denote the same number , whose calculation we leave as an exercise to the energetic reader . ] ( but much fewer terms denoting functions from numbers to numbers than functions from numbers to numbers )",
    ". see corollary  [ corr.later ] and example  [ xmpl.unevaluate.nat ] .",
    "note also the difference between the valuation @xmath239 $ ] and the substitution @xmath240 $ ] .",
    "the first is a valuation because it maps @xmath17 to @xmath241 , the second is a substitution because it makes @xmath17 to a term of type @xmath242 .",
    "sometimes a mapping can be both valuation and substitution ; for instance @xmath243 $ ] is a valuation ( @xmath37 maps to an element of @xmath184 ) , and is also a substitution .",
    "natural versions of definitions  [ defn.interpret.types ] and  [ defn.denot.terms ] take    the denotation of box type to be just boxed syntax rather than a pair of boxed syntax and denotation @xmath244 , and    @xmath245 and    @xmath246 where @xmath247 .",
    "however , this seems not to work ; @xmath212 need not necessarily be a smaller term than @xmath17 so the ` definition ' above is not inductive .",
    "this is not just a hypothetical issue : a term of the form @xmath248 may cause @xmath212 to be equal to @xmath249 , and @xmath42 might generate syntax of any size .",
    "the previous paragraph is not a mathematical proof ; aside from anything else we have left the notion ` size of term ' unspecified .",
    "the reader can experiment with different candidates : obvious ` subterm of ' , ` depth of ' , and ` number of symbols ' of are all vulnerable to the problem described above , as is a more sophisticated notion of size which gives @xmath17 size @xmath250 the least infinite cardinal  since we can generate multiple copies of terms of the form @xmath251 , and even if this is closed it can contain bound copies of @xmath17 .",
    "recalling subsection  [ subsubsect.exp ] , we calculate the denotation of @xmath252 where @xmath253 is specified by : @xmath101{r@{\\ } l } { \\ensuremath{\\mathit{exp}}}\\ 0\\rightarrow&\\box{\\lambda{b{:}{\\mathbb n}}.}1   \\\\   { \\ensuremath{\\mathit{exp}}}\\ ( { \\ensuremath{\\mathit{succ}}}(n))\\rightarrow&{{\\ensuremath{\\mathit{let\\,}}}x{=}{\\ensuremath{\\mathit{exp}}}\\,n{\\ensuremath{\\mathit{\\ in\\,}}}\\box ( { \\lambda{b{:}{\\mathbb n}}.}b*(x_{\\mvat}b ) ) } .",
    "\\end{array}\\ ] ] we sketch part of the calculation : @xmath254 = & { { { \\llbracket \\box({\\lambda{b{:}{\\mathbb n}}.}b*(x_{\\mvat}b ) ) \\rrbracket_{\\scalebox{.8}{$[x{{:=}}{{{\\llbracket { \\ensuremath{\\mathit{exp}}}\\,({\\ensuremath{\\mathit{succ}}}\\,0 ) \\rrbracket_{\\scalebox{.8}{$\\varnothing$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}]$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } \\\\[1.5ex ] = & \\box({\\lambda{b{:}{\\mathbb n}}.}b*(x_{\\mvat}b))[x{{:=}}{{\\ensuremath{\\mathit{hd}}}}{{{\\llbracket { \\ensuremath{\\mathit{exp}}}\\,({\\ensuremath{\\mathit{succ}}}\\,0 ) ) \\rrbracket_{\\scalebox{.8}{$\\varnothing$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } ] \\\\ & \\quad : : { { { \\llbracket { \\lambda{b{:}{\\mathbb n}}.}b*(x_{\\mvat}b ) \\rrbracket_{\\scalebox{.8}{$[x{{:=}}{{{\\llbracket { \\ensuremath{\\mathit{exp}}}\\,({\\ensuremath{\\mathit{succ}}}\\,0 ) \\rrbracket_{\\scalebox{.8}{$\\varnothing$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}]$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } \\\\ \\raisebox{3pt}{$\\cdots$ } & \\\\ = & \\box({\\lambda{b{:}{\\mathbb n}}.}b*({\\lambda{b{:}{\\mathbb n}}.}b*(({\\lambda{b{:}{\\mathbb n}}.}1)b)b))::(x\\in{\\mathbb n}{\\mapsto}x*x ) \\end{array}\\ ] ]      in subsection  [ subsubsection.one.line ] we considered the terms @xmath255 which implement the modal logic axioms @xmath88 and @xmath89 .",
    "we now describe their denotations , without working :    @xmath256 maps @xmath257 to @xmath258 .",
    "@xmath259 maps @xmath257 to @xmath260 .",
    "we need a technical result and some notation for proposition  [ prop.typesub ] :    [ lemm.varsigma.to.varsigmaun ] if @xmath203 ( definition  [ defn.gamma.varsigma ] ) then @xmath261 ( definition  [ defn.gamma.theta ] ) .    if @xmath262 then @xmath263 .",
    "suppose @xmath207 . by definition  [ defn.varsigmaunknowns ] @xmath264 . by definition  [ defn.gamma.varsigma ] @xmath265 for some @xmath7 .",
    "unpacking figure  [ fig.denot.types ] this implies that @xmath266 for some @xmath74 , and we are done .",
    "proposition  [ prop.typesub ] relies on a dual role played by syntax in @xmath214 .",
    "it is coerced between denotation and syntax in @xmath267 , and ` in the other direction ' in @xmath148 .",
    "proposition  [ prop.typesub ] expresses this important dynamic in the mathematics of the paper .",
    "technically , the result is needed for the case of @xmath71 in the proof of theorem  [ thrm.type.soundness ] .",
    "recall the notation @xmath77 from notation  [ nttn.restrict ] .",
    "[ prop.typesub ] suppose @xmath64 and @xmath203",
    ". then @xmath268 .",
    "( @xmath214 is defined in definition  [ defn.varsigmaunknowns ] ; its action on @xmath40 is defined in definition  [ defn.sub ] . )    by lemma  [ lemm.varsigma.to.varsigmaun ] @xmath261 . by proposition  [ prop.rtheta ] @xmath269 . by lemma  [ lemm.fa.rtheta ] @xmath270 .",
    "now it is a fact that @xmath271 , so by proposition  [ prop.ws ] @xmath268 as required .",
    "[ thrm.type.soundness ] if @xmath64 and @xmath203 then @xmath221 is defined and @xmath272 .    by induction on the derivation of @xmath64 .",
    "most of the rules follow by properties of sets and functions .",
    "we consider the interesting cases :    _ _ rule @xmath71.__suppose @xmath64 and @xmath273 so that by @xmath71 @xmath274 .",
    "suppose @xmath203 . then by inductive hypothesis @xmath272 .",
    "also , by proposition  [ prop.typesub ] @xmath275    it follows by definition  [ defn.interpret.types ] that @xmath276 as required .    _",
    "_ rule @xmath72.__suppose @xmath159 and @xmath160 so that by @xmath72 @xmath277 .",
    "suppose @xmath203 . by inductive hypothesis for @xmath160",
    "we have @xmath278 and so there is some term @xmath126 and some @xmath189 such that @xmath279 and @xmath280 .",
    "unpacking definition  [ defn.gamma.varsigma ] , @xmath281 $ ] . by inductive hypothesis for @xmath159",
    "we have @xmath282$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}\\in{{{\\llbracket { b}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}\\ ] ] and using definition  [ defn.denot.terms ] we have @xmath283$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}\\in{{{\\llbracket { b}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}\\ ] ] as required .    _ _ rule @xmath148.__by @xmath148 @xmath284 .",
    "suppose @xmath285 .",
    "unpacking definition  [ defn.gamma.varsigma ] , this means that @xmath286 for some @xmath126 and @xmath174 such that @xmath280 and @xmath189 . from definition  [ defn.denot.terms ] @xmath287 as required .    _ _ rule @xmath288.__suppose @xmath289 . by definition  [ defn.gamma.varsigma ]",
    "this means that @xmath206 . by definition  [ defn.denot.terms ] @xmath290 .",
    "the result follows .",
    "[ corr.later ] there is no term @xmath42 such that @xmath291 is typable and such that the map @xmath292 is injective .",
    "@xmath293 is an uncountable set whereas @xmath294 is countable .",
    "the result follows from theorem  [ thrm.type.soundness ] .",
    "[ xmpl.unevaluate.nat ] by corollary  [ corr.later ] there can be no term representing a function which reifies an element of @xmath166 to corresponding syntax .",
    "of course , there might be a term which reifies those elements of @xmath166 that are representable by syntax . for specific ` sufficiently small ' @xmath7 , this might even include all of @xmath166 .",
    "for example , if @xmath295 then the following function does the job : @xmath101{r@{\\ } l } { \\ensuremath{\\mathit{reifynat}}}\\ 0\\rightarrow&\\box 0 \\\\   { \\ensuremath{\\mathit{reifynat}}}\\ ( { \\mathsf{succ}}(n))\\rightarrow&{{\\ensuremath{\\mathit{let\\,}}}x{=}{\\ensuremath{\\mathit{reifynat}}}(n){\\ensuremath{\\mathit{\\ in\\,}}}\\box ( x_{\\mvat}{+}1)}. \\end{array}\\ ] ]    similar arguments to those used in corollary  [ corr.later ] and example  [ xmpl.unevaluate.nat ] also justify why the haskell programming language has a _ show _ function for certain types , but not for function types .",
    "we chose full function spaces in figure  [ fig.denot.terms ] , so that the models for which we prove soundness in theorem  [ thrm.type.soundness ] would be large , and we did that so that the proof of corollary  [ corr.later ] would become relatively easy .",
    "careful consideration has gone into the precise designs of @xmath296 and @xmath4 .",
    "we will later on in corollary  [ corr.later.c ] prove a similar result for the contextual system , and then later still in corollary  [ corr.more.c ] surprisingly leverage this to a result which even works for functions to all of @xmath297 rather than just to the ( much smaller ) @xmath298 .",
    "we have theorem  [ thrm.type.soundness ] ( soundness ) and corollary  [ corr.later ] ( impossibility in general of reifying denotation to syntax ) .",
    "the other major property of interest is that typing and denotation are consistent with a natural notion of reduction on terms .",
    "so we now turn our attention to the lemmas leading up to proposition  [ prop.type.soundness ] and theorem  [ thrm.red.sound ] .",
    "recall from definition  [ defn.sub ] the definition of the atoms - substitution action .",
    "lemma  [ lemm.typesub.a ] is a counterpart to proposition  [ prop.typesub ] .",
    "we had to prove proposition  [ prop.typesub ] earlier because calculating the denotation @xmath226 in figure  [ fig.denot.terms ] involves calculating @xmath299 ( an unknowns - substitution applied to a term ) .",
    "now we are working towards reduction , and @xmath102-reduction can generate atoms - substitution , so we need lemma  [ lemm.typesub.a ] .",
    "[ lemm.typesub.a ] suppose @xmath300 and @xmath301 .",
    "then @xmath302:{a}$ ] .    by a routine induction on the typing of @xmath40 .",
    "we consider three cases :    _ _ the case of @xmath71.__suppose @xmath300 and @xmath273 so that @xmath303 by @xmath71 .",
    "but then by lemma  [ lemm.standard.fv.sub ] @xmath140=r$ ] , and the result follows from proposition  [ prop.ws ] .",
    "_ _ the case of @xmath148__is similar to that of @xmath71 .",
    "_ _ the case of @xmath72.__using the fact from definition  [ defn.sub ] that @xmath304\\ = \\ { { \\ensuremath{\\mathit{let\\,}}}x{=}s'[a{{:=}}s]{\\ensuremath{\\mathit{\\ in\\,}}}r[a{{:=}}s]}.\\ ] ]    [ lemm.sub.var ] suppose @xmath300 and @xmath301 , and suppose @xmath203 .",
    "then @xmath305 \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}={{{\\llbracket r \\rrbracket_{\\scalebox{.8}{$\\varsigma[a{{:=}}{{{\\llbracket s \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}]$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] .    by a routine induction on the derivation of @xmath300 ( figure  [ fig.modal.types ] ) .",
    "we consider three cases :    _ _ the case of @xmath71.__we use lemma  [ lemm.standard.fv.sub ] and proposition  [ prop.ws ] ( as in the case of @xmath71 in the proof of lemma  [ lemm.typesub.a ] ) .",
    "_ the case of @xmath148.__by @xmath148 @xmath306 . by definition @xmath307=x_{\\mvat}$ ] .",
    "we use proposition  [ prop.ws ] .    _ _ the case of @xmath288 for @xmath37.__by @xmath288 @xmath308 . by assumption @xmath309 so unpacking definition  [ defn.gamma.varsigma ] , @xmath310 . by figure  [ fig.denot.terms ] @xmath311 , and",
    "we are done .",
    "proposition  [ prop.ws.denote ] can be viewed as a denotational counterpart of proposition  [ prop.ws ] :    [ prop.ws.denote ] suppose @xmath64 and @xmath203 and @xmath312 .",
    "suppose @xmath313 for every @xmath314 and @xmath315 for every @xmath316",
    ".    then @xmath317 .    by a routine induction on @xmath40 .",
    "[ lemm.suba.to.varsigma ] suppose @xmath156 and @xmath318 ,  and suppose @xmath203",
    ". then @xmath319$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}.\\ ] ]    we unpack the cases of @xmath0 and application in definition  [ defn.denot.terms ] .      [ lemm.letbox.denot ] suppose @xmath320 and @xmath203 .",
    "then @xmath321$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } .\\ ] ]    we just unpack the clause for @xmath41 in figure  [ fig.denot.terms ] ( well - definedness is from theorem  [ thrm.type.soundness ] ) .    [ lemm.comm.theta.x ] suppose @xmath116 is an unknowns - substitution ( definition  [ defn.substitution ] ) .",
    "suppose @xmath162 and suppose @xmath322 for every @xmath323 .",
    "then @xmath324\\theta = r\\theta[x{{:=}}\\box(s\\theta)]$ ] .    by a routine induction on @xmath40 .",
    "the interesting case is @xmath5 , for which it is easy to check that : @xmath325=s\\theta \\quad\\text{and}\\quad",
    "x_{\\mvat}[x{{:=}}\\box s]\\theta = s\\theta.\\ ] ]    [ lemm.xsub.denot ] suppose @xmath326 and @xmath327 , and suppose @xmath203 .",
    "then @xmath328 \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}={{{\\llbracket r \\rrbracket_{\\scalebox{.8}{$\\varsigma[x{{:=}}{{{\\llbracket \\box s \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}]$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] .    by induction on the derivation of @xmath326 .",
    "_ _ the case of @xmath71.__suppose @xmath326 and @xmath119 so that by @xmath71 @xmath329 .",
    "we sketch the necessary reasoning :    ( r)[x:=s ] _",
    "^=&(r[x:=s ] ) _ ^ & + = & ( r[x:=s])_x::r[x:=s ] _ ^ & + = & ( r[x:=s])_x::r _ ^ & + = & ( r_x[x:=(s_x)])::r _ ^ & + r _ ^ = & ( r)()_x::r _ ^ & + = & ( r)_x[x:=(s_x)]::r _ ^ & + = & ( r_x[x:=(s_x)])::r _ ^ &    _ _ the case of @xmath148 for @xmath17.__by @xmath148 @xmath330 .",
    "then we reason as follows :    x__^=&@xmath331(s _ ^ ) & + = & s _ ^ & + x_[x:=s ] _ ^=&s _ ^ &      [ defn.reduction ] define * @xmath102-reduction * @xmath332 inductively by the rules in figure  [ fig.reduction ] .",
    "@xmath140 $ ] and @xmath333 $ ] from definition  [ defn.sub ] .",
    "@xmath334 \\using{\\ensuremath{(\\mathbf{\\beta } ) } } \\end{prooftree } & \\begin{prooftree } \\phantom{h } \\justifies { { \\ensuremath{\\mathit{let\\,}}}x{=}\\box s{\\ensuremath{\\mathit{\\ in\\,}}}r}{\\mathrel{\\to_\\beta}}r[x{{:=}}\\box s ] \\using{\\ensuremath{(\\mathbf{\\beta_\\box } ) } } \\end{prooftree } \\\\[5ex ] \\begin{prooftree } r{\\mathrel{\\to_\\beta}}r'\\quad s{\\mathrel{\\to_\\beta}}s ' \\justifies rs{\\mathrel{\\to_\\beta}}r 's ' \\using{\\ensuremath{(\\mathbf{cnga } ) } } \\end{prooftree } & \\begin{prooftree } r{\\mathrel{\\to_\\beta}}r ' \\justifies { \\lambda{a{:}{a}}.}r{\\mathrel{\\to_\\beta}}{\\lambda{a{:}{a}}.}r ' \\using{\\ensuremath{(\\mathbf{cngl } ) } } \\end{prooftree } \\\\[4ex ] \\begin{prooftree } r{\\mathrel{\\to_\\beta}}r'\\quad s{\\mathrel{\\to_\\beta}}s ' \\justifies { { \\ensuremath{\\mathit{let\\,}}}x{=}s{\\ensuremath{\\mathit{\\ in\\,}}}r}{\\mathrel{\\to_\\beta}}{{\\ensuremath{\\mathit{let\\,}}}x{=}s'{\\ensuremath{\\mathit{\\ in\\,}}}r ' } \\using{\\ensuremath{(\\mathbf{cnge } ) } } \\end{prooftree } \\\\[4ex ] \\begin{prooftree } \\phantom{h } \\justifies { \\mathsf{isapp}}\\,\\box(r'r){\\mathrel{\\to_\\beta}}\\top \\using{\\ensuremath{(\\mathbf{isapp\\top } ) } } \\end{prooftree } & \\begin{prooftree } ( r\\text { not of the form } r'r ) \\justifies { \\mathsf{isapp}}\\,\\box(r){\\mathrel{\\to_\\beta}}\\bot \\using{\\ensuremath{(\\mathbf{isapp\\bot } ) } } \\end{prooftree } \\end{array}\\ ] ]    we do not have a rule that if @xmath332 then @xmath335 .",
    "this would be wrong because it does not respect the integrity of the syntax of a term ; syntax , in denotation , does not inherently reduce .",
    "we do however allow reduction under a @xmath0 .",
    "this is purely a design choice ; we are interested in making as many terms as possible @xmath102-convertible , and less immediately interested in this paper in finding nice notions of @xmath102-normal form .",
    "if we did not have a denotational semantics then we might have to be more sensitive to such questions ( because normal forms are important for consistency)because we _ do _ have a denotational semantics , we obtain consistency via soundness and the precise notion of normal form is not so vital .",
    "[ prop.type.soundness ] if @xmath64 and @xmath336 then @xmath154 .    by a routine induction on @xmath40 .",
    "the case of @xmath337 @xmath338 $ ] follows by lemma  [ lemm.typesub.a ] ; that of @xmath339 follows by proposition  [ prop.typesub ] .",
    "[ thrm.red.sound ] suppose @xmath64 and @xmath203 .",
    "suppose @xmath332 .",
    "then @xmath340 .    by induction on the derivation of @xmath332 .    _ the case of @xmath337 _  follows by lemmas  [ lemm.sub.var ] and  [ lemm.suba.to.varsigma ] .",
    "_ the case of @xmath339 _  follows by lemmas  [ lemm.letbox.denot ] and  [ lemm.xsub.denot ] .",
    "the modal type system is beautiful , but is a little too weak for some applications .",
    "the issue is that @xmath17 ranges over _ closed _ syntax .",
    "if we are working under some @xmath0-abstractions , we may well find this limiting ; we want to work with _ open _ syntax so that we can refer to the enclosing binder .",
    "this really matters , because it affects the programs we can write .",
    "for instance in the example of exponentiation from subsection  [ subsubsect.exp ] , the issue of working under a @xmath0-abstraction forced us to generate unwanted @xmath102-redexes .",
    "the contextual system is one way to get around this .",
    "syntax is still closed , but the notion of closure is liberalised by introducing a context into the modality ; to see the critical difference , compare the @xmath341i})$ ] rule in figure  [ fig.cmtt.types ] with the @xmath71 rule from figure  [ fig.modal.types ] .",
    "the interested reader can see how this allows us to write a nicer program for exponentiation , which does not generate @xmath102-redexes , in subsection  [ subsubsect.exp.c ] .",
    "the contextual system needs many vectors of types and atoms - and - types . for clarity",
    ", we write these vectors subscripted , for instance :    @xmath342 is shorthand for @xmath343 .",
    "@xmath344_1^n{a}$ ] is shorthand for @xmath345{a}$ ] .",
    "@xmath346 is shorthand for @xmath347 .",
    "@xmath348 is shorthand for @xmath349 .",
    "@xmath350 is shorthand for @xmath351 .",
    "@xmath352_1^n$ ] will be shorthand for the map taking @xmath353 to @xmath354 for @xmath355 and undefined elsewhere ( definition  [ defn.substitution.c ] )",
    ".    we may omit the interval where it is understood or irrelevant , so for instance @xmath356 and @xmath357 are both shorthand for the same thing : `` @xmath349 for some @xmath99 whose precise value we will never need to reference '' , and @xmath358 is shorthand for `` @xmath346 for some @xmath99 whose precise value we will never need to reference '' .",
    "we take atoms and unknowns as in definition  [ defn.atoms ] .",
    "[ defn.types.c ] define * types * inductively by :    r@  l a::= & o naa_1^na    @xmath20 ( truth - values ) ,  @xmath22 ( numbers ) ,  and @xmath9 ( functions ) are as in definition  [ defn.types ] .",
    "@xmath344_1^n{a}$ ] is a _",
    "contextual type_. think of this as generalising the modal types of definition  [ defn.types.c ] by ` allowing bindings in the box ' .",
    "fix a set of * constants * @xmath24 to each of which is assigned a type @xmath25 .",
    "we write @xmath26 as shorthand for ` @xmath24 is a constant and @xmath27 ' .",
    "we insist that constants include the following : @xmath359 we may omit the type subscripts where they are clear from context or do not matter .    [ defn.terms.c ] define * terms * inductively by :    r::= c a .r rr r x(r_i)_1^n @xmath35x = r@xmath36r    [ rmrk.transfer.to.c ] the syntax of the modal type system in definition  [ defn.terms ] injects naturally into that of definition  [ defn.terms.c ] , if we map @xmath360 to @xmath361\\text{-}$ ] ( the empty context ) and @xmath362 to @xmath363 .",
    "the important extra complexity is in @xmath364 ; when @xmath17 is instantiated by a substitution @xmath116 , this triggers an atoms - substitution of the form @xmath365_1^n$ ] .",
    "see definition  [ defn.sub.c ] .",
    "[ defn.hole.free.atoms.c ] define * free atoms * @xmath52 and * free unknowns * @xmath53 by : @xmath366_{1}^n r ) = & { { \\ensuremath{\\mathit{fa}}}}(r)\\setminus\\{a_1,\\dots , a_n\\ } & { { \\ensuremath{\\mathit{fa}}}}({{\\ensuremath{\\mathit{let\\,}}}x{=}s{\\ensuremath{\\mathit{\\ in\\,}}}r } ) = & { { \\ensuremath{\\mathit{fa}}}}(r)\\cup{{\\ensuremath{\\mathit{fa}}}}(s ) \\\\ { { \\ensuremath{\\mathit{fa}}}}(x{\\mvat}(s_i)_i ) = & \\bigcup_i { { \\ensuremath{\\mathit{fa}}}}(s_i ) \\\\[2ex ] { { \\ensuremath{\\mathit{fu}}}}(c ) = & \\varnothing & { { \\ensuremath{\\mathit{fu}}}}(a ) = & \\varnothing \\\\ { { \\ensuremath{\\mathit{fu}}}}({\\lambda{a{:}{a}}.}{r } ) = & { { \\ensuremath{\\mathit{fu}}}}({r } )   & { { \\ensuremath{\\mathit{fu}}}}({r}{s } ) = & { { \\ensuremath{\\mathit{fu}}}}({r } ) \\cup { { \\ensuremath{\\mathit{fu}}}}({s } )    \\\\ { { \\ensuremath{\\mathit{fu}}}}([a_i{:}{a}_i]r ) = & { { \\ensuremath{\\mathit{fu}}}}(r ) & { { \\ensuremath{\\mathit{fu}}}}({{\\ensuremath{\\mathit{let\\,}}}x{=}s{\\ensuremath{\\mathit{\\ in\\,}}}r } ) = & ( { { \\ensuremath{\\mathit{fu}}}}(r){\\setminus}\\{x\\})\\cup{{\\ensuremath{\\mathit{fu}}}}(s ) \\\\ { { \\ensuremath{\\mathit{fu}}}}(x{\\mvat}(s_i)_i ) = & \\{x\\}\\cup\\bigcup_i{{\\ensuremath{\\mathit{fu}}}}(s_i ) \\end{array}\\ ] ]    we take @xmath37 to be bound in @xmath40 in @xmath38 and @xmath367 to be bound in @xmath40 in @xmath368_1^n r$ ] ,  and we take @xmath17 to be bound in @xmath40 in @xmath41 .",
    "we take syntax up to @xmath56-equivalence as usual . for example :    @xmath57    @xmath369((x{\\mvat}(b))a)={\\lambda{b{:}{a}}.}[a{:}{b}]((x{\\mvat}a)b)\\neq{\\lambda{b{:}{a}}.}[b{:}{b}]((x{\\mvat}(b))b)$ ]    @xmath370{l } { { \\ensuremath{\\mathit{let\\,}}}x{=}[a{:}{a}]a{\\ensuremath{\\mathit{\\ in\\,}}}(x{\\mvat}(b ) ) } \\\\",
    "= { { \\ensuremath{\\mathit{let\\,}}}y{=}[a{:}{a}]a{\\ensuremath{\\mathit{\\ in\\,}}}(y{\\mvat}(b ) ) } \\\\",
    "= { { \\ensuremath{\\mathit{let\\,}}}y{=}[b{:}{a}]b{\\ensuremath{\\mathit{\\ in\\,}}}(y{\\mvat}(b ) ) } \\end{array}$ ]    @xmath371 \\begin{prooftree } \\gamma , a{:}{a}{\\vdash}r:{b}\\justifies \\gamma{\\vdash}({\\lambda{a{:}{a}}.}r):{a}\\to { b}\\using{\\ensuremath{(\\mathbf{{\\to}i } ) } } \\end{prooftree } & \\begin{prooftree } \\gamma{\\vdash}r':{a}\\to { b}\\quad \\gamma{\\vdash}r:{a}\\justifies \\gamma{\\vdash}r'r:{b}\\using{\\ensuremath{(\\mathbf{{\\to}e } ) } } \\end{prooftree } \\\\[2em ] \\begin{prooftree } \\gamma,(a_i{:}{a}_i)_i{\\vdash}r:{a}\\quad ( { { \\ensuremath{\\mathit{fa}}}}(r){\\subseteq}\\{a_i\\}_i ) \\justifies \\gamma{\\vdash}[a_i{:}{a}_i]r:[{a}_i]{a}\\using{\\ensuremath{(\\mathbf{[\\,]i } ) } } \\end{prooftree } & \\begin{prooftree } \\gamma , x{:}[{a}_i]{a}{\\vdash}r { :} { b}\\ \\",
    "\\gamma{\\vdash}s{:}[{a}_i]{a}\\justifies \\gamma{\\vdash}{{\\ensuremath{\\mathit{let\\,}}}x{=}s{\\ensuremath{\\mathit{\\ in\\,}}}r}:{b}\\using{\\ensuremath{(\\mathbf{[\\,]e } ) } } \\end{prooftree } \\\\[2em ] \\begin{prooftree } \\gamma , x:[{a}_i]_1^n{a}{\\vdash}r_j:{a}_j\\quad ( 1{\\leq}j{\\leq}n ) \\justifies \\gamma , x:[{a}_i]_1^n{a}{\\vdash}x{\\mvat}(r_i)_1^n:{a}\\using{\\ensuremath{(\\mathbf{ext } ) } } \\end{prooftree } \\end{array}\\ ] ]      [ defn.typing.rules.c ] a * typing * is a pair @xmath60 or @xmath372_i{a}$ ] .",
    "a * typing context * @xmath62 is a finite partial function from @xmath63 to types ( as in definition  [ defn.typing.rules ] , except that unknowns have contextual types instead of just box types @xmath2 ) .",
    "a * typing sequent * is a tuple @xmath64 of a typing context , a term , and a type .",
    "define the * valid typing sequents * of the contextual modal type system by the rules in figure  [ fig.cmtt.types ] .",
    "recall the notation @xmath77 from notation  [ nttn.restrict ] .",
    "proposition  [ prop.ws.c ] repeats proposition  [ prop.ws ] for the contextual system :    [ prop.ws.c ] if @xmath64 and @xmath80 then @xmath81 .    by a routine induction on @xmath40 .",
    "definition  [ defn.substitution.c ] reflects definition  [ defn.substitution ] for the richer syntax of terms :    [ defn.substitution.c ] an * ( atoms-)substitution * @xmath108 is a finite partial function from atoms @xmath109 to terms .",
    "@xmath108 will range over atoms - substitutions .",
    "write @xmath110 for the set @xmath111    write @xmath112 for the * identity * substitution , such that @xmath113 .",
    "write @xmath352_1^n$ ] for the map taking @xmath353 to @xmath354 for @xmath355 and undefined elsewhere .",
    "an * ( unknowns-)substitution * @xmath116 is a finite partial function from unknowns @xmath12 to terms such that if @xmath373 is defined then @xmath374_1^n r$ ] for some @xmath40 with @xmath375 ( so @xmath131 for every @xmath117 ) .",
    "@xmath116 will range over unknowns - substitutions .",
    "we write @xmath120 ,  @xmath112 ,  and @xmath376_1^n$ ] just as for atoms - substitutions ( we will be most interested in the case that @xmath377 )",
    ".    we also reflect definition  [ defn.fa.sigma ] and write @xmath378 and @xmath379 , but using the notions of ` free atoms ' and ` free unknowns ' from definition  [ defn.hole.free.atoms.c ] .",
    "the definition is formally identical : @xmath380    [ defn.sub.c ] define substitution actions @xmath128 and @xmath129 by the rules in figure  [ fig.sub.c ] .",
    "the capture - avoidance side - conditions of definition  [ defn.sub.c ] ( of the form ` @xmath381 ' or ` @xmath382 ' ) can be guaranteed by @xmath56-renaming .    strictly speaking the case of",
    "@xmath383 introduces a partiality into the notion of substitution action ; we assume that @xmath374_1^m s'$ ] and _ for this to make sense _ it must be that @xmath384 ; if @xmath385 then the definition is not well - defined .",
    "however , for well - typed syntax this is guaranteed not to happen , and since this is the only case we will care about , we will never notice this .",
    "@xmath386r)\\sigma=&[a_i{:}{a}_i](r\\sigma )   & ( a_i\\not\\in{{\\ensuremath{\\mathit{fa}}}}(\\sigma)\\ \\text{all}\\ i )   \\\\[2.5ex ] c\\theta=&c & a\\theta=&a \\\\",
    "( rs)\\theta=&(r\\theta)(s\\theta ) & ( x{\\mvat}(r_i)_i)\\theta=&s'[a_i{{:=}}r_i ]   & ( \\theta(x){=}[a_i{:}{a}_i]s ' ) \\\\ ( [ a_i{:}{a}_i]r)\\theta=&[a_i{:}{a}_i](r\\theta ) & ( x{\\mvat}(r_i))\\theta=&x{\\mvat}(r_i ) & ( x\\not\\in{{{\\ensuremath{\\mathit{dom}}}}}(\\theta ) ) \\\\ ( { \\lambda{c{:}{a}}.}r)\\theta=&{\\lambda{c{:}{a}}.}(r\\theta )   & ( { { \\ensuremath{\\mathit{let\\,}}}y{=}s{\\ensuremath{\\mathit{\\ in\\,}}}r})\\theta=&{{\\ensuremath{\\mathit{let\\,}}}y{=}s\\theta{\\ensuremath{\\mathit{\\ in\\,}}}r\\theta } & ( y\\not\\in{{\\ensuremath{\\mathit{fu}}}}(\\theta ) ) \\end{array}\\ ] ]    we conclude this section with some important definitions and results about the interaction of substitution and typing , which will be needed for theorem  [ thrm.type.soundness.c ] .",
    "definition  [ defn.gamma.theta.c ] reflects definition  [ defn.gamma.theta ] , but we need @xmath387 as well as @xmath141 :    [ defn.gamma.theta.c ] write @xmath141 when if @xmath117 then @xmath388{a}\\in\\gamma$ ] for some @xmath344{a}$ ] and @xmath389{a}$ ] .",
    "similarly write @xmath387 when if @xmath390 then @xmath68 for some @xmath7 and @xmath391 .",
    "[ lemm.fa.rtheta.c ] @xmath130 where @xmath129 is defined .    by a routine induction on @xmath40 using our assumption of definition  [ defn.substitution.c ] that",
    "if @xmath117 then @xmath131 .",
    "lemma  [ lemm.sigma.c ] reflects lemma  [ lemm.typesub.a ] .",
    "however , unlike was the case for the modal system , it is needed for proposition  [ prop.rtheta.c]/[prop.rtheta ] because the case of @xmath392 in definition  [ defn.sub.c ] triggers an atoms - substitution .",
    "[ lemm.sigma.c ] suppose @xmath64 and @xmath387 .",
    "then @xmath393 .",
    "by routine inductions on the derivation of @xmath64 .",
    "proposition  [ prop.rtheta.c ] reflects proposition  [ prop.rtheta ] and is needed for soundness of the denotation .",
    "the proof is significantly more complex , because of the atoms - substitution that can be introduced by the case of @xmath394 .",
    "this is handled in the proof below using lemma  [ lemm.sigma.c ] .",
    "[ prop.rtheta.c ] suppose @xmath64 and @xmath141",
    ". then @xmath144 .    by a routine induction on the typing of @xmath40 .",
    "we consider two cases :    _ _ the case of @xmath395 i})$].__suppose @xmath396 and @xmath397 so that @xmath398r:[{b}_j]{a}$ ] by @xmath395 i})$ ] . by inductive hypothesis @xmath399 .",
    "by lemma  [ lemm.fa.rtheta.c ] @xmath400 .",
    "we use @xmath395i})$ ] and the fact that @xmath401r)\\theta=[b_j{:}{b}_j](r\\theta)$ ] .    _ _ the case of @xmath148 for @xmath117.__suppose @xmath402_1^m{a}{\\vdash}s_j:{a}_j$ ] for each @xmath403 so that by @xmath148 @xmath402_j{a}{\\vdash}x{\\mvat}(s_j)_j{:}{a}$ ] . by inductive hypothesis @xmath404 for each @xmath405 . by assumption @xmath406_j{a}$ ] , which implies that @xmath407r'$ ] for some @xmath150 such that @xmath408 . by lemma  [ lemm.sigma.c ] @xmath409:{a}$ ] . by the definitions @xmath410_j$ ] , so we are done .",
    "we could now give a theory of reduction for the contextual system , following the definition of reduction for the modal system in subsection  [ subsect.reduction ] .",
    "however , we will skip over this ; the interested reader is referred elsewhere @xcite . what is more interesting , from the point of view of this paper , is the models we define for the contextual system , which we come to next",
    "definition  [ defn.interpret.types.c ] is like definition  [ defn.interpret.types ] , except that instead of box types , we have contextual types :    [ defn.interpret.types.c ] define @xmath166 the * interpretation * of types by induction in figure  [ fig.denot.types.c ] .    o _ ^=&\\{^,^ } + _ ^=&\\{0,1,2 ,  } + _ ^=&_^^_^ + _ 1^na_^= & \\{[a_i : a_i]_1^n",
    "r[a_i : a_i]_1^n r:[a_i]_1^n a } _ ^^_i=1^n_i _ ^    _ ^=&^ + _",
    "^=&(a ) + r _ ^=&(x_^r _ ^ ) + rr _ ^=&r _ ^r _ ^ + _ 1^n r _ ^=&[a_i : a_i]_1^n(r_x ) : : ( .r _ ^ ) + x(r_i)_1^n _ ^=&@xmath331((x))(r_i _ ^)_1^n +   _ ^=&r _ ^ + _ a_^([a_i : a_i](rr))= & ^ + _ a_^([a_i : a_i](r))=&^    [ defn.valuation.c ] a * valuation * @xmath197 is a finite partial function on @xmath63 .",
    "we define @xmath223 $ ] and @xmath222 $ ] just as in definition  [ defn.valuation ] .",
    "[ defn.varsigmaunknowns.c ] write @xmath214 for the substitution ( definition  [ defn.substitution.c ] ) such that @xmath264 if @xmath212 is defined , and @xmath411 is undefined if @xmath212 is undefined .",
    "[ defn.gamma.varsigma.c ] if @xmath62 is a typing context then write @xmath203 when :    @xmath204 .",
    "if @xmath205 then @xmath70 for some @xmath7 and @xmath412 .    if @xmath207 then @xmath413{a}$ ] and @xmath414{a}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] .",
    "unpacking definition  [ defn.interpret.types.c ] , clause  3 ( the one for @xmath17 ) means that @xmath415 r'$ ] and @xmath416r':[{a}_i]{a}$ ] . following the typing rules of figure  [ fig.cmtt.types ] ,",
    "this is equivalent to @xmath417 .",
    "[ defn.denot.terms.c ] for each constant @xmath26 other than @xmath216 , @xmath217 , and @xmath218 fix some interpretation @xmath219 which is an element @xmath220 .",
    "suppose @xmath203 and @xmath64 .",
    "an * interpretation * of terms @xmath221 is defined in figure  [ fig.denot.terms.c ] .",
    "definition  [ defn.denot.terms.c ] is in the same spirit as definition  [ defn.denot.terms ] , but now the modal types are contextual ; the modal box contains a context @xmath418 .",
    "when we calculate @xmath419 the denotation of @xmath364 , the denotations of the terms @xmath420 provide denotations for the variables in that context .",
    "[ lemm.varsigma.to.varsigmaun.c ] if @xmath203 then @xmath261 .",
    "if @xmath262 then @xmath263 .",
    "suppose @xmath207 . by definition  [ defn.varsigmaunknowns.c ] @xmath264 . by definition  [ defn.gamma.varsigma.c ] @xmath421_1^n{a}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] for some @xmath344_1^n{a}$ ] .",
    "unpacking figure  [ fig.denot.types.c ] this implies that @xmath422_1^n r$ ] for some @xmath416_1^n r:[{a}_i]_1^n{a}$ ] , and we are done .    [ lemm.typesub.c ] suppose @xmath64 and @xmath203 .",
    "then @xmath423 .",
    "by lemma  [ lemm.varsigma.to.varsigmaun.c ] @xmath261 . by proposition  [ prop.rtheta.c ] @xmath269 . by lemma  [ lemm.fa.rtheta.c ]",
    "it is a fact that @xmath271 , so by proposition  [ prop.ws ] @xmath268 as required .",
    "[ thrm.type.soundness.c ] if @xmath64 and @xmath203 then @xmath272 .    by induction on the the derivation of @xmath64 .",
    "most of the rules follow by properties of sets and functions .",
    "we consider the interesting cases :    _ _ rule @xmath395i})$].__suppose @xmath424 so that by @xmath395i})$ ] @xmath425r:[{a}_i]{a}$ ] .",
    "suppose @xmath426 and @xmath203 .",
    "using lemma  [ lemm.typesub.c ] @xmath416(r\\varsigma_{{\\mathbb x}}):{a}$ ] .",
    "suppose @xmath427 for @xmath355 . by definition  [ defn.gamma.varsigma.c ] @xmath428_1^n\\ ] ]",
    "so by inductive hypothesis for the derivation of @xmath424 it follows that @xmath429_1^n$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}\\in{{{\\llbracket { a}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } .\\ ] ] now this was true for arbitrary @xmath354 and it follows from definition  [ defn.interpret.types.c ] that @xmath430r \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}\\in{{{\\llbracket [ { a}_i]{a}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] as required .    _",
    "_ rule @xmath395e})$].__suppose @xmath431{a}{\\vdash}r:{b}$ ] and @xmath432{a}$ ] so that by @xmath395e})$ ] @xmath161 .",
    "suppose @xmath203 . by inductive hypothesis for @xmath432{a}$",
    "] we have @xmath433{a}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] .",
    "it follows by definition  [ defn.gamma.varsigma.c ] that @xmath431{a}{\\vdash}\\varsigma[x{{:=}}{{{\\llbracket s \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}]$ ] so by inductive hypothesis for @xmath431{a}{\\vdash}r:{b}$ ] we have @xmath434$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}\\in{{{\\llbracket { b}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] .",
    "we now observe by definition  [ defn.denot.terms.c ] that @xmath321$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}\\in{{{\\llbracket { b}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}.\\ ] ]    _ _ rule @xmath148.__suppose @xmath431_1^n{a}{\\vdash}r_i:{a}_i$ ] for @xmath355 so that by @xmath148 @xmath431_1^n{a}{\\vdash}x{\\mvat}(r_i)_1^n{:}{a}$ ] .    by inductive hypothesis for the typings @xmath431_1^n{a}{\\vdash}r_i:{a}_i$ ] we have @xmath435 for @xmath355 .",
    "suppose @xmath431{a}{\\vdash}\\varsigma$ ] . by definitions  [ defn.gamma.varsigma.c ] and  [ defn.denot.terms.c ]",
    "this means that @xmath436_1^n r')::f$ ] for some @xmath416 r':[{a}_i]{a}$ ] and some @xmath437 .",
    "it follows that @xmath438 as required .    _",
    "_ rule @xmath288.__suppose @xmath289 . by definition  [ defn.gamma.varsigma.c ]",
    "this means that @xmath206 . by definition  [ defn.denot.terms.c ] @xmath290",
    "the result follows .",
    "_ _ rule @xmath155.__suppose @xmath156 so that by @xmath155 @xmath157 . suppose @xmath203 and choose any @xmath189 .",
    "it follows that @xmath439 $ ] and so by inductive hypothesis that @xmath440$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } \\in{{{\\llbracket { b}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } .",
    "$ ]    since @xmath189 was arbitrary , by definition  [ defn.denot.terms.c ] we have that @xmath441$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } ) \\in{{{\\llbracket { a}{{\\to}}{b}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } .\\ ] ]    [ corr.later.c ]    there is no term @xmath42 such that @xmath442({\\mathbb n}{{\\to}}{\\mathbb n})$ ] is typable and such that the map @xmath443({\\mathbb n}{{\\to}}{\\mathbb n } ) \\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}})^{{{{\\llbracket { \\mathbb n}{{\\to}}{\\mathbb n}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}}$ ] is injective .",
    "there is no term @xmath42 such that @xmath444{\\mathbb n}$ ] is typable and such that the map @xmath445{\\mathbb n}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}})^{{{{\\llbracket { \\mathbb n}{{\\to}}{\\mathbb n}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}}$ ] is injective .",
    "@xmath446({\\mathbb n}{{\\to}}{\\mathbb n } ) \\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] and @xmath447{\\mathbb n}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] are both countable sets whereas @xmath448 is uncountable .      the examples from subsection  [ subsect.some.programs ] transfer to the contextual system if we translate @xmath360 to @xmath361\\text{-}$ ] and @xmath362 to @xmath363 ( cf .",
    "remark  [ rmrk.transfer.to.c ] ) .",
    "so the reader can look to subsection  [ subsect.some.programs ] for some simpler examples .",
    "we now consider some slightly more advanced ideas .",
    "we can move between the types @xmath449{b}$ ] and @xmath361({a}{{\\to}}{b})$ ] using terms @xmath450{b}{{\\to}}[\\,]({a}{{\\to}}{b})$ ] and @xmath451({a}{{\\to}}{b}){{\\to}}[{a}]{b}$ ] defined as follows : @xmath452{b}}.}{{\\ensuremath{\\mathit{let\\,}}}x{=}c{\\ensuremath{\\mathit{\\ in\\,}}}[\\,]{\\lambda{a{:}{a}}. } x{\\mvat}(a ) } & [ { a}]{b}{{\\to}}[\\,]({a}{{\\to}}{b } ) \\\\ g = &   { \\lambda{c{:}[\\,]({a}{{\\to}}{b})}.}{{\\ensuremath{\\mathit{let\\,}}}x{=}c{\\ensuremath{\\mathit{\\ in\\,}}}[a{:}a]((x{\\mvat}())a ) } & [ \\,]({a}{{\\to}}{b}){{\\to}}[{a}]{b}\\end{array}\\ ] ] it is routine to check that the typings above are derivable using the rules in figure  [ fig.cmtt.types ] .    intuitively , we can write the following :    @xmath453 maps @xmath454r$ ] to @xmath361{\\lambda{a{:}{a}}.}r$ ] .    @xmath455 maps @xmath361{\\lambda{a{:}{a}}.}r$ ] to @xmath454(({\\lambda{a{:}{a}}.}r)a)$ ]  ( so @xmath455 introduces an @xmath102-redex ) .",
    "this can be made formal as follows : @xmath456r ) \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}=&[\\,]{\\lambda{a{:}{a}}.}(r\\varsigma_{{\\mathbb x } } ) \\qquad\\quad\\text{and } \\\\ { { \\ensuremath{\\mathit{hd}}}}{{{\\llbracket g\\,([\\,]{\\lambda{a{:}{a}}.}r ) \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}=&[a{:}{a}](({\\lambda{a{:}{a}}.}(r\\varsigma_{{\\mathbb x}}))a ) \\end{array}\\ ] ] the fact that @xmath455 introduces a @xmath102-redex reflects the fact that we have given our language facilities to build up syntax  but not to destroy it .",
    "we can build a precise inverse to @xmath453 if we give ourselves an explicit destructor for @xmath0-abstraction .",
    "so for instance , we can give ourselves option types and then admit a constant symbol @xmath457({a}{{\\to}}{a } ) { { \\to}}{\\mathsf{option } } ( [ { a}]{b})$ ] with intended behaviour as follows : @xmath458\\,r ) & \\mbox{if $ { { { \\llbracket t \\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } = ( [ \\ ] \\lambda a{:}a .",
    "r ) { : : } \\_$}\\\\    { \\mathsf{none } } & \\mbox{otherwise } \\end{array}\\right.\\ ] ] using @xmath459 we could map from @xmath361({a}{{\\to}}{b})$ ] to @xmath449{b}$ ] in a manner that is inverse to @xmath453.[multiblock footnote omitted ]      recall from subsection  [ subsubsect.exp ] the discussion of exponentiation and how in the modal system the natural term to meta - program exponentiation introduced @xmath102-reducts .",
    "the following term implements exponentiation : @xmath101{r@{\\ } l } { \\ensuremath{\\mathit{exp}}}\\,0\\rightarrow\\ & [ b{:}{\\mathbb n}]1   \\\\   { \\ensuremath{\\mathit{exp}}}\\,({\\mathsf{succ}}\\,n)\\rightarrow\\ & { { \\ensuremath{\\mathit{let\\,}}}x{=}[b{:}{\\mathbb n}]{\\ensuremath{\\mathit{exp}}}\\,n{\\ensuremath{\\mathit{\\ in\\,}}}[b{:}{\\mathbb n}](b*(x{\\mvat}(b ) ) ) }   \\end{array}\\ ] ] this term does not generate @xmath102-reducts in the way we noted of the corresponding term from subsection  [ subsubsect.exp ] . for instance , @xmath460(b*b*1 ) .\\ ] ] compare this with subsection  [ subsubsect.exp.denot ] .",
    "think of the @xmath461 $ ] in @xmath461r$ ] as a ` translucent lambda ' , and think of @xmath462 as a corresponding application .",
    "we can use these to carry out computation  a rather weak computation ; just a few substitutions as formalised in the clause for @xmath463 in figure  [ fig.sub.c]but this computation occurs _",
    "inside _ a modality , which we could not do with an ordinary @xmath0-abstraction .    now might be a good moment to return to the clause for @xmath464r$ ] in figure  [ fig.denot.terms.c ] : @xmath465_1^n r \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}=[a_i{:}{a}_i]_1^n(r\\,\\varsigma_{{\\mathbb x } } ) : : \\bigl({\\lambda{(x_i{\\in}{{{\\llbracket { a}_i \\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}})_1^n}.}{{{\\llbracket r \\rrbracket_{\\scalebox{.8}{$\\varsigma[a_i{{:=}}x_i]_1^n$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}\\bigr)\\ ] ] we see the @xmath0-abstraction in the semantics , and we also see its ` translucency ' : the @xmath0-abstraction appears in the extension , but is also associated with a non - functional intension .",
    "there is a schema of _ unpack _ programs , parameterised over @xmath342 which evaluates syntax with @xmath99 free atoms :    @xmath466=& .. x(a_i)_1^n & : [ a_i]_1^nb((a_i)_1^nb )    we can express the following connection between @xmath467 ( which is a term ) and @xmath188 ( which is a function on denotations ) :    [ lemm.unpack.routine ] suppose @xmath425s:[{a}_i]{a}$ ] and @xmath203",
    ". then @xmath468s \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}={{\\ensuremath{\\mathit{tl}}}}{{{\\llbracket [ a_i{:}{a}_i]s \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } .\\ ] ]    by long but routine calculations unpacking figure  [ fig.denot.terms.c ] .    as an aside ,",
    "note that if we have diverging terms @xmath469 then we can combine this with @xmath467 to obtain a term @xmath470{a}}.}{\\ensuremath{\\mathit{unpack}}}\\,a\\,(\\omega_i):[{a}_i]{a}{{\\to}}{a}$ ] . in a call - by - name evaluation strategy ,",
    "this loops forever if evaluation tries to refer to one of the ( diverging ) arguments .      as in subsection  [ subsubsection.one.line ]",
    "we can write functions corresponding to axioms from the necessity fragment of s4 :    t = & .@xmath35x = a@xmath36x ( ) & : [ ] aa + 4 = & x.@xmath35x = x@xmath36 [  ] [  ] x ( ) & : [  ] a [  ] [  ] a + k = & .. @xmath35f = f@xmath36@xmath35x = x@xmath36f ( )  x ( ) & : [  ] ( a b ) [  ] a [  ] b    ( of course , @xmath471 is just a special case of @xmath467 above . )",
    "versions of the terms @xmath472 and @xmath473 exist for non - empty contexts .",
    "for example , we can have a schema of @xmath474 axioms , for any context @xmath62 :    4 _ = & .@xmath35x = x@xmath36 [  ] [ ] x ( i d _ ) & : [ ] a [  ] [ ] a    here and below we abuse notation by putting @xmath475 $ ] in the type ; we intend the _ types _ in @xmath62 , with the variables removed .",
    "above , @xmath476 is the identity substitution defined inductively on @xmath62 by @xmath477 note that the terms realising @xmath474 are not uniform , because the substitution @xmath476 is not a term in the language ; it is a meta - level concept , producing different syntax depending on @xmath62 .",
    "similarly , we have a schema of @xmath478 terms :    k_= & . .",
    "@xmath35f = f@xmath36@xmath35x = x@xmath36 [ ] f id_x",
    "i d _ & : [ ] ( a b ) [ ] a [ ] b     and terms exposing the structural rules of contexts :    _ _ 1 , _ 2 = & z. @xmath35z = z@xmath36[_1 , _ 2 ] ( z ( id__1 ) ) & : [ _ 1 ] a [ _ 1 , _ 2 ] a + _ b = & z. @xmath35z = z@xmath36[x : b ] ( z ( x , x ) ) & : [ b , b ] a [ b ] a + _ b , c = & z. @xmath35z = z@xmath36[y : c , x : b ] ( z ( x , y ) ) & : [ b , c ] a [ c , b ] a    we give @xmath479 in full generality and then for brevity @xmath480 and @xmath481 only for two - element contexts . if we think in terms of multimodal logic @xcite these terms ` factor ' , ` fuse ' , and ` rearrange ' contexts / modalities .",
    "we have seen semantics to both the modal and contextual type systems .",
    "we have also noted that , like function - spaces , our semantics _",
    "inflates_. we discussed why in remark  [ rmrk.why.inflate ] and subsection  [ subsubsect.explain ] .    in this section we delve deeper into the fine structure of the denotation to isolate a property of those parts of the denotation that can be described by syntax ( definition  [ defn.shape ] ) .",
    "this is an attractive well - formedness / well - behavedness property in its own right , and furthermore , we can exploit it to strengthen corollaries  [ corr.later ] and  [ corr.later.c ] ( see corollary  [ corr.more.c ] ) .",
    "[ defn.shape ] define the * shapely * @xmath189 inductively by the rules in figure  [ fig.shape ] .",
    "call @xmath197 * shapely * when :    @xmath212 is shapely for every @xmath207 .",
    "@xmath201 is shapely for every @xmath205 .",
    "intuitively , @xmath174 is shapely when , if it is intensional ( so @xmath174 is in some @xmath6{a}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] ) then the intension @xmath482 and the extension @xmath193 match up . in particular",
    ", this means that elements in @xmath483 , @xmath184 , or @xmath293are automatically shapely .",
    "conversely , @xmath174 is not shapely if it has an intension and an extension and they do not match up .",
    "the paradigmatic non - shapely element is @xmath3610::1 $ ] , since the intension ` the syntax @xmath484 ' does not match the extension ` the number @xmath33 ' .",
    "@xmath485{a}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}\\ \\text{is shapely } \\using{\\ensuremath{(\\mathbf{shape[\\ , ] } ) } } \\end{prooftree } \\\\[2ex ] \\begin{prooftree } { \\forall y\\in{{{\\llbracket { b}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}.}y\\ \\text{is shapely}{\\rightarrow}xy\\in{{{\\llbracket { a}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}\\ \\text{is shapely } \\justifies x\\in{{{\\llbracket { b}{{\\to}}{a}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}\\ \\text{is shapely } \\using{\\ensuremath{(\\mathbf{shapefun } ) } } \\end{prooftree } \\\\[2ex ] \\begin{prooftree } ( x\\in{{{\\llbracket \\mathbb b \\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } ) \\justifies x\\in{{{\\llbracket \\mathbb b \\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}\\ \\text{is shapely } \\using{\\ensuremath{(\\mathbf{shape\\mathbb b } ) } } \\end{prooftree } \\qquad \\begin{prooftree } ( x\\in{{{\\llbracket { \\mathbb n}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$ } } } } } } ) \\justifies x\\in{{{\\llbracket { \\mathbb n}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}\\ \\text{is shapely } \\using{\\ensuremath{(\\mathbf{shape{\\mathbb n } } ) } } \\end{prooftree } \\end{gathered}\\ ] ]    [ lemm.shape.back ]    if @xmath486 is shapely and @xmath487 is shapely , then so is @xmath488 .    if @xmath489{a}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] is shapely then @xmath490 .",
    "every @xmath491 is shapely .",
    "the first two parts follow from the form of the inductive definition in figure  [ fig.shape ] .",
    "the third part is a simple application of @xmath492 , noting that by @xmath493 every @xmath494 is shapely .",
    "we can combine lemmas  [ lemm.shape.back ] and  [ lemm.unpack.routine ] to get a nice corollary of shapeliness ( @xmath467 is from subsection  [ subsect.code.to.values ] ) :    if @xmath489a \\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] is shapely then @xmath495 .",
    "suppose @xmath489a \\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] is shapely , so that by part  2 of lemma  [ lemm.shape.back ] @xmath490 .",
    "we apply @xmath188 to both sides and use lemma  [ lemm.unpack.routine ] .",
    "[ lemm.sub.x.c ] suppose @xmath496{b}{\\vdash}r:{a}$ ] , @xmath497s:[{b}_i]{b}$ ] , and @xmath203",
    ". then @xmath498s ] \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}={{{\\llbracket r \\rrbracket_{\\scalebox{.8}{$\\varsigma[x{{:=}}{{{\\llbracket [ { b}_i]s \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}]$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] .    by a routine induction on the derivation of @xmath64 , similar to the proof of lemma  [ lemm.xsub.denot ] .",
    "[ corr.shape.varsigmaun ] suppose @xmath64 ,  @xmath203 ,  and @xmath197 is shapely .",
    "then @xmath499 .",
    "first , we note that the effect of @xmath214 can be obtained by concatenating @xmath500 $ ] for every @xmath501 .",
    "the order does not matter because by construction @xmath502 is closed syntax ( no free variables ) .",
    "furthermore since @xmath197 is shapely , @xmath503 so we can write @xmath197 as @xmath504,\\ ] ] where here @xmath505}$ ] is the map taking @xmath17 to @xmath506 for every @xmath507 .",
    "for the contextual system ; this is not hard . ]",
    "we now use lemma  [ lemm.sub.x.c ] for @xmath508 $ ] for each @xmath501 , and proposition  [ prop.ws.c ] .    [",
    "prop.shape.r ] suppose @xmath64 and suppose @xmath203",
    ". then if @xmath197 is shapely then so is @xmath221 .    by induction on the typing",
    "@xmath64 ( figure  [ fig.cmtt.types ] ) .    _",
    "the case of @xmath288 _ is immediate because by assumption @xmath201 is shapely .    _",
    "the case of @xmath509 _ is also immediate ( provided that all semantics for constants are shapely ) .    _ _ the case of @xmath155.__suppose @xmath156 so that by @xmath155 @xmath157 .",
    "suppose @xmath189 is shapely .",
    "then so is @xmath222 $ ] and by inductive hypothesis so is @xmath510$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] .",
    "it follows by @xmath492 that @xmath511$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}\\bigr)\\ ] ] is shapely .",
    "_ the case of @xmath512.__suppose @xmath513 and @xmath64 so that by @xmath512 @xmath514 .",
    "by inductive hypothesis @xmath515 and @xmath221 are both shapely . by part  1 of lemma  [ lemm.shape.back ] so is @xmath516 .",
    "_ _ the case of @xmath395 i})$].__suppose @xmath517 and @xmath518 so that by @xmath395i})$ ] @xmath425r:[{a}_i]{a}$ ]",
    ".    by inductive hypothesis @xmath519 is shapely for every shapely @xmath520 such that @xmath521 and it follows that @xmath522r \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}={{{\\llbracket { \\lambda{(a_i{:}{a}_i)}.}r \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] is shapely .    also unpacking definitions",
    "@xmath523r \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}=[a_i{:}{a}_i](r\\varsigma_{{\\mathbb x}}).\\ ] ] so it suffices to verify that @xmath430r \\rrbracket_{\\scalebox{.8}{$\\varsigma$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}={{{\\llbracket [ a_i{:}{a}_i](r\\varsigma_{{\\mathbb x } } ) \\rrbracket_{\\scalebox{.8}{$\\varnothing$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] .",
    "this follows from corollary  [ corr.shape.varsigmaun ] .",
    "corollary  [ corr.later.c ] proved that denotations can not be reified to syntax in general , by general arguments on cardinality .",
    "but our denotational semantics is inflated ; @xmath524({a}{{\\to}}{b } ) \\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] and @xmath191 have the same cardinality even if @xmath525({a}{{\\to}}{b } ) \\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}})$ ] and @xmath191 do not .",
    "corollary  [ corr.more.c ] tells us that we can not in general even reify denotation to the ` inflated ' denotations , even if they are large enough . in this sense , inflation is ` not internally detectable ' :    [ corr.more.c ]    there is no term @xmath42 such that @xmath442({\\mathbb n}{{\\to}}{\\mathbb n})$ ] is typable and such that @xmath526({\\mathbb n}{{\\to}}{\\mathbb n } ) \\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}^{{{{\\llbracket { \\mathbb n}{{\\to}}{\\mathbb n}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}}$ ] is injective .",
    "there is no term @xmath42 such that @xmath444{\\mathbb n}$ ] is typable and such that @xmath527{\\mathbb n}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}^{{{{\\llbracket { \\mathbb n}{{\\to}}{\\mathbb n}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}}$ ] is injective .    by proposition  [ prop.shape.r",
    "] @xmath42 is shapely , so by part  1 of lemma  [ lemm.shape.back ] it maps shapely elements of @xmath528 to shapely elements of @xmath524({\\mathbb n}{{\\to}}{\\mathbb n } ) \\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$]/@xmath529{\\mathbb n}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] . by part  3 of lemma  [ lemm.shape.back ] and",
    "the fact that @xmath530 is uncountable , the number of shapely elements of @xmath530 is uncountable . by part  2 of lemma  [ lemm.shape.back ] and",
    "the fact that syntax is countable , the number of shapely elements of @xmath524({\\mathbb n}{{\\to}}{\\mathbb n } ) \\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] and @xmath529{\\mathbb n}\\rrbracket_{\\scalebox{.8}{$$}}^{{\\hspace{.00ex}\\scalebox{.55}{$$}}}}}}$ ] is countable .",
    "the result follows .",
    "it is clear that part  1 of corollary  [ corr.more.c ] can be directly adapted to the modal system from section  [ sect.box.syntax ] .",
    "we noted as early as remark  [ rmrk.modal ] that @xmath1 looks like a comonad . in this section , we show that this is indeed the case .    before doing this",
    ", we would like to convince the reader that this is obviously impossible .",
    "true , we have natural maps @xmath531 ( evaluation ) and @xmath532 ( quotation ) .",
    "however , if @xmath1 is a comonad then it has to be a functor on some suitable category , so we would expect some natural map in @xmath533 .",
    "this seems unlikely because if we had this , then we could take @xmath7 to be a unit type ( populated by one element ) and @xmath534 and thus generate a natural map from @xmath535 to @xmath536 . but how would we do this in the light of corollaries  [ corr.later.c ] and corollary  [ corr.more.c ] ?",
    "even where closed syntax exists for a denotation , there may be many different choices of closed syntax to represent the same denotation , further undermining our chances of finding _ natural _ assignments . `",
    "@xmath1 as a comonad ' seems doomed",
    ".    this problem is circumvented by the ` trick ' of considering a category in which each denotation must be associated with syntax ; we do not insist that the syntax and denotation match .",
    "this is essentially the same idea as _ inflation _ in remark  [ rmrk.how.to.interpret.types ] ( but applied in the other direction ; in remark  [ rmrk.how.to.interpret.types ] we inflated by adding a purported denotation to every syntax ; here we are inflating by adding a purported syntax to every denotation ) . in the terminology of definition  [ defn.shape ] we can say that we do not insist on _",
    "shapeliness_. we simply insist that some syntax be provided .",
    "modulo this ` trick ' , @xmath1 becomes a well - behaved comonad after all .",
    "write @xmath537 for _ first projection _ and @xmath538 for _ second projection_.    that is , @xmath539 and @xmath540 .",
    "[ defn.box.f ] suppose @xmath541 .",
    "define a function @xmath542 by sending @xmath543 where @xmath544 and @xmath545",
    ".    it may be useful to unpack what @xmath546 does .",
    "suppose @xmath547 where @xmath189 and @xmath548 .",
    "then @xmath549 sends @xmath550 to @xmath551 .",
    "[ defn.j ] define a category @xmath552 by :    objects are types @xmath7 .. this is fine ; the assignment @xmath553 is injective , so it makes no difference whether we take objects to be @xmath7 or @xmath166 . ]",
    "arrows from @xmath7 to @xmath10 are functions from @xmath4 to @xmath554 ( not from @xmath166 to @xmath555 ; as promised above , some syntax must be provided ) .",
    "composition of arrows is given by composition of functions .",
    "[ defn.box.functor ] define an endofunctor @xmath556 on @xmath552 mapping    an object @xmath7 to @xmath557 and    an arrow @xmath558 to @xmath559 from definition  [ defn.box.f ] .",
    "so @xmath1 is a type - former acting on types and @xmath556 is a functor acting on objects and arrows .",
    "objects happen to be types , and @xmath556 acts on objects just by prepending a @xmath1 .",
    "arrows are functions on sets , and the action on @xmath556 on these functions is more complex as defined above .",
    "[ defn.delta.tya ]    write @xmath560 for the identity on @xmath4 for each @xmath7 .",
    "write @xmath561 for the arrow from @xmath562 to @xmath7 given by the function mapping @xmath563 to @xmath4 taking @xmath564 to @xmath174 ( where @xmath544 )",
    ". this will be the * counit * of our comonad .",
    "write @xmath565 for the arrow from @xmath562 to @xmath566 given by the function mapping @xmath563 to @xmath567 taking @xmath564 to @xmath568 ( where @xmath544 )",
    ". this will be the * comultiplication * of our comonad .",
    "@xmath556 from definition  [ defn.box.functor ] is a functor .",
    "it is routine to verify that @xmath569 and if @xmath558 and @xmath570 then @xmath571 .",
    "@xmath561 is a natural transformation from @xmath556 to @xmath572 ( the identity functor on @xmath552 ) .",
    "@xmath565 is a natural transformation from @xmath556 to @xmath573 .",
    "suppose @xmath558 .",
    "for the first part , we need to check that @xmath574 .",
    "this is routine : @xmath575 the second part is similar and no harder .",
    "note that @xmath576 is an arrow from @xmath566 to @xmath562 .",
    "[ lemm.box.delta.a ] @xmath576 maps @xmath577 to @xmath578 .    by a routine calculation on the definitions : @xmath579    @xmath556 is a comonad .    we need to check that    @xmath580 and    @xmath581 .",
    "both calculations are routine .",
    "we consider just the second one .",
    "consider @xmath582 .",
    "then @xmath583 { $ \\box\\box\\box s::$ } ; \\end{tikzpicture } } } \\box\\box s::\\box r::x ) \\\\",
    "= & \\box\\box s::\\box r::x \\\\[1.5ex ] ( { { \\boxdot}}\\delta_{a}\\circ\\epsilon_{a})(\\box\\box s::\\box r::x)=&{{\\boxdot}}\\delta_{a}(\\box\\box\\box s : : { \\raisebox{-3pt}{\\begin{tikzpicture } \\node [ fill = shade , rounded corners=2pt ] { $ \\box\\box s::$ } ; \\end{tikzpicture } } } \\box r::x ) \\\\",
    "= & \\box\\box s::\\box r::x \\end{array}\\ ] ] the shaded part is the part that gets ` deleted ' . in the second case we use lemma  [ lemm.box.delta.a ] .",
    "recall that in the previous subsection we represented @xmath1 as a comonad on a category with the ` trick ' of associating syntax to every denotation .",
    "it is possible to put this in a broader context using the notion of _ relative comonad_.    following @xcite , a * relative comonad * consists of the following information :    two categories @xmath552 and @xmath584 and a functor @xmath585",
    ". from definition  [ defn.j ] is deliberate : this is the only @xmath552 we will care about in this paper .",
    "the definition of relative comonad from @xcite is general in the source category . ]    a functor @xmath586 .    for every @xmath587 an arrow @xmath588 ( the * unit * ) .    for every @xmath589 and arrow @xmath590 , an arrow @xmath591 ( the * kleisli extension * ) .",
    "furthermore , we insist on the following equalities :    if @xmath589 and @xmath592 then @xmath593 .    if @xmath587 then @xmath594 .    if @xmath595 and @xmath596 and @xmath597 then @xmath598 .",
    "[ defn.relative.comonad ] take @xmath584 to have objects types @xmath7 and arrows elements of @xmath599this is simply the natural category arising from the denotational semantics of figure  [ fig.denot.types ] .",
    "take @xmath552 to be the category of definition  [ defn.j ] .",
    "take @xmath600 to map @xmath601 to @xmath602 and to map @xmath541 to itself .",
    "take @xmath471 to map @xmath601 to @xmath603 and to map @xmath541 to @xmath546 from definition  [ defn.box.f ] .",
    "definition  [ defn.relative.comonad ] determines a relative comonad on @xmath584 .",
    "it is slightly simplified , but accurate , to describe relative ( co)monads as being for the case where we have an operator that is nearly ( co)monadic but the category in question has ` too many objects ' . by that view",
    ", @xmath1 is a comonad on the full subcategory of @xmath584 over modal types .",
    "now the intuition of modal types @xmath2 is ` closed syntax ' , so it may be worth explicitly noting here that this full subcategory is _ not _ just a category of syntax .",
    "each @xmath4 contains for each term @xmath74 also a copy of @xmath166 , because we inflate .",
    "the intuition realised by the denotation of @xmath2 in this paper means ` typable closed syntax of the same language , of type @xmath7 ' .",
    "this is difficult to get right because it is self - referential ; if we are careless then the undecidable runtime impinges on the inductively defined denotation .",
    "we noted this in subsection  [ subsubsect.explain ] .",
    "for that reason we realised this intuition by an ` inflated ' reading of @xmath2 as ` closed syntax , and purported denotation of that syntax ' . as noted in remark  [ rmrk.how.to.interpret.types ]",
    ", there is no actual restriction that @xmath604 needs to match up , in that @xmath40 must have denotation @xmath174 .",
    "when @xmath40 and @xmath174 _ do _ match up we say that @xmath186 is _",
    "shapely_. this is definition  [ defn.shape ] , and we use this notion for our culminating result in corollary  [ corr.more.c ] , which entails that there is no unform family of terms of type @xmath92 .",
    "the proof of this involves a beautiful interplay between syntax and denotation , which also illustrates the usefulness of denotational techniques ; we can use a sound model to show that certain things _ can not _ happen in the syntax , because if they did , they would have to happen in the model .",
    "[ [ future - work ] ] future work + + + + + + + + + + +    one avenue for future work is to note that our denotation is _ sets based _ , and so this invites generalisation to _ nominal _ sets semantics @xcite .    perhaps we could leverage this to design a language which combines the simplicity of the purely modal system with the expressivity of contextual terms . specifically , nominal sets are useful for giving semantics to open terms @xcite and we hope to develop a language in which we can retain the modal type system but relax the condition that @xmath119 in @xmath71 in figure  [ fig.modal.types ] ( much as the contextual system does , but in the ` nominal ' approach we would not add types to the modality ) .",
    "the underlying motivation here is that the contextual system is ` eager ' in accounting for free variables  we need to express all the variables we intend to use in the contextual modal type , by putting their types in the modality .",
    "we might prefer to program on open syntax in a ` lazy ' fashion , by stating that the syntax may be open , but not specifying its free variables explicitly in the type .",
    "note that this is not the same thing as programming freely on open syntax .",
    "free variables would still be accounted for in the typing context ( leading to some form of _ dynamic linking _ as and when open syntax is unboxed and evaluated ; for an example of a @xmath0-calculus view of dynamic linking , though not meta - programming , see @xcite ) .",
    "so all variables would be eventually accounted for in the typing context , but they would not need to be listed in the type .",
    "this is another reason for the specific design of our denotional semantics and taking the denotation of @xmath2 to be specifically closed syntax ; we hope to directly generalise this using nominal techniques so that @xmath2 can also denote ( atoms-)open syntax .",
    "this is future work .",
    "[ [ on-the-precise-meaning-of-corollarycorr.more.c ] ] on the precise meaning of corollary  [ corr.more.c ] + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    corollary  [ corr.more.c ] depends on the fact that we admitted no constants of type @xmath605",
    ". we may be able to admit such a constant , representing a function that takes denotation and associates to it some ` dummy syntax ' chosen in some fixed but arbitrarly manner .",
    "so corollary  [ corr.more.c ] does not ( and should not ) prove that terms of type @xmath605 are completely impossible  only that they do not arise from the base system and can not exist unless we explicitly choose to put them in there .",
    "[ [ technical - notes - on - the - jump - in - complexity - from - modal - to - contextual - system ] ] technical notes on the jump in complexity from modal to contextual system + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we noted in the introduction that sections  [ sect.box.syntax ] and  [ sect.contextual.system ] , and sections  [ sect.denotations ] and  [ sect.contextual.models ] are parallel developments of the syntax and examples of the modal and contextual systems .",
    "we briefly survey technical details of how these differences manifest themselves .",
    "the contextual system enriches the modal system with types in the modality .",
    "the increase in expressivity is exemplified in subsection  [ subsubsect.exp.c ] .    in the contextual system and not in the modal system , instantiation of unknowns",
    "can trigger an atoms - substitution ( see definition  [ defn.sub.c ] ) leading to a kind of ` cascade effect ' .",
    "this turns out to be terminating , well - behaved , and basically harmless  but this has to be verified , and that brings some specific technical material forward in the proofs for the contextual case that is not so prominent in the purely modal case ( notably , lemma  [ lemm.sigma.c ] ) .    a clear view of exactly where the extra complexity of the contextual system ` lives ' in the denotation can be obtained by comparing the denotational semantics of @xmath2 and @xmath344{a}$ ] in figures  [ fig.denot.types ] and  [ fig.denot.types.c ] .",
    "[ [ box - and - monads ] ] @xmath1 and monads + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    famously , moggi proposed to model computation using a monad @xcite .",
    "let us write it as @xmath606 .",
    "this type is intuitively populated by ` computations of type @xmath7 ' .",
    "the unit arrow @xmath607 takes a value of type @xmath7 and returns the trivial computation that just returns @xmath7 .    the difference from the",
    "_ co__monad of this paper in that our @xmath2 is populated by _ closed syntax _ , and not by _ computation_.",
    "if we have an element of @xmath530 then it is easy to build a computation that just returns that value ; it is however not easy  and may be impossible  to exhibit closed syntax to represent this computation .",
    "we could add a constant to our syntax for each of the uncountably many functions from natural numbers to natural numbers .",
    "this would be mathematically fine  but not particularly implementable .",
    "we do not assume this .",
    "closed syntax is of course related to computation , and we can make this formal : given an element in @xmath536 we can map it to a computation , just by executing it .",
    "so intuitively there is an arrow @xmath608 . in the modal logic tradition",
    "this is called axiom @xmath609 .    in summary",
    ": we propose that the moggi - style monads corresponds to a modal @xmath610 , whereas cmtt - style @xmath1 is a modal @xmath1 and corresponds to a comonadic structure .",
    "see also  @xcite , where the @xmath1 operator of several constructive variants of s4 ( not equivalent to the version we presented here ) is modeled as comonads .",
    "[ [ brief - survey - of - applications - of - box - calculi ] ] brief survey of applications of @xmath1 calculi + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    logic and denotation , not implementation , are the focus of this paper , but the ` @xmath1-calculi ' considered in this paper have their motivation in implementation and indeed they were specifically designed to address implementational concerns .",
    "we therefore give a brief survey of how ( contextual ) modal types have been useful in the more applied end of computer science .",
    "the connection of the modal @xmath1 calculus with partial evaluation and staged computation was noticed by davies and pfenning  @xcite , and subsequently used as a language for run - time code generation by wickline et al .",
    "the contextual variant of @xmath1 as a basis for meta - programming and modeling of higher - order abstract syntax was proposed by nanevski and pfenning  @xcite , and subsequently used to reason about optimised implementation of higher - order unification in twelf  @xcite , which could even be scaled to dependent types  @xcite .",
    "recently , the contextual flavor of the system has been used in meta - programming applications for reasoning and programming with higher - order abstract syntax by pientka and collaborators  @xcite .",
    "[ [ relationship - between - the - formulation - with - meta - variables - and - labeled - natural - deductions ] ] relationship between the formulation with meta - variables and labeled natural deductions + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the syntax of terms from definition  [ defn.terms ] does not follow instantly from the syntax of types from definition  [ defn.types ] ; in particular , the use of a two - level syntax ( also reminiscent of the two levels of nominal terms @xcite ) is a design choice , not an inevitability .",
    "the usual way to present inference systems based on modal logic is to have a propositional ( or variable ) context where each proposition is labeled by the ` world ' at which it is true  @xcite .",
    "when s4 is considered , we take advantage of reflexivity and transitivity of the kripke frame to simplify the required information to two kinds of facts :    what holds at the current world , but not necessarily in all future worlds .    what holds in the current world and also in all future worlds .",
    "by this view , the first kind of fact corresponds to atoms @xmath37 , and the second kind of fact corresponds to unknowns @xmath17 .",
    "so this can be seen as the origin of the two - level structure of our syntax in this paper .",
    "the interested reader can find the modal ( non - contextual ) version of our type - system presented using the labeled approach in a paper by davies and pfenning  @xcite , and each stage of computation is indeed viewed as world in a kripke frame .    [",
    "[ cmtt - and - nominal - terms ] ] cmtt and nominal terms + + + + + + + + + + + + + + + + + + + + + +    nominal terms were developed in @xcite and feature a two - level syntax , just like cmtt .",
    "that is made very clear in this paper , where the first author imported the nominal terms terminology of _ atoms _ and _",
    "unknowns_.    the syntax of this paper is not fully nominal ",
    "the @xmath611r$ ] of the contextual system may look like a nominal abstraction , but there are no suspended permutation @xmath612 ( instead , we have types in the modality ) .",
    "one contribution of this paper is to make formal , by a denotation , the precise status of the two levels of variable in cmtt .",
    "so we can note that the abstraction for atoms is functional abstraction in cmtt whereas the abstraction for atoms in nominal terms is nominal atoms - abstraction ; unknowns of nominal terms range over elements of nominal sets , whereas unknowns of cmtt range over ordinary sets functionally abstracted over finitely many arguments ; the notion of _ equivariance _ ( symmetry up to permuting atoms ) characteristic of all nominal techniques is absent in cmtt ( the closest we get is a term like @xmath613 in subsection  [ subsect.modal-style.axioms ] ) ; and in contrast the self - reflective character of cmtt is absent from nominal terms and the logics built out of it @xcite .",
    "so in spite of some structural parallels between cmtt and nominal terms in that both are two - level , there are also significant differences .",
    "as noted above , there is a parallel between cmtt and kripke structures , that is made more explicit in @xcite .",
    "a direct connection between nominal terms and kripke semantics has never been made , but the first author at least has been aware of it as a possibility , where ` future worlds ' corresponds to ` more substitutions arriving ' . also as discussed above",
    ", an obvious next step is to develop a modified modal syntax which takes on board more ` nominal ' ideas , applied to the modal intuitions which motivate the @xmath0-calculus of this paper .",
    "this is future work .",
    "[ [ the - syntax - of - this - paper - and - previous - work ] ] the syntax of this paper , and previous work + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the modal and contextual systems which we give semantics to in this paper , are taken from previous work .",
    "specifically , definition  [ defn.terms ] corresponds to @xcite , definition  [ defn.terms.c ] corresponds to @xcite , figure  [ fig.modal.types ] corresponds to @xcite and figure  [ fig.cmtt.types ] to @xcite",
    ".    we can not give specific definition references in the citations to @xcite and @xcite , because those papers never give a specific definition of their syntax .",
    "if they did , then they would correspond as described .",
    "we do feel that this paper does make some contribution in terms of presentation , and the exposition and definitions here may be tailored to a slightly different community .",
    "this paper was supported by spanish micinn project tin2010 - 20639 paran10 ; amarout grant pcofund - ga-2008 - 229599 ; ramon y cajal grants ryc-2010 - 0743 and ryc-2006 - 002131 ; and the leverhulme trust .",
    "thorsten altenkirch , james chapman , and tarmo uustalu .",
    "monads need not be endofunctors . in",
    "_ foundations of software science and computation structures , 13th international conference ( fossacs 2010 ) _ , volume 6014 of _ lecture notes in computer science _ , pages 297311 .",
    "springer , 2010 .",
    "natasha alechina , michael mendler , valeria de  paiva , and eike ritter . categorical and kripke semantics for constructive s4 modal logic . in _",
    "computer science logic , csl01 _ , volume 2142 of _ lecture notes in computer science _ , pages 292307 , 2001 .        andrew cave and brigitte pientka .",
    "programming with binders and indexed data - types . in _ proceedings of the 39th acm sigplan - sigact symposium on principles of programming languages ( popl12)_. acm , 2012 . accepted .",
    "amy felty and brigitte pientka .",
    "reasoning with higher - order abstract syntax and contexts : a comparison . in _",
    "interactive theorem proving _ , volume 6172 of _ lecture notes in computer science _ , pages 227242 , 2010 .",
    "murdoch  j. gabbay and dominic  p. mulligan .",
    "http://www.gabbay.org.uk/papers/unialt.pdf[universal algebra over lambda - terms and nominal terms : the connection in logic between nominal techniques and higher - order variables ] .",
    "in _ proceedings of the 4th international workshop on logical frameworks and meta - languages ( lfmtp 2009 ) _ , pages 6473 .",
    "acm , august 2009 .",
    "murdoch  j. gabbay and dominic mulligan .",
    "henkin semantics : simply - typed lambda - calculus models in nominal sets ] . in _ proceedings of the 6th international workshop on logical frameworks and meta - languages ( lfmtp 2011 ) _ , volume  71 of _ eptcs _ , pages 5875 ,",
    "september 2011 .",
    "brigitte pientka and joshua dunfield .",
    "programming with proofs and explicit contexts . in _ proceedings of the 10th international acm sigplan symposium on principles and practice of declarative programming ( ppdp 2008 ) _ , pages 163173 , 2008 .",
    "brigitte pientka . a type - theoretic foundation for programming with higher - order abstract syntax and first - class substitutions . in",
    "_ proceedings of the 35th acm sigplan - sigact symposium on principles of programming languages ( popl08 ) _ , pages 371382 .",
    "acm , 2008 .",
    "brigitte pientka and frank pfennning . optimizing higher - order pattern unification . in _ proceedings of the international conference on automated deduction ( cade03 )",
    "_ , volume 2741 of _ lecture notes in computer science _ , pages 473487 , 2003 .",
    "christian urban , andrew  m. pitts , and murdoch  j. gabbay .",
    "http://www.gabbay.org.uk/papers.html#nomu[nominal unification ] . in _",
    "volume 2803 of _ lecture notes in computer science _ , pages 513527 .",
    "springer , december 2003 ."
  ],
  "abstract_text": [
    "<S> the modal logic s4 can be used via a curry - howard style correspondence to obtain a @xmath0-calculus . </S>",
    "<S> modal ( boxed ) types are intuitively interpreted as ` closed syntax of the calculus ' . this @xmath0-calculus is called modal type theory  this is the basic case of a more general _ </S>",
    "<S> contextual _ modal type theory , or cmtt .    </S>",
    "<S> cmtt has never been given a denotational semantics in which modal types _ are _ given denotation as closed syntax . </S>",
    "<S> we show how this can indeed be done , with a twist . </S>",
    "<S> we also use the denotation to prove some properties of the system . </S>",
    "<S> + _ keywords : _ contextual modal type theory , modal logic , semantics , nominal terms , syntax .    _ msc - class : _ 03b70 ( logic in computer science ) ; 03b45 ( modal logic ) ; 68q55 ( semantics )    _ ams - class : _ </S>",
    "<S> f.4.1 ( modal logic ) ; f.3.2 ( semantics of programming languages ) </S>"
  ]
}