{
  "article_text": [
    "constraint handling rules ( chr )  @xcite is a high - level language especially designed for writing constraint solvers .",
    "chr is essentially a committed - choice language consisting of multi - headed rules that transform constraints into simpler ones until they are solved .",
    "chr  defines both _ simplification _ of and _ propagation _ over user - defined constraints .",
    "simplification replaces constraints by simpler constraints while preserving logical equivalence .",
    "propagation adds new constraints , which are logically redundant but may cause further simplifications . consider the constraint _ min _",
    ", where @xmath0 means that @xmath1 is the minimum of @xmath2 and @xmath3",
    ". then typical chr rules for this constraint are : @xmath4 the first two rules are simplification rules , while the third one is a propagation rule .",
    "the first two rules correspond to the usual definition of _ min_. the first rule states that @xmath5 can be replaced by @xmath6 .",
    "the second has an analogous reading , and the third rule states that if we have @xmath0 then we can add @xmath7 to the current constraints .",
    "if such rules are in general easy to read , in many cases it remains a hard task to find them when one wants to write a constraint solver .",
    "thus , several methods have been proposed to automatically generate rule - based solvers for constraints given their logical specification  @xcite .",
    "these approaches can help to find more easily interesting rules , and it has also been shown in  @xcite that the rules produced automatically can lead to more efficient constraint reasoning than rules found by programmers .    in this paper , we propose a new method to generate chr propagation and simplification rules .",
    "this work extends the previous rule - based solver generation techniques described in  @xcite .",
    "it allows to obtain more general forms of rules , even for constraints defined intensionally over infinite domains .",
    "the intuitive principle of the generation is the following .",
    "consider that a solver @xmath8 for some constraints , called _ primitive constraints _ , is already available .",
    "other constraint predicates , called _ user - defined constraints _ , are given and their semantics is specified by mean of a constraint logic program @xmath9 ( i.e. , the constraint predicates are defined by clauses of @xmath9 ) .",
    "then we want to obtain chr propagation and simplification rules for the user - defined constraints to extend the existing solver .",
    "the basic idea of our approach relies on the following observation : a rule of the form @xmath10 is valid if the execution of the goal @xmath11 finitely fails with program @xmath9 and solver @xmath8 . for the execution of such goals",
    ", we will use a tabled resolution for constraint logic programming  @xcite that terminates more often than execution based on sld - like resolutions .",
    "we present three algorithms that can be integrated to build an environment to help developers to write chr rule - based constraint solvers .",
    "two of the algorithms focus on how to generate propagation rules for constraints given their logical specification .",
    "the first algorithm generates only primitive propagation rules ( i.e. ,  rules with right hand side consisting of primitive constraints ) .",
    "the second algorithm extends the first one to generate more general propagation rules with right hand side consisting of both primitive and user - defined constraints .",
    "we also show that a slight modification of this algorithm allows to generate the so - called splitting rules ( rule having a disjunction in their right hand side ) supported by the extension of chr called chr@xmath12  @xcite .",
    "the third algorithm focuses on transforming propagation rules into simplification rules to improve the time and space behavior of constraint solving .",
    "[ [ organization - of - the - paper . ] ] organization of the paper .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + +    in section  [ sec : primprop ] , we present an algorithm to generate primitive propagation rules . in section",
    "[ sec : prop ] , we describe how to modify the algorithm to generate more general propagation rules . section  [ sec : simp ] presents a transformation method of propagation rules into simplification rules . for clarity reasons , we will use an abstract representation for the generated rules . in section  [ rule - simplification ] , we present how these rules can be encoded in chr .",
    "we discuss related work in section  [ section - related - work ] , and finally we conclude with a summary and possibilities of further improvements .",
    "we assume some familiarity with constraint logic programming ( clp )  @xcite .",
    "we consider two classes of constraints , _ primitive constraints _ and _ user - defined constraints_. primitive constraints are those constraints defined by a constraint theory @xmath13 and for which solvers are already available . in the following , we do not expect that the solver for primitive constraints is complete .",
    "user - defined constraints are those constraints defined by a constraint logic program @xmath9 and for which we want to generate solvers .",
    "we assume that the set of primitive constraints is closed under negation , in the sense that the negation of each primitive constraint must be also a primitive constraint , e.g.  @xmath14 and @xmath15 or @xmath16 and @xmath17 . in the following ,",
    "we denote the negation of a primitive constraint @xmath18 by @xmath19 .",
    "in the rest of this paper , we use the following terminology .    a _ constraint logic program _",
    "is a set of clauses of the form    @xmath20    where @xmath21 are user - defined constraints and @xmath22 are primitive constraints .",
    "@xmath23 is called left hand side of the clause .",
    "a _ goal _ is a set of primitive and user - defined constraints .",
    "an _ answer _ is a set of primitive constraints .",
    "the logical semantics of a constraint logic program @xmath9 is its clark s completion and is denoted by @xmath24 .",
    "a user - defined constraint is _ defined _ in a constraint logic program if it occurs in the left hand side of a clause .",
    "a _ primitive propagation rule _ is a rule of the form @xmath25 or of the form @xmath26 , where @xmath27 is a set of primitive and user - defined constraints , while @xmath28 consists only of primitive constraints .",
    "@xmath27 is called the _ left hand side _ of the rule ( _ lhs _ ) and @xmath28 its _ right hand side _ ( _ rhs _ ) . a rule of the form @xmath29 is called _",
    "failure rule_.    in the following we use the notation @xmath30 to denote the existential closure of @xmath31 and @xmath32 to denote the existential closure of @xmath31 except for the variables in the set @xmath33 .",
    "a primitive propagation rule @xmath34 is _ valid _ with respect to the constraint theory @xmath35 and the program @xmath9 if and only if @xmath36 , where @xmath33 is the set of variables appearing in @xmath37 . a failure rule @xmath38 is _ valid _ with respect to @xmath35 and @xmath9 if and only if @xmath39 .",
    "we now give an algorithm to generate valid primitive propagation rules .",
    "[ section - algo - primitive - miner ]    the prim - miner  algorithm takes as input the program @xmath9 defining the user - defined constraints . to specify the syntactic form of the rules ,",
    "the algorithm needs also as input two sets of primitive and user - defined constraints denoted by @xmath40 and @xmath41 , and a set containing only primitive constraints denoted by @xmath42 .",
    "the constraints occurring in @xmath40 are the common part that must appear in the lhs of all rules , @xmath41 indicates candidate constraints used in conjunction with @xmath40 to form the lhs , and @xmath42 are the candidate constraints that may appear in the rhs .",
    "note that a syntactic analysis of the constraint logic program @xmath9 can suggest functors and constraint predicates to be used to form candidate constraints .",
    "the algorithm prim - miner  is presented in figure  [ figure - algo - primitivepropagminer ] and generates a set of valid rules of the form @xmath43 where @xmath44 is a single primitive constraint .",
    "note that rules with the same lhs , e.g. @xmath45 , @xmath46 ,  , @xmath47 , can be replaced by the single rule @xmath48 .",
    "the basic idea of the algorithm relies on the following observation : to be able to generate a failure rule of the form @xmath49 , we can simply check that the execution of the goal @xmath50 finitely fails .",
    "furthermore , while these rules are useful to detect inconsistencies , it is in general more interesting to propagate earlier some information that can be used for constraint solving , instead of waiting until a conjunction of constraints becomes inconsistent .",
    "thus , for each possible lhs @xmath50 ( i.e. , each subset of @xmath51 ) the algorithm distinguishes two cases :    1 .   prim - miner  uses a clp system to evaluate the goal @xmath50 .",
    "if the goal finitely fails , then the failure rule @xmath49 is generated .",
    "2 .   otherwise",
    "the negation of each candidate constraint @xmath44 from @xmath42 is added in turn to @xmath50 and the goal @xmath52 ) is evaluated .",
    "if the goal finitely fails , then the rule @xmath53 is generated .",
    "[ figure - algo - primitivepropagminer ]    * begin * + xxxxxxxxxxxxxxxxxxxxxxxxxxxx= + @xmath54  the resulting rule set is initialized to the empty set .",
    "+ @xmath55  is a list of all subsets of @xmath41 , + in an order compatible with the subset partial ordering + ( i.e. , for all @xmath27 in @xmath55  if @xmath28 is after @xmath27 in @xmath55  then @xmath56 ) .",
    "+   + * while * @xmath55  is not empty * do * + remove from @xmath55  its first element denoted @xmath57 . + * if * the goal @xmath58 fails +   with respect to the constraint logic program @xmath9 * then * + add the failure rule @xmath59 to @xmath54 + and remove from @xmath55  all supersets of @xmath57 .",
    "+ * else * + let @xmath60 be initialized to the empty set . +",
    "* for all * @xmath61 + * if * the goal @xmath62 fails +   with respect to the constraint logic program @xmath9 * then * + add @xmath44 to the set @xmath60 . +",
    "* endif * + * endfor * + * if * @xmath60 is not empty * then * add the rule @xmath63 to @xmath54  * endif * + * endif * + * endwhile * +   + output @xmath54 .",
    "+   + * end *    in practice these goal evaluations are made using a bounded depth resolution procedure to avoid non - termination of the whole generation algorithm .",
    "the algorithm prim - miner  uses a basic ordering to prune the search space and to avoid the generation of many uninteresting rules .",
    "this pruning relies simply on the following observation . if @xmath64 is valid , then rules of the form @xmath65 , where @xmath66 are also valid but useless .",
    "so the algorithm considers first the smallest lhs with respect to set inclusion , and when it finds a valid failure rule @xmath26 it discards from the lhs candidates any @xmath28 that is superset of @xmath27 .    at first glance ,",
    "the procedure used to evaluate the goals issued by the algorithm may be considered as a classical depth - first , left - to - right clp resolution .",
    "however , we will show in section  [ section - interest - tabled ] and section  [ sec : prop ] that a tabled clp resolution extends greatly the class of rules that can be generated , by allowing termination of the evaluation in many interesting cases .",
    "additionally , it should be noticed that the execution on the underlying clp system is not required to enumerate all answers since prim - miner  only performs a fail / succeed test , and thus the clp system can stop after a first answer has been found .",
    "[ ex : min ] consider the following constraint logic program which implements the predicate _",
    "min_. @xmath0 means that @xmath1 is the minimum of @xmath2 and @xmath3 : @xmath67 where @xmath16 and @xmath14 are primitive constraints with the usual meaning as total order and syntactic equality .",
    "the algorithm with the appropriate input generates ( among others ) the rule @xmath68 after having checked that the execution of the goal @xmath69 fails by constructing the following derivation tree :    @xmath70 \\ar[dr ] \\\\",
    "x{\\leq}y , \\",
    "z{=}x , \\ y{\\leq}x , \\",
    "z{\\not=}y \\ar[d ] & &   y{\\leq}x , \\   \\",
    "z{=}y , \\ y{\\leq}x , \\ z{\\not=}y \\ar[d ] \\\\ { { \\it false } } & & { { \\it false}}}\\ ] ]    note that we assume that the constraint solver for @xmath16 and @xmath14 is able to detect such inconsistencies .",
    "[ [ soundness - and - completeness . ] ] soundness and completeness .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + +    the prim - miner   algorithm attempts to extract all valid primitive propagation rules of the form @xmath71 or @xmath72 such that @xmath73 , @xmath74 , @xmath75 , and there is no other more general failure rule ( i.e. , no valid rule @xmath76 where @xmath77 ) . in general , the algorithm can not be complete , since the evaluation of some goals corresponding to valid rules may be non - terminating .",
    "in fact , this completeness can be achieved if more restricted classes of constraint logic programs are used to give the semantics of user - defined constraints and if the solver for the primitive constraints used by the underlying clp system is satisfaction complete .    the soundness of the algorithm ( i.e.",
    ", only valid rules are generated ) is guaranteed by the nice properties of standard clp schemes  @xcite and tabled clp schemes  @xcite .",
    "an important practical aspect , is that even a partial resolution procedure ( e.g. , bounded depth evaluation ) or the use of an incomplete solver by the clp system , does not compromise the validity of the rules generated .",
    "[ section - interest - tabled ]    termination of the evaluation of ( constraint ) logic programs has received a lot of attention .",
    "a very powerful and elegant approach based on tabled resolution has been developed , first for logic programming ( e.g. ,  ) and further extended in the context of clp ( e.g. ,  @xcite ) .",
    "the intuitive basic principle of tabled resolution is the following .",
    "each new subgoal @xmath8 is compared to the previous intermediate subgoals ( not necessarily in the same branch of the resolution tree ) .",
    "if there is a previous subgoal @xmath78 which is equivalent to @xmath8 or more general than @xmath8 , then no more unfolding is performed on @xmath8 and answers for @xmath8 are selected among the answers of @xmath78 .",
    "this process is repeated for all subsequent computed answers that correspond to the subgoal @xmath78 .",
    "the use of such technique has not been widely accepted since if this leads to termination in many more cases than execution based on sld - resolution , this should be paid by some execution overhead in general . when using the algorithm prim - miner  we can accept a slight decrease of performance ( since the solver is constructed once ) if this gives rise to an improvement of the termination capability which enables the generation of additional rules .",
    "thus , tabled clp can find very interesting applications in constraint solver synthesis .",
    "this will be illustrated in the following example .",
    "consider the well - known ternary _",
    "predicate for lists , which holds if its third argument is a concatenation of the first and the second argument .",
    "@xmath79 , \\   y { = } z.\\\\ append(x , y , z ) & \\ \\leftarrow \\ & x { = } [ h|x1 ] , \\ z { = } [ h|z1 ] , \\",
    "append(x1,y , z1 ) .",
    "\\end{aligned}\\ ] ] let the input parameters of prim - miner  be @xmath80,y{=}[],z{=}[],x{=}y , x{=}z , y{=}z , x{\\not=}y , x{\\not=}z , y{\\not=}z\\}\\\\ { \\ensuremath{cand_{{rhs } } } } & = & { \\ensuremath{cand_{{lhs}}}}.\\end{aligned}\\ ] ] then the algorithm generates ( among others ) the following primitive propagation rule : @xmath81 & \\ \\rightarrow \\ & x{=}z\\end{aligned}\\ ] ] by executing the goal @xmath82 , \\ x{\\not=}z$ ] with a tabled clp resolution . for a classical clp scheme the resolution tree will be infinite ,",
    "while in case of a tabled resolution it can be sketched as follows : @xmath83 , x{\\not=}z \\ar[dl ] \\ar[dr ] \\\\",
    "x= [ ] , y{=}z , y{= } [ ] , x{\\not=}z   \\ar[d ] & &   x{=}[h|x1 ] , z{=}[h|z1 ] ,   append(x1,y , z1 ) , y{= } [ ] ,   x{\\not=}z \\ar[d ] \\\\ { { \\it false } } & & { { \\it false}}}\\ ] ]    the initial goal @xmath84 , \\",
    "x{\\not=}z)$ ] is more general than the subgoal @xmath85 , \\",
    "z{=}[h|z1 ] , \\",
    "append(x1,y , z1 ) , \\",
    "y{= } [ ] , \\ x{\\not=}z$ ] ) , in the sense that @xmath86 ,",
    "\\ f{=}[e|c ] , \\",
    "b{= } [ ] , \\",
    "d{\\not=}f$ ] entails @xmath87 @xmath88 , \\",
    "a{\\not=}c$ ] .",
    "so no unfolding is made on @xmath89 , and the process waits for answers of @xmath90 to compute answers of @xmath89 .",
    "since @xmath90 has no further possibility of having answers , then @xmath89 fails and thus @xmath90 also fails .",
    "we refer the reader to  @xcite for a more detailed presentation of goal evaluation using a tabled clp resolution .",
    "using this kind of resolution prim - miner  is also able to produce rules such as : @xmath91 .",
    "\\\\ append(x , y , z),\\ y{\\not= } [ ] \\ & \\rightarrow & \\ x{\\not=}z.\\\\ append(x , y , z),\\ x{\\not= } [ ] \\ & \\rightarrow & \\ z{\\not= } [ ] . \\end{aligned}\\ ] ]    we have run all examples presented in this paper , using our own implementation of tabled clp resolution according to the description of  @xcite . the running prototype is implemented in sicstus prolog 3.7.1 .",
    "[ [ interesting - rules . ] ] interesting rules .",
    "+ + + + + + + + + + + + + + + + + +    if we use the algorithm prim - miner  as presented in figure  [ figure - algo - primitivepropagminer ] , we obtain a set of rules that is highly redundant and thus not suitable neither for human - reading nor for its direct use as an executable constraint solver .",
    "this problem encountered in propagation rule generation has already been pointed out in  @xcite .",
    "it is taken into account by applying the following simplification technique on the set of rules produced by prim - miner :    * the rules generated by prim - miner  are ordered in a list @xmath92 using any total ordering on the rule lhs compatible with the @xmath93-subsumption ordering  @xcite ( i.e. , a rule having a more general lhs is placed before a rule with a more specialized lhs ) .",
    "* let @xmath8 be a set of rules initialized to the empty set .",
    "for each rule @xmath25 in @xmath92 ( taken according to the list ordering ) the constraint @xmath28 is simplified to an equivalent constraint @xmath94 by the already known solver for @xmath95  and by the rules in @xmath8 . if @xmath94 is empty then",
    "the rule can be discarded , else add the rule @xmath96 to @xmath8 .",
    "* output the set @xmath8 containing the simplified set of rules .",
    "for example , using this process the set of rules @xmath97 is simplified to @xmath98    for clarity reasons this simplification step is presented separately from the algorithm prim - miner , but it can be incorporated in prim - miner  and performed during the generation of the rules .",
    "so , if the algorithm prim - miner  is implemented on a flexible platform ( e.g. , sicstus prolog with chr support ) , when a valid rule is extracted it can be immediately simplified with respect to the already generated rules . then , if it is not redundant it can be incorporated at runtime and thus be used actively to speed up further resolution and constraint solving steps called by the generation algorithm itself .",
    "[ [ other - performance - issues . ] ] other performance issues .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + +    it is likely that the same constraints and their negations are candidates for both the lhs and rhs of the rules . in this case",
    "the two following optimizations can be used :    1 .",
    "if a rule @xmath53 is generated and @xmath99 then there is no need to generate the rule @xmath100 since this rule is trivially redundant . 2 .",
    "if a rule @xmath71 is generated and @xmath44 is also in @xmath41 then there is no need to consider any @xmath28 such that @xmath28 is a superset of @xmath27 containing @xmath44 to form the lhs of another rule .",
    "3 .   if a rule @xmath101 is produced using the evaluation of the goal @xmath102 ( which fails ) , and @xmath103 and @xmath104 then the same goal evaluation is also needed to produce the rule @xmath105 .",
    "thus , we can avoid for such constraints this kind of repeated goal evaluations .",
    "+ for example , the execution of the goal @xmath106 may lead to the generation of the following rules : @xmath107      splitting rules have been shown to be interesting in constraint solving  @xcite , since they can be used to detect early alternative labeling cases or alternative solution sets .",
    "these rules are handled by chr@xmath12 an extension of chr proposed in  @xcite .",
    "such rules that can be generated by the extension proposed in this section are for example : @xmath108    where @xmath109 means that @xmath1 is the boolean conjunction of @xmath2 and @xmath3 , defined by the facts @xmath110 , @xmath111 ; and where @xmath0 is defined by the constraint logic program of example  [ ex : min ] .    in the following ,",
    "we restrict ourself to the generation of _ primitive splitting rules_.    a _ primitive splitting rule _ is a rule of the form @xmath112 , where @xmath113 are primitive constraints and @xmath50 is a set of primitive and user - defined constraints .",
    "@xmath114 is interpreted like the standard disjunction , and primitive splitting rules have a straightforward associated semantics .",
    "the modification of the basic prim - miner  algorithm is as follows . for all @xmath57",
    ", it must also consider each different set @xmath115 with @xmath116 and check if the goal @xmath117 fails with respect to the constraint logic program @xmath9 .",
    "if this is the case , it simply adds to @xmath54  the primitive splitting rule @xmath118 .",
    "for example , the rule @xmath119 can be obtained by running the goal @xmath120 and checking that its execution finitely fails .    here",
    "again , the soundness of the generation relies on the properties of the underlying resolution used .    in practice ,",
    "a huge number of splitting rules are not interesting because they are redundant with respect to some primitive propagation rules .",
    "so , to remove these uninteresting rules , the generation should preferably be done , by first using prim - miner  to obtain only primitive propagation rules , and then using the modified version of the algorithm to extract primitive splitting rules . thus in this second step , redundant rules , with respect to the set resulting from the first step , can be discarded on - the - fly .",
    "for example the rule @xmath121 will be removed if we have already generated the rule @xmath122 .",
    "moreover , in such trivial redundancy cases , the test of the validity of the rule @xmath123 can itself be avoided , and more generally the test of any rule of the form @xmath124 and @xmath125 , where @xmath126 and @xmath127 .",
    "in this section , we modify the algorithm presented in section  [ sec : primprop ] to handle a broader class of rules called _ general propagation rules _ , that encompasses the primitive propagation rules , and that can even represent recursive rules over user - defined constraints ( i.e. , rules where the same user - defined constraint predicate appears in the lhs and rhs ) .    a _ general propagation rule _ is a failure rule or a rule of the form @xmath25 , where @xmath27 and @xmath28 are sets of primitive and user - defined constraints .",
    "the notion of validity defined for primitive propagation rules also applies to this kind of rules .    in the prim - miner  algorithm ,",
    "the validity test of a primitive propagation rule @xmath128 is performed by checking that the goal @xmath129 fails . for general propagation rules , @xmath44 is no longer a primitive constraint but may be defined by a constraint logic program . in this case , the evaluation should be done using a more general resolution procedure to handle negated subgoals . however , to avoid the well known problems related to the presence of negation we can simply use a different validity test based on the following theorem .",
    "let @xmath130 be a general propagation rule and @xmath33 be the variables occurring in @xmath27 .",
    "let @xmath131 be the set of answers @xmath132 to the goal @xmath27 , and @xmath133 be the set of answers @xmath134 to the goal @xmath135 .",
    "then the rule @xmath130 is valid if @xmath136 .",
    "this straightforward property comes from the completeness result of standard clp schemes  @xcite which ensures that if a goal @xmath137 has a finite computation tree , with answers @xmath138 then @xmath139 , where @xmath140 is the set of variables appearing in @xmath137 .",
    "so , the modification proposed in this section consists simply in the replacement in algorithm prim - miner  of the call to the goal @xmath141 to check the validity of the rule @xmath142 , by the following steps .    * first , collect the set of answers @xmath132 to the goal @xmath143 . *",
    "then , collect the set of answers @xmath134 to the goal @xmath144 . * in each answer @xmath145 ( resp .",
    "@xmath146 ) , rename with a fresh variable any variable that is not in @xmath143 ( resp .",
    "@xmath147 ) . *",
    "finally , perform a satisfiability test of @xmath148 . *",
    "if this test fails then the rule @xmath128 is valid .",
    "since answers only contain primitive constraints and since the set of primitive constraints is closed under negation , then we can perform the satisfiability test by rewriting @xmath149 into an equivalent disjunctive normal form , and then use the solver for primitive constraints on each sub - conjunctions .",
    "it should be noticed that in cases where the evaluation of one of the two goals does not terminate before the bound of resolution depth is reached then the propagation rule @xmath128 is not considered as valid and the next rule is processed .",
    "consider the following user - defined boolean constraints : @xmath150 imposing that @xmath3 is the boolean complement of @xmath2 and @xmath151 stating that @xmath1 is the result of the exclusive boolean disjunction of @xmath2 and @xmath3 .",
    "these two constraints are defined by a straightforward constraint logic program . among others ,",
    "the modified algorithm presented above can generate the following rules :    @xmath152    for example , to test the validity of the first rule , the process is the following .",
    "first , the answers @xmath153 and @xmath154 to the goal @xmath155 are computed .",
    "then for the goal @xmath156 the same answers are collected .",
    "finally the satisfiability test of @xmath157 fails and thus establishes the validity of the rule .",
    "one other general rule that can be generated using the modified algorithm presented is for example : @xmath158 furthermore , rules representing symmetries can be automatically detected using the modified algorithm .",
    "for example , the rules @xmath159 expressing the symmetry of the _ min _ and the _ xor _ constraints with respect to the first and second arguments can be generated . in  @xcite",
    ", it has been shown that these rules are very useful to reduce the size of a set of propagation rules since many rules become redundant when we know such symmetries .",
    "however , it must be pointed out that if the test presented in this section allows us to handle a syntactically wider class of rules , it relies on different goal calls than the test of section  [ section - algo - primitive - miner ] .",
    "so when testing the validity of a primitive propagation rule one of the techniques may lead to terminating evaluation while the other one may not .",
    "thus in the case of primitive propagation rule it is preferable not to replace one test by the other , but to use both in a complementary way ( run one of them , and if it reaches the bound of resolution depth then apply the other ) .",
    "since a propagation rule does not rewrite constraints but adds new ones , the constraint store may contain superfluous information .",
    "constraints can be removed from the constraint store using _ simplification rules_.    a _ simplification rule _ is a rule of the form @xmath160 , where @xmath27 and @xmath28 are sets of primitive and user - defined constraints .    in this section ,",
    "we show how the rule validity test used in section  [ sec : prop ] can be applied to transform some propagation rules into simplification rules . for a valid propagation rule of the form @xmath161",
    ", we try to find a proper subset @xmath162 of @xmath50 such that @xmath163 is valid too .",
    "if such @xmath162 can be found , the propagation rule @xmath161 can be transformed into a simplification rule of the form @xmath164 .    to simplify the presentation , we present an algorithm to transform ( when possible ) propagation rules into simplification rules independently from the algorithm presented in section  [ sec : prop ] . note that the algorithm for the generation of propagation rules can be slightly modified to incorporate this step and to directly generate simplification rules .",
    "the algorithm is given in figure  [ figure - algo - simpminer ] and takes as input the set of generated propagation rules and the common part that must appear in the lhs of all rules , i.e.  @xmath40 .",
    "* begin * + xxxxxxxxxxxxxxxxxxxxxxxx= + @xmath165 + * for * each propagation rule of the form @xmath10 in @xmath9 * do * + find a proper subset @xmath162 of @xmath50 such that @xmath166 and + @xmath163 is valid ( using the validity test of section  [ sec : prop ] ) + * if * @xmath162 exists * then * + @xmath167 + * endif * + * endfor * +   + output @xmath168 + * end *    to achieve a form of minimality based on the number of constraints , we generate simplification rules that will remove the greatest number of constraints .",
    "so , when we try to transform a propagation rule into a simplification rule of the form @xmath169 we choose the smallest set @xmath162 ( with respect to the number of atomic constraints in @xmath162 ) for which the condition holds . if such a @xmath162 is not unique , we choose any one among the smallest .",
    "the condition @xmath170 is needed to be able to transform the propagation rules into simplification rules that rewrite constraints to _ simpler _ ones ( primitive constraints if possible ) , as shown in the following example .",
    "consider the following propagation rule @xmath171 generated for the _ append _ constraint with @xmath172 : @xmath173 & \\ \\rightarrow \\ &   y{=}z.\\end{aligned}\\ ] ] the algorithm tries the following transformations :    1 .",
    "first , it checks if rule @xmath171 can be transformed into the simplification rule @xmath174 \\leftrightarrow y{=}z.$ ] this is done by testing whether the rule @xmath175 $ ] is valid .",
    "but , this is not the case and thus the transformation is not possible .",
    "2 .   next , the algorithm finds out that the rule @xmath176",
    "\\rightarrow append(x , y , z)$ ] is a valid rule and then the propagation rule @xmath171 is transformed into the simplification rule @xmath174 \\leftrightarrow x{= } [ ] , \\",
    "y{=}z.$ ]    note that the propagation rule @xmath177 $ ] is also valid but transforming rule @xmath171 into @xmath173   \\ & \\leftrightarrow & \\",
    "append(x , y , z ) , \\ y{=}z.\\end{aligned}\\ ] ] will lead to a simplification rule which is uninteresting for constraint solving , i.e.  using this rule the _ append _ constraint can not be simplified and remains in the constraint store .",
    "the algorithm disables such transformation by checking the condition that all constraints of @xmath40 are not shifted to the right hand side of the rule ( @xmath178 ) .",
    "the generated rules may contain constraints that are built - in constraints for the chr system . to have a running chr solver , these constraints have to be encoded in a specific way .",
    "first , equality constraints appearing in the left hand side of a rule are propagated all over the constraints in its left and right hand side . then the resulting constraints are simplified .",
    "this can be performed as follows . in turn",
    "each equality constraint appearing in the lhs is removed and transformed in a substitution that is applied to the lhs and the rhs . then the next equality constraint is processed .",
    "for example , the simplification rule @xmath179 will be transformed into @xmath180 .",
    "secondly , for other built - in constraints the transformation leads to chr  rules containing a guard  @xcite .",
    "for example , if @xmath16 is a built - in constraint of the chr system then the rule @xmath181 is transformed into the guarded chr  rule @xmath182 .",
    "[ section - related - work ]    in  @xcite , a method has been proposed to generate propagation rules from the intentional definition of the constraint predicates ( eventually over infinite domains ) given by mean of a constraint logic program .",
    "it extended previous work  @xcite where different methods dedicated to the generation of propagation rules for constraints defined extensionally over finite domains have been proposed .",
    "compared to the work described in  @xcite the approach presented in this paper has several advantages :    * it enables user - defined constraints to occur in the right hand side of rules , while this is not handled by  @xcite . as a by - product rules representing symmetries as @xmath183",
    "can then be automatically detected .",
    "* it allows the generation of splitting rules like @xmath184 & \\ \\rightarrow \\ &   x{=}[a ] \\   \\lor \\",
    "y{=}[a]\\end{aligned}\\ ] ] supported by the extension of chr called chr@xmath12  @xcite .",
    "these rules have been shown to be interesting in constraint solving  @xcite , but have not been considered in  @xcite . *",
    "even if we restrict our attention to the class of rules handled in  @xcite , the approach presented in this paper leads to a more expressive set of rules .",
    "for example , the rule @xmath81 & \\ \\rightarrow \\ &   x{=}z.\\end{aligned}\\ ] ] can not be generated by the approach proposed in  @xcite while the algorithm described in section  [ sec : primprop ] is able to obtain it by executing the goal @xmath185 , x{\\not=}z$ ] with a tabled resolution for clp .",
    "* additionally , it needs less information about the semantics of the primitive constraints .",
    "for example it generates the rule @xmath186 simply by calling the goals @xmath187 and @xmath188 , and checking that their executions fail . while in this case , the algorithm presented in  @xcite requires some extra information concerning the semantics of @xmath16 ( information that would be provided in general by the user ) .    in this paper",
    ", we also described a method to transform propagation rules into simplification rules .",
    "it has been shown in  @xcite that this transformation has a very important impact on the efficiency of the solver produced . in  @xcite the propagation rules are modified to obtain ( when possible ) simplification rules using a technique based on a confluence notion .",
    "this is a syntactical criterion that works when we have at hand the whole set of rules defining the constraint .",
    "thus it can not be applied safely if only a part of the propagation rules have been generated .",
    "it also requires a termination test for rule - based programs consisting of propagation and simplification rules , and this test is undecidable for some classes of programs .",
    "the new transformation method presented in this paper avoids these two restrictions .",
    "the generation of propagation and simplification rules is also related in some aspects to _ generalized constraint propagation _",
    "@xcite , _ constructive disjunction _",
    "@xcite , and _ inductive logic programming _  @xcite as briefly discussed in  @xcite .",
    "however , it should be pointed out that to our knowledge these works have not been used for the generation of constraint solvers .",
    "[ sec : conclusion ]      the approach described allows the generation of chr propagation and simplification rules . it can be applied on constraints defined over finite and infinite domains by mean of a constraint logic program .",
    "moreover , it enables the developer to search for rules having such user - defined constraints in both their left and right hand sides .",
    "we have also shown that compared to the algorithms described in  @xcite to generate rule - based constraint solvers , this approach is able to generate more expressive rules ( including recursive and splitting rules ) .    one interesting direction for future work is to investigate the integration of constructive negation ( e.g. ,  @xcite ) in tabled resolution for clp to generate constraint solvers , in order to check the validity of the propagation and simplification rules in more general cases .",
    "another complementary aspect is the completeness of the solvers generated .",
    "it is clear that in general this property can not be guaranteed , but in some cases it should be possible to check it , or at least to characterize the kind of consistency the solver can ensure .",
    "automatic generation of constraint propagation algorithms for small finite domains . in _",
    "5th international conference on principles and practice of constraint programming , cp99_. lncs 1713 .",
    "springer - verlag , 5872 ."
  ],
  "abstract_text": [
    "<S> in this paper , we present a framework for automatic generation of chr solvers given the logical specification of the constraints . </S>",
    "<S> this approach takes advantage of the power of tabled resolution for constraint logic programming , in order to check the validity of the rules . </S>",
    "<S> compared to previous work  @xcite , where different methods for automatic generation of constraint solvers have been proposed , our approach enables the generation of more expressive rules ( even recursive and splitting rules ) that can be used directly as chr solvers .    </S>",
    "<S> [ firstpage ]    rule - based constraint solver , automatic solver generation , tabled resolution , constraint logic programming </S>"
  ]
}