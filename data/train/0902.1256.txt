{
  "article_text": [
    "constraint satisfaction problems ( csp ) form a rich class of algorithmic problems with applications in many areas of computer science .",
    "we only mention database systems , where csps appear in the guise of the conjunctive query containment problem and the closely related problem of evaluating conjunctive queries .",
    "it has been observed by feder and vardi  @xcite that as abstract problems , csps are homomorphism problems for relational structures .",
    "algorithms for and the complexity of constraint satisfaction problems have been intensely studied ( e.g.  @xcite ) , not only for the standard decision problems but also optimization versions ( e.g.  @xcite ) and counting versions ( e.g. @xcite ) of csps .    in this paper",
    "we study the _ csp enumeration problem _ , that is , problem of computing all solutions for a given csp instance . more specifically , we are interested in the question which structural restrictions on csp instances guarantee tractable enumeration problems",
    ". `` structural restrictions '' are restrictions on the structure induced by the constraints on the variables .",
    "example of structural restrictions is `` every variable occurs in at most 5 constraints '' or `` the constraints form an acyclic hypergraph . ''",
    "this can most easily be made precise if we view csps as homomorphism problems : given two relational structures @xmath0 , decide if there is a homomorphism from @xmath1 to @xmath2 . here",
    "the elements of the structure @xmath1 correspond to the variables of the csp and the elements of the structure @xmath2 correspond to the possible values .",
    "structural restrictions are restrictions on the structure @xmath1 .",
    "if @xmath3 is a class of structures , then @xmath4 denotes the restriction of the general csp ( or homomorphism problem ) where the `` left hand side '' input structure @xmath1 is taken from the class @xmath5 .",
    "@xmath6 denotes the corresponding enumeration problem : given two relational structures @xmath7 and @xmath2 , compute the set of all homomorphisms from @xmath1 to @xmath2 .",
    "the enumeration problem is of particular interest in the database context , where we are usually not only interested in the question of whether the answer to a query is nonempty , but want to compute all tuples in the answer . we will also briefly discuss the corresponding _ search _ problem :",
    "find a solution if one exists , denoted @xmath8 .",
    "it has been shown in @xcite that @xmath6 can be solved in polynomial time if and only if the number of solutions ( that is , homomorphisms ) for all instances is polynomially bounded in terms of the input size and that this is the case if and only if the structures in the class @xmath3 have bounded fractional edge cover number .",
    "however , usually we can not expect the number of solutions to be polynomial . in this case , we may ask which conditions on @xmath3 guarantee that @xmath6 has a polynomial delay algorithm . a _ polynomial delay algorithm _ for an enumeration problem is required to produce the first solution in polynomial time and then iteratively compute all solutions ( each solution only once ) , leaving only polynomial time between two successive solutions .",
    "in particular , this guarantees that the algorithms computes all solutions in _ polynomial total time _ , that is , in time polynomial in the input size plus output size .",
    "it is easy to see that @xmath6 has a polynomial delay algorithm if the class @xmath3 has bounded tree width .",
    "it is also easy to see that there are classes @xmath3 of unbounded tree width such that @xmath6 has a polynomial delay algorithm .",
    "it follows from our results that examples of such classes are the class of all grids or the class of all complete graphs with a loop on every vertex .",
    "it is known that the decision problem @xmath9 is in polynomial time if and only if the cores of the structures in @xmath3 have bounded tree width @xcite ( provided the arity of the constraints is bounded , and under some reasonable complexity theoretic assumptions ) .",
    "a _ core _ of a relational structure @xmath3 is a minimal substructure @xmath10 such that there is a homomorphism from @xmath3 to @xmath11 ; minimality is with respect to inclusion .",
    "it is easy to see that all cores of a structure are isomorphic .",
    "hence we usually speak of `` the '' core of a structure .",
    "note that the core of a grid ( and of any other bipartite graph with at least one edge ) is a single edge , and the core of a complete graph with all loops present ( and of any other graph with a loop ) is a single vertex with a loop on it .",
    "the core of a complete graph with no loops is the graph itself .",
    "as a polynomial delay algorithm for an enumeration algorithms yields a polynomial time algorithm for the corresponding decision problem , it follows that @xmath6 can only have a polynomial delay algorithm if the cores of the structures in @xmath3 have bounded tree width .",
    "unfortunately , there are examples of classes @xmath3 that have cores of bounded tree width , but for which @xmath6 has no polynomial delay algorithm unless @xmath12 ( see example  [ exa : second - solution ] ) .",
    "our main algorithmic results show that @xmath6 has a polynomial delay algorithm if the cores of the structures in @xmath5 have bounded tree width and if , in addition , they can be reached in a sequence of `` small steps . ''",
    "an _ endomorphism _ of a structure is a homomorphism of a structure to itself .",
    "retraction _ is an endomorphism that is the identity mapping on its image .",
    "every structure has a retraction to its core .",
    "however , in general , the only way to map a structure to its core may be by collapsing the whole structure at once . as an example , consider a path with a loop on both endpoints .",
    "the core consists of a single vertex with a loop .",
    "( more precisely , the two cores are the two endpoints with their loops . ) the only endomorphism of this structure to a proper substructure maps the whole structure to its core .",
    "compare this with a path that only has a loop on one endpoint .",
    "again , the core is a single vertex with a loop , but now we can reach the core by a sequence of retractions , mapping a path of length @xmath13 to a subpath of length @xmath14 and then to a subpath of length @xmath15 et cetera . we prove that if @xmath3 is a class of structures whose cores have bounded tree width and can be reached by a sequence of retractions each of which only moves a bounded number of vertices , then @xmath6 has a polynomial delay algorithm .",
    "we also consider more general sequences of retractions or endomorphism from a structure to its core .",
    "we say that a sequence of endomorphisms from a structure @xmath16 to a substructure @xmath17 , from @xmath18 to a substructure @xmath19 ,  , to a structure @xmath20 has _ bounded width _ if @xmath20 and , for each @xmath21 , the `` difference between @xmath22 and @xmath23 '' has bounded tree width . we prove that if we are given a sequence of endomorphisms of bounded width together with the input structure @xmath1 , then we can compute all solutions by a polynomial delay algorithm .",
    "unfortunately , in general we can not compute such a sequence of endomorphisms efficiently .",
    "we prove that even for width @xmath24 it is np - complete to decide whether such a sequence exists .",
    "finally , we remark that our results are far from giving a complete classification of the classes @xmath3 for which @xmath25 has a polynomial delay algorithm and those classes for which it does not . indeed , we show that it will be difficult to obtain such a classification , because such a classification would imply a solution to the notoriously open _ csp dichotomy conjecture _ of feder and vardi  @xcite ( see section  [ sec : tract ] for details ) .    due to space restrictions several proofs are omitted .",
    "[ [ relational - structures . ] ] * relational structures . * + + + + + + + + + + + + + + + + + + + + + + + +    a _ vocabulary _",
    "@xmath26 is a finite set of _ relation symbols _ of specified arities .",
    "relational structure _ @xmath1 over @xmath26 consists of a finite set @xmath27 called the _ universe _ of @xmath1 and for each relation symbol @xmath28 , say , of arity @xmath29 , an @xmath29-ary relation @xmath30 . note that we require vocabularies and structures to be finite .",
    "a structure @xmath1 is a _ substructure _ of a structure @xmath2 if @xmath31 and @xmath32 for all @xmath33 .",
    "we write @xmath34 to denote that @xmath1 is a substructure of @xmath2 and @xmath35 to denote that @xmath1 is a _ proper _ substructure of @xmath2 , that is , @xmath36 and @xmath37 .",
    "a substructure @xmath38 is _ induced _ if for all @xmath28 , say , of arity @xmath29 , we have @xmath39 . for a subset @xmath31 , we write @xmath40 $ ] to denote the induced substructure of @xmath2 with universe @xmath27 .    [",
    "[ homomorphisms . ] ] * homomorphisms .",
    "* + + + + + + + + + + + + + + + +    we often abbreviate tuples @xmath41 by @xmath42 . if @xmath43 is a mapping whose domain contains @xmath44 we write @xmath45 to abbreviate @xmath46 .",
    "a _ homomorphism _ from a relational structure @xmath1 to a relational structure @xmath2 is a mapping @xmath47 such that for all @xmath28 and all tuples @xmath48 we have @xmath49 .",
    "a _ partial homomorphism _ on @xmath50 to @xmath2 is a homomorphism of @xmath51 $ ] to @xmath2 .",
    "it is sometimes useful when designing examples to exclude certain homomorphisms or endomorphisms . the simplest way to do",
    "that is to use unary relations .",
    "for example , if @xmath52 is a unary relation and @xmath53 we say that @xmath54 _ has color _ @xmath52 . now",
    "if @xmath55 does not have color @xmath52 then no homomorphism from @xmath1 to @xmath2 maps @xmath54 to @xmath56 .",
    "two structures @xmath1 and @xmath2 are _ homomorphically equivalent _ if there is a homomorphism from @xmath1 to @xmath2 and also a homomorphism from @xmath2 to @xmath1 . note that if structures @xmath1 and @xmath57 are homomorphically equivalent , then for every structure @xmath2 there is a homomorphism from @xmath1 to @xmath2 if and only if there is a homomorphism from @xmath57 to @xmath2 ; in other words : the instances @xmath58 and @xmath59 of the decision csp are equivalent . however , the two instances may have vastly different sizes , and the complexity of solving the search and enumeration problems for them can also be quite different .",
    "homomorphic equivalence is closely related to the concept of the core of a structure : a structure @xmath1 is a _ core _ if there is no homomorphism from @xmath1 to a proper substructure of @xmath1 .",
    "a core of a structure @xmath1 is a substructure @xmath60 such that there is a homomorphism from @xmath1 to @xmath57 and @xmath57 is a core . obviously , every core of a structure is homomorphically equivalent to the structure .",
    "we observe another basic fact about cores :    [ obs : cores ] let @xmath1 and @xmath2 be homomorphically equivalent structures , and let @xmath57 and @xmath61 be cores of @xmath1 and @xmath2 , respectively .",
    "then @xmath57 and @xmath61 are isomorphic . in particular , all cores of a structure @xmath1 are isomorphic",
    "therefore , we often speak of _ the _ core of @xmath1 .",
    "it is easy to see that it is np - hard to decide , given structures @xmath36 , whether @xmath1 is isomorphic to the core of @xmath2 .",
    "( for an arbitrary graph @xmath62 , let @xmath1 be a triangle and @xmath2 the disjoint union of @xmath62 with @xmath1 .",
    "then @xmath1 is a core of @xmath2 if and only if @xmath62 is 3-colorable . )",
    "hell and neetil @xcite proved that it is co - np - complete to decide whether a graph is a core .",
    "[ [ tree - decompositions . ] ] * tree decompositions .",
    "* + + + + + + + + + + + + + + + + + + + + + +    a _ tree decomposition _ of a graph @xmath62 is a pair @xmath63 , where @xmath64 is a tree and @xmath65 is a mapping that associates with every node @xmath66 a set @xmath67 such that ( 1 ) for every @xmath68 the set @xmath69 is connected in @xmath64 , and ( 2 ) for every @xmath70 there is a @xmath66 such that @xmath71 .",
    "the sets @xmath72 , for @xmath66 , are called the _ bags _ of the decomposition .",
    "it is sometimes convenient to have the tree @xmath64 in a tree decomposition rooted ; we always assume it is .",
    "the _ width _ of a tree decomposition @xmath63 is @xmath73 .",
    "the _ tree width _ of a graph @xmath62 , denoted by @xmath74 , is the minimum of the widths of all tree decompositions of @xmath62 .",
    "we need to transfer some of the notions of graph theory to arbitrary relational structures . the _ gaifman graph _ ( also known as _ primal graph _ ) of a relational structure @xmath1 with vocabulary @xmath26 is the graph @xmath75 with vertex set @xmath1 and an edge between @xmath54 and @xmath56 if @xmath76 and there is a relation symbol @xmath28 , say , of arity @xmath29 , and a tuple @xmath77 such that @xmath78 .",
    "we can now transfer graph - theoretic notions to relational structures .",
    "in particular , a subset @xmath79 is _ connected _ in a structure @xmath1 if it is connected in @xmath75 .",
    "tree decomposition _ of a structure @xmath1 can simply be defined to be a tree - decomposition of @xmath75 .",
    "equivalently , a tree decomposition of @xmath1 can be defined directly by replacing the second condition in the definition of tree decompositions of graphs by ( 2 ) for every @xmath28 and @xmath77 there is a @xmath80 such that @xmath81 .",
    "a class @xmath82 of structures has _ bounded tree width _ if there is a @xmath83 such that @xmath84 for all @xmath85 .",
    "a class @xmath82 of structures has _ bounded tree width modulo homomorphic equivalence _ if there is a @xmath86 such that every @xmath85 is homomorphically equivalent to a structure of tree width at most w.    [ obs : width - cores ] a structure @xmath1 is homomorphically equivalent to a structure of tree width at most @xmath87 if and only if the core of @xmath1 has tree width at most @xmath87 .",
    "[ [ the - constraint - satisfaction - problem . ] ] * the constraint satisfaction problem . * + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    for two classes @xmath88 and @xmath89 of structures , the _ constraint satisfaction problem _ , @xmath90 , is the following problem :    the csp is a decision problem .",
    "the variation of it we study in this paper is the following enumeration problem :    we shall also refer to the search problem , @xmath91 , in which the goal is to find one solution to a csp - instance or output ` no ' if a solution does not exists .",
    "if one of the classes @xmath88 , @xmath89 is the class of all finite structures , then we denote the corresponding csps by @xmath92 , @xmath93 ( respectively , @xmath94 , @xmath95 , @xmath96 , @xmath97 ) .    the decision csp has been intensely studied . if a class @xmath82 of structures has bounded arity then @xmath98 is solvable in polynomial time if and only if @xmath82 has bounded tree width modulo homomorphic equivalence @xcite .",
    "if the arity of @xmath82 is not bounded , several quite general conditions on a class of structures have been identified that guarantee polynomial time solvability of @xmath98 , see , e.g.@xcite .",
    "problems of the form @xmath99 have been studied mostly in the case when @xmath82 is 1-element .",
    "problems of this type are sometimes referred to as _ non - uniform_. it is conjectured that every non - uniform problem is either solvable in polynomial time or np - complete ( the so - called _ dichotomy conjecture _ ) @xcite .",
    "although this conjecture is proved in several particular cases @xcite , in its general form it is believed to be very difficult .",
    "a search csp is clearly no easier than the corresponding decision problem . while any non - uniform search problem @xmath100 is polynomial time reducible to its decision version @xmath99 @xcite , nothing",
    "is known about the complexity of search problems @xmath101 except the result we state in section  [ sec : tract ] .",
    "paper @xcite provides some initial results on the complexity of non - uniform enumerating problems .",
    "since even an easy csp may have exponentially many solutions , the model of choice for ` easy ' enumeration problems is algorithms with polynomial delay @xcite .",
    "an algorithm alg is said to solve a csp _ with polynomial delay _",
    "( _ wpd _ for short ) if there is a polynomial @xmath102 such that , for every instance of size @xmath13 , alg outputs ` no ' in a time bounded by @xmath102 if there is no solution , otherwise it generates all solutions to the instance such that no solution is output twice , the first solution is output after at most @xmath102 steps after the computation starts , and time between outputting two consequent solutions does not exceed @xmath102 .",
    "if a class of relational structures @xmath82 has bounded arity , the aforementioned result of grohe @xcite imposes strong restrictions on enumeration problems solvable wpd .",
    "[ obs : bw - core ] if a class of relational structures @xmath82 with bounded arity does not have bounded tree width modulo homomorphic equivalence , then @xmath103 is not wpd , unless p@xmath104np .    unlike for the decision version ,",
    "the converse is not true : bounded tree width modulo homomorphic equivalence does not imply enumerability wpd .",
    "[ exa : second - solution ] let @xmath105 be the disjoint union of a @xmath106-clique and a loop and let @xmath107 . clearly , the core of each graph in @xmath88 has bounded tree width ( in fact , it is a single element ) , hence @xmath92 is polynomial - time solvable . for an arbitrary graph @xmath2 without loops , let @xmath61 be the disjoint union of @xmath2 and a loop .",
    "it is clear that there is always a trivial homomorphism from @xmath105 ( for any @xmath108 ) to @xmath61 that maps everything into the loop .",
    "there exist homomorphisms different from the trivial one if and only if @xmath2 contains a @xmath106-clique . thus if we are able to check in polynomial time whether there is a second homomorphism , then we are able to test if @xmath2 has a @xmath106-clique",
    ". therefore , although @xmath92 and @xmath96 are polynomial - time solvable , a wpd enumeration algorithm for @xmath94 would imply @xmath109 .",
    "it is not difficult to show that @xmath103 is enumerable wpd if @xmath82 has bounded tree width . for space restrictions",
    "we do not include a direct proof and instead we derive it from a more general result in section  [ sec : sequence ] .",
    "thus enumerability wpd has a different tractability criterion than the decision version , and this criterion lies somewhere between bounded tree width and bounded tree width modulo homomorphic equivalence . thus in order to ensure that the solutions can be enumerated wpd , we have to make further restrictions on the way the structure can be mapped to its bounded tree width core .",
    "the main new definition of the paper requires that the core is reached by `` small steps '' :    let @xmath1 be a relational structure with universe @xmath27 .",
    "we say that @xmath1 _ has a sequence of endomorphisms of width @xmath106 _ if there are subsets @xmath110 and homomorphisms @xmath111 such that    1 .",
    "@xmath112 is a homomorphism from @xmath113 $ ] to @xmath114 $ ] , 2 .",
    "@xmath115 for @xmath116 ; 3 .",
    "if @xmath62 is the primal graph of @xmath1 , then the tree width of @xmath117 $ ] is at most @xmath106 for every @xmath118 ; 4 .",
    "the structure induced by @xmath119 has tree width at most @xmath106 .    in section  [ sec : sequence ] , we show that enumeration for @xmath120 can be done wpd if a sequence of bounded width endomorphisms for @xmath1 is given in the input . unfortunately , we can not claim that @xmath94 can be done wpd if every structure in @xmath88 has such a sequence , since we do not know how to find such sequences efficiently .",
    "in fact , as we show in section  [ sec : hardness ] , it is hard to check if a width-1 sequence exists for a given structure . furthermore , we show a class @xmath88 where every structure has a width-2 sequence , but @xmath94 can not be done wpd , unless @xmath109 .",
    "this means that it is not possible to get around the problem of not being able to find the sequences ( for example , by finding sequences with somewhat larger width or by constructing the sequence during the enumeration ) .    thus having a bounded width sequence of endomorphisms is not the right tractability criterion .",
    "we then investigate a more restrictive notion , where the bound is not on the tree width of the difference of the layers but on the number of elements in the differences .",
    "however , in the rest of the section , we give evidence that enumeration problems solvable wpd can not be characterized in simple terms relying on tree width .",
    "for instance , a description of search problems solvable in polynomial time would imply a description of non - uniform decision problems solvable in polynomial time .",
    "this is shown via an analogous result for the search version of the problem , which might be of independent interest . by @xmath121",
    "we denote the disjoint union of relational structures @xmath1 and  @xmath2 .",
    "[ lem : enum - vs - non - uniform ] let @xmath2 be a relational structure , which is a core , and let @xmath122 be @xmath123 . then @xmath124 is solvable in polynomial time if and only if so is the problem @xmath125 .",
    "if the decision problem @xmath124 is solvable in polynomial time we can construct an algorithm that given an instance @xmath126 of @xmath127 computes a solution in polynomial time .",
    "indeed , as @xmath124 is solvable in polynomial time by the aforementioned result of @xcite it is also polynomial time to find a homomorphism from a given structure to @xmath2 provided one exists .",
    "if @xmath128 such a homomorphism @xmath129 exists by the definition of @xmath122 .",
    "so our algorithms , first , finds some homomorphism @xmath129 .",
    "then it decides by brute force whether or not there exists a homomorphism @xmath130 from @xmath2 to @xmath131 ( note that this can be done in polynomial time for every fixed @xmath2 ) .",
    "if such a homomorphism does not exist then we can certainly guarantee that there is no homomorphism from @xmath1 to @xmath131 .",
    "otherwise we obtain a required homomorphism @xmath132 as follows : let @xmath133 for @xmath134 , and @xmath135 for @xmath136 .",
    "conversely , assume that we have an algorithm alg that finds a solution of any instance of @xmath127 in polynomial time , say , @xmath102 .",
    "we construct from it an algorithm that solves @xmath124 .",
    "given an instance @xmath120 of @xmath124 we call algorithm alg with input @xmath121 and @xmath2 .",
    "additionally we count the number of steps performed by alg in such a way that we stop if alg has not finished in @xmath102 steps .",
    "if alg produces a correct answer then we have to be able to obtain from it a homomorphism from @xmath1 to @xmath2 . if alg s answer is not correct or the clock reaches @xmath102 steps we know that alg failed .",
    "the only possible reason for that is that @xmath121 does not belong to @xmath122 , which implies that @xmath1 is not homomorphic to @xmath2 .    in what follows",
    "we transfer this result to enumeration problems .",
    "let @xmath88 be a class of relational structures .",
    "the class @xmath137 consists of all structures built as follows : take @xmath138 and add to it @xmath139 independent vertices .",
    "[ lem : search - enumeration ] let @xmath88 be a class of relational structures . then @xmath96 is solvable in polynomial time if and only if @xmath140 is solvable wpd .",
    "if @xmath94 is enumerable wpd , then for any structure @xmath141 it takes time polynomial in @xmath142 to find the first solution . since @xmath57 is only twice of the size of the corresponding structure @xmath1 , it takes only polynomial time to solve @xmath96 .",
    "conversely , given a structure @xmath143 , where @xmath138 and @xmath144 is the set of independent elements , and any structure @xmath2 .",
    "the first homomorphism from @xmath57 to @xmath2 can be found in polynomial time , since @xmath96 is polynomial time solvable and the independent vertices can be mapped arbitrarily . let the restriction of this homomorphism onto @xmath1 be @xmath129 . then while enumerating all possible @xmath145 extensions of @xmath129 we buy enough time to enumerate all homomorphisms from @xmath1 to @xmath2 using brute force .",
    "in this section we show that for every fixed @xmath106 , all the homomorphisms from @xmath1 to @xmath2 can be enumerated with polynomial delay if a sequence of width @xmath106 endomorphisms of @xmath1 is given in the input . given a sequence @xmath146 and @xmath147 , @xmath148 , @xmath149 as in the definition of a sequence of width  @xmath106 endomorphisms ,",
    "we denote @xmath114 $ ] by @xmath22 .",
    "we will enumerate the homomorphisms from @xmath1 to @xmath2 by first enumerating the homomorphisms from @xmath20 , @xmath150 , @xmath148 to @xmath2 and then transforming them to homomorphisms from @xmath1 to @xmath2 using the homomorphisms @xmath112 .",
    "we obtain the homomorphisms from @xmath22 by extending the homomorphism from @xmath151 to the set @xmath152 ; lemma  [ lem : chain - extention ] below will be useful for this purpose . in order to avoid producing a homomorphism multiple times , we need a delicate classification ( see definitions of elementary homomorphisms and of the index of a homomorphism ) .    [",
    "lem : chain - extention ] let @xmath0 be relational structures and @xmath153 subsets , and let @xmath154 be a homomorphism from @xmath155 $ ] to @xmath65 .",
    "for every fixed @xmath106 , there is a polynomial - time algorithm homomorphism - ext@xmath156 that decides whether @xmath154 can be extended to a homomorphism from @xmath157 $ ] to @xmath2 , if the tree width of induced subgraph @xmath158 $ ] of the gaifman graph of @xmath1 is at most @xmath106 .",
    "the _ index _ of a homomorphism @xmath129 from @xmath1 to @xmath2 is the largest @xmath159 such that @xmath129 can be written as @xmath160 for some homomorphism @xmath132 from @xmath161 to @xmath2 . in particular ,",
    "if @xmath129 can not be written as @xmath162 , then the index of @xmath129 is 0 .",
    "observe that if the index of @xmath129 is at least @xmath159 , then there is a unique @xmath132 such that @xmath163 : this follows from the fact that @xmath164 is a surjective mapping from @xmath27 to @xmath165 , thus if @xmath166 and @xmath167 differ on @xmath165 , then @xmath168 and @xmath169 differ on @xmath27 .",
    "a homomorphism @xmath132 from @xmath161 to @xmath2 is _ elementary _ , if it can not be written as @xmath170 .",
    "a homomorphism is _ reducible _ if it is not elementary .",
    "[ lem : elementary - index ] if a homomorphism @xmath132 from @xmath161 to @xmath2 is elementary , then @xmath160 has index exactly @xmath159 .",
    "conversely , if homomorphism @xmath129 from @xmath1 to @xmath2 has index @xmath159 and can be written as @xmath163 , then the homomorphism @xmath132 from @xmath161 to @xmath2 is elementary .",
    "lemma  [ lem : elementary - index ] suggests a way of enumerating all the homomorphisms from @xmath1 to @xmath2 : for @xmath171 , we enumerate all the elementary homomorphisms from @xmath161 to @xmath2 , and for each such homomorphism @xmath132 , we compute @xmath172 . to this end , we need the following characterization of elementary homomorphisms :    [ lem : hom - elementary ] a homomorphism @xmath132 from @xmath161 to @xmath2 is reducible if and only if    1 .",
    "@xmath173 for every @xmath174 with @xmath175 , i.e. , for every @xmath176 , @xmath177 has the same value @xmath178 for every @xmath179 with @xmath180 , and 2 .",
    "the mapping defined by @xmath181 is a homomorphism from @xmath182 to @xmath2 .",
    "lemma  [ lem : hom - elementary ] gives a way of testing in polynomial time whether a given homomorphism @xmath132 is elementary : we have to test whether one of the two conditions are violated .",
    "we state this in a more general form : we can test in polynomial time whether a partial mapping @xmath154 can be extended to an elementary homomorphism @xmath132 , if the structure induced by the elements where @xmath154 is not defined has bounded tree width .",
    "we fix values every possible way in which the conditions of lemma  [ lem : hom - elementary ] can be violated and use homomorphism - ext to check whether there is an extension compatible with this choice . in order to efficiently enumerate all the possible violations of the second condition , the following definition is needed :    given a relation @xmath183 of arity @xmath29 , a",
    "_ bad prefix _ is a tuple @xmath184 with @xmath185 such that    1 .",
    "there is no tuple @xmath186 for any @xmath187 , and 2 .",
    "there is a tuple @xmath188 for some @xmath189 .",
    "if @xmath190 , then there is a unique @xmath191 such that the tuple @xmath192 is a bad prefix : there has to be an @xmath193 such that @xmath194 can not be extended to a tuple of @xmath183 , but @xmath195 can .",
    "[ lem : few - bad - prefixes ] the relation @xmath183 has at most @xmath196 bad prefixes , where @xmath29 is the arity of the relation .",
    "[ lem : elementary - ext ] let @xmath197 be a subset of @xmath165 and let @xmath154 be a mapping from @xmath197 to @xmath65 .",
    "for every fixed @xmath106 , there is a polynomial - time algorithm elementary - ext@xmath198 that decides whether @xmath154 can be extended to an elementary homomorphism from @xmath161 to @xmath65 , if the tree width of the structure induced by @xmath199 is at most @xmath106 .",
    "we enumerate the elementary homomorphisms in a specific order defined by the following precedence relation .",
    "let @xmath129 be an elementary homomorphism from @xmath22 to @xmath2 and let @xmath132 be an elementary homomorphism from @xmath200 to @xmath2 for some @xmath201 .",
    "homomorphism @xmath132 is the _ parent _ of @xmath129 ( @xmath129 is a _ child _ of @xmath132 ) if @xmath129 restricted to @xmath202 can be written as @xmath203 . _",
    "ancestor _ and _ descendant _ relations are defined as the reflexive transitive closure of the parent and child relations , respectively .",
    "note that an elementary homomorphism from @xmath22 to @xmath2 has exactly one parent for @xmath204 and a homomorphism from @xmath20 to @xmath2 has no parent .",
    "fix an arbitrary ordering of the elements of @xmath27 . for",
    "@xmath205 and @xmath206 , let @xmath207 be the union of @xmath202 and the first @xmath208 elements of @xmath152 .",
    "note that @xmath209 and @xmath210 .",
    "[ lem : elementary - enum ] let @xmath132 be a mapping from @xmath207 to @xmath2 that can be extended to an elementary homomorphism from @xmath22 to @xmath2 .",
    "assume that a sequence of width @xmath106 endomorphisms is given for @xmath1 .",
    "for every fixed @xmath106 , there is a polynomial - delay , polynomial - space algorithm elementary - enum@xmath211 that enumerates all the elementary homomorphisms of @xmath22 that extends @xmath132 and all the descendants of these homomorphisms .    by calling elementary - enum@xmath212 ( where @xmath154 is a trivial mapping from @xmath213 to @xmath2 )",
    ", we can enumerate all the elementary homomorphisms . by the observation in lemma  [ lem : elementary - index ] , this means that we can enumerate all the homomorphisms from @xmath1 to @xmath2 .",
    "[ the : width - k - chain ] for every fixed @xmath106 , there is a polynomial - delay , polynomial - space algorithm that , given structures @xmath1 , @xmath2 , and a sequence of width @xmath106 endomorphisms of @xmath1 , enumerates all the homomorphisms from @xmath1 to  @xmath2 .",
    "theorem  [ the : width - k - chain ] does not provide a complete description of classes of structures solvable wpd .",
    "[ cor : unbounded - width ] there is a class @xmath88 of relational structures such that not all structures from @xmath88 have a sequence of width @xmath106 endomorphisms and @xmath94 is solvable wpd .    let @xmath88 be the class of structures that are the disjoint union of a loop and a core .",
    "obviously , @xmath96 is polynomial time solvable .",
    "therefore , by lemma  [ lem : search - enumeration ] , @xmath140 is solvable with polynomial delay .",
    "however , it is not hard to see that @xmath137 does not have a sequence of endomorphisms of bounded tree width .",
    "furthermore , as we will see in the next section it is hard , in general , to find a sequence of bounded width endomorphims . still , we can find a sequence of endomorphisms for a structure @xmath1 if we impose two more restrictions on such a sequence .",
    "a retraction @xmath129 of a structure @xmath1 is called a _ @xmath106-retraction",
    "_ if at most @xmath106 nodes change their value according to @xmath129 .",
    "a structure is a _",
    "@xmath106-core _ if the only @xmath106-retraction is the identity .",
    "a @xmath106-core of a structure is any @xmath106-core obtained by a sequence of @xmath106-retractions .",
    "[ lem : k - cores - isomorphic ] all @xmath106-cores of a structure @xmath1 are isomorphic .",
    "lemma  [ lem : k - cores - isomorphic ] amounts to say that when searching for a sequence of @xmath106-retractions converging to a @xmath106-core we can use the greedy approach and include , as the next member of such a sequence , any @xmath106-retraction with required properties . with this in hands we now can apply theorem  [ the : width - k - chain ] .",
    "the : finite - retractions ] let @xmath214 be a positive integer and let @xmath82 be a class of structures such that the @xmath106-core of every structure in @xmath82 has tree width at most @xmath106 .",
    "then , the enumeration problem @xmath103 is solvable wpd .",
    "if @xmath82 is a class of structures of bounded tree width then @xmath103 is solvable wpd .",
    "the first result of this section shows that finding a sequence of endomorphisms of bounded width can be difficult even in simplest cases .    [ the : hardness ]",
    "it is np - complete to decide if a structure has a sequence of 1-width retractions to the core .",
    "the second result shows that @xmath94 can be hard even if every structure in @xmath88 has a sequence of width-2 endomorphisms .",
    "note that this result is incomparable with theorem  [ the : hardness ] , since an enumeration algorithm ( in theory ) does not necessarily have to compute an sequence of endomorphisms .",
    "we need the following lemma :    [ lem : outerplanar ] if @xmath62 is a planar graph , then it is possible to find a partition @xmath215 of its vertices in polynomial time such that @xmath216 $ ] and @xmath217 $ ] have tree width at most @xmath218 .",
    "[ pro : fpt - not - poly ] there is a class @xmath88 of relational structures such that every structure from @xmath88 has a sequence of width 2 endomorphisms to the core , and such that the problem @xmath94 is not solvable wpd , unless @xmath219 .",
    "let @xmath88 be a class of graphs built in the following way .",
    "take a 3-colorable planar graph @xmath62 and its partition @xmath215 according to lemma  [ lem : outerplanar ] . using colorings",
    "we can ensure that @xmath62 is a core .",
    "then we take a disjoint union of this graph with a triangle @xmath64 having all the colors and a copy @xmath220 of @xmath216 $ ] .",
    "let @xmath1 denote the resulting structure .",
    "@xmath1 has a sequence of width-2 endomorphisms .",
    "+ let @xmath132 be a 3-coloring of @xmath62 that is a homomorphism into the triangle , and @xmath166 the bijective mapping from @xmath220 to @xmath216 $ ] .",
    "then @xmath147 is defined to act as @xmath132 on @xmath62 , as @xmath166 on @xmath221 and identically on @xmath64 .",
    "endomorphism @xmath222 is just the 3-coloring of @xmath223 induced by @xmath132 .",
    "the images of @xmath147 and @xmath222 are @xmath224 $ ] and @xmath64 , respectively , so all the conditions on a sequence of width-2 homomorphisms are easily checkable .    claim 2 .",
    "the planar graph 3-coloring problem is turing reducible to @xmath94 . + given a planar graph @xmath62",
    "we find its partition @xmath215 and create a structure @xmath1 , as described above .",
    "then we apply an algorithm that enumerates solutions to @xmath94 we may assume that such an algorithm stops with some time bound regardless whether @xmath62 is 3-colorable or not . if the algorithm succeeds we can now produce a 3-coloring of @xmath62 .",
    "when making a query to a database one usually needs to obtain values of only those variables ( attributes ) ( s)he is interested in . in terms of homomorphisms",
    "this can be translated as follows : for relational structures @xmath1 , @xmath2 , and a subset @xmath225 , we aim to list those mappings from @xmath226 to @xmath65 which can be extended to a full homomorphism from @xmath1 to @xmath2 . in other words , we would like to enumerate all the mappings from @xmath226 to @xmath65 that arise as the restriction of some homomorphism from @xmath1 to @xmath2 .",
    "clearly , this problem significantly differs from the regular enumeration problem .",
    "a mapping from @xmath226 to @xmath65 can be extendible to a homomorphism in many ways , possibly superpolynomially many , and an enumeration algorithm would list all of them . in the worst case scenario it would list them before turning to the next partial mapping .",
    "if this happens it may destroy polynomiality of the delay between outputting consecutive solutions .",
    "we present two results , first one of them shows that the problem @xmath227 is wpd when @xmath88 is a class of structures of bounded tree width , the second one claims that , modulo some complexity assumptions , in contrast to enumeration problems this can not be generalized to structures with @xmath106-cores of bounded tree width for @xmath228 .            _ step 1 _  * set * @xmath231 , @xmath232 , @xmath233 , @xmath234 $ ] , complete@xmath235*false * + _ step 2 _ not complete * do * + _ step 2.1 _  * if * @xmath236 * then do * + _ step 2.1.1 _  * search * @xmath237 until a @xmath238 is found such that there exists a homomorphism extending + @xmath239 and * remove * all members of @xmath237 preceding @xmath56 inclusive + _ step 2.1.2 _ such a @xmath56 exists * then set * @xmath240 , @xmath241 + _ step 2.1.3 _ + _ step 2.1.3.1_  * if * @xmath242 * then set * @xmath243 and @xmath244 , @xmath245 + _ step 2.1.3.2_ complete:=*true * + _ step 2.2 _ + _ step 2.2.1 _ @xmath129 + _ step 2.2.2 _ @xmath246 , @xmath247 +    [ exa : multi - col - clique ] recall that the multicolored clique problem ( cf .",
    "@xcite ) is formulated as follows : given a number @xmath106 and a vertex @xmath106-colored graph , decide if the graph contains a @xmath106-clique all vertices of which are colored different colors .",
    "this problem is @xmath248$]-complete , i.e. , has no time @xmath249 algorithm for any function @xmath43 and constant @xmath250 , unless fpt@xmath251 $ ] .",
    "we reduce this problem to @xmath227 where @xmath88 is the class of structures whose 2-cores are 2-element described below .",
    "let us consider relational structures with two binary and two unary relations .",
    "this structure can be thought of as a graph whose vertices and edges have one of the two colors , say , red and blue , accordingly to which of the two binary / unary relations they belong to .",
    "let @xmath105 be the relational structure with universe @xmath252 , where @xmath44 are red while @xmath253 are blue .",
    "then @xmath254 induces a red clique , that is every @xmath255 ( @xmath256 are not necessarily different ) are connected with a red edge , and each @xmath257 is connected to @xmath258 with a blue edge .",
    "it is not hard to see that every pair of a red and blue vertices induces a 2-core of this structure .",
    "set @xmath259 .",
    "the reduction of the multicolored clique problem to @xmath227 goes as follows .",
    "given a @xmath106-colored graph @xmath260 whose coloring induces a partition of @xmath261 into classes @xmath262 .",
    "then we define structures @xmath0 and a set @xmath225 .",
    "we set @xmath263 , @xmath264 .",
    "then let @xmath265 , the elements of @xmath261 are colored red and the induced substructure @xmath266 $ ] is the graph @xmath62 ( without coloring ) whose edges are colored also red .",
    "finally , @xmath267 are made blue and each @xmath268 is connected with a blue edge with every vertex from @xmath269 .",
    "it is not hard to see that any homomorphism maps @xmath254 to @xmath261 and @xmath226 to @xmath270 , and that the number of homomorphisms that do not agree on @xmath226 does not exceed @xmath271 .",
    "moreover , @xmath62 contains a @xmath106-colored clique if and only if there is a homomorphism from @xmath1 to @xmath2 that maps @xmath226 onto @xmath270 .",
    "if there existed an algorithm solving @xmath227 wpd , say , time needed to compute the first and every consequent solution is bounded by a polynomial @xmath102 , then time needed to list all solutions is at most @xmath272 .",
    "this means that multicolored clique is fpt , a contradiction ."
  ],
  "abstract_text": [
    "<S> the homomorphism problem for relational structures is an abstract way of formulating constraint satisfaction problems ( csp ) and various problems in database theory . </S>",
    "<S> the decision version of the homomorphism problem received a lot of attention in literature ; in particular , the way the graph - theoretical structure of the variables and constraints influences the complexity of the problem is intensively studied . </S>",
    "<S> here we study the problem of enumerating all the solutions with polynomial delay from a similar point of view . </S>",
    "<S> it turns out that the enumeration problem behaves very differently from the decision version . </S>",
    "<S> we give evidence that it is unlikely that a characterization result similar to the decision version can be obtained . </S>",
    "<S> nevertheless , we show nontrivial cases where enumeration can be done with polynomial delay .    </S>",
    "<S> =    =    = = = = = =        andrei a.  bulatov    vctor  dalmau    martin grohe    dniel marx </S>"
  ]
}