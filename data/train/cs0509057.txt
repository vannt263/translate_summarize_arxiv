{
  "article_text": [
    "embeddings of programming languages into one another are useful in studying their relative power and , sometimes , finding languages that are _ universal _ in some sense .",
    "examples include turing - reducibility for studying computability , poly - time reductions for subrecursive languages @xcite , and ` structure - preserving ' embeddings for expressiveness @xcite .",
    "to further a search for languages suited to realizing domain - specific embedded languages ( dsels ) @xcite and `` active libraries , '' @xcite we propose stage - preserving embeddings as a tool to study languages in which some evaluation or simplification is guaranteed to take place at compile - time .",
    "such guarantees can be wielded to realize domain - specific optimizations and safety checks .",
    "the principal result shown here is that if a language has what we call a ` turing - complete kernel , ' it is universal in the sense that any language may be embedded into it while preserving staging and safety properties .      throughout this paper",
    "we shall rely on some basic notions from computability theory .",
    "we say a set of natural numbers @xmath0 is _ decidable _ or equivalently @xmath1 when there exists a turing machine that given as input any @xmath2 can decide whether @xmath3 .",
    "a set @xmath0 is _ computably enumerable _ or @xmath4 when there exists a turing machine that given input @xmath2 will halt exactly when @xmath3 .",
    "( we follow the recommendation of soare @xcite that the traditional term _",
    "recursively enumerable _ be retired in favour of the more descriptive term _",
    "computably enumerable_. ) these notions extend easily to sets of strings and terms by employing an appropriate coding of objects by natural numbers .",
    "for example , strings over a finite alphabet @xmath5 can be encoded by treating a string @xmath6 as a base-@xmath7 natural number ; we may then speak of a set of strings over @xmath5 as computably enumerable or decidable . a function implemented by a computer",
    "is appropriately modelled by a partial function , since the computation may fail to terminate for some values of the domain .",
    "a partial function @xmath8 is computably enumerable or @xmath4 when it is computable by a turing machine ; in this case we say @xmath9 is a partial computable function .",
    "the formalization of programming languages and compilers is susceptible to fussiness , and to keep this at bay i propose to be precise where it matters and vague where it does not .",
    "let us adopt a grossly simplified view , typical of computability , in which a programming language is merely a set of programs represented by binary strings .",
    "one way to achieve this perspective is to view the program text ( a sequence of characters ) as a single , large binary string .",
    "we shall suppose the programming languages of interest are all being compiled to one implementation language @xmath10  the subscript @xmath11 suggesting a _ machine _ language .",
    "to speak of translations being semantics - preserving , we require that @xmath10 comes paired with an equivalence @xmath12 on machine language programs capturing some desired notion of program equivalence  the precise meaning of @xmath12 does not matter for our purposes . for two programs @xmath13 , we write @xmath14 to mean they _ do the same thing_. we define programming languages in terms of their compilation to @xmath10 .",
    "a programming language is a pair @xmath15 with @xmath16 a decidable set of binary strings representing valid programs , and @xmath17 a compilation map required to be computably enumerable .",
    "some languages have compilers that do not necessarily terminate  c++ and metaml are examples @xcite .",
    "for this reason compilers are appropriately modelled by computably enumerable partial functions , rather than total functions . to keep the notational convenience of total functions we employ the usual device of introducing a special element @xmath18 to indicate a nonterminating compilation , and require that @xmath19 is in a singleton equivalence class under @xmath12 , i.e. , @xmath20 if and only if @xmath21 .    [ defn : semantics - preserving ] a language embedding @xmath22 is an injective and computable function that is semantics - preserving , i.e. , @xmath23 for all @xmath24 .    the typical scenario we shall consider is illustrated by this diagram :    @xmath25_{\\phi_a } \\ar[rr]^{e } & & l_u \\ar[ddl]^{\\phi_u } \\\\   \\\\      & l_m \\\\ } \\ ] ]    we have two source languages @xmath16 and @xmath26 , compilers @xmath27 and @xmath28 for them , and we consider an embedding @xmath29 .",
    "we ask when embeddings that preserve properties of interest ( semantics , staging , safety ) exist .",
    "the scenario of special interest is when @xmath26 is some language purporting to be ` universal . '",
    "we use the notion of _ stages _ to address compile - time computations ( cf .",
    "we are interested in embeddings that are stage - preserving : if a computation occurs at compile time in language @xmath16 , then it occurs at compile time in language @xmath26 .",
    "this can be conveniently addressed using the _ kernel _ of the compiler . recall that the kernel of a map @xmath30 is : @xmath31    @xmath32^\\phi \\\\ x + { \\widetilde{~~}}{(1 + 1 ) } \\ar[rr]^\\phi         &   & \\text{iadd}~x~2\\\\ x + { \\widetilde{~~}}{(1+(2 - 1 ) ) } \\ar[rru]^\\phi \\\\ y + 2   \\ar[rr]^\\phi                         & & \\text{iadd}~y~2 \\\\ y + { \\widetilde{~~}}{(4 - 2 ) } \\ar[rru]^\\phi } \\end{aligned}\\ ] ]    the kernel of a compiler is a simple but versatile notion .",
    "the kernel is an equivalence relation ; every program in a kernel - equivalence class compiles to the same target program .",
    "kernels capture staging  from the kernel one can deduce what compile - time reductions take place .",
    "for instance , a language whose compile - time evaluations are defined by a rewrite relation @xmath33 must satisfy @xmath34 , where @xmath30 is its compiler ( figure  [ f : kernel ] shows an example of some metaml - like terms ) .",
    "a useful analogy may be drawn to linear algebra , where the kernel of a linear transformation yields its _ nullspace_. when a vector is transformed , every component lying in the nullspace is zeroed .",
    "analogously , any code _ lying in the kernel _ of the compiler ` disappears ' at compile - time .",
    "thus we can view the kernel as a _ staging specification _ and use it to formalize the notion of a stage - preserving embedding .",
    "[ s : stage - preserving ]    [ defn : stage - preserving ] an embedding @xmath35 is stage - preserving when it satisfies @xmath36 .",
    "illustration of stage - preserving embedding .",
    "if two programs in @xmath16 compile to the same program in @xmath10 , then after embedding in @xmath26 they must still compile to the same program .",
    "note , though , that it is not required that @xmath37 , i.e. , we do not expect to get the same target program going either route , though this would be agreeable should it happen . ]",
    "[ s : kernel - staging - power ] figure  [ f : stagepres ] illustrates .",
    "the kernel of a compiler gives us a measure of its staging power , that is , its ability to reduce computations at compile time .",
    "[ defn : stage - preserving ] effectively says : to increase the staging power of a language , make its kernel larger .",
    "but at what point is a kernel `` big enough '' that we can embed any language into it and preserve staging ? to answer this ,",
    "let us order languages , writing @xmath38 to mean there exists a stage - preserving embedding @xmath22 .",
    "the relation @xmath39 is a preorder , i.e. , reflexive and transitive , but not necessarily anti - symmetric .",
    "given languages @xmath40 we might have the following diagram of @xmath39 , with arrows indicating the existence of stage - preserving embeddings : @xmath41 \\\\",
    "l_b \\ar@/^1pc/[rr ] \\ar[ur ] & & l_c \\ar@/^1pc/[ll ] \\ar[ul ] \\\\    &",
    "l_a \\ar[ul ] \\ar[ur ] } \\end{aligned}\\ ] ] the obvious question is whether there might exist languages maximal in the order @xmath39 ; we call such languages _ stage - universal_.    a programming language is stage - universal when there is a stage - preserving embedding of any other programming language into it .",
    "the term stage - complete would do equally well .",
    "now let us show that such languages exist and have a useful characterization .",
    "we shall construct such a language and refer to it as @xmath26 , the subscript here indicating _",
    "universal_. the universal language @xmath26 is required to provide some standard features of programming languages :    1 .",
    "we assume there is an effective coding @xmath42 of the languages @xmath43 in @xmath26 ; this means we can represent a program in @xmath16 by some term or computation in the language @xmath26 , and thereby examine and manipulate it .",
    "if @xmath24 is a program then @xmath44 may be thought of as a representation of @xmath45 by its parse tree , as a string of characters , or ( more traditionally ) a very large natural number ; the particulars do not matter so long as the encoding is unique and computable .",
    "2 .   we shall want to manipulate representations of programs in @xmath26 , so we assume @xmath26 permits the construction of functions over codes ( e.g. , functions that manipulate parse trees ) , and write @xmath46 to mean the application of such a function @xmath47 to a code @xmath48 .",
    "it is useful to distinguish between functions implemented in @xmath26 , e.g. , purely functional manipulations of coded programs , and _ programs _ such as interpreters that take such codes and produce behaviour . for a program @xmath49 taking as argument some code @xmath50 , we write @xmath51 $ ] .",
    "we assume @xmath26 has function composition : * if there are @xmath26-functions @xmath47 and @xmath52 , then there is an @xmath26-function @xmath53 . *",
    "if there is a program @xmath54 $ ] and an @xmath26-function @xmath55 , then the construction @xmath56 $ ] is meaningful : there is some program @xmath57 $ ] such that @xmath58 \\sim p[x]$ ] when @xmath59 .",
    "much of what follows relies on the ability to interpret @xmath10 programs in @xmath26 .",
    "interpreter _ for the machine language @xmath10 in the language @xmath26 is a program @xmath60 $ ] such that for every machine - language program @xmath61 , the interpreted version of @xmath62 is equivalent to @xmath62 : @xmath63 ) \\sim p_m\\ ] ]    that is , if we take some machine - language program @xmath62 and ` code ' it as ( for example ) a syntax tree @xmath64 and give it to the interpreter @xmath65 , then @xmath65 running @xmath64 behaves the same way as the program @xmath62 .",
    "the existence of such an interpreter ensures that the language @xmath26 does not lose basic capabilities of the language @xmath10 , such as the ability to interact with the operating system and so forth .",
    "this is of concern when dealing with interactive systems ( a.k.a . processes , reactive systems , etc . ) rather than purely functional programs .",
    "the existence of such an interpreter guarantees that @xmath28 is _ onto _ the equivalence classes @xmath66 giving the possible behaviours of @xmath10 programs .",
    "that is , for every machine - language program @xmath61 , there is a program @xmath67 such that @xmath68 is indistinguishable in behaviour from @xmath62 , i.e. , @xmath69 .",
    "what we need next is some vocabulary to discuss compile - time computations in the language @xmath26 .",
    "we work from the assumption stated earlier that @xmath26 has a mechanism for defining functions .",
    "a partial function @xmath9 is ` _ _ realizable in the kernel _ _ ' of @xmath28",
    "if there exists an @xmath26 function @xmath47 such that for any program @xmath49 taking as argument a code , and for any @xmath70 such that @xmath71 : @xmath72 ) = \\phi_u(p[{\\ulcorner y \\urcorner}])\\ ] ] or , equivalently , @xmath73,p[{\\ulcorner y \\urcorner } ] ) \\in { \\mathrm{ker}(\\phi_u)}$ ] .",
    "this means , more or less , that the partial function @xmath47 is evaluated at compile time .",
    "we now give a sufficient condition for stage - universality , inspired by ideas from partial evaluation , in particular jones - optimality @xcite and the futamura projections @xcite .",
    "the proof is boilerplate computability theory and partial evaluation .",
    "we rely heavily on the assumption ( stated earlier ) that compilers are @xmath4 functions .",
    "[ thm : complete - kernel ] if    1 .",
    "there is an interpreter @xmath60 $ ] for @xmath10 in @xmath26 ; and 2 .",
    "any @xmath4 function @xmath9 is realizable in the kernel of @xmath28 ,    then the language @xmath26 is stage - universal .    pick a language and compiler @xmath16 and @xmath27 . since @xmath27 is @xmath4 , by ( ii )",
    "there is a @xmath26-function @xmath74 realizing it such that if @xmath75 then @xmath76 ) = \\phi_u(p[{\\ulcorner p_m \\urcorner}])$ ] for any program @xmath49 taking a code - argument .",
    "consider the embedding @xmath29 given by : @xmath77\\ ] ]    where @xmath60 $ ] is the @xmath78 interpreter whose existence is ensured by ( i ) .",
    "recall from defn .",
    "[ defn : stage - preserving ] that @xmath79 is stage preserving when @xmath80 .",
    "choose @xmath81 such that @xmath82 .",
    "then there is a @xmath62 such that @xmath83 , and from the choice of @xmath74 , @xmath84 ) & = & \\phi_u(i_m[{\\ulcorner p_m \\urcorner } ] ) & \\mbox{and } \\\\",
    "\\phi_u(i_m[\\phi_a({\\ulcorner p_2 \\urcorner } ) ] ) & = & \\phi_u(i_m[{\\ulcorner p_m \\urcorner } ] )   \\end{array}\\ ] ] therefore @xmath85 , or @xmath86 , and the embedding @xmath79 is stage - preserving .",
    "since such an embedding exists for any language @xmath16 , the language @xmath26 is stage - universal .",
    "we shall be sloppy henceforth and refer to a `` turing - complete kernel '' to mean the properties listed in theorem  [ thm : complete - kernel ] .",
    "the construction in the proof above is not of immediate practical use ; there is no guarantee that an interpreted program @xmath87)$ ] will run anywhere near as fast as @xmath88 ( cf .",
    "jones - optimality @xcite ) .",
    "it does , however , give sufficient conditions for languages to be stage - universal :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ a language with a turing - complete kernel can , in principle , subsume any staged language .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    this suggests we look to such languages to realize dsels and ` active libraries . '",
    "the construction above would be useful if @xmath28 found programs that were ` optimal . '",
    "that is , if the compiler @xmath28 were to find fastest , smallest , etc .",
    "programs , then the construction @xmath87)$ ] _ would _ be practical .",
    "finding optimal programs is undecidable , so this goal is not reachable .",
    "however , if we find programs that are near to optimal , then approaches nearing the construction of theorem  [ thm : complete - kernel ] might be practical . in @xcite one possible method for realizing such compilers is described , using `` guaranteed optimization , '' a new compiler design technique .",
    "let us now turn to the question of when there exist language embeddings that preserve judgments about safety properties .",
    "since useful safety properties are often undecidable , compilers approximate the set of safe programs in a conservative way . for example",
    ", many compilers incorporate a static typing phase that determines whether programs are well - typed in some formalism ; programs that fail typing are rejected since they might be unsafe . when embedding one language into another , it is important that the set of programs judged to be safe is preserved .",
    "in particular we must avoid the possibility that a language embedding might allow us to run programs that fail safety checks in the source language .    in the real world",
    ", compilers react to programs they judge unsafe by producing no output program and issuing a variety of diagnostic messages . for ease of modelling ,",
    "let us suppose compilers have one designated output @xmath89 signifying a program that fails safety checks .",
    "the intent is that a compiler @xmath30 judges a program @xmath45 to be unsafe exactly when @xmath90 .",
    "there is then an obvious sense in which an embedding can be safety - preserving .",
    "[ defn : safety - preserving ] a _ safety_-preserving embedding @xmath35 is a semantics - preserving embedding that preserves the set of programs judged unsafe , i.e. , @xmath91 if and only if @xmath92 .",
    "we require that no programs in @xmath10 are equivalent to @xmath93 _ except _ @xmath93 itself , i.e. , @xmath93 has a singleton equivalence class under @xmath12 .",
    "this means , incidentally , that semantics - preserving ( defn .",
    "[ defn : semantics - preserving ] ) implies safety - preserving .",
    "following a similar line of reasoning as before , we ask whether there are languages that are safety - universal , in the sense that any language may be embedded into it while preserving safety .",
    "there are two approaches we explore here .",
    "the first is to note an obvious , but somewhat unenlightening , corollary of theorem  [ thm : complete - kernel ] :    any language meeting the criteria of theorem  [ thm : complete - kernel ] is safety - universal .",
    "this follows because stage - preserving embeddings are semantics - preserving , and from the way we defined the special compiler output @xmath94 , any stage - preserving transformation is safety - preserving ( defn .",
    "[ defn : safety - preserving ] )",
    ". therefore any stage - universal language is also safety - universal .    for a more informative construction ,",
    "let us consider compilers that employ a preliminary safety checking phase .",
    "we presume this safety checking phase implements a proof calculus @xmath95 making judgments of the form @xmath96 , indicating the program @xmath45 is safe . this is a general framework that subsumes , for example , type systems ; we can augment a typical type inference system with an additional rule of the form : @xmath97 this states that if a program @xmath45 can be given a type @xmath98 , then it is safe .",
    "we limit ourselves to _ effective _ proof calculi , i.e. , those whose deductions are computably enumerable , and in particular to relations @xmath99 that are decidable .",
    "we will write @xmath100 to mean `` @xmath99 is not a valid deduction of @xmath95 . ''",
    "[ thm : safety - universal ] let @xmath101 be a language and its compiler , and @xmath95 be an proof calculus with judgments of the form @xmath96 for some @xmath24 , such that the set @xmath102 is decidable .",
    "let @xmath103 be a language and compiler meeting the criteria of theorem  [ thm : complete - kernel ] .",
    "then there is a stage - preserving embedding @xmath29 such that @xmath104 if and only if @xmath100 .",
    "consider the function @xmath105 given by : @xmath106 since the set @xmath102 is decidable , i.e. @xmath1 , and @xmath27 is @xmath4 , the function @xmath107 is @xmath4 .",
    "by the conditions of theorem  [ thm : complete - kernel ] , there exists a u - function @xmath108 realizing @xmath107 in the kernel of @xmath28 .",
    "consider the embedding @xmath109\\end{aligned}\\ ] ] following the reasoning given in the proof of theorem  [ thm : complete - kernel ] , @xmath110 if and only if @xmath100 , and @xmath79 is a stage - preserving embedding .",
    "a key requirement , implicit in the above proof , is that the function @xmath111 must be able to produce @xmath112 , i.e. , the code of an unsafe program .",
    "the intuition we can draw from this is the following :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ any language with a turing - complete kernel _ and _ the ability to construct at compile - time a condition signifying `` unsafe program '' is safety - universal .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _",
    "variations on extensible and universal programming languages have been explored for decades .",
    "we have examined a new twist on this theme , looking not just to languages that are _ turing - complete _ ( can perform any effective procedure ) or syntactically extensible ( can provide a domain - specific syntax ) , but to languages that are universal with respect to _ staging _ and _ safety_. such languages appear ideal for expressing domain - specific safety checks and optimizations , suggesting a route to realizing libraries and dsels that are not only expressive , but also fast and safe ."
  ],
  "abstract_text": [
    "<S> we study embeddings of programming languages into one another that preserve what reductions take place at compile - time , i.e. , staging . a certain condition </S>",
    "<S>  what we call a ` turing complete kernel '  is sufficient for a language to be _ stage - universal _ in the sense that any language may be embedded in it while preserving staging . </S>",
    "<S> a similar line of reasoning yields the notion of safety - preserving embeddings , and a useful characterization of _ safety - universality_. languages universal with respect to staging and safety are good candidates for realizing domain - specific embedded languages ( dsels ) and ` active libraries ' that provide domain - specific optimizations and safety checks . </S>"
  ]
}