{
  "article_text": [
    "in 1996 , lov grover @xcite presented an algorithm for searching an unstructured list of @xmath1 items for a single match with quadratic speed - up over classical algorithms .",
    "grover s original algorithm exploits quantum parallelism by preparing a _ uniform _ superposition that represents all the items in the list then iterates both an oracle that marks the desired item by applying a phase shift of -1 on that item ( @xmath4 , with @xmath5 ) and nothing on the other items ( @xmath6 , with @xmath7 ) and an operator that performs inversion about the mean ( diffusion operator ) to amplify the amplitude of the match , the processes of this operator includes the operation @xmath8 which applies a phase shift of -1 on the states within the superposition ( @xmath9 , with @xmath10 ) except the state @xmath11 where it applies nothing ( @xmath12 , with @xmath13 ) @xcite . to maintain consistency with literatures ,",
    "this operation can also be written as @xmath14 which applies a phase shift if -1 on the state @xmath11 ( @xmath12 , with @xmath15 ) and nothing on the other states of the superposition ( @xmath9 , with @xmath16 ) _ together with _ a global phase shift of -1 @xcite .",
    "it was shown that the required number of iterations is approximately @xmath17 which is proved to be optimal to get the highest probability with the minimum number of iterations @xcite , such that there is only one match in the search space .    in @xcite ,",
    "grover s algorithm is generalised by showing that the uniform superposition can be replaced by almost any arbitrary superposition and the phase shifts applied by the oracle and the diffusion operator ( @xmath18 and @xmath12 ) can be generalised to deal with the arbitrary superposition and/or to increase the probability of success even with a factor increase in the number of iterations to still run in @xmath0 .",
    "these give a larger class of algorithms for amplitude amplification using variable operators from which grover s algorithm was shown to be a special case .    in another direction",
    ", work has been done trying to generalise grover s algorithm with a uniform superposition for the case where there are known number of multiple matches in the search space @xcite , where it was shown that the required number of iterations is approximately @xmath19 for small @xmath20 .",
    "the required number of iterations will increase for @xmath21 , i.e. the problem will be harder where it might be excepted to be easier @xcite .",
    "another work has been done for known number of multiple matches with arbitrary superposition and phase shifts @xcite where the same problem for multiple matches occurs . in @xcite ,",
    "a hybrid algorithm was presented to deal with this problem by applying grover s fixed operators algorithm for @xmath19 times then apply one more step using different oracle and diffusion operator by replacing the standard phase shifts @xmath22 with accurately calculated phase shifts @xmath23 and @xmath24 according to the knowledge of the number of matches @xmath2 to get the solution with probability close to certainty . using this algorithm will increase the hardware cost since we have to build one more oracle and one more diffusion operator for each particular @xmath2 . for the sake of practicality ,",
    "the operators should be fixed for any given @xmath2 and are able to handle the problem with high probability whether or not @xmath2 is known in advance .    in the case of multiple matches , where the number of matches is unknown ,",
    "an algorithm for estimating the number of matches ( known as _ quantum counting algorithm _ ) was presented @xcite . in @xcite ,",
    "another algorithm was presented to find a match even if the number of matches is unknown which will be able to work if @xmath2 lies within the range @xmath25 .    in this paper",
    ", we will propose a fixed operator quantum search algorithm that is able to handle the whole range @xmath3 more reliably whether or not the number of matches in known in advance .",
    "the plan of the paper is as follows : section 2 introduces the general definition of the unstructured search problem .",
    "section 3 defines the partial diffusion operator @xcite .",
    "section 4 introduces the algorithm and an analysis on its behaviour .",
    "section 5 shows a comparison with grover s algorithm .",
    "section 6 introduces the algorithm shown in @xcite for unknown number of matches by replacing grover s algorithm with the algorithm proposed here .",
    "the paper will end up with a general conclusion in section 7 .",
    "consider an unstructured list @xmath26 of @xmath1 items . for simplicity and",
    "without loss of generality we will assume that @xmath27 for some positive integer @xmath28 .",
    "suppose the items in the list are labelled with the integers @xmath29 , and consider a function ( oracle ) @xmath30 which maps an item @xmath31 to either 0 or 1 according to some properties this item should satisfy , i.e. @xmath32 . the problem is to find any @xmath31 such that @xmath33 assuming that such @xmath34 exists in the list . in conventional computers , solving this problem needs @xmath35 calls to the oracle ( query ) , where @xmath2 is the number of items that satisfy the oracle .",
    "in this section , we will define the _ partial diffusion operator _ @xmath36 which performs the inversion about the mean only on a _",
    "subspace _ of the system .",
    "the diagonal representation of the partial diffusion operator @xmath36 when applied on @xmath37 qubits system can take this form :    @xmath38    where the vector @xmath39 used in eqn .",
    "[ enheq13 ] is of length @xmath40 , @xmath41 is the identity matrix of size @xmath42 and @xmath43 is the hadamard gate @xmath44\\right)$ ] .    to understand the effect of this operator , consider a general state @xmath45 of @xmath37 qubits register :    @xmath46    for our purposes and without loss of generality , the general system @xmath45 can be re - written as ,",
    "@xmath47    where \\{@xmath48 : @xmath49 even } and \\{@xmath50 : @xmath49 odd}. the effect of applying @xmath36 on @xmath51 produces ,    @xmath52    where @xmath53 is the mean of the amplitudes of the subspace entangled with the state @xmath54 of the extra qubit workspace , i.e. @xmath55 .",
    "that is , applying the operator @xmath36 will perform the inversion about the mean only on the subspace @xmath55 and will only _ change the sign _ of the amplitudes for the rest of the system @xmath56 . a circuit implementation for @xmath36 using elementary gates @xcite",
    "is shown in fig .",
    "[ figy ] .",
    "[ t ]    # 1#2#3#4#5 @font    ( 3525,1974)(3226,-2173 ) ( 5101,-361 ) ( 5101,-811 ) ( 5101,-1561 ) ( 3976,-511)(300,300 ) ( 4276,-361 ) ( 1 , 0)225 ( 4501,-511)(300,300 ) ( 3976,-961)(300,300 ) ( 4276,-811 ) ( 1 , 0)225 ( 4501,-961)(300,300 ) ( 3976,-1711)(300,300 ) ( 4276,-1561 ) ( 1 , 0)225 ( 4501,-1711)(300,300 ) ( 4801,-361 ) ( 1 , 0)600 ( 4801,-811 ) ( 1 , 0)600 ( 4801,-1561 ) ( 1 , 0)600 ( 4951,-2161)(300,300 ) ( 5101,-361 ) ( 0,-1)600 ( 5101,-1411 ) ( 0,-1)450 ( 5401,-511)(300,300 ) ( 5401,-961)(300,300 ) ( 5401,-1711)(300,300 ) ( 5401,-2161)(300,300 ) ( 5926,-511)(300,300 ) ( 5926,-961)(300,300 ) ( 5926,-1711)(300,300 ) ( 5701,-1561 ) ( 1 , 0)225 ( 6226,-1561 ) ( 1 , 0 ) 75 ( 5701,-811 ) ( 1 , 0)225 ( 5701,-361 ) ( 1 , 0)225 ( 6226,-811 ) ( 1 , 0 ) 75 ( 6226,-361 ) ( 1 , 0 ) 75 ( 3901,-361 ) ( 1 , 0 ) 75 ( 3901,-811 ) ( 1 , 0 ) 75 ( 3901,-1561 ) ( 1 , 0 ) 75 ( 4951,-2011)(-1 , 0)1050 ( 5251,-2011 ) ( 1 , 0)150 ( 5701,-2011 ) ( 1 , 0)600 ( 3826,-286 ) ( 0,-1)1350 ( 3826,-1636 ) ( 1 , 0 ) 75 ( 3826,-286 ) ( 1 , 0 ) 75 ( 4105,-1236)@xmath57 ( 4630,-1236)@xmath57 ( 5080,-1236)@xmath57(5530,-1236)@xmath57(6055,-1236)@xmath57    ( 4051,-436)@xmath43(4051,-886)@xmath43(4051,-1636)@xmath43(4576,-436)@xmath58(4576,-886)@xmath58(4576,-1636)@xmath58(5476,-436)@xmath58(5476,-886)@xmath58(5476,-1636)@xmath58(5026,-2086)@xmath59(5476,-2086)@xmath60(6001,-436)@xmath43(6001,-886)@xmath43(6001,-1636)@xmath43(6576,-511)@xmath61$](6576,-1636)@xmath62$](3376,-736)@xmath28(3226,-961)qubits",
    "in this section we will propose the algorithm assuming that the number of matches is known in advance . for a list of size @xmath63 , prepare a quantum register of size @xmath37 qubits all in state @xmath39 and apply the steps of the algorithm as follows ( its quantum circuit is as shown in fig .",
    "[ enhfig6 ] ) :    * apply hadamard gate on each of the first @xmath28 qubits .",
    "* iterate the following steps @xmath64 times : * * apply the oracle @xmath65 . * * apply the partial diffusion operator @xmath36 .",
    "* measure the first @xmath28 qubits .",
    "[ t ]    # 1#2#3#4#5 @font    ( 4050,2091)(76,-1690 ) ( 1501,-286)(300,300 ) ( 1501,-886)(300,300 ) ( 1951,-1261)(750,1650 ) ( 2851,-1261)(750,1650 ) ( 3976,-886 ) ( 0 , 1)1200 ( 3976,-886)(-1 , 0 ) 75 ( 3901,314 ) ( 1 , 0 ) 75 ( 1876,-1336 ) ( 0,-1 ) 75 ( 1876,-1411 ) ( 1 , 0)1875 ( 3751,-1411 ) ( 0 , 1 ) 75 ( 826,-886 ) ( 0 , 1)1200 ( 901,-886)(-1 , 0 ) 75 ( 826,314 ) ( 1 , 0 ) 75 ( 1201,239 ) ( 1 , 0)300 ( 1801,239 ) ( 1 , 0)150 ( 2701,239 ) ( 1 , 0)150 ( 3601,239 ) ( 1 , 0)225 ( 1201,-136 ) ( 1 , 0)300 ( 1801,-136 ) ( 1 , 0)150 ( 2701,-136 ) ( 1 , 0)150 ( 3601,-136 ) ( 1 , 0)225 ( 1201,-736 ) ( 1 , 0)300 ( 1801,-736 ) ( 1 , 0)150 ( 2701,-736 ) ( 1 , 0)150 ( 3601,-736 ) ( 1 , 0)225 ( 1201,-1111 ) ( 1 , 0)750 ( 2701,-1111 ) ( 1 , 0)150 ( 3601,-1111 ) ( 1 , 0)225 ( 1651,-500)@xmath57    ( 3751,-500)@xmath57    ( 301 , 14)@xmath28 ( 151,-211)qubits ( 76,-1261)workspace ( 151,-1036)1 qubit ( 4126,-211)measure ( 980,239)@xmath54(980,-136)@xmath54(980,-736)@xmath54(980,-1111)@xmath54 ( 1576,164)@xmath43(1576,-211)@xmath43(1576,-811)@xmath43 ( 3151,-436)@xmath36 ( 2251,-436)@xmath66 ( 2251,-1636)@xmath67      [ t ]    # 1#2#3#4#5 @font    ( 5199,4420)(-1511,-2501 ) ( 601,1214 ) ( 0,-1)375 ( 1201,1214 ) ( 0,-1)375 ( 1801,1214 ) ( 0,-1)375 ( 1951,-61 ) ( 0,-1)150 ( 2551,-61 ) ( 0,-1)150 ( 3451,-211 ) ( 0,-1)375 ( 3151,389 ) ( 0,-1)600 ( -749,164 ) ( 0,-1)375 ( -149,164 ) ( 0,-1)375 ( 751,164 ) ( 0,-1)375 ( -749,-1561 ) ( 0,-1)150 ( -149,-1561 ) ( 0,-1)150 ( 1951,-1711 ) ( 0,-1 ) 75 ( 2551,-1711 ) ( 0,-1 ) 75 ( 3151,-1186 ) ( 0,-1)525 ( 2926,-661)(750,1125 ) ( 451,-1711 ) ( 0,-1)375 ( 226,-2461)(750,1500 ) ( 226,-661)(750,1125 ) ( -149,689)(0,0)[lb ] ( 151,689)(0,0)[lb ] ( 451,689)(0,0)[lb ] ( 751,689)(0,0)[lb ] ( 1051,689)(0,0)[lb ] ( 1351,689)(0,0)[lb ] ( 1651,689)(0,0)[lb ] ( 1951,689)(0,0)[lb ] ( 1201,-361)(0,0)[lb ] ( 1501,-361)(0,0)[lb ] ( 1801,-361)(0,0)[lb ] ( 2101,-361)(0,0)[lb ] ( 2401,-361)(0,0)[lb ] ( 2701,-361)(0,0)[lb ] ( 3001,-361)(0,0)[lb ] ( 3301,-136)(0,0)[lb ] ( -899,-661)(0,0)[lb ] ( 1900,-661)(0,0)[lb ] ( -899,-2461)(0,0)[lb ] ( 1900,-2461)(0,0)[lb ]    ( 601,-361)(0,0)[lb ] ( 301,-361)(0,0)[lb ] ( 1,-361)(0,0)[lb ] ( -299,-361)(0,0)[lb ] ( -599,-361)(0,0)[lb ] ( -899,-361)(0,0)[lb ] ( -1199,-361)(0,0)[lb ] ( -1499,-361)(0,0)[lb ] ( -1499,-1861)(0,0)[lb ] ( -1199,-1861)(0,0)[lb ] ( -899,-1861)(0,0)[lb ] ( -599,-1861)(0,0)[lb ] ( -299,-1861)(0,0)[lb ] ( 1,-1861)(0,0)[lb ] ( 601,-1861)(0,0)[lb ] ( 301,-1636)(0,0)[lb ] ( 1501,-1861)(0,0)[lb ] ( 2101,-1861)(0,0)[lb ] ( 2701,-1861)(0,0)[lb ] ( 3001,-1861)(0,0)[lb ] ( 1201,-1636)(0,0)[lb ] ( 1801,-1636)(0,0)[lb ] ( 2401,-1636)(0,0)[lb ] ( 3301,-1636)(0,0)[lb ] ( 1876,1814)(0,0)[lb ] ( -1499,-1111)(0,0)[lb ] ( -1499,389)(0,0)[lb ] ( 401,539)(0,0)[lb ]    for the sake of clarity and to understand the behaviour of the algorithm , we will trace the algorithm during the first few iterations . the mechanism of amplifying the amplitudes can be understood as shown in fig .",
    "[ pdomech ] . now consider the algorithm if iterated once .",
    "its behaviour can be understood as follows :    * _ register preparation_. prepare a quantum register of @xmath37 qubits all in state @xmath68 , where the extra qubit is used as a workspace for evaluating the oracle @xmath66 , the state of the system @xmath69 can be written as follows , where the subscript number refers to the step within the iteration and @xmath70 in the superscript refers to the iteration number : + @xmath71 * _ register initialisation_. apply hadamard gate on each of the first @xmath28 qubits in parallel , so they contain the @xmath72 states representing the list , where @xmath34 is the integer representation of items in the list : + @xmath73 * _ applying the oracle_. apply the oracle @xmath65 that maps the items in the list to either 0 or 1 simultaneously and stores the result in the extra workspace qubit : + @xmath74 * _ partial diffusion_. apply the partial diffusion operator defined above .",
    "let @xmath2 be the number of matches , which make the oracle @xmath66 evaluate to 1 ( solutions ) such that @xmath75 .",
    "assume that @xmath76 denotes a sum over @xmath34 which are desired matches , and @xmath77 denotes a sum over @xmath34 which are undesired items in the list .",
    "so , the system @xmath78 shown in eqn .",
    "[ enheq12 ] can be written as follows : + @xmath79 + applying @xmath36 on @xmath78 will result in a new system described as follows : + @xmath80 + where the mean used in the definition of partial diffusion operator is , + @xmath81 + and @xmath82 , @xmath83 and @xmath84 used in eqn .",
    "[ enheq17 ] are calculated as follows : + @xmath85 + such that , + @xmath86 + notice that , the states with amplitude @xmath83 had amplitude _ zero _ before applying @xmath36 as shown in the first iteration in fig .",
    "[ pdomech ] . * _ measurement_. if we measure the first @xmath28 qubits after the first iteration ( @xmath87 ) , then the probabilities of the system will be as follows : * * probability @xmath88 to find a match out of the @xmath2 possible matches is given by taking into account that a solution @xmath89 occurs _ twice _ as @xmath90 with amplitude @xmath83 and @xmath91 with amplitude @xmath84 as shown in eqn .",
    "[ enheq17 ] : + @xmath92 * * probability @xmath93 to find undesired result out of the states is given by : + @xmath94 + notice that , using eqn .",
    "[ enheq20 ] , + @xmath95    consider the system after first iteration shown in eqn .",
    "[ enheq17 ] before applying the measurement , the second iteration will modify the system as follows :    applying the oracle @xmath65 will _ swap _ the amplitudes of the states which represent the matches , i.e. states with amplitudes @xmath96 will be with amplitudes @xmath97 and states with amplitudes @xmath97 will be with amplitudes @xmath96 so the system can be described as ,    @xmath98    applying the operator @xmath36 will change the system as follows ,    @xmath99    where the mean used in the definition of partial diffusion operator is ,    @xmath100    and @xmath101 , @xmath102 and @xmath103 used in eqn .",
    "[ enheqn30 ] are calculated as follows :    @xmath104    and the probabilities of the system are ,    @xmath105    and , @xmath106    in the same fashion , the third iteration will give the following system ,    @xmath107    @xmath108    where the mean used in @xmath36 is ,    @xmath109    and @xmath110 , @xmath111 and @xmath112 used in eqn .",
    "[ enheqn35 ] are calculated as follows :    @xmath113    and the probabilities of the system are ,    @xmath114    and , @xmath115    in general , the system after @xmath116 iterations can be described using the following recurrence relations ,    @xmath117    where the mean to be used in the definition of the partial diffusion operator is as follows : let @xmath118 and @xmath119 , then ,    @xmath120    and @xmath121 , @xmath122 and @xmath123 used in eqn .",
    "[ enheqn39 ] are calculated as follows :    @xmath124    @xmath125    @xmath126    and the probabilities of the system are ,    @xmath127    and @xmath128    solving the above recurrence relations for @xmath129 , @xmath130 and @xmath131 shown eqn .",
    "[ enheqn41 ] , eqn .",
    "[ enheqn42 ] and eqn .",
    "[ enheqn43 ] respectively , the closed forms are as follows :    @xmath132    where @xmath133 , @xmath134 and @xmath135 is the chebyshev polynomial of the second kind @xcite represents the oracle function and @xmath135 is the chebyshev polynomial of the second kind.]which is defined as follows ,    @xmath136    the probabilities of the system ,    @xmath137    and , @xmath138    such that ,    @xmath139    now , we have to calculate how many iterations , @xmath64 , are required to find any match with probability close to certainty for different cases of @xmath140 . to find a match with high probability on any measurement , then @xmath141 must be as close as possible to one . to calculate the number of iterations , @xmath64 , required to satisfy this condition , we need the following theorem .",
    "consider the following relation ,    @xmath142    where @xmath143 is the chebyshev polynomial of the second kind , @xmath144 and @xmath134 , then ,    @xmath145    from the definition of @xmath143 shown in eqn .",
    "[ enheqn52 ] then eqn",
    ". [ enheqn59 ] can take this form ,    @xmath146    or ,    @xmath147    using simple trigonometric identities , the above relation may take the form ,    @xmath148    using the addition formulas for cosine we get ,    @xmath149    @xmath150    @xmath151    from the last equation we get , @xmath152    which gives the required conditions , @xmath153 .",
    "the number of iterations must be integer , let @xmath154 where @xmath155 . and since , @xmath156 , we have @xmath157 , then ,    @xmath158    where @xmath159 is the floor operation . to determine the lower bound of @xmath160 using @xmath64 , let @xmath160 to take the form ,    @xmath161    we have , @xmath162 then , @xmath163 and from the definition of @xmath164 , @xmath165 then , @xmath166 or , @xmath167 using this in eqn.[enheqn60 ] , we get the following lower bound ,    @xmath168    the minimum of the lower bound is @xmath169 ( @xmath170 ) when @xmath171 ( @xmath172 ) . notice that , when @xmath173 , the probability of success is 98.78% after a single iteration using eqn .",
    "[ enheq21 ] .",
    "this minimum of the lower bound can be neglected with respect to the real behaviour of the algorithm .    to demonstrate the real behaviour of the algorithm",
    ", we may plot the probability of success @xmath160 using the required number of iterations @xmath64 for any given @xmath2 , fig .",
    "[ pdops ] shows this behaviour as a function of @xmath174 .",
    "we can see from the plot that the minimum probability that the algorithm may reach is approximately 87.88% when @xmath175 . for @xmath176 , @xmath87 where only a single iteration is required to handle this range . for @xmath177 , @xmath178 where the algorithm will behave more reliable than grover s algorithm as we will see .",
    "first we will summarise the probabilities of success and the required number of iterations for grover s algorithm and the proposed algorithm before giving the comparison .",
    "the probability of success of grover s algorithm as shown in @xcite is as follows :    @xmath179    where @xmath180 and the required number of iterations @xmath181 is ,    @xmath182    for the proposed algorithm , the probability of success is as follows ,    @xmath183    where @xmath184 and the required @xmath64 is , @xmath185    fig .",
    "[ jitr].a shows the probability of success for both algorithms using the required number of iterations .",
    "we can see from the plot that the minimum probability that grover s algorithm may reach is approximately 50.0% when @xmath186 while for the proposed algorithm , the minimum probability is 87.88% when @xmath175 .",
    "grover s algorithm will behave similar to the single guess technique for @xmath187 where @xmath188 in that range so that @xmath189 . although the proposed algorithm is slower than grover s algorithm for small @xmath190 by @xmath191 , fig .",
    "[ jitr].b shows the probability of success for both algorithms for small @xmath190 ( hard cases where @xmath192 , where we can see that the proposed algorithm is more reliable ( higher probability ) than grover s algorithm . for @xmath193 , @xmath87 where the proposed algorithm runs in @xmath194 to get probability at least 90% , i.e. the problem is easier for multiple matches .",
    "and @xmath64 for both algorithms : a. @xmath195 ( left ) , b. @xmath196 ( right).,width=480,height=211 ]",
    "in case we do not know the number of matches @xmath2 in advance , we can apply the algorithm shown in @xcite for @xmath197 by replacing grover s step with the proposed algorithm .",
    "the algorithm can be summarised as follows :    * start with @xmath198 and @xmath199 .",
    "( where @xmath200 can take any value between 1 and @xmath201 ) * pick an integer @xmath202 between 0 and @xmath203 in a uniform random manner . * run @xmath202 iterations of the proposed algorithm on the state : + @xmath204 * measure the register and assume @xmath34 is the output . * if @xmath205 , then we found a solution and exit .",
    "* let @xmath206 and go to step 2 .    for the sake of simplicity and to be able to compare the performance of this algorithm with that shown in @xcite",
    ", we will try to follow the same style of analysis used in @xcite . before we construct the analysis",
    ", we need the following lemmas .",
    "the first lemma is straightforward using mathematical induction .",
    "[ lemch5 ] for any positive integer @xmath207 and real number @xmath208 such that @xmath209 , @xmath210    assume @xmath2 is the unknown number of matches such that @xmath3 .",
    "let @xmath208 be a real number such that @xmath211 and @xmath209 .",
    "let @xmath207 be any positive integer .",
    "let @xmath64 be any integer picked in a uniform random manner between 0 and @xmath203 .",
    "measuring the register after applying @xmath64 iterations of the proposed algorithm starting from the initial state , the probability @xmath212 of finding a solution is as follows ,    @xmath213    where , @xmath214 for @xmath215 and small @xmath190 .",
    "the average probability of success when applying @xmath64 iterations of the proposed algorithm when @xmath216 is picked in a uniform random manner is as follows ,    @xmath217    if @xmath215 and @xmath218 then @xmath219 , so ,    @xmath220    where @xmath221 for @xmath209 .",
    "we calculate the total expected number of iterations as done in theorem 3 in @xcite .",
    "assume that @xmath222 , and @xmath223 .",
    "notice that , @xmath224 for @xmath75 , then :    * the total expected number of iterations to reach the critical stage , i.e. when @xmath225 : + @xmath226 * the total expected number of iterations after reaching the critical stage : + @xmath227    the total expected number of iterations whether we reach to the critical stage or not is @xmath228 which is in @xmath0 for @xmath229 .    when this algorithm employed grover s algorithm @xcite , and based on the condition @xmath230 for @xmath231 , where @xmath232 will act as a lower bound for @xmath181 in that range .",
    "the total expected number of iterations is approximately @xmath233 . for @xmath234",
    ", @xmath232 will increase exponentially where it will not be able to approximate @xmath181 . employing the proposed algorithm instead , and based on the condition @xmath235 for @xmath229 , the total expected number of iterations is approximately @xmath228 , i.e. the algorithm will be able to handle the whole range , since @xmath236 will be able to act as a lower bound for @xmath64 over @xmath229 .",
    "[ 78mqg ] compares between the total expected number of iterations for both algorithms taking @xmath237 .",
    "and the proposed algorithm @xmath238 taking @xmath239 , where the number of iterations is the flooring of the values ( step function).,width=384,height=288 ]",
    "in grover s algorithm , the search space is split into two subspaces ( the solution and non - solution subspaces ) then amplifies the amplitudes of the solution states by iterating the diffusion operator and the oracle @xcite to find a match with high probability in @xmath0 for small @xmath190 and in the neighbourhood of @xmath240 @xcite .",
    "the main idea of using partial diffusion in quantum search is to split the subspace of the solutions into two smaller subspaces . in each iteration",
    ", one of the solution subspaces will be inverted about the mean ( together with the non - solution subspace ) while the other half will have the sign of their amplitudes changed to the negative sign , preparing it to be inverted about the mean ( together again with the non - solution subspace ) in the next iteration .",
    "the benefit of this alternating inversion is to preserve half the number of the solution states at each iteration so as to resist the _ de - amplification behaviour _ of the standard diffusion operator when reaching the so - called turning points and get the solution with high probability in @xmath0 for @xmath3 .",
    "apply the oracle @xmath66 each iteration will switch the entanglement of the two solution subspaces with the extra qubit workspace to decide which subspace to be inverted about the mean with the non - solution subspace .",
    "an algorithm for unknown number of matches replacing grover s step in the algorithm shown in @xcite is presented , where we showed that the algorithm will be able to handle the range @xmath3 in @xmath0 compared with @xmath25 when using grover s algorithm .",
    "we showed that the algorithm will be able to handle the whole possible range @xmath229 more reliably using fixed operators in @xmath67 for both known and unknown number of matches which makes it more suitable for practical purposes .",
    "m.  mosca .",
    "quantum searching , counting and amplitude amplification by eigenvector analysis . in _ proceedings of randomized algorithms ,",
    "workshop of mathematical foundations of computer science _ ,",
    "pages 90100 , 1998 ."
  ],
  "abstract_text": [
    "<S> in this paper , we will define a quantum operator that performs the inversion about the mean only on a subspace of the system ( _ partial diffusion operator _ ) . </S>",
    "<S> this operator is used in a quantum search algorithm that runs in @xmath0 for searching an unstructured list of size @xmath1 with @xmath2 matches such that @xmath3 . </S>",
    "<S> we will show that the performance of the algorithm is more reliable than known _ fixed operators quantum search algorithms _ especially for multiple matches where we can get a solution after a single iteration with probability over 90% if the number of matches is approximately more than one - third of the search space . </S>",
    "<S> we will show that the algorithm will be able to handle the case where the number of matches @xmath2 is unknown in advance such that @xmath3 in @xmath0 . </S>",
    "<S> a performance comparison with grover s algorithm will be provided . </S>"
  ]
}