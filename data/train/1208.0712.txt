{
  "article_text": [
    "a decentralized peer - to - peer system ( p2p ) @xcite involves many peers ( nodes ) which execute the same software , participate in the system having equal rights and might join or leave the system continuously . in such a framework processes",
    "are dynamically distributed to peers , with no centralized control .",
    "p2p systems have no inherent bottlenecks and can potentially scale very well .",
    "moreover , since there are no dedicated nodes critical for systems functioning , those systems are resilient to failures , attacks , etc .",
    "the main applications of p2p - systems involve : file sharing , redundant storage , real - time media streaming , etc .",
    "p2p systems are frequently implemented in a form of overlay networks @xcite , a structure that is totally independent of the underlying network that is actually connecting devices .",
    "overlay network represents a logical look on organization of the resources .",
    "some of the overlay networks are realized in the form of distributed hash tables ( dht ) that provide a lookup service similar to a hash table ; ( key , value ) pairs are stored in a dht , and any participating peer can efficiently retrieve the value associated with a given key .",
    "responsibility for maintaining the mapping from keys to values is distributed among the peers , in such a way that any change in the set of participants causes a minimal amount of disruption .",
    "it allows a dht to scale to extremely large number of peers and to handle continual node arrivals , departures , and failures .",
    "the chord protocol @xcite is one of the first , simplest and most popular dhts .",
    "the paper @xcite which introduces chord has been recently awarded the sigcomm 2011 test - of - time award .",
    "our aim is to describe chord using abstract state machine ( asm ) @xcite and to prove the correctness of the formalization , which was motivated by the obvious fact that errors in concurrent systems are difficult to reproduce and find merely by program testing .",
    "there are at least two reasons for using asms .",
    "the asm - code for chord presented in this paper has been written following one of the best implementations @xcite of the high level c@xmath0-like pseudo code from @xcite .",
    "recently , several non - relational database systems ( nrdbms ) have been developed @xcite that are usually based on the chord like technology . to analyze their behavior",
    ", it might be useful to characterize situations when correctness of the underlying protocol holds .",
    "following that idea , we have formulated several deterministic conditions that guarantee correctness of chord , and proved the corresponding statements .",
    "this is in contrast to the approach from @xcite where a probabilistic analysis is proposed , and correctness holds with `` high probability '' .",
    "most of them are based on the chord like technology .",
    "nrdbmss are used when a large amount of data exist and do not need frequent update .",
    "usually , an nrdbms does not guarantee correctness .",
    "the main objectives of chord are maintaining the ring topology as nodes concurrently join and leave a network , mapping keys onto nodes and distributed data handling .",
    "the formalism of asm enables us to precisely describe a class of possible runs - so called regular runs - of the protocol , and to prove correctness of the main operations with respect to it .",
    "moreover , several examples of runs , given in example [ primer_rr ] , that violate the constraints for the regular runs illustrate how correctness can be broken in those cases .",
    "let @xmath1 , @xmath2 and @xmath3 be three fixed positive integers , and @xmath4 .",
    "we will consider the following disjoint universes :    * the set @xmath5 of all peers that might participate in the considered chord network , * the set @xmath6 of identifiers of objects that might be stored in the considered chord network , and the set @xmath7 of the values of those @xmath3 objects , * the set @xmath8 denoting at most @xmath9 peers that are involved in the network in a particular moment , * the sets @xmath10 and @xmath11 which represent the actions of the peers .    note that :    * it might be that @xmath12 ( @xmath13 ) , i.e. , that there are more peers ( objects to be stored in the network ) than nodes , but it can never be @xmath14 , and * without any loss of generality we assume that the numbers of keys and values are the same ; if there are more values than keys , all values mapped to the same key might be organized in a list .    any peer , active in the network will be called a _ node_. we assume that a @xmath15 ( fig . [ node ] ) is represented by its identifier @xmath16 in the network , information on its @xmath17 and @xmath18 , a @xmath19 _ table _",
    ", a pointer ( @xmath20 ) to an element in the finger table which will be updated in the current stabilization cycle , and a _ list of @xmath21 pairs _ of the records for which the node is responsible for .        more formally , we introduce the following functions :    * @xmath22 * @xmath23 , * @xmath24 , * @xmath25 , * @xmath26 , and * @xmath27 ,    where @xmath28 is the set that contains lists of nodes identifiers , and @xmath29 is the set of lists containing pairs @xmath30 .",
    "each @xmath31 has @xmath2 entries ordered respect to the ring ordering .",
    "in other words , a peer @xmath32 , which is a node , is represented by the tuple :    * @xmath33 .",
    "table [ chord_functions ] shows all the other functions that will be used in the formal description of the protocol , but that do not directly change the representations of nodes .",
    "we assume that the five functions in table [ chord_functions ] ( @xmath34 , @xmath35 , @xmath36 , @xmath37 and @xmath38 ) are external .",
    ".chord functions [ cols=\"<,<\",options=\"header \" , ]     any node present in a chord network can execute get rule ( ask for the value of a key ) .",
    "that rule does not change the actual state of the network , but we define it as :    .... % \\textsc{get}$=$% invoke % \\textsc{findsuccessor}% for given % $ key$% and check corresponding % $ value$% ....    during the each execution of a _ peer_agent module _ all the messages send to a node are processed :    .... % \\textsc{readmessages}$=$% read messages dedicated to % $ me$% , change local variables if it is requested and clear processed messages ....",
    "in this section we present the correctness of our formalization with respect to the so - called regular runs .",
    "let @xmath39 and @xmath40 be all the nodes from a chord network such that @xmath41 .",
    "the pair @xmath42 forms a _ stable pair _ in a state if the following holds :    * @xmath43 , @xmath44 , for all @xmath45 .    a chord network @xmath46 , @xmath47 is _ stable _ in a state if the pair @xmath48 is stable .",
    "@xmath49    intuitively , a pair @xmath42 is stable in a state if there is no node trying to join the network through the node on the ring - interval @xmath50 in that state .    _",
    "_ are all runs of a distributive algebra @xmath51 which satisfy that :    * any execution of fairleave , unfairleave and put might happen only between a stable pair of nodes .",
    "[ ogranicenje1]@xmath49    the following example illustrates the need for the above constraint . in the example and",
    "in the rest of the paper we will graphically illustrate sequences of moves , so that @xmath52 denotes a state , the updated values are in bold , and @xmath53 means that the rest of a network is not affected by a move .",
    "[ primer_rr ] let @xmath54 be the initial state in which the nodes @xmath55 and @xmath56 are members of a network , and the node @xmath57 wants to join .",
    "suppose that before the pair @xmath58 becomes stable , @xmath55 executes the put rule with the hash @xmath59 of a key .",
    "since @xmath55 is not aware of @xmath57 , the corresponding key will be stored in @xmath56 , and not in @xmath57 .",
    "@xmath16 & @xmath60 & @xmath61 + @xmath17 & @xmath53 & @xmath60 + @xmath18 & @xmath61 & @xmath53 + @xmath62 & @xmath63 & @xmath63 +    @xmath64     @xmath16 & @xmath60 & & @xmath61 + @xmath17 & @xmath53 & & @xmath60 + @xmath18 & @xmath61 & & @xmath53 + @xmath62 & @xmath63 & & @xmath63 +    @xmath65     @xmath16 & @xmath60 & @xmath59 & @xmath61 + @xmath17 & @xmath53 & @xmath66 & + @xmath18 & @xmath61 & @xmath61 & @xmath53 + @xmath62 & @xmath63 & @xmath63 & @xmath63 +    @xmath67     @xmath16 & @xmath60 & @xmath59 & @xmath61 + @xmath17 & @xmath53 & @xmath66 & @xmath59 + @xmath18 & @xmath61 & @xmath61 & @xmath53 + @xmath62 & @xmath63 & @xmath63 & +    @xmath68     @xmath16 & @xmath60 & @xmath59 & @xmath61 + @xmath17 & @xmath53 & @xmath66 & @xmath59 + @xmath18 & & @xmath61 & @xmath53 + @xmath62 & @xmath63 & @xmath63 & @xmath59 +    @xmath68     @xmath16 & @xmath60 & @xmath59 & @xmath61 + @xmath17 & @xmath53 & & @xmath59 + @xmath18 & @xmath59 & @xmath61 & @xmath53 + @xmath62 & @xmath63 & @xmath63 & @xmath59 +    again , assume that @xmath54 is the initial state and the network contains the nodes @xmath55 , @xmath56 and @xmath69 . if the node @xmath57 executes the join rule , and before the pair @xmath70 becomes stable , @xmath56 wants to leave , @xmath57 will be isolated from the rest of the network , and the other nodes will never be aware of it .",
    "@xmath16 & @xmath60 & @xmath61 & @xmath71 + @xmath17 & @xmath53 & @xmath60 & @xmath61 + @xmath18 & @xmath61 & @xmath71 & @xmath53 +    @xmath64     @xmath16 & @xmath60 & & @xmath61 & @xmath71 + @xmath17 & @xmath53 & & @xmath60 & @xmath61 + @xmath18 & @xmath61 & & @xmath71 & @xmath53 +    @xmath72     @xmath16 & @xmath60 & @xmath59 & @xmath71 + @xmath17 & @xmath53 & @xmath66 & @xmath60 + @xmath18 & @xmath71 & @xmath61 & @xmath53 +    a similar example can be given for unfairleave .",
    "@xmath49    in the sequel , we show that a stable pair of nodes in a chord network , which executes a regular run , eventually becomes stable after adding / removing of a node between them ( the theorems [ succend]-[chord_cycle ] ) .",
    "corollary [ cor4 ] formulates the corresponding statement for a stable network .",
    "finally , we prove that the proposed key - handling correctly distributes keys and answers queries ( theorem [ golden_rule ] and corollary [ corol1 ] ) .",
    "the first theorem expresses that the rule findsuccessor will terminate in a finite number of steps .",
    "it corresponds to theorem iv.2 from@xcite .",
    "[ succend ] let @xmath73 be the node which fires the rule findsuccessor for @xmath74 .",
    "let @xmath75 be the minimal element of @xmath76 such that @xmath77 .",
    "if the pair @xmath78 is stable in that state , the node @xmath79 will get the result after a finite number of moves .",
    "theorems [ stabthj ] ",
    "[ chord_cycle ] guarantee that the successor and predecessor pointers for each node will be eventually up to date after a node joins , or unfair leaves the network . in the corresponding proofs we will use some finite initial sequences of runs . due to the fact that the stabilize and updatepredecessor are applied periodically by all nodes in a network",
    ", we will mention only those applications which change the values of the functions @xmath17 and @xmath18 .",
    "note that , in each proof we will consider some fixed linearization of moves , but according to corollary [ cor1 ] , all linearizations of the corresponding regular run will result in the same final state .",
    "theorem [ concjoin ] corresponds to theorem iv.3 from @xcite .",
    "[ stabthj ] let a peer join a chord network , between two nodes which constitute a stable pair .",
    "then , there is a number @xmath80 of steps , such that if no other join rule happens in the meantime , the stabilize rule will bring the starting pair to be stable after @xmath81 steps .",
    "[ concjoin ] let a chord network contain a stable pair . if a sequence of join rules is executed between the nodes which form this stable pair , interleaved with stabilize , updatepredecessor and update_fingers , then there is a number @xmath82 of steps , such that after the last join rule , the starting pair of nodes will be stable after @xmath81 steps .",
    "[ stabthl ] let a chord network contain a stable pair and let a node between them leave the network .",
    "then , there is a number @xmath83 of steps , such that if no join rule happens at the considered part of the network in the meantime , the pair will be brought into a stable state after @xmath81 steps .",
    "[ stab_mix_join_leave ] let a chord network contain a stable pair . let a node which is between those nodes leave the network following by several nodes which want to join between them .",
    "then , there is a number @xmath83 of steps , such that the considered pair will be brought into a stable state after @xmath81 steps .",
    "note that the restriction from the formulation of theorem [ stab_mix_join_leave ] , that no other leave - rules are allowed after the first one , is not essential .",
    "according to the definition of regular runs , leave - rules can be executed only between nodes which constitute a stable pair , and we can consider an execution of a sequence of join rules interleaved with leave - rules , and obtain the same result .",
    "the above statement will hold for each subsequence which starts with a leave rule followed by several join rules .",
    "thus , we have the following :    [ cor3 ] let a chord network contain a stable pair .",
    "let a node , which is in between those nodes , leave the network .",
    "then , there is a number @xmath83 , such that the considered pair of nodes will become stable after @xmath81 moves .",
    "theorem [ chord_cycle ] incorporates all previous ideas , and is the main statement concerning correctness of maintaining topological structure of chord networks .",
    "[ chord_cycle ] let a finite initial segment of a run produce the state @xmath84 of a chord network . then , for every pair of nodes @xmath85 , there is a number @xmath83 , such that @xmath86 will become stable after @xmath81 moves .",
    "since a network is stable in a state if all pairs of nodes from the network are stable in that state , we have :    [ cor4 ] let a finite initial segment of a run produce the state @xmath84 of a chord network .",
    "then , there is a number @xmath83 , such that the network will become stable after @xmath81 moves .",
    "finally , the next two statements say that our formalization consistently manipulates distributed keys .",
    "theorem [ golden_rule ] states that @xmath87 pairs are properly distributed over the network .",
    "informally , it follows from the facts that for every @xmath73 , @xmath88 for the keys for which @xmath79 is responsible for , and that all rules that manipulate @xmath87 pairs invoke findsuccessor rule .",
    "[ golden_rule ] @xmath89 @xmath90    corollary [ corol1 ] follows from the definition of get , and the theorems [ succend ] and [ golden_rule ] :    [ corol1 ] if get returns @xmath66 for some @xmath91 , then there is no @xmath92 such that @xmath87 pair is stored in the chord network .",
    "namely , according to theorem [ golden_rule ] , all @xmath87 pairs are stored properly , and from theorem [ succend ] get considers only the @xmath87 pairs stored in the node @xmath9 which satisfy condition @xmath93 @xmath94 .",
    "in this paper we have presented an asm - based formalization of the chord protocol .",
    "we have proved that the proposed formalization is correct with respect to the regular runs . up to our knowledge , it is the first comprehensive formal analysis of chord presented in the literature which concerns both maintenance of the ring topology and data distribution .",
    "we have also indicated that if we consider all possible runs , incorrect behavior of chord protocol could appear .    possible direction for further",
    "work is to apply similar technique to describe other dht protocols .",
    "for example , an interesting candidate for examination in the asm - framework could be synapse , a protocol for information retrieval over the inter - connection of heterogeneous overlay networks defined in @xcite , and applied in @xcite",
    ".    another challenge could be verification of the given description in one of the formal proof assistants ( e.g. , coq , isabelle / hol ) .",
    "it might also produce a certified program implementation from the proof of correctness of our asm - based specification .",
    "f.  chang , j.  dean , s.  ghemawat , w.  c.  hsieh , d.  a.  wallach , m.  burrows , t.  chandra , a.  fikes , r.  e.  gruber . .",
    "in _ proceedings of the @xmath95 conference on usenix symposium on operating systems design and implementation _ , volume 7 , pages 205218 , 2006 ."
  ],
  "abstract_text": [
    "<S> this paper describes the overlay protocol chord using the formalism of abstract state machines . </S>",
    "<S> the formalization concerns chord actions that maintain ring topology and manipulate distributed keys . </S>",
    "<S> we define a class of runs and prove the correctness of our formalization with respect to it .    </S>",
    "<S> * keywords * : peer - to - peer , chord , dht - based overlay networks , abstract state machines , formalization . </S>"
  ]
}