{
  "article_text": [
    "a number of recent papers have provided compelling evidence ( and proof , in some cases ) that certain computational , cryptographic , and information - theoretic tasks can be performed more efficiently by models based on quantum physics than those based on classical physics .",
    "for example , shor @xcite has shown that integers can be factored in expected polynomial time by quantum computers , a quantum key distribution protocol of bennett and brassard @xcite that does not rely on intractability assumptions has been proven secure under a wide variety of attacks @xcite , and buhrman , cleve , and wigderson @xcite have shown various separation results between quantum and classical two - party communication complexity models . in this paper",
    "we introduce the quantum analogue of another concept  interactive proof systems  and provide strong evidence that additional power is gained by interactive proof systems in the quantum setting .",
    "interactive proof systems were introduced by goldwasser , micali , and rackoff @xcite and babai @xcite .",
    "informally , in an interactive proof system a computationally unbounded prover interacts with a polynomial - time probabilistic verifier and attempts to convince the verifier to accept a given input string . a language @xmath0 is said to have an interactive proof system if there exists a verifier @xmath1 such that ( i )  there exists a prover @xmath2 ( called an honest prover ) that can always convince @xmath1 to accept when the given input is in @xmath0 , and ( ii )  no prover @xmath3 can convince @xmath1 to accept with nonnegligable probability when the input is not in @xmath0 .",
    "the class of languages having interactive proof systems is denoted @xmath4 .    based on the work of lund , fortnow , karloff , and nisan @xcite , shamir @xcite proved that every language in pspace has an interactive proof system .",
    "since any language having an interactive proof system is in pspace @xcite , this implies @xmath5 .",
    "all known protocols for pspace require a nonconstant number of rounds of communication between the prover and verifier , and can not be parallelized to require only a constant number of rounds under the assumption that the polynomial time hierarchy is proper .",
    "this is because the class of languages having constant - round interactive proof systems is equivalent to the class am @xcite , and hence is contained in @xmath6 .",
    "the main result we prove in this paper is as follows .",
    "[ thm : main ] every language in pspace has a 2-round quantum interactive proof system with exponentially small probability of error .    this result contrasts with the facts mentioned above regarding classical interactive proof systems , as it shows there are languages having 2-round quantum interactive proof systems that do not have constant - round classical interactive proof systems unless @xmath7 .    we now summarize informally our technique for proving theorem  [ thm : main ] .",
    "consider the following ( unsuccessful ) method for trying to reduce the number of rounds required by a nonconstant - round protocol for pspace to a constant : define the verifier so that it chooses all of its random numbers initially , sends them all to the prover in one round ( or in a constant number of rounds ) , receives all the responses from the prover , and checks the validity of the responses .",
    "this will not work , since the prover may cheat by `` looking ahead '' and basing its responses on random numbers that would have been sent in later rounds in the nonconstant - round case .",
    "however , using interactive proofs based on quantum physics , this technique can be made to work , as the aforementioned behavior on the part of the prover can be detected by a quantum verifier .",
    "we now sketch the method for doing this  a formal description of the protocol appears in section  [ sec : qips_for_qbf ] .",
    "the prover first sends a superposition of sequences of random numbers and corresponding responses to the verifier , and the verifier checks that the responses are valid according to a classical protocol for pspace .",
    "( it will be shown that the prover can not cheat by giving the verifier a superposition that is biased towards certain random sequences ",
    "the verifier will be able to later check that the superposition is close to uniform . )",
    "the verifier then chooses randomly one of the positions in the list of random numbers and responses , sends back to the prover its responses starting at this position in the list and challenges the prover to invert the computation it performed to obtain these responses .",
    "let us say that the random numbers and responses up to the chosen position in the list have _ low - index _ , and the remaining random numbers and responses have _ high - index_. the low - index responses , which were not sent back to the prover in the second round , should now depend only on the low - index random numbers ( for otherwise the prover has cheated ) .",
    "the verifier may now check that the superposition of high - index random numbers is uniform by performing an appropriately defined measurement .",
    "however , if the prover has cheated by basing its low - index responses on high - index random numbers , the low - index responses and high - index random numbers will be entangled in a manner detectable by the verifier ; with high probability , the high - index random numbers will fail the uniformity test . by performing this process itself in parallel a polynomial number of times ,",
    "the probability a cheating prover escapes detection is made exponentially small , while the protocol still requires only two rounds of communication .",
    "the remainder of the paper has the following organization . in section  [ sec : qip_definition ]",
    "we formally define quantum interactive proof systems . in section  [ sec : qips_for_qbf ] we prove theorem  [ thm : main ] by presenting a 2-round quantum interactive proof system for the quantified boolean formula problem and proving its correctness .",
    "we conclude with section  [ sec : conclusion ] , which mentions a number of open problems regarding quantum interactive proofs .",
    "we now give a formal definition of quantum interactive proof systems .",
    "we restrict our attention to constant round quantum interactive proof systems , although the definition is easily extended to a nonconstant number of rounds . the model for quantum computation that provides",
    "a basis for our definition of quantum interactive proof systems is the quantum circuit model .",
    "we will not define quantum circuits or discuss them in detail , as this has been done elsewhere ( see yao @xcite and berthiaume @xcite , for example ) .",
    "a @xmath8-round verifier @xmath1 is a polynomial - time computable mapping @xmath9 , where each @xmath10 is an encoding of a quantum circuit composed of quantum gates from some appropriately chosen universal set of gates .",
    "universal sets of gates / transformations have been investigated in a number of papers @xcite ; for the purposes of this paper , we will assume only that this set includes the walsh - hadamard gate and any universal gate for reversible computation such as the fredkin gate or toffoli gate .",
    "each encoding @xmath10 is identified with the quantum circuit it encodes .",
    "since the mapping @xmath1 is computable in polynomial time , each circuit @xmath10 must be polynomial in size .",
    "the qubits upon which each @xmath10 acts are assumed to be divided into two groups : message qubits and ancilla qubits .",
    "the message qubits represent the communication channel between the prover and verifier , while the ancilla qubits represent qubits that are private to the verifier .",
    "one of the verifier s ancilla qubits is specified as the output qubit .",
    "a @xmath8-round prover @xmath2 is a mapping from @xmath11 to the set of all quantum circuits .",
    "no restrictions are placed on the size of each @xmath12 or on the gates from which these circuits are composed .",
    "similar to the case of the verifier , the qubits of the prover are divided into message qubits and ancilla qubits .",
    "note that although the prover is all - powerful in a computational sense ( there is no bound on the complexity of the mapping @xmath2 or on the size of each @xmath12 ) , we of course require that the prover obey the laws of physics !",
    "this is enforced by requiring that the prover s actions correspond to quantum circuits .",
    "given a pair @xmath13 , we consider a quantum circuit composed in the manner illustrated in figure  [ fig : qips ] ( the case @xmath14 is shown ) .",
    "the probability that a pair @xmath13 accepts a given input @xmath15 is defined to be the probability that an observation of the output qubit in the @xmath16 basis yields @xmath17 when the circuits @xmath18 are applied in sequence as illustrated , assuming all qubits are initially in the @xmath19 state .",
    "now , we say that a language @xmath0 has a @xmath8-round quantum interactive proof system with error probability @xmath20 if there exists a @xmath8-round verifier @xmath1 such that    there exists a @xmath8-round prover @xmath2 such that if @xmath21 then @xmath13 accepts @xmath15 with probability 1 .    for all @xmath8-round provers",
    "@xmath3 , if @xmath22 then @xmath23 accepts @xmath15 with probability at most  @xmath20 .",
    "a few notes regarding the above definition are in order .",
    "first , we note that there are a number of other ways in which we could have defined quantum interactive proof systems , such as a definition based on quantum turing machines or a definition requiring that each circuit as above be given by @xmath24 or @xmath25 , with @xmath15 supplied as input to each circuit , for example .",
    "we have chosen the above definition because of its simplicity .",
    "given the apparent robustness of the class of `` polynomial - time computable quantum transformations , '' we suspect these definitions to be equivalent , although we have not investigated this question in detail .",
    "second , we assume that each circuit corresponds to a unitary operator ( e.g. , no `` measurement gates '' are used )",
    ". the action of any general quantum gate ( i.e. , a gate corresponding to a trace - preserving , completely positive linear map on mixed states of qubits ) can always be simulated by some unitary gate ( possibly adding more ancilla qubits ) @xcite . as this",
    "will not increase the size of a verifier s circuit by more than a polynomial factor , and will not affect the complexity of the mapping @xmath1 significantly , our definition is equivalent to a definition allowing more general quantum gates .",
    "we begin this section by defining the quantified boolean formula problem , which is complete for pspace .",
    "a quantified boolean formula is a formula of the form @xmath26 , where each @xmath27 is an existential or universal quantifier ( @xmath28 or @xmath29 ) and @xmath30 is a boolean formula ( without quantifiers ) in the variables @xmath31 .",
    "the quantified boolean formula ( qbf ) problem is to determine if a quantified boolean formula is true .    to prove theorem  [ thm : main ] , it is sufficient to prove that there exists a 2-round quantum interactive proof system with exponentially small error for the qbf problem",
    "this is because a verifier ( and any honest prover ) may first compute a polynomial - time reduction from a given problem in pspace to the qbf problem , then execute the protocol for qbf ( adjusting various parameters in the protocol to reduce error as necessary ) .",
    "our 2-round quantum interactive proof system for the qbf problem is based on a variant of the lund ",
    "fortnow  karloff ",
    "nisan protocol due to shen @xcite , to which the reader is referred for a detailed description . in this section",
    "we review some facts regarding this protocol that will later be helpful .",
    "let us suppose the input formula @xmath32 is fixed .",
    "also let @xmath33 be a finite field , write @xmath34 , and let @xmath35 be the length of @xmath36 ( with a slight modification of the protocol , @xmath37 is sufficient ) .",
    "the protocol is as follows . for @xmath38 ,",
    "the prover sends the verifier a polynomial @xmath39 over @xmath33 of degree at most @xmath35 , and the verifier chooses @xmath40 and sends @xmath41 to the prover .",
    "the prover then sends a polynomial @xmath42 to the verifier in the final round , and the verifier chooses @xmath43 ( there is no need for @xmath44 to be sent to the prover ) .",
    "the verifier then evaluates a particular polynomial - time predicate @xmath45 and accepts if and only if the predicate evaluates to true .",
    "a formal description of @xmath46 may be derived from the paper of shen .",
    "since the details of the predicate are not necessary for our discussion , we will only state certain properties of @xmath46 .",
    "first , for any sequence of random numbers @xmath47 there exist polynomials @xmath48 , where each polynomial @xmath49 depends only on @xmath50 , that correspond to the answers that should be given by an honest prover . these polynomials , which are well - defined regardless of the boolean value of @xmath36 , satisfy the following properties :    6 mm    if @xmath36 evaluates to true , then for all sequences @xmath51 , @xmath52 .    if @xmath36 evaluates to false , then for all sequences @xmath51 , @xmath53 for all polynomials @xmath54 .    if @xmath36 evaluates to false , then for any @xmath55 and @xmath56 , the following holds .",
    "if @xmath57 are such that @xmath58 , then there are at most @xmath35 values of @xmath59 for which there exist @xmath60 and @xmath61 such that @xmath62 .    if @xmath36 evaluates to false , then for any @xmath63 and @xmath64 for which @xmath65 , there are at most @xmath35 values of @xmath44 for which @xmath66 .    for given @xmath67",
    ", we call the polynomial @xmath68 the _ correct _ polynomial corresponding to @xmath67 .",
    "clearly , if @xmath36 evaluates to true , an honest prover can always convince the verifier to accept by sending the correct polynomials @xmath48 corresponding to the verifiers random numbers @xmath63 .",
    "now suppose that @xmath36 evaluates to false . by item 2",
    ", a cheating prover can not send the correct polynomial @xmath69 on the first round , for the prover rejects with certainty in this case .",
    "hence the prover must send @xmath70 if the verifier is to accept .",
    "now suppose for @xmath55 and @xmath67 the prover has sent polynomials @xmath71 during rounds @xmath72 .",
    "unless the verifier randomly chooses one of @xmath35 particular values for @xmath59 , the prover may not send @xmath73 on the next round without causing the verifier to reject .",
    "hence , if the prover sends an incorrect polynomial on round @xmath8 , then with probability at least @xmath74 it must send an incorrect polynomial on round @xmath75 .",
    "finally , if the prover does not send the correct polynomial @xmath76 during the last round , the verifier accepts with probability at most @xmath77 .",
    "hence , the total probability that the verifier accepts may not exceed @xmath78 .",
    "since the error probability of the protocol depends on the size of @xmath33 , @xmath33 may be chosen sufficiently large at the start of the protocol .",
    "it will be convenient for us to take @xmath33 to be the field with @xmath79 elements for @xmath8 polynomial in @xmath80 ( hence yielding exponentially small probability of error ) .",
    "for any chosen @xmath8 , the verifier ( and honest prover ) may use a deterministic procedure to implement arithmetic in , compute an irreducible polynomial @xmath81 of degree @xmath8 over @xmath82 in deterministic polynomial time @xcite , identify elements of @xmath33 with polynomials over @xmath82 of degree at most @xmath83 , and take arithmetic to be the usual arithmetic on polynomials modulo @xmath81 .",
    "there is thus a natural correspondence between @xmath8 bit strings and elements of @xmath33 .",
    "we now describe the verifier s protocol for our 2-round quantum interactive proof system for the qbf problem .",
    "we use the following conventions when describing the quantum circuits corresponding to the verifier s actions .",
    "collections of qubits upon which various transformations are performed are referred to as registers , and are labeled by capital letters in boldface .",
    "the registers required by the protocol are @xmath84 , @xmath85 , and @xmath86 for @xmath87 and @xmath88 , where @xmath89 is as in the classical protocol described in section  [ sec : classical ] and @xmath90 is some polynomial in @xmath80 specified depending on the desired error as described below .",
    "each register @xmath84 and @xmath85 consists of @xmath8 qubits , where @xmath79 is to be the size of the field @xmath33 .",
    "we view the classical states of these registers as elements in @xmath33 in the usual way .",
    "each @xmath86 consists of @xmath91 collections of @xmath8 qubits , for @xmath35 as in the classical protocol , and we view the classical states of these registers as polynomials of degree at most @xmath35 with coefficients in @xmath33 .",
    "the verifier may also use any polynomial number of additional ancilla qubits in order to perform the transformations described .",
    "in addition , the verifier will store the vector @xmath92 and any auxiliary variables needed for the protocol  as there will be no need for the verifier to perform quantum operations on these values , we consider them as being stored classically ( although there is no difference in the behavior of the protocol if they are thought of as being stored in quantum registers ) .",
    "the error probability of the protocol will depend on @xmath90 and @xmath8 as described below in section  [ sec : proof]we may take @xmath90 and @xmath8 to be fixed polynomials in @xmath80 to obtain exponentially small error",
    ".    it will be convenient to refer to certain collections of the quantum registers mentioned above ; for a given vector @xmath93 we let @xmath94 be the collection of registers @xmath95 for @xmath96 , and we let @xmath97 be the collection of registers @xmath98 for @xmath96 . see figure  [ fig : registers ] for an example .",
    "we also let @xmath99 and @xmath100 denote the vectors @xmath101 and @xmath102 , respectively .",
    "the verifier s protocol is described in figure  [ fig : qips_for_qbf ] .    ' '' ''    6 mm    receive quantum registers @xmath103 and @xmath104 from the prover .",
    "reject if @xmath105 contain an invalid proof that the input formula @xmath36 evaluates to true for any @xmath106 .",
    "choose @xmath107 uniformly at random and send @xmath92 and @xmath108 to the prover .",
    "receive @xmath109 from the prover and subtract @xmath110 from @xmath111 for each @xmath112 .",
    "apply transformation @xmath113 to each register of @xmath114 .",
    "if @xmath114 now contains only 0 values , then accept , otherwise reject .    ' '' ''    the check in step 1 refers to the classical protocol described in section  [ sec : classical ] .",
    "naturally this check is performed by reversibly computing the predicate @xmath46 ( described in section  [ sec : classical ] ) , so as not to alter superpositions of valid pairs @xmath115 .",
    "the transformation @xmath113 in step 4 is the walsh - hadamard transform applied to each qubit of the register in question , where @xmath116 as usual .",
    "the random choice of the vector @xmath92 in step 2 can be simulated efficiently with negligible error using the walsh - hadamard transform appropriately .",
    "( note that this negligible error will not change the fact that the protocol has one - sided error . )",
    "we now prove that the above protocol is correct .",
    "first we show that there exists an honest prover @xmath2 such that @xmath13 accepts with certainty whenever the input formula @xmath36 evaluates to true .    given qbf @xmath36 and @xmath117 matrix @xmath118 of elements in @xmath33 ,",
    "let @xmath119 denote the corresponding matrix of correct polynomials as defined in section  [ sec : classical ] .",
    "for each @xmath120 , @xmath121 is thus the sequence of polynomials the honest prover returns in the classical protocol given random numbers @xmath122 .",
    "the honest ( quantum ) prover first prepares superposition @xmath123 in registers @xmath103 and @xmath104 , adds the contents of each register @xmath124 to @xmath125 , and sends @xmath103 and @xmath104 to the verifier . under",
    "the assumption @xmath36 is true , each pair @xmath126 the verifier receives is a valid pair with respect to the classical protocol , so the verifier will not reject in step 1 .",
    "the behavior of the honest prover in the second round is as follows . for each @xmath112 ,",
    "let @xmath127 be a unitary transformation such that @xmath128 upon receiving @xmath92 and @xmath108 in the second round , the prover applies transformation @xmath129 to @xmath130 together with @xmath131 for each appropriate pair @xmath112 .",
    "this returns each register of @xmath108 to its initial zero value .",
    "the prover then sends @xmath130 to the verifier .",
    "it may be checked that after subtracting each @xmath124 from @xmath125 , the registers @xmath114 will not be entangled with any other registers ( as each register of @xmath132 depends only on those of @xmath133 ) , and are in a uniform superposition over all possible values .",
    "thus , each register of @xmath114 is put into state 0 during step 4 , and hence the verifier accepts with certainty .",
    "now we show that the verifier accepts with exponentially small probability in case @xmath36 is false , given any prover .",
    "we begin by examining the total state of the prover and verifier as the protocol is executed . in step 1",
    "the prover sends registers @xmath103 and @xmath104 to the verifier .",
    "the state of the system at this point may be expressed as @xmath134 where each @xmath135 is a complex number and @xmath136 is a normalized vector representing the state of the prover s ancilla registers ( which may be entangled with @xmath103 and @xmath104 in any manner the prover chooses ) .",
    "since the verifier rejects any pair @xmath137 for which each @xmath126 is not a valid proof that @xmath36 is true , we may assume @xmath138 is a superposition over such valid pairs for the purposes of bounding the probability that the verifier accepts .    at this point ,",
    "let us associate with each register @xmath84 and each register @xmath86 a random variable .",
    "the probabilities with which each random variable takes a particular value is precisely the probability that an observation of the associated register yields the given value , assuming that the observation takes place while the entire system is in state @xmath138 above . as we have done above for registers , we may consider collections of random variables as being single random variables , abbreviated by @xmath94 , @xmath97 , etc .",
    "for example , @xmath139 \\:=\\ : \\left\\|\\sum_{\\overline{f}{}^{(u ) } } \\alpha(r , f){| \\overline{f}{}^{(u)}\\rangle}{| \\xi(r , f)\\rangle}\\right\\|^2.\\ ] ] we also define a number of events based on these random variables .",
    "recall the definition of @xmath119 from above ( i.e. , @xmath119 is the @xmath117 matrix of correct polynomials an honest prover answers for given @xmath118 ) . for @xmath87 and @xmath140 , define @xmath141 to be the event that @xmath142 does not contain @xmath143 for @xmath144 and @xmath145 does contain @xmath146 , for @xmath118 denoting the contents of @xmath103 . for @xmath87 , define @xmath147 to be the event that @xmath142 does not contain @xmath143 for every @xmath148 . note that we must have @xmath149 = 1 $ ] for each @xmath120 , as the verifier surely rejects in step 1 if @xmath150 contains @xmath151 . finally , for each @xmath152 define events @xmath153 and @xmath154 as @xmath155 and @xmath156 .",
    "in step 2 the verifier chooses @xmath92 randomly and sends @xmath92 and @xmath108 to the prover .",
    "the prover applies some transformation to its registers ( now including @xmath108 ) , sends some register @xmath109 to the verifier , and the verifier subtracts the contents of @xmath103 from @xmath109 .",
    "the state of the system may now be described by @xmath157 where each @xmath158 is a complex number and @xmath159 is a normalized vector describing the state of the prover s registers as well as register @xmath109 .",
    "the verifier now executes step 4 . assuming for now that @xmath92 is fixed , this results in acceptance with probability @xmath160 where @xmath161 denotes the number of registers to which @xmath113 was applied , i.e. , @xmath162 . by the triangle inequality ,",
    "this probability is at most @xmath163    we now derive an upper bound on ( [ eq : prob_bound1 ] ) by considering the random variables defined above .",
    "first , we state a definition and prove a lemma regarding this definition that will be useful for this task .",
    "[ def : theta ] for any nonempty , finite set @xmath164 and mapping @xmath165 , define @xmath166    [ lemma : theta ] let @xmath167 satisfy @xmath168 and @xmath169 , let @xmath170 $ ] , and let @xmath171",
    ". then @xmath172    * proof .",
    "* first note that for any set @xmath173 and function @xmath174 with @xmath175 , we have @xmath176 by the cauchy - schwarz inequality , and hence @xmath177 .",
    "now define @xmath178 .",
    "we have @xmath179 thus @xmath180 as claimed .",
    "now , note that @xmath181\\ ] ] for each @xmath118 and @xmath182 ; the actions of the prover and verifier are norm - preserving , and hence will not affect the probabilities corresponding to each @xmath118 and @xmath182 . thus ( [ eq : prob_bound1 ] ) may be rewritten @xmath183 } \\right)^2.\\ ] ] for each pair @xmath184 , define a mapping @xmath185 $ ] as follows : @xmath186.\\ ] ] the probability in ( [ eq : prob_bound2 ] ) may be written as @xmath187\\theta_{\\mathbb{f}^{\\,l } } ( x_{r^{(u)},f^{(u)}}).\\ ] ] define @xmath188 $ ] and @xmath189 $ ] as follows : @xmath190,\\\\[2 mm ] z_{r^{(u)},f^{(u)}}\\left(\\overline{r}{}^{(u)}\\right ) & = & \\mathrm{pr}\\left[\\left.\\overline{\\mathbf{r}}{}^{(u)}= \\overline{r}{}^{(u)}\\right|\\mathbf{r}^{(u)}=r^{(u)},\\,\\mathbf{f}^{(u)}= f^{(u)},\\,\\neg b_u\\right],\\end{aligned}\\ ] ] for events @xmath191 and @xmath192 defined previously .",
    "we have @xmath193 for @xmath194 $ ] .",
    "now consider the values of @xmath195 for which @xmath196 ; we claim the number of such values is at least @xmath197 for every @xmath184 .",
    "this may be argued as follows .",
    "first , fix values for @xmath198 , @xmath182 , and @xmath120 , and assume event @xmath199 takes place . by the properties of the classical protocol discussed in section  [ sec : classical ] ,",
    "there are at most @xmath35 values of @xmath200 that do not cause the classical protocol to reject in this case .",
    "thus , the number of values of @xmath195 for which @xmath201\\not=0\\ ] ] is at most @xmath202 . since we have @xmath203,\\ ] ] the total number of values of @xmath195 for which @xmath204 is at most @xmath205 .",
    "now we may apply lemma  [ lemma : theta ] to obtain @xmath206\\,\\left(1-dm2^{-k}\\right ) + 2\\sqrt{dm2^{-k}},\\ ] ] and hence @xmath207\\theta_{\\mathbb{f}^{\\,l } } \\left(x_{r^{(u)},f^{(u)}}\\right ) \\:\\leq\\ :   1-\\mathrm{pr}[b_u]\\,\\left(1-dm2^{-k}\\right ) + 2\\sqrt{dm2^{-k}}. \\label{eq : prob_bound4}\\ ] ]    it remains to bound ( [ eq : prob_bound4 ] ) , given that @xmath92 is chosen uniformly from @xmath208 .",
    "let @xmath209 denote the random variable corresponding to the verifier s choice of @xmath92 .",
    "we bound @xmath210 $ ] by conditioning on the events @xmath154 that describe the exact places where the prover tries to `` sneak in '' the correct polynomials .",
    "specifically , we have @xmath211 \\:=\\ : \\sum_u\\mathrm{pr}[b_u]\\,\\mathrm{pr}[u = u ] \\ : = \\ : n^{-m}\\sum_{u , v}\\mathrm{pr}[b_u|d_v]\\,\\mathrm{pr}[d_v ] \\\\ = \\ : n^{-m}\\sum_v\\left(n^m - ( n-1)^m\\right)\\,\\mathrm{pr}[d_v ] \\ : = \\ : 1 - \\left(1 - \\frac{1}{n}\\right)^m \\:>\\ : 1 - e^{-m / n}.\\end{gathered}\\ ] ] thus , the overall probability that the verifier accepts is at most @xmath212 by initially choosing @xmath90 and @xmath8 to be sufficiently fast growing polynomials in the input size @xmath213 ( e.g. , @xmath214 and @xmath215 ) , this probability may be made smaller than @xmath216 , which completes the proof .",
    "we have defined in this paper a natural quantum analogue of the notion of an interactive proof system , and proved that there exist 2-round quantum interactive proof systems with exponentially small error for any pspace language .",
    "we do not know if constant - round quantum interactive proofs characterize pspace , or if there are such proof systems for ( presumably ) larger classes ( e.g. , does nexp have constant - round quantum interactive proofs ? ) .",
    "we have investigated neither the polynomial round case nor the @xmath8-round case for @xmath217 ; what languages have such quantum proof systems ?",
    "several variants on interactive proof systems have been studied , such as multiprover interactive proofs @xcite , probabilistically checkable proofs @xcite , and interactive proof systems having verifiers with very limited computing power @xcite .",
    "how do quantum analogues of these models compare with their classical counterparts ?",
    "m.  ben - or , s.  goldwasser , j.  kilian , and a.  wigderson .",
    "multi - prover interactive proofs : how to remove intractability assumptions . in _ proceedings of the twentieth annual acm symposium on the theory of computing _ ,",
    "pages 113131 , 1988 .    c.  h. bennett and g.  brassard .",
    "quantum cryptography : public key distribution and coin tossing . in _ proceedings of the ieee international conference on computers , systems , and",
    "signal processing _ ,",
    "pages 175179 , 1984 .",
    "s.  goldwasser and m.  sipser .",
    "private coins versus public coins in interactive proof systems . in s.",
    "micali , editor , _ randomness and computation _ , volume  5 of _ advances in computing research _ , pages 7390 .",
    "jai press , 1989 .    c.  lund , l.  fortnow , h.  karloff , and n.  nisan .",
    "algebraic methods for interactive proof systems . , 39(4):859868 , 1992 .",
    "a preliminary version appeared in _ proceedings of the 31st annual symposium on foundations of computer science _ ,",
    "pages 210 , 1990 .",
    "d.  mayers .",
    "quantum key distribution and string oblivious transfer in noisy channels . in _ advances in cryptology : proceedings of crypto96 _ , volume 1109 of _ lecture notes in computer science _ , pages 343357 .",
    "springer - verlag , 1996 ."
  ],
  "abstract_text": [
    "<S> in this paper we consider quantum interactive proof systems , i.e. , interactive proof systems in which the prover and verifier may perform quantum computations and exchange quantum messages . </S>",
    "<S> it is proved that every language in pspace has a quantum interactive proof system that requires only two rounds of communication between the prover and verifier , while having exponentially small ( one - sided ) probability of error . </S>",
    "<S> it follows that quantum interactive proof systems are strictly more powerful than classical interactive proof systems in the constant - round case unless the polynomial time hierarchy collapses to the second level . </S>"
  ]
}