{
  "article_text": [
    "the networks under study in natural and social sciences often show a natural divisibility into smaller modules ( or communities ) originating from an inherent , coarse - grained structure . in general ,",
    "these modules are characterized by an abundance of edges connecting the vertices within individual communities in comparison to the number of edges linking the modules .    to detect these partitions several algorithm- or score - based approaches",
    "have been developed and applied .",
    "very popular became the approach introduced by girvan and newman @xcite based on the quality function called `` modularity '' for partition assessment .",
    "this scoring function compares the actual fraction of intracommunity edges with its expectation in the random case given an identical degree distribution .",
    "the partition with the highest value of the scoring function is then considered to be the optimal splitting . the modularity @xmath0 is defined ( for undirected networks ) as @xmath1\\ ] ] with @xmath2 the weights of all edges linking pairs of vertices in community @xmath3 , @xmath4 the sum over all degrees of vertices in module @xmath3 , @xmath5 the total weight of all edges , and @xmath6 the number of communities .",
    "intrinsically , the modularity based approach does not prescribe the usage of a particular optimization procedure . in practice",
    ", a strategy for optimization has to be chosen .",
    "the modularity optimization is a np - hard problem @xcite .",
    "therefore , only an exhaustive search reveals the optimal solution for a generic network .",
    "this type of search is extremely demanding and only in a few cases feasible .",
    "thus , many heuristic approaches such as extremal optimization @xcite , simulated annealing @xcite , and the greedy algorithm @xcite have been developed , refined , and successfully applied . among the published",
    "approaches the greedy algorithm is one of the fastest techniques @xcite . on the other hand , many examples show that the greedy algorithm is not capable of finding the solutions with the highest modularity value .",
    "furthermore , recent studies have provided evidence that modularity @xcite and potts model based approaches @xcite are endowed with an intrinsic resolution limit ( small modules are not detected and amalgamated into bigger ones ) .",
    "thus , each community has to be refined by subduing it as a separate network to the community detection algorithm .",
    "therefore , a fast and accurate optimization technique is necessary .    in this article",
    ", we enhance the greedy algorithm by a multistep feature in combination with a local refinement procedure .",
    "the enhanced algorithm finds partitions with higher modularity values than previously reported .",
    "this paper is organized as follows . in sec .",
    "[ algorithm ] we introduce both procedures and describe the motivation for their construction .",
    "in addition , we discuss performance oriented implementations and estimate their running times . benchmarking results for a set of real - world networks and a comparison with other published results are presented in sec .",
    "[ benchmarks ] .",
    "the conclusions are in sec .",
    "[ conclusions ] . in this paper ,",
    "all networks are considered as undirected .",
    "the extension to directed networks is straightforward .    ' '' ''",
    "each vertex is a community calculate the modularity change matrix @xmath7 determine the community degrees @xmath4 mergecommunities(i , j )    ' '' ''",
    "the classical greedy algorithm ( first application in ref .",
    "@xcite ) joins iteratively the pair of communities that improves modularity most in each step .",
    "the essential idea of the `` multistep greedy '' algorithm ( msg ) is to promote the simultaneous merging of several pairs of communities at each iteration .",
    "the pseudocode of the msg algorithm is presented in algorithms [ concept ] and [ details ] , and an illustrative example is given in fig .",
    "[ example ] .",
    "the msg - algorithm starts with each vertex separated in its own community . at each iteration",
    "the modularity change @xmath8 upon merge of each pair of connected communities @xmath9 is calculated ( while nonconnected pairs are ignored because their merging yields a negative modularity change ) .",
    "the triplets @xmath10 are parsed in the order of decreasing @xmath7-value and increasing community index .",
    "those community pairs @xmath9 are joined which fulfill the following two criteria :    1 .",
    "the modularity change @xmath8 is within the @xmath11 most favorable values ( levels ) and positive .",
    "`` touched - community - exclusion - rule '' ( tcer ) : neither module @xmath3 nor @xmath12 is present in another pair inducing a higher modularity change .    convergence is reached when all pairwise merges of communities decrease modularity ( by induction one can prove that all merges in further iterations would decrease modularity ) .",
    "a _ level _ encompasses all triplets @xmath10 with equal @xmath8-value and the _ level parameter _",
    "@xmath11 is kept constant . by construction",
    "the level parameter is always smaller than the number of edges in the network .",
    "the multiple levels promote the concurrent formation of multiple centers .",
    "simultaneously growing community centers hinder the condensation into few large communities ( few formed communities scrape all vertices as the establishment of a new community is too expensive in modularity ) as observed in the classical greedy algorithm .",
    "the tcer is a second mean against excessive aggregation into few large modules .",
    "this rule permits the addition of only one community to an existing community per algorithm iteration .",
    "furthermore , the tcer guarantees that the modularity change upon all performed merges is just the sum over the corresponding @xmath7 elements which improves efficiency .",
    "the key observation for an efficient implementation of the msg is the following : upon merge of communities @xmath3 and @xmath12 only those @xmath7-elements concerning either of the two modules have to be recalculated .",
    "when the modules @xmath3 and @xmath12 are joined into a new one called @xmath13 , the updated modularity changes @xmath14 ( module @xmath15 is connected either to community @xmath3 or @xmath12 ) reads ( see sec .",
    "ii in ref .",
    "@xcite for details ) @xmath16 with @xmath17 the sum over all degrees of vertices in community @xmath18 and @xmath5 the total edge weight .",
    "further efficiency improvements are gained from an appropriate choice of data structures .",
    "a _ set _ ( implementation taken from the c++-stl - library ) is a sorted binary search tree . in a set individual elements",
    "can be found or inserted in @xmath19 time ( @xmath20 the number of elements ) and the extremal entries are found in constant time .",
    "the modularity changes are stored in the _ @xmath7 _ matrix implemented as vector of row structures .",
    "the @xmath3th row consists of a set with elements @xmath21 ( @xmath12 a module linked to the community @xmath3 ) ordered according to the community index @xmath12 .",
    "this data structure obsoletes a separate storage of the topology information .",
    "the extraction of the best @xmath11 modularity changes is handled via the _ level set_. for each pair of connected communities @xmath3 and @xmath12 the element @xmath22 is added to the _ level set_. the _ level - set _ elements are sorted with respect to decreasing @xmath7 and increasing index values .",
    "the degree information is stored in a vector henceforth named _",
    "d_. in each iteration a boolean vector called _ touched _ stores whether a community has already been modified in the same round . to save the time to determine the highest index of a present communities",
    ", the number of vertices ( initial length ) is chosen as length of the _ touched _ vector .    ' '' ''    each vertex is a community calculate community degrees @xmath23 and the @xmath7 matrix determine the initial modularity @xmath24 _ level set _",
    "@xmath25 set of @xmath7 elements @xmath10 , sorted with respect to decreasing @xmath7 and increasing @xmath26    @xmath27 boolean , @xmath28-dimensional vector ( @xmath29 no .",
    "vertices ) @xmath30 subset of _ level - set _",
    "elements @xmath10 with @xmath31 and @xmath8 among highest @xmath11 values    @xmath32 @xmath33 update the _ level set _ update the modularity @xmath34 empty @xmath35 flag @xmath36 update degrees : @xmath37    ' '' ''    the implementation details of the msg algorithm are listed in algorithm [ details ] .",
    "the calculation of the community degrees involves one parse of the edge information . in the second parse of the edge information the @xmath7 matrix and the _ level set _",
    "is filled . the initial modularity change @xmath8 upon join of modules ( at this stage the vertices ) @xmath3 and @xmath12 is calculated as ( see sec .",
    "ii in ref .",
    "@xcite for details ) @xmath38 with @xmath13 the weight of the edges connecting the vertices @xmath3 and @xmath12 , @xmath39 the degree of vertex @xmath18 , and @xmath5 the total edge weight .",
    "the modularity value of the initial partition is ( @xmath28 the number of vertices ) @xmath40 the algorithm iteration starts by initializing the _ touched _ vector .",
    "subsequently , the _ level_-set is parsed and all elements with positive @xmath7 value , whose modularity change is among the best @xmath11 ( external _ level parameter _ ) different values , are stored in a set named _ mp _ conserving the order of the _ level set_. in this order the module pairs are merged unless one of them was part of a amalgamation in the same algorithm iteration . in the merge process ,",
    "the changed @xmath7 matrix elements are calculated as described at the beginning of this paragraph . to determine which case applies in eq .",
    "( [ merge - equation ] ) the fact that each row of the @xmath7 matrix is ordered with respect to the community index can be used .",
    "more precisely , parse for the merge of modules @xmath3 and @xmath12 the corresponding rows concurrently . for each row",
    "define an momentarily considered element @xmath41 . if the community index of @xmath42 is equal to the one of @xmath43 , the first case applies and advance both @xmath41 s to the next element in the corresponding row .",
    "if the index @xmath15 of @xmath42 is lower than the one of @xmath43 calculate the @xmath14 element ( @xmath13 the name of the merged community ) according to the second case and advance ( if possible ) only @xmath42 .",
    "if the module index of @xmath42 is larger than the one of @xmath43 , proceed analogously .",
    "if one @xmath41 reaches the end of the row , merge the remaining elements of the other row according to the respective rule .",
    "this procedure will be called `` asynchronous parsing '' in sec .",
    "[ complexity - msg ] .",
    "it is customary to update each @xmath7 element after calculation . to complete the merge process it remains to update the community degrees and to flag the modified communities in the _ touched _ vector",
    ".      as we adopted the modularity change calculation of clauset et al .",
    "ii in ref .",
    "@xcite ) we can adopt their method of running time estimation as well .",
    "first , we observe that the update of one element in the @xmath7 matrix and the _ level set _ costs in the worst case @xmath44 ( insertion in set , each community has at most @xmath28 neighbors with @xmath28 the number of vertices ) and @xmath45 running time ( the number of distinct edges @xmath46 is bounded by the square of the number of vertices @xmath47 ) , respectively .    merging",
    "communities @xmath3 and @xmath12 involves an update of the @xmath7 matrix and the _ level set _ for each element of the corresponding rows of the @xmath7 matrix .",
    "the calculation of each changed value can be achieved in constant time as during the asynchronous parsing it is known whether the other community is linked as well and all other information ( community degrees ) is stored in a vector .",
    "thus , the total running time contribution of one merging event is @xmath48 with @xmath49 the number of edge starts / ends on vertices of community @xmath50 . in the worst case all communities are changed in one algorithm round . as the sum over all @xmath4 values is twice the number of distinct edges , the contribution of the merging processes in one algorithm round is at most @xmath51 .",
    "the other steps of one algorithm round are less consumptive : the extraction of pairs belonging to the best @xmath11 levels can be performed in constant time .",
    "the same is true for the update of the degree information .",
    "if @xmath52 is defined as the depth of the dendrogram of communities , at most @xmath52 algorithm rounds have to be performed .",
    "thus , the running time expectation for the iterative part is @xmath53 which is identical to the complexity of the classical greedy algorithm @xcite .",
    "the initialization involves the read - in processes of the edge information ( @xmath46 constant time operations ) , the degree calculation ( part of read - in process ) , the calculation of the initial modularity ( constant time operation on @xmath28 elements ) and finally the generation of the @xmath7 matrix and the _ level set _ at costs @xmath51 ( @xmath46 insertions in a set with at most @xmath28 or @xmath46 elements , respectively ) . in the worst case",
    "the expected contribution of the initialization to the running time is @xmath51 .    in the precedent paragraphs",
    "we have shown that the msg greedy algorithm has the total complexity @xmath53 . among the published strategies for modularity",
    "optimization the classical greedy algorithm @xcite is the fastest @xcite .",
    "as the msg shares the worst case expectation for the running time with the classical greedy algorithm , we conclude that the msg is one of the fastest procedures for modularity optimization .      to further improve modularity by `` adjusting '' misplaced vertices , a refinement step called `` vertex mover '' ( vm )",
    "is applied upon convergence of the msg algorithm . in principle , it could also be applied to other modularity optimization procedures . in the vm ,",
    "the list of vertices is parsed in the order of increasing degree and vertex index ( to resolve the degeneracy of multiple vertices with equal degree ) and every vertex is reassigned to the neighboring community with maximal modularity improvement .",
    "this parsing - and - reassignment procedure is repeated until no modularity improvement is observed .",
    "the vm procedure is similar to the kernighan - lin algorithm @xcite ( applied to modularity optimization in ref .",
    "in contrast to the kernighan - lin algorithm the vm procedure has a perfectly local focus .",
    "in other words , instead of repetitively searching for the optimal vertex to reassign , the vm procedure parses the vertices in the aforementioned order and identifies the optimal community for the considered vertex .",
    "furthermore , each reassignment of the vm approach improves modularity .",
    "therefore , the selection of the optimal intermediate partition as in the kernighan - lin algorithm is not necessary .    [ cols=\"^ \" , ]",
    "for benchmarking algorithms that optimize modularity the networks commonly used are the collaboration network ( coauthorships in cond - mat articles ) @xcite , the graph of metabolic reactions in _ caenorhabitis elegans _",
    "@xcite , the email network @xcite , the network of mutual trust ( pgp - key signing ) @xcite , the conference graph of college football teams @xcite , the network of jazz groups with common musicians @xcite and the zachary karate club example @xcite .",
    "in addition , we include less frequently used examples such as the graph of the metabolic reactions in _ escherichia coli _ @xcite , two different data set describing the protein - protein interactions in s. cerevisiae ( budding yeast ) @xcite with labels `` ppi '' and `` yeast . '' to cover linguistic applications we benchmark the word association network @xcite and the graph of the co - appearing words in publication titles ( co)authored by martin karplus @xcite who has the third highest @xmath54-factor @xcite among chemists @xcite . further aspects of social webs were incorporated by considering the graph of costarring actors in the imdb database @xcite .",
    "noticeable , the actor network - being the network with the largest number of edges - serves as a proof of concept for such big networks being treatable as well . from computer science",
    "we include the internet routing network @xcite and the graph of world wide web pages @xcite . with this selection of networks",
    "most currently known application fields of networks are covered . to study the effect of disconnected graphs and weighted networks , we consider in both cases the full network as well as the largest connected component ( suffix `` cp '' ) and the unweighted variant , respectively . unless stated otherwise the networks are treated unweighted .",
    "it is important to investigate the robustness upon the choice of @xmath11 and to determine the highest modularity values achievable with the msg - vm algorithm .",
    "there is a minor dependence on the value of @xmath11 ( fig .",
    "[ profiles ] ) which changes the msg - vm modularity by less than 2 % for large networks .",
    "moreover , the maximal modularity is obtained with @xmath55 for 14 of the 19 networks ( table [ real - world ] ) .",
    "an empirical formula for the optimal choice of the level parameter will be presented elsewhere .",
    "noteworthily , for a labeled graph and a chosen level parameter the algorithm is deterministic . to assess the contribution of the labeling",
    ", the benchmarking procedure is performed also on hundred copies of the smallest ten networks with permuted vertex labels .",
    "this permutation leaves the topology invariant , but modifies the order in which the community pairs are considered . in comparison to the maximal modularity value found for the unscrambled variants a maximal improvement of 0.94 %",
    "is observed .",
    "the modularity values obtained with the msg - vm approach are listed in table [ performance - comparision ] . for five of the seven networks considered here",
    "the msg - vm algorithm finds solutions with modularity higher than previously published . only for the zachary karate network",
    "the msg - vm procedure yields a smaller modularity value . for the jazz network",
    "a solution with the identical @xmath0 value is obtained . for the networks",
    "without published modularity values we compare the optimal values obtained by the msg - vm algorithm with the classical greedy algorithm for modularity optimization as introduced by newman @xcite in table [ real - world ] .",
    "we observe that the msg - vm algorithm outperforms the original greedy algorithm significantly .",
    "the running time estimations in secs .",
    "[ complexity - msg ] and [ complexity - vm ] are based on a worst case scenario . to investigate the running time behavior on real - world examples , we compare the running times of the classical greedy variant and the msg - vm algorithm in table [ real - world ] .",
    "these data show that given the appropriate level parameter choice the msg - vm algorithm is in almost all cases faster than the classical greedy algorithm and , at the same time , reaches a higher value of modularity .",
    "to prevent premature condensation into few large communities the greedy algorithm for modularity optimization has been extended by a procedure for simultaneous merging of more than one pair of communities at each step .",
    "furthermore , this `` multistep '' greedy variant has been combined with a simple vertex - by - vertex a posteriori refinement . on seven networks with previously published modularity values",
    "the msg - vm algorithm combination outperforms all other frequently used , generic techniques except for the smallest of the seven examples .",
    "in addition , a single run of the msg - vm algorithm requires similar computer time as the greedy algorithm . in most cases",
    "less than 10 independent ( i.e. , embarrassingly parallel ) runs of msg - vm are required to obtain a modularity within 1 % of the highest value because an empirical formula has been derived for the appropriate choice of the optimal step - width .",
    "therefore , the msg - vm algorithm is an efficient tool to find network partitions with high modularity .",
    "the authors thank stefanie muff and francesco rao for helpful discussions .",
    "christian bolliger , thorsten steenbock , and dr .",
    "alexander godknecht are acknowledged for maintaining the matterhorn cluster where most of the parameter studies were performed .",
    "we are thankful to drs .",
    "arenas , barabsi , gleiser , and newman for providing the network data .",
    "this work was supported by a swiss national science foundation grant to a.c ."
  ],
  "abstract_text": [
    "<S> identifying strongly connected substructures in large networks provides insight into their coarse - grained organization . </S>",
    "<S> several approaches based on the optimization of a quality function , e.g. , the modularity , have been proposed . </S>",
    "<S> we present here a multistep extension of the greedy algorithm ( msg ) that allows the merging of more than one pair of communities at each iteration step . </S>",
    "<S> the essential idea is to prevent the premature condensation into few large communities . upon convergence of the msg </S>",
    "<S> a simple refinement procedure called `` vertex mover '' ( vm ) is used for reassigning vertices to neighboring communities to improve the final modularity value . with an appropriate choice of the step width , </S>",
    "<S> the combined msg - vm algorithm is able to find solutions of higher modularity than those reported previously . </S>",
    "<S> the multistep extension does not alter the scaling of computational cost of the greedy algorithm . </S>"
  ]
}