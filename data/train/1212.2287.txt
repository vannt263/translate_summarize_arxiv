{
  "article_text": [
    "recent studies have shown that machine - learned tree - based models , combined with ensemble techniques , are highly effective for building web ranking algorithms  @xcite within the `` learning to rank '' framework  @xcite . beyond document retrieval ,",
    "tree - based models have also been proven effective for tackling problems in diverse domains such as online advertising  @xcite , medical diagnosis  @xcite , genomic analysis  @xcite , and computer vision  @xcite .",
    "this paper focuses on runtime optimizations of tree - based models that take advantage of modern processor architectures :  we assume that a model has already been trained , and now we wish to make predictions on new data as fast as possible .",
    "although exceedingly simple , tree - based models do not efficiently utilize modern processor architectures due to the prodigious amount of branches and non - local memory references in standard implementations . by laying out data structures in memory in a more cache - conscious fashion , removing branches from the execution flow using a technique called predication , and micro - batching predictions using a technique called vectorization , we are able to better exploit modern processor architectures and significantly improve the speed of tree - based models over hard - coded if - else blocks .",
    "our experimental results are measured in nanoseconds for individual trees and microseconds for complete ensembles .",
    "a natural starting question is :  do such low - level optimizations actually matter ?",
    "does shaving microseconds off an algorithm have substantive impact on a real - world task ?",
    "we argue that the answer is _ yes _",
    ", with two different motivating examples :  first , in our primary application of learning to rank for web search , prediction by tree - based models forms the inner loop of a search engine . since",
    "commercial search engines receive billions of queries per day , improving this tight inner loop ( executed , perhaps , many billions of times ) can have a noticeable effect on the bottom line .",
    "faster prediction translates into fewer servers for the same query load , reducing datacenter footprint , electricity and cooling costs , etc .",
    "second , in the domain of financial engineering , every nanosecond counts in high frequency trading .",
    "orders on nasdaq are fulfilled in less than 40 microseconds .",
    "firms fight over the length of cables due to speed - of - light propagation delays , both within an individual datacenter and across oceans  @xcite .",
    "thus , for machine learning in financial engineering , models that shave even a few microseconds off prediction times present an edge .",
    "we view our work as having the following contributions :  first , we introduce the problem of _ architecture - conscious _ implementations of machine learning algorithms to the information retrieval and data mining communities . although similar work has long existed in the database community  @xcite , there is little research on the application of architecture - conscious optimizations for information retrieval and machine learning problems .",
    "second , we propose novel implementations of tree - based models that are highly - tuned to modern processor architectures , taking advantage of cache hierarchies and superscalar processors . finally , we illustrate our techniques in a standard , widely - accepted , learning - to - rank task and show significant performance improvements over standard implementations and hard - coded if - else blocks .",
    "we begin with an overview of modern processor architectures and recap advances over the past few decades .",
    "the broadest trend is perhaps the multi - core revolution  @xcite :  the relentless march of moore s law continues to increase the number of transistors on a chip exponentially , but experts widely agree that we are long past the point of diminishing returns in extracting instruction - level parallelism in hardware . instead , adding more cores appears to be a better use of increased transistor density .",
    "since prediction is an embarrassingly parallel problem , our techniques can ride the wave of increasing core counts .",
    "a less - discussed , but just as important trend over the past two decades is the so - called `` memory wall ''  @xcite , where increases in processor speed have far outpaced improvements in memory latency .",
    "this means that ram is becoming slower relative to the cpu . in the 1980s ,",
    "memory latencies were on the order of a few clock cycles ; today , it could be several hundred clock cycles . to hide this latency",
    ", computer architects have introduced hierarchical cache memories :  a typical server today will have l1 , l2 , and l3 caches between the processor and main memory .",
    "cache architectures are built on the assumption of reference locality  that at any given time , the processor repeatedly accesses only a ( relatively ) small amount of data , and these fit into cache .",
    "the fraction of memory accesses that can be fulfilled directly from the cache is called the _ cache hit rate _ , and data not found in cache is said to cause a _",
    "cache miss_. cache misses cascade down the hierarchy ",
    "if a datum is not found in l1 , the processor tries to look for it in l2 , then in l3 , and finally in main memory ( paying an increasing latency cost each level down ) .",
    "managing cache content is a complex challenge , but there are two main principles that are relevant to a software developer .",
    "first , caches are organized into cache lines ( typically 64 bytes ) , which is the smallest unit of transfer between cache levels . that is ,",
    "when a program accesses a particular memory location , the entire cache line is brought into ( l1 ) cache .",
    "this means that subsequent references to nearby memory locations are very fast , i.e. , a cache hit .",
    "therefore , in software it is worthwhile to organize data structures to take advantage of this fact .",
    "second , if a program accesses memory in a predictable sequential pattern ( called striding ) , the processor will prefetch memory blocks and move them into cache , before the program has explicitly requested the memory locations ( and in certain architectures , it is possible to explicitly control prefetch in software )",
    ". there is , of course , much more complexity beyond this short description ; see  @xcite for an overview .",
    "the database community has explored in depth the consequences of modern processor architectures for relational query processing  @xcite .",
    "in contrast , these issues are underexplored for information retrieval and data mining applications .",
    "this is one of the first attempts at developing architectural - conscious runtime implementations of machine learning algorithms .",
    "researchers have explored scaling the _ training _ of tree - based models to massive datasets  @xcite , which is of course an important problem , but orthogonal to the issue we tackle here :  given a trained model , how do we make predictions quickly ?",
    "another salient property of modern cpus is pipelining , where instruction execution is split between several stages ( modern processors have between one to two dozen stages ) . at each clock cycle , all instructions `` in flight '' advance one stage in the pipeline ; new instructions enter the pipeline and instructions that leave the pipeline are `` retired '' .",
    "pipeline stages allow faster clock rates since there is less to do per stage .",
    "superscalar _ cpus add the ability to dispatch multiple instructions per clock cycle ( and out of order ) provided that they are independent .",
    "pipelining suffers from two dangers , known as `` hazards '' in vlsi design terminology .",
    "_ data hazards _ occur when one instruction requires the result of another ( that is , a data dependency ) .",
    "this happens frequently when dereferencing pointers , where we must first compute the memory location to access .",
    "subsequent instructions can not proceed until we actually know what memory location we are accessing ",
    "the processor simply stalls waiting for the result ( unless there are other independent instructions that can be executed ) . _",
    "control hazards _ are instruction dependencies introduced by if - then clauses ( which compile to conditional jumps in assembly ) . to cope with this",
    ", modern processors use _ branch prediction techniques_in short , trying to predict which code path will be taken .",
    "however , if the guess is not correct , the processor must `` undo '' the instructions that occurred after the branch point ( `` flushing '' the pipeline )",
    ".    the impact of data and control hazards can be substantial :  an influential paper in 1999 concluded that in commercial rdbmses at the time , almost half of the execution time is spent on stalls  @xcite . which is `` worse '' , data or control hazards ?",
    "not surprisingly , the answer is , it depends . however , with a technique called predication  @xcite , which we explore in our work , it is possible to convert control dependencies into data dependencies ( see section  [ section : approach ] ) .",
    "whether predication is worthwhile , and under what circumstances , remains an empirical question .",
    "another optimization that we adopt , called vectorization , was pioneered by database researchers  @xcite :  the basic idea is that instead of processing a tuple at a time , a relational query engine should process a `` vector '' ( i.e. , batch ) of tuples at a time to take advantage of pipelining .",
    "our work represents the first application of vectorization to optimizing machine learning algorithms that we are aware of .    beyond processor architectures , the other area of relevant work is the vast literature on learning to rank  @xcite , application of machine learning techniques to document ranking in search .",
    "our work uses gradient - boosted regression trees ( gbrts )  @xcite , a state - of - the - art ensemble method .",
    "the focus of most learning - to - rank research is on learning effective models , without considering efficiency , although there is an emerging thread of work that attempts to better balance both factors  @xcite .",
    "in contrast , we focus exclusively on runtime ranking performance , assuming a model that has already been trained ( by other means ) .",
    "in this section we describe various implementations of tree - based models , starting from two baselines and progressively introducing architecture - conscious optimizations .",
    "we focus on an individual tree , the runtime execution of which involves checking a predicate in an interior node , following the left or right branch depending on the result of the predicate , and repeating until a leaf node is reached .",
    "we assume that the predicate at each node involves a feature and a threshold :  if the feature value is less than the threshold , the left branch is taken ; otherwise , the right branch is taken .",
    "of course , trees with greater branching factors and more complex predicate checks can be converted into an equivalent binary tree , so our formulation is general .",
    "note that our discussion is agnostic with respect to the predictor at the leaf node , be it a boolean ( in the classification case ) , a real ( in the regression case ) , or even an embedded sub - model .",
    "we assume that the input feature vector is densely - packed in a floating - point array ( as opposed to a sparse , map - based representation ) .",
    "this means that checking the predicate at each tree node is simply an array access , based on a unique consecutively - numbered i d associated with each feature .",
    "object : as a high - flexibility baseline , we consider an implementation of trees with nodes and associated left and right pointers in c++ .",
    "each tree node is represented by an object , and contains the feature i d to be examined as well as the decision threshold . for convenience , we refer to this as the object implementation . in our mind , this represents the most obvious implementation of tree - based models that a software engineer would come up with  and thus serves as a good point of comparison .",
    "this implementation has two advantages :  simplicity and flexibility .",
    "however , we have no control over the physical layout of the tree nodes in memory , and hence no guarantee that the data structures exhibit good reference locality . prediction with this implementation essentially boils down to pointer chasing across the heap :  when following either the left or the right pointer to the next tree node , the processor is likely to be stalled by a cache miss .",
    "codegen : as a high - performance baseline , we consider statically - generated if - else blocks .",
    "that is , a code generator takes a tree model and directly generates c code , which is then compiled and used to make predictions . for convenience",
    ", this is referred to as the codegen implementation .",
    "this represents the most obvious performance optimization that a software engineer would come up with , and thus serves as another good point for performance comparison .",
    "we expect this approach to be fast .",
    "the entire model is statically specified ; machines instructions are expected to be relatively compact and will fit into the instruction cache , thus exhibiting good reference locality .",
    "furthermore , we leverage decades of compiler optimizations that have been built into gcc . note that this eliminates data dependencies completely by converting them all into control dependencies .",
    "the downside , however , is that this approach is inflexible .",
    "the development cycle now requires more steps :  after training the model , we need to run the code generation , compile the resulting code , and then link against the rest of the system .",
    "this may be a worthwhile tradeoff for a production system , but from the view of rapid experimentation and iteration , the approach is a bit awkward .",
    "struct : the object approach has two downsides :  poor memory layout ( i.e. , no reference locality and hence cache misses ) and inefficient memory utilization ( due to object overhead ) . to address the second point ,",
    "the solution is fairly obvious :  get rid of c++ and drop down to c to avoid the object overhead .",
    "we can implement each node as a struct in c ( comprising feature i d , threshold , left and right pointers ) .",
    "we construct a tree by allocating memory for each node ( malloc ) and assigning the pointers appropriately .",
    "prediction with this implementation remains an exercise in pointer chasing , but now across more memory - efficient data structures .",
    "we refer to this as the struct implementation .",
    "struct@xmath0 : an improvement over the struct implementation is to physically manage the memory layout ourselves . instead of allocating memory for each node individually , we allocate memory for all the nodes at once ( i.e. , an array of structs ) and linearize the tree in the following way :  the root lies at index 0 .",
    "assuming a perfectly - balanced tree , for a node at index @xmath1 , its left child is at @xmath2 and its right child is at @xmath3 .",
    "this is equivalent to laying out the tree using a breadth - first traversal of the nodes .",
    "the hope is that by manually controlling memory layout , we can achieve better reference locality , thereby speeding up the memory references .",
    "this is similar to the idea behind css - trees  @xcite used in the database community . for convenience",
    "we call this the struct@xmath0 implementation",
    ".    one nice property of retaining the left and right pointers in this implementation is that for unbalanced trees ( i.e. , trees with missing nodes ) , we can more tightly pack the nodes to remove `` empty space '' ( still following the layout approach based on breadth - first node traversal ) .",
    "thus , the struct@xmath0 implementation occupies the same amount of memory as struct , except that the memory is contiguous .",
    "pred : the struct@xmath0 implementation tackles the reference locality problem , but there remains one more issue : the presence of branches ( resulting from the conditionals ) , which can be quite expensive to execute .",
    "branch mispredicts may cause pipeline stalls and wasted cycles ( and of course , we would expect many mispredicts with trees ) .",
    "although it is true that speculative execution renders the situation far more complex , removing branches may yield performance increases . a well - known trick in the compiler community for overcoming these issues is known as predication  @xcite .",
    "the underlying idea is to convert control dependencies ( hazards ) into data dependencies ( hazards ) , thus altogether avoiding jumps in the underlying assembly code .",
    "here is how predication is adapted for our case : we encode the tree as a struct array in c , nd , where nd[i].fid is the feature i d to examine , and nd[i].theta is the threshold .",
    "we assume a fully - branching binary tree , with nodes laid out via breadth - first traversal ( i.e. , for a node at index @xmath1 , its left child is at @xmath2 and its right child is at @xmath3 ) . to make the prediction",
    ", we probe the array in the following manner :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .... i = ( i<<1 ) + 1 + ( v[nd[i].fid ] > = nd[i].theta ) ; i = ( i<<1 ) + 1 + ( v[nd[i].fid ] > = nd[i].theta ) ;    ... .... _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    we completely unroll the tree traversal loop , so the above statement is repeated @xmath4 times for a tree of depth @xmath4 . at the end",
    ", @xmath1 contains the index of the leaf node corresponding to the prediction ( which we look up in another array ) .",
    "one final implementation detail :  we hard code a prediction function for each tree depth , and then dispatch dynamically using function pointers . note that this approach assumes a fully - balanced binary tree ; to cope with unbalanced trees , we expand by inserting dummy nodes .    vpred : predication eliminates branches but at the cost of introducing data hazards .",
    "each statement in pred requires an indirect memory reference .",
    "subsequent instructions can not execute until the contents of the memory locations are fetched  in other words , the processor will simply stall waiting for memory references to resolve .",
    "therefore , predication is entirely bottlenecked on memory access latencies",
    ".    a common technique adopted in the database literature to mask these memory latencies is called _ vectorization _  @xcite . applied to our task",
    ", this translates into operating on multiple instances ( feature vectors ) at once , in an interleaved way .",
    "this takes advantage of multiple dispatch and pipelining in modern processors ( provided that there are no dependencies between dispatched instructions , which is true in our case ) .",
    "so , while the processor is waiting for the memory access from the predication step on the first instance , it can start working on the second instance .",
    "in fact , we can work on @xmath5 instances in parallel .",
    "for @xmath6 , this looks like the following , working on instances i0 , i1 , i2 , i3 in parallel :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .... i0 = ( i0<<1 ) + 1 + ( v[nd[i0].fid ] > = nd[i0].theta ) ; i1 = ( i1<<1 ) + 1 + ( v[nd[i1].fid ] > = nd[i1].theta ) ; i2 = ( i2<<1 ) + 1 + ( v[nd[i2].fid ] >",
    "= nd[i2].theta ) ; i3 = ( i3<<1 ) + 1 + ( v[nd[i3].fid ]",
    "> = nd[i3].theta ) ;    i0 = ( i0<<1 ) + 1 + ( v[nd[i0].fid ] > = nd[i0].theta ) ; i1 = ( i1<<1 ) + 1 + ( v[nd[i1].fid ] >",
    "= nd[i1].theta ) ; i2 = ( i2<<1 ) + 1 + ( v[nd[i2].fid ]",
    "> = nd[i2].theta ) ; i3 = ( i3<<1 ) + 1 + ( v[nd[i3].fid ] > = nd[i3].theta ) ;    ... .... _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    in other words , we traverse one layer in the tree for four instances at once . while we re waiting for v[nd[i0].fid ] to resolve , we dispatch instructions for accessing v[nd[i1].fid ] , and so on .",
    "hopefully , by the time the final memory access has been dispatched , the contents of the first memory access are available , and we can continue without processor stalls .",
    "again , we completely unroll the tree traversal loop , so each block of statements is repeated @xmath4 times for a tree of depth @xmath4 . at the end , @xmath1 contains the index of the leaf nodes corresponding to the prediction for @xmath5 instances .",
    "setting @xmath5 to 1 reduces this model to pure predication ( i.e. , no vectorization ) .",
    "note that the optimal value of @xmath5 is dependent on the relationship between the amount of computation performed and memory latencies  we will determine this relationship empirically . for convenience , we refer to the vectorized version of the predication technique as vpred .",
    "given that the focus of our work is efficiency , our primary evaluation metric is prediction speed . we define this as the elapsed time between the moment a feature vector ( i.e. , a test instance ) is presented to the tree - based model to the moment that a prediction ( in our case , a regression value ) is made for the instance . to increase the reliability of our results , we conducted multiple trials and report the mean and variance .",
    "we conducted two sets of experiments :  first , using synthetically - generated data to quantify the performance of individual trees in isolation , and second , on standard learning - to - rank datasets to verify the performance of full ensembles .",
    "all experiments were run on a red hat linux server , with intel xeon westmere quad - core processors ( e5620 2.4ghz ) .",
    "this architecture has a 64 kb l1 cache per core , split between data and instructions ; a 256 kb l2 cache per core ; and a 12 mb l3 cache shared by all cores .",
    "code was compiled with gcc ( version 4.1.2 ) using optimization flags -o3 -fomit - frame - pointer -pipe . all code ran single - threaded .      the synthetic data consisted of randomly generated trees and randomly generated feature vectors .",
    "each intermediate node in a tree has two fields :  a feature i d and a threshold on which the decision is made .",
    "each leaf is associated with a regression value .",
    "construction of a random tree of depth @xmath4 begins with the root node .",
    "we pick a feature i d at random and generate a random threshold to split the tree into left and right subtrees .",
    "this process is recursively performed to build each subtree until we reach the desired tree depth .",
    "when we reach a leaf node , we generate a regression value at random .",
    "note that our randomly - generated trees are fully - balanced , i.e. , a tree of depth @xmath4 has @xmath7 leaf nodes .",
    "once a tree has been constructed , the next step is to generate random feature vectors .",
    "each random feature vector is simply a floating - point array of length @xmath8 ( @xmath9 number of features ) , where each index position corresponds to a feature value .",
    "we assume that all paths in the decision tree are equally likely ; the feature vectors are generated in a way that guarantees an equal likelihood of visiting each leaf . to accomplish this , we take one leaf at a time and follow its parents back to the root . at each node , we take the node s feature i d and produce a feature value based on the position of the child node .",
    "that is , if the child node we have just visited is on the left subtree we generate a feature value that is smaller than the threshold stored at the current parent node ; otherwise we generate a feature value larger than the threshold .",
    "we randomize the order of instances once we have generated all the feature vectors . to avoid any cache effects ,",
    "our experiments are conducted on a large number of instances ( 512k ) .",
    "given a random tree and a set of random feature vectors , we ran experiments to assess the various implementations of tree - based models described in section  [ section : approach ] . to get a better sense of the variance , we performed 5 trials ; in each trial we constructed a new random binary tree and a different randomly - generated set of feature vectors . to explore the design space",
    ", we conducted experiments with varying tree depths @xmath10 and varying feature sizes @xmath11 .",
    "in addition to randomly - generated trees , we conducted experiments using standard learning - to - rank datasets , where training , validation , and test data are provided . using the training and validation sets we learned a complete tree - ensemble ranking model , and evaluation",
    "is then carried out on test instances to determine the speed of the various implementations .",
    "these experiments assess performance in a real - world application .",
    "we used gradient - boosted regression trees ( gbrts )  @xcite to train a learning - to - rank model .",
    "gbrts are ensembles of regression trees that yield state - of - the - art effectiveness on learning - to - rank tasks .",
    "the learning algorithm sequentially adds new trees to the ensemble that best account for the remaining regression error ( i.e. , the residuals ) .",
    "we used the open - source jforests implementation of lambdamart to optimize ndcg  @xcite .",
    "although there is no way to precisely control the depth of each tree , we can adjust the size distribution of the trees by setting a cap on the number of leaves ( which is an input parameter to the learner ) .",
    "we used two standard learning - to - rank datasets : letor - mq2007 and mslr - web10k .",
    "both are pre - folded , providing training , validation , and test instances .",
    "table  [ table : datasets ] shows the dataset sizes and the numbers of features . to measure variance , we repeated experiments on all five folds .",
    "note that mq2007 is much smaller and is considered by many in the community to be outdated .",
    ".average number of training , validation , and test instances in our learning - to - rank datasets , along with the number of features .",
    "[ table : datasets ] [ cols=\"<,>,>,>,>\",options=\"header \" , ]     the values of @xmath8 ( number of features ) in our synthetic experiments are guided by these learning - to - rank datasets .",
    "we selected feature sizes that are multiples of 16 ( 4-byte floats ) so that the feature vectors are integer multiples of cache line sizes ( 64 bytes ) :  @xmath12 roughly corresponds to letor features and is representative of a small feature space ; @xmath13 corresponds to mslr and is representative of a medium - sized feature space .",
    "we introduced a third condition @xmath14 to capture a large feature space condition .",
    "in this section we present experimental results , beginning with evaluation on synthetic data and then on learning - to - rank datasets .",
    "we begin by focusing on the first five implementations described in section  [ section : approach ] ( leaving aside vpred for now ) , using the procedure described in section  [ section : experimental_setup : synthetic ] .",
    "the prediction time per randomly - generated test instance is shown in figure  [ figure : results : synthetic ] , measured in nanoseconds .",
    "the balanced randomly - generated trees vary in terms of tree depth _",
    "d _ , and each bar chart shows a separate value of _ f _ ( number of features ) .",
    "time is averaged across five trials and error bars denote 95% confidence intervals .",
    "it is clear that as trees become deeper , prediction speeds decrease overall .",
    "this is obvious since deeper trees require more feature accesses and predicate checks , more pointer chasing , and more branching ( depending on the implementation ) .",
    "first , consider the high - flexibility and high - performance baselines .",
    "as expected , the object implementation is the slowest ( except for pred with @xmath14 ) .",
    "it is no surprise that the c++ implementation is slow due to the overhead from classes and objects ( recall the other implementations are in c ) .",
    "the gap between object and struct , which is the comparable c implementation , grows with larger trees . also as expected",
    ", the codegen implementation is very fast :  with the exception of @xmath12 , hard - coded if - else statements are faster or just as fast as all other implementations , regardless of tree depth .    comparing struct@xmath0 with struct",
    ", we observe no significant improvement for shallow trees , but a significant speedup for deep trees .",
    "recall that in struct@xmath0 , we allocate memory for the entire tree so that it resides in a contiguous memory block , whereas in struct we let allocate memory however it chooses .",
    "this shows that reference locality is important for deeper trees .",
    "finally , turning to the pred condition , we observe a very interesting behavior . for small feature vectors",
    "@xmath12 , the technique is actually faster than codegen .",
    "this shows that for small feature sizes , predication helps to overcome branch mispredicts , i.e. , converting control dependencies into data dependencies increases performance . for @xmath13",
    ", results are mixed compared to codegen , struct , and struct@xmath0 :  sometimes faster , sometimes slower . however , for large feature vectors ( @xmath14 ) , the performance of pred is terrible , even worse than the object implementation .",
    "we explain this result as follows :  pred performance is entirely dependent on memory latency .",
    "when traversing the tree , it needs to wait for the contents of memory before proceeding . until the memory references are resolved , the processor simply stalls . with small feature vectors",
    ", we get excellent locality :  32 features take up two 64-byte cache lines , which means that evaluation incurs at most two cache misses .",
    "since memory is fetched by cache lines , once a feature is accessed , accesses to all other features on the same cache line are essentially `` free '' .",
    "locality decreases as the feature vector size increases :  the probability that the predicate at a tree node accesses a feature close to one that has already been accessed goes down .",
    "thus , as the feature vector size grows , the pred prediction time becomes increasingly dominated by stalls waiting for memory fetches .",
    "the effect of this `` memory wall '' is evident in the other implementations as well .",
    "we observe that the performance differences between codegen , struct , and struct@xmath0 shrink as the feature size increases ( whereas they are more pronounced for smaller feature vectors ) .",
    "this is because as feature vector size increases , more and more of the prediction time is dominated by memory latencies .",
    "how can we overcome these memory latencies ? instead of simply stalling",
    "while we wait for memory references to resolve , we can try to do other useful computation  this is exactly what vectorization is designed to accomplish .      in section  [ section :",
    "approach ] , we proposed _",
    "vectorization _ of the predication technique in order to mask memory latencies .",
    "the idea is to work on @xmath5 instances ( feature vectors ) at the same time , so that while the processor is waiting for memory access for one instance , useful computation can happen on another .",
    "this takes advantage of pipelining and multiple dispatch in modern superscalar processors .",
    "the effectiveness of vectorization depends on the relationship between time spent in actual computation and memory latencies .",
    "for example , if memory fetches take only one clock cycle , then vectorization can not possibly help .",
    "the longer the memory latencies , the more we would expect vectorization ( larger batch sizes ) to help .",
    "however , beyond a certain point , once memory latencies are effectively masked by vectorization , we would expect larger values of @xmath5 to have little impact .",
    "in fact , values that are too large start to bottleneck on memory bandwidth and cache size .    in figure",
    "[ figure : results : vectorization ] , we show the impact of various batch sizes , @xmath15 , for the different feature sizes . note that when @xmath5 is set to 1 , we evaluate one instance at a time , which reduces to the pred implementation .",
    "prediction speed is measured in nanoseconds and normalized by batch size ( i.e. , divided by @xmath5 ) , so we report _ per - instance _ prediction time . for @xmath12 ,",
    "@xmath16 yields the best performance ; for @xmath13 , @xmath17 yields the best performance ; for @xmath14 , @xmath18 all provide approximately the same level of performance .",
    "these results are exactly what we would expect :  since memory latencies increase with larger feature sizes , a larger batch size is needed to mask the latencies .    with the combination of vectorization and predication , vpred becomes the fastest of all our implementations on the synthetic data .",
    "comparing figures  [ figure : results : synthetic ] and [ figure : results : vectorization ] , we see that vpred ( with optimal vectorization parameter ) is actually faster than codegen . table  [ table : relative_speed ] summarizes this comparison .",
    "vectorization is up to 70% faster than the non - vectorized implementation ; vpred can be twice as fast as codegen .",
    "in other words , we retain the best of both worlds :  speed and flexibility , since the vpred implementation does not require code recompilation .",
    "having evaluated different implementations on synthetic data , we move on to learning - to - rank datasets using tree ensembles .",
    "as previously described , we used the implementation of lambdamart by ganjisaffar et al .",
    "once a model has been trained and validated , we evaluate on the test set to measure prediction speed .",
    "since the datasets come pre - folded five ways , we repeated our experiments five times and report mean and variance across the runs .    to handle ensembles in our implementations , we simply add an outer loop to the algorithm that iterates over individual trees in the ensemble .",
    "note that ganjisaffar et al .",
    "actually construct multiple ensembles , each built using a random bootstrap of the training data ( i.e. , _ bagging _ multiple boosted ensembles ) . in this work",
    ", we do not adopt this procedure because bagging is embarrassingly parallel from the runtime execution perspective and hence not particularly interesting .",
    "for learning parameters , we used values recommended by ganjisaffar et al . , with the exception of max leaves ( see below ) .",
    "feature and data sub - sampling parameters were set to 0.3 , minimum percentage of observations per leaf was set to 0.5 , and the learning rate was set to 0.05 .    in terms of performance , shallower trees are naturally preferred .",
    "but what is the relationship between tree depth and ranking effectiveness ?",
    "tree depth with our particular training algorithm can not be precisely controlled , but can be indirectly influenced by the maximum number of leaves on an individual tree ( an input to the learner ) .",
    "table  [ table : effectiveness ] shows the average ndcg values ( at different ranks ) measured across five folds on the letor and mslr datasets with different values of this parameter , similar to the range of values explored in  @xcite .",
    "statistical significance was tested using the wilcoxon test ( @xmath19-value 0.05 ) ; none of the differences on the letor dataset were significant .",
    "for each condition , we also report the average depth of the trees that were actually learned .",
    "the average tree depth is computed for every ensemble and then averaged across the five folds ; variance is presented in parentheses .",
    "results show that for letor , tree depth makes no significant difference on ndcg , whereas larger trees yield better results on mslr ; however , there appears to be little difference between 50 and 70 max leaves .",
    "the results make sense : to exploit larger feature spaces we need trees with more nodes .",
    "since many in the community consider the letor dataset to be out of date with an impoverished feature set , more credence should be given to the mslr results .",
    "turning to performance results , figure  [ figure : results : actual ] illustrates per - instance prediction speed for various implementations on the learning - to - rank datasets .",
    "note that this is on the entire ensemble , with latencies now measured in microseconds instead of nanoseconds .",
    "as described above , the trees were trained with different settings of max leaves ; the _ x_-axis plots the tree depths from table  [ table : effectiveness ] . in this set of experiments , we made use of the vpred approach with the vectorization parameter set to @xmath20 for letor and @xmath21 for mslr .",
    "results from the synthetic datasets mostly carry over to these learning - to - rank datasets .",
    "object is the slowest implementation and struct is slightly faster . on the letor dataset ,",
    "struct is only slightly slower than struct@xmath0 , but on mslr , struct@xmath0 is faster than struct by a larger margin in most cases .",
    "vpred outperforms all other techniques , including codegen on mslr , but is slower than codegen on letor ( except for the shallowest trees )",
    ". however , note that in terms of ndcg , table  [ table : effectiveness](a ) shows no difference in effectiveness , so there is no advantage to building deeper trees for letor .",
    "the conclusion appears clear :  for tree - based ensembles on real - world learning - to - rank datasets , we can achieve the best of both worlds . with a combination of predication and vectorization , we can make predictions faster than statically - generated if - else blocks , yet retain the flexibility in being able to specify the model dynamically , which enables rapid experimentation .",
    "our experiments show that predication and vectorization are effective techniques for substantially increasing the performance of tree - based models , but one potential objection might be :  are we measuring the right thing ? in our experiments , prediction time is measured from when the feature vector is presented to the model to when the prediction is made .",
    "critically , we assume that features have already been computed .",
    "what about an alternative architecture where features are computed lazily , i.e. , only when the predicate at a tree node needs to access a particular feature ?",
    "this alternative architecture , where features are computed on demand , is difficult to study since results will be highly dependent on the implementation of feature extraction  which in turn depends on the underlying data structures ( layout of the inverted indexes ) , compression techniques , and how computation - intensive the features are .",
    "however , there is a much easier way to study this issue  we can trace the execution of the full tree ensemble and keep track of the fraction of features that are accessed . if during the course of making a prediction , most of the features are accessed , then there is little waste in computing all the features first and then presenting the complete feature vector to the model .    table  [ table : features ] shows the average fraction of features accessed in the final learned models for both learning - to - rank datasets , with different max leaves configurations .",
    "it is clear that , for both datasets , most of the features are accessed during the course of making a prediction , and in the case of the mslr dataset , nearly all the features are accessed all the time ( especially with deeper trees , which yield higher effectiveness ) .",
    "therefore , it makes sense to separate feature extraction from prediction .",
    "in fact , there are independent compelling reasons to do so :  a dedicated feature extraction stage can benefit from better reference locality ( when it comes to document vectors , postings , or whatever underlying data structures are necessary for computing features ) .",
    "interleaving feature extraction with tree traversal may lead to `` cache churn '' , where a particular data structure is repeatedly loaded and then displaced by other data .    returning to a point in the introduction :   do these optimizations actually matter , in the broader context of real - world search engines ?",
    "this is of course a difficult question to answer and highly dependent on the actual search architecture , which is a complex distributed system spanning hundreds of machines or more . here , we venture some rough estimates . from figure  [",
    "figure : results : actual](b ) , the mslr dataset , we see that compared to codegen , vpred reduces per - instance prediction time from around 40@xmath22 to around 25@xmath22 ( for max leaves setting of 50 ) ; this translates into a 38% reduction in latency per instance . in a web search engine , the learning to rank algorithm",
    "is applied to a candidate list of documents that is usually generated by other means ( e.g. , scoring with bm25 and a static prior ) .",
    "the exact details are proprietary , but the published literature does provide some clues .",
    "for example , cambazoglu et al .",
    "@xcite ( authors from yahoo ! )  experimented with reranking 200 candidate documents to produce the final ranked list of 20 results ( the first two pages of search results ) . from these numbers , we can compute the per - query reranking time to be 8ms using the codegen approach and 5ms with vpred .",
    "this translates into an increase from 125 queries per second to 200 queries per second on a single thread for this phase of the search pipeline .",
    "alternatively , gains from faster prediction can be leveraged to rerank more results or take advantage of more features .",
    "this simple estimate suggests that our optimizations can make a noticeable difference in web search , and given that our techniques are relatively simple  the predication and vectorization optimizations definitely seem worthwhile .",
    "during the course of our experiments , we noticed that two assumptions of our implementations did not appear to be fully valid .",
    "first , the pred and vpred implementations assume fully - balanced binary trees ( i.e. , every node has a left and a right child ) . in contrast , recall that struct@xmath0 makes no such assumption because with the left and right pointers we can tightly pack the tree nodes .",
    "the fully - balanced tree assumption does not turn out to be valid for gbrts  the learner does not have a preference for any particular tree topology , and so the trees are unbalanced most of the time . to compensate for this ,",
    "the pred and vpred implementations require insertion of dummy nodes to create a fully - balanced tree .",
    "second , we assume that all paths are equally likely in a tree , i.e. , that at each node , the left and right branches are taken with roughly - equal frequency",
    ". we noticed , however , that this is often not the case .",
    "to the extent that one branch is favored over another , branch prediction provides non - predicated implementations ( i.e. , if - else blocks ) an advantage , since branch prediction will guess correctly more often , thus avoiding pipeline flushes .",
    "one promising future direction to address the above two issues is to adapt the model learning process to prefer balanced trees and predicates that divide up the feature space evenly .",
    "we believe this can be incorporated into the learning algorithm as a penalty , much in the same way that regularization is performed on the objective in standard machine learning .",
    "thus , it is perhaps possible to jointly learn models that are both fast and good , as in the recently - proposed `` learning to _ efficiently _ rank '' framework  @xcite .",
    "modern processor architectures are incredibly complex because technological improvements have been uneven .",
    "this paper focuses on one particular issue :  not all memory references are equally fast , and in fact , latency can differ by an order of magnitude .",
    "there are a number of mechanisms to mask these latencies , although it largely depends on developers knowing how to exploit these mechanisms .",
    "the database community has been exploring these issues for quite some time now , and in this respect the information retrieval , machine learning , and data mining communities are behind .    in this paper",
    ", we demonstrate that two relatively simple techniques , predication and vectorization , along with more efficient memory layouts , can significantly accelerate prediction performance for tree - based models , both on synthetic data and on real - world learning - to - rank datasets .",
    "our work explores architecture - conscious implementations of a particular machine learning model  but we believe there are plenty of similar opportunities in other areas of machine learning as well .",
    "this work has been supported by nsf under awards iis-0916043 , iis-1144034 , and iis-1218043 .",
    "any opinions , findings , conclusions , or recommendations expressed are the authors and do not necessarily reflect those of the sponsor .",
    "the first author s deepest gratitude goes to katherine , for her invaluable encouragement and wholehearted support .",
    "the second author is grateful to esther and kiri for their loving support and dedicates this work to joshua and jacob .",
    "a.  criminisi , j.  shotton , and e.  konukoglu .",
    "decision forests : a unified framework for classification , regression , density estimation , manifold learning and semi - supervised learning . , 7(23):81227 , 2011 ."
  ],
  "abstract_text": [
    "<S> tree - based models have proven to be an effective solution for web ranking as well as other problems in diverse domains . </S>",
    "<S> this paper focuses on optimizing the runtime performance of applying such models to make predictions , given an already - trained model . </S>",
    "<S> although exceedingly simple conceptually , most implementations of tree - based models do not efficiently utilize modern superscalar processor architectures . by laying out data structures in memory in a more cache - conscious fashion , removing branches from the execution flow using a technique called predication , and micro - batching predictions using a technique called vectorization , </S>",
    "<S> we are able to better exploit modern processor architectures and significantly improve the speed of tree - based models over hard - coded if - else blocks . </S>",
    "<S> our work contributes to the exploration of _ architecture - conscious _ runtime implementations of machine learning algorithms . </S>"
  ]
}