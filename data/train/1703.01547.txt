{
  "article_text": [
    "this is a strategy to solve a problem by splitting it into multiple smaller problems and solve them recursively . for example , we get all the _ faces _ of a _ simplex _ @xmath1 $ ] by recursively deleting one _ vertex _ at a time as follows :        in python , for each natural number @xmath2 the following function generates faces by removing only vertices below the position @xmath3 in the simplex @xmath4 and @xmath5 $ ] is the _ simplicial complex _ generated by @xmath4 .",
    "def com(s , p ) :    if len(s)==1 :    return [ ]    else :    l= [ ]    for i in range(p , len(s ) ) :    n = len(s)-i-1    ss = s.copy ( )    ss.remove(s[n ] )    l.append(ss )    l = l+com(ss , i )    return l    the complex recursively generated by @xmath1 $ ] looks like this :        to make it usable we lexicographically order this complex with respect to @xmath6 and the natural ordering of vertices by a quick sort algorithm where @xmath7 runs over all faces of @xmath4 .",
    "a _ hash _ function @xmath8 pseudo - randomly assigns to each entry @xmath4 in a data - set an integer @xmath9 that can be used to quickly reference @xmath4 .",
    "its fibers @xmath10 are almost uniformly distributed for naturally occuring data - sets .",
    "for example , the hash function @xmath8 could be injective on the faces of the simplex @xmath1 $ ] and the integers @xmath11 and @xmath12 are references for the faces @xmath13 $ ] and @xmath14 $ ] .",
    "we define a _ hash table _ to be essentially the list @xmath15 of fibers @xmath16=h^{-1}(k)$ ] of a hash function @xmath8 over the set of integers @xmath17 and use it to locate each entry @xmath4 in the data - set by finding the fiber @xmath10 containing @xmath4 and then searching for @xmath4 inside that fiber .",
    "dynamic programming is a strategy which uses recursion to solve a problem once and _ memoization _ to store the solution in a hash table for future use .",
    "for example , in the hash table of the simplex @xmath1 $ ] the face @xmath13 $ ] located in fiber @xmath18 $ ] is lexicographically the 10th among all faces and the 6th among all edges ; the face @xmath14 $ ] in the fiber @xmath19 $ ] is the 12th among all faces and the 2nd among all triangles . to retrieve this information about @xmath20 we do @xmath21 and search for @xmath20 in the fiber @xmath18 $ ] instead of searching for @xmath20 in the whole list of faces .",
    "for a disjoint union @xmath22 of simplices , we generate their faces without duplicates , lexicographically order them in a complex @xmath23 and encode this information in a hash table @xmath15 for a quick retrival .",
    "the _ boundary map _ of the complex @xmath24 is a matrix @xmath25 with the only non - zero entries @xmath26 in column @xmath4 and row @xmath27 , the face of @xmath4 given by removing the @xmath28-th vertex , where @xmath29 and @xmath4 runs over all simplices of @xmath24 .",
    "we construct each @xmath4-column of the block @xmath30 $ ] of @xmath25 corresponding to @xmath31 by locating the faces @xmath27 of @xmath4 using the hash table @xmath15 .",
    "the output is the boundary maps for the homology of the space @xmath22 .",
    "the complex @xmath32 could be a @xmath0-_complex _ generated by a disjoint union @xmath22 of simplices with identifications @xmath33 .",
    "for example , the _ torus _ can be generated by two triangles ( jplex requires 18 triangles ) @xmath22 : @xmath34 $ ] and @xmath35 $ ] with three _ identifications _ @xmath36=[3,4],\\",
    "\\   [ 0,1]=[4,5 ] , \\ \\",
    "[ 0,2]=[3,5].\\ ] ]    these induce _ face - identifications _",
    "@xmath37=[3]$ ] , @xmath38=[4]$ ] , @xmath39=[4]$ ] , etc . that are encoded in the hash table @xmath15 for @xmath40 .",
    "the boundary maps @xmath25 for @xmath24 are obtained in a similar way as the boundary maps for @xmath40 but making updates based on @xmath33 .",
    "we initialize @xmath25 as a properly sized zero matrix and successively update its entries for @xmath41 a face of a simplex @xmath4 in @xmath22 and @xmath2 a natural number :    def b(s , p ) :    k = @xmath42    @xmath43 position of @xmath4 in @xmath40 relative to @xmath17    for @xmath44 :    remove vertex @xmath45 $ ] and produce a face @xmath41    @xmath46 position of @xmath47 in @xmath40 relative to @xmath48    if @xmath49 is even : @xmath30[b , a]=d[k][b , a]+1 $ ]    else : @xmath30[b , a]=d[k][b , a]-1 $ ]    if @xmath50    here @xmath47 denotes the lexicographically lowest simplex in @xmath40 that is @xmath33-identified with the face @xmath41 . _",
    "the boundary map @xmath25 for the complex @xmath24 is given by @xmath51 for all @xmath4 in @xmath22 .",
    "_    for the torus , our algorithm produces the boundary map @xmath25 .",
    "this gives the boundary map below for the @xmath0-structure after removing simplices which are not updated .",
    "....    def complexify(s , p = 0 ) : # generates the complex of simplex s when p is left as 0 .",
    "otherwise a subcomplex of faces with vertices < p never removed , is generated      if len(s)==1 :          return [ s ]      else :          l= [ ]          for i in range(p , len(s ) ) :              n = len(s)-i-1              ss = s.copy ( )              ss.remove(s[n ] )              l.append(ss )              l = l+complexify(ss , i )          return l + [ s ]    def isless(s , t ) : # lexicographical ordering boolean function for simplices .",
    "if s < t , returns true      n = min(len(s),len(t ) )      for i in range(0,n ) :          if s[i]<t[i ] :              return true          elif s[i]>t[i ] :              return false      if len(s)<len(t ) :          return true      return false      def makelex(l ) : # quicksort implimented with lexicographic ordering   that also preferences size of simplices      if len(l)<=1 :          return l      p = random.randrange(0,len(l ) )      piv = l[p ]      a= [ ]      b= [ ]      for i in range(0,len(l ) ) :          y = [ len(l[i])]+l[i ]          z = [ len(piv)]+piv          if isless(y , z ) and i!=p :              a.append(l[i ] )          if isless(z , y ) and i!=p :              b.append(l[i ] )      l = makelex(a)+[piv]+makelex(b )      return l        def choose(n , k ) : # standard combination function      if 0<=k<=n :          num=1          den=1          for t in range(1,min(k , n - k)+1 ) :              num*=n              den*=t              n-=1          return num//den      else :          return 0    def j(gen , n ) : # returns the number of n dimensional simplices that will be   generated from the generating set gen      sum=0      for i in range(0,len(gen ) ) :          sum = sum+gen[i][0]*choose(gen[i][1]+1,n+1 )      return sum    def par(gen ) : # returns partition generated from generating set gen      p= [ ]      n= [ ]      for i in range(0,j(gen,0 ) ) :          n.append(i )      for t in range(0,len(gen ) ) :          n = gen[t ]          for k in range(0,n[0 ] ) :              p.append(n[0:n[1]+1 ] )              n = n[n[1]+1:len(n ) ]      return p        def location(s , x = ' r ' ) : # uses hash table h to find quickly find the relative ( ' r ' )   or absolute ordering of a simplex      k = h(s)%len(h )      if type(h[k][0 ] ) = = list :          for i in range(0,len(h[k ] ) ) :              if h[k][i][2 ] = = s :                  if x = = ' r ' :                      return h[k][i][0 ]                  else :                      return h[k][i][1 ]      else :          if x = = ' r ' :              return h[k][0 ]          else :              return h[k][1 ]    def setgendata(s , r = [ ] ) :      global master , d , h , deadsimps      master.clear ( )      d.clear ( )      deadsimps.clear ( )      master = m(s )      d=[zeros(1,j(s,0 ) ) ]      d = s[len(s)-1][1 ]      for i in range(0,d ) : # initializes boundary matrix d          d.append(zeros(j(s,i),j(s,i+1 ) ) )      h.clear ( )      for i in range(0,2*len(master ) ) : # initializes ordinal hash table h          h.append(0 )      c = 0      for i in range(0,len(master ) ) : # fills h with simplex positions          n = h(master[i])%len(h )          if len(master[i ] ) > len(master[i-1 ] ) :              c = 0          if h[n ] = = 0 :              h[n ] = [ c , i , master[i],master[i ] ]          elif type(h[n][0 ] ) = = list :              h[n].append([c , i , master[i],master[i ] ] )          else :              h[n ] = [ h[n],[c , i , master[i],master[i ] ] ]          c = c+1        def boundarydecomp(s , p = 0 ) : # takes simplex s , and recursively calls a rightbound .",
    "will update all boundaries of the complex of s ( s and all faces )      global d , deadsimps      if type(s ) = = int :          s = [ s ]      dim = len(s ) - 1      m = d[dim ]      for x in range(0,p ) :          if len(s ) < = 1 :              break          ss = s.copy ( )          ss.remove(s[dim-x ] )          pos = location(lowestorderrelation(ss),'r ' )          if lowestorderrelation(ss ) ! = ss :              deadsimps.append(ss )          if ( dim - x)%2 = = 0 :              m[pos , location(s,'r ' ) ] = m[pos , location(s,'r ' ) ] + 1          else :              m[pos , location(s,'r ' ) ] = m[pos , location(s,'r ' ) ] - 1      for y in range(p , len(s ) ) :          if len(s ) < = 1 :              break          ss = s.copy ( )          ss.remove(s[dim-y ] )          pos = location(lowestorderrelation(ss),'r ' )          if lowestorderrelation(ss ) ! = ss :              deadsimps.append(ss )          if ( dim - y)%2 = = 0 :              m[pos , location(s,'r ' ) ] = m[pos , location(s,'r ' ) ] + 1          else :              m[pos , location(s,'r ' ) ] = m[pos , location(s,'r ' ) ] - 1          boundarydecomp(lowestorderrelation(ss),y )      def initializerelations(rel):#gets the full set of relations , and updates h with   relation information for each simplex      global h , deadsimps      rel = getallrelations(rel )      for a in rel :          deadsimps.append(a[1 ] )      for i in range(0,len(rel ) ) :          s = makelex(rel[i ] )          lor = s[0 ]          for u in range(0,len(s ) ) :              k = h(s[u])%len(h )              if type(h[k][0 ] ) = = list :                  for x in range(0,len(h[k ] ) ) :                      if h[k][x][2 ] = = s[u ] :                          lor2 = lowestorderrelation(s[u ] )                          if isless(lor2,lor ) :                              h[k][x][3 ] = lor2                              l = h(s[0])%len(h )                              b = h[l ]                              if type(b[0 ] ) = = list :                                  for y in range(0,len(b ) ) :                                      if b[y][2 ] = = s[0 ] :                                          b[y][3 ] = lor2                              else :                                  b[3 ] = lor2                              lor = lor2                            else :                              h[k][x][3 ] = lor                          break              else :                  lor2 = lowestorderrelation(s[u ] )                  if isless(lor2,lor ) :                      h[k][3 ] = lor2                      l = h(s[0])%len(h )                      b = h[l ]                      if type(b[0 ] ) = = list :                          for y in range(0,len(b ) ) :                              if b[y][2 ] = = s[0 ] :                                  b[y][3 ] = lor2                      else :                          b[3 ] = lor2                      lor = lor2                  else :                      h[k][3 ] = lor def lowestorderrelation(s ) : # finds the lowest order relation of simplex s , using h",
    "k = h(s)%len(h )      if type(h[k][0 ] ) = = list :          for i in range(0,len(h[k ] ) ) :              if h[k][i][2 ] = = s :                  if h[k][i][3 ] = = s :                      return s                  else :                      return lowestorderrelation(h[k][i][3 ] )      else :          if h[k][3 ] = = s :              return s          else :              return lowestorderrelation(h[k][3 ] ) def getallrelations(rel):#generates all lower order relations from a relation set rel      fullrel = [ ]      for i in range(0,len(rel ) ) :          lowerrels = [ ]          for u in range(0,len(rel[i ] ) ) :              lowerrels.append(complexify(rel[i][u],0 ) )          for k in range(0,len(lowerrels[0 ] ) ) :              newrel = [ ]              for x in range(0,len(lowerrels ) ) :                  newrel.append(lowerrels[x][k ] )              fullrel.append(newrel )      return rel+fullrel def prunesimps ( ) :      global d      d = makelex(deadsimps )      currentdim = 0      i = 0      for x in d :",
    "if len(x)-1>currentdim :              currentdim = len(x)-1              i = 0          p = location(x )          d[currentdim].col_del(p - i )",
    "if currentdim < len(d ) - 1 :              d[currentdim + 1].row_del(p - i )          i = i + 1 def betti(k , m = none ) :      if m = = none :          m = d      return betticalc.bettislow(k,m ) def ker(k , mat ) :      return betticalc.ker(k,mat ) ...."
  ],
  "abstract_text": [
    "<S> topological data analysis studies point - clouds in high dimensional spaces by generating simplicial complexes and calculating their homology . for example , the subsets of place neurons that co - fire generate a simplicial complex having the topology of the environment . </S>",
    "<S> see @xcite . in the literature simplicial complexes </S>",
    "<S> are generated by listing all the faces of each simplex and by removing the duplicates . </S>",
    "<S> see @xcite . </S>",
    "<S> our algorithm does not produce duplicates and can also generate @xmath0-complexes and their boundary maps . </S>",
    "<S> see @xcite . to achieve this we make use of the divide and conquer paradigm and dynamic programming based on statistical hash tables . </S>"
  ]
}