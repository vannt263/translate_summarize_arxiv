{
  "article_text": [
    "one of the most challenging goals of quantum information theory is to understand what can be accomplished by spatially separated parties , each performing local operations ( lo ) on quantum subsystems and exchanging classical communication ( cc ) amongst themselves , a process known as locc @xcite .",
    "unfortunately , this class of operations is extremely difficult to analyze , and while much progress has been made , often through the study of specific tasks , we still lack a deep intuition about its inner workings .",
    "separable operations ( sep ) @xcite , of which locc is a strict subset @xcite , has a much simpler mathematical description , but while its study has provided powerful lessons about locc , no simple picture has emerged that would allow us to understand the difference between these two important classes of quantum operations in the most general terms .    in this paper , we give a conceptually simple picture that distinguishes between locc and sep , and then we show that it provides a very strong separation between these two classes of quantum operations",
    ". we will prove a necessary condition for locc and then show that separable operations violates this condition by an arbitrarily large amount , an amount constrained only by the size of the system as measured by the number of parties involved . in previous work showing a gap between locc and sep , studies have been made of specific operational tasks that can be accomplished by sep but can not be closely approximated by locc @xcite .",
    "the gap we show is of a different sort , one which does not directly address the important question of how closely a given separable operation can be approximated by locc .",
    "in contrast , our necessary condition is of an abstract , geometrical nature , which provides a more general ( and one may hope , ultimately deeper ) understanding of the difference between sep and locc .",
    "let us begin by recalling what locc involves .",
    "we may assume the parties have agreed in advance upon a protocol that they will follow .",
    "one of the parties , say party @xmath0 whose system is described by states in hilbert space @xmath1 , starts by locally performing a generalized measurement @xcite with outcomes corresponding to kraus operators @xmath2 . that party broadcasts her outcome @xmath3 to the other parties , who according to the agreed upon protocol , all know which of them ( call this party @xmath4 ) is to measure next .",
    "party @xmath4 then performs a measurement with outcome @xmath5 , described by @xmath6 acting on @xmath7 and conditioned on alice s outcome @xmath3 , after which he broadcasts his outcome @xmath5 to all the others .",
    "the next party to measure will be @xmath8 ( which could be party @xmath0 again ) , performing @xmath9 , and they may continue in this way for an arbitrary ( but we assume here , finite ) number of rounds . from the fact that the probabilities of outcomes obtained at each stage must always sum to unity , one has that for each and every @xmath10 , @xmath11 where @xmath12 is the identity operator on @xmath13 , and @xmath14 is a collection of indices @xmath15 indicating all outcomes obtained in earlier measurements .",
    "the last index in the collection , @xmath16 , indicates which party performed this measurement , and when @xmath17 we define @xmath18 , reflecting the fact that party @xmath8 does nothing when party @xmath16 is measuring .",
    "when this is the case , the sum on the right has only this single term @xmath12 , and becomes trivial .",
    "given any locc protocol , we can represent it as a tree , each local measurement appearing as a branching to a set of nodes , with each of these nodes representing one outcome of that measurement .",
    "we will label each node by a positive operator @xmath19 obtained as follows : starting from the ordered product of all kraus operators implemented by the party whose outcome is represented by the given node , @xmath20 , multiply this by its hermitian conjugate to obtain the desired positive operator,@xmath21 note that in this product of kraus operators , there is one for each round leading up to this node , but many of these operators will be the identity , as parties other than @xmath8 will have measured at that round along this branch of the tree .",
    "we also note that in the following , we will sometimes use the term  outcome \" ( of a measurement ) to refer to these operators , @xmath19 , which label the node associated with that outcome .    as observed in @xcite , and tell us that @xmath22 using this result , we provided a method of constructing an locc protocol from an arbitrary separable operation whenever such a ( finite - round ) protocol exists @xcite .    for clarity and use in the remaining discussion ,",
    "the following is how we identify the sep implemented by a given locc protocol .",
    "when @xmath23 denotes a leaf of the tree , it identifies a final outcome of the protocol .",
    "the operator @xmath24 , with @xmath25 , is then defined to be party @xmath8 s part of the @xmath26th outcome in the sep implemented by this locc protocol . the closest @xmath16-node that is an ancestor to this leaf ( ancestors are closer to the root , descendants are further ) identifies the operator implemented by party @xmath16 for this final outcome of the locc , and is therefore ( proportional to ) @xmath27 of the sep . by doing this for each party",
    ", we may determine the product operator @xmath28 associated with each leaf node .",
    "the sep implemented by this locc protocol is then defined by the collection of distinct operators @xmath29 .. ] by theorem  @xmath0 of @xcite and the fact that we are restricting our discussion to finite - round protocols , we may , without loss of generality , assume @xmath30 is finite .",
    "the method of @xcite constructs an locc protocol for a sep by finding intersections of convex cones formed from subsets of the local operators @xmath31 for each party @xmath8 .",
    "consideration of the extreme rays , and we will sometimes refer to @xmath31 as a ` ray ' , by which we will mean that this operator generates the ray through multiplication by non - negative scalars , @xmath32 .",
    "an extreme ray of a convex cone is a ray that lies in the cone but can not be written as a positive linear combination of other rays in that cone .",
    "] of convex cones generated by these operators will lead us to the main result of this paper .",
    "the basic idea underlying our result is that too many extreme rays means that one can not find enough intersections to piece together the full puzzle into a single protocol that incorporates all of the operators defining the given sep . before stating our theorem ,",
    "let us first discuss how we count the @xmath33 parties .",
    "consider any locc protocol involving @xmath34 parties , with the collection of final outcomes corresponding to the set of positive operators , @xmath29 .",
    "if for each @xmath35 a given party only does an isometry , so that for this party @xmath36 , then that party can simply do those isometries at the end of the protocol . then it is immediate that an locc exists for this sep on @xmath34 parties if and only if one exists for the sep on @xmath37 parties obtained by simply deleting that one party s local operators from the @xmath38 .",
    "hence , in proving a necessary condition for locc , we need only consider seps having operators @xmath38 such that each of the @xmath33 parties has at least one local operator @xmath31 that is not the identity , and this is what we will do in the remainder of this paper .",
    "now we state our main result .",
    "let us count the distinct extreme rays in the convex cone generated by the set of local operators , @xmath39 for each @xmath8 , and define this number to be @xmath40 .",
    "then , we have the following theorem .    [ thm1]for any finite - round locc protocol of @xmath33 parties implementing a separable operation defined by the @xmath30 distinct positive product operators @xmath41 , it must be that @xmath42 where @xmath40 is the number of distinct extreme rays in the convex cone generated by operators @xmath39 , and the sum includes only those parties for which at least one of these local operators is not proportional to the identity .",
    "the upper bound in can be achieved with equality when @xmath43 .    in the next section",
    "we give a proof of this theorem , and then we offer our conclusions . in appendix",
    "[ app3 ] , we construct separable operations for every @xmath44 , each one having a unique representation in terms of product kraus operators , and which satisfy @xmath45 , the maximum possible value of this sum , showing that the bound in the theorem is extensively violated by separable operations .",
    "the uniqueness of the product representation for each of these separable operations implies that any implementation by locc must be in terms of that specific representation s set of kraus operators , since non - product representations can not be implemented by locc .",
    "it therefore follows that in the sense of this theorem , these separable operations are as far from locc as possible .",
    "in this section , we prove our main theorem . the proof will use a series of preliminary results , which will allow us to restrict the locc protocols that need to be considered .",
    "we begin with the following fairly straightforward result , which is lemma 4 in @xcite .",
    "[ lem3 ] for any locc protocol involving local measurements having two or more proportional outcomes , there is a corresponding locc protocol with no two outcomes of any measurement proportional to each other , but which implements the exact same separable operation as the original protocol , including reproducing the same weights for each positive operator @xmath38 defining the separable operation .",
    "in addition , if a party performs an isometry (  measurement \" with only one outcome ) at any stage of an locc protocol , they could just as well have absorbed that isometry into their subsequent measurement , omitting the round in which they had implemented the isometry ( see the paragraph following lemma  @xmath0 in @xcite for details ) .",
    "therefore , we can restrict consideration to locc protocols for which every round involves a measurement having at least two outcomes .",
    "it is then a simple matter to revise any such locc protocol into another for which every measurement has exactly two outcomes , with the latter implementing the exact same separable operation as the former .",
    "this can be done with a replacement of each measurement having more than two outcomes by a sequence of measurements having exactly two outcomes each .",
    "it is also readily demonstrated that if the original protocol has no two proportional outcomes in any individual measurement , then one can choose each replacement sequence of two - outcome measurements such that none of these measurements has its two outcomes proportional to each other .",
    "these observations tell us that in proving necessary conditions for locc , we can ( and will do so in the remainder of this paper ) restrict consideration to the following special class of locc protocols .",
    "[ def1 ] a  canonical \" locc protocol is one where every local measurement has exactly two outcomes , and in each of these measurements , the two outcomes are not proportional to each other .",
    "every such protocol can therefore be represented by a tree with every non - leaf node having exactly two child nodes ( these are commonly known as full binary trees ) .",
    "each node is labeled by a positive operator as shown in , and for any given node , the positive operators representing its two child nodes are not proportional to each other .",
    "we will refer to such trees as canonical locc trees .",
    "as we will be dealing with full binary trees , the following well - known theorem will be useful .",
    "[ thm2]@xcite for a full binary tree , the number of leaf nodes exceeds the number of non - leaf nodes by exactly @xmath0 .",
    "we will also need the following lemma , proved in appendix  [ app1 ] , concerning the location of nodes in a canonical locc tree that may be extreme rays .",
    "[ lem1 ] in a canonical locc tree , a node @xmath10 representing an outcome of a measurement by party @xmath8 can not be an extreme ray if there is an @xmath8-node that is a descendant of node @xmath10 .",
    "we are now ready to prove theorem [ thm1 ] .",
    "_ proof of theorem [ thm1 ] .",
    "_ consider first the special case where , in a finite canonical locc tree , each distinct outcome ( each @xmath38 ) appears once and only once as a leaf of the tree .",
    "then , the number of leaves on the tree is equal to the number of outcomes , @xmath30 .",
    "since the protocol begins with all parties having yet to make a measurement , we may label the root of the tree as @xmath12 for some @xmath8 ( it is immaterial for our purposes which @xmath8 is chosen ) .",
    "now , @xmath12 is not an extreme ray except when it is the _ only _ ray in the cone , which can only happen if for that party @xmath8 , @xmath46 .",
    "however , in this case we do not include this party in the count of extreme rays ( see paragraph preceding theorem  [ thm1 ] ) .",
    "therefore , since the root node is not extreme , and since every extreme ray ( indeed , every local operator @xmath31 ) in the corresponding sep is represented by a node in the tree , @xmath47 can not exceed one less than the number of nodes .",
    "since the total number of nodes is @xmath48 by the full binary tree theorem , we find that @xmath49 as claimed .    in general , however , there will be repeated outcomes : multiple leafs will correspond to the same outcome of the sep ( the same @xmath38 ) . therefore",
    ", we need a way to count extreme rays without counting repetitions of those already counted .",
    "we will do this by removing nodes in a way in which the tree remains a full binary tree at every stage of the process , and which leaves at least one instance of each extreme ray .",
    "note that by removing nodes , the remaining tree will no longer correspond to an locc protocol , but this is unimportant as our only purpose is to count everything in an appropriate manner .",
    "depict the tree with the root at the top and branches extending downward to the right and left .",
    "each non - leaf node is parent to two child nodes , each of which is , in turn , the root of what we may refer to as a child sub - tree of that parent .",
    "notice that every pair of nodes has a closest common ancestor .",
    "if that ancestor is not one of the pair , the node that is in the right child sub - tree of this common ancestor is ` to the right ' of the other , which is necessarily in the left child sub - tree ( according to this definition , a node that is an ancestor to another node is neither to the right nor to the left of that other one ) . for each @xmath26",
    ", there is therefore a right - most @xmath38 leaf ( a leaf is never ancestor to another leaf ) , which we choose as the ` keeper ' @xmath38 leaf . in this way",
    "we obtain @xmath30 keeper leafs , where for each @xmath26 any non - keeper @xmath38 leaf is to the left of its respective keeper leaf .",
    "all non - keeper leafs will be removed in a way that leaves a full binary tree with @xmath30 leaf nodes .",
    "illustration of the two types of removals used in pruning a canonical locc tree .",
    "( a ) a type-@xmath0 removal , where the parent @xmath50 is removed along with the maximal keeperless sub - tree @xmath51 .",
    "this type of removal is used when there is at least one @xmath38 leaf in @xmath51 whose corresponding keeper is not in @xmath52 .",
    "the root of @xmath52 is @xmath53 in the terminology used in the main text ; @xmath53 may be the only node in @xmath52 , in which case it turns out that @xmath53 is itself a keeper leaf .",
    "( b ) a type-@xmath4 removal where @xmath53 , which is the root of the sibling sub - tree of @xmath51 , is removed with @xmath51 .",
    "this type of removal is used when every leaf in @xmath51 has its corresponding keeper leaf in either @xmath54 or @xmath55 . under these circumstances",
    ", @xmath53 can not be a leaf . ]    as discussed in the next paragraph , non - keeper leafs will be removed as part of a sub - tree , and this is done in two different ways , which we now describe . consider a sub - tree @xmath51 of the full tree , where @xmath51 has no keeper leafs in it .",
    "denote the parent of @xmath51 as @xmath50 , the other child of this parent as @xmath53 .",
    "of the collection of @xmath38 leafs in @xmath51 ( with @xmath26 ranging over all values present in @xmath51 ) , if at least one of the corresponding keeper @xmath38 leafs is not a descendant of @xmath50 , then remove @xmath50 along with the entire sub - tree , @xmath51 .",
    "the tree is kept as a full binary tree by adding an edge from the parent of @xmath50 to the remaining child node @xmath53 .",
    "we will refer to this as a ` type-@xmath0 ' removal . `",
    "type-@xmath4 ' removals will be used when every leaf in @xmath51 has its corresponding keeper leaf as a descendant of @xmath50 , and thus of @xmath53 , in which case we will remove @xmath53 along with @xmath51 , re - attaching the children of @xmath53 as children , still siblings , of @xmath50 , and taking care to preserve the right / left relationship between these children ( under these circumstances , it turns out that @xmath53 can not be a leaf , see appendix  [ app7 ] for a proof ) .",
    "again , the tree remains full binary .",
    "see figure  [ fig1 ] for an illustration of these two types of removals.notice that the tree structure induces a partial order amongst the nodes , having to do with whether or not two nodes are ancestor / descendant of one another .",
    "as should be clear from figure  [ fig1 ] , if a pair of nodes are ( are not ) ancestor / descendant of one another after a removal , then they were ( were not ) ancestor / descendant before the removal .",
    "] they are chosen to guarantee that there is at least one instance of every extreme ray still present in the fully pruned tree , a fact that will be proven below .",
    "the following is how we will prune the tree . at every stage",
    "including the first , consider the left - most non - keeper leaf .",
    "if the sibling sub - tree of this non - keeper leaf has no keepers , consider instead the entire sub - tree for which the parent of these sub - trees is the root ( that is , consider both sibling sub - trees and their parent as a single sub - tree ) .",
    "then , if the sibling sub - tree of this larger sub - tree has no keepers combine these two sub - trees with their parent , and consider this larger sub - tree .",
    "continue in this fashion until a keeper leaf is encountered in the sibling sub - tree , having thus found a ` maximal ' keeperless sub - tree .",
    "remove this entire maximal sub - tree as either type-@xmath0 or type-@xmath4 , whichever is appropriate . then",
    ", find the left - most non - keeper leaf in the tree that remains , and repeat this process until all non - keeper leafs have been removed .",
    "having removed all non - keeper leafs , the @xmath30 keepers are the only leafs remaining in the fully pruned tree , as desired .",
    "furthermore , a non - leaf node is only removed if it is within a sub - tree that has no keeper leaf in it , or if it is that extra non - leaf node that is removed along with one of those sub - trees .",
    "this implies that the root of the entire original tree is never removed : the only sub - tree it is within is the full original tree , which obviously has a keeper ; and if either child sub - tree of the root has no keeper leaf , then the other sub - tree has in it every keeper corresponding to the non - keepers in that first sub - tree , so the first sub - tree is removed as type-@xmath4 , in which case it is the root of the other sub - tree that is removed as the extra non - leaf , rather than the root of the entire tree . hence , the root of the entire original tree is still present as the root of the entire fully pruned tree .",
    "we now prove that one instance of each extreme ray always remains in the fully pruned tree .",
    "suppose , by contradiction , that for some fixed @xmath8 and each @xmath56 with index set @xmath57 , @xmath58 is a ( single ) extreme ray whose every appearance is removed in our procedure for pruning the tree .",
    "this means that no keeper leaf can be @xmath59 , since keeper leafs are never removed .",
    "therefore , each @xmath38 keeper leaf with @xmath56 has a @xmath59 node as its ancestor in the original tree .",
    "recall that each non - keeper is to the left of its respective keeper leaf and consider the right - most appearance of @xmath59 in the original tree .",
    "assumed to be extreme , no @xmath59 node can have an @xmath8-node descendant , according to lemma  [ lem1 ] .",
    "therefore , no one of these nodes can be ancestor to another one , implying that each @xmath59 node is either to the right or left of every other one , so there is one of them that is furthest to the right . ]",
    "this right - most appearance will be ancestor to a keeper @xmath38 leaf with @xmath56 since otherwise the non - keeper it is ancestor to would be to the right of its respective keeper . since this @xmath59 node is ancestor to a keeper , it is not removed as part of an entire sub - tree @xmath51 ( @xmath51 is only removed if it has no keepers ) so it must be removed as the extra non - leaf that is removed along with @xmath51 . for type-@xmath4 removals , it turns out that extra non - leaf @xmath53 is not extreme ( see appendix  [ app7 ] for a proof ) so this @xmath59 node must be removed as type-@xmath0 , that is , as parent @xmath50 of @xmath51 . for the ( generally , partially pruned ) tree to which this type-@xmath0 removal is applied , then according to how we decide which type of removal to use , there exists a @xmath60 leaf in @xmath51 , which is a descendant of @xmath50 , whose corresponding keeper is not a descendant of @xmath50 . since",
    "ancestral relationships are not altered during pruning ( for those nodes that remain in the tree),@xmath61 this means that in the original tree , this non - keeper @xmath60 leaf in @xmath51 is a descendant of @xmath50 and its corresponding keeper is not .",
    "thus , the keeper @xmath60 leaf is to the right of @xmath50 in the original tree , since that keeper is to the right of a descendant of @xmath50 ( that non - keeper ) and is not itself a descendant of @xmath50 , implying that keeper is in the right child sub - tree of its closest common ancestor with @xmath50 .",
    "also in the original tree , this keeper @xmath60 leaf is either @xmath62 or else has a @xmath62 ancestor , and in either case this @xmath62 node can not be a descendant of @xmath50 ( or else the keeper @xmath60 leaf would be a descendant of @xmath50 ) , so is either ancestor to @xmath50 or is to the right of @xmath50 .",
    "if it is ancestor to @xmath50 , @xmath63 , because @xmath62 has @xmath50 as an @xmath8-node descendant , so by lemma  [ lem1 ] can not be extreme , which @xmath59 is , by assumption . if , on the other hand , this @xmath62 is to the right of @xmath50 , we also have that @xmath63 , because @xmath50 is the right - most @xmath59 node . in either case ,",
    "the nearest @xmath8-node to that non - keeper @xmath60 leaf in child sub - tree @xmath51 of @xmath50 is @xmath63 , so is not @xmath50 , implying @xmath51 must have an @xmath8-node in it , which is thus a descendant of @xmath50 .",
    "since @xmath50 is @xmath59 , lemma  [ lem1 ] then tells us that @xmath59 is not extreme , a contradiction , proving that every extreme ray is present at least once in the fully pruned tree .",
    "thus , our fully pruned tree , which is a full binary tree , has @xmath30 leaf nodes and @xmath48 nodes in all , and every extreme ray is present as one of its nodes . since the root of the original tree is not extreme and is never removed , there can be no more than @xmath64 extreme rays .",
    "it is shown in appendix  [ app2 ] that this bound can be saturated when @xmath43 , which completes the proof.@xmath65",
    "we have proved a necessary condition for any finite - round locc protocol , stated in theorem  [ thm1 ] .",
    "we have also demonstrated ( appendix  [ app3 ] ) that this necessary condition is violated extensively by separable operations , this violation growing without bound as the number of parties increases .",
    "considering an arbitrary sep , violating our bound becomes a general sufficient condition that the sep can not be exactly implemented by locc .",
    "we note that for the bipartite case , we have an independent argument that provides a better bound whenever @xmath66 , that bound being @xmath67 .",
    "this shows that , at least for @xmath68 , the bound of theorem  [ thm1 ] can only be saturated by finite - round locc when @xmath43 .",
    "in addition , we note that our necessary condition for locc is demonstrably not sufficient .",
    "an example is the sep presented in @xcite as the first demonstration that sep and locc are inequivalent . in this example , for which @xmath69 and @xmath68 , we have that @xmath70 , so that @xmath71 .",
    "the bound in our theorem is satisfied , but this sep can not be exactly implemented by locc .",
    "we hope that these ideas will open new avenues toward understanding locc .",
    "one important outstanding question is whether , for a given sep , there is a relationship between the extent to which the bound in theorem  [ thm1 ] is violated and how closely the sep can be approximated by locc .",
    "it is also of interest to determine whether or not the bound in theorem  [ thm1 ] can be violated by infinite - round locc , an important question that we have as yet been unable to answer .",
    "_ acknowledgments _  the author would like to thank li yu for helpful suggestions and especially dan stahlke for his numerous and very helpful comments and suggestions .",
    "this work has been supported in part by the national science foundation through grant no .",
    "here , we construct seps as sets of positive operators @xmath73 for every @xmath33 and for which theorem [ thm1 ] is violated maximally , having @xmath72 . define operators @xmath74 , where @xmath75 , @xmath76 , @xmath77 is the dimension of hilbert space @xmath13 with parties ordered such that @xmath78 , and the state on party @xmath8 s subsystem is @xmath79 here , @xmath80 and for @xmath81 , @xmath82 , @xmath83 is the standard basis for party @xmath8 , and @xmath30 is chosen as any prime number exceeding @xmath84 . since for each positive operator @xmath38 the local parts are the rank-@xmath0 projectors @xmath85 , each @xmath31 is thus an extreme ray of its respective convex cone .",
    "this means that @xmath86 and @xmath72 , an extensive violation of theorem  [ thm1 ] and the maximal possible value of this sum .",
    "we need to show that the set @xmath73 satisfies closure , @xmath87 .",
    "we have , @xmath88 where @xmath89 is the kronecker delta , vanishing unless its two arguments are equal , in which case it is equal to unity .",
    "recall that @xmath80 and @xmath82 , @xmath81 .",
    "suppose @xmath90 .",
    "then , @xmath91 , since the right - hand side of this inequality is no greater than @xmath92 .",
    "we conclude that equality of the two arguments in the kronecker delta in the last line of requires @xmath93 .",
    "similar arguments , proceeding sequentially with decreasing @xmath8 starting next from @xmath94 , shows that @xmath95 .",
    "thus , the right - hand side of is equal to @xmath96 , the identity on the full input hilbert space , as desired .",
    "finally for each @xmath33 , we show the existence of sets of kraus operators corresponding to the positive operators given in the previous paragraph , which are the unique product kraus representation for their associated quantum channel .",
    "define kraus operators @xmath97 , with @xmath98 defined above .",
    "define normalized states @xmath99 with @xmath100 a set of linearly independent product states on the @xmath101 parties excluding party @xmath0 ( this requires that at least one output dimension of those last @xmath101 parties exceeds its input , in order that the overall output dimension is not less than @xmath30 , the number of these independent states ) . then , since no two of the @xmath102 are proportional to each other , the conditions of corollary @xmath0 of @xcite are met for this set of kraus operators ( with a bipartite split between party @xmath0 and all the rest ) , which implies that no linear combination of the @xmath103 is a product operator ( apart from the @xmath103 s themselves ) .",
    "this , in turn , implies that the set @xmath104 is the unique product representation for the given channel .",
    "therefore , there is no other kraus representation that could possibly be locc , and these channels are as far from locc as possible , in the sense of theorem  [ thm1 ] of the main text , as claimed .",
    "if @xmath8-node @xmath10 has another @xmath8-node that is its descendant , then party @xmath8 made a measurement after the measurement that produced node @xmath10 . then , by , the positive operator labeling node @xmath10 is a sum of those positive operators labeling the descendant @xmath8-nodes produced by the later measurement . in turn ,",
    "some of those descendants may themselves have other descendant @xmath8-nodes produced by a subsequent measurement , so are sums of those operators corresponding to the latter nodes . eventually if we continue toward the leaves , we end up with nodes that are labeled by the @xmath31 defining the separable operation , so that node @xmath10 is seen to be labeled by a sum of those @xmath31 .",
    "this means node @xmath10 can not be an extreme ray in the convex hull of the @xmath31 unless all the @xmath31 entering this sum are proportional to each other , which is impossible in the canonical locc trees we are considering.@xmath65",
    "for type-@xmath4 removals ( of sub - tree @xmath51 with present sibling @xmath53 ) , we need to show that @xmath53 is a non - leaf that is not extreme .",
    "our argument will utilize the fact that @xmath53 and the root of @xmath51 were siblings in the original tree , so we need to be sure this is always the case , even following earlier removals . the only way siblings change during the pruning process is via type-@xmath0 removals , since type-@xmath4 removals do not change sibling relationships .",
    "suppose there was a type-@xmath0 removal of @xmath105 , child sub - tree of @xmath106 , where the other child sub - tree of @xmath106 was @xmath107 and the sibling of @xmath106 before this removal was @xmath108 .",
    "this removal only changes sibling relationships by changing the sibling of @xmath108 from @xmath106 to the root of @xmath107 , which we denote as @xmath109 , see figure  [ fig2 ] .",
    "we now argue that there will never be a type-@xmath4 removal involving nodes at the positions of this newly created sibling pair , even if their identities change further through subsequent pruning .",
    "since @xmath107 presently has a keeper leaf ( because otherwise the removed @xmath105 was not a maximal keeperless sub - tree , which are the only ones we remove ) , it will always have a keeper no matter how much further pruning occurs , since keepers are never removed , so a type-@xmath4 removal involving these nodes can only occur if the new sibling sub - tree of @xmath107 ( call this sub - tree @xmath110 ) is keeperless , which means it was keeperless to begin with , even before the previous type-@xmath0 removal that changed the sibling pair .",
    "this means that @xmath110 is to the right of @xmath107 , because otherwise @xmath110 would have been a maximal keeperless sub - tree , removed before that previous type-@xmath0 removal , since the pruning proceeds from left to right .",
    "however , if it is to the right , then the keeper leafs corresponding to the non - keepers in @xmath110 are further to the right and therefore not in @xmath107 , so removal of @xmath110 will be via a type-@xmath0 removal , not type-@xmath4 , and according to the above discussion , this is true no matter what pruning takes place between the previous type-@xmath0 removal and this one .",
    "therefore , all type-@xmath4 removals involve siblings that were siblings in the original tree .",
    "a type-@xmath0 removal creates a new sibling pair , @xmath109 and @xmath108 , but this pair will never be involved in a subsequent type-@xmath4 removal , showing that type-@xmath4 removals always involve siblings that were siblings in the original tree . ]",
    "consider a type-@xmath4 removal of @xmath51 , a child sub - tree of @xmath50 , with @xmath50 s other child @xmath53 removed along with @xmath51 .",
    "we can now prove that @xmath53 is not extreme .",
    "from the discussion above , we know that the root of @xmath51 was sibling to @xmath53 in the original ( canonical ) tree , so these two are not proportional and are both @xmath8-nodes for the same @xmath8 .",
    "assume , by contradiction , @xmath53 is extreme .",
    "then by lemma  [ lem1 ] , @xmath53 is an @xmath8-node with no @xmath8-node descendants , so @xmath53 must be proportional to @xmath31 for every @xmath26 such that @xmath38 is one of the keeper leafs that are descendants of @xmath53 . since every leaf in @xmath51 has its corresponding keeper leaf as a descendant of @xmath53 , the closest @xmath8-node to each and every leaf in @xmath51 must also be proportional to this same @xmath31 ( since the root of @xmath51 is an @xmath8-node , there is at least one such node in @xmath51 ) . therefore by of the main text , every @xmath8-node in @xmath51 , including its root node , is proportional to this same @xmath31 . in other words ,",
    "the root of @xmath51 is proportional to @xmath53 , a contradiction , proving that @xmath53 is not extreme .",
    "repeating the exact same argument starting from the assumption @xmath53 is a leaf leads to the same contradiction , thus proving @xmath53 is a non - leaf , and we are done .",
    "we will now show that any locc protocol satisfying the following two conditions saturates the bound in theorem  [ thm1 ] , @xmath111 :    1 .",
    "[ itema1]each party measures once and only once with the same ordering of the parties no matter which outcomes were obtained by the preceding parties .",
    "in addition , each of these measurements has exactly two outcomes .",
    "+ along any branch of the associated locc tree , party @xmath0 starts with a two - outcome measurement , followed by a two - outcome measurement by party @xmath4 , which is followed by a two - outcome measurement by party @xmath112 , and so on until each party has measured once , party @xmath33 always making the final measurement .",
    "for the entire protocol , party @xmath8 has @xmath113 different measurements , which measurement that party makes being determined by the outcomes of all previous parties measurements .",
    "party @xmath8 has a total of @xmath114 measurement outcomes . 2 .",
    "each of the @xmath115 outcomes for party @xmath8 is a distinct extreme ray in the cone generated by the collection of these outcomes .",
    "note that for a protocol satisfying the preceding condition [ itema1 ] , many of the @xmath31 ( fixed @xmath8 but different @xmath26 ) will be equal to each other , which explains why party @xmath116 has only @xmath115 extreme rays , rather than the maximum possible number , @xmath117 .    here",
    "is one specific example that does the trick . for",
    "each of party @xmath8 s measurements , indexed by @xmath118 , let one kraus operator be a projector onto ( normalized ) pure state @xmath119 , with the other outcome @xmath120 . as these are both projectors , the @xmath31 are equal to these kraus operators , @xmath121 choose the set of pure states @xmath119 in each @xmath13 such that no two are the same and no two are orthogonal to each other .",
    "then , the following argument shows that each and every @xmath31 is an extreme ray in the convex cone generated by the collection of all of them ( many are repeated , as explained above ) : the pure state projectors @xmath122 are each an extreme ray in the cone of the full set of positive operators acting on @xmath13 , so are necessarily also extreme in the cone of the collection of @xmath31 .",
    "if @xmath13 is two - dimensional , then @xmath123 is also extreme for each @xmath124 , by the same argument . otherwise , @xmath123 has rank exceeding unity so is not extreme in the cone of positive operators , but is nonetheless on the boundary of that set , since @xmath125 .",
    "note also that @xmath126 for every @xmath127 .",
    "suppose @xmath128 , with @xmath129 .",
    "taking the diagonal element , @xmath130 , of this equation leads to @xmath131 , or @xmath132 , a contradiction since @xmath133 .",
    "therefore , @xmath123 can not be written as a positive linear combination of all the others , so is an extreme ray in the cone of their collection .",
    "we conclude that each and every @xmath134 is an extreme ray , @xmath135 , and @xmath136 , saturating the bound .    if the last party omits his measurement for one of the outcomes of the next - to - last party , this removes a pair of leaf nodes , replacing it with a single leaf .",
    "therefore , this reduces @xmath30 by unity to @xmath137 .",
    "the number of extreme rays is reduced by two , since the new leaf was counted as extreme before the pair of leafs was removed , so the bound is still saturated . by continually omitting single measurements by the last party to measure along a given branch , @xmath30 is reduced by unity for each omission , and the number of extreme rays",
    "is reduced by two . in this way ,",
    "we can obtain examples saturating the bound for any @xmath30 satisfying @xmath138 [ @xmath30 can not be less than @xmath139 , since all @xmath33 parties perform a non - trivial measurement at least once in the full protocol ; alternatively , one may note that according to the way we count parties , @xmath140 , so @xmath141 , which also shows @xmath142 .",
    "this completes the proof of theorem  [ thm1 ] ."
  ],
  "abstract_text": [
    "<S> we give a conceptually simple necessary condition such that a separable quantum operation can be implemented by local operations on subsystems and classical communication between parties ( locc ) , a condition which follows from a novel approach to understanding locc . </S>",
    "<S> this necessary condition holds for any number of parties and any finite number of rounds of communication and as such , also provides a completely general sufficient condition that a given separable operation can not be exactly implemented by locc . </S>",
    "<S> furthermore , it demonstrates an extremely strong difference between separable operations and locc , in that there exist examples of the former for which the condition is extensively violated . </S>",
    "<S> more precisely , the violation by separable operations of our necessary condition for locc grows without limit as the number of parties increases . </S>"
  ]
}