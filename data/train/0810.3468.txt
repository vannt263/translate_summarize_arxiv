{
  "article_text": [
    "gnu octave is a numerical computing platform based on programming with matrices as a fundamental construct .",
    "several modeling and simulation research work benefit through the reduced time and complexity offered by matrix programming environments .",
    "modeling and simulation applications when developed through exploratory analysis , or initial speculative analysis of parameters , optimization in not the key goal .",
    "however , once a stable model is created , running parametric search over a large search space requires the creation of optimized models .    optimizing computational models written in matrix languages , for time and space usage , help to directly speed up the search process by reducing time and resources ( memory , diskspace ) .",
    "there are many ways of optimizing program performance , like tracing , logging , and profiling .",
    "profiling is the only method where the runtime is proportional to program size , unlike the other methods which depend on the execution time of the program .    clearly ,",
    "for large scale parametric searches , we can not use tracing or logging for optimization , due to enormous log data that needs post - analysis .",
    "this makes profiling as an efficient tool for program optimization . profiling for matrix programming languages like gnu octave , help identify resource usage , inefficient function usage , program flow , piecemeal function run - times and a complete idea of the running times spent on subroutines as a percentage of the program lifetime .",
    "the landmark work in profiling is the gnu debugger ( gdb ) @xcite , which initiated the idea of a call - graph profiler . since gdb",
    ", many types of profilers have been proposed and built , including dynamic instrumented profilers , static sampling profilers , flat profilers , call graph profilers .",
    "the java virtual machine ( jvm ) provides a complete infrastructure for dynamic program analysis , and encourages custom built profilers for querying and collecting statistics from the jvm @xcite .",
    "this is called the java virtual machine profiling interface ( jvmpi ) , and represents the state - of - the art in profiling . using jvmpi many successful profilers can be built for generic profiling or integrated into the existing applications .",
    "we present a call - graph profiler for matrix based languages , implemented on the freely available ( open source ) gnu octave platform .",
    "with knowledge of octave internals @xcite , we chose gnu octave platform for creating profiler .",
    "our work addresses concerns of optimization of numerical computational models , discrete simulations , and exploratory analysis , through the use of profiling .",
    "important metrics for the profiler are minimal sampling - time , minimal memory and resource usage from profiler , dynamic data collection , meaningful output presentation .",
    "we build a dynamic instrumentation profiler , with dispatch built into the octave interpreter , which allows us to create profilers of increasing complexity from flat profiler till the call - graph profiler .",
    "the terminology in use while describing the profiler statistics are described as follows    1 .",
    "_ total time _ : time taken for the subroutine to run , excluding the runtime of subroutines it calls .",
    "this includes only the computational times , and not the times for functions called during computation .",
    "self time _ : the run - time of a subroutine including its calls to the sub - functions .",
    "this is greater than or equal to the total - time of the subroutine .",
    "3 .   _ average time _ : the average of the total times , over all calls to the subroutine . the self time , and total time are reported as averages over the total calls .",
    "4 .   _ percentage time _ : the fraction of the program runtime for which the given subroutine has been executing . 5 .   _",
    "number of calls _ : total number of times a subroutine was called .",
    "6 .   _ cumulative time _ :",
    "this gives the sum of the times of all subroutines , that have lesser self time than the current function .",
    "results are sorted in descending order of self time , and increasing cumulative time .    in this paper",
    ", we use the terms function and subroutine interchangeably",
    ".    the rest of the paper is organized as follows . in sec",
    "ii , we report the profiling api required to create profilers on gnu octave .",
    "the algorithms used for the flat profiler and the call - graph profiler are discussed in sec iii , iv .",
    "benchmarking results of the profilers are presented in sec v , to illustrate accuracy and confidence on the profiled results",
    ". finally , in sec vi , we review the features and limitations of our profiler framework for octave , and indicate the future work required to integrate the profiler into the main gnu octave project .",
    "most profiling systems work by collecting data of a program at runtime .",
    "profilers collect statistics , and the time of occurrence for each piece of information . to enable collection of profiling events like function invocation , object creation , deletion , function call completion , and such interpreter - system specific data ,",
    "profilers need an event delivery mechanism from the interpreter itself .",
    "this makes building a profiler for gnu octave language as two tasks ; building interpreter api event delivery mechanism to the profiler , and then building profilers to make use of the events .",
    "this separation of concerns , was inspired from the profiler design of languages like python @xcite , and ruby @xcite .",
    "the rest of this section describes the events of interest to our profiler , and api for the event delivery system .",
    "the simplest profiler ( flat profilers , sec iii ) , need information about the occurrence of two events ; the function call , and function return .",
    "since octave is not an object oriented system we do not have object creation , deletion , nor member function invocation and such events can not be reported.in a more complicated profiler ( call - graph profiler , sec iv ) , the same events ( function call , return ) have attributes like the function - caller and function - callee passed to the profiler program .",
    "we do not trap events like variable state changed , entering a program section corresponding to line number in source code , or leaving such a program section , etc .",
    "the implications of these events are discussed in sec vi .    the api design of the event - reporting system is based on a global singleton class _ octave_profiler _ , which is instantiated by the octave interpreter .",
    "the class _ octave_profiler _ , has a member variable _ profiler_fcn _ which serves as a event reporter function .",
    "this is set by the profiler program , using a call to _",
    "static bool set_profiler(profiler_function profile);_. when set by a profiler , the _ profiler_fcn _ is invoked from within the octave interpreter whenever execution invokes a function or returns from a function .",
    "the profiler stops profiling , by invoking the _",
    "static bool clear_profiler ( ) ; _ which returns the handle _",
    "profiler_fcn _ to a null , and prevents event delivery .",
    "the event delivery is managed by function + _ static void send_event ( const octave_function fcn , profiler_function_type ftype , profiler_call_state cstate ) ; _ + from the internals of the octave interpreter . in this invocation _",
    "fcn _ is the function in question , and _ cstate _ indicates execution has entered or returned from a function .",
    "send_event _ function abstracts the call sequence _ profile_fcn(fcn , ftype , cstate ) ; _ by keeping it private .    this api in short provides a hook for the profilers to start / stop receiving events , and a base class that implements this mechanism .",
    "function profilers are written by deriving from the primitive base class _ profile_base_. the base class provides timing information , and the setup tear - down for the events as discussed above .",
    "the user level profiler interface is through the function _ profile _ , which has usage : * profile [ onoffinfo ] [ graphflat ] * , where the options are indicated in square brackets",
    ". a typical use case would be :    1 .",
    "[ profile_usage ] profile on graph _ % use a call - graph profiler _ 2 .",
    "bch ( ) _ % invoke the script _ 3 .",
    "profile info _",
    "% stop profiling & printout the results_.    the _ profile _ is responsible for creating instances of call - graph or flat profilers , and pass on the start , stop , print requests to these profilers using api of the profiler , as    1 .",
    "_ static void start_profiling ( ) _ 2 .   _ static void stop_profiling ( ) _ 3 .",
    "_ void print_profile ( ) _    the profilers to extend the base class _ profile_base_. this completes the description of the octave side profiling api , and the user interface for profilers .",
    "flat - file profilers are very simple , and only count the average statistics of the program . the only attribute information saved by flat - profilers are saved in the structure , _ call_elem _ , which has fields +    1 .   long int ncalls ; 2 .",
    "double total_time ; 3 .",
    "double self_time ; 4 .   std::string key ;    for each function that is invoked in the program .",
    "the meaning of each field , is self explanatory and the terms are defined in the introduction .",
    "nowhere are absolute times measured , and programs rely on relative time separation of events .",
    "the timing information is stored in the class objects of _ time_elem_. +    1 .",
    "double delta ; //incremental time from the previous routine that a function is called 2 .",
    "double tick ; //time for running our kids / child functions    the relative times of events noted down at each event , are finally added up to obtain the statistics for flat - profiler output .",
    "the class _ profiler_flat _ implements the flat - profiler , by extending _",
    "profile_base_. the algorithm is implemented using a stack data structure .",
    "the essential algorithm is the same for the complex call - graph profiler too .",
    "the profiler dispatch function delivers the function invoke and return events by interfacing with the profiler api , describe in sec ii .",
    "the profiler function for the flat - profilers is given as , + _ static void profile_func(const octave_function * fcn , profiler_function_type ftype , profiler_call_state cstate ) ; _    this function further delivers the events to the particular call - processing routines that handle event call , return separately . the function _",
    "profile_func ( ) _ is modeled as a template pattern , that delegates the events to particular handlers .",
    "the algorithm for the flat - profiler is summarized as ,    1 .",
    "when profiler is started , note starting time .",
    "register the profile event handler 3 .   on call event",
    ": + push a _",
    "time_elem _ instance set to zero , into time-stack.this time - stack is a false call - stack , as it mirrors the interpreter call - stack , functions are invoked and returned .",
    "4 .   on return event",
    "check if hashtable has an instance of record for the given function .",
    "otherwise create a new _ call_elem _ instance for this function and set the name to the function .",
    "2 .   increase the number of calls on this record by 1 .",
    "compute the relative time difference between the call and return events ; use the time_elem object on the top of time - stack .",
    "4 .   add the total time to the call record s corresponding field .",
    "add the self time to the call record s corresponding field.compute self time by subtracting from total time , the value of tick .",
    "update the record in the hashtable , indexed by the function name as key .",
    "if the call - stack of time , is not empty add the cost of this call , to the parent in the parents , time element tick field .",
    "repeat the steps 3 - 4 , till stopped .",
    "clear the profiling handler , and receive no more events .",
    "once profiling is stopped , prepare to print output .",
    "compute % times .",
    "sort the hashtable entries according to the total - time field of record .",
    "print out according to descending order of total times .",
    "it is important to note the source of this algorithm is obtained from profilers for popular programming languages @xcite , @xcite .",
    "we attribute the idea to the python , and ruby implementations .",
    "call - graph profiler builds the profiling output with the program execution , as a directed graph with arcs .",
    "the arcs point from the caller to the callee , and conveys the time of execution of the callee function .",
    "second order statistics and more than averages can be obtained by sifting through the profiling data , and it becomes much valuable than flat profiling .",
    "there are particular cases where flat profiling information is not helpful ; in general numerical routine execution times depend on the size of the input argument , and the average total time used for routines that are not o(1 ) , skew the profiled data .",
    "call - graph profilers side step such problems by assigning second order statistics , which include the self , average , and total times for each arc of a function call , and profiled function s complexity can be clearly observed without skewing the data . from definition of a call - graph , the parent - child relationships ( caller - callee relations ) from the profiled information are also immediately available .",
    "it is to be noted , that in our implementation not every parent - child relationship is saved , and the data is averaged for each unique caller - callee information , in order to reduce the profiler output to a meaningful subset .",
    "data structures derived from _",
    "call_elem _ , and _",
    "time_elem _ with extra variables , to contain the caller - callee relationship records are used",
    ".      the call - graph profiler is implemented in the _ class profile_callgraph _ which as in the flat - profiler derives from the _ profile_base _ class .",
    "the call - graph profiler is itself , so to speak , an incremental improvement over the flat - profiler .",
    "it s profiler event reported , dispatch and logging mechanisms are similar to flat - profiler , and not reiterated here .",
    "much of the algorithm of the call - graph profiler is very - similar to the flat - profiler .",
    "the differences remain ;    1 .   function call - event",
    ": when call - stack is empty , all call events are added to the toplevel callee hashtable .",
    "this saves the caller - callee information .",
    "function return - event : the returning function is added as a callee to top - of - stack ( tos).then the caller for this returning function set in the hash - table , and its timing record updated . similarly the callee for the tos function is set as the returning function , and the caller records updated .",
    "3 .   printing : the data is printed out as a tree , after sorting according to descending order .",
    "the printing of results follows a tree like pattern , illustrating the call - graph nature of the program execution .",
    "to evaluate the flat and call - graph profilers a test case comprising of a communication system simulation program was evaluated .",
    "the program , and associated files were about 1672 lines of octave code , excluding comments .",
    "this code set is chosen for its availability as much as its similar performance on the flat - profiler and the call - graph profilers , due to the constant input modulation sizes used all over the simulation program .",
    "the profiling is carried on at the toplevel program using the sequence of calls to _ profile _ function mentioned in sec [ profile_usage ] .",
    "the flat profiler , gives an average performance of the functions across the runtime of the program .",
    "the run time of the programs are reported in seconds , while the ms / call indicates milliseconds / call .",
    "it should be noted that measured results are more finely - granular than the ones reported .",
    "results are rounded - off due to formatting constraints .    from the results in table 1 ,",
    "we see that cpu hogging function is gf_add which takes about   29% of the program runtime .",
    "this information , along with the self - times and number of calls can be used to arrive at possible optimization candidates .",
    ".flat - profiler results [ cols= \" < , < , < , < , < , < , < \" , ]     the call - graph profiler output is more involved as shown in fig 1 .",
    "the important difference is , the call times , count information are collected as the caller - callee basis , and reported so .",
    "the call - graph profiler in this case helps to identify functions that perform on a o(@xmath0 ) complexity basis .",
    "the voluminous output of the call - graph profiler is reduced to the first few lines for brevity sake , is presented in the figure 1 .",
    "the same benchmark program was run on the call - graph profiler as well .",
    "[ fig_ncalls)a ]          there is a significant performance hit due to the profiling . in our design ,",
    "we explicitly compensate for the profiler runtime , and this is not a problem .",
    "the reported overhead times are found after compensation , and for the flat - profiler .",
    "the reported overhead time can only be accounted for , using a free parameter computed before profiling on each profiling session .",
    "this is called the _ bias _ value , as reported in the python profiler @xcite . in our profiler design",
    "we do not include such free parameters .",
    "such an overhead observed can only be attributed to the times that are not computable within the profiler .",
    "our hypothesis attributes the time due to the interpreter s delay in invoking the profiler for each function call and return events .",
    "this agrees well with the observed o(n ) overhead time dependence on the number of function calls . in figure 2 ,",
    "a tight - loop function was profiled with a number of calls , to obtain the overhead information presented in the graph .",
    "the linear trend observed in the overhead time seems to justify the apparent constant overhead time for the interpreter which can not be compensated without computing a constant bias factors .    from figure 2 , the bias factor would seem to be the slope of the overhead time , which can be estimated to be around an overhead time of 8.1706x@xmath1 seconds / call .",
    "this is however a free parameter , and dependent on implementation details .",
    "it should be noted that , most profilers suffer from the performance hit due to the profiling overhead .    on a more general note , from the benchmark tests we observe the total overhead times to be less than 0.5% of the total program runtime .",
    "our design has optimized the overhead time compared consistently from our initial prototype by compensating for each measurable profiling time .",
    "the call - graph profiler performs with a larger overhead compared to the flat - profiler ; we estimate a rough factor of @xmath2 increase in the overhead time , for the call - graph profiler .",
    "the explanation for this variation we think , to be the memory creation and cleanup associated with the data structures used to build the call - graph .",
    "also a non - trivial i / o times are associated with the call - graph procedures .",
    "[ fig_ncalls_b ]          certain features which are not implemented at present are not limitations to the profiler .",
    "these include    1 .",
    "resource profiling for opened - files , network - connections , database handles ; 2 .",
    "arguments passed from the caller - callee function are not traced ; 3 .",
    "event filtering , and selective profiling .",
    "the limitations of the profiler reported below include features that can not be added in the current design .    1 .",
    "memory profiling needs deeper access to the interpreter than the present framework can allow .",
    "2 .   line stepping and watch on variables are not possible , and more appropriate for a debugger .",
    "non - local exits are not traced ; this means uncaught exceptions are not profiled , and would end in a aborting of execution .",
    "this is however classified as a bug in the user s octave script program .",
    "we also note that , complete integration of the profiler into the codebase of the gnu octave project requires a different approach to creating the profiler - api",
    ". such an profiler mechanism would work by walking the abstract syntax tree ( ast ) , and passing function call and return events to the profiler . from our experimental work , we see this as feasibility to bring the advantages of the call - graph profiler to octave , in the future .",
    "in this paper we have demonstrated a flat profiler and a call - graph profiler for matrix based programming language like gnu octave . we have reported the profiling overhead , benchmark the performance for both the profiler . further the limitations and possible extensions on this design are enumerated .    16 susan l. graham ,",
    "peter b. kessler , and marshall k. mckusick .",
    "gprof : a call graph execution profiler , proceedings of the sigplan 82 , pp 120126 .",
    "sheng liang , deepa viswanathan , comprehensive profiling support in the java virtual machine , 5th usenix conference coots 99 .",
    "guido van rossum et - al , python ( www.python.org ) profiler code : python - svn / lib / profile.py .",
    "yukihiro matsumoto , ruby ( www.ruby-lang.org ) profiler code : ruby / lib / profiler.rb .",
    "john w. eaton , octave project ( www.gnu.org/software/octave ) , accessed feb,2007 .",
    "muthiah annamalai , hemant kumar , leela velusamy , octave - gtk : a gtk binding for gnu octave , proceedings of octave meeting 2006 , arxiv : cs/0604073v2 [ cs : se ] 28 apr , 2006 ."
  ],
  "abstract_text": [
    "<S> we report the design and implementation of a call - graph profiler for gnu octave , a numerical computing platform . </S>",
    "<S> gnu octave simplifies matrix computation for use in modeling or simulation . </S>",
    "<S> our work provides a call - graph profiler , which is an improvement on the flat profiler . </S>",
    "<S> we elaborate design constraints of building a profiler for numerical computation , and benchmark the profiler by comparing it to the rudimentary timer start - stop ( tic - toc ) measurements , for a similar set of programs . </S>",
    "<S> the profiler code provides clean interfaces to internals of gnu octave , for other ( newer ) profiling tools on gnu octave . </S>"
  ]
}