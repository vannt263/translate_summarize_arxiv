{
  "article_text": [
    "astronomical many - body simulations have been widely used to investigate the formation and evolution of various astronomical systems , such as planetary systems , globular clusters , galaxies , clusters of galaxies , and large scale structures . in such simulations ,",
    "we treat planetesimals , stars , or galaxies as particles interacting with each other .",
    "we numerically evaluate interactions between the particles and advance the particles according to newton s equation of motion .    in many cases ,",
    "the size of an astrophysical many - body simulation is limited by the available computational resources .",
    "simulation of pure gravitational many - body system is a typical example .",
    "since the gravity is a long - range interaction , the calculation cost is @xmath0 per timestep for the simplest scheme , where @xmath1 is the number of particles in the system .",
    "we can reduce this @xmath0 calculation cost to @xmath2 , by using some approximated algorithms , such as the barnes - hut treecode ( barnes , hut 1986 ) , but the scaling coefficient is pretty large .",
    "thus , the calculation of the interaction between particles is usually the most expensive part of the entire calculation , and thus limits the number of particles we can handle . smoothed particle hydrodynamics ( sph , lucy 1977 , gingold , monaghan 1977 ) , in which particles are used to represent the fluid , is another example . in sph calculations ,",
    "hydrodynamical equation is expressed by short - range interaction between particles .",
    "the calculation cost of this sph interaction is rather high , because the average number of particles which interact with one particle is fairly large , typically around 50 , and the calculation of single pairwise interaction is quite a bit more complex compared to gravitational interaction .",
    "astrophysics is not the only field where the particle - based calculation is used .",
    "molecular dynamics ( md ) simulation and boundary element method ( bem ) are examples of numerical methods where each element of the system in principle interacts with all other elements in the system . in both cases ,",
    "approaches similar to barnes - hut treecode or fmm ( greengard , rokhlin 1987 ) help to reduce the calculation cost , but the interaction calculation dominates the total calculation cost .    one extreme approach to accelerate the particle - based simulation is to build a special - purpose computer for the interaction calculation .",
    "two characteristics of the interaction calculation make it well suited for such approach .",
    "firstly , the calculation of pairwise interaction is relatively simple . in the case of gravitational interaction ,",
    "the total number of floating - point operations ( counting all operations , including square root and divide operations ) is only 20 .",
    "so it is not inconceivable to design a fully pipelined , hardwired processor dedicated to the calculation of gravitational interaction . for other application like sph or molecular dynamics , the interaction calculation is more complicated , but still hardware approach is feasible .",
    "secondly , the interaction is in its simplest form all - to - all . in other words ,",
    "each particle interacts with all other particles in the system .",
    "thus , there is lots of parallelism available .",
    "in particular , it is possible to design a hardware so that it calculate the force from one particle to many other particles in parallel . in this way we can reduce the required memory bandwidth . of course",
    ", if the interaction is of short - range nature , one need to implement some clever way to reduce calculation cost from @xmath0 to @xmath3 , and the reduction in the memory bandwidth is not as effective as in the case of true @xmath0 calculation .",
    "the approach to develop specialized hardware for gravitational interaction , materialized in the grape ( `` gravity pipe '' ) project ( sugimoto et al .",
    "1990 ; makino and taiji 1998 ) , has been fairly successful , achieving the speed comparable or faster than the fastest general - purpose computers for the price tag one or two orders of magnitude smaller . for example , grape-6 , which costed 500 m jye , achieved the peak speed of 64 tflops .",
    "this speed is favorably compared to the peak speed of the earth simulator ( 40tflops ) or asci - q(30tflops ) , both costed several tens of billions of jye .",
    "a major limitation of grape is that it can not handle anything other than the interaction through @xmath4 potential .",
    "it is certainly possible to build a hardware that can handle arbitrary central force , so that molecular dynamics calculation can also be handled ( ito et al . 1993 ; fukushige et al 1996 ; narumi et al . 1999",
    "; taiji et al 2003 ) .",
    "however , to design a hardware that can calculate both the gravitational interaction and , for example , an sph interaction is quite difficult . actually , to develop the pipeline processor just for sph interaction turned out to be a rather difficult task ( yokono et al .",
    "this is provably because the sph interaction is much more complex than gravity .",
    "computing devices which uses fpga ( field - programmable gate array ) chips could offer the level of flexibility that was impossible to achieve with the conventional grape approaches . as its name suggests , fpga is a mass - produced lsi chip , consisting of a large number of logic elements and switching network . by programming these logic elements and switching network , we can implement an arbitrary logic design , as far as it can fit to the chip used .",
    "thus , a single hardware can be used to implement various pipeline processors , such as that for gravity , sph , and others .",
    "such fpga - based `` reconfigurable '' computing device has been an active area of research since splash-1 and splash-2 ( buell et al .",
    "1996 ) , and several groups , including ourselves , have tried to apply the idea of reconfigurable computing to particle simulations ( kim et al .",
    "1995 , hamada et al . 2000 , spurzem et al . 2002 ) .",
    "hamada et al .",
    "( 2000 ) called this approach `` programmable grape '' or progrape .",
    "( 12 cm,8 cm)./figure1.eps    figure [ fig1 ] shows the basic structure of a progrape system .",
    "it consists of a programmable grape hardware and a host computer .",
    "the programmable grape hardware typically is composed of fpga chips to which the interaction pipelines are implemented , a particle memory , and an interface unit , and calculates the interaction @xmath5 between @xmath6-the particle and other particles expressed as @xmath7 where @xmath8 is the physical value of the @xmath6-th particle , such as position and velocities , and @xmath9 is a user - specified function .",
    "we specify the function @xmath9 by programming fpga .",
    "the physical values @xmath10 of all particles are stored in the particle memory and supplies them to the interaction pipeline .",
    "the physical values @xmath11 are stored in registers of the interaction pipeline .",
    "the interface unit controls communications between the programmable grape hardware and the host computer .",
    "the host computer performs all other calculations .",
    "fpga - based prograpes have several important advantages over conventional full - custom grape processors .",
    "one is that the development cost of the chip itself is paid by the manufacturer of the chip , not by us .",
    "thus , initial cost is much lower .",
    "this low development cost means that new hardwares can be developed in shorter cycle .",
    "large grape hardwares took several years to develop , and this means the device technology used in grape hardwares , even at the time of its completion , is a few years old .",
    "this delay implies quite a large performance hit .",
    "thus , even though the efficiency in the transistor usage is much worse than full - custom grape processors , the actual price - performance of a progrape system is not so bad , if one condition is satisfied : if the design of the pipeline processor to be implemented in fpga and other necessary softwares can be developed sufficiently fast .",
    "previous experiences tell us that it is not the case . to implement a relatively simple pipeline for gravitational interaction calculation took more than one person - year , and implementation of even a simple sph pipeline",
    "would take much more .",
    "thus , clearly the difficulty of the software development has been the limiting factor for the practical use of progrape or other fpga - based computing device .",
    "the difficulty is partly because we have to design the interaction pipeline itself , for which we need rather detailed and lengthy description of hardware logic in hardware - description languages such as vhdl .",
    "in addition to the pipeline itself , we also need to develop the control logic for the pipeline and communication to the host , driver software on the host computer , and software emulator library used to verify the design ( see section [ sectrad ] ) .    in theory ,",
    "most of the design description of softwares and hardwares , including the bit - level design of the interaction pipeline itself , can be automatically generated from some high - level description of the pipeline itself .",
    "the basic idea behind the pgpg ( pipeline generator for programmable grape ) system , which we describe in this paper , is to realize such automatic generation .",
    "pgpg generates all necessary hardware design descriptions and driver softwares , from high - level description of the pipeline processor itself .",
    "thus , the user is relieved of the burden of learning complex vhdl language .",
    "also , the driver software is automatically generated , so that the user can concentrate on writing the application program , not the low - level driver software for a specific hardware .",
    "thus , we can dramatically reduce the amount of the work of the application programmer .",
    "more importantly , when a new hardware becomes ready , once the pgpg system is ported , all user applications",
    "developed on it works unchanged .",
    "the effort spent to design one application on one hardware will not be thrown away when new hardware becomes available .    in this paper",
    ", we describe the pgpg system version 1.0 . in section 2",
    ", we describe the traditional design flow and its problem . in section 3",
    "we describe the basic concept and structure of pgpg . in section 4 ,",
    "we show a design of gravitational force pipeline as an example of pipeline generated by pgpg .",
    "section 5 is for discussion .",
    "table [ tabab ] is a glossary for abbreviations used in the paper .",
    ".abbreviation glossary [ cols= \" < , < \" , ]     [ tab1 ]    table [ tab1 ] shows the features of the current version of pgpg .",
    "the specification of version 1.0 is determined so that a pipeline for gravitational force , shown in section [ secgrav ] , can be constructed as the first step .",
    "pgpg version 1.0 supports nine parametrized modules as shown in table [ tab1 ] .",
    "the bit length and the number of pipeline stage for each module can be changed by the arguments .",
    "for example , the arguments of the fixed point format adder / subtracter pg_fix_addsub(sub , xi , xj , xij,32,1 ) indicate an operation flag(adder or subtracter ) , the first input , the second input , output , bit length , and number of pipeline stages , respectively , from the first to sixth argument .",
    "modules pg_fix_addsub and pg_fix_accum are fixed point format adder / subtracter and sign - magnitude accumulator , respectively .",
    "modules pg_log_muldiv and pg_log_unsigned_add are logarithmic format multiplier / divider and unsigned adder , respectively . in the logarithmic format , a positive , non",
    "- zero real number @xmath12 is represented by its base-2 logarithm @xmath13 as @xmath14 .",
    "the logarithmic format has been adapted for the gravitational pipeline because it has larger dynamics length for the same word length and operation such as multiplication and square root are easier to implement than in the usual floating - point format . for more details of the logarithmic format ,",
    "see grape-5 paper ( kawai et al .",
    "module pg_log_shift is a logarithmic format shifter .",
    "shift operations in the logarithmic format express square ( left shift ) and squared root ( right shift ) .",
    "module pg_conv_ftol is a converter from the fixed point format to the logarithmic format , and pg_conv_ltof is a converter from the logarithmic format to the fixed point format . in pgpg version 1.0 ,",
    "these modules are described partly using the altera s lpm .",
    "a gap of delay timing is synchronized automatically by the pgpg .",
    "addition to the parametrized modules , five definitions are defined in pgpg version 1.0 .",
    "definitions /npipe and /nvmp define the numbers of ( real ) pipeline and virtual multiple pipeline ( makino et al .",
    "1997 ) , respectively .",
    "definition /jpset defines a setting for the memory unit",
    ". definitions /ipset and",
    "/foset define settings for the input and output registers in the interaction pipeline , respectively .",
    "in this appendix , we show a part of the code generated by pgpg from pgdl description of the force calculation pipeline .",
    "more complete code is obtained by a cgi program of the current version of pgpg in a website ( http://progrape.jp ) .",
    "pgpg generates description files of the designed hardware logic in vhdl .",
    "the hardware logic includes the pipeline logic itself and its peripheral logic .",
    "figures [ fig11 ] and [ fig12 ] show a part of the vhdl source files generated by pgpg ( the total length is about 2800 lines ) .",
    "the design software provided by the fpga manufacture creates configuration data of fpga from the generated sources [ step ( c ) in figure [ fig3 ] ] .",
    "the configuration data are downloaded into the programmable grape hardware using the interface program also generated by pgpg .",
    ".... library ieee ;                                                         use ieee.std_logic_1164.all ;                                          use ieee.std_logic_unsigned.all ;                                                                                                           entity pipe is                                                          generic(jdata_width : integer : = 72 ) ;                               port(p_jdata : in std_logic_vector(jdata_width-1 downto 0 ) ;                p_run : in std_logic ;                                                 p_we :   in std_logic ;                                                 p_adri : in std_logic_vector(3 downto 0 ) ;                             p_adrivp : in std_logic_vector(3 downto 0 ) ;                           p_datai : in std_logic_vector(31 downto 0 ) ;                           p_adro : in std_logic_vector(3 downto 0 ) ;                             p_adrovp : in std_logic_vector(3 downto 0 ) ;                           p_datao : out std_logic_vector(31 downto 0 ) ;                          p_runret : out std_logic ;                                             rst , pclk : in std_logic ) ;                                        end pipe ;                                                                                                                                  architecture std of pipe is                                             begin                                                                                                                                        process(pclk ) begin      if(pclk'event and pclk='1 ' ) then        jdata1 < = p_jdata ;                  end if ;    end process ;                   process(pclk ) begin      if(pclk'event and pclk='1 ' ) then        if(vmp_phase = \" 0000 \" ) then          xj(31 downto 0 )",
    "< = jdata1(31 downto 0 ) ;          yj(31 downto 0 ) < = jdata1(63 downto 32 ) ;          zj(31 downto 0 ) < = p_jdata(31 downto 0 ) ;          mj(16 downto 0 ) < = p_jdata(48 downto 32 ) ;        end if ;      end if ;    end process ;       .       .",
    "u0 : pg_fix_sub_32_1   port map ( x=>xi , y=>xj , z=>xij , clk=>pclk ) ;    u1 : pg_fix_sub_32_1   port map ( x=>yi , y=>yj , z=>yij , clk=>pclk ) ;    u2 : pg_fix_sub_32_1   port map ( x=>zi , y=>zj , z=>zij , clk=>pclk ) ;    u3 : pg_conv_ftol_32_17_8_4 port map ( fixdata=>xij , logdata=>dx , clk=>pclk ) ;    u4 : pg_conv_ftol_32_17_8_4 port map ( fixdata=>yij , logdata=>dy , clk=>pclk ) ;    u5 : pg_conv_ftol_32_17_8_4 port map ( fixdata=>zij , logdata=>dz , clk=>pclk ) ;       .       .       .",
    ".... library ieee ;                                                        use ieee.std_logic_1164.all ;                                                                                                             entity pg_conv_ftol_32_17_8_4 is             port(fixdata : in std_logic_vector(31 downto 0 ) ;               logdata : out std_logic_vector(16 downto 0 ) ;              clk : in std_logic ) ;                                          end pg_conv_ftol_32_17_8_4 ;                                                                                    architecture rtl of pg_conv_ftol_32_17_8_4 is                                                                       begin                                                                                                                                      d1 < =   not fixdata(30 downto 0 ) ;                         one < = \" 0000000000000000000000000000001 \" ;                                                  u1 : lpm_add_sub generic map ( lpm_width=>31,lpm_direction=>\"add \" )                    port map(result=>d2,dataa=>d1,datab=>one ) ;         d0 < = fixdata(30 downto 0 ) ;                            sign0 < = fixdata(31 ) ;                                                                                                    with sign0 select                                                    d3 < = d0 when ' 0 ' ,                                                 d2 when others ;                                                                                                                    process(clk ) begin                                                   if(clk'event and clk='1 ' ) then                                       d3r < = d3 ;                                                         sign1 < = sign0 ;                                                  end if ;                                                          end process ;                                                                                                                         u2 : penc_31_5 port map ( a=>d3r , c=>c1 ) ;       with d3r select",
    "nz0 < = ' 0 ' when \" 0000000000000000000000000000000 \" ,                                               ' 1 ' when others ;                                             .       .       .",
    "end rtl ;                                                           ....      the interface software on the host computer to the programmable grape hardware is composed by the c complier of the sources generated by pgpg [ step(d ) in figure [ fig3 ] ] .",
    "figure [ fig13 ] shows a part of source files in c generated by pgpg ( the total length is about 150 lines ) .",
    "we run the application program linked with the interface software [ step(e ) ] .",
    "void pgpgi_setxj(int n , double x[][3 ] , double m [ ] ) {    devid = 0 ;    for(j=0;j < n;j++ ) {      xj = ( ( unsigned int ) ( x[j][0 ] * ( pow(2.0,32.0)/(64.0 ) ) + 0.5 ) ) & 0xffffffff ;      yj = ( ( unsigned int ) ( x[j][1 ] * ( pow(2.0,32.0)/(64.0 ) ) + 0.5 ) ) & 0xffffffff ;      zj = ( ( unsigned int ) ( x[j][2 ] * ( pow(2.0,32.0)/(64.0 ) ) + 0.5 ) ) & 0xffffffff ;      if(m[j ] = = 0.0 ) {        mj = 0 ;      } else if(m[j ] > 0.0 ) {        mj = ( ( ( int)(pow(2.0,8.0)*log(m[j]*(pow(2.0,60.0)/(1.0/1024.0)))/log(2.0 ) ) ) & 0x7fff ) | 0x8000 ;      } else {        mj = ( ( ( int)(pow(2.0,8.0)*log(-m[j]*(pow(2.0,60.0)/(1.0/1024.0)))/log(2.0 ) ) ) & 0x7fff ) | 0x18000 ;      }              void force(double x[][3 ] , double m [ ] , double eps2 , double a[][3 ] , int n ) {                                                                       for(i=0;i < n;i++ ) {                                                     xi = ( ( unsigned int ) ( x[i][0 ] * ( pow(2.0,32.0)/64.0 ) + 0.5 ) ) & 0xffffffff ;      yi = ( ( unsigned int ) ( x[i][1 ] * ( pow(2.0,32.0)/64.0 ) + 0.5 ) ) & 0xffffffff ;      zi = ( ( unsigned int ) ( x[i][2 ] * ( pow(2.0,32.0)/64.0 ) + 0.5 ) ) & 0xffffffff ;      if(eps2 = = 0.0 ) {                                                 ieps2 = 0 ;                                                      } else if(eps2 > 0.0 ) {                                            ieps2 = ( ( ( int)(pow(2.0,8.0)*log(eps2*((pow(2.0,32.0)/64.0)*(pow(2.0,32.0)/64.0)))/log(2.0 ) ) ) & 0x7fff ) | 0x8000 ;      } else {                                                         ieps2 = ( ( ( int)(pow(2.0,8.0)*log(-eps2*((pow(2.0,32.0)/64.0)*(pow(2.0,32.0)/64.0)))/log(2.0 ) ) ) & 0x7fff ) | 0x18000 ;      }                                                            sx = 0 ;      sy = 0 ;      sz = 0 ;                                                                           for(j=0;j <",
    "n;j++ ) {                                                     xj = ( ( unsigned int ) ( x[j][0 ] * ( pow(2.0,32.0)/64.0 ) + 0.5 ) ) & 0xffffffff ;        yj = ( ( unsigned int ) ( x[j][1 ] * ( pow(2.0,32.0)/64.0 ) + 0.5 ) ) & 0xffffffff ;        zj = ( ( unsigned int ) ( x[j][2 ] * ( pow(2.0,32.0)/64.0 ) + 0.5 ) ) & 0xffffffff ;        if(m[j ] = = 0.0 ) {                                                   mj = 0 ;                                                        } else if(m[j ] > 0.0 ) {                                              mj = ( ( ( int)(pow(2.0,8.0)*log(m[j]*(pow(2.0,60.0)/(1.0/1024.0)))/log(2.0 ) ) ) & 0x7fff ) | 0x8000 ;        } else {                                                           mj = ( ( ( int)(pow(2.0,8.0)*log(-m[j]*(pow(2.0,60.0)/(1.0/1024.0)))/log(2.0 ) ) ) & 0x7fff ) | 0x18000 ;        }                                                                                                                                   pg_fix_sub_32(xi , xj,&xij ) ;        pg_fix_sub_32(yi , yj,&yij ) ;        pg_fix_sub_32(zi , zj,&zij ) ;        pg_conv_ftol_fix32_log17_man8(xij,&dx ) ;        pg_conv_ftol_fix32_log17_man8(yij,&dy ) ;        pg_conv_ftol_fix32_log17_man8(zij,&dz ) ;          .          .          .",
    "pg_fix_accum_f57_s64(ffx,&sx ) ;        pg_fix_accum_f57_s64(ffy,&sy ) ;        pg_fix_accum_f57_s64(ffz,&sz ) ;      }                                                                       a[i][0 ] = ( ( double)(sx<<0))*(-(pow(2.0,32.0)/64.0)*(pow(2.0,32.0)/64.0)/(pow(2.0,60.0)/(1.0/1024.0)))/pow(2.0,0.0 ) ;      a[i][1 ] = ( ( double)(sy<<0))*(-(pow(2.0,32.0)/64.0)*(pow(2.0,32.0)/64.0)/(pow(2.0,60.0)/(1.0/1024.0)))/pow(2.0,0.0 ) ;      a[i][2 ] = ( ( double)(sz<<0))*(-(pow(2.0,32.0)/64.0)*(pow(2.0,32.0)/64.0)/(pow(2.0,60.0)/(1.0/1024.0)))/pow(2.0,0.0 ) ;    }                                                                     }                                                                     ....          / * absolute * /    fixdata_body     = 0x7fffffff & fixdata ;    {      int inv_fixdata_body=0 ;      inv_fixdata_body = 0x7fffffff ^ fixdata_body ;      if(fixdata_msb = = 0x1 ) {        abs = 0x7fffffff & ( inv_fixdata_body + 1 ) ;      } else {        abs = fixdata_body ;      }    }    abs_decimal = 0x3fffffff & abs ;        { / * priority encoder * /      int i ;      int count=0 ;      for(i=31;i > = 0;i-- ) {          int buf ;          buf = 0x1 & ( abs > > i ) ;          if(buf = = 0x1 ) { count = i ; break ; }          count = i ;      }      penc_out = count ;    }    penc_out = 0x1f & penc_out ; / * 5-bit * /        barnes ,  j. , & hut ,  p. 1986 , nature , 326 , 446 hutchings ,  b. , bellows ,  p. , hawkins ,  j. , hemmert ,  s. , nelson , b. , & rytting ,  m. 1999 , in proc .",
    "ieee symposium on field - programmable custom computing machines , p12 brebbia ,  c.  a. 1978 , the boundary method for engineers ( london : pentech press ) , p1 buell ,  d.  a. , arnold ,  j.  m. , & kleinfelder ,  w.  j. , 1996 , splash 2 ( ieee computer society press , los alamitos ) fukushige ,  t. , taiji ,  m. , makino ,  j. , ebisuzaki ,  t. , & sugimoto ,  d. 1996 , , 468 , 51 gingold ,  a. , & monaghan ,  j. 1977 , , 181 , 374 greengard ,  l. , & rokhlin ,  v. 1987 , j.comput.phys .",
    ", 73 , 325 hamada ,  t. , fukushige ,  t. , kawai ,  a. , & makino ,  j. 2000 , , 52 , 943 ito ,  t. , makino ,  j. , fukushige ,  t. , ebisuzaki ,  t. , okumura ,  s.  k. , & sugimoto ,  d. 1993 , , 45 , 339 ito ,  t. , masuda ,  n. , yoshimura ,  k. , shiraki ,  a. , shimobaba ,  a. & sugie ,  t. 2004 , optics express , 13 , 1923 kawai ,  a. , fukushige ,  t. , makino ,  j. , & taiji ,  m. 2000 , , 52 , 659 kim ,  h. , cook ,  a.  t. , & louca ,  l. 1995 , in proc . in spie photonics east conferences on fpgas for fast board development and reconfigurable computing , p115 lucy ,  l. 1977 , , 82 , 1013 makino ,  j. , & taiji ,  m. 1998 , scientific simulations with special - purpose computers",
    " the grape systems ( chichester : john wiley and sons ) makino ,  j. , taiji ,  m. , ebisuzaki ,  t. , & sugimoto ,  d. 1997 , , 480 , 432 mencer ,  o. 2002 , in proc .",
    "ieee symposium on field - programmable custom computing machines .",
    ", p67 narumi ,  t. , susukita ,  r. , ebisuzaki ,  t. , mcniven ,  g. , & elmegreen ,  b. 1999 , molecular simultion , 21 , 201    sugimoto ,  d. , chikada ,  y. , makino ,  j. , ito ,  t. , ebisuzaki ,  t. , & umemura ,  m. 1990 , nature , 345 , 33 spurzem ,  r.  2002 , in proc .",
    "fifth jsps / cse symposium ( astro - ph/0204326 ) taiji ,  m. , narumi ,  t. , ohno ,  y. , futatsugi ,  n. , suenaga ,  a. , takada ,  n. , & konagaya ,  a. 2003 , in proc . of sc2003 , cd - rom ( http://www.sc-conference.org/sc2003/ ) tsoi ,  h. , ho ,  c.  h. , yeung ,  h.  c. , & leong ,  p.  h.  w. 2004 , in proc .",
    "ieee symposium on field - programmable custom computing machines , p68 yokono ,  y. , ogasawara ,  r. , inutsuka ,  s. , chikada ,  y. , & miyama ,  s. 1999 , in numerical astrophysics , ed s. miyama , k. tomisaka , t. hanawa ( kluwer , dordrecht ) p429"
  ],
  "abstract_text": [
    "<S> we have developed pgpg ( pipeline generator for programmable grape ) , a software which generates the low - level design of the pipeline processor and communication software for fpga - based computing engines ( fbces ) . </S>",
    "<S> an fbce typically consists of one or multiple fpga ( field - programmable gate array ) chips and local memory . </S>",
    "<S> here , the term `` field - programmable '' means that one can rewrite the logic implemented to the chip after the hardware is completed , and therefore a single fbce can be used for calculation of various functions , for example pipeline processors for gravity , sph interaction , or image processing . </S>",
    "<S> the main problem with fbces is that the user need to develop the detailed hardware design for the processor to be implemented to fpga chips . </S>",
    "<S> in addition , she or he has to write the control logic for the processor , communication and data conversion library on the host processor , and application program which uses the developed processor . </S>",
    "<S> these require detailed knowledge of hardware design , a hardware description language such as vhdl , the operating system and the application , and amount of human work is huge . </S>",
    "<S> a relatively simple design would require 1 person - year or more . </S>",
    "<S> the pgpg software generates all necessary design descriptions , except for the application software itself , from a high - level design description of the pipeline processor in the pgpg language . </S>",
    "<S> the pgpg language is a simple language , specialized to the description of pipeline processors . </S>",
    "<S> thus , the design of pipeline processor in pgpg language is much easier than the traditional design . for real applications such as the pipeline for gravitational interaction , </S>",
    "<S> the pipeline processor generated by pgpg achieved the performance similar to that of hand - written code . in this paper </S>",
    "<S> we present a detailed description of pgpg version 1.0 . </S>"
  ]
}