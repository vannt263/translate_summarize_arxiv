{
  "article_text": [
    "in the _ functorial data model _ , which originated with rosebrugh and others in the late 1990s  @xcite , a database schema is a finitely presented category  @xcite ( essentially , a directed multi - graph and path equality constraints ) and a database instance on a schema @xmath0 is a set - valued functor from @xmath0 ( essentially , a set of tables ) .",
    "the database instances on a schema @xmath0 constitute a category , denoted @xmath1 , and a functor @xmath2 between schemas @xmath0 and @xmath3 induces three adjoint data migration functors : @xmath4 , defined as @xmath5 , and the left and right adjoints to @xmath6 , respectively : @xmath7 and @xmath8 .",
    "these data migration functors provide a category - theoretic alternative to traditional , set - theoretic operations for information integration such as sql and the chase  @xcite .",
    "we have developed a simple algebraic query language for the functorial data model , _ fql _",
    "( for functorial query language ) , as well as a corresponding integrated development environment ( ide ) , the _ fql ide_. the fql ide is an fql code editor , a fql @xmath9 sql translator , a fql execution engine , and a data visualization tool designed in the spirit of the schema - mapping tool clio  @xcite .",
    "the fql ide is open source , written in java , and available for download at categoricaldata.net/fql.html . in this paper , we demonstrate how the fql ide is used in practice by describing an example data migration scenario developed in collaboration with the national institute of standards and technology ( nist ) .",
    "rosebrugh et al s original model  @xcite has a number of theoretical issues that prevent it from being used directly as a basis for information integration .",
    "first , rosebrugh s model can not store meaningful data such as strings and integers ; it can only store meaningless identifiers ( ids ) .",
    "second , rosebrugh s model can not interoperate with sql .",
    "hence , fql is actually based on an extension of rosebrugh s model , described in  @xcite .",
    "the exact definition of this extension does not matter for the purposes of this paper .",
    "the example described in this paper is an fql analog of a `` semantic enrichment '' scenario developed at nist and published as  @xcite . in this scenario ,",
    "a database ( called _ portal a _ in  @xcite ) contains information about equipment , including the capabilities of such equipment ; for example , that a particular machine @xmath10 can drill holes as small as .5 cm in metal .",
    "the goal of the scenario is to `` enrich '' portal a s data with additional 3rd party information about materials , so that , for example , portal a s data also contains the fact that @xmath10 can drill holes in iron , because iron is a kind of metal .    in  @xcite ,",
    "portal a s database is a microsoft access database , the 3rd party enriching information about materials is an owl ( web ontology language ) ontology , and enrichment is done by invoking a black - box owl reasoner on an input query , portal a s data , the owl ontology about materials , and an owl ontology relating portal a s vocabulary ( e.g. , `` iron '' ) and the material ontology vocabulary ( e.g. , `` ferrous '' ) . in this paper , we simplify this scenario as follows : we assume portal a s data is given as a sql database , that the ontology about materials is simply an  is - a \" parenthood function , and that the correspondence between portal a s vocabulary and the is - a hierarchy vocabulary is a `` synonyms '' relation between sets of words .",
    "our fql development consists of three main steps :    1 .",
    "first , we import portal a s data , the is - a hierarchy , and the synonyms into fql .",
    "( section 2.1 ) 2 .",
    "second , we transitively close the is - a hierarchy , join it with the synonymns relation , and then join the result to portal a s data .",
    "( section 2.2 ) 3 .   finally , we test the result of our enrichment on a particular query ( query 1 from  @xcite ) .",
    "this query gives additional results on the enriched data , which demonstrates that fql can be used to do semantic enrichment along the lines described in  @xcite .",
    "( section 2.3 )    although we only have space to sketch the outline of the development , the entire development  about 2000 lines of fql code ,",
    "1800 lines of which are schema and data definitions  is included as a built - in example in the fql ide .",
    "the schema ( figure  [ schema ] ) for portal a s data ( figure  [ sql ] ) is a sql schema in categorical normal form  @xcite : every table consists of a distinguished ( primary key ) i d column , a set of `` attribute '' columns whose values contain strings or integers , and a set of foreign key columns whose values contain ids that refer to other tables . consequently , portal a s schema can be regarded as the presentation of a category : the objects of the category are the table names and type names , and the arrows between objects are the foreign key or attribute columns in the schema .",
    "an instance on portal a s schema , which physically is a set of relations , can then be regarded as a set - valued functor .",
    "the actual portal a schema as visualized in microsoft access is shown in figure  [ schema ] , and a snippet of the sql commands defining the portal a data are shown in figure  [ sql ]",
    ". the fql ide imports these sql commands and emits corresponding fql code that defines an fql schema and an fql instance on that schema .",
    "a portion of portal a s data , as displayed in the fql ide , is shown in figure  [ portala ] .",
    ".... create table unitcode (    i d int primary key , code varchar(255 ) , description varchar(255 ) ) ; insert into unitcode values   ( 1,\"ea\",\"each part / piece count \" ) , ( 2,\"thousands\",\"1000 parts / pieces count \" ) , ( 3,\"inch\",\"length measure in inches \" ) , ( 4,\"mm\",\"length measure in millimeters \" ) , ( 5,\"cm\",\"length measure in centimeters \" ) ;   ....        @xmath11^{\\tn{right } } \\ar@/_/[r]_{\\tn{left } }   &   { \\overset{\\sf{material}}{\\bullet } } } } \\hspace{.3 in } f_n \\taking t \\to s : = \\parbox{1.4in}{${\\sf is - a } \\mapsto { \\sf material}$ \\\\ $ { \\sf material } \\mapsto { \\sf material}$ \\\\ $ { \\sf left } \\mapsto { \\sf material}$ \\\\ $ { \\sf right } \\mapsto { \\sf parent}^n$ } \\hspace{.2 in } \\parbox{.8in}{\\xymatrix@=10pt{{\\underset{\\sf{material}}{\\bullet}}\\ar@(l , u)[]^{\\sf{parent } } } } = : s\\end{aligned}\\ ] ]",
    "two additional inputs are specified in the original scenario  @xcite : an owl ontology @xmath12 containing myriad facts about materials ( e.g. , steel is a metal ) , and an owl ontology relating the vocabulary used by @xmath12 ( e.g. , `` ferrous '' ) to the vocabulary used by portal a ( e.g. , `` iron '' ) . at present",
    "we do not have a good understanding about how owl relates to fql .",
    "so , we went through these ontologies by hand and stripped out relevant data .",
    "the result was    * a ( total ) function @xmath13 , where set @xmath14 is the set of words from the ontology , and * a synonyms relation @xmath15 where @xmath16 is the set of words from portal a. we do not require that syn be an equivalence relation , and for our particular data , it is not .",
    "we encode the parent function as an instance on the @xmath0 schema in figure  [ span ] , and because it turns out that @xmath16 and @xmath14 are disjoint , we can encode the syn relation as an instance on the @xmath3 in figure  [ span ] by treating the target node of both edges as representing @xmath17 . if @xmath16 and @xmath14 were not disjoint , we would need to use a span  @xcite schema with three , rather than two , nodes to encode the syn relation , but our development would be mostly the same .",
    "we enrich portal a s data using the @xmath18 data migrations ( defined in section 1 ) as follows .",
    "we begin by computing the reflexive , transitive closure of the parenthood function , resulting in an isa relation .",
    "to do this , we define , in figure  [ span ] , for each natural number @xmath19 , a functor @xmath20 from the schema for a relation ( @xmath3 ) to the schema for a function ( @xmath0 ) . given an @xmath21instance ( e.g. , the parent function ) @xmath22 , @xmath23 computes , as a @xmath24instance ( i.e. , relation ) , the @xmath19-ary composition of @xmath22 , i.e. , @xmath25 , with the @xmath26-th composition being the reflexive closure of @xmath22 .",
    "the reflexive transitive closure of @xmath22 is then the union @xmath27 .",
    "for this example , we used @xmath28 .",
    "taking the union of two instances on the same schema is a built - in fql primitive .",
    "a portion of the resulting isa relation , as displayed in the fql ide , is shown in figure  [ relation ] .",
    "we now have a relation ( @xmath24instance ) @xmath29 , where @xmath14 is the set of words from the materials ontology , and we have a relation ( @xmath24instance ) @xmath15 , where @xmath16 is the set of words from portal a. we next compute a translation of isa to use words from portal a by joining isa with syn resulting in a new relation ( @xmath3-instance ) @xmath30 ; formally , we are computing @xmath31 , where  ;  denotes relation composition and @xmath32 if and only if @xmath33 . finally , we must compute the reflexive transitive closure of isa  , which we will denote isa.    to specify how to compute isa we use fql s `` select / from / where '' syntax ; an example of this syntax is shown in figure  [ fql ] .",
    "note that fql s select / from / where syntax is syntactic sugar : the select / from / where syntax is equivalent to a data migration of the form @xmath34 .",
    "now that we have the isa relation ( @xmath24instance ) on portal a s vocabulary , we enrich portal a s data by joining it and the isa relation together . conceptually , the enrichment process is similar to the process where @xmath29 was enriched by @xmath15 , resulting in @xmath35 ; however , because portal a s schema is not a simple relation schema , it is impractical to write the fql code for the enrichment by hand , even using fql s select / from / where syntax . hence , we developed an fql extension to generate the required fql code from the definition of portal a s schema .",
    "the result of enrichment is a new , larger instance on portal a s schema .",
    "having enriched portal a s data , we can query it , using query 1 from  @xcite .",
    "the query we are using is written in fql s select / from / where syntax and is shown in figure  [ fql ] . before enrichment , this query returns only two rows ( figure  [ q1old ] ) .",
    "after enrichment , this query returns many more rows ( figure  [ q1new ] ) , because the isa relation contains many kinds of pre - hardened stainless steel .",
    "( note that `` pre - hardened stainless steel '' does not appear in figure  [ function ] because that term is used by portal a but not by the 3rd party owl materials ontology ) .",
    "by implementing this example we have shown that fql can express `` semantic enrichments '' similar to those described in  @xcite . however ,",
    "this particular example is innately relational : all of the data migrations described in this paper can be implemented in sql , albeit more verbosely than in fql .",
    "one promising direction for future work is to implement in fql an enrichment scenario from  @xcite whose semantics can not be expressed in sql , although this will require both an understanding of the relationship between owl and fql and a formalization of what exactly the `` black - box owl reasoner '' employed in  @xcite is doing .",
    "the fql ide includes several information integration examples that can not be expressed in sql , but they are smaller than the example described in this paper and they are not `` enrichments '' in the sense of  @xcite .",
    "we also learned a valuable lesson in functorial query language design and implementation by developing this example .",
    "not only does fql s select / from / where query syntax save time and effort compared to writing @xmath34 migrations , in many cases we were able to write select / from / where queries when we had no idea how to write the corresponding @xmath34 migration .",
    "moreover , fql s select / from / where queries can be executed directly in a more efficient manner than by translation to a migration of the form @xmath34 .",
    "the reason is that many techniques from relational database theory , such as join re - ordering , can be applied directly to select / from / where syntax .",
    "hence we conclude that select / from / where syntax should be primitive in any functorial query language .",
    "the mathematical foundations of select / from / where queries are described in  @xcite . * disclaimer .",
    "* mention of commercial products or services in this paper does not imply approval or endorsement by nist , nor does it imply that such products or services are necessarily the best available for the purpose .                      ....",
    "select    m.material_material_name as mn ,     c.capability_capability_name as ccn ,    c.capability_max_length as ml ,      uc.unitcode_code as ucc ,    posc.productorservicecategory_category_name as pcn   from    productorservicecategory as posc ,     material as m ,      unitcode as uc ,     capability as c ,     capabilitymaterials as cmx ,    capabilitycategories as cc   where    c = cmx.capabilitymaterials_capability_id and    uc = c.capability_max_length_unit and     uc.unitcode_code=\"cm \" and    m = cmx.capabilitymaterials_material_id and    c = cc.capabilitycategories_capability_id and    posc = cc.capabilitycategories_productorservicecategory_id and    ( m.material_material_name=\"pre-hardened stainless steel \" or      m.material_material_name=\"17-4 stainless steel \" ) and    ( posc.productorservicecategory_category_name=\"sinker edm \" or      posc.productorservicecategory_category_name=\"ram edm \" ) ...."
  ],
  "abstract_text": [
    "<S> in this paper we describe a functorial data migration  @xcite scenario about the manufacturing service capability of a distributed supply chain . </S>",
    "<S> the scenario is a category - theoretic analog of an ontology - based `` semantic enrichment '' scenario  @xcite developed at the national institute of standards and technology ( nist ) . </S>",
    "<S> the scenario is presented using , and is included with , the open - source fql tool , available for download at categoricaldata.net/fql.html . </S>"
  ]
}