{
  "article_text": [
    "combinatorial search problems are among the most difficult computational tasks : the time required to solve them often grows exponentially with the size of the problem  @xcite .",
    "many such problems have a great deal of structure , allowing heuristic methods to greatly reduce the rate of exponential growth .",
    "quantum computers  @xcite offer a new possibility for utilizing this structure with _ quantum parallelism _ , i.e. , the ability to operate simultaneously on many classical search states , and _ interference _ among different paths through the search space .    while several algorithms have been developed  @xcite , the extent to which quantum searches can improve on heuristically guided classical methods for np searches",
    "remains an open question .",
    "even if quantum computers are not useful for _ all _ combinatorial search problems , they may still be useful for many instances encountered in practice .",
    "this is an important distinction since typical instances of search problems are often much easier to solve than is suggested by worst case analyses , though even typical costs often grow exponentially on classical machines .",
    "the study of the average or typical behavior of search heuristics relies primarily on empirical evaluation .",
    "this is because the complicated conditional dependencies in search choices made by the heuristic often preclude a simple theoretical analysis , although phenomenological theories can give an approximate description of some generic behaviors  @xcite .",
    "the simplest algorithms are the unstructured methods , such as generate - and - test , which amount to a random search among the states or a systematic enumeration of them without any use of prior results to guide future choices .",
    "an analogous unstructured quantum search can improve on this classical method  @xcite .",
    "one structured approach to search _ builds _ solutions incrementally from smaller parts .",
    "these methods exploit the fact that in many problems the small parts can be tested for consistency before they are expanded to larger ones . when a small part is found to be inconsistent , all possible extensions of it will also be inconsistent , allowing an early pruning of the search . in such cases ,",
    "the search backtracks to a prior decision point to try a different incremental construction .",
    "analogies with this approach form the basis of previously proposed structured quantum searches  @xcite .",
    "a second approach takes advantage of the clustering of solutions found in many search problems .",
    "that is , instead of being randomly distributed throughout the search space , the states have a simple neighborhood relationship such that states with a few or no conflicts tend to be near other such states .",
    "this neighborhood relationship is used by _ repair _ or _ local _ searches .",
    "starting from a random state , they repeatedly select from among the current state s neighbors one that reduces the number of conflicts with the constraints .",
    "such searches can become stuck in local minima but are often very effective  @xcite .",
    "the problem of local minima can be addressed by allowing occasional changes that increase the number of conflicts  @xcite . by comparison with incremental methods ,",
    "local searches operate in a smaller search space , i.e. , they have no need to consider the many small parts that might be composed into a full solution . on the other hand",
    ", they also disregard any information from these small parts that can guide the search toward a solution .    in this paper , we present a new quantum search algorithm based on the neighborhood structure of the satisfiability problem",
    ". such structure forms the basis of many local classical methods but has not yet been applied to quantum computation .",
    "specifically the following two sections describe the satisfiability problem used to illustrate our algorithm and the ingredients of quantum programs .",
    "we then describe a quantum algorithm analogous to classical local search methods and evaluate its behavior .",
    "finally some open issues are discussed , including a variety of ways this approach can be extended .",
    "the appendices derive the properties of the algorithm s quantum operation and discuss approaches to the classical simulation of the algorithm .",
    "[ sect.sat ]    np search problems have exponentially many possible states and a procedure that quickly checks whether a given state is a solution  @xcite .",
    "constraint satisfaction problems ( csps )  @xcite are an important example .",
    "a csp consists of @xmath0 variables , @xmath1 , and the requirement to assign a value to each variable to satisfy given constraints .",
    "searches examine various _ assignments _ , which give values to some of the variables . _",
    "complete _ assignments have a value for every variable .",
    "one important csp is the satisfiability problem ( sat ) , which consists of a propositional formula in @xmath0 variables and the requirement to find a value ( true or false ) for each variable that makes the formula true .",
    "this problem has @xmath2 complete assignments . for @xmath3-sat ,",
    "the formula consists of a conjunction of clauses and each clause is a disjunction of @xmath3 variables , any of which may be negated .",
    "for @xmath4 these problems are np - complete .",
    "an example of such a clause for @xmath5 , with the third variable negated , is @xmath6 or @xmath7 or @xmath8 , which is false for exactly one assignment for these variables : @xmath9 . with",
    "the formula expressed as a conjunction of clauses , a solution must satisfy every clause . thus we can view each clause as a constraint that adds one conflict to all complete assignments that include assignments to the variables in the clause that make it false . by selecting the clauses to be distinct",
    ", the number of clauses @xmath10 corresponds to the number of constraints in the problem .",
    "the assignments for sat can also be viewed as bit strings with the correspondence that the @xmath11 bit is 0 or 1 according to whether @xmath12 is assigned the value false or true , respectively . in turn , these bit strings are the binary representation of integers , ranging from 0 to @xmath13 . for definiteness , we associate the value of variable @xmath12 with the bit in the integer corresponding to @xmath14 , i.e. , @xmath6 corresponds to the least significant bit .",
    "each clause in the a @xmath3-sat formula specifies a combination of @xmath3 bits that cause a conflict in any assignment containing all of them .",
    "for example , the clause @xmath6 or @xmath7 or @xmath8 introduces a conflict in all assignments for which bits 1 and 2 are 0 and bit 3 is 1 , i.e. , assignments whose integer representation ends with the bit string 100 .    for bit strings @xmath15 and",
    "@xmath16 , we define @xmath17 to be the number of 1-bits in @xmath16 and @xmath18 to be the bitwise and operation on @xmath15 and @xmath16 .",
    "thus @xmath19 counts the number of 1-bits both assignments have in common , and can also be viewed as a bitwise dot product of the two assignments considered as vectors of bits .",
    "we also use @xmath20 as the hamming distance between @xmath15 and @xmath16 , i.e. , the number of positions at which they have different values .",
    "these quantities are related by @xmath21    an example with @xmath22 and two constraints , each involving a single variable , is @xmath23 and @xmath24 .",
    "this problem has a unique solution : @xmath25 , an assignment with the bit representation 00 .",
    "this problem is also an instance of 1-sat with the propositional formula @xmath26 and @xmath27 .",
    "the @xmath28 complete assignments have the bit representations 00 , 01 , 10 , and 11 .",
    "the search algorithm presented below uses the average number of conflicts in an assignment , @xmath29 .",
    "each of the @xmath10 distinct clauses in a @xmath3-sat problem introduces a single unique conflict in all complete assignments whose values for the variables specified in the clause match those of the clause .",
    "since there are @xmath30 such assignments , the total number of conflicts in all assignments is @xmath31 .",
    "thus the average number of conflicts in an assignment is @xmath32    in evaluating average behavior of search algorithms , a common class of problems used is the ensemble of random @xmath3-sat problems .",
    "this ensemble is specified by values for the number of variables @xmath0 , the size of the clauses @xmath3 and the number of distinct clauses @xmath10 .    in using random @xmath3-sat to test our algorithm , we restrict attention to those with at least one solution .",
    "specifically , to generate `` random soluble problems '' , a set of @xmath10 distinct clauses is randomly selected from the @xmath33 possible clauses  @xcite .",
    "the resulting sat problem is then solved with a classical backtrack search to see if it has any solutions . only those instances with solutions",
    "are retained .",
    "soluble problems are very rare among randomly generated instances with many constraints .",
    "thus to allow comparison over the full range of @xmath34 we generate a slightly different ensemble , random problems with a prespecified solution . to generate these problems , a random assignment is first selected to be a solution . then , @xmath10 distinct clauses are selected from among those that do not conflict with that prespecified solution . for @xmath3-sat ,",
    "this leaves @xmath35 possible clauses to select among , because the prespecified solution precludes any clause that exactly matches the assignments in that solution .",
    "compared to random soluble problems , using a prespecified solution increases the likelihood of problems with a larger number of solutions , resulting in slightly easier problems both classically and for the quantum search algorithm described in this paper . however , at the extremes of @xmath36 and @xmath37 , both methods give the same results .",
    "furthermore , when @xmath34 is fairly large , almost all soluble problems have only a single solution , resulting in very little difference between these two methods of generating soluble problems .",
    "[ sect.quantum ]    in spite of difficult conceptual issues  @xcite , the properties of quantum mechanics needed to describe the search algorithm presented in this paper are relatively simple . specifically , these properties are the rich set of states available to a quantum computer and the operations that manipulate these states",
    ".    the state of a classical computer can be described by a string of bits .",
    "for example , the complete assignment of an @xmath0-variable sat problem considered at some point in a search is given by @xmath0 bits .",
    "quantum computers use physical devices whose full quantum state can be controlled .",
    "for example  @xcite , an atom in its ground state could represent a bit set to 0 , and an excited state for 1 .",
    "the atom can be switched between these states , e.g. , with lasers of appropriate frequencies .",
    "significantly , the atom can also be placed in a uniquely quantum mechanical _ superposition _ of these values , which can be denoted as a vector @xmath38 , with a component ( called an _ amplitude _ ) for each of the corresponding classical states for the system .",
    "similarly , with @xmath0 such devices , the state of the quantum machine is described by a vector with @xmath39 amplitudes @xmath40 .",
    "the amplitudes are complex numbers that have a physical interpretation : when the computer s state is measured , the superposition changes , or _ collapses _ , to become the classical state @xmath16 with probability @xmath41 .",
    "thus amplitudes satisfy the normalization condition @xmath42 .",
    "in contrast to a classical machine which , at any given step of its program , has a definite value for each bit , the quantum machine exists in a general superposition of @xmath39 such states .",
    "the change in the superposition brought about by measurement also means the amplitude values are not explicitly available for use in a computation .",
    "for example , an algorithm that attempts to test the phase of various amplitudes to determine the next operation would destroy the superposition .",
    "this observation greatly limits the types of quantum algorithms . thus using this rich set of states requires operations that rapidly manipulate amplitudes in a superposition without explicitly measuring them .",
    "because quantum mechanics is linear and the normalization condition must always be satisfied , these operations are limited to unitary linear operators  @xcite .",
    "that is , a state vector @xmath43 can be changed to a new vector @xmath44 related to the original one by a unitary transformation , i.e. , @xmath45 where @xmath46 is a unitary matrix is unitary when @xmath47 , where @xmath48 is the transpose of @xmath46 with all elements changed to their complex conjugates .",
    "examples include permutations , rotations and multiplication by phases ( complex numbers whose magnitude is one ) .",
    "] of dimension @xmath49 . in particular",
    ", this requires that the operations be reversible : each output is the result of a single input . in spite of the exponential size of the matrix , in many cases",
    "the operation can be performed in a time that grows only as a polynomial in @xmath0 by quantum computers  @xcite .",
    "an important example of such operations are reversible classical programs .",
    "specifically , let @xmath50 be such a program .",
    "then for each classical state @xmath16 , i.e. , a string of bit values , it produces an output @xmath51 $ ] , and each output is produced by only a single input .",
    "a simple example is a program operating with two bits that replaces the first value with the exclusive - or of both bits and leaves the second value unchanged , i.e. , @xmath52=00 $ ] , @xmath53=11 $ ] , @xmath54=10 $ ] and @xmath55=01 $ ] . denoting the two bits by the binary variables @xmath56 and @xmath57 , such a program performs the operation @xmath58 , where @xmath59 is the exclusive - or operation .",
    "the values of the variables @xmath56 and @xmath57 after this operation uniquely determine the original values , hence the program is reversible .",
    "when used with a quantum superposition , such classical programs operate independently and simultaneously on each component , i.e. , @xmath60 $ ] produces a new superposition @xmath61 where @xmath62 with @xmath51 $ ] . this _ quantum parallelism _ allows a machine with @xmath0 bits to operate simultaneously with @xmath39 different classical states . continuing with the 2-bit exclusive - or example",
    ", if we started with the superposition @xmath63 the program would produce @xmath64 .",
    "equivalently , this program corresponds to the permutation matrix @xmath65    these reversible classical programs amount to a permutation of the states .",
    "however , unitary operations can also mix the amplitudes in a state vector .",
    "an example for @xmath66 is @xmath67 this converts @xmath68 , which could correspond to an atom prepared in its ground state , to @xmath69 , i.e. , an equal superposition of the two states . because these matrices combine complex numbers , it is possible for the combination of amplitudes to cancel , leaving no final amplitude in some of the states .",
    "this capability for interference  @xcite distinguishes quantum computers from probabilistic classical machines .",
    "designing a quantum search algorithm requires combining these available quantum operations in a manner that concentrates amplitudes in solutions .",
    "classical search techniques can be a useful guide for such designs .",
    "that is , a quantum search method could , at least approximately , map amplitude from one state to others that would be considered after it by the corresponding classical method . in effect",
    ", this allows examining , and using interference from , all possible choices the classical search could have made , rather than being restricted to a single series of choices .",
    "the details of the particular problem being solved could be introduced by adjustments to the phases of the amplitudes based on testing states for consistency , a rapid operation for np problems .",
    "this technique , used with previous unstructured  @xcite and structured  @xcite quantum searches , neatly separates the design of the method that mixes amplitudes from any consideration of the detailed nature of specific problems . in the rest of this paper , we show how analogies with local or repair style searches can be used as the basis for quantum search .",
    "classical repair style searches consist of randomly selecting a complete assignment as the initial state , then repeatedly moving to one of the current state s neighbors until a solution is found or the number of search steps reaches a prespecified bound .",
    "typically , at each step the search selects a neighbor that reduces the number of conflicts , if any such neighbor exists .",
    "if the search terminates without finding a solution , it is repeated from a new random initial state .",
    "the two key ingredients of these local search algorithms are identifying the neighboring states ( i.e. , those with a single different assignment ) and then selecting from among these neighbors the next one to use .",
    "the identification of neighbors does nt depend on constraints of the particular problem being solved . on the other hand , the selection process uses information on the problem instance such as the number of conflicts in the current state compared to the conflicts of the neighbors . in some versions of repair searches , such as simulated annealing  @xcite",
    "the selection process also depends on the number of steps that have been performed ( e.g. , through a changing temperature parameter ) .",
    "the quantum algorithm introduced here operates on superpositions of all complete assignments for the sat problem .",
    "furthermore , instead of selecting only a single new state , each step of the algorithm considers all possible new states .",
    "this parallelism offers the possibility of improved performance by arranging for interference among many different classical search paths .",
    "a successful algorithm will adjust amplitudes along these paths so that search paths leading to solutions tend to combine constructively while those leading to nonsolutions combine destructively .",
    "we construct quantum analogs of the two key ingredients of classical repair searches .",
    "first , the identification of neighbors corresponds to an operation on the superposition that moves amplitudes preferentially from a state to its neighbors .",
    "second , the selection among the neighbors is performed by adjustments to the amplitude phases , based on the number of conflicts in the states and their neighbors , i.e. , the same information that is used in the classical methods .    to describe the resulting algorithm more explicitly , let @xmath70 be the amplitude of the assignment @xmath16 after completing step @xmath71 of the algorithm . a single trial of the search algorithm consists of the following parts :    1 .",
    "initialize amplitude equally among all the assignments , i.e. , @xmath72 for all @xmath16 .",
    "2 .   iterate : for step @xmath71 from 1 to @xmath73 , adjust phases and then multiply by the matrix @xmath46 described in  [ sect.u ] , to give @xmath74 where @xmath75 is the phase adjustment for assignment @xmath16 as described in  [ sect.phases ] .",
    "3 .   measure the final superposition    the initialization can be performed rapidly by applying the matrix of eq .",
    "( [ eq.umix ] ) separately to each of the @xmath0 bits .",
    "after @xmath73 steps , the measurement gives a single assignment , which is a solution with probability @xmath76 with the sum over solutions .",
    "here @xmath77 is the probability to obtain the assignment @xmath16 with the measurement . on average , the algorithm will need to be repeated @xmath78 times to find a solution . as with classical repair searches",
    ", this algorithm is incomplete : it can find a solution if one exists but not prove no solutions exist .",
    "the search cost can be characterized by the number of steps required to find a solution on average , i.e. , @xmath79 .",
    "completing the description of the algorithm requires specifying the number of steps @xmath73 . because the measurement destroys the superposition ,",
    "it is not possible to evaluate @xmath80 explicitly at each step and use this information to determine when to halt .",
    "instead @xmath73 must be specified a priori based on readily available problem characteristics , such as the number of variables @xmath0 and clauses @xmath10 .",
    "the value of @xmath73 may be changed from one trial to the next , which allows some exploration for suitable values  @xcite .    in our case , because the algorithm emphasizes mapping amplitude among neighbors , one might expect that about @xmath0 steps are required to ensure an opportunity to move significant amplitude to solutions ( since a solution is at most @xmath0 neighbors away from any given assignment ) .",
    "however , the experiments reported below show fairly large amplitudes with somewhat fewer steps .",
    "in addition , instead of continuing the algorithm to maximize the probability to have a solution , a lower average search cost is sometimes possible by stopping earlier  @xcite , a simple strategy for improving probabilistic algorithms  @xcite .",
    "determining the number of steps that minimizes average cost for @xmath3-sat problems with given @xmath0 and @xmath10 remains an open problem , but at worst one could try the algorithm for all values of @xmath73 up to @xmath0 , resulting in a linear increase in the overall search cost .",
    "more sophisticated methods for finding a suitable number of steps to take have been proposed for the unstructured search algorithm  @xcite and similar techniques may be useful for this structured search as well .",
    "[ sect.u ]    for sat problems with @xmath0 variables , each state has @xmath0 neighbors .",
    "thus the matrix @xmath81 giving the most direct correspondence with the classical repair searches would have @xmath82 whenever the assignments @xmath15 and @xmath16 are not neighbors and @xmath83 whenever @xmath15 and @xmath16 are neighbors , i.e. , @xmath84 . however , this matrix is not unitary and so does not correspond to a quantum operation .",
    "instead we consider a more general class of matrices whose elements depend only on the hamming distance between assignments , i.e. , @xmath85 which can be made unitary by appropriate choices of the values @xmath86 for @xmath87 . to give a close correspondence with the classical method",
    ", we use the unitary matrix of this form with the largest possible value of @xmath88 , which governs the mapping between states and their neighbors .",
    "as shown in appendix  [ sect.matrix ] , such matrices can be written as @xmath89 where , for assignments @xmath15 and @xmath16 , @xmath90 and @xmath91 is a diagonal matrix of phases ( complex numbers with magnitude equal to 1 ) depending only on the number of 1-bits in the assignments , i.e. , @xmath92 .",
    "the matrix @xmath93 is unitary and can be implemented rapidly on quantum computers using a recursive decomposition  @xcite .",
    "the largest possible value of @xmath88 is obtained by selecting @xmath94 to be 1 for @xmath95 and @xmath96 for @xmath97 , as shown in appendix  [ sect.matrix ] .",
    "these values define the mixing matrix @xmath46 used in the search algorithm .    for example , when @xmath22 and the states are considered in binary order , i.e. , 00 , 01 , 10 , and 11 , @xmath98 for instance , the value mapping the state 00 to its neighbors , 01 and 10 , is 1/2 , corresponding to the second and third elements of the first column of this matrix .",
    "[ fig.matrix ] shows relative values of the mixing matrix elements for larger cases with even @xmath0 .",
    "this mixing matrix has a regular pattern of real - valued entries . specifically ,",
    "each column , specifying the mapping from a particular assignment @xmath16 to all the others , has a positive value for assignments @xmath15 at hamming distance 0 and 1 from @xmath16 , negative values for @xmath99 and 3 , and so on .",
    "more generally , @xmath86 is negative when @xmath100 is 2 or 3 , and otherwise is positive .",
    "we make use of this pattern in designing the phase adjustments , described below .",
    "when @xmath0 is odd , the pattern for the matrix values is different : @xmath101 for even values of @xmath102 and the values for odd @xmath102 alternate in sign .",
    "that is , @xmath86 is positive when @xmath103 , negative when @xmath104 and otherwise is 0 .    unlike the local classical search",
    ", there is some mixing between assignments that are not neighbors . generally , these contributions are relatively small , and become smaller as @xmath0 increases , for most assignments . while these additional connections make it more difficult to understand the algorithm purely in analogy with classical repair style searches , the long range couplings provide a possible mechanism to move amplitude away from local minima , i.e. , inconsistent states all of whose neighbors have more conflicts .      [ sect.phases ]    the phase adjustment for states ,",
    "i.e. , the values of @xmath75 in eq .",
    "( [ eq.map ] ) , is the portion of the algorithm using information about the particular sat problem to be solved .",
    "the key to designing an effective algorithm is selecting phases that , at least on average , move significant amplitude toward solutions . as with classical heuristics , the phase selected for a given assignment must be a function only of readily available information about that assignment and not require specific knowledge of the problem as a whole , such as the location of the solutions , that can only be obtained by extensive search . furthermore , as described in ",
    "[ sect.quantum ] , the phase choices can not depend on explicit knowledge of the amplitude associated with the state .",
    "for example , the ability to set @xmath75 based on the sign of @xmath105 could greatly simplify the design of the algorithm , but such an operation can not be physically realized .    following the analogy with classical local searches , we make use of the same information such searches use , namely the number of conflicts in an assignment and how it compares to its neighbors .",
    "we found several methods that concentrate amplitude into solutions to some extent . in this section , we describe two such phase choices .",
    "the first makes few assumptions about the structure of the problem so applies fairly well to a wide range of problems .",
    "the second makes more specific assumptions about the problem structure and is thereby able to make more effective use of the pattern of values in @xmath46 , but only for a limited set of highly constrained problems .      in the previous structured and unstructured algorithms  @xcite ,",
    "the phase choice consists of inverting the phase of all inconsistent states , i.e. , using @xmath106 when @xmath16 is consistent , and otherwise @xmath96 .",
    "the more recent structured method  @xcite also inverted phases of some consistent states depending on the step @xmath71 of the algorithm .",
    "in all these cases , the mapping matrix tended to concentrate amplitude toward those states whose phases were unchanged .",
    "as described in appendix  [ sect.matrix ] , the matrix @xmath46 of  [ sect.u ] is related to those used these previous algorithms .",
    "thus we examine using phase inversion as a simple approach to moving amplitude toward desired states .",
    "in our case , the mapping emphasizes moving amplitude among neighbors . since neighbors tend to have similar number of conflicts , we want to combine the ability of phase inversion to move amplitude toward those states whose phases are unchanged with an emphasis on neighbors to take advantage of the large value of @xmath88 .",
    "a simple way to do this is to only invert the phases of states with at least a certain number of conflicts , and gradually reduce this threshold during the search .",
    "this allows for amplitude to move between neighbors while also biasing the system toward states with fewer and fewer conflicts . in effect",
    "this technique attempts to combine amplitude coherently for states with fewer and fewer conflicts while also giving relatively large transfers to these states through the large mapping between neighbor states produced by the matrix @xmath46 .",
    "although this argument ignores the , sometimes counterproductive , contribution from non - neighbor assignments , it does serve to motivate the phase selection method .",
    "specifically we select an initial threshold @xmath107 for the number of conflicts and then at step @xmath71 the phase for assignment @xmath16 is @xmath108 the algorithm operates for at most @xmath109 steps ( after this point , eq .",
    "( [ eq.phase ] ) gives the same phase to all states so there are no further changes to the relative amplitudes ) .",
    "the exact choice for @xmath107 is not critical as long as there are relatively many states with about that number of conflicts .",
    "a simple approach is to start with the average number of conflicts in assignments , as given by eq .",
    "( [ eq.conflicts ] ) .",
    "thus for our algorithm we take @xmath110 .",
    "although not used in this paper , a possible alternative for a given problem , would be to count the number of conflicts in a set of randomly chosen assignments to estimate the distribution of conflicts among assignments .",
    "this distribution could in turn suggest a more suitable starting threshold , as well as different amounts to lower the threshold with each step of the algorithm .",
    "another approach to the phase choices is based on the pattern of the mixing matrix , illustrated in fig .",
    "[ fig.matrix ] . specifically , if we could identify a series of disjoint sets of assignments in which successive sets have a large number of neighbors and the final set consists of solutions , then we could attempt to move amplitude from one set to the next based on the large mapping between neighbors . to use this technique",
    "we would also need to be able to initially concentrate amplitude in the first of these sets .",
    "identifying such a sequence of sets requires fairly regular relationships among the number of conflicts of neighboring assignments .",
    "we restrict attention to the case where @xmath0 is even . a similar argument can give a phase selection strategy for odd @xmath0 based on the different pattern of the @xmath46 matrix described in ",
    "[ sect.u ] .    to illustrate this approach , we consider the simple case of soluble problems with the maximum possible number of constraints , i.e. , @xmath37 from eq .",
    "( [ eq.mmax ] ) . in this case , each assignment with @xmath111 conflicts has @xmath111 neighbors with @xmath112 conflicts and the remaining @xmath113 neighbors have @xmath114 conflicts .",
    "let @xmath115 be the number of neighbors of assignment @xmath16 that have fewer conflicts than @xmath16 does .",
    "then for these problems , @xmath116 where @xmath111 is the number of conflicts in the assignment @xmath16 .",
    "let @xmath117 be the set of assignments with @xmath118 better neighbors , i.e. , @xmath119 .",
    "the set @xmath120 contains just the single solution of the problem .",
    "the maximum constrained problems have @xmath121 assignments in @xmath117 . since this quantity is largest when @xmath122 , the initial superposition with equal amplitude in all states will have the largest total contribution for the assignments in @xmath123 .",
    "thus we will select phases in a way that attempts to move significant amplitude from the assignments in @xmath117 to those in @xmath124 , starting with @xmath122 .",
    "if successful , this process will concentrate amplitude in the solution after @xmath125 steps .",
    "we can improve this process by first increasing the amplitude in the assignments in @xmath123 .",
    "this is readily done using the pattern of signs of the matrix @xmath46 .",
    "specifically , the initial superposition gives a positive amplitude to every assignment .",
    "we can arrange for the first step of the algorithm to give a sum of positive contributions to every state in @xmath123 by selecting the signs of the phases for the states to equal those of the corresponding matrix elements in @xmath46 .",
    "that is , assignments at hamming distance @xmath102 from those in @xmath123 , namely those in @xmath126 , have @xmath75 equal to the sign of @xmath86 .    for subsequent steps @xmath127 , we attempt to move as much amplitude as possible from assignments in @xmath128 to those in @xmath129 .",
    "to do this we make use of the fact that the mapping between neighbors has the largest matrix elements in @xmath46 and these elements , @xmath88 are positive .",
    "thus , just considering the contribution from neighbors , we can expect a large contribution from assignments in @xmath128 to those in @xmath129 by selecting @xmath75 for these assignments to be positive and setting the phase for all other assignments to @xmath96 .",
    "this argument ignores the contributions from assignments at larger hamming distances .",
    "however , if a large portion of the amplitude at step @xmath71 is concentrated in assignments in @xmath128 , the other contributions to assignments in @xmath129 will be small both because the corresponding @xmath86 values are small and the amplitudes in the other assignments are relatively small .",
    "[ eq.phase1 ] this discussion motivates selecting the phase for an assignment @xmath16 as follows . for the first step ,    [ eq.phase1first ] _ s = \\ {    rl -1 & + 1 &    .    where @xmath130 .",
    "for subsequent steps , i.e. , @xmath127 ,    [ eq.phase1rest ] _ s = \\ {    rl 1 & + -1 &    .    with the algorithm terminating after at most @xmath131 steps .    as suggested by the motivating argument , this choice of phases requires a close relation between the number of conflicts in an assignment and its neighborhood relations .",
    "while such a relation holds exactly for the maximum constrained problem , it is only an approximation for problems with fewer constraints .",
    "for example , problems can have local minima , i.e. , assignments for which @xmath132 but which nevertheless have some conflicts and thus are not solutions .",
    "more generally , the neighbors of a given assignment can have various numbers of conflicts making it more difficult to move amplitude one step at a time to sets of assignments with successively fewer conflicts .",
    "these characteristics introduce variations in the amplitudes , in effect causing some randomization of the phases .",
    "we observed the validity of the approximation , and its usefulness as a search strategy , was lowest for problems around the transition from over- to underconstrained problems near @xmath133 .",
    "nevertheless , for highly constrained problems the behavior is close enough to that of maximum constrained cases to give the step by step shift of a large portion of the amplitude toward assignments with fewer conflicts .",
    "the behavior of this search algorithm was examined through a classical simulation .",
    "while these results are limited to small problems , they nevertheless give an indication of how this algorithm can dramatically focus amplitude into solutions . as a check on the numerical errors , the norm of the state vector remained within @xmath134 of 1 .",
    "we first illustrate the steps in this algorithm , for the trivial problem with two variables described in ",
    "[ sect.sat ] . for this problem",
    "the characteristics of the assignments and the amplitudes using eq .",
    "( [ eq.phase ] ) are :    [ cols=\"<,^,^,^,^\",options=\"header \" , ]     thus this method also gives @xmath135 but only after 2 steps , so the search cost is @xmath136 .",
    "a particularly simple case is given by problems with the maximum possible number of constraints that still allows for a solution , i.e. , @xmath37 as given in eq .",
    "( [ eq.mmax ] ) .    in this case , classical repair style search methods can find a solution rapidly starting from any initial state , typically by removing one conflict at a time .",
    "similarly , incremental classical methods will encounter conflicts immediately upon choosing any variable value not in the solution , thus allowing the solution to be found in @xmath137 steps .    as shown in appendix  [ sect.maxconstraints ] , the classical simulation of the quantum algorithm for these problems runs rapidly .",
    "thus we are able to explore the behavior of the algorithm with considerably more variables than is possible when there are fewer constraints .",
    "the scaling of the search cost for this extreme problem is shown in fig .",
    "[ fig.extreme ] on a log - log plot where a straight line corresponds to a polynomial growth in the cost .",
    "the expected search cost grows quite slowly and is approximately proportional to @xmath138 over the range of the figure . for these problems eq .",
    "( [ eq.phase1 ] ) gives somewhat lower search costs than eq .",
    "( [ eq.phase ] ) .",
    "the slow growth in search cost is particularly impressive since an unstructured quantum search requires of order @xmath139 steps , which for @xmath140 is about @xmath141 .",
    "while this scaling is a polynomial growth in search cost , its cost grows a bit faster than that of classical heuristics for these problems .    for eq .",
    "( [ eq.phase ] ) , the number of steps giving the smallest cost grows very slowly , ranging from 2 to 4 over the range of variables shown in the figure . for eq .",
    "( [ eq.phase1 ] ) , the largest probability for a solution is after @xmath125 steps .",
    "however , for the problems with @xmath142 , the small probability of a solution after just the first step is enough to give a slightly smaller search cost .",
    "further insight into the behavior of this algorithm is given by fig .",
    "[ fig.amplitude ] which shows how the probability to have assignments with different numbers of conflicts varies with each step of eq .",
    "( [ eq.map ] ) .",
    "specifically , for each step @xmath71 and each number of conflicts @xmath111 , the figure shows the value of @xmath143 where the sum is over all assignments @xmath16 with @xmath111 conflicts . as described in appendix  [ sect.maxconstraints ] , the amplitudes @xmath144 depend only on the number of conflicts in the assignment @xmath16 .",
    "thus each term in this sum is the same , giving @xmath145 where @xmath146 denotes the amplitude of any of the assignments with @xmath111 conflicts .",
    "the initial condition ( not shown ) has equal probability , @xmath147 , in all assignments so the corresponding values in this plot would be @xmath148 .",
    "we see a large probability in states with @xmath149 conflicts after step @xmath71 , illustrating the effectiveness of eq .",
    "( [ eq.phase1 ] ) in using neighbor relations to move amplitude .",
    "moreover , the large spike at 50 conflicts for step 1 shows the effectiveness of eq .",
    "( [ eq.phase1first ] ) in concentrating amplitude in states with @xmath150 for this problem . in this case",
    ", @xmath151 compared to its initial value @xmath152 .",
    "the relatively low search costs and polynomial scaling are also observed for problems with somewhat fewer constraints than the maximum , e.g. , @xmath153 , using this choice of phases .",
    "while this extends the range of good performance for the quantum algorithm , such a scaling also gives relatively easy problems for classical heuristics as well .",
    "the ability of this algorithm to concentrate amplitude into solutions for highly constrained problems is a significant improvement over unstructured search methods .",
    "however , such problems are inherently easy because they can be readily solved by classical heuristic methods , for both incremental and repair style searches . by contrast , the difficult search problems , on average , have an intermediate number of constraints  @xcite : not so few that most assignments are solutions , nor so many that any incorrect search choices can be quickly pruned . specifically , for @xmath3-sat",
    "the difficult problems have scaling @xmath154 , with the proportionality constant giving the largest concentration of hard cases depending on the choice of @xmath3 .",
    "for instance , with @xmath5 , the hard cases are concentrated near  @xcite @xmath155 .",
    "thus it is important to examine the behavior of the algorithm for problems with fewer constraints . in this section",
    "we do so using the phase choice of eq .",
    "( [ eq.phase ] ) .",
    "a larger example of how the algorithm concentrates amplitude into solutions is shown in fig .",
    "[ fig.largerexample ] .",
    "it shows the values of @xmath156 for each of the @xmath39 assignments .",
    "the assignments are grouped by their number of conflicts and , within each group , by the integer corresponding to the binary representation of the assignment . for clarity ,",
    "assignments with each number of conflicts are given the same amount of horizontal space in the plot , even though there are , e.g. , many more assignments with 6 conflicts than with 0 or 12 .",
    "there are @xmath157 assignments , so random selection would give a probability of about 0.0002 to each assignment .",
    "we see that the algorithm results in many states with relatively few conflicts , including the solutions , having considerably larger probabilities than due to random selection .",
    "the figure also illustrates the variation in @xmath156 among the assignments showing that , unlike the extreme problem of the previous section , the amplitudes do not depend only on the number of conflicts .",
    "rather the details of which constraints apply to each assignment give rise to the variation in values seen here .",
    "this variation precludes a simple theoretical analysis of the algorithm .    for problems near the transition from over- to underconstrained cases , the scaling behavior of this algorithm",
    "is shown in fig .",
    "[ fig.scaling ] .",
    "specifically , we generated random soluble instances of 3-sat problems with @xmath158 , as described in ",
    "[ sect.sat ] . with @xmath159 , a large fraction of the randomly generated instances",
    "are soluble , so random soluble instances are readily generated .",
    "the nearly linear behavior on this log - plot indicates the seach cost grows exponentially for these problems .",
    "thus this algorithm is not particularly effective for the hard problem instances , which are concentrated near the transition region of @xmath155 .    to show how this algorithm is capable of using structure to improve performance , we examined the behavior as a function of the number of constraints . to allow sampling the behavior of problems with many constraints we used random problems with prespecified solution to cover the full range of @xmath34 , generated as described in  [ sect.sat ] . for comparison",
    ", we also examined the behavior of random soluble problems up to @xmath160 .",
    "as shown in fig .",
    "[ fig.phase ] , the search cost eventually decreases as problems become highly constrained , though at a larger value of @xmath34 than for both the incremental quantum search method  @xcite and classical methods , whose cost is largest near the transition at @xmath155 .",
    "thus the local quantum search method introduced here has only limited effectiveness at using structure to reduce search cost .",
    "nevertheless , it is better than unstructured search for highly constrained problems .",
    "the algorithm presented here shows how the structure of search problems can be used as the basis of a quantum search algorithm .",
    "the algorithm is particularly effective for relatively highly constrained problems .",
    "it is less effective for problems with an intermediate number of constraints .",
    "the algorithm might be improved in a number of ways .",
    "first , the initial motivation for the matrix @xmath46 was to maximally connect assignments to their neighbors .",
    "in fact , we found that the mapping allowed the algorithm to work best with fewer steps than might be expected from moving among neighbors one step at a time .",
    "it may be possible to design other mappings that do this even more effectively .",
    "another issue is the structure of the types of mappings possible with different choices of the phases for the diagonal matrix @xmath91 .",
    "as we saw , the matrix elements depend only on the hamming distance between the assignments when the diagonal elements of @xmath91 depend only on the number of 1-bits .",
    "it may be helpful to apply the testing operation , and consequent phase adjustments , more frequently as amplitude is moved to neighbors than is possible when @xmath46 has the largest possible mixing between neighbors .",
    "one such method is to decompose @xmath46 into a product of matrices , each of which introduces a smaller amount of mixing , e.g. , using @xmath161 , where @xmath162 is a diagonal matrix with @xmath163 if @xmath164 and @xmath165 otherwise .",
    "phase adjustments can then be introduced between the components of this product .",
    "another method uses somewhat smaller values of @xmath88 while retaining real values for @xmath46 by picking a value @xmath166 and using @xmath163 if @xmath167 and @xmath168 otherwise .",
    "the resulting mixing matrix has a more diffusive behavior , giving smaller changes with each step and hence more opportunity to apply the phase adjustment . taken to an extreme , with @xmath169 ,",
    "this recovers the diffusion matrix of the unstructured search  @xcite , which moves too little amplitude among states at each step to finish rapidly .",
    "there are also a variety of phase adjustment policies .",
    "those studied here are effective for highly constrained problems , but we found that other choices can enhance performance in some cases .",
    "furthermore , since we focus on typical or average behavior , other choices that do not improve the average but result in smaller variance would also be useful in improving the predictablility of the algorithm s performance .    as a possible extension to this algorithm , it would be interesting to see whether the nonsolution sets with relatively high probability could be useful also .",
    "if so , the benefits of this algorithm would be greater than indicated by its direct ability to produce solution sets .",
    "this may also suggest similar algorithms for the related optimization problems where the task is to find the best solution according to some metric , not just one consistent with the problem constraints .",
    "there remain a number of important questions .",
    "first , how are the results degraded by errors and decoherence , the major difficulties for the construction of quantum computers  @xcite ?",
    "while there has been recent progress in implementation  @xcite , quantum approaches to error control  @xcite and studies of decoherence in the context of factoring  @xcite it remains to be seen how these problems affect the algorithm presented here .",
    "however , two aspects of our algorithm may reduce the effect of errors .",
    "first , the algorithm is based on attempts to randomize phases of contributions to nonsolutions while maintaining similar phases for contributions to solutions .",
    "since the precise values of the randomized phases are not critical , some additional variations due to noise should be tolerable .",
    "second , for problems with @xmath0 variables the algorithm requires only @xmath137 steps during which quantum coherence must be maintained .",
    "that is , coherence need not be maintained between successive trials of the algorithm .",
    "this contrasts with the @xmath170 coherent steps required by the unstructured algorithm  @xcite .",
    "thus even though our algorithm may need to be repeated many times to give a good chance of finding a solution , it has less stringent coherence requirements which can simplify its hardware implementation .",
    "the second remaining question is due to the algorithm s restriction to csps with two values per variable .",
    "this contrasts with the method that constructs solutions incrementally  @xcite by operating in a greatly expanded search space . other csps can be converted to equivalent problems with two values , but it is often better to operate directly with the problem as specified . thus an important open question is whether the neighborhood - based mixing matrix can be effectively generalized to apply directly to csps with larger domain sizes .",
    "third , it would be useful to have a theory for asymptotic behavior of this algorithm for large @xmath0 , even if only approximately in the spirit of mean - field theories of physics",
    ". this would give a better indication of the scaling behavior than the classical simulations , necessarily limited to small cases , and may also suggest better phase choices . considering",
    "these questions may suggest simple modifications to the quantum map to improve its robustness and scaling .",
    "finally , there is the general issue of optimally using the information that can be readily extracted from search states .",
    "local search methods rely on the number of conflicts and the neighborhood relations among states . in the method presented here ,",
    "only a small amount of this information was actually used to determine the phase choices .",
    "additional information is available on partial assignments , as used with incremental searches , but at the cost of involving a greatly expanded search space .",
    "making fuller use of this available information could improve the performance , especially in conjunction with a theoretical understanding of the typical structure of classes of search problems  @xcite .",
    "[ sect.matrix ]    here we show that the mixing matrix @xmath46 used in our algorithm is the unitary matrix depending only on the hamming distance between states that gives the largest possible contribution to neighbors .",
    "we do this in two steps .",
    "we first show that matrices whose elements depend only on hamming distance can be expressed in the form @xmath171 where @xmath93 is given by eq .",
    "( [ eq.w ] ) and @xmath91 is diagonal with elements depending only on the number of 1-bits in the assignments . in the second step ,",
    "we show that our choice of values for @xmath91 gives the largest possible mapping to neighbors among unitary matrices of this form .      for @xmath0 variables ,",
    "the matrices have dimensions @xmath49 and elements determined by a set of values @xmath172 , i.e. , @xmath85 .",
    "for example , with @xmath22 and the states binary order , i.e. , 00 , 01 , 10 , and 11 , the matrix has the general form @xmath173    these matrices have a simple recursive decomposition when the states are in binary order , i.e. , ordered by the value of the integer with corresponding binary representation , namely @xmath174 where the @xmath175 matrices @xmath176 and @xmath177 also have elements depending only on the hamming distance between assignments , but considering only the first @xmath178 variables .",
    "an example of this decomposition can be seen in the structure of eq .",
    "( [ eq.generalu ] ) .",
    "this decomposition gives a particularly simple expression for these matrices .",
    "specifically , define the matrix @xmath179 as @xmath180 for example , when @xmath22 , @xmath181 this matrix also has a recursive decomposition @xmath182 where @xmath183 is the same matrix but defined on assignments to @xmath178 variables .",
    "now consider the product @xmath184 .",
    "for @xmath66 , this gives @xmath185 which is a diagonal matrix .",
    "now suppose that @xmath184 is always diagonal for any matrix with @xmath186 depending only on @xmath20 up to @xmath178 variables .",
    "using the recursive decompositions of eq .",
    "( [ eq.udecomposition ] ) and ( [ eq.wdecomposition ] ) then gives , for a matrix with @xmath0 variables @xmath187 each of the submatrices are diagonal because they involve products of the form @xmath184 for @xmath178 variables .",
    "thus , by induction , @xmath184 is a diagonal matrix for all @xmath0 , which we denote by @xmath188 , where @xmath2 .",
    "note that eq .",
    "( [ eq.w ] ) is @xmath189 .",
    "the matrix @xmath93 is symmetric and unitary  @xcite . in particular",
    ", @xmath93 is its own inverse : @xmath190 .",
    "thus from @xmath191 we obtain @xmath89 .",
    "furthermore , the diagonal elements of @xmath91 depend only on the number of 1-bits in the assignments , i.e. , @xmath92 for some set of values @xmath192 . to see this",
    ", we have @xmath193 where the innermost sum of the second line is over all assignments @xmath56 and @xmath57 for which @xmath194 and @xmath195 .",
    "for this inner sum , consider those assignments @xmath56 with exactly @xmath196 1-bits in common with @xmath15 , i.e. , @xmath197 .",
    "there are @xmath198 such choices for @xmath56 .",
    "then the @xmath57 sum counts the number of assignments @xmath57 such that @xmath194 and @xmath199 .",
    "these assignments are characterized by @xmath200 , the number of 1-bits they share with both @xmath15 and @xmath56 .",
    "the number of such @xmath57 is readily seen to be @xmath201 summing over @xmath200 then gives the total number of assignments @xmath57 , which we denote as @xmath202 .",
    "combining these observations gives @xmath203 which depends only on the number of 1-bits in the assignment @xmath15 .    in summary ,",
    "_ any _ matrix whose values depend only on the hamming distance between assignments can be written in the form @xmath89 where @xmath91 is a diagonal matrix with elements depending only on the number of 1-bits in the assignments .",
    "that is , the values for @xmath172 are uniquely determined by the diagonal values of @xmath91 , which in turn are fully specified by the values @xmath192 for assignments with each possible number of 1-bits .",
    "since @xmath93 is unitary , @xmath46 will be unitary if and only if @xmath91 is . for diagonal matrices ,",
    "the unitary condition is equivalent to the requirement that each diagonal element is a phase , i.e. , a complex number whose magnitude equals one .      to determine the choices for @xmath94 that give the largest possible value for @xmath88 , we have @xmath204 where @xmath205 with the sum over all assignments @xmath206 with @xmath207 1-bits .",
    "a given 1-bit at position @xmath208 of @xmath206 contributes 0 , 1 or 2 to @xmath209 when positions @xmath208 of @xmath15 and @xmath16 are both 0 , have exactly a single 1-bit , or are both 1 , respectively .",
    "thus @xmath210 equals @xmath211 where @xmath212 is the number of 1-bits in @xmath206 that are in exactly one of @xmath15 and @xmath16 .",
    "there are @xmath213 positions from which such bits of @xmath206 can be selected , and by eq .",
    "( [ eq.hamming ] ) this is just @xmath20 .",
    "thus the number of assignments @xmath206 with @xmath207 1-bits and @xmath212 of these bits in exactly one of @xmath15 and @xmath16 is given by @xmath214 where @xmath215 .",
    "thus @xmath216 where @xmath217 so that @xmath85 with @xmath218 .    to select the values of @xmath94 that maximize @xmath88 , note that @xmath219 and @xmath220 .",
    "thus @xmath221 is positive for @xmath222 and negative for @xmath223 , and @xmath88 is maximized by selecting @xmath94 to be 1 for @xmath224 and @xmath96 for @xmath97 .",
    "if @xmath0 is even , @xmath221 is zero for @xmath225 so the choice of @xmath226 does not affect the value of @xmath88 . in this case , we take @xmath227 .",
    "these choices give @xmath228 which scales as @xmath229 as @xmath230 .",
    "note this is much larger than the off - diagonal matrix elements in the diffusion matrix used in the unstructured search algorithm  @xcite , which are @xmath231 .",
    "this maximum neighbor mixing matrix is identical to that used with an incremental search method  @xcite but with a different interpretation of the search states .",
    "if instead we take @xmath232 and the remaining values equal to one @xmath46 becomes the diffusion matrix of the unstructured search method  @xcite .",
    "a direct classical simulation of the quantum algorithm results in an exponential increase in the cost , limiting the empirical evaluation of the algorithm to small cases .",
    "nevertheless , the simple structure of the mixing matrix @xmath46 can be used to reduce this cost penalty .",
    "it can be further reduced for the special case of soluble problems with the maximum possible number of constraints .        as a practical matter , it is helpful if a quantum search method can be evaluated effectively on existing classical computers . unfortunately , the exponential slowdown and growth in memory required for such a simulation severely limits the size of feasible problems .",
    "for example , eq .  ( [ eq.map ] ) is a matrix multiplication of a vector of size @xmath39 so a direct evaluation requires @xmath233 multiplications .",
    "the cost of the classical simulation can be reduced substantially by exploiting the map s simple structure .",
    "specifically , the product @xmath234 can be computed recursively using eq .",
    "( [ eq.wdecomposition ] ) giving @xmath235 where @xmath236 and @xmath237 denote , respectively , the first and second halves of the vector @xmath238 .",
    "thus the cost to compute @xmath234 is @xmath239 resulting in an overall cost of order @xmath240 for this product as well as the full mapping step @xmath241 . while still exponential , this improves substantially on the cost for the direct evaluation on classical machines .",
    "an open question is whether other techniques could give approximate values for the behavior without an exponential cost on classical machines  @xcite .",
    "in general , the cost of a classical simulation of the quantum algorithm grows exponentially with the number of variables .",
    "however , the simulation cost is greatly reduced in some special cases where the amplitudes have a regular structure .",
    "one such case is provided by problems with the maximum possible number of constraints that still allows for a solution .",
    "for such problems , the amplitudes depend only on the number of conflicts in each assignment , not their particular location .",
    "this observation allows for a smaller representation of the search state and hence an empirical study of larger cases . to see this ,",
    "consider a 1-sat problem with @xmath0 variables .",
    "the most constrained , but still soluble , case will have @xmath0 conflicts , each involving a distinct variable .",
    "thus each variable has an associated `` bad bit '' value that causes a conflict .",
    "the number of conflicts in a given assignment @xmath16 is then just equal to the number of bad bits it contains .",
    "an assignment with @xmath111 conflicts will have @xmath111 neighbors with @xmath112 conflicts and @xmath113 neighbors with @xmath114 conflicts .",
    "thus the neighborhood structure of the problem is uniquely determined by the number of conflicts in the assignments .",
    "suppose @xmath144 depends only on the number of conflicts in the assignment @xmath16 .",
    "we need to show that after a single step , eq .",
    "( [ eq.map ] ) gives values for @xmath242 that only depend on the number of conflicts in @xmath15 .",
    "first note that the phase choice @xmath75 uses only the neighborhood structure of @xmath16 , which for these problems depends only on the number of conflicts in @xmath16 .",
    "thus @xmath243 depends only on @xmath111 , the number of conflicts in @xmath16 , and can be denoted by @xmath244 . since the mixing matrix @xmath186 depends only on the hamming distance between the assignments @xmath15 and @xmath16 , eq .",
    "( [ eq.map ] ) becomes @xmath245 where the inner sum is over assignments @xmath16 with @xmath111 conflicts and hamming distance @xmath102 from the assignment @xmath15 .",
    "suppose @xmath15 has @xmath118 conflicts .",
    "of the @xmath111 `` bad bits '' in @xmath16 , @xmath246 are in common with those of @xmath15 , and the remaining @xmath247 do not appear in @xmath15 .",
    "the number of ways to construct such assignments @xmath16 is then @xmath248 thus the result of this mapping step depends only on the number of conflicts in the assignment @xmath15 , preserving the simple structure of the search state . thus we can represent the entire search state by simply keeping track of the amplitudes associated with each possible number of conflicts , i.e. , @xmath249 where @xmath118 and @xmath111 range from 0 to @xmath0 and @xmath250    because the search state depends only on the number of conflicts and not their specific associated variables or values , we can , without loss of generality , choose the conflicts so that all the `` bad bits '' have the value 1 , i.e. , the unique solution of the problem has all variables equal to 0 . with this choice , we can then make use of the decomposition of the mixing matrix .",
    "that is , @xmath251 where @xmath252 is a diagonal matrix with @xmath253 equal to 1 for @xmath254 and @xmath96 otherwise , and @xmath255 from eq .  ( [ eq.skm ] ) . here",
    "the binomials in the sum count , for an assignment @xmath15 with @xmath118 1-bits , the number of assignments @xmath16 with @xmath111 1-bits that have @xmath256 .",
    "this decomposition is possible for this particular choice of the unique solution because the number of 1-bits correspond to the number of conflicts .",
    "finally , 1-sat problems with fewer than the maximum number of constraints also have the property that the amplitudes depend only on the number of conflicts in each assignment .",
    "so this compact representation could be used to study other cases of 1-sat with many more variables than is feasible for a direct classical simulation .",
    "andre berthiaume , david deutsch , and richard jozsa .",
    "the stabilization of quantum computations . in _ proc . of the workshop on physics and computation ( physcomp94 ) _ , pages 6062 , los alamitos , ca , 1994 .",
    "ieee press .",
    "michel boyer , gilles brassard , peter hoyer , and alain tapp .",
    "tight bounds on quantum searching . in t.",
    "toffoli et  al . ,",
    "editors , _ proc . of the workshop on physics and computation ( physcomp96 ) _ , pages 3643 , cambridge , ma , 1996 . new england complex systems institute .",
    "david  g. cory , amr  f. fahmy , and timothy  f. havel .",
    "nuclear magnetic resonance spectroscopy : an experimentally accessible paradigm for quantum computing . in t.",
    "toffoli et  al . ,",
    "editors , _ proc . of the workshop on physics and computation ( physcomp96 ) _ , pages 8791 , cambridge , ma , 1996 . new england complex systems institute .",
    "neil gershenfeld , isaac chuang , and seth lloyd .",
    "bulk quantum computation . in t.",
    "toffoli et  al . ,",
    "editors , _ proc . of the workshop on physics and computation ( physcomp96 ) _ , page 134 , cambridge , ma , 1996 . new england complex systems institute .",
    "bart selman , hector levesque , and david mitchell . a new method for solving hard satisfiability problems . in _ proc . of the 10th natl .",
    "conf . on artificial intelligence",
    "( aaai92 ) _ , pages 440446 , menlo park , ca , 1992 . aaai press .",
    "peter  w. shor .",
    "algorithms for quantum computation : discrete logarithms and factoring . in s.",
    "goldwasser , editor , _ proc . of the 35th symposium on foundations of computer science _ , pages 124134 .",
    "ieee press , november 1994 ."
  ],
  "abstract_text": [
    "<S> local search algorithms use the neighborhood relations among search states and often perform well for a variety of np - hard combinatorial search problems . </S>",
    "<S> this paper shows how quantum computers can also use these neighborhood relations . </S>",
    "<S> an example of such a local quantum search is evaluated empirically for the satisfiability ( sat ) problem and shown to be particularly effective for highly constrained instances . for problems with an intermediate number of constraints , </S>",
    "<S> it is somewhat less effective at exploiting problem structure than incremental quantum methods , in spite of the much smaller search space used by the local method . </S>"
  ]
}