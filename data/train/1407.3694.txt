{
  "article_text": [
    "the problem of dynamic resource allocation in constrained queueing networks is fundamental to modern communication networks . this has long been the subject of significant research , where the @xcite of tassiulas and ephremides proposed the mw ( maximum weight ) scheduling algorithm of throughput - optimality .",
    "it has been also a powerful paradigm in cross - layer control and resource allocation @xcite .",
    "however , the algorithm can not be implemented in practice due to its high algorithmic complexity .",
    "been made since then for developing algorithms of lower complexity while maintaining the same performance guarantee .",
    "examples of such algorithms include greedy algorithms @xcite and random access algorithms @xcite .",
    "recently , there have been exciting progresses for the topic that even fully distributed random access algorithms based on csma ( carrier sense multiple access ) can achieve the desired high performance , i.e. , throughput - optimality , in wireless interference network models , e.g. , see @xcite .",
    "the main intuition underlying these results is that nodes in a network can adjust their csma parameters dynamically using local information such as queue - length so that they can simulate the mw algorithm asymptotically for throughput - optimality .",
    "however , it is known that the queue - based csma algorithms suffer from very poor delay performance .",
    "there have been also significant efforts formally addressing the limitation in the delay performance of the queue - based csma algorithms @xcite as well as designing better alternatives in delay under certain scenarios @xcite .",
    "in addition , another issue is that the throughput - optimality proof in @xcite is very sensitive to the underlying wireless network model .",
    "namely , it is not an easy task to design similar csma - like throughput - optimal algorithms in other network models since one has to reproduce painful , long and routine proof - arguments for throughput - optimality in each different model .",
    "the main goal of this paper is to resolve these issues of the recent queue - based csma algorithms by developing a general framework that can produce a variety of throughput - optimal and low - complexity scheduling algorithms , not to the underlying network models .",
    "design and analysis of resource allocation algorithms in constrained queueing networks have been of great interest for last four decades across various research communities , where the contention resolution protocols in multiple - access broadcast channels have been studied since the mid-1970s @xcite .",
    "the broadcast channels induce a special constraint in resources usages among queues ( i.e. , every queue contend with all other queues ) , and simple distributed contention resolution protocols gained much attention in the ages .",
    "it is the year 1992 that the seminal work by tassiulas and ephremides proposed a throughput - optimal algorithm , referred to as mw , for general resource constraints .",
    "its main appeal is that it does require only information on the current queue lengths ( and instantaneous service rates ) and does not rely on the knowledge of underlying system parameters .",
    "however , as we mentioned earlier , the mw algorithm suffers from the high implementation complexity , and a huge array of subsequent research has been made to develop algorithms with high performance guarantees and low - complexity .",
    "maximal scheduling or longest - queue - first algorithm are low - complexity alternatives to mw , but they achieve only some fraction of the maximal throughput region .",
    "parallel iterative matching @xcite and islip @xcite were shown to be 50% throughput - optimal @xcite .",
    "on the other hand , kumar et al .",
    "@xcite and dimakis and walrand @xcite identified sufficient conditions on the network topology for throughput - optimality .",
    "those conditions were further analyzed to obtain fractional throughput results about a class of wireless networks by joo et al .",
    "@xcite and leconte et al .",
    "these algorithms are generally not throughput - optimal and require multiple rounds of message exchanges between nodes .",
    "simpler or distributed implementations of mw has been also extensively studied in the literature .",
    "tassiulas @xcite provides linear - complexity versions of mw , called ` pick - and - compare ' , but it is known that they suffer from the bad delay performance .",
    "the works on this line also include a variant of mw by giaccone , prabhakar and shah @xcite and a gossip - based algorithm by modiano , shah and zussman @xcite .",
    "however , these algorithms are specific to certain network models and still require high information ( or message ) exchanges for each new scheduling decision .",
    "a few years ago , it was proven that even fully distributed queue - based random access algorithms based on csma with very little message passing can simulate the mw algorithm asymptotically and hence achieve throughput - optimality in wireless interference network models @xcite .    however , the csma algorithms are known to suffer from the following two issues : the bad delay performance and the limited applicability to other network models . for the delay issue , bouman et al .",
    "@xcite formally established explicit lower bounds on the delay of queue - based random access algorithms . on the other hand ,",
    "significant efforts have also been made to design csma algorithms with better delay performance , e.g. , see @xcite .",
    "the limited applicability issue is rather technical : it is a technically tedious task to design similar csma - like throughput - optimal algorithms in other network models since one has to reproduce painful , long and routine proof - arguments for analyzing ` time - varying ' markov chains in each different model , e.g. , see the buffered circuit switched network model @xcite .",
    "the main motivation of this paper is for resolving these issues and goes beyond csma - like algorithms for achieving high performance guarantees and low implementation complexity , not sensitive to the underlying network models .",
    "we develop a generic framework for designing throughput - optimal and low - complexity scheduling algorithms , where queue - based csma algorithms belong to it as special cases . under the framework ,",
    "an algorithm updates current schedules via an interaction with a given oracle system that can generate a solution of a certain discrete optimization problem in a finite number of interactive queries .",
    "specifically , an algorithm maintains three parameters , ` schedule ' , ` weight ' and ` advice ' , at each time instance .",
    "the schedule and advice are kept being updated under interactions with the oracle system and the weight is decided by some function of current queue - size , which we call ` queue - length - function ' .",
    "therefore , the scheduling algorithm design is determined by ` which oracle is used ' and ` which queue - length - function is chosen ' .",
    "the oracle system can be designed through iterative optimization methods including the naive exhaustive search algorithm , the markov chain monte carlo ( e.g. , the glauber dynamics @xcite ) , the message - passing inference algorithms ( e.g. , the belief propagation @xcite ) and the linear / integer programming ( e.g. , the cutting - plane method @xcite ) . in this paper",
    ", we describe three oracle examples , the exhaustive search ( es ) , the markov chain monte carlo ( mcmc ) and the belief propagation ( bp ) in section [ sec : exam ] .",
    "in particular , the ` pick - and - compare ' algorithms @xcite and queue - based csma algorithms can be understood as such algorithms ( with minor modifications ) using es and mcmc oracles , respectively ( see section [ sec : exam ] ) .",
    "the scheduling complexity is decided by the number of operations required for an oracle processing a single query , which is typically very small , e.g. , es , mcmc and bp .",
    "we prove that given any oracle system , there exists a queue - length - function such that an algorithm using the oracle is throughput - optimal under general constrained queueing network models , which includes wireless network models , input - queued switch models , the buffered circuit switched network model , etc .",
    "in particular , we first show there exists a queue - length - function such that its value does not change too often ( i.e. , remains fixed for a long time ) and hence the mw optimization problem can be solved through ( enough ) interactions to the oracle , i.e. , the algorithm simulates mw and is throughput - optimal .",
    "this proof strategy is similar to those of @xcite in spirit .",
    "the main difference is that we force the queue - length - function value being ` rarely - varying ' in integers , while the authors in @xcite do it being ` slowly - varying ' in real numbers . due to such a difference , now we do not need to analyze ` time - varying ' algorithms ( e.g. , markov chains ) , i.e. , analysis when algorithm parameters are fixed is enough .",
    "this makes the proof much simpler and not sensitive to the given oracle and underlying network model .",
    "our strong theoretical statement provides a quite powerful paradigm for developing a variety of low - complexity scheduling algorithms of high performance .",
    "for example , our experimental results show that the delay performance of such an algorithm using the bp oracle is close to that of the mw algorithm , and it significantly outperforms csma algorithms ( see section [ sec : exp ] ) .",
    "moreover , one can also easily design other types of throughput - optimal algorithms , via designing various oracle systems , under a quite broad class of constrained queueing network models , without suffering from repeating tedious proofs sensitive to the underlying assumptions and setups . at a high level",
    ", we use the interactive oracle concept to provide a ` black - box ' tool for designing scheduling algorithms of high performance and low - complexity .",
    "this establishes a rigorous connection between iterative optimization methods and low - complexity scheduling algorithms , which we believe provides various future directions and new insights in both areas .      in section [ sec :",
    "pre ] , we describe the constrained queueing network model of our interest and the performance metric ( i.e. , throughput - optimality ) for scheduling algorithms .",
    "section [ sec : main ] provides the main result of this paper , i.e. , our generic framework for designing a throughput - optimal and low - complexity scheduling algorithm which decides its current schedule via an interaction with an oracle system . in section",
    "[ sec : exam ] , we provide several examples of scheduling algorithms under the framework .",
    "section [ sec : pfmainthm ] provides the formal proof of the main result , and our experimental results are presented in section [ sec : exp ] .",
    "we consider a stochastic network of @xmath0 queues represented by @xmath1 with @xmath2 , and time is discrete indexed by @xmath3 .",
    "external packets ( or jobs ) arrive at each queue as per an exogenous stochastic process , where we let @xmath4 denote the number of packets arriving at queue @xmath5 during the time interval @xmath6 .",
    "we assume that @xmath7 are independent bernoulli random variables with @xmath8=\\lambda_i\\ ] ] for some @xmath9 $ ] , called the _ arrival rate _ for queue @xmath5 .",
    "packets in queues are served at unit rate subject to scheduling constraints .",
    "formally , a schedule is denoted by @xmath10\\in \\{0,1\\}^n$ ] , where @xmath11 means queue @xmath5 is transmitting ( or active ) and @xmath12 otherwise .",
    "we let @xmath13 be a set of all available schedules and let @xmath14 be the schedule during @xmath6 for @xmath15 .    to describe the dynamics in the network , we let @xmath16 denote the number of packets in @xmath5-th queue at time @xmath17 ( i.e. , _ length of queue _ ) and let @xmath18 $ ] be the vector of queue lengths . then the queueing dynamics for queue @xmath5 can be described as @xmath19 where @xmath15 and @xmath20    for given @xmath1 and @xmath21 , our goal is to develop low - complexity and high - performance scheduling algorithms which determine @xmath22 for each time instance @xmath15 .",
    "a scheduling algorithm is required to choose @xmath14 at each time instance @xmath15 .",
    "we say an algorithm is throughput - optimal if it keeps queues finite for as large a set of arrival rates @xmath23 $ ] as possible . to describe it formally ,",
    "we define the capacity region as follows : @xmath24 where it is the convex hull of the feasible scheduling set @xmath21 . since @xmath14 , the effective ` service ' rate induced by any algorithm over time is essentially in @xmath25 . therefore ,",
    "if arrival rates @xmath26 can be served by any algorithm , then there exists @xmath27 such that @xmath28 component - wise .",
    "we say @xmath26 is _ ( strictly ) admissible _ if @xmath29 is ( strictly ) less than @xmath30 for some @xmath31 .",
    "let @xmath32 and @xmath33 be the set of all admissible and strictly admissible rates , respectively : @xmath34 a throughput - optimal algorithm keeps queues finite for any @xmath35 , where there can be many different ways to argue the finiteness of queues . in this paper",
    ", we use the following popular definition of throughput - optimality .",
    "[ def : throughput - optimality ] a scheduling algorithm is called _ throughput - optimal _ if for any @xmath35 the ( appropriately defined ) network markov chain is positive recurrent .",
    "if the state of the network markov chain includes queue - sizes , then its positive recurrence implies that the queues remain finite with probability 1 , which motivates the above definition .",
    "we recall the definition of the positive recurrence of a markov chain @xmath36 on a countable state space @xmath37 .",
    "a state @xmath38 is said to be _ recurrent _ if @xmath39=1 $ ] , where @xmath40 . if @xmath41<\\infty$ ] , a recurrent state @xmath42 is called _ positive recurrent_. if a markov chain is irreducible and it has a positive recurrent state , all states are positive recurrent . in this case , we call such a markov chain positive recurrent . one way to show the positive recurrence of a markov chain is using the following lyapunov - foster criteria .",
    "a function @xmath43 is called a ` lyapunov function ' if @xmath44 .",
    "the following theorem provides a criteria about the positive recurrence using a lyapunov function , e.g. , see @xcite .",
    "[ thm : lyapunov ] consider a lyapunov function @xmath45 such that @xmath46 is finite for any @xmath47 .",
    "suppose there exist functions @xmath48 such that @xmath49\\leq -\\kappa({\\mathsf{x}}),~\\forall x\\in\\omega,\\ ] ] and they satisfy the following conditions :    1 .",
    "2 .   @xmath51 .",
    "@xmath52 for all @xmath47 .",
    "4 .   @xmath53 .",
    "then , @xmath54 is positive recurrent .",
    "this section presents our main result , throughput - optimal and low - complexity scheduling algorithms .",
    "we first describe the generic concept of our algorithms utilizing certain oracle systems .",
    "the oracle systems are motivated by ( randomized or deterministic ) iterative algorithms which find an approximate optimal solution to the following optimization problem : @xmath55 typically , in an iterative algorithm , the output at each iteration depends only on information from the previous iteration ( and weight @xmath56 ) .",
    "we call such information ` advice '",
    ". one can understand an iteration of the algorithm as an interaction to an oracle system , where a query consisting of advice and weight is sent to an interactive oracle system , and the oracle returns a schedule together with an updated advice for the next iteration .",
    "this naturally suggests the following scheduling algorithm : at each time instance @xmath17 , ( a ) it sends a query consisting of the advice @xmath57 produced in the previous step and weight @xmath58 decided by current queue lengths to the oracle system , and then ( b ) the oracle returns a schedule to use at the next time instance @xmath59 .",
    "hence , the complexity of the scheduling algorithm is that of the oracle system processing a query ( equivalently , that of one iteration of an iterative algorithm ) , which is typically very small as we provide examples in section [ sec : exam ] . in the following sections , we provide the formal descriptions of oracle systems of interest and scheduling algorithms utilizing them .     and",
    "weight @xmath58 is sent to the oracle .",
    "the oracle returns the schedule @xmath60 to use at the next time instance and updated advice @xmath61 .",
    ", width=288 ]      we consider a network model introduced in section  [ subsec : network_model ] with set of queues @xmath1 with @xmath2 and available schedules @xmath62 .",
    "then the oracle system we are interested in has an advice space @xmath63 with the following input and output :    * it takes inputs @xmath64 and @xmath65 $ ] , * it outputs ( or returns ) @xmath66 and @xmath67 ,    where @xmath56 , @xmath68 , and @xmath69 are called ` weights ' on queues , ` advice ' , and ` updated advice ' , respectively .",
    "formally , let the outputs @xmath70 and @xmath71 , where the oracle can generate random outputs in general .",
    "we assume that the oracle system satisfies the following properties :    1 .   for any @xmath72",
    ", if @xmath73 is large enough , then there exists @xmath74 such that for any @xmath75 and advice @xmath64 , @xmath76 where @xmath77 is the function composing @xmath78 ` @xmath17 times ' , i.e. , @xmath79 .",
    "2 .   for any @xmath56 , @xmath80    the first assumption *",
    "a1 * implies that the schedule @xmath30 generated by the oracle system after @xmath81 interactions is an approximate solution to the optimization problem .",
    "the second assumption * a2 * is merely for a technical purpose : it provides the countability of the underlying space of the network markov chain which we define in the following section .      in this section",
    ", we describe our scheduling algorithm given an oracle system . to this end",
    ", we let @xmath82 be positive - real - valued functions and @xmath83 where @xmath84 .",
    "the algorithm maintains parameters @xmath85 .",
    "it updates the schedule @xmath22 and parameters @xmath86 under an interaction with the oracle system as follows :    ' '' ''    * @xmath87 , * @xmath88 , * @xmath89 is the closest integer to @xmath90 if @xmath91 and @xmath92 otherwise .    ' '' ''    figure [ fig : oracle ] illustrates the above scheduling algorithm using an interactive oracle system . for each time @xmath93",
    ", we let @xmath94 then , @xmath95 becomes a markov chain on the following state space @xmath37 : @xmath96 then , @xmath37 is countable due to the assumption * a2 * of the oracle system .",
    "now we are ready to state the main result in this paper , where its proof is presented in section [ sec : pfmainthm ] .",
    "[ thm : mainresult ] the above scheduling algorithm is throughput - optimal , i.e. , @xmath54 is positive recurrent for any @xmath35 , if functions @xmath97 satisfy the assumptions * a1-a2 * and the following conditions :    1 .   @xmath98 and @xmath99 are increasing , differentiable and concave .",
    "2 .   @xmath100 and @xmath101 .",
    "3 .   @xmath102 .",
    "5 .   for any fixed @xmath104 , @xmath105 6 .",
    "there exists @xmath106 such that , for any fixed @xmath104 , @xmath107    in the following section , we provide several specific examples of throughput - optimal and low - complexity scheduling algorithms under theorem [ thm : mainresult ] .",
    "in this section , we show the wide - applicability of our framework by designing several throughput - optimal and low - complexity scheduling algorithms under it . in particular , we provide examples of low - complexity oracle systems with corresponding explicit functions @xmath97 so that they satisfy the assumptions * a1-a2 * and the conditions * c1-c6 * of theorem  [ thm : mainresult ] .",
    "the first oracle system we introduce utilizes an exhaustive search ( es ) algorithm to find a maximum weight schedule @xmath66 , i.e. , it maximizes @xmath108 over @xmath66 for given @xmath1 with @xmath2 , @xmath62 , and @xmath109 . an es algorithm keeps a search - index @xmath110 which may not be in @xmath21 , and current maximum schedule @xmath66 . at each iteration , if @xmath111 is in @xmath21 and its weight is greater than the weight of @xmath30 , replace @xmath30 by @xmath111 .",
    "in addition , it updates the search index @xmath111 by @xmath112 where @xmath113 can be considered as a non - negative integer less than @xmath114 and @xmath112 is naturally defined under the interpretation . * es oracle system . * formally , the es oracle system has an advice space @xmath115 . for an advice @xmath116 and weights @xmath117 ,",
    "the oracle outputs @xmath118 and @xmath119 are decided as follows :    ' '' ''    * set @xmath120 * set @xmath121 .    ' '' ''    since it compares all schedules in @xmath21 exhaustively , after @xmath114 interactions with the oracle system , it returns a schedule @xmath66 whose weight is maximum .",
    "thus we have , for all @xmath64 and @xmath122 , @xmath123 which implies that we can take @xmath124 for the the assumption * a1 * , i.e. , @xmath81 is a constant function with respect to @xmath125 . in addition",
    ", the assumption * a2 * holds obviously . using these facts and theorem [ thm : mainresult ]",
    ", the following corollary can be derived .",
    "[ cor : es ] the scheduling algorithm described in section [ sec : algorithm_description ] using the es oracle system is throughput - optimal if @xmath126    it is elementary to check the conditions * c1 * -*c5 * of theorem [ thm : mainresult ] , where @xmath124 .",
    "the condition * c6 * of theorem [ thm : mainresult ] can be derived as follows : for @xmath127 , @xmath128 this completes the proof of corollary [ cor : es ] .",
    "the second oracle system we introduce is the markov chain monte carlo ( mcmc ) algorithm . for a detailed description of the oracle",
    ", we consider a special setup of available schedules @xmath21 .",
    "[ fig : wireless ]   queues in grid interference topology .",
    "available schedules are @xmath129 , @xmath130 , @xmath131 , @xmath132 , @xmath133 , @xmath134 , etc.,title=\"fig:\",width=240 ]    * wireless network model . *",
    "we consider an undirected graph @xmath135 and the set of available schedules @xmath21 is defined as : @xmath136 the above scheduling constraint has been popularly used for modeling interference in wireless networks @xcite , i.e. , two queues @xmath5 and @xmath137 can not transmit simultaneously if they share an edge in the ` interference ' graph @xmath138 .",
    "we let @xmath139 denote the set of interfering neighbors of queue @xmath5 .",
    "* mcmc oracle system .",
    "* in the mcmc oracle system , the advice space is @xmath140 and for an advice @xmath141 , the oracle outputs @xmath118 and @xmath142 are decided randomly as follows :    ' '' ''    1 .",
    "choose a queue @xmath5 uniformly at random , and set @xmath143 2 .",
    "if @xmath144 for some @xmath145 , then set @xmath146 .",
    "otherwise , set @xmath147 @xmath148 where @xmath149 .",
    "4 .   for each @xmath150 , * if @xmath11 , then set @xmath151 * else if @xmath152 for all @xmath145 , then set @xmath153 * otherwise , set @xmath154 .    ' '' ''    then , using known results on the mixing time of mcmc , one can prove that the assumption * a1 * holds with @xmath155 where @xmath156 are some ( ` @xmath0-dependent ' ) constants independent of @xmath157 .",
    "the proof of is a direct consequence of lemma 3 and lemma 7 in @xcite , and we omit the details due to space constraints .",
    "the assumption * a2 * also holds obviously again . using these facts and theorem [ thm : mainresult ]",
    ", the following corollary can be derived .",
    "[ cor : mcmc ] the scheduling algorithm described in section [ sec : algorithm_description ] using the mcmc oracle system is throughput - optimal if @xmath158    it is elementary to check the conditions * c1 * -*c4 * of theorem [ thm : mainresult ] .",
    "the condition * c5 * is from and @xmath159 : @xmath160 furthermore , the condition * c6 * can be derived as follows : this completes the proof of corollary  [ cor : mcmc ] .",
    "[ cor : mcmc ] the scheduling algorithm described in section [ sec : algorithm_description ] using the mcmc oracle system is throughput - optimal if @xmath161 where @xmath162 .",
    "it is elementary to check the conditions * c1 * -*c4 * of theorem [ thm : mainresult ] . for the condition * c5 * , @xmath163 which comes from and @xmath164 .",
    "then @xmath165 and it implies the condition * c5*.    the condition * c6 * can be derived as follows : for large enough @xmath166 , @xmath167 . combining this with , we have that @xmath168 it completes the proof of corollary  [ cor : mcmc ] .",
    "we note that the scheduling algorithm described in section [ sec : algorithm_description ] using the mcmc oracle system is the discrete - time version of the csma algorithm in @xcite .",
    "the third oracle system we introduce is the belief propagation ( bp ) algorithm , where bp is a popular heuristic iterative algorithm for solving inference problems arising in graphical models @xcite . for the provable throughput - optimality of the scheduling algorithm using the bp oracle system , we consider a special setup of available schedules @xmath21 which is described in what follows",
    ".    * input - queued switch model .",
    "* we consider the undirected complete bipartite graph of left - vertices @xmath169 , right - vertices @xmath170 , and edges @xmath171 , where @xmath172 then , the set of queues is @xmath173 of @xmath174 queues and @xmath175 where this is a popular model for input - queued switches @xcite , and also a special case of the wireless network model described in the previous section .",
    "input ports and @xmath176 output ports , there are @xmath177 queues .",
    "available schedules are @xmath178 , @xmath179 , @xmath132 , @xmath133 , @xmath180 , and @xmath181.,width=240 ]    * bp oracle system .",
    "* in the bp oracle system , the advice space is @xmath182 and for an advice @xmath183 , where @xmath184 $ ] , the oracle outputs @xmath118 and @xmath185 are decided as follows :    ' '' ''    * for each @xmath186 , set @xmath187 where @xmath188 * if @xmath189 , reset @xmath190 .    ' '' ''    in the above , one can set @xmath191\\in [ 0,1]^{|\\mathcal e|}$ ] such that @xmath192 is unique , and @xmath193 for some constant @xmath194 , e.g. , let @xmath195 be a random number in the interval @xmath196 $ ] . then , from the works by bayati et al .",
    "@xcite or sanghavi et al .",
    "@xcite , it follows that the assumption * a1 * holds with @xmath197 for the assumption * a2 * , one can observe that @xmath198 which is obviously a finite set given @xmath56 .",
    "using these facts and theorem [ thm : mainresult ] , the following corollary can be derived . in the bp oracle system ,",
    "the advice space is @xmath199 and for an advice @xmath200\\in",
    "\\mathbb a$ ] , the oracle outputs @xmath118 and @xmath201 are decided as follows :    * for each @xmath202 , set @xmath203 where @xmath204 * if @xmath189 , reset @xmath205 by an arbitrary schedule in @xmath21 .    in the above ,",
    "we carefully design @xmath206 so that ( a ) @xmath192 is unique , ( b ) @xmath207 and ( c ) @xmath208 .",
    "then , from the work by bayati et al .",
    "@xcite , it follows that the assumption * a1 * holds with @xmath209 for the assumption * a2 * , one can observe that @xmath210 which is obviously a finite set given @xmath56 . using these facts and theorem [ thm : mainresult ]",
    ", the following corollary follows .",
    "the ( max - product ) bp is an iterative , message - passing algorithm for finding @xmath66 which maximizes @xmath108 .",
    "the algorithm maintains messages @xmath211 at the @xmath17-th iteration , and they are updated as : @xmath212 where @xmath213 is @xmath166 if @xmath214 and @xmath215 otherwise .",
    "after enough iterations , the algorithm outputs @xmath216 if @xmath217 , and @xmath218 otherwise .",
    "bayati et al .",
    "@xcite establish the following result .    * if the desired maximizer @xmath219 is unique , the bp algorithm outputs it for all @xmath220 , where @xmath221 is the difference between the weights of the maximum weight schedule and the second maximum weight schedule , i.e. , @xmath222 .",
    "the unique condition in the above theorem can be removed by adding small noises to weights .",
    "for example , for integer weight @xmath56 , by adding @xmath223 for the @xmath5-th weight , we guarantee unique maximizer . in our model , for @xmath224 and @xmath225 , we add @xmath226 to @xmath227 weight and we get the following conclusion :    * for integer weight @xmath56 , the bp algorithm outputs @xmath219 for all @xmath228 .",
    "now we explain how the bp algorithm can be understood as an oracle system .",
    "an advice is represented by @xmath229 and , with input @xmath68 , the oracle system outputs following @xmath230 and @xmath231 : @xmath232 namely , the iterative bp mechanism can be thought as an interactive oracle system , where messages corresponds to advices . due to * bp2 * , we have @xmath233 and by theorem [ thm : mainresult ] , the following corollary follows .",
    "[ cor : bp ] the scheduling algorithm described in section [ sec : algorithm_description ] using the bp oracle system is throughput - optimal if @xmath234    it is elementary to check the conditions * c1 * -*c5 * of theorem [ thm : mainresult ] , where @xmath235 .",
    "the condition * c6 * of theorem [ thm : mainresult ] can be derived as follows : for @xmath236 , @xmath237 where @xmath238 is some constant depending on @xmath239 and the last equality is from @xmath240 and @xmath241 .",
    "this completes the proof of corollary [ cor : bp ] .",
    "we note that there are many different ways to design the bp oracle , for example , one can consider the following variant .    ' '' ''    * for each @xmath186 , set @xmath242 * choose @xmath186 so that @xmath243 is the largest one among those which @xmath244 after resetting @xmath245 . * reset @xmath245 and keep this procedure until no more edge is found in the step 2 .    ' '' ''    the scheduling algorithm described in section [ sec : algorithm_description ] using the above second bp oracle system is also throughput - optimal for the same set of functions @xmath246 in theorem [ cor : bp ] , where its proof is identical to that of the first bp oracle system .",
    "the main difference in the second bp oracle is that it decides the schedule @xmath247 greedily based on the ` belief ' @xmath248 $ ] , while the first one simply checks whether @xmath243 is positive or not .",
    "a similar version of the scheduling algorithm using the second oracle system was actually studied in @xcite heuristically , where by carefully choosing queue - length functions , theorem [ thm : mainresult ] provides its formal throughput - optimality proof which is missing in @xcite .      in this section ,",
    "we introduce the fourth oracle system combining two mechanisms , bp and es , in the wireless interference network model described in section [ sec : mcmc_wireless ] .",
    "we call it the bp - es oracle system .    * bp - es oracle system .",
    "* in the oracle system , the advice space is @xmath249 , and for an advice @xmath250 where @xmath251 $ ] , the oracle outputs @xmath118 and @xmath252 are decided as follows :    ' '' ''    * for each edge @xmath186 , set @xmath253 * choose a queue @xmath5 uniformly at random , and set @xmath254 * set @xmath255 where @xmath256 $ ] is defined as @xmath257    ' '' ''    as in section  [ sec : mcmc_wireless ] , we consider an undirecteted graph @xmath258 and let @xmath259 the first algorithm we utilize for this model is exhaustive search ( es ) which is introduced in section  [ sec : es ] and for fixed weight @xmath56 , it find a maximum weight scheduling in @xmath114 iterations",
    ". another algorithm is belief propagation ( bp ) for maximum weight independent set . in this algorithm , at every iteration @xmath17 , each node @xmath5 sends a message @xmath260 to each neighbor @xmath145 .",
    "each node also maintains a belief @xmath261 .",
    "the message and belief updates are as follows :    * initially , set @xmath262 for all @xmath263 . * update messages : @xmath264 * for each @xmath150 , @xmath265 * output @xmath22 as @xmath266    bp algorithm for wireless networks sometimes finds a maximum weight schedule but it does not always converge .",
    "so , we combine two algorithms and call it es+bp .    in the above , the second and third steps can be implementable in distributed fashions using poisson clocks @xcite and gossip algorithms for distributed averaging @xcite . the bp - es oracle system outputs schedule @xmath205 as the maximum weight one among three schedules @xmath30 , @xmath111 and @xmath267 , where @xmath30 is the current maximum schedule",
    ", @xmath111 is the es search index and @xmath267 is decided by the bp mechanism . since the search index @xmath111 is decided randomly , the bp - es oracle finds an maximum weight schedule with probability @xmath268 after @xmath269 interactions for the the assumption * a1*. the assumption * a2 * holds with similar reasons as before . using these facts and theorem [ thm : mainresult ] , the following corollary can be derived .",
    "[ cor : esbp ] the scheduling algorithm described in section [ sec : algorithm_description ] with the bp - es oracle system is throughput - optimal if @xmath270    the proof of corollary [ cor : esbp ] is almost identical to that of corollary [ cor : es ] .",
    "this section provides the proof of theorem  [ thm : mainresult ] , i.e. , we show that @xmath36 described in section [ sec : algorithm_description ] is positive recurrent , as long as @xmath271 and @xmath97 satisfy the assumptions * a1-a2 * and the conditions * c1 * -*c6 * stated in theorem  [ thm : mainresult ] . towards this , we shall construct a lyapunov function @xmath169 and auxiliary functions @xmath272 , @xmath273 so that they satisfy the conditions of theorem  [ thm : lyapunov ] .",
    "first , note that the state space @xmath37 is countably infinite from the assumption * a2 * of the oracle system .",
    "for @xmath274 , we consider the following function : @xmath275 where @xmath276 .",
    "since @xmath277 from the condition * c2 * , we have @xmath278 as @xmath279 .",
    "thus , @xmath280 and @xmath43 is a lyapunov function . with an abuse of notation",
    ", we use @xmath281 to denote @xmath282 .",
    "now , given @xmath271 , there exists @xmath283 and @xmath284\\in [ 0,1]^{|s|}$ ] so that @xmath285 for a state @xmath274 , we consider the following functions @xmath272 and @xmath273 : @xmath286 where @xmath287 is a constant in the condition * c6 * , @xmath288 is the largest integer not greater than @xmath166 , and @xmath289 are some constants satisfying @xmath290 for example , one can choose @xmath291 . using the above functions , we shall establish the following lemma .",
    "[ lemma : negative_drift ] for every initial state @xmath38 with large enough @xmath292 and every arrival rate @xmath35 , it follows that @xmath293\\,|\\,{\\boldsymbol{x}}(0)={\\mathsf{x}}]\\leq -\\kappa({\\mathsf{x}}).\\label{eq : negative_drift}\\ ] ]    the proof of the above lemma is presented in section [ sec : pf : lemma : negative_drift ] . in the remainder of this section",
    ", we check that @xmath272 and @xmath273 satisfy the desired conditions * l1-l4 * of theorem  [ thm : lyapunov ] , which leads to the positive recurrence of the markov chain @xmath95 .",
    "first , it is easy to check that @xmath294 is finite . without loss of generality",
    ", we can also assume that holds for every @xmath38 by letting @xmath295 if @xmath292 is not large enough .",
    "from the conditions * c2 * and * c4 * , we have @xmath296 as @xmath297 . since @xmath98 is an unbounded increasing function due to * c1 * and * c2 * , we have @xmath298 as @xmath297 .",
    "thus , the first two conditions * l1 * and * l2 * are satisfied .    by the definition of function @xmath272 , it is not hard to check that @xmath272 increases as @xmath299 does",
    ". therefore , it follows that @xmath300 which implies the condition * l3*. finally , as @xmath278 ( i.e. , @xmath297 ) , @xmath301^{-1}\\to 0,\\end{aligned}\\ ] ] which implies the condition * l4*. this completes the proof of theorem [ thm : mainresult ] .      to begin with",
    ", we describe the main steps to prove lemma  [ lemma : negative_drift ] at a high level :    1 .   for",
    "given initial state @xmath42 with large enough @xmath299 , @xmath58 does not change many times in @xmath302 $ ] , which is formally stated in lemma  [ lemma : stopping_time ] .",
    "the schedule @xmath22 is close to a max - weight one with respect to @xmath303 ` mostly ' in the time interval @xmath304 $ ] , which is formally stated in lemma  [ lemma : bernoulli_main ] .",
    "the first step plays a key role for establishing the second step : since @xmath58 does not change often , the interactive oracle system can find a max - weight schedule with respect to @xmath305 .",
    "the max - weight property in the second step will lead to the negative drift property in lemma  [ lemma : negative_drift ] .",
    "now we proceed toward proving lemma  [ lemma : negative_drift ] formally .",
    "let @xmath306 is the time at which the @xmath307-th change of @xmath58 occurs , i.e. , @xmath58 remains fixed during the time interval @xmath308 .",
    "formally , let @xmath309 and for @xmath310 , iteratively define @xmath311 in the following lemma , for initial state @xmath42 with large enough @xmath299 , we show that @xmath58 can be changed at most @xmath0 times in time interval @xmath302 $ ] , i.e. , @xmath312 .",
    "[ lemma : stopping_time ] for any initial state @xmath313 with large enough @xmath299 , the following event occurs with probability @xmath314 : @xmath312 and @xmath315,\\label{eq : bound_of_q_max}\\end{aligned}\\ ] ] where @xmath287 is the constant in the condition * c6 * of theorem  [ thm : mainresult ] .",
    "since @xmath58 remains fixed for @xmath316 , the assumption * a1 * implies that that with high probability , @xmath22 is close to the max - weight schedule with respect to @xmath58 for @xmath317 using this observation with lemma [ lemma : stopping_time ] , we obtain the following lemma that with high probability , the schedule @xmath22 is closed to a max - weight one with respect to @xmath303 ` mostly ' in the time interval @xmath304 $ ] .",
    "[ lemma : bernoulli_main ] for any @xmath318 and initial state @xmath274 with large enough @xmath299 , it follows that @xmath319~\\geq~1-\\beta,\\ ] ] where @xmath320\\,:\\\\      & { \\boldsymbol{\\sigma}}(t)\\cdot f({\\boldsymbol{q}}(t))\\geq ( 1-\\eta)\\max_{{\\boldsymbol{\\rho}}\\in s}{\\boldsymbol{\\rho}}\\cdot f({\\boldsymbol{q}}(t))\\bigg\\}.    \\end{aligned}\\ ] ]    in the remainder of this section , we shall establish the proof of lemma  [ lemma : negative_drift ] using lemma  [ lemma : stopping_time ] and lemma  [ lemma : bernoulli_main ] . to this end , we first recall that @xmath321 from the conditions * c1 * and * c4 * , we have @xmath322 where @xmath323 $ ] . in addition , from , we have an upper bound on the expectation of the first term in : @xmath324 } \\nonumber \\\\    & = & { \\mathbb e}[{\\boldsymbol{a}}(t)]\\cdot { \\mathbb e}[f({\\boldsymbol{q}}(t))\\;|\\ ; { \\boldsymbol{x}}(0)={\\mathsf{x } } ] \\nonumber \\\\    & \\leq & \\sum_{{\\boldsymbol{\\rho}}\\in s } \\alpha_{{\\boldsymbol{\\rho}}}{\\boldsymbol{\\rho}}\\cdot { \\mathbb e}[f({\\boldsymbol{q}}(t))\\;|\\ ; { \\boldsymbol{x}}(0)={\\mathsf{x } } ] \\nonumber \\\\    & \\leq & ( 1-\\varepsilon ) { \\mathbb e}[\\max_{{\\boldsymbol{\\rho}}\\in s}{\\boldsymbol{\\rho}}\\cdot f({\\boldsymbol{q}}(t))\\;|\\ ; { \\boldsymbol{x}}(0)={\\mathsf{x } } ] .",
    "\\label{eq : arrival_bound}\\end{aligned}\\ ] ] by combining and , it follows that @xmath325\\,|\\,{\\boldsymbol{x}}(0)={\\mathsf{x}}]}\\\\ & = & { \\mathbb e}\\left[\\sum_{t=0}^{\\tau({\\mathsf{x}})-1}l(t+1)-l(t)\\,\\bigg|\\,{\\boldsymbol{x}}(0)={\\mathsf{x}}\\right]\\\\ & \\leq & \\sum_{t=0}^{\\tau({\\mathsf{x}})-1}{\\mathbb e}\\left [ { \\boldsymbol{a}}(t)\\cdot f({\\boldsymbol{q}}(t))\\,|\\,{\\boldsymbol{x}}(0)={\\mathsf{x}}\\right]\\\\ & & \\mbox { } -\\sum_{t=0}^{\\tau({\\mathsf{x}})-1}{\\mathbb e}\\left[{\\boldsymbol{\\sigma}}(t)\\cdot f({\\boldsymbol{q}}(t))\\,|\\,{\\boldsymbol{x}}(0)={\\mathsf{x}}\\right ] + n f'(0)\\tau({\\mathsf{x}})\\\\ & = & { \\mathbb e}\\left[\\sum_{t=0}^{\\tau({\\mathsf{x}})-1}\\delta(t)\\;\\bigg|\\ ; { \\boldsymbol{x}}(0)={\\mathsf{x}}\\right],\\end{aligned}\\ ] ] where @xmath326    now we will bound @xmath327 . from lemma [ lemma : bernoulli_main ] with @xmath328 , where @xmath329 is defined in , it follows that for @xmath330 , @xmath331 where the last inequality is from lemma [ lemma : stopping_time ] . on the other hand , for any @xmath332 $ ] , we know that @xmath333 using these facts with lemma [ lemma : bernoulli_main ] , we further have that @xmath325\\,|\\,{\\boldsymbol{x}}(0)={\\mathsf{x}}]}\\\\ & \\leq & { \\mathbb e}\\left[\\sum_{t=0}^{\\tau({\\mathsf{x}})-1}\\delta(t)\\;\\bigg|\\ ; { \\boldsymbol{x}}(0)={\\mathsf{x}}\\right]\\\\ & = & \\pr [ \\mathcal a^c]\\cdot { \\mathbb e}\\left[\\sum_{t=0}^{\\tau({\\mathsf{x}})-1}\\delta(t)\\;\\bigg|\\ ; { \\boldsymbol{x}}(0)={\\mathsf{x}},\\mathcal a^c\\right]\\\\ & & \\qquad + ~\\pr[\\mathcal a]\\cdot { \\mathbb e}\\left[\\sum_{t=0}^{\\tau({\\mathsf{x}})-1}\\delta(t)\\;\\bigg|\\ ; { \\boldsymbol{x}}(0)={\\mathsf{x}},\\mathcal a\\right]\\\\ & \\leq & \\beta\\,n\\,f((1+c)q_{\\max})\\tau({\\mathsf{x } } ) + n\\,f'(0)\\tau({\\mathsf{x}})\\\\ & & \\qquad + ( 1-\\beta)\\,n\\,f((1+c)q_{\\max})\\alpha\\,\\tau({\\mathsf{x}})\\\\ & & \\qquad + \\left(1-\\beta\\right)\\left(-\\frac{\\varepsilon}{2 } f((1-c)q_{\\max})\\right)(1-\\alpha)\\tau({\\mathsf{x}})\\\\ & \\leq & \\left ( -\\frac{\\varepsilon}{2}(1-\\beta)(1-\\alpha)+\\frac{2n(\\beta+(1-\\beta)\\alpha)}{1-c}\\right)\\times\\\\ & & \\qquad f((1-c)q_{\\max})\\tau({\\mathsf{x } } ) + n\\,f'(0)\\tau({\\mathsf{x}})\\\\    & = & -\\kappa({\\mathsf{x}}),\\end{aligned}\\ ] ] where @xmath334 denotes the event that @xmath335 and in the last inequality , we use the following property for concave function @xmath98 : @xmath336 this completes the proof of lemma  [ lemma : negative_drift ] .",
    "we first proceed toward proving in lemma  [ lemma : stopping_time ] .",
    "it follows from the following observations : @xmath337 where the first inequality is from our modeling assumption that @xmath338 and @xmath339 , and the second inequality is from the definition of @xmath272 .",
    "hence , for @xmath340 $ ] , @xmath341 does not change more than @xmath342 from its initial value @xmath343 , which completes the proof of .",
    "now , we aim for proving @xmath312 .",
    "it suffices to show that , for given initial state @xmath42 with large enough @xmath299 , @xmath344,\\ ] ] i.e. , @xmath345 does not change more than @xmath314 , and hence @xmath346 can be updated at most once for each @xmath150 . to prove , it is enough to show the following inequality : @xmath347 since using the definition of @xmath272 , @xmath348 to this end , for @xmath340 $ ] , consider following cases :    1 .",
    "if @xmath349 , then from the definition @xmath350 the amount of change @xmath351 is bounded by @xmath352 where we use and the condition * c1 * , i.e. , @xmath353 is decreasing .",
    "2 .   otherwise ,",
    "it is bounded by @xmath354    where we use and the conditions * c1-c2 * , i.e. , @xmath353 is decreasing , @xmath355 and @xmath356 for large enough @xmath166 .",
    "this completes the proof of and hence that of lemma  [ lemma : stopping_time ] .      without loss of generality , assume that @xmath357 and let @xmath358 to simplify notation , we will use @xmath359 instead of @xmath360 . from conditions",
    "* c1 * -*c6 * , it is elementary to check that for large enough @xmath166,@xmath361 where their detailed proofs are given in appendix [ sec : appenda ] . due to lemma",
    "[ lemma : stopping_time ] , we can assume that @xmath362 and @xmath363    the sufficient conditions to prove lemma  [ lemma : bernoulli_main ] are the following :    1 .",
    "for all @xmath332$],@xmath364 \\leq \\max_{{\\boldsymbol{\\rho}}\\in s } { \\boldsymbol{\\rho}}\\cdot { \\boldsymbol{w}}(t).\\ ] ] 2 .   with probability @xmath365 , at least @xmath366 number of time instance @xmath367 $ ] satisfy @xmath368\\leq { \\boldsymbol{\\sigma}}(t)\\cdot{\\boldsymbol{w}}(t).\\label{eq : claimb}\\ ] ] 3 .   for all @xmath340 $ ]",
    "at which is satisfied , @xmath369    the proof of lemma [ lemma : bernoulli_main ] comes immediately from ( a ) , ( b ) and ( c ) as follows : @xmath370    & = & ( 1-\\eta')^3\\left[\\max_{{\\boldsymbol{\\rho}}\\in s } { \\boldsymbol{\\rho}}\\cdot f({\\boldsymbol{q}}(t))\\right ] \\\\    & \\leq &   ( 1-\\eta')^2\\left[\\max_{{\\boldsymbol{\\rho}}\\in s } { \\boldsymbol{\\rho}}\\cdot { \\boldsymbol{w}}(t ) \\right]\\\\    & \\leq & ( 1-\\eta ' ) \\left({\\boldsymbol{\\sigma}}(t)\\cdot{\\boldsymbol{w}}(t)\\right ) \\\\",
    "& \\leq & { \\boldsymbol{\\sigma}}(t)\\cdot f({\\boldsymbol{q}}(t)),\\end{aligned}\\ ] ] where with probability @xmath365 , at least @xmath366 number of time instance @xmath367 $ ] satisfy the second last and last inequalities .",
    "hence , we proceed toward proving ( a ) , ( b ) and ( c )",
    ".    * proof of ( a ) . *",
    "recall that our scheduling algorithm in section [ sec : algorithm_description ] maintains @xmath371 , where @xmath372 .",
    "thus , for @xmath15 and @xmath150 , we have @xmath373 and @xmath374 for large enough @xmath299 , combining above inequality with , we conclude that @xmath375}\\\\    & \\leq & \\left(1-\\frac{2n}{f((1-c)q_{\\max})}\\right ) \\left[\\max_{{\\boldsymbol{\\rho}}\\in s } { \\boldsymbol{\\rho}}\\cdot f({\\boldsymbol{q}}(t))\\right]\\\\    & \\leq & \\max_{{\\boldsymbol{\\rho}}\\in s } { \\boldsymbol{\\rho}}\\cdot f({\\boldsymbol{q}}(t))-2n\\\\    & \\leq & \\max_{{\\boldsymbol{\\rho}}\\in s } { \\boldsymbol{\\rho}}\\cdot { \\boldsymbol{w}}(t),\\end{aligned}\\ ] ] where we use @xmath376 for @xmath332 $ ] from .",
    "* proof of ( b ) .",
    "* we first state the following key proposition for the proof of ( b ) .",
    "[ lem : assum1 ] suppose the assumption * a1 * holds .",
    "then , for any advice @xmath64 and @xmath377 , the following event occurs with probability @xmath378 : @xmath379    for @xmath75 , define a binary random variable @xmath380 such that @xmath381",
    "if @xmath382 and @xmath383 otherwise . then , from the assumption * a1 * , @xmath384 < \\delta$ ] and @xmath385 < \\delta(l - h)$ ] . the conclusion of proposition [ lem : assum1 ] directly follows from the markov inequality applying to the random variable @xmath386 .    from the above proposition",
    ", it follows that with probability @xmath378 , @xmath387 where from lemma [ lemma : stopping_time ] , we set @xmath388 due to @xmath389",
    ". since @xmath58 changes at most @xmath0 times in @xmath302 $ ] from lemma [ lemma : stopping_time ] , one can use the union bound and conclude that with probability @xmath390 , @xmath391 for at least @xmath392 fraction of times in @xmath393 .",
    "furthermore , from , , and the definition of @xmath272 , we have @xmath394 thus , it follows that @xmath395 therefore , with probability @xmath365 , for at least @xmath396 fraction of times in the interval @xmath302 $ ] , holds .",
    "* proof of ( c ) . * from , we first have that @xmath397 for all @xmath340 $ ] at which is satisfied , @xmath398\\\\    & \\leq & { \\boldsymbol{\\sigma}}(t)\\cdot{\\boldsymbol{w}}(t),\\end{aligned}\\ ] ] where we use , and @xmath399 . for large enough @xmath299 , combining the above inequality with leads to ( c ) : @xmath400 this completes the proof of lemma  [ lemma : bernoulli_main ] .",
    "this section presents experimental results for the performance of our scheduling algorithm using various interactive oracle systems .",
    "we consider two network models : input - queued switch networks and wireless networks described in section [ sec : mcmc_wireless ] and section [ sec : bp ] , respectively . we compare the average queue - length in our scheduling algorithm using the mcmc , es and bp oracle systems with that of the mw algorithm @xcite",
    ".        * input - queued switch network . *",
    "we first consider an input - queued switch network on @xmath401 complete bipartite graph topology in section  [ sec : bp ] .",
    "we report the average queue lengths in the switch network for @xmath402 with load 90% , i.e. , arrival rates @xmath403 for all @xmath186 and any algorithm can not stabilize the queues if @xmath404 for all @xmath405 .",
    "we run the mw algorithm and our low - complexity scheduling algorithms using the mcmc , es , and bp oracle systems , where we consider the second bp oracle described in section [ sec : bp ] . here",
    "we use @xmath406 for es and bp oracles and @xmath407 for mcmc oracle . also , in bp oracle system , instead of using arbitrary schedule in @xmath21 when @xmath408 , we use a greedy algorithm with belief - weight to find a schedule , where belief at each @xmath202 is defined by @xmath409 :    * find @xmath410 with maximum belief @xmath411 . * when @xmath412 are given ,",
    "choose @xmath413 such that @xmath414 is a matching and @xmath415 is maximum among such @xmath416 .",
    "figure  [ fig : switch_performance ] summarizes our experimental results and we observe that the performance of our scheduling algorithm using bp oracle system is as good as that of the mw algorithm , although it is much simpler to code and faster to run .",
    "grid topology.,title=\"fig:\",width=288 ]   grid topology.,title=\"fig:\",width=288 ]    * wireless networks in grid topology . *",
    "we also consider a wireless network with two dimensional grid interference topology . due to the high complexity of the mw algorithm , we chose the @xmath417 grid , i.e. , @xmath418 queues , where figure  [ fig : wireless ] represents the @xmath419 grid .",
    "we again compare the evolution of the average queue lengths of the mw algorithm and our scheduling algorithms using es , mcmc and bp - es oracle systems .",
    "we note that we consider a minor variant of bp - es oracle so that it chooses a schedule greedily based on bp beliefs @xmath420 $ ] similarly as the second bp oracle in the input - queued switch network .",
    "we use the same weight functions as in the input - queued switch case and our experimental results are in figure [ fig : wireless_performance ] .",
    "we again observe that the performance of our scheduling algorithm using bp - es oracle system is as good as that of the mw algorithm , although it is much simpler to code and faster to run .",
    "the problem of dynamic resource allocation among network users contending resources has long been the subject of significant research for last four decades . in this paper",
    ", we develop a generic framework for designing resource allocation algorithms of low - complexity and high - performance via connecting iterative optimization and low - complexity scheduling .",
    "our work shows sufficient conditions on queue - length functions so that a queue - based scheduling algorithms is throughput - optimal . to our best knowledge , our result is the first that establishes a rigorous connection between iterative optimization methods and low - complexity scheduling algorithms , which we believe provides various future directions and new insights in both areas .    10    l. tassiulas and a. ephremides .",
    "stability properties of constrained queueing systems and scheduling policies for maximum throughput in multihop radio networks . _ ieee transactions on automatic control _ , 37:1936 - 1948 , 1992 .",
    "l. georgiadis , m. j. neely , and l.  tassiulas .",
    "resource allocation and cross - layer control in wireless networks . _ foundations and trends in networking _ , 1:1 - 144 , 2006 .",
    "t. e. anderson , s. s. owicki , j. b. saxe , and c. p. thacker .",
    "high - speed switch scheduling for local - area networks .",
    "_ acm transactions on computer systems _ , 11(4):319 - 352 , 1993 .",
    "n. mckeown .",
    "islip : a scheduling algorithm for input - queued switches .",
    "_ ieee transaction on networking _",
    ", 7(2):188 - 201 , 1999 .    c. joo , x. lin , and n. b. shroff .",
    "understanding the capacity region of the greedy maximal scheduling algorithm in multi - hop wireless networks . _",
    "ieee infocom _ , 2008 .",
    "m. leconte , j. ni , and r. srikant .",
    "improved bounds on the throughput efficiency of greedy maximal scheduling in wireless networks . _",
    "acm mobihoc _ , 2009 .",
    "l. a. goldberg and p. d. mackenzie .",
    "analysis of practical backoff protocols for contention resolution with multiple servers .",
    "_ acm soda _ , 1996 .    p. gupta and a. l. stolyar . optimal throughput allocation in general randomaccess networks . , 2006 .    p. marbach , a. eryilmaz , and a. ozdaglar . achievable rate region of csma schedulers in wireless networks with primary interference constraints .",
    "_ ieee conference on decision and control _ , 2007 .",
    "s. rajagopalan , d. shah , and j. shin .",
    "network adiabatic theorem : an efficient randomized protocol for contention resolution . _ acm sigmetrics _ , 2009 .",
    "l. jiang , d. shah , j. shin , and j. walrand . distributed random access algorithm : scheduling and congestion control .",
    "_ ieee transactions on information theory _ ,",
    "56(12):6182 - 6207 , 2010 .",
    "d. shah and j. shin .",
    "randomized scheduling algorithm for queueing networks .",
    "_ annals of applied probability _ , 22:128 - 171 , 2012 .",
    "d. shah , d. n. c. tse , and j. n. tsitsiklis .",
    "hardness of low delay network scheduling .",
    "_ ieee transactions on information theory _ , 57(12):7810 - 7817 , 2011 .",
    "n. bouman , s. borst , and j. leeuwaarden .",
    "delays and mixing times in random - access networks .",
    "acm sigmetrics _ , 2013 .",
    "d. shah and j. shin , delay optimal queue - based csma . _",
    "acm sigmetrics performance evaluation review _",
    ", 38(1):373 - 374 , 2010 .",
    "m. lotfinezhad and p. marbach . throughput - optimal random access with order - optimal delay .",
    "_ ieee infocom _ , 2011 .",
    "l. jiang , m. leconte , j. ni , r. srikant , and j. walrand . fast mixing of parallel glauber dynamics and low - delay csma scheduling .",
    "_ ieee infocom _ , 2011",
    ".    p. k. huang and x. lin , improving the delay performance of csma algorithms : a virtual multi - channel approach .",
    "_ ieee infocom _ , 2013 .",
    "n. abramson and f. kuo ( editors ) .",
    "the aloha system . _ computer- communication networks _",
    ", 1973 .",
    "j. g. dai and b. prabhakar .",
    "the throughput of data switches with and without speedup . _ ieee infocom _ , 2000 .",
    "s. kumar , p. giaccone , and e. leonardi .",
    "rate stability of stable - marriage scheduling algorithms in input - queued switches . , 2002 .",
    "l. tassiulas .",
    "linear complexity algorithms for maximum throughput in radio networks and input queued switches .",
    "_ infocom _ , 1998 .",
    "p. giaccone , b. prabhakar , and d. shah .",
    "randomized scheduling algorithms for high - aggregate bandwidth switches .",
    "_ ieee journal on selected areas in communications high - performance electronic switches / routers for high - speed internet _ , 21(4):546 - 559 , 2003 .",
    "e. modiano , d. shah , and g. zussman .",
    "maximizing throughput in wireless network via gossiping . _",
    "acm sigmetrics _ , 2006 .",
    "a. dimakis and j. walrand .",
    "sufficient conditions for stability of longest - queue- first scheduling : second - order properties using fluid limits . _ advances in applied probability _ , 38(2):505 - 521 , 2006 .",
    "d. a. levin , y. peres , and e. l. wilmer .",
    "markov chains and mixing times . _",
    "american mathematical society _",
    ", 2008 .",
    "j. yedidia , w. freeman , and y. weiss .",
    "constructing free energy approximations and generalized belief propagation algorithms .",
    "_ ieee transactions on information theory _ ,",
    "51:2282 - 2312 , 2004 .",
    "g. cornuejols .",
    "valid inequalities for mixed integer linear programs .",
    "mathematical programming series b , 112:3 - 44 , 2008 .",
    "s. foss and t. konstantopoulos .",
    "an overview of some stochastic stability methods .",
    "_ journal of operations research , society of japan _",
    ", 47(4 ) , 2004 .    m. i. jordan .",
    "graphical models .",
    "_ statistical science _ , 19:140 - 155 , 2004 .",
    "m. bayati , d. shah , and m. sharma .",
    "max - product for maximum weight matching : convergence , correctness , and lp duality . _ ieee transactions on information theory _ , 54(3 ) : 1241 - 1251 , 2008 .",
    "s. sanghavi , d. malioutov , and a. s. willsky .",
    "linear programming analysis of loopy belief propagation for weighted matching .",
    ", 2007 .",
    "s. atalla , d. cuda , p. giaccone , m. pretti .",
    "belief - propagation assisted scheduling in input - queued switches .",
    "_ ieee 18th annual symposium on high performance interconnects ( hoti ) _ , 2010    d. shah .",
    "gossip algorithms .",
    "_ now publishers inc _ , 2009 .",
    "here , we provide the proofs of - for large enough @xmath166 . due to conditions * c2 * and * c5 * , @xmath421 which proves and .",
    "now , follows from the condition * c1 * and * c2 * : @xmath422 where we use the following property for concave function @xmath98 : @xmath423 finally , for , let @xmath424 and we observe that @xmath425 as @xmath426 due to the condition * c6*. this completes the proof of ."
  ],
  "abstract_text": [
    "<S> since tassiulas and ephremides proposed the maximum weight scheduling algorithm of throughput - optimality for constrained queueing networks in 1992 , extensive research efforts have been made for resolving its high complexity issue under various directions . in this paper , we resolve the issue by developing a generic framework for designing throughput - optimal and low - complexity scheduling algorithms . under the framework , </S>",
    "<S> an algorithm updates current schedules via an interaction with a given oracle system that can generate a solution of a certain discrete optimization problem in a finite number of interactive queries . </S>",
    "<S> therefore , one can design a variety of scheduling under this framework by choosing different oracles , e.g. , the exhaustive search ( es ) , the markov chain monte carlo ( mcmc ) , the belief propagation ( bp ) and the cutting - plane ( cp ) algorithms . the complexity of the resulting algorithm is decided by the number of operations required for an oracle processing a single query , which is typically very small . somewhat surprisingly , we prove that an algorithm using any such oracle is throughput - optimal for general constrained queueing network models that arise in the context of emerging large - scale communication networks . in particular , the ` pick - and - compare ' algorithms developed by tassiulas in 1998 and recently developed queue - based csma algorithms can be also understood as special cases of such algorithms using es and mcmc oracles , respectively . to our best knowledge </S>",
    "<S> , our result is the first that establishes a rigorous connection between iterative optimization methods and low - complexity scheduling algorithms , which we believe provides various future directions and new insights in both areas . </S>"
  ]
}