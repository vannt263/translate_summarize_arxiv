{
  "article_text": [
    "let @xmath6 be an affine weyl group , and @xmath7 be the corresponding finite weyl group .",
    "then the cosets of @xmath7 in @xmath6 , often denoted @xmath8 , have a remarkable combinatorial structure with connections to diverse structures in algebra and geometry , including affine grassmannians @xcite , characters and modular representations for the symmetric group @xcite , and crystal bases of quantum groups @xcite .",
    "combinatorially , the elements in @xmath6 can be understood as pairs from @xmath9 by the parabolic decomposition ( see e.g. ( * ? ? ? * proposition 2.4.4 ) ) .    in type @xmath5",
    ", these cosets correspond to a profoundly versatile combinatorial object known as an abacus diagram . from the abacus diagram",
    ", one can read off related combinatorial objects such as root lattice coordinates , core partitions , and the bounded partitions used in @xcite , @xcite and @xcite .",
    "the goal of the present paper is to extend the abacus model to types @xmath10 , @xmath4 , and @xmath11 , and define analogous families of combinatorial objects in these settings .",
    "some of these structures are not , strictly speaking , new .",
    "nevertheless , we believe that our development using abacus diagrams unifies much of the folklore , and we hope that it will be useful to researchers and students interested in extending results from type @xmath5 to the other affine weyl groups . in this sense ,",
    "our paper is a companion to @xcite , @xcite and @xcite .",
    "the following diagram illustrates six families of combinatorial objects that are all in bijection .",
    "each family has an action of @xmath6 , a coxeter length function , and is partially ordered by the bruhat order",
    ". we will devote one section to each of these objects and give the bijections between them using type - independent language .",
    "@xmath12 {      \\node[rectangle , draw ] ( a ) { \\parbox{1.2in}{sorted mirrored \\newline permutations of $ \\mathbb{z}$ } } ; &      \\node[rectangle , draw ] ( b ) { \\parbox{1.2in}{abacus diagrams } } ; &      \\node[rectangle , draw ] ( c ) { \\parbox{1.3in}{core partitions } } ; &      \\node[rectangle , draw ] ( d ) { \\parbox{1.2in}{bounded partitions } } ; \\\\      &      \\node[rectangle , draw ] ( e ) { \\parbox{1.2in}{root lattice points } } ; &      \\node[rectangle , draw ] ( f ) { \\parbox{1.3in}{canonical reduced expressions for minimal length coset representatives } } ; &      & \\\\      } ;      \\path[- > ]          ( a ) edge[thick ] ( b )                  ( b ) edge[thick ] ( c )          ( c ) edge[thick ] ( d )          ( b ) edge[thick ] ( e )          ( c ) edge[thick ] ( f )          ; \\end{tikzpicture}}\\ ] ] we believe that the abacus diagrams and core partitions we introduce have not appeared in this generality before .",
    "in fact , we show in theorem  [ t : core_bruhat ] that our construction answers a question of billey and mitchell ; see section  [ s : bruhat ] .",
    "several authors have used combinatorics related to bounded partitions , and we show how these objects are naturally related to abaci in section  [ s : bounded ] .",
    "we also obtain some formulas for coxeter length in section  [ s : coxeter_length_formulas ] that appear to be new . to avoid interrupting the exposition",
    ", we postpone a few of the longer arguments from earlier sections to section  [ s : proofs ] . section  [ s : future_work ] briefly suggests some ideas for further research .    in order to simplify the notation , we use a convention of overloading the definitions of our bijections . we let the output of the functions ( @xmath13 , @xmath14 , @xmath15 , @xmath16 , @xmath17 ) be the corresponding combinatorial interpretation ( @xmath18-permutation , abacus diagram , core partition , canonical reduced expression , bounded partition , respectively ) , no matter the input .",
    "for example , if @xmath19 is a bounded partition , then its corresponding abacus diagram is @xmath20 .",
    "we follow the conventions of bjrner and brenti in ( * ? ? ?",
    "* chapter 8) .",
    "fix a positive integer @xmath21 and let @xmath22 .",
    "we say that a bijection @xmath23 is a * mirrored @xmath18-permutation * if @xmath24 @xmath25 for all @xmath26 .",
    "eriksson and eriksson @xcite use these mirrored permutations to give a unified description of the finite and affine weyl groups , based on ideas from @xcite .",
    "it turns out that the collection of mirrored @xmath18-permutations forms a realization of the affine coxeter group @xmath27 , where the group operation is composition of @xmath18-permutations . since the coxeter groups @xmath28 and",
    "@xmath29 are subgroups of @xmath27 , every element in any of these groups can be represented as such a permutation .",
    "green @xcite uses the theory of full heaps to obtain this and related representations of affine weyl groups .",
    "a mirrored @xmath18-permutation @xmath30 is completely determined by its action on @xmath31 . also",
    ", equations   and imply that @xmath32 for all @xmath33 mod @xmath34 .",
    "we have coxeter generators whose images @xmath35 are given by @xmath36 @xmath37 @xmath38 @xmath39 @xmath40 and we extend each of these to an action on @xmath18 via @xmath41 and @xmath42 .",
    "observe that each of these generators interchange infinitely many entries of @xmath18 by equation  ( [ e:8.42 ] ) .",
    "[ t : bb8 ] the collection of mirrored @xmath18-permutations that satisfy the conditions in the second column of table  [ t : mzp_def ] form a realization of the corresponding affine coxeter group @xmath4 , @xmath10 , or @xmath11 .",
    "the collection of mirrored @xmath18-permutations that additionally satisfy the sorting conditions in the third column of table  [ t : mzp_def ] form a collection of minimal length coset representatives for the corresponding parabolic quotient shown in the first column of table  [ t : mzp_def ] .",
    "the corresponding coxeter graph is shown in the fourth column of table  [ t : mzp_def ] .",
    "proofs can be found in @xcite and ( * ? ? ?",
    "* section 8) .    to describe the essential data that determines an mirrored @xmath18-permutation",
    ", we observe an equivalent symmetry .",
    "@xmath18-permutation for coxeter group elements & sorting conditions for minimal length coset representatives & coxeter graph + @xmath0 &   & @xmath43 & + @xmath2 & @xmath44    ( by ( [ e:8.43 ] ) , this is equivalent to requiring the number of negative entries lying to the right of position zero is even . ) & @xmath43    ( comparing with the condition on the previous row , we see that elements of @xmath45 are elements of @xmath46 . ) & + @xmath1 & @xmath47 & @xmath48    ( comparing with the previous conditions , we see that elements of @xmath49 are _ not _ necessarily elements of @xmath46 , even though @xmath28 is a subgroup of @xmath27 . )    & + @xmath3 & @xmath44 and @xmath47    & @xmath48    ( comparing with the previous conditions , we see that elements of @xmath50 are also elements of @xmath49 . )    & +    * ( balance lemma)*[l : ol_balance ] if @xmath30 is an mirrored @xmath18-permutation , then we have @xmath51 conversely , if @xmath52 is a bijection that satisfies ( [ e:8.42 ] ) and ( [ e : local_balance ] ) , then @xmath30 is an mirrored @xmath18-permutation .",
    "equations   and imply that for all @xmath26 , @xmath53 ; in particular , this is true for @xmath54 .    to prove the converse , we must show that an infinite permutation @xmath23 satisfying and satisfies .",
    "equation   implies @xmath55 for any @xmath56 and @xmath57 . by",
    ", we have @xmath58 so @xmath59 as was to be shown .    given a mirrored @xmath18-permutation , we call the ordered sequence @xmath60 $ ] the * base window * of @xmath30 . since the set of mirrored @xmath18-permutations acts on itself by composition of functions , we have an action of @xmath6 on the base window notation .",
    "the left action interchanges values while the right action interchanges positions .",
    "we have labeled the node of the coxeter graph of @xmath6 that is added to the coxeter graph of @xmath7 by @xmath61 .",
    "then , our cosets have the form @xmath62 ( where @xmath63 ) , and the minimal length coset representatives all have @xmath61 as a unique right descent .    we can characterize the base windows that arise .    [",
    "l : olwd ] an ordered collection @xmath64 $ ] of integers is the base window for an element of @xmath27 if and only if    * @xmath65 have distinct residue mod @xmath34 , * @xmath65 are not equivalent to @xmath66 mod @xmath34 , and * @xmath67 for each @xmath68",
    ".    given such a collection of integers , extend @xmath69 $ ] to a @xmath18-permutation @xmath30 using , and set @xmath70 for all @xmath71 .",
    "the third condition on @xmath72 $ ] ensures that @xmath30 is a mirrored @xmath18-permutation by the balance lemma  [ l : ol_balance ] .    on the other hand ,",
    "each of the three conditions is preserved when we apply a coxeter generator @xmath73 , so each element of @xmath27 satisfies these conditions by induction on coxeter length .    with the conventions we have adopted in table  [ t : mzp_def ]",
    ", we can also prove that no two minimal length coset representatives contain the same entries in their base window .",
    "[ l : bdoldet ] suppose @xmath74 is a collection of integers such that each @xmath75 is equivalent to @xmath76 mod @xmath34 .",
    "then , there exists a unique element @xmath77 that contains @xmath74 among the entries of its base window @xmath78 .",
    "it follows from the balance lemma  [ l : ol_balance ] that whenever @xmath75 appears among the entries of the base window of @xmath79 , then @xmath80 also appears among the entries of the base window of @xmath30 .",
    "hence , the entries of the base window @xmath81 are completely determined by the @xmath75 .    for @xmath30 to be a minimal length coset representative , we must order these entries to satisfy the condition shown in the third column of table  [ t : mzp_def ] while maintaining the condition shown in the second column of table  [ t : mzp_def ] .",
    "let @xmath82 denote the entries @xmath81 of the base window arranged into increasing order so @xmath83 .    by the condition shown in the third column of table  [ t : mzp_def ] and , we have that @xmath84 is the only possible descent among the entries of the base window of @xmath30 , so we have that @xmath85 .",
    "also , since @xmath86 , we have @xmath87 which implies @xmath88 by .",
    "since @xmath89 forms an increasing subsequence of length @xmath90 , we have @xmath91 and @xmath92 . putting these together ,",
    "we find @xmath93 thus , @xmath94 must be @xmath95 or @xmath96 .",
    "therefore , the entries of the base window of @xmath97 are either @xmath98 or @xmath99 . since @xmath100 , precisely one of these satisfies the condition shown in the second column of table  [ t : mzp_def ] .",
    "[ c : unbw ] suppose @xmath101 . if @xmath102 then @xmath103 as unordered sets .",
    "this follows from the observation that the sorting conditions completely determine the ordering of elements in the base window . considering the third column of table  [ t : mzp_def ] , this is clear for @xmath0 and @xmath2 . by lemma  [ l : bdoldet ]",
    ", we see that this holds for @xmath1 as well . since @xmath104 , it holds for @xmath3 .",
    "we now combinatorialize the set of integers that can appear in the base window of a mirrored @xmath18-permutation as an abacus diagram . these diagrams",
    "enforce precisely the conditions from lemma  [ l : olwd ] .    an * abacus diagram * ( or simply * abacus * ) is a diagram containing @xmath105 columns labeled @xmath106 , called * runners*. runner @xmath76 contains entries labeled by the integers @xmath107 for each * level * @xmath108 where @xmath109 .",
    "we draw the abacus so that each runner is vertical , oriented with @xmath110 at the top and @xmath111 at the bottom , with runner @xmath112 in the leftmost position , increasing to runner @xmath105 in the rightmost position .",
    "entries in the abacus diagram may be circled ; such circled elements are called * beads*. entries that are not circled are called * gaps*. the linear ordering of the entries given by the labels @xmath107 ( for level @xmath113 and runner @xmath114 ) is called the * reading order * of the abacus which corresponds to scanning left to right , top to bottom .",
    "( observe that there are no entries in the abacus having labels @xmath115 . )",
    "we say that a bead @xmath116 is * active * if there exist gaps ( on any runner ) that occur prior to @xmath116 in reading order .",
    "otherwise , we say that the bead is * inactive*. a runner is called * flush * if no bead on the runner is preceded in reading order by a gap on that same runner .",
    "we say that an abacus is * flush * if every runner is flush .",
    "we say that an abacus is * balanced * if    * there is at least one bead on every runner @xmath76 for @xmath117 , and * the sum of the labels of the lowest beads on runners @xmath76 and @xmath118 is @xmath34 for all @xmath119 .",
    "we say that an abacus is * even * if there exists an even number of gaps preceding @xmath34 in reading order .",
    "[ def : abacus ] given a mirrored @xmath18-permutation @xmath30 , we define @xmath120 to be the flush abacus whose lowest bead in each runner is an element of @xmath121 .    note that this is well - defined by lemma  [ l : olwd ] .",
    "also , @xmath120 is always balanced by lemma  [ l : ol_balance ] , so the level of the lowest bead on runner @xmath76 is the negative of the level of the lowest bead on runner @xmath118 . in the rest of the paper , we will implicitly assume that all abaci are balanced and flush unless otherwise noted .    for the minimal length coset representative @xmath122 whose base window is + @xmath123 $ ] , the balanced flush abacus @xmath124 is given in figure  [ fig : abacus ] .",
    "[ example ]    we record some structural facts about balanced flush abaci to be used later .    [ l : ab_balance ] for each @xmath71 , we have that entry @xmath125 is a gap if and only if entry @xmath118 is a bead .",
    "this follows from the definition together with the balance lemma  [ l : ol_balance ] .",
    "[ l : balance_up_low ] fix an abacus @xmath126 and consider a single row @xmath127 of @xmath126 .",
    "if there exists @xmath76 such that the entries in columns @xmath76 and @xmath118 are both beads , then the level of row @xmath127 is @xmath128 .",
    "similarly , if there exists @xmath76 such that the entries in columns @xmath76 and @xmath118 are both gaps , then the level of row @xmath127 is @xmath129 . in particular",
    ", we can not have both of these conditions holding at the same time for a given row of @xmath126 .",
    "this follows from the balance lemma  [ l : ol_balance ] .",
    ".abaci for @xmath8 [ cols=\"<,<\",options=\"header \" , ]",
    "if we sum contributions to the coxeter length from beads in the same runners in proposition  [ p : boundedfromabacus ] , we obtain the following formula for the coxeter length of a minimal length coset representative defined by way of an abacus .    [",
    "p : e_cox ] let @xmath126 be the abacus corresponding to a minimal length coset representative @xmath130 . for @xmath54",
    ", choose the lowest bead @xmath131 occurring in either runner @xmath76 or @xmath118 , and the bead @xmath132 occurring in @xmath131 s runner .",
    "let @xmath133 be the number of gaps between @xmath131 and @xmath134 in @xmath126",
    ". then @xmath135    in our example of @xmath136\\in{\\widetilde}{c}_3/c_3 $ ] with abacus @xmath124 in figure  [ fig : abacus ] , we create a part of the bounded partition @xmath137 for each bead in @xmath126 greater than @xmath138 .",
    "the beads in question are @xmath139 , @xmath140 , @xmath141 , @xmath142 , and @xmath143 .",
    "the first three beads are greater than @xmath144 , so we count the number of gaps between @xmath116 and @xmath145 and add one , giving @xmath146 , @xmath146 , and @xmath147 .",
    "the last two beads are between @xmath143 and @xmath148 , so we take @xmath145 , giving @xmath149 and @xmath112 .",
    "this agrees with the previously found @xmath150 . in the terminology of corollary  [ p : e_cox ] , @xmath151 , @xmath152 , @xmath153 , @xmath154 , and @xmath155 .",
    "we then calculate @xmath156 , @xmath157 , @xmath158 and see that @xmath159 , agreeing with the number of generators in @xmath160 found in example  [ ex : peeling ] .    given a core partition @xmath161 , theorem  [ t : upperfromlam ] gives a simple method to find",
    "the corresponding bounded partition , from which its coxeter length can be read directly .",
    "it is possible to determine the coxeter length of the corresponding minimal length coset representative in another way , analogous to the method given in type @xmath162 in proposition 3.2.8 in @xcite by translating proposition  [ p : e_cox ] into the language of core partitions .",
    "if we fill in the boxes of a core along the diagonals with the numbers @xmath112 through @xmath105 instead of the residues , the number at the end of each row corresponds to the runner number of the bead in the abacus which corresponds to that row .",
    "this filling allows us to visualize which rows of @xmath161 correspond to beads in the same runner .",
    "involved in the statement of the proposition below is the determination of the rows @xmath163 and @xmath164 of @xmath161 that correspond to the beads @xmath131 and @xmath134 .",
    "[ p : core_length ] let @xmath165 be a symmetric @xmath166-core partition . if all parts of @xmath161 are less than or equal to @xmath21 , then @xmath167    otherwise , define @xmath163 to be the longest row of @xmath161 to have runner number @xmath76 or @xmath118 labeling its rightmost box . then follow the boundary of @xmath161 extended @xmath21 steps out in each direction from its center , a path which will involve @xmath21 vertical steps and @xmath21 horizontal steps . define @xmath164 to be the unique row of @xmath161 ending with one of the @xmath21 vertical steps and whose rightmost box is labeled by the same choice of @xmath76 or @xmath118 as for @xmath163 . define @xmath168 to be the number of rows of @xmath161 whose box on the main diagonal has hook length greater than @xmath105 .",
    "then , @xmath169    in a core of the first type , all boxes are skew .",
    "the sum counts the number of boxes in the bounded partition , because the number of boxes between the diagonal and @xmath170 inclusive is @xmath171 .    in a core of the second type",
    ", there exists a box in @xmath161 with hook length at least @xmath105 .",
    "hence the boundary of @xmath161 extends more than @xmath21 steps out in each direction from its center , and @xmath164 is well defined since in the abacus @xmath172 , bead @xmath134 exists between @xmath173 and @xmath174 on runner @xmath175 , the runner number of row @xmath163 .",
    "the first two terms in the formula translate directly from proposition  [ p : e_cox ] and correspond to contributions from beads @xmath176 .",
    "beads @xmath177 correspond to rows of @xmath161 starting with row @xmath178 ; again the number of boxes between the diagonal and @xmath170 inclusive is @xmath171 .    consider the core @xmath179 , pictured in figure  [ fig : compact ] with runner numbers .",
    "this partition has parts of size larger than @xmath180 , so we apply the second half of proposition  [ p : core_length ] .",
    "the runners corresponding to @xmath181 , @xmath149 , and @xmath180 are have runner numbers @xmath182 , @xmath146 , and @xmath180 .",
    "consequently , @xmath183 , @xmath184 , @xmath185 , @xmath186 , @xmath187 , @xmath188 , and @xmath189 .",
    "we conclude that @xmath190 .",
    "another formula for coxeter length can be obtained summing contributions from the longest rows in @xmath191 ending with a given runner number , and then subtracting terms to account for boxes that are counted twice in the peeling process .",
    "this gives a second analogue of proposition 3.2.8 in @xcite .",
    "let @xmath192 be a symmetric @xmath166-core .",
    "let @xmath193 be the lowest box on the main diagonal of @xmath192 .",
    "for @xmath194 , let @xmath163 be index of the longest row @xmath195 of @xmath192 having rightmost box from runner @xmath76 or @xmath118 .",
    "the * rim * of @xmath192 consists of the boxes from @xmath192 that have no box lying directly to the southeast .",
    "we define the * rim walk * @xmath196 from the rightmost box @xmath197 of @xmath195 to be the collection of boxes encountered when walking along the rim of @xmath192 from @xmath197 towards @xmath193 , ending at the last box encountered from runner @xmath198 prior to @xmath193 .",
    "we let @xmath199 denote the * height * of @xmath196 , defined to be the number of rows of @xmath192 that intersect @xmath196 and end in a box having a runner number that is different from the last box of @xmath195 .",
    "let @xmath192 be a symmetric @xmath166-core .",
    "the coxeter length of @xmath200 is @xmath201 where @xmath202 is the number of boxes on the @xmath76-th diagonal of @xmath192 .    by theorem  [ t : upperfromlam ]",
    ", the coxeter length is equal to the number of boxes in the bounded diagram @xmath203 of @xmath192 .",
    "there is one row in @xmath203 for each bead in @xmath204 succeeding @xmath34 in reading order , and the number of boxes on each row in @xmath203 is the number of skew boxes in the row , together with entries from the @xmath66-th and @xmath21-th diagonals , depending on the coxeter type .",
    "we claim that the number of skew boxes from all rows ending with a box from runner @xmath76 is equal to @xmath205 . depending on the coxeter type",
    ", we will also subtract boxes corresponding to @xmath206 and @xmath207 in the last step of the construction of @xmath203 .    to see why the claim is true ,",
    "consider the last bead @xmath116 in reading order lying on runner @xmath76 .",
    "this bead has @xmath208 gaps lying weakly between @xmath209 and @xmath116 .",
    "each gap lying between @xmath34 and @xmath116 corresponds to a skew box for precisely one bead lying on runner @xmath76 to the right of @xmath34 in reading order .",
    "since @xmath125 is the earliest bead on runner @xmath76 in reading order that corresponds to a row lying above the main diagonal , we must therefore subtract the gaps prior to position @xmath210 that are not of the form @xmath211 for any bead @xmath212 on runner @xmath76 .",
    "by lemma  [ l : ab_balance ] , such gaps correspond to beads lying between @xmath198 and @xmath116 that do not lie on runner @xmath76 .",
    "this quantity is equal to the height of our rim walk beginning at the last box of row @xmath163 , which corresponds to @xmath197 .    including contributions for each runner",
    "@xmath76 yields the sum given in the formula .",
    "consider the core @xmath179 , pictured in figure  [ fig : compact ] with runner numbers .",
    "we have @xmath213 , @xmath214 and @xmath215 .",
    "the rim walk from the last box @xmath197 of @xmath216 consists of all @xmath217 boxes on the rim lying between @xmath197 and @xmath193 , and there are @xmath180 rows ( namely , @xmath149 , @xmath147 , and @xmath146 ) that do not end in runner @xmath182 .",
    "hence , @xmath218 .",
    "the rim walk from the last box @xmath219 of @xmath220 consists of the @xmath148 boxes on the rim lying between @xmath219 and the box immediately right of @xmath193 .",
    "there are @xmath149 rows ( namely , @xmath180 and @xmath146 ) that do not end in runner @xmath146 , so @xmath221 .",
    "the rim walk from the last box @xmath222 of @xmath223 consists of the single box @xmath222 because there are no other boxes from runner @xmath180 lying on the rim between @xmath222 and @xmath193 .",
    "hence , @xmath224 .",
    "thus , we compute @xmath225 as @xmath226 @xmath227",
    "we now turn to the proof of theorem  [ t : core_action ] .    _ [ of theorem  [ t : core_action ] ]  _ given @xmath228 , suppose that @xmath229 and @xmath230 .",
    "let the residues be assigned to entries of @xmath231 near the southeast boundary of the diagram of @xmath192 as in definition  [ d : residue ] .",
    "consider the application of a generator @xmath73 .    by lemma  [ l : ab_balance ]",
    ", the midpoint of the boundary lattice path of @xmath192 occurs at entry @xmath34 in the abacus , and this corresponds to the outermost corner of the lowest box on the main diagonal in @xmath192 . in every type , the boxes on the main diagonal are assigned residue 0 .    because the assignment of fixed residues is constant along northwest - southeast diagonals ,",
    "the assignment of fixed residue to entry @xmath232 is the same as the assignment of fixed residue to entry @xmath233 whenever @xmath234 and @xmath235 . from this",
    "it follows that every bead on a given runner is assigned the same fixed residue .",
    "moreover , we find that all of the beads in runner @xmath236 correspond to boxes with residue @xmath237    we observe that the connected components of boxes with fixed residue are always single boxes .",
    "a box with fixed residue @xmath76 is removable if and only if it lies at the end of its row and column , which therefore occurs if and only if it corresponds to an active bead on runner @xmath238 or @xmath239 with a gap immediately preceding it in the reading order of the abacus .",
    "similarly , a box with fixed residue @xmath76 is addable if and only if it corresponds to a gap on runner @xmath238 or @xmath239 with an active bead immediately preceding it in the reading order of the abacus . the action of @xmath73 in type @xmath27 swaps runners @xmath76 and @xmath238 as well as @xmath240 and @xmath239 which therefore interchanges all of the @xmath76-addable and @xmath76-removable boxes .",
    "since the abacus is flush , exchanging runners @xmath76 with @xmath238 and @xmath240 with @xmath239 ( mod @xmath34 ) either adds some set of boxes with residue @xmath76 to the diagram of @xmath192 in the case that @xmath73 is an ascent , or else removes a set of boxes with residue @xmath76 in the case that @xmath73 is a descent . if @xmath73 is neither an ascent nor a descent then the levels of the lowest beads in the relevant columns are the same , so the abacus and corresponding core remain unchanged .",
    "this proves the result in the case when @xmath73 ( @xmath241 ) is a generator of type @xmath4 .",
    "the generators @xmath242 and @xmath243 apply to entries in an escalator , which we consider below .",
    "the generators @xmath244 and @xmath245 apply to entries in an descalator , and the argument is entirely similar so we omit it .    to verify the result for @xmath242 and @xmath243 , we consider the action of these generators on all possible abaci .",
    "it suffices to consider the action on a single row of the abacus since this translates into a connected segment of the lattice path boundary of the core partition .",
    "using the results for type @xmath4 generators that we have already shown above , we observe that the lattice path always begins on the boundary of a box with residue @xmath246 by induction .",
    "* case : * the abacus row contains a single bead among the positions @xmath247 .",
    "then , the abaci satisfy the following commutative diagram .",
    "@xmath248    we translate these entries of the abaci into a segment of the boundary lattice path .",
    "observe that lemma  [ l : balance_up_low ] implies that we are above the main diagonal , so we assign residues to boxes in the upper escalator horizontally . then , it is straightforward to verify that the action of @xmath249 does add ( or remove ) all addable ( removable , respectively ) components with residue @xmath76 , for @xmath250 , as shown below .",
    "@xmath251 { $ n-2 $ } ; \\draw ( 1.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ { \\genfrac{}{}{0pt}{}{(n-1)}{n}}$ } ; \\draw ( 3.0cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 4.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { } ; \\draw [ line width=3pt ] ( 1.5cm,0 ) node ( test1 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test2 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test3 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test4 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test5 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { } ; \\end{tikzpicture } }   & \\raisebox{.2cm}{$\\stackrel{s_n^d}{\\longrightarrow}$ } & \\myscalebox{0.5}{\\begin{tikzpicture } \\draw ( 0,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw",
    "( 1.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 3.0cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 4.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n-1 $ } ; \\draw [ line width=3pt ] ( 1.5cm,0 ) node ( test1 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test2 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test3 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test4 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test5 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { } ; \\end{tikzpicture } }   \\\\ $ \\downarrow^{s_{n-1}}$ & & $ \\downarrow^{s_{n-1}}$ \\\\ \\myscalebox{0.5}{\\begin{tikzpicture } \\draw ( 0,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw ( 1.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n-1 $ } ; \\draw ( 3.0cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 4.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw [ line width=3pt ] ( 1.5cm,0 ) node ( test1 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test2 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test3 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test4 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test5 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { } ; \\end{tikzpicture } }   & \\raisebox{.2cm}{$\\stackrel{s_n^d}{\\longrightarrow}$ } & \\myscalebox{0.5}{\\begin{tikzpicture } \\draw ( 0,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw ( 1.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { } ; \\draw ( 3.0cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 4.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ { \\genfrac{}{}{0pt}{}{(n-1)}{n}}$ } ; \\draw [ line width=3pt ] ( 1.5cm,0 ) node ( test1 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test2 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test3 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test4 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test5 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { } ; \\end{tikzpicture } }   \\\\ \\end{tabular}\\ ] ]    * case : * the abacus row contains a single gap among the positions @xmath247 .",
    "then , the abaci satisfy the following commutative diagram .",
    "@xmath252    we translate these entries of the abaci into a segment of the boundary lattice path .",
    "observe that lemma  [ l : balance_up_low ] implies that we are below the main diagonal , so we assign residues to boxes in the lower escalator vertically .",
    "then , it is straightforward to verify that the action of @xmath249 does add ( or remove ) all addable ( removable , respectively ) components with residue @xmath76 , for @xmath250 , as shown below .",
    "@xmath251 { $ n-2 $ } ; \\draw ( 0,1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { } ; \\draw ( 0,3.0 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { } ; \\draw ( 0,4.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { } ; \\draw ( 1.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { } ; \\draw ( 1.5cm,1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 1.5cm,3.0 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ { \\genfrac{}{}{0pt}{}{(n-1)}{n}}$ } ; \\draw ( 1.5cm,4.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw [ line width=3pt ] ( 1.5cm,0 ) node ( test1 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test2 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test3 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test4 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test5 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { } ; \\end{tikzpicture } }   & \\raisebox{1.5cm}{$\\stackrel{s_n^d}{\\longrightarrow}$ } & \\myscalebox{0.5}{\\begin{tikzpicture } \\draw ( 0,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw ( 0,1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { } ; \\draw ( 0,3.0 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { } ; \\draw ( 0,4.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { } ; \\draw ( 1.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n-1 $ } ; \\draw ( 1.5cm,1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 1.5cm,3.0 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 1.5cm,4.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw [ line width=3pt ] ( 1.5cm,0 ) node ( test1 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test2 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test3 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test4 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test5 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { } ; \\end{tikzpicture } }   \\\\ $ \\downarrow^{s_{n-1}}$ & & $ \\downarrow^{s_{n-1}}$ \\\\ \\myscalebox{0.5}{\\begin{tikzpicture } \\draw ( 0,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw ( 0,1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { } ; \\draw ( 0,3.0 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { } ; \\draw ( 0,4.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { } ; \\draw ( 1.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 1.5cm,1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 1.5cm,3.0 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n-1 $ } ; \\draw ( 1.5cm,4.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw [ line width=3pt ] ( 1.5cm,0 ) node ( test1 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test2 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test3 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test4 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test5 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { } ; \\end{tikzpicture } }   & \\raisebox{1.5cm}{$\\stackrel{s_n^d}{\\longrightarrow}$ } & \\myscalebox{0.5}{\\begin{tikzpicture } \\draw ( 0,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw ( 0,1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { } ; \\draw ( 0,3.0 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { } ; \\draw ( 0,4.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { } ; \\draw ( 1.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ { \\genfrac{}{}{0pt}{}{(n-1)}{n}}$ } ; \\draw ( 1.5cm,1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 1.5cm,3.0 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { } ; \\draw ( 1.5cm,4.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw [ line width=3pt ] ( 1.5cm,0 ) node ( test1 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test2 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test3 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test4 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test5 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { } ; \\end{tikzpicture } }   \\\\ \\end{tabular}\\ ] ]    * case : * the abacus row contains two beads in one of the configurations shown below .    @xmath253    we translate these entries of the abaci into a segment of the boundary lattice path .",
    "if we are above the main diagonal , then we assign residues to the boxes in the upper escalator horizontally , as shown below .",
    "@xmath254 { $ n-1 $ } ; \\draw ( 1.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 3.0cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 4.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west ] { $ n-2 $ } ; \\draw ( 0,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw ( 1.5cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ { \\genfrac{}{}{0pt}{}{(n-1)}{n}}$ } ; \\draw ( 3.0cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 4.5cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { } ; \\draw [ line width=3pt ] ( 1.5cm,-1.5 cm ) node ( test1 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test2 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test3 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test4 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test5 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { } ; \\end{tikzpicture } }   & \\raisebox{0.75cm}{$\\stackrel{s_n^d}{\\longrightarrow}$ } & \\myscalebox{0.5}{\\begin{tikzpicture } \\draw ( 0,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { } ; \\draw ( 1.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 3.0cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ { \\genfrac{}{}{0pt}{}{(n-1)}{n}}$ } ; \\draw ( 4.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west ] { $ n-2 $ } ; \\draw ( 0,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw ( 1.5cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 3.0cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 4.5cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { } ; \\draw [ line width=3pt ] ( 1.5cm,-1.5 cm ) node ( test1 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test2 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test3 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test4 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test5 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { } ; \\end{tikzpicture } }   \\\\ \\end{tabular}\\ ] ]    if we are below the main diagonal , then we assign residues to the boxes in the lower escalator vertically , as shown below .",
    "@xmath254 { $ { \\genfrac{}{}{0pt}{}{(n-1)}{n}}$ } ; \\draw ( 1.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 3.0cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ { \\genfrac{}{}{0pt}{}{(n-1)}{n}}$ } ; \\draw ( 4.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west ] { $ n-2 $ } ; \\draw ( 0,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw ( 1.5cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 3.0cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 4.5cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { } ; \\draw [ line width=3pt ] ( 1.5cm,-1.5 cm ) node ( test1 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test2 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test3 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test4 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test5 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { } ; \\end{tikzpicture } }   & \\raisebox{0.75cm}{$\\stackrel{s_n^d}{\\longrightarrow}$ } & \\myscalebox{0.5}{\\begin{tikzpicture } \\draw ( 0,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ { \\genfrac{}{}{0pt}{}{(n-1)}{n}}$ } ; \\draw ( 1.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 3.0cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 4.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west ] { $ n-2 $ } ; \\draw ( 0,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw ( 1.5cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ { \\genfrac{}{}{0pt}{}{(n-1)}{n}}$ } ; \\draw ( 3.0cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 4.5cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { } ; \\draw [ line width=3pt ] ( 1.5cm,-1.5 cm ) node ( test1 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test2 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test3 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test4 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test5 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { } ; \\end{tikzpicture } }   \\\\ \\end{tabular}\\ ] ]    in each subcase , it is straightforward to verify that the action of @xmath249 does add ( or remove ) all addable ( removable , respectively ) components with residue @xmath76 , for @xmath250 .",
    "* case : * the abacus row contains two beads in one of the configurations shown below .    @xmath255    we translate these entries of the abaci into a segment of the boundary lattice path .",
    "if we are above the main diagonal , then we assign residues to the boxes in the upper escalator horizontally , as shown below .",
    "@xmath254 { $ n$ } ; \\draw ( 1.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 3.0cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n-1 $ } ; \\draw ( 4.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west ] { $ n-2 $ } ; \\draw ( 0,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw ( 1.5cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ { \\genfrac{}{}{0pt}{}{(n-1)}{n}}$ } ; \\draw ( 3.0cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 4.5cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { } ; \\draw [ line width=3pt ] ( 1.5cm,-1.5 cm ) node ( test1 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test2 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test3 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test4 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test5 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { } ; \\end{tikzpicture } }   & \\raisebox{0.75cm}{$\\stackrel{s_{n-1}}{\\longrightarrow}$ } & \\myscalebox{0.5}{\\begin{tikzpicture } \\draw ( 0,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { } ; \\draw ( 1.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 3.0cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ { \\genfrac{}{}{0pt}{}{(n-1)}{n}}$ } ; \\draw ( 4.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west ] { $ n-2 $ } ; \\draw ( 0,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw ( 1.5cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n-1 $ } ; \\draw ( 3.0cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 4.5cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw [ line width=3pt ] ( 1.5cm,-1.5 cm ) node ( test1 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test2 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test3 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test4 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test5 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { } ; \\end{tikzpicture } }   \\\\ \\end{tabular}\\ ] ]    if we are below the main diagonal , then we assign residues to the boxes in the lower escalator vertically , as shown below .",
    "@xmath254 { $ { \\genfrac{}{}{0pt}{}{(n-1)}{n}}$ } ; \\draw ( 1.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 3.0cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ { \\genfrac{}{}{0pt}{}{(n-1)}{n}}$ } ; \\draw ( 4.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west ] { $ n-2 $ } ; \\draw ( 0,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw ( 1.5cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n-1 $ } ; \\draw ( 3.0cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 4.5cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { } ; \\draw [ line width=3pt ] ( 1.5cm,-1.5 cm ) node ( test1 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test2 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test3 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test4 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test5 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { } ; \\end{tikzpicture } }   & \\raisebox{0.75cm}{$\\stackrel{s_{n-1}}{\\longrightarrow}$ } & \\myscalebox{0.5}{\\begin{tikzpicture } \\draw ( 0,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ { \\genfrac{}{}{0pt}{}{(n-1)}{n}}$ } ; \\draw ( 1.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 3.0cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ n-1 $ } ; \\draw ( 4.5cm,0 ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west ] { $ n-2 $ } ; \\draw ( 0,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west ] { $ n-2 $ } ; \\draw ( 1.5cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , draw , anchor = south west , fill = gray!20 ] { $ { \\genfrac{}{}{0pt}{}{(n-1)}{n}}$ } ; \\draw ( 3.0cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { $ n$ } ; \\draw ( 4.5cm,-1.5 cm ) node [ rectangle , minimum size=1.5 cm , inner sep=0pt , anchor = south west , fill = gray!20 ] { } ; \\draw [ line width=3pt ] ( 1.5cm,-1.5 cm ) node ( test1 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test2 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test3 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 0:1.5 cm )   node ( test4 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { }   -- + + ( 90:1.5 cm )   node ( test5 ) [ circle , fill = black , inner sep=0pt , minimum size=2pt , draw ] { } ; \\end{tikzpicture } }   \\\\ \\end{tabular}\\ ] ]    in each subcase , it is straightforward to verify that the action of @xmath249 does add ( or remove ) all addable ( removable , respectively ) components with residue @xmath76 , for @xmath250 .",
    "* case : * the abacus positions @xmath247 are all beads or all gaps .    in this case ,",
    "both @xmath242 and @xmath243 fix the boundary lattice path segment .",
    "it is straightforward to see that the corresponding core partitions have no addable nor removable @xmath76-boxes for @xmath250 .",
    "observe that lemma  [ l : balance_up_low ] prohibits abaci in either of the configurations shown below .",
    "@xmath256    this exhausts the cases .",
    "we now turn to the proof of theorem  [ t : upperfromlam ] .    _",
    "[ of theorem  [ t : upperfromlam ] ]  _ fix a core partition @xmath192 and its associated abacus @xmath257 . recall that a box in @xmath192 having hook length @xmath258 is called * skew*. define the bounded diagram @xmath203 as in section  [ s : bounded_diagram ] .",
    "we say that a box of @xmath192 lying in the bounded diagram @xmath259 is * bounded*. we will prove that the bounded boxes are the boxes peeled in the central peeling procedure .    to prove theorem  [ t : upperfromlam ] , we work by induction on coxeter length , investigating the application of one step of the central peeling process . for the remainder of this proof , let @xmath197 be the rightmost box in the row @xmath127 of @xmath161 containing the lowest box on the reference diagonal , @xmath116 be its corresponding active bead in @xmath260 , and let @xmath76 be the residue of @xmath197 . when we apply @xmath73 to remove @xmath197",
    ", we claim that :    * @xmath197 is bounded . *",
    "we remove no other bounded box . *",
    "if a box @xmath219 was bounded in @xmath192 , then @xmath219 is also bounded in @xmath261 .",
    "proving these claims complete the proof of theorem  [ t : upperfromlam ] because they show that during the central peeling procedure the bounded boxes of @xmath161 remain bounded boxes in intermediary steps and that exactly one bounded box of @xmath262 is peeled in each step .    in terms of the abacus",
    ", @xmath116 is essentially the first bead succeeding @xmath34 in reading order .",
    "however , if we are in a type that uses @xmath245 then there may be a bead in position @xmath263 that can not be moved to the left because position @xmath264 is a gap . in this case",
    ", @xmath116 is the next bead in reading order after @xmath263 . in all cases , @xmath265 by the balance lemma  [ l : ol_balance ] .",
    "we first prove ( 1 ) using the definition of @xmath166-core . when we are in a type that uses @xmath266 , then @xmath127 is the row containing the lowest box on the main diagonal .",
    "all boxes in row @xmath127 starting from the first diagonal to @xmath197 all have hook length less than @xmath105 , so they are all skew and consequently bounded as well , including @xmath197 . when we are in a type that uses @xmath245 , then @xmath127 is the row containing the lowest box on the first diagonal .",
    "all boxes in row @xmath127 starting from the first diagonal to @xmath197 all have hook length less than or equal to @xmath105 ; equality occurs only when @xmath127 has a box in the @xmath105-th diagonal and row @xmath267 has a box on the main diagonal .",
    "the skew boxes in @xmath127 are therefore all boxes between the second and @xmath105-th diagonal ; this implies that the bounded boxes in @xmath127 are all boxes between the main and @xmath268-st diagonal , this last box being @xmath197 by definition  [ def : cpp ] .    to prove ( 2 ) , consider some box @xmath219 that is removed when applying @xmath73 .",
    "we will show that there are non - skew boxes in the row containing @xmath219 which imply that @xmath219 is not bounded .",
    "define @xmath269 to be the lowest box on the @xmath127-th column .",
    "this is the reflection of @xmath197 by the main diagonal and in the abacus this column corresponds to the symmetric gap @xmath209 .",
    "suppose that we apply generator @xmath73 for @xmath270 or @xmath271 .",
    "we note that both @xmath269 and @xmath219 have residue @xmath76 and are in non - consecutive diagonals containing this residue .",
    "therefore the box that is at the same time above @xmath269 and to the left of @xmath219 has hook length at least @xmath105 and is therefore not skew .",
    "when we apply the generator @xmath266 , the box @xmath197 is on the main diagonal and the box @xmath219 is on the @xmath236-th diagonal for @xmath272 .",
    "therefore the box that is at the same time above @xmath197 and to the left of @xmath219 has hook length at least @xmath105 and is therefore not skew .",
    "when we apply the generator @xmath245 , we remove two boxes in @xmath219 s row ; we prove the existence of the two required gaps . in this case , @xmath197 is on the first diagonal , with a box directly below , a box to the left , and the box @xmath269 to the lower - left , all four of which are removed when @xmath245 is applied .",
    "the two boxes to the left of @xmath219 that are above @xmath197 and @xmath269 both have hook length at least @xmath105 .",
    "when we apply the generator @xmath243 , we also remove two boxes in @xmath219 s row . if @xmath219 is on the @xmath236-th diagonal where @xmath273 , then the box above @xmath269 and to the left of @xmath219 has hook length at least @xmath105 , as does its right neighbor .",
    "the last case is that @xmath219 is in diagonal @xmath173 while @xmath197 is in diagonal @xmath274 . in this case ,",
    "@xmath197 and @xmath219 are in the same block of four boxes which are removed upon the application of @xmath243 .",
    "there are @xmath21 bounded boxes in @xmath219 s row , not including @xmath219 .",
    "this exhausts the cases .    to prove ( 3 ) ,",
    "we show that the number of skew boxes on each row of @xmath192 above @xmath197 is equal to the number of skew boxes on each row of @xmath261 above @xmath197 . left - justifying these skew boxes to the main diagonal then gives the same bounded region .",
    "we consider first generators @xmath73 where @xmath270 and @xmath275 .",
    "let @xmath212 be a bead lying to the right of @xmath116 in reading order .",
    "if @xmath276 , then all boxes between the main diagonal and @xmath219 are skew .",
    "no boxes in this row are removed upon application of @xmath73 because the residue of @xmath219 is different from the residue of @xmath197 . if @xmath277 , then the number of skew boxes is the number of gaps between @xmath212 and @xmath278 . if the action of @xmath73 fixes runner @xmath279 , then the number of gaps between @xmath212 and @xmath278 does not change .",
    "otherwise @xmath212 is on runner @xmath280 or runner @xmath281 . if @xmath212 is on runner @xmath280 , then since @xmath282 is a gap , then so is @xmath283 .",
    "if @xmath212 is on runner @xmath281 , then we notice that because @xmath116 is a bead then @xmath284 is a gap , and consequently so is @xmath283 . in both cases ,",
    "if we restrict our attention to the entries between @xmath212 and @xmath278 , we see that in the application of @xmath73 , we lose a gap in position @xmath285 but gain a gap in position @xmath286 , so there is no net change .    in the case of @xmath266 , both @xmath212 and @xmath116",
    "are on runner @xmath112 , so because @xmath287 is a gap , so is @xmath288 , and we see that in the application of @xmath266 , we lose a gap in position @xmath289 but gain a gap in position @xmath290 .    if @xmath212 is involved in a transposition under @xmath245 , then there are two cases .",
    "either @xmath116 is in position @xmath264 or @xmath116 is in position @xmath291 . in the former case , there is a bead in position @xmath263 , and there is a gaps in positions @xmath90 and @xmath105 .",
    "consequently , @xmath212 is in either runner @xmath112 or @xmath149 , and there are gaps @xmath292 and @xmath293 to the left of @xmath212 on runners @xmath90 and @xmath105 , as well as on the level below .",
    "when we apply @xmath245 , we therefore lose the gaps in runners @xmath90 and @xmath105 , but then gain them back in runners @xmath112 and @xmath149 . in the latter case ,",
    "the only beads lower than @xmath34 are in runner @xmath112 , and there is a gap in position @xmath105 . consequently , @xmath212 is also in runner @xmath112 , and there are gaps in positions @xmath289 and @xmath288 .",
    "when we apply @xmath245 , we lose the gap @xmath289 but then gain back @xmath290 .",
    "finally , if @xmath212 is involved in a transposition under @xmath243 , then @xmath116 is in position @xmath294 or @xmath295 , and there are gaps in positions @xmath296 and @xmath174 .",
    "consequently , @xmath212 is in either runner @xmath173 or @xmath297 , and there are gaps @xmath292 and @xmath293 to the left of @xmath212 on runners @xmath21 and @xmath274 , as well as on the level below .",
    "when we apply @xmath243 , we therefore lose the gaps in runners @xmath21 and @xmath274 , but then gain them back in positions @xmath298 and @xmath299 .",
    "this completes the proof of ( 3 ) .",
    "there are various results ( @xcite , @xcite , @xcite , @xcite , to name some recent examples ) involving type @xmath5 objects that we expect have analogues in the other types .",
    "another family of combinatorial objects in bijection with @xmath46 is the lecture hall partitions of bousquet - mlou and eriksson @xcite",
    ". it may be interesting to see whether some analogue of these partitions exists in the other affine types .",
    "this work has benefited from conversations with m. vazirani and c. berg .",
    "we also thank d. armstrong , s. fishel , r. green , e. oshea , and a. schilling for helpful discussions . c.  r.  h.  hanusa gratefully acknowledges support from psc - cuny research awards pscreg-41 - 303 and trada-42 - 115 .",
    "we thank the anonymous reviewer for several helpful suggestions .",
    "s.  c. billey , s.  a.",
    "mitchell , http://www.combinatorics.org/volume_16/abstracts/v16i2r18.html[affine partitions and affine grassmannians ] , electron .",
    "j. combin .",
    "16  ( 2 , special volume in honor of anders bjorner ) ( 2009 ) research paper 18 , 45 .",
    "g.  james , a.  kerber , the representation theory of the symmetric group , vol .",
    "16 of encyclopedia of mathematics and its applications , addison - wesley publishing co. , reading , mass . , 1981 , with a foreword by p. m. cohn , with an introduction by gilbert de b. robinson .",
    "h.  eriksson , k.  eriksson , http://www.combinatorics.org/volume_5/abstracts/v5i1r18.html[affine weyl groups as infinite permutations ] , electron .",
    "j. combin . 5 ( 1998 )",
    "research paper 18 , 32 pp .",
    "( electronic ) ."
  ],
  "abstract_text": [
    "<S> we introduce abacus diagrams that describe the minimal length coset representatives of affine weyl groups in types @xmath0 , @xmath1 , @xmath2 and @xmath3 . </S>",
    "<S> these abacus diagrams use a realization of the affine weyl group @xmath4 due to eriksson to generalize a construction of james for the symmetric group . </S>",
    "<S> we also describe several combinatorial models for these parabolic quotients that generalize classical results in type @xmath5 related to core partitions . </S>"
  ]
}