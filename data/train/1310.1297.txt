{
  "article_text": [
    "graph matching is an increasingly important problem in inferential graph statistics , with applications across a broad spectrum of fields including computer vision ( @xcite , @xcite ) , shape matching and object recognition ( @xcite , @xcite ) , and biology and neuroscience ( @xcite , @xcite , @xcite ) , to name a few . the _ graph matching problem _ ( gmp ) seeks to find an alignment between the vertex sets of two graphs that best preserves common structure across graphs .",
    "unfortunately , the gmp is inherently combinatorial , and no efficient exact graph matching algorithms are known . indeed ,",
    "even the simpler problem of determining if two graphs are isomorphic is famously of unknown complexity ( @xcite , @xcite ) , and if the graphs are allowed to be loopy , weighted and directed , then the simplest version of gmp is equivalent to the np - hard quadratic assignment problem . due to its wide applicability , there exist a vast number of approximating algorithms for gmp ; see the paper  30 years of graph matching in pattern recognition \" ( @xcite ) for an excellent survey of the existing literature .",
    "when matching across graphs , often we have access to a partial matching of the vertices in the form of a _",
    "seeding_. in practice , the assumption of seeds is quite natural in many applications .",
    "for example , in aligning social networks actors user names may often allow for a partial alignment to be known a priori .",
    "when matching across brain graphs ( connectomes ) , we have geometric information provided by the brain atlas which provides a soft seeding fo the vertices . in many time series graphs ,",
    "it is common to have a group of invariant vertices across time which act as seeds .    in the _ seeded graph matching problem _ ( sgmp )",
    ", we leverage the information contained in an available partial matching to match the remaining vertices across graphs .",
    "though the literature on seeded graph matching is comparatively small , recent results point to significant performance improvements in gm algorithms by incorporating even a modest number of seeds ( @xcite , @xcite ) .",
    "though a myriad of approximate graph matching algorithms exist , the very large graphs arising in the burgeoning realm of  big data \" demand highly scalable algorithms . roughly speaking , existing state of the art algorithms for approximate graph matching can be divided into two classes : those that seek to bijectively match vertices of graphs of the same order , and those that seek matchings between the vertex sets that are allowed to be many  to  many and many  to  one .",
    "the current cutting - edge bijective graph matching algorithms achieve excellent performance in approximately matching graphs with thousands of vertices and with computational complexity @xmath0@xmath1 the number of vertices being matched ; see for example @xcite , @xcite and @xcite .",
    "these algorithms often operate directly on the adjacency matrices of the graphs to be matched , utilizing the tools of nonlinear optimization to approximtely solve gmp directly . however , owing to their @xmath0 complexity , these algorithms are practically unusable , without significant computation resources , for matching very large graphs ( @xmath2 .    scalability is often achieved via relaxing the bijection requirement and allowing many  to  many and many  to  one matchings .",
    "these graph matching procedures can efficiently match very large graphs , often with @xmath1 in the tens of thousands ; see for example @xcite , @xcite . a common approach to these scalable inexact algorithms",
    "is that they first match smaller , lower dimensional representative objects ( prototype graphs in @xcite , eigenvectors in @xcite ) and use these to build the overall matching .",
    "herein , we propose a new divide - and - conquer approach to _",
    "scalable bijective _ seeded graph matching .",
    "our algorithm , the large seeded graph matching algorithm ( lsgm , see algorithm [ alg : dandc ] ) , merges the approaches of bijective and non - bijective graph matching and leverages the information in seeded vertices in order to match very large graphs .",
    "the algorithm proceeds in two steps : we first spectrally embed the graphs  yielding a low dimensional euclidean representation of our graph  and then use the information provided by seeded vertices to jointly cluster the vertices of the two embedded graphs .",
    "this embedding procedure allows us to employ the powerful theory of adjacency spectral embedding ( see for example @xcite and @xcite ) to prove asymptotically perfect performance in _ jointly _ clustering stochastic block model random graphs , see theorem [ t ] for detail .",
    "once the vertices are jointly clustered , we then match the graphs within the clusters .",
    "this matching step is fully parallelizable and flexible in that we can employ any one of a number of matching procedures depending on the properties of the resulting clusters .",
    "the flexibility afforded by our procedure in the clustering and matching subroutines can have a dramatic impact on algorithmic scalability .",
    "for example , on a 1600 vertex simulated graph our parallelization procedure was able to achieve an factor of 8 improvement in speed at minimal accuracy degradation by increasing the number of clusters and hence the number of cores that were used ; see section [ sec : k ] .    though we are not the first to employ a divide - and - conquer approach to graph matching ( see for example @xcite , @xcite , @xcite ) , our focus on the efficient utilization of apriori observed seeded vertices and the theoretical framework for our approach provided by theorem [ t ] set our algorithm apart from the existing literature .    * note : * all graphs considered herein will be simple ; in particular there are no multiple edges between two vertices nor are there edges with a single vertex as both endpoints .",
    "modifications for the directed case are quite simple @xcite but we do not consider them in this manuscript . all vectors considered will be column vectors , and @xmath3 is the length-@xmath4 vector of all @xmath5 .",
    "when appropriate we drop the subscript and just write @xmath6 . throughout the paper",
    "we employ the standard notation @xmath7:=\\{1,2,\\ldots , n\\}$ ] for any @xmath8 , and to simplify future notation , if @xmath9 and @xmath10 $ ] , then @xmath11 will denote the submatrix of @xmath12 with row indices @xmath13 and column indices @xmath14 . for a matrix @xmath15 , @xmath16 will denote the @xmath17th column of @xmath15 and @xmath18 the @xmath17th row of @xmath15 . also for two matrices @xmath15 and @xmath19 , @xmath20 $ ] will denote the column concatenation of @xmath15 and @xmath19 .",
    "symmetric , hollow @xmath21 , @xmath22 $ ] , seeding @xmath23\\rightarrow[s]$ ] a matching of @xmath24 and @xmath25 given by @xmath26 ; embed and jointly cluster the graphs according to algorithm [ alg : emcl ] in parallel match cluster @xmath17 across the graphs using , yielding matching @xmath27 ; @xmath28 .",
    "there are numerous formulations of the graph matching problem , though they all share the same objective heuristic : given two graphs , @xmath29 and @xmath30 , gmp seeks an alignment between the vertex sets @xmath31 and @xmath32 that best preserves structure across the graphs . in _ bijective _ graph matching , we further assume @xmath33 and the alignment sought by gmp is a bijection between @xmath31 and @xmath32 . in _ non - bijective _ graph matching , we allow for @xmath34 and for alignments that are not one  to  one .    in the bijective matching setting , gmp is commonly formulated as follows : find a bijection @xmath35 minimizing the quantity @xmath36 \\text { or } [ i\\nsim_{g_1}\\!j\\text { , } \\psi(i)\\sim_{g_2}\\psi(j)]\\big\\}\\big|,\\end{aligned}\\ ] ] i.e. the problem seeks to minimize the number of edge disagreements between @xmath25 and @xmath37 ( see @xcite , @xcite , @xcite )",
    ". equivalently stated , if @xmath12 and @xmath38 are the respective adjacency matrices of @xmath24 and @xmath25 , then this problem seeks to minimize @xmath39 over all permutation matrices @xmath40 permutation matrices@xmath41 , with @xmath42 the matrix frobenius norm . in the non - bijective matching setting ,",
    "@xmath31 and @xmath32 need not have equal cardinality .",
    "this requires an alternative formulation of gmp , as ( [ eq : min ] ) is no longer necessarily well - defined .",
    "see @xcite , @xcite , @xcite , @xcite for a variety of generalizations of ( [ eq : min ] ) . in the seeded graph",
    "matching problem ( sgmp ) , we further assume the presence of a latent alignment @xmath43 between the vertex sets of @xmath24 and @xmath25 .",
    "our task is to then efficiently leverage the information in a partial observation of the latent alignment , i.e. a _ seeding _ , to estimate the remaining latent alignment . in bijective sgmp",
    ", we are given subsets of the vertices @xmath44 and @xmath45 called _ seeds _ with @xmath46 and a bijective seeding function @xmath47 . without loss of generality",
    "we may reorder the vertices so that @xmath48 $ ] and @xmath49 ( the identity function on @xmath50 ) .",
    "the task then is to use @xmath51 to estimate @xmath43 by finding the bijection extending @xmath51 which minimizes ( [ eq : min ] ) . in the non - bijective",
    "setting , to accommodate the fact that the latent alignment need not be one  to  one , we define @xmath43 to be a subset of @xmath52 , and we are tasked with using a partial observation of @xmath43 to estimate the remaining latent alignment .",
    "we present the details of the lsgm algorithm , algorithm [ alg : dandc ] . in section  [ sec : jclust ] , we describe steps 1 - 3 of this algorithm which constitute the divide steps . in section  [ sec : matchclust ] , we describe the final step of the algorithm which constitutes the conquer step . [",
    "s : sec ]      we begin by describing the embedding and clustering subroutine .",
    "the input is the symmetric adjacency matrices @xmath12 and @xmath38 of the two graphs to be matched ( @xmath24 and @xmath25 respectively ) , the number of seeds @xmath53 , the seeding function @xmath54\\rightarrow[s]$ ] , the number of clusters @xmath55 , and the embedding dimension @xmath56 .",
    "note that the procedure can easily be modified to handle directed graphs as well .",
    "symmetric @xmath21 , @xmath57 , seeding @xmath54\\rightarrow[s]$ ] , @xmath58 , @xmath59 $ ] ; a clustering of the @xmath60 embedded vertices into @xmath55 clusters ; compute the first @xmath61 orthonormal eigenpairs of @xmath12 and @xmath38 , namely @xmath62 and @xmath63 respectively ; @xmath64 , @xmath65 ; @xmath66,:)$ ] , @xmath67,:)$ ] , @xmath68 ; apply the transformation @xmath69 to @xmath70 obtaining the embedding @xmath71 of @xmath12 ; cluster the @xmath60 embedded points , @xmath72 into @xmath55 clusters via the @xmath55-means clustering procedure ;    * step 1 : * compute the first @xmath61 eigenpairs of @xmath12 and @xmath38 . letting the orthonormal eigen - decompositions of @xmath73(s_a\\oplus \\widetilde s_a ) [ u_a|\\widetilde u_a]^t$ ] and @xmath74(s_b\\oplus \\widetilde s_b ) [ u_b|\\widetilde u_b]^t$ ] , with @xmath75 , @xmath76 and the diagonals of @xmath77 and @xmath78 nonincreasing , we compute only @xmath79 , @xmath80 , @xmath81 , @xmath82 .",
    "* step 2 : * initially embed the vertices of @xmath24 and @xmath25 into @xmath83 as @xmath84 and @xmath85 respectively .",
    "* step 3 : * let @xmath86,:)$ ] and @xmath87,:)$ ] be the initial embedding of the seeded vertices .",
    "align the embedded seeded vertices via the orthogonal procrustes fit problem : for @xmath88 , we set @xmath89 * step 4 : * align the two embedded adjacency matrices ; i.e. we apply the transformation @xmath69 to @xmath70 and obtaining the transformed embedding @xmath71 .    *",
    "step 5 : * cluster the @xmath60 embedded vertices , @xmath71 and @xmath90 , into @xmath55 clusters with the _ k - means _ algorithm ( @xcite ) .",
    "let the corresponding cluster centroids be labeled @xmath91 .    * remark 3.1.1 . * the above procedure can be implemented on very large graphs using efficient svd algorithms ( see for example @xcite ) .",
    "indeed , as we are only interested in the first @xmath92 eigenpairs , these can be computed in @xmath93 steps for @xmath94 . in the sparse regime ,",
    "fast partial singular value decompositions ( e.g. irlbd in @xcite ) can be effectively implemented on arbitrarily large graphs .",
    "paired with fast clustering procedures ( here , each iteration of @xmath55-means has complexity @xmath95 , and in practice excellent performance can often be achieved with significantly less than @xmath1 iterations ) , the above procedure can be effectively run on extremely large sparse graphs .",
    "we do not implement parallelized versions of the svd procedure or clustering procedure in our algorithm ; indeed , even for the large graphs we considered , the partial svd and direct @xmath55-means were directly and efficiently computable .",
    "note that there is an extensive literature devoted to parallel svd and clustering implementations , see @xcite and for more detail .",
    "empirically , we see that the matching step is the most computationally intensive step of our procedure , and the runtime gains possible by parallelizing the svd and clustering procedures are relatively small compared to the gains achieved by matching in parallel .",
    "see section [ scalability ] for detail .",
    "additionally , the orthogonal procrustes problem in step 3 can be solved in @xmath96 time as it involves computing the singular value decomposition of @xmath97 and setting @xmath98 .",
    "* remark 3.1.2 * model selection , more specifically choosing @xmath61 and @xmath55 , is a difficult hurdle to overcome in spectral clustering ( see @xcite and @xcite for instance ) .",
    "one way to estimate @xmath61 is via automated profile likelihood procedures such as @xcite .",
    "unfortunately , the procedure in @xcite requires computation of the full spectrum , which is computationally intensive . in our simulation examples we assume @xmath61",
    "is known , and in the real data examples , we use the ideas of @xcite to estimate the embedding dimension from a partial scree plot .",
    "we expect our procedure to work well as long as @xmath99 ( see lemma [ lem : gap ] for detail ) which we see is the case in our simulated and real data examples .",
    "our procedure is insensitive to our choice of @xmath55 provided that    * the procedure consistently clusters across the graphs  if the optimal matching of @xmath24 and @xmath25 is given by @xmath100 ( in the bijective case ) , then for all @xmath101 , @xmath102 and @xmath103 are in the same cluster .",
    "this is essential for ensuring the accuracy of the subsequent matching step . *",
    "the clusters are modestly sized ( for implementing the subsequent matching procedure ) .",
    "note that in practice it is impossible to ensure that the clustering is consistent , and we explore the impact of different values for @xmath55 ( and misclustered vertices ) in section [ sec : k ] .",
    "indeed , the accuracy of the algorithm is limited by the initial clustering , and we are presently working to understand the consistency of different clustering procedures in different model settings .    * remark 3.1.3 .",
    "* practically , the particular choice of clustering procedure utilized in step 5 of algorithm [ alg : emcl ] is of secondary importance .",
    "indeed , we choose the @xmath55-means clustering procedure ( using _ matlab _ s built in k - means solver ) because of its ease of implementation and theoretical tractability .",
    "the particular clustering procedure can be chosen to optimize speed and accuracy given the properties of the underlying data .",
    "see @xcite for a review of clustering procedures . also note that although in many applications a natural @xmath55 is dictated by the data , we do not need to exactly find @xmath55 . for our graph matching exploitation task",
    "we do not need to finely cluster the vertices of our graphs ; a gross but consistent clustering would still achieve excellent performance .",
    "* remark 3.1.4 .",
    "* while our algorithm is presented for undirected unweighted graphs , we could adapt our approach to directed graphs ( we would embed the vertices as in @xcite ) , or weighted graphs ( the svd can easily be run on weighted graphs ) .",
    "we plan to theoretically explore this further in future work .",
    "when the desired matching is bijective , we first must resolve disagreements in cluster sizes and adjust the clusters accordingly .",
    "more specifically , we need to address the fact that within each cluster , we may have an unequal number of vertices from each of the two graphs .",
    "we do this as follows :    * suppose that for each @xmath104 , cluster @xmath17 has @xmath105 total vertices ( from both graphs combined ) with @xmath106 . within cluster @xmath17 ,",
    "suppose there are @xmath107 vertices from @xmath24 and @xmath108 vertices from @xmath25 .",
    "* resize cluster @xmath17 to be of size @xmath109 to parse out eq .",
    "( [ eq : blocksize ] ) , note that ideally we would resize the clusters to be of size @xmath110 , but @xmath111 may be greater than @xmath1 ( note that it is never greater than @xmath112 ) . to account for this , we sequentially ( starting from the smallest cluster and working up ) remove 2 vertices from each cluster until @xmath113 . * designating all vertices as unassigned , sequentially for @xmath104 , assign the @xmath114 unassigned vertices from each graph closest ( in the l@xmath115 sense ) to @xmath116 to be in cluster @xmath17 .",
    "note that if the desired output is a non - bijective matching , the above procedure for ameliorating cluster sizes need not be implemented .",
    "once the cluster sizes are resolved , we can match the two graphs within a cluster using any number of bijective matching algorithms .",
    "see section [ s : results ] for performance comparisons of various matching procedures .",
    "these matching sub - routines can be run fully in parallel , and if the matching within cluster @xmath17 is denoted @xmath117 , then the final output of our algorithm is the full matching @xmath118 , an approximate solution to the sgmp . to further parallelize our approach , one could implement a multithread graph matching procedure as in @xcite .",
    "however , to run their procedure one needs a machine with a numa architecture and openmp installed , whereas we focus on a scalable procedure able to be run on a typical computer cluster , without any specialized hardware / software .",
    "* remark 3.2.1 * first , note that the distances needed to resize the cluster have already been computed by the @xmath55-means clustering procedure so that the cost incurred by reassigning the vertices is computationally minimal ( see section [ s : results ] for empirical evidence of this ) .",
    "second , we do not focus on modifying existing @xmath55-means procedures to automatically make the clusters be of commensurate sizes .",
    "we view our resizing as a refinement of the original @xmath55-means procedure , and not as providing a new clustering of the vertices . in practice , our reassigned clusters are very similar to the original @xmath55-means clusters , often differing in only a few vertices",
    ".    * remark 3.2.2 * in the event that one of the @xmath55-means clusters is composed of a large majority of vertices from a _ single _ graph , bijective graph matching might not be sensible . in this case",
    ", we can non - bijectively match within each cluster by padding the adjacency matrices with empty vertices to make the graphs of commensurate size ( as suggested in @xcite ) , and match the resulting graphs .",
    "vertices matched to isolates could be treated as unmatched , or we could iteratively remove the matched vertices in the larger graph and rematch the graphs , yielding a many  to  many matching .",
    "* remark 3.2.3 * in these matching procedures , it is not surprising that we obtain best results if we use the seeded vertices to not only cluster but also match the graphs ( via the sgm algorithm of @xcite and @xcite ) .",
    "we recognize that the other bijective matching procedures ( @xcite and @xcite ) have not been modified in the literature to accommodate seeded vertices , and we do not pursue the modification here .",
    "our results point to the need for modifying these algorithms to handle seedings , and we expect them to achieve excellent performance when thus modified .      the many executions of the bijective matching subroutine can be run in parallel , and if @xmath119 is the size of the largest cluster of the points , then this step has computational complexity @xmath120 ( assuming that we use all seeds in the matching procedure ) . if the executions are run in sequence then this step would have complexity @xmath121 . if @xmath122 then the computational cost of this step is @xmath0 , and we have the same computational bound as the algorithms of @xcite , @xcite , @xcite . to deal with this issue of load balancing , we re - cluster any overly large clusters by re - running our embedding and clustering procedure with the same seeding function @xmath43 on ( where @xmath123 is the set of indices of the unseeded vertices in cluster @xmath17 ) @xmath124,[s])&a'([s],\\ell_i)\\\\ ( a'([s],\\ell_i))^t&a'(\\ell_i,\\ell_i ) \\end{pmatrix},\\ ] ] and @xmath125 ( defined analogously ) for all @xmath17 such that the size of the corresponding cluster is overly large .",
    "if we are unable to reduce these cluster sizes further , then our algorithm can not improve upon the existing @xmath0 computational complexity , though we achieve a significantly better lead constant . in this case",
    ", we might overcome this hurdle by non - bijectively matching any overly large clusters , as these procedures are often highly scalable .",
    "* remark 3.3.1 .",
    "* if there exists an @xmath126 such that @xmath127 , @xmath128 and each cluster is size @xmath129 , then the computational cost of the lsgm algorithm is @xmath130 for @xmath131 and @xmath132 for @xmath133 when the matching subroutines are fully parallelized .",
    "hence , a modest number of modestly sized clusters@xmath134yields a @xmath130 running time for the lsgm algorithm .",
    "if the number of seeds is large and if the seeds are all used in the matching procedures ( i.e. we use sgm to match the clusters ) , the lsgm algorithm may be computationally unwieldy . to remedy this",
    ", we formulate a procedure for active seed selection that aims to optimally choose a computationally tractable number of seeds from @xmath135 to match across each cluster .",
    "if we are matching cluster @xmath17 of size @xmath105 across @xmath24 and @xmath25 , and computationally we can only handle an additional @xmath136 seeds in the sgm subroutine  so that we are matching @xmath137 total vertices  then ideally we would want to pick the  best \" @xmath136 seeds to use .",
    "luckily , the results of @xmath138 provide a useful heuristic for what defines  best \" in this setting .",
    "ideally , columns of the seed to non - seed adjacency matrix in @xmath24 and @xmath25 would be enough to uniquely identify the unseeded vertices in each graph and this can be achieved with a logarithmic number of randomly chosen seeds @xcite . though this is a limiting result , the result ( and its proof ) offers insight into how to select the `` best '' seeds in a finite resource setting . specifically , we seek to have the columns of the seed to non - seed adjacency matrix maximally distinguish the unseeded vertices .",
    "mathematically , this translates to choosing seeds that have the maximum entropy in their collection of seed - nonseed adjacency vectors . to this end",
    ", we formulate the following seed selection algorithm for selecting the seeds to use when matching across cluster @xmath17 ( for @xmath17 fixed ) .",
    "suppose that the desired number of seeds for matching cluster @xmath17 is @xmath136 . to have the columns of the seed to non - seed adjacency matrix maximally distinguish the unseeded vertices , we seek seeds that have maximum entropy contained in their collection of seed - nonseed adjacency vectors .",
    "we propose to accomplish this greedily by repeatedly maximizing the ( average across the two graphs ) entropy increase possible by adding a _ single _ inactive seeded vertex to our active seed set .",
    "abusing notation , define @xmath139,\\ ] ] to be the shannon entropy of the binary column vectors of the seed to nonseed adjacency matrix in graph @xmath140 with seed set @xmath141 and unseeded vertices @xmath142 and @xmath143 is the shannon entropy function .",
    "initialize @xmath144 and for @xmath145 , we set @xmath146 to @xmath147 where @xmath148\\setminus \\mathcal{s}_i^{(t-1)}}\\left(h^1(\\mathcal{s}_i^{(t-1)}\\cup\\{i\\})+h^2(\\mathcal{s}_i^{(t-1)}\\cup\\{i\\})\\right).\\ ] ] finally , set @xmath149 .",
    "for example , suppose that we have 4 seeded vertices and 4 unseeded vertices and seed to nonseed adjacency given by : @xmath150,c_i^1)=\\begin{pmatrix } 1&0&1&0\\\\0&1&1&0\\\\1&1&1&0\\\\0&1&0&0\\end{pmatrix } , b([s],c_i^2)=\\begin{pmatrix } 1&1&1&0\\\\1&0&1&0\\\\1&1&0&0\\\\1&1&1&0\\end{pmatrix}.\\ ] ] if we were choosing 3 seeds for subsequent matching , we would choose ( in this order ) : @xmath151 , then @xmath152 ( seed 3 could also have been chosen as there are two maximizers of the entropy ) , then @xmath153",
    "in as much as we can partition the vertices of @xmath24 and @xmath25 into consistent clusters , it is natural to model @xmath24 and @xmath25 using the _ stochastic block model _ ( sbm ) of @xcite and @xcite ( details of the model are presented shortly ) .",
    "we then define the clustering criterion for clustering the rows of @xmath154^t$ ] into @xmath55 clusters via @xmath155\\rightarrow[k]}\\sum_{i=1}^{2n}\\bigg\\|\\left [ \\begin{pmatrix }     { \\widehat{y}}\\\\    { \\widehat{x}}q    \\end{pmatrix } \\right](i,:)-c(b(i),:)\\bigg\\|^2_2,\\end{aligned}\\ ] ] where the rows of @xmath156 are the centroids of the @xmath55 clusters and @xmath157 is the cluster assignment function .",
    "note that @xmath55-means attempts to solve ( [ eq : cc ] ) . in theorem [ t ]",
    "we show that , under some mild conditions on the underlying sbm , the optimal cluster assignment @xmath157 almost surely perfectly clusters the vertices of both @xmath24 and @xmath25 .",
    "we present the necessary background below .",
    "a @xmath61-dimensional stochastic block model random graph , @xmath158 , has the following parameters : an integer @xmath159 , a vector of nonnegative integers @xmath160 , and a latent  position matrix @xmath161^{n\\times d}$ ] with @xmath162 distinct rows .",
    "the random graph s vertex set @xmath163 is the union of the _ blocks _ @xmath31 , @xmath32 ,  , @xmath164 , which are disjoint sets with respective cardinalities @xmath165 , @xmath166 ,  , @xmath167 . for each @xmath168 , let @xmath169 denote the block of @xmath102 , ie @xmath170 .",
    "lastly , for each pair of vertices @xmath171 , the adjacency of @xmath102 and @xmath172 is an independent bernoulli trial with probability of success @xmath173 , where @xmath174 .",
    "two independent sbm graphs may have no correlation structure between them , and there is no natural bijective alignment of their vertices . to induce this alignment , we introduce correlation between the graphs .",
    "we say that two ( matched ) random graphs @xmath24 and @xmath25 from this model have correlation @xmath175 $ ] if the set of indicator random variables @xmath176 are mutually independent except that for each @xmath171 , the indicator random variables @xmath177 and @xmath178 have pearson product - moment correlation coefficient @xmath179 .",
    "such correlated graphs can be easily constructed by realizing @xmath24 from the underlying sbm and then , for each @xmath171 , @xmath180 is an independent bernoulli trial with probability of success @xmath181 if @xmath102 and @xmath172 are adjacent in @xmath24 , and probability of success @xmath182 if @xmath102 and @xmath172 are not adjacent in @xmath24 .",
    "if @xmath24 and @xmath25 are thus correlated , then there is a natural latent alignment between the vertices of the graphs , namely the identity function id@xmath183 .    given @xmath184 such that @xmath185 coordinate - wise and @xmath186 ( the number of seeds ) , the random graphs @xmath24 and @xmath25 from the @xmath61-dimensional stochastic block model parameterized with @xmath162 , @xmath187 , @xmath15 , and having correlation @xmath179 , are @xmath188-seeded if , a priori for each @xmath189 ,   @xmath190 of the @xmath191 vertices from block @xmath192 function as seeds for lsgm , i.e.  their across graph correspondence is known .",
    "let @xmath24 and @xmath25 be @xmath179-correlated , @xmath193-seeded ( with @xmath194 ) , @xmath61-dimensional sbm s parametrized by @xmath162 , @xmath195 , and @xmath15 .",
    "let their respective adjacency matrices be @xmath12 and @xmath38 , and let their respective block membership functions be @xmath196 and @xmath197 .",
    "without loss of generality , let the true alignment function be id@xmath183 and let @xmath198 .",
    "consider the transformed ( as in step 4 of algorithm [ alg : emcl ] ) adjacency spectral embeddings of @xmath24 and @xmath25 , @xmath71 and @xmath90 , and assume that we have clustered the rows of @xmath154^t$ ] via the optimal @xmath199 of ( [ eq : cc ] ) .",
    "adopting the notation of algorithm [ alg : dandc ] , define ( where again @xmath200 is the set of unseeded indices in @xmath140 corresponding to cluster @xmath17 and @xmath201 ) @xmath202,c_i^1)\\\\a([s],c_i^1)^t & a^{(i)}\\end{smallmatrix}\\right)-\\left(\\begin{smallmatrix } i_s&0\\\\0 & p\\end{smallmatrix}\\right)\\left(\\begin{smallmatrix } b_s&b([s],c_i^2)\\\\b([s],c_i^2)^t & b^{(i)}\\end{smallmatrix}\\right)\\left(\\begin{smallmatrix } i_s&0\\\\0 & p^t\\end{smallmatrix}\\right)\\big\\|_f,\\\\ \\psi^{(i)}_n & : = \\text{argmin}_{p\\in\\pi(c_i ) } \\big\\|a^{(i)}-pb^{(i)}p^t\\big\\|_f\\end{aligned}\\ ] ] to be the respective optimal seeded and unseeded matchings of cluster @xmath17 across the two graphs .",
    "when appropriate , we will drop the subscript and refer to the matching of cluster @xmath17 as simply @xmath27 .",
    "we shall hereto forth be considering a sequence of growing models with @xmath203 vertices . in the next theorem",
    ", we prove that under modest assumptions , we have that for all but finitely many @xmath1 , @xmath204 , and all of the vertices are perfectly clustered across the two graphs .",
    "the results of @xcite immediately give that @xmath205 a.a.s . and @xmath206 a.a.s . for all @xmath207 and the above procedure ( when perfected implemented )",
    "correctly aligns the two sbm graphs.although this result is asymptotic in nature , it provides hope that our two - step procedure will be effective in approximating the the true but unknown alignment across a broad spectrum of graphs .",
    "[ t ] with notation as above , let @xmath24 and @xmath25 be @xmath193-seeded ( with @xmath194 ) , @xmath61-dimensional sbm s parametrized by @xmath162 , @xmath195 , and @xmath15 .",
    "although we assume @xmath24 and @xmath25 have the same block structure , we make no assumptions about the correlation structure .",
    "let their respective adjacency matrices be @xmath12 and @xmath38 , and without loss of generality let the true alignment function be @xmath208 , so that the block membership function is @xmath198 . adopting the notation of section [ s : sec ] , if the following assumptions hold :    * there exist constants @xmath209 such that @xmath210 and @xmath211 ; * defining @xmath212 and @xmath213 if @xmath214 $ ] are such that @xmath215 then @xmath216 ; * without loss of generality , let @xmath217 be the latent positions corresponding to the seeded vertices , then we assume there exists an @xmath218 satisfying @xmath219 and @xmath220 such that @xmath221,:)v^t\\|_2\\geq \\alpha\\sqrt{s};\\ ] ]    then for all but finitely many @xmath1 , the @xmath157 of ( [ eq : cc ] ) satisfies @xmath222    .",
    "the graphs are first embedded using adjacency spectral embedding ( ase ) , aligned using the seeded vertices , and perfectly clustered in the aligned space.,scaledwidth=100.0% ]    regardless of the correlation structure , theorem [ t ] implies that our joint clustering procedure yields a canonical nonbijective matching of the vertices ( where the matching is given by the clustering ) .",
    "our proof of this theorem will proceed as follows .",
    "first we will state some key results proved elsewhere .",
    "then we will bound @xmath223 and will then have that the @xmath224 matrix @xmath225^t$ ] is close to a specified transformation of the @xmath226^t$ ] ( recalling from @xcite that for a matrix @xmath227 , @xmath228 ) .",
    "finally , we will use this to show that the clustering will perfectly cluster the vertices in the two graphs into the @xmath162 true blocks .",
    "let @xmath229[s_{{d}}\\oplus\\widetilde s_{{d}}][u_{{d}}|\\widetilde u_{{d}}]^t$ ] be the orthonormal eigen - decomposition of @xmath230 with @xmath231 @xmath232 , and ordered so that the diagonals of @xmath233 $ ] are nondecreasing .",
    "the next lemma collects some necessary results from @xcite and @xcite which will be needed in the sequel .",
    "[ lem : gap ] with notation as above , let @xmath234 and + @xmath235 .",
    "if @xmath236 then it holds with probability one that for all but finitely many @xmath1 that @xmath237    we are now ready to prove the following .",
    "[ lem : xq - y ] for all but finitely many @xmath1 it holds that @xmath238    _ proof : _ as in section [ s : sec ] , let @xmath239,:)w-{\\widehat{y}}([s],:)\\|_f$ ] and let @xmath240 .",
    "it immediately follows from eq .",
    "that @xmath241 .",
    "clearly @xmath242,:)q-{\\widehat{y}}([s],:)\\|_f\\leq\\|{\\widehat{x}}([s],:)\\tilde{q}-{\\widehat{y}}([s],:)\\|_f\\leq 2\\beta \\sqrt{s}.\\end{aligned}\\ ] ] and working in the other direction @xmath243,:)q-{\\widehat{y}}([s],:)\\|_f   & \\geq \\|{\\widehat{x}}([s],:)(q-\\tilde{q})\\|_f-\\|{\\widehat{x}}([s],:)\\tilde{q}-{\\widehat{y}}([s],:)\\|_f \\notag \\\\ & \\geq \\|{\\widehat{x}}([s],:)(q-\\tilde{q})\\|_f-2\\beta \\sqrt{s}.\\end{aligned}\\ ] ] if we let the svd of @xmath244 be @xmath245 then @xmath246,:)(q-\\tilde{q})\\|_f   & \\geq   \\|x([s],:)w_a ( q-\\tilde{q})\\|_f   -\\|\\left({\\widehat{x}}([s],:)-x([s ] , : ) w_a\\right ) ( q-\\tilde{q})\\|_f \\notag\\\\ & \\geq   \\left (   \\sum_{i=1}^s \\sum_{j=1}^d \\langle x(i,:),w_a v_1(:,j ) \\rangle s(j , j)^2   \\right)^{1/2 } -2\\beta \\sqrt{s}\\|q-\\tilde{q}\\|_f \\notag\\\\ & \\geq   ( \\alpha-2\\beta)\\sqrt{s}\\|q-\\tilde{q}\\|_{f}\\end{aligned}\\ ] ] by the assumption ( eq . [ eq : latsep ] ) that @xmath247 , : ) v\\|_2 ^ 2\\geq \\alpha^2 s$ ] and eq . (",
    "[ eq : boundl ] ) . combined with eq .",
    "( [ eq : boundr ] ) , we have @xmath248 .",
    "hence , we have that @xmath249 since @xmath250 and @xmath219 .    [",
    "lem : xqy - xt ] for all but finitely many @xmath1 , it holds that @xmath251    _ proof : _ we have @xmath252 the first term in eq .",
    "( [ eq:4.4.1 ] ) is bounded by @xmath253 by eq .  .",
    "for the second term we have from eq .",
    "( [ eq : lemmaproved ] ) that @xmath254    _ pf of main thm : _ let @xmath255 be the @xmath256-balls of radius @xmath257 around the @xmath162 distinct rows of @xmath258",
    ". if @xmath215 , then by assumption @xmath259 and the @xmath260 are disjoint .",
    "let @xmath261 ^t$ ] and let @xmath262 $ ] .",
    "let @xmath263 be the optimal clustering of the rows of @xmath264 from ( [ eq : cc ] ) .",
    "suppose there is an index @xmath265 $ ] such that @xmath266 this would imply that @xmath267 ( where @xmath268 is the @xmath224 matrix whose @xmath269 row is @xmath270 ) .",
    "as @xmath271 for a constant @xmath272 , we would then have that @xmath273 lemma [ lem : xqy - xt ] yields that @xmath274 ( where the final equality follows from assumption @xmath275 .",
    "combined with eq .",
    "( [ eq : contr ] ) , this contradicts the minimality of @xmath276 and therefore @xmath277 .    from ( [ eq : l9 ] ) we have @xmath278 if @xmath279 $ ] are such that @xmath280 , then @xmath281 and it follows that @xmath282 it follows that for all but finitely many @xmath1 , @xmath283^t$ ] .",
    "stated simply , @xmath284 now ( * ? ? ?",
    "* theorem 1 ) immediate implies that for all but finitely many @xmath1 , @xmath285 for all @xmath286 $ ] and the proof is complete .",
    "* remark 4.5 .",
    "* the implication of assumption _ iii .",
    "_ in theorem [ t ] is that in order for the scaled procrustes fit of the embedded seeded vectors to align the entire embedding , it is sufficient that the latent positions corresponding to the seeded vectors can not concentrate too heavily in one direction .",
    "we note that analogous assumptions are made in the literature on sparse subspace clustering , see @xcite for example and detail .",
    "* remark 4.6 .",
    "* if there exist constants @xmath209 such that @xmath210 and @xmath211 , then the results of @xcite demonstrate that the optimal clustering for the one graph analogue of ( [ eq : cc ] ) perfectly clusters the vertices of a single sbm .",
    "we next explore the effectiveness of our divide - and - conquer approach on simulated and real data examples . when comparing across graph matching algorithms , we measure effectiveness via the matching accuracy ( since we assume a true latent alignment , this amounts to the fraction of vertices which were correctly aligned ) and runtime of the algorithms . across both runtime and accuracy ,",
    "our algorithm achieves excellent performance : achieving significantly better accuracy than existing scalable bijective matching algorithms ( umeyama s spectral approach @xcite ) , and achieving significantly better accuracy and runtime than the existing state - of - the - art ( in terms of accuracy ) matching procedures ( path @xcite , glag @xcite , faq @xcite ) .",
    "unless otherwise specified , all of our experiments are run on a 2 x intel(r ) xeon(r ) cpu e5 - 2660 0 @xmath287 2.20ghz ( with 32 virtual cores and 16 physical cores ) .",
    "we implement all of our code in the software package matlab limited to 12 parallel threads .",
    "additionally , the code needed to run our algorithm ( in matlab ) is publically available for download at ` https://github.com/lichen11/lsgmcode ` .",
    "once the vertices of the two graphs are clustered , we can run the matching procedures in full parallel across the clusters .",
    "our first experiment seeks to understand how available bijective matching algorithms perform ( with respect to accuracy and speed ) , so that we can better understand how to appropriately set the maximum allowed cluster size . to this end , we run the following experiment .",
    "we consider two @xmath179-correlated sbm random graphs with the following parameters ( where @xmath288 , @xmath289 is the @xmath290 identity matrix , and @xmath291 denotes the kronecker product ) : each of @xmath292 and @xmath293 , @xmath294 , @xmath295 $ ] , for each of @xmath296 .",
    "we cluster the graphs into 2 clusters and run a variety of _ bijective _ gm algorithms on these clusters .",
    "we record both the performance of the algorithms in recovering the true alignment and the corresponding running time of each algorithm .",
    "note we ran the matching procedures on the two clusters in parallel .",
    "the algorithms we ran include sgm @xcite , faq @xcite , the spectral matching algorithm of umeyama @xcite , the path algorithm and the associated convex relaxation ( path cr , which is solved exactly using frank - wolfe methodology @xcite ) @xcite , and the glag algorithm @xcite ) .",
    "see figure  [ fig : rho ] for the results .",
    ".43   ( left ) and @xmath292 ( right ) .",
    "the parameters for the sbm graph are @xmath297 , @xmath295 $ ] , for each of @xmath296 and @xmath298 $ ] . for each value of @xmath299",
    "we ran 100 monte carlo replicates .",
    "note , the difference in scales for the left and right accuracy plots .",
    "we do not include the accuracy results for sgm for @xmath292 because they are near 1 and obscure the ordering for the remaining vertices.,title=\"fig : \" ]    [ cols=\">,^,^,^,^\",options=\"header \" , ]     to run lsgm , we used @xmath298 $ ] seeds for @xmath300 and @xmath301 $ ] seeds for @xmath292 , all seeds chosen uniformly at random from the two blocks .",
    "the seeds are always used in the embedding and clustering procedure , but sgm is the only algorithm to use seeded vertices when matching the clusters .",
    "it is not surprising that it achieves best performance .",
    "we expect similarly excellent results from the other matching algorithms once they are seeded .    in the @xmath300 experiment",
    ", we note that , of the nonseeded matching algorithms , path and its associated convex relaxation achieve the best results .",
    "the path cr procedure scales very well in running time but performs progressively worse as @xmath1 increases . on the other hand , the path algorithm s running time scales poorly ( as does that of the glag algorithm ) , needing significantly longer running time than sgm or path cr across all values of @xmath1 .",
    "while path and path cr achieve similar results to sgm for @xmath302 , the significantly longer run time for path and the sharply decreased performance for path cr at @xmath303 hinder these algorithms effectiveness as post - clustering matching procedures . indeed , to employ these two procedures , we would need to severely restrict the maximum allowed size of our clusters to achieve a feasible running time and/or accurate matchings .",
    "we note that seeding glag , the path algorithm and path cr may yield significantly faster running times and less performance degradation as @xmath1 increases , as seeding faq yields both .",
    "sgm is remarkably stable , achieving excellent matching performance across all @xmath1 .",
    "this not only indicates that our clustering methodology is consistent across graphs , but points to the importance of using the seeds in the subsequent matching . here",
    "the correlation is very high , and for smaller @xmath299 path and path cr perform on par with sgm , suggesting that seeds are less important when matching very similar graphs .",
    "we next explore the effect of decreased correlation .",
    "we explore this in the @xmath292 experiment , and again we note that sgm significantly outperforms all the nonseeded matching algorithms ( with average accuracy @xmath304 for all @xmath1 ) .",
    "this points to the consistency of our clustering procedure here .",
    "note that we needed slightly more seeds to achieve this consistency with the lower correlation .",
    "indeed , with three seeds from each cluster , the clustering was not consistent when @xmath292 , unlike in the @xmath300 case .",
    "how sensitive is the performance of our algorithm to mis - specifying @xmath55 ?",
    "we claim that as long as the clusters are consistently estimated , the procedure is relatively insensitive to mis - estimating @xmath55 .",
    "following this reasoning , if our clustering step allows clusters that are larger than @xmath305 , then we would expect our clusters to be consistent and our performance would not degrade significantly .",
    "however , if our clustering step does not allow cluster larger than @xmath305 , then we would not expect our clusters to be consistent and our performance would degrade significantly .",
    "to this end , we consider the following experiment .",
    "we consider @xmath306-correlated sbm s , with 10 blocks each of size @xmath307 , and interblock edge probability @xmath308 and across block edge probability @xmath309 .",
    "we run 20 mc replicates of divide - and - conquer graph matching with @xmath310 seeds and with the maximum allowed cluster size equal to 100 , 200 , 300 , 400 , 500 .",
    "we summarize results in figure  [ fig : accvsmaxclust ] .",
    "note that we have included the `` oracle '' matcher , which gives the maximum number of vertices possibly matched correctly given the clustering .",
    "and @xmath300 , @xmath311 @xmath312 and @xmath310 seeds randomly selected from the 1000 vertices . for each combination of parameters , we run 20 mc replicates .",
    "note that the oracle and sgm matching overlap heavily .",
    "due to scalability issues , glag and path were not run in this experiment . ]    from the figure  [ fig : accvsmaxclust ] , we see that the performance of sgm again is significantly better than all the other gm algorithms considered , and is also resilient to allowing larger clusters in the @xmath55-means procedure .",
    "this is echoed in the experiment for @xmath300 , where we see that sgm nearly achieves oracle accuracy across all maximum cluster sizes .",
    "we also explore the sensitivity of the lsgm s runtime to the maximum allowed cluster size .",
    "utilizing 12 cores , the average runtimes of the lsgm algorithm ( using sgm for matching and @xmath292 ) are @xmath313 seconds for max cluster size equal to @xmath314 ; indeed , sgm has runtime @xmath0 and is the slowest step of our divide - and - conquer procedure , so we expect to see the runtime increase if the matching subroutines are between bigger graphs .",
    "larger clusters may be more consistent and therefore may lead to better matching performance , but this is achieved at the expense of increased runtime .      while each of path , path cr , faq and glag perform significantly better than chance , again path and glag scale poorly in running time .",
    "the path cr algorithm and faq scale well in running time but have their matching performance decrease significantly as @xmath1 increases .",
    "path and glag also see this performance degradation in @xmath1 .",
    "in addition , all the algorithms ( except sgm ) perform significantly worse than the @xmath300 case .",
    "as real data is , at best , weakly correlated , this points to the primacy of seeding in matching real data graphs . due to the decreased performance and poor scalability of the nonseeded matching algorithms as @xmath1 increases",
    ", we will henceforth focus our attention on using sgm to match the clusters .",
    "again , we expect the best performing unseeded algorithms ( path , path cr and glag ) will achieve excellent performance when seeded , though we do not pursue this modification here",
    ".     blocks , block  block connectivity as specified in the text , @xmath315 , @xmath316 , and @xmath317 seeds randomly assigned to one of the three blocks .",
    "the dashed curve plots the fraction of unseeded vertices correctly matched by the sgm algorithm across the various @xmath318 , with error bars @xmath319 the solid curve plots the fraction of unseeded vertices correctly matched by the lsgm algorithm across the various @xmath318 , with error bars again @xmath319 here sgm is the algorithm of @xcite run without clustering . ]",
    "our two step approach first embeds and clusters the two graphs and then matches them accordingly .",
    "theoretically , we can embed and cluster and then match the graphs perfectly , but we next explore how much accuracy is practically lost because of the embedding step .",
    "when @xmath1 is small ( e.g. @xmath320 ) and the sgm algorithm of @xcite can be feasibly run without first clustering , the sgm algorithm will outperform lsgm in general , even in the sbm setting .",
    "indeed sgm utilizes the across cluster connectivity structure in the matching task , information which lsgm does not utilize when matching across clusters .",
    "it is also clear that sgm is utilizing more of the information contained in the seeding than lsgm . if the latent positions generating the sbms are separated enough ( as at assumption _ i. _ of theorem [ t ] ) and",
    "@xmath1 is large enough for the clustering to be consistent across the graphs , then we will illustrate that lsgm performs excellently .",
    "however , even in the case of perfect clustering , lsgm still needs ( modestly ) more seeds than sgm to achieve comparable performance .",
    "we illustrate this in figure [ fig : sgmlsgm ] .",
    "we match across two @xmath321-correlated sbms with @xmath322 blocks , @xmath315 , with block  block adjacency probabilities dictated by the matrix @xmath323 and seed values ranging from @xmath317 drawn uniformly from the 600 vertices . the dashed curve plots the fraction correctly matched by the sgm algorithm across the various @xmath318 , with error bars @xmath319 analogously , the solid curve plots the fraction correctly matched by the lsgm algorithm across the various @xmath318 , with error bars again @xmath319 note that with only 4 seeds , sgm perfectly matches across the graphs , though lsgm requires 7 seeds for comparable performance .",
    "block , @xmath324 , @xmath325 dimensional @xmath179-correlated sbm s with @xmath318 seeds drawn uniformly at random from the 27000 vertices .",
    "note that for each combination of @xmath318 and @xmath179 , we ran 25 mc simulates .",
    "all standard deviations are @xmath326 except with 10 seeds where the s.d .",
    "is @xmath327 for @xmath328.,title=\"fig : \" ] [ fig : sub6 ]    given a consistent clustering of the graphs , lsgm needs modestly more seeds to perform as well as the full sgm .",
    "in contrast , if the clustering is not consistent , lsgm can not hope to match the clusters exactly .",
    "however , while sgm can only match graphs of order @xmath329 lsgm can be used to match much larger graphs .",
    "we demonstrate this in the following experiment , where we match two large sbm graphs . in figure",
    "[ cliff ] , we plot the average accuracy of lsgm in matching the unseeded vertices in 25 mc simulations across two @xmath330 block , @xmath324 , @xmath325 dimensional , @xmath179-correlated sbm s with @xmath318 seeds drawn uniformly at random from the 27000 vertices .",
    "the @xmath162 latent positions @xmath15 are sampled uniformly from the @xmath61-dimensional simplex , and we utilize the @xmath55-means clustering algorithm ( @xmath55 an estimate of @xmath162 ) in step 5 of algorithm [ alg : emcl ] .",
    "note how few seeds are needed to ensure good performance for even modestly correlated graphs .",
    "for example , we correctly match 78.75@xmath331 of the unseeded vertices correctly with only 50 seeds and @xmath332 .",
    "this again reflects the consistency of our clustering procedure , and the applicability of our procedure in matching real data graphs , which are ( at best ) modestly correlated and have ( at best ) a modest number of seeds .",
    "we do not assume knowledge of the true @xmath162 in the above procedure , instead estimating an appropriate @xmath55 from the data .",
    "the figure shows that the matching is robust to this estimation .",
    "we also do not assume knowledge of the true @xmath61 , and here we used the automated spectral procedure of @xcite to estimate the embedding dimension @xmath61 .",
    "the model is relatively low rank , and for higher rank sbm s we see slower algorithmic performance in general .",
    "our divide and conquer algorithm essentially is composed of four steps : embed , procrustes , cluster , match . the final matching step lends itself to parallelization , and insomuch as the embedding , procrustes and clustering are computationally less expensive than the subsequent matching step , we expect our algorithm to scale well",
    ". note that we observed this scaling previously in section [ sec : k ] as well , where we saw that on a 1600 vertex simulated graph our parallelization procedure was able to achieve an 8x improvement in speed at minimal accuracy degradation by increasing the number of clusters and hence the number of cores that were used .",
    "0.55   and interblock connection probability @xmath309 ) .",
    "note , sgm ran on a single core only . for each experiment and each combination or @xmath179 and core number , we run 200 mc replicates , and we ran 20 mc replicates for the sgm experiment . for the full lsgm procedure , we then plot the achieved runtime against the theoretical maximum speedup possible when parallelizing as predicted by amdahl s law.,title=\"fig : \" ]       0.55   and interblock connection probability @xmath309 ) .",
    "note , sgm ran on a single core only . for each experiment and each combination or @xmath179 and core number , we run 200 mc replicates , and we ran 20 mc replicates for the sgm experiment . for the full lsgm procedure",
    ", we then plot the achieved runtime against the theoretical maximum speedup possible when parallelizing as predicted by amdahl s law.,title=\"fig : \" ]       0.55   and interblock connection probability @xmath309 ) .",
    "note , sgm ran on a single core only . for each experiment and each combination or @xmath179 and core number , we run 200 mc replicates , and we ran 20 mc replicates for the sgm experiment . for the full lsgm procedure",
    ", we then plot the achieved runtime against the theoretical maximum speedup possible when parallelizing as predicted by amdahl s law.,title=\"fig : \" ]       1      + correlation & mean runtime + 0.3 & 658.26 + 0.6 & 134.89 + 0.9 & 116.30 +    to explore this further , we run our algorithm on three pairs of sbms with varying @xmath333 .",
    "each sbm has 8 blocks ( with intrablock connection probability @xmath308 and interblock connection probability @xmath309 ) each of size 200 , and we run our lsgm procedure with 20 seeds utilizing 1to4 cores and , in all cases , clustering the graphs into 8 clusters .",
    "we plot the resulting algorithmic wall times in figure [ fig : scale ] ( run on a genuine intel laptop : model name : intel(r ) xeon(r ) cpu e31290 @ 3.60ghz with 4 processors ) .",
    "we note that with lower correlation , matching is the most costly step in our procedure as expected , while in the high correlation setting ( @xmath300 ) , the matching steps are relatively inexpensive . in all cases , we see roughly a 2x speedup in our procedure when utilizing 4 cores .",
    "we lastly note that matching these graphs using sgm with @xmath300 without first embedding and clustering the graphs has average runtime @xmath334 seconds ( @xmath335 seconds when @xmath292 and @xmath336 seconds when @xmath337 ) , compared with @xmath338 seconds ( @xmath339 seconds when @xmath340and @xmath341 seconds when @xmath342 with our divide - and - conquer procedure using 4 cores .",
    "see figure [ fig : scale ] for detail .",
    "+    cores & embed & procrustes & cluster & match +    & + 1 & 0.53 & 0.89@xmath343 & 0.17@xmath344 & 67 + 2 & 0.54 & 0.73@xmath343 & 0.18@xmath344 & 41 + 3 & 0.54 & 0.72@xmath343 & 0.18@xmath344 & 36 + 4 & 0.54 & 0.72@xmath343 & 0.15@xmath344 & 32 +    & + 1 & 0.53 & 0.89@xmath343 & 0.19@xmath344 & 14 + 2 & 0.53 & 0.73@xmath343 & 0.18@xmath344 & 8.9 + 3 & 0.54 & 0.72@xmath343 & 0.19@xmath344 & 8.0 + 4 & 0.54 & 0.73@xmath343 & 0.19@xmath344 & 7.1 +    & + 1 & 0.53 & 1.06@xmath343 & 1.06@xmath344 & 9.4 + 2 & 0.53 & 0.74@xmath343 & 0.20@xmath344 & 6.3 + 3 & 0.54 & 0.73@xmath343 & 0.21@xmath344 & 5.2 + 4 & 0.54 & 0.72@xmath343 & 0.20@xmath344 & 5.1 +    for each of the three correlation levels and for each of 1 to 4 cores , we also calculated the average runtime of each step of our algorithm : embedding , procrustes , clustering and matching ( see the table [ table : runtimes ] for details ) .",
    "we see that matching is the most time intensive aspect of the procedure ( especially in the low correlation setting ) , and that parallelizing the other components of our algorithm would yield incremental runtime improvements when compared to parallelizing the matching step .",
    "while parallelizing the other components of our algorithm has been the subject of independent research , the gains in implementing these parallelization strategies are incremental in this setting , and therefore we do not pursue them here .",
    "we next demonstrate the effectiveness of the lsgm algorithm in a practical real data setting . in this data",
    "set , for each of 21 subjects , we have two brain connectome graphs . for each subject , the vertices in the connectome graphs correspond to voxels in the @xmath345 voxel diffusion tensor mri brain mask .",
    "edges between vertices are present if there exists at least one neural fiber bundle connecting the voxel regions corresponding to the two vertices .",
    "the largest connected component ( lcc ) in these connectomes ranges from 20,00030,000 vertices . for more detail on the creation of these graphs and their utility in the neuroscience literature ,",
    "see @xcite and @xcite and the references contained therein .",
    "all the data can be found at ` http://openconnecto.me/graphs ` ( note that we have spatially down - sampled each data point by a factor of four in each dimension ) .",
    "while our theory is proven in the setting of sbm random graphs , this example shows the applicability of our method in matching graphs with heavy - tailed degree distribution .",
    "indeed , when we plot on a log - log scale the degree sequence of two of the connectomes to be matched below , we see all three connectomes have a heavy - tailed degree distribution rather than the flat degree distribution we would expect from the sbm ; see figure [ fig6 ] for detail .",
    "while our algorithm uncovers significant signal when matching across these connectomes , it will be useful to explore modifications to our approach for accommodating heavy - tailed degree graphs and power - law graphs .",
    "we strongly suspect that there is significant signal in the degree distribution , with higher degree vertices being easier to correctly match that lower degree vertices , and we are presently working to theoretically verify and empirically explore the algorithmic impact of these heavy - tailed degrees .",
    "0.32     0.32     0.32     in @xcite , the authors collapsed the larger graphs into smaller , more manageable graphs ( with vertex count @xmath346 ) and matched across these smaller graphs .",
    "for any two subjects , they were able to correctly match a significantly higher percentage of the vertices for the two pairs of within  subject graphs than for the four pairs of across  subject graphs .",
    "we obtain analogous results by running the lsgm algorithm to match across the larger , less downsampled , graphs .",
    "the graphs are created such that the true alignment for any two graphs matches vertices comprised of the same voxels in the @xmath347 voxel brain mask .    in figure 4",
    ", we highlight our results for a single pair of subjects , and note that analogous results held across the data set . in this example , the lcc of graphs 8 and 29 are of size 21,891 and 22,307 respectively , and the lcc of graph 1 is size 22,734 .",
    "we match across the intersection of the lcc s for graphs 8 and 29 ( same subject , results plotted in figure 4 ) and for graphs 1 and 8 ( different subjects , results plotted in figure 4 ) . from the scree plot",
    ", we estimate the optimal embedding dimension to be @xmath348 in both cases and we cluster using @xmath55-means , and as noted in section [ cost ] , we recluster any overly large clusters  here reclustering any clusters of size @xmath349and hence we initially set @xmath350 .",
    "it is clear from figure [ fig6 ] that lsgm correctly matches a significantly larger proportion of vertices for the within ",
    "subject connectomes than the across  subject connectomes .",
    "as these connectomes are too large to feasibly run sgm ( or any of the bijective matching procedures other than u  which performed very poorly here ) , we can not compare the performance of lsgm to the other bijective approaches here .",
    "on the 2 x intel(r ) xeon(r ) cpu e5 - 2660 0 @xmath287 2.20ghz machine using 12 cores , we display the average runtime ( wall time ) when matching across connectomes for the four steps of our algorithm in table [ table : brain ] .",
    "subjects & seeds & projection & procrustes & clustering & matching +    01 - 08 & 200 & 562.82 & 1.57 & 13.49 & 473.46 + 01 - 08 & 1000 & 754.84 & 2.44 & 15.79 & 883.58 + 01 - 08 & 2000 & 862.43 & 2.82 & 15.14 & 1495.26 + 01 - 08 & 5000 & 981.86 & 3.60 & 13.55 & 2698.32 + 08 - 29 & 200 & 777.11 & 1.94 & 18.16 & 569.97 + 08 - 29 & 1000 & 987.08 & 2.80 & 18.47 & 1019.73 + 08 - 29 & 2000 & 1096.84 & 3.26 & 19.29 & 1592.76 + 08 - 29 & 5000 & 890.89 & 2.90 & 15.19 & 2902.19 +    although the projection step takes longer to run than matching in some of the examples , this is an artifact of the full parallelization of the matching step ; indeed , the matching step would be computationally unwieldy without parallelizing .",
    "we also note that slower matching corresponds to better algorithmic performance . with this in mind ,",
    "we expect greater improvement from implementing our algorithm on more specialized computational hardware ( and paralellizing the svd calculation for very large graphs ) and from employing hot restarts when the algorithm terminates quickly .",
    "we emphasize that even very large graphs can be reasonably matched with a simple computing cluster .",
    "it is worth noting that in this example ( and across the entire data set ) , more seeds corresponded to a significantly better matched ratio for both the within  subject and across  subject pairs of graphs . however , for the larger values of @xmath318 ( @xmath351 ) , we are unable to run the sgm subroutines utilizing the full seeding",
    ". instead , we used the active seed selection algorithm of section [ cost ] to pick an  optimal \" , computationally feasible set of seeds to use in matching across each cluster . in all cases ,",
    "our algorithm performs significantly better than chance ( chance here being @xmath352 $ ] for the 1 - 8 pair and @xmath353 $ ] for the 8 - 29 pair for @xmath354 $ ] ) .",
    "we also explore the potential for increased performance in lsgm by utilizing different clustering procedures .",
    "the brain graphs are very sparse , and there is precedent in the literature that first projecting the latent positions onto the sphere and then clustering the graphs via @xmath55-means results in better clustering performance in the presence of graph sparsity @xcite .",
    "we call this variant of @xmath55-means the _ spherical @xmath55-means _",
    "( @xmath355-means ) algorithm , and we see that replacing standard @xmath55-means with @xmath355-means significantly increases the performance of the lsgm algorithm .",
    "this result reinforces the idea that , in practice , the clustering procedure should be chosen to leverage the signal present in the data .        & sgm & faq & umeyama & path cr + & 0.0773&0.0064&0.0034&0.0091 + & 1.72e-03 & 4.25e-04 & 1.12e-04 & 2.91e-04 +    our results reconfirm that variability in the estimated connectivity is greater between subjects than within subjects .",
    "the estimated connectivity varies due to both noise in the collection of raw scan data and the use of a suite of pre - processing tools used to clean , register and analyze the raw data . as a result , large scale graph matching can serve as another tool to assess the reliability of these methods . furthermore , this suggests that when registering two scans from the same subject , jointly using geometric properties and connectivity will improve registration accuracy .",
    "we lastly note that within cluster matching using sgm also significantly outperforms the other graph matching algorithms ( applied post embedding and clustering ) when matching across brain graphs ; see table [ table : brain2 ] for the matching accuracy and standard error ( over 20 monte carlo replicates ) for matching the 8 - 29 within - subject pair in the divide - and - conquer paradigm using @xmath356 seeded vertices and embedding the graphs into @xmath357 .",
    "we did not run path and glag here due to scalability concerns .",
    "we lastly note that running even the fastest of these algorithms , umeyama s spectral matching procedure , without first performing the embedding and clustering is prohibitively slow .",
    "indeed , here umeyama s algorithm has a runtime in excess of 50 hours and using over 30 gb of ram , reinforcing the necessity of the divide - and - conquer step ( note that in the _ graphm _ package umeyama was downloaded from , the large graph example has 1500 vertices ) .",
    ".25 , @xmath348 . for the 18 pair , @xmath358 , @xmath348",
    ", we cluster using @xmath55-means and @xmath355-means , reclustering any clusters of size @xmath349 .",
    "we plot the fraction of the vertices correctly matched in each of the four experiments for number of seeds @xmath359and @xmath360 . here",
    "we ran @xmath361 mc simulates and the error bars are @xmath319,title=\"fig:\",scaledwidth=350.0% ]    many graph inference tasks rely on being able to efficiently match across graphs . state ",
    "of  the  art bijective approximate graph matching algorithms have computational complexity @xmath0rendering them infeasible ( without significant computational resources ) for very large graphs .",
    "we present the fully parallelizable lsgm approximate graph matching algorithm which , under some mild conditions , has computational complexity @xmath130a marked improvement over @xmath0 . we demonstrate , via simulated data examples and a real data example , the effectiveness of our lsgm algorithm in performing seeded graph matching across large graphs , which heretofore were unassailable using existing bijective matching techniques .",
    "in addition , we theoretically justify our divide - and - conquer procedure in the sbm regime by proving that the procedure perfectly matches correlated sbm random graphs under some mild assumptions .",
    "our algorithm allows for flexibility in the choice of clustering and matching procedure .",
    "we focused on @xmath55-means clustering here due to its ease of implementation and theoretical tractability , but the clustering procedure can ( and should ! )",
    "be chosen to leverage the signal present in the data .",
    "the variety of matching procedures implemented point to the need for seeding the rest of the bijective graph matching procedures .",
    "when using the seeds to match , we need to intelligently choose as many seeds as is feasible in the subsequent matching task .",
    "we present a procedure for dynamically selecting seeded vertices .",
    "our procedure also provides a heuristic for defining `` good '' seeded vertices , and we are working on extending this heuristic towards the task of active learning of seeded vertices .    *",
    "acknowledgments : * this work is partially supported by a national security science and engineering faculty fellowship ( nsseff ) , johns hopkins university human language technology center of excellence ( jhu hltcoe ) , and the xdata program of the defense advanced research projects agency ( darpa ) administered through air force research laboratory contract fa8750 - 12 - 2 - 0303 .",
    "we also would like to thank william roncal gray , r. jacob vogelstein and disa mhembere for their help with the connectome data and thoughtful discussions and suggestions .",
    "ayser armiti and michael gertz .",
    "efficient geometric graph matching using vertex embedding . in _ proceedings of the 21st acm sigspatial international conference on advances in geographic information systems _ , pages 224233 .",
    "acm , 2013 .",
    "alexander  c berg , tamara  l berg , and jitendra malik .",
    "shape matching and object recognition using low distortion correspondences . in _ computer vision and pattern recognition , 2005 .",
    "cvpr 2005 .",
    "ieee computer society conference on _ , volume  1 , pages 2633 .",
    "ieee , 2005 .",
    "minsu cho , jungmin lee , and kyoung  mu lee .",
    "feature correspondence and deformable object matching via agglomerative correspondence clustering . in _ computer vision ,",
    "2009 ieee 12th international conference on _ , pages 12801287 .",
    "ieee , 2009 .",
    "minsu cho and kyoung  mu lee .",
    "progressive graph matching : making a move of graphs via probabilistic voting . in _",
    "computer vision and pattern recognition ( cvpr ) , 2012 ieee conference on _ , pages 398405 .",
    "ieee , 2012 .",
    "d.  e. fishkind , d.  sussman , m.  tang , j.  t. vogelstein , and c.  e. priebe .",
    "consistent adjacency - spectral partitioning for the stochastic block model when the model parameters are unknown .",
    ", 31(1):2339 , 2013 .",
    "kostas haris , serafim  n efstratiadis , nicos maglaveras , costas pappas , john gourassas , and george louridas .",
    "model - based morphological segmentation and labeling of coronary angiograms .",
    ", 18(10):10031015 , 1999 .",
    "a.  m. khan , d.  f. gleich , a.  pothen , and m.  halappanavar .",
    "a multithreaded algorithm for network alignment via approximate matching . in",
    "_ high performance computing , networking , storage and analysis ( sc ) , 2012 international conference for _ , pages 111 .",
    "ieee , 2012 .",
    "david knossow , avinash sharma , diana mateus , and radu horaud .",
    "inexact matching of large and sparse graphs using laplacian eigenvectors . in _ graph - based representations in pattern recognition _ , pages 144153 .",
    "springer , 2009 ."
  ],
  "abstract_text": [
    "<S> we present a parallelized bijective graph matching algorithm that leverages seeds and is designed to match very large graphs . </S>",
    "<S> our algorithm combines spectral graph embedding with existing state - of - the - art seeded graph matching procedures . </S>",
    "<S> we justify our approach by proving that modestly correlated , large stochastic block model random graphs are correctly matched utilizing very few seeds through our divide - and - conquer procedure . </S>",
    "<S> we also demonstrate the effectiveness of our approach in matching very large graphs in simulated and real data examples , showing up to a factor of 8 improvement in runtime with minimal sacrifice in accuracy . </S>"
  ]
}