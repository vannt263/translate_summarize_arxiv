{
  "article_text": [
    "peg solitaire is a game for one player .",
    "each move consists of hopping a peg over another one , which is removed .",
    "the goal is to reduce the board to a single peg .",
    "the best - known forms of the game take place on cross - shaped or triangular boards , and it has been marketed as `` puzzle pegs '' and `` hi - q . ''",
    "discussions and various solutions can be found in @xcite .    in @xcite , guy",
    "proposes one - dimensional peg solitaire as an open problem in the field of combinatorial games . here",
    "we show that the set of solvable configurations forms a regular language , i.e.  it can be recognized by a finite - state automaton .",
    "in fact , this was already shown in 1991 by plambeck ( @xcite , introduction and ch.5 ) and appeared as an exercise in a 1974 book of manna @xcite .",
    "more generally , b. ravikumar showed that the set of solvable configurations on rectangular boards of any finite width is regular @xcite , although finding an explicit grammar seems to be difficult on boards of width greater than 2 .",
    "the set of configurations that can be reduced to a single peg is the regular language @xmath0 where @xmath1\\ , ( 10)^ * 11 \\nonumber \\\\ & + & 11 ( 01)^ * ( 11)^ * 01 + 10 ( 11)^ * ( 10)^ * 11 . \\label{lang}\\end{aligned}\\ ] ] here @xmath2 and @xmath3 indicate a peg and a hole respectively , @xmath4 means ` 0 or more repetitions of @xmath5 ' , and @xmath6 means ` 1 or more repetitions of @xmath5 . '",
    "[ thm ]    to prove the theorem , we follow leibnitz @xcite in starting with a single peg , which we denote @xmath7 and playing the game in reverse .",
    "the first ` unhop ' produces @xmath8 and the next @xmath9 ( as it turns out , @xmath10 is the only configuration that can not be reduced to a single peg without using a hole outside the initial set of pegs .",
    "therefore , for all larger configurations we can ignore the @xmath3 s on each end . )",
    "we take the second of these as our example .",
    "it has two ends , @xmath11 and @xmath12 .",
    "the latter can propagate itself indefinitely by unhopping to the right , @xmath13 when the former unhops , two things happen ; it becomes an end of the form @xmath14 and it leaves behind a space of two adjacent holes , @xmath15 furthermore , this is the only way to create a @xmath16 .",
    "we can move the @xmath16 to the right by unhopping pegs into it , @xmath17 however , since this leaves a solid block of @xmath2 s to its left , we can not move the @xmath16 back to the left . any attempt to do so",
    "reduces it to a single hole , @xmath18 here we are using the fact that if a peg has another peg to its left , it can never unhop to its left .",
    "we prove this by induction : assume it is true for pairs of pegs farther left in the configuration .",
    "since adding a peg never helps another peg unhop , we can assume that the two pegs have nothing but holes to their left .",
    "unhopping the leftmost peg then produces @xmath19 , and the original ( rightmost ) peg is still blocked , this time by a peg which itself can not move for the same reason .",
    "in fact , there can never be more than one @xmath16 , and there is no need to create one more than once , since after creating the first one the only way to create another end of the form @xmath11 or @xmath20 is to move the @xmath16 all the way through to the other side @xmath21 and another @xmath16 created on the right end now might as well be the same one .",
    "we can summarize , and say that any configuration with three or more pegs that can be reduced to a single peg can be obtained in reverse from a single peg by going through the following stages , or their mirror reflection :    1 .",
    "we start with @xmath22 . by unhopping the rightmost peg",
    ", we obtain @xmath23 .",
    "if we like , we then 2 .   unhop the leftmost peg one or more times , creating a pair of holes and obtaining @xmath24 .",
    "we can then 3 .",
    "move the @xmath16 to the right ( say ) , obtaining @xmath25 .",
    "we can stop here , or 4 .",
    "move the @xmath16 all the way to the right , obtaining @xmath26 , or 5 .",
    "fill the pair by unhopping from the left , obtaining @xmath27 .",
    "equation  [ lang ] simply states that the set of configurations is the union of all of these plus @xmath2 , @xmath28 , and @xmath29 , with as many additional holes on either side as we like .",
    "then @xmath0 is regular since it can be described by a regular expression @xcite , i.e.  a finite expression using the operators @xmath30 and @xmath31 .    among other things ,",
    "theorem  [ thm ] allows us to calculate the number of distinct configurations with @xmath32 pegs , which is @xmath33 here we decline to count @xmath28 and @xmath29 as separate configurations , since many configurations have more than one way to reduce them .",
    "more generally , a configuration that can be reduced to @xmath34 pegs must belong to the regular language @xmath35 , since unhopping can not interleave the pegs coming from different origins @xcite .",
    "this leads to the following algorithm :      suppose we are given a string @xmath36 where each @xmath37 .",
    "let @xmath38 be a nondeterministic finite automaton ( without @xmath39-transitions ) for @xmath40 , where @xmath41 is the set of states in @xmath38 , @xmath42 is the start state , and @xmath43 is the set of accepting states .",
    "we then construct a directed acyclic graph @xmath44 as follows : let the vertices of @xmath44 consist of all pairs @xmath45 where @xmath46 and @xmath47 .",
    "draw an arc from @xmath45 to @xmath48 in @xmath44 whenever @xmath38 makes a transition from state @xmath49 to state @xmath50 on symbol @xmath51 .",
    "also , draw an arc from @xmath52 to @xmath53 for any @xmath54 and any @xmath55 . since @xmath56 , @xmath57 .",
    "then any path from @xmath58 to @xmath59 in @xmath44 consists of @xmath32 arcs of the form @xmath45 to @xmath48 , together with some number @xmath34 of arcs of the form @xmath52 to @xmath53 . breaking the path into subpaths by removing all but",
    "the last arc of this second type corresponds to partitioning the input string into substrings of the form @xmath0 , so the length of the shortest path from @xmath58 to @xmath59 in @xmath44 is @xmath60 , where @xmath34 is the minimum number of pegs to which the initial configuration can be reduced .",
    "since @xmath44 is a directed acyclic graph , we can find shortest paths from @xmath58 by scanning the vertices @xmath45 in order by @xmath61 , resolving ties among vertices with equal @xmath61 by scanning vertices @xmath52 ( with @xmath54 ) earlier than vertex @xmath53 .",
    "when we scan a vertex , we compute its distance to @xmath58 as one plus the minimum distance of any predecessor of the vertex .",
    "if the vertex is @xmath58 itself , the distance is zero , and all other vertices @xmath62 have no predecessors and infinite distance .",
    "thus we can find the optimal strategy for the initial peg solitaire configuration by forming @xmath44 , computing its shortest path , using the location of the edges from @xmath52 to @xmath53 to partition the configuration into one - peg subconfigurations , and applying corollary  [ one - peg - strategy ] to each subconfiguration .",
    "since @xmath57 , this algorithm runs in linear time .",
    "in contrast to these results , uehara and iwata @xcite showed that in two or more dimensions peg solitaire is np - complete .",
    "however , the complexity of finding the minimum number of pegs to which a @xmath63 configuration can be reduced , for bounded @xmath64 , remains open .",
    "finally , we note that ravikumar has proposed an impartial two - player game , in which players take turns making peg solitaire moves , and whoever is left without a move loses .",
    "it is tempting to think that this two - player game might be pspace - complete in two or more dimensions , and polynomial - time solvable in one ."
  ],
  "abstract_text": [
    "<S> we solve the problem of one - dimensional peg solitaire . </S>",
    "<S> in particular , we show that the set of configurations that can be reduced to a single peg forms a regular language , and that a linear - time algorithm exists for reducing any configuration to the minimum number of pegs . </S>"
  ]
}