{
  "article_text": [
    "let @xmath2 be a finite undirected connected simple graph with @xmath0 edges . consider a random walk on  @xmath3 , i.e. , a markov chain whose states are the vertices in  @xmath4 and whose transitions",
    "are restricted to the edges in  @xmath5 .",
    "the _ hitting time _",
    "@xmath6 associated to a pair of vertices @xmath7 is the expected time that the random walk originating at  @xmath8 takes to reach  @xmath9 ( for the first time ) .    [",
    "th : simple ] for a simple random walk on @xmath3 , and any @xmath10 , we have @xmath11 where @xmath12 is the distance between @xmath8 and  @xmath9 .    theorem  [ th : simple ] has the following direct corollary .",
    "[ thm : sg1i ] for a simple random walk , the maximum hitting time @xmath13 satisfies @xmath14 , with equality reached only for a path graph with @xmath0 edges .",
    "these results generalize to asymmetric random walks ( i.e. , random walks on edge - weighted graphs ) and to random walks with edge - cost functions .",
    "an _ edge - weight function _ on @xmath3 is a mapping @xmath15 such that @xmath16 if @xmath8 and  @xmath9 are adjacent , and @xmath17 otherwise .",
    "such a function defines a random walk on @xmath3 with transition probabilities @xmath18    let @xmath19 denote the set of vertices adjacent to @xmath20 .",
    "the _ asymmetry _ , or _ transitional bias _ , of  @xmath21 ( and of the corresponding edge - weighted graph and random walk ) is defined by @xmath22 obviously @xmath23 if and only if @xmath21 is constant on @xmath5 , or equivalently the random walk is simple .",
    "an _ edge - cost function _ is a function @xmath24 .",
    "the associated _ cost _ of a finite walk in @xmath3 is defined as the sum of costs of all its edges ( with multiplicities ) . if @xmath25 for every edge  @xmath26 , then the cost of a walk is equal to its length .",
    "the hitting time @xmath27 relative to the edge - cost function  @xmath28 is defined as the expected value of the cost of a random walk starting at  @xmath8 and stopping at  @xmath9 .    our main result is the following generalization of theorem  [ thm : sg1i ] .    let @xmath28 be a nonnegative edge - cost function . then for any @xmath29 , we have @xmath30 where @xmath31 is the minimum distance between @xmath9 and the endpoints of  @xmath26 .",
    "this section will repeat some definitions from the previous section , with necessary expansion and clarification .    we will consider a finite undirected connected simple graph @xmath32 ( where @xmath4 is the set of vertices of @xmath3 and @xmath5 is the set of edges of @xmath3 ) which has @xmath33 vertices and @xmath0 edges .",
    "undirected edge connecting vertices @xmath34 and @xmath35 will be denoted as @xmath36}$ ] and directed edge  as @xmath37 .",
    "set of all neighbors ( adjacent vertices ) of vertex @xmath8 in graph @xmath3 will be denoted as @xmath38 or simply as @xmath19 .",
    "a generalized distance function in graph @xmath3 will be denoted as @xmath39 where @xmath40 and @xmath41 are either subgraphs of @xmath3 or arbitrary sets of vertices / edges of @xmath3 .",
    "it is defined as a minimum distance between vertices that belong to objects of set @xmath40 and vertices that belong to objects from set @xmath41 .",
    "for instance , if we have edge @xmath42}$ ] and vertex @xmath43 then @xmath44 . we will also sometimes use notation @xmath45 for the same expression .",
    "_ edge - weight _ function on graph @xmath3 is a mapping @xmath46 that is positive on pairs of adjacent vertices and zero otherwise .",
    "a most common example is a unit function , that is , @xmath47 iff @xmath36}\\in{\\mathcal{e}}$ ] .",
    "pair @xmath48 is called an _ edge - weighted graph _ ( or an _ electric network _ if weights are treated as edge conductances ) and it can be used to define a random walk on @xmath3 as a time - homogeneous _ markov chain _ with @xmath3 as its state space , and with transition probabilities set by formulas @xmath49}\\in { \\mathcal{e}}\\ ; \\quad p_{xy } = 0\\quad \\textrm{if } { \\left[{x , y}\\right]}\\notin { \\mathcal{e}}\\ ] ] for any @xmath50 .",
    "this means that at each step of the walk we `` choose '' transition edge with probability proportional to the edge s weight .",
    "see @xcite , @xcite , @xcite for more formal definition of random walks on graphs , markov chains and electric networks .    among random walks on finite graphs _",
    "simple _ or _ symmetric _ random walk ( defined by edge - weight function constant on @xmath5 ) is the most commonly used . for this walk , if vertex @xmath8 has degree @xmath51 then @xmath52 for any adjacent vertex @xmath9 .",
    "most texts on graphs and probability only consider random walks which are constructed from an edge - weight function . in this article , however , we will sometimes use `` generalized '' random walks with absorbing vertex which are not , strictly speaking , random walks on graphs ( such a walk is still , however , a finite time - homogeneous markov chain ) .",
    "namely , a markov chain obtained from a random walk by declaring exactly one vertex @xmath53 as _ absorbing _ and setting probabilities for all transitions out of @xmath53 according to formula @xmath54 ( @xmath55 is kronecker s delta function ) will be called @xmath56-walk . in this case",
    "we will set @xmath57 .",
    "any `` standard '' random walk is in fact a time - reversible _ markov chain _ ( @xcite , @xcite ) with graph @xmath3 being its diagram where each edge of @xmath3 represents two oppositely oriented transitions .",
    "this markov chain is _ strongly connected _ , meaning that you can reach any vertex @xmath9 from any other vertex @xmath8 .",
    "an @xmath56-walk is `` almost '' strongly connected  you can reach any vertex @xmath9 from any vertex @xmath8 unless @xmath58 .    we will call average ( that is , expected value of ) length of walk s paths that begin at some vertex @xmath8 and end as soon as they reach @xmath53 , _ hitting time _ for vertex @xmath8 , and will denote it as @xmath59 or simply @xmath60 .",
    "when it will not end in confusion we will use an even simpler notation @xmath61 or @xmath62 .",
    "this is also sometimes called _ access time _ or _ absorption time _ since it is the expected value of the time it will take for the walker to reach ( and therefore be `` absorbed '' by ) vertex @xmath53 .    for most of the facts ( theorems , lemmas etc . )",
    "about hitting time in this article we can switch between @xmath56-walks and `` standard '' random walks .",
    "obviously , computing @xmath60 for a `` regular '' random walk @xmath63 is the same as computing it for the @xmath56-walk obtained from @xmath63 by declaring vertex @xmath53 absorbing and changing probabilities for transitions out of @xmath53 accordingly .    treating vertex @xmath53 as the fixed absorbing state will help us to simplify some proofs .",
    "therefore we will often convert a given random walk into an @xmath56-walk and consider vertex @xmath53 an absorbing vertex , and in all figures in this article we will distinguish that vertex by drawing a circle around it .    for any @xmath56-walk numbers @xmath64 satisfy the following system of linear equations @xmath65",
    "let us consider matrix @xmath66 with elements @xmath67 .",
    "then system [ eq : maineq_graph ] is equivalent to @xmath68 .",
    "in other words , matrix @xmath66 maps vector @xmath69 into vector @xmath70 where all vector coordinates are 1 , except for the one indexed by @xmath53 which equals 0 ; for ease of notation we assume that @xmath53 is the last indexed vertex .",
    "this matrix @xmath66 is a so - called _ normalized laplacian matrix _ of a random walk ( see @xcite ) .",
    "proof immediately follows from the fact that any path to @xmath53 that starts in @xmath8 begins with a transition to one of its neighbors @xmath9 with probability @xmath71 .",
    "vertex @xmath53 is the only exception since there are no transitions out of @xmath53 , and @xmath72 .",
    "[ prop : mnonsing ] for any @xmath56-walk on @xmath3 matrix @xmath66 is nonsingular .",
    "we will use the fact that matrix @xmath66 is diagonally dominant , meaning that in every row absolute value of its diagonal element is greater than or equal to the sum of absolute values of all non - diagonal elements .",
    "it is also strictly dominant ( inequality mentioned just above is strict ) in the last row . now",
    "if @xmath73 is singular then there exists a non - zero vector @xmath74 such that @xmath75 . since @xmath74 is non - zero then maximum absolute value of its coordinates @xmath76 is positive .",
    "assuming that maximum is reached at index @xmath51 we have @xmath77 and since @xmath78 it follows that @xmath79    in order for this inequality chain to be valid all inequalities here must be , in fact , equalities .",
    "that means that for every index @xmath80 such that @xmath81 ( that is , corresponding vertices of the graph are adjacent ) we must have @xmath82 ( and therefore , @xmath83 ) .",
    "it follows then that all @xmath84 are the same because @xmath3 is connected , which is impossible because that would contradict any of the equations corresponding to a vertex adjacent to @xmath53 .",
    "this means , among other things , that system of linear equations ( [ eq : maineq_graph ] ) always has exactly one solution .",
    "*    below you will find a few simple graphs with values of @xmath85 printed next to the vertices ( values are computed for simple random walks ) . absorbing state vertex @xmath53 is , as always , circled .    //  graph 1 //",
    "vertices real x10 = -25 ; real y10 = -20 ; fill(circle((x10,y10),3 ) ) ; // 0 real x11 = 15 ; real y11 = -20 ; fill(circle((x11,y11),3 ) ) ; // 1 real x12 = 55 ; real y12 = -5 ; fill(circle((x12,y12),3 ) ) ; // 2 real x13 = 55 ; real y13 = -35 ; fill(circle((x13,y13),3 ) ) ; // 3 draw(circle((x10,y10),5 ) ) ;    //",
    "edges draw((x10 , y10 )  ( x11 , y11 ) ) ; // 0 - 1 draw((x11 , y11 ) ",
    "( x12 , y12 ) ) ; // 1 - 2 draw((x11 , y11 ) ",
    "( x13 , y13 ) ) ; // 1 - 3 draw((x12 , y12 ) ",
    "( x13 , y13 ) ) ; // 2 - 3    //",
    "labels label(``0 '' , ( x10 , y10 + 12 ) ) ; // 0 label(``7 '' , ( x11 , y11 + 12 ) ) ; // 1 label(``9 '' , ( x12 + 10 , y12 ) ) ; // 2 label(``9 '' , ( x13 + 10 , y13 ) ) ; // 3    //",
    " graph 2 //",
    "vertices real x20 = 100 ; real y20 = -20 ; fill(circle((x20,y20),3 ) ) ; // 0 real x21 = 140 ; real y21 = -20 ; fill(circle((x21,y21),3 ) ) ; // 1 real x22 = 180 ; real y22 = -35 ;",
    "fill(circle((x22,y22),3 ) ) ; // 2 real x23 = 180 ; real y23 = -5 ; fill(circle((x23,y23),3 ) ) ; // 3 real x24 = 220 ; real y24 = -20 ; fill(circle((x24,y24),3 ) ) ; // 4 draw(circle((x20,y20),5 ) ) ;    // edges draw((x20 , y20 ) ",
    "( x21 , y21 ) ) ; // 0 - 1 draw((x21 , y21 ) ",
    "( x22 , y22 ) ) ; // 1 - 2 draw((x21 , y21 )  ( x23 , y23 ) ) ; // 1 - 3 draw((x22 , y22 ) ",
    "( x23 , y23 ) ) ; // 2 - 3",
    "draw((x22 , y22 ) ",
    "( x24 , y24 ) ) ; // 2 - 4 draw((x23 , y23 ) ",
    "( x24 , y24 ) ) ; // 3 - 4    //",
    "labels label(``0 '' , ( x20 , y20 + 12 ) ) ; // 0",
    "label(``9 '' , ( x21 , y21 + 12 ) ) ; // 1 label(``12 '' , ( x22 + 12 , y22 - 5 ) ) ; // 2 label(``12 '' , ( x23 + 12 , y23 + 5 ) ) ; // 3 label(``13 '' , ( x24 + 10 , y24 ) ) ; // 4    //",
    " graph 3 //",
    "vertices real x30 = 270 ; real y30 = -20 ; fill(circle((x30,y30),3 ) ) ; // 0 real x31 = 310 ; real y31 = -20 ; fill(circle((x31,y31),3 ) ) ; //",
    "1 real x32 = 350 ; real y32 = -35 ; fill(circle((x32,y32),3 ) ) ; // 2 real x33 = 350 ; real y33 = -5 ; fill(circle((x33,y33),3 ) ) ; // 3 real x34 = 390 ; real y34 = -20 ; fill(circle((x34,y34),3 ) ) ; // 4 draw(circle((x30,y30),5 ) ) ;    //",
    "edges draw((x30 , y30 ) ",
    "( x31 , y31 ) ) ; // 0 - 1 draw((x31 , y31 )  ( x32 , y32 ) ) ; // 1 - 2 draw((x31 , y31 )  ( x33 , y33 ) ) ; // 1 - 3 draw((x31 , y31 )  ( x34 , y34 ) ) ; // 1 - 4 draw((x32 , y32 )  ( x33 , y33 ) ) ; // 2 - 3",
    "draw((x32 , y32 ) ",
    "( x34 , y34 ) ) ; // 2 - 4 draw((x33 , y33 )  ( x34 , y34 ) ) ; // 3 - 4    //",
    "labels label(``0 '' , ( x30 , y30 + 12 ) ) ; // 0 label(``13 '' , ( x31 , y31 + 12 ) ) ; // 1 label(``16 '' , ( x32 + 12 , y32 - 5 ) ) ; // 2 label(``16 '' , ( x33 + 12 , y33 + 5 ) ) ; //",
    "3 label(``16 '' , ( x34 + 10 , y34 ) ) ; // 4    matrix @xmath66 for the first graph in fig.[fig : simple_ex ] looks like this @xmath86    the examples above might lead you to suspect that the values of function @xmath85 are always integers in case of a simple random walk .",
    "this is true for a tree ( we will prove that in the next section ) but it is not so for an arbitrary connected graph . here",
    "are some examples of graphs with non - integer values of @xmath85 .",
    "label(``0 '' , ( -25 , -8 ) ) ; fill(circle((-25,-20),3 ) ) ; draw((-25 , -20 ) ",
    "( 15 , -5 ) ) ; draw(circle((-25,-20),5 ) ) ;    label(``@xmath87 '' , ( 15 , 9 ) ) ; fill(circle((15,-5),3 ) ) ;    label(``@xmath88 '' , ( 15 , -49 ) ) ; fill(circle((15,-35),3 ) ) ; draw((-25 , -20 ) ",
    "( 15 , -35 ) ) ; draw((15 , -35 ) ",
    "( 15 , -5 ) ) ; draw((15 , -35 )  ( 55 , -35 ) ) ;    label(``8 '' , ( 63 , 7 ) ) ; fill(circle((55,-5),3 ) ) ; draw((15 , -5 )  ( 55 , -5 ) ) ; label(``@xmath89 '' , ( 63 , -49 ) ) ; fill(circle((55,-35),3 ) ) ; draw((15 , -5 )  ( 55 , -35 ) ) ; draw((55 , -5 )  ( 55 , -35 ) ) ;    // -",
    "label(``0 '' , ( 190 , -8 ) ) ; fill(circle((195,-20),3 ) ) ; draw((195 , -20 ) ",
    "( 235 , -5 ) ) ; draw(circle((195,-20),5 ) ) ;    label(``@xmath90 '' , ( 235 , 9 ) ) ; fill(circle((235,-5),3 ) ) ;    label(``@xmath90 '' , ( 223 , -59 ) ) ; fill(circle((235,-55),3 ) ) ; draw((195 , -20 ) ",
    "( 235 , -55 ) ) ; draw((235 , -55 ) ",
    "( 315 , -55 ) ) ;    label(``@xmath91 '' , ( 323 , 9 ) ) ; fill(circle((315,-5),3 ) ) ; draw((235 , -5 ) ",
    "( 315 , -5 ) ) ; label(``@xmath91 '' , ( 323 , -59 ) ) ; fill(circle((315,-55),3 ) ) ; draw((315 , -5 ) ",
    "( 315 , -55 ) ) ;    fill(circle((275,-35),3 ) ) ; label(``@xmath92 '' , ( 275 , -21 ) ) ; draw((195 , -20 )  ( 275 , -35 ) ) ; draw((235 , -5 ) ",
    "( 275 , -35 ) ) ; draw((235 , -55 ) ",
    "( 275 , -35 ) ) ; draw((315 , -5 ) ",
    "( 275 , -35 ) ) ; draw((315 , -55 ) ",
    "( 275 , -35 ) ) ;    fill(circle((40,0),3 ) ) ; label(``6 '' , ( 40 , 10 ) ) ; fill(circle((80,0),3 ) ) ; label(``6 '' , ( 80 , 10 ) ) ;    fill(circle((0,-20),3 ) ) ; label(``@xmath93 '' , ( -10 , -20 ) ) ; fill(circle((40,-20),3 ) ) ; label(``@xmath93 '' , ( 50 , -18 ) ) ; fill(circle((80,-20),3 ) ) ; label(``@xmath93 '' , ( 70 , -18 ) ) ; fill(circle((120,-20),3 ) ) ; label(``@xmath93 '' , ( 130 , -20 ) ) ;    fill(circle((60,-40),3 ) ) ; label(``0 '' , ( 60 , -53 ) ) ; draw(circle((60,-40),5 ) ) ;    draw((40 , 0 ) ",
    "( 80 , 0 ) ) ;    draw((40 , 0 )  ( 0 , -20 ) ) ; draw((40 , 0 ) ",
    "( 40 , -20 ) ) ; draw((80 , 0 )  ( 80 , -20 ) ) ; draw((80 , 0 )  ( 120 , -20 ) ) ;    draw((0 , -20 )  ( 40 , -20 ) ) ; draw((80 , -20 )  ( 120 , -20 ) ) ;    draw((60 , -40 )  ( 0 , -20 ) ) ; draw((60 , -40 )  ( 40 , -20 ) ) ; draw((60 , -40 ) ",
    "( 80 , -20 ) ) ; draw((60 , -40 )  ( 120 , -20 ) ) ;    // -",
    "fill(circle((240,0),3 ) ) ; label(``@xmath91 '' , ( 240 , 14 ) ) ; fill(circle((280,0),3 ) ) ; label(``@xmath94 '' , ( 280 , 14 ) ) ;    fill(circle((200,-20),3 ) ) ; label(``@xmath95 '' , ( 188 , -20 ) ) ; fill(circle((240,-20),3 ) ) ; label(``@xmath95 '' , ( 251 , -16 ) ) ; fill(circle((280,-20),3 ) ) ; label(``@xmath96 '' , ( 270 , -22 ) ) ; fill(circle((320,-20),3 ) ) ; label(``@xmath97 '' , ( 332 , -20 ) ) ;    fill(circle((260,-40),3 ) ) ; label(``0 '' , ( 260 , -53 ) ) ; draw(circle((260,-40),5 ) ) ;    draw((240 , 0 ) ",
    "( 280 , 0 ) ) ;    draw((240 , 0 )  ( 200 , -20 ) ) ; draw((240 , 0 ) ",
    "( 240 , -20 ) ) ; draw((280 , 0 ) ",
    "( 280 , -20 ) ) ; draw((280 , 0 ) ",
    "( 320 , -20 ) ) ;    draw((200 , -20 ) ",
    "( 240 , -20 ) ) ; draw((280 , -20 )  ( 320 , -20 ) ) ;    draw((260 , -40 ) ",
    "( 200 , -20 ) ) ; draw((260 , -40 )  ( 240 , -20 ) ) ;    draw((260 , -40 ) ",
    "( 320 , -20 ) ) ;",
    "consider a `` straight - line '' tree graph , which is more formally known as @xmath98 ",
    "_ path graph _ or _ path tree of length _ @xmath0  with @xmath99 vertices and @xmath0 edges pictured below .",
    "label(``@xmath98 '' , ( 0,0 ) ) ; fill(circle((-25,-20),3 ) ) ; draw((-25 , -20 ) ",
    "( 15 , -20 ) ) ; fill(circle((15,-20),3 ) ) ; draw((15 , -20 )  ( 55 , -20 ) ) ; fill(circle((55,-20),3 ) ) ; draw((55 , -20 )  ( 70 , -20 ) ) ; fill(circle((80,-20),1 ) ) ; fill(circle((90,-20),1 ) ) ; fill(circle((100,-20),1 ) ) ;    draw((110 , -20 ) ",
    "( 125 , -20 ) ) ; fill(circle((125,-20),3 ) ) ; draw((125 , -20 ) ",
    "( 165 , -20 ) ) ; fill(circle((165,-20),3 ) ) ; draw((165 , -20 ) ",
    "( 205 , -20 ) ) ; fill(circle((205,-20),3 ) ) ; label(``@xmath53 '' , ( 225,-20 ) ) ; draw(circle((205,-20),5 ) ) ;    if we index vertices from right to left starting at zero ( @xmath100 = @xmath53 ) and denote hitting time @xmath101 for vertex @xmath102 as @xmath103 then system ( [ eq : maineq_graph ] ) turns into the following recurrence equation @xmath104 also , obviously @xmath105 and @xmath106 .",
    "label(``@xmath98 '' , ( 0,0 ) ) ; fill(circle((-25,-20),3 ) ) ; draw((-25 , -20 ) ",
    "( 15 , -20 ) ) ; fill(circle((15,-20),3 ) ) ; draw((15 , -20 )  ( 55 , -20 ) ) ; fill(circle((55,-20),3 ) ) ; draw((55 , -20 )  ( 70 , -20 ) ) ; fill(circle((80,-20),1 ) ) ; fill(circle((90,-20),1 ) ) ; fill(circle((100,-20),1 ) ) ;    draw((110 , -20 ) ",
    "( 125 , -20 ) ) ; fill(circle((125,-20),3 ) ) ; draw((125 , -20 ) ",
    "( 165 , -20 ) ) ; fill(circle((165,-20),3 ) ) ; draw((165 , -20 ) ",
    "( 205 , -20 ) ) ; fill(circle((205,-20),3 ) ) ; draw(circle((205,-20),5 ) ) ;    label(``@xmath107 '' , ( 205,-35 ) ) ; label(``@xmath108 '' , ( 165,-35 ) ) ; label(``@xmath109 '' , ( 125,-35 ) ) ;    label(``@xmath110 '' , ( -25,-35 ) ) ; label(``@xmath111 '' , ( 15,-35 ) ) ; label(``@xmath112 '' , ( 55,-35 ) ) ;    now let s rewrite the equation ( [ eq : maineq_path ] ) as @xmath113    if we denote difference @xmath114 as @xmath115 then @xmath116 and therefore @xmath117 , @xmath118 etc .",
    ", @xmath119 .",
    "it follows immediately that @xmath120 and since @xmath105 we obtain that @xmath121 and consequently , @xmath122 .",
    "this is an easy and well - known fact ( see , for instance , @xcite ) .",
    "this gives us a very simple upper bound for @xmath123 for the path trees .    using a somewhat similar technique we can prove the same for any tree @xmath124 .",
    "[ thm : st1 ] for simple random walk on any finite tree @xmath124 with @xmath0 edges inequality @xmath125 holds true .",
    "we need to prove inequality @xmath126 for any pair of vertices in @xmath124 . to do that we will fix vertex @xmath53 , declare it absorbing and convert the given walk into an @xmath56-walk . also without any loss of generality we can consider only vertices from connected component of @xmath127 that contains @xmath8 .",
    "we will call @xmath128 the _ tail _ of vertex @xmath8 , where @xmath129 is the set of all vertices that lie in the component of @xmath130 that contains @xmath53 .",
    "simply put , tail of @xmath8 is the sub - tree defined by all the vertices that can not be connected to @xmath53 by a path bypassing @xmath8 .",
    "we will denote by @xmath131 the number of edges in sub - tree @xmath132 . in the following picture sub - tree @xmath132",
    "is shown with thicker lines ; @xmath133 .",
    "fill(circle((-25,-20),3 ) ) ; fill(circle((-25,-80),3 ) ) ; draw((-25 , -20 ) ",
    "( 15 , -40 ) , linewidth(2pt ) ) ; draw((-25 , -80 )  ( 15 , -40 ) , linewidth(2pt ) ) ;    draw((-25 , -80 )  ( -45 , -40 ) , linewidth(2pt ) ) ; fill(circle((-45,-40),3 ) ) ; draw((-25 , -80 )  ( -60 , -70 ) , linewidth(2pt ) ) ; fill(circle((-60,-70),3 ) ) ; draw((-25 , -80 )  ( -55 , -90 ) , linewidth(2pt ) ) ; fill(circle((-55,-90),3 ) ) ;    fill(circle((15,-40),3 ) ) ; draw((15 , -40 ) ",
    "( 55 , -45 ) , linewidth(2pt ) ) ; fill(circle((55,-45),3 ) ) ;    label(``@xmath8 '' , ( 55,-55 ) ) ;    draw((55 , -45 )  ( 50 , -10 ) , linewidth(2pt ) ) ; fill(circle((50,-10),3 ) ) ; draw((50 , -10 )  ( 30 , 10 ) , linewidth(2pt ) ) ; fill(circle((30,10),3 ) ) ; draw((50 , -10 )  ( 70 , 0 ) , linewidth(2pt ) ) ; fill(circle((70,0),3 ) ) ;    fill(circle((85,-40),3 ) ) ; draw((55 , -45 )  ( 85 , -40 ) ) ;    fill(circle((85,-40),3 ) ) ; draw((85 , -40 )  ( 95 , -70 ) ) ; fill(circle((95,-70),3 ) ) ; draw((85 , -40 )  ( 60 , -90 ) ) ; fill(circle((60,-90),3 ) ) ;    draw((85 , -40 ) ",
    "( 125 , -30 ) ) ; fill(circle((125,-30),3 ) ) ; draw(circle((125,-30),5 ) ) ;    label(``@xmath53 '' , ( 125,-40 ) ) ;    [ lem : tail_eq ] for any vertex @xmath8 and any of its neighbors @xmath134 , the following equality holds true @xmath135    we will prove that using induction by @xmath131 .",
    "basis : @xmath136 , that is , @xmath9 is a leaf ( pendant vertex )",
    ". then obviously , @xmath137 and @xmath138 which proves the basis .",
    "now , for the step of induction we will take some pair of @xmath8 and @xmath9 .",
    "since @xmath139 then lemma is true for the pair of @xmath9 and any of its other neighbors in @xmath124  we will name them @xmath140 .",
    "fill(circle((-75,-20),1 ) ) ; fill(circle((-70,-20),1 ) ) ; fill(circle((-65,-20),1 ) ) ; fill(circle((-75,-40),1 ) ) ; fill(circle((-70,-40),1 ) ) ; fill(circle((-65,-40),1 ) ) ; fill(circle((-75,-60),1 ) ) ; fill(circle((-70,-60),1 ) ) ; fill(circle((-65,-60),1 ) ) ; fill(circle((-75,-80),1 ) ) ; fill(circle((-70,-80),1 ) ) ; fill(circle((-65,-80),1 ) ) ;    fill(circle((-25,-20),3 ) ) ; fill(circle((-25,-40),3 ) ) ; fill(circle((-25,-60),3 ) ) ; fill(circle((-25,-80),3 ) ) ;    draw((-25 , -20 ) ",
    "( 15 , -40 ) ) ; label(``@xmath141 '' , ( -45,-20 ) ) ; draw((-25 , -40 )  ( 15 , -40 ) ) ; label(``@xmath142 '' , ( -45,-40 ) ) ; draw((-25 , -60 )  ( 15 , -40 ) ) ;    draw((-25 , -80 ) ",
    "( 15 , -40 ) ) ; label(``@xmath143 '' , ( -45,-80 ) ) ;    fill(circle((15,-40),3 ) ) ; draw((15 , -40 )  ( 55 , -40 ) ) ; fill(circle((55,-40),3 ) ) ; draw((55 , -40 )  ( 70 , -40 ) ) ;    fill(circle((80,-40),1 ) ) ; fill(circle((90,-40),1 ) ) ; fill(circle((100,-40),1 ) ) ; label(``@xmath9 '' , ( 15,-55 ) ) ; label(``@xmath8 '' , ( 55,-55 ) ) ;    draw((55 , -40 ) ",
    "( 75 , -10 ) ) ; fill(circle((75,-10),3 ) ) ; draw((55 , -40 )  ( 50 , -10 ) ) ; fill(circle((50,-10),3 ) ) ;    draw((125 , -40 )  ( 165 , -40 ) ) ; fill(circle((165,-40),3 ) ) ; draw((165 , -40 )  ( 205 , -40 ) ) ; fill(circle((205,-40),3 ) ) ; draw(circle((205,-40),5 ) ) ;    label(``@xmath107 '' , ( 205,-55 ) ) ; label(``@xmath108 '' , ( 165,-55 ) ) ;    writing out the equation ( [ eq : maineq_graph ] ) for vertex @xmath9 we get @xmath144 or @xmath145    now we rewrite that using equation ( [ eq : tail_eq ] ) for each pair @xmath146 and equality @xmath147 .",
    "@xmath148 which gives us @xmath149    now connect vertices @xmath53 and @xmath8 by a non - self - intersecting path of length @xmath150 ( there is only one such path ) and index its vertices in exactly the same way we did above in the fig.[fig : indx_path_tree ] .",
    "then we have set of equations @xmath151 and summing them up we get @xmath152 . since @xmath153 and @xmath154 , it follows that @xmath155 and @xmath156 is equal to @xmath1 if and only if there is only one connected component in @xmath127 .",
    "below are a few corollaries of lemma [ lem : tail_eq ] .",
    "the first three are nearly self - evident and we will leave them as easy exercises for the reader .    for simple random walk on a tree",
    "all hitting times are integers .",
    "@xmath157 .",
    "@xmath158 , where @xmath159 .",
    "another widely used characteristic of a random walk on graph @xmath3 is _ commute time _",
    "@xmath160 between vertices @xmath161 .",
    "it is defined as sum of hitting times @xmath162 and is equal to the expected ( average ) time it takes the walker to `` travel '' from @xmath8 to @xmath9 and then back to @xmath8 .",
    "imagine that @xmath8 is your house and @xmath9 is your office  that immediately explains the name , does nt it ?",
    "if @xmath8 and @xmath9 are two vertices in @xmath124 then @xmath163 for instance , commute time between any two neighboring vertices equals twice the number of the edges .    again , connect @xmath8 and @xmath9 with path @xmath164 $ ] of length @xmath12 where @xmath165 and @xmath166 and for every index @xmath167 denote by @xmath168 the number of edges in the component of subtree @xmath169 that contains @xmath170 .",
    "visually , if you `` take '' vertices @xmath8 and @xmath9 in your right and left hands so that path @xmath171 becomes a horizontal rope connecting your hands and shake the entire tree so that the other vertices and edges will drop down to dangle from the nodes of @xmath171 , then @xmath168 represents the number of edges `` hanging '' on the @xmath51-th node @xmath170 .    //",
    "variables real y0 = 0 ; real y1 = -30 , y2 = -45 , y3 = -57 , y4 = -60 , y5 = -77 ; ; real x0 = 15 , x1 = 55 , x2 = 90 , x3 = 120 , x4 = 165 , x5 = 205 ; real dx = 30 , ddx = 10 , dy = 15 ; //",
    "path fill(circle((x0,y0),3 ) ) ; draw((x0 , y0 ) ",
    "( x1 , y0 ) ) ; fill(circle((x1,y0),3 ) ) ; draw((x1 , y0 ) ",
    "( x2 , y0 ) ) ; fill(circle((x2,y0),3 ) ) ; draw((x2 , y0 )  ( x3 , y0 ) ) ; fill(circle((x3,y0),3 ) ) ; draw((x3 , y0 )  ( x4 , y0 ) ) ; fill(circle((x4,y0),3 ) ) ; draw((x4 , y0 )  ( x5 , y0 ) ) ;",
    "fill(circle((x5,y0),3 ) ) ; // circling the path s ends draw(circle((x0,y0),5 ) ) ; draw(circle((x5,y0),5 ) ) ; //dangles //",
    "# 0 draw((x0 , y0 ) ",
    "( x0 , y4 ) ) ; fill(circle((x0,y4),3 ) ) ; draw((x0 , y0 )  ( x0-ddx , y5 ) ) ; fill(circle((x0-ddx , y5),3 ) ) ; // # 1 draw((x1 , y0 ) ",
    "( x1 , y2 ) ) ; fill(circle((x1,y2),3 ) ) ; draw((x1 , y2 ) ",
    "( x1 , y4 ) ) ; fill(circle((x1,y4),3 ) ) ; draw((x1 , y2 )  ( x1+ddx , y4 ) ) ; fill(circle((x1+ddx , y4),3 ) ) ; // # 2 // # 3 draw((x3 , y0 )  ( x3 , y2 ) ) ; fill(circle((x3,y2),3 ) ) ; //",
    "# 4 draw((x4 , y0 ) ",
    "( x4 , y1 ) ) ; fill(circle((x4,y1),3 ) ) ; draw((x4 , y1 )  ( x4-ddx , y2 ) ) ; fill(circle((x4-ddx , y2),3 ) ) ; draw((x4 , y1 ) ",
    "( x4 , y3 ) ) ; fill(circle((x4,y3),3 ) ) ; draw((x4 , y1 )  ( x4+ddx , y4 ) ) ; fill(circle((x4+ddx , y4),3 ) ) ; draw((x4-ddx , y2 )  ( x4-ddx , y5 ) ) ; fill(circle((x4-ddx , y5),3 ) ) ; //",
    "# 5 draw((x5 , y0 ) ",
    "( x5 , y1 ) ) ; fill(circle((x5,y1),3 ) ) ; draw((x5 , y1 ) ",
    "( x5+ddx , y2 ) ) ; fill(circle((x5+ddx , y2),3 ) ) ; draw((x5 , y1 )  ( x5+ddx , y3 ) ) ; fill(circle((x5+ddx , y3),3 ) ) ; draw((x5 , y1 )  ( x5 , y5 ) ) ; fill(circle((x5,y5),3 ) ) ; //",
    "labels label(``@xmath165 '' , ( x0,y0+dy ) ) ; label(``@xmath172 '' , ( x1,y0+dy ) ) ; label(``@xmath173 '' , ( x4,y0+dy ) ) ; label(``@xmath166 '' , ( x5,y0+dy ) ) ; // `` box '' around path real dp = 5 ; draw((x0-dp ,",
    "y0-dp)(x5+dp , y0-dp)(x5+dp , y0+dp)(x0-dp , y0+dp)(x0-dp , y0-dp ) , dotted ) ;    let s assume that vertex @xmath9 is absorbing . then from lemma [ lem : tail_eq ] @xmath174 and after expressing @xmath175 through @xmath176 @xmath177 adding these formulas for @xmath178 we obtain @xmath179    now swap @xmath8 and @xmath9 , reverse indexing , and we have @xmath180 .",
    "add these two equations together and we get @xmath181    i should mention here that this corollary also immediately follows from one of the theorems in article @xcite which we will use later ( as an example of electric network approach ) to prove our theorem [ thm : asg1 ] . same theorem ( together with monotonicity laws for electric resistance ) proves that for the case of finite connected graph we always have inequality @xmath182 .",
    "the theorem itself and this inequality can also be proved in a rather straightforward way using _ harmonic functions _ approach ( see @xcite or @xcite ) .",
    "*    now let us move on to the connected graphs in general .",
    "[ thm : sg1 ] for simple random walk on graph @xmath32 inequality @xmath183 where @xmath184 , holds true for any two vertices @xmath185 .    again , to simplify the notation and reasoning , we will  just as in [ thm : st1 ]  rename vertex @xmath9 to @xmath53 , declare it absorbing and convert the given walk into an @xmath56-walk .",
    "[ lem : sg1_1 ] consider edge @xmath186}\\in{\\mathcal{e}}$ ] such that vertices @xmath53 and @xmath8 are in the same connected component of graph @xmath187 . then @xmath188 .",
    "in other words , removing such edge can not decrease hitting time",
    ".    seems self - evident  erasing an edge leading directly into the absorbing state should only increase hitting time .",
    "however this is not an entirely trivial fact .",
    "let us denote @xmath189 . if @xmath190 then @xmath8 is only connected to @xmath53 and there is nothing to prove .",
    "fill(circle((125,-50),3 ) ) ; fill(circle((125,-35),3 ) ) ; fill(circle((135,-20),3 ) ) ;    draw((125 , -50 ) ",
    "( 165 , -40 ) ) ; draw((125 , -35 ) ",
    "( 165 , -40 ) ) ; draw((135 , -20 ) ",
    "( 165 , -40 ) ) ;    fill(circle((165,-40),3 ) ) ; label(``@xmath108 '' , ( 165,-55 ) ) ;    draw((165 , -40 )  ( 235 , -50 ) ) ; draw((165 , -40 )  ( 160 , -20 ) ) ;    fill(circle((235,-50),3 ) ) ; draw(circle((235,-50),5 ) ) ;    label(``@xmath53 '' , ( 235,-65 ) ) ;    fill(circle((205,-20),3 ) ) ; label(``@xmath8 '' , ( 235,-20 ) ) ;    draw((235 , -50 )  ( 205 , -20 ) , dotted ) ; label(``@xmath26 '' , ( 218 , -40 ) ) ;    fill(circle((205,0),3 ) ) ; draw((205 , -20 )  ( 205 , 0 ) ) ; label(``@xmath172 '' , ( 210,10 ) ) ;    fill(circle((185,0),3 ) ) ; draw((205 , -20 )  ( 185 , 0 ) ) ; label(``@xmath191 '' , ( 175,5 ) ) ;    draw((205 , -20 )  ( 185 , -15 ) ) ;    pair [ ] z=(105,-50 ) , ( 150,0 ) , ( 200,25 ) , ( 245,-20 ) , ( 195,-35 ) ; draw(z[0] .. z[1] .. z[2] .. z[3] .. z[4] .. cycle , dashed ) ;    now consider @xmath192 for any @xmath193 .",
    "we need to show that all these numbers are non - negative ( they are actually positive ) .",
    "subtracting systems ( [ eq : maineq_graph ] ) for @xmath3 and @xmath194 from each other we get the same matrix @xmath66 on the left side of the resulting system but the right side vector is different from ( [ eq : maineq_graph ] ) .",
    "its coordinates are zero for all indices ( vertices ) with exception of @xmath8 .",
    "we have @xmath195 and that number on the right side of the second equation in ( [ eq : diffax ] ) is obviously positive . if we denote that number by @xmath196 then we have that matrix @xmath66 maps vector @xmath197 to vector @xmath198 . in all these formulas",
    "we are using @xmath199 since it is easy to see that changing it to @xmath200 in cases where it is called for makes no difference .",
    "let us consider another set of numbers that satisfy similar system of equations .",
    "namely , for each vertex @xmath35 define @xmath201 as the probability that our random walk starting in @xmath35 will be absorbed in @xmath53 with edge @xmath26 being its last transition .",
    "obviously for any vertex except @xmath8 you have @xmath202 because each path starting in @xmath35 first goes to one of its neighbors ( this transition not being edge @xmath26 ! ) and then has to get from there to @xmath53 passing through @xmath26 in the end . for vertex @xmath8 @xmath203    thus matrix @xmath66 maps vector @xmath204 into vector @xmath205 .",
    "it follows then that vector @xmath197 equals to @xmath206 since they are both mapped to the same vector @xmath198 by nonsingular matrix @xmath66 ( see proposition [ prop : mnonsing ] ) .    since @xmath196 is positive , and all the numbers @xmath201 are positive ( graph @xmath194 is connected ) this concludes the proof of the lemma .",
    "[ lem : sg1_2 ] @xmath207    for every edge @xmath208}$ ] in graph @xmath3 let us represent it as two directed edges with different orientations @xmath209 and @xmath210 .",
    "we will mark each directed edge @xmath209 with difference @xmath211 .",
    "sum of all these numbers is obviously zero .",
    "however , if we group them by start vertex @xmath8 , then for every such group except for the case of @xmath212 sum of the numbers will be , by equation ( [ eq : maineq_graph ] ) , equal to @xmath213 . for @xmath53",
    "the sum is @xmath214 .",
    "it follows then ( since the sum of degrees of all vertices in a graph equals twice the number of edges ) @xmath215 which is exactly what we need .",
    "now using the lemmas above we will prove theorem [ thm : sg1 ] by induction by the number of edges @xmath0 .",
    "basis of induction is obvious .",
    "now let us connect @xmath8 to @xmath53 by a shortest path ; its last edge will connect some vertex @xmath108 and @xmath53 . if @xmath53 has any other incident edge @xmath26 besides @xmath216}$ ] then by removing it and discarding components of connectedness that do not contain @xmath8 we will reduce @xmath3 to graph @xmath194 with fewer edges than @xmath3 . thus , from lemma",
    "[ lem : sg1_1 ] and induction hypothesis , @xmath217 which proves this case .",
    "if no such edge exists then @xmath53 is a pendant vertex with only one incident edge @xmath216}$ ] .    //",
    "ellipsis real xp = 80 ; real yp = -20 ; fill(circle((xp , yp),1 ) ) ; fill(circle((xp+10,-20),1 ) ) ; fill(circle((xp+20,-20),1 ) ) ;    //",
    "vertices real x0 = xp+45 ; real y0 = yp ; real x1 = xp+60 ; real y1 = yp+25 ; real x2 = xp+20 ; real y2 = yp-15 ; real x3 = xp+85 ; real y3 = yp ; real x4 = xp+125 ; real y4 = yp ; real x5 = xp-20 ; real y5 = yp ; real x6 = xp+30 ; real y6 = yp-30 ; fill(circle((x0 , y0),3 ) ) ; fill(circle((x1 , y1),3 ) ) ; fill(circle((x2 , y2),3 ) ) ; fill(circle((x3 , y3),3 ) ) ; fill(circle((x4 , y4),3 ) ) ; fill(circle((x5 , y5),3 ) ) ; fill(circle((x6 , y6),3 ) ) ; draw(circle((x4 , y4),5 ) ) ;    // ellipse draw(ellipse((xp+20 , yp ) , 80 , 60 ) ) ; label ( `` '' , ( xp-10 , yp+40 ) ) ;    //",
    "edges draw((x0 - 15 , y0 ) ",
    "( x0 , y0 ) ) ; //",
    "draw((x1 , y1 ) ",
    "( x3 , y3 ) ) ; draw((x2 , y2 )  ( x3 , y3 ) ) ; draw((x0 , y0 )  ( x3 , y3 ) ) ; draw((x3 , y3 ) ",
    "( x4 , y4 ) ) ; draw((x5 , y5 )  ( x5 + 15 , y5 ) ) ; draw((x2 , y2 )  ( x6 , y6 ) ) ; draw((x3 , y3 )  ( x6 , y6 ) ) ; draw((x4 , y4 ) ",
    "( x1 , y1 ) , dotted ) ; draw((x1 , y1 ) ",
    "( x0 , y0 ) ) ;    draw((x6 , y6 ) ",
    "( x6 - 5 , y6 - 13 ) ) ; draw((x2 , y2 ) ",
    "( x2 - 15 , y2 - 3 ) ) ; draw((x1 , y1 )  ( x1 - 12 , y1 + 5 ) ) ; draw((x1 , y1 )  ( x1 - 15 , y1 - 5 ) ) ; draw((x1 , y1 )  ( x1 + 5 , y1 + 15 ) ) ;    // labels label(``@xmath108 '' , ( x3 - 5 , y3 - 15 ) ) ; label(``@xmath53 '' , ( x4 , y4 - 15 ) ) ; label(``@xmath8 '' , ( x5 , y5 - 15 ) ) ; label(``@xmath26 '' , ( x4 - 15 , y4 + 12 ) ) ;    now consider graph @xmath218 and assign @xmath108 as its absorbing state ( vertex ) to create an @xmath56-walk . from proposition",
    "[ prop : mnonsing ] it follows that values of @xmath219 are the same as solutions of system of linear equations ( [ eq : maineq_graph ] ) , therefore solution for @xmath220 is obviously the same as solution for @xmath3 restricted to @xmath220 , from which @xmath221 is subtracted .    from lemma [ lem : sg1_2 ] we know that @xmath222 .",
    "since we know that @xmath223 and also @xmath224 , it immediately follows that @xmath225 .",
    "the following theorem is an obvious corollary of the last one .",
    "[ thm : sg1c ] for a simple random walk on @xmath3 we have @xmath14 , with equality reached if and only if @xmath3 is path graph @xmath98 .",
    "*    now we will try to generalize this fact for the graphs endowed with a so called edge - cost function .",
    "it is often necessary to consider a case where edges of graph have different `` lengths '' , or where `` time '' to transition along an edge is not constant ( originally we assumed it is always equal to 1 ) . formally ,",
    "each edge @xmath42}$ ] can be assigned some ( usually non - negative ) _ cost _ @xmath226 which is associated with traveling ( transitioning ) along @xmath26 .",
    "cost @xmath227 of any finite path @xmath228 $ ] is determined as the sum of costs of all edges ( transitions ) in that path , that is @xmath229})$ ] .",
    "for instance , if @xmath230 then path s cost is simply its length . in the example below",
    "we show cost function @xmath28 presented as numbers written next to the edges , and path @xmath231 $ ] ( shown with thicker lines ) with cost @xmath232})+f({\\left[{r , t}\\right]})+f({\\left[{t , s}\\right]})=2 + 5 + 1 = 8 $ ] .    //",
    "vertices real x00 = 100 ; real y00 = -20 ; fill(circle((x00,y00),3 ) ) ; // 0 real x01 = 140 ; real y01 = -20 ; fill(circle((x01,y01),3 ) ) ; // 1 real x02 = 180 ; real y02 = -35 ; fill(circle((x02,y02),3 ) ) ; // 2 real x03 = 180 ; real y03 = -5 ; fill(circle((x03,y03),3 ) ) ; //",
    "3 real x04 = 220 ; real y04 = -20 ; fill(circle((x04,y04),3 ) ) ; // 4    //",
    "edges draw((x00 , y00 ) ",
    "( x01 , y01 ) ) ; // 0 - 1 draw((x01 , y01 )  ( x02 , y02 ) , linewidth(2pt ) ) ; // 1 - 2 draw((x01 , y01 )  ( x03 , y03 ) ) ; // 1 - 3 draw((x02 , y02 ) ",
    "( x03 , y03 ) ) ; // 2 - 3 draw((x02 , y02 ) ",
    "( x04 , y04 ) , linewidth(2pt ) ) ; // 2 - 4 draw((x03 , y03 )  ( x04 , y04 ) , linewidth(2pt ) ) ; // 3 - 4    //",
    "labels label(``p '' , ( x00 , y00 + 12 ) ) ; // 0 label(``q '' , ( x01 , y01 + 12 ) ) ; // 1 label(``r '' , ( x02 + 4 , y02 - 9 ) ) ; // 2 label(``s '' , ( x03 + 4 , y03 + 9 ) ) ; // 3 label(``t '' , ( x04 + 10 , y04 ) ) ; // 4    label(``_1 _ '' , ( x00 + 20 , y00 + 6 ) ) ; // 0 - 1 label(``_2 _ '' , ( x01 + 17 , y01 + 12 ) ) ; // 1 - 2 label(``*2 * '' , ( x01 + 17 , y01 - 13 ) ) ; // 1 - 3 label(``_3 _ '' , ( x02 + 4 , y01 ) ) ; // 2 - 3 label(``*1 * '' , ( x02 + 23 , y01 + 12 ) ) ; // 2 - 4 label(``*5 * '' , ( x02 + 23 , y01 - 13 ) ) ; // 3 - 4    in real - life computational problems",
    "this is a very common occurrence .",
    "time to transition ( travel ) along an edge ( or some cost associated with that transition ) is often non - constant and it has to be taken into consideration when computing total time ( or some other type of `` expense '' ) to travel from one point to another .",
    "access ( hitting ) time @xmath233 relative to cost function @xmath28 is defined as expected value of cost function for random walk s path that starts in @xmath8 and stops when it reaches ( is absorbed by ) vertex @xmath9 . just as before ,",
    "@xmath234 is defined as @xmath235 .",
    "[ thm : fg1 ] for a simple random walk on @xmath3 , for any non - negative edge - cost function @xmath28 and any vertices @xmath7 inequality @xmath236 holds true .    as before",
    ", we will rename @xmath9 to @xmath53 and make it absorbing , converting regular random walk to an @xmath56-walk .",
    "second inequality can be left to the reader as an easy exercise ( incidentally , the inequality between the first and the last expressions immediately follows from theorem [ thm : sg1c ] ) .",
    "we only need to prove the first inequality .",
    "it would seem we can simply reuse the proof of theorem [ thm : sg1 ] using function @xmath237})$ ] instead of @xmath213 , and system @xmath238 instead of [ eq : maineq_graph ] .",
    "alas , that is not possible ( at least not in the most direct manner ) because lemma [ lem : sg1_1 ] is not valid for arbitrary cost function @xmath226 . as a very simple example consider the following graph @xmath3 with graph @xmath194 produced by erasing edge @xmath239}$ ] from @xmath3 .    //",
    " graph 1 //",
    "vertices real x11 = 15 ; real y11 = -20 ; fill(circle((x11,y11),3 ) ) ; // 1 real x12 = 55 ; real y12 = -5 ; fill(circle((x12,y12),3 ) ) ; //",
    "2 real x13 = 55 ; real y13 = -35 ; fill(circle((x13,y13),3 ) ) ; // 3 draw(circle((x11,y11),5 ) ) ;    //",
    "edges draw((x11 , y11 ) ",
    "( x12 , y12 ) ) ; // 1 - 2",
    "draw((x11 , y11 )  ( x13 , y13 ) ) ; // 1 - 3 draw((x12 , y12 ) ",
    "( x13 , y13 ) ) ; // 2 - 3    //",
    "labels label(``@xmath240 '' , ( ( x11+x12)/2 , ( y11+y12)/2 + 7 ) ) ; // 1 - 2 label(``@xmath241 '' , ( ( x12+x13)/2 + 7 , ( y12+y13)/2 ) ) ; // 2 - 3",
    "label(``@xmath242 '' , ( ( x11+x13)/2 , ( y11+y13)/2 - 7 ) ) ; // 1 - 3",
    "label(``@xmath53 '' , ( x11 - 13 , y11 ) ) ; // 1 label(``@xmath243 '' , ( x12 + 7 , y12 + 10 ) ) ; // 2 label(``@xmath244 '' , ( x13 + 7 , y13 - 10 ) ) ; // 3    //",
    " graph 2 //",
    "vertices real s = 150 ; real x21 = x11 + s ; real y21 = y11 ; fill(circle((x21,y21),3 ) ) ; // 1 real x22 = x12 + s ; real y22 = y12 ; fill(circle((x22,y22),3 ) ) ; // 2 real x23 = x13 + s ; real y23 = y13 ; fill(circle((x23,y23),3 ) ) ; // 3 draw(circle((x21,y21),5 ) ) ;    //",
    "edges draw((x21 , y21 ) ",
    "( x22 , y22 ) ) ; // 1 - 2 draw((x22 , y22 )  ( x23 , y23 ) ) ; // 2 - 3    //",
    "labels label(``@xmath240 '' , ( ( x21+x22)/2 , ( y21+y22)/2 + 7 ) ) ; // 1 - 2 label(``@xmath241 '' , ( ( x22+x23)/2 + 7 , ( y22+y23)/2 ) ) ; // 2 - 3 label(``@xmath53 '' , ( x21 - 13 , y21 ) ) ; // 1 label(``@xmath243 '' , ( x22 + 7 , y22 + 10 ) ) ; // 2 label(``@xmath244 '' , ( x23 + 7 , y23 - 10 ) ) ; // 3    label(``@xmath3 '' , ( ( x11+x12)/2 , ( y11+y13)/2 - 35 ) ) ; label(``@xmath194 '' , ( ( x21+x22)/2 , ( y21+y23)/2 - 35 ) ) ;    here @xmath240 , @xmath241 and @xmath242 are some arbitrary positive numbers ",
    "values of cost function @xmath28 .",
    "solving system [ eq : maineq_graphf ] we obtain @xmath245 and @xmath246 and , if @xmath247 then hitting time for vertex @xmath244 has actually decreased after deleting edge @xmath239}$ ] .",
    "however we can still reuse some ideas from lemma [ lem : sg1_1 ] .",
    "let us define linear operator @xmath248 by formula @xmath249    thus on the right side of system [ eq : maineq_graphf ] we have vector @xmath250 with @xmath28 considered as a vector in @xmath251 .",
    "therefore , for every vertex @xmath8 we have @xmath252 that is , hitting time for vertex @xmath8 is a linear combination of edge costs with some coefficients that depend only on graph @xmath3 , vertex @xmath8 and edge @xmath26 .",
    "we will denote these coefficients as @xmath253 and the preceding equation serves as their definition . to finalize the proof we need to show that the following inequality @xmath254 holds true for any vertex @xmath8 and edge @xmath26 .    to start with ,",
    "it is obvious that @xmath253 is the same as expected value of the number of times that random walk starting at @xmath8 passes through edge @xmath26 before it reaches @xmath53 . to show that , simply use vector ( edge - cost function ) @xmath255 .    thus ,",
    "if @xmath256 ( that is , @xmath26 and @xmath53 are incident ) then @xmath257 ( you can not walk through @xmath26 more than once ) proving inequality [ eq : hve ] for this case .",
    "now for any vertex @xmath20 or any edge @xmath258 we will define functions @xmath259 as the expected value of the number of times that random walk starting from @xmath35 and stopping having reached @xmath53 will visit @xmath8 or pass through @xmath26 , respectively . in case when vertex @xmath53 is fixed we will use simplified notation @xmath260 or @xmath261 .",
    "so we can reformulate our theorem as inequality @xmath262 . if @xmath263}$ ] then consider function @xmath264 .",
    "it is very easy to check that @xmath265 from that it is not difficult to see that @xmath266 .",
    "first , @xmath267 .",
    "second , if @xmath268 is not a zero function then at some vertex @xmath269 we have @xmath270 reaching its maximum . from [ eq : omega ] it follows then that @xmath271 must have the same value as @xmath272 for all @xmath273 , and then @xmath268 has the same value in all the neighbors of those vertices as well etc . since @xmath3 is connected then @xmath268 must be constant non - zero function on @xmath274 which gives us an obvious contradiction with [ eq : omega ] .",
    "equation [ eq : omega ] basically says that the value of the function in a vertex is equal to the mean of the values in its neighbors .",
    "this is a so - called _ harmonicity _ equation ( or property ) .",
    "therefore @xmath275 ( or we could simply say that any transition through edge @xmath26 involves either walking to @xmath8 and then transitioning from @xmath8 to @xmath43 , or walking to @xmath43 and transitioning from @xmath43 to @xmath8 ) .",
    "[ lem : sb_ineq ] for any vertex @xmath276 function @xmath277 satisfies the following inequality @xmath278    this inequality can indeed be proved more or less the same way we did lemma [ lem : sg1_1 ] .",
    "first , use the same reasoning to prove that function @xmath260 can not decrease when we delete any edge @xmath279}$ ] such that @xmath53 and @xmath8 are still connected in the resulting graph .",
    "then we choose shortest path @xmath280 $ ] from @xmath281 to @xmath282 ( where @xmath283 ) , and remove all edges coming out of @xmath53 except @xmath216}$ ] . in this `` updated '' graph",
    "we can add up expressions @xmath284 along all directed edges @xmath37 to show that @xmath285 ( using same `` grouping '' trick as in lemma [ lem : sg1_2 ] ) .",
    "then `` moving '' along path @xmath171 we prove that at each step difference @xmath286 is at most @xmath213 and therefore @xmath287 . since function @xmath288 obviously attains its maximum in @xmath289 ,",
    "the lemma is therefore proved .    from this",
    "immediately follows the theorem s proof .",
    "@xmath290 since @xmath291 , @xmath292 .",
    "this inequality gives us another proof of theorem [ thm : sg1c ] .",
    "indeed , let us arrange all edges in @xmath3 by their distance from @xmath53 in ascending order and index them correspondingly @xmath293 , @xmath294 , ",
    ", @xmath295 .",
    "thus for @xmath230 @xmath296 because @xmath3 is connected and therefore @xmath297 .",
    "once again , equality is attained only for path graph @xmath98 .    on a separate note  hitting probability function @xmath288 can be easily computed for the case of a tree . in a tree for any two vertices there is a unique non - self - intersecting path that connects them ; it also serves as the shortest path between these two vertices .",
    "let @xmath280 $ ] be such a path from @xmath281 to @xmath282 ( where @xmath283 ) , and @xmath298 be such a path from @xmath34 to @xmath53 .",
    "fill(circle((-25,-20),3 ) ) ; fill(circle((-25,-80),3 ) ) ; draw((-25 , -20 ) ",
    "( 15 , -40 ) ) ; draw((-25 , -80 )  ( 15 , -40 ) , dashed ) ; label(``@xmath8 '' , ( -22,-93 ) ) ;    draw((-25 , -80 ) ",
    "( -45 , -40 ) ) ; fill(circle((-45,-40),3 ) ) ; draw((-25 , -80 ) ",
    "( -60 , -70 ) ) ; fill(circle((-60,-70),3 ) ) ; draw((-25 , -80 ) ",
    "( -55 , -90 ) ) ; fill(circle((-55,-90),3 ) ) ;    fill(circle((15,-40),3 ) ) ; draw((15 , -40 )  ( 55 , -40 ) , dashed ) ; fill(circle((55,-40),3 ) ) ; draw((55 , -40 )  ( 80 , -40 ) , dashed ) ;    //",
    "elipsis fill(circle((95,-40),1 ) ) ; fill(circle((102,-40),1 ) ) ; fill(circle((109,-40),1 ) ) ;    label(``@xmath299 '' , ( 65,-55 ) ) ;    draw((55 , -40 ) ",
    "( 50 , -10 ) ) ; fill(circle((50,-10),3 ) ) ; draw((50 , -10 )  ( 30 , 10 ) ) ; fill(circle((30,10),3 ) ) ; draw((50 , -10 )  ( 70 , 0 ) ) ; fill(circle((70,0),3 ) ) ; draw(ellipse((50 , 0 ) , 55 , 25 ) ) ; label(``@xmath300 '' , ( 110 , 10 ) ) ; label(``@xmath34 '' , ( 40,12 ) ) ;    draw((125 , -40 ) ",
    "( 165 , -40 ) , dashed ) ; fill(circle((165,-40),3 ) ) ; draw((165 , -40 )  ( 175 , -70 ) ) ; fill(circle((175,-70),3 ) ) ; draw((165 , -40 )  ( 140 , -70 ) ) ; fill(circle((140,-70),3 ) ) ;    draw((165 , -40 ) ",
    "( 205 , -40 ) , dashed ) ; fill(circle((205,-40),3 ) ) ; // draw(circle((205,-40),5 ) ) ;    label(``@xmath53 '' , ( 205,-55 ) ) ;    // `` box '' around path a  x draw((-26,-89)(17,-47)(212,-47)(212,-33)(12,-33)(-35,-80)(-26,-89 ) , dotted ) ; label(``@xmath301 '' , ( 10,-66 ) ) ;    // `` box '' around path a",
    " u draw((50,-44)(210,-44)(210,-36)(59,-36)(55,-9)(30,17)(23,10)(45,-12)(50,-44 ) , dotted ) ; label(``@xmath302 '' , ( 22,-5 ) ) ;    then value of @xmath288 can be computed by the following formula @xmath303 which can be visually represented in the following manner : if we ( mentally ) remove path @xmath171 from @xmath3 then @xmath304 turns into a disjoint union of several connected components such that in every one of them all vertices share the same _ `` point of entrance into @xmath171 '' _ , say , @xmath43 ( @xmath299 ) .",
    "then in all the vertices of this component function @xmath277 has the same value equal to @xmath305 .",
    "now we will turn to the case of edge - weighted functions or asymmetric random walks .",
    "we will use a simple measure of _ asymmetry _ ( or _ transitional bias _ ) for any edge - weight function @xmath21 ( or a random walk ) .",
    "we will denote it @xmath306 ; it is defined as @xmath307 or , alternatively , as @xmath308 that is , for each vertex we compute the maximum ratio between non - zero transition probabilities from this vertex , and then we find maximum among those values .",
    "there is only one special case where @xmath309 is undefined for a connected graph  when it has only one vertex .",
    "this is a trivial case and clearly we know all there is to know about this walk / graph s properties including hitting times .",
    "for all other random walks @xmath310 , and @xmath311 if and only if random walk is symmetric ( edge - weight function is constant on @xmath5 ) .",
    "we will undertake a somewhat different approach although a few lemmas will be reused .",
    "thankfully , we are not constrained by the requirements of space here , and i care much more for keeping the reader s interest alive than for brevity .",
    "i also ( educator s bias , perhaps ) dislike writing dense and less readable proofs of general cases instead of explaining main ideas for some natural special case and then expanding or generalizing the proof .",
    "i should say that generally symmetric walks suffice for all standard computational algorithms .",
    "need for asymmetric walks is rare since they seem to be of limited usability in terms of computer ( or complexity theory ) applications .",
    "first of all , defining them in a suitable manner is often messy . since random walks are generated from _ edge - weighted graphs _",
    ", that means we have to be able to quickly compute values of the edge - weight function .",
    "if you define them differently that might require some considerable extra storage which has to be accessed at every turn .",
    "also , as we will shortly see , upper bounds for hitting time involve exponential functions of @xmath0 such as @xmath312 .",
    "graphs to which we apply the algorithms of this sort usually contain many thousands ( or even millions ) of vertices and edges , therefore making a @xmath312-type estimate almost absolutely useless .",
    "still , such random walks present an interesting challenge at least mathematically ; and perhaps the facts we will prove might turn out to be of some use for the algorithm theory in the future .",
    "*    now let us describe in a nutshell the very useful connection between random walks on finite graphs and electric networks .",
    "electric network @xmath313 is simply a finite connected undirected graph in which each undirected edge @xmath314}$ ] has positive _ resistance _",
    "@xmath315 ( and _ conductance _",
    "@xmath316 ) .",
    "we allow current to flow between vertices of this construct by , for example , setting voltage at vertex @xmath53 to zero , and voltage at @xmath8 to 1 .",
    "of course the current flow has to comply with basic laws of electricity such as kirchhoff s and ohm s laws . in `` physical reality '' we would select two points @xmath53 and @xmath8 and attach point @xmath53 to earth and point @xmath8 to a current source , and let the electricity flow in accordance with laws of nature .    //",
    "vertices real x0 = 20 ; real y0 = 0 ; fill(circle((x0,y0),3 ) ) ; // 0 real x1 = 100 ; real y1 = 0 ; fill(circle((x1,y1),3 ) ) ; // 1 real x2 = 180 ; real y2 = 0 ; fill(circle((x2,y2),3 ) ) ; // 2 real x3 = 100 ; real y3 = -80 ; fill(circle((x3,y3),3 ) ) ; // 3 real x4 = 180 ; real y4 = -80 ; fill(circle((x4,y4),3 ) ) ; // 4 real x5 = 260 ; real y5 = -80 ; fill(circle((x5,y5),3 ) ) ; // 4    real dx3 = ( x1-x0)/3 ; real dy3 = ( y1-y3)/3 ; real dxs = dx3/8 ; real dys = ( y3-y1)/16 ;    // edges //",
    "draw((x0 , y0 ) ",
    "( x1 , y1 ) ) ; // 0 - 1 draw((x0 , y0 )  ( x0+dx3 , y1 ) ) ; draw((x0 + 2*dx3 , y0 ) ",
    "( x1 , y1 ) ) ; real xc = x0+dx3 ; real yc = y0 ; for ( real ii = 0 ; ii < 8 ; ii = ii+1 ) if ( ii = = 7 ) dys = 0 ; draw((xc , yc ) ",
    "( xc+dxs , y0+dys ) ) ; xc = xc + dxs ; yc = y0+dys ; dys = -dys ;    //",
    "draw((x1 , y1 ) ",
    "( x2 , y2 ) ) ; // 1 - 2 draw((x1 , y1 ) ",
    "( x1+dx3 , y2 ) ) ; draw((x1 + 2*dx3 , y1 )  ( x2 , y2 ) ) ; xc = x1+dx3 ; yc = y1 ; dys = ( y3-y1)/15 ; for ( real ii = 0 ; ii < 8 ; ii = ii+1 ) if ( ii = = 7 ) dys = 0 ; draw((xc , yc ) ",
    "( xc+dxs , y0+dys ) ) ; xc = xc + dxs ; yc = y0+dys ; dys = -dys ;    //",
    "draw((x3 , y3 ) ",
    "( x4 , y4 ) ) ; // 3 - 4 real dxs = dx3/8 ; draw((x3 , y3 ) ",
    "( x3+dx3 , y3 ) ) ; draw((x3 + 2*dx3 , y4 )  ( x4 , y4 ) ) ; xc = x3+dx3 ; yc = y3 ; dys = ( y3-y1)/15 ; for ( real ii = 0 ; ii < 8 ; ii = ii+1 ) if ( ii = = 7 ) dys = 0 ; draw((xc , yc )  ( xc+dxs , y3+dys ) ) ; xc = xc + dxs ; yc = y3+dys ; dys = -dys ;    //",
    "draw((x4 , y4 )  ( x5 , y5 ) ) ; // 4 - 5 real dxs = dx3/8 ; draw((x4 , y4 )  ( x4+dx3 , y4 ) ) ; draw((x4 + 2*dx3 , y4 ) ",
    "( x5 , y5 ) ) ; xc = x4+dx3 ; yc = y4 ; dys = ( y3-y1)/15 ; for ( real ii = 0 ; ii < 8 ; ii = ii+1 ) if ( ii = = 7 ) dys = 0 ; draw((xc , yc )  ( xc+dxs , y4+dys ) ) ; xc = xc + dxs ; yc = y4+dys ; dys = -dys ;    //draw((x1 , y1 ) ",
    "( x3 , y3 ) ) ; // 1 - 3 draw((x1 , y1 )  ( x3 , y1-dy3 ) ) ; draw((x3 , y3+dy3 )  ( x3 , y3 ) ) ; xc = x1 ; yc = y1-dy3 ; dxs = ( x1-x0)/15 ; dys = dy3/8 ; for ( real ii = 0 ; ii < 8 ; ii = ii+1 ) if ( ii = = 7 ) dxs = 0 ; draw((xc , yc ) ",
    "( x1+dxs , yc - dys ) ) ; xc = x1+dxs ; yc = yc - dys ; dxs = -dxs ;    // draw((x2 , y2 ) ",
    "( x4 , y4 ) ) ; // 2 - 4 draw((x2 , y2 )  ( x4 , y2-dy3 ) ) ; draw((x2 , y4+dy3 )  ( x4 , y4 ) ) ; xc = x2 ; yc = y2-dy3 ; dxs = ( x1-x0)/15 ; dys = dy3/8 ; for ( real ii = 0 ; ii < 8 ; ii = ii+1 ) if ( ii = = 7 ) dxs = 0 ; draw((xc , yc )  ( x2+dxs , yc - dys ) ) ; xc = x2+dxs ; yc = yc - dys ; dxs = -dxs ;",
    "// labels label(``**0 * * '' , ( x0 , y0 + 9 ) ) ; // 0 label(``**1 * * '' , ( x1 , y1 + 9 ) ) ; // 1 label(``**2 * * '' , ( x2 , y2 + 9 ) ) ; // 2 label(``**3 * * '' , ( x3 , y3 - 9 ) ) ; // 3 label(``**4 * * '' , ( x4 , y4 - 9 ) ) ; // 4 label(``**5 * * '' , ( x5 , y5 - 9 ) ) ; // 5    label(``a '' , ( x0 - 4 , y0 - 10 ) ) ; label(``x '' , ( x5 + 7 , y5 + 7 ) ) ;    label(``@xmath317 '' , ( x0 - 45 , y0 + 10 ) ) ; // 0 draw(box((x0 - 80,y0 ) , ( x0 - 10 , y0 + 20 ) ) , dotted ) ; label(``@xmath318 '' , ( x5 , y5 + 25 ) ) ; //",
    "4 draw(box((x5 - 35,y5 + 15 ) , ( x5 + 35 , y5 + 35 ) ) , dotted ) ;",
    "label(``@xmath319 '' , ( x0 + 40 , y0 + 20 ) ) ; // 0 - 1 label(``@xmath320 '' , ( x1 + 40 , y1 + 20 ) ) ; // 1 - 2 label(``@xmath321 '' , ( x1 - 20 , y1 - 42 ) ) ; // 1 - 3",
    "label(``@xmath322 '' , ( x2 + 20 , y2 - 42 ) ) ; // 2 - 4 label(``@xmath323 '' , ( x3 + 40 , y3 - 20 ) ) ; //",
    "3 - 4 label(``@xmath324 '' , ( x4 + 40 , y4 - 20 ) ) ; // 4 - 5    // big fat label with arrows label(scale(1.5)*``@xmath325 '' , ( x0 - 40 , y3 - 50 ) ) ; draw(box((x0 - 120,y3 - 80 ) , ( x1 - 40 , y3 - 15 ) ) , dashed ) ; draw((x0 - 30 , y3 - 15 )  ( x1 - 5 , y1 - 12 ) , arrow = arcarrow(simplehead ) , dashed ) ; draw((x1 , y1 )  ( x1 , y1 - 18 ) , arrow = arrow(texhead ) ) ; real thk = 0.6 ; filldraw((x1-thk , y1 ) ",
    "( x1-thk , y1 - 20 )  ( x1+thk , y1 - 20 )  ( x1+thk , y1 )  cycle , black ) ;    it turns out that if we define transition probabilities for edges of @xmath313 in the following way @xmath326 ( that is , we are using conductances of the edges as their `` weights '' ) then the resulting random walk is very `` intimately '' connected with properties of the underlying electric network @xmath313 .",
    "namely , when voltages at @xmath53 and @xmath8 are fixed as described above they uniquely determine voltages in all other points of the network , and voltage @xmath327 in vertex @xmath34 equals probability @xmath328 that random walk starting in vertex @xmath34 will pass through vertex @xmath8 before reaching @xmath53 .",
    "many other interesting facts follow .",
    "for instance , stationary probability distribution @xmath329 for this random walk can be computed as @xmath330 ( see @xcite , or @xcite ) .",
    "the statement about voltages @xmath327 can be proved using function @xmath331 and checking that it complies with harmonicity equations [ eq : omega ] for vertices different from @xmath53 and @xmath8 while vanishing in @xmath53 and @xmath8 . from",
    "that it easily follows that @xmath266 .",
    "this is the same approach ( employing discrete harmonic functions on @xmath313 without calling them that ) which we already used before in the proof of theorem [ thm : fg1 ] .",
    "more on the harmonic functions on graphs can be read in @xcite or @xcite .",
    "some well known properties of finite electric networks can be applied to prove various facts about random walks . among such properties is raleigh s monotonicity law ( increasing some edge resistances in electric network can only increase effective resistances between any two points ) and some of its corollaries .",
    "one of them states that cutting an edge ( with the network staying connected ) can only increase all effective resistances in the network .",
    "the other one says that replacing vertex @xmath8 with two vertices @xmath332 and @xmath333 connected by edge @xmath334}$ ] ( with some positive resistance ) with some of the edges @xmath335}$ ] being `` moved '' to @xmath332 ( turning into @xmath336}$ ] ) and some  to @xmath333 ( @xmath335}$ ] becomes @xmath337}$ ] ) , also can only increase the resistance values .",
    "vice versa , shrinking any edge @xmath208}$ ] into one vertex @xmath43  with corresponding changes in adjacency and incidence  can only decrease remaining effective resistance values ( and therefore , increase conductance ) .",
    "*    we will use two simple functions of two variables @xmath0 and @xmath338 , where @xmath0 will later represent the number of edges in the graph , and @xmath338 will represent walk s asymmetry @xmath309 .",
    "@xmath339 where @xmath340 , @xmath341 , @xmath342 . both @xmath343 and @xmath344",
    "are integer polynomials of @xmath338 with coefficients which are integer polynomials of @xmath0 .",
    "we will need the following easily deducible properties of functions @xmath343 and @xmath344 .",
    "a.   both functions are positive and monotonically increasing for @xmath345 and @xmath346 ; [ itm : fp_mono ] b.   @xmath347 for @xmath348 ; [ itm : fp_fsump ] c.   @xmath349 for @xmath350 ; [ itm : fp_sum ] d.   @xmath351 . [ itm : fp_pnext ]    now let us begin with path tree @xmath98 .",
    "we denote probability of moving left ( away from @xmath100 ) for vertex @xmath102 as @xmath352 and probability of moving right ( toward @xmath100 ) as @xmath353 , where @xmath354 . in other words , @xmath355 and @xmath356 .",
    "[ prop : pt_ineq ] for any random walk on @xmath98 the inequality for maximum hitting time @xmath357 holds true .    without loss of generality",
    "we can assume that absorbing vertex @xmath53 coincides with @xmath100  that is , with the rightmost end of the path tree .",
    "then we will claim a slightly better result .",
    "namely we will prove the inequality not for the walk s asymmetry @xmath309 but for @xmath358 obviously , @xmath359 , and with function @xmath343 being monotonic this will prove the desired result .    //",
    "vertices real x0 = 0 ; real y0 = -20 ; fill(circle((x0,y0),3 ) ) ; //",
    "m real x1 = 60 ; real y1 = -20 ; fill(circle((x1,y1),3 ) ) ; // m-1 real x2 = 150 ; real y2 = -20 ; fill(circle((x2,y2),3 ) ) ; // k+1 real x3 = 210 ; real y3 = -20 ; fill(circle((x3,y3),3 ) ) ; // k real x4 = 270 ; real y4 = -20 ; fill(circle((x4,y4),3 ) ) ; // k-1 real x5 = 360 ; real y5 = -20 ; fill(circle((x5,y5),3 ) ) ; //",
    "1 real x6 = 420 ; real y6 = -20 ; fill(circle((x6,y6),3 ) ) ; // 0 draw(circle((x6,y6),5 ) ) ;    //",
    "edges draw((x0 , y0 ) ",
    "( x1 , y1 ) ) ; //",
    "m - m-1 draw((x1 , y1 ) ",
    "( x1 + 15 , y1 ) ) ; //",
    "m-1 - > ... draw((x2 - 15 , y2 )  ( x2 , y2 ) ) ; // ... - > k+1 draw((x2 , y2 ) ",
    "( x3 , y3 ) ) ; //",
    "k+1 - k draw((x3 , y3 ) ",
    "( x4 , y4 ) ) ; //",
    "k - k-1 draw((x4 , y4 ) ",
    "( x4 + 15 , y4 ) ) ; //",
    "k-1 - > ... draw((x5 - 15 , y5 ) ",
    "( x5 , y5 ) ) ; // ... - > 1 draw((x5 , y5 )  ( x6 , y6 ) ) ; // 1 - 0    //",
    "labels label(``@xmath110 '' , ( x0 , y0 + 10 ) ) ; // m label(``@xmath111 '' , ( x1 , y1 + 10 ) ) ; // m-1 label ( `` ... '' , ( x1 + 40 , y1 ) ) ; // m label(``@xmath360 '' , ( x2 , y2 + 10 ) ) ; // k+1 label(``@xmath102 '' , ( x3 , y3 + 10 ) ) ; // k label(``@xmath361 '' , ( x4 , y4 + 10 ) ) ; // k-1 label ( `` ... '' , ( x4 + 40 , y4 ) ) ; // m label(``@xmath108 '' , ( x5 , y5 + 10 ) ) ; // 1 label(``@xmath100 '' , ( x6 , y6 + 10 ) ) ; // 0    //",
    "arrows draw((x0 , y0 )  ( x0 + 15 , y0),arrow = arcarrow(simplehead ) ) ; //",
    "m - > m-1 label(``@xmath362 '' , ( x0 + 10 , y0 - 12 ) ) ; draw((x1 , y1 ) ",
    "( x1 - 15 , y1),arrow = arcarrow(simplehead ) ) ; // m-1 - > m label(``@xmath363 '' , ( x1 - 10 , y1 - 12 ) ) ; draw((x3 , y3 ) ",
    "( x3 - 15 , y3),arrow = arcarrow(simplehead ) ) ; //",
    "k - > k+1 label(``@xmath352 '' , ( x3 - 10 , y3 - 12 ) ) ; draw((x3 , y3 )  ( x3 + 15 , y3),arrow = arcarrow(simplehead ) ) ; //",
    "k - > k-1 label(``@xmath353 '' , ( x3 + 10 , y3 - 12 ) ) ; draw((x5 , y5 )  ( x5 + 15 , y5),arrow = arcarrow(simplehead ) ) ; // 1 - > 0 label(``@xmath364 '' , ( x5 + 10 , y5 - 12 ) ) ;    if we denote @xmath365 , and @xmath366 , @xmath367 then we have @xmath368    using this inequality recursively with @xmath369 , we come to our next inequality @xmath370 and then @xmath371    now we are ready to state and prove the case of an arbitrary tree .",
    "[ thm : ast1 ] for any finite tree @xmath124 with @xmath0 edges and any random walk on @xmath124 with asymmetry @xmath309 inequality @xmath372 holds true .",
    "let us fix some vertex @xmath53 . then to prove that for any vertex @xmath8 we have @xmath373 we start with performing our usual conversion to an @xmath56-walk with absorbing vertex @xmath53 .",
    "then , just as it was with theorem [ thm : st1 ] the main step in this proof is represented by the following lemma which is a generalization of lemma [ lem : tail_eq ] .",
    "[ lem : ast1_1 ] in the conditions of lemma [ lem : tail_eq ] the following inequality is true @xmath374 where @xmath375 is the number of edges in the tail @xmath376 of vertex @xmath9 .",
    "the proof is quite similar to the one of lemma [ lem : tail_eq ] .",
    "again we will do it by induction by @xmath377 .",
    "basis @xmath138 is obvious .",
    "fill(circle((-75,-20),1 ) ) ; fill(circle((-70,-20),1 ) ) ; fill(circle((-65,-20),1 ) ) ; fill(circle((-75,-40),1 ) ) ; fill(circle((-70,-40),1 ) ) ; fill(circle((-65,-40),1 ) ) ; fill(circle((-75,-60),1 ) ) ; fill(circle((-70,-60),1 ) ) ; fill(circle((-65,-60),1 ) ) ; fill(circle((-75,-80),1 ) ) ; fill(circle((-70,-80),1 ) ) ; fill(circle((-65,-80),1 ) ) ;    fill(circle((-25,-20),3 ) ) ; fill(circle((-25,-40),3 ) ) ; fill(circle((-25,-60),3 ) ) ; fill(circle((-25,-80),3 ) ) ;    draw((-25 , -20 ) ",
    "( 15 , -40 ) ) ; label(``@xmath141 '' , ( -45,-20 ) ) ; draw((-25 , -40 )  ( 15 , -40 ) ) ; label(``@xmath142 '' , ( -45,-40 ) ) ; draw((-25 , -60 )  ( 15 , -40 ) ) ;    draw((-25 , -80 ) ",
    "( 15 , -40 ) ) ; label(``@xmath143 '' , ( -45,-80 ) ) ;    draw((15 , -40 ) ",
    "( -5 , -30 ) , arrow = arcarrow(simplehead ) ) ; label(``@xmath378 '' , ( 3,-23 ) ) ; draw((15 , -40 ) ",
    "( -5 , -60 ) , arrow = arcarrow(simplehead ) ) ; label(``@xmath352 '' , ( 3,-67 ) ) ;    fill(circle((15,-40),3 ) ) ; draw((15 , -40 )  ( 55 , -40 ) ) ; draw((15 , -40 )  ( 35 , -40 ) , arrow = arcarrow(simplehead ) ) ; label(``@xmath379 '' , ( 32,-48 ) ) ;    fill(circle((55,-40),3 ) ) ; draw((55 , -40 )  ( 70 , -40 ) ) ;    fill(circle((80,-40),1 ) ) ; fill(circle((90,-40),1 ) ) ; fill(circle((100,-40),1 ) ) ; label(``@xmath9 '' , ( 15,-58 ) ) ; label(``@xmath8 '' , ( 55,-58 ) ) ;    draw((55 , -40 ) ",
    "( 75 , -10 ) ) ; fill(circle((75,-10),3 ) ) ; draw((55 , -40 )  ( 50 , -10 ) ) ; fill(circle((50,-10),3 ) ) ;    draw((125 , -40 ) ",
    "( 165 , -40 ) ) ; fill(circle((165,-40),3 ) ) ; draw((165 , -40 ) ",
    "( 205 , -40 ) ) ; fill(circle((205,-40),3 ) ) ; draw(circle((205,-40),5 ) ) ;    label(``@xmath107 '' , ( 205,-58 ) ) ; label(``@xmath108 '' , ( 165,-58 ) ) ;    let us denote transition probabilities @xmath380 as @xmath381 , and @xmath382 as @xmath379 .",
    "then ( [ eq : maineq_graph ] ) can be rewritten in the following manner @xmath383 thus @xmath384 and using induction hypothesis , properties ( [ itm : fp_sum]-[itm : fp_pnext ] ) of functions @xmath344 and @xmath343 , inequality @xmath310 and the fact that sum of @xmath385 equals @xmath386 we have @xmath387    now we can finalize the proof of theorem [ thm : ast1 ] .",
    "let us connect any vertex @xmath8 in @xmath124 with absorbing vertex @xmath53 by non - self - intersecting path of length @xmath150 indexing its vertices as @xmath107 , @xmath108 , ",
    ", @xmath388 . denoting @xmath389 as simply @xmath390 , writing out inequalities ( [ eq : tail_ineq ] ) and adding them up we have @xmath391 since numbers @xmath392 are a monotonically decreasing sequence of @xmath393 different positive integers with the largest of them no greater than @xmath0 .",
    "similarly to proposition [ prop : pt_ineq ] we have actually proved a slightly stronger fact . in a tree with one",
    "vertex @xmath53 marked ( in our case , the absorbing vertex ) for any edge @xmath394}$ ] we can define direction `` towards '' @xmath53 on it ( or alternatively , `` away '' from @xmath53 ) .",
    "graph @xmath395 has exactly two components .",
    "namely , direction on @xmath26 `` towards '' @xmath53 is direction towards that vertex out of @xmath34 and @xmath35 which lies in the same component as @xmath53 .",
    "any vertex in the tree ( except @xmath53 ) has exactly one incident edge directed _ towards _",
    "@xmath53 , all the others are pointing _ away _ from it .    if we define @xmath396 as maximum of 1 and all ratios @xmath397 between two probabilities for transition from same vertex where @xmath379 is probability of an `` away '' transition , and @xmath398  of `` towards '' transition , then it is easy to see that we have actually proved our inequality for @xmath396 instead of @xmath309 . as a nice corollary",
    "we obtain that if for any vertex its transition probability `` towards '' @xmath53 is greater than or equal to any transition probability `` away '' from @xmath53 then @xmath399 and thus we will have @xmath14 .",
    "obviously , this corollary can not be directly generalized for an arbitrary connected graph as notion of `` direction '' can not be similarly defined in a graph with cycles .",
    "we can see that polynomial @xmath343 gives us exact value of @xmath400 only in case of path graph with constant transition probabilities @xmath401 where @xmath379 is probability of transition that moves the walker away from the absorbing vertex ( which is fixed as one of the ends of the path ) , and @xmath402 .",
    "also it is easy to show that @xmath403 can be used as a much simpler but less precise upper bound for @xmath85 .",
    "*    let us move on to the general case of random walks ( possibly asymmetric ) on finite connected graphs .",
    "we will venture a guess that results similar to theorems [ thm : fg1 ] and [ thm : ast1 ] are true for any finite connected graph and any random walk defined on it .",
    "[ thm : asg1 ] for any random walk on @xmath3 with asymmetry @xmath309 inequality @xmath404 holds true .",
    "as before , we choose any vertex @xmath53 and convert our random walk into an @xmath56-walk . then , the following lemma is a straightforward generalization of lemma [ lem : sg1_1 ] .",
    "[ lem : asg1_1 ] consider absorbing vertex @xmath53 and edge @xmath186 } \\in { \\mathcal{e}}$ ] .",
    "we will consider random walk on graph @xmath187 generated from the same edge - weight function restricted to @xmath194 .",
    "then for any vertex @xmath405 @xmath406 ( in other words , removing edge @xmath407}$ ] and proportionally redistributing its transition probability between other edges coming out of @xmath8 can not decrease hitting time . )",
    "proof is almost exactly the same as for lemma [ lem : sg1_1 ] and i will skip it . of course , if @xmath34 is not in the same component of connectedness of @xmath194 as @xmath53 then we have @xmath408 and there is nothing to prove .    and",
    "we will need something similar to lemma [ lem : ast1_1 ] .",
    "the following lemma is the main hurdle in this proof .",
    "[ lem : asg1_2 ] if absorbing state @xmath53 is a pendant vertex connected only with vertex @xmath108 then @xmath409    we revert back to considering original random walk so @xmath53 is no longer an absorbing vertex .",
    "there is only one transition out of @xmath53 and @xmath410 .",
    "let us remind you that commute time @xmath411 between vertices @xmath34 and @xmath35 in graph @xmath3 is the sum of hitting times @xmath412 . since @xmath413",
    "it would suffice to prove that commute time between @xmath53 and @xmath108 is at most @xmath414 .    to do that we will use electric network approach",
    "described earlier in this section . the following result for commute time",
    "is proved in @xcite ( theorem 2.2 , case of trivial cost function ) : for any two vertices of @xmath4 we have equality @xmath415 where @xmath416 is effective resistance between vertices @xmath34 and @xmath35 , and @xmath417 where sum is taken over the set @xmath418 of all directed edges ( so each undirected edge @xmath36}$ ] gives us two terms  for @xmath419 and @xmath420 ) .    from equation ( [ eq : ctfres ] ) we have @xmath421 since @xmath422 , and @xmath423 because these two vertices are connected by one edge of resistance 1 with no other edges coming out of @xmath53 .",
    "now all we need is to prove that @xmath424 or , switching from directed edges to undirected @xmath425    consider any two incident edges @xmath36}$ ] ( or @xmath426}$ ] ) and @xmath427}$ ] .",
    "ratio of their weights ( conductances ) is the same as ratio @xmath428 which is bounded from above by @xmath309 . thus if @xmath429 then conductance of @xmath36}$ ] can not be greater than @xmath430 , which together with monotonicity of function @xmath431 proves the required inequality .",
    "this also proves that it turns into equality only for a path graph .",
    "once again we will make use of induction by the number of edges .",
    "basis case @xmath432 is obvious .",
    "now we do more or less the same as in theorem [ thm : sg1 ] .",
    "connect vertex @xmath8 with absorbing vertex @xmath53 by any path @xmath171 and let @xmath108 be next to last vertex of @xmath171 . remove all edges out of vertex @xmath53 except for @xmath216}$ ] one by one and adjust the walk accordingly as shown in lemma [ lem : asg1_1 ] .",
    "the lemma guarantees us that for this new graph @xmath194 we have @xmath433 . thus proving our inequality for @xmath194 will prove it for the original graph @xmath3 , because both number of edges and @xmath309 have not increased when we switched from @xmath3 to @xmath194 .    //",
    "ellipsis real xp = 80 ; real yp = -20 ; fill(circle((xp , yp),1 ) ) ; fill(circle((xp+10,-20),1 ) ) ; fill(circle((xp+20,-20),1 ) ) ;    //",
    "vertices real x0 = xp+45 ; real y0 = yp ; real x1 = xp+60 ; real y1 = yp+25 ; real x2 = xp+20 ; real y2 = yp-15 ; real x3 = xp+85 ; real y3 = yp ; real x4 = xp+125 ; real y4 = yp ; real x5 = xp-20 ; real y5 = yp ; real x6 = xp+30 ; real y6 = yp-30 ; fill(circle((x0 , y0),3 ) ) ; fill(circle((x1 , y1),3 ) ) ; fill(circle((x2 , y2),3 ) ) ; fill(circle((x3 , y3),3 ) ) ; fill(circle((x4 , y4),3 ) ) ; fill(circle((x5 , y5),3 ) ) ; fill(circle((x6 , y6),3 ) ) ; draw(circle((x4 , y4),5 ) ) ;    // ellipse draw(ellipse((xp+20 , yp ) , 80 , 60 ) ) ; label ( `` '' , ( xp-10 , yp+40 ) ) ;    //",
    "edges draw((x0 - 15 , y0 )  ( x0 , y0 ) ) ; //",
    "draw((x1 , y1 ) ",
    "( x3 , y3 ) ) ; draw((x2 , y2 )  ( x3 , y3 ) ) ; draw((x0 , y0 )  ( x3 , y3 ) ) ; draw((x3 , y3 )  ( x4 , y4 ) ) ; draw((x5 , y5 )  ( x5 + 15 , y5 ) ) ; draw((x2 , y2 ) ",
    "( x6 , y6 ) ) ; draw((x3 , y3 )  ( x6 , y6 ) ) ; draw((x4 , y4 ) ",
    "( x1 , y1 ) , dotted ) ; draw((x4 , y4 ) ",
    "( x6 , y6 ) , dotted ) ; draw((x6 , y6 ) ",
    "( x6 - 5 , y6 - 13 ) ) ; draw((x2 , y2 ) ",
    "( x2 - 15 , y2 - 3 ) ) ; draw((x1 , y1 )  ( x1 - 12 , y1 + 5 ) ) ; draw((x1 , y1 )  ( x1 - 15 , y1 - 5 ) ) ; draw((x1 , y1 )  ( x1 + 5 , y1 + 15 ) ) ;    // labels label(``@xmath108 '' , ( x3 - 5 , y3 - 15 ) ) ; label(``@xmath53 '' , ( x4 , y4 - 15 ) ) ; label(``@xmath8 '' , ( x5 , y5 - 15 ) ) ;    let us denote @xmath434 by @xmath220 and set @xmath108 as absorbing vertex .",
    "then as we already know , solution of system ( [ eq : maineq_graph ] ) for @xmath220 is the same as solution for @xmath194 from which @xmath435 is subtracted .",
    "since by induction hypothesis we have @xmath436 then from lemma [ lem : asg1_2 ] we have that @xmath437",
    "finally , here is our strongest result that generalizes almost all of the previous ones . in a way it would have been simpler to simply state it in the very beginning ,",
    "prove it and be done .",
    "however , as it was already mentioned before , i do not favor such an approach .",
    "[ thm : fsgc ] for any random walk on @xmath438 with asymmetry @xmath309 and any non - negative edge - cost function @xmath28 inequality @xmath439 holds true for any vertices @xmath440 .",
    "using @xmath441-functions ( see proof of theorem [ thm : fg1 ] ) we can reformulate this theorem s statement as the following inequality : @xmath442 .",
    "now all we need is an inequality similar to lemma [ lem : sb_ineq ] .",
    "[ lem : asb_ineq ] for any vertex @xmath276 function @xmath277 satisfies the following inequality @xmath443 where @xmath444 and @xmath445 is transition probability along any edge @xmath208}$ ] such that @xmath446 .",
    "here is the plan : there exists path @xmath447 $ ] of length @xmath150 connecting vertices @xmath8 and @xmath53 which begins with edge @xmath208}$ ] .",
    "following exactly same reasoning as in lemma [ lem : sg1_1 ] , we can claim that removal of all edges coming out of @xmath53 except for @xmath216}$ ] does not decrease values of function @xmath277 , and does not increase the value of @xmath309 .",
    "therefore , we can assume that @xmath53 is a pendant vertex and thus @xmath448 where @xmath449 is @xmath441-function for graph @xmath450 .",
    "thus we can replace @xmath3 with @xmath220 , use inequality [ eq : sb ] for @xmath220 ( induction by @xmath150 ) and try to get an upper bound for @xmath451 .",
    "let s go ahead and execute this plan .    //",
    "main variables real xp = 0 ; real yp = 0 ;    //",
    "vertices real bx = xp-65 ; real by = yp+5 ; real cx = xp-50 ; real cy = yp-15 ; real dx = xp-25 ; real dy = yp-25 ; real ex = xp ; real ey = yp+5 ; real fx = xp+20 ; real fy = yp-40 ;    real a2x = xp+55 ; real a2y = yp+10 ; real a1x = xp+85 ; real a1y = yp ; real ax = xp+125 ; real ay = yp ;    fill(circle((bx , by),3 ) ) ; fill(circle((cx , cy),3 ) ) ; fill(circle((dx , dy),3 ) ) ; fill(circle((ex , ey),3 ) ) ; fill(circle((fx , fy),3 ) ) ;    fill(circle((a2x , a2y),3 ) ) ; fill(circle((a1x , a1y),3 ) ) ; fill(circle((ax , ay),3 ) ) ; draw(circle((ax , ay),5 ) ) ;    // ellipse draw(ellipse((xp-10 , yp ) , 110 , 50 ) ) ; label ( `` '' , ( xp-5 , yp+35 ) ) ;    //",
    "`` random '' edges draw((bx , by )  ( bx+7 , by+10 ) ) ; draw((bx , by )  ( bx-3 , by+12 ) ) ; draw((bx , by )  ( bx-17 , by+2 ) ) ; draw((bx , by )  ( bx-25 , by-12 ) ) ;    draw((a1x , a1y ) ",
    "( a1x-2 , a1y+13 ) ) ; draw((a1x , a1y )  ( a1x-20 , a1y-3 ) ) ;    // path edges draw((bx , by )  ( cx , cy ) ) ; draw((cx , cy ) ",
    "( dx , dy ) ) ; draw((dx , dy )  ( ex , ey ) ) ; draw((ex , ey )  ( fx , fy ) ) ; draw((fx , fy )  ( a2x , a2y ) ) ;    draw((a2x , a2y )  ( a1x , a1y ) ) ; draw((a1x , a1y )  ( ax , ay ) ) ;    //",
    "labels real lby = 12 ; label(``@xmath8 '' , ( bx , by - lby ) ) ; label(``@xmath9 '' , ( cx , cy - lby ) ) ;    label(``@xmath108 '' , ( a1x-5 , a1y - lby ) ) ; label(``@xmath53 '' , ( ax , ay - lby ) ) ;    first , we will use induction by @xmath150 . if @xmath452 then @xmath8 is adjacent to @xmath53 ( thus @xmath453 ) .",
    "therefore after removing all other edges coming out of @xmath53 we have @xmath454 since obviously @xmath455 , we have @xmath456 proving the basis of induction .",
    "second , to prove induction step from @xmath457 to @xmath458 we need to find some upper bound for @xmath459 .",
    "let us define @xmath460 as sum of weights for all edges coming out of vertex @xmath8 .",
    "second , if for every directed edge @xmath37 of graph @xmath3 we write product @xmath461 next to that edge then sum of all these numbers is zero .",
    "but if we group them by the start vertex then for every vertex @xmath34 we will have the sum of the numbers in that group @xmath462 which is zero for every vertex other than @xmath53 and @xmath8 . adding up all these grouped expressions we obtain @xmath463 and @xmath464    using @xmath465 we get @xmath466 because distance between edges @xmath208}$ ] and @xmath216}$ ] is @xmath467 and thus their weights ratio is at most @xmath468 .",
    "finally for any @xmath193 we have @xmath469 proving the induction step as well .",
    "now let s assume that edge @xmath26 connects vertices @xmath9 and @xmath43 , and @xmath470 .",
    "we have then only two possible cases ( there are actually three cases but two of them are symmetric and without loss of generality we can discard one of them ) .",
    "thus @xmath472 and @xmath473 .",
    "let @xmath338 be any neighbor of @xmath43 such that it is closer than @xmath43 to vertex @xmath53 .    //",
    "main variables real [ ] px = -115,-60,-25,20,55,85,125 ; real [ ] py = 5,-15,-20,-10,10,-5,0 ; //",
    "vertices int [ ] idxs = 0,1,2,3,4,5,6 ; for ( var ii : idxs ) fill(circle((px[ii ] , py[ii]),3 ) ) ; //",
    "path edges int [ ] idxs1 = 0,1,2,3,4,5 ; for ( var jj : idxs1 ) draw((px[jj],py[jj])(px[jj+1],py[jj+1 ] ) ) ; //",
    "labels real dy = 12 , dx = 4 ; label(``@xmath9 '' , ( px[0 ] , py[0]-dy ) ) ; label(``@xmath43 '' , ( px[1 ] , py[1]-dy ) ) ; label(``@xmath338 '' , ( px[2 ] , py[2]-dy ) ) ; label(``@xmath53 '' , ( px[6 ] , py[6]-dy ) ) ; label(``@xmath26 '' , ( ( px[0]+px[1])/2+dx , ( py[0]+py[1])/2+dy/2 ) ) ;    from lemma [ lem : asb_ineq ] we have @xmath474 and so @xmath475    case 2 . @xmath476 .",
    "let s choose any vertex @xmath34 adjacent to @xmath9 and vertex @xmath35 adjacent to @xmath43 such that @xmath477 and @xmath478 .    //",
    "main variables real [ ] px = -115,-50,-25,14,55,125 ; real [ ] py = -5,-15,-13,33,10,5 ; real [ ] qx = -130,-60,-27,14,75,125 ; real [ ] qy = 45,25,43,33,40,5 ; int [ ] idxs = 0,1,2,3,4,5 ; int [ ] idxs1 = 0,1,2,3,4 ; // a  x path //",
    "vertices for ( var ii : idxs ) fill(circle((px[ii ] , py[ii]),3 ) ) ; //",
    "path edges for ( var ii : idxs1 ) draw((px[ii],py[ii])(px[ii+1],py[ii+1 ] ) ) ; // a  y path // vertices for ( var ii : idxs ) fill(circle((qx[ii ] , qy[ii]),3 ) ) ; // path edges for ( var ii : idxs1 )",
    "draw((qx[ii],qy[ii])(qx[ii+1],qy[ii+1 ] ) ) ; // one more edge ( xy ) draw((px[0 ] , py[0 ] ) ",
    "( qx[0 ] , qy[0 ] ) ) ; //",
    "labels real dy = 12 , dx = 8 ; label(``@xmath9 '' , ( px[0 ] , py[0]-dy ) ) ; label(``@xmath34 '' , ( px[1 ] , py[1]-dy ) ) ; label(``@xmath43 '' , ( qx[0 ] , qy[0]+dy ) ) ; label(``@xmath35 '' , ( qx[1 ] , qy[1]+dy ) ) ; label(``@xmath53 '' , ( px[5 ] , py[5]-dy ) ) ; label(``@xmath26 '' , ( ( px[0]+qx[0])/2+dx , ( py[0]+qy[0])/2 ) ) ;    again we have @xmath479 and @xmath480 which concludes the proof .",
    "a simpler case of this problem ( see theorem [ thm : sg1c ] ) was posed to me as a conjecture sometime around february 20 , 2016 by my old friend and colleague alexey kirichenko , and author wants to thank him for the opportunity to engage in fruitful discussions about some issues in computational complexity , graph theory and markov chains , as well as for his enduring friendship and readiness to help out whenever i needed an advice .    now for scientific motivation .",
    "this issue comes from an old and very important complexity theory question about an algorithm with limited memory to determine whether two vertices @xmath40 and @xmath41 in any given finite undirected graph @xmath3 can be connected with a path .",
    "theory that investigates this is called _",
    "s - t connectivity _ where `` s '' and `` t '' come from conventional names ( `` source '' and `` target '' ) for two vertices of the given graph which in this article we usually called @xmath8 and @xmath53 .",
    "complexity of s - t connectivity for directed graphs is called stcon , and for undirected graphs  ustcon .",
    "it is known that stcon is * nl*-complete , that is , a non - deterministic turing machine with log - space memory can provide the next step for the algorithm which will eventually build the desired path ( if the graph is connected ) .",
    "ustcon was shown to be * l*-complete ( see @xcite ) , meaning that it can be solved by a deterministic turing machine using logarithmic amount of memory .",
    "the connectivity problem becomes much easier if we decide to make do with an _ heuristic _ ; in other words if we attempt to come up with an algorithm that determines `` probability '' of @xmath53 and @xmath8 being connected in @xmath3 within some preset tolerance @xmath481 .",
    "for instance , we could be satisfied if after the algorithm is run we can claim we know whether @xmath53 and @xmath8 are connected or not with probability greater than 0.999 ( @xmath482 ) .",
    "now imagine that we know that the expected length of a simple random walk on @xmath3 with absorbing state vertex @xmath53 is less than some specific number @xmath483 .",
    "simulating a random walk on graph @xmath3 requires only finite memory ( basically , we only need to store current location of the walker , and some trivial fixed overhead such as the number of steps and ids of our two vertices ) and if starting from @xmath8 we havent reached vertex @xmath53 after @xmath484 moves , we can stop the simulation and `` claim '' that probability that @xmath53 and @xmath8 are connected is below @xmath485 ( by markov s inequality , see @xcite ) .",
    "we then repeat this @xmath484-steps - long walk @xmath486 times .",
    "if @xmath53 was never reached , then probability drops below @xmath487 and we can consequently state ( with the required level of confidence ) that @xmath53 and @xmath8 are not connected .    usually a researcher proves a `` big @xmath488''-type of asymptotic upper bound and stops there , since from the point of view of computational complexity theory the job is done  many statements of this type can be found in classical work by aleliunas et al , @xcite .",
    "this approach is fine for pure theoretical purposes , but it is not applicable for the situation that i have just described above because we need to simulate random walk with a specific number of steps . therefore having an upper bound of , say , @xmath489 or @xmath490 is not very useful for real - life computer - based implementation .",
    "also most of the existing estimates and results on maximum ( and average ) hitting time are based on the number of graph s vertices @xmath33 ( see a survey of many such results in @xcite ) . in this article",
    "we have proved some upper bounds for maximum hitting time as functions of graph s number of edges @xmath0 and showed that most of these upper bounds are sharp .",
    "if graph is `` sparse '' , which in our case means that @xmath491 , then this type of upper bound will likely be better than the upper bounds based on @xmath33 , such as a well - known theorem from @xcite stating that the maximum hitting time is less than or equal to approximately @xmath492 . among such graphs",
    "are sub - graphs of @xmath51-dimensional grid where @xmath51 is some `` small '' number , or generally any graphs with vertex degrees bounded from above by some fixed number which is sufficiently small compared to @xmath33 .",
    "r.  aleliunas , r.m .",
    "karp , r.j .",
    "lipton , l.  lovasz , c.w .",
    "rackoff ( 1979 ) , `` random walks , universal travelling sequences , and the complexity of maze problems '' , proc .",
    "20th ann . symp . on foundations of computer science , pp.218223 .",
    "chandra , p.  raghavan , w.l .",
    "ruzzo , r.  smolensky , p.  tiwari ( 1996 ) , `` the electrical resistance of a graph captures its commute and cover times '' , computational complexity , december 1996 , volume 6 , issue 4 , pp.312340 ."
  ],
  "abstract_text": [
    "<S> we obtain upper bounds ( in most cases , sharp ) for the hitting times of random walks on finite undirected graphs . </S>",
    "<S> in particular , we show that the maximum hitting time for a simple random walk on a connected graph with @xmath0 edges is at most  @xmath1 . </S>",
    "<S> similar bounds are given for the settings involving arbitrary edge - weight and edge - cost functions .    </S>",
    "<S> upper bounds of this type are especially useful for sparse graphs . </S>"
  ]
}