{
  "article_text": [
    "in this section , we review the notion of context - sensitive parsing ( [ csp ] ) , describe how we tackle it through recall and stateful parsing ( [ recall ] ) , and situate our implementation ( [ impl ] ) .    in what follows ,",
    "we use the term _ parser _ to refer to any unit of functionality that can match some input text ( both at the the lexical and grammatical levels ) and produce a result based on this match .",
    "we assume that simple parsers can be combined into increasingly complex parsers .",
    "true context - sensitive parsing is seldom applied to programming languages .",
    "writing context - sensitive grammars can prove challenging , for instance the grammar for the language @xmath0 is notoriously tricky  @xcite .",
    "in addition , most language features can be adequately expressed using the much more tractable context - free grammars .",
    "nevertheless , many mainstream languages exhibit context - sensitive features . here are a few examples :    * in c , in order to determine whether the statement ` x*y ; ` is the product of @xmath1 by @xmath2 , or rather the declaration of a variable @xmath2 which is a pointer to type @xmath1 , one must analyze the type definitions preceding the statement . * in haskell and standard ml , programmers can introduce operators with custom precedence and associativity .",
    "the parser needs to interpret these definitions in order to be able to parse the remainder of the input . *",
    "since python has significant indentation , a python parser needs to detect when the indentation level increases or decreases . * in xml ,",
    "opening tags must be matched with corresponding closing tags .",
    "for instance , ` <",
    "foo></foo > ` is valid while ` < foo></bar > ` is not . as such",
    ", an xml parser must memorize the names of open tags , at arbitrary levels of nesting .",
    "* many network protocols , including tcp , make use of length - delimited fields whose length is not known in advance but indicated by a length field that precedes them .",
    "most parsing tools can not adequately handle these syntactic peculiarities , leading to all sorts of hacks , and sometimes to the rejection of parsing tools altogether .",
    "there are a few exceptions however , which we review in section  [ related ] .",
    "section  [ challenges ] deals with the key properties almost all these solutions lack , namely _",
    "context transparency _ , hence calling for a new solution .",
    "while context sensitivity was first characterized by chomsky  @xcite , his context - sensitive grammars ( csg ) are only of little help , due to the intricate coding that they require .",
    "a csg is made of rewrite rules @xmath3 where @xmath4 and @xmath5 are strings of mixed terminals and non - terminals .",
    "these rules must be non - contracting : @xmath5 , as a string of symbols , must not be shorter than @xmath4 . as a matter of fact",
    ", these grammars were never meant to describe programming languages , but natural languages , where the shape of the rules make much more sense .",
    "in particular , it is difficult to encode _ recall _ constraints : for instance , requiring the same string of tokens to appear at two different locations in the sentence ( assuming the string is not fixed in advance ) .",
    "we propose instead to approach context sensitivity through the notion of _ recall _ , i.e. the ability to accept sentences based on relationships between some of their parts .",
    "this is more easily understood in parsing terms as the capability to make parsing decisions based on previously matched input .",
    "we enable recall by allowing users to write parsers which can manipulate mutable state .",
    "however , unlike solutions deployed by existing parsing tools such as antlr  @xcite and rats !",
    "@xcite , we are _ principled _ about state use . indeed , parsing algorithms do not proceed linearly . when faced with a choice , they may speculatively try an alternative , and need to backtrack if this alternative does not succeed .",
    "when backtracking happens , all changes made to the state during the speculative execution need to be reversed .",
    "parsers may also memoize the result of a speculative execution . in a stateful model ,",
    "these results need to include the state changes incurred by the execution . as will be explained in section [ stateful - parsing ] ,",
    "we satisfy these requirements by introducing primitive operations to manipulate mutable state in a principled way .",
    "we implement our stateful parsing approach as a peg - like  @xcite ( top - down recursive descent ) functional - style   parser - combinator library named _ autumn _ , which can be used with java , kotlin , and other java - compatible languages .",
    "implementation details are given in section  [ implementation ] and a detailed use case is worked out in section  [ usecase ] .",
    "as the problem of context - sensitive features in programming languages is not new , it is not surprising that several solutions have been proposed .",
    "we review these solutions in order to better put our contributions in perspective .",
    "we do not purport to review the entire body of work on context - sensitive parsing , but only the approaches closest to our goal .",
    "in particular , we left out the literature on context - sensitive lexical analysis ( e.g. , @xcite ) which by definition only handles a small subset of all context sensitivity issues .",
    "parsing with backtracking semantic actions  @xcite is an approach that extends a ( general ) backtracking lr parser with reversible semantic actions . upon backtracking ,",
    "state changes are reversed .",
    "two important restrictions apply : state changes can only occur during term reduction , and the state can only affect the parse through semantic conditions that trigger backtracking .    compared to our approach , the difference in implementation ( top - down recursive versus lr ) has far - reaching consequences . backtracking semantic actions reverse state changes rather than making snapshots of the state .",
    "accordingly it becomes impossible to compare state snapshots .",
    "these capabilities are very useful in the context of peg parsing , as they enable the definition of custom parsers , left - recursion and memoization ; but less so within an lr system where custom parsers can not be defined .",
    "we also believe our _ top - down recursive - descent _ model to be more intuitive in the presence of state . logically , state changes occur as parser are invoked , from left to right and from top to bottom .",
    "backtracking semantic actions , on the other hand , are executed upon term reduction .",
    "this means that a parser may modify the state before other parsers that matched input on its left .    despite these caveats , we consider parsing with backtracking semantic actions  @xcite to be the safest and most convenient system for context - sensitive parsing among those presented in this section .",
    "jim et al .",
    "@xcite proposed data - dependent grammars , a formalism which permits context sensitivity by allowing rules to be parameterized by semantic values . a parameterized nonterminal appearing on the right - hand side of a rule acts as a form of function call that also returns a semantic value .",
    "these semantic values are computed by _ semantic actions _ written in a general - purpose programming language .",
    "there are also _ semantic predicates _ which can make grammar branches succeed or fail depending on a semantic value .",
    "data - dependent grammars can be compiled to a format accepted by a target parsing tool , which must support fairly general semantic actions . in subsequent work",
    "@xcite , the authors introduced a new kind of automaton that can be used to implement parsers recognizing data - dependent grammars .",
    "these techniques are put to work in a tool called yakker .",
    "data - dependent grammars , though theoretically compelling , suffer from usability issues .",
    "the value - passing model means that the parse state needs to be threaded throughout the grammar . making a rule dependent on a new semantic value",
    "means that all rules through which this rule is reachable might need to be modified to pass this value around .",
    "maintainability - wise , this is far from ideal .",
    "moreover , it harms composability , as a rule must be aware of all states it has to pass through .",
    "afroozeh and izmaylova  @xcite show how advanced parser features such as lexical disambiguation filters , operator precedence , significant indentation and conditional preprocessor directives can be translated to data - dependent grammars . quite clearly , the task is non - trivial and one comes away with the feeling that dependent grammars are better suited as an elegant calculus to be targeted by parsing tool writers rather than as a paradigm that fits the needs of tool users .",
    "the machinery implementing the formalism is also distinctively non - trivial , involving a multi - stage transformation into a continuation routine or into a new kind of automaton .",
    "in contrast , our approach consists of a lightweight library that can be layered on top of a general - purpose programming language .",
    "finally , we note that the much older definite clause grammars ( dcgs )  @xcite formalism works on almost exactly the same principle , but building upon logic programming .",
    "accordingly , it suffers from similar limitations .",
    "monadic parsing  @xcite is a well - known way to build functional - style parser - combinator libraries , made popular by haskell libraries such as parsec  @xcite .",
    "in this paradigm , the type of a parser is a function parameterized by a result type , i.e. with signature @xmath6 , where the parameter string is the input text and the returned string is the input remaining after parsing .",
    "the parser type is also a monad instance , meaning there is a ` bind ` function whose signature , in haskell notation , is :    ` parser r1 - > ( r1 - > parser r2 ) - > parser r2 ` + where ` r1 ` and ` r2 ` are result types .",
    "this function takes a parser as first parameter , and a function which transforms the result of the parse into another parser as second parameter .",
    "when invoked , the parser returned by ` bind ` will invoke the first parser , pass its result ( of type ` r1 ` ) to the function , then invoke the parser this function returns , yielding a result of type ` r2 ` .",
    "the important point about monadic parsers is that they can handle context sensitivity .",
    "indeed , the second parameter to ` bind ` ( the function ) returns a parser from a result .",
    "this means that the behaviour of the parser returned by ` bind ` depends on data acquired during the parse : this is a form of _",
    "recall_.    an in - depth analysis of this aspect was done by atkey  @xcite . in particular",
    ", he formalizes monadic parsers by introducing _ active right - hand sides _ , which are the right - hand sides of rules that can contain monadic combinators .",
    "these combinators generate grammar fragments at parse - time ( much like a monadic parser generates a new parser ) , hence the term _",
    "while monadic parsing seems at first sight very similar to the data - dependent grammars from section  [ yakker ] , atkey  @xcite carefully contrasts the two approaches :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ we characterise their [ jim et al . ]",
    "approach as refining context - free grammars : each yakker grammar has an underlying context - free grammar with regular right - hand sides , and the constraints allow for sophisticated data - dependent filtering of parses .",
    "in contrast , we consider active right - hand sides that generate the grammar as the input is read . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    nevertheless , monadic parsers suffer from the same pitfalls as data - dependent grammars : the state is threaded through the grammar ( or code ) , leading to poor maintainability and composability",
    ".      attribute grammars  @xcite associate attributes to ast nodes ( assuming an ast node per matched grammar rule ) .",
    "the attributes can be synthesized : their value derived from the attributes of subnodes , or inherited : their value computed by a parent node .",
    "the formalism supports context - sensitive parsing through production guards predicated over attributes .",
    "however , attribute grammars are not context - transparent .",
    "to enable recall , they need to propagate the recalled value from the definition site to the use site , through a chain of of synthesized and inherited attributes .",
    "even reference attributed grammars  @xcite , which allow attributes to contain references to nodes , do not fully solve this distribution problem .",
    "manipulating parse - wide state can be an effective solution to the problem of data dependence : the data depended upon can be written in the state when encountered and read or even altered later on .    broadly speaking , we can distinguish two big classes of stateful parsing tools . first , there are parser combinator libraries that allow users to write their own subparsers .",
    "notable examples include parboiled  @xcite , lua peg  @xcite and scala s parser combinators  @xcite .",
    "since these custom parsers are implemented in a general - purpose programming language , they can manipulate state , even though the libraries make no provision for this .",
    "second , there are parsing tools that provide very general semantic actions and semantic predicates .",
    "notable examples include bison  @xcite and antlr  @xcite .",
    "these work much like their counterpart in yakker ( cf .",
    "section  [ yakker ] ) , except that instead of returning a value , semantic actions may modify a global state object .",
    "unfortunately , most parsing tools in both categories do not make the necessary provisions for dealing with backtracking and memoization : if the parser backtracks over a construct that made state changes ( semantic action or custom parser ) , these changes need to be undone ; if the parser can memoize the result of a construct , state changes need to be memoized as well . in the absence of such guarantees ,",
    "a construct can only access state which it is sure has not been corrupted by changes that should have been discarded .",
    "it must also be sure that some state - altering construct was not skipped due to memoization .",
    "these are tricky propositions to verify even for medium - sized grammars , and every change to the grammar threatens to falsify them .",
    "one may think that solving the backtracking problem is simply a matter of inserting a construct that reverses state changes whenever a rule fails .",
    "however , a rule can be backtracked over even if it succeeded .",
    "it suffices that one of the rules through which our rule was reached fails .",
    "hence this scheme would entail , for each state - altering construct , the modification of every rule through which it can be reached .      rats !",
    "@xcite is a fully - memoizing ( _ packrat _ ) peg parser .",
    "rats ! is , to the best of our knowledge , the only stateful parsing tool that provides some guarantees for state usage , by ensuring that state changes are discarded if certain conditions are met .    for this purpose , rats !",
    "transactions _ that wrap rules under which state changes might occur .",
    "a transaction can either succeed , in which case its state changes are retained , or fail , in which case the changes are discarded .",
    "rats ! also requires that a nonterminal invoked at a given position within a transaction must always modify the state in the same way , no matter how that nonterminal was reached . combining transactions with this requirement",
    "ensures that rats ! will never have to discard the memoization of a rule , hence upholding the linear - time guarantee of packrat parsers .    in spite of its advantages ,",
    "this scheme has two important pitfalls .",
    "first , it requires nonterminal invocations at a given position to always return the same result .",
    "this precludes parsing expressions that modify the behaviour of the parsing expression they invoke . however , this capability is valuable in practice .",
    "for example , we use it to enable left - recursion handling in our library ( cf . section  [ leftrec ] ) .",
    "second , state changes are not memoized .",
    "if a rule succeeds after applying a state change , but the enclosing transaction fails , the changes are lost .",
    "if we wanted to call the rule at the same position again , the memoized result would be used and it does not include the state changes .",
    "this means that a state change can not safely be referenced by two different transactions , and that transactions can not be re - tried after a state change higher up in the grammar hierarchy .",
    "as the previous section has shown , enabling the definition of context - sensitive languages without jeopardizing maintainability , composability or even safety is no easy feat .",
    "we put forward the notion of _ context transparency _ as the gold standard that a context sensitive parsing mechanism needs to meet in order to be considered sufficiently practical .",
    "a grammatical construct is * context - transparent * if it is unaware of the context shared between its ancestors and its descendants .",
    "data - dependent grammars , monadic parsers , dcgs and attribute grammars are not context - transparent because of the need to explicitly pass values around . for instance , consider two data - dependent grammars : a grammar for a python - like language with significant indentation , in which the rules for block - level constructs ( statements , definitions ) are paremeterized by the indentation level ; and a grammar for a generic macro definition language ( e.g. , gnu m4 ) .",
    "we want to compose these two languages such that macro definitions may appear anywhere where definitions can appear in our python - like language .",
    "additionally , we want macro bodies to include python - like code .",
    "the issue is that the rules in the macro language grammar know nothing about indentation level , yet the indentation level needs to be shared between the block holding the macro definition and the python - like code appearing inside macro definitions . in this case , the lack of context transparency would force us to rewrite all rules in the macro language grammar to carry around the indentation level .",
    "stateful parsers also are not context - transparent , as they must ensure that no unforeseen backtracking or memoization takes place .",
    "for instance , if a parser @xmath7 manipulates the state and its callers do not expect it to backtrack , it can not be swapped for a parser @xmath8 ( where @xmath9 is some parser combinator ) without first ensuring that @xmath8 never backtracks over @xmath7 .",
    "lack of context - transparency makes grammars hard to reason about , hence hard to write and to maintain : refactoring , extending or composing grammars becomes particularly challenging , because each change to a rule might entail the need to modify all rules through which it is ( transitively ) reachable . in stateful parsers ,",
    "such changes are liable to introduce undesired backtracking or memoization .",
    "we suggest a simple solution : use stateful parsing ( which does not thread context through the grammar ) , but undo state changes upon backtracking and allow the memoization of state changes . and to achieve this , we introduce a new context sensitivity handling discipline : _ principled _ stateful parsing .",
    "in section  [ intro ] , we established the relevance of context - sensitive parsing and introduced the notion of _ recall _ as a way to express context - sensitive features in terms of backreferences to previously matched input .",
    "we enable recall by storing the matched input ( or data derived thereof ) in a mutable data store : the _ parse state_. this section expounds how _ principled stateful parsing _ is able to work with parse state while avoiding the usual pitfalls of stateful parsing ( cf .",
    "sections  [ stateful ] and [ challenges ] ) .      before diving into a formal explanation , we present the remarkably simple intuition behind the approach .",
    "the point of using state is to pass context around implicitly , without the need to hardwire context in the grammar , hence achieving context transparency ( cf .",
    "section [ challenges ] ) .",
    "if the execution of a parser were linear , simply reading / writing to this state would suffice .",
    "unfortunately , parsers must sometimes perform speculative executions that may fail further down the line , a phenomenon called backtracking .",
    "when backtracking occurs , all state changes in the speculative execution being backtracked over must be reversed .",
    "hence , we need an operation that can take a * snapshot * of the state at a given point , and an operation that can * restore * the state described by such a snapshot .    given these requirements , it helps to think of the parse state as a log of the operations applied to the state , which can be snapshot and rolled back as required .",
    "appropriately , this is also how we formalize the parse state .",
    "additionally , it is sometimes desirable to save the result of a speculative execution ( whether it failed or not ) , i.e. , the state changes it induced : a _ delta _ acquired by performing a * diff * between the states before and after the execution .",
    "it is also necessary to be able to * merge * these changes back into the state .",
    "the most straightforward application of the _ diff _ and _ merge _ capabilities is the memoization of parse results .",
    "however , other valuable use cases exist , such as longest - match parsing and left - recursive parsing ( see section  [ leftrec ] ) .",
    "this motivates the need for four primitive state - manipulation operations : * snapshot * , * restore * , * diff * and * merge*. these operations are described in section [ operations ] .    *",
    "principled stateful parsing * is an approach where parsers behave transactionally : each parser invocation either succeeds or leaves the state untouched .",
    "additionally , it is possible to generate and merge deltas corresponding to state changes made by parser invocations .",
    "all this is made possible through the use of formally specified state manipulation operations .",
    "we formalize our approach using the z notation  @xcite , though eschewing its schema calculus in favor of a purely functional presentation .",
    "the z notation is a formal specification language that builds on top of zermelo - frankel set theory , first - order logic and simply typed lambda calculus . as such ,",
    "z can be seen as a language where functions can be defined in lambda calculus extended with predicates from first - order logic and set theory .",
    "formal assertions over the functions can be made using the same notation .",
    "we also note that in z , all types used in the lambda calculus are sets .    since we adopt the functional parser - combinator approach ( cf .",
    "section  [ intro ] ) , parsers are simply functions manipulating parse state ( section  [ pstate ] ) whose set - theoretic signature is given in section  [ parsers ] .",
    "section  [ operations ] formally specifies the primitive state - manipulation operations that were briefly introduced in section [ intuition ] .",
    "finally , section  [ call ] gives the semantics of parser invocation by specifying the @xmath10 operation , which maps a parser ( as defined in [ parsers ] ) to a single state transformation .      at the core of our approach",
    "lies the notion of parse state .",
    "the parse state abstracts over a general mutable data store .",
    "we do not place any constraint on the data within the store .",
    "this is formalized as follows .",
    "[ change ] + state = change    the square brackets introduce the abstract set @xmath11 of all state changes .",
    "what exactly constitutes a state change ( most likely the mutation of a memory location ) is an implementation concern that is not relevant to the formalization .",
    "@xmath12 is the set of possible parse states : i.e. , of possible configurations of our mutable store .",
    "we represent a parse state as a sequence of state changes .",
    "this means that a state can be seen as a log of the operations over the mutable store it represents , assuming some well - defined initial state .    in z , the set of sequences of items from the set @xmath13",
    "is written @xmath14 and corresponds to the powerset of pairs @xmath15 , or equivalently to the powerset of partial functions @xmath16 . in each sequence , the indices are unique and consecutive .    in practice , an implementation of the approach will want to use parse state to reify important parsing notions , such as input position .",
    "we consciously avoided making our formalism needlessly specific , hence the absence of some usual parsing notions such as input position .",
    "this enables using our approach to parse non - linear inputs ( e.g. , object graphs ) , or perform computations that only bear nominal resemblance to traditional parsing , even though this direction is outside the scope of the current paper .",
    "a parser represents a computation over the parse state that either succeeds or fails , and has side effects on the parse state , in the form of _ state changes _ , as introduced in the previous section .",
    "transform = state state + parser = state transform + result : : = success | failure + result : state parser result    formally , a parser is a function from a state  the current state at the time of invocation  to a sequence of transformations , which move from one state to another . this amounts to defining a parser in terms of its execution trace .",
    "two things seem to be missing from this definition .",
    "first , it does not say if the parse succeeds when run over a specific state .",
    "this property is exposed separately through the @xmath17 predicate rather than as part of the @xmath18 signature .",
    "this approach is not significant : it simply makes the math look nicer .",
    "second , the input being parsed does not explicitly appear in the signature .",
    "instead , the input is assumed to be held within the parse state .",
    "a parser is a recognizer of states .",
    "it accepts states for which @xmath19 holds .",
    "if within the input state one dissociates the _ parse input _ from the rest of the state ( the _ context _ ) , one can see that the parser recognizes  hence also defines  different languages depending on the context .",
    "but a parser is also a transformer of states as well : when invoked it performs a @xmath20 transformation . in section [ call ]",
    "we explain how to derive this transformation from a parser ( recall that parsers have type @xmath18 defined as @xmath21 ) , as a means of defining the semantics of a parser given its execution trace .",
    "we could alternatively have defined @xmath18 as @xmath22 ( with the result being the composition of the transformations in the sequence ) , or directly as @xmath20 .",
    "we chose to emphasize the execution trace  a sequence of transformations  instead , because the primitive state operations described in the next section are suppliers of such transformations , to be composed to yield the transformation performed by the parser .",
    "this representation also emphasizes that the parse state is both an input of the parser and an input of the returned transformations .",
    "this reflects the fact that a parser is context - sensitive : it chooses which operation to perform depending on the state .",
    "this is closely related to the notions of active right - hand sides @xcite and monadic parsing @xcite .",
    "in fact , each operation in the sequence is chosen depending on the state obtained by running the initial state through the composition of all preceding transformations .",
    "abstracting over this makes the specification much simpler , without altering its meaning .",
    "we now present six primitive operations ( amongst which the four announced in section  [ intuition ] ) that parsers can perform .",
    "snapshot = change + delta = change +   + call : parser transform + snapshot : state state + diff : snapshot state delta + applychange : change transform + restore : snapshot transform + merge : delta transform    [ [ call ] ] call + + + +    of these six , @xmath10 has a special status : it represents the invocation of a parser",
    ". we will define this operation in section [ call ] , hence specifying the semantics of parsers given their execution trace .",
    "note that the signature definition of @xmath10 expands to @xmath23 : a parser must be called with a state as parameter .    [",
    "[ snapshot ] ] snapshot + + + + + + + +    a snapshot , as the name implies , is a capture of the state at a specific point during the execution .",
    "naturally , this makes @xmath24 , the set of all snapshots , equivalent to @xmath12 .",
    "formally , the @xmath25 operation , which creates such a capture , is simply the identity function .",
    "snapshot = x : state @ x    [ [ diff ] ] diff + + + +    the @xmath26 operation returns a @xmath27 object representing the difference between a snapshot and the current state , as a set of state changes . as a precondition",
    ", this operation requires the snapshot it receives to be a prefix of the current state .",
    "this is expressed with the z built - in @xmath28 infix operator . by keeping the deltas append - only , we ensure that a delta can be later _ merged _ to any state , not just the one corresponding to the snapshot .",
    "sn : diff @ st :   ( diff  sn ) @ + sn  prefix  st    since deltas are state suffixes , @xmath27 , the state of all deltas , is equivalent to @xmath12 .",
    "assuming the precondition is respected , @xmath26 can be defined as the remainder of the current state after chopping off the prefix corresponding to the snapshot . in z , the @xmath29 function packs the indices ( left - hand side ) of a set of pairs in @xmath30 , where @xmath13 is some set , in order to turn this set into a proper sequence .",
    "for instance , it turns @xmath31 to @xmath32 .",
    "diff = sn : snapshot @ st : state @ + squash   ( st sn )    [ [ transformations ] ] transformations + + + + + + + + + + + + + + +    all operations except @xmath26 and @xmath25 return a transformation .",
    "recall that we defined @xmath18 as @xmath33 .",
    "the transformations returned by the operations are precisely those which will be part of a parser s execution trace . @xmath26 and @xmath25 are different because they do not modify the parse state . instead , @xmath26 and",
    "@xmath25 create new objects , which can be freely passed through the parse state .",
    "[ [ applychange ] ] applychange + + + + + + + + + + +    the @xmath34 operation is very simple : given a change , it simply returns a transformation that applies this change , by appending it to the change log .",
    "it can be defined as follows , using the concatenation operator ( @xmath35 ) to append the change to the old log .",
    "applychange = c : change @ st : state @ + st c    this `` operation '' models the fact that parsers can perform arbitrary state changes .",
    "[ [ restore ] ] restore + + + + + + +    the @xmath36 operation takes a snapshot as input and returns a transformation that brings the state to that described by the snapshot .",
    "restore = sn : snapshot @ st : state @ sn    [ [ merge ] ] merge + + + + +    the @xmath37 operation takes a delta as input and returns a transformation that appends this delta to the input state .",
    "merge = d : delta @ st : state @ st d      we now look at how the transformation returned by the @xmath10 operation can be derived from the execution trace returned by a parser . recall that the @xmath10 operation s signature is @xmath38 .",
    "we start by defining two helper functions .",
    "@xmath39 maps sequences of transformations of length @xmath40 to a sequence of length @xmath41 similar to the input sequence , but where the first two items have been replaced by their composition ( @xmath42 and @xmath43 access the first two items of @xmath44 while @xmath45 is the relational composition operator ) .",
    "@xmath46 takes a natural @xmath47 and a sequence of transformations and returns the composition of its @xmath47 first items , or the identity transformation if @xmath48 .",
    "this is achieved by iteratively running the sequence through @xmath39 , using the z built - in @xmath49 operator .",
    "composetwo = s : transform @ + s   1 s   2 tail   ( tail  s ) + reducen = n : @ s : transform @ +   ( n = 0 )    state +   iter   ( n - 1 )   composetwo  s  1 +    with this in place , we define the result of @xmath10 as the composition of all transformations within the call s execution trace , assuming the parser invocation is successful .",
    "otherwise , the identity transformation is returned .",
    "the hash sign ( @xmath50 ) is an operator returning the cardinality of a set .",
    "call = p : parser @ st : state @ +   ( result  st  p = success ) +   reducen   ( # p  st )   ( p  st )   st +   st",
    "we implemented the _ principled stateful parsing _",
    "approach in a general - purpose parsing library called _ autumn_. it is freely available online  @xcite .",
    "autumn is implemented in kotlin , an up - and - coming jvm language that closely matches java s semantics while reducing boilerplate .",
    "kotlin possesses many features that make it particularly well suited for writing domain - specific languages ( dsls ) , an ability we exploit to define grammars .",
    "we will introduce these features as we encounter them .",
    "our approach is not language - specific and can easily be ported to other languages .",
    "we start by exposing the fundamentals of the autumn api and how it relates to our formalization ( section  [ autumn - api ] ) .",
    "we then show the api in action on a simple example ( section  [ parser - example ] ) .",
    "finally we discuss how the api enables simple left - recursion handling ( section  [ leftrec ] ) .",
    "in this section , we review how our implementation relates to our formalization of principled stateful parsing ( section [ stateful - parsing ] ) .",
    "figure [ key - types ] shows the key interfaces and classes in our implementation .",
    ".... interface parser {      fun parse ( ctx : context ) : result }    sealed class result {    object success : result ( )    open class failure ( val pos : int , val msg : string )      : result ( ) }    class context ( input : string ,                 vararg states : state < * , * > ) {    var pos : int = 0    val text : string = input + ' \\u0000 '    fun < t : state < * , * > > state(klass : class < t > ) : t { ... }      fun snapshot ( ) : snapshot { ... }    fun restore(snap : snapshot ) { ... }    fun diff(snap : snapshot ) { ... }    fun merge(delta : delta ) { ... }      ... }    class snapshot { ... } class delta { ... }    interface state < snapshot , delta > {    fun snapshot ( ) : snapshot    fun restore(snap : snapshot )    fun diff(snap : snapshot ) : delta    fun merge(delta : delta ) }    abstract class grammar {    open val whitespace : parser      = zeromore(charpred(char::iswhitespace ) )    open val root : parser    open val requiredstates : list < state < * , * > = emptylist ( )    ... } ....    * parser * we represent a parser by an instance of the ` parser ` interface .",
    "implementers must override the ` parse ` method , which takes a ` context ` as parameter and returns a ` result ` : either a ` success ` or a ` failure ` which holds the position at which the failure occurred , together with a diagnostic message .",
    "it can also hold custom diagnostic information through subclassing of ` failure ` .",
    "this gives a lot of control over the error messages that will be shown to the user .",
    "* context * each parse  the invocation of a parser on a complete piece of input text  has an associated ` context ` object .",
    "the role of this object is to hold the state for the parse .",
    "the context is passed down to parsers during parser invocation , so that all parsers may access it .",
    "using a context object rather than global state allows multiple parses to co - exist , potentially in parallel .    the mutable store mentioned in the formalization",
    "is represented as a collection of singleton classes implementing the ` state ` interface .",
    "parsers can retrieve a state instance by calling the ` state ` method with the proper class object .",
    "note that the state held by the context also includes the input text and the input position , although , as a special provision , these can be accessed directly through the ` text ` and ` pos ` properties respectively .",
    "* state * the ` state ` interface has four methods : ` snapshot ` , ` restore ` , ` diff ` and ` merge ` , corresponding to the four key operations introduced in section [ intuition ] , but only locally for the ` state ` instance itself . to get the parse - wide semantics of section [ stateful - parsing",
    "] , we aggregate the state operations over all ` state ` instances .",
    "this is achieved through the methods in the ` context ` class that mimic the ` state ` interface .",
    "these methods manipulate the ` snapshot ` and ` delta ` classes ( not to be confused with the eponymous type parameters of interface ` state ` ) , which aggregate ` state`-level snapshots and deltas .    in our formalization",
    ", we represented the mutable store as a log of all operations over the store . in practice , this might not be a good idea , as parsers must compute using the state , meaning the `` current state '' would need to be re - derived from the whole log at least every time backtracking happens , unless all operations were fully reversible .",
    "the approach we took instead was to give maximum implementation flexibility to the programmer : he can choose , for each ` state ` instance , the most appropriate strategy to create snapshots and deltas , as well as to restore / merge them back in .",
    "maintaining a log of reversible operations is only one possibility among many .    however , having the programmer implement the ` state ` interface for each data structure he wishes to manipulate would be tedious and repetitive .",
    "hence , we supply base implementations for common use cases , such as :    * ` copystate ` : for states that are records containing just a few fields , which we can afford to copy every time , and which can be treated as a unit ( i.e. , a delta can not represent that a field changed while the others retained their previous value  the value of every field is systematically captured ) . * ` stackstate ` : represents a stack as a singly linked list ( which is naturally immutable ) .",
    "snapshots and deltas are represented as nodes in the list .",
    "the list is treated as a unit .",
    "* ` monotonicstack ` : similar to ` stackstate ` , but adds the restriction that ` diff ` must only be called with a snapshot that is a suffix of the current stack .",
    "deltas are then prefixes of the stack and can be grafted back at a later time , allowing for granular change handling . * ` mapstate ` : represents a map as an immutable hash array map trie ( hamt )  @xcite .",
    "our implementation is based on that of steindorfer and vinju  @xcite which ensures good performance .",
    "the map is treated as a unit . * ` inertstate ` : represents state that does not change during the parse , or whose change is not significant ( e.g. , logging logic ) .",
    "all operations are implemented as no - ops .",
    "* grammar * programmers must subclass the ` grammar ` class in order to define a new grammar .",
    "when doing so , they must define the root parser by overriding ` root ( ) ` , and provide any required ` state ` instances by overriding ` requiredstates ( ) ` . `",
    "grammar ` also defines a default ` whitespace ` parser which consumes any number of characters matching the java ` char::iswhitespace ` predicate .",
    "parser combinator libraries traditionally struggle with the definition of recursive parsers : it is forbidden to write [ ` val a = seq ( ... , a ) ` ] because ` a ` is not defined yet when it is evaluated on the right - hand side . using the ` grammar ` initialization logic ,",
    "we can replace the recursive reference to ` a ` with the [ ` ! a ` ] operator - overloading syntax : [ ` val a = seq ( ... , !",
    "this creates a stub parser which will be patched with a reference to ` a ` at parse - time . to achieve this , the ` grammar ` class maps names to parsers through reflection over its ` parser`-valued fields .",
    "autumn enforces the _ principled stateful parsing _ guarantees , but only if its interfaces are implemented correctly .",
    "in particular :    * each implementation of ` parser ` must either succeed or undo all the state changes it incurred .",
    "this is usually achieved through the use of ` snapshot ( ) ` and ` restore ( ) ` . *",
    "each implementation of ` state ` must implement its operations according to the specification given in section [ stateful - parsing ] .      as an illustration , figure  [ seq - parser ] shows the implementation of one of the most fundamental parser combinators , the sequential composition of parsers .",
    "the resulting parser calls its subparsers sequentially , succeeding if they all succeed .",
    "if one of them fails , the parser reverts the state to its initial condition .    ....",
    "class seq ( vararg children : parser ) : parser(*children ) {    override fun _",
    "parse_(ctx : context ) : result {      val snapshot = ctx.snapshot ( )      for ( child in children ) {        val r = child.parse(ctx )        if ( r is failure ) {          ctx.restore(snapshot )          return ctx.failure      }    }      return success }    } ....      when a parser invokes itself ( either directly or indirectly through intermediate parsers ) without intervening state changes , the result is an infinite loop of parser invocations .",
    "this is a well - known problem of top - down recursive parsers , called _ left - recursion_. fortunately , it can be mitigated as follows : start by running the left - recursive parser while failing all left - recursive invocations , then re - run it , using the result of the initial parse as the result of all left - recursive invocations .",
    "repeat until as much input as possible has been matched .",
    "refer to our earlier paper  @xcite for more details .",
    "interestingly , this strategy can be implemented entirely within the stateful parsing paradigm . in particular , when we speak of _ result of a parse _ , we are really referring to a _ delta _ of the parse state .",
    "these deltas need to be stored in the parse state , so that they can be retrieved by left - recursive invocations .",
    "we also need to track , within the state , which left - recursive parsers have been invoked at which input position , so that we may recognize left - recursive invocations .",
    "recognizing left - recursive invocations is the task of a dedicated parser that must be wrapped around all left - recursive parsers .",
    "we do so by annotating recursive parsers with the ` ! ` operator .",
    "since left - recursion requires recursive references ( cf .",
    "section  [ autumn - api ] ) , we can easily check that all such parsers have been properly annotated : a missing annotation will result in an unresolved reference instead of a mystifying infinite loop .",
    "in this section , we demonstrate the stateful parsing approach with a realistic use case , using our autumn library .",
    "we implement a parser for a simple , yet non - trivial , statically - typed , object - oriented programming language , which we call _ examply_. this imaginary language draws inspiration from java ( its main unit of definition is the class ) , kotlin ( its postfix type notation and closure notation ) and python ( significant indentation ) .",
    "its full grammar , written with autumn , can be found online  @xcite .",
    "examply possesses two common context - sensitive features :    * * significant whitespace *  indentation is significant : like python , the language does not use curly braces or keywords to delimit blocks of code such as loop or function bodies . instead",
    ", these constructs expect to have their body indented with respect to their first line .",
    "similarly , a decrease in indentation signifies the end of the block .",
    "newlines are also significant , as they are used to separate successive statements and declarations .",
    "* * namespace classification *  the parser needs to know which identifiers refer to types . in our language",
    ", this is needed because there is an ambiguity between the syntax of function calls  which can receive a closure parameter as an indented block  and the syntax of anonymous classes : + .... val a = myfunction ( )      myfunction2 ( )    val b = myclass ( )      var x : int      fun foo ( ) { ... } .... + the body of a class only admits declarations , while the block part of a function call admits all statements ( including declarations ) .",
    "these two constructs result in different nodes being added to the abstract syntax tree ( ast ) produced by the parse .",
    "we now explain how examply handles significant whitespace .",
    "the code enabling this feature is shown in figure  [ indent - code ] .",
    "the usual whitespace handling strategy is to assume that every parser consumes its trailing whitespace through invocation of the ` whitespace ` parser .",
    "to do so , it is only necessary to ensure that all `` primitive '' parsers ( fullfilling what is traditionally the role of lexical analysis : matching identifiers , literals , keywords and operators ) consume their trailing whitespace : then all parsers will do so by transitivity .",
    "the ` grammar ` class provides some support for this , including lexical analysis emulation ( not demonstrated in this paper ) , and the [ ` + lit ` ] syntax which evaluates to a parser matching a literal string and any trailing whitespace .",
    "ultimately , this leads to an important guarantee : all parsers are invoked at an input position where no leading whitespace is present .    in order to handle significant whitespace",
    ", we maintain two data structures .",
    "the first one , ` indentmap ` , maps line numbers to two quantities : the input position at which the indentation ends on that line , and the indentation count , which is obtained by expanding tabs to tab stops aligned to multiples of 4 .",
    "the second data structure , ` indentstack ` , is a stack that stores the indentation counts for all enclosing blocks .",
    "` context.indent ` and ` context.istack ` are extension properties for the ` context ` class and provide syntactic sugar to access the indentation count on the current line , and the indentation stack , respectively .",
    "we build ` indentmap ` at the beginning of the parse , through the invocation of the ` buildindentmap ` parser .",
    "this does not require any special tricks : each parser has access to the whole input ( ` ctx.text ` ) .",
    "the parser does not advance the input position ( ` ctx.pos ` ) , so that subsequent parsers are free to proceed .    within the grammar , we use the ` indent ` parser to require an indented block , and the ` dedent ` parser to test for the end of an indented block .",
    "the implementation of these parsers is straightforward . `",
    "indent ` checks if the current line is indented with respect to the indentation of the current block ( the top of ` indentstack ` , initialized to 0 ) .",
    "if so , it succeeds after pushing the new indentation count onto the stack .",
    "` dedent ` checks to see if the indentation count of the current line is less than that of the current block , or if we have reached the end of the input .",
    "if so it succeeds , after popping the previous count from the stack .    finally ,",
    "the ` newline ` parser succeeds if and only if it is invoked at the end of the indentation on the current line or at the end of the input .",
    ".... data class indententry ( val count : int , val end : int )    class indentmap : inertstate < indentmap > {    lateinit var map : map < int , indententry >    fun get(ctx : context ) : indententry =      map[ctx.linemap.linefromoffset(ctx.pos ) ] ! ! }    class indentstack : stackstate < int > ( )    val context.indent : indententry    get ( ) = state(indentmap::class).get(this ) val context.istack : indentstack    get ( ) = state(indentstack::class )    val buildindentmap = parser { ctx - >    val map = hashmap <",
    "int , indententry > ( )    var pos = 0    ctx.text.split('\\n').foreachindexed { i , str - >      val wspace = str.takewhile {        it = = ' ' || it = = ' \\t ' }      val count = wspace.wspace.expandtabs(4).length      map.put(i , indententry(count , pos + wspace.length ) )      pos + = str.length + 1    }    ctx.state(indentmap::class).map = map    success }    val indent = parser { ctx - >    val new = ctx.indent.count    val old = ctx.istack.peek ( ) ? : 0    if ( new > old ) success after { ctx.istack.push(new ) }    else ctx.failure {      \" expecting indentation > $ old positions \" } }    val dedent = parser { ctx - >    val new = ctx.indent.count    val old = ctx.istack.peek ( ) ? : 0    if ( new < old || ctx.pos = = ctx.text.length - 1 )      success after { ctx.istack.pop ( ) }    else ctx.failure {      \" expecting indentation < $ old positions \" } }    val newline = predicate {    indent.end = = pos || ctx.pos = = ctx.text.length - 1 } ....      examply needs to distinguish between types ( i.e. , class names ) and other identifiers at parse - time , in order to resolve ambiguities .",
    "we call this process _ namespace classification _ : we want to know whether an identifier belongs to the namespace of types or not .",
    "such parse - time tracking is reminiscent of the c language , and is seldom seen in modern languages . in examply , we could avoid it by adding a keyword ( e.g. , ` new ` ) to disambiguate constructor invocation from function invocation .",
    "or we could perform ast - disambiguation passes after parsing .",
    "we stress that examply is designed to showcase the strength of the principled stateful approach , and notably its ability to deal with the quirks of existing languages .    to understand the logistics of namespace classification , we must first define how our imaginary language handles type references :    1 .",
    "types are always referenced through a single identifier , except within imports where they are preceded by a package string .",
    "2 .   a class name can only be referenced after or within its definition .",
    "3 .   a class definition can appear anywhere other declarations can : at the top - level , within another class , or within a code block .",
    "class definitions are lexically scoped : a class has access to all imported classes and to all classes defined before it within one of its outer scopes ( class body or code block ) .",
    "a class has access to all classes defined within its superclass and other ancestors .",
    "a class can not inherit from one of its outer classes .",
    "7 .   in order to avoid ambiguous type names ( for instance , both",
    "a class defined in an outer class and a class defined in a superclass could bear the same name ) , examply features type aliases that assign an alternate name to an existing type .",
    "type aliases can appear anywhere a class definition can appear , and have the same visibility as class definitions .    figure  [ type - code ] shows the code handling namespace classification .",
    "we do not engage with its minutiae , but instead give a high - level description of its operation .",
    "the code itself should demonstrate that the implementation of these ideas is terse and readable , even to those who ignore the precise semantics of some operations .",
    "we note however that in the code , ` ctx.stack ` refers to the stack used to construct ast nodes .",
    "we occasionally peek in this stack in order to retrieve identifiers .",
    "the main data structure is the ` typestack ` ` state ` instance .",
    "it holds a stack of ` type`s , which are pairs formed by a string and a list of other ` type`s .",
    "intuitively , each ` type ` instance represents a class name alongside with a list of classes accessible through it : its inner classes and the inner classes of its ancestors .",
    "we call these classes the _ private classes _ of a class : they cease being accessible once the class definition ends .",
    "we define two helper functions over the type stack : ` istype ` checks if an identifier refers to a type , and ` priv ` returns the private classes of the named class , or an empty list if no such class exists .",
    "each time we encounter a new type during the parse , it is pushed onto the type stack .",
    "this is the the task of the ` newtype ` parser , which is applied to identifiers introduced by classes and type aliases .",
    "a parameter controls whether the new type is an alias , in which case it inherits the private classes of the aliased class .",
    "note that classes start with an empty list of private classes .",
    "this will be updated once the class definition is complete .",
    "once a scope ( a class body , or some code block ) is exited , the types introduced within it are not longer accessible . to enforce this",
    ", we use the ` scoped ` parser : it saves the type stack size , invokes its child parser ( corresponding to a scope ) , then removes any extraneous items from the type stack .",
    "if the scoped body was a class body , the ` type ` representing the class on the stack must be updated with a list of its private classes , so that an inner class may access them .",
    "this is the role of the ` classdef ` parser .",
    "it looks up the class and superclass names on the ast stack , then looks up the list of private classes of the superclass .",
    "if found , this list is pushed on the type stack .",
    "all of this is done after taking a snapshot of type stack .",
    "subsequently , the ` body ` parser is invoked and , if successful , a delta of the type stack is generated using the snapshot .",
    "this delta corresponds to the private classes of the class , including those introduced by its superclass .",
    "the snapshot is restored and the topmost entry on the type stack ( which represents the class ) is removed and replaced with a new one that binds the class name to its private classes .",
    "a reduced version of this process also needs to happen for anonymous classes : they need to access their superclass private classes , but no ` type ` record must be created for them .",
    "the ` anonclassinherit ` parser fullfills this role , by reusing the ` inherit ` function .",
    "finally , to resolve the ambiguity , we use the ` classguard ` parser : it performs a lookahead , attempting to match an identifier , and succeeding only this identifier refers to a type .",
    "we defer our assessment of the approach until section  [ discussion ] .",
    ".... data class type ( val name : string , val priv : linklist < type > ) class typestack : monotonicstack < type > ( ) val context.types : typestack      get ( ) = state(typestack::class )    fun istype(ctx : context , iden : string ) : boolean    = ctx.types.stream().any { it.name = = iden }    fun priv(ctx : context , iden : string ) : linklist < type >    = ctx.types.stream ( )      .filter { it.name = = iden }      .next ( ) ? .priv ? : linklist ( )    fun newtype ( child : parser , alias : boolean = false ) = parser { ctx - >",
    "child.parse(ctx ) anddo {        val name = ctx.stack.peek ( ) as string        val priv = if ( alias ) priv(ctx , name )                   else linklist ( )        ctx.types.push(type(name , priv ) )    } }    fun scoped(body : parser ) = parser { ctx - >    val size = ctx.types.size",
    "body.parse(ctx ) anddo { ctx.types.truncate(size ) } }    fun inherit(ctx : context , name : string )    = priv(ctx , name).stream().each { ctx.types.push(it ) }    fun classdef ( body : parser ) = parser { ctx - >      val parent = ctx.stack.at(0 ) as maybe < simpletype >      val name = ctx.stack.at(1 ) as string      val snapshot = ctx.types.snapshot ( )      if ( parent is some < simpletype > )        inherit(ctx , parent.value.name )      body.parse(ctx ) anddo {        val diff = ctx.types.diff(snapshot )        ctx.types.restore(snapshot )        ctx.types.pop ( )        ctx.types.push(type(name , diff ) ) } }    val anonclassinherit = perform { ctx - >    inherit(ctx , ctx.stack.at(1 ) as string ) }    val classguard = seq(iden , predicate { ctx - >    istype(ctx , ctx.stack.peek ( ) as string ) } ) .ahead ....      to illustrate the use of significant whitespace and namespace classification ( as presented in sections [ whitespace ] and [ nstrack ] ) , let s look at two short examples .",
    "first , here is how we define an indented code block :    .... val statements =     seq(indent , scoped(!\"statement \" until dedent ) )        .collect < stmt > ( ) ....    the block starts by an increase in indentation ( ` indent ` ) , and ends when a decrease in indentation is encountered ( ` dedent ` ) , parsing statements in the mean time ( ` ! statement until dedent ` ) .",
    "the ` collect ` part instructs the parser to collect all statement nodes pushed onto the ast stack and to aggregate them in a list , which is itself pushed onto that stack .",
    "we also see that all indented statements form a scope ( ` scoped ` ) in the sense of section  [ nstrack ] .",
    "second , here is how the parser for `` block constructors '' ( i.e. , anonymous classes ) is defined :    .... val blockctorbody = scoped(seq(anonclassinherit , decls ) ) val blockctor    = seq(classguard , iden , paramlist , blockctorbody )      .build { ctorcall(get ( ) , get ( ) , get ( ) ) } ....    the parser is simply guarded with the ` classguard ` parser , which checks if there is an identifier at the current input position , and whether this identifier refers to a type .",
    "the body of the class can access the superclass private classes through ` anonclassinherit ` .",
    "the ` scope ` wrapper ensures that this access is restricted to the class and does not spread to the code that follows . `",
    "decls ` refers to an indented block of declarations .",
    "we have implemented two context - sensitive features in for an imaginary but non - trivial programming language . with the code",
    "we have shown so far , the rest of the grammar is trivially able to define code delimited by changes in indentation , or by newlines ( section  [ whitespace ] ) ; or to direct the parse depending on whether an identifier refers to a type ( section  [ nstrack ] ) .    all this , by itself , is no mean feat .",
    "there are few parsing tools where this is possible to begin with ( most of them are presented in section  [ related ] ) .",
    "significant indentation handling , in particular , is non - trivial because autumn does not include a lexical analysis layer out of the box .",
    "we also underline that the presented implementations are rather terse , less than 50 lines of code each .",
    "some of that does come from our choice of implementation language , but it also shows that the principled stateful parsing approach does not impose a significant boilerplate overhead .",
    "in particular , the ability to reuse state - handling strategies , such as ` monotonicstack ` means that _ context - transparency _ comes almost for free .",
    "the state manipulations operations from sections  [ intuition ] and  [ operations ] are strangely discreet in our examples .",
    "significant whitespace handling does not use them at all , while namespace classification performs a ` diff ` in order to capture the types introduced by a class body .",
    "but because they do not appear in the code does not mean the operations are not used , they are simply hidden from view .",
    "the basic contract of principled stateful parsing is that each parser either succeeds or leaves the state untouched .",
    "you can convince yourself that all the parsers and parser combinators we introduced satisfy this condition , either by reusing existing combinators , or by delegating the responsibility for this to their single subparser .",
    "it remains that the parsers we introduce do get backtracked over during the parse .",
    "as such , their state mostly get saved and restored by other parsers that invoke them , directly or indirectly .",
    "it is in fact crucial for the state to get restored when backtracking occurs : we need to know the correct indentation level whenever we backtrack out of a block ; we also need to know which identifiers are classes , even when backtracking over a type definition .",
    "granted , given that most constructs in the grammar are guarded by specific keywords , such backtracking occurences should be rare .",
    "however , unlike the other , often _ accidentally _ stateful parsers ( cf .",
    "section  [ related ] ) , context transparency ensures that we can evolve the grammar as we see fit , without fear of breaking the mechanisms we just introduced .",
    "it is also a pre - requisite for safe grammar composition .",
    "in fact , the scarcity of state operations is a boon : it means that the benefits of our approach come at very little cost , at least implementation - wise .",
    "we would also disabuse the reader of the notion that the autumn codebase hides some devilish complexity in order to make up for this : the whole library  @xcite is less than 2500 lines of code .",
    "all pre - defined parsers live in a single file of less than 500 lines .",
    "this file defines around 50 parsers : those corresponding to all basic peg  @xcite operators , as well as numerous extensions , notably to work with error messages , ast nodes , ...      performance has not been our focal point , but preliminary testing seems to indicate that performance is within an order of magnitude of mainstream parsing tools such as rats !",
    "@xcite and parboiled  @xcite for context - free grammars .",
    "the implementation currently incurs overhead even for context - free grammars , which we are working to reduce .",
    "the overhead scales with the amount of state in use , depending on the ` state ` implementation details .",
    "the costly operations are the creation of snapshots and deltas . in general ,",
    "memory allocations tend to be the bottleneck , so increased sharing between snapshots results in better performances .",
    "indeed , we ve had success with purely functional data structures  @xcite .",
    "just like peg parsing without full memoization , parsing has exponential complexity in the worst case .",
    "in practice however run times are acceptable , as programming language grammars are fairly deterministic .",
    "in this paper , we proposed an approach to tackle the problem of context - sensitive parsing .",
    "our solution , unlike existing ones , possesses the property of _ context transparency _ : grammatical constructs are unaware of the context shared between their ancestors and their descendants , making it easier to write , evolve and compose context - sensitive grammars .",
    "we proceeded in two parts .",
    "first , we allowed parsers to manipulate a mutable data store , so as to enable context - sensitivity through _",
    "recall_. second , we required parsers to behave transactionally : a parser must either succeed , or fail and leave the state unaltered . this transactional discipline , which we call _ principled stateful parsing _ , prevents parsing mechanisms such as backtracking and memoization to break the guarantee of context transparency .    to enforce the principled stateful parsing discipline , we supplied formally specified state manipulation operations .",
    "the role of these operations is to snapshot and restore the state , as well as to create and merge deltas between a snapshot and the current state .",
    "we implemented our approach in a parsing library called _ autumn _ , and showed how it can be used in practice to implement common context - sensitive grammar features such as significant whitespace and namespace classification .",
    "we underline the low boilerplate and conceptual overhead introduced by the approach .",
    "a.  afroozeh and a.  izmaylova .",
    "one parser to rule them all . in _",
    "acm international symposium on new ideas , new paradigms , and reflections on programming and software _ , onward !",
    "2015 , pages 151170 .",
    "acm , 2015 .",
    "t.  parr , s.  harwell , and k.  fisher .",
    "adaptive ll ( * ) parsing : the power of dynamic analysis . in _ proceedings of the 2014 acm international conference on object oriented programming systems languages & applications _ , oopsla 14 , pages 579598 .",
    "acm , 2014 .",
    "m.  j. steindorfer and j.  j. vinju .",
    "optimizing hash - array mapped tries for fast and lean immutable jvm collections . in _ proceedings of the 2015 acm sigplan international conference on object - oriented programming , systems , languages , and applications _ , oopsla 2015 , pages 783800 .",
    "acm , 2015 .",
    "a.  d. thurston and j.  r. cordy .",
    "a backtracking lr algorithm for parsing ambiguous context - dependent languages . in _ proceedings of the 2006 conference of the centre for advanced studies on collaborative research , october 16 - 19 , 2006 , toronto , ontario , canada _ , pages 3953 , 2006 .",
    "e.  van  wyk and a.  schwerdfeger .",
    "context - aware scanning for parsing extensible languages . in _",
    "international conference on generative programming and component engineering , gpce 2007_. acm , october 2007 ."
  ],
  "abstract_text": [
    "<S> historically , true context - sensitive parsing has seldom been applied to programming languages , due to its inherent complexity . however , many mainstream programming and markup languages ( c , haskell , python , xml , and more ) possess context - sensitive features . </S>",
    "<S> these features are traditionally handled with ad - hoc code ( e.g. , custom lexers ) , outside of the scope of parsing theory .    </S>",
    "<S> current grammar formalisms struggle to express context - sensitive features . </S>",
    "<S> most solutions lack _ context transparency _ : </S>",
    "<S> they make grammars hard to write , maintain and compose by hardwiring context through the entire grammar . </S>",
    "<S> instead , we approach context - sensitive parsing through the idea that parsers may _ recall _ previously matched input ( or data derived therefrom ) in order to make parsing decisions . </S>",
    "<S> we make use of mutable _ parse state _ to enable this form of recall .    </S>",
    "<S> we introduce _ principled stateful parsing _ as a new transactional discipline that makes state changes transparent to parsing mechanisms such as backtracking and memoization . to enforce this discipline , users specify parsers using formally specified primitive state manipulation operations .    </S>",
    "<S> our solution is available as a parsing library named _ </S>",
    "<S> autumn_. we illustrate our solution by implementing some practical context - sensitive grammar features such as significant whitespace handling and namespace classification .    [ parsing ]    stateful parsing , grammars , context sensitivity , data dependence , parsing expressions </S>"
  ]
}