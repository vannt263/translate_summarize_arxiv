{
  "article_text": [
    "for @xmath50 , define the functions @xmath51",
    "@xmath52 @xmath53 ( note that @xmath54 depend implicitly on the length @xmath2 of the strings . )",
    "then we have the equations @xmath55",
    "@xmath56 @xmath57 these equations will hold even for @xmath58 if one defines trivially @xmath59 for @xmath60 .",
    "alternatives 1,2 in the parentheses signify whether the minimum is attained by its first or second arguments , respectively .",
    "the proof consists simply of inspecting the definitions of the functions @xmath54 and verifying that in each of the cases the required relations hold .",
    "we omit the details , since the reader would no doubt have to go through the same thought process to verify them on her own as to check that a purported proof is correct .",
    "depth0pt    a schematic representation of the finite state machine is shown in figures 2 , 3 and 4 below .",
    "we present several variants of the machine : the machine in figure 2 only decides between alternative 1 and alternative 2 .",
    "the machine in figure 3 , which has auxiliary counters for the distance and for the variable @xmath2 ( so strictly speaking it is not really a finite - state automaton ) , actually computes @xmath24 .",
    "note that this is still designed only for the case in which @xmath13 begins with the symbol @xmath33 and @xmath25 begins with @xmath32 .",
    "figure 4 shows the complete finite - state machine which may be used to compute @xmath24 for any two states @xmath23 .",
    "this includes an initial component that discards the first few symbols which are identical for @xmath13 and @xmath25 , and another component that permutes the symbols @xmath11 to fit the design of the basic machine in figure 2 .",
    "( 300,230)(0,0 ) ( 30,100 ) ( 150,100 ) ( 270,100 ) ( 75,190)(30,30 ) ( 195,190)(30,30 ) ( 50,90)(1,0)80 ( 130,110)(-1,0)80 ( 170,90)(1,0)80 ( 250,110)(-1,0)80 ( 20,82)(0,55)(25,45 ) ( 40,82)(60,55)(35,45 ) ( 25,45)(30,43)(35,45 ) ( 45,77)(-1,1)7 ( 140,82)(120,55)(145,45 ) ( 160,82)(180,55)(155,45 ) ( 145,45)(150,43)(155,45 ) ( 165,77)(-1,1)7 ( 260,82)(240,55)(265,45 ) ( 280,82)(300,55)(275,45 ) ( 265,45)(270,43)(275,45 ) ( 285,77)(-1,1)7 ( 35,120)(2,3)43 ( 145,120)(-2,3)43 ( 155,120)(2,3)43 ( 265,120)(-2,3)43 ( 55,173 ) ( 47,163 ) ( 39,153 ) ( 33,143 ) ( 28,133 ) ( 22,123 ) ( 232,173 ) ( 240,163 ) ( 248,153 ) ( 253,143 ) ( 260,133 ) ( 266,123 ) ( 85,80 ) ( 70,112 ) ( 195,80 ) ( 205,112 ) ( 0,40 ) ( 25,32 ) ( 240,40 ) ( 265,32 ) ( 114,67 ) ( 114,57 ) ( 114,47 ) ( 104,146 ) ( 179,146 ) ( 19,103 ) ( 18,94 ) ( 141,94 ) ( 258,94 ) ( 81,208 ) ( 80,200 ) ( 201,208 ) ( 200,200 )    figure 2 : the finite state machine : deciding between alternative 1 and alternative 2 .",
    "the two letters signify the two inputs from @xmath13 and @xmath25 , reading at each step the next - most - significant symbol .",
    "the parentheses in the non - terminal states indicate that if the input terminates without a decision , then in the start state alternative 1 wins , in the rightmost state alternative 2 wins , and in the middle state there is a draw , meaning that the shortest path is not unique and both alternatives are valid .",
    "( 300,200)(0,0 ) ( 30,100 ) ( 150,100 ) ( 270,100 ) ( 75,190)(30,30 ) ( 195,190)(30,30 ) ( 50,90)(1,0)80 ( 130,110)(-1,0)80 ( 170,90)(1,0)80 ( 250,110)(-1,0)80 ( 20,82)(0,55)(25,45 ) ( 40,82)(60,55)(35,45 ) ( 25,45)(30,43)(35,45 ) ( 45,77)(-1,1)7 ( 137,85)(114,75)(105,60 ) ( 140,82)(130,59)(115,49 ) ( 105,60)(97,40)(115,49 ) ( 137,77)(2,3)5 ( 163,85)(186,75)(195,60 ) ( 160,82)(170,59)(185,49 ) ( 195,60)(203,40)(185,49 ) ( 164,77)(-2,3)5 ( 260,82)(240,55)(265,45 ) ( 280,82)(300,55)(275,45 ) ( 265,45)(270,43)(275,45 ) ( 285,77)(-1,1)7 ( 35,120)(2,3)43 ( 145,120)(-2,3)43 ( 155,120)(2,3)43 ( 265,120)(-2,3)43 ( 55,173 ) ( 47,163 ) ( 39,153 ) ( 33,143 ) ( 28,133 ) ( 22,123 ) ( 232,173 ) ( 240,163 ) ( 248,153 ) ( 253,143 ) ( 260,133 ) ( 266,123 ) ( 85,80 ) ( 70,112 ) ( 195,80 ) ( 205,112 ) ( 0,40 ) ( 25,32 ) ( 240,40 ) ( 265,32 ) ( 85,58 ) ( 85,48 ) ( 156,53 ) ( 104,146 ) ( 179,146 ) ( 19,105 ) ( 21,98 ) ( 18,91 ) ( 141,94 ) ( 258,94 ) ( 81,208 ) ( 80,200 ) ( 201,208 ) ( 200,200 ) ( 26,47 ) ( 106,37 ) ( 184,37 ) ( 93,91 ) ( 74,100 ) ( 213,91 ) ( 194,100 ) ( 266,47 ) ( 67,163 ) ( 187,163 )      ( 300,340)(0,0 ) ( 30,100 ) ( 150,100 ) ( 270,100 ) ( 75,190)(30,30 ) ( 195,190)(30,30 ) ( 50,90)(1,0)80 ( 130,110)(-1,0)80 ( 170,90)(1,0)80 ( 250,110)(-1,0)80 ( 20,82)(0,55)(25,45 ) ( 40,82)(60,55)(35,45 ) ( 25,45)(30,43)(35,45 ) ( 45,77)(-1,1)7 ( 137,85)(114,75)(105,60 ) ( 140,82)(130,59)(115,49 ) ( 105,60)(97,40)(115,49 ) ( 137,77)(2,3)5 ( 163,85)(186,75)(195,60 ) ( 160,82)(170,59)(185,49 ) ( 195,60)(203,40)(185,49 ) ( 164,77)(-2,3)5 ( 260,82)(240,55)(265,45 ) ( 280,82)(300,55)(275,45 ) ( 265,45)(270,43)(275,45 ) ( 285,77)(-1,1)7 ( 35,120)(2,3)43 ( 145,120)(-2,3)43 ( 155,120)(2,3)43 ( 265,120)(-2,3)43 ( 55,173 ) ( 47,163 ) ( 39,153 ) ( 33,143 ) ( 28,133 ) ( 22,123 ) ( 232,173 ) ( 240,163 ) ( 248,153 ) ( 253,143 ) ( 260,133 ) ( 266,123 ) ( 85,80 ) ( 70,112 ) ( 195,80 ) ( 205,112 ) ( 0,40 ) ( 25,32 ) ( 240,40 ) ( 265,32 ) ( 85,58 ) ( 85,48 ) ( 156,53 ) ( 104,146 ) ( 179,146 ) ( 81,208 ) ( 80,200 ) ( 201,208 ) ( 200,200 ) ( 26,47 ) ( 106,37 ) ( 184,37 ) ( 93,91 ) ( 74,100 ) ( 213,91 ) ( 194,100 ) ( 266,47 ) ( 67,163 ) ( 187,163 ) ( 230,300 ) ( 220,282)(200,255)(225,245 ) ( 240,282)(260,255)(235,245 ) ( 225,245)(230,243)(235,245 ) ( 245,277)(-1,1)7 ( 219,303 ) ( 221,295 ) ( 253,268 ) ( 253,258 ) ( 253,248 ) ( 20,330 ) ( 20,320 ) ( 20,310 ) ( 75,330 ) ( 75,320 ) ( 75,310 ) ( 130,330 ) ( 130,320 ) ( 130,310 ) ( 20,280 ) ( 20,270 ) ( 20,260 ) ( 75,280 ) ( 75,270 ) ( 75,260 ) ( 130,280 ) ( 130,270 ) ( 130,260 ) ( 36,323 ) ( 91,323 ) ( 146,323 ) ( 36,273 ) ( 91,273 ) ( 146,273 ) ( 212,307)(-4,1)43 ( 212,293)(-4,-1)43 ( 215,310)(150,375)(102,346 ) ( 107,348)(-2,-1)7 ( 215,290)(150,225)(102,251 ) ( 107,249)(-2,1)7 ( 218,286)(170,233)(150,233 ) ( 150,233)(-1,0)60 ( 90,233)(50,233)(43,251 ) ( 47,245)(-2,3)4 ( 218,314)(170,367)(150,367 ) ( 150,367)(-1,0)60 ( 90,367)(50,367)(43,349 ) ( 47,355)(-2,-3)4 ( 128,309)(-1,-1)10 ( 128,309)(-1,-1)7 ( 128,289)(-1,1)10 ( 128,289)(-1,1)7 ( 73,309)(-1,-1)10 ( 73,309)(-1,-1)7 ( 73,289)(-1,1)10 ( 73,289)(-1,1)7 ( 18,309)(-1,-1)10 ( 18,309)(-1,-1)7 ( 18,289)(-1,1)10 ( 18,289)(-1,1)7 ( 118,299)(-1,0)112 ( 6,299)(0,299)(0,293 ) ( 0,293)(0,-1)187 ( 0,293)(0,-1)70 ( 6,100)(0,100)(0,106 ) ( 6,100)(1,0)5 ( 123,223 ) ( 123,368 ) ( 113,247 ) ( 113,342 ) ( 174,288 ) ( 174,304 ) ( 4,220 ) ( -52,210 ) ( -52,201 ) ( -52,192 ) ( 18,94 ) ( 141,94 ) ( 258,94 )        we now define the graph of states in the @xmath2-disc tower of hanoi puzzle , and show that it is isomorphic to @xmath9",
    ". the isomorphism may be computed by reading sequentialy the locations of the discs , starting with the largest one ( which corresponds to the most significant digit in the sierpiski gasket labeling ) , and following a diagram of permutations translating the labels of the three pegs into the symbols @xmath11 ( another finite - state machine ! ) . together with the results of the previous section",
    ", this will give an effective means of computing the length of the shortest path between any two vertices in the hanoi graph , and of deciding whether the largest disc will be moved once or twice in a shortest path .",
    "after that , we describe briefly an algorithm for actually constructing the shortest path , based on the algorithm for getting to a perfect state .",
    "label the three pegs in the tower of hanoi with the symbols @xmath64 . since in a legal state , on each of the pegs the discs are arranged in increasing size from top to bottom , a state is described uniquely by specifying , for any disc , the label of its peg .",
    "thus , we define @xmath65 , the @xmath2-th _ hanoi graph _ , to be the graph whose vertex set is the set @xmath66 ( with the coordinates of the vectors specifying , from left to right , the labels of the pegs of the largest disc , second - largest disc , etc . ) , and where edges between states correspond to permissible moves .",
    "figure 5 shows the graph @xmath67 .",
    "@xmath65 and @xmath9 are isomorphic graphs .",
    "the finite - state machine shown below translates a hanoi state @xmath68 into a sierpiski gasket labeling @xmath69 , by reading the digits from left to right and outputting the symbols @xmath11 at each step according to the identifications in its internal state , then changing the internal state according to the input .",
    "( 300,0)(0,135 ) ( 22,70 ) ( 22,60 ) ( 22,50 ) ( 36,63 ) ( 22,86 ) ( 96,3 ) ( 82,10 ) ( 82,0 ) ( 82,-10 ) ( 54,45)(1,-1)25 ( 60,39)(-1,1)7 ( 96,123 ) ( 82,130 ) ( 82,120 ) ( 82,110 ) ( 54,81)(1,1)25 ( 60,87)(-1,-1)7 ( 170,3 ) ( 156,130 ) ( 156,120 ) ( 156,110 ) ( 170,123 ) ( 156,10 ) ( 156,0 ) ( 156,-10 ) ( 230,63 ) ( 216,70 ) ( 216,60 ) ( 216,50 ) ( 212,45)(-1,-1)25 ( 206,39)(1,1)7 ( 212,81)(-1,1)25 ( 206,87)(1,-1)7 ( 119,123)(1,0)28 ( 125,123)(-1,0)5 ( 119,3)(1,0)28 ( 125,3)(-1,0)5 ( 60,63)(1,0)146 ( 67,63)(-1,0)7 ( 106,26)(2,3)50 ( 110,32)(-2,-3)6 ( 106,100)(2,-3)50 ( 110,94)(-2,3)6 ( 60,95 ) ( 200,95 ) ( 60,24 ) ( 200,24 ) ( 90,65 ) ( 105,84 ) ( 155,84 ) ( 130,125 ) ( 130,-6 ) ( 0,-36 )      this is lemma 2 in @xcite .",
    "there it was claimed simply that @xmath65 and @xmath9 are isomorphic , but the proof , which is by induction , actually describes how to compute the isomorphism , and this is easily seen to be equivalent to our finite - state machine formulation .",
    "depth0pt      by running the machines of figures 4 and 6 in parallel , we now have an algorithm for computing @xmath24 for two arbitrary states in the hanoi graph , and for solving the decision problem for the largest disc , i.e. to decide whether the largest disc which it is necessary to move will move once or twice . as we will show in the next section , when @xmath13 and @xmath25 are randomly chosen states , the expected stopping time of the machine is @xmath70 .",
    "( this random variable even has an exponential tail distribution , so with very high probability only a small number of discs will need to be read to solve the decision problem . )",
    "having solved the decision problem , the shortest path may now be computed in a straightforward manner , as described in @xcite , using the algorithm for getting to a perfect state ( use the algorithm described in @xcite , or the algorithm for the sierpiski gasket described in section 2 together with the machine of figure 6  which incidentally leads to an algorithm for getting to perfect states which we have not found in the literature ) .        in this section ,",
    "we calculate the average number of discs that must be read in order to decide whether in a shortest path the largest disc will be moved once or twice .",
    "let @xmath71 , @xmath72 .",
    "assume that we have already discarded the largest discs which for @xmath13 and @xmath25 were on the same peg , so that @xmath73 .",
    "the algorithm for solving the decision problem then tells us to run the machines of figures 4 and 6 until they reach a terminal state ( or we run out of input ) .",
    "since we have already initialized by discarding irrelevant discs , we will really be using the machine of figure 2 ( keeping track of the correct identification of the symbols @xmath74 with the pegs @xmath64 ) .",
    "since we are dealing with random inputs , what we are really interested in is the absorption time of the markov chain whose transition matrix is @xmath75 into the terminal states 4 and 5 .",
    "we may identify these two states to get the simpler matrix @xmath76 for @xmath77 , denote by @xmath78 the expected time to get to state @xmath79 , _ starting from state @xmath80_. then clearly we have the equations @xmath81",
    "@xmath82 @xmath83 it may easily be verified that the solution to this system of equations is @xmath84 the value @xmath85 is our expected stopping time , since @xmath86 corresponds to the initial state .",
    "note that this value is the limit as @xmath87 of the average number of discs that must be read ; in reality , for finite @xmath2 the value will be slightly smaller since after @xmath2 steps we run out of input and the machine terminates even if it has not reached a terminal state . to summarize :      the decision problem for shortest paths can be solved in average time @xmath88 . specifically , the average number of disc pairs that our algorithm must read , once identical discs have been discarded , is bounded from above by , and converges as @xmath87 to , @xmath70 .",
    "hinz and schief @xcite computed the average length @xmath89 of a shortest path between two random points on the _ infinite _ sierpiski gasket of unit side .",
    "an equivalent result of hinz @xcite and of chan @xcite , in terms of the tower of hanoi , is that the average number of moves in a shortest path between two random states in the @xmath2-disc tower of hanoi , is asymptotically @xmath90 as @xmath87 .    without going into too much detail ,",
    "we show that it is possible to obtain the value of @xmath89 just by looking at the finite - state machine of figure 4 .",
    "since we are dealing with the infinite gasket , we start with @xmath91 and , as before , decrease the value of @xmath2 after each step , so that @xmath2 will go into the negative integers .",
    "let @xmath92 be the expected accumulated values of the variable @xmath61 if one starts the machine , with initial values @xmath93 , at either of the four non - terminal states , in order of their distance from the state start ( so @xmath94 is the total distance ; @xmath95 is the distance after discarding identical most - significant digits of @xmath13 and @xmath25 , etc . ) .",
    "then we have the equations @xmath96",
    "@xmath97 @xmath98 @xmath99 @xmath100    the value ( 1/2 + 2/3 ) in the second and fourth equations is the expected value of @xmath101 ( respectively @xmath102 ) , given that the first pair of inputs is one of the six values @xmath103 ( respectively @xmath104 ) ."
  ],
  "abstract_text": [
    "<S> we present efficient algorithms for constructing a shortest path between two states in the tower of hanoi graph , and for computing the length of the shortest path . </S>",
    "<S> the key element is a finite - state machine which decides , after examining on the average only @xmath0 of the largest discs , whether the largest disc will be moved once or twice . </S>",
    "<S> this solves a problem raised by andreas hinz , and results in a better understanding of how the shortest path is determined . </S>",
    "<S> our algorithm for computing the length of the shortest path is typically about twice as fast as the existing algorithm . </S>",
    "<S> we also use our results to give a new derivation of the average distance @xmath1 between two random points on the sierpiski gasket of unit side . </S>",
    "<S> +   + key words : tower of hanoi , finite automata , sierpiski gasket      the _ tower of hanoi _ puzzle , invented in 1883 by the french mathematician edouard lucas , has become a classic example in the analysis of algorithms and discrete mathematical structures ( see e.g. @xcite , 1.1 ) . </S>",
    "<S> the puzzle consists of @xmath2 discs of different sizes , stacked on three vertical pegs , in such a way that no disc lies on top of a smaller disc . </S>",
    "<S> a permissible _ move _ is to take the top disc from one of the pegs and move it to one of the other pegs , as long as it is not placed on top of a smaller disc . </S>",
    "<S> the set of states of the puzzle , together with the permissible moves , thus forms a graph in a natural way . </S>",
    "<S> the number of vertices in the @xmath2-disc hanoi graph is @xmath3 .    </S>",
    "<S> the main question of interest is to find _ </S>",
    "<S> shortest paths _ in the state graph , i.e. , shortest sequences of moves leading from a given initial state to a given terminal state . the simplest and most well - known case is that in which it is required to move all the discs from one of the pegs to another , i.e. where the initial and terminal states are two of the three `` perfect '' states with all the discs on the same peg . </S>",
    "<S> this is very easy , and can be shown to take exactly @xmath4 moves . </S>",
    "<S> more difficult is to get from a given arbitrary initial state to one of the perfect states - hinz @xcite calls this the `` p1 '' problem . </S>",
    "<S> this takes @xmath4 moves in the worst case ( which is when the initial state is another perfect state ) , and on the average @xmath5 moves for a randomly chosen initial state @xcite . </S>",
    "<S> moreover , there is a simple and efficient algorithm to compute the shortest path in this case .    in the most general case of arbitrary initial _ and _ terminal states , however , the question of computing the shortest path and its length ( the `` p2 '' problem @xcite ) in the most efficient manner , has not been completely resolved so far . ( the worst - case behavior is still @xmath4 moves , and the average number of moves for random initial and terminal states has been shown @xcite,@xcite to be about @xmath6 . ) the main obstacle in the understanding of the behavior of the shortest path , has been the behavior of the largest disc that `` separates '' the initial and terminal states , i.e. the largest disc which is not on the same peg in both states ( trivially , any larger discs may simply be ignored ) . </S>",
    "<S> it is not difficult to see @xcite that in a shortest path , this disc will be moved either once ( from the source peg to the target peg ) or twice ( from the source to the target , via the third peg ) . </S>",
    "<S> the problem is to decide which of the two alternatives is the correct one . </S>",
    "<S> once this is settled , the path may be constructed by two applications of the algorithm for the p1 problem . </S>",
    "<S> hinz @xcite proposed an algorithm for the computation of the shortest path based on this idea . </S>",
    "<S> the algorithm consists essentially of computing the length of the path for both alternatives and choosing the shorter of the two .    in this paper , </S>",
    "<S> we propose a more thorough explanation of the process whereby it is decided which of the two paths is the shortest . </S>",
    "<S> we show that it is possible to keep track of the relevant information using a finite - state machine , which at each step reads the locations of the next - smaller disc in the initial and terminal states , and changes its internal state accordingly . eventually , the machine reaches a terminal state , whereupon it pronounces which of the two paths is the shortest . for a random input , </S>",
    "<S> its expected stopping time is computed to be @xmath7 . </S>",
    "<S> in other words , after observing on the average the locations of just the @xmath8 largest discs in the initial and terminal states , we will know which of the paths to choose , and we will be able to continue using the algorithm for the p1 problem . if one is interested just in the length of the shortest path , then our algorithm is typically about twice as fast as the algorithm proposed by hinz @xcite ( with a small constant overhead due to the initial 1.66 discs ) , since it overrides the need to compute both the distance for the path that moves the largest disc once , and the path that moves it twice . the paper is organized as follows : in the next section , we define the _ discrete sierpiski gasket _ graph , a graph which is isomorphic to the tower of hanoi state graph , but for which the labeling of the vertices is simpler to understand . in section 3 , </S>",
    "<S> we present the main ideas for this graph , and then in section 4 show how to translate the results to the hanoi graph by a re - labeling of the vertices . in section 5 </S>",
    "<S> we perform a probabilistic analysis of the finite - state machine , to compute the average number @xmath7 of discs that need to be read in order to decide whether the largest disc will be moved once or twice , and to give a new derivation of the asymptotic value @xmath6 for the average distance between two random states in the @xmath2-disc hanoi graph .      </S>",
    "<S> we now define a family of graphs called _ </S>",
    "<S> discrete sierpiski gaskets_. these graphs are finite versions of the famous fractal constructed by the polish mathematician waclaw sierpiski in 1915 . </S>",
    "<S> the connection between the tower of hanoi problem and the sierpiski gasket was first observed by ian stewart @xcite , and was later used by andreas hinz and andreas schief @xcite in their calculation of the average distance between points on the sierpiski gasket .    the @xmath2th discrete sierpiski gasket graph , which we denote by @xmath9 , consists of the vertex set @xmath10 ( the symbols @xmath11 indicate `` top '' , `` left '' and `` right '' , respectively ) , with the edges defined as follows : first , for each @xmath12 ( for reasons that will become apparent below , this will be our standard indexing of the coordinates of the vertices of @xmath9 ) we have edges connecting @xmath13 to @xmath14 second , define the _ tail _ of @xmath15 as the suffix @xmath16 of @xmath13 , where @xmath17 is maximal such that @xmath18 . if @xmath13 has a tail of length @xmath19 , then @xmath13 is of the form @xmath20 . </S>",
    "<S> connect @xmath13 with an edge to the vertex @xmath21    one possible embedding of @xmath9 in the plane is illustrated in figure 1 below . </S>",
    "<S> this embedding makes clear the meaning of the labeling of the vertices : the first letter ( the `` most significant digit '' ) signifies whether the vertex is in the top , left or right triangles inside the big triangle ; the next letter locates the vertex within the top , left or right thirds of that triangle , etc .        </S>",
    "<S> figure 1 : the graph @xmath22    it will be shown in section 4 that @xmath9 is isomorphic , in a computationally straightforward way , to the @xmath2-disc hanoi graph . ( the same was shown in @xcite , with less emphasis on explicit computation of the isomorphism . ) thus , the problem of shortest paths on the hanoi graph reduces to that of shortest paths in the discrete sierpiski gasket . </S>",
    "<S> we tackle this problem in the next section .      for vertices </S>",
    "<S> @xmath23 , we define the distance @xmath24 to be the length of a shortest path from @xmath13 to @xmath25 . </S>",
    "<S> our goal is to write down a recursion equation for this distance , which is at the heart of the finite - state machine we will construct to compute @xmath24 . </S>",
    "<S> first , let us review briefly some of the known facts about @xmath24 in the simple case when @xmath25 is one of the `` perfect '' states @xmath26 . for concreteness , </S>",
    "<S> assume that @xmath27 , and let @xmath28 as before . </S>",
    "<S> then it is known that @xmath29 a simple algorithm exists for computing a shortest path from @xmath13 to @xmath25 in this case . in the hanoi labeling of the graph , the algorithm is described in @xcite . in the current labeling , </S>",
    "<S> the algorithm is even simpler and is based on the binary number system : if one identifies the symbol @xmath30 with @xmath31 and the symbols @xmath32 and @xmath33 with @xmath34 , then traversing the edges of the graph becomes equivalent to the operations of subtraction or addition of 1 in binary notation . </S>",
    "<S> the number of steps to reach @xmath35 is then clearly the right - hand side in the above equation .    with these preparatory remarks , </S>",
    "<S> we now attack the problem of general @xmath36 . </S>",
    "<S> first , observe that we may assume that @xmath37 , since otherwise we may simply consider @xmath13 and @xmath25 as vertices in the graph @xmath38 ( note the self - similar structure in the definition of the graph , also apparent in the tower of hanoi puzzle when one ignores the largest disc ) . </S>",
    "<S> for concreteness , we shall analyze in detail the case where @xmath39 . referring to figure 1 for convenience </S>",
    "<S> , we see that @xmath40 @xmath41 since in a shortest path from @xmath13 to @xmath25 , one must go from the top triangle to the right triangle either through the edge @xmath42 ( we call this alternative 1 , see theorem 1 below ) or through a shortest path from @xmath43 to @xmath44 ( alternative 2 ) - in the tower of hanoi language , this is an indication of the fact that in a shortest sequence of moves the largest disc must move either once or twice , see @xcite .    to simplify the next few equations , introduce the following notation : if @xmath45 , let @xmath46 , and define for any @xmath47 @xmath48 then we have @xmath49 the recursion equations which will enable us to construct our finite - state machine and compute @xmath24 are now given by the following theorem : </S>"
  ]
}