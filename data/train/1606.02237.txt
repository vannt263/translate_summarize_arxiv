{
  "article_text": [
    "_ data _ is fuel and prerequisite for any kind of data management , analysis and decision making process . however , with the explosion of data volume and the variety of data sources  two aspects of the big data problem @xcite  we observe quite significant difficulties in applying conventional methodologies to real world problems .",
    "the existing theories and technologies for data management and analytics have been pushed to the limits of their ability to solve more and more complex tasks especially in the context of significant modern trends over the last few years which are shortly described below .    _",
    "agile analytics _ goes beyond standard olap analysis by facilitating ad - hoc queries where the user can freely vary data processing and/or visualization parameters and is not restricted by predefined application - specific and domain - specific scenarios .",
    "_ self - service analytics _ is one of the most significant trends in the bi industry over the last few years .",
    "it is aimed at giving users the ability to solve analytical tasks with little or no help from it @xcite .",
    "self - service tools are intended for such users as data enthusiasts , business users , data artisans , analysts .",
    "what unites all these kinds of users is that they do not possess deep knowledge in mathematics and statistics but all of them need some simple tool to solve a problem or answer a question by analyzing available data .",
    "_ near real time analytics .",
    "_ there is strong demand in reducing the time between data acquisition and making a business decision but conventional systems can not provide the necessary response time and agility of decision making on large volumes of data @xcite . although modern hardware provides a basis for a new generation of in - memory , columnar databases @xcite with potentially higher query performance on analytical workloads , it is important to understand that it is not only a hardware problem ",
    "new data models , query languages , analysis scenarios and algorithms are needed .",
    "_ data semantics .",
    "_ a typical enterprise system can contain tens of thousands data tables and open systems can involve even more external data sources . in this situation it is extremely difficult to get meaningful results without understanding what data means and having the possibility to process data automatically @xcite . in this context ,",
    "semantics `` should enable to respond to queries and other transactions in a more intelligent manner '' @xcite .",
    "_ reasoning about data . _",
    "analytical queries are rather complex data processing scripts over numerous data sources and writing such queries is a tedious and error - prone task requiring high expertise .",
    "the mechanism of reasoning about data can significantly simplify this problem by automatically deriving the desired result from the available data .",
    "_ analytical computations .",
    "_ analysts need to embed complex computations in their analysis tasks and normally it is performed by copying data to a different system for processing which is both inefficient and not flexible procedure . executing custom analysis tasks close to",
    "the data is still a big problem because of serious incompatibilities between data modeling and programming .",
    "obviously it is difficult to solve these and other practical data management problems without clear understanding of what data is .",
    "however , there exist some fundamental issues and controversies which do not allow us to answer this question and hence to solve these problems in a principled manner .",
    "some of these basic issues are shortly described below .",
    "_ tuple is probably the most wide spread way to formally represent data by combining several simpler data elements .",
    "this mathematical construct has been used for representing complex things in computer science for dozen of years and it seems that everybody is happy with its properties . yet , one serious issue arises ( at least in the context of data modeling ) if we ask the question whether a tuple is a value ( passed by - copy ) or it is passed by - reference . if a tuple is a value then the whole database is essentially one huge tuple because there is no possibility to reference things .",
    "if tuples are passed by - reference then any tuple is a combination of references and there is no way to represent a combination of values . in both cases ,",
    "something very important is missing when using tuples as a mathematical construct for data representation .",
    "therefore , in practice there exist two major workarounds : 1 ) two separate structures are used for representing values and objects ( either as dedicated structures like struct and class or by annotating them by a marker like by - ref and by - val ) ; 2 ) each individual instance ( variable , parameter , field and so on ) is annotated as passed by - value or by - reference .",
    "in particular , a variation of the first approach is used in the relational model ( rm ) @xcite where two kinds of data elements and two kinds of sets are used : values are members of domains and tuples are members of relations . a fundamental controversy here is that both domains and relations are normal sets containing tuples and therefore there is no formal reason to distinguish them .",
    "so the question is why _ two _ kinds of sets for representing elements with the same structure ( tuples ) ? why tuples from relations can be composed of only tuples from domains and not from tuples from other relations ? why tuples from domains can not include tuples from relations ?",
    "of course , there exist numerous specific fixes and workarounds for solving these problems but the question is about inherent support at the level of tuples themselves as a basic construct for data representation and access .",
    "and the question is then whether it is possible to introduce _",
    "one _ kind of tuples for both purposes ?    _ sets .",
    "_ a set is a fundamental mathematical notion which is widely used in data modeling for formally representing a collection of distinct things . yet , there exist several subtle questions which have different answers in different models .",
    "one of them is whether a set itself is a data element or only its members are data elements ?",
    "in real life , a collection of objects is normally treated as a new object . in rm , a set ( relation or domain )",
    "is not a fully - fledged data element .",
    "other approaches like object - based models introduce collections which can be treated as data elements ( but also with some limitations and specific treatments ) .",
    "another question is whether every data element should be a set ?",
    "for example , in rm a tuple is not a set . what is the difference between tuples and sets if tuples in mathematics are defined via sets ?",
    "is this difference important for data modeling or maybe it is enough to have only sets and not tuples ? should any data element ( including sets ) be a member of some other set and whether it is possible to have data elements without a set it is in ? if all elements including sets are included in other sets then all of them should be members in some kind of global set . how this global set should be organized",
    "_ hierarchies .",
    "_ a hierarchy is one of the most natural ways to organize things and to think about the world ( along with tuples which combine elements ) .",
    "yet , the use of hierarchies has always been controversial in data modeling : some techniques ( like xml ) and methodologies like object - based models @xcite provide full support for hierarchies while others like rm essentially expel them from the data realm .",
    "one reason for not supporting hierarchies is the existence of multiple treatments of their meaning .",
    "does a hierarchy represent containment ? is this containment in terms of membership or subset relations ? and if it is containment what is the difference from tuples regarded as containers for the members ? or maybe a hierarchy represents inheritance ? then what mechanism is used for the implementation of inheritance ?",
    "or maybe it corresponds to a dimension hierarchy ? due to this diversity of interpretations ,",
    "systems normally provide different hierarchies for different purposes while a hierarchy as a basic construct loses its role ( and it is probably one of the reasons why they are not supported in rm ) .",
    "another more specific but rather deep issue is asymmetry between class or concept hierarchies and the corresponding instance hierarchies .",
    "the paradox @xcite is that instances forget about the hierarchical type structure of their classes and exist in a flat space rather than as a hierarchy .",
    "a general question is whether it is possible to have only one kind of hierarchies as a basic construct and at the same time cover all their common uses and interpretations ?",
    "_ multidimensionality .",
    "_ probably nobody after descartes will dispute that the world is inherently multidimensional and multidimensionality is one of the most common ways to organize things ( along with tuples and hierarchies ) .",
    "indeed , it is rather natural to assume that similar to objects in physical space , data items and conceptual things also have coordinates which determine their position with respect to other things .",
    "surprisingly , inspite of its naturalness and importance for data analysis , multidimensionality is not an inherent feature of general - purpose data models .",
    "rather , multidimensionality is added as a new layer of data representation for ( mostly numeric ) analysis purposes @xcite .",
    "therefore , the question is whether it is possible to have multidimensionality as an inherent mechanism of the model at the same level as tuples , sets and hierarchies so that data always exist within a multidimensional space ?",
    "_ identification .",
    "_ identity determines what a thing is , how things exist , how they are distinguished , how they are accessed as well as many other mechanisms @xcite .",
    "currently there exist many different approaches to identification of elements like pointers , references , surrogates , keys , oids or identification by content . here",
    "again there exist many quite different views on the role and importance of identities for data modeling .",
    "in particular , there are different opinions concerning the question whether identities are data at all and if yes then whether identities belong to the problem domain or they belong to the system level . finding some common basis for all of the existing views on identities and identification would significantly simplify many complex data modeling and analysis problems",
    ".    _ connectivity .",
    "_ all things in the worlds are connected and all elements in a database have to be also connected .",
    "one way to connect things is via properties storing a reference to a related thing .",
    "another approach , joins , is where two things are considered related if they both contain some common value . and",
    "the third approach consists in using relationships which are elements referencing related things .",
    "do we actually need all these mechanisms ? and",
    "if yes then is it possible to introduce one basic principle all other connectivity mechanisms can be reduced to ?",
    "these fundamental challenges can hardly be resolved by introducing a new specific method or technique .",
    "they require a principled solution which should be general enough to unify many existing patterns of thought , and at the same time it should be simple and natural .",
    "such unification is the main goal of the concept - oriented model ( com ) described in this paper .",
    "com addresses the theoretical and practical issues described in the beginning of the paper and is aimed at _ simplifying _ data modeling and management .",
    "of course , complete unification is hardly possible because it would mean developing a kind of the ultimate theory .",
    "therefore , com should be viewed as an attempt to increase unification among existing theories of data and data modeling techniques .",
    "com tries to achieve higher _ generality _ by decreasing the number of basic notions used to describe a database by simultaneously increasing their coverage , that is , the number of various data modeling patterns that can be effectively modeled by these notions .",
    "also , com is being developed to be a _",
    "approach so that its main notions are close to how data is thought of and used in real life ( semantics ) .",
    "com has been described at conceptual level as well as syntactically using the concept - oriented query language ( coql ) @xcite with limited formalization .",
    "com has also been implemented in two systems : a self - service tool for analytical data integration , conceptmix @xcite and a framework for data wrangling and agile data transformations , datacommandr @xcite .",
    "the main contribution of this paper is that we propose a new formalization of com in terms of functions , sets and tuples .",
    "more specifically , we make the following contributions :    * new formal definition of a data element via two kinds of functions : identity functions and entity functions is proposed . *",
    "new mechanism of function overriding and data hierarchies is described . *",
    "new use of functions for data modeling is described where functions are mappings between values with arbitrary domain - specific structure ( rather than only primitive identifiers ) . * new treatment of connectivity based on functions where",
    "joins and relationships are considered two higher levels types of connectivity derived from functions . * new uses of functions for representing data semantics : a function is a mapping from an object to its coordinate , a function is a mapping from more specific elements to more general elements , a function is a mapping from members to their set .",
    "the paper has the following layout . in section 2",
    "we introduce basic but the most important notions of data element , function and concept .",
    "section 3 defines the structure of data elements which is a nested partially ordered set .",
    "section 4 describes the structure of sets which is opposed to the structure of elements .",
    "section 5 is devoted to describing how the formal constructs of com can be interpreted .",
    "section 6 provides a discussion of this approach , its benefits and subtle properties . in section 7",
    "we describe how the principles of com are used in a novel column - oriented framework for agile data integration and transformations , and section 8 makes concluding remarks .",
    "_ com makes a very simple and natural assumption that a data element is a _ value_. in computer science , the main characteristic of values is connected with the mechanism of representation : values represent themselves directly by their content and can be passed exclusively by copying the whole content . in particular , it is not possible to share a value or to represent it indirectly via another value ( if it is not part of some other construct as will be described below ) .",
    "anything can be considered a value if its contents can be copied as one whole .",
    "examples of values are numbers like 25.76 or letters like ` b ' .",
    "_ copies and locations .",
    "_ if one value can produce many copies then an important question arises : is a copy of a value equivalent to the original value or it is a different element with the same content ?",
    "for example , if number 5 is copied from one database to another then will the second copy be treated as a new element or there still exists only one value ?",
    "it is a quite controversial question because both options are important . on one hand , there is only one number 5 independent of where and how it is used . on the other hand ,",
    "copying a value is a creation procedure which by definition produces something new and we need to take it into account .",
    "if values are considered in isolation then com assumes that all copies of one value are equivalent ( as it is accepted in mathematics ) . however , multiple copies of one value have different locations .",
    "these locations provide a context which allows us to distinguish different representations of the same data .",
    "thus com distinguishes between values themselves and their existence in different locations .",
    "when we say that a value was changed then we actually mean that the content in some location was changed and it does not influence other locations",
    ".    _ tuples . _",
    "any value has some structure .",
    "values the structure of which is hidden or ignored are referred to as _ primitive values _ ( also called elementary , system or atomic values in other models ) .",
    "new values can be created by using a _ composition _ of existing values .",
    "formally , such a composition is represented by _",
    "tuples _ which are treated in their accepted mathematics sense by capturing the notion of an ordered list .",
    "a tuple is a value written in angle brackets @xmath0 enclosing its member values .",
    "a tuple consisting of @xmath1 members is called @xmath1-tuple and @xmath1 is called its _",
    "arity_. tuple members are distinguished by their relative location which in com is referred to as _ dimension _ ( also called attribute , column , property , slot , variable or characteristic in other models ) .",
    "dimension and the corresponding member are separated by colon ( we also used equality in other publications ) . if @xmath2 is a tuple then @xmath3 is a dimension and @xmath4 is a member stored in this dimension . by definition ( of values ) , tuples are composed of copies of the member values which get distinct locations in the tuple .",
    "thus tuples are constructs where copies of other values exist .",
    "but since a tuple itself is also a value , it can not be shared or represented indirectly  it can be only copied , for example , become a member of another tuple .",
    "there is one special value represented by empty tuple @xmath5 ( also denoted by null ) which has empty structure .",
    "it is assumed that adding empty value to a tuple ( in any dimension ) does not change it : @xmath6 . to avoid infinite structures we prohibit inclusion of a ( non - empty ) value into itself directly or indirectly and hence value composition is an acyclic graph .",
    "_ extension _ is an approach to building new values by using composition ( tuples ) where one constituent ( tuple member ) , called _ super - element _ or base element , has a special semantic role and uses .",
    "all other constituents taken as a whole are referred to as an _ extension _ or _ segment _ , that is , a segment or extension is a tuple without its base .",
    "we will use a convention that a base dimension has a special name _",
    "super _ and is written as the first member separated from the extension members by bar symbol : @xmath7 . here",
    "@xmath8 is a super - element and @xmath4 is a member of the extension .",
    "it can be also written as @xmath9 where @xmath8 is a base and @xmath4 is an extension .",
    "a tuple with empty extension is equal to the base . a tuple with empty base is equal to the extension : @xmath10 .",
    "therefore , _ any _ tuple can be represented as a sequence of segments where the very first segment is empty tuple and each next segment extends the previous one : @xmath11 where @xmath12 are segments .",
    "all possible tuples are then represented as a tree of extensions where empty tuple is a root , a parent is a base for its children and a child is an extension of its base .",
    "it is a tree because there is only one base for any tuple and cycles are prohibited .",
    "note that in this definition of extension , there is no difference from normal tuples except that one dimension has a special name ( _ super _ ) . in the next section",
    "we will describe how this special dimension is used to constrain possible tuples .",
    "_ functions _ in com are treated in their accepted mathematical sense as a mapping from a set of input values into a set of output values where exactly one output value is associated with each input value .",
    "a function is denoted as @xmath13 where @xmath14 is a set of input values , called _ domain _ , @xmath15 is a set of all output values , called _ range _ , and @xmath16 is an argument that takes its values from @xmath14 .",
    "function input can be written either as an argument in parentheses , @xmath17 , or before the function using _ dot notion _ , @xmath18 .",
    "one element of the mapping defined by a function @xmath19 is referred to as a _ function element_. thus a function can be represented as a set of all its elements : @xmath20 , @xmath21 .",
    "one distinguishing feature of com functions is that formally they define some output for _ all _ input values .",
    "however , the empty output , @xmath22 , is semantically interpreted as having no output , that is , the input is not mapped . if all inputs from the domain are mapped to empty value , @xmath23 , @xmath24 , then this function is called _",
    "empty function_. the benefit is that we can formally work with functions returning empty values precisely as with normal functions by forgetting about the fact that not all input values can be mapped . from the data modeling point of view",
    ", a distinguishing feature of com functions is that they define mappings between values with _",
    "arbitrary _ domain - specific structure rather than only between primitive types .    _ identity and entity functions_. in the previous section we defined value as a tuple composed of other values with certain positions .",
    "an alternative representation of composition is that tuple dimensions are treated as functions ( rather than locations or positions ) which return tuple members : if @xmath25 then @xmath3 is a function such that @xmath26 or @xmath27 in dot notation .",
    "then a value is represented as a tuple of functions and these member functions are used to access tuple members given a tuple .",
    "now let us ask a question : what happens with these functions if a tuple is copied ?",
    "a function is a mapping that can be represented as a set of function elements , and hence there are two possibilities : elements of this mapping are also copied or the mapping is shared among all copies of the tuple . according to this distinction , a function which",
    "is passed by - value by copying its definition ( mapping ) is referred to as an _ identity function _ and a function which is passed by - reference is referred to as an _",
    "entity function_. it is convenient to think of an identity function as storing its outputs within the tuple itself ( so a tuple is used as storage ) and hence identity functions are copied along with tuples . in contrast ,",
    "entity functions store their outputs outside of the tuple and there exists only one such definition shared among all tuples .    _ data element .",
    "_ com uses two kinds of tuples : _ identity tuples _ are composed of only identity function outputs and are written in angle brackets @xmath28 .",
    "_ entity tuples _ are composed of only entity function outputs and are written in parentheses @xmath29 .",
    "a _ data element _ in com is defined as an identity tuple with an associated entity tuple the entity functions of which are defined on the identity : @xmath30 } e=\\langle \\ldots , f : a,\\ldots \\rangle(\\ldots , g : b,\\ldots)\\ ] ]    importantly , only identity is a value while entity tuple ( outputs of all entity functions ) is not a value .",
    "an entity can not be copied or passed as one whole .",
    "only entity constituents  outputs of individual entity functions  are values and can be copied . if identities are normal values then why do we call them identities ? because identities are values with an associated entity and identities provide the only way to represent and access entities .",
    "thus identities represent not only themselves ( by - value ) but also the associated entity ( by - reference ) .",
    "two elements are considered identical if they have the same identity .",
    "_ function extension .",
    "_ generally , a tuple can involve functions with the same name as in its members but they will be completely unrelated . yet , it is not so for super - elements and it is one of the main reasons for their introduction .",
    "if an extension defines a function already used in its super - element , @xmath31 , then the extension is said to _ override _ the super - function .",
    "com introduces a novel mechanism for overriding functions . instead of completely hiding the super - function and returning an arbitrary value",
    ", an extension makes a contribution to the value returned by the super - function . in the above tuple",
    ", the value @xmath32 returned by the super - function can not be completely overridden by the extended function but rather it is modified . formally , overridden functions must satisfy a function extension principle which postulates that _ a value returned by a function must extend the value returned by its base function _ ( fig .",
    "[ figure01 ] ) : @xmath33 } e=\\langle",
    "a|b \\rangle \\rightarrow e.f=\\langle a.f|b.f \\rangle\\ ] ]    function output can be represented as a sequence of values each returned by this function applied to one segment of the identity .",
    "if a function is not defined for a segment then its output is supposed to be empty tuple which does not change the result .",
    "the function extension principle can be expressed in terms of partial order as will be described in section 3.2 .",
    "its novelty and main benefit is that data fields can be overridden by making them more specific in extensions .",
    "an example can be found in section 4.2 and in @xcite where also the reverse overriding strategy is described .",
    "_ concept _ is a syntactic construct for describing the structure of data elements in com .",
    "it is a template which only declares functions but does not provide their definitions ( it does not define function elements ) .",
    "concepts are used as data types for various storage elements like variables , fields , parameters , collections etc .",
    "a concept is defined as a couple of two classes : one identity class and one entity class .",
    "both classes are defined as a combination of functions ( also called dimensions or fields ) which are typed by other concepts or primitive types .",
    "if a field belongs to the identity class then it declares an identity function and if it belongs to the entity class then it defines an entity function .",
    "a concept with the empty entity class is equivalent to conventional constructs describing value types like classes in c++ or struct .",
    "a concept with the empty identity class is equivalent to a conventional class like that in java .",
    "_ concept instances .",
    "_ instances of identity classes are values which can be copied or stored in variables having this ( or more general ) concept .",
    "instances of entity class are entities the dimensions of which can be retrieved given the identity .",
    "for example , a bank account could be described by the following concept :    * * ` concept ` * * `  account  ` + `  ` * * ` identity ` * * `  ` + `  char(10 )  bankno  ` + `  char(10 )  accno  ` + `  ` * * ` entity ` * * `  ` + `  person  owner  ` + `  double  balance `    this concept has 4 functions : 2 identity functions and 2 entity functions .",
    "any variable of this concept will store a value with the structure described by the identity class of concept ` account ` ( two fields in this example ) . and",
    "this variable can be used to retrieve values from the entity class fields like the account balance",
    ". thus concepts can be thought of as conventional value types describing values ( say , domains in rm ) with a number of associated functions returning values depending on this value .",
    "_ concept inclusion .",
    "_ a concept can be extended by another concept and this relation among concepts is _ called inclusion_. for example , we could define a concept ` bank ` and then extend it by a concept ` account ` :    * * ` concept ` * * `  bank  ` + `  ` * * ` identity ` * * `  ` + `  char(10 )  bankno  ` + `  ` * * ` entity ` * * `  ` + `  char(10 )  name `    * * ` concept ` * * `  account  ` * * ` in ` * * `  bank  ` + `  ` * * ` identity ` * * `  ` + `  ` [ line - through]*`char(10 )  bankno ` * `  ` + `  char(10 )  accno  ` + `  ` * * ` entity ` * * `  ` + `  person  owner  ` + `  double  balance `    note that we removed the ` bankno ` field from the ` account ` concept because it is modeled via inclusion relation ( extension ) .",
    "in other words , now the bank number field is a super - dimension .",
    "variables of the ` account ` concept will still store values with two fields : account number and bank number inherited from the super - concept .    _ overriding fields . _ a sub - concept can override a field of its super - concept by making its type more specific according to the function extension principle ( 2 ) ( see also type constraint in section 3.2 ) .",
    "for example , if super - concept ` a ` has a field ` location ` of type ` country `    * * ` concept ` * * `  a  ` + `  ` * * ` entity ` * * `  ` + `  country  location  //  base  field `    then the sub - concept ` b ` can override this field by defining it as having type ` city `    * * ` concept ` * * `  b  ` * * ` in ` * * `  a  ` + `  ` * * ` entity ` * * `  ` + `  city  location  //",
    "overridden  field `    importantly , ` city ` must be included in ` country ` , that is , a field type can be made only more specific than that in the super - concept . what the overridden field will store ?",
    "instances of ` b ` will store only the city segment while the country segment will be stored in the super - element of type ` a ` . here",
    "it is also important that one super - element can be shared among many sub - elements which means that each sub - element adds also its own extensions to the fields defined in the super - element ( see also discussion of the type constraint in section 3.2 ) .",
    "_ properties of concepts .",
    "_ one important methodological consequence of using concepts as data types is that data modeling starts from defining values which can be used by themselves or as references ( identifiers ) . and",
    "after that entity properties can be added as functions of identities .",
    "identities can exist without entities but entities can not exist without identities .",
    "therefore data modeling is getting more value - oriented and identity - oriented in comparison to the traditional entity - focused approaches .",
    "another consequence is that hierarchies are integral and natural part of any data type and the whole data modeling process .",
    "the main advantage of inclusion is that it automates what in many situations has to be done manually .",
    "also , concepts generalize conventional classes and can be used as normal classes but at the same time they can model hierarchies of objects ( similar to prototype - based programming and the hierarchical data model ) .",
    "having some constraints imposed on the structure of a set of data elements is important because they are assumed to be used for representing data semantics by excluding meaningless states . in mathematics , a structure imposed on a set ( for example , graphs , topologies , orders , geometries or matroids )",
    "is represented by an associated relation .",
    "a specific feature of com is that it uses partially ordered sets as a structural constraint imposed on data elements .",
    "this constraint does not depend on the kind of functions ( identity or entity ) and therefore in this section we will assume that an element is a conventional tuple .    _",
    "strict partial order _ is a binary relation @xmath34 ( less than ) on elements of the set @xmath35 .",
    "if @xmath36 ( @xmath4 is less than @xmath8 ) then @xmath4 is a _ lesser _ element and @xmath8 is a _",
    "greater _ element .",
    "this relation satisfies the properties of irreflexibity and transitivity : @xmath37 } \\forall a \\in r , \\neg ( a < a ) \\\\\\ ] ] @xmath38 } \\forall a , b , c \\in",
    "r,(a < b ) \\land ( b < c ) \\rightarrow a < c\\ ] ]    the property of antisymmetry holds as a consequence of the above two properties : @xmath39 } \\forall a , b \\in r , a < b \\rightarrow \\neg ( b < a)\\ ] ]    _ partially ordered set _",
    "( poset ) @xmath40 is a set @xmath15 with a strict partial order relation @xmath34 established on its elements .",
    "element @xmath4 is said to be immediately less than @xmath8 , @xmath41 , if @xmath36 and @xmath42 .",
    "the number of immediate greater elements of this element is referred to as _",
    "arity _ or dimensionality .",
    "_ primitive _ elements do not have any greater elements .",
    "_ lattice .",
    "_ if any two elements @xmath43 both have a least upper bound @xmath44 ( supremum ) and a greatest lower bound @xmath45 ( infimum ) then this poset is a _",
    "lattice_. for a finite set , a lattice has two special elements .",
    "the greatest element @xmath46 , called _ top _ , is greater than any other element of the set : @xmath47 .",
    "the least element @xmath48 , called _ bottom _ , is less than any other element of the set : @xmath49 .",
    "a _ labeled poset _ ( and lattice ) is a set where all instances of the partial order relation have labels .",
    "if @xmath4 is less then @xmath8 with label @xmath3 then it is written as follows : @xmath50 .",
    "all immediate greater elements are supposed to have unique labels .",
    "_ tuple ordering principle .",
    "_ in mathematics , partial order is represented as a binary relation @xmath51 . to represent a poset it is necessary to define another set . in com ,",
    "partial order is represented by tuples themselves with no need in any additional set .",
    "the connection between these two representations is established by the tuple ordering principle which postulates that a _",
    "tuple is immediately less than any of its members _ :",
    "@xmath52 } \\langle \\ldots , f :",
    "e,\\ldots\\rangle < _ f^1 e\\ ] ]    equivalently , an element is immediately greater than any tuple where it is a member : @xmath53 .",
    "labels correspond to dimensions and top element corresponds to empty tuple : @xmath54 .",
    "this principle can be used to represent an existing poset by writing each element as a tuple of its immediate greater elements .    _ function ordering principle . _",
    "the tuple ordering principle is written in terms of functions as follows : @xmath55 } f(e ) > _ f^1 e\\ ] ]    it means that function output value is immediately greater than the function input value . given a poset ,",
    "it can be represented by functions corresponding to labels .",
    "conversely , a number of functions can be represented as a labeled poset ( if they satisfy this structural constraint ) .",
    "_ tuple inclusion principle .",
    "_ a tree of sub - elements is represented by _ strict inclusion _",
    "relation @xmath56 .",
    "if @xmath57 ( @xmath4 is included in @xmath8 ) then @xmath4 is called a _ sub - element _ and @xmath8 is called a _ super - element_. sub - elements are said to be included in their super - elements .",
    "a connection between tuples and inclusion relation is established by the tuple inclusion principle : @xmath58 } \\langle super : s | \\ldots\\rangle \\subset^1   s\\ ] ]    it means that an extended element is immediately included in its base element . since _",
    "super _ is a normal dimension , inclusion @xmath56 is a subset of partial order @xmath34 : @xmath59    in other words , some instances of partial order which are labeled by _ super _ are also instances of inclusion relation . top element of the lattice @xmath60 is also referred to as a _ root _ of the inclusion hierarchy .    a _ nested set _",
    "@xmath61 is a set @xmath15 with an inclusion @xmath56 established on its elements .",
    "it is essentially a tree of elements where the root is the empty tuple and each element has many extensions but only one super - element . given a nested set @xmath61 , it can be represented as a number of tuples each defined as an extension of its immediate super - tuple : @xmath62    _ type constraint . _",
    "inclusion relation is not simply a subset of partial order .",
    "they are connected via _ type constraint _ which is a structural analogue of the function extension principles ( 2 ) : @xmath63 } e \\subset^1 a \\land a < _ f^1 c \\land e <",
    "_ f^1 d \\rightarrow d \\subseteq c\\ ] ]    its purpose is to exclude ( semantically meaningless ) situations by guaranteeing that _ all _ constituents of a sub - element are included in the corresponding constituents of the super - element : @xmath64    for example ( fig .  [ figure02 ] ) , function @xmath3 returns @xmath65 for element @xmath8 , @xmath66 , and therefore all extensions of this function must return some extension of the element @xmath65 .",
    "in particular , function @xmath3 must return some extension of @xmath65 for element @xmath67 , and @xmath3 can not return @xmath68 for @xmath67 .",
    "this can be fixed if @xmath68 is made an extension of @xmath65 so that it conforms to the diagram in fig .",
    "[ figure01 ] .",
    "the use of the type constraint for overriding fields is demonstrated in section 4.2 .",
    "type constraint can be described in terms of category theory and functors .",
    "a functor is a structure preserving mapping between two categories .",
    "a nested set can be interpreted as a category with elements as objects and instances of inclusion relation as arrows ( morphisms ) .",
    "a ( non - super ) function is a ( covariant ) functor which maps this element to some other element .",
    "the goal of the type constraint is to preserve the inclusion structure , that is , output elements returned by the same function must have the same structure as input elements .",
    "in our case , input elements have nested structure and hence output elements also must have nested structure .",
    "type constraint and function extension principles are similar to covariance and contravariance of parameters in programming languages .",
    "more specifically , it is analogous to _ covariant return types _ where a more specific overriding method can return a more specific type than that returned by its base method .",
    "also , many programming languages support this mechanism for generic parameters . for function types ,",
    "covariance and contravariance were first described in @xcite where it was observed that it is safe to use a function that takes more general arguments and returns a more specific type than the overridden function .",
    "_ nested partially ordered set _",
    "@xmath69 is a set @xmath15 with strict partial order @xmath34 and strict inclusion @xmath56 relations established on its elements which satisfy type constraint ( 6 ) .",
    "a database can be formally defined as a nested partially ordered set .",
    "more specifically , a _",
    "concept - oriented database _ is a finite set of elements @xmath15 satisfying the following conditions :    * any element is an identity tuple with an associated entity tuple according to the definition ( 1 ) * any element is less than its tuple members ( function outputs ) so that @xmath15 is a partially ordered set according to the tuple ordering principle ( 3 ) * any element is an extension of some super - element so that @xmath15 is a nested set according to the tuple inclusion principle ( 5 ) * all elements satisfy the type constraint ( 6 )    this structure can be represented as a conventional finite lattice where each element has one upward path to the top element interpreted as set nesting ( inclusion ) .",
    "an example of such structure is shown in fig .",
    "[ figure02 ] where inclusion tree ( of super - dimensions ) is drawn by bold lines . also , there are two kinds of instances of partial order relation corresponding to identity tuples ( solid lines ) and entity tuples ( dashed lines ) .",
    "solid lines define the data itself , that is , what is stored and passed as values .",
    "dashed lines define shared data , that is , what is stored persistently .",
    "an independent but very important mechanism is that this structure allows for labels with duplicate names but it restricts its use according to the type constraint ( structural analogue of the function extension principle ) .",
    "another way to visualize nested partially ordered sets is to show it is a nested euler diagram with both sets and elements partially ordered or a tree representing inclusion relation with nodes partially ordered @xcite .",
    "nested partial order is a structural approach to representing a concept - oriented database .",
    "it is an alternative to the functional approach described in the previous sections and syntactic approach based on the concept - oriented query language .",
    "an advantage of this representation is that it emphasizes structural aspects of the model ( relationships among elements ) but its disadvantage is that it is too abstract for implementation purposes where functional and syntactic approaches are mores suitable .",
    "but probably the most serious drawback of this representation is that it does not distinguish between data elements and sets , particularly , it does not say anything about differences between schema and instances .",
    "this issue is considered in the next section .",
    "in the previous sections we described the structure of data elements but we did not say anything explicitly about the sets these elements are in ( by assuming that all elements exist within one set ) . the goal of this section is to introduce a set as an explicit construct of the model .",
    "sets in com provide a mechanism for declaring certain constraints on the structure of data elements .",
    "this means that if an element is a member of some set then it has to satisfy the constraints associated with this set and it can not have arbitrary structure anymore . since the structure is described by functions ( an element is defined as a number of mappings to other elements ) , sets should restrict functions that can be used to describe these elements .",
    "_ set _ is defined very similar to data elements as one tuple of identity functions and an associated tuple of entity functions : @xmath70    where @xmath71 , @xmath72 , and @xmath73 , @xmath74 are identity and entity functions , respectively .",
    "note that sets are defined in terms of other sets treated as elements of the model . essentially , a set is a combination of other sets which play a role of ranges for its functions . and there is only one way to create a new set : specify its functions .    _",
    "structure of sets .",
    "_ we can forget about set members and treat sets as normal elements .",
    "then all properties of data elements and constraints applied on their structure are also valid for sets . in particular , we assume that all sets ( treated as elements by ignoring their members ) are partially ordered and hence we apply to them the corresponding terminology : greater and lesser sets , super- and subsets , primitive sets , top and bottom sets .",
    "the only difference is in the interpretation : instead of data elements we use sets and instead of function elements we use function declarations via their domains and ranges .    _",
    "set types .",
    "_ set type involves two parts : a description of the mechanism for storing elements ( like a table consisting of rows or a hash map ) , and the type of elements . in data modeling ( in contrast to programming ) , only the latter is normally important .",
    "this means that a set type is defined via the type of its elements while the implementation of the storage is provided by the system .",
    "for example , we could say that a model needs a set of bank accounts without specifying what kind of storage this set will use . the storage for this set can be chosen separately like row - store or column - store .",
    "the type of data elements in com is specified via concepts ( section 2.3 ) and also concepts are used to describe set types ( by assuming some default storage type ) . in coql , a set of elements of certain type is written as a concept name in parentheses .",
    "for example , ` ( account ) ` denotes a set of bank accounts .    _",
    "set extension .",
    "_ just like data elements , a set can extend another set if one of the identity functions represents a base set . in its limited form ,",
    "this mechanism can be used to add new functions to an existing set by inheriting the base functions .",
    "however , it is more general than the classical extension mechanism because it supports object hierarchies and a more general mechanism for overriding functions .",
    "a _ concept - oriented database _ is a number of set elements and data elements .",
    "both of them have nested partial order relation as a constraint on their structure .",
    "data elements of the database are represented by the functions of the set elements .",
    "sets without function definitions ( without data ) define a schema . thus defining a database schema",
    "is reduced to declaring new sets in terms of already existing set declarations .",
    "syntactically , it is done by defining concepts .",
    "an empty database has only primitive sets .",
    "there is only one way to declare a new set which consists in specifying the following components :    * exactly one superset @xmath75 ( if not specified explicitly then by default it is assumed to be the root ) * zero or more range sets @xmath76 for identity functions with unique names @xmath77 * zero or more range sets @xmath78 for entity functions with unique names @xmath79    there are two kinds of primitive sets : sets that define values like numbers or strings , and sets that provide a mechanism of referencing .",
    "the sets of the former kind provide conventional data types but they do not have any entity functions .",
    "the sets of the latter kind appear in explicit form only in com ( implicitly they should exist in any system that provides persistence or representation by - reference ) . essentially , such a set is a provider of generic references for its subsets and in a simplified form it could be declared as follows :    * * ` concept ` * * `  reference  ` + `  ` * * ` identity ` * * `  ` + `  integer  reference  ` + `  ` * * ` entity ` * * `  ` + `  byte  getdata(integer  offset ) `    a data management system can provide several types of such primitive references for different purposes .",
    "for example , there could be different references for small sets and big sets , for local storage and network distributed storage and so on .",
    "what is important is that for every new set , a superset has to be chosen and this superset defines whether the new set will be a conventional data type ( passed by - value ) or a reference type ( passed by - reference ) .",
    "more complex system can provide a possibility to develop concepts which implement some user - defined logic of persistence and access ( see @xcite for more information ) .",
    "an example of a concept - oriented schema is shown in fig .",
    "[ figure03 ] .",
    "identity functions are represented by solid lines : bold lines show super - dimensions and normal solid lines represent other identity dimensions .",
    "any set that is intended to store data by - reference must have reference as a direct or indirect root .",
    "if this set has to have many instances for one super - element then it is necessary to add other identity dimensions .",
    "for example , the set ` city ` is included in ` country ` but it also has an additional identity dimension so that many city instances can be created within one country instance . note that the ` person ` set does not have own identity dimensions and hence its instances will be identified by system references .",
    "entity functions are shown by dashed lines and they return a value associated with the current identity but shared among all other elements .",
    "for example , every account has a balance and every person has an associated bank account and address .          _ product . _",
    "all possible elements of a set are defined via the product of all its identity sets ( including the superset ) : @xmath80    here @xmath75 is a superset and @xmath81 are other greater identity sets .",
    "this definition of the product operation has the following properties :    * the arity of the product is equal to the number of identity sets ( including the superset ) what conforms to the conventional mathematical definition of product . for comparison , the arity in rm is equal to the sum of arities of the source sets .",
    "* entities of the source sets are not taken into account .",
    "* product operation defines only identities .",
    "entity functions of the new set can be defined either explicitly for all element or defined as an expression in terms of other functions ( derived dimension ) .",
    "* product is a lesser set with respect to all its source sets .",
    "thus product is not an isolated set ",
    "it exists within the structure of its source sets and is connected with them via functions .    _",
    "_ creating a subset is one of the most wide spread operations where it is necessary to produce a new set containing elements from one source set satisfying certain properties .",
    "a subset in com is defined as a set without own identity but inheriting identity from the superset .",
    "its elements are selected by providing an additional predicate @xmath82 which has to be true for all selected elements : @xmath83    here @xmath84 is a subset of @xmath75 and each element from @xmath84 references some element from @xmath75 via its super - function without adding new functions ( neither identity nor entity ) . by adding functions to the entity part",
    "we can define extended sets precisely as they are treated in object - orientation .",
    "note again that a subset is not defined in isolation by abstractly selecting necessary elements : a subset is an element of the model with a certain position in its structure .",
    "_ derived functions _ are defined via expressions computing their output from the values returned by other functions in the database .",
    "any derived function is defined in the context of the current element , accessed via a special _ this _ function , and returns a value from its declared range .",
    "the simplest ( row - based ) derived functions use arithmetic expressions and dimensions of the current set .",
    "for example , we could define a function which returns the ratio between employee age and salary :    ` age2salary ( )  =  this.age ( )  /  this.salary ( ) `    dot notation can be used to access functions of greater elements . for example , a function returning complete address simply concatenates several strings :    ` address ( )  =  ` + `  address.country.name ( )  +  ` + `  address.city.name ( ) `    however a really powerful mechanism for accessing arbitrary functions in the database is provided by a novel arrow notation described below in this section .",
    "_ set operations .",
    "_ these operations manipulate sets of elements rather than individual items .",
    "two most important operations for set manipulations are project and de - project .",
    "_ project _ , denoted by right arrow , is applied to a set of elements and returns all distinct outputs of the specified function : @xmath85    in terms of partial order it is defined as follows : @xmath86    since projection is a set , it contains any element only one time without duplicates .",
    "_ de - project , _ denoted by left arrow , is an opposite operation which returns all inputs which are mapped to the elements from the argument via the specified function : @xmath87    in terms of partial order it is defined as follows : @xmath88    de - project operation can be also defined in terms of inverted functions in category theory . if @xmath89 is a function then inverted function @xmath90 , where @xmath91 is a powerset of @xmath84 , returns a set of inputs for a certain output : @xmath92 } f^{-1 } ( x)=\\ { a \\in e | f(a)=x \\}\\ ] ]    de - project operation is then defined as a union of all outputs of the inverted function : @xmath93    _ arrow notation .",
    "_ project and de - project operations can be applied to the result returned by the previous operation .",
    "this approach is referred to as _ arrow notation _ because it is very similar to the conventional dot notation .",
    "the main difference and advantage of arrow notation is that it is intended for manipulating and navigating through sets rather than through instances in a graph .",
    "also , this notation explicitly uses two directions for navigation via inversion ( de - project ) .",
    "another advantage is that it does not use joins and group - bys but rather relies on references which is very simple and natural approach .",
    "dot notation is especially useful if we take into account semantics of references and the data structure in com so that arrows are not simply navigation operations but rather operations having a significant semantic load like changing the level of details or change the generality level .",
    "assume that we have such basic mathematical constructs like tuple or set as well as more complex structures like poset or topology .",
    "is it already a data model ?",
    "no . in order to use a structure for data modeling",
    "it is necessary to define its meaning in common terms accepted in real life .",
    "this is done by defining data semantics and it is therefore of primary importance for data modeling .",
    "earlier we have already described some basic semantics .",
    "for example , we postulated that datum ( data element ) is a value and values are represented by tuples .",
    "below we will describe more complex semantic constructs .",
    "_ references .",
    "_ com assumes that a reference _ is _ a value and in this sense we can not distinguish between normal values like number 5 and references ( so number 5 may well be a reference ) .",
    "what really turns a value into a reference is the possibility to provide access to other values .",
    "this possibility is integrated into any data element in com via the duality principle .",
    "references are implemented via functions the implementation of which is hidden so we actually do not know where data is stored .    _",
    "_ characterization is perhaps one of the most wide spread approaches to describe things where an element is supposed to have attributes which may take values .",
    "it exists in almost all other data models but in com it is especially simple because it does not distinguishes between attributes storing primitive values , complex values , objects or multiple - valued attributes .",
    "there is only one basic way to directly characterize things in com : to store ( identities of ) other things in the definition .",
    "note also that any element can be characterized by other elements and , vice versa , it can characterize other elements ( if it does not break structural constraints ) .",
    "_ set - valued attributes .",
    "_ it is a very important feature because many things are characterized by a subset of other things rather than by a single value .",
    "many existing models provide a straightforward solution to this problem by simply marking a field as a set - valued or collection . however , this approach is difficult to formalize and it leads to numerous problems in complex models with complex relationships .",
    "for example , what if the subsets of values used to characterize other elements are themselves characterized by set - valued attributes ?",
    "the desire to formalize the mechanism of set - valued attributes was one of the main motivations for introducing the nested relation model ( nrm ) @xcite .",
    "com does not provide set - valued attributes as a basic feature because it makes the model more complicated without necessity . instead",
    ", this mechanism is provided at higher level using the assumption that _ lesser elements represent subsets characterizing a greater element_. if it is necessary to have this characteristic as an attribute then it can be defined as a derived function which is equivalent to normal dimensions but returns a ( computed ) subset of elements . for example",
    "[ figure03 ] ) , all account holders of a bank can be returned by the following derived function of the ` bank ` concept which deprojects this bank to the ` person ` concept :    ` ( person )  bank::accountholders ( )  {  ` + `  return  this  ` + `  < -  bank  < -  ( account )  ` + `  < -  account  < -  ( person )  ` + ` } `    _ relationships . _",
    "a relationship is a dedicated data modeling constructs which is used to establish an association between data elements .",
    "the idea of using relationships was proposed in the entity - relationship model ( erm ) @xcite .",
    "although relationships provide very powerful means for conceptual modeling , their use has a number of drawbacks : ( i ) there exist many possibilities to relate the same elements and therefore the use of relationships is normally quite ambiguous and depends on the application @xcite , ( ii ) it is not clear when to use relationships and when to use attributes , ( iii ) it is not clear what is the difference between relationships and normal data . for a unified model",
    "these are quite serious issues . on the other hand ,",
    "relationships are known to be very useful and can not be ignored .",
    "therefore , com does not provide relationships as a dedicated construct but rather uses the following principle : _ a common lesser concept is treated as a relationship or dependency connecting its greater concepts_. so if we know that some existing concepts are somehow related or depend on each other then we simply introduce a common lesser concept which connects them .",
    "for example , ` person ` in fig .",
    "[ figure03 ] is a normal concept but in com it is also treated as a relationship between people and addresses which are its greater concepts .    _",
    "_ a specific feature of com is that it provides two mechanisms for modeling containment ( is - in ) relation : by - reference using partial order and by - value using inclusion relation . in order to include an element in another element it is enough to reference it .",
    "this relation can be changed by changing this reference .",
    "a more specific type of containment is provided by inclusion relation .",
    "it is used for modeling identification hierarchies like postal addresses . note that an element can be also viewed as consisting of its greater elements . however",
    ", this relation has completely different semantics and describes part - of relation : greater elements are parts within their common lesser element .    _ general - specific and inheritance .",
    "_ com does not provide this relation as a separate construct .",
    "instead , com assumes that it is a particular case of containment : _ to be contained within some element means to be more specific element and to inherit properties of the container_. thus all lesser elements and sub - elements are interpreted as more specific elements with respect to their greater elements and super - elements .",
    "the classical inheritance is modeled by creating a new concept without own identity and adding only some entity dimensions . in the general case , however , an element may have many more specific extensions inheriting its properties .    _ multidimensional space . _",
    "another important semantic interpretation consists in thinking of elements as existing in a multidimensional space .",
    "this approach is used in multidimensional models where the roles of axes and coordinates are assigned to the elements of the model .",
    "com supports this interpretation by assuming that _ lesser elements are points while greater elements are coordinates_. for example , if a book element references a publisher then the book is interpreted as a point while the publisher is one of its coordinates . here",
    "again we see that an element can be simultaneously a point with respect to its greater elements and a coordinate for its lesser elements .",
    "com is more flexible than the standard multidimensional models because it does not rely on predefined cubes , dimensions , facts and measures which are application - specific roles .",
    "data is thought of as originally existing in a multidimensional space so that it is always possible to say what coordinates this element has and how many dimensions this schema has .",
    "the partially ordered schema in com can also be viewed as a generalization of star , snowflake and snowstorm schemas where lesser concepts correspond to fact tables and greater concepts describe detail tables .",
    "_ a graph can be viewed either as a formal structure ( like poset ) or as a semantic model where things are supposed to be connected by relationships .",
    "both uses are widely used in different models . yet , not in com .",
    "although references in com are viewed as a basic mechanism for connecting elements and therefore can be interpreted as edges in a graph , it is a wrong interpretation .",
    "com assumes that if two elements are connected via a reference then they by definition belong to different levels and play different roles : container - member , coordinate - point , master - detail or general - specific .",
    "however , a graph metaphor is known to be very popular and useful in data modeling so the question is how two elements can be connected by an edge ?",
    "it is done using the following principle : _ common lesser elements in com are interpreted as edges connecting their greater elements interpreted as vertices_.",
    "_ how identities are different primary keys and oids ? _ identity is by definition a value .",
    "in contrast , a key is a subset of entity attributes and hence is not a value as such .",
    "identities are much closer to conventional ( primitive ) references and oids @xcite .",
    "the difference is that identities ( like primary keys ) have arbitrary domain - specific structure .",
    "_ should identities be modeled ?",
    "_ essentially the question is whether identities are part of the problem domain and whether they are data at all .",
    "these questions are quite important because many models ( mostly object - oriented ) assume that entity identifiers have a primitive form and have to be provided by the platform and hence identities are not part of the problem domain .",
    "also some models assume that only primitive values should be used while all more complex structures should be modeled by objects .",
    "com assumes that identities are data just because they are values .",
    "since values play primary role in data modeling there should be dedicated means for their modeling .",
    "the question whether some kind of data belongs to the problem domain or to the system is about the level of abstraction .",
    "consequently , both identities and entities can belong to the problem domain or be provided by the platform .",
    "_ is entity a value ?",
    "_ no , entity is not a value .",
    "only constituents of an entity returned by individual entity functions are values .",
    "writing an entity as a tuple is a convenient way to represent related elements but in contrast to identity tuples , entity tuples can not be passed or stored as one whole ( one value ) .",
    "entity constituents are values which are accessible using one identity but there is nothing else that unites them . in particular , they are not supposed to be stored together side - by - side as is implicitly assumed in many other models .    _ why concepts ?",
    "_ concepts generalize classes and provide a number of benefits .",
    "they allow for modeling simultaneously values and objects by hiding this separation behind one name .",
    "it is important if the structure changes because element ( fields , variables , parameters etc . )",
    "types do not depend on the internal structure of concepts and distribution of functions between identity and entity parts .",
    "concepts also significantly simplify data modeling at conceptual level because now there is no need to distinguish between value types and object / entity types .",
    "it is enough to have only one construct for all data typing tasks .    _ why functions ?",
    "_ functions provide a convenient mathematical abstraction for the underlying data access and storage mechanisms .",
    "in other words , we do not actually know where the data is stored and how it is being accessed but we know that for each input value we can get the corresponding output value by using function names .",
    "the use of functions is very natural in the context of column - stores providing higher performance for analytical workloads because functions can be very naturally mapped to the column - oriented representation of data .",
    "note that functions are storage elements , that is , all data is stored in functions as opposed to storing data in rows of sets .    _",
    "com vs. logical models .",
    "_ due to their generality , both the functional @xcite and the logical views on data can be treated as the lowest common denominator for other data models .",
    "this means that differences between them are of fundamental character and it is hardly possible to justify that one of them is better than the other .",
    "we would like to describe only one such fundamental feature distinguishing com ( which belongs to the class of functional data models ) and models based on the first - order logic : how they represent connectivity between things .    in logical data models ,",
    "if we want to say that things are somehow connected then we define a predicate which is true for these things ( fig .",
    "[ figure04 ] left ) .",
    "for example , if we want to describe which accounts belong to which banks then it is done via a two - place predicate ` belongsto(acc , bank ) ` .",
    "the most important consequence is that all such relationships are symmetric ( horizontal ) and the predicates may have any arity including unary , binary and @xmath1-ary predicates .",
    "another property is that this model has only two levels : atoms and propositions ( predicates ) . in particular , it is not possible to make propositions about other propositions .",
    "of course , this can be overcome by introducing additional roles and treatments for predicates , for example , a unary predicate could represent set membership relation ( one predicate then represents one set ) and binary predicates could represent symmetric relationships like roles in description logics ( dl ) . yet",
    ", the usefulness of these extensions only emphasizes that having only atoms and predicates is not enough for a good data model .",
    "the main construct for describing connectivity in functional data models is that of function .",
    "if two things are related than one of them is mapped to the other using some function ( fig .",
    "[ figure04 ] right ) .",
    "for example , an account element is mapped to the bank element using the function ` belongs ` .",
    "importantly , it is not equivalent to having binary predicates .",
    "it is possible to model functions by means of predicates but this should viewed as a workaround in the case functions are not directly supported .",
    "one difference between functions is predicates is that the former are directed ( function is a mapping ) while the latter are symmetric .",
    "one immediate advantage of this property is that functions can be composed and hierarchies have natural support while the composition of predicates is performed quite differently .",
    "note also that functions can well support the horizontal symmetric connectivity as it is done by predicates .",
    "if an element is mapped to many other elements using different functions then it is treated as a tuple of other elements which is analogous to a proposition about these elements . in this sense , the functional paradigm ( and com ) can cover both dimensions : vertical ( a constituent might have its own constituents ) , and horizontal ( an element can be composed of many constituents ) . in formal logic ,",
    "they are modeled using predicates . in the functional approach ( and in com ) , they are modeled using two dedicated constructs : functions and sets ( of tuples ) .        _",
    "com vs. the functional data model ( fdm ) . _",
    "the goal of fdm @xcite is to provide simple but general means for manipulating data by relying on the mathematical notion of function .",
    "com also uses this notion and hence the question is what the differences between these two models are .",
    "first , fdm uses classical approach to the treatment of data elements and data typing while com distinguishes between identity functions and entity functions .",
    "second , fdm functions are mappings from only primitive entity identifiers to either values or other entity identifiers . in particular , arbitrary values can not be used as inputs to fdm functions .",
    "com functions are mappings between _ arbitrary _ values which also can be references .",
    "third , the structure of fdm functions is not constrained and it is an arbitrary graph .",
    "com functions are constrained by partial order which is important for representing data semantics . in other words , a function in com is not simply a mapping ",
    "it is a semantic construct with many interpretations ( output is more general than input , output is a coordinate for input , output is a characteristic of input , output is a container for input ) .",
    "fourth , com provides special super - functions and the principle of function extension which underlie several important mechanisms like object hierarchies , incremental overriding , and reverse overriding .",
    "hierarchical organization of entities and property inheritance is provided in the extended functional model ( efdm ) @xcite but it is a standard ( object - oriented ) approach to inheritance : an instance of a type is also an instance of its super - types , and a function which applies to a type also applies all of its subtypes .",
    "com generalizes it by using object hierarchies and a more complex overriding strategy .",
    "_ why only single - valued functions ? _ functions in com are not simply mappings between sets  they have quite significant semantic load , that is , to define a function means to define meaning for a connection between two sets .",
    "multi - valued functions make natural semantic interpretation more difficult .",
    "for example , if we want to interpret a function as returning a coordinate for this object along one axis then it is quite natural to allow for only one output because an object in real world can not simultaneously have several locations .",
    "also , if an element has several coordinates or characteristics then it is difficult to answer the question about dimensionality . indeed ,",
    "if an element has @xmath1 single - valued properties then it is naturally positioned in an @xmath1-dimensional space .",
    "but if one of these properties can return 2 or more outputs then the dimensionality obviously grows because they can be varied independently .",
    "hence , the object is positioned in a space with variable dimensionality where dimensions are not clearly identified which is not a good feature .",
    "similar difficulties appear in any model that wants to introduce multi - valued , relation - valued properties or nested relations and this mechanism leads to numerous complications .",
    "for that reason , com does not use multi - valued functions at the level of schema , that is , a function always returns a single value . yet , in practice , multi - valued characteristics and relationships are met very frequently so we can not simply ignore them . to model them",
    "com uses the principle that _ if a thing is characterized by several other things then these characteristics are lesser elements_. essentially , this means that a multi - valued function is a reversed function and hence they can be defined via de - projection operation . in addition",
    ", com uses derived functions which are defined via other functions and are allowed to have multi - valued output .",
    "therefore , multi - valued properties can always be defined via derived functions which return either lesser elements or sets of elements retrieved from other sets in the schema using arbitrary query .    _",
    "com vs. the relational model ( rm ) .",
    "_ com can be reduced to rm by assuming that all sets have only primitive greater sets .",
    "therefore , most formal aspects of the relational algebra will also work in com .",
    "if greater sets are sets of values with arbitrary structure then we get the object - relational model ( orm ) @xcite . in both cases",
    "we get a kind of two - level schema with domains and relations at two levels . interpreting com identities in relational terms",
    "is ambiguous .",
    "one way is to assume that primary keys correspond to com identities .",
    "however , primary keys are composed of normal attributes which have the same status as all other attributes while in com identities are treated quite differently .",
    "another way is to assume that com identities correspond to surrogates which in addition may have user - defined structure modeled by identity classes .",
    "this analogy is much closer to the purpose of com identities however surrogates and row identifiers are not part of rm in its classical formulation and the need in this mechanism is a quite controversial issue . in this context",
    ", com provides additional arguments in favor of having primitive identifiers in a good data model .",
    "another significant difference of com from rm is that com is inherently semantic model which provides various general semantic interpretations to its constructs rather than being a formal algebra for manipulating tuples and relations .",
    "_ where are joins ? _ joins can be used in com by imposing constraints on product operation .",
    "for example ( fig .",
    "[ figure05 ] ) , we could find the product of sets ` person ` and ` address ` , and then select only elements that have equal values in some fields :    ` ( person  p ,  address  a  |  p.address  = =  a ) `    in most cases however , joins are used to retrieve elements connected via references but if the mechanism of referencing is not inherently supported ( as it is in rm ) then the only way is to implement it manually at the level of queries by means of joins .",
    "the use of joins for implementing references has significant drawbacks @xcite : ( i ) it is a low level and error - prone operation @xcite , ( ii ) it lacks semantics by easily producing wrong results because the intention of the operation is not obvious from its syntax , ( iii ) it is a cross - cutting concern because the same fragments are explicitly written in many queries , ( iv ) joins describe the logic of connectivity which appears at the same level as the domain - specific logic of retrieval , ( v ) joins are not analytics friendly .",
    "therefore , com does not encourage the use of product operation with filters for that purpose .",
    "instead , arrow notation should be used which inherently supports references and set operations .",
    "there are more complex patterns of connectivity and com distinguishes two of them ( fig .  [ figure05 ] ) : _ common greater values _ and _ common lesser values_. the former pattern means that two data elements or concepts are related if they have a common greater element .",
    "the latter pattern means that two elements are related if they have a common lesser element .",
    "obviously , the first pattern corresponds to joins and the second pattern corresponds to relationships ( discussed in section 5 ) .",
    "thus com establishes a nice duality between two connectivity patterns .",
    "these two patterns provide higher level mechanisms of connectivity based on references .",
    "for example , ` person ` and ` company ` in fig .",
    "[ figure05 ] are not directly connected in the schema .",
    "yet , they can be connected indirectly and there are only two general ways : to find a common greater element like a common ` address ` , or to find a common lesser element like a common ` contract ` .",
    "both patterns can be used in queries for finding related elements without classical joins :    ` ( person )  - >  ( address )  < -  ( company )  ` + ` ( person )  < -  ( contract )  - >  ( company ) `    this duality of joins and relationships is quite important for understanding the nature of connectivity . in particular , the connectivity via lesser elements ( relationships or dependencies ) provides a basis for the mechanism of inference in multidimensional space @xcite .",
    "it is an important mechanism because it allows for going beyond numeric analysis and doing in multidimensional space what has always been a prerogative of logic - based models .",
    "_ universal relation model ( urm ) _",
    "the goal of this extension of rm was to relieve the user of the need for specifying concrete join conditions and to achieve access path independence where a query is written in terms of only attributes .",
    "for example , a query for getting all wheel suppliers is written as follows :    ` retrieve  ( suppliers )  ` + ` where  parts  =  wheel `    note that this query does not provide any indication how suppliers are connected with parts  it is the task of the system to translate it into the logical structure of relations .",
    "the main idea of urm consists in regarding the database as a single relation , called the universal relation , so that all other relations are its projections . essentially , the universal relation is a kind of canonical representation where a database is viewed as one whole rather than as a flat set of relations .",
    "such a holistic view is absent in rm but is important for many data management tasks : easy querying , inference , schema matching , analysis , consistency and others .",
    "yet , the assumption of universal relation was shown to be incompatible with many aspects of the relational model and it did not result in a successful foundation for data modeling .",
    "the problems raised in the context of urm are still very actual and at the general level com provides an alternative solution to them by relying on order - theoretic basis ( as opposed to relational algebra ) .",
    "more specifically , bottom concept in com can be viewed as an analogue of the universal relation .",
    "the difference is that the universal relation is defined over a set of ( primitive ) attributes while com schema has many levels within a partially ordered set .",
    "this difference is illustrated in fig .",
    "[ figure06 ] .",
    "assume that there are three sets of ` suppliers ` , ` parts ` and ` sp ` which is a relationship between ` suppliers ` and ` parts ` .",
    "the task is to automatically retrieve all parts delivered by some suppliers .",
    "urm analyzes joins between relations and tries to propagate initial constraints from suppliers to parts . in this example , there exist two paths .",
    "the first one uses a join between ` suppliers ` and ` sp ` on ` s # ` and then a join between ` sp ` and ` parts ` on ` p # ` .",
    "the second path uses a join between ` suppliers ` and ` parts ` on ` city ` .",
    "the problem is that such a propagation through joins is ambiguous : joins are undirected and there are many possible paths from the source to destination .",
    "com relies on the structure of references by partially ordering the relations and propagation through lesser elements . in this example ( fig .",
    "[ figure07 ] ) , the system builds the propagation path from ` suppliers ` down to ` sp ` and then up to ` parts ` .",
    "such paths have clearer semantics and less ambiguity @xcite .            _",
    "why partial order ? _ the only known work where partial order relation is laid at the foundation of data modeling is @xcite where `` partial order database is simply a partial order '' .",
    "however , this approach relies more on formal logic and it is focused on manipulating many partial orders .",
    "one reason why partial order is not widely used in data modeling is that it is a quite strong constraint for possible structures .",
    "indeed , self - references and cycles are very common in database designs especially in the presence of graph databases .",
    "therefore , a natural question is whether it is a good idea to use partial order and why it was introduced at all ? shortly , partial order in com is introduced for the same reason trees are used for inheritance .",
    "more specifically , references in com have much higher semantic load than in other models : they represent more general elements , containers , and coordinates .",
    "if we want to have a semantic model ( and com is intended to be a semantic model ) then we need to exclude meaningless situations where an element is contained in itself , an element is a coordinate for itself and so on . and it is precisely where partial order works perfectly . if for some reason it is necessary to have a self - reference or a cycle then it always can be done by scarifying semantic consistency .",
    "all queries will still work except for smarter mechanisms like inference which can be confused by cycles as well as applications and processes which assume partial order like olap analysis .",
    "a better solution consists in marking dimensions which are known to reference a more specific element ( while all dimensions by default reference more general elements ) .",
    "such markers essentially resolves semantic cycles in element definitions by retaining the model in consistent state .    _",
    "com vs. conceptual modeling .",
    "_ com does not completely belong to the class of traditional conceptual models such as entity - relationship model ( er ) , universal modeling language ( uml ) or object - role modeling ( orm ) @xcite .",
    "these models have higher level of description and wider scope of applicability by allowing to represent more domain knowledge using richer sets of data modeling constructs .",
    "in contrast , com is positioned as a logical data model with strong support for conceptual modeling .",
    "it is important that com not only brings more semantics to the logical level but also generalizes some semantic relations by simplifying the process of modeling as described in section 5 .",
    "thus the main advantage is that conceptual modeling is not a separate layer with its own modeling constructs but rather is an integral part of the logical level of the model .",
    "in this section , we describe one possible application of com which has been implemented in a framework for agile data transformations and manipulations , called datacommandr @xcite .",
    "it is a data processing engine behind conceptmix @xcite  a tool for self - service data transformations .",
    "data manipulations in datacommandr are described using the concept - oriented expression language ( coel ) .",
    "the aim of coel is to provide a simple and natural language for describing complex queries against multiple tables without using such classical set - oriented operations as joins , group - by and aggregation .",
    "the closest analogue of coel is data analysis expressions ( dax ) used in microsoft tabular model @xcite .",
    "our main research goal when implementing datacommandr and coel was to demonstrate that it is possible and even easier to work with such a functional ( column - oriented ) approach without the need in having set operations like joins and group - by .",
    "let us illustrate how this new approach differs from the classical view on data manipulations .",
    "assume that we have already some data stored in multiple tables .",
    "our goal is to derive new data in the form of one or more tables each having some columns .",
    "the currently dominating approach is to define new tables in terms of already existing ( or previously defined ) tables , that is , a new table is a function of other tables : @xmath94",
    ". normally , this definition is made at the level of one row , that is , an output row is defined as a function of input rows : @xmath95 .",
    "the looping strategy is then implemented automatically by the underlying system like rdbms , etl or mapreduce .",
    "note that the main unit of definition and the return value of expressions in such languages is one row ( tuple ) .",
    "in contrast , the main unit of definition in coel is that of column , that is , a column is defined as a function of other columns : @xmath96 .",
    "just as new tables are normally defined at the level of rows ( tuples ) , new columns in coel are defined at the level of values ( in both cases the goal is to exclude explicit loops from the language ) . in other words , an output value in coel expressions",
    "is defined as a function of input values : @xmath97 .",
    "thus instead of using set operations and returning tuples , coel expressions use column operations and return values . in this sense , coel is similar to how formulas are defined in typical spreadsheet applications with the main difference that it defines columns via other columns rather than cells via other cells .",
    "a table in datacommandr is created as a java object without data and without any essential properties because all the data is stored in columns .",
    "coel is used in tables only for representing constraints ( analogous to sql where clause ) .",
    "however , table constraints are actually represented as functions returning true or false and therefore have the same form as coel column definitions described below .",
    "if some columns already store data ( for example , loaded from a file ) then we can easily define a new _ calculated column _ as a function which returns one primitive output value for each input row . for example",
    "[ figure08 ] ) , we could compute a column with the total amount for each line item in a purchase order by defining the following column :    ` dccolumn  amount  =  ` + `  createcolumn(````amount ` '' ` ,  `` `` lineitems ` '' ` ,  `` `` double ` '' ` ) ;  ` + ` amount.definition  =  ` * * `` ` [ price ]  [ quantity ] ` '' * * ` ;  `    the first line creates a java column object with the name ` amount ` , input table ` lineitems ` and output ( primitive ) table ` double ` .",
    "the second statement provides a definition for this new column as a coel expression ( written in bold ) .",
    "note that coel expressions refer to other elements by name in square brackets .",
    "of course , this column could be easily defined in sql by adding this formula to the select clause . yet , from the conceptual point of view , it is important that the ` amount ` column is thought of as an independent data modeling unit with its own definition . in other words , we have made an important conceptual shift by switching from `` table views '' to `` column views '' .",
    "it is easy to add columns , delete columns , index columns and perform column - oriented operations .",
    "a table in this approach does not have its own data at all  it is an element of the schema level rather than the data level .",
    "defining new derived columns within one table is easy .",
    "what is not trivial is working with multiple tables .",
    "for example , assume that we have two tables with purchase orders and line items loaded from two csv files .",
    "these tables have only primitive columns and therefore not directly connected but we would like to define a new column by accessing data from the both tables . normally the only possibility is to apply join operation and produce a new table with the data from the two source tables .",
    "datacommandr provides a different mechanism by defining _",
    "link columns _ which explicitly connect two tables without producing a new table . to define a link column",
    "it is necessary to return a tuple rather than a primitive value .",
    "for example , if we want to define a column in the table ` lineitems ` which returns an element of the ` orders ` table then it can be done as follows :    ` dccolumn  order  =  ` + `  createcolumn(````order ` '' ` ,  `` `` lineitems ` '' ` ,  `` `` orders ` '' ` ) ;  ` + ` order.definition  =  ` + `  ` * * `` ` tuple (  supp=[supplierid ] ,  no=[orderno ]  ) ` ' ' * * ` ;  `    here the output table ` orders ` is supposed to have columns ` supp ` and ` no ` while the input table has columns ` supplierid ` and ` orderno ` .",
    "once this column has been defined , it can be used in formulas to access orders given line items but a separate join table is never built .",
    "another mechanism where datacommander changes the way data is being manipulated is data aggregation .",
    "the standard approach assumes that all the data is stored in one table and then it is necessary to specify which columns are used for grouping and aggregation .",
    "the result is then returned as a new table with all groups and the corresponding aggregated values for the group members .",
    "datacommandr assumes that one or more aggregated columns can be added to any existing table by providing the corresponding definition . instead of defining a new table as a result of some set operation ( like group - by )",
    "we simply define a new _ accumulation column _ which is supposed to `` accumulate '' multiple values provided by another table . for example",
    ", we can compute the total amount for each order by summing up the prices of all its line items :    ` dccolumn  total  =  ` + `  createcolumn(````total ` '' ` ,  `` `` orders ` '' ` ,  `` `` double ` '' ` ) ;  ` + ` total.definition  =  ` + `  ` * * `` ` accu (  [ lineitems ] ,  [ order ] ,  [ amount ] ,  sum  ) ` ' ' * * ` ;  `    here the accumulation operator ` accu ` takes four parameters : a fact table ( ` lineitems ` ) , a grouping column of the fact table ( ` order ` ) , a measure column of the fact table ( ` amount ` ) and an aggregation function ( ` sum ` ) .",
    "the procedure will loop through all facts in the table ` lineitems ` , retrieve the measure value returned by the ` amount ` calculated column , and then add this value to the element pointed to by the ` order ` link column . here",
    "we again see that we essentially define a new column in terms of other columns without any set operations .",
    "it is much more flexible and intuitive approach especially taking into account that the group , measure and aggregation function parameters can be arbitrary coel expressions so that we can collect data using rather complex paths between tables .",
    "in summary , com is based on the following basic tenets that distinguish it from other models :    _ duality principle .",
    "_ com emphasizes the differences between what is passed by - value and what is represented indirectly by using other values .",
    "therefore , a data element in com is defined as a value ( identity tuple ) with associated other values ( entity tuple ) .",
    "such couples are modeled by a novel type modeling construct , concept , which generalizes conventional classes .",
    "a model is then split into two branches  identity modeling and entity modeling  by producing a nice yin - yang style of balance and symmetry between two sides of the problem domain .    _",
    "inclusion principle .",
    "_ one identity dimension of a data element has a special semantic interpretation .",
    "it is supposed to represent a container where this element is a member , a more general element made more specific by this element , and an address space where this element exists by providing an extending segment for it , a base element the properties of which this element inherits .",
    "an important difference from other models is that inclusion principle in com unifies containment ( is - in ) and specialization with inheritance ( is - a ) .",
    "this principle underlies a new function overriding mechanism where a more specific function provides an extension for its base function ( rather than completely overriding it ) .",
    "inclusion principle eliminates the asymmetry between classes and their instances which now both exist in a hierarchy .    _",
    "partial order .",
    "_ com assumes that all elements are partially ordered .",
    "the main purpose and advantage of partial order is that it can describe many existing semantic relationships : object - attribute - value ( object is a lesser element and value is a greater element ) , multidimensional space ( point is a lesser element and coordinate is a greater element ) , containment ( greater elements are collections for lesser elements ) , relationships ( lesser elements relate greater elements ) . data modeling is then reduced to partially ordering a set of concepts while their semantics is derived from this structure .",
    "m. atkinson , f. bancilhon , d. dewitt , k. dittrich , d. maier , s. zdonik , the object - oriented database system manifesto . in proceedings of the first international conference on deductive and object - oriented databases , 223 - 40 , 1989 .",
    "p. atzeni , c.s .",
    "jensen , g. orsi , s. ram , l. tanca , r. torlone , the relational model is dead , sql is dead , and i do nt feel so good myself . _",
    "acm sigmod record _ , 42(2 ) , 64 - 68 , 2013 .",
    "p. buneman , functional database languages and the functional data model , position paper for the fdm workshop , 1997 .",
    "retrieved may 1 , 2014 , from : http://www.cis.upenn.edu/  peter / fdm - position.html l. cardelli , a semantics of multiple inheritance .",
    "proc . of the international symposium on semantics of data types .",
    "lncs 173 , 51 - 67 , 1984 .",
    "s. chaudhuri , u. dayal , v. narasayya , an overview of business intelligence technology .",
    "_ communications of the acm _ , 54(8 ) , 88 - 98 , 2011 .",
    "chen , the entity - relationship model - toward a unified view of data .",
    "_ acm transactions on database systems _ , 1(1 ) , 9 - 36 , 1976 .",
    "codd , a relational model of data for large shared data banks .",
    "_ communications of the acm _ , 13(6 ) , 377 - 387 , 1970 .",
    "codd , extending the database relational model to capture more meaning .",
    "_ acm transactions on database systems ( tods ) _ , 4(4 ) , 397 - 434 , 1979 .",
    "j. cohen , b. dolan , m. dunlap , j.m .",
    "hellerstein , c. welton , mad skills : new analysis practices for big data . in _ proc .",
    "35th international conference on very large data bases ( vldb 2009 ) _ , 1481 - 1492 , 2009 . m. dahchour , a. pirotte , e. zimnyi , generic relationships in information modeling .",
    "_ journal on data semantics iv _ , lncs 3730 , 1 - 34 , 2005 .",
    "dittrich , object - oriented database systems : the notions and the issues . in _ proc . intl .",
    "workshop on object - oriented database systems _ , 2 - 4 , 1986 .",
    "halpin , object - role modeling : principles and benefits . international journal of information system modeling and design ( ijismd ) , 1(1 ) , 33 - 57 , 2010 .",
    "w. kent , the unsolvable identity problem .",
    "extreme markup languages ( eml 2003 ) , 2003 .",
    "w. kim , j.f .",
    "garza , n. ballou , d. woelk , architecture of the orion next - generation database system .",
    "_ ieee tkde _ , 2(1 ) , 109 - 124 , 1990 .",
    "kulkarni , m.p .",
    "atkinson , efdm : extended functional data model , computer journal , 29(1 ) , 38 - 46 , 1986 .",
    "f. leymann , a survey of the universal relation model .",
    "data & knowledge engineering 4(4 ) , 305 - 320 , 1989 .",
    "s. manegold , p.a .",
    "boncz , m.l .",
    "kersten , optimizing database architecture for the new bottleneck : memory access , the vldb journal 9 , 231 - 246 , 2000 .",
    "pedersen , multidimensional modeling . _",
    "encyclopedia of database systems_. l. liu , m.t .",
    "\" ozsu ( eds . ) .",
    "springer , ny . , 1777 - 1784 , 2009 .",
    "pedersen , c.s .",
    "jensen , multidimensional database technology .",
    "_ ieee computers _ , 34(12 ) , 40 - 46 , 2001 .",
    "d. raymond , partial order databases .",
    "thesis , university of waterloo , canada , 1996 .",
    "m. russo , a. ferrari , c. webb , microsoft sql server 2012 analysis services : the bism tabular model .",
    "microsoft press , 2012 .",
    "a. savinov , datacommandr : column - oriented data integration , transformation and analysis . in _ proc",
    "international conference on internet of things and big data ( iotbd 2016 ) _ , 339 - 347 , 2016 .",
    "a. savinov , joins vs. links or relational join considered harmful . in _ proc . international conference on internet of things and big data ( iotbd 2016 ) _ , 362 - 368 , 2016 .",
    "a. savinov , conceptmix : self - service analytical data integration based on the concept - oriented model . in _ proc .",
    "3rd international conference on data technologies and applications ( data 2014 ) _ , 78 - 84 , 2014 .",
    "a. savinov , concept - oriented model and nested partially ordered sets .",
    "technical report tud - fl14 - 01 , technische universitt dresden , march 2014 .",
    "a. savinov , references and arrow notation instead of join operation in query languages .",
    "_ computer science journal of moldova ( csjm ) _ , 20(3 ) , 313 - 333 , 2012 .",
    "a. savinov , inference in hierarchical multidimensional space . in _ proc .",
    "international conference on data technologies and applications ( data 2012 ) _ , 70 - 76 , 2012 .",
    "a. savinov , concept - oriented programming : classes and inheritance revisited . in _ proc .",
    "7th international conference on software paradigm trends ( icsoft 2012 ) _ , 381 - 387 , 2012 .",
    "a. savinov , concept - oriented model : classes , hierarchies and references revisited . _ journal of emerging trends in computing and information sciences _ , 3(4 ) , 456 - 470 , 2012 .",
    "a. savinov , concept - oriented model : extending objects with identity , hierarchies and semantics .",
    "_ computer science journal of moldova ( csjm ) _ , 19(3 ) , 254 - 287 , 2011 .",
    "a. savinov , concept - oriented query language for data modeling and analysis . in l. yan & z. ma ( eds ) ,",
    "_ advanced database query systems : techniques , applications and technologies _ , igi global , 85 - 101 , 2011 .",
    "storey , understanding semantic relationships , the vldb journal 2 , 455 - 488 , 1993 .",
    "schek , m.h .",
    "scholl , the relational model with relation - valued attributes , _ information systems _",
    ", 11(2 ) , 137 - 147 , 1986 .",
    "sibley , l. kerschberg , data architecture and data model considerations . in _ proceedings of the afips",
    "joint computer conferences _ , 85 - 96 , 1977 .",
    "stein , delegation is inheritance . in _ proc .",
    "oopsla87 , acm sigplan notices _ , 22(12 ) , 138 - 146 , 1987 .",
    "m. thiele , w. lehner , real - timebi and situational analysis . in m.e .",
    "zorrilla , j .-",
    "n . mazn ,  .",
    "ferrndez , i. garrigs , f. daniel , & j. trujillo ( eds . ) , _ business intelligence applications and the web : models , systems and technologies _ , igi global , 285 - 309 , 2012 ."
  ],
  "abstract_text": [
    "<S> the plethora of existing data models and specific data modeling techniques is not only confusing but leads to complex , eclectic and inefficient designs of systems for data management and analytics . </S>",
    "<S> the main goal of this paper is to describe a unified approach to data modeling , called the concept - oriented model ( com ) , by using functions as a basis for its formalization </S>",
    "<S> . com tries to answer the question what is data and to rethink basic assumptions underlying this and related notions . </S>",
    "<S> its main goal is to unify major existing views on data ( generality ) , using only a few main notions ( simplicity ) which are very close to how data is used in real life ( naturalness ) . </S>"
  ]
}