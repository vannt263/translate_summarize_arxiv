{
  "article_text": [
    "rdf data is increasingly used in data management applications related to traditional computer science topics ( e.g. , search engines , semantic annotations , social tagging ) , as well as in contexts well beyond this traditional scope ( e.g. , rdf is becoming prevalent in many life science and in particular bioinformatics applications ) .",
    "these and other applications have significantly increased the volumes of rdf data to be handled .",
    "this size effect and the complexity and irregularity of rdf data pose significant challenges to the task of building an efficient query evaluation engine .",
    "rdf data consists of triples of the form ( _ subject _ , _ property _ , _ object _ ) .",
    "this seemingly simple data model leads to complex queries and expensive evaluation , since any meaningful question requires forming chains of several triples , which are translated to many - join queries over a single , huge table containing all the triples .",
    "one approach taken in order to handle such large data volumes consists of mapping the data into one or several relations , and storing them in a relational database management system ( rdbms ) , possibly endowed with specific indexes  @xcite .",
    "then , rdf queries expressed in sparql can be translated to sql queries  @xcite , which are evaluated by the rdbms .",
    "another approach consists of developing rdf - specific stores and query processors  @xcite , which still share some of the standard notions and features of relational storage engines .    ]",
    "these efforts aim at providing a generic , one - size - fits - all storage model for rdf .",
    "however , decades of research and development of rdbmss has shown that huge performance gains can be achieved by tuning the storage to the data sets and to the requirements of specific applications .",
    "this is typically achieved by establishing _ materialized views and/or indices _ specific to the data and workload  @xcite .",
    "another important aspect of rdf data management is that the rich semantic information , under the form , e.g. , of an rdf schema , can be associated to the data set . in this situation ,",
    "schema - based reasoning may lead to finding answers to a query , which would simply not be found by querying the data alone .",
    "thus , the interpretation of rdf queries may be affected by the existence of associated semantics , and this must be taken into account when designing a query - inspired set of views .",
    "we propose to demonstrate rdfviews  ( standing for _ rdf _ _ view _ _ _ s__election ) , a system that focuses on automatically choosing the materialized views which are most appropriate for a given data set and query workload .",
    "the tool provides many options to guide the search , into which it also incorporates the insights brought by an rdf schema , if one is available .",
    "rdfviews  outputs a set of proposed materialized views ( which are automatically created within an rdbms ) , as well as a set of rewritings ( or reformulations ) of the original workload , in terms of these materialized views .",
    "thus , rdfviews  can , in effect , be seen as a storage tuning wizard for rdf data , to be used in conjunction with off - the - shelf rdbmss .",
    "the tool s various steps and options can be easily inspected and controlled via a gui by rdfviews target users : administrators of large rdf databases .",
    "rdfviews  takes as input a set of conjunctive sparql queries .",
    "each query is endowed with a weight , reflecting its relative importance ( e.g. how often it is posed ) .",
    "we model our problem as a search state optimization problem , based on an existing proposal for selecting views to materialize in a relational setting  @xcite , which we adapted to the particularities of the rdf model . for a given query workload @xmath0",
    ", we define a state as the pair @xmath1 , where @xmath2 is the set of views to materialize and @xmath3 the rewritings needed to answer the queries of @xmath0 using exclusively the views in @xmath2 .",
    "we use three transitions , which can be applied to a given state and yield a new one : _ selection cut _ , _ join cut _ and _ view fusion_. intuitively , the first two aim at relaxing the queries , by removing some predicates . the third one attempts to fuse two candidate views , replacing them by a single one .",
    "the relaxation steps help eliminate constraints which differentiate two views , so that view fusion may be applied . if the workload queries have common sub - queries , these will be identified as useful views to materialize .",
    "the quality of each state is assessed using a _ quality function _ , which reflects the query execution time , the view maintenance cost and the space needed for materializing the views of the state . starting from an initial state , we apply the transitions and navigate in the search space according to a search strategy . as the _ initial state _ of our search",
    ", we choose the one that proposes to materialize exactly the query workload ( best execution time , worst view maintenance cost ) . at the end of the search we return the state with the best quality score ( minimum combined cost ) .",
    "the architecture of rdfviews  is depicted in figure  [ fig : system ] .",
    "the rdf data is initially stored into an rdbms as a single triple table ( _ tt _ ) ; for efficiency , and following many similar works  @xcite , the table is dictionary - encoded , i.e. , uris and string constants are assigned distinct integers , and the _ tt _ table stores triples of integers .",
    "the database administrator ( _ dba _ ) uses rdfviews  to further tune the store . to this end , she provides the sparql query workload to the * workload processor * through a graphical interface . in the presence of an rdf schema ,",
    "the queries are reformulated , compiling the knowledge of the schema inside them and transforming each query to a union of queries  @xcite .",
    "the ( possibly reformulated ) queries are used to create the _ initial state _ of the search .",
    "the initial state is then loaded to the * states navigator * , which constitutes the gist of our system .",
    "we have devised two exhaustive strategies that navigate through the whole search space . however , as the problem we address is known to be well above exponential , we employ heuristics which significantly prune the search space .",
    "moreover , we provide the option to apply some additional stop conditions : we identify states that have some specific characteristics and we do not allow more transitions to be applied on these states . more details about the search strategies can be found in  @xcite .",
    "once the search is finished , we obtain the best state according to our quality function and we materialize the views of this state , after translating them to sql ( * view materializer * ) .",
    "then , we push the rewritings contained in the best state to the * query executor * , which stores them for future use .",
    "whenever a user issues a query from the workload , the query executor uses the stored rewritings to efficiently answer the query by using the already materialized views .",
    "our system has been fully implemented in java 6 . the triple table and",
    "the materialized views are stored in postgresql v8.4.4 .",
    "we have built a web - based interface which enables users to interact with the system , extensively parameterize it and follow in detail the view selection process .",
    "screen captures and further details on the system can be found at the rdfviews  website .",
    "demo attendees will play the role of a database administrator . using the interface",
    ", they will first choose one of the pre - loaded rdf datasets ( among others , some of the the most widely - used rdf datasets will be available : barton , yago , uniprot and lubm ) , and the query workload for which they want to tune the database .",
    "they may also load their own datasets , modify the existing query workloads or add new ones .",
    "the queries can be modified either by using a sparql editor or through a visual editor we have created .",
    "finally , they will pick the rdf schema(s ) they wish to use .    before initializing the search for the best view configuration",
    ", attendees will define some additional details of the searching process , according to their specific preferences .",
    "in particular , they will choose whether they prefer a quick search , or a search that lasts longer but guarantees the optimal solution .",
    "furthermore , they will tune the quality function used by adjusting the weights of its components ( giving more importance to the query execution time , to the view maintenance or to the space needed ) .",
    "after the end of the search , the selected views are displayed , together with their space cost and performance gains .",
    "moreover , a graphical overview of the search space will be given .",
    "this information will also act as a feedback to the user , which may choose to tune differently the quality functions in a subsequent search etc .    to verify the performance benefits brought by rdfviews , attendees will then act as simple users issuing queries , which will be first answered against the triple table and then by exploiting the materialized views ."
  ],
  "abstract_text": [
    "<S> in recent years , the significant growth of rdf data used in numerous applications has made its efficient and scalable manipulation an important issue . in this paper </S>",
    "<S> , we present rdfviews , a system capable of choosing the most suitable views to materialize , in order to minimize the query response time for a specific sparql query workload , while taking into account the view maintenance cost and storage space constraints . </S>",
    "<S> our system employs practical algorithms and heuristics to navigate through the search space of potential view configurations , and exploits the possibly available semantic information - expressed via an rdf schema - to ensure the completeness of the query evaluation .    </S>",
    "<S> = 10000 = 10000    * categories and subject descriptors : * h.3.4 information storage and retrieval : systems and software ; h.2.1 database management : logical design    * general terms : * algorithms , design , performance    * keywords : * rdf data management , view selection , materialized views , query optimization , rdfs </S>"
  ]
}