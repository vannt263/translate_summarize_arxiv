{
  "article_text": [
    "unification based formalisms show a clear inability to deal in a natural way with phenomena such as the semantics of coordination , quantification scoping ambiguity or bound anaphora . as a matter of fact , although unification can be used to implement a weak form of @xmath0-reduction , it seems that this kind of phenomena is better handled by using some form of @xmath1-calculus @xcite .",
    "one possibility , which is at the heart of systems like @xmath1prolog@xcite , is to extend both the notion of term , to include @xmath1-abstraction and application , and the definition of unification to deal with @xmath1-terms . for this extension to be technically sound",
    "it is necessary to require @xmath1-terms to be well typed . on the other hand ,",
    "it turns out that if instead of using terms we use complex feature descriptions ( where conjunction replaces unification ) , we still can follow the same plan to produce a higher - order calculus of feature descriptions .",
    "is a simple formalism , based on categorial grammars , designed to test the practical feasibility of such an approach .",
    "the main reason for selecting a categorial framework for this experiment was that , due to the simplicity of the categorial framework , it allowed us to concentrate on the constraint calculus itself .",
    "another reason was also the close historical relationship between categorial grammars and semantic formalisms incorporating @xmath1-abstraction .",
    "extends categorial grammar by associating not only a category but also a higher - order feature description with each well - formed part of speech .",
    "the type of these feature descriptions are determined by the associated category .",
    "note also that a derivation leading to an unsatisfiable feature description is legal . when compared with other formalisms ( for instance , @xcite ) one of the main distinguishing features of is the fact that it computes partial descriptions of feature structures and not the feature structures themselves .",
    "it is important to notice that this calculus is easily modified to deal with constraints over finite or rational trees , instead of feature trees .",
    "also , the advantages of this kind of calculus , namely its decidability , over the use of general high - order logic programming systems , for processing semantic representations in nlp systems should be obvious . the rest of the paper proceeds as follows .",
    "we start by defining a feature description calculus as an hybrid of @xmath1-calculus and feature logics and we present its denotational semantics . in section [ cs ]",
    "we describe a complete constraint solver for higher - order feature descriptions . in section [ catgram ]",
    "we define constraint categorial grammars and briefly present its implementation .",
    "some final remarks are considered in section [ fr ] .",
    "the feature description calculus @xmath3  at the heart of our formalism is inspired both on the @xmath1-calculus and on feature logics @xcite . for technical reasons , namely that we want to ensure the existence of normal forms , it is a typed calculus .",
    "our base types are * bool * for truth values and * fs * for feature structures .",
    "our types are described by @xmath4 note that we exclude * fs * as the type of any feature description .",
    "this reflects our commitment to compute partial descriptions of feature structures rather than feature structures .",
    "now assume we are given a set of _ atoms _ @xmath5 , @xmath6 , ",
    ", a set of _ feature _ symbols @xmath7 , @xmath8 ,  , a set of _ feature structure variables _ @xmath9 , @xmath10 ,  , and , for each type @xmath11 , a set of _ variables of type @xmath11 _ @xmath12 , @xmath13 ,  .",
    "then the set of _ feature descriptions _ of type @xmath11 is described by @xmath14 where @xmath15 and @xmath16 denote either atoms or feature structure variables , and @xmath17 is a , possibly empty , sequence of feature symbols denoting a path in a feature structure .",
    "note that the language thus defined includes both feature logics and a typed @xmath1-calculus .",
    "we import from both theories such notions as substitution , free and bounded occurrences of variables , @xmath18 and @xmath19reductions and @xmath20-normal form .",
    "in particular , a _ closed feature description _ is a feature description with no free variables .",
    "moreover , feature constraints of feature logics , widely used in unification grammars , correspond to a subset of _ feature descriptions _ of type * bool * , without abstractions or applications .    to define a semantics for the calculus of feature descriptions",
    "we adopt the standard model @xmath21 of rational trees for feature structures ( see @xcite ) and associate with each type @xmath11 a semantic domain @xmath22 as follows @xmath23 from this point on a semantics for feature descriptions is defined in the same way as for feature logics and the typed @xmath1-calculus by noting that the standard boolean operations can be extended to all the semantic domains involved in a component wise fashion , e.g. @xmath24 more precisely , let an _ assignment _",
    "@xmath25 be a mapping defined on variables , such that @xmath26  and @xmath27 , for each type @xmath11 .",
    "as usual , @xmath28 $ ] denotes the assignment obtained from @xmath25 by mapping @xmath29 to @xmath30 .",
    "let @xmath31 , @xmath32 and @xmath33 denote the interpretation of features , paths and atoms in , respectively .",
    "furthermore , let @xmath34 be @xmath35 if @xmath16 is a variable and @xmath36 otherwise .",
    "then , the semantics of feature descriptions @xmath3  given an assignment @xmath25 is defined inductively , as follows : @xmath37\\!]}\\rho&= & \\rho(x_\\tau)\\\\   { [ \\![}t.p\\dot = s { ] \\!]}\\rho & = & \\left\\ { \\begin{array}{l }    1 \\;\\;\\;if \\;\\;p^{\\cal rt}(t^{\\cal rt}\\rho)= s^{\\cal rt}\\rho \\\\ 0 \\;\\;\\ ;    otherwise \\end{array } \\right . \\\\",
    "{ [ \\![}t = s{]\\!]}\\rho & = &   \\left\\ { \\begin{array}{l }    1 \\;\\;\\;if \\;\\;t^{\\cal rt}\\rho=",
    "s^{\\cal rt}\\rho \\\\ 0 \\;\\;\\ ;    otherwise \\end{array } \\right .",
    "\\\\\\end{array } & \\begin{array}{llll }    { [ \\![}\\lambda x.e_\\tau { ] \\!]}\\rho&= & { \\lambda\\!\\!\\lambda}v.{[\\![}e_\\tau    { ] \\!]}\\rho[v / x ] & ( v\\;\\in\\;{\\cal rt})\\\\       { [ \\![}\\lambda x_\\tau.e_\\tau ' { ] \\!]}\\rho&= & { \\lambda\\!\\!\\lambda}v.{[\\![}e_\\tau '    { ] \\!]}\\rho[v / x_\\tau ] & ( v\\ ; \\in\\;{\\cal d}_\\tau)\\\\ { [ \\![}e_{fs\\rightarrow\\tau } x.p{]\\!]}\\rho & = & ( { [ \\![}e_{fs\\rightarrow\\tau } { ] \\!]}\\rho ) { [ \\![}x.p{]\\!]}\\rho\\\\ { [ \\![}e_{fs\\rightarrow\\tau } a { ] \\!]}\\rho & = & ( { [ \\![}e_{fs\\rightarrow\\tau}{]\\!]}\\rho)a^{\\cal rt}\\\\ { [ \\![}e_{\\tau\\rightarrow\\tau ' } e_\\tau'{]\\!]}\\rho & = & \\ ( { [ \\![}e_{\\tau\\rightarrow\\tau ' } { ] \\!]}\\rho){[\\![}e_\\tau ' { ] \\!]}\\rho \\end{array } \\end{array}\\ ] ] where @xmath38 denotes function `` abstraction '' in set theory and @xmath39 means that @xmath40 is the domain of @xmath9 . for the conjunction operation , we define : @xmath41\\!]}\\rho & = & \\left\\ {    \\begin{array}{ll } 1 & \\mbox { if $ { [ \\![}e_{bool } { ] \\!]}\\rho=1 $ and        $ { [ \\![}e'_{bool } { ] \\!]}\\rho=1$}\\\\ 0 & \\mbox { otherwise } \\end{array}\\right.\\\\ { { [ \\![}e_{fs\\rightarrow\\tau } \\wedge e'_{fs\\rightarrow\\tau}{]\\!]}\\rho } & = & { \\lambda\\!\\!\\lambda}v.d \\wedge d'\\mbox { where $ \\begin{array}[t]{ll }    { { [ \\![}e_{fs\\rightarrow\\tau}{]\\!]}\\rho}={\\lambda\\!\\!\\lambda}v.d & ( v\\;\\in\\;{\\cal rt})\\\\     { { [ \\![}e'_{fs\\rightarrow\\tau}{]\\!]}\\rho}={\\lambda\\!\\!\\lambda}v.d ' & ( v\\;\\in\\;{\\cal rt } )    \\end{array}$}\\\\ { { [ \\![}e_{\\tau'\\rightarrow\\tau } \\wedge e'_{\\tau'\\rightarrow\\tau}{]\\!]}\\rho}&= & { \\lambda\\!\\!\\lambda}v.d \\wedge d'\\mbox { where $ \\begin{array}[t]{ll }    { { [ \\![}e_{\\tau'\\rightarrow\\tau}{]\\!]}\\rho}={\\lambda\\!\\!\\lambda}v.d & ( v\\;\\in\\;{\\cal d}_{\\tau)'}\\\\     { { [ \\![}e'_{\\tau'\\rightarrow\\tau}{]\\!]}\\rho}={\\lambda\\!\\!\\lambda}v.d ' & ( v\\;\\in\\;{\\cal d}_{\\tau ' } )    \\end{array}$ } \\end{array}\\ ] ] and analogously for the other boolean operations . if @xmath42 , @xmath43 , and @xmath44 then the semantics of * true * , for each type @xmath11 is defined by : @xmath45\\!]}\\rho}=1_{bool},\\\\ { { [ \\![}{\\bf        true}_{fs{\\rightarrow}\\tau}{]\\!]}\\rho}=\\lambda v. 1_\\tau \\;(v\\;\\in\\;{\\cal rt})\\\\     { { [ \\![}{\\bf true}_{\\tau'{\\rightarrow}\\tau}{]\\!]}\\rho}=\\lambda v.   1_\\tau\\;(v\\;\\in\\;{\\cal      d}_\\tau ) \\end{array}\\ ] ] and analogously for * false*.    an important property of the feature description calculus is the existence of normal form under @xmath0-reduction which is a simple consequence of well - typedness .",
    "another important property is that for any closed feature description of type @xmath11 we can decide if it is equivalent to @xmath46 .",
    "this last property is essentially an extension of the satisfiability problem for a complete axiomatization of feature logics .",
    "for this reason we will say that a feature description of type @xmath11 is satisfiable iff its semantics is not that of @xmath46 .",
    "our implementation of the feature description calculus is based on the reduction to normal form followed by the techniques used in @xcite for resolving complex feature constraints . in order to face the np - hardness of the satisfiability problem ,",
    "our approach was based in factoring out , in polynomial time , deterministic information contained in a complex constraint and simplifying the remaining formula using that information .",
    "the deterministic information corresponds to a conjunction of ( positive ) atomic constraints in _",
    "solved form_[multiblock footnote omitted ] , which we denote by @xmath47 .",
    "we say that @xmath48 is a _ partial model _ of @xmath49 if and only if every model of @xmath49 is a model of @xmath48 .",
    "when every model of @xmath47 is a model of @xmath49 , but no proper subset of @xmath47 satisfies this condition , we will say that @xmath48 is a _",
    "minimal _ model of @xmath49 . by using disjunctive forms",
    "it can be proved that any set of feature constraints @xmath49 admits at most a finite number of minimal models . in @xcite",
    "a rewrite system was presented that from a complex feature constraint @xmath50 produces a pair @xmath51 , where @xmath47 is _ solved form _ , @xmath52 is smaller than @xmath53 and such that @xmath54 and any minimal model of @xmath50 can be obtained by conjoining a minimal model of @xmath52 with @xmath47 .",
    "moreover the rewriting system is complete in the sense that @xmath55 is satisfiable , unless it produces @xmath46 as the final model .",
    "we now extend that rewrite system to higher - order feature descriptions .",
    "first we give some more characterizations of feature descriptions .",
    "a _ basic normal description _ of type @xmath11 is described by : @xmath56    then , every closed feature description in basic normal form will be of the form @xmath57 where @xmath58 denotes a sequence of bound variables of some types and @xmath59 is not an abstraction . omitting the @xmath1 prefix , given a feature description of type * bool * , @xmath59 , the solver will produce a partial model @xmath47 and a smaller feature description @xmath60 or * false * :    @xmath61    with the convention that after each application of one of the rewrite rules the new partial model is reduced to solved form ( or * false * ) .",
    "the complete rewrite system @xmath62 is :    @xmath63\\\\ ( \\lambda x.e_\\tau)a & \\rwm & e_\\tau[a / x]\\\\ ( \\lambda x_{\\tau'}.e_\\tau)e'_{\\tau ' } & \\rwm & e_\\tau[e'_{\\tau'}/x_{\\tau ' } ] \\end{array } & \\begin{array}{lll } \\neg ( \\lambda x.e)&\\rwm&\\lambda x. \\neg e\\\\ ( \\lambda x.e)\\wedge(\\lambda x.e')&\\rwm&\\lambda x.e \\wedge e'\\\\ ( \\lambda x.e)\\vee(\\lambda x.e')&\\rwm&\\lambda x.e \\vee e \\end{array}\\end{aligned}\\ ] ]    @xmath64    @xmath65    @xmath66    @xmath67    @xmath68{4cm}{if both $ e_\\tau$    and    $ e'_\\tau$   are $ { \\cal m}$-dependent with $ e''_\\tau$ } \\end{array}\\end{aligned}\\ ] ]    we assume that @xmath69-reductions will be performed whenever necessary .",
    "for simplicity we omitted the rules concerning negation .",
    "the rewrite system is divided in six groups , each one dealing with : ( 1 ) @xmath0-reduction ( where @xmath70 $ ] denotes the substitution in @xmath71 of @xmath9 for @xmath30 ) , abstraction and boolean operations for higher order types ; this rules are applied before any other rule ( 2 ) application and boolean operations ( 3 ) rewrite inside abstractions and applications ( 4 ) * false * and * true * ; ( 5 ) feature description of type * bool * , @xmath59 ; this rules essentially correspond to the feature constraint rewrite system in @xcite ( 6 ) distributive law ; this rule must apply only when both @xmath72 and @xmath73 have variables in common with @xmath74 , eventually through `` bindings '' in @xmath47.-dependence coincides with the one for complex feature constraints @xcite , if @xmath75 means @xmath9 occurs free in @xmath76 . given two constraints @xmath77 and @xmath78 and a model @xmath47 , @xmath77 and @xmath78",
    "@xmath47-dependent _ if and only if @xmath79 , where @xmath80 is the smallest set satisfying : if @xmath81 , then @xmath82 ; if @xmath82 and @xmath83 , then @xmath84 . ]",
    "if this last rule is omitted , the rewrite process becomes polynomial although incomplete .",
    "given a closed feature description @xmath72 the rewrite system is correct , terminating and complete in the sense that @xmath72 is satisfiable unless * false * is produced .",
    "moreover the final feature description is in basic normal form .    for a proof of the above results",
    "see @xcite .",
    "in this section we show how the expressiveness of categorial grammars can be augmented using feature descriptions .",
    "we will use a basic ( rigid ) categorial grammar ( @xmath85 ) , consisting of a set of categories , a lexicon which assigns categories to words and a calculus which determines the set of admissible category combinations . given a set of basic categories @xmath86 we define recursively the set of categories @xmath87 by : the elements of @xmath86 are categories ; if @xmath88 and @xmath89 are categories then @xmath90 and @xmath91 are categories . some unary ( lexical ) rules ( lifting , division , etc )",
    "will be added to provide a flexible @xmath85 which can cope with discontinuity and other linguistic phenomena .",
    "semantically these rules allow functional abstraction over displaced or missing elements .",
    "a constraint categorial grammar is a tuple @xmath92 where    1 .",
    "@xmath93 is a set of base categories 2 .",
    "@xmath94 is a map which associates with each category @xmath95 a type @xmath96 and satisfies @xmath97 3 .",
    "@xmath98 is a set of triples @xmath99 , where @xmath100 is a word , @xmath88 a category and @xmath76 is a feature description of type @xmath101 4 .",
    "@xmath102 is the set of inference rules to combine pairs @xmath103 of syntactic categories and feature descriptions ( semantic representation ) .",
    "the inference rules used in the current grammars are : @xmath104 plus a set of unary rules .      in figure [ fig1 ] .",
    "is given a fragment of an english grammar written in .",
    "we use @xmath105 for @xmath1 , & for @xmath106 and @xmath107 for @xmath108. all variables are bound and can be any string of letters .",
    "the let constructor allows the use of macros in the writing of the lexicon .",
    "the transformation constructor implements unary rules for type raising .",
    "type raising rules are just allowed for some categories and their application is controlled during execution .",
    "the lex constructor is used for each lexical entry . in this experiment",
    "we do not impose any type discipline ( hpsg style ) in the feature structures themselves .",
    "if we assign to each part of speech a feature structure , then an associated feature description will be of type @xmath109 .",
    "for instance , if we assign the type @xmath110 to `` john '' , with semantics @xmath111 , and assign the type @xmath112 to `` runs '' , with semantics @xmath113 , the sentence `` john runs '' would have the type @xmath110 and semantics @xmath114 .",
    "once more we note that the use of partial descriptions allows us to express directly , the relations between the several constituents .",
    "the semantic used is inspired in the ones in @xcite .",
    "is implemented in prolog augmented with the constraint solver for feature descriptions . in this section",
    "we briefly describe this implementation .",
    "although the feature descriptions used in the grammar are untyped , a type inference algorithm is used to infer types for each expression .",
    "moreover , for each lexical entry the type of the feature description is checked with that of the category and whenever possible the _ normal form _ of the feature description is computed .",
    "the inference rules are build - in in the grammar processor .",
    "currently , we use a bottom - up chart parser that builds a context - free backbone .",
    "each edge is a ( prolog ) term @xmath115 where @xmath116 is the category spanning from @xmath117 to @xmath118 and @xmath119 is the information to be used to extract the semantic representation , and that reflects how this edge was formed : if it was a lexical entry @xmath119 is a reference to it ; if it results from a left ( right ) application rule , it is a pair of references for its daughters ; if it results from a unary rule , it is a pair of references to the initial category and to that rule .",
    "when the parse trees are successful built , the semantic representation is extracted and the constraint solver applied .",
    "these two components can be interleaved in order to prune , as soon as possible , inconsistent edges . as is apparent from the sample grammar ( figure [ fig1 ] . )",
    "the semantic representations can become very cumbersome to write and visualize .",
    "so a graphical `` workbench '' , based on a tcl / tk interface to yap prolog , was provided to edit grammars and lexicon , as well as to visualize the parse trees and semantic representations ( as matrix boxes ) .      as an example we analyze the parsing of the sentence",
    "`` a man said that john read a book and mary died '' .",
    "there are two possible parse trees of this sentence , one with the coordination in the scope of the relative clause and other with a wider scope .",
    "the semantic representation of this sentence will be a feature description @xmath120 where x1 and x2 are partially represented in figures [ w2 ] . and [ w3 ] .. figures [ w4 ] . and [ w5 ] .",
    "show the semantics of the sentences `` john read a book '' and `` mary died '' , respectively . in the feature description x2 ( figure [ w3 ] . )",
    "the former semantics is identified with the value of x_1.arg1.scope.arg2 and the latter is identified with the value of x_1.arg2 . in the feature description x1 ( figure [ w2 ] . )",
    "the value of x_1.scope.arg2 is the feature structure corresponding to the coordination of the these two sentences .",
    "as remarked in the previous section , the parsing process first builds a parse forest using only the categories of lexical items and the inference ( and unary ) rules for syntactic categories .",
    "the parse tree of sentence we are considering is too large to be considered here , so figure [ w6 ] .",
    "shows only the parse forest of `` john read a book '' . in the first row",
    "we have the syntactic categories of each lexical item ( given in the lexicon or derived by a unary rule ) . in the following rows",
    "each entry corresponds to the possible ways of deriving a category spanning a portion of the input sentence .",
    "for instance , the category @xmath121 can be derived in the third row from @xmath122 and @xmath123 , spanning `` read a book '' .",
    "then for each parse tree that spans the whole sentence with root category @xmath15 , the semantic representation of the constituents are combined and if the constraint solver does not produce @xmath124 , a semantic representation is derived .",
    "the current implementation of shows the practical feasibility of using higher order feature structure descriptions as semantic representations . this reflects the fact that the complexity of the satisfiability problem for higher order feature descriptions is essentially the same as for feature logics .",
    "we should also point out that the good performance of the system results in part from its hybrid nature where a categorial grammar with atomic base categories is used to guide parsing .",
    "some more toy english grammars where written that can handle some kinds of discontinuity , modifiers and quantifier scope .",
    "however , the introduction of a type discipline and more general treatment of recursive lexical rules ( @xcite ) must be considered , in future work . on the other hand ,",
    "most recent developments of categorial grammars are based on the lambek calculus @xcite ( an intuitionist fragment of linear logic ) .",
    "some implementations for the propositional fragment are based on chart parsers @xcite and we conjecture that @xmath3calculus can be successfully used in such a systems , for process semantic representations . from an implementational perspective",
    "it would be helpful to study how current techniques employed in functional programming implementations , namely the use of combinators , can be imported for improve the computation of @xmath0-reductions .",
    "gosse bouma and gertjan van noord .",
    "constraint - based categorial grammars . in _ proceedings of the 15th international conference on computational linguistics and the 22nd annual meeting of the association for computational linguistics ( coling ) _ , 1994 .",
    "lus damas , nelma moreira , and giovanni  b. varile .",
    "the formal and computational theory of complex constraint solution . in c.",
    "rupp , m.  a. rosner , and r.  l. johnson , editors , _ constraints , language , and computation _ , computation in cognitive science , pages 149166 .",
    "academic press , london , 1994 .",
    "michael  j. maher .",
    "complete axiomatizations of the algebras of finite , rational and infinite trees . technical report ,",
    "ibm thomas j. watson research center , p.o .",
    "box 704 , yorktown heights , ny 10598 , u.s.a .",
    ", 1988 .",
    "gopalan nadathur and dale miller .",
    "an overview of @xmath1prolog . in robert",
    "a. kowalski and kenneth  a. bowen , editors , _ logic programming : proceedings of the fifth international conference and symposium _ , volume  1 , pages 810827 , seattle , wa , 1988 . mit press .",
    "henk zeevat , ewan klein , and jo  calder .",
    "unification categorial grammar . in nicholas",
    "haddock , ewan klein , and glyn morrill , editors , _ categorial grammar , unification grammar and parsing_. centre for cognitive science , university of edinburgh , 1987 .",
    "volume 1 of working papers in cognitive science ."
  ],
  "abstract_text": [
    "<S> although unification can be used to implement a weak form of @xmath0-reduction , several linguistic phenomena are better handled by using some form of @xmath1-calculus . in this paper </S>",
    "<S> we present a higher order feature description calculus based on a typed @xmath1-calculus . </S>",
    "<S> we show how the techniques used in for resolving complex feature constraints can be efficiently extended . </S>",
    "<S> is a simple formalism , based on categorial grammars , designed to test the practical feasibility of such a calculus .    </S>",
    "<S> * keywords : * constraint satisfaction , computational semantics , high - order programming </S>",
    "<S> .    [ section ]    a    # 1#2@xmath2    # 1#2#1=#2    # 1 </S>"
  ]
}