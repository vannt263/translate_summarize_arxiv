{
  "article_text": [
    "successive cancellation ( sc ) decoding was considered in @xcite for general reed - muller codes @xmath0 of order @xmath1 and dimension @xmath2 .",
    "it was also proposed in @xcite to set to zeros those information bits that are the least protected in sc decoding .",
    "simulation results of @xcite show that the resulting subcodes with frozen bits significantly outperform the original codes @xmath3 subsequent papers @xcite-@xcite extend sc technique to the list decoding of rm codes and their bit - frozen subcodes .",
    "simulation results of these papers show that the optimal selection of the frozen bits in rm codes brings sc list decoding close to the maximum likelihood decoding for the code lengths @xmath4 and list sizes @xmath5    a breakthrough in this area was achieved by e. arikan @xcite , who proved that the bit - frozen subcodes of the full code @xmath6 - now well known as polar codes - achieve the channel capacity of a symmetric memoryless channel as @xmath7 .",
    "paper @xcite also employs a novel analytical technique and reveals new properties of probabilistic recursive processing , such as bit polarization .",
    "we also note that the specific choice of the maximal order @xmath8 is immaterial in this case since the results of @xcite hold for the optimized bit - frozen subcodes of any code @xmath0 of rate @xmath9 in particular if @xmath10 for @xmath7 .",
    "sc list decoding was later considered in @xcite .",
    "this paper cites a similar algorithm of @xcite but relates the algorithm of @xcite to rm codes only .",
    "this is incorrect .",
    "all papers @xcite-@xcite address list decoding of the optimized bit - frozen subcodes , and all emphasize large improvements that these subcodes achieve over the original rm codes .",
    "paper @xcite also incorrectly asserts that the recursive processing of @xmath11 codewords in @xcite may require @xmath12 operations per one codeword , as opposed to only @xmath13 operations for @xmath14 in fact , sc list decoding of @xcite-@xcite yields complexity of @xmath13 per one codeword and the overall complexity has the order of @xmath15 for both rm codes and their subcodes .    in summary , papers @xcite-@xcite and @xcite",
    "use a similar decoding algorithm and apply it to the same class of the bit - frozen subcodes of rm codes . on the other hand",
    ", we also note that the design of polar codes in @xcite complements the earlier constructions of polar codes by using the precoded information blocks and the fast analytical technique of @xcite , which gives the output bit error rates without any simulation .",
    "below , we discuss recursive design and decoding of polar codes in more detail .",
    "we first describe some recursive properties of rm  or polar codes similarly to papers @xcite .",
    "consider boolean polynomials @xmath16 of degree @xmath1 or less in @xmath2 binary variables @xmath17 , where @xmath18 .",
    "vectors @xmath19 will mark the positions of our code .",
    "we also use short notation @xmath20 for a punctured vector @xmath21 , where @xmath22  each map @xmath23 generates a codeword @xmath24 of a code @xmath3  below , we take any sequence @xmath25 and describe the recursive decomposition@xmath26{l}$f(x)=f_{0}(\\mathbf{x}_{2\\,|\\,m})+x_{1}f_{1}(\\mathbf{x}_{2\\,|\\,m})= ... \\smallskip$\\\\ $ = \\sum_{i_{1}, ... ,i_{\\ell}}x_{1}^{i_{1}}\\cdot ... \\cdot x_{\\ell}^{i_{\\ell}}\\,\\,f_{i_{1}, ... ,i_{\\ell}}(\\mathbf{x}_{\\ell+1\\,|\\,m})\\smallskip$\\\\ $ = ... = \\sum_{i_{1}, ... ,i_{m}}f_{i_{1}, ... ,i_{m}}\\;x_{1}^{i_{1}}\\cdot",
    "... \\cdot x_{m}^{i_{m}}\\smallskip$\\end{tabular } \\ \\ \\ \\ \\ \\ \\ \\ \\ \\label{poly1}\\ ] ] two polynomials @xmath27 and @xmath28 derived in the first step generate codewords @xmath29 and @xmath30  in @xmath31 for each @xmath32 the codeword @xmath33 belongs to the code @xmath34 .",
    "this yields the plotkin construction @xmath35 of code @xmath0 .",
    "similarly , any step @xmath36 decomposes the polynomial @xmath16 with respect to various monomials @xmath37 .",
    "we define these monomials using the binary strings @xmath38 , which we call binary _ paths _ of length @xmath39 . for each path",
    "@xmath40 the remaining part @xmath41 of decomposition ( [ poly1 ] ) defines some codeword @xmath42 of length @xmath43 finally , any _ full path _",
    "@xmath44 of step @xmath2 defines the single monomial @xmath45 which has some coefficient @xmath46 note that any path @xmath47 that ends with an information bit @xmath48 gives some vector @xmath49 of length @xmath50 and weight @xmath51 where @xmath52 is the hamming weight of the string @xmath53 if @xmath54 then @xmath55 rm codes @xmath0 include only @xmath56 paths of weight @xmath57 , where @xmath56 is the dimension of the code @xmath0 .",
    "decomposition ( [ poly1 ] ) is also shown in fig . 1 and 2 . here",
    "the full code @xmath58 is depicted in fig .",
    "each decomposition step @xmath59 is marked by the splitting monomial @xmath60 for example , path @xmath61 gives the coefficient @xmath62  associated with the monomial @xmath63 .",
    "2 depicts code @xmath64 here we only include all paths @xmath65 of weight @xmath66 note that any two paths @xmath67 entering some node have the same weight @xmath68 and generate the same code @xmath69 on their extensions @xmath70 . for example , path @xmath71 proceeds from @xmath72 to the single bit @xmath73 via nodes @xmath74 @xmath75 @xmath76 and @xmath77            now consider some subset of @xmath78 paths @xmath79 then we encode @xmath78 information bits via their paths and obtain codewords @xmath80 these codewords form a linear code @xmath81 note also that at any level @xmath82 and at any node @xmath83 , encoding only needs to add two codewords of level @xmath84 entering this node@xmath85 thus , encoding performs the order of @xmath86 operations on each of @xmath87 nodes @xmath83 and has the overall complexity of @xmath88 summed up over all levels @xmath89",
    "_ recursive decoding of rm codes .",
    "_ consider a discrete memoryless channel ( dmc ) @xmath90 with inputs @xmath91 defined by the map @xmath92 for @xmath93 then we define the codewords @xmath94 of a code @xmath95 where vector @xmath96 is the component - wise product of vectors @xmath97 and @xmath98 with symbols @xmath99 for any codeword @xmath100 let @xmath101,@xmath102 be the two output halves corrupted by noise .",
    "we use double index @xmath103 for any position @xmath104 in a half @xmath105 .  define the posterior probability ( pp )",
    "@xmath106 that @xmath107 is sent in a position @xmath108 we will also use two related quantities , which we call  the offsets  @xmath109 and the likelihoods @xmath110@xmath111 thus , we form vectors @xmath112  @xmath113 and @xmath114 the following recursive algorithm @xmath115 of @xcite , @xcite performs scd of information bits in codes @xmath0 or their bit - frozen subcodes @xmath81 we first derive pp of symbols @xmath116 in the @xmath117 construction:@xmath118 namely , it is easy to verify that the offsets @xmath119 of symbols @xmath120 satisfy simple recalculations @xmath121 we may then apply some decoding algorithm @xmath122 to the vector @xmath123 and obtain a vector @xmath124 of length @xmath125 then each half of the vector ( @xmath126 forms a corrupted version of vector @xmath97 in the @xmath117 construction . as a result , every symbol @xmath127 of vector @xmath97 has the likelihoods @xmath128 and @xmath129 on these halves .",
    "this gives the overall likelihood of every symbol @xmath130@xmath131 given the vectors @xmath132 and @xmath133 we can now apply some algorithm @xmath134 and decode @xmath135 into a vector @xmath136 @xmath137 @xmath138 with respect to polar codes , observe that recalculations ( [ 1 ] ) degrade the original channel , whereas recalculations ( [ 2 ] ) upgrade it .",
    "recalculations ( [ 1 ] ) and ( [ 2 ] ) form the level @xmath139 of  sc decoding",
    ".  we can also use recalculations ( [ 1 ] ) , ( [ 2 ] ) for vectors @xmath140 and @xmath135 instead of decoding them .",
    "then levels @xmath36 are processed similarly , moving decoding back and forth along the paths of fig . 1 or fig",
    ". 2 . for any current path @xmath141",
    ", decoder has an input vector @xmath142 that consists of @xmath86 pp .",
    "in essence , this vector represents the output channel of this path @xmath143 .",
    "then we process the @xmath98-extension @xmath144 using recalculations ( [ 1 ] ) . after processing ,",
    "the node @xmath144 returns its current output @xmath145 to the node @xmath143 .",
    "similarly , we then continue with recalculations ( [ 2 ] ) for the @xmath97-extension @xmath146 .",
    "thus , @xmath98-extensions ( marked with 1 on fig",
    ". 1 ) precede the @xmath97-extensions , and all paths @xmath147 are ordered lexicographically in each step .",
    "next , consider all full paths @xmath148 @xmath149 every path @xmath150 ends with one information bit @xmath151 and gives its likelihood @xmath152 .",
    "we then choose the more reliable value for @xmath153 the result is the current sequence @xmath154 of the first @xmath155 information bits .",
    "the decoding ends if @xmath156    it is easy to verify @xcite that @xmath2 decomposition steps give complexity @xmath157 indeed , any level @xmath158 includes at most @xmath87 paths @xmath159 each path @xmath143  recalculates vectors @xmath160 and @xmath161 of length @xmath43 recalculations ( [ 1 ] ) , ( [ 2 ] ) on these vectors have complexity order of @xmath43 thus , each level @xmath82 of recursion requires the order of @xmath162 operations .    _ recursive decoding of polar codes . _",
    "any subcode @xmath163 with @xmath78 ordered paths @xmath164 is decoded similarly .",
    "here we simply drop all frozen paths @xmath165 that give information bits @xmath166  this gives the following algorithm .",
    "@xmath167{l}\\text{algorithm } \\psi(m , t)\\text { for code } c(m , t).\\smallskip\\\\ \\text{given : a vector } \\mathbf{q}=(q_{i , j})\\text { of pp.}\\smallskip\\\\ \\text{take } s=1, ... ,n\\text { and } \\ell=1, ... ,m.\\smallskip\\\\ \\text{for a path } \\mathbf{\\mathbf{\\xi}}(s)=i_{1}(s), ... ,i_{m}(s)\\text { in step } \\ell\\text { do:}\\smallskip\\\\\\begin{array } [ c]{l}\\text{apply recalculations}\\;\\text{(\\ref{1 } ) if } i_{\\ell}(s)=1\\smallskip \\smallskip\\\\ \\text{apply recalculations}\\;\\text{(\\ref{2 } ) if } i_{\\ell}(s)=0.\\smallskip\\\\ \\text{output the bit } f\\left (   s\\right )   \\text { for } \\ell = m . \\end{array } \\end{array } $ } \\smallskip\\smallskip\\smallskip$ ]    _ recursive list decoding .",
    "_ for the bit - frozen subcodes @xmath163 of rm codes , _ list decoding",
    "_ version @xmath168 of this algorithm was employed in @xcite-@xcite .",
    "consider processing of any path @xmath169 then the algorithm already has the list of @xmath11 most probable code candidates @xmath170 obtained on the previous paths .",
    "each candidate is defined by the sequence @xmath171   $ ] of @xmath172 information bits and by the current vector @xmath173 of posterior probabilities derived by processing these @xmath172 paths . for each candidate @xmath174",
    ", we then recalculate the vector @xmath173 on the path @xmath169 this is similar to the case @xmath14 namely , any intermediate node @xmath175 of the path @xmath176 is given @xmath11 most probable vectors @xmath177 of length @xmath43 if the path @xmath176 has the new bit @xmath178",
    "then we follow @xmath98-extension @xmath144 and perform recalculations ( [ 1 ] ) for each vector @xmath179 otherwise , path @xmath143 receives @xmath11 vectors",
    "@xmath180 ) from the @xmath98-extension @xmath144 and proceeds with recalculations ( [ 2 ] ) on its @xmath97-extension @xmath181    our recalculations are slightly different in the final step @xmath182 given the prefix @xmath183 of the path @xmath176 , we continue with the same recalculations ( [ 1 ] ) or ( [ 2 ] ) depending on the new symbol @xmath184 however , now we consider both values @xmath185 of a new information bit @xmath186 . as a result ,",
    "we obtain two posterior probabilities @xmath187 and @xmath188 for each candidate @xmath170 on the full path @xmath169 thus , @xmath11 candidates yield two presorted lists @xmath189 and @xmath190 .",
    "to proceed further , we select @xmath11 most probable codewords in the combined list , which requires the order of @xmath191 operations .",
    "the result is the new list of information bits @xmath192 note that this list can exclude some candidates @xmath174 but keep both values @xmath185 for some other @xmath174 until we select the single most probable codeword in the end . in processing",
    ", we also keep the current posterior probabilities @xmath193 which will be used in the next steps for the path @xmath194 a more detailed description of this decoding algorithm is also given in @xcite .",
    "note that each level @xmath82 includes at most @xmath87 nodes @xmath195 each of which processes @xmath196 vectors of length @xmath43 given some constant number @xmath197 operations per code symbol , we only perform @xmath198 operations in step @xmath199 and then relegate decoding to step @xmath200 thus , we can bound complexity @xmath201 of level @xmath82 and the overall complexity @xmath202 of the list decoding by the order of @xmath203:@xmath204@xmath205 this concludes our description of the list decoding algorithm ."
  ],
  "abstract_text": [
    "<S> we survey the known list decoding algorithms for polar codes and compare their complexity .    </S>",
    "<S> * index terms : * polar codes ; reed - muller codes ; successive cancellation decoding . </S>"
  ]
}