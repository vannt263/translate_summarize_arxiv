{
  "article_text": [
    "let @xmath0 be a smooth geometrically irreducible projective curve defined over a finite field @xmath1 of genus @xmath2 .",
    "let @xmath3 and @xmath4 denote the function field and the module of differentials of @xmath0 respectively .",
    "let @xmath5 be distinct rational points on @xmath0 , and @xmath6 .",
    "let @xmath7 be an arbitrary divisor on @xmath0 , whose support is disjoint from that of @xmath8 . recall that @xmath9 and @xmath10",
    ". then goppa s famous two codes @xcite are defined by @xmath11 and @xmath12 which are respectively called evaluation ag code and differential ag code .",
    "it is well - known that @xmath13 , whose proof @xcite requires the riemann - roch theorem .",
    "[ riekdmd ] let @xmath14 be a divisor on @xmath0 .",
    "then @xmath15 moreover if @xmath16 , then @xmath17 , and if @xmath18 , then @xmath19 .",
    "though the two kinds of ag codes were equally created , their historical development has been somewhat unbalanced .",
    "the target of intensive researches on the bounds on the minimum distance and decoding algorithms up to the bounds were usually the differential code or rather the dual code to the evaluation code .",
    "thus all known decoding algorithms for differential ag codes decode @xmath20 rather than @xmath21 itself in the sense that they work with the data called syndromes defined using functions in @xmath22 .",
    "see @xcite and many references therein . the bias is also reflected on the terms like primal ag code and dual ag code , which mean evaluation ag code and differential ag code respectively . in this respect ,",
    "the recent result @xcite on the unique decoding algorithm for evaluation ag codes is against to the trend and implies that the duality is not essential for decoding and for bounding the minimum distance of @xmath23 .",
    "this makes one conceive of a decoding algorithm for @xmath21 that likewise does not rely on the duality , syndromes , or the space @xmath22 .    in this paper",
    ", we present a fast unique decoding algorithm for general differential ag codes , which does not rely on the duality and does not use syndromes defined by the functions in @xmath22 . essentially it is the interpolation - based decoding algorithm for @xmath23 of @xcite rewritten for the differential ag code @xmath21 based on the same principle ideas but using data derived from the relevant space of differentials .",
    "specifically , the ring @xmath24 defined in this paper is the same @xmath24 defined in @xcite , but instead of @xmath24-module @xmath25 , here we define another @xmath24-module @xmath26 .",
    "thus the decoding algorithm for differential ag codes works with the polynomials in @xmath27 while the algorithm for evaluation ag codes works in @xmath28 .",
    "these changes aside , the basic principles underlying both decoding algorithms are exactly the same . thus we achieve an equal and symmetric treatment of goppa s two codes in decoding and bounding the minimum distance .    in section [ kkmcd ] , we set up the algebraic framework in which the decoding algorithm works . in section [ mqief ]",
    ", we present the decoding algorithm after a brief explanation of its structure . in section [ ioqer ] ,",
    "we report a performance analysis .",
    "it will be clearly seen that the framework and the algorithm itself resemble the corresponding ones in @xcite so closely that , to avoid repetition , we do not prove that the algorithm works correctly nor provide the proofs for the assertions about performance analysis , but instead refer the reader to @xcite for almost verbatim details of missing proofs . in section [ dkwdf ] , we will see that decoding capacities of both decoding algorithms are nicely interrelated . in section [ dkdkf ] ,",
    "we give an explicit example . in section [ xnmlf ] ,",
    "we consider decoding of goppa codes .",
    "recall that goppa codes are subfield subcodes of differential ag codes on the projective line .",
    "hence as a special case , we obtain a decoding algorithm for classical goppa codes .",
    "this algorithm is interesting because goppa codes are the main workhorse in the mceliece code - based cryptosystem and the speed of decryption is largely dependent on the efficiency of its decoding algorithm .",
    "we assume the existence of a rational point @xmath29 distinct from the points in the support of @xmath8 .",
    "let @xmath30 for @xmath31 , let @xmath32 .",
    "the weierstrass semigroup at @xmath29 is then @xmath33 which is a numerical semigroup whose number of gaps , the positive integers not in @xmath34 , is the genus @xmath2 of @xmath0 .",
    "let @xmath35 be the smallest positive nongap , and let @xmath36 for some @xmath37 . for each @xmath38 ,",
    "let @xmath39 be the smallest nongap such that @xmath40 and @xmath41 for some @xmath42 . by the properties of @xmath43 inherited from the valuation @xmath44 of @xmath3 , the set @xmath45 forms a basis of @xmath24 as a free module of rank @xmath46 over @xmath47 $ ] , which we call the apry system of @xmath24 .",
    "hence @xmath48 is a vector space basis of @xmath24 over @xmath1 , whose elements are called the monomials of @xmath24 .",
    "the monomials of @xmath24 are in one - to - one correspondence with the nongaps in @xmath34 . for @xmath49 , we denote by @xmath50 the unique monomial with @xmath51 .    notice that the ring @xmath24 and the numerical semigroup @xmath34 are the same as defined in @xcite . now come the definitions which are new but correspond to @xmath52 and @xmath53 in @xcite .",
    "let @xmath54 which is clearly a module over @xmath24 . for a differential @xmath55 ,",
    "let @xmath56 denote the smallest integer @xmath57 such that @xmath58 .",
    "thus @xmath56 is simply @xmath59 .",
    "let @xmath60 .",
    "note that @xmath61 , and in this sense @xmath62 is a numerical @xmath34-module .",
    "the integers in @xmath62 will also be called nongaps . as @xmath62 contains all large enough integers , for each @xmath38",
    ", there exists the smallest nongap @xmath63 of @xmath62 such that @xmath64 and @xmath65 for some @xmath66 . using the valuative properties of @xmath67",
    ", we also see that @xmath68 forms a basis of @xmath69 as a free module of rank @xmath46 over @xmath47 $ ] . for @xmath70 , define @xmath71 for @xmath72 and @xmath73 . then @xmath74 .",
    "thus @xmath75 is a basis of @xmath69 over @xmath1 , and will be called the monomials of @xmath69 .",
    "the set @xmath76 is called the apry system of @xmath69 .",
    "one may observe that @xmath69 , as @xmath77 , and @xmath62 were defined in @xcite but not used for decoding .",
    "now let us consider the @xmath24-module @xmath78 with indeterminate @xmath79 .",
    "it is also a free @xmath47$]-module of rank @xmath80 with free basis @xmath81 , and that every element of @xmath82 can be written as a unique @xmath1-linear combination of the monomials in @xmath83 .",
    "so we can regard the elements of @xmath82 as polynomials over @xmath1 .",
    "we denote @xmath84 , @xmath85 , @xmath86 , and @xmath87 .",
    "let us review the grbner basis theory on the @xmath24-module @xmath82 .",
    "for an integer @xmath57 , the weighted degree of a polynomial @xmath88 is defined by @xmath89 in particular , we have @xmath90 , @xmath91 .",
    "then @xmath92 induces the weighted degree order @xmath93 on @xmath94 , where we break ties by declaring the monomial with @xmath79 precedes the other without @xmath79 . for @xmath95 ,",
    "the notations @xmath96 , @xmath97 , and @xmath98 are used to denote respectively the leading term , the leading monomial , and the leading coefficient , with respect to @xmath93 .",
    "suppose @xmath99 is an @xmath47$]-submodule of @xmath100 .",
    "a finite subset @xmath101 of @xmath99 is called a _ grbner basis _ of @xmath99 with respect to @xmath93 if the leading term of every element of @xmath99 is an @xmath47$]-multiple of the leading term of some element of @xmath101 .",
    "we will write @xmath102 where we understand that the leading term of @xmath103 is in @xmath69 while that of @xmath104 is in @xmath105 .",
    "the sigma set @xmath106 of @xmath99 is the set of all leading monomials of the polynomials in @xmath99 with respect to @xmath93 .",
    "the delta set @xmath107 of @xmath99 is the complement of @xmath108 in @xmath94 .",
    "the _ residue _ map @xmath109 is linear over @xmath1 .",
    "thus the differential ag code @xmath110 is a linear code of length @xmath111 over @xmath1 .",
    "note that @xmath112 is a basis of @xmath113 as a vector space over @xmath1 .",
    "let @xmath114 be the dimension of @xmath115 .",
    "then there is a set @xmath116 such that @xmath117 is a basis of @xmath115 .",
    "note that the map @xmath118 is surjective onto @xmath119 .",
    "indeed we can show that @xmath120 for @xmath121 by the riemann - roch theorem .",
    "let @xmath122 be the differential such that @xmath123 is the @xmath124th element of the standard basis of @xmath119 .",
    "let @xmath125 be the kernel of @xmath118 .",
    "note that @xmath125 is a submodule of @xmath69 over @xmath24 , and also over @xmath47 $ ] .",
    "let @xmath126 be a grbner basis of @xmath125 over @xmath47 $ ] such that @xmath127 .",
    "then we have @xmath128 which corresponds to proposition 2 of @xcite and can be proved in a similar way .",
    "we assume a codeword is sent through a communication channel and a vector @xmath129 is received .",
    "thus we suppose @xmath130 with a codeword @xmath131 and the error vector @xmath132 .",
    "then @xmath133 with a unique differential @xmath134 for all integer @xmath135 , let @xmath136 , @xmath137 , and @xmath138 .",
    "for @xmath139 , let @xmath140 and for @xmath141 but @xmath142 , let @xmath143 , @xmath144 , @xmath145 .",
    "then we have @xmath146 , @xmath147 , and @xmath148 for all @xmath57 .    the _ interpolation module _",
    "@xmath149 for a vector @xmath150 is now defined by @xmath151 which is a submodule of @xmath82 over @xmath24 .",
    "let @xmath152 so that @xmath153",
    ". then we see that @xmath154 .",
    "hence the set @xmath155 is a grbner basis of @xmath149 with respect to @xmath156 .",
    "the fast decoding algorithm for differential ag codes , displayed in figure [ keprer ] , starts with the basis and iterates the substeps pairing , voting , and rebasing , computing a grbner basis of @xmath157 from that of @xmath158 while @xmath159 is computed by majority voting for @xmath139 .",
    "let @xmath160 for @xmath139 , and define @xmath161 .",
    "then it can be shown that @xmath162 if @xmath163 for @xmath139 , and hence the algorithm succeeds in iteratively computing @xmath164 for all @xmath139 if @xmath165 .",
    "the proof is mostly identical with the corresponding one in @xcite , with some obvious change of notations .",
    "so we leave out the proof .",
    "note that the fast decoding algorithm for differential ag codes is also enhanced with the speedup techniques introduced in the section iii.e of @xcite for evaluation ag codes .",
    "a minor difference is due to the different inequality in the following theorem .",
    "[ lalkaa ] suppose @xmath166 and @xmath129 .",
    "if for a nonzero @xmath167 , @xmath168 then @xmath169 . here",
    "@xmath170 denotes the @xmath171 with the variable @xmath79 substituted with @xmath172 .",
    "let @xmath173 . then @xmath174 . as @xmath175 , @xmath176 for @xmath124 with @xmath177 .",
    "it follows that @xmath178 hence by the riemann - roch theorem , if @xmath170 is nonzero , then we must have @xmath179 .    according to theorem [ lalkaa ] , a polynomial @xmath171 in @xmath158 satisfying the condition @xmath180",
    "is called a _",
    "@xmath29-polynomial _ for @xmath181 . in the fast decoding algorithm",
    ", we actually use the condition @xmath182 since if we assume @xmath183 , then a polynomial @xmath171 in @xmath184 satisfying the condition is a @xmath29-polynomial for @xmath181 .",
    "see the step q. since @xmath185 ( see corollary 7 in @xcite ) , if we have @xmath186 during decoding , then we must have @xmath187 , and the decoder may declare _ decoding failure_. see the step f.",
    "[ dkaaa ] we have @xmath188 .",
    "hence @xmath189 is at least goppa bound @xmath190 for differential ag codes .",
    "note that @xmath191 to see the last equality , note that by the riemann - roch theorem , @xmath192 for all large enough @xmath193 . since @xmath194",
    ", we have @xmath195 .",
    "now our assertion follows .",
    "let us define @xmath196 for @xmath197 , which is the largest number of errors for which the majority voting succeeds for @xmath57 .",
    "like proposition 22 in @xcite , we can show that for nongap @xmath198 , @xmath199 and if @xmath200 , equality holds on the left .",
    "we now find out when the condition in the step q is satisfied .",
    "let @xmath201 .",
    "[ ckjkw ] let @xmath184 be a grbner basis of @xmath158 with respect to @xmath93 .",
    "if @xmath202 , then there exists an @xmath203 such that @xmath171 is a @xmath29-polynomial for @xmath181 .    by the same argument of the proof of lemma 18 of @xcite , we know that there exists an @xmath203 such that @xmath204 .",
    "so if @xmath202 , then this @xmath171 satisfies the condition to be a @xmath29-polynomial .",
    "let us define @xmath205 for @xmath197 . by theorem [ ckjkw ] ,",
    "the value @xmath206 is the largest number of errors for which a @xmath29-polynomial exists in @xmath184 . like proposition 20 in @xcite",
    ", we can then show that for @xmath197 , @xmath207 and for @xmath208 , equality holds on the left . from and , we see that @xmath209 for nongap @xmath210 , and moreover for @xmath211 , @xmath212    recall that the actual condition used in the step q to find a @xmath29-polynomial in @xmath184 is @xmath182 . by a similar proof of theorem [ ckjkw ]",
    ", we have    [ casksq ] suppose @xmath213 .",
    "if @xmath214 , then there exists an @xmath203 satisfying @xmath182 , and @xmath171 is a @xmath29-polynomial for @xmath181 .    by theorem [ casksq ] ,",
    "the condition in the step q is satisfied for some @xmath215 depending on @xmath201 , and at the latest for some @xmath216 .",
    "finally note that @xmath217 which can be verified by definitions .",
    "the fast decoding algorithm iteratively updates a @xmath218 array of polynomials in @xmath47 $ ] that represents @xmath184 .",
    "each of the @xmath219 rows of the array are again viewed as pairs of vectors in @xmath47^{\\gamma}$ ] . for the initialization step s1 , we precompute @xmath220 for @xmath221 and @xmath222 for @xmath223 in the vector form . in the _ rebasing _ substep of the step m , the most intensive computation is the substitution of @xmath79 with @xmath224 . as @xmath225 is in the form @xmath226 ,",
    "the computation is facilitated if @xmath227 for @xmath228 is precomputed in the vector form .",
    "for the step s3 , it is necessary to precompute the vectors @xmath229 in @xmath119 for @xmath230 , essentially the generator matrix of the code @xmath115 .",
    "our complexity analysis is now summarized , omitting the details , in the following .",
    "\\(1 ) lagrange basis polynomial @xmath220 can be chosen such that the maximum degree of the polynomials in the vector form of @xmath220 is bounded by @xmath231 .",
    "\\(2 ) the maximum degree of the polynomials in the vector form of @xmath222 is bounded by @xmath232 .",
    "\\(3 ) the maximum degree of the polynomials in the @xmath233 array during an execution is bounded by @xmath234 if @xmath235 .",
    "if @xmath236 , then it is bounded by @xmath111 .",
    "\\(4 ) the number of iterations is at most @xmath237 .    if @xmath235 , an execution of the fast decoding algorithm takes @xmath238 multiplications . for @xmath236",
    ", it takes @xmath239 multiplications .",
    "the implicit constant is absolute .",
    "observe that these results are exactly the same with the complexity analysis of the decoding algorithm for evaluation ag codes reported in @xcite .",
    "we now show that @xmath189 is indeed a lower bound for the minimum distance of the code @xmath21 .",
    "recall that @xmath161 where @xmath240 .",
    "[ xmxmzd ] the minimum distance @xmath241 of @xmath21 is lower - bounded by @xmath189 .",
    "let @xmath139 and suppose @xmath133 , @xmath242 with nonzero @xmath243 .",
    "consider @xmath119 as an @xmath1-algebra with the component - wise multiplication @xmath244 .",
    "let us consider the evaluation map from @xmath24 to @xmath119 , which is a surjective homomorphism of @xmath1-algebras .",
    "let @xmath245 be the kernel of the map , and we have an isomorphism @xmath246 with @xmath119 .",
    "then @xmath247 hence @xmath248 .",
    "now as @xmath249 , we have @xmath250",
    ". therefore @xmath251 .",
    "this result implies that @xmath252 .",
    "recall that @xmath253 where @xmath53 is the numerical @xmath254-module used in @xcite .",
    "then theorem 33 in @xcite says that the minimum distance of @xmath23 is lower bounded by @xmath255 for comparison of @xmath189 with @xmath256 , we assume @xmath257 such that @xmath258 from now on . like lemma 32 of @xcite , we can show that @xmath259 if and only if @xmath260 or @xmath261 , which implies that @xmath262 observe the nice symmetry between @xmath256 and @xmath189 .",
    "recall that @xmath263 for @xmath264 .",
    "let @xmath265 for @xmath266 .",
    "the codes @xmath267 are sometimes used in formulating minimum distance bounds of ag codes @xcite .",
    "[ qerdd ] @xmath197 if and only if @xmath268 or @xmath269 .    by the riemann - roch theorem , @xmath270 for the last equivalence , recall that @xmath271 .",
    "lemma [ qerdd ] allows us to write @xmath272 finally let us focus on one - point ag codes with @xmath273 . in this case",
    "let @xmath275 and @xmath276 .",
    "then @xmath277 where the former is the famous feng - rao bound of the one - point ag code @xmath278 and the latter is a slight variation of the bound @xmath279 defined in @xcite .",
    "let @xmath0 be the hermitian curve of genus @xmath280 defined by the equation @xmath281 over @xmath282 with @xmath283 .",
    "let @xmath284 where @xmath285 is the origin and @xmath29 is the unique point at infinity .",
    "except @xmath285 and @xmath29 , there are @xmath286 rational points @xmath287 then the differential ag code @xmath288 is a @xmath289 $ ] linear code over @xmath290 .",
    "note that this is the dual code of @xmath23 dealt in section iv - a of @xcite .",
    "hence the data about @xmath24 are the same , but the data about @xmath69 are new .",
    "the weierstrass semigroup at @xmath29 is @xmath291 so @xmath292 , and we take @xmath293 .",
    "the apry system of @xmath24 is @xmath294 on the other hand , @xmath295 and the apry system of @xmath69 is @xmath296    the monomials of @xmath82 are displayed in the array below , where the common @xmath79 factor of the monomials of @xmath105 are omitted .",
    "@xmath297      \\draw ( -0.5,0.5 ) node[scale=.6 ] { $ y_0 $ } ;       \\draw ( -0.5,1.5 ) node[scale=.6 ] { $ y_1 $ } ;       \\draw ( -0.5,2.5 ) node[scale=.6 ] { $ y_2 $ } ;      \\draw[dimgray , fill ] ( 0,0 ) |- ( 11,3 ) |- ( 0,0 ) ;         \\draw ( 0,0 ) grid[step=4 mm ] + ( 11,3 ) ;      \\draw ( 0,0 ) + ( .5,.5 ) node[scale=.6 ] { $ 1^{\\vphantom{1}}$ } ;      \\draw ( 1,0 ) + ( .5,.5 ) node[scale=.6 ] { $ x^{\\vphantom{1}}$ } ;      \\draw ( 10,0 ) + ( .5,.5 ) node[scale=.6 ] { $ \\cdots$ } ;      \\foreach { \\mathsf{x}}in { 2, ... ,9 }                    \\draw ( { \\mathsf{x}},0 ) + ( .5,.5 ) node[scale=.6 ] { $ x^{{\\mathsf{x}}}$ } ;      \\draw ( 0,1 ) + ( .5,.5 ) node[scale=.6 ] { $ 1^{\\vphantom{1}}$ } ;      \\draw ( 1,1 ) + ( .5,.5 ) node[scale=.6 ] { $ x^{\\vphantom{1}}$ } ;      \\draw ( 10,1 ) + ( .5,.5 ) node[scale=.6 ] { $ \\cdots$ } ;      \\foreach { \\mathsf{x}}in { 2, ... ,9 }                    \\draw ( { \\mathsf{x}},1 ) + ( .5,.5 ) node[scale=.6 ] { $ x^{{\\mathsf{x}}}$ } ;      \\draw ( 0,2 ) + ( .5,.5 ) node[scale=.6 ] { $ 1^{\\vphantom{1}}$ } ;      \\draw ( 1,2 ) + ( .5,.5 ) node[scale=.6 ] { $ x^{\\vphantom{1}}$ } ;      \\draw ( 10,2 ) + ( .5,.5 ) node[scale=.6 ] { $ \\cdots$ } ;      \\foreach { \\mathsf{x}}in { 2, ... ,9 }                \\draw ( { \\mathsf{x}},2 ) + ( .5,.5 ) node[scale=.6 ] { $ x^{{\\mathsf{x}}}$ } ;        \\end{tikzpicture } \\quad \\begin{tikzpicture}[scale=1.2,x=4mm , y=4mm , baseline=(current bounding box ) ]      \\draw ( -0.5,0.5 ) node[scale=.6 ] { $ { \\bar{\\omega}}_0 $ } ;       \\draw ( -0.5,1.5 ) node[scale=.6 ] { $ { \\bar{\\omega}}_1 $ } ;       \\draw ( -0.5,2.5 ) node[scale=.6 ] { $ { \\bar{\\omega}}_2 $ } ;       \\draw[dimgray , fill ] ( 0,0 ) |- ( 11,3 ) |- ( 0,0 ) ;         \\draw ( 0,0 ) grid[step=4 mm ] + ( 11,3 ) ;      \\draw ( 0,0 ) + ( .5,.5 ) node[scale=.6 ] { $ 1^{\\vphantom{1}}$ } ;      \\draw ( 1,0 ) + ( .5,.5 ) node[scale=.6 ] { $ x^{\\vphantom{1}}$ } ;      \\draw ( 10,0 ) + ( .5,.5 ) node[scale=.6 ] { $ \\cdots$ } ;      \\foreach { \\mathsf{x}}in { 2, ... ,9 }                    \\draw ( { \\mathsf{x}},0 ) + ( .5,.5 ) node[scale=.6 ] { $ x^{{\\mathsf{x}}}$ } ;      \\draw ( 0,1 ) + ( .5,.5 ) node[scale=.6 ] { $ 1^{\\vphantom{1}}$ } ;      \\draw ( 1,1 ) + ( .5,.5 ) node[scale=.6 ] { $ x^{\\vphantom{1}}$ } ;      \\draw ( 10,1 ) + ( .5,.5 ) node[scale=.6 ] { $ \\cdots$ } ;      \\foreach { \\mathsf{x}}in { 2, ... ,9 }                    \\draw ( { \\mathsf{x}},1 ) + ( .5,.5 ) node[scale=.6 ] { $ x^{{\\mathsf{x}}}$ } ;      \\draw ( 0,2 ) + ( .5,.5 ) node[scale=.6 ] { $ 1^{\\vphantom{1}}$ } ;      \\draw ( 1,2 ) + ( .5,.5 ) node[scale=.6 ] { $ x^{\\vphantom{1}}$ } ;      \\draw ( 10,2 ) + ( .5,.5 ) node[scale=.6 ] { $ \\cdots$ } ;      \\foreach { \\mathsf{x}}in { 2, ... ,9 }                \\draw ( { \\mathsf{x}},2 ) + ( .5,.5 ) node[scale=.6 ] { $ x^{{\\mathsf{x}}}$ } ;        \\end{tikzpicture}\\ ] ] here are the corresponding nongaps of @xmath254 and @xmath69 , respectively .",
    "@xmath298      \\draw ( -0.5,0.5 ) node[scale=.6 ] { $ \\phantom{y_0}$ } ;       \\draw ( -0.5,1.5 ) node[scale=.6 ] { $ \\phantom{y_1}$ } ;       \\draw ( -0.5,2.5 ) node[scale=.6 ] { $ \\phantom{y_2}$ } ;      \\draw[dimgray , fill ] ( 0,0 ) |- ( 11,3 ) |- ( 0,0 ) ;         \\draw ( 0,0 ) grid[step=4 mm ] + ( 11,3 ) ;      \\draw ( 10,0 ) + ( .5,.5 ) node[scale=.6 ] { $ \\cdots$ } ;      \\foreach { \\mathsf{x}}in { 0, ... ,9 }                \\draw ( { \\mathsf{x}},0 ) + ( .5,.5 ) node[scale=.6 ] { $ { \\pgfmathparse{a({\\mathsf{x}})}\\pgfmathresult}$ } ;      \\draw ( 10,1 ) + ( .5,.5 ) node[scale=.6 ] { $ \\cdots$ } ;      \\foreach { \\mathsf{x}}in { 0, ... ,9 }                \\draw ( { \\mathsf{x}},1 ) + ( .5,.5 ) node[scale=.6 ] { $ { \\pgfmathparse{b({\\mathsf{x}})}\\pgfmathresult}$ } ;      \\draw ( 10,2 ) + ( .5,.5 ) node[scale=.6 ] { $ \\cdots$ } ;      \\foreach { \\mathsf{x}}in { 0, ... ,9 }                \\draw ( { \\mathsf{x}},2 ) + ( .5,.5 ) node[scale=.6 ] { $ { \\pgfmathparse{c({\\mathsf{x}})}\\pgfmathresult}$ } ;     \\end{tikzpicture } \\quad \\begin{tikzpicture}[scale=1.2,x=4mm , y=4mm , baseline=(current bounding box ) ,      declare function= {          a(\\u ) = int(-9 + 3*\\u ) ;          b(\\u ) = int(-5 + 3*\\u ) ;          c(\\u ) = int(-13 + 3*\\u ) ;      } ]      \\draw ( -0.5,0.5 ) node[scale=.6 ] { $ \\phantom{{\\bar{y}}_0}$ } ;       \\draw ( -0.5,1.5 ) node[scale=.6 ] { $ \\phantom{{\\bar{y}}_1}$ } ;       \\draw ( -0.5,2.5 ) node[scale=.6 ] { $ \\phantom{{\\bar{y}}_2}$ } ;       \\draw[dimgray , fill ] ( 0,0 ) |- ( 11,3 ) |- ( 0,0 ) ;         \\draw ( 0,0 ) grid[step=4 mm ] + ( 11,3 ) ;      \\draw ( 10,0 ) + ( .5,.5 ) node[scale=.6 ] { $ \\cdots$ } ;      \\foreach { \\mathsf{x}}in { 0, ... ,9 }                \\draw ( { \\mathsf{x}},0 ) + ( .5,.5 ) node[scale=.6 ] { $ { \\pgfmathparse{a({\\mathsf{x}})}\\pgfmathresult}$ } ;      \\draw ( 10,1 ) + ( .5,.5 ) node[scale=.6 ] { $ \\cdots$ } ;      \\foreach { \\mathsf{x}}in { 0, ... ,9 }                \\draw ( { \\mathsf{x}},1 ) + ( .5,.5 ) node[scale=.6 ] { $ { \\pgfmathparse{b({\\mathsf{x}})}\\pgfmathresult}$ } ;      \\draw ( 10,2 ) + ( .5,.5 ) node[scale=.6 ] { $ \\cdots$ } ;      \\foreach { \\mathsf{x}}in { 0, ... ,9 }                \\draw ( { \\mathsf{x}},2 ) + ( .5,.5 ) node[scale=.6 ] { $ { \\pgfmathparse{c({\\mathsf{x}})}\\pgfmathresult}$ } ;     \\end{tikzpicture}\\ ] ]    the lagrange interpolation polynomials in @xmath69 are @xmath299    the @xmath300$]-submodule @xmath125 of @xmath69 has grbner basis @xmath301 , where @xmath302    using these data , we can compute @xmath303 and hence @xmath304 .",
    "the fast decoding algorithm runs with the received vector @xmath305 as input and with the above precomputed data .",
    "the decoding process itself is similar to that of the example in section iv - a in @xcite .",
    "thus we omit an example run of the algorithm .",
    "let @xmath306 be a set of distinct rational points of the projective line @xmath307 over @xmath308 , and let @xmath309 denote the point at infinity .",
    "let @xmath8 denote the divisor of zeros of @xmath310 .",
    "let @xmath311 $ ] be a given polynomial with @xmath312 for @xmath221 , and let @xmath313 be the divisor of zeros of @xmath314 .",
    "we assume @xmath315 .",
    "then the classical goppa code @xmath316 is a subfield subcode over @xmath317 of the differential ag code @xmath318 as @xmath115 is an @xmath319 $ ] code with @xmath320 and @xmath321 , the goppa code @xmath316 is an @xmath322 $ ] linear code over @xmath317 with @xmath323 , @xmath324 . see @xcite for more on goppa codes and subfield subcodes of ag codes .",
    "clearly , the fast decoding algorithm can decode the subfield subcode @xmath316 just by decoding @xmath115 .",
    "so let us specialise the algorithm for @xmath115 .",
    "let @xmath325 .",
    "the genus of the projective line is @xmath236 , and @xmath326 , @xmath327 $ ] , @xmath328 . for @xmath329 $ ] , simply @xmath330 . in particular ,",
    "@xmath331 and @xmath332 with @xmath333 . furthermore @xmath334 and",
    "we can show that @xmath335{\\bar{\\omega}}_0 $ ] and @xmath336 where @xmath337 noting that @xmath338 . for @xmath339",
    ", we have @xmath340 therefore @xmath341\\eta_0 $ ] where @xmath342 and for @xmath221 , @xmath343    with the above precomputed data , the fast decoding algorithm for goppa codes is reduced to the following simple algorithm .",
    "note that the differential @xmath344 , as well as @xmath79 , is just a placeholder , and the algorithm actually works with a @xmath345 array of univariate polynomials .",
    "we made some changes in notations for clarification and restructured the algorithm slightly for ready implementation .",
    "it should be noted that when the algorithm is in second phase @xmath346 , the update of @xmath347 is actually unnecessary .",
    "as is well - known , the binary goppa code @xmath348 defined by a separable polynomial @xmath349 is identical with the goppa code defined by @xmath350 .",
    "hence @xmath348 has dimension @xmath351 and minimum distance @xmath352 .",
    "moreover the goppa code @xmath348 can be decoded up to @xmath353 number of errors by the fast decoding algorithm for the goppa code defined by @xmath350 .",
    "we take this approach in the following example .",
    "let @xmath348 be the binary goppa code defined by @xmath354 $ ] with @xmath355 and the generator polynomial @xmath356 $ ] with @xmath357 .",
    "this is an @xmath358 $ ] goppa code , capable of correcting two errors .",
    "precomputed are @xmath359 and @xmath360 suppose @xmath361 is the received vector",
    ". the algorithm iteratively computes the following for @xmath362 .",
    "@xmath363 g^{(6)}&= & 0\\,z&+&({\\alpha}x^7 + { \\alpha}^2x^5 + { \\alpha}^4x^4 + { \\alpha}^5x^3 + { \\alpha}^3x^2 + { \\alpha}^2x + 1){\\omega}_0\\\\ f^{(6)}&= & x\\,z&+&({\\alpha}^2x^6 + { \\alpha}^4x^5 + { \\alpha}^5x^4 + { \\alpha}^3x^3 + { \\alpha}^2x^2 + { \\alpha}^3x){\\omega}_0\\\\[1ex ] \\vdots\\\\[1ex ] g^{(0)}&= & x\\,z&+&({\\alpha}^2x^6 + { \\alpha}^4x^5 + { \\alpha}^4x^4 + { \\alpha}x^3 + { \\alpha}^2x^2 + { \\alpha}^3 x){\\omega}_0\\\\ f^{(0)}&= & ( { \\alpha}^3x^2+{\\alpha}^5x + { \\alpha}^4)\\,z&+&({\\alpha}^3x^2+{\\alpha}^5x+{\\alpha}^4){\\omega}_0\\\\ \\end{array}\\ ] ] and in the second phase , it computes @xmath364 . then from @xmath365 , the algorithm computes the corrected codeword @xmath366 to output .",
    "we presented a fast unique decoding algorithm for differential ag codes .",
    "the principle of the algorithm is the same with the companion algorithm for evaluation ag codes in @xcite , and the description of the algorithm is almost identical with that of the other . in this paper , we focused on the differences and omitted most of the repetitive parts . the list decoding extension for evaluation ag codes done by @xcite can be done for differential ag codes in the same way .",
    "s.  sakata , h.  e. jensen , and t.  hholdt , `` generalized berlekamp - massey decoding of algebraic - geometric codes up to half the feng - rao bound , '' _ ieee trans .",
    "inf . theory _ ,",
    "41 , no .  6 , pp .",
    "17621768 , 1995 .",
    "p.  beelen and t.  hholdt , `` the decoding of algebraic geometry codes , '' in _ advances in algebraic geometry codes _ , ser .",
    "coding theory cryptol.1em plus 0.5em minus 0.4emworld sci .",
    "hackensack , nj , 2008 , vol .  5 ,"
  ],
  "abstract_text": [
    "<S> the interpolation - based decoding that was developed for general evaluation ag codes is shown to be equally applicable to general differential ag codes . a performance analysis of the decoding algorithm , which is parallel to that of its companion algorithm , is reported . </S>",
    "<S> in particular , the decoding capacities of evaluation ag codes and differential ag codes are seen to be nicely interrelated . as an interesting special case , a decoding algorithm for classical goppa codes is presented .    </S>",
    "<S> algebraic geometry code , decoding algorithm , interpolation , grbner base . </S>"
  ]
}