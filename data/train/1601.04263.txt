{
  "article_text": [
    "runtime security monitors are components of defending systems against cyber attacks and must provide fast and accurate detection of attacks .",
    "conventional run - time monitoring systems suffer from high false alarm rates , for both positive and negative alarms , and are inefficient because their typical amount of observed parameters is large and possibly irrelevant to a number of attacks .",
    "there are two key reasons for these limitations : first , the systems do not `` understand '' the complete behavior of the system they are protecting , and second , the systems do not `` understand '' what an attacker is trying to achieve .",
    "actually , most such systems are retrospective , taking into account and analyzing historical data , resulting to attack surface signatures of previous attacks and attempting to identify the same signature(s ) in new traffic .",
    "thus , conventional run - time monitors are passive , waiting for ( and expecting that ) something similar to what has already happened to recur .",
    "attackers , of course , respond by varying their attacks so as to avoid detection .",
    "there are two dimensions along which run - time monitoring systems for security can be classified .",
    "the first one is the behavior description method , i.e. profile - based or model - based .",
    "the second one is the behavior comparison method , i.e. matching to bad behavior or deviation from good behavior .",
    "this classification approach leads to four classes , as shown in figure  [ fig : quad ] , which include existing techniques and systems , each with its own strengths and weaknesses .",
    "profile - based systems that detect attacks by matching with bad behavior ( class 1 in the figure ) typically employ statistical and machine learning methods to build a profile of bad behavior of the systems and more specifically , build statistical profiles of attacks ( e.g. ,  @xcite ) .",
    "these systems are more robust than model based systems , since the machine learning techniques tend to generalize from the data presented .",
    "however , they do not provide rich diagnostic information and suffer from false alarms .",
    "alternatively , profile - based systems that detect deviation from good behavior ( class 3 in the figure ) typically build a statistical profile of normal ( good ) behavior and detect deviations from this profile ( e.g.  @xcite ) .",
    "such anomaly detectors are even more robust than class 1 systems , because they do not depend on historical knowledge of the form of an attack .",
    "however , they have a significant false alarm rate , because they have limited diagnostic information : when a deviation is detected , the known information about it is that something out of the ordinary has happened , but there is no sufficient information whether this is malicious , accidental or just a variation of the normal behavior beyond the statistically accepted profile .    model - based systems ( classes 2 and 4 in figure  [ fig : quad ] ) are popular in highly secure environments , where successful attacks cause significantly high costs .",
    "signature - based systems are a typical example in this class  ( e.g.  @xcite ) , and they look for matches to bad behavior , i.e. they are systems in class 2 .",
    "the advantage of such systems is that , when a match occurs , i.e. an attack is detected , the systems have enough diagnostic information available to `` understand '' what the failure has been .",
    "however , they lack robustness , since they will fail to detect an attack , if they have no model of it ; thus , they are susceptible to zero - day attacks and , in general , attacks they have not been trained for",
    ". finally , model - based systems that employ run - time software verification to detect deviation from good behavior fall in class 4 of the figure .",
    "these systems model the good behavior of a system ( e.g.  @xcite ) and detect deviations from that behavior using run - time software verification techniques .",
    "their advantage is that , whenever the system execution deviates from good behavior , there is knowledge of the exact problem that led to the deviation ( i.e. the offending instruction or routine ) .",
    "however , such verification methods ( a ) require adequate design / implementation information of the system to operate ( which is usually not the case for legacy systems ) and ( b ) limit run - time system performance , with high impact on real - time systems , such as industrial control systems ( ics ) .",
    "our run - time security monitor falls in class 4 , because it ( a ) models normal ( good ) behavior of the system through a formal specification description and ( b ) raises an alarm when the behavior of the application s execution deviates from the behavior described in the ( executable ) specification .",
    "specifically , our security monitor has an active model of normal behavior , namely an executable specification of the application  @xcite .",
    "this executable specification consists of a decomposition into sub - modules and pre- and post - conditions and invariant for each sub - module .",
    "in addition , data - flow and control - flow links connect the sub - modules , specifying the expected flow of values and of control .",
    "the pre- and post - conditions and invariant are arbitrary first - order statements about the set of data values ( that flow into and out of the sub - modules ) and about other arbitrary constraints respectively .",
    "our run - time security monitor is suitable not only for new systems , which derive application implementation from application specification , but also for `` legacy '' systems , where application implementations exist without adequate ( formal or informal ) application specifications .",
    "this can be achieved by describing application specification at any feasible level of abstraction through available specification information .",
    "furthermore , modular application specification at any desired level of abstraction also allows us to monitor only attack(s ) specific behavior of `` real - time '' systems without affecting their performance at run - time .",
    "as our run - time security monitor is using an executable application specification , it is efficient for use in real - time system as has been proven for real - time safety - critical systems  @xcite .",
    "our run - time security monitor ( `` rsm '' ) , shown in figure  [ fig : monitor ] , is the core component of a larger system named armet .",
    "armet takes as input a specification ( `` appspec '' ) and an implementation ( `` appimpl '' ) of the application of interest .",
    "based on the specification , the `` wrapper synthesizer '' of armet generates probes to observe the run - time behavior of the application that corresponds to the specification elements . during execution of the `` appimpl '' ,",
    "the rsm checks whether the actual behavior of the system ( _ observations _ generated by `` wrapper synthesizer '' ) is consistent with the _ predictions _ generated from `` appspec '' .",
    "if an inconsistency is detected , rsm raises an alarm and armet suspends the application execution and proceeds to diagnosis , in order to identify why the execution of `` appimpl '' did not behave as predicted .",
    "in addition to run - time monitoring , armet employs diagnostic reasoning techniques to further isolate and characterize the failure  @xcite .",
    "armet is highly robust and has high diagnostic data resolution , which is a key requirement of real - time systems that require continuous operation even after a successful attack .",
    "armet achieves continuous operation through the construction of a far more complex models of applications .",
    "rsm runs executable application specification in parallel with the actual application code , comparing their results at the granularity and abstraction level of the executable specification .",
    "the executable specification is hierarchical and modular , allowing flexibility in the granularity of the monitoring .",
    "depending on the environment , the executable specification may run at a high level of abstraction , incurring less overhead , but requiring more diagnostic reasoning when the program diverges from the behavior of the executable specification .",
    "alternatively , the executable specification can be elaborated in greater detail , incurring more overhead , but providing more containment .",
    "optionally , the model can also specify suspected incorrect behaviors of a component and associated potential attack plans , allowing the diagnostic reasoning to characterize the way in which a component may have misbehaved .",
    "then , diagnosis is a selection of behavioral modes for each component of the specification , such that the specification predicts the observed misbehavior of the system .        through this work",
    ", we introduce a highly reliable run - time security monitor with proven absence of false alarms ( i.e. soundness and completeness ) .",
    "importantly , the proof establishes a contract between the monitor and its user such that , if the user establishes the _ assumptions _ of the proof , the monitor _ guarantees _ to detect any violation at run - time .",
    "the remaining of the paper is organized as follows . in section  [ sec : rw ] , we describe related work and in section  [ sec : lang ] we present the calculus ( syntax and semantics ) of the application specification language . in section  [ sec : ad ] , we first present the calculus of the security monitor and then we present the formulation and proof of soundness and completeness of the monitor .",
    "we conclude in section  [ sec : conc ] .",
    "the operation of rsm is to check the consistency between the specified and execution behaviors of an application at run - time .",
    "this may be viewed as a run - time verification problem .",
    "the goal of run - time verification is to specify the intended behavior of a system in some formalism and to generate an executable monitor from this formalism ( i.e. specification ) that reports inconsistent execution , if detected .",
    "there has been extensive research on specification based run - time monitoring .",
    "most such approaches employ formalism such as context grammars , regular expressions  @xcite , event calculus  @xcite , temporal logic  @xcite and rule systems operating over atomic formulas  @xcite . such formalism offer limited expressive power to formalize complex system properties ,",
    "although they can be translated into efficient executable monitors . to addresses the challenges of run - time monitoring of `` legacy '' and \" real - time  systems ( namely the lack of design information and performance respectively ) , our formalism allows not only to specify dependencies , system level behavior and security properties ( in case of partial design details ) , but also to specify internal system behavior and complex security properties ( in case of desired design details ) of such systems as well .",
    "run - time monitoring of legacy systems has not received significant attention",
    ". however , there have been attempts to apply similar monitoring techniques .",
    "for example , kaiser et al .",
    "instrument the systems by probing and passing data to another component that forms a basis of the system s model which is later used to monitor run - time modifications automatically  @xcite .",
    "more recently , wofgang et al .",
    "have automatically generated run - time monitor for network traffic from a high - level specification language which is based on first order predicate logic and set theory   @xcite .",
    "furthermore , based on a variant of denotational semantics of the specification language and operational semantics of the monitor  @xcite , they verified soundness of the resource analysis of the monitor  @xcite .",
    "the resource analysis identifies the number of instances of the monitor and the number of messages required to detect a violation .",
    "model - based executable specifications have been rarely used for run - time monitoring of real - time systems  @xcite . however , barnett et al .",
    "have used asml as an executable specification language for run - time monitoring  @xcite .",
    "asml is an extension of asm , which is based on the formalism of a transition system whose states are first order algebras  @xcite .",
    "there is no formal semantics of asml , however , the operational semantics of some constructs of asm has been defined by hannan et al .",
    "more recently , choilko et al . have developed a framework for executable specification based run - time monitoring of timed systems  @xcite . in this work",
    ", the formalism of the specification is based on an _ extended time interval _ which is a pair of a time event and a time interval .",
    "the formalism for implementation is based on _ timed word _ which is a sequence of time events and the goal of the monitor is to check the conformance of an implementation word and the specification trace .",
    "in contrast to the approaches discussed above , the focus of our run - time security monitor is to check consistency of automatically generated _ predictions _ ( conditions ) from an executable specification language and run - time _ observations _ of application execution .",
    "the formalism of our specification language is based on monadic second order logic  @xcite and event calculus interpreted over algebraic data structures .",
    "this formalism allows specification of faulty behaviors of a system .",
    "furthermore , the formalism enables description of attack plans , which are exploited by the monitor at run - time for early threat detection against more sophisticated and complex attacks , e.g. advanced persistent threats .",
    "our formalism is similar to crash hoare - logic that is used to capture the faulty behavior of a file system  @xcite .",
    "our formalism allows sound construction ( resp .",
    "specification ) of high - level abstract behavior of a system from low - level abstract behavior(s ) using a method analogous to classical set builder .",
    "our security monitor is the first approach in run - time monitoring that formally assures the absence of false alarms and thus is sound and complete . for our proof",
    "we use the denotational semantics of the application specification language as described in  @xcite .",
    "our executable ( application ) specification language  @xcite consists of a _ decomposition _ of an application behavior into sub - modules and pre- and post - conditions and invariant ( _ behavioral description _ ) for each sub - module : in rest of the paper , we use the term system for application behavior .",
    "the _ decomposition _ is further equipped with data - flow and control - flow links that connect the sub - modules , specifying the expected flow of values and of control .",
    "the specification also allows to specify potential _ _ attack plan__s for the components based on attack models and associated rules that imply a certain attack model .    in the following subsection ,",
    "we discuss selected high level syntactic domains and their semantics .",
    "based on the aforementioned description , syntactically , the specification language ( represented by syntactic domain @xmath0 ) has following three main top level constructs :    1 .",
    "hierarchical decomposition ( @xmath1 ) of sub - modules , 2 .   behavioral description ( @xmath2 ) of each sub - module and 3 .",
    "attack plans ( @xmath3 ) of modules / sub - modules .",
    "the simplified grammar of these top level domains is shown in figure  [ fig : domains ] .",
    "application specification @xmath0 : : = ... @xmath1 @xmath2 @xmath3 ... + decomposition @xmath1 : : = @xmath4 @xmath5 ( @xmath4 ) @xmath1 + behavioral model @xmath2 : : = @xmath6 @xmath5 ( @xmath6 ) @xmath2 + attack plan @xmath3 : : = @xmath7 @xmath8 @xmath5 ( @xmath7 @xmath8 ) @xmath3 + ...    in the following we briefly discuss the decomposition and attack plans , and will focus more on behavioral description , being core and the only one that is also used in the following sections for semantics and proof .",
    "the hierarchical decomposition @xmath4 of a component consists of    1 .",
    "its interface * sets of inputs and outputs respectively * a set of the resources used by the component ( e.g. files , binary code , ports ) and a set of sub - components * sets of events that allow entry and exit to and from the component respectively * a set of events that are allowed to occur during the execution of the component * a set of conditional probabilities between the possible modes of the resources and the possible modes of the component and a set of known vulnerabilities occurred to the component 2 .   and a structural model that is a set of sub - components some of that might be splits or joins of * data - flows between linking ports of the sub - components and * control - flow links between cases of a branch and a component that will be enabled if that branch is taken    the syntactical domain @xmath4 is defined in figure  [ fig : decomp ] .",
    "@xmath4 : : = * define - ensemble * compname + * : entry - events * * : auto * @xmath5 ` set`(evnt ) + * : exit - events * ` set`(evnt ) + * : allowable - events * ` set`(evnt ) + * : inputs * ` set`(objname ) + * : outputs * ` set`(objname ) + * : components * ` set`(comp ) + * : controlflows * ` set`(ctrlflow ) + * : splits * ` set`(spltcf ) + * : joins * ` set`(joincf ) + * : dataflows * ` set`(dataflow ) + * : resources * ` set`(res ) + * : resource - mapping * ` set`(resmap ) + * : model - mappings * ` set`(modmap ) + * : vulnerabilities * ` set`(vulnrablty )    the elements of @xmath4 are informally discussed above .",
    "further details of @xmath4 are out of the scope of this paper .",
    "the @xmath6 describes normal ( and optionally various compromised ) behavior of a component that includes    * set of inputs and outputs respectively , * allowable events during the execution in that mode and * preconditions on the inputs , post - conditions and invariant , all of that are first order logical expressions .",
    "the complete syntax of @xmath6 is defined in figure  [ fig : behave ] .",
    "@xmath6 : : = * defbehavior - model * ( compname * normal * @xmath5 * compromised * ) + * : inputs * ` set`(objname ) + * : outputs * ` set`(objname ) + * : allowable - events * ` set`(evnt ) + * : prerequisites * ` set`(behcond ) + * : postconditions * ` set`(behcond ) + * : invariant * ` set`(behcond )      the attack plan @xmath3 consists of a description of potential attack models ( @xmath7 ) and the rules ( @xmath8 ) that imply a certain attack .",
    "syntactically , an attack plan includes    * a set of types of attacks that are being anticipated and the prior probability of each of them , * a set of effects such that how each attack type can effect mode ( normal / compromised ) of a resource and * a set of rules expressing the conditional probabilities between attack types and resource modes .",
    "the syntactic domains of @xmath7 and @xmath8 are defined in figure  [ fig : attack ] resp .",
    "@xmath7 : : = * define - attack - model * atkmodname + * : attack - types * ( ` set`(atktype ) ) + * : vulnerability - mapping * ( ` set`(atkvulnrabltymap ) )    @xmath8 : : = * defrule * tkrulname ( * : forward * ) + * if * ` set`(atkcond ) * then * ` set`(atkcons )    in principle , attack plans are hypothetical attacks based on rules that describe different ways of compromising a component .",
    "the monitor exploits such plans to match at run - time and detect any such attack , thus making the monitor more robust .      to provide an intuitive grounding for these ideas",
    "we will consider an example of a simple ics and of its model in the specification language .",
    "the system consists of a water tank , a level sensor and a pump that is capable of either filling or draining the tank .",
    "the tank has a natural leakage rate that is proportional to the height of the water column in the tank .",
    "the tank is controlled by a pid controller ; this is a computational device running a standard ( pid ) control algorithm that has a simple structure :    the algorithm has two inputs : the _ set - point _ , i.e. the water level that the tank should maintain and the _ sensor value _ provide by the level sensor .",
    "it has a simple output , the _ command_.",
    "the algorithm performs the following computations based on the three parameters notated as _",
    "kp _ , _ ki _ and _ kd _ that are used as scaling weights in the algorithm as shown in figure  [ fig : example ] ( a ) .    1 .",
    "calculate the _ error _ , the difference between the set - point and the sensor value 2 .",
    "calculate three terms : 1 .   the _ proportional _ term",
    "; this is just the error weighted by kp .",
    "2 .   the _ integral _ term ; this is a running sum of the _ errors _ seen so far , weighted by ki .",
    "the _ derivative _ term ; this is a local estimate of rate of change of the sensor value , weighted by kd .",
    "calculate the sum of the three terms .",
    "the value of the sum is the _ command _ output of the algorithm .",
    "the _ command _ output of the algorithm is sent to the pump , controlling the rate at which the pump either adds or removes water .",
    "the algorithm is `` tuned '' by the choice of the three parameters kp , ki and kd ; when well tuned the system responds quickly to deviations from the set - point with little over - shoot and very small oscillations around the set - point .",
    "finally , we note that the level sensor can be viewed as ( and often is ) a computational and communication device that estimates the actual height of the water tank and communicates the estimated height back to the controller .",
    "there are two standard categories of attacks on such a system :    * * false data injection attacks*. these are attacks on the sensor and its communication channel , such that the controller receives a value that is different from the actual level of the tank .",
    "* * controller attacks*. these are penetrations to the computer running the control algorithm . for our purposes",
    "it is only necessary to consider attacks that overwrite the value of one of kp , ki , or kd .",
    "any such attack , will cause the controller to calculate an incorrect command .    in either case",
    ", the end result is that the level in the water tank will not be correctly maintained . in the first case",
    ", the controller calculates a correct response to the distorted sensor value .",
    "for example , suppose that the attacker is systematically distorting the sensor value to be too low .",
    "in that case , the controller will continuously issue commands to the pump to add water to the tank , eventually causing the tank to overflow . in the second case ,",
    "a change in value of one of the controller parameters will cause the controller to calculate in an incorrect command .",
    "this can have a variety of effects , depending on which parameters are changed .",
    "monitoring of such a system requires its behavioral specification as shown in figure  [ fig : example ] ( b ) .",
    "the actual system is a _ cyber - physical _ system , containing both physical components ( i.e. the tank , the pump ) and computational components ( i.e. the controller and the sensor ) .",
    "the monitor model parallels this structure ; it contains computational models of the controller and the sensor as well as a computational model of the physical plant .",
    "this later model performs a numerical integration of the differential equations describing the physical plant s behavior , e.g. the dynamics of the pump .",
    "the application specification of the controller , essentially mirrors the structure of the algorithm : there is a component that calculates the error term , data - flow links that connect the error term to each of three parallel steps that calculate the proporational , integral and derivative terms , finally there is the summation component that adds the three terms , calculating the command output .    the structural model of the controller",
    "is shown diagrammatically in figure  [ fig : example ] ( b ) ( n and c refers to normal and compromised behavior and a refers to possible attacks ) .",
    "the models for the components of the controller are reasonably straightforward .",
    "for example , the normal behavioral model for the kd calculation states that the output of the component is the derivative of the error , weighted by kd .",
    "this is expressed as a post - condition , as shown in figure  [ fig : behave - comp - der - example ] .",
    "notice that what the controller calculates is a discrete approximation of the derivative of the error term , which is calculated using the previous and current versions of the error .",
    "the value of the error term is conceptually a state variable that is updated between successive iterations of the controller computation . in our specification language , however , we model these as extra inputs and data flows ( as we do also for control algorithm parameters such as kd ) . for simplicity , we have omitted these extra items from the diagram in figure  [ fig : example ] .    the compromised behavioral model states that any other behavior is acceptable ; it does so by stating no post - conditions .",
    "the run - time behavior of the monitor will depend on the strength of the post - conditions ; if these are too weak , the monitor may allow undesired behaviors ..    .... ( define - component - type controller - step   : entry - events ( controller - step )   : exit - events ( controller - step )   : allowable - events ( update - state accum - error )   : inputs ( set - point sens - val )   : outputs ( com )      : components   ( ( err - comp : type err - comp : models ( normal ) ) ( comp - der : type comp - der : models ( normal ) ) ... )      : dataflows   ( ( set - point controller - step set - point err - comp ) ( the - error err - comp the - error comp - der ) ... ) ) ....    .... ( define - component - type comp - der   : entry - events ( compute - derivative )   : exit - events ( compute - derivative )   : inputs ( the - error old - error kd time - step )   : outputs ( der - term )   : behavior - modes ( normal compromised ) )    ( defbehavior - model ( comp - der normal )   : inputs ( the - error the - old - error kd time - step )   : outputs ( der - term )   : prerequisites ( [ data - type - of the - error number ] )   : post - conditions       ( [ and [ data - type - of der - term number ]     [ equal der - term       ( * kd(/(- new - error old - error ) time - step ) ) ] ] ) )     ( defbehavior - model ( comp - der compromised )   : inputs ( the - error the - old - error kd time - step )   : outputs ( der - term )   : prerequisites ( )   : post - conditions ( ) ) ....      ( a ) application ( b ) specification      in this section , we first give the definition of semantic algebras , then discuss informal description and the formal denotational semantics of the core construct ( i.e. behavioral description ) of the specification language .",
    "semantic domains _ represent a set of elements that share some common properties .",
    "a semantic domain is accompanied by a set of operations as functions over the domain .",
    "a domain and its operations together form a _ semantic algebra",
    "_  @xcite .",
    "the domains of our language are similar to the domains of any classical programming / specification language ( e.g. java , jml , acsl ) . in the following we declare",
    "/ define only important semantic domains and their operations .",
    "the domain _ environment _ holds the environment values of the language and is formalized as a tuple of domains _ context _ ( which is a mapping of identifiers to the environment values ) and _ space _ ( that models the memory space ) .",
    "the _ environment _ domain includes interesting values , e.g. component , attack plan and resource . here",
    "resource can be binary code in memory , files and ports etc .",
    "* domain * : _ environment _ + _ environment _ : = _ context _ @xmath9 _ space _ + _ context _ : = _ identifier _",
    "@xmath10 _ envvalue _ + _ envvalue _ : = _ variable _ + _ component _ + _ atkplan _ + _ resource _ + ... + _ space _ : = @xmath11(_variable _ ) + _ variable _ : = n , where n @xmath12 @xmath13 represents locations the domain _ environment _ supports typical selection , update and equality operations over its values .",
    "the domain _ state _ represents the execution of a program .",
    "a _ store _ is important element of the state and holds for every _ variable _ a _ value_. the _ data _ of the state is a tuple of a _ flag _ that represents the current status of the state and a _ mode _ to represent the current mode of execution of the state of a component .",
    "* domain * : _ state _ + _ state _ : = _ store _ @xmath9 _ data _ + _ store _ : = _ variable _ @xmath10 _ value _ + _ data _ : = _ flag _ @xmath9 _ mode _ + _ flag _ : = \\{running , ready , completed } + _ mode _ : = \\{normal , compromised } the domain _ state _ has typical operations , e.g. read and write / update of values , checking equality of _ flag _ and _ mode _ in a given state , and setting a certain _ flag _ and _ mode _ of a given state .",
    "_ value _ is a disjunctive union domain and note that the domain _ value _ is a recursive domain .",
    "* domain * : _ value _",
    "_ value _ : = _ obsevent _ + _ rtevent _ + _ component _ + _ atkplan _",
    "+ ... + _ _",
    "value__@xmath14    the domain includes semantic values of observable event , a run - time event and attack plan etc .",
    "the equality of the given two semantic values can be evaluated .",
    "the _ component _ formalizes the semantic model of a component as a predicate over decomposition , normal and compromised behavior and a pre - state and a post - state of the component s execution respectively .",
    "the predicate is formalized as follows :    _ component _",
    "= @xmath11(_sbehavior _ @xmath9 _ nbehavior _ @xmath9 _ cbehavior _ @xmath9 _ state _",
    "@xmath9 _ _ state__@xmath15 )    where    _ sbehavior _ : = @xmath11(__value__@xmath14 @xmath9 _ _ value__@xmath14 @xmath9 _ _ value__@xmath14 @xmath9 _ state _",
    "@xmath9 _ _ state__@xmath15 ) + _ nbehavior _ = _ cbehavior _ : = @xmath11(__value__@xmath14 @xmath9 _ _ value__@xmath14 @xmath9 _ state _",
    "@xmath9 _ _ state__@xmath15 )    furthermore , _",
    "sbehavior _ is defined as a predicate over sets of input and output values , set of allowable values , a pre - state and a post - state of the behavior .",
    "also , normal behavior and compromised behavior ( _ nbehavior _ and _ cbehavior _ ) are also defined as predicates over sets of input and output values , a pre - state and a corresponding post - state respectively .",
    "the semantics domain _ atkmodel _ formalizes the attack model and is defined as a predicate over an attack name , probability of the attack and the corresponding vulnerability causing the attack ; the attack model is formulated as follows :    _ atkmodel _ : = @xmath11(_identifier _ @xmath9 _ fval _ @xmath9 _ vulnerability _ )      a valuation function defines a mapping of a language s abstract syntax structures to its corresponding meanings ( semantic algebras )  @xcite .",
    "the valuation function operates on a syntactic construct and returns a function from the environment to a semantic domain .",
    "we define the result of the valuation function as a predicate , e.g. the behavioral relation ( behrelation ) is defined as a predicate over an environment , a pre- and a post - state and is defined as follows :    behrelation : = @xmath11(environment @xmath9 state @xmath9 state@xmath15 )    the valuation functions for the abstract syntax domains of specification ( @xmath0 ) , behavioral description ( @xmath6 ) and attack plans ( @xmath3 ) have same signatures .",
    "for example , a valuation function signature for @xmath6 is defined as follows :    @xmath6 : environment @xmath10 behrelation    based on the above relation and the auxiliary semantic inference rules ( see figure  [ fig : semrules ] ) , we define valuation functions for @xmath6 and @xmath3 in the following subsection .",
    "semantically , normal and compromised behavioral models results in modifying the corresponding elements of the environment value _ component _ as defined below :    = @xmath6(e)(e , s , s ) @xmath16 + let = c @xmath12 component : compname(e)(s , s , invalue(c ) ) in + @xmath17 @xmath18 @xmath12 environment , nseq @xmath12 ` set`(evntname ) , b@xmath18 , b@xmath19 : @xmath20 , + eseq @xmath12 obsevent * , iseq , oseq @xmath12 value@xmath14 : + ` set`(objname@xmath18)(e)(s , iseq ) @xmath21 `",
    "set`(behcond@xmath18)(e ) ( s ) @xmath21 + ( c , e , b@xmath18 ) @xmath21 ` set`(evnt)(e ) ( e , s , s , nseq , eseq ) @xmath21 + ` set`(objname@xmath19)(e)(s , oseq ) @xmath21`set`(behcond@xmath19)(e)(s , s)@xmath21 + ` set`(behcond@xmath22)(e ) ( s , s ) @xmath21 noatk(c , e , b@xmath19 ) + @xmath23 + let v = b@xmath18 @xmath21 b@xmath19 @xmath21 eqmode(s , `` normal '' ) in + ( c , e , s , s , iseq , oseq , v )    where update is an auxiliary semantic rule as shown in figure  [ fig : semrules ] .    in detail , if the semantics of @xmath6 in an environment @xmath24 yields environment @xmath25 and transforms a pre - state @xmath26 into a post - state @xmath27 then    * the evaluation of inputs ` set`(objname@xmath18 ) yields a set of values @xmath28 in environment @xmath24 and state @xmath26 such that the pre - conditions ` set`(behcond@xmath18 ) hold in @xmath24 and @xmath26 and the component @xmath29 has no potential threat ( see rule noatk ) and * the evaluation of allowable events results in environment @xmath25 and given post - state @xmath27 with some auxiliary sets @xmath30 and @xmath31 and * the evaluation of outputs ` set`(objname@xmath19 ) yields a set of values @xmath32 in @xmath25 and @xmath27 such that post - conditions ` set`(behcond@xmath19 ) hold in @xmath33 , @xmath26 and @xmath27 and * the invariant ` set`(behcond@xmath19 ) holds in @xmath25 , @xmath26 and @xmath27 , and the component @xmath29 has no threat ( noatk ) , finally the environment @xmath25 can be constructed as follows * * if the post - state is `` normal '' then @xmath25 is an update to the normal behavior `` nbeh '' of the component `` compname '' * * otherwise @xmath25 is an update to the compromised behavior `` cbeh '' of the component as shown in the corresponding inference rules of update .",
    "moreover , the valuation function for attack plan is defined as :    = @xmath7(e)(e , s , s ) @xmath16 + @xmath17 = s ",
    "@xmath12 state , aseq , aseq , vnseq @xmath12 iseq , apseq @xmath12 value@xmath14 : + ` set`(atktype)(e)(s , instate@xmath15(s  ) , aseq , apseq ) @xmath21 + ` set`(atkvulnrabltymap)(e ) ( s  , s , aseq , vnseq ) @xmath21 + ( atkmodname , e , e , aseq , apseq , vnseq )    in detail , the semantics of the domain `` @xmath7 '' updates the environment @xmath24 with a semantic value of _ atkplan _ such that if    * in a given @xmath24 and @xmath26 , the evaluation of `` ` set`(atktype ) '' yields post - state @xmath34 , a set of attack types @xmath35 and a set of values ( conditional probabilities ) @xmath36 and also * in given @xmath24 and @xmath26 , the evaluation of `` ` set`(atkvulnrabltymap ) '' yields post - state @xmath27 , a set of attack types @xmath37 and a set of vulnerabilities @xmath38 , then * the environment @xmath25 is an update of environment @xmath24 with the semantic value _ atkplan _ , which is a triple of ( a ) a set of attack types ( b ) a set of corresponding probabilities and ( c ) a set of vulnerabilities causing the attack types , respectively .",
    "based on  @xcite , in this section we discuss the informal behavior of our run - time security monitor whose main goal is to check consistency between a program s run - time _ observations _ and its specification - based _ predictions _ and to only raise a flag if any inconsistency is identified . in detail ,",
    "when the application implementation starts execution , a `` startup '' event is generated and dispatched to the top level component of the system , which transforms the execution state of the component into `` running '' mode .",
    "the component instantiates its subnetwork ( i.e. sub - components ) and propagates the data along its data - links by enabling the corresponding control - links ( if involved ) .",
    "when the data arrives on the input port of the component , the monitor checks if it is complete ; if so , the monitor checks the preconditions of the component for the data and if they succeed , it transforms the state of the component into `` ready '' mode",
    ". should the conditions fail , it raises a flag .    after the above startup ,",
    "the execution monitor starts monitoring the arrival of every _ observation _ ( run - time event ) as follows :    1 .",
    "if the event is a `` method entry '' , then the execution monitor checks if this is one of the `` entry events '' of the component in the `` ready '' state ; if so , then after receiving the data , the respective preconditions , invariant and absence of attack plans are checked ; if they succeed , then the data is applied on the input port of the component and the mode of the execution state is changed to `` running '' .",
    "if the event is a `` method exit '' , then the execution monitor checks if this is one of the `` exit events '' of the component in the `` running '' state ; if so , it changes its state into `` completed '' mode and collects the data from the output port of the component and checks for the corresponding postconditions , invariant and absence of attack plans . should the checks fail , the monitor raises an alarm .",
    "3 .   if the event is one of the `` allowable events '' of the component , if invariant holds and there is no attack plan then it continues execution and finally 4 .",
    "otherwise , if the event is an none of the above events , then the monitor raises an alarm .",
    "based on the aforementioned description of the execution monitor , we have formalized the denotational semantics of the monitor by a relation @xmath39 that is declare and defined as follows :    * monitor * @xmath40 * appimpl * @xmath9 * appspec * + @xmath10 * environment * @xmath10 * state * @xmath9 * * state**@xmath15 + monitor(@xmath41 , @xmath0)(e)(s , s ) @xmath16 + @xmath17 c @xmath12 component , t , t",
    "@xmath12 state@xmath42 , d , d @xmath12 environment@xmath42 , rte @xmath12 rtevent : + @xmath0(d)(d , t , t ) @xmath21 @xmath41(e@xmath43)(e@xmath43 , s , s ) @xmath21 setflag(s , `` running '' ) @xmath21 + eqmode(s , `` normal '' ) @xmath21 arrives(rte , s ) @xmath21 equals(s , t ) @xmath21 equals(e@xmath43 , d ) + @xmath23 = + @xmath17 p , p @xmath12 environment * , m , n @xmath12 state * : + equals(m(0 ) , s ) @xmath21 equals(p(0 ) , e@xmath43 ) @xmath21 + @xmath44 k @xmath12 @xmath13 : + ( @xmath17 i @xmath12 @xmath45 : monitors(i , rte , c , p , p , m , n ) @xmath21 equals(s , n(k ) ) ) @xmath21 + @xmath21 + if qmode(n(k ) , `` normal '' ) then + eqflag(n(k ) , `` completed '' ) @xmath21 equals(s , t ) + else @xmath46 equals(s , t )    in detail , the predicate says that if we execute specification ( @xmath0 ) in an arbitrary safe pre - state ( s ) and environment ( d ) and execute program ( @xmath41 ) in an arbitrary pre - state ( t s.t .",
    "s equals t ) and environment ( e@xmath43 s.t .",
    "e@xmath43 equals d ) then there is a finite natural number ( k ) at which monitor can be observed such that for all iterations until k , the monitor continuous operation .",
    "however , at iteration k , either the monitor is in a `` normal '' mode or in a `` compromised '' mode .",
    "if the mode is `` normal '' , then the component under monitoring has finished its job safely and the post - state of the program execution ( t ) is equal to post - state ( t ) of the specification execution , otherwise component is compromised and thus the program execution state ( s ) and specification execution state ( t ) are inconsistent .",
    "the core semantics of _ monitor _ is captured by an auxiliary predicate _ monitors _ that is defined as a relation on    * the number of observation @xmath47 w.r.t . of a component , * an observation ( run - time event ) @xmath48 , component @xmath29 being observed , * sets of pre- and post - environments @xmath24 and @xmath25 resp . and * sets of pre- and post - states @xmath26 and @xmath27 respectively .    the predicate _ monitors _",
    "is formalized as follows :    * monitors * @xmath40 @xmath13 = @xmath9 * rtevent * @xmath9 * component * + @xmath9 * * environment**@xmath14 @xmath9 * * environment**@xmath14 + @xmath9 * * state**@xmath14 @xmath9 * * state**@xmath49 + monitors(i , rte , c , e , e , s , s ) @xmath16 + eqmode(s(i ) , `` completed '' ) + @xmath50 + [ ( qmode(s(i ) , `` running '' ) @xmath50 eqmode(s(i ) , `` ready '' ) ) @xmath21 + @xmath46 eqmode(s(i ) , `` compromised '' ) @xmath21 c(e(i))(e(i ) , s(i ) , s(i ) ) @xmath21 + @xmath44 e @xmath12 obevent : equals(rte , store(name(rte))(e(i ) ) ) @xmath21 + ( type(oe , c ) , c , e , e , s , s , i , eqmode(s , `` normal '' ) ) ) ]    in detail , the predicate _ monitors _ is defined such that , at any arbitrary observation either the execution is completed and returns or the current execution state @xmath51 of component @xmath29 is `` ready '' or `` running '' and the current execution state is safe and behavior of the component @xmath29 has been evaluated and there is a run - time event @xmath52 that we want to observe ( and thus equals an _ observation _",
    "@xmath48 ) and then any of the following can happen :    * either the _ prediction _ resp .",
    "_ observation _ is an entry event of the component @xmath29 , then it waits until the complete data for @xmath29 arrives , if so , then * * either the preconditions and the invariant of `` normal '' behavior of the component hold and there is no potential attack for the component ( as modeled by semantic rule comp in figure  [ fig : semrules ] ) ; if so , then the subnetwork of the component is initiated and the sub - components in the subnetwork are monitored iteratively with the corresponding arrival of the _ observation _ * * or the preconditions and the invariant of `` compromised '' behavior of the component hold or some attack plan is detected for the component , in this case the state is marked to `` compromised '' and returns * or the _ observation _ is an exit event and after the arrival of complete data , the post - conditions and the invariant hold and if there is no potential threat detected , then the resulting state is marked as `` completed '' * or the _ observation _ is an allowable event , the invariant holds and there is no threat for @xmath29 , then the @xmath29 continues the execution * or the _ observation _ is an unexpected event ( i.e. none of the above holds ) , then the state is marked as `` compromised '' and returns .    all of the above choices are modeled by the corresponding semantic inference rule of ` run ` , see figure  [ fig : semrules ] .",
    "the intent of soundness statement is to articulate whether the system s behavior is consistent with the behavioral specification . essentially , the goal here is to show the absence of false negative alarm such that whenever the security monitor alarms there is indeed a semantic inconsistency between post - state of the program execution and post - state of the specification execution .",
    "the soundness theorem is stated as follows :    [ soundness ] the result of the security monitor is sound for any execution of the target system and its specification , iff , the specification is consistent with the program and the program executes in a safe pre - state and in an environment that is consistent with the environment of the specification , then    * for the pre - state of the program , there is an equivalent safe pre - state for which the specification can be executed and the monitor can be observed and * if we execute the specification in an equivalent safe pre - state and observe the monitor at any arbitrary ( combined ) post - state , then * * either there is no alarm , and then the post - state is safe and the program execution ( post - state ) is semantically consistent with the specification execution ( post - state ) * * or there is an alarm , and then the post - state is compromised and the program execution ( post - state ) and the specification execution ( post - state ) are semantically inconsistent .    formally , soundness theorem has the following signatures and definition .",
    "soundness_ad @xmath40 @xmath11(appimpl @xmath9 appspec @xmath9 bool ) + soundness_ad(@xmath41 , @xmath0 , b ) @xmath16 + @xmath17 @xmath42 @xmath12 environment@xmath42 , e@xmath43 , e@xmath43 @xmath12 environment@xmath43 , s , s @xmath12 state@xmath43 : + consistent(e@xmath42 , e@xmath43 ) @xmath21 consistent(@xmath41 , @xmath0 ) @xmath21 + @xmath41(e@xmath43)(e@xmath43 , s , s ) @xmath21 eqmode(s , `` normal '' ) + @xmath23 + @xmath44 t , t @xmath12 state@xmath42 , e@xmath42 @xmath12 environment@xmath42 : + equals(s , t ) @xmath21 @xmath0(e@xmath42)(e@xmath42 , t , t ) @xmath21 monitor(@xmath41 , @xmath0)(e@xmath43;e@xmath42)(s;t , s;t ) @xmath21 + @xmath17 t , t @xmath12 state@xmath42 , e@xmath42 @xmath12 environment@xmath42 : + equals(s , t ) @xmath21 @xmath0(e@xmath42)(e@xmath42 , t , t ) @xmath21 monitor(@xmath41 , @xmath0)(e@xmath43;e@xmath42)(s;t , s;t ) + @xmath23 = + let b = eqmode(s , `` normal '' ) in + if b = ` true ` then equals(s , t ) else @xmath46 equals(s , t ) ( g )    in detail , the soundness statement says that , if    1 .",
    "a specification environment ( e@xmath42 ) is _ consistent _ with a run - time environment ( e@xmath43 ) and 2 .",
    "a target system ( @xmath41 ) is _ consistent _ with its specification ( @xmath0 ) and 3 .   in a given run - time environment ( e@xmath43 ) ,",
    "execution of the system ( @xmath41 ) transforms pre - state ( s ) into a post - state ( s ) and 4 .",
    "the pre - state ( s ) is safe , i.e. the state is in `` normal '' mode ,    then    * there is such pre- and post - states ( t and t respectively ) and environment ( e@xmath42 ) of the specification execution such that in a given specification environment ( e@xmath42 ) , execution of the specification ( @xmath0 ) transforms pre - state ( t ) into a post - state ( t ) and * the pre - states s and t are _ equal _ and _ _ monitor__ing of the system ( @xmath41 ) transforms combined pre - state ( s;t ) into a combined post - state ( s;t ) and if * in a given specification environment ( e@xmath42 ) , execution of the specification ( @xmath0 ) transforms pre - state ( t ) into a post - state ( t ) and * the pre - states s and t are _ equal _ and _ _ monitor__ing of the system ( @xmath41 ) transforms pre - state ( s ) into a post - state ( s ) then * * either there is no alarm ( b is ` true ` ) and then the post - state s of program execution is safe and the resulting states s and t are semantically _ equal _ * * or the security monitor alarms ( b is ` false ` ) and then the post - state s of program execution is compromised and the resulting states s and t are semantically not",
    "_ equal_.    in the following section we present proof of the soundness statement .",
    "the proof is essentially a structural induction on the elements of the specification ( @xmath0 ) of the system ( @xmath41 ) .",
    "we have proved only interesting case @xmath6 of the specification to show that the proof works in principle . however , the proof of the remaining parts can easily be rehearsed following the similar approach .    the proof is based on certain lemmas ( see subsection  [ subsec : lemmas ] ) , which are about the relations between different elements of the system and its specification ( being at different levels of abstraction ) .",
    "these lemmas and relations can be proved based on the defined auxiliary functions and predicates ( see subsection  [ subsec : afp ] ) that are based on the method suggested by hoare  @xcite .    in the following ,",
    "we start proof with induction on @xmath2 .      we can re - write ( g ) as    soundness_ad(@xmath41 , @xmath2 , b ) @xmath16 + @xmath17 @xmath42 @xmath12 environment@xmath42 , e@xmath43 , e@xmath43 @xmath12 environment@xmath43 , s , s @xmath12 state@xmath43 : + consistent(e@xmath42 , e@xmath43 ) @xmath21 consistent(@xmath41 , @xmath2 ) @xmath21 + @xmath41(e@xmath43)(e@xmath43 , s , s ) @xmath21 eqmode(s , `` normal '' ) + @xmath23 + @xmath44 t , t @xmath12 state@xmath42 , e@xmath42 @xmath12 environment@xmath42 : + equals(s , t ) @xmath21 @xmath2(e@xmath42)(e@xmath42 , t , t ) @xmath21 + monitor(@xmath41 , @xmath2)(e@xmath43;e@xmath42)(s;t , s;t ) @xmath21 + @xmath17 t , t @xmath12 state@xmath42 , e@xmath42 @xmath12 environment@xmath42 : + equals(s , t ) @xmath21 @xmath2(e@xmath42)(e@xmath42 , t , t ) @xmath21 + monitor(@xmath41 , @xmath2)(e@xmath43;e@xmath42)(s;t , s;t ) + @xmath23 = + let b = eqmode(s , `` normal '' ) in + if b = ` true ` then equals(s , t ) + else @xmath46 equals(s , t ) ( g-1 )    here , we have two syntactic cases for @xmath2 but we will show only one case in the following subsection .      we can re - write ( g-1 ) as    soundness_ad(@xmath41 , @xmath6 , b ) @xmath16 + @xmath17 @xmath42 @xmath12 environment@xmath42 , e@xmath43 , e@xmath43 @xmath12 environment@xmath43 , s , s @xmath12 state@xmath43 : + consistent(e@xmath42 , e@xmath43 ) @xmath21 consistent(@xmath41 , @xmath6 ) @xmath21 + @xmath41(e@xmath43)(e@xmath43 , s , s ) @xmath21 eqmode(s , `` normal '' ) + @xmath23 + @xmath44 t , t @xmath12 state@xmath42 , e@xmath42 @xmath12 environment@xmath42 : + equals(s , t ) @xmath21 @xmath6(e@xmath42)(e@xmath42 , t , t ) @xmath21 + monitor(@xmath41 , @xmath6)(e@xmath43;e@xmath42)(s;t , s;t ) @xmath21 + @xmath17 t , t @xmath12 state@xmath42 , e@xmath42 @xmath12 environment@xmath42 : + equals(s , t ) @xmath21 @xmath6(e@xmath42)(e@xmath42 , t , t ) @xmath21 + monitor(@xmath41 , @xmath6)(e@xmath43;e@xmath42)(s;t , s;t ) + @xmath23 = + let b = eqmode(s , `` normal '' ) in + if b = ` true ` then equals(s , t ) + else @xmath46 equals(s , t ) ( f.1 )    from ( f.1 ) , we know    * consistent(e@xmath42 , e@xmath43 ) ( 1 ) * consistent(@xmath41 , @xmath6 ) ( 2 ) * @xmath41(e@xmath43)(e@xmath43 , s ,",
    "s ) ( 3 ) * eqmode(s , `` normal '' ) ( 4 )    we show    * @xmath44 t , t @xmath12 state@xmath42 , e@xmath42 @xmath12 environment@xmath42 : equals(s , t ) @xmath21 + @xmath6(e@xmath42)(e@xmath42 , t , t ) @xmath21 monitor(@xmath41 , @xmath6)(e@xmath43;e@xmath42)(s;t , s;t ) ( g-1.1 ) * @xmath17 t , t @xmath12 state@xmath42 , e@xmath42",
    "@xmath12 environment@xmath42 : equals(s , t ) @xmath21 + @xmath6(e@xmath42)(e@xmath42 , t , t ) @xmath21 monitor(@xmath41 , @xmath6)(e@xmath43;e@xmath42)(s;t , s;t ) + @xmath23 = + let b = eqmode(s , `` normal '' ) in + if b = ` true ` then equals(s , t ) + else @xmath46 equals(s , t ) ( g-1.2 )      we split the goal ( g-1.1 ) into following three sub - goals :    equals(s , t ) ( g-1.1.1 ) @xmath6(e@xmath42)(e@xmath42 , t , t ) ( g-1.1.2 ) monitor(@xmath41 , @xmath6)(e@xmath43;e@xmath42)(e@xmath43;e@xmath42 , s;t , s;t ) ( g-1.1.3 )      we define    t : = constructs(s , @xmath6 ) ( 5 )    we instantiate lemma ( 1 ) with s as s , t as t , @xmath0 as @xmath6 to get    t : = constructs(s ,",
    "@xmath6 ) @xmath23 equals(s , t ) ( i.1 )    the goal ( g-1.1.1 ) follows from ( i.1 ) and definition ( 5 ) .",
    "@xmath53      we expand definition ( 2 ) and get    @xmath17 m , m @xmath12 state , n , n @xmath12 environment : + = @xmath41(n)(n , m , m ) @xmath21 eqmode(m , \" normal ) + @xmath23 @xmath6(n)(n , m , m ) ( f.2 )    we instantiate formula ( f.2 ) with m as s;t , m as s;t , n as e@xmath43;e@xmath42 , n as e@xmath43;@xmath42 and @xmath41 with @xmath41 to get    = @xmath41(e@xmath43;e@xmath42)(e@xmath43;e@xmath42 , s;t , s;t ) @xmath21 eqmode(s;t , `` normal '' ) + @xmath23 @xmath6(e@xmath43;e@xmath42)(e@xmath43;e@xmath42 , s;t , s;t ) ( i.2 )    we instantiate lemma ( 4 ) with s as s , s as s , t as t , t as t , e@xmath43 as e@xmath43 , e@xmath43 as e@xmath43 , e@xmath42 as e@xmath42 , e@xmath42 as e@xmath42 , @xmath41 as @xmath41 and get    @xmath41(e@xmath43;e@xmath42)(e@xmath43;e@xmath42 , s;t , s;t ) @xmath16 @xmath41(e@xmath43)(e@xmath43 , s , s ) ( i.3 )    we instantiate lemma ( 6 ) with s as s , t as t , t and get    eqmode(s;t , `` normal '' ) @xmath16 eqmode(s , `` normal '' ) ( i.4 )    from ( i.2 ) with assumptions ( 3 ) , ( 4 ) , ( i.3 ) and ( i.4 ) we get    @xmath6(e@xmath43;e@xmath42)(e@xmath43;e@xmath42 , s;t , s;t ) ( i.2 )    we instantiate lemma ( 5 ) with s as s , s as s , t as t , t as t , e@xmath43 as e@xmath43 , e@xmath43 as e@xmath43 , e@xmath42 as e@xmath42 , e@xmath42 as e@xmath42 , @xmath0 as @xmath6 and get    @xmath6(e@xmath43;e@xmath42)(e@xmath43;e@xmath42 , s;t , s;t ) @xmath16 @xmath6(e@xmath43)(e@xmath43 , s , s ) ( i.5 )    the goal ( g-1.1.2 ) follows from ( i.5 ) with assumption ( i.2).@xmath53 .",
    "we instantiate induction assumption ( on @xmath2 ) with @xmath41 as @xmath41 , @xmath0 as @xmath6 , b as b to get     + @xmath17 @xmath42 @xmath12 environment@xmath42 , e@xmath43 , e@xmath43 @xmath12 environment@xmath43 , s , s @xmath12 state@xmath43 : + consistent(e@xmath42 , e@xmath43 ) @xmath21 consistent(@xmath41 , @xmath6 ) @xmath21 + @xmath41(e@xmath43)(e@xmath43 , s , s ) @xmath21 eqmode(s , `` normal '' ) + @xmath23 + @xmath44 t , t @xmath12 state@xmath42 , e@xmath42 @xmath12 environment@xmath42 : + equals(s , t ) @xmath21 @xmath6(e@xmath42)(e@xmath42 , t , t ) @xmath21 + monitor(@xmath41 , @xmath6)(e@xmath43;e@xmath42)(s;t , s;t ) @xmath21 + @xmath17 t , t @xmath12 state@xmath42 , e@xmath42 @xmath12 environment@xmath42 : + equals(s , t ) @xmath21 @xmath6(e@xmath42)(e@xmath42 , t , t ) @xmath21 + monitor(@xmath41 , @xmath6)(e@xmath43;e@xmath42)(s;t , s;t ) + @xmath23 = + let b = eqmode(s , `` normal '' ) in + if b = ` true ` then equals(s , t ) + else @xmath46 equals(s , t ) ( i.6 )    we instantiate ( i.6 ) with e@xmath42 as e@xmath42 , e@xmath42 as e@xmath42 , e@xmath43 as e@xmath43 , e@xmath43 as e@xmath43 , s as s , s as s to get    consistent(e@xmath42 , e@xmath43 ) @xmath21 consistent(@xmath41 , @xmath6 ) @xmath21 + @xmath41(e@xmath43)(e@xmath43 , s , s ) @xmath21 eqmode(s , `` normal '' ) + @xmath23 + @xmath44 t , t @xmath12 state@xmath42 , e@xmath42 @xmath12 environment@xmath42 : + equals(s , t ) @xmath21 @xmath6(e@xmath42)(e@xmath42 , t , t ) @xmath21 + monitor(@xmath41 , @xmath6)(e@xmath43;e@xmath42)(s;t , s;t ) @xmath21 + @xmath17 t , t @xmath12 state@xmath42 , e@xmath42 @xmath12 environment@xmath42 : + equals(s , t ) @xmath21 @xmath6(e@xmath42)(e@xmath42 , t , t ) @xmath21 + monitor(@xmath41 , @xmath6)(e@xmath43;e@xmath42)(s;t , s;t ) + @xmath23 = + let b = eqmode(s , `` normal '' ) in + if b = ` true ` then equals(s , t ) + else @xmath46 equals(s , t ) ( i.6.1 )    the goal ( g-1.1.3 ) follows from ( i.6.1 ) with assumptions ( 1 ) , ( 2 ) , ( 3 ) , ( 4 ) . hence goal ( g-1.1 ) is proved .",
    "@xmath53      we know",
    "* equals(s , t ) ( 6 ) * @xmath6(e@xmath42)(e@xmath42 , t , t ) ( 7 ) * monitor(@xmath41 , @xmath6)(e@xmath43)(e@xmath43 , s , s ) ( 8)    we show    let b = eqmode(s , `` normal '' ) in + if b = ` true ` then equals(s , t ) + else @xmath46 equals(s , t ) ( g-1.2 )    we have two cases here    [ [ section ] ]    we know    eqmode(s , `` normal '' ) ( 10 )    we show    equals(s , t ) ( g-1.2  )    we define    t : = constructs(s , @xmath6 ) ( 11 )    we instantiate lemma ( 1 ) with s as s , t as t to get    t : = constructs(s , @xmath6 ) @xmath23 equals(s , t ) ( i.7 )    the goal ( g-1.2  ) follows from ( i.7 ) with def .",
    "( 11 ) and ( 10).@xmath53    [ [ section-1 ] ]    we know    @xmath46 eqmode(s , `` normal '' ) ( 12 )    we instantiate lemma ( 7 ) with s as s and get    @xmath46 eqmode(s , `` normal '' ) @xmath23 eqmode(s , `` compromised '' ) ( i.8 )    from ( i.8 ) with assumption ( 12 ) , we know    eqmode(s , `` compromised '' ) ( 13 )    we show    @xmath46 equals(s , t ) ( g-1.2 )    we instantiate lemma ( 2 ) with s as s , s as s , t as t , t as t , e@xmath43 as e@xmath43 , e@xmath43 as e@xmath43 , e@xmath42 as e@xmath42 , e@xmath42 as e@xmath42 , @xmath41 as @xmath41 , @xmath0 as @xmath6 to get    @xmath41(e@xmath43)(e@xmath43 , s , s ) @xmath21 @xmath6(e@xmath42)(e@xmath42 , t , t ) + @xmath21 equals(s , t ) @xmath21 eqmode(s , `` compromised '' ) + @xmath23 t @xmath54 constructs(s , @xmath6 ) ( i.9 )    from ( i.9 ) , with assumptions ( 3 ) , ( 7 ) , ( 6 ) and ( 13 ) we get    t @xmath54 constructs(s , @xmath6 ) ( 14 )    we instantiate lemma ( 3 ) with s as s , t as t , @xmath0 as @xmath6 to get    t",
    "@xmath54 constructs(s , @xmath6 ) @xmath23 @xmath46 equals(s , t ) ( i.10 )    the goal ( g-1.2 ) follows from ( i.10 ) with assumption ( 14 ) .",
    "the proof of ( g-1.2 ) and ( g-1.2 ) implies the goal ( g-1.2 ) .",
    "@xmath53    hence , the goal ( g-1.2 ) follows from the proofs of ( g-1.2.1 ) and ( g-1.2.2 ) .",
    "the premise eqmode(s , `` compromised '' ) of ( i.9 ) shows that the program execution state s has been compromised.@xmath53      the proof of completeness is very similar to what we have already presented above for the soundness .",
    "however , the proof differs only for the goal ( g-1.2 ) whose proof is presented in the previous subsection .    in the following",
    ", first we formulate the completeness theorem :    [ completeness ] the result of the security monitor is complete for a given execution of the target system and its specification , iff , the specification is consistent with the program and the program executes in a safe pre - state and in an environment that is consistent with the environment of the specification , then    * for the pre - state of the program , there is an equivalent safe pre - state for which the specification can be executed and the monitor can be observed and * if we execute the specification in an equivalent safe pre - state and observe the monitor at any arbitrary ( combined ) post - state , then * * either the program execution ( post - state ) is semantically consistent with the specification execution ( post - state ) , then there is no alarm and the program execution is safe * * or the program execution ( post - state ) and the specification execution ( post - state ) are semantically inconsistent , then there is an alarm and the program execution has been compromised .    formally , completeness theorem has the following signatures and definition .",
    "completeness_ad @xmath40 @xmath11(appimpl @xmath9 appspec @xmath9 bool ) + completeness_ad(@xmath41 , @xmath0 , b ) @xmath16 + @xmath17 @xmath42 @xmath12 environment@xmath42 , e@xmath43 , e@xmath43 @xmath12 environment@xmath43 , s , s @xmath12 state@xmath43 : + consistent(e@xmath42 , e@xmath43 ) @xmath21 consistent(@xmath41 , @xmath0 ) @xmath21 + @xmath41(e@xmath43)(e@xmath43 , s , s ) @xmath21 eqmode(s , `` normal '' ) + @xmath23 + @xmath44 t , t @xmath12 state@xmath42 , e@xmath42 @xmath12 environment@xmath42 : + equals(s , t ) @xmath21 @xmath0(e@xmath42)(e@xmath42 , t , t ) @xmath21 + monitor(@xmath41 , @xmath0)(e@xmath43;e@xmath42)(s;t , s;t ) @xmath21 + @xmath17 t , t @xmath12 state@xmath42 , e@xmath42",
    "@xmath12 environment@xmath42 : + equals(s , t ) @xmath21 @xmath0(e@xmath42)(e@xmath42 , t , t ) @xmath21 + monitor(@xmath41 , @xmath0)(e@xmath43;e@xmath42)(s;t , s;t ) + @xmath23 = + if quals(s , t ) then + b = ` true ` @xmath21 b = eqmode(s , `` normal '' ) + else b = ` false ` @xmath21 b = eqmode(s , `` normal '' ) ( g )    in detail , the completeness statement says that , if    1 .",
    "a specification environment ( e@xmath42 ) is _ consistent _ with a run - time environment ( e@xmath43 ) and 2 .",
    "a target system ( @xmath41 ) is _ consistent _ with its specification ( @xmath0 ) and 3 .   in a given run - time environment ( e@xmath43 ) , execution of the system ( @xmath41 ) transforms pre - state ( s ) into a post - state ( s ) and 4 .",
    "the pre - state ( s ) is safe , i.e. the state is in `` normal '' mode ,    then    * there is such pre- and post - states ( t and t respectively ) and environment ( e@xmath42 ) of specification execution such that in a given specification environment ( e@xmath42 ) , execution of the specification ( @xmath0 ) transforms pre - state ( t ) into a post - state ( t ) and * the pre - states s and t are _ equal _ and _ _ monitor__ing of the system ( @xmath41 ) transforms combined pre - state ( s;t ) into a combined post - state ( s;t ) and if * in a given specification environment ( e@xmath42 ) , execution of the specification ( @xmath0 ) transforms pre - state ( t ) into a post - state ( t ) and * the pre - states s and t are _ equal _ and _ _ monitor__ing of the system ( @xmath41 ) transforms pre - state ( s ) into a post - state ( s ) , then * * either the resulting two post - states s and t are semantically _ equal _ and there is no alarm * * or the resulting two post - states s and t are semantically not _ equal _ and then the security monitor alarms .    in the following ,",
    "we discuss proof of the completeness statement .",
    "we can re - write ( g ) as    soundness_ad(@xmath41 , @xmath6 , b ) @xmath16 + @xmath17 @xmath42 @xmath12 environment@xmath42 , e@xmath43 , e@xmath43 @xmath12 environment@xmath43 , s , s @xmath12 state@xmath43 : + consistent(e@xmath42 , e@xmath43 ) @xmath21 consistent(@xmath41 , @xmath6 ) @xmath21 + @xmath41(e@xmath43)(e@xmath43 , s , s ) @xmath21 eqmode(s , `` normal '' ) + @xmath23 + @xmath44 t , t @xmath12 state@xmath42 , e@xmath42 @xmath12 environment@xmath42 : + equals(s , t ) @xmath21 @xmath6(e@xmath42)(e@xmath42 , t , t ) @xmath21 monitor(@xmath41 , @xmath6)(e@xmath43;e@xmath42)(s;t , s;t ) @xmath21 + @xmath17 t , t @xmath12 state@xmath42 , e@xmath42 @xmath12 environment@xmath42 : + equals(s , t ) @xmath21 @xmath6(e@xmath42)(e@xmath42 , t , t ) @xmath21 monitor(@xmath41 , @xmath6)(e@xmath43;e@xmath42)(s;t , s;t ) + @xmath23 = + if quals(s , t ) then b = ` true ` @xmath21 b = eqmode(s , `` normal '' ) + else b = ` false ` @xmath21 b = eqmode(s , `` normal '' ) ( f.1 )    from ( f.1 ) , we know    * consistent(e@xmath42 , e@xmath43 ) ( 1 ) * consistent(@xmath41 , @xmath6 ) ( 2 ) * @xmath41(e@xmath43)(e@xmath43 , s , s ) ( 3 ) * eqmode(s , `` normal '' ) ( 4 )    we show    * @xmath44 t , t @xmath12 state@xmath42 , e@xmath42 @xmath12 environment@xmath42 : equals(s , t ) @xmath21 + @xmath6(e@xmath42)(e@xmath42 , t , t ) @xmath21 monitor(@xmath41 , @xmath6)(e@xmath43;e@xmath42)(s;t , s;t ) ( g-1.1 ) * @xmath17 t , t",
    "@xmath12 state@xmath42 , e@xmath42 @xmath12 environment@xmath42 : equals(s , t ) @xmath21 + @xmath6(e@xmath42)(e@xmath42 , t , t ) @xmath21 monitor(@xmath41 , @xmath6)(e@xmath43;e@xmath42)(s;t , s;t ) + @xmath23 = + if quals(s , t ) then b = ` true`@xmath21b = eqmode(s , `` normal '' ) + else b = ` false ` @xmath21 b = eqmode(s , `` normal '' ) ( g-1.2 )      the proof is similar to as for the soundness goal ( g.1.1 ) as discussed in the subsection .",
    "@xmath53      we know    * equals(s , t ) ( 5 ) * @xmath6(e@xmath42)(e@xmath42 , t , t ) ( 6 ) * monitor(@xmath41 , @xmath6)(e@xmath43)(e@xmath43 , s , s ) ( 7 )    we show    if quals(s , t ) then b = ` true ` @xmath21 b = eqmode(s , `` normal '' ) + else b = ` false ` @xmath21 b = eqmode(s , `` normal '' ) ( g-1.2 )    we have two cases here    [ [ section-2 ] ]    we know    equals(s , t ) ( 8 )    we show    b = ` true ` @xmath21 b = eqmode(s , `` normal '' ) ( g-1.2  )    to prove the goal , it suffices to show    eqmode(s , `` normal ) = ` true ` ( g-1.2''.1 )    we instantiate lemma ( 8) with s as s and t as t and get    equals(s , t ) @xmath23 eqmode(s , `` normal '' ) ( i.1 )    the goal ( g.1.2``.1 ) follows from ( i.1 ) with assumption ( 8 ) . hence the goal ( g.1.2 '' ) is proved .",
    "furthermore , the goal shows that there is no alarm when the two post - states ( s and t ) are equivalent and are not compromised .",
    "[ [ section-3 ] ]    we know    @xmath46 eqmode(s , `` normal '' ) ( 9 )    we show    b = ` false ` @xmath21 b = eqmode(s , `` normal '' ) ( g-1.2  )    to prove the goal , it suffices to show    eqmode(s , `` normal ) = ` false ` ( g-1.2''.1 )    we instantiate lemma ( 9 ) with s as s and t as t and get    @xmath46 equals(s , t ) @xmath23 @xmath46 eqmode(s , `` normal '' ) ( i.3 )    the goal ( g.1.2``.1 ) follows from ( i.3 ) with assumption ( 9 ) . hence the goal ( g.1.2 '' ) is proved .",
    "@xmath53    furthermore",
    ", we instantiate lemma ( 7 ) with s as s to get    @xmath46 eqmode(s , `` normal '' ) @xmath23 eqmode(s , `` compromised '' ) ( i.4 )    from ( i.4 ) with the proved goal ( g.1.2 \" ) we get    eqmode(s , `` compromised '' )    that shows that the alarm is generated when the post - states ( s and t ) are semantically not equal . furthermore , from the assumption ( 2 ) if follows that indeed the program execution ( post - state ) is compromised .      in this section ,",
    "we declare respectively define auxiliary functions and predicates that are used in the proof of soundness and completeness above .    *",
    "* constructs : state@xmath43 * * @xmath9 appspec * * @xmath10 state@xmath42 * + constructs(s , @xmath0 ) = t , + s.t .",
    "t = build(@xmath0 ) @xmath21 eqmode(s , `` normal '' ) @xmath21 abstract(s , t ) * * constructs : environment@xmath43 * * @xmath9 appspec * * @xmath10 environment@xmath42 * + constructs(e , @xmath0 ) = e , s.t .",
    "e = build(@xmath0 ) @xmath21 abstract(e , e ) * * _ ; _ : state@xmath43 @xmath9 state@xmath42 @xmath10 state * + s;t = state(\\{@xmath55i : v@xmath56 @xmath12 store(s ) : @xmath57 @xmath55i : v@xmath56 @xmath12 store(t ) } @xmath58 + \\{@xmath55i : v@xmath56 @xmath12 store(t ) : @xmath57 @xmath55i : v@xmath56 @xmath12 store(s ) } @xmath58 + \\{@xmath55i : v@xmath56 : = @xmath44 v  : @xmath55i : v@xmath56 @xmath12 store(s ) @xmath21 @xmath55i : v@xmath56 @xmath12 store(t ) @xmath21 + v ",
    "= super(v , v ) } , flag(s ) ) * * _ ; _ : environment@xmath43 @xmath9 environment@xmath42 @xmath10 environment * + e;e = nvironment(\\{@xmath55i : v@xmath56 @xmath12 context(e ) : + @xmath57 @xmath55i : v@xmath56 @xmath12 context(e ) } @xmath58 + \\{@xmath55i : v@xmath56 @xmath12 context(e ) : @xmath57 @xmath55i : v@xmath56 @xmath12 context(e ) } @xmath58 + \\{@xmath55i : v@xmath56 : = @xmath44 v  : @xmath55i : v@xmath56 @xmath12 context(e ) @xmath21 + @xmath55i : v@xmath56 @xmath12 context(e ) @xmath21 v  = super(v ,",
    "v ) } + , space(e ) ) * * super : value@xmath43 @xmath9 value@xmath42 @xmath10 value * + super(v , v ) = = v , if v@xmath40 v + v , if v@xmath40 v * * super : envval@xmath43 @xmath9 envval@xmath42 @xmath10 envval * + super(v , v ) = = v , if v@xmath40 v + v , if v@xmath40 v * * equals @xmath40 @xmath59state@xmath43 @xmath9 state@xmath42 ) * + equals(s , t ) @xmath16 + @xmath17 c : component@xmath42 , @xmath0:appspec , @xmath41 : appimpl : + c @xmath12 @xmath0 @xmath21 c @xmath12 @xmath41 @xmath21 c(e@xmath43)(s , s , e@xmath43 ) + @xmath23 = c(e@xmath42)(t , t , e@xmath42 ) @xmath21 + @xmath17 i d : identifier@xmath42 , v : value@xmath42 : @xmath55id , v@xmath56 @xmath12 store(t ) + @xmath23 @xmath55id , v@xmath56 @xmath12 store(s ) @xmath21 abstract(v , v ) * * consistent @xmath40 @xmath11(environment@xmath43 @xmath9 environment@xmath42 ) * + consistent(e@xmath43 , e@xmath42 ) @xmath16 + @xmath17 d : identifier , v : value@xmath42 , v : value@xmath43 : + @xmath55id , v@xmath56 @xmath12 context(e@xmath42 ) @xmath23 @xmath55id , v@xmath56 @xmath12 context(e@xmath43 ) @xmath21 abstract(v , v ) * * consistent @xmath40 @xmath11(appimpl",
    "@xmath9 appspec ) * + consistent(=@xmath41 , @xmath0 ) @xmath16 the safe execution of `` @xmath41 '' meets `` @xmath0 '' and `` @xmath0 '' + always executes in a safe state , that can be formulated as follows : + @xmath17 s , s @xmath12 state , e , e @xmath12 environment : + @xmath41(e)(e , s , s ) @xmath21 eqmode(s , `` normal '' ) @xmath23 @xmath0(e)(e , s , s ) @xmath21 + @xmath17 t , t @xmath12 state@xmath42 , d , d @xmath12 environment@xmath42 : + @xmath0(d)(d , t , t ) @xmath21 eqmode(t , `` normal '' ) @xmath23 eqmode(t , `` normal '' ) + semantically , the predicate `` consistent '' returns ` true ` iff only such pair of states ( s and s ) are related by `` @xmath41 '' which is also related by `` @xmath0 '' . here",
    "the states and environment are combined of two corresponding abstractions of specification and implementation respectively .",
    "furthermore , execution of `` @xmath0 '' in a safe pre - state always yields a safe post - state . * * abstract @xmath40 @xmath11(state@xmath43 @xmath9 state@xmath42 ) * + abstract(s , t ) @xmath16 + @xmath17  : identifier , v : value@xmath42 : + @xmath55i , v@xmath56 @xmath12 store(t ) @xmath23 @xmath44 v:value@xmath43:= @xmath55i , v@xmath56 @xmath12 store(s ) @xmath21 + abstract(v , v ) * * abstract @xmath40 @xmath11(value@xmath43 @xmath9 value@xmath42 ) * + abstract(v , v ) @xmath16 + @xmath17 = @xmath60 , @xmath60:type , s : state@xmath43 , t : state@xmath42 : + equals(s , t ) @xmath21 v(s , @xmath60 ) @xmath21 v(t , @xmath60 ) @xmath23 @xmath60@xmath40 @xmath60 * * abstract @xmath40 @xmath11(envval@xmath43 @xmath9 envval@xmath42 ) * + abstract(v , v ) @xmath16 + @xmath17 = @xmath60 , @xmath60:type , e : environment@xmath42 , e:environment@xmath43 : + consistent(e , e ) @xmath21 v(e , @xmath60 ) @xmath21 v(e , @xmath60 ) @xmath23 @xmath60@xmath40 @xmath60      in this section , we give definitions and corresponding proof hints of lemmas that were used in the proofs above .    @xmath17 s @xmath12 state@xmath43 , t @xmath12 state@xmath42 : t = constructs(s ) @xmath23 equals(s , t )    @xmath17 s , s @xmath12 state@xmath43 , t , t @xmath12 state@xmath42 , + @xmath41 @xmath12 appimpl , @xmath0 @xmath12 appspec , + e@xmath43 , e@xmath43 @xmath12 environment@xmath43 , e@xmath42 , e@xmath42 @xmath12 environment@xmath42 : + @xmath41(e@xmath43)(e@xmath43 , s , s ) @xmath21 @xmath0(e@xmath42)(e@xmath42 , t , t ) + @xmath21 quals(s , t ) @xmath21 eqmode(s , `` compromised '' ) + @xmath23 t @xmath54 constructs(s )    * _ proof hints _ * in principle , from a compromised program state , an equivalent specification safe state can not be constructed because the program state may have inconsistent values for certain variables or new variables etc .",
    "@xmath17 s @xmath12 state@xmath43 , t @xmath12 state@xmath42 : t @xmath54 constructs(s ) @xmath23 @xmath46 equals(s , t )    @xmath17 s , s @xmath12 state , t , t @xmath12 state@xmath42 , + e@xmath43 , e@xmath43 @xmath12 environment@xmath43 , e@xmath42 , e@xmath42 @xmath12 environment@xmath42 , + @xmath41 @xmath12 appimpl : + @xmath41(e@xmath43;e@xmath42)(e@xmath43;e@xmath42 , s;t , s;t ) @xmath16 @xmath41(e@xmath43)(e@xmath43 , s , s )    * _ proof hints _ * the goal follows from the semantics of _ @xmath41_.    @xmath17 s , s @xmath12 state , t , t @xmath12 state@xmath42 , + e@xmath43 , e@xmath43 @xmath12 environment@xmath43 , e@xmath42 , e@xmath42",
    "@xmath12 environment@xmath42 , + @xmath0 @xmath12 appspec : + @xmath0(e@xmath43;e@xmath42)(e@xmath43;e@xmath42 , s;t , s;t ) @xmath16 @xmath0(e@xmath42)(e@xmath42 , t , t )    @xmath17 s @xmath12 state , t @xmath12 state@xmath42 : + eqmode(s;t , `` normal '' ) @xmath16 eqmode(s , `` normal '' )    @xmath17 s @xmath12 state@xmath43 : + @xmath46 eqmode(s , `` normal '' ) @xmath16 eqmode(s , `` compromised '' )    @xmath17 s @xmath12 state@xmath43 , t @xmath12 state@xmath42 : equals(s , t ) @xmath23 eqmode(s , `` normal '' )    * _ proof hint _ * the definition of _ equals _ enables to show the goal . also because of the fact , that two states are only equal if they can be constructed in a safe mode .",
    "@xmath17 s @xmath12 state@xmath43 , t @xmath12 state@xmath42 : + @xmath46 equals(s , t ) @xmath23 @xmath46 eqmode(s , `` normal '' )",
    "we have presented a sound and complete run - time security monitor for application software , which avoids false alarms ( positive or negative ) .",
    "the monitor implements run - time software verification , comparing an executable application specification with the execution of its implementation at run - time .",
    "our main contribution , the proof of soundness and completeness , establishes an _ assume / guarantee_-based contract between the _ security monitor _ and its user , i.e. the designer of the application to be monitored . specifically , if the user establishes the _ assumptions _ of the proof , then the monitor _ guarantees _ to detect all deviations of the execution s behaviour relatively to the behaviour defined in the application specification and will never produce any false alarm at run - time .",
    "importantly , the proof strategy can be a fundamental building block for :    1 .",
    "any proof that shows that an abstract description / specification ( non - determinism ) of a program is consistent with its concrete description / implementation ( determinism / instance ) , 2 .",
    "transformation rules to automatically generate sound and complete monitors ( for program execution ) from specification and 3 .   developing proof tactics to prove such tedious goals semi - automatically , significantly reducing human effort .",
    "our future work includes the mechanisation of this proof in a proof assistant , specifically coq , targeting the development of a generic library based on our proof strategy so that the proof can be applied to any given specification and implementation ."
  ],
  "abstract_text": [
    "<S> conventional approaches for ensuring the security of application software at run - time , through monitoring , either produce ( high rates of ) false alarms ( e.g. intrusion detection systems ) or limit application performance ( e.g. run - time verification ) . </S>",
    "<S> we present a run - time security monitor that detects both known and unknown cyber attacks by checking that the run - time behavior of the application is consistent with the expected behavior modeled in application specification . </S>",
    "<S> this is crucial because , even if the implementation is consistent with its specification , the application may still be vulnerable due to flaws in the supporting infrastructure ( e.g. the language run - time system , supporting libraries and the operating system ) . </S>",
    "<S> this run - time security monitor is sound and complete , eliminating false alarms , as well as efficient , so that it does not limit run - time application performance and so that it supports real - time systems . </S>",
    "<S> importantly , this monitor is readily applicable to both legacy and new system platforms .    </S>",
    "<S> the security monitor takes as input the application specification and the application implementation , which may be expressed in different languages . </S>",
    "<S> the specification language of the application software is formalized based on monadic second order logic ( i.e. first order logic and set theory ) and event calculus interpreted over algebraic data structures . </S>",
    "<S> this language allows us to express behavior of an application at any desired ( and practical ) level of abstraction as well as with high degree of modularity . </S>",
    "<S> the security monitor detects every attack by systematically comparing the application execution and specification behaviors at runtime , even though they operate at two different levels of abstraction . </S>",
    "<S> we define the denotational semantics of the specification language and prove that the monitor is sound and complete , i.e. if the application is consistent with its specification , the security monitor will produce no false alarms ( soundness ) and that it will detect any deviation of the application from the behavior sanctioned by the specification language ( completeness ) . furthermore , the monitor is efficient because of the modular application specification at appropriate level(s ) of abstraction . </S>",
    "<S> importantly , the application specification language enables the description of known or potential attack plans , enabling not only attack detection but attack characterization as well and , thus , facilitating effective and efficient defenses to sophisticated attacks . </S>"
  ]
}