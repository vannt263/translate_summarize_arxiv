{
  "article_text": [
    "in their famous paper @xcite einstein , podolsky and rosen ( epr ) suggested a gedankenexperiment which , as they believed , must prove the incompleteness of quantum mechanics .",
    "an interesting analysis of this problem was given by bohr @xcite .",
    "some progress was achieved by bell @xcite .",
    "he showed that under assumption of the epr arguments some inequalities must be fulfilled .",
    "if bohr s arguments are correct then these inequalities can be violated .",
    "it was only in @xmath0 when the bohr s arguments were experimentally verified @xcite .",
    "now the arguments by epr are considered to be incorrect , but nevertheless it is the work @xcite that initiated the discussion of basics of quantum mechanics .    in this work",
    "i analyze the connection between the boolean functions theory and bell inequalities for multi - qubit systems ( which were obtained in @xcite ) .",
    "surprisingly enough , in many aspects bell inequalities theory is analogous to the combinatorial problems of computer logic circuits design developed a year earlier then the bell s work @xcite appeared .",
    "there is also a relation between bell inequalities and applications of boolean functions theory to classical cryptography .",
    "for example , classification of bell inequalities discussed in @xcite is closely connected to the jevons group , studied in @xcite , and the maximal quantum violation of a given bell inequality is connected to the nonlinearity of the corresponding boolean function .",
    "i made an attempt to clarify these connections .",
    "but there are still many open questions , both combinatorial ( like classification of bell inequalities with respect to the group @xmath1 ) and analytical ( like calculation of the maximal quantum violation @xmath2 ) .",
    "another interesting problem is the connection between the maximal quantum violation and the uncertainty relation for boolean functions . in this work",
    "it is shown that the bell inequalities whose maximal quantum violation is the largest ( mermin inequalities ) , minimize this uncertainty relation .",
    "all mathematical constructions discussed in the text are illustrated with _",
    "mathematica_. i choose _ mathematica_since it has an extremely flexible and unified programming language and a very rich set of built - in mathematical functions . due to this",
    "it is possible to present the algorithms illustrating the discussed quantities in a very compact form . using _",
    ", it is possible to code all the illustrating examples using high - level constructions , avoiding worrying about low - level programming details which have nothing to do with the problem under study .",
    "i do not pretend to give the most effective _",
    "mathematica_code for calculating different features of boolean functions , my goal is to present a compact and ready - to - use working code .",
    "all the examples can be typed in and run provided that they are entered to _",
    "mathematica_in the given order .",
    "i also presented the _ c _ source code for the fast walsh - hadamard transform and a way to turn it into an executable program which can be used in _",
    "the bell inequalities for a multi - qubit system , which were obtained in @xcite , are closely connected with boolean functions theory .",
    "there is a natural one - to - one correspondence between the set of all @xmath3 boolean functions of @xmath4 boolean variables and the set of bell inequalities for @xmath4-qubits . in this section",
    "i give a short overview of the notions and results of the boolean functions theory which are needed for applications to bell inequalities .",
    "the most important notion discussed in this section is the walsh - hadamar transform , which turns out to be the coefficients of the bell inequality corresponding to a given boolean function .    here",
    "i also introduce a visualization technique of boolean functions which is useful to graphically represent different classes of boolean functions .",
    "this approach is based on the fact that for all @xmath4 the number of boolean functions of @xmath4 variables is a square ( in fact , @xmath5 ) , so that one can associate the boolean functions with the cells of a @xmath6 array . briefly speaking ,",
    "this is done numerating boolean functions with integers , interpreting the vectors of their values as binary decompositions and then using division modulo @xmath7 . in this section",
    "i visualize boolean functions with respect to their degree and uncertainty . in both cases",
    "the pictures show some kind of fractal behavior .",
    "let @xmath8 be the finite field with two elements @xmath9 . the sum and the product of elements @xmath10 are denoted as @xmath11 and @xmath12 respectively .",
    "the product of @xmath4 copies of @xmath13 we denote as @xmath14 and refer to its elements as ( @xmath4-dimensional ) boolean vectors .",
    "it is clear that @xmath15 .",
    "the notation @xmath16 is used for the scalar product of two boolean vectors @xmath17 and @xmath18 : @xmath19    there is a natural one - to - one correspondence @xmath20 between the set @xmath21 and the set @xmath22 : @xmath23 in other words , the boolean vector @xmath24 corresponds to the integer @xmath25 whose binary representation is given by @xmath24 .",
    "the most significant bit in the binary decomposition of @xmath25 is the first component of @xmath24 and the least significant bit is the last component .",
    "the correspondence @xmath20 is natural in the following sense . for an integer",
    "@xmath26 the set @xmath27 can be identified with a subset of @xmath21 by padding @xmath28-dimensional boolean vectors on the left to extend them to @xmath4 dimensions .",
    "then the diagram @xmath29 is commutative .",
    "this means that one can apply @xmath20 to @xmath28-dimensional boolean vectors with @xmath26 .",
    "the correspondence @xmath20 is illustrated by table [ tbl : b ] .",
    ".the correspondence @xmath20 between boolean vectors @xmath30 and integer numbers @xmath31 . [ cols=\"^,^,^,^,^\",options=\"header \" , ]     the cross - product is defined as follows . for powers of variables",
    "we have @xmath32 where @xmath33 and @xmath34 are the greatest common divisor and the least common multiple of integers @xmath35 and @xmath36 respectively . for two monomials",
    "the cross - product is defined via @xmath37 and then extended for arbitrary polynomials by bilinearity .",
    "for example , let us calculate the cross - product @xmath38 : @xmath39 the cycle index @xmath40 for small @xmath4 is shown in the second column of the table [ tbl:1 ] .",
    "now let us add an action on the set @xmath41 .",
    "let @xmath42 be the cyclic group of the second order .",
    "the action @xmath43 we define as : @xmath44 and @xmath45 being the logical _ not _ , @xmath46 and @xmath47 . for cycle lengthes",
    "we have @xmath48 according to for the number of equivalence classes we have the following expression ( see also @xcite ) : @xmath49 these numbers are shown in the third column of the table [ tbl:1 ] .",
    "the last column of the table shows the number @xmath50 of equivalence classes with respect to the equivalence under study . the number @xmath51 was taken from _",
    "larsed / boolean/_. the numbers @xmath50 for @xmath52 are unknown .",
    "in conclusion , the relation between the boolean functions theory and the general bell inequalities for @xmath4-qubits is established .",
    "the classification of bell inequalities with respect to the jevons group is obtained , which is a weaker result then the problem posed in @xcite .",
    "nevertheless , to my knowledge it is the only approach to the more general classification .",
    "this approach is based on the works @xcite done for computer logic circuits theory , which shows the connection between quite different problems  qubit system description and computer logic circuit design .",
    "there are still many unsolved problems .",
    "two the most important ones are :    1 .",
    "classification of bell inequalities ( or boolean functions ) with respect to the group @xmath1 , 2 .",
    "characterization of the maximal quantum violation @xmath2 of a given boolean function @xmath53 in terms of properties of @xmath53 , in particular , finding the relation between @xmath2 and the nonlinearity @xmath54 .    and , of course , a very interesting question  how the ideas from different applications of the boolean functions theory ( not only to cryptography or computer logic circuits design ) can be used in quantum information theory .",
    "in this appendix i present the _ mathematica_code figs . [",
    "fig : o ] , [ fig : u ] , [ fig : v ] , [ fig : bell ] and table [ tbl:1 ] were obtained with .",
    "first of all , the set @xmath21 can be coded as @xmath55:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{v[n\\ _ ] : = tuples[\\{0 , 1\\ } , n]}\\ ] ] the _",
    "mathematica_function @xmath56}$ ] gives the list of the base-@xmath57 digits of @xmath4 , padding it on the left if necessary to give a list of length @xmath58 . using this function",
    ", one can code @xmath21 in another way as @xmath59 : = integerdigits[\\ # , 2 , n]\\ & /@",
    "range[0 , 2^n-1 ] } \\nonumber\\ ] ] this code works a few times more slowly , but this approach can be useful if it necessary to construct only some part of @xmath21 , not the whole set @xmath21 . we know that @xmath60 , but since @xmath61 , the simple definition @xmath62 : = \\ v[2^n]}$ ] will not work for @xmath63 .",
    "a general boolean function can be coded as follows :    @xmath64:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{f[c\\ _ , s\\ _ ] : =      function[x , mod[c.(apply[times , \\#]\\ & /@\\",
    "( part[x , \\#]\\ & /@\\",
    "s ) ) , 2]]}\\ ] ]    where @xmath65 is the list of all the multi - indices @xmath66 for which the coefficients @xmath67 and @xmath68 the list of these coefficients . note that the @xmath69-es of @xmath68 and @xmath65 must be the same . for example , the expression @xmath70 , \\{m\\}]]}\\ ] ] gives a homogeneous polynomial of the degree @xmath28 ( except the case when all elements of @xmath68 are zero ; when all elements of the list @xmath68 are @xmath71 then is the @xmath28-th symmetric polynomial :    @xmath72\\ } ] , subsets[range[n ] , \\{m\\}]][\\{x_1 , \\ldots , x_n\\ } ] =      s_m(x_1 , \\ldots , x_n)}\\ ] ]    similarly , the expression @xmath73 , m]]}\\ ] ] is a polynomial of the degree not greater then @xmath28 .",
    "the walsch - hadamard transform can be coded as    @xmath64:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{wht : = \\ function[u , plus\\ @@\\",
    "( function[x , ( -1)^{\\#[x]+(x.u ) } ] /@\\",
    "v[length[u]])]\\&}\\ ] ]    this method of calculation the walsch - hadamard transform is very simple and quite ineffective . in appendix",
    "b a much better method is presented .",
    "the only disadvantage of that method is the fact that it works much faster only when it is necessary to calculate all the numbers @xmath74 , @xmath75 simultaneously , and it can not be applied to calculate only one number @xmath74 for a given @xmath76 .",
    "@xmath77 is a functional : @xmath78}$ ] is a function and @xmath78[\\{u_1 , \\ldots , u_n\\}]}$ ] is its value @xmath74 at @xmath79 .",
    "the inverse walsch - hadamard transform can be coded as    @xmath64:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{whit : = \\ function[x , ( 1 - 2^{-length[x ] }      plus\\ @@\\",
    "( function[u , ( -1)^{x.u}\\ \\#[u ] ] /@\\",
    "v[length[x]]))/2 ] \\&}\\ ] ]    like @xmath77 , it is also a functional .",
    "the autocorrelation of two boolean functions can be coded as    @xmath64:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{\\delta : = \\ function[u , plus\\ @@\\      ( function[x , ( -1)^{\\#1[x ] + \\#2[mod[\\ # , 2]\\ & /@\\ ( x+u ) ] } ] /@\\",
    "v[length[u ] ] ) ] \\&}\\ ] ]    it is a functional of two arguments : the expression @xmath80[\\{u_1 , \\ldots , u_n\\}]}$ ] is the value @xmath81 at @xmath79 .    the uncertainty can be coded as    @xmath64:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{u[n\\ _ ] : = \\ function[f , 2^{-n } count[wht[f ] /@\\",
    "v[n ] , \\_?(\\ # ! = 0 \\ & ) ]      count[\\delta[f , f ] /@\\ v[n ] , \\_?(\\ # ! = 0 \\&)]]}\\ ] ]    for a function @xmath82 the expression @xmath83[f]}$ ] gives the uncertainty @xmath84 of @xmath53 .",
    "to calculate @xmath84 for all @xmath82 we need a way to define @xmath53 given its number @xmath85 , @xmath86 .",
    "the following code solves this problem :    @xmath64:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{itof[n\\ _ , b\\ _ ] : = \\ part[integerdigits[b,2 , 2^n ] , 2^n - fromdigits[\\ # , 2 ] ] \\&}\\ ] ]    given @xmath87 , the expression @xmath88}$ ] is the corresponding boolean function , to which one can apply the syntaxis @xmath88[\\{x_1 , \\ldots , x_n\\}]}$ ] .",
    "we can visualize boolean functions with respect to their uncertainty using the code    @xmath64:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{ut[n\\ _ ] : = \\ partition[table[u[n][itof[n , b ] ] , \\{b , 0 , 2^{2^n}-1\\ } ] , 2^{2^{n-1}}]}\\ ] ]    in _",
    "mathematica_this table can be immediately plotted with the @xmath89 function , what was doe for the case of @xmath90 , for the other two cases i used a simple script to generate _ pstricks _ code from this table and then compiled it with latex(_pstricks _ code produced huge pictures in the case of @xmath90 ) . in this way fig .",
    "[ fig : u ] was obtained . the code @xmath91 //flatten //sort //split",
    "//length}\\ ] ] gives the number of different values of the uncertainty .",
    "for @xmath92 it is @xmath71 ( all @xmath93 boolean functions have the same uncertainty @xmath71 ) , for @xmath94 it is @xmath95 ( the values are @xmath71 and @xmath96 ) and for @xmath90 it is @xmath97 ( the values are @xmath71 , @xmath98 , @xmath96 and @xmath93 ) .",
    "unfortunately , these are all the values of @xmath4 for which this simple code works , for larger @xmath4 another technique is needed .",
    "now i will show how the fig .  [",
    "fig : o ] was obtained .",
    "the key point is the function    @xmath99:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{d[n\\ _ , m\\ _ ] : = } \\ & \\mathtt{function[c , fromdigits[f[c , subsets[range[n ] , m ] ] /@\\",
    "v[n ] , 2 ] ] } \\\\      & \\mathtt{/@\\ v[plus\\ @@\\ ( binomial[n , \\ # ] \\ & /@\\ range[0 , m ] ) ] } \\end{split}\\ ] ]    which returns the numbers @xmath85 of the boolean functions @xmath82 of degree @xmath100 . to visualize boolean functions with respect to their degree",
    "let us create a list @xmath101};$ ]",
    ". then we can fill it in as @xmath102 + 1 ] ] = n - i]}\\ ] ] the table @xmath103}$ ] gives the desired visualization .",
    "now let us discuss the equivalence of bell inequalities .",
    "the map @xmath104 can be coded as    @xmath64:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{p[pi\\_]:=\\ function[x , \\#[permute[x , inversepermutation[pi]]]]\\&}\\ ] ]    the expression @xmath105}$ ] is a functional : @xmath105[f]}$ ] gives the function @xmath106 , and @xmath105[f][\\{x_1 , \\ldots , x_n\\}]}$ ] gives its value @xmath107 at @xmath108 .",
    "the maps @xmath109 , @xmath110 and @xmath111 can be coded as    @xmath99:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{\\delta : = \\ function[x , 1-\\#[x]]\\ & } \\\\      { { \\scriptstyle in[\\arabic{inpromtcount}]:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{s[y\\ _ ] : = \\ function[x , \\#[function[z , mod[z , 2 ] ] /@\\",
    "( x + y)]]\\ & } \\\\      { { \\scriptstyle in[\\arabic{inpromtcount}]:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{t[z\\ _ ] : = \\ function[x , mod[\\#[x ] + x.z , 2]]\\ & } \\end{split}\\ ] ]",
    "let us illustrate the relations between the maps under study .",
    "as an example , consider the first relation .",
    "i show that this relation is valid by applying the maps from both sides to all boolean functions @xmath82 and comparing the results .",
    "to do it , we need operations which produce the lists of values @xmath112 and @xmath113 , @xmath30 given the list @xmath114 , @xmath30 of values of @xmath82 . the code    @xmath99:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{ps[n\\ _ , pi\\ _ , y\\_]}\\ & \\mathtt{:= composition[p[pi ] , s[y]][function[x , part[\\ # , fromdigits[x,2]+1 ] ] ] /@\\",
    "v[n ] \\ & } \\\\      { { \\scriptstyle in[\\arabic{inpromtcount}]:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{sp[n\\ _ , pi\\ _ , y\\_]}\\ & \\mathtt{:= composition[s[y ] , p[pi]][function[x , part[\\ # , fromdigits[x,2]+1 ] ] ] /@\\ v[n ] \\ & } \\end{split}\\ ] ]    is a solution to this problem .",
    "the expression    @xmath64:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{ps[3 , \\{2,3,1\\ } , \\{1,1,0\\ } ] /@\\",
    "v[2 ^ 3 ] - sp[3 , \\{2,3,1\\ } , \\{1,0,1\\ } ] /@\\",
    "v[2 ^ 3 ] //short}\\ ] ]    produces a list of zero - lists , as expected .",
    "this example clearly demonstrates that the first relation is valid ( in the case of @xmath94 ) .",
    "@xmath115    given a number @xmath87 the function    @xmath99:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{e[n\\ _ , b\\_]}&\\ \\mathtt{:=\\ replace[fromdigits[map[\\ # , v[n ] ] , 2 ] \\ & } \\\\      & \\mathtt{/@\\ function[f , apply[function[\\{\\varepsilon , y , pi , z\\ } , composition[\\varepsilon , t[z ] , p[pi ] , s[y ] ] } \\\\      & \\mathtt{[function[x , part[integerdigits[f , 2 , 2^n ] , fromdigits[x , 2 ] + 1 ] ] ] ] , \\#]\\ & } \\\\      & \\mathtt{/@\\ tuples[\\{\\{identity , \\delta\\ } , v[n ] , permutations[range[n ] ] , v[n]\\}]][b ] } \\\\      & \\mathtt{//sort //split , \\{(i\\ _ ) .. \\ } \\to i , 1 ] }   \\end{split}\\ ] ]    produces the list of numbers which correspond to the functions , equivalent to the one corresponding to @xmath116 . with this functions it is easy to get the equivalence classes .",
    "let us illustrate the general idea by the case of @xmath94 .",
    "we start with @xmath117 : @xmath118 //short}$ ] produces @xmath119 it is the first class of equivalence ( which contains @xmath93 elements ) .",
    "the smallest number which is not in this class is @xmath71 ; @xmath120 //short}$ ] produces @xmath121 it is the second class of equivalence ( which contains @xmath122 elements ) .",
    "the smallest number which is not in either class found so far is @xmath123 ; @xmath124 //short}$ ] produces @xmath125 it is the third class of equivalence ( which contains @xmath126 elements ) .",
    "the ext number to try is @xmath127 : @xmath128 //short}$ ] produces @xmath129 it is the fourth class of equivalence ( which also contains @xmath126 elements ) .",
    "the next number is @xmath130 ; @xmath131 //short}$ ] produces @xmath132 it is the fifth class of equivalence ( which contains @xmath93 elements ) . since @xmath133 ,",
    "we exhausted all numbers ( boolean functions ) which means that in the case of @xmath94 there are @xmath134 classes of equivalence , they are shown in fig .",
    "[ sfig : bell - b ] .",
    "the same approach allows one to get fig .",
    "[ sfig : bell - b2 ] .",
    "the maximal quantum violations can be found as follows .",
    "let us introduce the functions @xmath99:=",
    "\\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{s[\\varphi\\_]\\ : = \\ \\{cos[\\varphi ] , i\\ sin[\\varphi]\\ } } \\\\",
    "{ { \\scriptstyle in[\\arabic{inpromtcount}]:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{s[\\varphi\\_list]\\ : = \\ apply[times , \\#]\\ & } \\\\      &",
    "\\mathtt{/@\\ tuples[s /@\\ \\varphi ] } \\end{split}\\ ] ] the maximal violation can now be coded as @xmath99:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{v[f\\ _ , \\varphi\\_]\\ : = \\ abs[((-1)^{f[\\#]}\\ & } \\\\      & \\mathtt{/@\\ v[length[\\varphi]]).s[\\varphi ] ] } \\\\      { { \\scriptstyle in[\\arabic{inpromtcount}]:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{v2[b\\ _ , \\varphi\\_]\\ : = \\ v[itof[length[\\varphi ] , b ] , \\varphi ] } \\end{split}\\ ] ] the quantity @xmath135}$ ] give the maximal quantum violation @xmath2 of the function @xmath53 corresponding to the number @xmath116 .",
    "let us illustrate the calculation of maximal quantum violation for mermin inequalities .",
    "the mermin inequalities ( whose coefficients are given by and ) can be coded as ( using the standard package _ algebrasymmetricpolynomials _ ) @xmath136\\ : = \\ mod[symmetricpolynomial[x , 2 ] , 2]}\\ ] ] the maximal quantum violation of mermin inequalities can be found as @xmath99:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{findmaximum[v[m , \\{\\varphi_1 , \\ldots , \\varphi_n\\ } ] , } \\\\      & \\mathtt{\\{\\varphi_1 , \\varphi^0_1\\ } , \\ldots , \\{\\varphi_n , \\varphi^0_n\\ } ] } \\end{split}\\ ] ] for example , the code @xmath137 , \\{\\varphi_1 , 1\\ } , \\{\\varphi_2 , 1\\}]}\\ ] ] produces @xmath138 the code @xmath139 , } \\\\      & \\mathtt{\\{\\varphi_1 , 1\\ } , \\{\\varphi_2 , 1\\ } , \\{\\varphi_3 , 1\\ } ] } \\end{split}\\ ] ] produces @xmath140 in full agreement with the relation . since @xmath2 is the same for equivalent functions , using the classes of equivalence calculated before , it is easy to get fig .",
    "[ fig : v ] .",
    "now i will show how the table [ tbl:1 ] was obtained . to calculate the cycle index",
    "@xmath141 we need to calculate the sum .",
    "the vectors @xmath142 for a given @xmath4 can be obtained using the standard package @xmath143 , containing the function @xmath144}$ ] , which returns the list of partitions of @xmath4 .",
    "any partition @xmath35 of this list has the following form @xmath145 with @xmath146 and @xmath147 .",
    "the relation @xmath148 gives a one - to - one correspondence between the partitions of @xmath4 and the vectors @xmath142 .",
    "here @xmath149 is on @xmath150-th place and the other components are zero .",
    "this correspondence can be realized in _",
    "@xmath99:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{ct[p\\ _ ] : = } \\ & \\mathtt{module[\\{c = table[0 , \\{plus\\ @@\\ p\\}]\\ } , } \\\\      &",
    "\\mspace{20mu } \\mathtt{set[part[c , \\#[[1 ] ] ] , length[\\#]]\\ & /@\\ split[p ] ; } \\\\      & \\mspace{20mu } \\mathtt{return[c ] } \\\\      & \\mathtt { ] } \\end{split}\\ ] ]    then we need to define the cross - product .",
    "we introduce the object @xmath151}$ ] which represents the @xmath4-th power of the @xmath35-th independent variable .",
    "the code    @xmath64:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{cp[var[p\\ _ , n\\ _ ] , var[q\\ _ , m\\_]]\\ : = \\ var[lcm[p , q ] , n\\ m\\ gcd[p , q]]}\\ ] ]    reproduces the definition . to extend the cross - product for arbitrary polynomials",
    "we need the following definitions ( the order in which they are given is important ) :",
    "@xmath99:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{cp[v\\ _ , c\\ _ ]           : = c\\ v /;\\ numericq[c ] } \\\\      { { \\scriptstyle in[\\arabic{inpromtcount}]:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{cp[c\\ _ , v\\ _ ]           : = c\\ v /;\\ numericq[c ] } \\\\",
    "{ { \\scriptstyle in[\\arabic{inpromtcount}]:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{cp[v1\\ _",
    "+ v2\\ _ , v3\\ _ ] : = cp[v1 , v3 ] + cp[v2 , v3 ] } \\\\      { { \\scriptstyle in[\\arabic{inpromtcount}]:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{cp[v3\\ _ , v1\\ _ + v2\\ _ ] : = cp[v3 , v1 ] + cp[v3 , v2 ] } \\\\      { { \\scriptstyle in[\\arabic{inpromtcount}]:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{cp[v3\\ _ , v1\\ _ v2\\ _ ]    : = cp[v3 , v1]\\ cp[v3 , v2 ] } \\\\      { { \\scriptstyle in[\\arabic{inpromtcount}]:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{cp[v1\\ _ v2\\ _ , v3\\ _ ]    : = cp[v1 , v3]\\ cp[v2 , v3 ] } \\\\      { { \\scriptstyle in[\\arabic{inpromtcount}]:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{cp[c\\ _ v1\\ _ , v2\\ _ ]     : = c\\ cp[v1 , v2 ] /;\\ numericq[c ] } \\\\",
    "{ { \\scriptstyle in[\\arabic{inpromtcount}]:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{cp[v1\\ _ , c\\ _ v2\\ _ ]     : = c\\ cp[v1 , v2 ] /;\\ numericq[c ] } \\end{split}\\ ] ]    the following code reproduces the identities @xmath152 and @xmath153 respectively :    @xmath99:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{var /:\\",
    "power[var[p\\ _ , n\\",
    "_ ] , m\\_]\\ : = \\ var[p , n\\ m ] } \\\\      { { \\scriptstyle in[\\arabic{inpromtcount}]:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{var /:\\ var[p\\ _ , n\\_]\\ var[p\\ _ , m\\_]\\ : = \\",
    "var[p , n + m ] } \\end{split}\\ ] ]    the code for the functions @xmath154 and @xmath57 is obvious :    @xmath99:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{a[k\\_]\\ : = \\ \\frac{1}{k } plus\\ @@\\",
    "moebiusmu\\left[\\frac{k}{\\#}\\right]\\ & /@\\",
    "divisors[k]\\right ) } \\\\      { { \\scriptstyle in[\\arabic{inpromtcount}]:=",
    "\\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{b[k\\_]\\ : = \\ \\frac{1}{k } plus\\ @@\\ \\left(2^{\\#/2 } moebiusmu\\left[\\frac{k}{\\#}\\right]\\ &",
    "/@\\ complement[divisors[k ] , \\",
    "divisors[k/2]]\\right ) } \\end{split}\\ ] ]    a factor of of the sum can be coded as    @xmath99:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{factor[i\\_]\\ : = } \\ & \\mathtt{times\\ @@\\ ( var[\\ # , a[\\ # ] ] \\ & /@\\",
    "divisors[i ] ) +      times\\ @@\\ ( var[\\ # , b[\\ # ] ] \\ & } \\\\      & \\mathtt{/@\\ complement[divisors[2i ] , divisors[i ] ] ) } \\end{split}\\ ] ]    a term of the sum is coded as    @xmath99:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}&\\mathtt{term[c\\_]\\ : = \\ module[\\{t\\ } , } \\\\      & \\mspace{20mu}\\mathtt{t = mapindexed[if[\\#1 = = 0 , 1 , if[\\#1 = = 1 , factor[\\#2[[1 ] ] ] , } \\\\",
    "& \\mspace{40mu}\\mathtt{fold[cp , factor[\\#2[[1 ] ] ] , table[factor[\\#2[[1]]],\\{\\#1 - 1\\}]]]]\\ & , c ] ; } \\\\      & \\mspace{20mu}\\mathtt{fold[cp , first[t ] , rest[t ] ] } \\\\      & \\mathtt { ] /(times\\ @@\\ ( factorial /@\\",
    "c ) times\\ @@\\ mapindexed[(2 \\#2[[1]])^{\\#1 } \\ & , c ] ) } \\end{split}\\ ] ]    the whole sum is given by    @xmath64:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{cycleindex[n\\_]\\ : = \\",
    "( ct /@\\ partitions[n]))}\\ ] ]    the number @xmath155 can be obtained as follows :    @xmath99:= \\quad \\setcounter{outpromtcount}{\\value{inpromtcount}}\\stepcounter{inpromtcount}}}\\mathtt{ub[n\\_]\\ : = } \\ & \\mathtt{\\frac{1}{2 } ( ( cycleindex[n]\\ /.\\ \\{var[p\\ _ , k\\_]\\ \\to\\ 2^k\\ } ) } \\\\            & \\mathtt{+ ( cycleindex[n]\\ /.\\ \\{var[p\\ _ , k\\_]\\ : \\to\\ if[evenq[p ] , 2^k , 0]\\ } ) ) } \\end{split}\\ ] ]    then one can get the numbers form the table [ tbl:1 ] : the code @xmath156 , \\{n , 1 , 5\\}]}$ ] produces @xmath157 .",
    "a much faster way of calculating the walsch - hadamar transform of a boolean function @xmath82 ( i.e. calculation of all @xmath158 numbers @xmath74 , @xmath75 ) is based on the following decomposition of the hadamard matrix : @xmath159 which can be proved by induction .",
    "the relation @xmath160 can be written as @xmath161 for @xmath162 and @xmath163 .",
    "the walsh - hadamard transform can be calculated according to as @xmath164 starting with the vector @xmath165 we calculate vectors @xmath166 for @xmath167 .",
    "then @xmath168 is @xmath169 .",
    "the algorithm in _",
    "c _ is presented in the function _",
    "whtl _ in the file _",
    "whtl.c _ below . to turn _ whtl.c _ into a program usable from inside",
    "_ mathematica_another file , _",
    "_ is necessary .",
    "\\textcolor{gray}{// \\textit{xlen is of the form $ 2^n$ , returns $ n$ } }   \\textcolor{blue}{long } _ _ log(\\textcolor{blue}{long } xlen ) \\ {",
    "i = 1 , m = xlen ;     \\textcolor{blue}{while}((m > > = \\textcolor{red}{1 } ) ! = \\textcolor{red}{1 } ) i++ ;     \\textcolor{blue}{return } i ;   \\ }     \\textcolor{blue}{void } whtl(\\textcolor{blue}{int * } x , \\textcolor{blue}{long } xlen ) \\ {     \\textcolor{blue}{int * } y = ( \\textcolor{blue}{int*})calloc(xlen , \\textcolor{blue}{sizeof}(\\textcolor{blue}{int } ) ) ;     \\textcolor{blue}{long } i , j , k , t , pow1 , pow2 , ind1 , ind2 ;     \\textcolor{blue}{long } n = _ _ log(xlen ) ;       \\textcolor{blue}{for}(k = \\textcolor{red}{1 } ; k",
    "< = n ; k++ ) \\ {       pow1 = \\textcolor{red}{1}<<(k-\\textcolor{red}{1 } ) ;       pow2 = \\textcolor{red}{1}<<(n - k ) ;       \\textcolor{blue}{for}(j = \\textcolor{red}{0 } ; j < pow2 ; j++ ) \\",
    "{         t = j<<k ;         \\textcolor{gray}{// \\textit{in c arrays are numbered from 0 } }         \\textcolor{blue}{for}(i = \\textcolor{red}{0 } ; i < pow1 ; i++ ) \\",
    "{           ind1 = t + i ;           ind2 = ind1 + pow1 ;           y[ind1 ] = x[ind1 ] + x[ind2 ] ;           y[ind2 ] = x[ind1 ] - x[ind2 ] ;         \\ }       \\ }       \\textcolor{blue}{if}(k <",
    "n )         memcpy(x , y , \\textcolor{blue}{sizeof}(\\textcolor{blue}{int})*xlen ) ;     \\ }        on a unix system the files are compiled with the following command @xmath170 this command produces an executable file _",
    "whtl_. to use it in _",
    "mathematica_it must be installed as @xmath171;}\\ ] ] then it can be used as @xmath172}\\ ] ] where all @xmath173 , @xmath174 are @xmath175 ."
  ],
  "abstract_text": [
    "<S> the relation between the boolean functions and bell inequalities for qubits is analyzed . </S>",
    "<S> the connection between the maximal quantum violation of a bell inequality and the nonlinearity of the corresponding boolean function is discussed . </S>",
    "<S> a visualization scheme of boolean functions is proposed . </S>",
    "<S> an attempt to classify bell inequalities for qubits is made , a weaker result ( classification with respect to jevons group ) is obtained . </S>",
    "<S> the fractal structure of the classification is shown . </S>",
    "<S> all constructs are illustrated by _ </S>",
    "<S> mathematica_code . </S>"
  ]
}