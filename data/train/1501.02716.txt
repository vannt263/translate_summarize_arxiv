{
  "article_text": [
    "[ sec : intro ]    dynamic networks , instantiated , e.g. , by wireless sensor networks , mobile ad - hoc networks and vehicle area networks , are becoming ubiquitous nowadays .",
    "the primary properties of such networks are sets of participants ( called processes in the sequel ) that are a priori unknown and potentially changing , time - varying connectivity between processes , and the absence of a central control .",
    "dynamic networks is an important and very active area of research @xcite .    accurately modeling dynamic networks is challenging , for several reasons : first , process mobility , process crashes / recoveries , deliberate joins / leaves , and peculiarities in the low - level system design like duty - cycling ( used to save energy in wireless sensor networks ) make static communication topologies , as typically used in classic network models , inadequate for dynamic networks .",
    "certain instances of dynamic networks , in particular , peer - to - peer networks @xcite and inter - vehicle area networks @xcite , even suffer from significant churn , i.e. , a large number of processes that can appear / disappear over time , possibly in the presence of faulty processes @xcite , and hence consist of a potentially unbounded total number of participants over time .",
    "more classic applications like _ mobile ad - hoc networks _ ( manets )",
    "@xcite , wireless sensor networks @xcite and disaster relief applications @xcite typically consist of a _ bounded _ ( but typically unknown ) total number of processes .",
    "second , communication in many dynamic networks , in particular , in wireless networks like manets , is inherently broadcast : when a process transmits , then every other process within its transmission range will observe this transmission  either by legitimately receiving the message or as some form of interference .",
    "this creates quite irregular communication behavior , such as capture effects and near - far problems @xcite , where certain ( nearby ) transmitters may `` lock '' a receiver and thus prohibit the reception of messages from other senders .",
    "consequently , the `` health '' of a wireless link between two processes may vary heavily over time @xcite . for low - bandwidth wireless transceivers , an acceptable link quality",
    "usually even requires communication scheduling @xcite ( e.g. , time - slotted communication ) for reducing the mutual interference .",
    "overall , this results in a frequently changing spatial distribution of pairs of nodes that can communicate at a given point in time .    as a consequence , many dynamic networks ,",
    "in particular , wireless ones @xcite , are not adequately modeled by means of bidirectional links : fading and interference phenomenons @xcite , including capture effects and near - far problems , are _ local _ effects that affect only the receiver of a wireless link .",
    "given that the sender , which is also the receiver of the reverse link , resides at a different location , the two receivers are likely to experience very different levels of fading and interference @xcite .",
    "this effect is even more pronounced in the case of time - slotted communication , where forward and backward links are used at different times .",
    "consequently , the existence of asymmetric communication links can not be ruled out in practice : according to @xcite , 80% of the links in a typical wireless network are asymmetric .    despite these facts ,",
    "most of the dynamic network research we are aware of assumes bidirectional links @xcite .",
    "the obvious advantage of this abstraction is simplicity of the algorithm design , as strong communication guarantees obviously make this task easier .",
    "moreover , it allows the re - use of existing techniques for wireline networks , which naturally support bidirectional communication",
    ". however , there are also major disadvantages of this convenient abstraction : first , for dynamic networks that operate in environments with unfavourable communication conditions , e.g. in disaster relief applications or , more generally , in settings with various interferers and obstacles that severely inhibit communication , bidirectional links may simply not be achievable . for implementing distributed services in such settings , algorithms that do not need bidirectional links are mandatory .",
    "second , the entire system needs to be engineered in such a way that bidirectional single - hop communication can be provided within bounded time .",
    "this typically requires relatively dense networks and/or processes that are equipped with powerful communication interfaces , which incur significant cost when compared to sparser networks or / and cheaper or more energy - saving communication devices . and last but not least , if directed single - hop communication was already sufficient to reach some desired goal ( say , reaching some destination process ) via multi - hop messages , waiting for guaranteed single - hop bidirectional communication would incur a potentially significant , unnecessary delay . obviously ,",
    "in such settings , algorithmic solutions that do not need bidirectional single - hop communication could be significantly faster .    in this paper",
    ", we thus restrict our attention to dynamic networks consisting of an _ unknown but bounded _",
    "total number of processes , which are interconnected by _ directed _ communication links .",
    "the system is assumed to be synchronous , hence time is measured in discrete _ rounds _ that allow the processes to exchange at most one message .",
    "time - varying communication is modeled as a sequence of _ communication graphs _ , which contain a directed edge between two processes if the message sent in the corresponding round is successfully received .",
    "a bidirectional link is modeled by a pair of directed links that are considered independent of each other here .    a natural approach to build robust services despite the dynamic nature of such systems",
    "is to use some sort of distributed agreement on certain system parameters like schedules , frequencies , and operating modes , as well as on application - level issues : such a solution allows to use arbitrary algorithms for generating local proposals , which are supplied as inputs to a consensus algorithm that finally selects one of them consistently at all processes .",
    "as opposed to master - slave - based solutions , this approach avoids the single point of failure formed by the process acting as the master .",
    "the ability to reach _ system - wide _ consensus is hence the most convenient abstraction one could provide here .",
    "the first major contribution of our paper is hence a suite of impossibility results and a consensus algorithm for directed dynamic networks that , to the best of our knowledge , works under the weakest communication guarantees sufficient for consensus known so far .",
    "obviously , however , one can not reasonably assume that every dynamic network always provides sufficiently strong communication guarantees for solving consensus .",
    "fortunately , weaker forms of distributed agreement are sufficient for certain applications . in case of determining communication schedules @xcite , for example , which are used for staggering message transmission of nearby nodes in time to decrease mutual interference , it usually suffices if those processes that have to communicate regularly with each other ( e.g. , for implementing a distributed service within a partition ) agree on their schedule .",
    "a more high - level example would be agreement on rescue team membership @xcite in disaster relief applications .    for such applications , suitably designed @xmath2-set agreement algorithms @xcite , where processes must agree on at most @xmath2 different values system - wide , are a viable alternative to consensus ( @xmath10 ) .",
    "this is particularly true if such a @xmath2-set agreement ( i ) respects partitions , in the sense that processes in the same ( single ) partition decide on the same value , and ( ii ) is _ gracefully degrading _",
    ", in the sense that the actual number @xmath2 of different decision values depends on the _ actual _ network topology in the execution : if the network is well - behaved , the resulting @xmath2 is small ( ideally , @xmath10 ) , whereas @xmath2 may increase under unfavorable conditions . whereas any gracefully degrading algorithm must be @xmath2-uniform , i.e. , unaware of any a priori information on @xmath2",
    ", it should ideally also be _",
    ", i.e. , produce the smallest number @xmath2 of different decisions possible .",
    "the second major contribution of our paper are several impossibility results for @xmath2-set agreement in directed dynamic networks , as well as the , to the best of our knowledge , first instance of a worst - case @xmath2-optimal @xmath2-set agreement , i.e. , a consensus algorithm that indeed degrades _ gracefully _ to general @xmath2-set agreement .    * detailed contributions and paper organization . *    in [ sec : model ] , we introduce our detailed system model , which adopts the _ message adversary _ notation used in @xcite .",
    "it consists of an ( unknown ) number @xmath11 of processes , where communcation is modeled by a sequence of directed communication graphs , one for each round : if some edge @xmath12 is present in the communication graph @xmath13 of round @xmath14 , then process @xmath15 has received the message sent to it by @xmath16 in round @xmath14 .",
    "the message adversary determines the set of links actually present in every @xmath13 , according to certain constraints that may be viewed as network assumptions .    with respect to consensus",
    ", we provide the following contributions :    1 .",
    "in [ sec : consimposs ] , we show that communication graphs that are weakly connected in every round are not sufficient for solving consensus , and introduce a fairly weak additional assumption that allows to overcome this impossibility .",
    "our message adversary @xmath17 requires that the communication graph in every round is weakly connected and has one ( possibly changing ) strongly connected component ( called a _ root component _ ) that has no in - coming links from processes outside .",
    "note carefully that every directed graph has at least one root component .",
    "since this assumption is still too weak for solving consensus , @xmath17 also requires that , eventually , there will be @xmath1 consecutive rounds where the processes in the root component remain the same , although the connection topology may still change .",
    "we use the term _ vertex - stable root component _ ( vsrc ) for this requirement . in [ sec : consensus ] , we provide a consensus algorithm that works in this model , and prove its correctness . our algorithm requires a window of stability of @xmath18 rounds , where @xmath19 is the _ dynamic network causal diameter _ of the network (= the number of rounds required to reach all processes in the network from any process in the vertex - stable root component via multi - hop communication ) .",
    "2 .   in [ sec : consimposs ] , we show that any consensus and leader election algorithm has to know an a priori bound on @xmath19 . since @xmath20 is a trivial bound on @xmath19 , this implies that no uniform algorithm , i.e. , no algorithm unaware of @xmath11 or @xmath19 , can solve consensus in our model .",
    "in addition , we prove that consensus is impossible both under @xmath6 and under @xmath21 , which shows that @xmath19 is a lower bound for the window of stability of vsrcs .",
    "we also demonstrate that neither reliable broadcast , atomic broadcast , nor causal - order broadcast can be implemented under @xmath17 .",
    "the same is shown to be true for counting , @xmath2-verification , @xmath2-token dissemination , all - to - all token dissemination , and @xmath2-committee election .    with respect to @xmath2-set agreement and gracefully degrading consensus",
    ", we provide the following contributions :    1 .   in [ sec :",
    "impossibility - proofs ] , we provide a fairly weak natural message adversary @xmath0 that is still too strong for solving @xmath2-set agreement : it reveals that the restriction to at most @xmath2 simultaneous vsrcs in every round is _ not _ sufficient for solving @xmath2-set agreement if just a single vsrc is vertex - stable for less than @xmath22 rounds : a generic reduction of @xmath2-set agreement to consensus introduced in @xcite , in conjunction with certain bivalence arguments , is used to construct a non - terminating run in this case . moreover , _",
    "eventual _ stability of _ all _ vsrcs is also not enough for solving @xmath2-set agreement , not even when it is guaranteed that ( substantially ) less than @xmath2 vsrcs exist simultaneously .",
    "the latter is a consequence of some adversarial partitioning over time , which could happen in our dynamic networks . 2 .   in [ sec : sufficiency",
    "] , we show that the message adversary @xmath7 , which combines @xmath8 ( ensuring termination ) with some information flow guarantee @xmath9 between certain vsrcs ( ensuring @xmath2-agreement ) , is sufficient for solving @xmath2-set agreement .",
    "basically , @xmath9 guarantees that at most @xmath2 vsrcs exist in a run that are not affecting each other significantly . despite being fairly strong",
    ", the resulting message adversary @xmath7 allows to implement a @xmath2-uniform @xmath2-set agreement algorithm , which naturally respects partitions and is _ worst - case @xmath2-optimal _ , in the sense that no algorithm can solve @xmath23-set agreement under @xmath7 . to the best of our knowledge",
    ", it is the first gracefully degrading consensus algorithm proposed so far .    as a final remark",
    ", we note that the ultimate goal of the latter part of our research are network assumptions for every @xmath24 , which are both necessary and sufficient for solving @xmath2-set agreement . knowing or at least approaching this border is interesting for several reasons : first , it is interesting from a theoretical point of view : @xmath2-set agreement has been a major target for the study of solvability in asynchronous systems with failure detectors since decades .- set agreement is still unknown @xcite .",
    "interestingly , @xcite revealed that there are relations between this classic model and dynamic networks . ]",
    "second , striving for weak network assumptions is always advantageous w.r.t .  the assumption coverage in real systems , as they are typically more likely to hold in a given dynamic network .",
    "finally , a set of network assumptions close to the necessary and sufficient ones is needed for @xmath2-optimal @xmath2-set agreement algorithms : whereas our worst - case @xmath2-optimal algorithm only needs a single worst - case run under @xmath7 where it can not solve @xmath23-set agreement , a @xmath2-optimal algorithm must solve @xmath2-set agreement for the _ smallest _ @xmath2 possible in _ every _ run .",
    "we believe that our work constitutes a significant step towards identifying the exact solvability border of @xmath2-set agreement : since necessary and sufficient network conditions in our model must lie somewhere in between ( 3 ) and ( 4 ) , we managed to tightly `` enclose '' them . further tightening the gap and eventually closing it ,",
    "is a topic of future research .",
    "dynamic networks have been studied intensively in research ( see the overview by kuhn and oshman @xcite and the references therein ) . besides work on peer - to - peer networks like @xcite , where the dynamicity of nodes ( churn ) is the primary concern , different approaches for modeling dynamic connectivity have been proposed , both in the networking context and in the context of classic distributed computing .",
    "casteigts et al .",
    "@xcite introduced a comprehensive classification of time - varying graph models .",
    "* there is a rich body of literature on dynamic graph models going back to  @xcite , which also mentions for the first time modeling a dynamic graph as a sequence of static graphs .",
    "a more recent paper using this approach is @xcite , where distributed computations are organized in lock - step synchronous rounds .",
    "communication is described by a sequence of per - round communication graphs , which must adhere to certain network assumptions ( like @xmath25-interval connectivity , which says that there is a common subgraph in any interval of @xmath25 rounds ) .",
    "afek and gafni @xcite introduced message adversaries for specifying network assumptions in this context , and used them for relating problems solvable in wait - free read - write shared memory systems to those solvable in message - passing systems .",
    "raynal and stainer @xcite also used message adversaries for exploring the relationship between round - based models and failure detectors .    besides time - varying graphs , several alternative approaches that consider missing messages as failures have also been proposed in the past : moving omission failures  @xcite , round - by - round fault detectors  @xcite , the heard - of model  @xcite and the perception - based failure model  @xcite .    * agreement problems .",
    "* agreement problems in dynamic networks with undirected communication graphs have been studied in @xcite ; agreement in directed graphs has been considered in @xcite .    in particular , the work by kuhn et al .",
    "@xcite focuses on the @xmath26-coordinated consensus problem , which extends consensus by requiring all processes to decide within @xmath26 rounds of the first decision .",
    "since they consider only undirected graphs that are connected in every round , without node failures , solving consensus is always possible . in terms of the classes of  @xcite ,",
    "the model of @xcite is in one of the strongest classes ( class  10 ) in which every process is always reachable by every other process . on the other hand ,",
    "@xcite do consider directed graphs , but restrict the dynamicity by not allowing stabilizing behavior .",
    "consequently , they also belong to quite strong classes of network assumptions in @xcite . in sharp contrast",
    ", the message adversary tolerated by our algorithms does not guarantee bidirectional ( multi - hop ) communication between all processes , hence falls between the weakest and second weakest class of models defined in  @xcite .",
    "the leader election problem in dynamic networks has been studied in @xcite , where the adversary controls the mobility of nodes in a wireless ad - hoc network .",
    "this induces dynamic changes of the ( undirected ) network graph in every round and requires any leader election algorithm to take @xmath27 rounds in the worst case , where @xmath28 is a bound on information propagation .",
    "regarding @xmath2-set agreement in dynamic networks , we are not aware of any previous work except @xcite , where bidirectional links are assumed , and our previous paper  @xcite , where we assumed the existence of an underlying _ static _ skeleton graph ( a non - empty common intersection of the communication graphs of all rounds ) with at most @xmath2 _ static _ root components .",
    "note that this essentially implies a directed dynamic network with a static core .",
    "by contrast , in this paper , we allow the directed communication graphs to be fully dynamic . in @xcite , we provided @xmath2-set agreement algorithms for partially synchronous systems with weak synchrony requirements .    * degrading consensus problems .",
    "* we are also not aware of related work exploring gracefully degrading consensus or @xmath2-uniform @xmath2-set agreement .",
    "however , there have been several attempts to weaken the semantics of consensus , in order to cope with partitionable systems and excessive faults .",
    "vaidya and pradhan introduced the notion of _ degradable _ agreement @xcite , where processes are allowed to also decide on a ( fixed ) default value in case of excessive faults .",
    "the _ almost everywhere agreement _ problem introduced by @xcite allows a small linear fraction of processes to remain undecided .",
    "aguilera et .",
    "@xcite considered quiescent consensus in partitionable systems , which requires processes outside the majority partition not to terminate .",
    "none of these approaches is comparable to gracefully degrading @xmath2-set agreement , however : on the one hand , we allow more different decisions , on the other hand , all correct processes are required to decide and every decision must be the initial value of some process .    ingram et .",
    "@xcite presented an asynchronous leader election algorithm for dynamic systems , where every component is guaranteed to elect a leader of its own .",
    "whereas this behavior clearly matches our definition of graceful degradation , contrary to decisions , leader assignments are revocable and the algorithm of @xcite is guaranteed to successfully elect a leader only once the topology eventually stabilizes .",
    "we consider a synchronous distributed system made up of a fixed set of distributed processes @xmath29 with @xmath30 , which have fixed unique ids and communicate via unreliable message passing . for convenience , we assume that the unique i d of @xmath31 is @xmath32 , and use both @xmath33 and @xmath32 for denoting this process ; `` generic '' processes will also be denoted by @xmath16 , @xmath15 etc .",
    "similar to the @xmath34 model @xcite , we assume that processes organize their computation as an infinite sequence of communication - closed  @xcite lock - step rounds .",
    "for every @xmath35 and each round @xmath36 , let @xmath37 be the state of @xmath16 at the beginning of round @xmath14 , taken from the set @xmath38 of all states @xmath16 can possibly enter ; @xmath39 is taken from the set of @xmath16 s initial states @xmath40 .",
    "the round @xmath14 computation of process @xmath16 is determined by two functions that make up @xmath16 s algorithm : the message sending function @xmath41 determines the message @xmath42 , taken from a suitable message alphabet @xmath43 , sent to all other processes in the system by @xmath16 in round @xmath14 , based on @xmath16 s state @xmath44 at the beginning of round @xmath14 . for simplicity",
    ", we assume that some ( possibly @xmath45 ) message is sent to all in a round where there is no proper algorithm message to be broadcast . a receiver may omit to receive a message sent to it in a round , and senders do not know ( without receiving explicit feedback later on ) who successfully received their message .",
    "the transition function @xmath46 takes @xmath16 s state @xmath44 at the beginning of round @xmath14 and a set @xmath47 of pairs of process ids and messages , which contains the round @xmath14 messages received by @xmath16 from other processes in the system , and computes the successor state @xmath48 .",
    "we assume that , for each process",
    "@xmath15 , there is at most one @xmath49 such that @xmath50 is the message @xmath15 sent in round @xmath14 .",
    "note that neither @xmath51 nor @xmath52 need to involve @xmath11 , i.e. , the algorithms executed by the processes may be uniform with respect to the network size @xmath11 .",
    "= [ circle , draw = gray , fill = lightgray!30,thick , inner sep=0pt , minimum size=4 mm ] = [ p , double ] = [ ->,black , thick , auto ] = [ ->,black , thick , densely dotted , auto ] = [ draw = none , opacity=0 ]    the evolving nature of the network topology is modeled as an infinite sequence of simple directed graphs @xmath53 , which is determined by an omniscient _ message adversary _ @xcite that has access to the processes states .",
    "[ def : commgraphs ] for each round @xmath14 , the _ round @xmath14 communication graph _",
    "@xmath54 is a simple directed graph with node set @xmath55 and edge set @xmath56 , where @xmath57 _ iff _ @xmath15 successfully receives @xmath16 s round @xmath14 message ( in round @xmath14 ) .",
    "the set @xmath58 denotes @xmath15 s _ in - neighbors _ in @xmath13 ( excluding @xmath15 ) .",
    "note that we will sloppily write @xmath59 to denote @xmath60 , as well as @xmath61 to denote @xmath62 .",
    "[ fig : graphs ] shows a sequence of communication graphs for a network of @xmath63 processes , for rounds @xmath64 to @xmath65 . for deterministic algorithms ,",
    "a run is completely determined by the initial states of the processes and the sequence of communication graphs .",
    "we emphasize that @xmath16 does not have any _ a priori _ knowledge of its neighbors , i.e. , @xmath16 does not know who receives its round @xmath14 message , and does not know who it will receive from in round @xmath14 before its round @xmath14 computation .",
    "since every @xmath66 can range arbitrarily from @xmath11 isolated nodes to a fully connected graph , there is no hope to solve any non - trivial agreement problem without restricting the power of the adversary to drop messages has no outgoing / incoming edges to / from some other processes in @xmath13 . ]",
    "to some extent .",
    "inspired by @xcite , we encapsulate a particular restriction , e.g. , that every communication graph must be strongly connected , by means of a particular _ message adversary_. note that [ def : ma ] generalizes the notation introduced in @xcite , which just specified the _ set _ of communciation graphs the adversary may choose from in every round , to sets of _ sequences _ of communication graphs .",
    "[ def : ma ] a message adversary _ adv _ ( for our system @xmath67 of @xmath11 processors ) is a set of sequences of communication graphs @xmath68 . a particular sequence of communication graphs @xmath69 is _ feasible _ for _ adv _ , if @xmath70 .    informally",
    ", we say that some message adversary _ adv _ guarantees some property , called a _ network assumption _ , if every @xmath71 satisfies this property .    for our system @xmath67 of @xmath11 processes , this introduces a natural partial order of message adversaries , where @xmath72 is weaker than @xmath73 ( denoted @xmath74 ) iff @xmath75 , i.e. , if it can generate at most the communication graph sequences of @xmath73 . as a consequence , an algorithm that works correctly under message adversary",
    "@xmath73 will also work under @xmath72 .      to formally introduce the consensus and",
    "@xmath2-set agreement problem studied in this paper , we assume some finite set @xmath76 and consider the set of possible initial states @xmath40 ( of process @xmath16 ) to be partitioned into @xmath77 subsets @xmath78 $ ] , with @xmath79 .",
    "when @xmath16 starts in a state in @xmath78 $ ] , we say that @xmath80 is @xmath16 s input value , denoted @xmath81 .",
    "moreover , we assume that , for each @xmath82 , there is a set @xmath83\\subset\\s_p$ ] of decided states such that @xmath83\\cap\\d_p[w]=\\emptyset$ ] if @xmath84 and @xmath85 $ ] is closed under @xmath16 s transition function , i.e. , @xmath52 maps every state in this subset to this subset ( for all possible sets @xmath86 of received messages ) .",
    "we say that @xmath16 has _ decided _ on the output value ( also called decision value ) @xmath80 , denoted @xmath87 , when it is in some state in @xmath83 $ ] .",
    "when @xmath16 performs a transition from a state outside of the set of decided states to the set of decided states , we say that @xmath16 _",
    "decides_.    [ def : consensus ] algorithm @xmath88 solves _ consensus _ , if the following properties hold in every run of @xmath88 :    * if process @xmath16 decides on @xmath89 and @xmath15 decides on @xmath90 , then @xmath91 . *",
    "if @xmath92 , then @xmath80 is some @xmath93 s initial value @xmath94 .",
    "* every process must eventually decide .",
    "for the _ @xmath2-set agreement problem _",
    "@xcite , we assume that both @xmath95 and @xmath96 to rule out trivial solutions .",
    "[ def : ksa ] algorithm @xmath88 solves _ @xmath2-set agreement _",
    ", if the following properties hold in every run of @xmath88 :    * at most @xmath2 different decision values are obtained system - wide in any run . * if @xmath92 , then @xmath80 is some @xmath93 s initial value @xmath94 .",
    "* every process must eventually decide .    clearly , consensus is the special case of @xmath64-set agreement ; set agreement is a short - hand for @xmath20-set agreement .",
    "a consensus or @xmath2-set agreement algorithm is called _ uniform _ , if it does not have any a priori knowledge of the network ( and hence of @xmath11 ) .",
    "a @xmath2-set agreement algorithm is called _ @xmath2-uniform _ , if it does not require a priori knowledge of @xmath2 .",
    "we will now define the cornerstones of the message adversaries used in our paper , which culminate in [ def : d - bounded - vsrc ] and [ def : e - network - vertex - stable - roots ] .",
    "message adversaries such as @xmath17 ( [ ass : window ] ) and @xmath0 ( [ ass : inter ] ) will be defined implicitly , by defining the properties of the sequences of feasible communication graphs . informally , most of those will rest on the pivotal concept of _ root components _ , which are strongly connected components in @xmath13 without _ incoming _ edges from processes outside the component .",
    "our message adversaries will be required to eventually guarantee root components that are vertex - stable , i.e. , to consist of the same _ set _ of nodes ( with possibly varying interconnect ) during a sufficiently large number of consecutive rounds .",
    "vertex - stability will eventually guarantee that all members can receive information from each other .",
    "[ def : rc ] a _ root component _ @xmath97 , with non - empty set of vertices @xmath98 , is a _ strongly connected component _",
    "( scc ) in @xmath13 that has no incoming edges from other components , formally @xmath99 .    by contracting sccs , it is easy to see that every weakly connected directed simple graph @xmath100 has at least one root component , see [ lem : root ] . hence , if @xmath100 has @xmath2 root components , it has at most @xmath2 weakly connected components ( with disjoint root components , but possibly overlapping in the remaining processes ) .",
    "[ def : vsrc ] a sequence of consecutive rounds with communication graphs @xmath101 for @xmath102 $ ] , @xmath103 , contains an @xmath104-_vertex - stable root component _ @xmath105 , if , for @xmath106 , every @xmath101 contains a root component @xmath107 with the same set of nodes @xmath108 ( but possibly varying interconnection topology ) .",
    "we will abbreviate @xmath105 as an @xmath104-vsrc or @xmath109-vsrc if only the length of @xmath104 matters , and sometimes denote an @xmath104-vsrc @xmath105 by its vertex set @xmath108 if @xmath104 is clear from the context .",
    "note carefully that we assume @xmath110 here , since @xmath111 $ ] ranges from the _ beginning _ of round @xmath112 to the _ end _ of round @xmath113 ; hence , @xmath114 $ ] is not empty but rather represents round @xmath14 .",
    "the most important property of a vsrc @xmath105 is that information is guaranteed to spread to all its vertices @xmath108 if the interval @xmath104 is large enough , as proved in [ lem : bncd ] below . to express this formally ,",
    "we need a few basic definitions and lemmas .    similarly to the classic",
    "`` happened - before '' relation @xcite , we say that a process _",
    "@xmath16 causally influences @xmath15 in round @xmath14 _ , denoted by @xmath115 , iff either ( i ) @xmath15 has an incoming edge @xmath116 from @xmath16 in @xmath66 , or ( ii ) if @xmath117 , i.e. , we assume that @xmath16 always influences itself in a round . given a sequence of communication graphs @xmath118 , we say that there is an _ causal influence chain _ of length @xmath119 starting from @xmath16 in round @xmath14 to @xmath15 , denoted by @xmath120}{\\leadsto } q)$ ] , if there exists a sequence of not necessarily distinct processes @xmath121 such that @xmath122 for @xmath123 .",
    "if @xmath2 is irrelevant , we just write @xmath115 or just @xmath124 and say that @xmath16 ( in round @xmath14 ) causally influences @xmath15 .",
    "this allows us to define the notion of a dynamic causal distance between processes as given in [ def : dd ] .",
    "[ def : dd ] given a sequence of communication graphs @xmath118 , the _ dynamic causal distance _",
    "@xmath125 from process @xmath16 ( in round @xmath14 ) to process @xmath15 is the length of the shortest causal influence chain starting in @xmath16 in round @xmath14 and ending in @xmath15 , formally @xmath126}{\\leadsto}q)\\}$ ] .",
    "we define @xmath127 and @xmath128 if @xmath16 never influences @xmath15 after round @xmath14 .",
    "note that , in contrast to the similar notion of dynamic distance defined in @xcite , the dynamic causal distance in our _ directed _ graphs is not necessarily symmetric : if the adversary chooses the graphs @xmath66 such that not all processes are strongly connected , the causal distance between two processes can even be finite in one and infinite in the other direction .",
    "in fact , even if @xmath66 is strongly connected for round @xmath14 ( but not for rounds",
    "@xmath129 ) , @xmath130 can be infinite .",
    "however , the following [ lem : cd ] shows that the causal distance in successive rounds can not arbitrarily decrease .",
    "[ lem : cd ] given a sequence of communication graphs @xmath118 , for every two processes @xmath131 it holds that @xmath132 . as a consequence , if @xmath133 , then also @xmath134 .",
    "since @xmath135 in every round @xmath14 , the definition of dynamic causal distance trivially implies @xmath136 .",
    "analogous to the dynamic diameter defined for undirected communication graphs in @xcite , we now define the _ dynamic causal diameter _",
    "@xmath137 for round @xmath138 in a @xmath104-vsrc @xmath105 as the largest round @xmath138 dynamic causal distance @xmath139 between any pair of processes @xmath140 :    [ def : cdiam ] given a sequence of communication graphs @xmath118 , let @xmath111 $ ] , @xmath141 , be a nonempty interval of indices in this sequence.$ ] with a vsrc @xmath105 '' . ]",
    "assume that the subsequence of communication graphs @xmath101 for @xmath142 contains an @xmath104-vsrc @xmath105 with node set @xmath108 .",
    "then , the _ dynamic causal diameter _ of @xmath105 for round @xmath138 is defined as @xmath143 .    obviously , it may be the case that @xmath144 in general .",
    "however , if @xmath109 is sufficiently large , the following [ lem:2 ] reveals that @xmath145 .",
    "[ lem:2 ] given some @xmath111 $ ] and a vsrc @xmath105 with @xmath146 , if @xmath147 , then @xmath148 \\colon \\cdiam^x(r^i ) { \\leqslant}|r|-1 $ ] .",
    "fix some process @xmath149 and some @xmath138 where @xmath150 .",
    "let @xmath151 , and define for each @xmath152 the set @xmath153 .",
    "@xmath154 is hence the set of processes @xmath155 such that @xmath156}{\\lt}}q)$ ] holds . using induction",
    ", we will show that @xmath157 for @xmath158 .",
    "induction base @xmath159 : @xmath160 follows immediately from @xmath151 .",
    "induction step @xmath161 , @xmath158 : clearly the result holds if @xmath162 , thus we consider round @xmath163 and @xmath164 : it follows from strong connectivity of @xmath165 that there is a set of edges from processes in @xmath166 to some non - empty set @xmath167 .",
    "hence , we have @xmath168 , which implies @xmath169 by the induction hypothesis .    thus , in order to guarantee @xmath170 and thus @xmath171 , choosing @xmath2 such that @xmath172 and @xmath173 is sufficient .",
    "since @xmath174 , both conditions can be fulfilled by choosing @xmath175 . moreover , due to the definition of @xmath166 , it follows that @xmath176 for all @xmath155 .",
    "since this holds for any @xmath16 and any @xmath177 , the statement of [ lem:2 ] follows .",
    "[ lem:2 ] thus implies that information available at any node @xmath149 at the beginning of round @xmath178 $ ] has spread to all other nodes in @xmath108 by the end of round @xmath113 , i.e. , during @xmath104 . on the other hand",
    ", it may be the case for some particular vsrc @xmath105 with @xmath179 that the information available at the beginning of some round @xmath106 has already spread to all other nodes in @xmath108 by the end of round @xmath113 .",
    "[ lem : infprop ] reveals that this implies that the information available at any round @xmath180 $ ] has also been spread to all nodes in @xmath108 by the end of round @xmath113 .",
    "[ lem : infprop ] suppose that @xmath105 for @xmath111 $ ] is an @xmath104-vsrc of size @xmath181 , such that there is some @xmath182 $ ] with @xmath183 .",
    "then , for every @xmath184 $ ] , it holds that @xmath185 .",
    "[ lem : cd ] reveals that for all @xmath186 , we have @xmath187 , which implies @xmath188 for every @xmath189 where @xmath190 and proves our lemma .    conversely , assume that some particular vsrc @xmath105 is such that information available at the beginning of round @xmath112 reaches all members of @xmath108 by the end of some round @xmath191 , i.e. , @xmath192 for some @xmath193 .",
    "can we infer something about @xmath137 for later rounds @xmath194 in this case ? in particular , will information available at the beginning of round @xmath195 be spread to all nodes by the end of round @xmath113 ? unfortunately , in general , this is not the case , as the following simple example for @xmath196 $ ] and @xmath197 shows : if @xmath198 is the complete graph whereas @xmath199 is a ring , @xmath200 , but information propagation starting at round 2 does not reach all other nodes by the end of of round @xmath201 .",
    "this stimulated the following [ def : d - bounded - vsrc ] , which parameterizes the worst - case information propagation in a vsrc via a parameter @xmath28 that represents its dynamic causal diameter .",
    "informally , it guarantees that messages sent by any process in @xmath108 , in any but the last @xmath202 rounds of @xmath104 , reach all members of @xmath108 within @xmath104 .",
    "[ def : d - bounded - vsrc ] an @xmath104-vertex - stable root component @xmath105 with @xmath111 $ ] is _",
    "@xmath28-bounded _ , with _ dynamic causal diameter _",
    "@xmath203 , if either @xmath204-bounded  that is too short to be interesting .",
    "obviously , such a vsrc need not guarantee information propagation within @xmath28 rounds .",
    "note that it would actually be possible to write @xmath205 here , as our algorithms do not even consider @xmath28-vsrcs as interesting ; we chose the present definition for consistency with [ def : e - network - vertex - stable - roots ] for @xmath19-network - bounded  vsrcs , however . ] or else @xmath206 \\colon \\cdiam^x(r^i ) { \\leqslant}d$ ] .",
    "[ lem:2 ] showed that every sufficiently long vsrc @xmath105 is @xmath28-bounded for @xmath207 ; all sufficiently long vsrcs are hence necessarily @xmath208-bounded . on the other hand ,",
    "choosing some @xmath209 can be used to force the message adversary to speed - up information propagation accordingly .",
    "for example , we show in [ sec : expander ] that certain expander graph topologies ensure @xmath210 .",
    "to formalize information propagation from root components to the rest of the network , one has to account for the fact that a process @xmath15 outside any root component may be reachable from _ multiple _ root components in general . intuitively speaking , this models dynamic networks that do not `` cleanly '' partition .",
    "given a sequence of communication graphs @xmath118 containing a set @xmath211 of @xmath212 @xmath104-vsrcs , all vertex - stable in the same interval @xmath111 $ ] , let the round @xmath138 _ dynamic network causal diameter _",
    "@xmath213 be the maximum , taken over all processes @xmath214 , of the minimal dynamic causal distance @xmath139 from _ some _ process @xmath215 in round @xmath138 , formally @xmath216 .",
    "[ def : e - network - vertex - stable - roots ] will be used in the sequel to guarantee that every process in the network receives a message from some member of at least one vsrc in @xmath211 within @xmath19 rounds if @xmath217 .",
    "[ def : e - network - vertex - stable - roots ] a set @xmath211 of @xmath212 @xmath104-vsrcs with @xmath111 $ ] is @xmath19-network - bounded , with _",
    "dynamic network causal diameter _",
    "@xmath218 , if either @xmath219 or else @xmath220:\\ , \\cheight^x(s^i ) { \\leqslant}h$ ] .",
    "note that [ def : e - network - vertex - stable - roots ] guarantees @xmath221}{\\leadsto } q)$ ] for _ at least one _ but not for all @xmath222 .",
    "moreover , @xmath16 ( and hence @xmath223 ) may be different for different starting rounds @xmath138 in @xmath104 .",
    "a comparison of [ def : e - network - vertex - stable - roots ] and [ def : d - bounded - vsrc ] reveals that it always holds that @xmath224 . moreover , in the case @xmath225 ( where @xmath226 contains a single root component @xmath105 only ) , [ def : e - network - vertex - stable - roots ] is exactly [ def : d - bounded - vsrc ] with the dynamic causal diameter @xmath137 replaced by the dynamic network causal diameter @xmath227 . finally , analogous to [ lem:2 ] , the following [ lem : bncd ] shows that the dynamic network causal diameter @xmath19 is bounded by @xmath20 , provided @xmath228 .",
    "[ lem : bncd ] suppose there is some interval @xmath111 $ ] where there is a set @xmath211 of exactly @xmath212 @xmath104-vertex - stable root components . if @xmath229 and @xmath230 , then @xmath226 is @xmath20-network bounded .",
    "let @xmath231 and fix any @xmath138 where @xmath232 .",
    "define , for each @xmath152 , the set @xmath233 .",
    "@xmath234 is hence the set of processes @xmath15 such that @xmath235}{\\leadsto } q)$ ] holds for at least one @xmath236 . using induction",
    ", we will show that @xmath237 for @xmath238 .",
    "induction start @xmath239 follows immediately from @xmath240 with @xmath212 .",
    "induction step @xmath241 : first assume that already @xmath242 ; since @xmath243 , we are done . otherwise , consider round @xmath163 and @xmath244 : since every node @xmath245 is in a weakly connected component containing at least one root in every round , hence also in @xmath246 , there is a set of edges from processes in @xmath247 to some non - empty set @xmath248 .",
    "hence , we have @xmath249 , which implies @xmath250 by the induction hypothesis .",
    "thus , in order to guarantee @xmath251 and thus @xmath252 , choosing @xmath2 such that @xmath253 and @xmath254 is sufficient . since @xmath255 , both conditions can be fulfilled by choosing @xmath256 . moreover , due to the definition of @xmath247 , it follows that for all @xmath214 there is some @xmath257 with @xmath258 , implying @xmath259 . since this holds for any @xmath260 following [ def : e - network - vertex - stable - roots ] , this implies [ lem : bncd ] .",
    "we conclude this section with an example of a network topology that guarantees a dynamic causal network diameter @xmath19 that is much smaller than @xmath20 , which justifies why we introduced this parameter ( as well as @xmath28 ) explicitly in our model .",
    "an undirected graph @xmath100 is an _ @xmath262-vertex expander _ if , for all sets @xmath263 of size @xmath264 , it holds that @xmath265 , where @xmath266 is the set of neighbors of @xmath267 in @xmath100 , i.e. , those nodes in @xmath268 that have a neighbor in @xmath267 .",
    "( explicit expander constructions can be found in @xcite . ) as we need an expander property for _ directed _ communication graphs , we consider , for a vertex / process set @xmath267 and a round @xmath14 , both the set @xmath269 of nodes outside of @xmath267 that are reachable from @xmath267 and the set of nodes @xmath270 that can reach @xmath267 in @xmath14 . [",
    "ass : fast ] ensures an expansion property both for subsets @xmath267 chosen from root components ( property ( a ) ) and other processes ( properties ( b ) , ( c ) ) .",
    "[ ass : fast ] there is a fixed constant @xmath262 and a fixed set @xmath108 such that the following conditions hold for all sets @xmath271 :    if @xmath272 and @xmath273 , then @xmath274 and @xmath275 .",
    "if @xmath276 and @xmath277 , then @xmath278 .",
    "if @xmath276 and @xmath279 , then @xmath280 .    the following [ lem : expgraphs ] shows that ( 1 ) [ ass : fast ] does not contradict the existence of a single root component and that ( 2 ) these expander topologies guarantee both a dynamic causal diameter @xmath210 for @xmath104-vsrcs with @xmath281 and a dynamic causal network diameter @xmath282 .",
    "[ lem : expgraphs ] there are sequences of graphs @xmath283 with a single root component in every @xmath13 where [ ass : fast ] holds and where , for any such run , there is an interval @xmath104 during which there exists a @xmath28-bounded  and @xmath19-network - bounded @xmath104-vertex stable root component with @xmath210 and @xmath282 .",
    "we will first argue that _ directed _ graphs with a single root exist that satisfy [ ass : fast ] .",
    "consider the simple _ undirected _ graph @xmath284 that is the union of an @xmath262-vertex expander on @xmath105 with member set @xmath108 , and an @xmath262-vertex expander on @xmath285 .",
    "we turn @xmath286 into a directed graph by replacing every edge @xmath287 with oriented directed edges @xmath288 and @xmath289 .",
    "this guarantees properties ( a)-(c ) . in order to guarantee the existence of exactly one root component ,",
    "we drop all directed edges pointing to @xmath105 from the remaining graph , i.e. , we remove all edges @xmath288 where @xmath290 and @xmath155 , which leaves properties ( a)-(c ) intact and makes the @xmath108 from [ ass : fast ] the single root component of the graph .",
    "we stress that the actual topologies chosen by the adversary might be quite different from this construction , which merely serves us to show the existence of such graphs .",
    "we also recall that our message adversaries like the one given in [ ass : window ] will rely on vertex - stable root components @xmath105 , which only require that the set of its vertices @xmath108 remain unchanged , whereas the interconnect topology can change arbitrarily . adding [ ass : fast ]",
    "does of course not change this fact .",
    "we will first show that the `` per round '' expander topology stipulated by [ ass : fast ] is strong enough to guarantee that every sufficiently long vsrc is @xmath28-bounded  with @xmath210 .    for @xmath291 ,",
    "let @xmath292 be the set of processes @xmath15 in @xmath105 with @xmath111 $ ] and @xmath281 such that @xmath293}{\\lt}}q)$ ] , and @xmath294 .",
    "the result @xmath210 follows immediately from [ lem:2 ] if @xmath295 , so assume that @xmath296 and consider some process @xmath297 . for round @xmath112 , property ( a )",
    "yields @xmath298 .",
    "in fact , for all @xmath32 where @xmath299 , we can apply property ( a ) to get @xmath300 , hence @xmath301 .",
    "let @xmath302 be the smallest value such that @xmath303 , which guarantees that @xmath304 .",
    "that is , @xmath305 .",
    "now consider any @xmath155 and define @xmath306 as the set of nodes that causally influence the set @xmath307 in round @xmath308 , for @xmath309 .",
    "again , by property ( a ) , we get @xmath310 , so @xmath311 . from the definition of @xmath302 above",
    ", we thus have @xmath312 .",
    "since @xmath313 , it follows that every @xmath314 influences every @xmath155 within @xmath315 rounds .",
    "while the above proof has been applied to the starting round @xmath316 only , it is evident that it carries over literally also for any @xmath317 , which shows that @xmath105 is indeed @xmath28-bounded .",
    "what remains to be shown is that @xmath19-network - boundedness with @xmath318 also holds .",
    "we use properties ( b ) and ( c ) similarly as in the above proof : for any round @xmath319 $ ] , we know by ( b ) that any process @xmath149 has influenced at least @xmath320 nodes by round @xmath321 where @xmath322 by arguing as for the @xmath154 sets above . now ( c ) allows us to reason along the same lines as for the sets @xmath323 above . that is , any @xmath15 in round @xmath324 will be influenced by at least @xmath320 nodes .",
    "therefore , any @xmath16 will influence every @xmath245 by round @xmath324 , which completes the proof .",
    "this confirms that sequences of communication graphs with @xmath325 and @xmath261 indeed exists and are compatible with message adversaries such as @xmath17 stated in [ ass : window ] below .",
    "in this section , we will prove that some a priori knowledge of the dynamic network causal diameter and the existence of a stable interval of a certain minimal size are inevitable for soving consensus in our model .",
    "moreover , we will introduce the message adversary @xmath17 , which will be shown in [ sec : consensus ] to be weak enough for solving consensus if @xmath326 , albeit it is too strong for solving other standard problems in dynamic networks like reliable broadcasting .    since consensus is trivially impossible for an unrestricted message adversary , which may just inhibit any communication in the system , we start from a message adversary that guarantees weakly connected communication graphs @xmath13 in every round @xmath14 .",
    "however , it is not difficult to see that this not sufficient for solving consensus , even when all @xmath327 are the same , i.e. , in a static topology : consider the case where @xmath100 contains two root components @xmath328 and @xmath329 ; such a graph obviously exists , cp .",
    "[ lem : root ] below .",
    "if all processes in @xmath328 start with initial value @xmath330 and all processes in @xmath329 start with initial value @xmath64 , they must decide on their own initial value and hence violate agreement .",
    "after all , no process in , say , @xmath328 ever has an incoming link from any process not in @xmath328 .",
    "we hence restrict our attention to message adversaries that guarantee a _ single _",
    "root component in @xmath66 for any round @xmath14 .",
    "[ fig : graphs ] showed a sequence of graphs where this is the case .",
    "some simple properties of such graphs are asserted by [ lem : root ] .",
    "[ lem : root ] any @xmath13 contains at least one and at most @xmath11 root components ( isolated processes ) , which are all disjoint .",
    "if @xmath13 contains a single root component @xmath97 , then @xmath13 is weakly connected , and there is a directed ( out - going ) path from every @xmath331 to every @xmath332 .    we first show that every weakly connected directed simple graph @xmath100 has at least one root component . to see this , contract every scc to a single vertex and remove all resulting self - loops .",
    "the resulting graph @xmath333 is a directed acyclic graph ( dag ) ( and of course still weakly connected ) , and hence @xmath333 has at least one vertex @xmath108 ( corresponding to some scc in @xmath100 ) that has no incoming edges . by construction , any such vertex @xmath108 corresponds to a root component in the original graph @xmath100 .",
    "since @xmath13 has at least @xmath64 and at most @xmath11 weakly connected components , the first statement of our lemma follows .    to prove the second statement",
    ", we use the observation that there is a directed path from @xmath334 to @xmath80 in @xmath100 if and only if there is a directed path from the vertex @xmath335 ( containing @xmath334 ) to the vertex @xmath336 ( containing @xmath80 ) in the contracted graph @xmath333 . if there is only one root component in @xmath100 ,",
    "the above observations imply that there is exactly one vertex @xmath108 in the contracted graph @xmath333 that has no incoming edges .",
    "since @xmath333 is connected , @xmath108 has a directed path to every other vertex in @xmath333 , which implies that every process @xmath297 has a directed path to every vertex @xmath15 , as required .",
    "it follows from @xcite that assuming a single root component makes consensus solvable if the root component is static . in this paper",
    ", we allow the root component to change throughout the run , i.e. , the ( single ) root component @xmath97 of @xmath66 might consist of a different set of processes in every round round @xmath14 .",
    "however , it will turn out that a sufficiently long interval of vertex - stability is indispensable for solving consensus in this setting . in the sequel",
    ", we will consider the message adversary @xmath17 stated in [ ass : window ] , which implicitly enforces the dynamic network causal diameter @xmath19 according to [ def : e - network - vertex - stable - roots ] and is parameterized by some stability window duration @xmath337 .    [ ass : window ] the message adversary @xmath17 is the set of all sequences of communication graphs @xmath283 , where    1 .   for every round @xmath14 , @xmath13 contains exactly one root component @xmath97 , 2 .",
    "all vertex - stable root components occurring in any @xmath283 are @xmath19-network - bounded , 3 .   for each @xmath283",
    ", there exists some @xmath338 and an interval of rounds @xmath339 $ ] with a @xmath19-network - bounded  @xmath340-vertex - stable root component .",
    "note that item  ( ii ) has been added to the above definition solely for the sake of our consensus algorithm in [ sec : consensus ] .",
    "all the impossibility results and lower bounds in this section hold also when ( ii ) is dropped or replaced by something ( like @xmath28-bounded  vsrcs , as in [ ass : inter ] ) that does not affect item  ( iii ) .",
    "first , we relate the message adversary in [ ass : window ] to the classification of  @xcite : [ lem : classification ] reveals that it is stronger than the weakest class that requests one node that eventually reaches all others , but weaker than the second class that requests one node that is reached by all .",
    "by contrast , models like @xcite that assume bidirectionally connected graphs @xmath13 in every round belong to the strongest classes ( class 10 ) in  @xcite .    [",
    "lem : classification ] in every sequence @xmath283 of communication graphs feasible for @xmath341 ,    1 .",
    "there is at least one process @xmath16 such that @xmath342 is finite for all @xmath245 , and this causal distance is in fact at most @xmath343 .",
    "conversely , for @xmath344 , the adversary can choose some sequence @xmath283 where no process @xmath16 is causally influenced by all other processes @xmath15 , i.e. , @xmath345 .",
    "[ ass : window ] guarantees that there is ( at most ) one root component @xmath97 in every @xmath13 , @xmath36 .",
    "since we have infinitely many graphs in @xmath283 but only finitely many processes , there is at least one process @xmath16 in @xmath97 for infinitely many @xmath14 .",
    "let @xmath346 be this sequence of rounds .",
    "moreover , let @xmath151 , and define for each @xmath152 the set @xmath347 .    using induction , we will show that @xmath348 for @xmath158 .",
    "consequently , by the end of round @xmath349 at latest , @xmath16 will have causally influenced all processes in @xmath67 .",
    "induction base @xmath159 : @xmath350 follows immediately from @xmath151 .",
    "induction step @xmath161 , @xmath158 : first assume that already @xmath351 ; since @xmath352 , we are done .",
    "otherwise , consider round @xmath353 and @xmath354 : since @xmath16 is in @xmath355 , there is a path from @xmath16 to any process @xmath15 , in particular , to any process @xmath15 in @xmath356 .",
    "let @xmath357 be an edge on such a path , such that @xmath358 and @xmath359 .",
    "clearly , the existence of this edge implies that @xmath360 and thus @xmath361 . since this implies @xmath362 by the induction hypothesis , we are done .    finally , at most @xmath343 rounds",
    "are needed until all processes @xmath15 have been influenced by @xmath16 , i.e. , @xmath363 : a pigeonhole argument reveals that at least one process @xmath16 must have been in the root component for @xmath20 times after so many rounds . after all , if every @xmath16 appeared at most @xmath364 times , we could fill up at most @xmath365 rounds . by the above result",
    ", this is enough to secure that some @xmath16 influenced every @xmath15 .",
    "the converse statement ( ii ) follows directly from considering a static star , for example , i.e. , a communication graph where there is one central process @xmath366 , and for all @xmath14 , @xmath367 . clearly , @xmath366 can not be causally influenced by any other process , and @xmath368 for any @xmath369 .",
    "on the other hand , this topology satisfy [ ass : window ] , which includes the requirement of at most one root component per round .",
    "next , we examine the solvability of several broadcast problems @xcite under the message adversary of [ ass : window ] , summarized in [ thm : impossibleproblems ] .",
    "although there is a strong bond between some of these problems and consensus in traditional settings , they are _ not _ implementable under our assumptions  basically , because there is no guarantee of ( eventual ) bidirectional communication .",
    "[ thm : impossibleproblems ] under the message adversary @xmath17 given in [ ass : window ] , for any @xmath1 , neither _",
    "reliable broadcast _ , _ atomic broadcast _ , nor _ causal - order broadcast _ can be implemented .",
    "moreover , there is no algorithm that solves _ counting _ , _ @xmath2-verification _ , _",
    "@xmath2-token dissemination _",
    ", _ all - to - all token dissemination _ , and _ @xmath2-committee",
    "election_.    we first consider reliable broadcast , which requires that when a correct process broadcasts @xmath370 , every correct process eventually delivers @xmath370 .",
    "suppose that the adversary chooses the communication graphs @xmath371 , which matches [ ass : window ] .",
    "clearly , @xmath15 is a correct process in our model . since @xmath16 never receives a message from @xmath15 , @xmath16",
    "can trivially never deliver a message that @xmath15 broadcasts .",
    "for the token dissemination problems stated in @xcite , consider the same communication graphs and assume that there is a token that only @xmath372 has .",
    "since no other process ever receives a message from @xmath372 , token dissemination is impossible .    for counting , @xmath2-verification , and @xmath2-committee election",
    ", we return to the static star round graph @xmath367 with central node @xmath366 considered in the proof of [ lem : classification ] .",
    "as the local history of any process is obviously independent of @xmath11 here , it is impossible to solve any of these problems .",
    "we will now show that every correct solution for consensus , as well as for the related leader - election problem , requires some a priori knowledge of the dynamic network causal diameter of the communication graphs generated by the adversary . recall that a uniform algorithm does not have any priori knowledge of the network ,",
    "i.e. , does not even know upper bounds for the dynamic network causal diameter @xmath19 ( and hence for @xmath11 ) .",
    "[ thm : impossdiameter ] there is no uniform algorithm that can solve consensus under the message adversary @xmath17 given in [ ass : window ] , for any @xmath1 .",
    "assume for the sake of a contradiction that there is such a uniform algorithm @xmath373 , w.l.o.g .  for a set of input values",
    "@xmath76 that contains 0 and 1 .",
    "consider a run @xmath374 of @xmath373 on a communication graph @xmath100 that forms a ( very large ) static directed line rooted at process @xmath16 and ending in process @xmath15 .",
    "process @xmath16 has initial value @xmath375 $ ] , while all other processes have initial value @xmath330 .",
    "clearly , the uniform algorithm @xmath373 must allow @xmath16 to decide on @xmath80 by the end of round @xmath376 , where @xmath376 is a constant ( independent of @xmath19 and @xmath11 ; we assume that @xmath11 is large enough to guarantee @xmath377 ) .",
    "next , consider a run @xmath378 of @xmath373 that has the same initial states as @xmath374 , and communication graphs @xmath379 that , during rounds @xmath380 $ ] , are also the same as in @xmath374 ( defining what happens after round @xmath376 will be defered ) . in any case , since @xmath374 and @xmath378 are indistinguishable for @xmath16 until its decision round @xmath376 , it must also decide @xmath80 in @xmath378 at the end of round @xmath376 .    however , since @xmath381 , @xmath15 has not been causally influenced by @xmath16 by the end of round @xmath376 .",
    "hence , it has the same state @xmath382 both in @xmath378 and in @xmath383 . as a consequence",
    ", it can not have decided by round @xmath376 : if @xmath15 decided @xmath80 , it would violate agreement with @xmath16 in @xmath383 .",
    "now assume that runs @xmath384 , @xmath383 are actually such that the stable window occurs later than round @xmath376 , i.e. , @xmath385 , and that the adversary just reverses the direction of the line then : for all @xmath386 , @xmath387 , @xmath15 is the root and @xmath16 is the last process of the resulting topology .",
    "observe that the resulting @xmath378 still satisfies [ ass : window ] , since @xmath15 itself forms the only root component .",
    "now , @xmath15 must eventually decide on some value @xmath388 in some later round @xmath389 , but since @xmath15 has been in the same state at the end of round @xmath376 in both @xmath378 and @xmath383 , it is also in the same state in round @xmath389 in both runs .",
    "hence , its decision contradicts the decision of @xmath16 in @xmath390 .",
    "we now use a more involved indistinguishability argument to show that a slightly weaker problem than consensus , namely , leader election is also impossible to solve uniformly under the message adversary @xmath341 . the classic leader election problem ( cf .",
    "@xcite ) assumes that , eventually , exactly one process irrevocably elects itself as leader ( by entering a special elected state ) and every other process elects itself as non - leader ( by entering the non - elected state ) .",
    "non - leaders are not required to know the process i d of the leader .    whereas it is easy to achieve leader election in our model when consensus is solveable , by just reaching consensus on the process ids in the system , the opposite is not true : since the leader elected by some algorithm need not be in the root component that exists when consensus terminates , one can not use the leader to disseminate a common value to all processes in order to solve consensus atop of leader election .",
    "[ thm : impossdiameterle ] there is no uniform algorithm that can solve leader election under the message adversary @xmath17 given in [ ass : window ] , for any @xmath1 .",
    "we assume that there is a uniform algorithm @xmath373 that solves the problem .",
    "consider the execution @xmath391 of @xmath373 in a static unidirectional chain of @xmath370 processes , headed by process @xmath16 with i d @xmath392 : since @xmath16 has only a single out - going edge and does not know @xmath11 , it can not know whether it has neighbors at all . since it might even be alone in the single - vertex graph consisting of @xmath16 only",
    ", it must elect itself as leader in any @xmath391 , @xmath393 , after some @xmath394 rounds ( @xmath394 may depend on @xmath392 , however , as we do not restrict @xmath373 to be time - bounded ) .",
    "let @xmath392 and @xmath395 be two arbitrary different process ids , and let @xmath394 resp.@xmath396 be the termination times in the executions @xmath391 resp .",
    "@xmath397 , for any @xmath370 , @xmath398 ; let @xmath399 .",
    "we now build a system consisting of @xmath400 processes .",
    "to do so we assume a chain @xmath401 of @xmath402 processes headed by @xmath16 ( with i d @xmath392 ) and ending in process @xmath403 , a second chain @xmath404 of @xmath402 processes headed by @xmath15 ( with i d @xmath395 ) and ending in process @xmath372 , and the process @xmath14 .",
    "now consider an execution @xmath405 , which proceeds as follows : for the first @xmath25 rounds , the communication graph is the unidirectional ring created by connecting the above chains with edges @xmath406 , @xmath407 and @xmath408 ; its root component clearly is the entire ring . starting from round @xmath402 on , process @xmath14 forms the single vertex root component , which feeds , through edges @xmath408 and @xmath409 the two chains @xmath404 and @xmath410 , with @xmath410 being @xmath401 with all edges reversed .",
    "note that , from round @xmath402 on , there is no edge connecting processes in @xmath401 with those in @xmath404 or vice versa .",
    "let @xmath302 be the process that is elected leader in @xmath405 .",
    "we distinguish 2 cases :    1 .",
    "if @xmath411 , then consider the execution @xmath412 that is exactly like @xmath405 , except that there is no edge @xmath406 during the first @xmath25 rounds : @xmath16 with i d @xmath392 is the single root component here .",
    "clearly , for @xmath16 , the execution @xmath412 is indistinguishable from @xmath413 during the first @xmath414 rounds , so it must elect itself leader .",
    "however , since no process in @xmath415 ( including @xmath416 ) is causally influenced by @xmath16 during the first @xmath25 rounds , all processes in @xmath417 have the same state after round @xmath25 ( and all later rounds ) in @xmath412 as in @xmath405 .",
    "consequently , @xmath302 also elects itself leader in @xmath412 as it does in @xmath405 , which is a contradiction .",
    "2 .   on the other hand ,",
    "if @xmath418 , we consider the execution @xmath419 , which is exactly like @xmath405 , except that there is no edge @xmath408 during the first @xmath25 rounds : @xmath15 with i d @xmath395 is the single root component here .",
    "clearly , for @xmath15 , the execution @xmath419 is indistinguishable from @xmath420 ( made up of the chain @xmath404 ) during the first @xmath421 rounds , so it must elect itself leader .",
    "however , since no process @xmath403 in @xmath422 ( including @xmath416 ) is causally influenced by @xmath15 during the first @xmath25 rounds , @xmath403 has the same state after round @xmath25 ( and all later rounds ) in @xmath419 as in @xmath405 .",
    "consequently , @xmath302 also elects itself leader @xmath419 as it does in @xmath405 , which is again a contradiction .",
    "this completes the proof of [ thm : impossdiameterle ] .",
    "the goal of this section is to show that root components @xmath105 must be vertex - stable sufficiently long for solving consensus in our model .",
    "in essence , what is needed for this purpose is that every member of the set @xmath108 of processes in @xmath105 is able to reach the entire network . recalling [ def : e - network - vertex - stable - roots ] , this requires @xmath109 to be at least @xmath19 and hence @xmath423 in [ ass : window ] .    in order to show that @xmath424 is indeed necessary in our setting",
    ", we will now consider a stronger message adversary @xmath425 given in [ ass : too - short ] below : it is stronger than @xmath424 as its stability interval is shorter , but still slightly weaker than @xmath426 , in that it also guarantees one process to be reached from the processes in @xmath108 within @xmath19 rounds , despite the too short stability interval @xmath104 .",
    "note carefully that , since there is only one such process , it would be reached if @xmath109 was actually @xmath19 .",
    "this property is formally captured by _ almost @xmath427-network - bounded _",
    "vsrcs introduced in [ def : almoste - network - vertex - stable - roots ] , which is slightly weaker than [ def : e - network - vertex - stable - roots ] in that @xmath104-vsrc s with @xmath428 are no longer arbitrary .",
    "[ def : almoste - network - vertex - stable - roots ] an @xmath104-vertex - stable root component @xmath105 with @xmath111 $ ] is _ almost @xmath427-network - bounded _ , with _",
    "dynamic network causal diameter _",
    "@xmath218 , if either @xmath429 or else @xmath430 $ ] there exists a unique @xmath245 with @xmath431 , while for all @xmath432 we have @xmath433 .    [ ass : too - short ] the message adversary @xmath425 is the set of all sequences of communication graphs @xmath283 , where    1 .   for every round @xmath14 , @xmath13 contains exactly one root component @xmath97 , 2 .   all vertex - stable root components",
    "@xmath105 occurring in any @xmath283 are @xmath19-network - bounded , 3 .   for each @xmath283 , there exists some @xmath338 and an interval of rounds @xmath434 $ ] with an almost @xmath427-network - bounded  @xmath340-vertex - stable root component .",
    "note carefully that [ ass : too - short ] allows the message adversary to choose _ any _ communication graph sequence that is consistent with the conditions stated therein .",
    "in particular , @xmath425 can choose a sequence of communication graphs that ensures a dynamic causal distance @xmath19 between _ any _ specific @xmath435 and @xmath15 in a vsrc with @xmath428 .",
    "moreover , we have the following [ lem : advrelation ] that relates our message adversaries :    [ lem : advrelation ] it holds that @xmath436 , so that every sequence of communication graphs generated by the message adversary @xmath424 is also feasible for @xmath425 .",
    "a comparison of [ ass : too - short ] and [ ass : window ] reveals that they differ only in item  ( iii ) .",
    "since almost @xmath427-network - bounded  is slightly weaker than @xmath19-network - bounded , as the adversary needs to guarantee a network causal distance @xmath437 of at most @xmath438 from every @xmath149 to every @xmath439 in the former , @xmath440 follows : after all , @xmath426 assumes a @xmath19-network - bounded  vsrc . on the other hand , [ ass : too - short ]",
    "does not forbid the message adversary to generate a sequence of communication graphs that adheres to [ ass : window ] with @xmath441 , which also confirms @xmath442 and completes our proof .",
    "we will now prove that the message adversary @xmath425 , and hence by [ lem : advrelation ] also @xmath21 , is too strong for solving consensus : processes can _ withold _ information from each other , which causes consensus to be impossible @xcite . in order to simplify our proof , we assume that the adversary has to fix the start of @xmath434 $ ] and the set of root members @xmath108 in the eventually generated root component @xmath443 before the beginning of the execution ( but given the initial values ) . note that this does not strengthen the adversary , and hence does not weaken our impossibility result : for deterministic algorithms , the whole execution depends only on the initial values and the sequence of the @xmath66 s , so the adversary could simulate the execution and determine every @xmath444 based on this .    [",
    "lem : neighbours - are - bivalent ] consider two runs of a consensus algorithm @xmath373 under message adversary @xmath425 , for some a priori fixed @xmath434 $ ] and set of processes @xmath108 in @xmath443 , which start from two univalent configurations @xmath445 and @xmath446 that differ only in the state of one process @xmath16 at the beginning of round @xmath14 .",
    "then , @xmath445 and @xmath446 can not differ in valency .",
    "the proof proceeds by assuming the contrary , i.e. , that @xmath445 and @xmath446 have different valency .",
    "we will then apply the same sequence of round graphs to extend the execution prefixes that led to @xmath445 and @xmath446 to get two different runs @xmath447 and @xmath448 .",
    "it suffices to show that there is at least one process @xmath15 that can not distinguish @xmath447 from @xmath448 : this implies that @xmath15 will eventually decide on the same value in both executions , which contradicts the assumed different valency of @xmath445 and @xmath446 .",
    "our choice of the round graphs depends on the following exhaustive cases :    1 .   for @xmath290",
    ", we let the adversary choose any root component @xmath449 consisting of the processes in @xmath108 , for all @xmath450 . obviously , every process ( i.e. , we can choose any ) @xmath155 has the same state throughout @xmath447 and @xmath448 .",
    "2 .   for @xmath149 and @xmath451 ,",
    "we choose any root component @xmath449 consisting of the processes in @xmath108 for @xmath452 , and @xmath453 for @xmath454 , where @xmath15 is the process that does not hear from any process in @xmath108 ( and hence from @xmath16 ) within @xmath340 according to [ def : almoste - network - vertex - stable - roots ] .",
    "hence , @xmath15 has the same state in @xmath447 and @xmath448 , both during @xmath340 and afterwards , where it is the single root .",
    "3 .   for @xmath149 and @xmath455",
    ", we choose graphs @xmath456 where @xmath453 and @xmath16 has only in - edges for @xmath457 ; @xmath15 ( satisfying @xmath458 and hence @xmath459 ) is again the `` distant '' process allowed by [ def : almoste - network - vertex - stable - roots ] . from @xmath460 on , we choose the same graphs @xmath456 as in case ( ii ) .",
    "it is again obvious that @xmath15 has the same state throughout @xmath447 and @xmath448 , since @xmath16 can not communicate to any process before @xmath340 and does not reach @xmath15 within @xmath340 .    in any case , for process @xmath15 , the sequence of states in the extensions starting from @xmath445 and @xmath446 is hence the same .",
    "therefore , the two runs are indistinguishable for @xmath15 , which can not hence decide differently .",
    "this provides the required contradiction to the different valencies of @xmath445 and @xmath446 .",
    "the next [ lem : graph - seq ] establishes connectedness of the successor graph of a configuration @xcite .",
    "[ lem : graph - seq ] for any two round @xmath14 graphs @xmath333 and @xmath461 , we can find a finite sequence of graphs @xmath462 , each with a single root component , where any two consecutive graphs differ only by at most one edge .",
    "we say that the configurations @xmath445 resp .",
    "@xmath446 reached by applying @xmath333 resp .",
    "@xmath461 to the same configuration @xmath463 are _ connected _ in this case .",
    "moreover , our construction guarantees that if the root components of @xmath333 and @xmath461 consist of the same set of processes @xmath464 , the same is true for all @xmath465 .",
    "first , we consider two cases with respect to the members @xmath466 and @xmath467 of the respective root components : ( a ) @xmath468 , ( b ) @xmath469 . moreover , for the second part of the proof , we also consider a special case of ( b ) : ( b ) @xmath470 .    for case ( b ) ( and thus also for ( b ) ) , we consider @xmath471 . for case",
    "( a ) , we construct @xmath472 from @xmath333 as follows : let @xmath473 and @xmath474 , then @xmath472 has the same edges as @xmath333 plus @xmath475 , thus @xmath476 ( recall that @xmath477 must be reachable from @xmath466 already in @xmath333 ) .",
    "so , now we have that in both cases @xmath333 and @xmath472 differ in at most one edge .",
    "moreover , there is a nonempty intersection between @xmath328 and @xmath467 .    in the first phase of our construction ( which continues as long as @xmath478 ) , we construct @xmath479 from @xmath480 , @xmath291 , by choosing one edge @xmath481 from @xmath482 and let @xmath479 have the same edges as @xmath465 plus @xmath483 .",
    "clearly , @xmath465 and @xmath479 differ in at most one edge . moreover",
    ", when adding an edge , we can not add an additional root component , so as long as we add edges we will have that @xmath479 has a single root component @xmath484 .",
    "when we reach a point in our construction where @xmath485 , the first phase ends .",
    "as @xmath465 now contains all the edges in @xmath461 , i.e. , @xmath486 , we have @xmath487 . in the second phase of the construction",
    ", we remove edges . to this end , we choose one edge @xmath481 from @xmath488 , and construct @xmath479 from @xmath465 by removing @xmath483 .",
    "again we have to show that there is only one root component .",
    "since we never remove an edge in @xmath489 , @xmath465 always contains a directed path from some @xmath490 to both @xmath80 and @xmath392 that only uses edges in @xmath489 . as @xmath491 ,",
    "this also holds for @xmath479 .",
    "since there is only one root component in @xmath461 , this implies that there is only one in @xmath479 .",
    "let @xmath492 be the last graph constructed in the first phase , and @xmath493 the last graph constructed in the second phase .",
    "it is easy to see that @xmath494 , which implies that @xmath495 and hence @xmath496 .",
    "this completes the proof of the first part of our lemma .    to see that the second part also holds , we consider case ( b ) in more detail and show by induction that @xmath497 . for the base case , we recall that @xmath498 and thus @xmath499 . for the induction step ,",
    "we consider first that the step involves adding an edge @xmath481 ( phase 1 ) : adding an edge can only modify the root component when @xmath500 and @xmath501 .",
    "since such an edge @xmath483 is not in @xmath489 ( as it has the same root component as @xmath502 ) , we can not select it for addition , so the root component does not change .",
    "if , on the other hand , the step from @xmath465 to @xmath479 involves removing the edge @xmath481 ( phase 2 ) , we only need to consider the case where @xmath503 .",
    "( if @xmath500 , then also @xmath504 so the root component can not change by removing @xmath483 . )",
    "but since we never remove edges from @xmath489 , this implies that even after removing @xmath483 there is still a path from @xmath80 to @xmath392 , so the root component can not have changed .",
    "the proof of the following impossibility result follows roughly along the lines of the proof of  ( * ? ? ?",
    "* lemma  3 ) .",
    "it shows , by means of induction on the round number , that a consensus algorithm @xmath373 can not reach a univalent configuration after any finite number of rounds .",
    "[ thm : consensusimp ] there is no algorithm that solves consensus under the message adversary @xmath425 , and hence none under @xmath21 .",
    "we follow roughly along the lines of the proof of  ( * ? ? ?",
    "* lemma 3 ) and show per induction on the round number , that no algorithm @xmath373 can reach a univalent configuration by round @xmath14 , for any @xmath36 . since no process can have decided in a bivalent configuration , this violates the termination property of consensus .    for the base case ,",
    "we consider binary consensus only and argue similar to  @xcite but make use of our stronger validity property : let @xmath505 be the initial configuration , where the processes with the @xmath138 smallest ids start with @xmath64 and all others with @xmath330 .",
    "clearly , in @xmath506 all processes start with @xmath330 and in @xmath507 all start with @xmath64 , so the two configurations are @xmath330- and @xmath64-valent , respectively . to see that for some @xmath138 @xmath505 must be bivalent , consider that this is not the case , then there must be a @xmath505 that is @xmath330-valent while @xmath508 is @xmath64-valent .",
    "but , these configurations differ only in @xmath509 , and so by [ lem : neighbours - are - bivalent ] they can not be univalent with different valency .    for the induction step",
    "we assume that there is a bivalent configuration @xmath463 at the beginning of round @xmath510 , and show that there is at least one such configuration at the beginning of round @xmath14 .",
    "we proceed by contradiction and assume all configurations at the beginning of round @xmath14 are univalent .",
    "since @xmath463 is bivalent and all configurations at the beginning of @xmath14 are univalent , there must be two configurations @xmath445 and @xmath446 at the beginning of round @xmath14 which have different valency . clearly , @xmath445 and @xmath446 are reached from @xmath463 by two different round @xmath510 graphs @xmath511 and @xmath512 .",
    "[ lem : graph - seq ] shows that there is a sequence of graphs such that @xmath445 and @xmath446 are connected .",
    "each pair of subsequent graphs in this sequence differs only in one link @xmath513 , such that the resulting configurations differ only in the state of @xmath392 .",
    "moreover , if the root component in @xmath333 and @xmath461 is the same , all graphs in the sequence also have the same root component .",
    "since the valency of @xmath445 and @xmath446 was assumed to be different , there must be two configurations @xmath514 and @xmath515 in the corresponding sequence of configurations that have different valency and differ only in the state of one process , say @xmath16 . applying [ lem :",
    "neighbours - are - bivalent ] to @xmath514 and @xmath515 again produces a contradiction , and so not all successors of @xmath463 can be univalent .",
    "we have hence established that @xmath425 is too strong for consensus , which implies the same for @xmath21 according to [ lem : advrelation ] .",
    "in this section , we show that it is possible to solve consensus under the message adversary @xmath517 given in [ ass : window ] .",
    "the underlying idea of our consensus algorithm is to use flooding to propagate the largest input value to everyone .",
    "however , as [ ass : window ] does not guarantee bidirectional communication between every pair of processes according to [ lem : classification ] , flooding is not sufficient : the largest input value could be hidden at a single process @xmath16 that never has outgoing edges .",
    "if such a leaf process @xmath16 would never accept smaller values , it is impossible to reach agreement ( without potentially violating validity ) .",
    "thus , we have to find a way to force @xmath16 to accept also a smaller value .    a well - known technique to do so is _ locking _ a candidate value .",
    "obviously , we do not want a leaf process to lock its value , but rather some process(es ) that will be able to impose their locked value , i.e. , can successfully flood the system .",
    "in addition , we may allow processes that have successfully locked a value to decide only when they are sure that every other process has accepted their value as well . according to [ def : e - network - vertex - stable - roots ] , both can be guaranteed when these processes have been in a vertex stable root component long enough which is ( amply ) guaranteed by @xmath517 .",
    "the first major ingredient of our consensus algorithm is a network approximation algorithm ( described in [ sec : approxalgo ] ) , which allows processes to detect their root membership in ( past ) rounds .",
    "the core of our consensus algorithm ( presented in [ sec : consensuscore ] ) then exploits this knowledge for reaching agreement on locked values and imposes the resulting value on all processes in the network . as we will see",
    ", the main complication comes from the fact that a process can detect whether it has been part of the root component of round @xmath14 only with some latency .      according to our system model",
    ", no process @xmath16 has any initial knowledge of the network . in order to learn about vsrcs , for example",
    ", it hence needs to _ locally _ acquire such knowledge . process @xmath16 achieves this by means of [ alg : approx ] , which maintains a _ network estimate _ @xmath518 in a local variable . of process @xmath16 in round @xmath14 _ before _ the round @xmath14 computation finishes as @xmath519 ; we usually suppress the superscript when it refers to the current round . ]",
    "@xmath518 is a graph that holds the local estimates of every communication graph @xmath66 that occurred so far , simply by labeling an edge @xmath520 with the set of round numbers of every @xmath66 once @xmath16 received evidence that @xmath520 was present in round @xmath14 .",
    "initially , @xmath518 consists of process @xmath16 only . in every round ,",
    "every process @xmath16 broadcasts its current @xmath518 and fuses it with the network estimates received from its neighbors . in more detail",
    ", @xmath16 updates @xmath518 whenever @xmath521 , by adding @xmath522 if @xmath15 is @xmath16 s neighbour for the first time , or by updating the label of the edge @xmath523 to @xmath524 ( [ line : addedge1 ] and  [ line : addedge2 ] ) .",
    "moreover , @xmath16 also receives @xmath525 from @xmath15 and uses this information to update its own knowledge : the loop in [ line : forloop ] ensures that @xmath16 has an edge @xmath526 for each @xmath527 in @xmath525 , where @xmath25 is the set of rounds previously known to @xmath16 .    given @xmath518 ,",
    "we use @xmath528 with @xmath330 for intervals that span at most the last @xmath529 rounds , i.e. , any older information could safely be removed from the approximation graph , resulting in a message complexity that is polynomial in @xmath11.]@xmath530 to denote the current estimate of @xmath531 contained in @xmath518 .",
    "formally , @xmath528 is the graph induced by the set of edges @xmath532 as the information about @xmath15 s neighbors in @xmath531 might take many rounds to reach some process @xmath16 ( if it ever arrives at @xmath16 ) , @xmath528 may never be fully up - to - date , and as only reported edges are added to the estimate ( but not all reports need to reach @xmath16 ) , @xmath528 will be an under - approximation of @xmath531 .",
    "for example , a process @xmath16 that does not have any incoming links from other processes , throughout the entire run of the algorithm , can not learn anything about the remaining network , i.e. , @xmath518 will permanently be the singleton graph .",
    "[ alg : approx ] finally provides an externally callable function @xmath533 , which will be used by the core consensus consensus algorithm to find out whether the calling process @xmath16 was member in an @xmath104-vsrc @xmath105 and to query the set of all members @xmath108",
    ". we will prove in [ lem : cpr2root ] below that the latter is the case if @xmath528 is strongly connected and consists of the same non - empty set @xmath108 of processes for all @xmath534 .",
    "informally , this is due to the fact that the members of an @xmath104-vsrc will not be able to acquire knowledge of the topology outside @xmath105 within @xmath104 , as they do not have incoming links from outside .",
    "provides externally callable function @xmath535 .",
    "* variables and initialization : *    @xmath536 initially @xmath537    * emit round @xmath14 messages : * send @xmath538 to all current neighbors    * round @xmath14 : computation : * replace @xmath483 with @xmath539 in @xmath540 where @xmath541 [ line : addedge1 ] add @xmath542 to @xmath540 [ line : addedge2 ] @xmath543 [ line : forloop ] replace @xmath544 in @xmath540 with @xmath545 ; add @xmath527 if no such edge exists [ line : forloopend ] let @xmath546 be induced graph of @xmath547 let @xmath548 be @xmath546 if it is strongly connected , or the empty graph otherwise.[line : cps ] return @xmath549 return @xmath550    we start our analysis of [ alg : approx ] with [ lem : asubsetg ] , which shows that @xmath528 underapproximates @xmath531 in a way that consistently includes neighborhoods .",
    "its proof uses the trivial invariant asserting @xmath551 at the end of every round @xmath552 .",
    "[ lem : asubsetg ] if @xmath528 contains @xmath513 at the end of some round @xmath14 , then ( i ) @xmath553 , i.e. , @xmath554 , and ( ii ) @xmath528 also contains @xmath555 for every @xmath556 .",
    "we first consider the case where @xmath552 , then at the end of round @xmath14 @xmath528 is empty , i.e. , there are no edges in @xmath528 . as the precondition of the lemma s statement is false",
    ", the statement is true .    for the case",
    "where @xmath557 , we proceed by induction on @xmath14 :    induction base @xmath558 : if @xmath528 contains @xmath513 at the end of round @xmath558 , it follows from @xmath559 at the end of every round @xmath552 , for every @xmath245 , that @xmath560 , since @xmath16 is the only processor that can have added this edge to its graph approximation . clearly , it did so only when @xmath561 , i.e. , @xmath562 , and included also @xmath555 for every @xmath563 on that occasion",
    ". this confirms ( i ) and ( ii ) .",
    "induction step @xmath564 , @xmath557 : assume , as our induction hypothesis , that ( i ) and ( ii ) hold for any @xmath565 at the end of round @xmath14 , in particular , for every @xmath566 .",
    "if indeed @xmath513 in @xmath528 at the end of round @xmath567 , it must be contained in the union of round @xmath14 approximations @xmath568 and hence in some @xmath569 ( @xmath570 or @xmath571 ) at the end of round @xmath14 .",
    "note that the edges ( labeled @xmath567 ) added in round @xmath567 to @xmath518 are irrelevant for @xmath528 here , since @xmath572 .",
    "consequently , by the induction hypothesis , @xmath562 , thereby confirming ( i ) . as for (",
    "ii ) , the induction hypothesis also implies that @xmath555 is also in this @xmath569 .",
    "hence , every such edge must be in @xmath573 and hence in @xmath528 at the end of round @xmath567 as asserted .",
    "the following [ lem : cpr2root ] shows that locally detecting @xmath528 to be strongly connected ( in [ line : cps ] of [ alg : approx ] ) implies that @xmath16 is in the root component of round  @xmath403 .",
    "this result rests on the fact that @xmath528 underapproximates @xmath531 ( [ lem : asubsetg].(i ) ) , but does so in a way that never omits an in - edge at any process @xmath574 ( [ lem : asubsetg].(ii ) ) .",
    "[ lem : cpr2root ] if the graph @xmath575 ( [ line : cps ] ) with @xmath576 is non - empty in round @xmath14 , then @xmath16 is member of @xmath577 , i.e. , @xmath149 .",
    "for a contradiction , assume that @xmath575 is non - empty ( hence @xmath528 is an scc by [ line : cps ] ) , but @xmath290 . since @xmath16 is always included in any @xmath518 by construction and @xmath528 underapproximates @xmath531 by [ lem : asubsetg].(i ) , this implies that @xmath528 can not be the root component of @xmath531 .",
    "rather , @xmath528 must contain some process @xmath392 that has an in - edge @xmath513 in @xmath531 that is not present in @xmath528 . as @xmath392 and hence some edge @xmath578",
    "is contained in @xmath528 , because it is an scc , [ lem : asubsetg].(ii ) reveals that this is impossible .    from the definition of the function @xmath533 in [ alg : approx ] and [ lem : cpr2root ] , we get the following [ cor : stable2root ] .",
    "[ cor : stable2root ] if the function @xmath533 evaluates to @xmath579 at process @xmath16 in round @xmath14 , then @xmath580 where @xmath581 , it holds that @xmath16 is a member of @xmath582 , i.e. , @xmath149 .",
    "the following [ lem : root2cpr ] proves that , in a sufficiently long @xmath111 $ ] with a @xmath104-vertex - stable root component @xmath105 , every member @xmath16 of @xmath105 detects an scc for round @xmath112 ( i.e. , @xmath583 ) with a latency of at most @xmath28 rounds ( i.e. , at the end of round @xmath584 ) . informally speaking , together with [ lem : cpr2root ] , it asserts that if there is an @xmath104-vertex - stable root component @xmath105 for a sufficiently long interval @xmath104 , then a process @xmath16 observes @xmath585 from the end of round @xmath584 on iff @xmath149 .",
    "[ lem : root2cpr ] consider an interval of rounds @xmath111 $ ] , such that there is a @xmath28-bounded   @xmath104-vertex - stable root component @xmath105 and assume @xmath586 .",
    "then , from the end of round @xmath584 onwards , we have @xmath587 , for every process in @xmath435 .",
    "consider any @xmath588 . at the beginning of round @xmath589",
    ", @xmath15 has an edge @xmath590 in its approximation graph @xmath525 with @xmath591 iff @xmath592 .",
    "since processes always merge all graph information from other processes into their own graph approximation , it follows from the definition of a @xmath28-bounded  @xmath104-vertex - stable root component ( [ def : d - bounded - vsrc ] ) in conjunction with the fact that @xmath593 that every @xmath435 has these in - edges of @xmath15 in its graph approximation by the end of round @xmath594 .",
    "since @xmath105 is a vertex - stable root - component , it is strongly connected without in - edges from processes outside @xmath105 .",
    "hence @xmath587 from the end of round @xmath584 on , as asserted .",
    "this immediately gives us the following [ cor : allrootdec ] , which ensures that in a sufficiently long @xmath104-vsrc @xmath105 , with @xmath111 $ ] and member set @xmath108 , every @xmath149 detects its membership in the @xmath340-vsrc @xmath443 , @xmath595 \\subseteq i$ ] , with a latency of at most @xmath28 rounds .",
    "[ cor : allrootdec ] consider an interval of rounds @xmath111 $ ] , with @xmath596 , such that there is a @xmath28-bounded  vertex - stable root component @xmath105 .",
    "then , from the end of round @xmath113 on , a call to @xmath597)$ ] returns @xmath108 at every process in @xmath108 .    together , [ cor : stable2root , cor : allrootdec ] reveal that @xmath598 _ precisely _ characterizes the caller s actual membership in the @xmath599$]-vsrc @xmath105 in the communication graphs from the end of round @xmath113 on .",
    "* variables and initialization : *    @xmath600 , initially own input value @xmath601 initially @xmath602 @xmath603 initially @xmath330    * emit round @xmath14 messages : * send @xmath604 to all neighbors [ line : senddec ] send @xmath605 to all neighbors    * round @xmath14 computation : * [ line : secondif ] [ line : firstif ] @xmath606 decide on @xmath607 and set @xmath608[line : decother ]    @xmath609 [ line : updatexp ] @xmath610 @xmath611 [ line : lock ] decide on @xmath607 and set @xmath608 [ line : decideown ] [ line : decown ] @xmath612    as explained in [ sec : consensus ] , the core consensus algorithm stated in [ alg : consensus ] builds upon the network approximation algorithm given as [ alg : approx ] : relying on [ cor : stable2root ] , every process uses @xmath613 provided by [ alg : approx ] to detect whether it has been in the vertex - stable root component of some past round(s ) .",
    "since [ cor : allrootdec ] reveals that @xmath613 has a latency of up to @xmath614 rounds for reliably detecting that a process is in the vertex - stable root component of some ( interval of ) rounds , our algorithm ( conservatively ) looks back @xmath28 rounds in the past when locking a value .    in more detail , [ alg : consensus ] proceeds as follows : initially , no process has locked a value , that is , @xmath615 and @xmath616 .",
    "processes try to detect whether they are privileged by evaluating the condition in [ line : if - g ] .",
    "when this condition is true in some round @xmath302 , they lock the current value ( by setting @xmath617 and @xmath618 to the current round ) , unless @xmath619 is already @xmath620 . note that our locking mechanism does not actually protect the value against being overwritten by a larger value being also locked in @xmath302",
    "; it locks out only those values that have older locks @xmath621 .",
    "when the process @xmath370 that had the largest value in the root component of round @xmath302 detects that it has been in a vertex - stable root component in all rounds @xmath302 to @xmath622 ( [ line : if - lock - heard ] ) , it can decide on its current value . as all other processes in that root component must have had @xmath370 s value imposed on them , they can decide as well . after deciding ,",
    "a process stops participating in the flooding of locked values , but rather ( [ line : senddec ] ) floods the network with @xmath623 .",
    "since the stability window guaranteed by [ ass : window ] with @xmath624 is large enough to allow every process to receive this message , all processes will eventually decide .",
    "before we turn our attention to the correctness proof of [ alg : consensus ] , we need to define how the network approximation algorithm and the core consensus algorithm are combined to form a joint algorithm in our computation model .",
    "informally , we assume that ( i ) the complete round @xmath14 computing step of the network approximation algorithm is executed just before the round @xmath14 computing step of the consensus algorithm , and that ( ii ) the round  @xmath14 message of the former is piggybacked on the round  @xmath14 message of the latter .",
    "consequently , the round @xmath14 computing step of the consensus core algorithm , which terminates round  @xmath14 , can already access the _ result _ of the round @xmath14 computation of the network approximation algorithm , i.e. , its state at the _ end _ of round @xmath14 .",
    "consequently , [ cor : stable2root , cor : allrootdec ] reveal that a call to @xmath533 with @xmath625 $ ] by @xmath16 in the transition function of round @xmath113 ( or later ) returns @xmath626 _ precisely _ when a vsrc @xmath105 containing @xmath16 existed .",
    "formally , let @xmath627 , @xmath628 , @xmath629 , @xmath630 be the set of states , message alphabet , transition function , and message sending function of the network approximation algorithm , with @xmath631 , @xmath632 and @xmath633 denoting its state at the beginning of round @xmath14 , the message sent in round @xmath14 , and the set of messages received in round @xmath14 .",
    "analogously , let @xmath634 , @xmath635 , @xmath636 , @xmath637 , @xmath638 , @xmath639 and @xmath640 be the corresponding entities for the core consensus algorithm ; note that @xmath641 , albeit the core consensus algorithm only reads ( but never writes ) the graph approximation @xmath518 ( when calling @xmath613 ) .    for the joint algorithm , we define the joint state space as @xmath642 and the joint message alphabet as @xmath643 .",
    "we assume that there are projection functions @xmath644 resp .",
    "@xmath645 which , given @xmath646 , can be used to obtain the corresponding @xmath647 resp .",
    "the joint message sending function @xmath649 just computes the pair of messages @xmath650 via @xmath651 and @xmath652 .",
    "the joint transition function @xmath653 first applies @xmath629 to @xmath654 to compute ( i ) @xmath655 and ( ii ) an intermediate state @xmath656 that is identical to @xmath638 except that @xmath657 is replaced by the newly computed @xmath658 .",
    "@xmath636 is then applied to @xmath656 to compute the state @xmath659 , which finally results in @xmath660 .",
    "all this happens atomically and instantaneously at the round switching time .",
    "our correctness proof starts with the validity property of consensus according to [ def : consensus ] .",
    "[ lem : validity ] every decision value is the input value of some process .",
    "processes decide either in [ line : decother ] or in [ line : decown ] .",
    "when a process decides via the former case , it has received a @xmath661 message , which is sent by @xmath15 iff @xmath15 has decided on @xmath662 in an earlier round . in order to prove validity , it is thus sufficient to show that processes can only decide on some process input value when they decide in [ line : decown ] , where they decide on their current estimate @xmath663 .",
    "let the round of this decision be @xmath14 .",
    "the estimate @xmath663 is either @xmath16 s initial value , or was updated in some round @xmath664 in [ line : updatexp ] from a value received by way of one of its neighbors @xmath665 message . in order to send such a message , @xmath15 must have had @xmath666 at the beginning of round @xmath667 , which in turn means that @xmath662 was either @xmath15 s initial value , or @xmath15 has updated @xmath662 after receiving a message in some round @xmath668 . by repeating this argument , we will eventually reach a process that sent its initial value , since no process can have updated its decision estimate prior to the first round .",
    "the following [ lem : assorted - properties ] states a number of properties maintained by our algorithm when the first process @xmath16 has decided .",
    "essentially , they say that there has been a vertex - stable root component in the interval @xmath669 $ ] centered around the lock round @xmath302 ( but not earlier ) , and asserts that all processes in that root component chose the same lock round @xmath302 .",
    "[ lem : assorted - properties ] suppose that process @xmath16 decides in round @xmath14 , no decisions occurred before @xmath14 , and @xmath670 , then    * @xmath16 is in the vertex - stable root component @xmath105 with @xmath669 $ ] and member set @xmath108 , * @xmath671 , * @xmath672 , where @xmath466 is the members set of the vsrc @xmath673 , and * all processes in @xmath108 executed [ line : lock ] in round @xmath302 , and no process in @xmath674 can have executed [ line : lock ] in a round @xmath675 .    item ( i ) follows since [ line : if - g ] has been continuously @xmath620 since round @xmath302 and from [ lem : cpr2root ] .",
    "as for item ( ii ) , @xmath676 follows from the requirement of [ line : if - lock - heard ] , while @xmath677 follows from ( i ) and the fact that by [ lem : root2cpr ] the requirement of [ line : if - lock - heard ] can not be , for the first time , fullfilled strictly after round @xmath678 . from [ lem : root2cpr ] , it also follows that if @xmath679 , then the condition in [ line : if - g ] would return true already in round @xmath680 , thus locking would occur already in round @xmath680 .",
    "since @xmath16 did not lock in round @xmath680 , ( iii ) must hold .",
    "finally , from ( i ) , ( iii ) , and [ lem : root2cpr ] , it follows that every other process in @xmath108 also has @xmath681)=\\true$ ] in round @xmath302 . moreover , due to ( iii ) ,",
    "@xmath682)=\\false$ ] in round @xmath680 , which causes all the processes in @xmath108 ( as well as those in @xmath674 ) to set @xmath618 to 0 . since @xmath683)$",
    "] can not become true for any @xmath684 at a process @xmath685 , as @xmath686 for any @xmath687 by [ cor : stable2root ] , ( iv ) also holds .",
    "the following [ lem : highlander ] asserts that if a process decides , then it has successfully imposed its proposal value on all other processes .",
    "[ lem : highlander ] suppose that process @xmath16 decides in [ line : decideown ] in round @xmath14 and that no other process has executed [ line : decideown ] before @xmath14 .",
    "then , for all @xmath15 , it holds that @xmath688 .    using items ( i ) and ( iv ) in [ lem : assorted - properties ]",
    ", we can conclude that @xmath16 was in the vertex - stable root component of rounds @xmath670 to @xmath622 and that all processes in it member set @xmath108 have locked in round @xmath302 .",
    "therefore , in the interval @xmath689 $ ] , @xmath302 is the maximal value of @xmath618 .",
    "more specifically , all processes @xmath15 in @xmath108 have @xmath690 , whereas all processes @xmath372 in @xmath691 have @xmath692 during these rounds by [ lem : assorted - properties].(iv ) .",
    "let @xmath693 have the largest proposal value @xmath694 among all processes in @xmath108 .",
    "since @xmath370 is in @xmath108 , there is a causal chain of length at most @xmath19 from @xmath370 to any @xmath245 .",
    "note carefully that guaranteeing this property requires item",
    "( ii ) of [ ass : window ] , as the first decision ( in round @xmath14 ) need not occur in the eventually guaranteed @xmath695-vsrc but already in some earlier `` spurious '' vsrc .    since no process executed [",
    "line : decideown ] before round @xmath14 , no process will send @xmath696 messages in @xmath689 $ ] .",
    "thus , all processes continue to execute the update rule of [ line : updatexp ] , which implies that @xmath697 will propagate along the aforementioned causal path to @xmath15 .",
    "[ thm : consensus ] let @xmath698 be the beginning of the stability window guaranteed by the message adversary @xmath517 given in [ ass : window ] .",
    "then , [ alg : consensus ] in conjunction with [ alg : approx ] solves consensus by the end of round @xmath699 .",
    "validity holds by [ lem : validity ] . considering [ lem : highlander ]",
    ", we immediately get agreement : since the first process @xmath16 that decides must do so via [ line : decown ] , there are no other proposal values left in the system .",
    "observe that , so far , we have not used the liveness part of [ ass : window ] .",
    "in fact , [ alg : consensus ] is always safe in the sense that agreement and validity are not violated , even if there is no vertex - stable root component .",
    "we now show the termination property . by [ cor : allrootdec ] , we know that every process in @xmath149 evaluates the predicate @xmath700)=\\true$ ] in round @xmath701 , thus locking in that round .",
    "furthermore , [ ass : window ] and [ cor : allrootdec ] imply that at the latest in round @xmath702 every process @xmath149 will evaluate the condition of [ line : if - lock - heard ] to @xmath620 and thus decide using [ line : decown ] .",
    "thus , every such process @xmath16 will send out a message @xmath703 . by [ def : e - network - vertex - stable - roots ] and [ ass : window ] , we know that every @xmath245 will receive a @xmath696 message at the latest in round @xmath704 and decide by the end of this round .",
    "in this section , we will turn our attention from consensus to general @xmath2-set agreement and prove related impossibility results and lower bounds .",
    "we will accomplish this by showing that certain `` natural '' message adversaries do not allow to solve @xmath2-set agreement .",
    "for example , as excessive partitioning of the system into more than @xmath2 root components makes @xmath2-set agreement trivially impossible , one natural assumption is to restrict the maximum number of root components per round in our system to @xmath2 .    [",
    "ass : inter ] below defines the generic message adversary @xmath0 , which allows at most @xmath2 vsrcs per round and guarantees a common window of vertex stability of duration at least @xmath1 .",
    "note that it implicitly involves both the dynamic causal diameter @xmath28 and the dynamic network causal diameter @xmath705 according to [ def : d - bounded - vsrc ] and [ def : e - network - vertex - stable - roots ] ( that have be enforced by the message adversary ) .",
    "[ ass : inter ] the message adversary @xmath0 is the set of all sequences of communication graphs @xmath283 , where    1 .   for every round @xmath14 , @xmath13 contains at most @xmath2 root components , 2 .",
    "all vertex - stable root components occurring in any @xmath283 are @xmath28-bounded , 3 .   for each @xmath283",
    ", there exists some @xmath338 and an interval of rounds @xmath339 $ ] where @xmath706 @xmath19-network - bounded  vertex - stable root components @xmath707 exist simultaneously .",
    "like for [ ass : window ] , item  ( ii ) has only been added for the sake of the @xmath2-set agreement algorithm ( [ alg : ksa ] ) ; the impossibility results and lower bounds also hold when ( ii ) is dropped or replaced by something that does not affect item  ( iii ) .",
    "observe that @xmath708 is the same as @xmath17 except that item  ( ii ) requires all vsrcs to be @xmath28-bounded  instead of @xmath19-network - bounded .",
    "note also that the message adversary @xmath709 guarantees at most @xmath2 vsrcs in every @xmath13 , @xmath36 .",
    "we will now prove that it is impossible to solve @xmath2-set agreement for @xmath710 under the message adversary @xmath711 , even under the slightly weaker version of this message adversary stated in [ thm : d - static - roots ] below .",
    "we will use the generic impossibility theorem provided in ( * ? ? ?",
    "1 ) for this purpose . in a nutshell ,",
    "the latter exploits the fact that @xmath2-set agreement is impossible if @xmath2 sufficiently disconnected components may occur and consensus can not be solved in some component .",
    "we first introduce the required definitions : two executions of an algorithm @xmath712 are _ indistinguishable _ ( until decision ) for a set of processes @xmath713 , denoted @xmath714 , if for any @xmath715 it holds that @xmath16 executes the same state transitions in @xmath262 and in @xmath405 ( until it decides ) .",
    "now consider a model of a distributed system @xmath716 that consists of the set of processes @xmath67 and a _ restricted model _ @xmath717 that is computationally compatible to @xmath43 ( i.e. , an algorithm designed for a process in @xmath43 can be executed on a process in @xmath718 ) and consists of the set of processes @xmath719 .",
    "let @xmath373 be an algorithm that works in system @xmath716 , where @xmath720 denotes the set of runs of algorithm @xmath373 on @xmath43 , and let @xmath721 be a nonempty set of processes .",
    "given any restricted system @xmath722 , the _ restricted algorithm _",
    "@xmath723 for system @xmath718 is constructed by dropping all messages sent to processes outside @xmath713 in the message sending function of @xmath373 .",
    "we also need the following similarity relation between runs in computationally compatible systems ( cf .",
    "* definition 3 ) ) : let @xmath724 and @xmath725 be sets of runs , and @xmath713 be a non - empty set of processes .",
    "we say that _ runs @xmath725 are compatible with runs @xmath724 for processes in @xmath713 _ , denoted by @xmath726 , if @xmath727 .    [ thm : impossibility ] let @xmath728 be a system model and consider the runs @xmath729 that are generated by some fixed algorithm @xmath72 in @xmath730 , where every process starts with a distinct input value .",
    "fix some nonempty and pairwise disjoint sets of processes @xmath731 , and a set of distinct decision values @xmath732 .",
    "moreover , let @xmath733 and @xmath734 .",
    "consider the following two properties :    * for every set @xmath735 , value @xmath736 was proposed by some @xmath737 , and there is some @xmath738 that decides @xmath736 . * if @xmath739 then @xmath93 receives no messages from any process in @xmath713 until every process in @xmath740 has decided .",
    "let @xmath741 and @xmath742 be the sets of runs of @xmath72 where ( dec-@xmath740 ) respectively both , ( dec-@xmath713 ) and ( dec-@xmath740 ) , hold . is by definition compatible with the runs of the restricted algorithm @xmath743 . ]",
    "suppose that the following conditions are satisfied :    @xmath744 is nonempty .",
    "@xmath745 .",
    "in addition , consider a restricted model @xmath746 such that the following properties hold :    there is no algorithm that solves consensus in @xmath747 .",
    ".    then , @xmath72 does not solve @xmath2-set agreement in @xmath730 .",
    "the proof of [ thm : d - static - roots ] below utilizes [ thm : impossibility ] in conjunction with the impossibility of consensus under @xmath21 established in [ thm : consensusimp ] .",
    "[ thm : d - static - roots ] there is no algorithm that solves @xmath2-set agreement with @xmath749 processes under the message adversary @xmath711 stated in [ ass : inter ] , for any @xmath750 , even if there are @xmath23 root components @xmath751 that are vertex - stable all the time , i.e. , in @xmath752 $ ] ( and only root component @xmath753 is vertex - stable for at most @xmath754 rounds ) .",
    "suppose that there is a @xmath2-set algorithm @xmath373 that works correctly under the assumptions of our theorem . for @xmath10 , [ thm : d - static - roots ]",
    "is implied by [ thm : consensusimp ] , since @xmath5 is the same as @xmath755 if item  ( ii ) is dropped in both definitions .    to prove the theorem for @xmath756 , we will show that the conditions of the generic [ thm : impossibility ] are satisfied , thereby providing a contradiction to the assumption that @xmath373 exists .",
    "let @xmath757 for @xmath758 and let @xmath759 .",
    "consequently , @xmath740 = @xmath760 and @xmath761 .    *",
    "( a ) * the set of runs @xmath762 of @xmath373 where no process in @xmath740 receives any message from @xmath713 before it dedices is nonempty : we choose the communication graph in every round to be such that @xmath740 has no incoming links from @xmath713 until every process in @xmath740 has decided . since any such sequence of communication graphs satisfies the assumptions of our theorem , @xmath763 .    *",
    "( b ) * the set of runs @xmath764 of @xmath373 where both ( i ) some process in every @xmath765 decides @xmath736 and ( ii ) no process in @xmath740 receives any message from @xmath713",
    "before it decides satisfies @xmath766 : let @xmath767 be the set of runs where processes @xmath33 have unique input values @xmath768 , @xmath769 , the communication graph in every round is such that @xmath770 are isolated , and @xmath771 are weakly connected ( with a single root ) until every process has decided . by the assumptions of our theorem ,",
    "@xmath767 is non - empty .",
    "since ( i ) the processes in @xmath740 never receive a message from a process in @xmath713 in both @xmath744 and @xmath767 , and ( ii ) the initial values of the processes in @xmath740 are not restricted in @xmath767 in any way , it is easy to find , for any run @xmath772 , a run @xmath773 such that @xmath774 . because obviously @xmath775 , we have established @xmath776 .    *",
    "( c ) * consensus is impossible in @xmath777 : let @xmath740 be the partition containing the @xmath2^th^ root component @xmath753 , which is perpetually changing in every round , except for some interval of rounds @xmath778 $ ] , where @xmath779 , for some fixed @xmath698 . during this interval , let the topology of @xmath740 be such that there exists some @xmath780 and some @xmath781 with @xmath782 . since @xmath783 , such a topology ( e.g.  a chain with head @xmath16 and tail @xmath15 ) can be created by the message adversary @xmath21 underlying [ thm : consensusimp ] exists . hence , consensus is impossible in @xmath740 .    *",
    "( d ) * @xmath784 : fix any run @xmath785 and consider a run @xmath786 , where every process in @xmath740 has the same sequence of state transitions in @xmath787 as in @xmath788 .",
    "such a run @xmath787 exists , since the processes in @xmath740 can be disconnected from @xmath713 in every round in @xmath720 , so @xmath774 .    since [ thm : d - static - roots ] tells us that no @xmath2-set agreement algorithm ( for @xmath750 ) can _ terminate _ with insufficient concurrent stability of the at most @xmath2 root components in the system , it is tempting to assume that @xmath2-set agreement becomes solvable if a round exists after which all communication graphs remain the same .",
    "however , we will prove in [ thm : rgst - impossibility ] below that this is not the case for any @xmath789 .",
    "we will again use the generic [ thm : impossibility ] , this time in conjunction with the variant of the well - known impossibility of consensus with lossy links @xcite provided in [ lem : lossylink - simulation ] , to prove that ensuring at most @xmath2 different decision values is impossible here , as too many decision values may originate from the unstable period .",
    "[ lem : lossylink - simulation ] let @xmath790 be a two - processor subsystem of our system @xmath791 .",
    "if the sequence of communication graphs @xmath13 , @xmath36 , of @xmath43 are restricted by the existence of a round @xmath792 such that ( i ) for @xmath793 , @xmath794 and/or @xmath795 , and no other edges incident with @xmath16 or @xmath15 are in @xmath13 , and ( ii ) for @xmath796 , there are no edges incident with @xmath16 and @xmath15 at all in @xmath13 , then consensus is impossible in @xmath718 .",
    "up to @xmath667 , this is ensured by the impossibility of 2-processor consensus with a lossy but at least unidirectional link established in ( * ? ? ? * lemma 3 ) .",
    "after @xmath667 , this result continues to hold ( and is even ensured by the classic lossy link impossibility @xcite ) .",
    "hence , consensus is indeed impossible in @xmath718 .",
    "[ thm : rgst - impossibility ] there is no algorithm that solves @xmath2-set agreement for @xmath797 processes under the message adversary @xmath798 , for every @xmath799 .",
    "suppose again that there is a @xmath2-set algorithm @xmath373 that works correctly under the assumptions of our theorem .",
    "we restrict our attention to runs of @xmath720 where , until @xmath800 , ( i ) the same set of @xmath23 root components @xmath801 with @xmath759 exists in every round , and ( ii ) two remaining processes @xmath802 exist , which are ( possibly only uni - directionally , i.e. , via a lossy link ) connected in every round , without additional edges to or from @xmath713 .",
    "after @xmath800 , the communication graph remains the same , except that the processes in @xmath740 are disconnected from each other and there is an edge from , say , @xmath803 to some process in @xmath713 in every round .",
    "note that these runs satisfy [ ass : inter ] for @xmath804 , as the number of root components never exceeds @xmath2 .",
    "moreover , we let the adversary choose @xmath800 sufficiently large such that the processes in @xmath713 have decided .",
    "since the processes in @xmath735 ( @xmath805 ) never receive a message from the remaining system before @xmath800 , in which case they must eventually unilaterally decide , we can safely assume this .",
    "we can now again employ the generic impossibility in this modified setting .",
    "the proofs of properties ( a ) , ( b ) and ( d ) remain essentially the same as in [ thm : d - static - roots ] .",
    "it hence only remains to prove :    consensus is impossible in @xmath777 : this follows immediately from [ lem : lossylink - simulation ] with @xmath806 .",
    "the following [ thm : strong - rgst - impossibility ] reveals that even ( considerably ) less than @xmath2 root components per round before stabilization and a single perpetually stable root component after stabilization are not sufficient for solving @xmath2-set agreement .",
    "[ thm : strong - rgst - impossibility ] there is no algorithm that solves @xmath2-set agreement for @xmath797 processes under the message adversary @xmath807 , for every @xmath799 , even if @xmath808 , @xmath809 , where @xmath100 contains only a single root component .",
    "we show that , under the assumption that @xmath373 exists , there is a sequence of communication graphs that is feasible for our message adversary that leads to a contradiction .",
    "we choose @xmath768 for all @xmath31 and let @xmath810 for @xmath811 .",
    "if @xmath2 is even , let @xmath812 ; if @xmath2 is odd , let @xmath813 . in any case , let @xmath814 .",
    "finally , let @xmath815 .",
    "note that @xmath740 may be empty , while all @xmath735 are guaranteed to contain at least one process since @xmath816 .",
    "for all rounds , the processes in @xmath740 have an incoming edge from a process in one of the @xmath735 .",
    "we split the description of the adversarial strategy into @xmath817 phases in each of which we will force some @xmath735 to take @xmath818 decisions . to keep processes @xmath819 with @xmath820 from deciding on the same value before their respective phase @xmath32",
    ", the adversary restricts @xmath13 such that ( i ) there are no links to @xmath735 from any other @xmath821 and ( ii ) either the edge @xmath116 or @xmath822 or both are in @xmath13 , in a way that causes [ lem : lossylink - simulation ] to apply .",
    "note carefully that any such @xmath13 indeed has no more than @xmath823 root components .    in the initial phase",
    ", @xmath824 is forced to decide : since @xmath825 has no incoming edges from another node in @xmath13 , this situation is indistinguishable from a run where @xmath825 became the single root after @xmath800 .",
    "thus , by the correctness of @xmath373 , @xmath825 must eventually decide on @xmath826 . at this point ,",
    "the initial phase ends , and we can safely allow the adversary to modify @xmath13 in such a way that @xmath825 has an incoming edge from some other process .",
    "we now proceed with @xmath827 phases : in the @xmath32^th^ phase , @xmath811 , the adversary drops any link between the processes @xmath828 ( and does not provide an incoming link from any other process , as before ) in any @xmath13 .",
    "since , for both @xmath16 and @xmath15 , this is again indistinguishable from the situation where they become the single root after @xmath800 , both will eventually decide in some future round ( if they have not already decided ) .",
    "since the adversary may have chosen a link failure pattern in earlier phases that causes the impossibility (= forever bivalent run ) of [ lem : lossylink - simulation ] to apply , as @xmath829 , it follows that @xmath373 and hence @xmath830 can not have solved consensus in @xmath735 .",
    "since @xmath373 solves @xmath2-set agreement , @xmath16 and @xmath15 must hence decide on two _ different _ values .",
    "moreover , since neither @xmath16 nor @xmath15 ever received a message from a process not in @xmath735 , their decision values must be different from the ones in all former phases .",
    "finally , after @xmath16 and @xmath15 have made their decisions , the adversary may again modify @xmath13 such that they have an incoming edge from some other process , thereby reducing the number of root components by two and preserving the maximum number @xmath823 of root components , and continue with the next phase .",
    "if @xmath2 is even , then the final phase @xmath827 forces two more decisions just as described above ; otherwise , @xmath831 provides one additional decision value ( which happens concurrently with the initial phase here ) . in either case",
    ", we have shown that all @xmath33 with @xmath832 have decided on different values , which contradicts the assumption that a correct algorithm @xmath373 exists .",
    "note that [ thm : strong - rgst - impossibility ] reveals an interesting gap between @xmath201-set agreement and 1-set agreement , i.e. , consensus : it shows that @xmath201-set agreement is impossible with @xmath833 root components per round before and a single fixed root component after stabilization .",
    "by contrast , if we reduce the number of root components per round to a single one before stabilization ( and still consider a single fixed root thereafter ) , even @xmath64-set agreement becomes solvable  @xcite .",
    "in this section , we will provide a message adversary @xmath9 ( [ ass : stablestream ] ) that is sufficiently weak for solving @xmath2-set agreement if combined with @xmath834 ( [ ass : inter ] ) .",
    "although we can of course not claim that it is a strongest one in terms of problem solvability ( we did not even define what this means ) , we have some indications that it is close to the solvability / impossibility border .      to illustrate some of the ideas that will be used in our message adversary for general @xmath2-set agreement , we start with the simple case of @xmath20-set agreement ( also called _ set agreement _ ) first .",
    "note that [ thm : d - static - roots ] does not apply here . to circumvent the impossibility result of [ thm : strong - rgst - impossibility ]",
    ", it suffices to strengthen the assumption of at most @xmath20 root components in every round such that the generation of too many decision values during the unstable period is ruled out . a straightforward way to achieve",
    "this is to just forbid @xmath11 different decisions obtained in root components consisting of a single process .",
    "achieving this is easy under the @xmath835-influence message adversary given in [ asm : influenceset ] , the name of which has been inspired by the @xmath835 failure detector @xcite .",
    "[ asm : influenceset ] the message adversary @xmath836  is the set of all sequences of communication graphs @xmath283 , where in any set @xmath837 of @xmath11 root components consisting of single processes @xmath838 , @xmath839 , occuring in any run the following holds : there are two indices @xmath32 , @xmath840 such that @xmath841 _ influences _",
    "@xmath842 , denoted @xmath843 , in the sense that there exists a causal chain starting after @xmath844 that ends before or at the beginning of @xmath845 .",
    "it is easy to devise a set agreement algorithm that works correctly in a dynamic network under [ asm : influenceset ] , provided ( a bound on ) @xmath11 is known : in [ alg : setagreement ] , process @xmath33 maintains a proposal value @xmath736 , initially @xmath846 , and a decision value @xmath847 , initially @xmath848 , which are broadcast in every round .",
    "if @xmath33 receives no message from any other process in a round , it decides by setting @xmath849 . if @xmath33 receives a message from some @xmath93 that has already decided ( @xmath850 ) , it sets @xmath851 .",
    "otherwise , it updates @xmath736 to the maximum of @xmath736 and all received values @xmath852 . at the end of round @xmath11 , a process that has not yet decided sets @xmath853 , and all processes terminate .",
    "* set agreement algorithm , code for process @xmath33 : * @xmath854 // initial value @xmath855    * emit round @xmath14 messages : * send @xmath856 to all    * receive round @xmath14 messages : * receive @xmath857 from all current neighbors    * round @xmath14 : computation : * @xmath858 @xmath859 @xmath853 @xmath853 ; terminate    [ thm : setagreement ] [ alg : setagreement ] solves @xmath20-set agreement in a dynamic network under message adversary @xmath836  given in [ asm : influenceset ] .",
    "termination ( after @xmath11 rounds ) and also validity are obvious , so it only remains to show @xmath20-agreement .",
    "assume , w.l.o.g .",
    ", that the processes @xmath860 are ordered according to their initial values @xmath861 , and let @xmath862 be the set of different values ( in @xmath847 or , if still @xmath863 , in @xmath736 ) present in the system at the beginning of round @xmath864 ; @xmath865 is the set of initial values .",
    "obviously , @xmath866 , and since @xmath20-agreement is fulfilled if @xmath867 , we only need to consider the case where all @xmath846 are different",
    ".    consider process @xmath803 : if @xmath803 gets a message from some other process @xmath93 in round 1 , @xmath868 as ( i ) @xmath803 does not decide on its own value and sets @xmath869 and ( ii ) no process that receives a message containing @xmath870 from @xmath803 takes on this value .",
    "hence , @xmath20-set agreement will be achieved in this case .",
    "otherwise , @xmath803 does not get any message in round 1 and hence decides on @xmath870 .    proceeding inductively ,",
    "assume that @xmath871 has decided on @xmath872 by round @xmath873 , and received only messages from processes with smaller index in rounds @xmath874 and no message in round @xmath2 .",
    "now consider process @xmath33 : if @xmath33 gets a message from some process @xmath93 with @xmath875 in some round @xmath876 , with minimal @xmath2 , before it decides , then @xmath877 as ( i ) @xmath33 does not decide on its own value and sets @xmath878 , ( ii ) @xmath33 did not send its value to any process in @xmath879 before their decisions , and ( iii ) no process with index larger than @xmath32 that receives a message containing @xmath846 from @xmath33 takes on this value . hence , @xmath20-set agreement will be achieved in this case . otherwise ,",
    "if @xmath33 gets a message from some process @xmath880 in round @xmath32 , it will decide on @xmath881 s decision value @xmath872 and hence also cause @xmath882 . in the only remaining case , @xmath33 does not get any message in round @xmath32 and hence decides on @xmath846 , which completes the inductive construction of @xmath883 for @xmath884 .",
    "now consider @xmath885 in round @xmath11 in the above construction of @xmath886 : [ asm : influenceset ] prohibits the only case where @xmath20-agreement could possibly be violated , namely , when @xmath885 also decides on @xmath887 : during the first @xmath11 rounds , we would have obtained @xmath11 single - node root components no two of which influence each other in this case .",
    "thus , we can not extend the inductive construction of @xmath888 to @xmath889 , as the resulting execution would be infeasible .      whereas the set agreement solution introduced in the previous subsection",
    "is simple , it is apparent that [ asm : influenceset ] is quite demanding . in particular",
    ", it requires explicit knowledge of ( a bound on ) @xmath11 .",
    "we will now provide a message adversary @xmath9 ( [ ass : stablestream ] ) , which is sufficient for general @xmath2-set agreement if combined with @xmath834 ( [ ass : inter ] ) .",
    "we obtained this combination by adding some additional properties to the necessary network conditions implied by our impossibility [ thm : d - static - roots , thm : strong - rgst - impossibility].-set agreement could be to generalize [ asm : influenceset ] : one could e.g.  assume that at least two out of every set of @xmath20 different root components consisting of 1 or 2 processes are influenced by a common predecessor root component .",
    "whereas this assumption does not require vertex stability of root components , it effectively ensures that information propagates not slower as in vsrcs .",
    "owing to this fact , it also prohibits the existence of the node @xmath15 in [ ass : too - short ] with causal distance @xmath28 from @xmath16 in the root component , thereby causing the proof of [ thm : d - static - roots ] to fail . working out the details",
    "may turn out difficult , though : after all , unlike single - process roots , larger root components suffer from the problem that its members can not always determine whether the root was a vsrc or not .",
    "influence must hence be conservative , in the sense that it involves even _ potential _ 2-process roots . ]    to avoid non - terminating (",
    "i.e. , forever undecided ) executions as predicted by [ thm : d - static - roots ] , we require the _ stable interval _ constraint guaranteed by the message adversary @xmath834 to hold . the parameter @xmath28 , which can always be safely set to @xmath890 according to [ lem : infprop ] , allows to adapt the message adversary to the actual dynamic causal diameter guaranteed in the vsrcs of a given dynamic network .",
    "note that , since @xmath203 , rounds where no message is received are not forbidden here ( in contrast to [ asm : influenceset ] ) .    in order to also circumvent executions violating the @xmath2-agreement property established by [ thm : strong - rgst - impossibility ]",
    ", we introduce the _ majority influence _ constraint guaranteed by the message adversary @xmath9 given in [ ass : stablestream ] below .",
    "like [ asm : influenceset ] for set agreement , it guarantees some ( minimal ) information flow between sufficiently long - lasting vertex - stable root components that exist at different times . as visualized in [ fig : model_majorinf ] , it implies that the information available in any such vsrc originates in at most @xmath2 `` initial '' vsrcs .",
    "thereby , it enhances the very limited information propagation that could occur in our model solely under @xmath891 , which is too strong for solving @xmath2-agreement .",
    "= [ circle , draw , text = black , inner sep=3mm , scale=0.6 ] = [ circle , fill = black!20,draw = black , text = black , inner sep=3mm , scale=0.6 ] = [ line width=0.8mm , draw = black ]    \\(a ) @xmath892 ; ( b ) [ right of = a ] @xmath893 ; ( c ) [ right of = b ] @xmath894 ; ( d ) [ right of = c ] @xmath895 ;    \\(i ) [ below left of = b ] @xmath896 ; ( k ) [ below right of = b ] @xmath897 ;    \\(f ) [ below left of = k ] @xmath898 ; ( g ) [ right of = f ] @xmath899 ; ( h ) [ right of = g ] @xmath900 ; ( e ) [ left of = f , ] @xmath901 ;    \\(a ) edge node ( b ) ( b ) edge[myarrows ] node ( c ) ( c ) edge[myarrows ] node ( d )    \\(i ) edge node ( f ) ( i ) edge node ( b ) ( k ) edge node ( d )    \\(e ) edge node ( f ) ( f ) edge[myarrows ] node ( g ) ( f ) edge node ( k ) ( g ) edge[myarrows ] node ( h ) ;    ( @xmath902 ) ",
    "( @xmath903)node[below right ] @xmath403 ;    formally , given some run @xmath787 , we denote by @xmath904 the set of all root components that are vertex - stable for at least @xmath1 consecutive rounds in @xmath787 .",
    "let @xmath905 be vertex - stable in @xmath906 $ ] and @xmath907 be vertex - stable in @xmath908 $ ] with @xmath909 ; note that @xmath910 for every @xmath911 .",
    "[ def : influence ] given any two @xmath912 , we say that some process @xmath913 _ influences _ some process @xmath914 and write @xmath915 with @xmath916 iff there exists a causal chain from @xmath16 to @xmath15 starting after @xmath917 that ends before or at the beginning of @xmath918 , i.e. , @xmath919 . in this case",
    ", we also say that @xmath920 ( weakly ) influences @xmath921 and write @xmath922 , using the relation @xmath923 here .",
    "we will also need stronger notions of influence , which are based on the following [ def : influence - set ] :    [ def : influence - set ] given any two @xmath924 , their influence set is @xmath925 .",
    "the _ majority influence _ between the nodes in @xmath926 and @xmath927 guarantees that @xmath926 influences a set of nodes in @xmath927 , which is greater than any set influenced by vsrcs not already known by the processes in @xmath926 ( and greater than or equal to any set influenced by vsrcs already known by the processes in @xmath926 ) .",
    "majority influence is hence a very natural way to discriminate between strong and weak influence between vsrcs , see [ def : stronginfluence ] below .",
    "[ def : majorityinfluence ] we say that a vsrc @xmath928 exercises a _ majority influence _ on a vsrc @xmath929 , denoted @xmath930 with @xmath931 , iff @xmath932 with @xmath933 it holds that @xmath934 and @xmath932 with @xmath935 it holds that @xmath936 .    with these preparations , we are now ready to specify a message adversary @xmath9 given in [ ass : stablestream ] .    [",
    "ass : stablestream ] the message adversary @xmath9 is the set of all sequences of communication graphs @xmath283 , where in every run @xmath937 with @xmath938 s.t.@xmath939 with @xmath940 .    informally speaking , [ ass : stablestream ] ensures that all but at most @xmath2 `` initial '' vsrcs in @xmath941 are majority - influenced by some earlier vsrc in @xmath941 ( see [ fig : model_majorinf ] ) .",
    "note carefully , though , that [ ass : stablestream ] neither prohibits partitioning of the system in more than @xmath2 simultaneous vsrcs nor directly exhibits a @xmath2-quorum property , cf .",
    "the well - known quorum failure detector @xmath942 @xcite that is known to be necessary ( but not sufficient ! ) for solving @xmath2-set agreement : after all , one could e.g.  choose @xmath943 vsrc s @xmath893 , @xmath895 and @xmath944 in [ fig : model_majorinf ] without finding any pair among those which are majority - influenced by a common predecessor vsrc .",
    "therefore , @xmath9 alone is too strong for solving @xmath2-set agreement .",
    "the same is true for an alternative to [ ass : stablestream ] that just ensures a @xmath2-quorum ( unless acyclicity could be guaranteed as well ) .",
    "conversely , if majority influence was replaced by strong influence according to [ def : stronginfluence ] , a quorum property could be easily established : starting out from an arbitrary set of @xmath945 @xmath946-vsrcs , we could go back along the ( acyclic ) majority influence relation until we end up in the set @xmath947 guaranteed by [ ass : stablestream ] .",
    "if a @xmath2-set agreement algorithm relied on @xmath946-vsrcs for decisions , this would guarantee that no more than @xmath2 decision values ( possibly fabricated in the `` initial '' @xmath946-vsrcs ) can be produced . a message adversary equivalent to [ ass : stablestream ] with strong majority",
    "would be fairly weak , however .",
    "these observations indicate that @xmath948 is indeed reasonably close to the @xmath2-set agreement solvability border .",
    "we conclude this section with some straightforward stronger assumptions , which also imply [ ass : stablestream ] and can hence be handled by the algorithm introduced in [ sec : algorithms ] :    replacing majority influence in [ def : majorityinfluence ] by majority intersection @xmath949 , which is obviously the strongest form of influence .    requiring @xmath950 , i.e. , a majority intersection with respect to the number of processes in @xmath927 .",
    "this could be interpreted as a changing vsrc , in the sense of `` @xmath927 is the result of changing a minority of processes in @xmath926 '' .",
    "although this restricts the rate of growth of vsrcs in a run , it would apply , for example , in case of random graphs where the giant component has formed @xcite .      in this section",
    ", we provide a @xmath2-set agreement algorithm and prove that it works correctly under the message adversary @xmath948 , i.e. , the conjunction of [ ass : inter , ass : stablestream ] .",
    "note that the algorithm needs to know @xmath28 , but neither @xmath11 nor @xmath19 .",
    "it consists of a `` generic '' @xmath2-set agreement algorithm , which relies on the network approximation algorithm of [ sec : approxalgo ] for locally detecting vertex - stable root components and a function @xmath951 that extracts candidate decision values from history information .",
    "our implementation of @xmath951 uses a vector - clock - like mechanism for maintaining `` causally consistent '' history information , which can be guaranteed to lead to proper candidate values thanks to @xmath948 .    in sharp contrast to classic @xmath2-set agreement algorithms ,",
    "the algorithm is _",
    "@xmath2-uniform _ , i.e. , the parameter @xmath2 does not appear in its code . rather , the number of system - wide decision values is determined by the number of ( certain ) @xmath946-vsrcs occurring in the particular run . as a consequence ,",
    "if the network partitions into @xmath2 weakly connected components , for example , decision values need _ not _ involve @xmath2 isolated partitions : obviously , @xmath2 isolated partitions in the communication graph also imply @xmath2 root components , but @xmath2 root components do not imply a partitioning of the communication graph into @xmath2 weakly connected components  one process may still be connected to several components . ]",
    "all processes in a component obtain the same decision value . on the other hand ,",
    "if the network remains well - connected , the algorithm guarantees a unique decision value system - wide .",
    "our algorithm is in fact not only @xmath2-uniform but even worst - case @xmath2-optimal , in the sense that ( i ) it provides at most @xmath2 decisions system - wide in all runs that are feasible for @xmath948 , and ( ii ) that there is at least one feasible run under @xmath948  where no correct @xmath2-set agreement can guarantee less than @xmath2 decisions .",
    "( i ) will be proved in [ sec : corproof ] , and ( ii ) follows immediately from the fact that a run consisting of @xmath2 isolated partitions is also feasible for @xmath948 .",
    "our algorithm can hence indeed be viewed as a consensus algorithm that degrades gracefully to @xmath2-set agreement , for some @xmath2 determined by the actual network properties .",
    "01 -10    like the consensus algorithm in [ sec : consensus ] , our @xmath2-set agreement algorithm consists of two reasonably independent parts , the network approximation algorithm [ alg : approx ] and the @xmath2-set agreement core algorithm given in [ alg : ksa ] . as in [ sec : consensuscore ] , we assume that the complete round @xmath14 computing step of the network approximation algorithm is executed just before the round @xmath14 computing step of the @xmath2-set algorithm , and that the round  @xmath14 message of the former is piggybacked on the round  @xmath14 message of the latter . recall that this implies that the round @xmath14 computing step of the @xmath2-set core algorithm , which terminates round  @xmath14 , can already access the result of the round @xmath14 computation of the network approximation algorithm , i.e. , its state at the end of round @xmath14 .",
    "* variables and initialization : * @xmath952 [ * ] : = \\emptyset$ ] / * @xmath953[r]$ ] holds @xmath33 s estimate of the locks learned by @xmath93 in round @xmath14 * / @xmath954[0 ] : = \\set{(\\set{p_i } , x_i , \\r-1)}$ ] / * virtual first lock @xmath955 at @xmath33 * / [ line : inithist ] @xmath956 // most recent lock round , @xmath848 if none @xmath957 // @xmath33 s decision , @xmath848 if undecided     * emit round r messages : * send @xmath958 to all neighbors [ line : sendhistory ]     * receive round r messages : * for all @xmath93 in @xmath33 s neighborhood @xmath959 , receive @xmath960     * round r computation : * decide @xmath961 and set @xmath962 [ line : adoptdec ]    // update @xmath963 with @xmath964 received from neighbors @xmath965 // remember current history @xmath966[r ' ] : = \\hist_i[x][r ' ] \\cup \\hist_j[x][r']$ ] [ line : remotehistoryupdate ]    // locally add all newly learned locks : @xmath954 : = \\hist_i \\setminus \\hist'_i$ ] [ line : learnlock ]    //",
    "perform state transitions ( undecided , locked , decided ) : @xmath967 [ line : lock ? ] @xmath968 @xmath969 [ line : setlock ] @xmath954[r ] : = \\hist_i[i][r ] \\cup \\lock$ ] //",
    "create new lock [ line : addnewlock ] @xmath956 //",
    "release unsuccessful lock [ line : releaselock ] [ line : decide ? ] decide @xmath970 and set @xmath971 [ line : setdecision ]    let @xmath267 be the multiset @xmath972[r'']$ ] + let @xmath973 be the set of the most frequent elements in @xmath267 [ line : bounded - history ] let @xmath974 [ line : hottestmajority ?",
    "] let @xmath80 be @xmath975 of the single element @xmath976 @xmath977 [ line : createlockmajority ] [ line : ambiguousmajority ? ] @xmath978 [ line : createlockmaximum ] //",
    "deterministic choice @xmath979 [ line : returnnewlock ]    the general idea of our core @xmath2-set agreement algorithm in [ alg : ksa ] is to generate new decision values only at members of @xmath946-vsrcs , and to disseminate those values throughout the remaining network .",
    "using the network approximation @xmath980 , our algorithm causes process @xmath33 to make a transition from the initially _ undecided _ state to a _ locked _ state when it detects some minimal `` stability of its surroundings '' , namely , its membership in some @xmath981-vsrc @xmath28 rounds in the past ( [ line : lock ? ] ) . note that the latency of @xmath28 rounds is inevitable here ,",
    "since information propagation within a @xmath981-vsrc may take up to @xmath28 rounds due to @xmath28-boundedness , as guaranteed by item  ( ii ) in [ ass : inter ] .",
    "if process @xmath33 , while in the locked state , observes some period of stability that is sufficient for locally inferring a consistent view among _ all _ vsrc members ( which occurs when the @xmath981-vsrc has actually extended to a @xmath946-vsrc ) , @xmath33 can safely make a transition to the _ decided _ state ( [ line : setdecision ] ) .",
    "the decision value is then broadcast in all subsequent rounds , and adopted by any not - yet decided process in the system that receives it later on ( [ line : adoptdec ] ) .",
    "note that @xmath834 ( [ ass : inter ] ) guarantees that this will eventually happen .",
    "since locking is done optimistically , however , it may also happen that the @xmath981-vsrc does not extend to a @xmath946-vsrc ( or , even worse , is not recognized to have done so by some members ) later on . in this case , @xmath33 makes a transition from the locked state back to the undecided state ( [ line : releaselock ] ) .",
    "unfortunately , this possibility has severe consequences : meachanisms are required that , despite possibly inconsistently perceived unsuccessful locks , ensure both ( a ) an _ identical _ decision value among all members of a @xmath946-vsrc who successfully detect this @xmath946-vsrc and thus reach the decided state , and ( b ) no more than @xmath2 different decision values originating from different @xmath946-vsrcs .",
    "both goals are accomplished by a particular selection of the decision values ( using function @xmath982 ) , which ultimately relies on an intricate utilization the network properties guaranteed by our message adversary @xmath948([ass : inter , ass : stablestream ] ) : our algorithm uses a suitable _ lock history _ data structure for this purpose , which is continuously exchanged and updated among all reachable processes .",
    "it is used to store sets of _ locks _ @xmath983 , which are created by every process that enters the locked state : @xmath108 is the vertex - set of the detected @xmath981-vsrc , @xmath80 is a certain proposal value ( determined as explained below ) , and @xmath984 is the round when the lock is created .    in more detail , the lock history at process @xmath33 consists of an array @xmath953[r]$ ] that holds @xmath33 s ( under)approximation of the locks process @xmath93 got to know in round @xmath14 .",
    "it is maintained using the following simple update rules :    _ local lock creation : _ apart from the single _ virtual _ lock @xmath985 created initially by @xmath33 in [ line : inithist ] ( which guarantees a non - empty lock history right from the beginning ) , all regular locks created upon @xmath33 s transition from the undecided to the locked state are computed by the function @xmath982 in [ line : setlock ] .",
    "any lock locally created at @xmath33 in round @xmath14 ( that is , in the round  @xmath14 computing step of the core @xmath2-set agreement algorithm that terminates round @xmath14 ) is of course put into @xmath954[r]$ ] .    _",
    "remote lock learning : _ since all processes exchange their lock histories , @xmath33 may learn about some lock @xmath986 created by process @xmath987 in round @xmath667 from the lock history @xmath988[r']$ ] received from some @xmath93 later on . in this case , @xmath986 is just added to @xmath966[r']$ ] ( [ line : remotehistoryupdate ] ) .",
    "_ local lock learning : _ in order to ensure that the lock histories of all members of a @xmath946-vsrc are eventually consistent , which will finally ensure identical decision values , _ every _ newly learned remote lock @xmath989[r']$ ] obtained in ( ii ) is also added to @xmath954[r]$ ] .",
    "note that the update rules ( i)+(ii ) resemble the ones of vector clocks @xcite .",
    "clearly , @xmath954[r']$ ] will always be accurate for current and past rounds @xmath664 , while @xmath953[r']$ ] may not always be up - to date , i.e. , may lack some locks that are present in @xmath990[r']$ ] .",
    "nevertheless , if @xmath33 and @xmath93 are members of the same @xmath946-vsrc @xmath105 with @xmath991 $ ] , [ def : d - bounded - vsrc ] ensures that @xmath33 and @xmath93 have consistent histories @xmath953[r']$ ] and @xmath992[r']$ ] at latest by ( the end of ) round @xmath993 , for any @xmath994 $ ] .",
    "hence , if @xmath33 creates a new lock @xmath986 when it detects , in its round @xmath14 computing step , that it was part of a @xmath981-vsrc that was stable from @xmath995 to @xmath996 , it is ascertained that any other member @xmath93 will have locally learned the same lock @xmath986 in the same round @xmath14 , provided that the @xmath981-vsrc in fact extended to a @xmath946-vsrc .",
    "the resulting consistency of the histories is finally exploited by the function @xmath997 , which computes ( the value of ) a new local lock ( [ line : setlock ] ) created in round @xmath14 . as its input parameters , it is provided with the members @xmath108 of the detected @xmath981-vsrc and its starting round @xmath998 . @xmath982 first determines a multiset @xmath267 , which contains all locks locally known to the members @xmath999 by round @xmath995 ( [ line : bounded - history ] ) . note that the multiplicity of some lock @xmath1000 in @xmath267 is just the number of members of @xmath108 who got to know @xmath986 by round @xmath995 , which is just @xmath1001 according to [ def : influence - set ] . in order to determine a proper value for the new lock to be computed by @xmath982 , we exploit the fact that @xmath9 ( given in [ ass : stablestream ] ) ensures majority influence according to [ def : majorityinfluence ] : if the set @xmath1002 , containing the most frequent locks in @xmath267 with the same maximal lock creation round , contains a single lock @xmath986 only , its value @xmath1003 is used .",
    "note that the restriction to the maximal lock creation date automatically filters unwanted , outdated locks that have merely been disseminated in preceding @xmath946-vsrcs , see ( 1 ) below .",
    "otherwise , i.e. , if @xmath1002 contains multiple candidate locks , a consistent deterministic choice , namely , the maximum among all lock values in @xmath267 , is used ( [ line : createlockmaximum ] ) . as a consequence , at most @xmath2 different decision values will be generated system - wide .    given the various mechanisms employed in our algorithm and their complex interplay , the question about a more light - weight alternative solution that omits",
    "some of these mechanisms might arise .",
    "we will proceed with some informal arguments that support the necessity some of the pillars of our solution , namely , ( 1 ) the preference of most recently created locks in @xmath982 , ( 2 ) the creation of a new lock at every transition to the locked state , and finally ( 3 ) the usage of an a priori unbounded data structure @xmath963 . although these arguments are also `` embedded '' in the correctness proof in the following section",
    ", they do not immediately leap to the eye and are hence provided explicitly here .",
    "the preference of most recently created lock in @xmath982 , which is done by selecting the set @xmath1002 in [ line : hottestmajority ? ] , defeats the inevitable `` amplification '' of the number of processes that got to know some `` old '' lock : all members of a @xmath946-vsrc have finally learned _ all _ `` old '' locks that were only known to _ some _ of its members at the starting round of the vsrc initially . in terms of multiplicity in @xmath267",
    ", this would falsely make any such old lock a preferable alternative to the most recently created lock .    instead of creating new locks at every newly detected @xmath981-vsrc",
    ", it might seem sufficient to simply update the creation time of an old lock that ( dominantly ) influences a newly detected vsrc .",
    "this is not the case , however : consider a hypothesized algorithm where new locks are only generated if no suitable old locks can be found in the current history , and assume a run where two vsrcs with vertex sets @xmath1004 and @xmath1005 that are both stable for @xmath981 rounds and two root components @xmath1006 and @xmath1007 that are stable for @xmath946 rounds are formed .",
    "let these vsrcs be such that @xmath223 is formed before @xmath1008 if @xmath1009 and let there be no influence among the processes of @xmath1010 , apart from their influence on each other when they are members of the same vsrc .",
    "first , let the processes of @xmath328 lock on some old lock @xmath1011 .",
    "then , assume that the processes of @xmath329 lock on some lock is known to @xmath1012 and has a more recent creation time than @xmath1011 ] @xmath1014 , a lock not known in @xmath328 .",
    "since @xmath1005 , if @xmath1015 is sufficiently well connected , @xmath803 might lock on @xmath1011 in @xmath1015 , because @xmath1011 is known to both @xmath803 and @xmath1016 while @xmath986 is known merely to @xmath803 at the start of @xmath1015 .",
    "subsequently , this results in the situation in @xmath1017 where there is neither a clear majority ( @xmath1011 and @xmath986 are known to both members of @xmath1017 ) nor a clear most recently adopted lock ( for @xmath803 , it seems that @xmath1011 is the most recent lock , while for @xmath1012 , it seems that @xmath986 is more recent ) .",
    "consequently , in @xmath1017 , it is not clear whether to lock on @xmath1003 or on @xmath1018 .",
    "nevertheless , the processes of @xmath1017 should be able to determine that they must lock on @xmath986 and not on @xmath1011 , since @xmath1019 holds in our example : @xmath1020 and @xmath1021 .",
    "we can therefore conclude that merely adopting old locks is insufficient .    since the stabilization round @xmath800 , as implied by [ ass : inter ] ,",
    "may be delayed arbitrarily , an unbounded number of @xmath946-vsrcs can occur before @xmath800 .",
    "since any of those might produce a critical lock , in the sense of exercising a majority influence upon some later @xmath946-vsrc , no such lock can safely be deleted from @xmath963 of any @xmath33 after bounded time .      in this final subsection",
    ", we will prove the following [ thm : kset ] :    [ thm : kset ] [ alg : ksa ] solves @xmath2-uniform @xmath2-set agreement in a dynamic network under the message adversary @xmath948 , which is the conjunction of [ ass : inter ] and [ ass : stablestream ] .",
    "the proof consists of a sequence of technical lemmas , which will finally allow us to establish all the properties of @xmath2-set agreement given in [ sec : model ] .",
    "first , validity according to [ def : ksa ] is straightforward to see , as only the values of locks are ever considered as decisions ( [ line : setdecision ] ) .",
    "values of locks , on the other hand , are initialized to the initial value of a process ( [ line : inithist ] ) and later on always have values of previous locks assigned to them ( [ line : createlockmajority , line : createlockmaximum ] ) .",
    "note that the claimed @xmath2-uniformity is obvious , as the code of the algorithm does not involve @xmath2 .    to establish termination , we start with some simple properties related to setting locks at all members of vertex stable root components .    [",
    "lem : minlock ] apart from processes adopting a decision sent by another process , only processes part of a vertex stable root with interval length greater than @xmath28 ( resp .",
    "@xmath1022 ) lock ( resp .",
    "decide ) .",
    "the if - statement in [ line : lock ? ] ( resp .",
    "[ line : decide ? ] ) is evaluated to true only if @xmath613 detects a stable member set @xmath108 in some interval @xmath104 of length @xmath981 ( resp .  of length @xmath946 ) or larger , which implies by [ cor : stable2root ] that @xmath105 is indeed a @xmath981-vsrc ( resp .",
    "@xmath946-vsrc ) .",
    "[ lem : maxlock ] all processes part of a vertex stable root @xmath1023}$ ] with interval length greater than @xmath1022 , which did not start already before @xmath112 , lock , i.e. set @xmath1024 , in round @xmath1025 .    because @xmath1023}$ ] is @xmath28-bounded by [ ass : inter ] , [ cor : allrootdec ] guarantees that @xmath1026 returns @xmath108 from round @xmath1025 ( of the @xmath2-set - algorithm ) on , and that it can not have done so already in round @xmath1027 .",
    "hence , @xmath1028 in round @xmath1025 , the if - statement in [ line : lock ? ] is entered and @xmath1024 is set in [ line : setlock ] .",
    "[ lem : maxdecide ] all processes part of a vertex stable root @xmath1023}$ ] with interval length greater than @xmath1029 , which did not start already before @xmath112 , have decided by round @xmath1030 .",
    "it follows from [ lem : maxlock ] that all members of the vsrc @xmath1023}$ ] set @xmath1024 in round @xmath1025 . as the vsrc remains stable also in rounds @xmath1031 , [ line : releaselock ] will not be executed in these rounds , thus @xmath1032 remains unchanged .",
    "consequently , due to [ cor : allrootdec ] , the if - statement in [ line : decide ? ] will evaluate to true at the latest in round @xmath1033 , causing all the processes to decide via [ line : setdecision ] by round @xmath1030 as asserted .",
    "[ lem : termination ] the algorithm eventually terminates at all processes .    for a contradiction , assume that there is @xmath1034 which has not terminated after the stable interval guaranteed by [ ass : inter ]",
    "this implies that @xmath93 is not part of a root component during this stable interval , because [ lem : maxdecide ] ensures termination by @xmath1035 at the latest for the latter .",
    "hence , @xmath93 did not get a decide message either . from [ def : e - network - vertex - stable - roots ] , it follows that there exists a causal chain of length at most @xmath19 to @xmath93 from some member @xmath33 of a vsrc after its termination .",
    "therefore , it must receive the decide message by @xmath1036 at latest .",
    "although we now know that all members of a vsrc that is vertex stable for at least @xmath1029 rounds will decide , we did not prove anything about their decision values yet . in the sequel , we will prove that they decide on the _ same _ value .",
    "[ lem : d - consistent - history ] given some vsrc @xmath105 with @xmath111 $ ] and @xmath1037 , in all rounds @xmath1038 $ ] it holds that @xmath1039[r ' ] = \\bigcup_{r ' { \\leqslant}a } \\hist_j[j][r']$ ]    by the @xmath28-boundedness of @xmath105 , a message from round @xmath112 has reached every member of @xmath108 by round @xmath584 .",
    "moreover , no message sent by a process not in @xmath108 during @xmath104 can reach a member of @xmath108 during @xmath104 because @xmath105 is a root component .",
    "therefore , since @xmath963 is sent by each process @xmath33 in every round ( [ line : sendhistory ] ) and @xmath33 adds only newly learned entries to @xmath963 ( [ line : addnewlock , line : learnlock ] ) , all these updates of @xmath963 during @xmath104 , regarding any round @xmath1040 , occur at the latest in round @xmath584 .",
    "[ lem : consistent - decisions ] all processes of a vsrcs @xmath105 of @xmath941 with @xmath111 $ ] adopt the same lock ( and hence decide the same ) .",
    "such a lock is created by @xmath1041 in round @xmath1025 , when it recognizes @xmath105 as having been vertex - stable for @xmath981 rounds according to [ lem : maxlock ] .",
    "as the lock ( value ) is computed based on @xmath963 present in round @xmath1025 , which is consistent among all vsrc members by [ lem : d - consistent - history ] , the lemma follows .",
    "finally , we show that , given that the system satisfies [ ass : stablestream ] , there will be at most @xmath2 decision values in any run of [ alg : ksa ] , which proves @xmath2-agreement : since there are at most @xmath2 vsrcs of @xmath941 that are not majority - influenced by other vsrcs , it remains to show that any majority - influenced vsrc decides the same as the vsrc it is majority - influenced by . in order to do so",
    ", we will first establish a key property of our central data structure @xmath963 .",
    "[ lem : historyapproximation ] given @xmath1042}$ ] , @xmath1043}$ ] with @xmath1044 and any @xmath1045 .",
    "let @xmath986 be a lock known to all members of @xmath926 by @xmath1046 , i.e. , for all @xmath1047 it holds that , by the end of round @xmath1046 , @xmath1048[r']$ ] . for any process @xmath1049",
    ", it holds that if there exists some @xmath1047 , s.t .",
    "@xmath1050 , then @xmath1051[r']$ ] .",
    "assume there exists a @xmath1047 s.t .",
    "@xmath1050 but @xmath1052[r']$ ] .",
    "the definition of @xmath1050 implies that there exists a causal chain from @xmath33 to @xmath93 that ends before @xmath93 becomes a part of @xmath927 .",
    "since processes send their own history in every round according to [ line : sendhistory ] , every message in this causal chain consisted of a @xmath1053 containing @xmath986 and thus @xmath93 put @xmath986 into its @xmath990[r]$ ] via [ line : remotehistoryupdate ] if @xmath1054[r']$ ] did not already contain @xmath986 .    given @xmath1042}\\in \\mathbb{v}_{2d+1}$ ] and",
    "@xmath1043 } \\in \\mathbb{v}_{2d+1}$ ] , assume that the processes of @xmath926 created the ( same ) lock @xmath986 when locking .",
    "if @xmath1055 , then the processes of @xmath927 will choose a lock @xmath1011 where @xmath1056 ( and hence decide the same as the processes of @xmath926 ) .    from the definition of @xmath1057 ( [ def : majorityinfluence ] ) , it follows that no vsrc @xmath105 of @xmath1058 has a larger influence set on @xmath927 than @xmath926 . by [ lem : minlock ]",
    ", this implies that no lock that was generated by some @xmath105 in @xmath1058 can be known to more members of @xmath927 than the lock @xmath986 generated by @xmath926 .",
    "since process @xmath33 puts only newly learned locks into @xmath963 ( [ line : addnewlock , line : learnlock ] ) , by [ lem : historyapproximation ] , this means that in round @xmath1059 no `` bad '' lock @xmath1060 is present in more elements of @xmath1061[r']$ ] than @xmath986 .",
    "we now show that @xmath1062 for all @xmath1060 occuring in as many elements of @xmath267 as @xmath986 with @xmath1063 .",
    "obviously , the only locks @xmath1060 that could occur in as many elements of @xmath267 as @xmath986 are locks that have been in @xmath963 of some @xmath1047 at the beginning of round @xmath1064 already . since for any such @xmath1060 , @xmath986 was created after @xmath1060 , by [ line : createlockmajority , line : createlockmaximum ] , we have that @xmath1062 , as claimed . because in round @xmath1065 , at all processes @xmath1066 of @xmath927 , [ lem : d - consistent - history ] implies that @xmath1067[r ' ]       = \\bigcup_{r ' { \\leqslant}r_{suc } } \\hist_j[i][r']$ ] , when locking in round @xmath1065 according to [ lem : maxlock ] , every @xmath33 of @xmath927 will find @xmath986 as the unique most common lock in the elements of @xmath267 with maximal @xmath984 .",
    "this leads to the evaluation of the if - statement in [ line : hottestmajority ? ] to true and to the creation of a new lock @xmath1011 , where @xmath1068 in [ line : createlockmajority ] , as asserted .",
    "this finally completes the proof of [ thm : kset ] .",
    "we introduced a framework for modeling dynamic networks with directed communication links under generalized message adversaries that focus on vertex - stable root components .",
    "we presented related impossibility results and lower bounds for consensus , as well as a message adversary that is much stronger than the ones known so far for solving consensus , along with a suitable algorithm and its correctness proof .",
    "moreover , we made a significant step towards determining the solvability / impossibility border of general @xmath2-set agreement in our model .",
    "we provided several impossibility results and lower bounds , which also led us to the , to the best of our knowledge , first gracefully degrading consensus/@xmath2-uniform @xmath2-set agreement under fairly strong message adversaries proposed so far ."
  ],
  "abstract_text": [
    "<S> we study distributed agreement in synchronous directed dynamic networks , where an omniscient message adversary controls the presence / absence of communication links . </S>",
    "<S> we prove that consensus is impossible under a message adversary that guarantees weak connectivity only , and introduce vertex - stable root components ( vsrcs ) as a means for circumventing this impossibility : a @xmath0 message adversary guarantees that , eventually , there is an interval of @xmath1 consecutive rounds where every communication graph contains at most @xmath2 strongly connected components consisting of the same processes ( with possibly varying interconnect topology ) , which have at most out - going links to the remaining processes . </S>",
    "<S> we present a consensus algorithm that works correctly under a @xmath3 message adversary , where @xmath4 is the dynamic causal network diameter . </S>",
    "<S> our algorithm maintains local estimates of the communication graphs , and applies techniques for detecting network stability and univalent system configurations . </S>",
    "<S> several related impossibility results and lower bounds , in particular , that neither a @xmath5 message adversary nor a @xmath6 one allow to solve consensus , reveal that there is not much hope to deal with ( much ) stronger message adversaries here .    however , we show that gracefully degrading consensus , which degrades to general @xmath2-set agreement in case of unfavorable network conditions , allows to cope with stronger message adversaries : we provide a @xmath2-uniform @xmath2-set agreement algorithm , where the number of system - wide decision values @xmath2 is not encoded in the algorithm , but rather determined by the actual power of the message adversary in a run : our algorithm guarantees at most @xmath2 decision values under a @xmath7 message adversary , which combines @xmath8 ( with some small value of @xmath1 , ensuring termination ) with some information flow guarantee @xmath9 between certain vsrcs ( ensuring @xmath2-agreement ) . since related impossibility results reveal that a @xmath0 message adversary is too strong for solving @xmath2-set agreement and that some information flow between vsrcs is mandatory for this purpose as well , our results provide a significant step towards the exact solvability / impossibility border of general @xmath2-set agreement in directed dynamic networks </S>"
  ]
}