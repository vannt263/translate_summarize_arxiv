{
  "article_text": [
    "in this paper we study a variant of _ graph search_. our motivation comes from applied robotics problems . as an introduction ,",
    "consider the following two problems , which can both be modeled as graph searches .    1 .",
    "an _ evader _ is hiding in a _ building _ and a team of one or more",
    "_ searchers _ are trying to _ capture _ him .",
    "the building is represented by a graph @xmath0 : nodes are _ rooms _ and edges are _ doors _ between rooms .",
    "both searchers and evader occupy the nodes of the graph and move from node to node by sliding along the edges .",
    "the evader is captured when he is located in the same node as a searcher .",
    "it is assumed that the evader has the following characteristics :  ( a )  he wants to avoid capture , ( b )  he is invisible to the searchers ( unless he is located in the same node as one of them ) , ( c )  he is always aware of the searchers locations and ( d )  he is arbitrarily fast .",
    "an evader and a team of searchers are located inside a _ cave_. the cave is again represented by a graph @xmath0 : edges are _ tunnels _ and nodes are the _ intersections _ of tunnels .",
    "the searchers move from node to node , sliding along the edges ; capture takes place if a searcher slides along an edge occupied by the evader , or if the evader moves through a node occupied by a searcher .",
    "the previously mentioned properties of the evader are assumed to hold in this case as well .",
    "the two problems are very similar but differ in one important respect . in the first problem the evader is assumed to reside in the _ nodes _ of the graph ( the rooms ) ; in the second problem he is assumed to reside in the _ edges _ ( the tunnels ) .",
    "accordingly , we will call the first problem _ node search _ and the second _ edge search_. edge- or node - location of the evader is an important aspect of the graph search problem and can be used to categorize the related literature .",
    "historically , research has concentrated on the problem of _ edge - located _ evader . to the best of our knowledge ,",
    "very little work has been done on the problem of _ node - located _ evader .",
    "interestingly , the term node search  has been used in the past to denote a version of the graph search for edge - located evader @xcite .",
    "hence , to avoid confusion , let us repeat that _ we use node search  to denote the search for a node - located evader_. _ _    another important aspect of the graph search problem is the visibility  of the evader .",
    "namely , we say that the evader is _ visible _ if the searchers always know his location ; we say that the evader is _",
    "invisible _ if the evaders may become aware of his location only when he is in the same node ( or edge ) as they .",
    "additional aspects of the graph search include whether it is _ internal _ ( the searchers can only move along the edges of the graph ) or not ( a searcher can , in one step , move to any node of the graph  we call this _ teleporting _ ) , _ monotone _ ( the evader can never return to a searched part of the graph ) and _ connected _ ( the searched parts form a connected subgraph )",
    ". these terms will be defined rigorously in section [ sec02 ] .",
    "we now present a brief overview of the graph search literature .",
    "early papers include @xcite where the problem of cave searching was posed and @xcite where the first mathematical study of the problem was presented .",
    "the problem was independently rediscovered a little later in @xcite .",
    "the edge search problem was placed in the context of graph theory in @xcite .",
    "the already mentioned node search  variant  ( actually dealing with edge - located evader )  appeared a little earlier in @xcite .",
    "another variant , called mixed search  ( and again dealing with edge - located evader )  appeared in @xcite and was further studied in @xcite .",
    "the study of _ connected _ edge search started relatively recently ; see @xcite .",
    "there is very little published on true  node search , i.e. , the search for a node - located evader .",
    "there is a considerable literature on pursuit of _ visible _ node - located evaders , which we will not discuss , since visible evader search is outside the scope of the current paper ; let us simply mention that an important early paper is @xcite .",
    "graph search is also related to several _ graph parameters _ , most notably  _ pathwidth _ and _ vertex separation_. these connections are discussed in many papers , e.g. , in @xcite .",
    "finally there are several reviews of the graph search literature :  an old and deep one is @xcite , a more recent one is @xcite and a very recent and very extensive one is @xcite .    the above mentioned papers adopt a theoretical point of view .",
    "while there is much discussion about graph search algorithms , we have found few actually implemented algorithms which can tackle relatively large graphs ( with the exception of _ tree _ search algorithms ) .",
    "a much more applied line of research appears in the _ robotics _ literature , for example in @xcite and the book @xcite .",
    "these papers present actual implementations of algorithms , as well as numerical and even physical experiments , but they provide little ( if any )  theoretical justification of their methods",
    ". in particular , the distinction between edge and node search often appears to be misunderstood .",
    "we attempt to clarify this distinction and also combine the robotics and graph theoretic points in two technical reports we have previously published @xcite .",
    "in the current paper we study graph search for an invisible , node - located evader .",
    "we also examine connections to the problem of invisible , edge - located evader .",
    "we do _ not _ deal with the case of visible evader .",
    "we are mainly interested in _ internal , monotone , connected _",
    "( imc )  node search .",
    "this version of the problem is the one most relevant to robotics applications which , as already stated , provide our main motivation . in general , we try to provide a balanced combination of theory and implementation .",
    "the main contribution of the paper is the introduction of ( several variants of )  the node - search algorithm gsst ( _ guaranteed search by spanning tree _ ) .",
    "this algorithm is presented in detail , theoretically motivated and analyzed and also practically evaluated by a number of numerical experiments . ] .",
    "the _ main idea _ behind the algorithm is that every imc  node search generates a spanning tree of the graph ; conversely , every spanning tree can be used to perform a node search .",
    "trees can be searched much more efficiently than general graphs ; gsst  exploits this fact to quickly compute a large number of searches and then output the one which requires the least number of searchers .",
    "our experiments also indicate that gsst can efficiently node - clear large graphs in a small running time . from the theoretical point of view",
    ", we establish several results about node search and its relation to edge search .",
    "these results are used to motivate the gsst  algorithm and also to prove that some variants of gsst are probabilistically complete ( i.e. , they are guaranteed to find a minimal imc node clearing schedule if given sufficient time ) .",
    "the paper is organized as follows .",
    "preliminary concepts and notation are introduced in section [ sec02 ] ; edge search and node search are compared in section [ sec03 ] ; imc  node and edge search on _ trees _ is studied in section [ sec04 ] ; imc  node search on general graphs is studied in section [ sec05 ] where the gsst  search algorithm is also introduced ; the algorithm is evaluated by numerical experiments in section [ sec06 ] ; conclusions and future research directions appear in section [ sec07 ] .",
    "some edge search results by barriere et al .",
    "@xcite are presented in appendix [ seca ] ; the connection of node search to _ mixed _ edge search is discussed in appendix [ secb ] ; connections to _ pathwidth _ are discussed in appendix [ secc ] ; an implementation of gsst as an actual executable program ( which runs on windows and linux computers )  is discussed in appendix [ secd ] .",
    "we denote graphs by boldface letters , e.g. @xmath2 where @xmath3 is the _ node set _ and @xmath4 is the _ edge set_. we will always label the nodes of @xmath0 as @xmath5 ( hence the graph contains @xmath6 nodes , i.e. @xmath7 ) .",
    "edges are denoted as @xmath8 where @xmath9 ; often we will write @xmath10 instead , for simplicity , but note that @xmath11 and @xmath10 are the same edge ( i.e. we study _ undirected _ graphs ) .",
    "we only consider connected graphs without loops or multiple edges .",
    "_ also , to avoid some trivial cases , we will always consider graphs with at least one edge ( and at least two nodes ) .",
    "_    nodes @xmath12 are said to be _ neighbors _ iff @xmath13 .    given a node sequence @xmath14 , where @xmath15 for @xmath16 @xmath17 we say that @xmath14 is    1 .   a _ path _",
    "iff @xmath18 for @xmath19 and @xmath20 ; 2 .   a _ cycle _ iff @xmath18 for @xmath19 ( and @xmath20 ) except that @xmath21 .",
    "a _ tree _ is a connected graph without any cycles .",
    "equivalent definitions are :  a tree is a graph for which there is a unique path between every pair of nodes ; a tree is a connected graph with @xmath6 nodes and @xmath22 edges .",
    "the _ leaves _ of the tree are the nodes which have exactly one neighbor .",
    "a _ rooted tree _ is a tree with a distinguished node @xmath23 called the _",
    "root _ of the tree . given a tree @xmath24",
    ", we will denote the same tree rooted at @xmath23 by @xmath25 .",
    "take any node @xmath26 and let @xmath27 be the unique path from @xmath23 to @xmath28 ; then @xmath29 is the _ parent _ of @xmath28 ; @xmath28 is the _ child _ of @xmath29 . given a node @xmath30 , its children , their children and so on are the _ descendants _ of @xmath30 .",
    "given a rooted tree @xmath31 and a node @xmath32 , consider the node set @xmath33   = \\left\\ {   z:\\text { } z\\text { is } y\\text { or a descendant of } y\\right\\}\\ ] ] and the edge",
    "set@xmath34   = \\left\\ {   zu : zu\\in e\\text { and } z , u\\in v\\left [   y\\right ] \\right\\ }   ; \\ ] ] note that both @xmath35   $ ] and @xmath36   $ ] are determined by _ both _ @xmath32 and @xmath30 . the graph @xmath37   , e\\left [ y\\right ]   \\right )   $ ] is a tree ( a _ sub - tree _ of @xmath38 ) .",
    "the _ rooted _ tree @xmath37   , e\\left [   y\\right ]   , y\\right ) $ ] will be denoted by @xmath39   $ ] .    a _ search schedule _ on the graph",
    "@xmath2 is a sequence of _ ordered _ pairs of nodes : @xmath40 subject to @xmath41 for @xmath42 .",
    "we call @xmath43 the @xmath44-th move ( or step )  of the search schedule",
    ". the @xmath44-th move can be any one of the following    1 .",
    "_ placing _ a searcher at node @xmath45 ( in which case @xmath46 and @xmath47 ) or 2 .",
    "_ sliding _ a searcher from node @xmath48 to node @xmath47 or 3 .   _ removing _ a searcher from node @xmath49 ( in which case @xmath50 and @xmath51 ) .",
    "we will also use the more evocative notation @xmath52 , i.e. a searcher is moved from node @xmath49 to node @xmath45 .",
    "moves of the form : @xmath53 ( a new searcher is introduced in the graph )  and @xmath54 ( a searcher is removed from the graph ) involve the fictitious source  node  0 ( it is not an element of @xmath3 ) , in which searchers are kept whenever they are not actively involved in the graph search ; the evader does not have access to the source node .    given a search @xmath55 , the number of searchers inside the graph at time @xmath44",
    "will be denoted by @xmath56 .",
    "the maximum number of searchers used by @xmath55 will be denoted by @xmath57 , i.e. @xmath58 these numbers must not be confused with the search number of a _ graph _ , which will be defined in section [ sec0202 ] .",
    "finally , we say that a node @xmath49 is _ guarded _ at time @xmath44 iff a searcher is located at @xmath49 ( at time @xmath44 ) ; otherwise we say @xmath49 is _",
    "unguarded_.  a path @xmath14 is called _ n - unguarded _ ( node unguarded ) iff nodes @xmath59 ( @xmath60 ) are unguarded ( at time @xmath44 ) ; otherwise it is called _ n - guarded . _",
    "the path is called _ e - unguarded _ ( edge unguarded ) iff nodes @xmath59 ( @xmath61 ) are unguarded ( at time @xmath44 ) and e - guarded otherwise .",
    "it is easy to see that@xmath62 the reason for the two different definitions is that the first pertains to _ node _ recontamination and the second to _ edge _ recontamination , as will be seen in section [ sec0202 ] .",
    "we repeat the assumptions introduced in section [ sec01 ] regarding the evader .",
    "namely , the evader wants to avoid capture , he is invisible to the searchers ( unless located in the same node ) , he is always aware of the searchers locations and arbitrarily fast .",
    "the net result of all these assumptions is that ( in both node and edge search )  the evader can ( and will ) always avoid capture if an escape route is available .",
    "hence , from the searchers point of view , we can think of graph search as a process of eliminating escape routes .",
    "this is expressed as follows :     1 .",
    "a node / edge is _ dirty _ if it can _ possibly _ contain the evader and _ clear _ otherwise ( e.g. , a node occupied by a searcher is clear ) ; 2 .",
    "a previously clear node / edge can become dirty ( e.g. , when a previously guarded path between a clear and a dirty node becomes unguarded )  this is called _ recontamination _ ; 3 .",
    "graph search is the process of gradually decreasing the _ dirty set _ ( of nodes or edges ) until it becomes the empty set ( i.e. , the evader has no escape route left ) .",
    "_ worst case approach _ which essentially eliminates the evader from the graph search , introducing in his place the dirty set .",
    "we can think of node ( edge ) search as a _",
    "one - player _ node game  ( edge game ) . in both these games",
    "the player controls all searchers , much like pieces in a game of chess .",
    "we now present the rules of the two games . for reasons which will be explained presently , we substitute the terms clear  and dirty  with the terms n - clear  and n - dirty  ( in the node game ) and e - clear  and e - dirty  ( in the edge game ) .",
    "    * rules of the node game *    1 .   at time @xmath63",
    "all nodes are _ n - dirty _ and no searcher is located in the graph .",
    "2 .   at every time @xmath64 the player performs _ one _ of the following moves : 1 .   place a searcher on a node , 2 .",
    "remove a searcher from a node , 3 .   slide a searcher along one edge .",
    "an n - dirty node becomes _ n - clear _ when occupied by a searcher .",
    "an n - clear node @xmath49 becomes n - dirty when it is connected to to an n - dirty node @xmath45 by an _",
    "n - unguarded  path_. 5 .",
    "an edge is n - dirty if it is adjacent to an n - dirty node ; otherwise it is clear .",
    "the game is concluded when all nodes ( and consequently also all edges ) are n - clear .    ",
    "* rules of the edge game *    1 .   at time @xmath63",
    "all edges are _ e - dirty _ and no searcher is located in the graph .",
    "2 .   at every time @xmath64 the player performs _ one _ of the following moves : 1 .   place a searcher on a node , 2 .",
    "remove a searcher from a node , 3 .   slide a searcher along one edge .",
    "an e - dirty edge becomes e - clear when a searcher slides along the edge .",
    "4 .   an e - clear edge @xmath10 becomes e - dirty when it is connected to to a e - dirty edge @xmath65 by an _",
    "unguarded  path_. 5 .",
    "a node is e - dirty if it is unguarded and adjacent to an e - dirty edge ; otherwise it is e - clear .",
    "the game is concluded when all edges ( and consequently also all nodes )  are e - clear .    ",
    "[ prp0201]the reason for using n - clear  and e - clear  ( instead of simply clear )  is that an edge can be clear in the node game and dirty in the edge game .",
    "an example will illustrate this point .",
    "consider the graph of fig.1 and the search schedule @xmath66 @xmath66 @xmath67 @xmath68 @xmath69 if this schedule is executed in a node game , after the final move all nodes are n - clear and so all edges are also n - clear .",
    "but in an edge game , after the final move , edge @xmath70 has still not been traversed and hence it is still e - dirty . more generally , while n - clear  and e - clear  refer to similar physical situations , there is no a priori reason that their mathematical definitions are equivalent ( in section [ sec04 ] we will show that they _ are _ equivalent _ provided certain conditions are satisfied _ ) .    ) , then placing a second searcher at 1 and sending him through 2 , 4 , 3 ( @xmath71 , @xmath72 , @xmath73 , @xmath74 ) is node clearing but not edge clearing.,width=216 ]    [ prp0202]note that in the edge game clear edges are recorded  at the completion of each move .",
    "this is important to note in the case that an edge is e - cleared and e - dirtied _ during the same move _",
    "( i.e. for a single value of @xmath44 ) . to clarify this ,",
    "suppose that in the graph of fig.1 the following moves are executed :  @xmath71 at @xmath75 ; @xmath72 at @xmath76 .",
    "in this case edge @xmath77 is first e - cleared ( because traversed )  and then e - dirtied , _ both during _ @xmath76 .",
    "after completion of the second move , _ edge _ @xmath78 _ is e - dirty_.    we now introduce more detailed notation regarding clear / dirty nodes / edges . for the node game",
    "we will use the following notation.@xmath79    we use exactly analogous notation for the edge game , but with an @xmath4 ( rather than @xmath6 ) subscript:@xmath80 , @xmath81 , @xmath82 , @xmath83 , @xmath84 .",
    "obviously we have @xmath85    [ prp0203]the n - clear / e - clear graph definitions are consistent , i.e. @xmath86 / @xmath87 _ are _ graphs . more specifically :     1 .   in the node game",
    "@xmath88 consists of the n - clear nodes and all edges between such nodes ( these are exactly the set @xmath89 ) ; 2 .   in the edge game",
    "@xmath90 consists of the e - clear edges and none of these can be left dangling , i.e. if @xmath91 then @xmath49,@xmath92 ( we will prove this as lemma [ prp0301 ] in section [ sec03 ] ) ; in addition @xmath93 may contain guarded nodes adjacent to e - dirty edges ; such nodes may appear as disconnected components of @xmath90 .    in the current paper we will concentrate on some _ restricted _ versions of the edge and node games . more specifically ,",
    "the restrictions concern the allowable search schedules and they are the following .    1 .",
    "we call a search schedule _ rooted _ iff searchers can be placed only into a single , prespecified node @xmath23 , called the _ root _ of the search .",
    "we call a search schedule _ internal _ iff searchers once placed into the graph ( a ) can only move along the edges and ( b )  are never removed from the graph . in other words , teleporting  ( the arbitrary movement of a searcher from one node to another , irrespective of the graph connectivity ) is not allowed , we have @xmath94 where @xmath95 is the length of the search . ] .",
    "3 .   in the node game",
    "we call a search schedule @xmath55 _ monotone _ iff the clear node set is never decreasing : @xmath96 for all @xmath97 in other words ,",
    "once a node is n - cleared it never becomes n - dirty again .",
    "the definition is similar for the edge game ; i.e. , @xmath55 is monotone in the edge game iff @xmath98 for all @xmath97 .",
    "is monotone ( since @xmath99 ) but _ not _ strongly monotone .",
    "we stress this detail mostly for the sake of completness ; in what follows we will _ not _ use strong monotonicity . ]",
    "4 .   in the node game ( resp .",
    "edge game )  we call a search schedule _",
    "connected _ iff the clear graph @xmath88 ( resp .",
    "@xmath90 )  is connected for @xmath64 .    in section [ sec03 ]",
    "we will study general , unrestricted graph search ; in the remaining sections we will concentrate on internal monotone ( _ i m _ ) , internal connected ( _ ic _ )  and , especially , internal monotone connected ( _ imc _ )  node / edge search .",
    "our focus originates in our interest in practical _ pursuit / evasion _ problems which arise in robotics .",
    "the nature of the problem dictates the restrictions on the search .    1 .",
    "the internality constraint arises from the fact that a robot can not teleport ; it can only move through rooms and doors connecting these rooms ; in the graph model of the physical situation this is reflected by the use of edge - sliding moves only . 2 .",
    "similarly , rootedness reflects the fact that usualy an environment has a single entrance through which robots must enter .",
    "connectedness and monotonicity are desirable ( but not mandatory ) characteristics of robotic search .",
    "for example , in a hostile environment it is preferrable that the cleared area consists of a single connected region , which is easier to guard and control than multiple regions .",
    "similarly , if a high cost is associated with clearing an area , it is desirable that this area is cleared only once , i.e. , that the search is monotone",
    ".    a given graph @xmath0 with @xmath6 nodes can always be node - cleared using @xmath6 searchers :  just place one searcher in every node .",
    "usually @xmath0 can be cleared with much @xmath100fewer searchers ; the _ node search number _ of @xmath0 , denoted by @xmath101 , is the minimum number of searchers required to node - clear @xmath0 . introducing additional constraints on the search schedule",
    "we get additional search numbers :    [ c]lll@xmath102 : & min .",
    "nr . of searchers required to clear @xmath0 with & internal  node search schedule ; + @xmath103 & -//- & i m  node search schedule ; + @xmath104 : & -//- & ic  node search schedule ; + @xmath105 & -//- & imc  node search schedule .    for the edge game",
    "we define the corresponding edge search numbers :  @xmath106 , @xmath107 , @xmath108 , @xmath109 , @xmath110 .    in case of a search rooted at node @xmath30",
    ", we will modify the notation as follows : @xmath111 is the minimum number of searchers required to node - clear @xmath0 by a search rooted at @xmath30 ; similarly for @xmath112 , @xmath113 and so on . if the graph @xmath0 is a rooted tree @xmath38 , then we will assume it is always searched by rooted searches ; hence @xmath114 , @xmath115 and so on .",
    "a _ minimal _ node search schedule is one which clears @xmath0 using @xmath101 searchers ; a _ minimal _ i m  node search schedule is an i m  schedule which clears @xmath0 using @xmath116 searchers and similarly for all other types of either node or edge search .",
    "in this section we compare unrestricted  edge and node search . in other words ,",
    "we compare the outcome of a search schedule @xmath55 when it is used first in a node game and then in edge game , both played on the same graph @xmath0 and without requiring rootedness , internality , monotonicity or connectedness .",
    "our main result is theorem [ prp0303 ] which , informally , says the following : every search schedule @xmath55 gives at least as good results in the node game as in the edge game .",
    "more precisely , at every step @xmath44 of the search , the set of e - clear nodes ( and edges ) is a subset of the set of n - clear nodes ( and edges ) .",
    "an immediate corollary is that an edge clearing search schedule is also node clearing ; the converse does not hold , as we have already seen by the example of remark [ prp0201 ] .    to prove theorem [ prp0303 ]",
    "we will need the following lemmas .",
    "[ prp0301]given a graph @xmath0 and a search schedule @xmath55 , for @xmath117 we have@xmath118 in other words : if a node @xmath49 is e - dirty , then all edges @xmath119 , adjacent to @xmath49 , are also e - dirty ; and if an edge @xmath10 is e - clear , then nodes @xmath12 are e - clear .    for ( [ eq0301a ] ) : since @xmath49 is e - dirty , it must be unguarded .",
    "we distinguish two cases .",
    "( 1.i )  suppose @xmath49 is adjacent to a single edge , call it @xmath10 .",
    "if @xmath10 is e - clear then @xmath49 is not adjacent to any e - dirty edges and hence must be e - clear , which is contrary to the original assumption .",
    "hence @xmath10 is e - dirty .",
    "( 1.ii )  on the other hand , if @xmath49 is adjacent to more than one edges , they can not all be e - clear ( then @xmath49 would also be e - clear ) ; so at least one edge , call it @xmath120 , is e - dirty .",
    "suppose there is also an e - clear edge , call it @xmath10 .",
    "but then the e - unguarded path @xmath121 connects e - dirty @xmath122 to e - clear @xmath10 , which leads to contradiction .",
    "hence all edges adjacent to @xmath49 are e - dirty .    for ( [ eq0301b ] )",
    ": suppose @xmath123 .",
    "then @xmath49 is unguarded and there exists some @xmath124 and @xmath125 .",
    "but the path @xmath126 is e - unguarded and so @xmath127 which is a contradiction .",
    "[ prp0302]if a node @xmath49 is e - cleared exactly at time @xmath44 , then @xmath49 is entered by a searcher at @xmath44 .",
    "suppose @xmath128 @xmath129 .",
    "this can happen in two ways .",
    "( i )  @xmath49 was unguarded and e - dirty at @xmath130 and then entered by a searcher at @xmath44 .",
    "this is exactly the case described by the theorem .",
    "( ii )  the other way for @xmath49 to be cleared exactly at @xmath44 is if @xmath49 was unguarded and e - dirty at @xmath130 and in addition a single edge , call it @xmath131 , was e - dirty at @xmath130 and e - cleared at @xmath44 ( while all other edges @xmath119 were e - clear at @xmath130 and remained e - clear at @xmath44 ) . for this to happen , the move at time @xmath44 is either @xmath132 or @xmath133 .",
    "but @xmath132 is not possible , because then @xmath49 would be guarded and e - clear at @xmath130 .",
    "hence the move at @xmath44 is @xmath133 and @xmath49 was entered at @xmath44 ( which shows that ( ii )  is a sub - case of ( i ) ) .",
    "now we are ready to prove the following .",
    "[ prp0303]given a graph @xmath0 and a search schedule @xmath55 , we have @xmath134    we will actually show the relationships ( equivalent  to ( [ eq0312 ] ) ) @xmath135 the proof is by induction . at @xmath136",
    "all nodes are dirty in both the edge game and the node game , hence @xmath137 .",
    "suppose @xmath138 for @xmath139 .",
    "now we take @xmath140 and consider first the cleared and then the recontaminated nodes .    1 .",
    "_ cleared nodes . _ by lemma [ prp0302 ] , a node becomes e - cleared _ exactly _ at @xmath141 only if entered at @xmath141 .",
    "hence at most one such node ( call it @xmath142 )  exists and , since entered at @xmath141 , it is also n - clear at @xmath141 .",
    "in other words : @xmath143 .",
    "recontaminated nodes . _",
    "denote by @xmath144 the set of nodes recontaminated ( in the node game ) _ exactly _ at @xmath141 ; i.e. , @xmath145 . by the definition of n - dirty node",
    ", every @xmath146 must have a path ( n - unguarded at @xmath141 ) to a node @xmath147 .",
    "furthermore , at least one @xmath146 must have a path ( n - unguarded at @xmath141 ) to a node @xmath148 ( if this did not hold for any @xmath146 , then none of the nodes of @xmath144 would get recontaminated to begin with ) and in fact this shows _ every _",
    "@xmath146 must have a path ( n - unguarded at @xmath141 ) to a node @xmath148 .",
    "so take any @xmath146 , then there exists a path @xmath149 satisfying:@xmath150 now we will show that @xmath151 must belong to @xmath152 as well .",
    "first , @xmath153 .",
    "second , if @xmath154 then @xmath151 was cleared exactly at @xmath141 , which ( by lemma [ prp0302 ] ) means a searcher entered @xmath151 at @xmath141 ; but then @xmath155 which is contrary to ( [ eq0431 ] ) . hence @xmath156 .  since @xmath151 is _ e - dirty _ at time @xmath141 , @xmath157 is",
    "e - dirty at @xmath141 by lemma [ prp0301 ] .",
    "also @xmath149 is e - unguarded at @xmath141 .",
    "hence @xmath158 .",
    "since this is true for every @xmath146 , we conclude@xmath159    if the move at @xmath141 was placing or sliding a searcher into node @xmath142 , let @xmath160 ; else let @xmath161 .",
    "since @xmath162 we have @xmath163 since the e - dirty nodes at @xmath141 include all the e - dirty nodes at @xmath44 except the node @xmath142 ( which was e - cleared at @xmath141 ) , we have@xmath164 and so we have @xmath165 the n - dirty nodes at @xmath141 are exactly the n - dirty nodes at @xmath44 , excluding nodes n - cleared at @xmath141 , plus the nodes recontaminated at @xmath141 . in other words@xmath166 combining eqs .",
    "( [ eq0407 ] ) , ( [ eq0308 ] ) and ( [ eq0309 ] ) we get@xmath167 hence by induction we get @xmath168  ( and @xmath169 )  for @xmath117 .",
    "let us now consider the edge sets @xmath170 and @xmath83 .",
    "take any @xmath44 and any edge @xmath171 . without loss of generality",
    "we can assume @xmath172 and hence , by lemma [ prp0301 ] , @xmath173 .",
    "hence , for @xmath117 , we have @xmath174 which completes the proof .",
    "[ prp0304]given a graph @xmath0 and an internal search schedule @xmath55 , if @xmath55 is edge clearing it is also node clearing .",
    "suppose the final move of @xmath55 took place at time @xmath95 , then @xmath175 . since @xmath176 we have @xmath177 which also means @xmath178 ( if a node @xmath49 was n - dirty , an adjacent edge @xmath10 would also be n - dirty ) .",
    "[ prp0305]from theorem [ prp0303 ] we see that edge search is weaker  than node search , i.e. , for every search schedule * * , * * and at every time step , the clear set in the edge game is smaller or equal than the one in the node game .",
    "there is a variant of edge search , the so - called _ mixed edge search _ which , as we will see in appendix [ secb ] , is _ equivalent _ to node search , i.e. every search schedule produces the same clear and dirty sets at every step of both the edge and node game ( this is stated and proved as theorem [ prpa01 ] ) .",
    "from this fact follow two consequences . first , _ node search is np - complete _ ( since mixed edge search is np - complete @xcite ) .",
    "second , theorem [ prp0303 ] can be obtained as a corollary of theorem [ prpa01 ] .",
    "a more detailed discussion of these issues appears in appendix [ secb ] .",
    "in this section we will focus on _ rooted imc  ( internal , monotone , connected )  search on trees _ and we will compare node and edge search in this context .",
    "several authors have studied rooted imc  _ edge _ search @xcite .",
    "our main results in this section are theorems [ prp0401 ] and [ prp0402 ] which establish the equivalence of rooted imc  node and edge search on trees .",
    "hence several results already established for edge search also hold for node search ( on trees ) as will be seen in the sequel .    [ prp0401]given a tree @xmath1 and an internal _ rooted _ search schedule",
    "@xmath55 , if @xmath55 is monotone connected _ in the node game _",
    "then @xmath179 and @xmath55 is monotone connected in the edge game .",
    "the proof is inductive .",
    "we have @xmath180 and @xmath181 .",
    "also , since the search is rooted and internal , the move at @xmath75 will be the placement of a searcher into the root @xmath23 ; hence @xmath182 and @xmath183 .",
    "now suppose that at time @xmath184 we have @xmath185 and let us consider the move @xmath186 , performed at @xmath141 , @xmath187 .",
    "we first dispose of the case where the move involves the node 0 .",
    "because of internality , @xmath188 ( no searcher is removed from the graph ) .",
    "if the move is @xmath53 , by rootedness we must have @xmath189 . also by rootedness",
    ", @xmath23 is the first node cleared ( at some @xmath75 ) .",
    "now , in the node game : ( a )  by monotonicity , no node is recontaminated at @xmath141 and ( b )  no node is n - cleared either ( since @xmath23 _ remains _",
    "n - clear , the move @xmath190 implies @xmath191 ) ; hence @xmath192 which also means @xmath193 . in the edge game , @xmath194 ( a )  does not clear any new edges ( so it does not clear any new nodes either ) and ( b )  does not remove any searchers from any node , so neither edge  nor node recontamination is possible ; hence @xmath195 and @xmath196 . in short ,",
    "if the @xmath197-th move involves node 0 , from ( [ eq0401 ] )  follows @xmath198    next we examine the case where the @xmath197-th move is @xmath186 , with @xmath199 .",
    "we will examine the effects of this move separately for the node and edge game .",
    "* i. * _ node game_. @xmath49 was guarded at time @xmath44 , so @xmath200 .",
    "suppose , first , that at @xmath44 only one searcher was located on @xmath201 so @xmath49 is unguarded at @xmath141 .",
    "however , since @xmath55 was supposed monotone in the node game , there is no node @xmath202 @xmath203 @xmath204 and , especially , @xmath49 remains n - clear .",
    "since no node has become n - dirty at @xmath141 , no edge has become n - dirty either ( an edge becomes n - dirty iff incident on an n - dirty node ) . as for clearings , @xmath45 is n - clear at @xmath141 , since entered by a searcher ; and @xmath10 is also n - clear since @xmath205 .",
    "no node other than @xmath45 was entered at @xmath141 , so no node other than @xmath45 was n - cleared .",
    "is there an edge ( other than @xmath10 )  which was n - cleared exactly at @xmath141 ?",
    "this is only possible if ( a )  the edge has the form @xmath206 and ( b)@xmath207 ( @xmath45 became n - clear _ exactly _ at @xmath141 ) and ( c )  @xmath208 .",
    "suppose @xmath209 .",
    "since @xmath88 is connected , there is a path @xmath210 which is _ inside _ @xmath88 and hence _ does not contain _ @xmath45 .",
    "then the tree @xmath1 contains a cycle @xmath211 which is a contradiction . hence the only edge _",
    "possibly _ n - cleared at @xmath141 ( if not already n - clear at @xmath44 ) is @xmath10 . in short@xmath212",
    "the case that @xmath49 is still guarded at @xmath141 ( i.e. @xmath49 contained more than one searcher at time @xmath44 ) is omitted , since it is similar but easier to treat than the case of unguarded @xmath49 .",
    "* ii . * _ edge game_. again , we first examine the case that only one searcher was located in @xmath49 at time @xmath44 .",
    "so @xmath49 was guarded ( and e - clear ) at @xmath44 and is unguarded at @xmath141 .",
    "we will now show that @xmath49 remains e - clear at @xmath141 ; in other words that @xmath213 suppose , on the contrary , that we have@xmath214 there are only two ways for ( [ eq0443 ] )  to hold , each of which we examine separately .    1",
    ".   @xmath215 such that @xmath216 .",
    "then @xmath217 .",
    "since the move at @xmath141 was @xmath186 , @xmath49 was guarded at @xmath44 and @xmath218 .",
    "now , from @xmath186 and @xmath219 we get @xmath220 ; from this and @xmath49 unguarded at @xmath141 we conclude that @xmath221 which contradicts monotonicity of the node search .",
    "2 .   alternatively",
    ", there exists a path @xmath222 ( with @xmath223 ) such that @xmath224 and @xmath222 is e - unguarded at @xmath141 .",
    "first note that , since @xmath225 is e - unguarded at @xmath141 and the @xmath197-th move is @xmath186 , it follows that @xmath226 ; and since @xmath1 is a tree , @xmath227 too ; in short @xmath228 . also @xmath229 , since @xmath225 is a path .",
    "now@xmath230{l}\\text{the } \\left (   t+1\\right )   \\text{-th move is } u\\rightarrow v\\\\ u\\notin\\left\\ {   x_{1}, ... ,x_{k}\\right\\ } \\\\ ux_{1} ... x_{k}\\text { is e - unguarded at } t+1 \\end{array } \\right\\ }   \\rightarrow ux_{1} ... x_{k}\\text { is e - unguarded at } t\\ ] ] and this together with @xmath231 implies @xmath232 . from @xmath233 follows that @xmath234 was not entered at @xmath141 and so @xmath235 . from this and",
    "@xmath236 being n - unguarded at @xmath141 we conclude that @xmath237 which contradicts monotonicity of the node search .    in short , @xmath49 can not become e - dirty at @xmath141 , i.e. , we have proved ( [ eq0441 ] ) .",
    "using this we now will show that no previously e - clear edge @xmath65 can become e - dirty at @xmath141 . because this would require the existence of some edge @xmath238 and a path @xmath239 which is e - unguarded at @xmath141 but e - guarded at @xmath44 ( otherwise @xmath65 would already be e - dirty at @xmath240 .",
    "but any such path would have to contain @xmath49 ( no searcher was removed from any other node at @xmath141 ) which would in turn imply @xmath241 , which contradicts ( [ eq0441 ] ) . since no edge is recontaminated no node is recontaminated either ( the only node guarded at @xmath44 and unguarded at @xmath141 is @xmath49 , for which we have ( [ eq0441 ] ) ) .",
    "on the other hand , the only edge _ possibly _ e - cleared at time @xmath141 ( if not already e - clear at @xmath44 ) is @xmath10 , since no other edge was traversed at @xmath141 .",
    "hence the only node _ possibly _ e - cleared at time @xmath141 ( if not already e - clear at @xmath44 )  is @xmath45 .",
    "in short  we have shown @xmath242 the treatment of the case that @xmath49 is still guarded at @xmath141 ( i.e. , at @xmath44 it contained more than one searcher ) is omitted , since it is similar but easier to the case of @xmath49 unguarded . from ( [ eq0401 ] ) , ( [ eq0402 ] ) and ( [ eq0403 ] ) we obtain @xmath243 and , proceeding inductively , we obtain the required result : @xmath244 monotonicity and connectedness in the edge game follow from the fact that these hold in the node game and from eq.([eq0405a ] ) .    [ prp0402]given a tree @xmath1 and an internal _ rooted _ search schedule @xmath55 with root @xmath23 , if @xmath55 is monotone connected _ in the edge game _ and satisfies either of the following constraints    1 .",
    "@xmath245 , @xmath246 2 .",
    "@xmath245 , @xmath247 , @xmath248 ,    then@xmath249 and @xmath55 is monotone connected in the node game .",
    "[ prp0403]before proving the theorem , let us discuss the significance of constraints * c1 * and * c2*. three remarks must be made    1 .",
    "regarding the kind of searches which will satisfy either of the constraints :  * c1 * will be satisfied by searches with @xmath250 , @xmath251 ( provided @xmath23 has a single neighbor , namely @xmath45 ) ; * c2 * will be satisfied by searches with @xmath252 , @xmath253 , @xmath254 ; in both cases @xmath23 is , obviously , the root of the search .",
    "the constraints are imposed to exclude situations similar to the one discussed in remark [ prp0202 ] , where an edge is e - cleared and e - dirtied during the _ same _ time step @xmath44 .",
    "3 .   finally ,",
    "* c1 * and * c2 * are not exceedingly restrictive ; as will be seen later , every interesting  imc  search on a tree either satisfies * c1 * / * c2 * or can easily be converted to an equivalent search which does .    [",
    "proof of theorem [ prp0402]]the theorem will be proved by induction . it is easy to check that @xmath255   : \\qquad v_{e}^{c}\\left (   t\\right ) = v_{n}^{c}\\left (   t\\right )   \\text { and } e_{e}^{c}\\left (   t\\right )   = e_{n}^{c}\\left (   t\\right)\\ ] ] with @xmath256 when * c1 * holds and @xmath257 when * c2 * holds .",
    "now suppose that at time @xmath258 we have @xmath259 and consider the move performed at @xmath141 .",
    "we first dispose of the case where the move involves the node 0 .",
    "because of internality , @xmath188 ( no searcher is removed from the graph ) .",
    "if the move is @xmath53 , by rootedness we must have @xmath189 . by * c1 * and * c2 * , @xmath23 is the first node cleared ( at @xmath75 ) . in the edge game , at @xmath141 ,",
    "no edge is recontaminated ( by monotonicity )  and no edge is e - cleared ( since no edge is traversed ) ; hence @xmath260 ; since no searcher is removed from a node , @xmath195 as well . in the node game",
    ", @xmath23 is already n - clear at @xmath261 and no other node is entered at @xmath141 , so no node is n - cleared ; no searcher is removed from the graph , so no node is recontaminated ; hence @xmath262 which implies @xmath263 as well . in short , if the @xmath197-th move involves node 0 , from ( [ eq0401a ] )  and the above arguments follows @xmath198    next we examine the case where the @xmath197-th move is @xmath186 , with @xmath199 .",
    "we will examine the effects of this move separately for the node and edge game .",
    "* i. * _ edge game_. by monotonicity of the search , no previously e - clear edge becomes e - dirty at @xmath141 ; and hence the only node that can _ possibly _ become e - dirty is @xmath49 .",
    "we will show however that @xmath49 also remains e - clear . since @xmath264 and @xmath258 , from edge monotonicity follows that @xmath265 for all @xmath258 . and , since @xmath266 and @xmath90 is connected , there exists @xmath267 ; if @xmath49 becomes e - dirty at @xmath141 , then @xmath268 , which contradicts monotonicity of the edge search .",
    "hence no previously e - clear node becomes e - dirty at @xmath141 .    regarding new clearings , edge @xmath10 and node @xmath45 _",
    "may _ become e - clear at @xmath141 ( if they were not already e - clear at @xmath44 ) .",
    "no edge other than @xmath10 was traversed , hence no edge other than @xmath10 ( and no node other than @xmath45 ) can be e - cleared at @xmath141 .",
    "in short , in the edge game we have@xmath269    * ii . *  _ node game_. again , we first examine the case that only one searcher was located on @xmath49 at time @xmath44 .",
    "so @xmath49 was guarded ( hence n - clear ) at @xmath44 and is unguarded at @xmath141 .",
    "we will now show that @xmath49 remains n - clear at @xmath141 ; in other words that @xmath270 suppose on the contrary that we have@xmath271 ( [ eq0445 ] )  can happen in only two ways , each of which we examine separately .",
    "1 .   @xmath215 such that @xmath272 and @xmath273 .",
    "then @xmath274 and hence ( since the move at @xmath141 was @xmath186 and @xmath219 ) @xmath275 .",
    "+ since @xmath265 ( for all @xmath258 ) and @xmath266 and @xmath90 is connected , there exists @xmath267 .",
    "however , since @xmath276 and @xmath49 is unguarded at @xmath141 , we conclude @xmath277 , which contradicts monotonicity of the edge search .",
    "2 .   alternatively",
    ", there exists a path @xmath222 ( with @xmath223 ) such that @xmath278 and @xmath222 is n - unguarded at @xmath141 ( so @xmath279 ) .",
    "first note that , since @xmath225 is a path , @xmath229 .",
    "now@xmath230{l}\\text{the } \\left (   t+1\\right )   \\text{-th move is } u\\rightarrow v\\\\ u\\notin\\left\\ {   x_{1}, ... ,x_{k}\\right\\ }",
    "\\\\ ux_{1} ... x_{k}\\text { is n - unguarded at } t+1 \\end{array } \\right\\ }   \\rightarrow ux_{1} ... x_{k}\\text { is e - unguarded at } t\\ ] ] since @xmath280 it follows that @xmath281 ; since also @xmath282 is not traversed at @xmath141 , it follows that @xmath283 . by the same reasoning as in the previous case , there exists @xmath284 and , since @xmath285 and @xmath49 is unguarded at @xmath141 , we conclude @xmath277 , which contradicts the edge monotonicity of @xmath55",
    ".    in short , @xmath49 can not become n - dirty at @xmath141 , i.e. , we have proved ( [ eq0444 ] ) .",
    "using this fact and an argument similar to that of theorem [ prp0401 ] , we conclude that no previously n - clear node can become n - dirty at @xmath141 .",
    "since no node is recontaminated , no edge is recontaminated either .    on the other hand , the only node _",
    "possibly _ n - cleared at time @xmath141 is @xmath45 ( no other node was entered ) and hence the only edge _ possibly _ n - cleared at time @xmath141 is @xmath10 ( if another edge was cleared , by an analysis similar to that of theorem [ prp0401 ] , we conclude that a cycle must exist in @xmath1 , which is impossible ) . hence the only edge possibly n - cleared at @xmath141 is @xmath10 .",
    "in short , in the node game we have@xmath286 the treatment of the case that @xmath49 is still guarded at @xmath141 ( i.e. , it contained more than one searcher at @xmath44 ) is omitted , since it is similar to but easier than the case of @xmath49 unguarded . from ( [ eq0401a ] ) ,",
    "( [ eq0406 ] ) and ( [ eq0407a ] ) we obtain @xmath287 and , proceeding inductively , we obtain the required result @xmath288 monotonicity and connectedness in the node game follow from the fact that these hold in the edge game and eq.([eq0447 ] ) .",
    "we will now review some results ( obtained by barriere et al .",
    "@xcite ) regarding imc  _ edge _ search on trees and will show that similar results hold for imc  _ node _ search on trees . in the following presentation",
    "the terminology and notation of @xcite is somewhat changed , to conform with the one used in the current paper .",
    "the first basic result of @xcite is the following .",
    "[ prp0404]@xcite for every tree @xmath1 there is an imc edge clearing search schedule @xmath55 which uses @xmath289 searchers .",
    "moreover , in @xmath55 all searchers are initially placed at the same node @xmath23 ( i.e. , the search schedule is rooted ) and the first step ( after placing the searchers ) consists in clearing an edge incident to @xmath23 .",
    "[ prp0405]for every tree @xmath1 we have @xmath290",
    ". there exists a _ rooted _",
    "imc  search schedule which achieves this bound .    theorem [ prp0404 ] can be extended to the following sequence of inequalities@xcite .",
    "[ prp0406]@xcite for every tree @xmath1 we have@xmath291@xmath292 furthermore , there are trees @xmath1 for which the inequality @xmath293 is strict",
    ".    barriere et al . also present the * search * algorithm @xcite , which computes a minimal edge - clearing rooted imc  schedule @xmath55 for every tree @xmath1 .",
    "the next theorem shows that @xmath55 is also a minimal _ _",
    "node-__clearing rooted imc  schedule .",
    "[ prp0413]for every tree @xmath1 , the search @xmath55 produced by the * search * algorithm is    1 .   a minimal edge - clearing imc  search of @xmath1 , which is also rooted ; 2 .",
    "a minimal node - clearing imc  search of @xmath1 , which is also rooted .",
    "part 1 of the theorem is proved as lemma 9 in @xcite .",
    "let us now prove part 2 . since @xmath55 is an edge - clearing strategy it is also node - clearing .",
    "we next show it is minimal .",
    "let us first consider the case of trees @xmath1 such that @xmath294 .",
    "it is easy to see that such trees are paths of the form @xmath295 , and * search * produces the obvious  edge clearing schedule : @xmath296 , @xmath297 , ...",
    "( or the reverse , starting at @xmath298 ) which is also a rooted minimal node clearing imc  schedule .",
    "suppose now that @xmath299 .",
    "by part 1 , * search * will produce a rooted minimal edge clearing imc  schedule @xmath55 . also , by relaxing the requirement that all searchers are placed into the graph in the first move ( in other words , by interspersing searcher placements with edge slidings ) we can obtain from @xmath55 a new search schedule @xmath300 which    1 .",
    "uses the same number of searchers as @xmath55 * * ( i.e. * , * @xmath301 * * ) ; * * 2 .",
    "is rooted ( i.e. all searcher placements are into @xmath23 ) ; 3 .",
    "satisfies either * c1 * or * c2 * of theorem [ prp0402 ] ; 4 .   produces the same sequence of clear graphs @xmath302 as @xmath55  ( with a slight time adjustment , to account for the changes in searcher placement times ) .",
    "hence @xmath300 satisfies the conditions of theorem [ prp0402 ] and is imc  in the edge game which means that , using @xmath300 , we have @xmath303 from this also follows that @xmath300 is a node clearing rooted imc  search schedule of @xmath1 .",
    "now take another node clearing imc  search of @xmath1 , call it @xmath304 , which is minimal for the node game ( i.e. , @xmath305 @xmath306 ) . then , by theorem [ prp0401 ] , @xmath304 is also edge clearing , hence@xmath307 on the other hand , since @xmath300 is node clearing , @xmath308 hence @xmath309 which completes the proof .",
    "[ prp0414]for every tree @xmath1 we have @xmath310 .",
    "[ prp0416]theorem [ prp0413 ] shows that the barriere * search * algorithm can be used to compute a rooted imc  node clearing schedule for every tree @xmath1 .",
    "how good is such a schedule ?",
    "in other words , can we node clear a tree @xmath1 with fewer than @xmath306 searchers ?",
    "we can certainly do this with an internal ( non - monotone , non - connected )  search . for example , let @xmath311 be the complete binary tree of height @xmath312 ; then @xmath313 , while @xmath314 ; but we do not know the values of @xmath315 and @xmath316 . more generally , we do not have the analog for node search of the inequalities ( [ eq0451 ] ) .",
    "it is easy to see that@xmath317{c}s_{n}^{im}\\left (   \\mathbf{g}\\right ) \\\\",
    "s_{n}^{c}\\left (   \\mathbf{g}\\right )   = s_{n}^{ic}\\left (   \\mathbf{g}\\right ) \\end{array } \\leq s_{e}^{mc}\\left (   \\mathbf{g}\\right )   = s_{e}^{imc}\\left (   \\mathbf{g}\\right )   \\label{eq0452}\\ ] ] for every graph @xmath0 and , in particular , for every tree @xmath1 ( and the inequalities in ( [ eq0452 ] ) can be strict ) .",
    "refining ( [ eq0452 ] ) to something like ( [ eq0451 ] ) is a subject of our future research .",
    "the question is of special interest to us because , as already mentioned , the one _ absolute _ requirement for robotic pursuit / evasion is internality ; monotonicity and connectedness are desirable but not indispensable .",
    "[ prp0417]a basic component of barriere s * search * algorithm is the @xmath318 labeling  of edges , performed by the auxiliary * label * algorithm@xcite . as will be seen in the next section , the barriere @xmath318 labels are also used by our gsst algorithm to node - clear _ general graphs_.",
    "we now turn to the study of rooted imc node searches of an arbitrary graph @xmath2 ( which will always be assumed to have @xmath6 nodes , i.e. , @xmath7 ) . in every such search ,",
    "the @xmath44-th move has the form @xmath319 , where @xmath320 or , perhaps , @xmath321 , the source  node .",
    "we present several variants of a basic node clearing algorithm .",
    "all variants are guaranteed to find a node clearing search schedule ; we prove that two of the variants will find a minimal schedule with probability @xmath322 where @xmath323 and @xmath324 is the number of iterations of the algorithm ; even non - minimal search schedules require a reasonably small number of searchers , as will be seen by the experiments of section [ sec06 ] .",
    "our basic algorithmic idea is motivated by the following rather simple observation : _ every rooted imc  node - clearing search of _",
    "@xmath0 _ generates a spanning tree_. this observation can be refined in the form of the following theorem .",
    "[ prp0501]given a graph @xmath2 and a rooted imc node clearing search @xmath55 of @xmath0 .",
    "the clearing moves of @xmath55 generate a sequence of trees , @xmath325 , where ( for @xmath326 )  @xmath327 and the following hold :     1 .",
    "@xmath328 is the empty graph ( @xmath329 , @xmath330 ) ; 2 .",
    "@xmath331 is a spanning tree of @xmath332 , @xmath333 ) ; 3 .   for @xmath326 :",
    "@xmath334 , @xmath335 ( in other words @xmath336 is a subtree of @xmath337 ) ; 4 .   for @xmath326 : @xmath338 , and for @xmath339 : @xmath340 , with @xmath341   $ ] .",
    "since @xmath55 is monotone , it involves @xmath6 clearing moves .",
    "@xmath328 is the empty graph .",
    "@xmath342 is formed by the first move of @xmath55 , which consists in placing a searcher at the root node .",
    "so @xmath342 is the tree with a single node and trivially has @xmath343as a subgraph .",
    "suppose * d3 *  and * d4 *  hold up to @xmath344 and consider the @xmath345-th clearing move of @xmath55 . since @xmath55 is connected , we add to @xmath337  one node @xmath346 and ( as explained in the proof of theorem [ prp0401 ] ) _ exactly _ one edge @xmath347 ( with @xmath348   $ ] ) to obtain a new tree @xmath349 ( of @xmath350 nodes and @xmath351 edges )  which also satisfies  * d3 *  and * d4*. hence * d3 *  and * d4 *  hold for @xmath352 . at @xmath353",
    ", @xmath354 contains @xmath6 nodes , hence @xmath355 ; since @xmath331 is a tree , it is a spanning tree of @xmath0 .",
    "[ prp0502]an abbreviated statement of theorem [ prp0501 ] could be : every rooted imc node clearing search of @xmath0 specifies a spanning tree of @xmath0 * * and an order of clearing the nodes .",
    "but the order must be consistent with the edge structure of the graph and the spanning tree ( e.g. , we can not use an order of node clearing which requires non - existent edges ) .",
    "this consistence is exactly what conditions * d3 *  and * d4 *  describe .",
    "theorem [ prp0501 ] gives the motivation for our algorithm gsst ( * * g**__uaranteed * * s**earch with * * s**panning * * t**rees _ _ ) , which is informally described below .",
    "* input : * graph @xmath0 select a spanning tree @xmath1 of @xmath0 and a root @xmath356 of @xmath1 find a rooted imc node - clearing search @xmath357 of @xmath1 apply @xmath55 to @xmath0 send a `` guard '' to @xmath49 execute @xmath186 * output : * the search @xmath55 obtained by combining @xmath357 with the guard moves    [ alg : random ]    note that , by construction , all clearing moves take place along edges of the spanning tree @xmath1 .    in the above description",
    "we have used the term guard . stated informally ,",
    "the searchers play two roles :  _ tree searchers _  perform the clearing moves , always along the edges of the spanning tree ; _ guards _",
    "are stationary and block potential recontamination paths .",
    "however , note that a particular searcher can change roles during the course of the search .",
    "the main advantage of the gsst  algorithm is that it is _",
    "a random spanning tree @xmath1 can be quickly generated and searched .",
    "since @xmath1 and @xmath0 have the same node set , node - clearing @xmath1 in a _ node - monotone manner _",
    "results in node - clearing @xmath0 as well .",
    "the main issue is : _ how many guards will be required to block recontamination through non - tree edges of _ @xmath358 ?",
    "the number usuallly turns out to be quite reasonable , because ( a )  guards can be reused and ( b )  tree searchers  can also be used as guards when they do not perform clearing moves .",
    "both the labeling and the traversal phase of gsst  can be executed in either a centralized or distributed manner ; the latter is useful for robotic applications , where each robot can share some of the computational load . in the distributed implementation , all searchers share the underlying spanning tree and labeling .",
    "when a searcher reaches a node , he checks to see if he can move without recontamination .",
    "if he can , he determines his next move based on the traversal strategy , and he shares this move with the team .",
    "hence gsst has short execution time and can be run repeatedly ( in reasonable time ) , using many different ( randomly selected )  spanning trees .",
    "our algorithm depends on the quick discovery of a spanning tree corresponding to a minimal or near - minimal search ( theorem [ prp0501 ] ) .",
    "our experiments in section [ sec06 ] show that gsst discovers near - minimal searches in only a short time for several families of complex graphs .",
    "an important characteristic of the gsst  algorithm is its anytime - ness .",
    "anytime algorithms return a partial answer before completion and they keep providing improved answers , the improvement increasing with computation time @xcite .",
    "gsst  has these characteristics , as will be understood in section [ sec0502 ] .",
    "namely , gsst  is characterized by monotonicity ( the solution only improves over time ) , recognizable quality ( the quality of the solution , i.e. number of searchers , can be determined at run time ) , consistency ( the algorithm will not spend too much time finding a single solution ) , and interruptibility .",
    "a detailed description of the gsst algorithm is given by the following pseudocode on p .. the notation @xmath359 means that the move @xmath360 is appended to the previously determined search schedule @xmath55 ( i.e. , becomes the next move of @xmath55 ) .",
    "several subroutines appearing in the following listing will be discussed presently .",
    "[ gsst ]    * input : * @xmath0 : a graph ; @xmath324 : no .",
    "of spanning trees to use .",
    "@xmath363 @xmath1=*generatetree*(@xmath0 ) randomly choose root @xmath356",
    "@xmath364 @xmath365 , @xmath366 @xmath367 , @xmath368 @xmath369 @xmath318=*r - label(t ) * @xmath10=*selectedge*(@xmath370 ) move that searcher to @xmath49 _ staying inside the clear graph _",
    "@xmath371 @xmath372 , @xmath373 @xmath374 , @xmath375 @xmath369 @xmath364 @xmath376 @xmath377 * output : * node clearing schedule @xmath378 .",
    "[ alg : random ]    the following remarks explain the operation of the algorithm .    1 .",
    "generate a random spanning tree @xmath1 by * generatetree .",
    "* we have used two different methods of random spanning tree generation . 1 .",
    "the _ uniform _ method is an implementation of wilson s @xcite _ loop erased random walk algorithm_. 2 .",
    "the _ dfs _ method selects a root node and randomly moves down the tree in a depth - first manner . at each node ,",
    "a random incident edge is chosen and set as an edge in the spanning tree",
    ". a visited list is maintained , and when a node is visited more than once , the edge used to reach it the second time is set as a non - tree edge .",
    "this eliminates cycles in the graph and thus generates a tree .",
    "when a leaf is reached , the algorithm recurses to ensure that all nodes are included in the tree ( i.e , it is a spanning tree of the original graph ) .",
    "the motivation for this method is to bias towards spanning trees that require fewer guards .",
    "the intuition is that a dfs traversal will generate only a few nodes with non - tree edges , thus leading to few required guards .",
    "2 .   label the edges of @xmath1 by the * r - label * algorithm ( this , a modification of barriere s * label * algorithm , is listed and discussed in appendix [ seca ] ) .",
    "3 .   while n - dirty nodes still exist , select an n - dirty edge @xmath10 of @xmath1 ( by * selectedge , * to be discussed presently ) . let a searcher traverse @xmath10",
    "if this does not cause node recontamination staying inside the clear graph  is actually a simplification , i.e. , in the interest of brevity , we do not indicate how such a path is obtained ; however this is always possible , usually in more than one ways . ] ; if no such searcher exists , then use a new searcher ( originally placed at the root )  to traverse @xmath10 .",
    "4 .   repeat the process until all nodes are n - cleared .",
    "( hence the algorithm does not allow node recontamination and will generate as many searchers as necessary to prevent it ) .",
    "when all nodes have been n - cleared , a rooted imc node clearing search has been generated , which performs all its clearing moves along the edges of @xmath1 .",
    "go back to step 1 and repeat the process with a new spanning tree . 7 .",
    "after the maximum number of trees and ( corresponding searches ) has been generated , return a search @xmath379 which attains @xmath380 , the minimum value of @xmath381 .",
    "the subroutine * selectedge * chooses an n - dirty edge @xmath10 _ belonging to _ @xmath1 and adjacent to the current clear graph @xmath382 .",
    "there are several ways to perform this selection .    1 .",
    "* labeled selection ( l ) .",
    "* select the next edge @xmath10 of @xmath1 to be traversed according to the barriere @xmath318 labels ( as in algorithm * r - search , * presented in appendix [ seca ] ) ; however , if traversing @xmath10 would cause recontamination then select the next edge in the barriere sequence ; if , at some stage of the search , traversing _ any _ edge of @xmath1 would cause recontamination ( i.e. , if all searchers are stuck ) then introduce a new searcher at the root .",
    "2 .   * labeled selection with randomized tie - breaking ( lr ) . * same as the previous except that ties of edge labels are broken randomly .",
    "3 .   * randomized selection ( r ) . * choose @xmath10 randomly ( without making _ any _ use of the barriere labeling )  by a uniform probability on all n - dirty edges _ belonging to _ @xmath1 and adjacent to @xmath382:@xmath383{cl}c\\text { } & \\text{if } u\\text { is n - clear}\\ \\text{and } uv\\text { is n - dirty}\\ \\text{and an edge of } \\mathbf{t}\\text{\\textbf{;}}\\\\ 0 & \\text{else.}\\end{array } \\right.\\ ] ] 4 .",
    "* labeled weighted selection ( lw ) . *",
    "this rule is intermediate between r and l : edge selection is still random but , instead of a uniform probability distribution , the probability of an edge @xmath10 being selected is inversely proportional to its barriere @xmath318 label .",
    "label dominated selection * * ( ld ) .",
    "* this can be done by labeling edges that lead to parts of the graph that are trees ( subtrees of the graph ) .",
    "a list of searchers who can move without recontamination can be maintained during search .",
    "if an edge adjacent to @xmath384 leads to a subtree of the graph , and enough free searchers are available , clearing this subtree can only improve the search strategies .    by using each of the above rules in the basic  gsst algorithm",
    ", we obtain _ ten _ gsst variants : uniform gsst - l , uniform gsst - lr , ... , uniform gsst - ld , dfs  gsst - l , ... , dfs  gsst - ld .",
    "these variants ( except for the two gsst - r s ) utilize the barriere labeling , _ _ but do not necessarily produce a barriere traversal of the spanning tree__. in a sense randomized selection is the simplest or most naive rule that can be used to select the next move of the search schedule :  every n - dirty edge of @xmath1 ( adjacent to the clear graph )  is equally likely to be selected . the remaining three rules can be understood as ways to bias the probability by which edges are selected in some meaningful way .",
    "the effectiveness of these rules will be judged by the experiments of section [ sec06 ] . from the theoretical point of view",
    ", we will show in section [ sec0503 ]  that the uniform gsst - r and uniform gsst - ld will find a minimal node clearing schedule with probability @xmath322 where @xmath324 is the number of iterations and @xmath385 ; we conjecture that this property does not hold for barriere selection . as a practical matter ,",
    "the issue is how large @xmath324 has to be for @xmath322 to be sufficiently close to 1 .",
    "however , the experiments of section [ sec06 ] indicate that the above rules find good search schedules in very reasonable time .",
    "variants of gsst can also be produced by replacing the * generatetree * subroutine with an _ exhaustive generation _ of all spanning trees of @xmath0 ( it can be used in conjunction with any of the above variants of * selectedge * ) .",
    "to do this we have used char s spanning tree enumeration algorithm @xcite .",
    "exhaustive enumeration is feasible only for relatively small graphs .",
    "finally note that the search schedules produced by ( every variant of )  gsst are imc .",
    "this holds for the search of both @xmath1 and @xmath0 . indeed , for the search of @xmath0 to work ,",
    "the search of @xmath1 _ must _ be imc .",
    "in other words , no obvious modification of gsst will produce , for example , an internal , connected , _",
    "non - monotone _ node - clearing search of @xmath0 .",
    "the question arises :  how good is a minimal imc  node clearing of @xmath0 ( as compared to , for example , an internal but not monotone / connected node clearing ) ?",
    "this is the question already hinted at in remark [ prp0416 ] .",
    "let us close this section by repeating that _ the basic idea of gsst  is to perform all clearing moves along the edges of a spanning tree_. this idea exploits the facts that ( a )  spanning trees can be both generated and searched quickly and ( b )  blocking recontamination does not require an excessively large number of guards ( because a searcher can change roles as a guard and a tree searcher ) .",
    "[ prp0504]given a graph @xmath0 and a search @xmath55 of @xmath0 , the _ frontier _  at @xmath44 ( under @xmath55 ) is @xmath386 i.e. , the n - clear nodes which are connected to n - dirty nodes .",
    "[ prp0505]in a node search , for every @xmath44 , the nodes @xmath387 are guarded .",
    "a frontier node @xmath49 is by definition n - clear and adjacent to an n - dirty node @xmath45 .",
    "this is only possible if @xmath49 is guarded .",
    "[ prp0506]consider a rooted imc node clearing search @xmath55 of @xmath0 .",
    "let @xmath388 and suppose the clearing moves of @xmath55 take place at times @xmath389 ; let also @xmath388 .",
    "the @xmath351-th _ phase _ of @xmath55 ( for @xmath326 ) is the time interval @xmath390   $ ] , i.e. the interval between the @xmath391-th and @xmath351-th clearing move .",
    "the following remarks are rather obvious . for @xmath392 , a _ target edge _ @xmath393 ( with @xmath394   $ ] ) corresponds to the @xmath395-th phase ( here we take the root node to be @xmath396 ) .",
    "while @xmath397   $ ] the algorithm moves a searcher towards @xmath393 . for @xmath398",
    "$ ] , @xmath393 is n - dirty , @xmath59 is n - clear , @xmath399 is n - dirty . at @xmath400",
    "we have @xmath401 and @xmath393 , @xmath399 are",
    "n - cleared .",
    "[ prp0507]given a graph @xmath2 and a rooted imc node clearing search @xmath55 of @xmath0 , produced by either gsst - r or gsst - lw , let @xmath261 , @xmath402 , ... , @xmath403 @xmath404be the times at which clearing moves take place ; let also @xmath388 .",
    "then for @xmath405    1 .   for @xmath406   $ ] : @xmath407 ; 2 .   for @xmath406",
    "$ ] : every @xmath408 contains exactly one searcher , except one node @xmath409 which possibly contains two searchers ; 3 .   for @xmath410 : every @xmath411 contains exactly one searcher .",
    "the proof is by induction on @xmath351 .",
    "items 1 , 2 , 3 of the theorem hold for @xmath412 , @xmath413   = \\left\\ {   0,1\\right\\ }   $ ] .",
    "suppose they also hold up to the @xmath395-th phase . in the interval",
    "@xmath414 $ ] a target edge @xmath415 ( with @xmath416   $ ] ) is selected and an available searcher is sent towards @xmath415 . because gsst - r / gsst - lw always selects for clearing an edge adjacent to the clear graph , @xmath417 @xmath418 , @xmath419 @xmath420 .",
    "there are three cases .",
    "* i*.  @xmath59 is neighbor of a single n - dirty node , namely @xmath421 . in this case",
    "@xmath422 ( i.e. , @xmath421 is n - cleared in one step ) and @xmath423   = \\left\\ {   t_{m},t_{m}+1\\right\\ }   $ ] .",
    "node @xmath424 ;  node @xmath421 may or may not belong to @xmath425 but , at any rate , it contains exactly one searcher ; no searchers enter or exit any other nodes , hence ( by the inductive hypothesis )  all @xmath426 contain exactly one searcher .",
    "* ii*.  @xmath59 is neighbor of more than one n - dirty nodes , one of which is @xmath421 , and there are free searchers . since @xmath59 is a frontier node , by hypothesis it contains a single searcher who , consequently , is stuck .",
    "however , if free searchers are available inside n - clear , non - frontier nodes , one of these searchers will be sent to @xmath415 by a sequence of moves . at every @xmath44 during this sequence ,",
    "the searcher may enter a frontier node @xmath427 ; for that particular @xmath44 , @xmath427 will be the only frontier node which contains two searchers . at @xmath428",
    "the searcher will be located at @xmath59 ( which will now contain two searchers ) and at @xmath429 he will enter @xmath421 ; this leaves at @xmath429 every @xmath430 with a single searcher and also places a searcher at @xmath421 .",
    "the only node which may have been added to the frontier is @xmath421 which contains a single searcher ; every other node @xmath431 was previously in the frontier , contained a single searcher and , if a searcher entered @xmath49 at some @xmath432   $ ] , it exited @xmath49 at @xmath141 ; hence every such node at @xmath429 contains a single searcher .",
    "* iii*.  the final case is when all frontier - located searchers are stuck and there are no searchers inside n - clear , non - frontier nodes . in this case",
    "a new searcher is placed at the root node and the rest of the analysis is identical to that of case ii .",
    "hence items 1 , 2 , 3 also hold for @xmath414   $ ] and we can complete the induction for @xmath326 .",
    "[ prp0508]given a graph @xmath2 and a tree sequence @xmath433 which satisfies conditions * d1-d4 * of theorem [ prp0501 ] .",
    "then  uniform gsst - r / gsst - lw with @xmath434 ( i.e. , using a single spanning tree ) has a nonzero probability of producing a search @xmath55 which generates @xmath433 .    the probability that algorithm 1 generates the tree sequence @xmath435 is @xmath436   \\pr\\left (   \\mathbf{t}_{0}|\\mathbf{t}_{n}\\right ) \\pr\\left (   \\mathbf{t}_{n}\\right )   .\\ ] ] note that the conditioning in the above expression _ always _ includes @xmath331 , since this is the first choice made in running gsst - r / gsst - lw .",
    "now obviously , @xmath437 . by wilson s theorem 1 @xcite , @xmath438 for every spanning tree @xmath331 .",
    "also , @xmath439 is the probability of expanding ( at the @xmath351-th step )  @xmath336 by the edge @xmath440 which , by the construction of both gsst - r and gsst - lw , is always positive .",
    "finally , @xmath441 .",
    "hence @xmath442 for every sequence @xmath443 .",
    "[ prp0509]given a graph @xmath2 and a rooted imc node clearing search @xmath55 of @xmath0 ; let @xmath435 be the tree sequence generated by @xmath55 .",
    "let @xmath300 be a search produced by either gsst - r or gsst - lw  and _ also _ generating @xmath435",
    ". then @xmath444 .",
    "the proof is exactly the same for gsst - r and gsst - lw , so we only prove the first one , by induction .",
    "let @xmath389 be the clearing times of @xmath55 and @xmath445 be the clearing times of @xmath300 .",
    "also let @xmath446    at @xmath447we have @xmath448    the only times at which @xmath449 may change are @xmath450 , @xmath451 .",
    "suppose that@xmath452 further , suppose that at @xmath453 a new searcher is introduced in @xmath300 .",
    "this can only happen ( in the @xmath300 search ) if all of the following hold :    1 .   at @xmath454",
    "exactly @xmath455 searchers exist in @xmath0 ; 2 .",
    "there are no searchers inside nodes @xmath456 ( i.e. , all searchers are located inside frontier nodes ) ; 3 .",
    "all searchers are stuck ( i.e. , moving a searcher out of a frontier node @xmath49 exposes @xmath49 to recontamination ) .",
    "the sequence @xmath457 along with the clearing times determines the frontier @xmath458 for every @xmath44 .",
    "hence @xmath300 at @xmath454 has the same frontier as @xmath55 at @xmath459 . if conditions 1 - 3 above hold in @xmath300 , then every searcher is located in a frontier  node and is stuck .",
    "it is possible that non - stuck searchers exist in @xmath55 ( located either in frontier or non - frontier nodes ) but this also means that @xmath460 ; hence adding a searcher in @xmath300 at @xmath453 preserves @xmath461 since no searchers are added in @xmath300 for @xmath462   $ ] and no searchers are ever removed in @xmath55 ( i.e. , @xmath463 ) we also get @xmath464 from the above inequality inductively we get @xmath465which proves the lemma .",
    "[ prp0510]given a graph @xmath466 .    1 .",
    "uniform gsst - r will generate a minimal rooted imc clearing node search of @xmath0 with probability greater than or equal to @xmath467 where @xmath324 is the number of iterations and @xmath468 .",
    "2 .   uniform gsst - lw will generate a minimal rooted imc clearing node search of @xmath0 with probability greater than or equal to @xmath469 where @xmath324 is the number of iterations and @xmath470 .",
    "the proof is exactly the same for gsst - r and gsst - lw , so we only prove the first one .",
    "@xmath0 has at least one minimal rooted imc node  clearing search @xmath55 of @xmath0 .",
    "let @xmath433 be the tree sequence generated by @xmath55 .",
    "by lemma [ prp0508 ] , gsst - r has a nonzero probability , call it @xmath471 , of generating _ in a single iteration _ a search @xmath300 with the same tree sequence as @xmath55 . then , by lemma [ prp0509 ] , @xmath472 since @xmath55 is minimal , @xmath473 and so @xmath300 is minimal too .",
    "now , the probability of _ not _ generating @xmath300 in a single iteration is @xmath474 ; and the probability of _ not _ generating @xmath300 in @xmath324 iterations is @xmath475 , while the probability of generating @xmath300 in @xmath324 iterations is @xmath467 .",
    "finally , let us mention that the gsst algorithm can be modified to produce an edge- rather than node - clearing search using the following theorem .",
    "[ prp0511]given a graph @xmath0 and an imc node clearing search @xmath55 using @xmath476 searchers , there is an edge clearing search @xmath300 using either @xmath476 or @xmath477 searchers .",
    "suppose that @xmath0 contains @xmath478 edges , that the length ( i.e. , number of moves )  of @xmath55 is @xmath95 and that @xmath479 . the new search",
    "@xmath300 will consist of the @xmath55 moves ( executed at integer times @xmath42 ) combined with the moves of an extra searcher , the edge cleaner , who will only ( if at all )  move at _ fractional _ time steps of the form @xmath480 , @xmath481 ( fractional times are introduced to preserve the alignment  of @xmath55 and @xmath300 , i.e. to ensure @xmath482 at integer times ; of course , once @xmath300 has been obtained , the time scale can be renormalized , so that _ all _ moves occur at integer times ) .",
    "we will use the notation @xmath483 .",
    "we will describe the moves of of the edge cleaner on a step - by - step basis , for @xmath42 in such a manner that at the same time we will complete an inductive proof of the fact that@xmath484 recall that @xmath485 is the frontier , i.e. , the set of n - clear nodes connected to n - dirty nodes ( and similarly for @xmath486 ) and that the frontier nodes are always guarded in both the node and edge game .",
    "for @xmath75 we have @xmath487 , @xmath488 , and the edge cleaner is not used , so @xmath489 .",
    "now suppose that @xmath490 and consider @xmath140 .",
    "let the @xmath197-th move of @xmath55 be @xmath186 .",
    "we consider three cases .    1",
    ".   * case i*. if @xmath49 is an interior node ( i.e. ,  a non - frontier node :  @xmath491 ) , then @xmath10 is an edge of @xmath492 and no new nodes / edges are cleared , either in the node or edge game .",
    "no path becomes unguarded , and so no recontaminaiton is possible either .",
    "hence @xmath493 the edge cleaner is not used , hence also @xmath494 2 .",
    "* case ii*. if @xmath49 is a frontier node ( @xmath495 ) which contains a _ single _ searcher at @xmath130 , then @xmath49 becomes unguarded at @xmath44 .",
    "clearly @xmath496 it is also easy to see that there is no edge @xmath497 with @xmath498 and @xmath499 : if such an edge existed , then we would have @xmath500 ( @xmath32 was not entered at @xmath44 ) and so @xmath501 ; but @xmath502 ( it was guarded at @xmath130 ) and so node monotonicity of @xmath55 would be violated .",
    "+ take any edge @xmath503 .",
    "edge @xmath504 can not be recontaminated in the node game ( no node was recontaminated ) .",
    "edge @xmath504 can not be recontaminated in the edge game either ; for this to happen there must exist an e - unguarded path from @xmath504 to some @xmath505 ; but all such paths must go through @xmath49 ( no other node became unguarded at @xmath44 )  and hence must include @xmath10 ( the only edge e - dirty at @xmath506 and incident on @xmath49 ) but @xmath45 is guarded at @xmath44 .",
    "hence no edge is e - dirtied at @xmath44 and so no node is e - dirtied either . in other words@xmath507",
    "which , together with ( [ eq5903 ] )  shows that @xmath508 . also , @xmath509 ; in both the node and edge game , @xmath49 was removed from the frontier and @xmath45 was _ possibly _ added to it . in short ,",
    "we have established ( [ eq5901 ] )  for case ii as well .",
    "+ from the previous remarks we know that , in the edge game and at time @xmath44 , no edge was recontaminated and edge @xmath10 was e - cleared .",
    "i.e.,@xmath510 in the node game , on the other hand , @xmath511 where @xmath512 , @xmath513 and there _ may _ exist other nodes @xmath514 which must ( a )  be neighbors of @xmath45 and ( b )  belong to @xmath515 .",
    "hence @xmath516 were guarded at @xmath130 and remain so at @xmath44 . in other words , at time @xmath44 the edges @xmath517 have both endpoints guarded and are n - clear but e - dirty .",
    "now we invoke the edge cleaner who ( at times @xmath518 ) moves to @xmath45 and then performs the moves @xmath519 , @xmath520 , @xmath521 , @xmath522 , ... , @xmath523 .",
    "this entire sequence can be performed in no more than @xmath524 moves , so at @xmath525 the edges @xmath526 have been e - cleared and so @xmath527 combining ( [ eq5905 ] )  and ( [ eq5906 ] )  we get @xmath528 . in short ,",
    "we have established ( [ eq5902 ] )  for case ii as well.@xmath529 3 .",
    "* case iii*. the final case to examine is when @xmath49 is a frontier node which contains more than one searcher at @xmath130 .",
    "we omit a detailed treatment because the proof combines elements from the previous two cases ; namely , recontamination does not happen ( for the same reasons as in case i ) bu the edge cleaner may possibly be required ( as in case ii ) .    hence , in all three cases considered , starting from ( [ eq5900 ] )  we have established ( [ eq5901 ] )  and ( [ eq5902 ] ) .",
    "hence we can complete the induction up to time @xmath530",
    "@xmath404which means@xmath531 eqs.([eq5907 ] )  imply that all nodes are e - cleared at @xmath95 but a few extra steps may be required to e - clear all edges ( by time @xmath532 at most ) .",
    "in this section we evaluate the performance of the gsst  algorithm by numerical experiments . some of these experiments involve specific graphs ( section [ sec0601 ] ) and others involve families of graphs ( sections [ sec0602 ] and [ sec0603 ]  in which case we present average results ) .",
    "we use ten _ variants _ of gsst , obtained by using two different methods of spanning tree generation ( uniform and dfs ) and five methods of edge traversal ( gsst - l , gsst - r , gsst - lr , gsst - lw , and gsst - ld ) .",
    "the first graph we have used appears in fig.[fig02 ] .",
    "this is a relatively simple graph ( with imc@xmath404node search number @xmath5333 )  which we use to illustrate the basic principles of gsst  operation .",
    "we node - search the graph using the ten gsst variants , each with @xmath534 generated spanning trees ; to each spanning tree corresponds a search @xmath535 , @xmath536 . in table 2",
    "we list for each gsst  variant : ( a)@xmath537 ( i.e. , the minimum number of searchers achieved by the specific combination ) , ( b )  the proportion of minimal searches out of the the @xmath324 total searches and ( c )  the time ) , on a pc  with intel dual core e7500 cpu , running at 2.93 ghz with 3 gb ram ; computation time is reported in seconds , unless otherwise indicated . ]",
    "( in sec )  required to run the @xmath324 searches .",
    "[ c]|l|l|l|l|l|l|l| & & + * edge traversal * & min@xmath404 & prop . of min & time & min & prop . of min & time +",
    "gsst - l & & & & & & + gsst - r & & & & & & + gsst - lr & & & & & & + gsst - lw & & & & & & + gsst - ld & & & & & & +    * table 2 .",
    "* node - clearing the simple graph  by the various gsst variants : minimum number of searchers attained and proportion of minimal solutions ; number of spanning trees generated is @xmath538    the true node search number ( i.e. , 3 ) has been found by every variant of gsst . generally , the dfs  variants perform better than the uniform ones , as can be seen by the higher proportion of minimal solutions achieved",
    ". a better understanding of the distribution of the number of searchers required by each search can be obtained by looking at the _ histogram _ of the distribution ; one such histogram ( for the variant with bh edge traversal and uniform spanning tree generation ) is plotted in fig.[fig03 ] .",
    "we can see that this simple graph has a high proportion of spanning trees which yield minimal schedules .",
    "an additional tool to evaluate the anytime performance of gsst is the plot of @xmath539 ( the minimum node clearing number of searchers achieved by the first @xmath395 searches ) .",
    "@xmath540 is decreasing with @xmath395 .",
    "the overall minimum achieved by gsst is @xmath541 ( having tried @xmath324 searches ) .",
    "if this minimum is achieved for a small value of @xmath395 , then the minimal solution has been obtained quickly .",
    "a graph of @xmath540 ( for the variant with labeled edge traversal and uniform spanning tree generation ) appears in fig.[fig04 ] ; as can be seen a minimal solution ( clearing the graph with three searchers ) is achieved by the seventh computed search , approximately at time @xmath542sec .",
    "the simple graph  is simple enough to have a relatively small number of spanning trees ( namely 272 , as computed by kirchoff s theorem @xcite ) and so we can also run gsst on _ all _ spanning trees ( exhaustive enumeration ) .",
    "the computation takes 0.03125 ( for the gsst - l variant ) sec and shows that 83 out of the 272 spanning trees ( _ rooted at node _ 1 ) yield minimal searches .",
    "the second graph we have used appears in fig.[fig05 ] .",
    "it consists of a root  node and two branches under it ; the left branch is a tree and the right one a grid ; hence the name tree / grid \" .",
    "the graph has @xmath5334 and we have deliberately designed it to trick  the gsst  algorithm . for the sake of definiteness consider gsst - l .",
    "if the root of the search is node 6 , then gsst - l  will find a four searcher node clearing imc  schedule .",
    "however , if the root is node 1 , then gsst - l  will only find a five searcher schedule , even after enumerating all spanning trees .",
    "a four searcher imc  node clearing schedule is possible from either starting node ; but it requires the use of a non - barriere edge traversal ( for example , one produced by the gsst - r variant ) ; but gsst - l will always first send the searchers down the right branch ( towards the grid ) ; actually , going first to the left branch , towards the tree , is better ( i.e. yields a four searcher schedule ) .",
    "table 3 summarizes the results of our experiment , using the ten variants of gsst and @xmath543 spanning trees per variant .",
    "note that in this table ( as in all others ) the starting node is selected randomly .",
    "the uniform variants are able to generate minimal search schedules , but not the dfs  ones .",
    "[ c]|l|l|l|l|l|l|l| & & + * edge traversal * & min & prop . of min & time & min & prop . of min & time +",
    "gsst - l & & & & & & + gsst - r & & & & & & + gsst - lr & & & & & & + gsst - lw & & & & & & + gsst - ld & & & & & & +    * table 3 .",
    "* node - clearing the tree / grid  by the various gsst variants : minimum number of searchers attained and proportion of minimal solutions ; number of spanning trees generated is @xmath544 * *    in this case the uniform variants find four - searcher clearing schedules and hence outperform the dfs  generated ones , which can only clear the graph with five or more searchers ( e.g. , @xmath545 ) but the dfs  variants still can not achieve a four searcher clearing schedule . ] .",
    "note also the lower proportion of minimal solutions , even for the uniform variants .",
    "for example , uniform gsst - l finds @xmath546 minimal solutions .",
    "this in an indication that this graph  is indeed harder than the simple  one , at least for the gsst  algorithm . also , the tree / grid graph  has 31529 spanning trees ( and correspondingly many cycles ) which is an additional indication that it is ( much ) harder to search than the simple graph , which has 272 spanning trees",
    ". the small number of minimal solutions can also be appreciated by looking at the histogram ( for uniform gsst - l  variant it is plotted in fig.[fig06 ] ) .    however , despite the small proportion of minimal solutions , the first one is always found after a relatively small number of iterations .",
    "for example , the uniform gsst - l variant finds a four searcher schedule with the 420-th spanning tree generated ( out of a total of @xmath547 spanning trees ) , approximately at time @xmath548sec .",
    "the next graph we use has been obtained by discretization of an actual floorplan , namely the first floor of the newel - simon building in the carnegie mellon university  campus . in fig.[fig08 ] we present the actual floorplan and its discretization ; in fig.[fig09 ] we present the resulting graph ( the node numbers in fig.[fig09 ] correspond to the cell numbers in fig.[fig08 ] ) .",
    "this graph , with 60 nodes and 64  edges , appears to be more complex than the previous ones ; however it has a relatively small number of spanning trees ( namely 3604 , as computed by kirchoff s theorem ) . by visual inspection",
    "it appears very unlikely that the graph can be node - cleared with two searchers ; on the other hand , as will be seen presently , gsst can compute three - searcher clearing schedules .",
    "hence we conjecture that the search number @xmath549 is three .    applying the standard  variants of gsst  and using @xmath543 spanning trees per variant",
    "we obtain the results of table 4 .",
    "[ c]|l|l|l|l|l|l|l| & & + * edge traversal * & min & prop . of min & time & min & prop . of min & time +",
    "gsst - l & & & & & & + gsst - r & & & & & & + gsst - lr & & & & & & + gsst - lw & & & & & & + gsst - ld & & & & & & +    * table 4 .",
    "* node - clearing the nsh  graph  by the various gsst variants : minimum number of searchers attained and proportion of minimal solutions ; number of spanning trees generated is @xmath544    we see that all the gsst  variants using uniform spanning tree generation achieve the true search number , namely three .",
    "the random edge traversal variants perform poorest of all : the uniform gsst - r finds only one minimal search and the dfs gsst - r variant three . generally , while the time required to complete @xmath324 searches is higher for the nsh  graph than for the tree / grid  graph , the proportion of correct solutions is in some cases higher ( at least for the uniform variants ) .",
    "a histogram of the searchers required appears in fig.[fig10 ] , for the uniform gsst - l  variant ; for this variant the first minimal search schedule is computed at step 845 ( out of 50000 ) , approximately at time @xmath550sec .",
    "the next graph we use has also been obtained by discretization of an actual floorplan , namely the first floor of the national gallery of art , in washington , dc . in fig.[fig12 ] we present the actual floorplan and the discretization we have used ; in fig.[fig13 ] we plot the corresponding graph .",
    "this graph , has 70 nodes and 93  edges and is more complex than any of the previously used graphs .",
    "in particular , it is more complex than the nsh  graph .",
    "while the national art gallery graph has about 50% more edges than the nsh  graph , it has a _ much _ larger number of spanning , approximately 5.3@xmath551 , as compared to 3604 ; this precludes use of the gsst with exhaustive enumeration of the spanning trees .",
    "also , we have no obvious way to compute the true node search number .",
    "nevertheless , we proceed to apply the ten gsst  variants using @xmath552 spanning trees per combination .",
    "the results obtained appear in table 5 .",
    "[ c]|l|l|l|l|l|l|l| & & + * edge traversal * & min & prop . of min & time & min & prop . of min & time +",
    "gsst - l & & & & & & + gsst - r & & & & & & + gsst - lr & & & & & & + gsst - lw & & & & & & + gsst - ld & & & & & & +    * table 5 .",
    "* node - clearing the national art gallery  graph  by the various gsst variants : minimum number of searchers attained and proportion of minimal solutions ; number of spanning trees generated is @xmath553    we see that all the gsst  variants . ]",
    "find node clearing searches with five searchers . while we can not be sure that the true node search number of the national art gallery is five , we have been unable to find a lower search number using any method ( including extensive inspection by the authors ) .",
    "in addition , the middle part of the graph resembles a five - by - six grid , which is known to have a node search number of five ( see section [ sec0603 ] ) .",
    "a histogram of the searchers required appears in [ fig14 ] , for the uniform gsst - l variant ; for this variant the first minimal search schedule is found at step 101823 ( out of a total @xmath554 ) .",
    "similar results hold for the other variants .",
    "the national art gallery graph results ( as well as the nsh  ones )  show the applicability of gsst on graphs that are derived from representations of real indoor environments ( which has been the main motivation for our research ) .",
    "the methods that incorporate barriere labeling improve performance on the nsh map because it is similar to a tree ( it becomes a tree if we remove only a _",
    "edges ) . in this case ,",
    "barriere labeling , which is based on trees , helps to improve the schedules generated by gsst .",
    "the national art gallery , on the other hand , is more similar to a grid , which lessens the advantage of using barriere labeling to guide traversal ( though a significant improvement is still obtained ) .",
    "the next experiment presented involves , unlike the ones of section [ sec0601 ] , a large number of graphs belonging to the same _ family_. our goal is to evaluate the _ average _ performance of the gsst  algorithm .",
    "while , strictly speaking , the results are specific to the family of interval graphs , they also suggest general properties of the gsst  algorithm .    to evaluate the performance of gsst  we must have some estimate of the actual search number of each graph we use ; then we can compare this search number with the minimum @xmath381 achieved by gsst . to satisfy this condition",
    ", we will work with _",
    "interval graphs_. briefly , an interval graph is obtained from a _ system of intervals _",
    ", i.e. a collection of intervals of real numbers ; each interval corresponds to a graph node and two nodes are connected by an edge iff the corresponding intervals intersect .",
    "it is known @xcite that the _ ( non - monotone , non - connected )",
    "edge search number _ of an interval graph @xmath0 ( i.e. , @xmath106 )  is equal to its _ interval width _ , which is defined to be the size of the largest clique of the graph .",
    "it is also known that the interval width of an interval graph @xmath0 of @xmath6 nodes can be computed in time o@xmath555 @xcite . of course , while we know the _ edge _ search number @xmath106 exactly , this only provides an estimate of the imc  _ node_-search number @xmath556 , in which we are really interested .",
    "there is no strict inequality connecting @xmath106 and @xmath557 ; we just know that @xmath558 and @xmath559 . in general , we expect that the discrepancy between @xmath106 and @xmath557 is not too large and hence @xmath106 can be used to evaluate gsst  performance .",
    "we randomly generate interval systems ( and the corresponding interval graphs ) by the following mechanism .",
    "first we select two parameters of the family : @xmath6 , the number of intervals , and @xmath560 , the average interval length .",
    "then we generate @xmath6 intervals , the @xmath351-th interval having its left endpoint at @xmath351 and the right endpoint at @xmath561 , where @xmath562 follows an exponential probability law @xmath563 .",
    "we form the interval graph @xmath0 corresponding to this interval system and compute its interval width .",
    "we repeat the process 100 times to obtain @xmath564 interval graphs ; these form a family characterized by the parameters @xmath565 ( specified by us ) and also by the average number of edges and the average interval width .",
    "we repeat the process for five different choices of @xmath566 ; this information is summarized in table 6 .",
    "[ c]|l|l|c|c|@xmath6 & @xmath560 & * average num . of edges * & * average interval width * + & & & + & & & + & & & + & & & + & & & +    * table 6 . *",
    "characteristics of the various families of interval graphs used for the experiments .",
    "finally , we apply the ten gsst variants to each of the five familes ( using @xmath567 spanning trees per variant ) .",
    "the results are summarized in tables 7.a ( for the uniform variants ) and 7.b ( for the dfs  variants ) . in these tables",
    "every row corresponds to a family , the families being indexed by their average interval widths ( appearing in the first column ) .",
    "each of the remaining columns corresponds to one gsst  variant and lists the average ( over the 100 graphs )  minimum number of searchers achieved by the respective variant .",
    "hence , an estimate of the efficiency of the gsst  variants can be obtained by comparing the first column of each table to the remaining ones .",
    "for example , in the first row of table 7.a we see that all uniform gsst  variants node clear the graphs of the first family with fewer searchers ( on the average )  than those predicted  by the interval width of the graphs ( e.g. , @xmath568 ) . as we proceed down the rows of table 7.a to graphs of higher interval width ( and , presumably , of greater complexity ) the average number of searchers required to clear a graph increases above the average interval width .",
    "for example , in the last row the average interval width is 15.53 and the average minimum number of searchers required by the uniform gsst - l variant is 19.05 ; in other words the uniform gsst - l requires @xmath569 more searchers than expected by the interval width estimate .",
    "things get better with the dfs  variants ; for example , for the @xmath570 family , the searcher overhead incurred by the dfs gsst - l  variant is @xmath571 , which is actually quite good for graphs of such high complexity .",
    "[ c]|l|l|l|l|l|l|**av .",
    "width * * & * gsst - l * & * gsst - r * & * gsst - lr * & * gsst - lw * & * gsst - ld * + & & & & & + & & & & & + & & & & & + & & & & & + & & & & & +    * table 7.a * : average minimum number of searchers required to node - clear each family of interval graphs  by the uniform gsst variants ; number of spanning trees generated is @xmath572    [ c]|l|l|l|l|l|l|**av .",
    "width * * & * gsst - l * & * gsst - r * & * gsst - lr * & * gsst - lw * & * gsst - ld * + & & & & & + & & & & & + & & & & & + & & & & & + & & & & & +    * table 7.b * : average minimum number of searchers required to node - clear each family of interval graphs  by the dfs gsst variants ; number of spanning trees generated is @xmath572    the results on interval graphs show that gsst can yield near - minimal schedules on a large class of graphs .",
    "they also demonstrate that gsst  scales well with increasing complexity both in performance and computation time .",
    "this is a direct result of the linear scalability of the algorithm in the number of nodes in the environment .",
    "we now present some experiments involving grid graphs , i.e. graphs with nodes located at points with integer coordinates ( an example appears in fig .",
    "[ fig18 ] ) .",
    "it is easily seen that a grid graph of dimension @xmath573 ( i.e. containing nodes with coordinates @xmath574 ) can be node cleared using @xmath575 searchers ; the corresponding search schedule is obvious of the grid is less than or equal to the width @xmath576 ) place @xmath577 searchers on one of the vertical sides of the grid and slide them horizontally to the other vertical side . ] .",
    "however , for a _ general _ graph search algorithm ( such as gsst ) which must work without assuming any special structure of the graph , grid graphs are potentially extremely hard , because they have many cycles and many spanning trees , only a few of which correspond to minimal search schedules .",
    "in this experiment we use 6 grid graphs , with dimensions starting at @xmath578 and going up to @xmath579 . to each such graph",
    "we apply the ten gsst variants ; in tables 8.a ( uniform st  generation variants ) and 8.b ( dfs  st  generation variants ) we list the minimum search number attained by each variant on each graph ( @xmath324 , the number of spanning trees generated per graph is also listed , in the last column ) .",
    "let us also note that the total execution time for this experiment is approximately 25 hours , reflecting ( a ) the large number of graphs used , ( b ) the high complexity of many graphs , ( c )  the large number of spanning trees used ( the _ much smaller _ execution time for each individual graph and gsst  variant is not listed , for economy of space ) .",
    "[ c]|l|r|r|r|r|r|r| + * graph dim . * & * gsst - l * & * gsst - lr * & * gsst - r * & * gsst - lw * & * gsst - ld * & * no.trees * + & 5 & 5 & 5 & 5 & 5 & 10@xmath580 + & 7 & 7 & 7 & 7 & 7 & 2@xmath58110@xmath580 + & 8 & 8 & 8 & 8 & 8 & 3@xmath58110@xmath580 + & 10 & 9 & 9 & 9 & 9 & 3@xmath58110@xmath580 + & 11 & 11 & 11 & 10 & 11 & 4@xmath58110@xmath580 + & 13 & 13 & 13 & 13 & 13 & 5@xmath58110@xmath580 +    * table 8.a*. minimum search number attained by the uniform gsst variants on the full - grid graphs .    [ c]|l|r|r|r|r|r|r| + * graph dim . * & * gsst - l * & * gsst - lr * & * gsst - r * & * gsst - lw * & * gsst - ld * & * no.trees * + & 6 & 6 & 6 & 6 & 6 & 10@xmath580 + & 7 & 7 & 8 & 7 & 7 & 2@xmath58110@xmath580 + & 9 & 9 & 9 & 9 & 9 & 3@xmath58110@xmath580 + & 11 & 11 & 11 & 11 & 11 & 3@xmath58110@xmath580 + & 12 & 13 & 12 & 13 & 12 & 4@xmath58110@xmath580 + & 14 & 14 & 14 & 14 & 15 & 5@xmath58110@xmath580 +    * table 8.b . * minimum search number attained by the dfs  gsst variants on the full - grid graphs .",
    "we see that , on the grids , the uniform variants perform better than the dfs  ones ; this is exactly the opposite situation from what happens in interval graphs . with few exceptions ,",
    "the uniform variants ( table 8.a )  either attain the actual minimum search number ( for the @xmath578 graph ) or incur a small overhead of 1 or 2 extra searchers .",
    "the situation changes with the @xmath579 graph , where the minimum attained search number is 13 , with a 30% overhead over the true @xmath582 .",
    "however , the @xmath579 grid graph is very complex , with 100 nodes , 180 edges and 5.6943@xmath583 spanning trees .",
    "judging from the distribution of the attained search numbers ( which , for economy of space , is not displayed here ) lower search numbers _ can _ be attained but they require a much larger number of spanning trees .",
    "to get an idea of the complexity of the full grid graphs , we list in table 8.c . the number of spanning trees for each of the six graphs used .",
    "this provides a measure of the hardness of node - clearing the graph .",
    "this actually quite reasonable : a graph with many cycles ( and many spanning trees )  is harder to clear because it contains many escape routes for the evader .",
    "[ c]|l|r|**graph dim . * * & * no . of spaning trees * + & 5.57560@xmath584 + & 3.2566@xmath585 + & 1.9872@xmath586 + & 1.2623@xmath587 + & 8.3266@xmath588 + & 5.6943@xmath583 +    * table 8.c . * number of spanning trees for each of the full - grid graphs    on the positive side , we see that node - clearing schedules can be computed for the full grid graphs using slightly more than the minimum number of searchers and in reasonable computation time . for example",
    ", the uniform gsst - l  variant finds the first 8-searcher clearing schedule for the @xmath589 graph in under 2 mins and an 11-searcher clearing schedule for the @xmath590 graph in under 10 mins . considering that ( due to the large number of cycles )  grid graphs are potentially some of the hardest graphs for gsst , we find these results to be quite satisfactory .",
    "our final experiment involves what we call depleted grid graphs .",
    "these are obtained as follows .",
    "first we choose two parameters , @xmath577 and @xmath576 , the length and width of the grid . just like with the full grid graphs , we place nodes at the positions @xmath591 .",
    "we also connect all nearest neighbor nodes along the following lines    1 .   one horizontal line : @xmath592 , 2 .",
    "@xmath577 vertical lines:@xmath593 , for @xmath594    obtaining a tree of the form indicated by the solid edges in fig.[fig18 ] .",
    "finally , we consider all pairs of nearest neighbors @xmath595 , @xmath596 which are not already connected and add to the graph an edge connecting each such pair with probability @xmath597 .",
    "the resulting graph @xmath0 is a subgraph of the full @xmath598 grid and has @xmath599 ; in other words , @xmath600 yields an upper bound ( useful for estimating the performance of gsst ) of @xmath557 .",
    "it seems reasonable that , on the average , @xmath557 is an increasing function of @xmath597 and for @xmath601 the bound is tight , i.e. @xmath602 ; it will be useful to keep this in mind when evaluating the results of the experiment .",
    "note also that , as @xmath597 approaches 0 , the graph becomes more similar to a tree ( has fewer cycles ) .",
    "we generate twelve families of depleted grids ; namely we use dimensions @xmath578 , @xmath589 , @xmath603 , @xmath579 and @xmath597 values 0.4375 , 0.7500 and 0.9375 , yielding twelve combinations .",
    "we generate _ fifty _ graphs from each family and apply to each of these the ten gsst  variants , _ using _",
    "@xmath604 _ spanning trees for each graph_. the results appear in tables 9.a ( uniform variants ) and 9.b ( dfs  variants ) .",
    "namely , for each combination we present the minimum search number attained , averaged over the fifty graphs of the corresponding family .",
    "it can be seen that the resulting numbers are quite low , especially for the uniform variants , often going under the @xmath600 bound .",
    "[ c]|c|c|c|c|c|c|c|**graph dim . * * & @xmath597 & * gsst - l * & * gsst - r * & * gsst - lr * & * gsst - lw * & * gsst - ld * + & & & & & & + & & & & & & + & & & & & & + & & & & & & + & & & & & & + & & & & & & + & & & & & & + & & & & & & + & & & & & & + & & & & & & + & & & & & & + & & & & & & +    * table 9.a . * _ _ average minimum number of searchers required to node - clear each family of depleted - grid graphs  by the uniform gsst variants ; number of spanning trees generated is @xmath605 .",
    "[ c]|c|c|c|c|c|c|c|**graph dim . * * & @xmath597 & *",
    "gsst - l * & * gsst - r * & * gsst - lr * & * gsst - lw * & * gsst - ld * + & & & & & & + & & & & & & + & & & & & & + & & & & & & + & & & & & & + & & & & & & + & & & & & & + & & & & & & + & & & & & & + & & & & & & + & & & & & & + & & & & & & +    * table 9.b*.average minimum number of searchers required to node - clear each family of depleted - grid graphs  by the dfs  gsst variants ; number of spanning trees generated is @xmath605 .",
    "the depleted grid results show the high performance of gsst on graphs with large numbers of spanning trees and many cycles .",
    "better results are obtained for smaller values of @xmath597 , i.e. when the graph becomes more similar to a tree ; this is to be expected , since a basic component of the gsst algorithm is search along a spanning tree .",
    "it is interesting to note that even for a quite high value of @xmath597 , namely 0.9375 , results ( at least for uniform gsst  variants )  are quite good ; taking into account also the results of the full grids , it appears that the increase of attained search number over @xmath600 happens only when @xmath597 gets _ very _ close to 1 .",
    "once again we observe that the uniform variants perform better than the dfs  ones .",
    "our experiments demonstrate the performance of gsst on several different classes of graphs . on many complex graphs",
    ", gsst was able to find a minimal search schedule in reasonable time .",
    "on _ all _ graphs , at least one near - minimal schedule is computed early in the execution of the algorithm .",
    "in fact , the anytime  operation of gsst  ( see also the discussion in section [ sec0501 ] )  yields reasonably good solutions in very short time and then keeps improving on these solutions as long as additional computation time is available .",
    "while the minimal schedules form a small percentage of the computed solutions , many more near - minimal solutions are available .",
    "these properties of gsst  are highly desirable , especially given the fact that ( as far as we are aware ) no other algorithm has been _ implemented _ which can tackle graphs of the size and complexity presented here .",
    "we can highlight some specific conclusions supported by the experiments on the various graphs considered in section [ sec0601 ]  [ sec0603 ] .    1 .",
    "the nsh and national art gallery graphs show the application of gsst on graphs that are derived from representations of indoor environments .",
    "the methods that incorporate barriere labeling improve performance on the nsh map because it is similar to a tree .",
    "the national art gallery , on the other hand , is more similar to a grid , which lessens the advantage of using barriere labeling to guide traversal .",
    "the results on interval graphs show that gsst can yield near - minimal schedules on a large class of graphs .",
    "they also demonstrate that , with increasing complexity , gsst  scales well both in performance and computation time .",
    "finally , the grid results show the high performance of gsst on graphs with large numbers of spanning trees and many cycles .",
    "these are potentially some of the hardest graphs for gsst .",
    "also , it appears that the the increase of attained search number over @xmath600 happens only when @xmath597 gets _ very _ close to 1 .    comparing spanning tree generation methods",
    ", we see that dfs  generation performs better on all graphs considered except for grid graphs ( and the tree / grid graph ) where the uniform st  generation is better .",
    "at this point we do not have a good explanation but we intend to further research this fact because we believe it will give us a better understanding of which are the good  spanning trees , i.e. the ones associated with minimal searches .",
    "see section [ sec07 ] for some additional remarks on this issue .",
    "regarding edge traversal methods , there is no single gsst  variant which consistently outperforms all others .",
    "however , uniform gsst - l never does too poorly and is fast ; gsst - lw has the same advantages and , in addition , is provably complete . hence , in case node - clearing schedules must be quickly produced ( i.e. computation time is at premium ) , one can use a reduced suite  of gsst  variants , consisting of gsst - l and gsst - lw ( with both uniform and dfs  spanning tree generation ) and expect to obtain nearly as good results ( at a fraction of the computing time )  as when using the full  suite of the ten gsst  variants .",
    "let us also stress that all variants of gsst  can attain lower search numbers than the ones presented here if sufficient running time is available .",
    "motivated by the problem of robotic pursuit / evasion , in the current paper we have investigated _ node search _ ,",
    "i.e. , the capture by a team of searchers of an invisible evader located in the _ nodes _ of a graph .",
    "this problem has so far received little attention in the graph theoretic literature , with most related publications concentrating on the problem of edge - located evader .",
    "the basic contributions of the current paper are of two kinds .    1 .   from the theoretical point of view",
    ", we have shown that , in general graphs , the problem of node search is easier than that of edge search , in the sense that every edge clearing search is also a node clearing one ; but the converse does not hold in general .",
    "we have then concentrated on the internal monotone connected ( imc )  node search of trees and shown that it is essentially equivalent to edge search under the same restrictions ; hence barriere s tree search algorithm , originally designed for edge search , can also be used for node search .",
    "2 .   from the algorithmic point of view ,",
    "we have presented gsst , a new algorithm which performs imc  search on general graphs .",
    "this algorithm is based on the fact that every node clearing search generates a spanning tree ; hence node - clearing a preselected spanning tree ( by the use of _ tree searchers _ ) and simultaneously blocking recontamination ( by the use of _ guards _ )  monotonically node - clears the graph . because spanning tree generation and search can both be performed very efficiently",
    ", a large number of spanning trees can be tried by gsst  until the one yielding the minimum number of searchers is discovered .",
    "experiments have shown that gsst can quickly node - clear large and complex graphs using a small number of searchers .",
    "many issues touched upon in the current paper require additional research .",
    "we conclude by listing some future research directions , categorized as follows .    1 .",
    "* theory*. 1 .   _",
    "optimality_. given a graph @xmath0 with imc node search number @xmath557 .",
    "suppose we have @xmath476 searchers with @xmath606 .",
    "what is the best we can do ? of course best  depends on some optimality criterion .",
    "for example we may want to clear the graph in the minimum number of steps . or , we may want a search strategy which minimizes the cumulative area  of the dirty set ( i.e. , @xmath607 ) .",
    "we would like to obtain algorithms which solve such optimization problems .",
    "our experiments show that the uniform gsst  variants perform better than dfs  on grids and grid - like graphs .",
    "we want to discover a mathematical explanation of this fact , e.g. , to find necessary and / or sufficient conditions under which uniform gsst  outperforms dfs  gsst .",
    "a result of this type will probably have useful computational implications ",
    "see also item 2.(a )  below .",
    "we want to establish a sequence of inequalities between node search numbers . in other words , to refine ( [ eq0452 ] ) , either for a general graph @xmath0 , or for the special case when @xmath0 is a tree . for the latter case , we conjecture that we can re - establish the barriere et al . inequalities ( [ eq0451 ] ) so as to hold for _ node- _  rather than edge - search numbers .",
    "4 .   finally , we are interested in questions of _",
    "consistency_. suppose that we are given a graph along with a _ configuration _ of each nodes ( i.e. , a specification of the clear and dirty nodes ) .",
    "can this configuration be obtained by a sequence of moves in the node game ? in the edge game ? also , given a configuration of clear and dirty nodes and another one of clear and dirty edges , are these configurations compatible in the node game ? in the edge game ? 2 .",
    "* computation .",
    "* the gsst  algorithm searches the space of spanning trees in a random manner .",
    "is there a way to bias the search in some useful way ?  for this",
    "we need a characterization of good  spanning trees , i.e. , trees which yield a low number of searchers ( this includes tree searchers _ and _ guards ) .",
    "we have no such characterization at present .",
    "perhaps we can obtain it by understanding why uniform variants perform better than dfs  on grid graphs ( and conversely on interval graphs ) .",
    "* extensions*. we want to study theoretically and develop algorithms for the following variants of the search problem .",
    "1 .   for less restricted types of node search , e.g. , internal monotone ( but not connected ) , internal connected ( but not monotone ) ; or for completely unrestricted node search .",
    "2 .   for different types of  pursuer / evader behavior ; e.g. , for pursuers with extended ( non - local )  visibility , evaders with finite speed etc .",
    "3 .   how does the graph search problem look from the evader s point of view ? given a graph @xmath0 and @xmath476 searchers , what is the best the evader can do if @xmath608 ?",
    "what if @xmath609 ? in the latter case capture is guaranteed , but can the evader , for example , maximize the number of steps until capture ?  many other interesting problems can be posed from the evader s point of view .    * acknowledgement*. we gratefully acknowledge sanjiv singh for many useful discussions and valuable comments on the current paper .",
    "in this appendix we present the * r - label * and * r - search * algorithms , which perform rooted imc  search of _ trees _ and are also used by the gsst  algorithm . *",
    "r - label * and * r - search * are simplified versions of corresponding algorithms presented by barriere et al .",
    "@xcite ; some theoretical results from @xcite are also reviewed . in our presentation",
    "the terminology and notation of @xcite are somewhat changed , to conform with the current paper .",
    "the next lemma and definition play a crucial role in computing the imc  search number of a tree .    [ prp0407]@xcite given a rooted tree @xmath38 and a node @xmath32 of @xmath38 , if @xmath32 has more than one children , enumerate them as @xmath610 , so that they satisfy @xmath611",
    "\\right )   \\geq s_{e}^{imc}\\left ( \\mathbf{t}_{x}\\left [   y_{k+1}\\right ]   \\right )   $ ] for @xmath612 .",
    "then@xmath613   \\right )   = \\max\\left ( s_{e}^{imc}\\left (   \\mathbf{t}_{x}\\left [   y_{1}\\right ]   \\right )   , s_{e}^{imc}\\left (   \\mathbf{t}_{x}\\left [   y_{2}\\right ]   \\right )   + 1\\right )   . \\label{eqa001}\\ ] ]    [ prp0410]@xcite given a tree @xmath24 and a node @xmath614 , consider all the edges @xmath65 incident on @xmath30 and label them as follows .    1 .",
    "if @xmath32 is a leaf , then @xmath615 .",
    "2 .   if @xmath32 is not a leaf , let @xmath616 be the neighbors of @xmath32 other than @xmath30 , enumerated so that @xmath617  ( for @xmath612 ) and define@xmath618    note that the above definition assigns _ two _ labels to each edge @xmath65 , namely @xmath619 and @xmath620 . intuitively , @xmath619 is the number of searchers that must cross the _ directed _ @xmath65 edge in an imc  edge - clearing of the tree . in @xcite barriere",
    "present the * label * algorithm which computes the labels @xmath621 .",
    "furthermore they prove the following .",
    "[ prp0411]@xcite for every tree @xmath1 and every edge @xmath65 of @xmath1 , we have @xmath622\\right ) = \\lambda_{x}\\left (   xy\\right )   $ ] .",
    "[ prp0411a]@xcite given a tree @xmath623 , for every @xmath614 define @xmath624 as follows@xmath625{ll}\\lambda_{x}\\left (   xy_{1}\\right )   & \\text{if } x\\text { has a single neighbor } y_{1}\\\\ \\max\\left (   \\lambda_{x}\\left (   xy_{1}\\right )   , \\lambda_{x}\\left ( xy_{2}\\right )   + 1\\right )   & \\text{otherwise;}\\end{array } \\right.\\ ] ] in the second line of the definition , @xmath626 are the neighbors of @xmath30 , enumerated so that they satisfy @xmath627",
    "\\right )   \\geq s_{e}^{imc}\\left (   \\mathbf{t}_{x}\\left [ y_{k+1}\\right ]   \\right )   $ ] for @xmath628 .",
    "then @xmath629    the algorithms and results of @xcite are geared towards computing @xmath630 .",
    "the gsst  algorithm , on the other hand , requires the computation of @xmath631 and rooted searches .",
    "hence we introduce the * r - label * and * r - search * algorithms , which are simplified , rooted  versions of the corresponding barriere algorithms .",
    "the pseudocode of these algorithms is listed in the next page .",
    "the * r - label * algorithm takes as input a tree @xmath632 _ and _ a root node @xmath633 .",
    "the algorithm is a straightforward implementation of definition [ prp0410 ] . *",
    "r - label * does _ not _ compute all the labels @xmath634 but only the ones for which @xmath32 is a child of @xmath30 in the rooted tree @xmath635 ; for these edges , * r - label * produces the same @xmath318 labels as * label*. * r - label * uses two subroutines :  given that @xmath23 is the root , the subroutine * * depth**@xmath636 returns a partition @xmath637 of  the node set @xmath3 , where @xmath638 contains all nodes of depth @xmath639 ; the subroutine * * sortchildren**@xmath640 returns the children of @xmath32 sorted in decreasing order of their @xmath318 labels .",
    "the * r - search * algorithm uses the @xmath318 labels to produce a rooted imc ( edge and node )  clearing search of @xmath1 .",
    "* r - search * is almost identical to barriere s * search * , the only difference being that the starting node @xmath23 is given , rather than chosen by the algorithm ( this implies that * r - search * produces a minimal _ rooted _ imc search of @xmath635 ) .",
    "* r - search * uses barriere s subroutine * move*. the notation @xmath641 means :  append @xmath642 moves of the form @xmath186 to the search schedule @xmath55 .",
    "[ label ]    * input : * tree @xmath643 , start node @xmath356 @xmath644 * * depth**@xmath645 @xmath646=$ ] * * sortchildren**@xmath647 @xmath648 @xmath649 @xmath650 * output : * edge labeling @xmath651    * input : * tree @xmath643 , start node @xmath356 , edge labeling @xmath318 @xmath363 @xmath652=$ ] * * sortchildren**@xmath653 @xmath55=**move**@xmath654 * output : * search @xmath55    [ alg : search ]    * input : * tree @xmath643 , start node @xmath356 , edge labeling @xmath318 @xmath655 @xmath656=$ ] * * sortchildren**@xmath657 @xmath55=**move**@xmath658 @xmath659 * output : * search @xmath55    [ alg : search ]",
    "theorem [ prp0303 ] tells us that edge search is weaker  than node search in the sense that , for every graph and every search schedule , we have @xmath660 and @xmath661 . we will now consider a variant of edge search , the so - called _ mixed edge search _ which , as we will see , is _ equivalent _ to node search .",
    "mixed edge search is obtained by augmenting the clearing rules . in the _ mixed search edge game _",
    "an edge can be cleared not only by sliding , but also by guarding both its endpoints .",
    "more precisely , to obtain the rules of the mixed edge search game , take the rules of the edge game ( presented in section [ sec02 ] ) , change the terms e - clear  and e - dirty  to m - clear  and m - dirty  and add the following rule :    1 .   an m - dirty edge @xmath10 becomes m - clear when both @xmath49 and @xmath45 are occupied by searchers .    in other words , we can clear an edge either by traversing it or by guarding both its endpoints .",
    "we will use @xmath662 to denote the set of m - clear nodes at time @xmath44 , and will analogously use the notations @xmath663 , @xmath664 , @xmath665 , @xmath666 etc .",
    "we emphasize that , in the mixed search edge game , the evader resides in the edges of the graph and recontamination occurs by the same rules as in the plain  edge game .",
    "[ prpa01]given a graph @xmath0 and an internal search schedule @xmath55 .",
    "then , we have @xmath667    the proof is inductive and consists of several steps .    *",
    "i. * at @xmath63 we have@xmath668 suppose that we have @xmath669 and let us next consider time @xmath141 .",
    "* we will now prove that@xmath670 to this end we will show two things .    1 .",
    "if a previously n - dirty edge becomes n - clear at _ @xmath141 _",
    "_ , then it also becomes m - clear__. suppose that @xmath671 .",
    "in other words , @xmath10 is n - cleared exactly at @xmath141 ; this means that one of @xmath12 was already n - clear by @xmath44 and the other was n - cleared _ exactly _ at @xmath141 . without loss of generality , assume@xmath672 since a node can be n - cleared only by moving into it , the @xmath673-th move must be @xmath674 .",
    "we distinguish the following cases .",
    "+ * ( i.1 ) * suppose @xmath675 .",
    "since @xmath148 and @xmath676 , @xmath49 was guarded at @xmath44 ; since @xmath675 , @xmath49 remains guarded at @xmath141 .",
    "hence , at @xmath141 , @xmath10 has both ends guarded and so @xmath677 .",
    "( note that this analysis holds even when @xmath678 , i.e. , when the move was to place a new searcher ) . + * ( i.2 ) * suppose @xmath679 and @xmath49 is still guarded at @xmath141 ( i.e. , at @xmath44 there was more than one searcher in @xmath49 )",
    ". then at @xmath141 both @xmath49 and @xmath45 are guarded and @xmath677 .",
    "+ * ( i.3 ) * the remaining possibility is that @xmath679 and @xmath49 is unguarded at @xmath141 ( i.e. , at @xmath44 there was exactly one searcher in @xmath49 ) .",
    "note that @xmath186 at @xmath141 means that @xmath49 is guarded at @xmath44 and hence @xmath680 .",
    "if @xmath681 as well , then @xmath682 .",
    "so we now will show that @xmath683 is not possible .",
    "indeed @xmath684 can only happen in one of the following two ways .",
    "+ * ( i.3.1 ) * there exists a node @xmath219 such that @xmath685 . but @xmath686 implies @xmath687 ( because @xmath49 is guarded at @xmath44 ) and @xmath687 implies @xmath220 ( because @xmath688 was not entered at @xmath141 )",
    ". finally , from @xmath220 and @xmath49 unguarded at @xmath141 , we conclude @xmath689 which contradicts assumption ( [ eq0322 ] ) . + * ( i.3.2 ) * alternatively , there exists a path @xmath690 ( with @xmath691 ) , e - unguarded at @xmath141 and with @xmath692 ( note also that , since @xmath690 is a path , @xmath693 ) . in this case , we have@xmath230{l}vux_{1} ... x_{k}\\text { e - unguarded at } t+1\\text { } \\\\",
    "u\\rightarrow v\\text { at } t+1\\\\ u\\notin\\left\\ {   x_{1},x_{2}, ... ,x_{k}\\right\\ } \\end{array } \\right\\ }   \\rightarrow ux_{1} ... x_{k}\\text { is e - unguarded at } t\\text{;}\\ ] ] and@xmath230{l}ux_{1} ...",
    "x_{k}\\text { e - unguarded at } t\\\\ x_{k-1}x_{k}\\in e_{m}^{d}\\left (   t\\right ) \\end{array } \\right\\ }   \\rightarrow x_{k-1}\\in v_{m}^{d}\\left (   t\\right )   = v_{n}^{d}\\left ( t\\right )   ; \\ ] ] and finally @xmath230{r}\\left .",
    "\\begin{array } [ c]{l}x_{k-1}\\in v_{n}^{d}\\left (   t\\right )   \\text { } \\\\",
    "u\\rightarrow v\\text { at } t+1\\\\ v\\notin\\left\\ {   x_{1},x_{2}, ... ,x_{k}\\right\\ } \\end{array } \\right\\ }   \\rightarrow x_{k-1}\\in v_{n}^{d}\\left (   t+1\\right ) \\\\ ux_{1}",
    "... x_{k-1}\\text { is n - unguarded at } t+1 \\end{array } \\right\\ }   \\rightarrow u\\in v_{n}^{d}\\left (   t+1\\right)\\ ] ] but @xmath221 contradicts assumption ( [ eq0322 ] ) . hence @xmath694 + in short , by examining cases ( i.1)-(i.3)@xmath404we have shown that@xmath695 i.e. , if at @xmath141 some @xmath10 is n - cleared it is also m - cleared .",
    "if a previously m - clear edge becomes m - dirty at _",
    "@xmath141 _ _ , then it also becomes n - dirty . _",
    "_ suppose that @xmath696 .",
    "without loss of generality , we can assume that there exists a @xmath697 and a path @xmath698 which was e - guarded at @xmath44 but became e - unguarded at @xmath141 .",
    "since the path became e - unguarded at @xmath141 , exactly one node in it was guarded at @xmath44 ( and became unguarded at @xmath141 ) .",
    "call this node @xmath699 , with @xmath700 if the node in question is @xmath45 ( i.e. , @xmath701 )  and @xmath702 otherwise .",
    "the move at @xmath141 is @xmath703 , where @xmath704 ( since @xmath698 is e - unguarded at @xmath141 ) . since @xmath705 @xmath706 , either @xmath707 or @xmath708 .",
    "we consider the following cases .",
    "+ * ( ii.1 ) * if @xmath707 then @xmath709 as well ( it was not entered ) and the path @xmath710 is n - unguarded at @xmath141 .",
    "so @xmath711 and @xmath712 .",
    "+ * ( ii.2 ) * if @xmath713 , then @xmath708 and so @xmath234 is the guarded node in the path @xmath698 ( i.e. , @xmath714 ) .",
    "we distinguish two subcases .",
    "+ * ( ii.2.1 ) * the move at @xmath141 is @xmath715 and @xmath716 .",
    "then @xmath717 and so @xmath709 and , by the same argument as in ( ii.1 ) , we get @xmath712 . + * ( ii.2.2 ) * the move at @xmath141 is @xmath718 .",
    "since we have assumed @xmath719 , @xmath282 must be adjacent to some _ other _ edge @xmath720 @xmath721 ; so we can use @xmath32 in place of @xmath722 , @xmath723 in place of @xmath698 and conclude by the reasoning of case ( ii.2.1 ) that @xmath724 .",
    "+ in short , we have shown that@xmath725 i.e. , if at @xmath141 some @xmath10 is m - dirtied then it is also n - dirtied .",
    "hence every edge added at @xmath141 to @xmath89 is also added to @xmath726 and every edge removed at @xmath141 from @xmath726 is also removed from @xmath727 .",
    "these facts , combined with @xmath728 , yield@xmath729 * iii . * to strengthen ( [ eq0306 ] ) to set equality , we need the reverse set inclusion .",
    "in fact we can prove @xmath730 by following the proof of theorem [ prp0303 ] and replacing e - clear , e - dirty , ... with m - clear , m - dirty , ...",
    "( analogs of lemmas [ prp0301 ] , [ prp0302 ] can also be proved easily ) . from ( [ eq0306 ] )  and ( [ eq0314 ] )  we obtain @xmath731 * iv .",
    "* now suppose  @xmath732 .",
    "then @xmath49 is unguarded and adjacent to some @xmath733 .",
    "hence either @xmath49 or @xmath45 is n - dirty and so ( since @xmath49 is unguarded ) @xmath221 . on the other hand ,",
    "if @xmath221 , then @xmath49 is unguarded and there exists a @xmath734 and ( since @xmath49 is unguarded ) @xmath732 .",
    "it follows that @xmath735 * v. * in short , we have established that@xmath736{c}e_{m}^{c}\\left (   t\\right )   = e_{n}^{c}\\left (   t\\right ) \\\\ v_{m}^{c}\\left (   t\\right )   = v_{n}^{c}\\left (   t\\right ) \\end{array } \\right )   \\rightarrow\\left ( \\begin{array } [ c]{c}e_{m}^{c}\\left (   t+1\\right )   = e_{n}^{c}\\left (   t+1\\right ) \\\\",
    "v_{m}^{c}\\left (   t+1\\right )   = v_{n}^{c}\\left (   t+1\\right ) \\end{array } \\right )   .",
    "\\label{eq0323}\\ ] ] eq.([eq0323 ] ) and the fact @xmath737 and @xmath738 complete the proof of the theorem .",
    "several facts follow from theorem [ prpa01 ] .",
    "first , it is well known that mixed edge search is np - complete @xcite hence node search is also np - complete .",
    "second , theorem [ prpa01 ] can be used to obtain a theorem [ prp0303 ] as a corollary with a short proof ( which , of course , presupposes the lengthy proof of theorem [ prpa01 ] ) .",
    "we give a sketch of such a proof .",
    "suppose a graph @xmath0 and a search schedule @xmath55 are given .",
    "then , by theorem [ prpa01 ] we have ( for every @xmath44 ) @xmath739 and @xmath740 .",
    "now suppose @xmath55 is applied to @xmath0 under the rules of the edge game and , up to time @xmath44 we have @xmath741 and @xmath742 .",
    "then , at time @xmath141 , every e - cleared edge is also m - cleared ( since the mixed game has all the clearing rules of the edge game and an additional one )  and every m - dirtied edge is also e - dirtied ( since the edge and mixed games have the same recontamination rules ) except if an edge was already e - dirty .",
    "hence @xmath743 , which also shows that @xmath744 .",
    "finally , the above theorem [ prpa01 ] and the monotonicity result proved in @xcite ( if there is a mixed edge clearing search of @xmath0 using @xmath745 guards , there is a monotone mixed edge clearing  search of @xmath0 using @xmath745 guards ) makes the following conjecture seem almost trivially true .",
    "[ prpa02]if there is a node clearing search @xmath55 of @xmath0 using at most @xmath476 guards , there is a monotone node clearing search @xmath300 of @xmath0 using at most @xmath476 guards .",
    "however some additional work is required to prove the conjecture , because of the following detail :  edge monotonicity does not necessarily imply node monotonicity . in other words , the implication @xmath746 is not necessarily true !",
    "consider again the search schedule of remark [ prp0202 ] . in this case @xmath747 , but @xmath748 does not hold .",
    "it is true however ( and easy to prove )  that @xmath749    unfortunately , the result proved by bienstock in @xcite concerns simple , not strong monotonicity .",
    "hence one of our future research goals is to extend bienstock s result to node search and thus prove that @xmath750 .",
    "vertex separation and pathwidth are strongly ( but not obviously ) related to graph search and search number , as discussed in ( among other papers )  @xcite , where the author can find a more detailed discussion ; here we just give the basic definitions and the main theorem .",
    "[ def0204]given a graph @xmath2 , a _ path decomposition _ of @xmath0 is a pair @xmath751 , where @xmath752 is a family of subsets of @xmath3 and @xmath753 is a path whose nodes are the subsets @xmath754 and they satisfy the following properties    1 .",
    "2 .   for every edge @xmath756 in @xmath4",
    ", there is a subset @xmath757 that contains both @xmath45 and @xmath427 .",
    "3 .   if @xmath758 then @xmath759 .",
    "[ def0205]the _ width _ of a path decomposition @xmath751 ( with @xmath760 ) is denoted by @xmath761 and is defined by @xmath762    [ def0206]the _ pathwidth _ of a graph @xmath763 is denoted by @xmath764 and defined by @xmath765    [ def0207]given a graph @xmath2 ( with @xmath7 )  and a permutation @xmath766 of @xmath767 .",
    "the _ vertex separation _ of @xmath0 with respect to @xmath766 is denoted by @xmath768 and defined by@xmath769 the _ vertex separation _ of @xmath358 is denoted by @xmath770 and defined by@xmath771    the following theorem shows the connection between @xmath770 and @xmath764 and search number .    for every graph @xmath0 , @xmath772 and @xmath773 .",
    "we have implemented the gsst  algorithm in two forms which are publicly available .    1 .",
    "as a command line executable , which runs on windows and linux computers . the program and supporting material are available at the url   + ` http://www.frc.ri.cmu.edu/gholling/home/software.html ` .",
    "2 .   as a graphical user interface ( gui ) , available at + ` http://users.auth.gr/kehagiat/kehagiassoftware.htm ` .          ....",
    "usage : gsearch -m [ graph ] -n [ no.trees ] -s [ startnode ] -g [ gen.tree ]             -y [ wr - search ] -w [ wr - tree ] -v [ visualize ] -t [ edge traversal ]            -i [ improve tree ] -l [ low number ]",
    "-r [ redundancy check ]         example : gsearch -m graphs / edge01.txt -g exhaustive -s 1 -n 500000 -t bh ....                                                      the ` -m ` option indicates the file which contains the graph description .",
    "this must be an ascii ( plain text )  file containing a list of the edges of the graph , one edge per line , indicated as a pair of nodes .",
    "the nodes must be continuously numbered from 1 to @xmath6 and these numbers are used as labels .",
    "@xmath6 is assumed to be the largest number appearing in the edge list ( the graph is assumed to be undirected and connected ) .",
    "examples of edge lists can be found in the ` graphs ` directory .",
    "the remaining options of ` gsearch ` correspond to the description of the algorithm in section [ sec05 ] .",
    "the ` -n ` option corresponds to the @xmath324 parameter of gsst ( number of spanning trees ) , ` -s ` is the root of the search , ` -g ` describes the uniform and dfs  methods for generating spanning trees ( there are also options for exhaustive enumeration of all spanning trees and for reading a specific spanning tree from file ) and the ` -t ` options ( ` bh , random , bhrand , bhweight , bhdom ` ) corresponds to the traversal methods ( l , r , lr , lw and ld , respectively ) .",
    "the ` -i , -r ` and ` -l ` options are self explanatory .",
    "the  ` -y ` option writes one or more minimal strategies in the file(s ) ` output / strat*.txt ` ; each row of the file corresponds to one step of the strategy and shows the nodes in which the searchers are currently located .",
    "the  ` -w ` option writes the rooted tree(s ) corresponding to optimal strategies , in the file(s ) ` output / tree*.txt ` ; each row of the file shows one parent and her child .",
    "the ` -v ` visualization option only works on linux computers ( for a visualization of the search on windows computers use the gui ) .",
    "this is an executable , ` gsearchgui.exe , ` which corresponds closely to the command line program .",
    "( in fact the gui  is a front end for the command line program . )",
    "launching the program brings up the window of figure [ fig15 ] . on the left side",
    "we see several input boxes .",
    "all of these correspond to abovementioned options of the command line program with one exception : in addition to the edge list file ( ` graphs / edge11.txt ` in figure [ fig15 ] ) there is also a file containing the @xmath30- and @xmath32-coordinates of the nodes ( ` graphs / node11.txt ` in figure [ fig15 ]  this is required for visualization ) .",
    "the gui  starts with the default selection of ` edge01.txt ` and ` node01.txt ` ; if you want a different graph , type the corresponding file names in the input boxes .      1 .",
    "the button performs the graph search ( it actually invokes the ` gsearch ` executable and stores results in the ` output ` directory ) .",
    "time to complete the search depends on the size of the graph and the number of spanning trees used .",
    "do _ not _ use the exhaustive spanning tree enumeration option on large graphs because the program may take too long to terminate .",
    "the button plots the graph .",
    "an image of the graph is generated and an image viewer is invoked which can be used to view the image file ( this is always named ` graph.jpg ` ) .",
    "a screenshot of the image viewer appears in figure [ fig16 ] .",
    "the button plots the graph search .",
    "actually , first the search strategy files are used to generate a sequence of image files , one image corresponding to each step of the search ( these files are stored in the directory ` pix ` ) and then the image viewer is invoked to view the files .",
    "the user can step through the images using the arrow keys , or use the / buttons to run a slide show of the search .",
    "a screenshot of the image viewer appears in figure [ fig16 ] .",
    "_ nota bene _ : do not run before running !",
    "the function uses the latest results of ; if these correspond to an earlier graph ( from a previous run of the gui ) the plotted search will produce nonsense reults .",
    "the gui was implemented by ath .",
    "kehagias in ms visual basic 5.0 ( and a little bit of c , using the dev - cpp 4.9.9.2 environment ) .",
    "the image viewer is a freeware program called autopics and made available by the company _ mydesktophelp _ ( at ` http://www.mydesktophelp.com ` ) .",
    "the gd  graphics library ( version gd-2.0.34-win32 ) has also been used ; this library is available at ` http://www.libgd.org/ ` .",
    "finally it must be stressed that the current version , ` gsearchgui v.0.9 , ` is still _ beta _ and requires further development .",
    "however we make it publicly available in the hope that it will prove useful to the graph search community .",
    "l. barriere , p. flocchini , p. fraigniaud , and n. santoro , capture of an intruder by mobile agents , in _ proc . of the 14th annual acm symposium on parallel algorithms and architectures _",
    "( spaa 2002 ) , pp . 200209 , 2002 .",
    "l. barriere , p. fraigniaud , n. santoro , and d. m. thilikos , searching is not jumping , in _ proc .",
    "of the 29th international workshop on graph - theoretic concepts in computer science _",
    "( wg 2003 ) , vol . 2880 of springer lncs , pp .",
    "3445 , 2003 .    d. bienstock , graph searching , path - width , tree - width and related problems ( a survey ) , in _ reliability of computer and communication networks _ , vol . 5 of dimacs ser",
    ". discrete math .",
    "sci . , pp . 3349 , 1991 .",
    "p. fraigniaud and n. nisse , connected treewidth and connected graph searching , in _ proc . of the 7th latin american symposium on theoretical informatics _",
    "( latin 2006 ) , vol .",
    "3887 of springer lncs . , pp . 479490 , 2006 .",
    "g. hollinger , ath .",
    "kehagias , s. singh , d. ferguson , and s. srinivasa .",
    "anytime guaranteed search using spanning trees .",
    "report cmu - ri - tr-08 - 36 , robotics institute , carnegie mellon university , 2008 .",
    "r. jayakumar , k. thulasiraman and m.n.s .",
    "mod - char : an implementation of char s spanning tree enumeration algorithm and its complexity analysis .",
    "_ ieee trans . on circuits and systems _ , vol .",
    "36 , pp.219 - 228 , 1989 .",
    "b. yang , d. dyer , and b. alspach , sweeping graphs with large clique number , in _ proc . of the 15th international symposium on algorithms and computation _",
    "( isaac 2004 ) , springer lncs , vol . 3341 , pp . 908920 , 2004 ."
  ],
  "abstract_text": [
    "<S> one or more _ searchers _ must _ capture _ an invisible _ evader _ hiding in the _ nodes _ of a graph . </S>",
    "<S> we study this version of the _ graph search _ problem under additional restrictions , such as monotonicity and connectedness . </S>",
    "<S> we emphasize that we study _ node search _ </S>",
    "<S> , i.e. , the capture of a _ node - located _ evader ; this problem has so far received much less attention than _ edge search _ , i.e. , the capture of an _ edge - located _ evader .    </S>",
    "<S> we show that in general graphs the problem of node search is easier than that of edge search , namely , every edge clearing search is also node clearing , but the converse does not hold in general ( however node search is np - complete , just like edge search ) </S>",
    "<S> . then we concentrate on the _ internal monotone connected _ ( imc )  </S>",
    "<S> node search of _ trees _ and show that it is essentially equivalent to imc  edge search ; hence barriere s tree search algorithm @xcite , originally designed for edge search , can also be used for node search .    </S>",
    "<S> we return to imc  node search on general graphs and present ( several variants of ) a new algorithm : _ gsst _ ( guaranteed search by spanning tree ) . </S>",
    "<S> gsst clears a graph @xmath0 by performing all its clearing moves along a spanning tree @xmath1 of @xmath0 . </S>",
    "<S> because spanning trees can be generated and cleared very quickly , gsst  can test a large number of spanning trees and find one which clears @xmath0 with a small ( though not necessarily minimal )  number of searchers . </S>",
    "<S> we prove the existence of probabilistically complete variants of gsst ( i.e. , these variants are guaranteed to find a minimal imc node clearing schedule if run for sufficiently long time ) . </S>",
    "<S> our experiments also indicate that gsst can efficiently node - clear large graphs given only a small running time . </S>",
    "<S> _ an implementation of gsst  _ ( running on windows and linux computers ) </S>",
    "<S> _ is also provided and made publicly available_. </S>"
  ]
}