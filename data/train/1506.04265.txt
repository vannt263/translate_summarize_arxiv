{
  "article_text": [
    "this project has been done so that people interested in cryptography , especially students can get a better understanding of how generation of random primes , key generation and encryption and decryption process takes place in rsa .",
    "being an undergrad students our search for an easy - to - understand c implementation of rsa that involved generation of random primes lead no where . on not finding a satisfactory implementation , we implemented it .",
    "in a _ public key cryptosystem _ each user places in a public file an encryption procedure e. that is , the public file is a directory giving the encryption procedure of each user .",
    "the user keeps secret the details of his corresponding decryption procedure d. these procedures have the following four properties :    1 .   deciphering the enciphered form of a message m yields m. formally , + @xmath1 2 .",
    "both e and d are easy to compute 3 .   by publicly revealing e",
    "the user does not reveal an easy way to compute d. this means that in practice only he can decrypt messages encrypted with e , or compute d efficiently 4 .   if a message m is first deciphered and then enciphered , m is the result .",
    "formally , + @xmath2",
    "for implementation of rsa these four famous algorithms have been used : -    * sieve of eratosthenes ( for prime number generation ) * fermat primality test * miller - rabin primality test * encryption - decryption algorithms .",
    "proper discussion about each algorithm is mentioned in next subsections .",
    "the sieve of eratosthenes is one of the most efficient ways to find all primes smaller than n when n is smaller than 10 million or so .",
    "following is the algorithm to find all the prime numbers less than or equal to a given integer n by eratosthenes method :    \\1 .",
    "create a list of consecutive integers from 2 to n : ( 2 , 3 , 4 , .... , n ) .",
    "initially , let p equal 2 , the first prime number .",
    "starting from p , count up in increments of p and mark each of these numbers greater than p itself in the list .",
    "these numbers will be 2p , 3p , 4p , etc . ; note that some of them may have already been marked .",
    "find the first number greater than p in the list that is not marked .",
    "if there was no such number , stop .",
    "otherwise , let p now equal this number ( which is the next prime ) , and repeat from step 3 .",
    "but when the algorithm terminates , all the numbers in the list that are not marked are prime .",
    "if p is the number which we want to test for primality , then we could randomly choose a , such that _ a < p _ and then calculate @xmath3 _",
    "p_. if the result is not 1 , then by fermat s little theorem _ p _ can not be prime .",
    "what if that is not the case ?",
    "we can choose another _ a _ and then do the same test again .",
    "we could stop after some number of iterations and if the result is always 1 in each of them , then we can state with very high probability that _",
    "the more iterations we do , the higher is the probability that our result is correct . you can notice that if the method returns composite , then the number is sure to be composite , otherwise it will be probably prime .",
    ".... int fermat(long long p , int iterations ) {      if(p = = 1 ) { /*1 is n't prime ; this conditional           statement is not required for our given program .",
    "we write it for maintaining generality.*/          return 0 ;                             }         int i=0 ;                  for(i=0;i < iterations;i++ ) {          / * choose a random integer between                   1 and p-1 ( inclusive ) * /          long long a = rand()%(p-1)+1 ;           / * modulo is the function we developed                   above for modular exponentiation * /          if(modulo(a , p-1,p ) ! = 1 ) {               return 0 ; / * p is definitely composite * /          }      }      return 1 ; / * p is probably prime * / } ....      let _ p _ be the given number which we have to test for primality . first we rewrite _",
    "p-1 _ as @xmath4 .",
    "now we pick some _ a _ in range [ _ 1,n-1 _ ] and then check whether _",
    "a*s = 1 ( mod p ) _ or @xmath5 . if both of them fail , then _",
    "p _ is definitely composite . otherwise _",
    "p _ is probably prime .",
    "we can choose another _ a _ and repeat the same test .",
    "we can stop after some fixed number of iterations and claim that either _",
    "p _ is definitely composite , or it is probably prime . it can be shown that for any composite number _",
    "p _ , at least ( 3/4 ) of the numbers less than _ p _ will witness _ p _ to be composite when chosen as _ a _ in the above test .",
    "which means that if we do 1 iteration , probability that a composite number is returned as prime is ( 1/4 ) .",
    "with k iterations the probability of test failing is _ ( 1/4)k _ or _ 4(-k)_. this test is comparatively slower compared to fermat s test but it does nt break down for any specific composite numbers and 18 - 20 iterations is a quite good choice for most applications .",
    ".... int miller(long long p , int iteration ) {      if(p<2 ) { /*this conditional statement is           not required for our given program .",
    "we write it for maintaining generality.*/          return 0 ;      }      if(p!=2 & & p%2==0 ) {          return 0 ;      }      long long s = p-1 ;      while(s%2==0 ) {          s/=2 ;      }      int i=0 ;      for(i=0;i <",
    "iteration;i++ ) {          long long a = rand()%(p-1)+1,temp = s ;          long long mod = modulo(a , temp , p ) ;          while(temp!=p-1 & & mod!=1 & & mod!=p-1 ) {              mod = mulmod(mod , mod , p ) ;              temp * = 2 ;          }          if(mod!=p-1 & & temp%2==0 ) {              return 0 ;          }      }      return 1 ; } ....      the algorithm of rsa consists of the following steps :    \\1 . select two prime nos _ p & q _ such as _ p!=q _",
    "n _ as product of _ p & q _ , i.e. _ n = p*q _    \\3 . calculate _",
    "m _ as product of _ ( p-1 ) & ( q-1 ) _ i.e. _ m=(p-1)(q-1 ) _    \\4 .",
    "select any integer _",
    "e < m _ such that it is co - prime to _ m _ , co - prime means gcd(e , m ) = 1 .",
    "d _ such that _ ( d*e )",
    "mod m = 1 _ , + i.e. _ d = e-1 mod m _",
    "the public key is _ e , n _ the private key is _ d , n _",
    "+ so these are the keys , now if you want to perform some encryption operation using these keys here are the steps , + if you have a text _ p _ , its encrypted version(cipher text _ c _ is ) @xmath6 + to decrpty it back to plain text use @xmath7",
    "successful implementation of above discussed algorithms can be achieved in following steps .      in the implementation of rsa , the first thing we have to do is generate two large prime numbers , _",
    "p _ and _ q_. the standard way to generate big prime numbers is to take a preselected random number of the desired length , apply a fermat test ( best with the base 2 as it can be optimized for speed ) and then to apply a certain number of miller - rabin tests ( depending on the length and the allowed error rate like @xmath8 ) to get a number which is very probably a prime number . the pre - selection is done either by test divisions by small prime numbers ( up to few hundred ) or by sieving out primes up to 10,000 - 1,000,000 considering many prime candidates of the form _ b+2i_(_b _",
    "i _ upto a few thousands ) .    here",
    "pre selection of a random prime by first creating an array of primes of size 10000 by the sieve of eratosthenes .",
    "then generated a random number ` gen ' with the help of ` rand ( ) ` function such that the number is greater than 1000 and less than 10000 .",
    "i have extracted the number at ` gen'-th index position of the array of primes .",
    "now as the extracted number might not be a prime number , applied the fermat primality test .",
    "though fermat is highly accurate in practice there are certain composite numbers _ p _ known as _ carmichael numbers _ for which all values of _ a < p _ for which _ gcd(a , p)=1 _",
    ".@xmath9__modulo p = 1__. if apply fermat s test on a carmichael number the probability of choosing an a such that _ gcd(a , p ) ! = 1 _ is very low ( based on the nature of carmichael numbers ) , and in that case , the fermat s test will return a wrong result with very high probability .",
    "for this reason , applied miller rabin primality test on the number in case it satisfies fermat test .",
    "if the number satisfies all the tests , we get a large number with a very high probability of being prime .",
    "now put the entire set of above operations in a loop such that if the number generated does not satisfy the miller rabin primality test , the above operations will be repeated again and this will go on until we generate a prime number . as needed to generate two prime numbers , we provide another loop outside this which runs two times and stores the generated primes in an array of size 2 .      calculate _",
    "n _ as the product of _ p & q _ , the two generated primes .",
    "the next thing to do is to generate a number _ e _ such that @xmath10 and @xmath11 . here",
    "generated a random number less than @xmath12 and checked their gcd .",
    "continued the process until their gcd is 1 . after generating _ e_,calculated the value of _ d",
    "_ such that @xmath13 the public key is _",
    "\\{e , n}_. the private key is _",
    "\\{d , n}_.      created a function ` encrypt ( ) ` to encrypt a message with the help of public key _",
    "\\{e , n}_. the encrypted keyword _",
    "c _ is calculated by doing @xmath14 .",
    ".... void encrypt ( ) {        long long i ;        c = 1 ;        for(i=0;i < e;i++ )        c = c*m%n ;        c = c%n ;        printf(\"\\n\\tencrypted keyword : % lld\",c ) ; } ....      created a function ` decrypt ( ) ` to decrypt a cipher with the help of private key__\\{d , n}__. the decrypted message _",
    "m _ is calculated by doing @xmath15 .",
    ".... void decrypt ( ) {        long long i ;        m = 1 ;        for(i=0;i < d;i++ )              m = m*c%n ;              m = m%n ;        printf(\"\\n\\tdecrypted keyword : % lld\\n\",m ) ; } ....    .data types used in implementation [ cols=\"^,^,<\",options=\"header \" , ]",
    "example 1 :    .... 62011    12269          f(n ) phi value      = 760738680       public key   : { 11723299,760812959 }       private key : { 288096259,760812959 }     enter the plain text     : 5321         encrypted keyword : 573183424     enter the cipher text    : 573183424         decrypted keyword : 5321          ....    example 2 :    ....      39703    66883           f(n ) phi value      = 2655349164       public key   : { 8068769,2655455749 }       private key : { 149069429,2655455749 }     enter the plain text     : 5321   encrypted keyword : 2521426694     enter the cipher text    : 2521426694         decrypted keyword : 5321       ....",
    "comment : these two examples show how on entering the same message on two different runs , the value of the cipher text is different because of the generation of different prime numbers _",
    "p _ and _ q _ and the different public and private exponents _ e _ and _ d _ , each time the program is run .",
    "the main problem faced is that for a given message _ m _ , the cipher text _ c _ generated is large , nearly a 10 digit number . also , the value of _ d _",
    ", i.e. , the private exponent is of 10 digits . to decrypt _",
    "m _ , we have to calculate @xmath16 .",
    "this calculation is taking a long time in some cases .",
    "the time taken on computing is not fixed it changes in each & every run . after performing a statistical test of encrypting a plain text ( which is 25000 ) & decrypting it time taken is noted      plotting the data it is extremely clear that computational time of phi function , encryption & decryption of plain text & cipher text respectively is not predictable .",
    "some runs of test with takes more time , some takes less time while complexity of computations remaining approximately fixed ."
  ],
  "abstract_text": [
    "<S> this project involves an implementation of the rivest shamir adleman ( rsa)@xcite encryption algorithm in c. it consists of generation of two random prime numbers and a number co - prime to @xmath0 also called euler toitent function . </S>",
    "<S> these three are used to generate a public key and private key . </S>",
    "<S> the user has to enter a message which is encrypted by the public key . </S>",
    "<S> the algorithm also decrypts the generated cipher text with the help of the private key and returns the plain text message which was encrypted earlier .    </S>",
    "<S> plain text : the general message needed to be encrypted is called plain text . </S>",
    "<S> + cipher text : the garbage like looking string having no information about plain text is called cipher text . </S>"
  ]
}