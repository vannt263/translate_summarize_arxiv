{
  "article_text": [
    "although not as well known as huffman s optimal fixed - to - variable - length coding method , the optimal variable - to - fixed - length coding technique proposed by tunstall@xcite offers an alternative method of block coding . in this case , the input blocks are variable in size and the output size is fixed , rather than vice versa .",
    "consider a variable - to - fixed - length code for an independent , identically distributed ( _ i.i.d .",
    "_ ) sequence of random variables @xmath5 , where , without loss of generality , @xmath6 = p_i$ ] for @xmath7 .",
    "the outputs are @xmath8-ary blocks of size @xmath9 for integers  @xmath8  most commonly @xmath10  and @xmath11 , so that the output alphabet can be considered with an index @xmath12",
    ".    -bit - output tunstall tree ]    codewords have the form @xmath13 , so that the code is a @xmath2-ary prefix code , suggesting the use of a coding tree . unlike the huffman tree , in this case",
    "the inputs are the codewords and the outputs the indices , rather than the reverse ; it thus parses the input and is known as a _ parsing tree_. for example ,",
    "consider the first two symbols of a ternary data stream to be parsed and coded using the tree in fig .",
    "[ parsetree ] .",
    "if the first symbol is a @xmath14 , the first index is used , that is , bits @xmath15 are encoded . if the first symbol is not a @xmath14 , the first two ternary symbols are represented as a single index  @xmath16 , @xmath17 , etc .",
    "so , for example , if fig .  [ parsetree ] is the ( ternary ) coding tree , then an input of @xmath18 would first have @xmath19 parsed , coded into binary @xmath20 ; then have @xmath21 parsed , coded into binary @xmath16 ; then have @xmath14 parsed , coded into binary @xmath15 , for an encoded output bitstream of @xmath22 .    if @xmath23 is _ i.i.d . _ , then the probability of @xmath24-symbol codeword @xmath25 is @xmath26 where @xmath27 $ ] ; i.e. , internal nodes have probability equal to the product of their corresponding events . an optimal tree will be that which maximizes expected compression ratio , the numbers of input bits divided by output bits .",
    "the number of input symbols per parse is @xmath24 symbols ( @xmath28 bits ) , depending on @xmath29 , while the number of output bits will always be @xmath30 .",
    "thus the expected ratio to maximize is : @xmath31 where the constant to the left of the right summation term can be ignored , leaving expected input parse length as the value to maximize .    because probabilities are fully known ahead of time , if we start with an optimal ( or one - item ) tree , the nature of any split of a leaf into other leaves , leading to a new tree with one more output item , is fully determined by the leaf we choose to split . since splitting increases expected length ( the value to maximize ) by the probability of the node split , we should split the most probable node at each step , starting with a null tree , until we get to an @xmath0-item tree . splitting one node does not affect the benefit value of splitting nodes that are not its descendents .",
    "this greedy , inductive splitting approach is tunstall s optimal algorithm .",
    "note that , because the output symbol is of fixed length , codeword probabilities should be as uniform as possible , which tunstall s algorithm accomplishes via always splitting the most probable item into leaves , one of which will be the least probable item in the subsequent tree .",
    "tunstall s technique stops just before @xmath0 leaves are exceeded in the tree ; this might have less than @xmath0 leaves as in fig .",
    "[ parsetree ] for @xmath32 .",
    "the optimal algorithm necessarily has unused codes in such cases , due to the fixed - length nature of the output .",
    "markov sources can be parsed using a parameterized generalization of the approach where the parameter is determined from the markov process , independent of code size , prior to building the tree@xcite .",
    "analyses of the performance of tunstall s technique are prevalent in the literature @xcite , but perhaps the most obvious advantage to tunstall codes is that of being randomly accessible@xcite : each output block can be decoded without having to decode any prior block .",
    "this not only aids in randomly accessing portions of the compression sequence , but also in synchronization : because the size of output blocks is fixed , simple symbol errors do not propagate beyond the set of input symbols a given output block represents .",
    "huffman codes and variable - to - variable - length codes ( e.g. , those in @xcite ) do not share this property .",
    "although much effort has been expended in the analysis of tunstall codes and codec implementation , until recently few have analyzed the complexity of generating such codes .",
    "the algorithm itself , in building a tree element by element , would be @xmath33 time given a nave implementation or @xmath34 time using a single priority queue . since",
    "binary output blocks are of size @xmath35 , this is somewhat limiting .",
    "however , recently two independent works@xcite showed that new algorithms based on that of tunstall ( and khodak@xcite ) could derive an optimal code in sublinear time ( in the number of output items ) given a bernoulli ( _ i.i.d .",
    "_  binary ) input random variable .",
    "however , many input sources are not binary and many are not _ i.i.d . _ ; indeed , many are not even memoryless .",
    "a more general linear - time algorithm would thus be of use . even in the binary case ,",
    "these algorithms have certain drawbacks in the control of the construction of the optimal parsing tree . as in tunstall coding",
    ", this parsing tree grows in size , meaning that a sublinear algorithm must `` skip '' certain trees , and the resulting tree is optimal for some @xmath36 which might not be the desired  @xmath0 . to grow the resulting tree to that of appropriate size",
    ", one can revert to tunstall s tree - growing steps , meaning that they are  and their implementation is  still relevant in finding an optimal binary tree .    here",
    "we present a realization of the original tunstall algorithm that is linear time with respect to the number of output symbols .",
    "this simple algorithm can be expanded to extend to nonidentically distributed and ( suboptimally ) to markov sources . because such sources need multiple codes for different contexts , the time and space requirements for the algorithm are greater for such sources , although not prohibitive and still linear with the size of the output . specifically ,",
    "if we have a source with @xmath1 states , then we need to build @xmath1 @xmath2-ary trees .",
    "if the _ total _ number of output leaves is @xmath0 , then the algorithm presented here takes @xmath3 time and @xmath4 space .",
    "( this reasonably assumes that @xmath37 , where @xmath38 is the number of possible triples of conditional probabilities , tree states , and node states ; e.g. , @xmath39 for bernoulli sources and @xmath40 for any markov input . )",
    "the method of implementing tunstall s algorithm introduced here is somewhat similar to two - queue huffman coding@xcite , which is linear time given sorted probabilities .",
    "the two - queue algorithm proceeds with the observation that nodes are _ merged _ in _ ascending _ order of their overall total probability .",
    "thus a queue can be used for these combined nodes which , together with a second queue for uncombined nodes , assures that the smallest remaining node can be dequeued in constant time from the head of one of these two queues .    in tunstall coding",
    ", leaves are _ split _ in _ descending _ order .",
    "consider a node with probability @xmath41 split into two nodes : a left node of probability @xmath42 and a right node of probability @xmath43 . because every prior split node had probability not exceeding @xmath41",
    ", the left child will have no larger a probability than any previously created left child , and the right child will have no larger a probability than any previously created right child . thus , given a bernoulli input , it is sufficient to use two queues to have a linear - time algorithm for computing the optimal tunstall code , as in fig .",
    "[ binaryfig ] .    *  linear - time binary tunstall code generation *    1 .   initialize two empty regular queues : @xmath44 for left children and @xmath45 for right children .",
    "these queues will need to hold at most @xmath0 items altogether .",
    "2 .   split the root ( probability @xmath46 ) node with the left child going into @xmath44 and the right child going into  @xmath45 .",
    "assign tree size @xmath47 .",
    "3 .   move the item with the highest ( overall ) probability out of its queue .",
    "the node this represents is split into its two children , and these children are enqueued into their respective queues .",
    "increment tree size by @xmath46 , i.e. , @xmath48 ; if @xmath49 , go to step 3 ; otherwise , end .    consider the simple example of coding a bernoulli@xmath50 input using a two - bit ( four - leaf ) tree , illustrated in fig .",
    "[ tsplit ] .",
    "initially ( fig .",
    "[ tsplit]a ) , the `` left '' queue has the left child of the root , of probability @xmath51 , and the `` right '' queue has the right child , of probability  @xmath52 . since @xmath51 is larger , the left node is taken out and split into two nodes : the @xmath53 node in the left queue and the @xmath54 node in the right queue ( fig .  [ tsplit]b ) .",
    "the @xmath53 node follows ( being larger than the @xmath52 node and thus all other nodes ) , leaving leaves of probability @xmath55 ( last to be inserted into the left queue , corresponding to input @xmath15 ) , @xmath56 ( last in the right queue , input @xmath16 ) , @xmath54 ( input @xmath57 ) and @xmath52 ( input @xmath46 ) ( fig .",
    "[ tsplit]c ) .",
    "the value maximized , compression ratio ( [ maxval ] ) , is @xmath58 [ example1 ]    as with huffman coding , allowing larger blocks of data generally improves performance , asymptotically achieving entropy ; related properties are explored in @xcite .",
    "as previously indicated , there are faster methods to build optimal trees for bernoulli sources . however , these sublinear - time methods do not directly result in an optimal representation of a given size , instead resulting in one for a ( perhaps different ) output alphabet size not exceeding  @xmath0 .",
    "any method that achieves a smaller optimal tree more quickly can therefore achieve an optimal @xmath0-leaf tree more quickly using the method introduced here in postprocessing .",
    "this method of executing tunstall s algorithm is structured in such a way that it easily generalizes to sources that are not binary , are not _ i.i.d . _ , or are neither .",
    "if a source is not _",
    "_ , however , there is state due to , for example , the nature or the quantity of prior input .",
    "thus each possible state needs its own parsing tree . since the size of the output set of trees is proportional to the total number of leaves , in this case @xmath0 denotes the total number of leaves .    in the case of sources with memory , a straightforward extension of tunstall coding",
    "might not be optimal@xcite .",
    "indeed , the optimal parsing for any given point should depend on its state , resulting in multiple parsing trees . instead of splitting the node with maximum probability , a _",
    "generalized tunstall policy _ splits according to the node maximizing some ( constant - time - computable ) @xmath59 _ across all parsing trees _ , where @xmath29 indexes the beginning state ( the parse tree ) and @xmath60 indexes the state corresponding to the node ; @xmath61 is the probability of the @xmath62^th^ leaf of the @xmath29^th^ tree , conditional on this tree .",
    "every @xmath63 is decreasing in @xmath64 , the probability corresponding to the node in tree @xmath29 to be split .",
    "this generalization generally gives suboptimal but useful codes ; in the case of _ i.i.d .",
    "_ sources , it achieves an optimal code using @xmath65 , where @xmath66 is the natural logarithm .",
    "the functions @xmath67 are yielded by preprocessing which we will not count as part of the algorithm time cost , being independent of @xmath0 . in this case",
    "@xmath0 , the size of the output , is actually the number of total leaves in the output set of trees , not the number in any given tree .",
    "these functions are chosen for coding that is , in some sense , asymptotically optimal@xcite .",
    "consider @xmath2-ary coding with @xmath0 outputs and @xmath38 equivalent output results in terms of states and probabilities  e.g. , @xmath68 for _ i.i.d .",
    "_ input probability mass function @xmath69 , since events all have probability in the @xmath38-member set @xmath70 .",
    "if the source is memoryless , we always have @xmath71 .",
    "a more complex example might have @xmath2 different output values with different probabilities with @xmath1 input states and @xmath1 output states , leading to @xmath72 .",
    "then a straightforward extension of the approach , using @xmath38 queues , would split the minimum-@xmath73 node among the nodes at the heads of the @xmath38 queues .",
    "this would take @xmath4 space and @xmath74 time per tree , since there are @xmath75 steps with @xmath38 looks ( for minimum-@xmath67 nodes , only one of which is dequeued ) and @xmath2 enqueues as a result of the split of a node into @xmath2 children .",
    "( probabilities in each of the multiple parsing trees are conditioned on the state at the time the root is encountered . )",
    "however , @xmath38 could be large , especially if @xmath1 is not small",
    ". we can instead use an @xmath76-time priority queue structure  e.g. , a heap  to keep track of the leaves with the smallest values of @xmath73 .",
    "such a priority queue contains up to @xmath38 pointers to queues ; these pointers are reordered after each node split from smallest to largest according to priority @xmath77 , the value of the function for the item at the head of the corresponding regular queue .",
    "( priority queue insertions occur anywhere within the queue that keeps items in the queue sorted by priorities set upon insertion .",
    "removal of the smallest @xmath73 and inserts of arbitrary @xmath73 generally take @xmath76 amortized time in common implementations@xcite , although some have constant - time inserts@xcite . ) the algorithm  taking @xmath3 time and @xmath4 space per tree , as explained below  is thus as described in fig .",
    "[ generalfig ] .      1 .",
    "initialize empty regular queues @xmath78 indexed by all @xmath38 possible combinations of conditional probability , tree state , and node state ; denote a given triplet of these as  @xmath79 .",
    "these queues , which are not priority queues , will need to hold at most @xmath0 items ( nodes ) altogether .",
    "initialize an additional empty priority queue @xmath80 which can hold up to @xmath38 pointers to these regular queues . 2 .   split the @xmath1 root ( probability @xmath46 ) nodes among regular queues according to  @xmath81 .",
    "similarly , initialize the priority queue to point to those regular queues which are not empty , in an order according to the corresponding  @xmath67 .",
    "assign solution size @xmath82 .",
    "3 .   move the item at the head of @xmath83  the queue pointed to by the head @xmath84 of the priority queue  @xmath80  out of its queue ; it has the lowest @xmath73 and is thus the node to split .",
    "its @xmath2 children are distributed to their respective queues according to  @xmath85 .",
    "then @xmath84 is removed from the priority queue , and , if any of the aforementioned children were inserted into previously empty queues , pointers to these queues are inserted into the priority queue .",
    "@xmath84 , if @xmath83 remains nonempty , is also reinserted into the priority queue according to @xmath73 for the item now at the head of its associated queue .",
    "increment solution size by @xmath86 , i.e. , @xmath87 . if @xmath88 , go to step 3 ; otherwise , end .",
    "as with the binary method , this splits the most preferred node during each iteration of the loop , thus implementing the generalized tunstall algorithm .",
    "the number of splits is @xmath75 and each split takes @xmath89 time amortized .",
    "the @xmath2 factor comes from the @xmath2 insertions into ( along with one removal from ) regular queues , while the @xmath90 factor comes from one amortized priority queue insertion and one removal per split node .",
    "while each split takes an item out of the priority queue , as in the example below , it does not necessarily return it to the priority queue in the same iteration .",
    "nevertheless , every priority queue insert must be one of either a pointer to a queue that had been previously removed from the priority queue ( which we amortize to the removal step ) or a pointer to a queue that had previously never been in the priority queue ( which can be considered an initialization ) .",
    "the latter steps  the only ones that we have left unaccounted  number no more than @xmath38 , each taking no more than @xmath90 time , so , under the reasonable assumption that @xmath91 , these initialization steps do not dominate .",
    "( if we use a priority queue implementation with constant amortized insert time , such as a fibonacci heap@xcite , this sufficient condition becomes @xmath37 . )",
    "we thus have an @xmath92-time method ( @xmath3 in terms of @xmath0 , @xmath1 , and @xmath2 , since @xmath40 ) using only @xmath4 space to store the tree and queue data .",
    "the significant space users are the output trees ( @xmath4 space ) ; the queues ( @xmath38 queues which never have more items in them total than there are tree nodes , resulting in @xmath4 space ) ; and the priority queue ( @xmath93 space ) .",
    "consider an example with three inputs  @xmath14 , @xmath46 , and @xmath10  and two states  @xmath46 and @xmath10 , according to the markov chain shown in fig .",
    "[ gensplit ] .",
    "state @xmath46 always goes to state @xmath10 with input symbols of probability @xmath94 , @xmath95 , and @xmath96 . for state @xmath10 , the most probable output , @xmath97 , results in no state change , while the others , @xmath98 and @xmath99 , result in a change back to state  @xmath46 . because there are @xmath10 trees and each of @xmath10 states has @xmath10 distinct output probability / transition pairs , we need @xmath100 queues , as well as a priority queue that can point to that many queues .",
    "let @xmath101 , @xmath102 , and @xmath103 .",
    "the fifth split in using this method to build an optimal coding tree is illustrated by the change from the left - hand side to the right - hand side of fig .",
    "[ gensplit ] .",
    "the first two splitting steps split the two respective root nodes , the third splits the probability @xmath104 node , and the fourth splits the probability @xmath105 node . at this point",
    ", the priority queue contains pointers to five queues .",
    "( the order of equiprobable sibling items with the same output state does not matter for optimality , but can affect the output ; for the purposes of this example , they are inserted into each queue from left to right . ) in this example we denote these node queues by the conditional probability of the nodes and the tree the node is in .",
    "for example , the first queue , @xmath106 , is that associated with any node that is in the first tree and represents a transition from state @xmath10 to state @xmath10 ( that of probability @xmath104 ) .    before the step under examination ,",
    "the queue that is pointed to by the head of the priority queue is the first - tree queue of items with conditional probability @xmath52 ( i.e. , @xmath107 ) and tree probability @xmath108 .",
    "thus the node to split is that at the head of this queue , which has lowest @xmath73 value @xmath109 .",
    "this item is removed from the priority queue , the head of the queue it points to is also dequeued , and the corresponding node in the first tree is given its three children .",
    "these children are queued into the appropriate queue : for the most probable item  probability @xmath110 , conditional probability @xmath104  is queued into @xmath106 , while the two items both having probability @xmath111 and conditional probability @xmath112 are queued into  @xmath113 .",
    "finally , because the removed queue was not empty , it is reinserted into the priority queue according to the priority value of its head , still @xmath114 .",
    "no other queue needs to be reinserted since none of the new nodes entered a queue that was empty before the step . in this case , then , the priority queue is unchanged , and the queues and trees have the states given in right - hand side .",
    "g.  l. khodak , `` redundancy estimates for word - based encoding of sequences produced by a bernoulli source , '' in _ all - union conference on problems of theoretical cybernetics _ , 1969 , in russian .",
    "english translation available from http://arxiv.org/abs/0712.0097 ."
  ],
  "abstract_text": [
    "<S> a method is presented for constructing a tunstall code that is linear time in the number of output items . </S>",
    "<S> this is an improvement on the state of the art for non - bernoulli sources , including markov sources , which require a ( suboptimal ) generalization of tunstall s algorithm proposed by savari and analytically examined by tabus and rissanen . in general , </S>",
    "<S> if @xmath0 is the total number of output leaves across all tunstall trees , @xmath1 is the number of trees ( states ) , and @xmath2 is the number of leaves of each internal node , then this method takes @xmath3 time and @xmath4 space . </S>"
  ]
}