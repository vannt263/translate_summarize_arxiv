{
  "article_text": [
    "this paper investigates the problem of encoding a given graph @xmath0 into a binary string @xmath18 with the requirement that @xmath18 can be decoded to reconstruct @xmath0 .",
    "this problem has been extensively studied with three objectives : ( 1 ) minimizing the length of @xmath18 , ( 2 ) minimizing the time needed to compute and decode @xmath18 , and ( 3 ) supporting queries efficiently .    as these objectives are often in conflict , a number of coding schemes with different trade - offs have been proposed .",
    "the standard adjacency - list encoding of a graph is widely useful but requires @xmath19 bits where @xmath2 and @xmath1 are the numbers of edges and nodes , respectively .",
    "a folklore scheme uses @xmath20 bits to encode a rooted @xmath1-node tree into a string of @xmath1 pairs of balanced parentheses .",
    "since the total number of such trees is at least @xmath21 , the minimum number of bits needed to differentiate these trees is the log of this quantity , which is @xmath22 by stirling s approximation formula .",
    "thus , two bits per edge up to an additive @xmath23 term is an information - theoretic tight bound for encoding rooted trees .",
    "the rooted trees are the only nontrivial graph family with a known polynomial - time coding scheme whose code length matches the information - theoretic bound .",
    "for certain graph families , kannan , naor and rudich  @xcite gave schemes that encode each node with @xmath24 bits and support @xmath24-time testing of adjacency between two nodes .",
    "for dense graphs and complement graphs , kao , occhiogrosso , and teng  @xcite devised two compressed representations from adjacency lists to speed up basic graph techniques .",
    "galperin and wigderson @xcite and papadimitriou and yannakakis  @xcite investigated complexity issues arising from encoding a graph by a small circuit that computes its adjacency matrix . for labeled planar graphs , itai and rodeh",
    "@xcite gave an encoding of @xmath25 bits .",
    "for unlabeled general graphs , naor @xcite gave an encoding of @xmath26 bits .",
    "let @xmath0 be a plane graph with @xmath1 nodes , @xmath2 edges , @xmath3 faces , and no self - loop .",
    "@xmath0 need not be connected or simple ( i.e. , free of multiple edges ) .",
    "we give coding schemes for @xmath0 which all take @xmath4 time for encoding and decoding .",
    "the bit counts of our schemes depend on the level of required query support and the structure of the encoded family of graphs .",
    "in particular , whether multiple edges ( or self - loops ) are permitted plays a significant role .    for applications that require support of certain queries ,",
    "jacobson @xcite gave an @xmath27-bit encoding for a connected and simple planar graph @xmath0 that supports traversal in @xmath28 time per node visited .",
    "munro and raman  @xcite recently improved this result and gave schemes to encode binary trees , rooted ordered trees and planar graphs . for a general planar @xmath0 , they used @xmath29 bits while supporting adjacency and degree queries in @xmath5 time .",
    "we reduce this bit count to @xmath6 for any constant @xmath7 with the same query support . if @xmath0 is triconnected or triangulated , our bit count further decreases to @xmath30 or @xmath31 , respectively . with the same query support",
    ", we can encode a simple @xmath0 using only @xmath11 bits for any constant @xmath7 . as a corollary ,",
    "if a simple @xmath0 is also triconnected or triangulated , the bit count is @xmath12 or @xmath13 , respectively .",
    "if only @xmath5-time adjacency queries are supported , our bit counts for a general @xmath0 and a simple @xmath0 become @xmath14 and @xmath15 , respectively .",
    "all our schemes mentioned so far as well as that of @xcite can be modified to accommodate self - loops with @xmath1 additional bits .    if we only need to reconstruct @xmath0 with no query support , the code length can be substantially shortened . for this case ,",
    "turn @xcite used @xmath32 bits for @xmath0 that may have self - loops ; this bound was improved by keeler and westbrook @xcite to @xmath33 bits .",
    "they also gave coding schemes for several important families of planar graphs .",
    "in particular , they used @xmath34 bits for a triangulated simple @xmath0 , and @xmath35 bits for a connected @xmath0 free of self - loops and degree - one nodes . for a simple triangulated @xmath0 ,",
    "he , kao , and lu  @xcite improved the count to @xmath36 .",
    "tutte  @xcite gave an information - theoretic tight bound of roughly @xmath37 bits for a triangulated @xmath0 .",
    "for a simple @xmath0 that is free of self - loops , triconnected and thus free of degree - one nodes ,",
    "he , kao , and lu  @xcite improved the count to at most @xmath17 .",
    "we further improve the bit count to at most @xmath38 .",
    "figure  [ fig_summary ] summarizes our results and compares them with previous ones .",
    "we can look up the type of @xmath41 in @xmath42 .",
    "to recover @xmath40 , we perform the following @xmath44 steps . before step @xmath45 , we know the start index of @xmath46}$ ] in @xmath43 . with the cases below ,",
    "step @xmath45 finds the numbers of tree , external , and internal edges in @xmath40 as well as the length of @xmath46}$ ] , which tells us the start index of @xmath47}$ ] in @xmath43 .",
    "_ case a3 _ : @xmath46}$ ] starts with 1 .",
    "let @xmath52 be the maximal block of 1 s in @xmath43 at the start of @xmath46}$ ] .",
    "then , @xmath46}$ ] has length @xmath53 .",
    "let @xmath54 be the symbol after @xmath55 in @xmath43 .",
    "there are two further subcases .",
    "_ case b2 _ : @xmath46}$ ] starts with 0 .",
    "let @xmath63 be the maximal block of 0 s in @xmath43 at the start of @xmath46}$ ] .",
    "then @xmath46}$ ] has length @xmath53 .",
    "let @xmath54 be the symbol after @xmath55 in @xmath43 .",
    "there are two further subcases :                          statement 1 . in the above discussion",
    ", @xmath42 has length @xmath1 , and @xmath43 has length @xmath2 .",
    "the encoding @xmath18 of @xmath0 is the concatenation of @xmath42 and @xmath43 .",
    "treated as an integer of base 3 , @xmath18 uses at most @xmath80 bits .",
    "statement 2 .",
    "let @xmath81 be the dual of @xmath0 . @xmath81 has @xmath3 nodes , @xmath2 edges and @xmath1 faces .",
    "since @xmath0 is triconnected , @xmath81 is also triconnected . furthermore , since @xmath77 , @xmath82 and @xmath81 has no self - loop or multiple edge .",
    "thus , we can use statement 1 to encode @xmath81 with at most @xmath83 bits . since @xmath0 can be uniquely determined from @xmath81 , to encode @xmath0",
    ", it suffices to encode @xmath81 . to shorten @xmath18 ,",
    "if @xmath84 , we encode @xmath0 using at most @xmath85 bits ; otherwise , we encode @xmath81 using at most @xmath86 bits .",
    "this new encoding uses at most @xmath87 bits . since @xmath88 ,",
    "the bit count is at most @xmath89 . for the sake of decoding , we use one extra bit to denote whether we encode @xmath0 or @xmath81 .",
    ", _ tables _ , in lecture notes in computer science 1180 : proceedings of the 16th conference on foundations of software technology and theoretical computer science , springer - verlag , new york , ny , 1996 , pp",
    ".  3742 ."
  ],
  "abstract_text": [
    "<S> let @xmath0 be a plane graph of @xmath1 nodes , @xmath2 edges , @xmath3 faces , and no self - loop . </S>",
    "<S> @xmath0 need not be connected or simple ( i.e. , free of multiple edges ) . </S>",
    "<S> we give three sets of coding schemes for @xmath0 which all take @xmath4 time for encoding and decoding . </S>",
    "<S> our schemes employ new properties of canonical orderings for planar graphs and new techniques of processing strings of multiple types of parentheses .    for applications that need to determine in @xmath5 time the adjacency of two nodes and the degree of a node , we use @xmath6 bits for any constant @xmath7 while the best previous bound by munro and raman is @xmath8 . </S>",
    "<S> if @xmath0 is triconnected or triangulated , our bit count decreases to @xmath9 or @xmath10 , respectively . if @xmath0 is simple , our bit count is @xmath11 for any constant @xmath7 . </S>",
    "<S> thus , if a simple @xmath0 is also triconnected or triangulated , then @xmath12 or @xmath13 bits suffice , respectively .    </S>",
    "<S> if only adjacency queries are supported , the bit counts for a general @xmath0 and a simple @xmath0 become @xmath14 and @xmath15 , respectively .    if we only need to reconstruct @xmath0 from its code , a simple and triconnected @xmath0 uses @xmath16 bits while the best previous bound by he , kao , and lu is @xmath17 .    </S>",
    "<S> [ section ] [ theorem]lemma [ theorem]corollary </S>"
  ]
}