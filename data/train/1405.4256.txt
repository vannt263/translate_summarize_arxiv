{
  "article_text": [
    "_ resource usage analysis _ infers the aggregation of some numerical properties ( named _ resources _ ) , like memory usage , time spent in computation , or bytes sent over a wire , throughout the execution of a piece of code .",
    "the expressions giving the usage of resources are usually functions of the sizes of some input arguments to procedures .",
    "our starting point is the methodology outlined by + @xcite , characterized by the setting up of recurrence equations . in that methodology",
    ", the size analysis is the first of several other analysis steps that include , e.g. , cardinality analysis ( that infers lower and upper bounds on the number of solutions computed by a predicate ) , and which ultimately obtain the resource usage bounds .",
    "one drawback of these proposals , as well as most of their subsequent derivatives , is that they are able to cope with size information about subterms in a very limited way .",
    "this is an important limitation , which causes the analysis to infer trivial bounds for a large class of programs .",
    "for example , consider a predicate which computes the factorials of a list :    p6.3cmp6 cm    .... % listfact(+l , -fl ) .",
    "listfact ( [ ] ,    [ ] ) .",
    "listfact([e|r],[f|fr ] ) : -      fact(e , f ) ,      listfact(r , fr ) .",
    "....    &    .... % fact(+n , -f ) .",
    "fact(0,1 ) .",
    "fact(n , m ) : - n1 is n - 1 ,               fact(n1 , m1 ) ,               m is n * m1 .",
    "....    intuitively , the best bound for the running time of this program for a list @xmath0 is @xmath1 , where @xmath2 and @xmath3 are constants related to unification and calling costs . but with no further information , the upper bound for the elements of @xmath0 must be @xmath4 to be on the safe side , and then the returned overall time bound must also be @xmath4 . in a previous paper  @xcite we focused on a proposal to improve the size analysis based on _",
    "sized types_. while in that paper we already hinted at the fact that the application of our sized types in resource analysis could result in considerable improvement , no description was provided of the actual resource analysis .",
    "this paper is complementary and fills this gap by describing a new resource usage analysis that can _ take advantage of the new information contained in sized types_. furthermore , the resource analysis we propose is _ based fully on abstract interpretation_. previously , the auxiliary analyses used this technique , but the core resource analysis did not use it directly .",
    "our approach formulates the resource analysis as an _ abstract domain _ that can be integrated within a standard , parametric abstract interpreter . in particular , we integrate it into the plai abstract interpretation framework  @xcite of ciaopp , obtaining features such as _ multivariance _ , efficient fixpoints , and assertion - based verification and user interaction for free .",
    "we also perform an assessment of the accuracy and efficiency of the resulting overall system .",
    "in section [ sec : overview ] we give a high - level view of the approach . in the following section we review the abstract interpretation approach to size analysis using sized types .",
    "section  [ sec : resources ] gets deeper into the resource usage analysis , our main contribution .",
    "experimental results are shown in section  [ sec : results ] .",
    "finally we review some related work and discuss future directions .",
    "we give now an overview of our approach to resource usage analysis , and present the main ideas in our proposal using the classical ` append/3 ` predicate as a running example :    .... append ( [ ] ,     s , s ) .",
    "append([e|r ] , s , [ e|t ] ) : - append(r , s , t ) .",
    "....    the process starts by performing the regular type analysis present in the ciaopp system  @xcite . in our example",
    ", the system infers that for any call to the predicate ` append(x , y , z ) ` with ` x ` and ` y ` bound to lists of numbers and ` z ` a free variable , if the call succeeds , then ` z ` also gets bound to a list of numbers .",
    "the set of `` list of numbers '' is represented by the regular type @xmath5 , defined as follows :    .... listnum : = [ ] | [ num | listnum ] . ....    from this regular type definition , sized type schemas",
    "are derived .",
    "the sized type schema @xmath6 is derived from @xmath5 .",
    "this schema corresponds to a list whose length is between @xmath7 and @xmath8 , containing numbers between @xmath9 and @xmath10 .",
    "@xmath11    from now on , in the examples we will use @xmath12 and @xmath13 instead of @xmath5 and @xmath14 for the sake of conciseness .",
    "the next phase involves relating the sized types of the different arguments to the ` append/3 ` predicate using recurrence ( in)equations .",
    "let @xmath15 denote the sized type schema for argument ` x ` in a call ` append(x , y , z ) ` ( from the regular type inferred by a previous analysis ) .",
    "we have that @xmath15 denotes @xmath16 .",
    "similarly , the sized type schema for the output argument ` z ` is @xmath17 , denoted by @xmath18 .",
    "we are interested in expressing bounds on the length of the output list ` z ` and the values of its elements as a function of size bounds for the input lists ` x ` and ` y ` ( and their elements ) . for this",
    ", we set up a system of inequations .",
    "for instance , the inequations that are set up to express a lower bound on the length of the output argument ` z ` , denoted @xmath19 , as a function on the size bounds of the input arguments ` x ` and ` y ` , and their subarguments ( @xmath20 , and @xmath21 ) are :    @xmath22    note that in the recurrence inequation set up for the second clause of ` append/3 ` , the expression @xmath23 ( respectively @xmath24 ) represents the size relationship that a lower ( respectively upper ) bound on the length of the list in the first argument of the recursive call to ` append/3 ` is one unit less than the length of the first argument in the clause head .",
    "as the number of size variables grows , the set of inequations becomes too large .",
    "thus , we propose a compact representation , which allows us to grasp all the relations in one view .",
    "the first change in our proposal is to write the parameters to size functions directly as sized types .",
    "now , the parameters to the @xmath19 function are the sized type schemas corresponding to the arguments ` x ` and ` y ` of the ` append/3 ` predicate :    @xmath25    in a second step , we group together all the inequalities of a single sized type .",
    "as we always alternate lower and upper bounds , it is always possible to distinguish the type of each inequality .",
    "we do not write equalities , so that we do not use the symbol @xmath26 . however , we always write inequalities of both signs ( @xmath27 and @xmath28 ) for each size function , since we compute both lower and upper size bounds . troughout this paper we use a representation using @xmath29 for the symbols @xmath27 and @xmath28 that are always paired . for example , the expression @xmath30 represents the conjunction of the following size constraints :  @xmath31 . in the implementation ,",
    "constraints for each variable are kept apart and solved separatedly .    after setting up the corresponding system of inequations for the output argument ` z ` of ` append/3 ` , and solving it",
    ", we obtain the following expression :    @xmath32    that represents , among others , the relation @xmath33 ( resp .",
    "@xmath34 ) , expressing that a lower ( resp .",
    "upper ) bound on the length of the output list ` z ` , denoted @xmath35 ( resp .",
    "@xmath36 ) , is the addition of the lower ( resp .",
    "upper ) bounds on the lengths of ` x ` and ` y ` .",
    "it also represents the relation @xmath37 ( resp .",
    "@xmath38 ) , which expresses that a lower ( resp .",
    "upper ) bound on the size of the elements of the list ` z ` , denoted @xmath39 ( resp .",
    "@xmath40 ) , is the minimum ( resp .",
    "maximum ) of the lower ( resp .",
    "upper ) bounds on the sizes of the elements of the input lists ` x ` and ` y ` .",
    "resource analysis builds upon the sized type analysis and adds recurrence equations for each resource we want to analyze .",
    "apart from that , when considering logic programs , we have to take into account that they can fail or have multiple solutions when executed , so we need an auxiliary _ cardinality analysis _ to get correct results .",
    "let us focus on cardinality analysis .",
    "let @xmath41 and @xmath42 denote lower and upper bounds on the number of solutions for ` append/3 ` .",
    "following the program structure we can infer :    @xmath43 @xmath44    since @xmath45 , the solution to these inequations must be @xmath46 .",
    "thus , we have inferred that ` append/3 ` has at least ( and at most ) one solution : it behaves like a function . when setting up the equations , we use the result of the non - failure analysis to see that `",
    "append/3 ` can not fail when given lists as arguments .",
    "if not , the lower bound is 0 .    now we move forward to analyzing the number of resolution steps performed by a call to ` append/3 ` ( we will only focus on upper bounds , @xmath47 , for brevity ) . for the first clause",
    ", we know that only one resolution step is needed , so :    @xmath48    the second clause performs one resolution step plus all the resolution steps performed by all possible backtrackings over the call in the body of the clause .",
    "this number can be bounded as a function of the number of solutions .",
    "thus , the equation reads :    @xmath49    solving these equations we infer that an upper bound on the number of resolution steps is the ( upper bound on ) the length of the input list ` x ` plus one .",
    "this is expressed as :    @xmath50",
    "as shown in the ` append ` example , the variables that we relate in our inequations come from sized types , which are ultimately derived from the regular types previously inferred for the program . among several representations of regular types used in the literature",
    ", we use one based on _ regular term grammars _ , equivalent to  @xcite but with some adaptations . a _ type term _ is either a _ base type _",
    "@xmath51 ( taken from a finite set ) , a _ type symbol _",
    "@xmath52 ( taken from an infinite set ) , or a term of the form @xmath53 , where @xmath54 is a @xmath13-ary function symbol ( taken from an infinite set ) and @xmath55 are _ type terms_. a _ type rule _ has the form @xmath56 , where @xmath57 is a _ type symbol _ and @xmath58 a _ type term_. a _ regular term grammar _",
    "@xmath59 is a set of _ type rules_.    to devise the abstract domain we focus specifically on the plai + @xcite framework , integrated within ciaopp@xcite ( see  [ sec : absframe ] ) , where we have incorporated our implementation .",
    "the plai algorithm abstracts execution and - or trees similarly to  @xcite but represents the abstract executions _ implicitly _ and computes fixpoints efficiently using memo tables , dependency tracking , etc .",
    "it takes as input a pair @xmath60 representing an entry point ( predicate ) along with an abstraction of the call patterns ( in the chosen _ abstract domain _ ) and produces an abstraction which overapproximates information at all program points ( for all procedure versions ) .    the formal concept of _ sized type _ is an abstraction of a set of herbrand terms which are a subset of some regular type @xmath57 and meet some lower- and upper - bound size constraints on the number of _ type rule applications _ needed to generate the terms .",
    "a grammar for the new sized types follows :    [ cols=\">,^ , < , > \" , ]",
    "we have constructed a prototype implementation in ciao by defining the abstract operations for sized type and resource analysis that we have described and plugging them into ciaopp s plai .",
    "our objective is to assess the gains in precision in resource analysis .",
    "table  [ expresults ] shows the results of the comparison between the new lower ( * _ lb _ * ) and upper bound ( * _ ub _ * ) resource analyses implemented in ciaopp , which also use the new size analysis ( columns _ new _ ) , and the previous resource analyses in ciaopp  @xcite ( columns _ prev . _ )",
    ". we also compare ( for upper bounds ) with _ raml _  @xcite .",
    "although the new resource analysis and the previous one infer concrete resource usage bound functions , for the sake of conciseness and to make the comparison with raml meaningful , table  [ expresults ] only shows the complexity orders of such functions , e.g. , if the analysis infers the resource usage bound function @xmath61 , and @xmath62 , table  [ expresults ] shows @xmath63 .",
    "the parameters of such functions are ( lower or upper ) bounds on input data sizes .",
    "the symbols used to name such parameters have been chosen assuming that lists of numbers @xmath64 have size @xmath65 , lists of lists of lists of numbers have size @xmath66 , and numbers have size @xmath67 .",
    "the calling modes are the usual ones with the last argument as output .",
    "table  [ expresults ] includes columns with symbols summarizing whether the new ciaopp  resource analysis improves on the previous one and _ raml _ s : @xmath68 ( resp .",
    "@xmath69 ) indicates more ( resp .",
    "less ) precise bounds , and @xmath26 the same .",
    "the new resource analysis improves on ciaopp s previous analysis .",
    "moreover , raml can only infer polynomial costs , while our approach is able to infer other types of functions , as shown for the divide - and - conquer benchmarks ` hanoi ` and ` fib ` , which represent a common class of programs . for predicates with polynomial cost , we get equal or better results than raml .",
    "the last two columns show the times ( in seconds ) required by both lower and upper bound analysis together for the new resource analysis , and for the previous resource analysis in ciaopp ( ciao / ciaopp  version 1.15 - 2124-ga588643 , on an intel core i7 2.4 ghz , 8 gb 1333 mhz ddr3 memory , running mac os x lion 10.7.5 ) .",
    "these times include also the auxiliary non - determinism and failure analyses .",
    "the resulting times are encouraging , despite the currently relatively inefficient implementation of the interface with the mathematica system which is used for solving recurrence equations .",
    "several other analyses for resources have been proposed in the literature . some of them",
    "just focus on one particular resource ( usually execution or heap consumption ) , but it seems clear that they could be generalized .",
    "we already mentioned raml + @xcite in section  [ sec : results ] .",
    "their approach differs from ours in the theoretical framework being used : raml uses a type and effect system , whereas we use abstract interpretation .",
    "another difference is the use of polynomials in raml , which allows a complete method of resolution but limits the type of closed forms that can be analyzed .",
    "in contrast , we use recurrence equations , which have no complete decision procedure , but encompass a much larger class of functions .",
    "type systems are also used to guide inference in @xcite and  @xcite . in  @xcite ,",
    "the authors use sparsity information to infer asymptotic complexities , instead of recurrences .",
    "@xcite uses symbolic evaluation graphs to derive termination and complexity properties .",
    "the recurrence equation approach was proposed originally by wegbreit  @xcite . similarly to ciaopp s previous analysis , the approach of  @xcite applies the recurrence equation method directly ( i.e. , not within an abstract interpretation framework ) .",
    "@xcite shows a complexity analysis based on abstract interpretation over a step - counting version of functional programs , but which does not generate closed forms .",
    "types with embedded size information have also been proposed by  @xcite for functional programs .",
    "our sized type analysis is based on regular types and abstract interpretation , and deals with the logic programming features such as unification , non - determinism , and backtracking .",
    "we have presented a new formulation of resource analysis as a domain within abstract interpretation and which uses as input information the sized types that we developed in  @xcite .",
    "our approach overcomes important limitations of existing resource analyses and enhances their precision .",
    "it also benefits from an easier implementation and integration within an abstract interpretation framework such as plai / ciaopp , which brings in useful features such as _ multivariance _ for free .",
    "finally , the results of our experimental assessment regarding accuracy and efficiency are quite encouraging .    , genaim , s. , and masud , a.  n. 2011 .",
    "ore precise yet widely applicable cost analysis . in _",
    "12th verification , model checking , and abstract interpretation ( vmcai11 ) _ , r.  jhala and d.  schmidt , eds .",
    "lecture notes in computer science , vol .",
    "springer verlag , 3853 .",
    ", pescetti , a. , zaccagnini , a. , and zaffanella , e. 2005 . : towards computer algebra support for fully automatic worst - case complexity analysis .",
    "available from http://arxiv.org/.    \\1991 .",
    "a practical framework for the abstract interpretation of logic programs .",
    "_ 10 , _  2 , 91124 .    , lpez - garca , p. , and hermenegildo , m. 2004 .",
    "ultivariant non - failure analysis via standard abstract interpretation . in _",
    "7th international symposium on functional and logic programming ( flops 2004)_. number 2998 in lncs .",
    "springer - verlag , heidelberg , germany , 100116 .",
    "bstract interpretation and applications to logic programs .",
    "_ 13 , _  2 - 3 , 103179 .",
    "egular type language for logic programs .",
    "in _ types in logic programming_. mit press , 157187 .    \\1993 . .",
    "_ 15 , _  5 ( november ) , 826875 .    ,",
    "lin , n .- w . , and hermenegildo , m. 1990 .",
    "ask granularity analysis in logic programs . in _ proc . of the 1990 acm conf .",
    "on programming language design and implementation_. acm press , 174188 .    , lpez - garca , p. , hermenegildo , m. , and lin , n .- w .",
    "ower bound cost estimation for logic programs . in _ 1997 international logic programming symposium_. mit press , cambridge , ma , 291305 .    ,",
    "strder , t. , schneider - kamp , p. , emmes , f. , and fuhs , c. 2012 .",
    "symbolic evaluation graphs and term rewriting : a general methodology for analyzing logic programs . in _",
    "acm , 112 .",
    "cost recurrences for dml programs . in _ international conference on functional programming_. 253264 .    , bueno , f. , carro , m. , lpez , p. , mera , e. , morales , j. , and puebla , g. 2012 .",
    "n overview of ciao and its design philosophy .",
    "_ 12 , _  12 ( january ) , 219252 .",
    "http://arxiv.org/abs/1102.5497 .    ,",
    "aehlig , k. , and hofmann , m. 2012 .",
    "multivariate amortized resource analysis .",
    "_ 34 , _  3 , 14 .",
    "\\2002 . resource usage analysis . in _",
    "symposium on principles of programming languages_. 331342 .    ,",
    "bueno , f. , and hermenegildo , m. 2010 .",
    "utomatic inference of determinacy and mutual exclusion for logic programs using mode and type information .",
    "_ 28 , _  2 , 117206 .    , darmawan , l. , and bueno , f. 2010 .",
    "ramework for verification and debugging of resource usage properties . in _ technical communications of the 26th intl .",
    "conference on logic programming ( iclp10 ) _ ,",
    "m.  hermenegildo and t.  schaub , eds .",
    "leibniz international proceedings in informatics ( lipics ) , vol .",
    "schloss dagstuhl  leibniz - zentrum fuer informatik , dagstuhl , germany , 104113 .",
    "etermination of variable dependence information at compile - time through abstract interpretation . in _ 1989 north american conference on logic programming_. mit press , 166189 .",
    "ompile - time derivation of variable dependency using abstract interpretation .",
    "_ 13 , _  2/3 ( july ) , 315347 .    ,",
    "mera , e. , lpez - garca , p. , and hermenegildo , m. 2007 .",
    "ser - definable resource bounds analysis for logic programs . in _",
    "23rd international conference on logic programming ( iclp07)_. lecture notes in computer science , vol .",
    "springer .    , nielson , h.  r. , and seidl , h. 2002 .",
    "automatic complexity analysis . in _",
    "european symposium on programming_. 243261 .",
    "ptimized algorithms for the incremental analysis of logic programs . in _ international static analysis symposium ( sas 1996)_. number 1145 in lncs .",
    "springer - verlag , 270284 .",
    "utomatic complexity analysis . in _",
    "4th acm conference on functional programming languages and computer architecture ( fpca89)_. acm press .    , lopez - garcia , p. , bueno , f. , and hermenegildo , m. 2013 .",
    "ized type analysis for logic programs ( technical communication ) . in _",
    "theory and practice of logic programming , 29th intl .",
    "conference on logic programming ( iclp13 ) special issue , on - line supplement _ , t.  swift and e.  lamma , eds .",
    "vol .  13 .",
    "cambridge u. press , 114 .",
    "inferring cost equations for recursive , polymorphic and higher - order functional programs . in _ ifl _ , p.  w. trinder , g.  michaelson , and r.  pena , eds .",
    "lecture notes in computer science , vol .",
    "springer , 86101 .",
    "ore precise yet efficient type inference for logic programs . in _",
    "international static analysis symposium_. lecture notes in computer science , vol .",
    "springer - verlag , 102116 .",
    "echanical program analysis .",
    "_ 18 , _  9 .",
    "abstract interpretation @xcite is a framework for static analysis .",
    "execution of the program on a concrete domain is simulated in an abstract domain , simpler than the former one .",
    "both domains must be lattices , @xmath70 and @xmath71 . to go from one to another we use a pair of functions , called _ abstraction _ @xmath72 and _ concretization _",
    "@xmath73 , which should form a galois connection : @xmath74 intuitively @xmath75 generates the smallest element in @xmath76 that contains all the elements in @xmath77 , and @xmath78 computes all the concrete elements represented by @xmath10 .",
    "the methodology is very general , so we focus specifically on the plai + @xcite framework .",
    "the plai algorithm abstracts execution and - or trees similarly to  @xcite but represents the abstract executions _ implicitly _ and computes fixpoints efficiently using memo tables , dependency tracking , etc .",
    "the procedure is _ generic _",
    "( _ parametric _ ) in the sense that it factors out the abstraction of program execution flow ( the execution and - or trees ) , which is common to many different analyses , from other ( mainly data - related ) abstractions , which are more application - specific , and which are encoded as one or more _",
    "abstract domains_. it is also goal dependent : it takes as input a pair @xmath60 representing a predicate along with an abstraction of the call patterns ( in the chosen _ abstract domain _ ) and produces an abstraction @xmath79 which overapproximates the possible outputs , as well as all different call / success pattern pairs for all called predicates in all paths in the program and the corresponding abstract information at all other program points , for all procedure versions .",
    "this algorithm is the basis of the plai abstract analyzer found in ciaopp  @xcite , where we have integrated a working implementation of the proposed resource analysis . in plai ,",
    "abstract domains are pluggable units which need to define implementations of @xmath80 , least upper bound ( @xmath81 ) , bottom ( @xmath82 ) , and a number of other operations related to predicate calls and successes . for any clause @xmath83 ,",
    "let @xmath84 and @xmath85 be the abstract substitutions to the left and to the right of literal @xmath86 , and @xmath87 and @xmath88 their projections onto the variables of @xmath86 respectively .",
    "@xmath89 and @xmath90 are the _ entry _ and _ exit _ substitutions of the clause respectively , denoted also as @xmath91 and @xmath92",
    ". we can show this graphically as follows :    cc    ( call ) at ( -1.5 , 1.5 ) @xmath93 ; ( p ) at ( 0,1.5 ) @xmath94 ; ( success ) at ( 1.5 , 1.5 ) @xmath95 ; ( b1e ) at ( -4.5,0 ) @xmath96 ; ( h1 ) at ( -3,0 ) @xmath97 ; ( b1x ) at ( -1.5,0 ) @xmath98 ; ( dots ) at ( 0,0 ) @xmath99 ; ( bme ) at ( 1.5,0 ) @xmath100 ; ( hm ) at ( 3,0 ) @xmath101 ; ( bme ) at ( 4.5,0 ) @xmath102 ; ( p )  ( h1 ) ; ( p )  ( hm ) ;    &    ( entry ) at ( -2 , 1 ) @xmath91 ; ( h ) at ( 0,1 ) @xmath103 ; ( exit ) at ( 2 , 1 ) @xmath92 ; ( l1 ) at ( -3,0 ) @xmath89 ; ( p1 ) at ( -2,0 ) @xmath104 ; ( l2 ) at ( -1,0 ) @xmath105 ; ( dots ) at ( 0,0 ) @xmath99 ; ( ln ) at ( 1,0 ) @xmath106 ; ( pn ) at ( 2,0 ) @xmath107 ; ( ln1 ) at ( 3,0 ) @xmath90 ; ( h )  ( p1 ) ; ( h )  ( pn ) ;    to compute @xmath95 from @xmath93 of a generic ( sub)goal @xmath108 with predicate @xmath94 :    1 .",
    "generate a @xmath109 from @xmath93 for each of the @xmath110 clauses @xmath111 defining the predicate @xmath94 .",
    "this transfers the unification of the subgoal and head variables into @xmath76 .",
    "2 .   for each clause @xmath111 , compute @xmath112 from @xmath109 , and then project @xmath112 back again onto the subgoal variables , obtaining @xmath113 .",
    "aggregate all the exit substitutions using the least upper bound , @xmath114 .",
    "computing @xmath92 from @xmath91 is straightforward : set @xmath91 as @xmath89 . then , project it onto the variables appearing in the call to the first literal @xmath115 , obtaining @xmath116 for @xmath115 , and compute @xmath117 from it using the procedure mentioned above .",
    "now @xmath89 is integrated with this success substitution , referred to as _ extending _",
    "@xmath89 with @xmath117 . the result is set as @xmath105 , for which the same series of steps is performed with respect to the second literal @xmath118 .",
    "the process continues until @xmath90 is obtained , which is actually @xmath92 .    in the process",
    ", more than one call substitution may appear for the same predicate .",
    "this is called _ multivariance _ of predicates .",
    "furthermore , if the predicate is recursive , a fixpoint needs to be computed . to do so",
    ", the process above is iterated starting from the bottom element of the lattice , @xmath82 .",
    "+ @xcite describe performant algorithms for this purpose , which are implemented in ciaopp .",
    "because of space constraints , in the main part of the paper the concrete and abstract domains have not been described in full . in this section",
    "we aim to give a more precise definition of both elements within the framework of abstract interpretation .    in the concrete domain ,",
    "the _ resource usage _ of a predicate ` p ` with respect to a set of resources @xmath119 is given by a set of triples @xmath120 , where @xmath121 is a tuple of terms .",
    "the interpretation of such set is that for a call to ` p ` with arguments bound to @xmath121 , the number of solutions is exactly @xmath122 and the resource usage of each @xmath119 is exactly @xmath123 . note that @xmath122 and @xmath123 are actual values , not equations or recurrences .",
    "the resource usage is computed by adding the head cost at the point of entering a clause and the literal cost at the point of calling a literal in the body , using the usual sld resolution semantics .",
    "this definition follows closely the one in  @xcite , but extended to support several resources and cardinality .",
    "let @xmath124 be the set of tuples of terms @xmath121 for which a concrete element @xmath125 has information over its resource usage .",
    "we define @xmath126 if and only if @xmath127 and for each @xmath128 , @xmath129 .",
    "that is , the set of terms of the smaller element must be a subset of the larger one , and the cardinality and resource usage must coincide in the common part of their domains .",
    "this concrete domain is abstracted in three different ways , to get a compound domain .",
    "two of them have already been discussed in the literature : the non - failure and determinacy analyses .",
    "those components of the abstract domain correspond to abstracting the set of elements @xmath121 using a regular type abstract domain and then summarizing for those elements whether @xmath130 or @xmath131 ( for the non - failure domain ) and whether @xmath132 or @xmath133 ( for the determinacy one ) .",
    "the @xmath134 component of the abstract elements follows closely the non - failure analysis , keeping different information during the analysis , but with the same result .",
    "for the recurrences part , we perform several abstractions .",
    "first of all , we move from strict values for the number of solutions and resource usage to value bounds .",
    "thus , the elements are sets of triples @xmath135 . the ordering is now given by : @xmath136 the abstraction function in this case is very simple",
    ", we just need to send each value to an interval with it as only point : @xmath137    the second abstraction involves summarizing the domain of each @xmath138 using the sized types abstract domain . as discussed in  @xcite",
    ", a set of terms is described via sized types using sized type schemas along with a domain @xmath139 which tells which are the values of the bound variables which are covered by the abstract element , and a set of recurrences @xmath140 which defines the relations that bound variables must satisfy between them .",
    "when adding resource usage information , apart from the bounds from sized types we can refer to new variables : @xmath41 and @xmath42 refer to the upper and lower bound in the number of solutions , and @xmath141 contains such variables for each resource in the system .    in this case , it is easier to give the concretization function to move from an abstract element @xmath125 to one in the intermediate abstract domain : @xmath142 where @xmath143 returns the upper and lower _ numerical _ bounds for the variables @xmath144 as given in the recurrences @xmath140 for the tuple of values @xmath121 . in few words",
    ", @xmath145 takes all the possible tuples of values given by the sized type we refer to , and computes the cardinality and resource usage of each of them as given by the recurrence equations .",
    "the intermediate domain and this concretization function allows us to define an ordering @xmath80 in the abstract elements .",
    "but , as stated in the main part of the paper , doing so would entail knowing whether some recurrences define a set that is larger or smaller than another one .",
    "this is an undecidable problem , and thus we need to resort to other checks which , while being correct , are not complete . in our case , we chose to use a syntactic check .    from @xmath146 we can obtain the corresponding concretization function @xmath147 , and from @xmath145 we can do the same to obtain an @xmath148 . by composition",
    "we obtain the abstraction @xmath149 and concretization @xmath150 functions that define the galois connection between concrete resource usage triples and the abstract domain of recurrence equations .    as stated before , our complete abstract elements : @xmath151 are the combination of that given by @xmath152 with those of non - failure ( which give the @xmath134 and @xmath153 components ) and determinism ( which gives the @xmath154 component ) , which abstract information about @xmath122 over all possible values . for an abstract element @xmath155 to be smaller than @xmath156 , it must be smaller in all of the three domains at the same time ."
  ],
  "abstract_text": [
    "<S> we present a novel general resource analysis for logic programs based on sized types . </S>",
    "<S> sized types are representations that incorporate structural ( shape ) information and allow expressing both lower and upper bounds on the size of a set of terms and their subterms at any position and depth . </S>",
    "<S> they also allow relating the sizes of terms and subterms occurring at different argument positions in logic predicates . using these sized types , </S>",
    "<S> the resource analysis can infer both lower and upper bounds on the resources used by all the procedures in a program as functions on input term ( and subterm ) sizes , overcoming limitations of existing resource analyses and enhancing their precision . </S>",
    "<S> our new resource analysis has been developed within the abstract interpretation framework , as an extension of the sized types abstract domain , and has been integrated into the ciao  preprocessor , ciaopp . </S>",
    "<S> the abstract domain operations are integrated with the setting up and solving of recurrence equations for inferring both size and resource usage functions . </S>",
    "<S> we show that the analysis is an improvement over the previous resource analysis present in ciaopp  and compares well in power to state of the art systems .    </S>",
    "<S> [ firstpage ] </S>"
  ]
}