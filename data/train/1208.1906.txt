{
  "article_text": [
    "the idea for a batch spreadsheet processor was originally proposed in @xcite in the context of a course on parser design .",
    "the evolution of that idea presented here , which goes far beyond what was originally envisioned and implemented in the course , is based on the premise of enabling anything that seems reasonable , even if the usefulness is not immediately apparent .",
    "so , for example , if formula syntax is based on the c programming language , then it should support all of c s operators , including + + , + = , etc .",
    "this is discussed further in section [ sec : cycles ] on cycles .",
    "other examples , where the usefulness is apparent and the behavior intuitively expected , are allowing lists ( such as function arguments ) to be specified using cell ranges , cell ranges to be specified using single cells ( for a single  cell range ) , and ranges to overlap and be specified in reverse and by columns or rows as discussed in section [ sec : ranges ] .    after a brief review of the history of spreadsheets",
    ", we will present the specifications for the proposed batch processor , together with some examples from a partial implementation .",
    "the history of electronic spreadsheets @xcite starts with richard mattessich @xcite in 1964 .",
    "the output of his batch processor looked like a spreadsheet , but the input was purely data and all functionality was encoded in the fortran program implementing the business budget model . in all subsequent spreadsheet implementations , including the one proposed here , the input specifies both the data and the functional relationships among the cells .",
    "the modern interactive spreadsheet era starts in 1979 with visicalc , by dan bricklin and bob frankston . in 1982",
    "james gosling created the unix _ sc _ spreadsheet calculator which has evolved through the work of others and is still in use today . in 1983 came lotus 1 - 2 - 3 , by mitch kapor , and in 1985 excel for macintosh , by microsoft ( windows came later ) .",
    "there was also quattro pro , by borland , in 1987 , but in the battle for the commercial spreadsheet market eventually excel won .",
    "other popular opensource spreadsheet implementations include oleo ( 1992 ) and gnumeric , from the gnu project , 1998 , and openoffice , from staroffice and sun , 2000 .",
    "it is well - known that spreadsheet design and use can be very error - prone @xcite , and most of the problems stem from the interactive nature of modern spreadsheet features such as cut / paste , adding and removing rows and columns , etc .",
    "the batch approach eliminates many of the traditional problems , while enabling more powerful command - line types of options .",
    "for example , to copy the entries from one range of cells to another , a copy command like _ copy a2:c6 d6:b2 _ allows overlapping and reverse ranges .",
    "a batch spreadsheet processor can also be written using portable c code , with no system - dependent gui .",
    "for ease of discussion , we will refer to the batch spreadsheet for c programmers as simply `` ss '' for the rest of the paper .",
    "ss first reads input from any files specified on the command line , then it reads standard input for additional commands such as may be supplied by a front - end gui , or by the user directly .",
    "the input may contain c or c++ style comments , and macros using # define . as in c",
    ", input lines are joined together whenever one ends with a backslash followed by a literal newline character .",
    "output goes to standard output by default , but can be redirected globally using the output command , or redirected on a per  command basis using the plot and print commands .",
    "`` stdout '' and `` - '' , with or without quotes , can be used as pseudo output file names to refer to standard output .",
    "cell references may be specified in any one of three formats : a0 , rc , and cr . in a0 format ,",
    "cells are specified by their column ( one or two letters , a - z , case - insensitive ) and row ( one - to - three digits 0 - 9 ) , with an optional $ preceding the column and/or row value to indicate that the cell is fixed . the column value",
    "a ... zz represents an integer column number 0 ... 701 . in rc and cr formats ,",
    "cell are specified by their absolute row and column numbers , using the letters r and c ( or r , c ) , with brackets around relative offsets .",
    "when copying formulas , relative cell references remain relative to the destination cells , and fixed references remain fixed . the format for displaying cells in formulas",
    "may be selected using the format command .",
    "a range consists of two cells , the start and end cells of the range , separated by a colon .",
    "for example , a0:b9 ( or a0:c1r9 , or r0c0:r9c1 , or c0r0:r9c1 , etc . ) specifies a range including rows 0 to 9 of columns a and b. the range start and end values do not have to be in increasing order ; b9:a0 , b0:a9 , and a9:b0 all refer to the same group of cells as a0:b9 , but correspond to different directions for traversing the range . for example",
    "the command _",
    "copy a0:a9 b9:b0 _ would copy column b to a in reverse order .    by default",
    ", ranges are traversed byrows to improve cache performance , since elements in a row are adjacent in memory .",
    "that is , in pseudo - code :    ....    for row = start_row to end_row      for col = start_col to end_col        use cell[row , col ] ....    the bycols option can be used with the copy , eval , fill , plot , and print commands to cause evaluation by columns .",
    "that is , in pseudo - code :    ....    for col = start_col to end_col      for row = start_row to end_row        use cell[row , col ] ....    note that the starting row may be less than , equal to , or greater than the ending row .",
    "same for columns .",
    "so a range may consist of a single cell , row , or column ( a0:a0 , a0:d0 , a0:a4 ) , cells in `` forward '' order ( a0:b4 ) , or cells in `` partial reverse '' order ( a4:b0 , b0:a4 ) , or cells in `` reverse '' order ( b4:a0 ) .",
    "a range basically represents a list of cells , and is explicitly converted to a list when used in a range assignment or numeric function argument . a range consisting of a single cell",
    "may be specified using just that one cell , e.g.  a0 as a range is the same as a0:a0 .",
    "the ss primitive data types are double precision floating point , string , and constant .",
    "all numeric calculations are performed and stored using double precision floating point .",
    "a string is a sequence of characters enclosed in single or double quotes .",
    "no escape sequences are recognized .",
    "if a string appears in a numeric calculation it is treated as having the value 0 .",
    "the built - in constants are : huge_val = inf ; rand_max = 32767 ; pi = 3.14159 ( computed from 4*atan(1 ) ) .",
    "the values of the constants shown are from a solaris / sparc system and may vary depending on the system .",
    "undefined cells are treated as having the value 0 .",
    "user - defined variables are stored in a symbol table and their formulas are evaluated each time the spreadsheet is evaluated .",
    "note that cell names can not be used as variables .",
    "see sections [ sec : example ] and [ sec : cycles ] for examples using symbols .",
    "ss operators have the same precedence and associativity as those in the c programming language .",
    "they mostly have the same meaning too , except for some of the bitwise operators .",
    "the keywords not , and , xor , and or , case  insensitive , may also be used to represent the logical operators .",
    "the bit shift operators ` < < ` , ` < < = ` , ` > > ` , and ` > > = ` are implemented for floating - point using ldexp ( ) to adjust the binary exponent by the specified power of 2 .",
    "additionally , c s bitwise operators are treated as logical operators , so ` ~ ` , & , ` ^ ` , ` | ` are the same as ! , & & , ` ^^ ` ( logical xor ) , ` || ` respectively , and & = , ` ^= ` , ` |= ` are the same as & & = , ` ^^= ` , ` ||= ` .",
    "ss includes all of the functions from the standard c math library , and more .",
    "it includes the time function from time.h , rand and srand from stdlib.h , and also irand , drand , and nrand functions for integer , uniform(0,1 ) , and normally distributed pseudo  random values respectively .",
    "most of the numeric functions take one expression argument and return one value .",
    "a few of the functions take no arguments ( rand , irand , drand , nrand , time ) , and some take two arguments ( atan2 , fmod , frexp , ldexp , modf , pow ) . for frexp and modf , the second argument must be a cell or symbol , since it will be assigned one of the result values .",
    "range functions take an argument list of expressions and ranges and return one value computed from the defined cells .",
    "the range functions include :    ....    avg        average    count      number of cells defined    majority   non - zero if majority are non - zero    max        maximum    min        minimum    prod       product    stdev      standard deviation    sum        sum ....    user  defined numeric and range functions can be written in c following a provided template to access ss internal data structures .",
    "these are loaded at run ",
    "time from a dynamic link library .",
    "commands have their own syntax , consisting of keywords and options . for all commands which traverse a range the ` byrows ` or ` bycols ` option",
    "may be used to set the direction .",
    "ss commands include :    ....    byrows|bycols - set default direction    copy dest_range src_range    debug [ on|off ]    eval [ range|symbols ] [ number_of_iterations ]    exit    fill range start_expr , increment_expr    format a0|rc|cr - formula printing format    format [ cell|row|col|range ] \" fmt_string \"    load \" fname \" ...    output \" fname \"    plot|plot2d|plot3d [ \" fname \" ] [ range ]    print [ \" fname \" ] [ range ] [ all|      macros|symbols|formulas|values|      formats|pointers|constants|functions ] ...    quit    srand expr - initialize rand ( ) ....    if no range or symbols options are specified , eval evaluates the spreadsheet for the number of iterations specified ( default is 2 iterations ) .",
    "each iteration first evaluates the symbol table , then evaluates the cells twice : first starting at the top - left corner of the cells being used and traversing the range to the bottom - right corner of the cells being used ; then again starting at the bottom - right corner and traversing to the top - left corner .",
    "this catches most forward and reverse formula dependencies . if the symbols option is specified , only the symbol table is evaluated for the number of iterations specified . if a range is specified , only the symbol table and that range are evaluated for the number of iterations specified .",
    "the fill command fills a range with constant values , starting with the start expression value , and increasing by the increment expression value for subsequent cells .",
    "the start and increment expressions are evaluated only once , before filling starts .",
    "the format a0 , rc , and cr options specify the format used for printing formulas . for printing values , the format can be set globally or for a specific cell , row , column or range .",
    "the default global format is `` % .2f '' .",
    "if a cell is not assigned a format , printing will use the cell s row format , if set ; otherwise it will use the cell s column format , if set ; otherwise it will use the global format .",
    "the plot commands do not actually plot anything , they simply display output in a form suitable as input to another program like a plot utility .",
    "the following example shows a set of student scores being scaled by their average and standard deviation .",
    "columns a and b represent the `` natural '' use of a spreadsheet for lists of values related to or computed from a parallel list of values .",
    "cells c1 and d1 represent an `` unnatural '' situation which can occur frequently in spreadsheets where we need to store values somewhere , but their exact position does not matter relative to anything else",
    ". it would be more natural to store these types of values in variables instead of a spreadsheet cell .",
    "the example does that for the computation of the mean , in variable _ mean _ , and the use of that variable in the formula for column a is more `` natural '' and readable than the use of $ d$1 for the standard deviation .",
    ".... % cat grades.ss a0:d0 = { \" grade \" , \" score \" , \" avg \" , \" stdev \" } ; mean = avg(b1:b5 ) ; c1=mean ; d1=stdev(b1:b5 ) ; a1=80 + 15*(b1-mean)/$d$1 ; copy a2:a5 a1:a4 ; b1:b5 = { 57 , 67 , 92 , 87 , 76 } ; eval ; print symbols values formulas pointers ; % ss <",
    "grades.ss    mean = avg(b1:b5 ) = 75.8     ( symbols )            a        b        c        d 0        grade    score    avg      stdev 1        60.29    57.00    75.80    14.31 2        70.77    67.00 3        96.98    92.00        ( values ) 4        91.74    87.00 5        80.21    76.00            a 0        \" grade \" 1        80+((15*(b1-mean))/$d$1 ) 2        80+((15*(b2-mean))/$d$1 ) 3        80+((15*(b3-mean))/$d$1 ) 4        80+((15*(b4-mean))/$d$1 ) 5        80+((15*(b5-mean))/$d$1 )            b        c        d 0        \" score \" \" avg \"    \" stdev \" 1        57       mean     stdev(b1:b5 ) 2        67 3        92                   ( formulas ) 4        87 5        76            a        b        c        d 0        1058e28 1058e60 1058e98 1058ed0 1        1059288 0        1058fb0 1059058 2        1059288 0 3        1059288 0            ( pointers ) 4        1059288 0 5        1059288 0 ....    from the `` print pointers '' output at the end we can see that cells a1:a5 all refer to the same formula .",
    "if a cell depends on itself , that forms a cycle and the spreadsheet may not converge when evaluated .",
    "cycles which converge can be used to implement iterative algorithms .",
    "for example , the following spreadsheet uses newton s method to find the square root of x :    .... % cat sqrt.ss x = 2 ; a0 = b0 ?",
    "b0 : x/2 ; b0 = ( a0+x / a0)/2 ; format \" % 20.18 g \" ; ....    since a0 depends on b0 , and b0 depends on a0 , there is a cycle .",
    "a0 will be set to b0 if b0 is non - zero , otherwise a0 will be set to x/2 to initialize the algorithm .",
    "so a0 represents the previous value of b0 , and b0 represents the next estimate of the square root .",
    "newton s method converges quickly :    .... % echo \" print all ; eval a0:b0 10 ; \\ print values ; \" | ss sqrt.ss    x = 2      a                     b 0 b0 ?",
    "b0 : ( ( x/2 ) )     ( a0+(x / a0))/2      a                     b 0 0                     0    ss_eval : : converged after 7 iterations      a                     b 0 1.41421356237309492   1.41421356237309492 ....    finite element analysis is another application which requires iteration and can be set up in a spreadsheet . in the following small example , the value of each non - boundary cell is computed as the average of the cell s four nearest neighbors .    .... % cat cycles.ss // average of 4 nearest neighbors r1c1=(r[]c[-1]+r[]c[+1]+r[-1]c[]+r[+1]c[])/4 ; copy r1c2:r1c5 r1c1:r1c4;// set up one row copy r2c1:r5c5 r1c1:r4c5;// copy to rows 2 .. 5 fill r0c0:r0c6 1 , 0;// boundary conditions , fill r1c0:r6c0 1 , 0;//   1 's top and left fill r1c6:r6c6 0 , 0;//   0 's right and bottom fill r6c1:r6c5 0 , 0 ; format \" % 6.4f \" ; format rc ; print values ; eval ; eval 1000 ; print values ; % ss < cycles.ss       0        1        ...      5        6 0     1.0000   1.0000   ...",
    "1.0000   1.0000 1     1.0000   0.0000   ...",
    "0.0000   0.0000 2     1.0000   0.0000   ...",
    "0.0000   0.0000 3     1.0000   0.0000   ...      0.0000   0.0000 4     1.0000   0.0000   ...",
    "0.0000   0.0000 5     1.0000   0.0000   ...      0.0000",
    "0.0000 6     1.0000   0.0000   ...",
    "0.0000   0.0000 ss_eval : still changing after 2 iterations ss_eval : converged after 74 iterations         0        1        ...      5        6 0     1.0000   1.0000   ...      1.0000   1.0000 1     1.0000   0.9374   ...      0.5000   0.0000 2     1.0000   0.8747   ...      0.2990   0.0000 3     1.0000   0.8040   ...      0.1960   0.0000 4     1.0000   0.7010   ...      0.1253   0.0000 5     1.0000   0.5000   ...      0.0626   0.0000 6     1.0000   0.0000   ...      0.0000   0.0000 ....    a larger finite element analysis example is shown in figure [ fig : plot3d ] using a web  based gui front - end with 3d plotting .",
    "the spreadsheet may not converge when using operators + + , ` -- ` , + = , * = , etc .  and the pseudo - random number generator functions , since they produce varying values on each evaluation",
    ". however , these operators and functions are still useful , in particular for monte - carlo simulations .",
    "the following simple example generates pseudo - random values for a0 , with b0 representing the sum , c0 the evaluation count , and d0 the average :    .... % cat rand.ss a0 = drand ( ) ; b0 + = a0 ; d0 = b0/++c0 ; eval a0:d0 10 ; print values ; % ss < rand.ss ss_eval : : still changing after 10 iterations          a        b        c        d 0        0.37     4.90     10.00    0.49 ....    the following example contains cycles in the formulas for symbols _ sample _ and _ trials _ , and cells _",
    "c1:c60_. it tests the distribution of nrand values using 60 counters over the range -3 to 3 with 50000 samples ( iterations ) .    ....",
    "sample = nrand ( ) ; trials + = 1 ; fill a1:a61 -3 , 0.1 ;",
    "c1 + = ( sample>=a1)&&(sample < a2 ) ? 1 : 0 ; b1 = c1/trials ; copy b2:c60 b1:c59 ; eval c1:b60 50000 ; plot a1:b60 ; ....    the results , plotted in figure [ fig : nrand ] , are consistent with the normal distribution .",
    "ss intentionally omits certain features which are commonly found in spreadsheets and other computational environments .",
    "it omits data types other than simple strings and double precision floating point , targeting mainly numerical applications involving floating point operations . internally",
    ", other data types may be used as appropriate when implementing specific algorithms , but the cell and symbol values are stored using floating point .",
    "it also omits matrices and matrix operations , on the basis that applications requiring matrix operations are best implemented using one of the many existing high  quality commercial or free software packages designed for those kinds of applications .",
    "the current implementation of ss contains less than 40 numeric and range functions , which represent the most basic framework necessary for proof  of  concept .",
    "most spreadsheets and programming environments contain hundreds of functions ; for example , gnumeric @xcite contains 520 , so any practical implementation must allow for easy extension by adding new functions .",
    "the implementation of new internal functions should follow the same templates as user  defined functions ,    the main difference being that internal functions are compiled  in whereas user  define functions are dynamically linked in at run  time . for example , the complete implementation of the irand function is :    .... / * 1 pseudo - random integer , 0<=irand(i)<=i-1 * / double nf_irand(const node * n , const cell * c ) {    int i = eval_tree ( n->u.t.right , c ) ;      return ( int ) ( i*(rand()/(rand_max+1.0 ) ) ) ; } ....    by simply placing that code in an irand.c file in the numeric function sub  directory of the source code , it will be compiled  in .",
    "the first ",
    "line comment is used to specify how many arguments the function takes and a description that will be included in both the run  time help command and the documentation .",
    "the template for all functions consists of parse tree node and reference cell arguments , and a double return value .",
    "the technical literature on spreadsheet implementation is relatively sparse @xcite , as opposed to publications covering use of spreadsheets .",
    "innovation is hampered by requiring excel compatibility and designing for non  programmer users .",
    "the computing environment proposed here brings together the spreadsheet and workspace ( variables and symbol table ) paradigms , with powerful batch input commands and c  compatible formula syntax .",
    "it provides flexibility in formula evaluation and range traversal , and allows cycles , so it can be used to implement iterative as well as traditional spreadsheet applications ."
  ],
  "abstract_text": [
    "<S> a computing environment is proposed , based on batch spreadsheet processing , which produces a spreadsheet display from plain text input files of commands , similar to the way documents are created using latex . in this environment , besides the usual spreadsheet rows and columns of cells , variables can be defined and are stored in a separate symbol table . </S>",
    "<S> cell and symbol formulas may contain cycles , and cycles which converge can be used to implement iterative algorithms . </S>",
    "<S> formulas are specified using the syntax of the c programming language , and all of c s numeric operators are supported , with operators such as + + , + = , etc .  </S>",
    "<S> being implicitly cyclic . </S>",
    "<S> user  </S>",
    "<S> defined functions can be written in c and are accessed using a dynamic link library . </S>",
    "<S> the environment can be combined with a gui front - end processor to enable easier interaction and graphics including plotting .    </S>",
    "<S> * keywords : * computational models , software architectures for scientific computing </S>"
  ]
}