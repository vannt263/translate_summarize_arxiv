{
  "article_text": [
    "planning and logic programming are two close areas of research . planner @xcite , which was designed as _ a language for proving theorems and manipulating models in a robot _ ,",
    "is perceived as the first logic programming language .",
    "planning has been an important problem domain for prolog @xcite . despite the amenability of prolog to planning",
    ", prolog is no longer a competitive tool for planning .",
    "tabling @xcite is a technique used in logic and functional programming systems , which caches the results of certain calculations in memory and reuses them in subsequent calculations through a quick table lookup . like state marking used in search algorithms ,",
    "tabling can prevent the same state from being expanded more than once during search .",
    "tabling has been found useful in many search problems , including theorem proving @xcite , program analysis @xcite and model checking @xcite .",
    "recently , tabled logic programming has been successfully employed to solve specific planning problems @xcite , and has been shown to be significantly faster than the state - of - the - art asp ( answer set programming ) planners on some problems @xcite .",
    "this paper describes picat s planner and its implementation .",
    "this paper also presents planning models in picat for several domains used in international planning competition 2014 ( ipc14 ) @xcite , and demonstrates broader applicability of tabled logic programming to planning .",
    "picat is a logic - based multi - paradigm language that provides logic variables , pattern matching , nondeterminism through backtracking , loops , functions , constraints , and tabling as its core modeling and solving features . as a modeling language for planning",
    ", picat differs from pddl ( plan domain description language ) @xcite and asp @xcite in several aspects : ( 1 ) picat allows use of structures to represent states ; ( 2 ) picat supports explicit commitment and nondeterministic actions , which enables users to have better control over action applications ; ( 3 ) picat provides facilities for describing domain knowledge and heuristics for pruning search space .    as a solving system ,",
    "picat s planner implements several techniques for better performance .",
    "first , it tables every state encountered during search and avoids repeating the exploration of the same state .",
    "second , it adopts the hash - consing technique @xcite to share common state data and to speed up the equality testing of states .",
    "third , it utilizes tabled states to effectively perform _ resource - bounded _ search . for optimal planning , picat offers built - ins to perform iterative search , but unlike ida * @xcite , picat also reuses results tabled in early iterations @xcite .",
    "this paper shows that the above - mentioned features of picat make picat a more appropriate language than pddl for modeling and solving planning problems . to that end",
    ", this paper presents examples in picat for several domains used in ipc14 .",
    "these examples illustrate several modeling techniques on how to design state representations to facilitate data sharing and symmetry breaking , on how to translate pddl operators into picat actions , and on how to incorporate domain knowledge and heuristics to reduce search spaces .",
    "this paper also gives the experimental results of the presented models and several other models encoded in the same way .",
    "the experimental results demonstrate the effectiveness of tabling and the importance of modeling .",
    "picat is a dynamically - typed language .",
    "the basic types are taken from prolog , except for _ arrays _ and _ maps_. an array takes the form ` { t_1,\\ldots , t_{n } } ` .",
    "the index of the first array element is 1 , and the index notation x[i ] can be used to access array elements .",
    "picat also borrows the basic logical operators from prolog , including _ conjunction _",
    "( @xmath0 ) , _ negation _ ( not @xmath1 ) , _ disjunction _ ( @xmath1;@xmath2 ) , and _ if - then - else _ ( @xmath3->@xmath1;@xmath2 ) .",
    "picat allows function calls in arguments . for this reason",
    ", it requires structures to be preceded with a dollar symbol $ in order for them to be treated as data , unless the structure is special , or it occurs in a head pattern .    for each type , picat provides a set of built - in functions and predicates . many built - in predicates",
    "are taken from prolog , including ` member/2 ` , ` nth/3 ` , and ` select/3 ` . the function ` insert_ordered(list , term ) ` inserts @xmath4 into the ordered list @xmath5 such that the resulting list remains ordered .    in picat ,",
    "predicates and functions are defined with pattern - matching rules .",
    "picat has two types of rules : the _ non - backtrackable rule _",
    "@xmath6`=>`@xmath7 , and the backtrackable rule @xmath6`?=>`@xmath7 . in a predicate definition",
    ", the @xmath8 takes the form @xmath9 , where @xmath10 is a predicate name , and @xmath11 is the arity . the condition @xmath12 , which is an optional goal , specifies a condition under which the rule is applicable . for a call @xmath3 ,",
    "if @xmath3 matches @xmath8 and @xmath12 succeeds , then the rule is said to be _ applicable _ to @xmath3 . when applying a rule to call @xmath3 , picat rewrites @xmath3 into @xmath13 .",
    "if the used rule is non - backtrackable , then the rewriting is a commitment , and the program can never backtrack to @xmath3 .",
    "however , if the used rule is backtrackable , then the program will backtrack to @xmath3 once @xmath13 fails , meaning that @xmath13 will be rewritten back to @xmath3 , and the next applicable rule will be tried on @xmath3 . in a function definition",
    ", the @xmath8 takes the form @xmath14 where @xmath15 is a function name and @xmath4 is a result to be returned .",
    "all of the rules in a function definition must be non - backtrackable .",
    "a pattern can contain _ as - patterns _ of the form ` v@pattern ` , where @xmath16 is a new variable in the head , and @xmath17 is a non - variable term . the as - pattern `",
    "v@pattern ` is the same as ` pattern ` in pattern matching , but after pattern matching succeeds , @xmath16 is made to reference the term that matched @xmath17 .",
    "picat supports loops and list comprehensions .",
    "for example , the loop    ....",
    "foreach(e in l ) goal end ....    is true if goal is true for each e in l. picat adopts the following simple scoping rule : _ variables that occur only in a loop , but do not occur before the loop in the outer scope , are local to each iteration of the loop_. loops are compiled into tail - recursive predicates , and list comprehensions are compiled into tail - recursive predicates through ` foreach ` loops .",
    "picat supports tabling for dynamic programming solutions .",
    "other features of picat include assignments , list comprehensions , global maps for storing permanent data , higher - order functions , action rules for defining event - driven actors , and modules for modeling and solving constraint satisfaction problems with cp , sat , and mip .",
    "both predicates and functions can be tabled . in order to have all calls and answers of a predicate or function tabled , users just need to add the keyword ` table ` before the first rule . for a predicate definition",
    ", the keyword table can be followed by a tuple of table modes , including + ( input ) , - ( output ) , min , max , and nt ( not tabled ) . for a predicate with a table mode declaration that contains min or max , picat tables one optimal answer for each tuple of the input arguments .",
    "the last mode can be ` nt ` , which indicates that the corresponding argument will not be tabled .",
    "linear tabling @xcite is used in picat , and table modes are taken from @xcite , except for the ` nt ` mode , which was initially proposed by @xcite .",
    "ground structured terms are hash - consed @xcite so that common ground terms are tabled only once .",
    "for example , for the three lists ` [ 1,2,3 ] ` , ` [ 2,3 ] ` , and ` [ 3 ] ` , the shared sub - lists ` [ 2,3 ] ` and ` [ 3 ] ` are reused from ` [ 1,2,3 ] ` .",
    "mode - directed tabling has been successfully used to solve specific planning problems such as sokoban @xcite , and the petrobras planning problem @xcite .",
    "a planning problem is modeled as a path - finding problem over an implicitly specified graph .",
    "the following gives the framework used in all these solutions .    ....",
    "table ( + , -,min )      path(s , path , cost ) , final(s ) = > path = [ ] , cost = 0 .",
    "path(s , path , cost ) = >          action(s , s1,action , actioncost ) ,          path(s1,path1,cost1 ) ,          path = [ action|path1 ] ,          cost = cost1+actioncost . ....    the call path(s , path , cost ) binds path to an optimal path from s to a final state .",
    "the predicate final(s ) succeeds if s is a final state , and the predicate action encodes the set of actions in the problem .    a dag.,width=134 ]",
    "consider using the ` path/3 ` predicate to find a shortest path from node ` a ` to node ` d ` in the dag shown in figure [ fig : shortest ] .",
    "the final state is ` d ` .",
    "the call ` path(a , path , cost ) ` initiates the search from node ` a ` . in order to resolve the call",
    ", picat applies the transition ` a\\rightarrowb ` to node ` a ` , and generates a new call to ` path ` for finding a shortest path from ` b ` to ` d ` . after the answer ` b\\rightarrowc\\rightarrowd ` is found for the call , picat tables the answer ` a\\rightarrowb\\rightarrowc\\rightarrowd ` , which has cost 8 , for the inital call .",
    "after that , picat backtracks , trying the alternative transition ` a\\rightarrowc ` to node ` a ` .",
    "after the shortest path ` c\\rightarrowd ` is found , picat finds another path ` a\\rightarrowc\\rightarrowd ` , which has cost 5 , for the initial call .",
    "since this path is shorter than the tabled path , picat replaces the tabled path with this new path .",
    "since the graph has no cycles , picat returns the new path as the final answer . in general , calls need to be re - evaluated until fixed points are reached if there are looping calls @xcite .    when applied to the single - source shortest path problem ,",
    "linear tabling is similar to dijkstra s algorithm , except that linear tabling tables shortest paths from the encountered states to the goal state rather than shortest paths to the encountered states from the initial state .",
    "the above framework performs depth - unbounded search . for many planning problems , branch & bound and ida * @xcite are useful for finding optimal solutions .",
    "the planner module of picat provides built - ins for planning with different types of search .",
    "the ` planner ` module is based on tabling but it abstracts away tabling from users . for a planning problem , users only need to define the predicates ` final/1 ` and ` action/4 ` , and call one of the search predicates in the module on an initial state in order to find a plan or an optimal plan .    * ` final(s ) ` : this predicate succeeds if @xmath18 is a final state . * ` action(s , nexts , action , acost ) ` : this predicate encodes the state transition diagram of a planning problem .",
    "the state @xmath18 can be transformed to @xmath19 by performing @xmath20 .",
    "the cost of @xmath20 is @xmath21 , which must be non - negative . if the plan s length is the only interest , then @xmath21 = 1 .",
    "these two predicates are called by the planner .",
    "the action predicate specifies the precondition , effect , and cost of each of the actions .",
    "this predicate is normally defined with nondeterministic pattern - matching rules . as in prolog",
    ", the planner tries actions in the order they are specified .",
    "when a non - backtrackable rule is applied to a call , the remaining rules will be discarded for the call .",
    "the following predicates constitute the core of the ` planner ` module .    * ` best_plan_unbounded(s , limit , plan , plancost ) ` : this predicate finds an optimal plan by performing _ depth - unbounded _ search . this predicate is implemented based on the path - finding framework shown above .",
    "the argument @xmath22 is not utilized to limit the depth of search .",
    "it is compared with @xmath23 after an optimal plan has been found . during depth - unbounded search ,",
    "once a state has failed , it will not be explored again . * ` plan(s , limit , plan , plancost ) ` : this predicate searches for a plan by performing _",
    "resource - bounded _",
    "search , in which a state is expanded only if it is new and its resource limit is non - negative , or if the state has previously failed but the current occurrence has a higher resource limit than before .",
    "this predicate is defined as a tabled predicate that tables the @xmath22 argument but does not use it in variant checking @xcite .",
    "the implementation of this predicate is described in the next subsection . *",
    "` best_plan(s , limit , plan , plancost ) ` : this predicate finds an optimal plan by performing resource - bounded _ iterative - deepening _ search .",
    "it calls the plan/4 predicate to find a plan , using 0 as the initial cost limit and gradually relaxing the cost limit until a plan is found .",
    "unlike ida * , which starts a new round from scratch , picat also reuses the states that were tabled in the previous rounds . * ` best_plan_bb(s , limit , plan , cost ) ` this predicate finds an optimal plan using branch & bound .",
    "first , it calls ` plan/4 ` to find a plan .",
    "then , it tries to find a better plan by imposing a stricter limit .",
    "this step is repeated until no better plan can be found .",
    "it returns the last plan that was found .",
    "* current_resource ( ) : this function returns the resource limit argument of the latest call to plan/4 . in order to retrieve the argument , the implementation has to traverse the call - stack until it reaches a call to plan/4 .",
    "this function can be used to check against a heuristic value .",
    "if the heuristic estimate of the cost to travel from the current state to a final state is greater than the resource limit , then the current state should fail .    ....",
    "plan(s , limit , plan , plancost ) = >          iplan = { limit,[],0 } ,          catch(plan_bounded_aux(s , iplan ) , ( plan , plancost ) , true ) .        table ( + , nt )      plan_bounded_aux(s,{limit , iplan , iplancost } ) ,          final(s )      = >          throw((iplan.reverse ( ) , iplancost ) ) .",
    "plan_bounded_aux(s,{limit , iplan , iplancost } ) = >          action(s , nexts , action , acost ) ,          limit1 = limit - acost ,          limit1 > = 0 ,          inherited1 = { limit1 ,                        [ action|iplan ] ,                        iplancost+acost } ,          plan_bounded_aux(nexts , inherited1 ) .",
    "figure [ fig : planbounded ] sketches picat s implementation of the predicate ` plan/4 ` .",
    "the following array is passed from a state to the next state as an ` nt ` argument :    ....      { limit , iplan , iplancost } ....    in order to perform resource - bounded search , picat treats the second argument of the predicate ` plan_bounded_aux ` differently from other ` nt ` arguments .",
    "picat stores the ` limit ` argument of each failed call to ` plan_bounded_aux ` , and uses this information to decide whether the same state should fail when it recurs .",
    "the first rule of ` plan_bounded_aux ` throws the inherited plan and its cost as an exception if ` final(s ) ` succeeds .",
    "the exception will be caught by the ` catch ` call in the rule body of ` plan/4 ` .",
    "the second rule of ` plan_bounded_aux ` calls ` action/4 ` to select an action , which produces a new state , ` nexts ` .",
    "then , the rule computes the new resource limit , ` limit1 ` , by subtracting the cost of the selected action from ` limit ` .",
    "if ` limit1 > = 0 ` succeeds , then the rule continues with the tabled search by recursively calling ` plan_bounded_aux ` on the new state ` nexts ` .",
    "otherwise , if ` limit1 > = 0 ` fails , then picat backtracks to select an alternative action .     resource - bounded search . ]",
    "the idea of resource - bounded search is to utilize tabled states and their resource limits to effectively decide when a state should be expanded and when a state should fail .",
    "let @xmath24 denote a state with an associated resource limit , @xmath25 , as depicted in figure [ fig : resource_bounded ] .",
    "if @xmath25 is negative , then @xmath24 immediately fails . if @xmath25 is non - negative and @xmath18 has never been encountered before , then @xmath18 is expanded by using a selected action",
    "otherwise , if the same state @xmath18 has failed before and @xmath26 was the resource limit when it failed , then @xmath24 is only expanded if @xmath27 , i.e. , if the current resource limit is larger than the resource limit was at the time of failure .",
    "this section describes the picat models for four of the problem domains used in the sequential optimal track of ipc14 : _ transport _ , _ tetris _ , _ floortile _ , and _",
    "parking_. each of the following models will show the state representation , the encoding of the actions , the search predicate that is used ( best_plan or best_plan_unbounded ) , and the domain knowledge and heuristics that are employed . in these models ,",
    "states are typically represented by lists , and preconditions and state updates are handled by standard list operations .",
    "sometimes , arrays are used when no list suffixes can be shared .",
    "the picat encodings of actions are mostly straightforward translations from the pddl encodings .",
    "these models do not use sophisticated domain knowledge or heuristics that would hurt the readability or compromise the optimality of answers .",
    "these four domains , as well as five other domains , are described in appendix a.      this problem is a variant of the popular logistics domain in planning .",
    "given a weighted directed graph , a set of trucks each of which has a capacity for the number of packages it can carry , and a set of packages each of which has an initial location and a destination , the objective of the problem is to find an optimal plan to transport the packages from their initial locations to their destinations .",
    "this problem is more challenging than the _ nomystery _ problem that was used in ipc11 , because of the existence of multiple trucks , and because an optimal plan normally requires trucks to cooperate .",
    "this problem degenerates into the shortest path problem if there is only one truck and only one package .",
    "the pddl and picat encodings of the problem are given in appendix b.      a state is represented by an array of the form \\{trucks , packages } , where trucks is an ordered list of trucks , and packages is an ordered list of waiting packages .",
    "a package in packages is a pair of the form ( loc , dest ) where loc is the source location and dest is the destination of the package .",
    "a truck in trucks is a list of the form , where loc is the current location of the truck , dests is an ordered list of destinations of the loaded packages on the truck , and cap is the capacity of the truck . at any time , the number of loaded packages must not exceed the capacity .    note that keeping cap as the last element of the list facilitates sharing , since the suffix , which is common to all the trucks that have the same capacity , is tabled only once . also note that the names of the trucks and the names of packages are not included in the representation .",
    "two packages in the waiting list that have the same source and the same destination are indistinguishable , and as are two packages loaded on the same truck that have the same destination .",
    "this representation breaks symmetries .",
    "two configurations that only differ by a truck s name or a package s name are treated as the same state .",
    "a state is final if all of the packages have been transported .    ....",
    "final({trucks , [ ] } ) = >             foreach([_loc , dests| _ ] in trucks )              dests = = [ ]          end .",
    "....    the pddl rules for the actions are straightforwardly translated into picat as follows .    ....",
    "action({trucks , packages},nextstate , action , acost ) ?",
    "= >          action = $ load(loc ) , acost = 1 ,          select([loc , dests , cap],trucks , trucksr ) ,          length(dests ) < cap ,          select((loc , dest),packages , packagesr ) ,             newdests = insert_ordered(dests , dest ) ,          newtrucks = insert_ordered(trucksr,[loc , newdests , cap ] ) ,          nextstate = { newtrucks , packagesr } ,      action({trucks , packages},nextstate , action , acost ) ?",
    "= >          action = $ unload(loc ) , acost = 1 ,              select([loc , dests , cap],trucks , trucksr ) ,          select(dest , dests , destsr ) ,          newtrucks = insert_ordered(trucksr,[loc , destsr , cap ] ) ,          newpackages = insert_ordered(packages,(loc , dest ) ) ,          nextstate = { newtrucks , newpackages}.      action({trucks , packages},nextstate , action , acost ) = >          action = $ move(loc , nextloc ) ,          select([loc|tail],trucks , trucksr ) ,          road(loc , nextloc , acost ) ,              newtrucks = insert_ordered(trucksr,[nextloc|tail ] ) ,          nextstate = { newtrucks , packages}. ....    for the _ load _ action , the rule nondeterministically selects a truck that still has room for another package , and nondeterministically selects a package that has the same location as the truck . after loading the package to the truck",
    ", the rule inserts the package s destination into the list of loaded packages of the truck .",
    "note that the rule is nondeterministic .",
    "even if a truck passes by a location that has a waiting package , the truck may not pick it . if this rule is made deterministic , then the optimality of plans is no longer guaranteed , unless there is only one truck and the truck s capacity is infinite .",
    "domain knowledge can be used to reduce the nondeterminism and avoid unnecessary applications of actions . in the complete picat encoding given in appendix b ,",
    "the predicate ` action ` begins with a rule that deterministically unloads a package if the package s destination is the same as the truck s location .",
    "resource - bounded search is used to find an optimal plan .",
    "after each new state is generated , the following condition is checked to ensure that the current path is viable .    ....",
    "current_resource ( ) - acost > =   estimated_cost(newstate ) .",
    "....    let @xmath28 , @xmath29 , @xmath30 be the remaining packages , and @xmath31 be the minimum cost of moving package @xmath32 to its destination by using any truck .",
    "the moving cost of a state can be safely estimated as max(@xmath33 ) .",
    "the estimated total cost is the estimated moving cost plus the loading and unloading costs of all of the remaining packages .",
    "this heuristic is admissible .",
    "the problem is a simplified version of the well - known tetris .",
    "there are three kinds of pieces : 1-cell _ boxes _ , 2-cell _ rectangles _ , and 3-cell _ l - shaped _ pieces .",
    "initially , all the pieces are distributed on a grid board .",
    "the pieces can freely move on the board to any cells as long as the cells are not occupied by other pieces .",
    "there is a region on the board that is designated as the target region .",
    "the goal of the game is to move all the pieces to the target region . in the ipc",
    "setting , rectangles can rotate but l - shaped pieces can not .",
    "pieces can be represented as follows : a square is represented by the cell it occupies ; a rectangle by a term of the form rect(c1,c2 ) where c1 and c2 are cell locations ; and an l - shaped piece by a term of the form ell(c1,c2,c3 ) . in the ipc",
    "setting , the ordering of the cells that are occupied by a piece is important .",
    "so rect(c1,c2 ) and rect(c2,c1 ) represent two different rectangle pieces .",
    "a state is represented by an array of the form ` { squares , rects , ls } ` , where each argument gives a sorted list of a single kind of pieces .",
    "the pddl rules for actions can be translated into picat in a straightforward manner .",
    "for example , the following rule selects a rectangle piece to move .    ....",
    "action(state@{squares , rects , ls},newstate , action , acost ) ?",
    "= >          action = $ move(rect , newrect ) , acost = 1 ,          select(rect , rects , rectsr ) ,            rect = $ rect(c1,c2 ) ,           connected(c2,c3 ) ,          not_occupied(c3,state ) ,           % %   c3 is free          newrect = $ rect(c2,c3 ) ,           newstate = { squares , insert_ordered(rects , newrect),ls}. ....    the predicate not_occupied(c3,state ) is true if c3 is not occupied by any of the pieces in state .",
    "resource - bounded search is used to find an optimal plan for this problem .",
    "the goal of the problem is to move all the pieces to the target region . for each piece",
    ", assume that it s the only piece on the board , disregarding all other pieces .",
    "the estimated cost of moving the piece to the target region is its shortest distance to the nearest cell in the target region times the cost of each move .",
    "the estimated cost of transforming a state into a final state is the sum of the estimated costs of all the pieces .",
    "this heuristic function is admissible and easy to compute , but very conservative because a cell in the target region can serve as a target for multiple pieces .",
    "a set of robots use two different colors ( black and white ) to paint patterns in floor tiles . the robots can move around the floor tiles in four directions ( up , down , left and right ) .",
    "robots paint with one color at a time , but can change their spray guns to the other color .",
    "however , robots can only paint the tile that is in front ( up ) and behind ( down ) them , and once a tile has been painted no robot can stand on it .",
    "a state is represented by a list of the form ` [ robots , wtiles , btiles ] ` , where robots is an ordered list of robots and wtitles ( btiles ) is an ordered list of locations of the painted white ( black ) tiles .",
    "a robot in robots is a pair ( color , loc ) where color is the color of the paint that the robot is holding and loc is the robot s location .    a state is final if all the tiles that are required to be painted are all painted .    ....",
    "final({_,wtiles , btiles } ) = >           painted_w_tiles_in_goal(wtiles ) ,          painted_b_tiles_in_goal(btiles ) .",
    "....    the actions are encoded according to the state representation .",
    "for example , once a tile is painted , the tile s location is added into wtiles or btiles depending on the color of the paint ; once a robot ( color , loc ) moves from loc to loc1 , the pair is changed to ( color , loc1 ) .",
    "the current graph is determined by the initial graph , the set of painted tiles , and the set of robots .",
    "a robot can move from its current location loc to a new location nextloc if nextloc is connected to loc in the graph , nextloc is not painted , and nextloc is not occupied by another robot .      the color - changing action , if needed , can be forced to take place right before a painting action .",
    "this macro action helps reduce the search space .    for ipc14 ,",
    "the used instances were generated in the fashion that _",
    "robots should only paint tiles in front of them_. this special condition can be exploited to reduce the nondeterminism of the painting rules : if a robot is at location loc , trying to paint the up location uloc , and the up location of uloc has already been painted , then uloc can be painted deterministically ; similarly , if a robot is at location loc , trying to paint the down location dloc , and the down location of dloc has already been painted , then dloc can be painted deterministically .    depth - unbounded search is used for this problem . during depth - unbounded search ,",
    "dead ends are tabled and are not re - explored when they are encountered again . for this problem , a state becomes a dead end if there is an unpainted tile that is not reachable by any robot .",
    "no extra code is needed to detect dead ends . because depth - unbounded search is used , no heuristics are needed .",
    "this domain involves parking cars on a street with n curb locations , and where cars can be double - parked but not triple - parked .",
    "the goal is to find a plan to move from one configuration of parked cars to another configuration , by driving cars from one curb location to another . for each curb location",
    ", there are two parking spots : the curb side and the road side . for a car to move from a spot at a curb into a spot at a different curb ,",
    "the destination spot must be clear ; and if the spot is on the curb side , then the road - side spot must also be clear . in some ways",
    ", this problem is similar to the _ blocks world _ and the _ tower of hanoi_.      a configuration is represented by an array of curbs @xmath34 , where each @xmath35 is a list of up to two cars . when a curb has two cars , it is assumed that @xmath36 is the road - side car and @xmath37 is the curb - side car .",
    "this representation allows the road - side car @xmath36 to be removed without touching the curb - side car @xmath37 .",
    "a state is represented by a pair of the form ( currconfig , goalconfig ) , where a currconfig is the current configuration , and goalconfig is the goal configuration . as shown below",
    ", the inclusion of the goal configuration in the state representation facilitates the encoding of domain knowledge .",
    "a state is final if the current configuration is the same as the goal configuration .    ....",
    "final((config , config ) ) = > true .",
    "....    all possible moves are specified with one rule as follows :    ....      action((config , gconfig),nexts , action , acost ) = >           action = $ move(i , j ) , acost = 1 ,          nth(i , config , icars),icars = [ clearcar|newicars ] ,          nth(j , config , jcars ) , j !",
    "= = i , jcars !",
    "= [ _ , _ ] ,          n = length(config ) ,          newconfig = new_array(n ) ,          foreach ( k in 1 .. n )              ( k = = i - > newconfig[k ] = newicars              ; k = = j - > newconfig[k ] = [ clearcar|jcars ]              ; newconfig[k ] = config[k ] )          end ,          nexts = ( nextconfig , gconfig ) .",
    "....    the built - in predicate nth(i , array , arg ) is true if the i - th argument of array is arg . when i is a variable , this predicate nondeterministically searches for an argument that unifies with arg .",
    "the rule finds a non - empty curb i and a different curb j that has less than two cars , and moves the clear car , clearcar , from curb i to curb j.      two knowledge rules can be incorporated into the basic encoding in order to speed up the search .",
    "first , when a car is moved into a spot that is its final spot in the goal configuration , such a move should be made deterministically .",
    "note that if a car is moved to a road - side final spot then the curb - side spot must be occupied by a correct car .",
    "second , a car that has been placed in its final spot should not be moved away .",
    "this kind of domain knowledge has been used in solving the tower of hanoi @xcite and the blocks world @xcite .",
    "resource - bounded search is used to find an optimal plan .",
    "the cost of transforming a state to a final state can be simply estimated as the number of incorrectly - positioned cars . this estimation is admissible , since at least one action is needed to move each incorrectly - positioned car",
    ". the following improved heuristic function , which takes special curb configurations into account , is used by the model : for each curb , if the curb has two cars in the current state , but is required to have in the final state , then its cost is 4 ; if the curb has two cars , but is required to have or ( a @xmath38 c , b @xmath38 c ) , then its cost is 3 ; otherwise , the cost is the number of incorrectly - positioned cars .",
    "in addition to the four domains presented in this paper , we have encoded in picat several other domains used in the deterministic sequential track of ipc14 .",
    "the domains and their picat encodings are given in appendix a. the picat encodings are simple , compact , and comparable in size with the pddl encodings used in ipc14 . most of the encodings can be further improved by incorporating sophisticated domain knowledge and heuristics . in order to evaluate the effectiveness of the use of tabling and the use of heuristics , we have built two separate sets of encodings , namely , picat - nt and picat - nh , which use the same state representation as the original picat encodings but have some component removed .",
    "picat - nt performs prolog - style non - tabled iterative - deepening search . since picat - nt does not table any state , it may explore the same state multiple times during search . the picat - nh encodings do not use any heuristics . we have compared these picat encodings with the ipc14 pddl encodings solved with symba @xcite , a domain - independent bidirectional a * planner which won the optimal sequential track of ipc14 . this comparison offers a glimpse of how well picat compares with the best domain - independent planner . a comparison of picat s planner and several domain - dependent planners also shows the promise of tabled planning @xcite .     & 14 & * 14 * & 0 & * 14 * & 6 + & 20 & * 20 * & 0 & * 20 * & 3 + & 20 & * 20 * & * 20 * & * 20 * & 3 + & 20 & * 20 * & 17 & 18 & 17 + & 20 & * 20 * & 0 & * 20 * & * 20 * + & 20 & * 20 * & 19 & 13 & 19 + & 20 & * 11 * & 4 & 0 & 1 + & 17 & * 13 * & * 13 * & 9 & 10 + & 20 & * 9 * & 0 & 4 & 8 +    table [ tab : res ] shows the number of instances ( # insts ) in the domains used in ipc14 and the number of ( optimally ) solved instances by each planner .",
    "the results were obtained on a cygwin notebook computer with 2.4ghz intel i5 and 4 gb ram . both picat and symba",
    "were compiled using g++ version 4.8.3 . for symba , a setting suggested by one of symba s developers was used .",
    "a time limit of 30 minutes was used for each instance as in ipc . for every instance that was solved by both symba and picat ,",
    "the plan quality is the same .",
    "a comparison of picat and picat - nt shows the effectiveness of the use of tabling .",
    "for every domain , except for _ childsnack _ and _ tetris _ , picat solved more instances than picat - nt .",
    "for _ barman _ , _ cave _ , _ floortile _ and _ transport _ , picat - nt could not solve any of the instances .",
    "the picat encodings for five of the domains ( _ citycar _ , _ ged _ , _ parking _ , _ tetris _ , and _ transport _ ) use heuristics .",
    "the use of heuristics is helpful for these domains , especially for _ parking _ , for which picat - nh did not solve any of the instances .",
    "picat solved more instances than symba for every domain except for _ floortile _ , for which both systems solved all of the instances .",
    "the running times of the instances are not given , but the total runs for picat were finished within 24 hours , while the total runs for symba took more than 72 hours .",
    "this paper has presented picat s planner , its implementation , and example models for several domains from ipc14 .",
    "the example models illustrate several modeling techniques in picat . one key task of modeling is finding an efficient state representation .",
    "while classical planning frameworks such as pddl are based on a factored representation of states , picat uses a structured representation",
    ". a structured state representation can leave out unnecessary information that is not needed for planning and can break symmetries by avoiding enumerating all possible permutations of objects .",
    "another key task of modeling is utilizing domain knowledge to reduce search spaces . in the past",
    ", a lot of work has been done on the use of domain knowledge in planning @xcite , but recently , this part of modeling has been put aside , because of the advancement of domain - independent pddl planners .",
    "this paper has shown that , even with simple domain knowledge , the declarative encodings of picat significantly outperform symba , a state - of - the - art domain - independent planner",
    ".    this paper has demonstrated for the first time that tabled logic programming is competitive with the cutting - edge pddl planners .",
    "the key to the success is tabling . tabling avoids repeating the exploration of the same state and facilitates performing resource - bounded search .",
    "the picat planner does not do prior grounding that is typical for most current state - space search planners , and hence picat has no problem with exploded memory consumption due to grounding .",
    "nevertheless , memory consumption can be demanding during search since every encountered state is tabled .",
    "this is why careful modeling that removes symmetries and uses domain control knowledge to prune useless state transitions is important .",
    "a good state representation should also exploit the underlying term - sharing technique that is used in the tabling system . in the examples that are presented in this paper ,",
    "ordered lists are used to represent collections of objects .",
    "it takes linear time to perform the basic operations .",
    "one direction for future work is to design data structures for state representations which are compact , efficient , and good for sharing .",
    "a plethora of action languages have been designed for modeling and solving planning problems ( e.g. , and its successors @xcite , golog @xcite , and @xcite ) .",
    "the focus of these languages has been on the modeling power rather than efficiency and scalability .",
    "these languages have been implemented by translation into sat , asp , cp , or pddl @xcite , but no implementation has been shown to be competitive with the cutting - edge pddl planners .",
    "picat can be used as an implementation language for these action languages . like in pddl",
    ", a state is represented as a set of flat facts in all of these action languages .",
    "another direction for future work is to devise an efficient translation from these action languages into picat that automatically exploits structural representation , symmetries , domain control knowledge , and heuristics .    ,",
    "kuter , u. , and nau , d.  s. 2009 .",
    "translating htns to pddl : a small amount of domain knowledge can go a long way . in _",
    "ijcai_. 16291634 .",
    "using temporal logics to express search control knowledge for planning .",
    "_ 116 , _  1 - 2 , 123191 .    , fritz , c. , and mcilraith , s.  a. 2011",
    "golog - style search control for planning . in _ knowing , reasoning , and acting : essays in honour of hector j. levesque _",
    ", g.  lakemeyer and s.  a. mcilraith , eds . college publications .    ,",
    "dovier , a. , and zhou , n .- f .",
    "2015 . on modeling planning problems in logic programming .",
    "in _ ppdp_. to appear .    \\2014 . using tabled logic programming to solve the petrobras planning problem .  _ 14 ,",
    "4 - 5 , 697710 .    ,",
    "eiter , t. , and truszczyski , m. 2011 .",
    "answer set programming at a glance .",
    "_ 54 , _  12 , 92103 .    ,",
    "vallati , m. , and mccluskey , l. 2014 . international planning competition .",
    ", ramakrishnan , c.  r. , and warren , d.  s. 1996 .",
    "practical program analysis using general purpose logic programming systems  a case study .  _ 31 ,",
    "_  5 , 117126 .    ,",
    "formisano , a. , and pontelli , e. 2011 .",
    "perspectives on logic - based approaches for reasoning about actions and change . in _",
    "lncs_. vol .",
    "6565 . 259279 .    ,",
    "faber , w. , leone , n. , pfeifer , g. , and polleres , a. 2004 . a logic programming approach to knowledge - state planning : semantics and complexity .",
    "_ 5 , _  2 , 206263 .",
    ", kaminski , r. , kaufmann , b. , and schaub , t. 2012 . .",
    "morgan and claypool publishers .",
    "action languages .",
    "_ 2 _ , 193210 .",
    "\\2008 . simplifying dynamic programming via mode - directed tabling .",
    "_ 38 , _  1 , 7594 .",
    "domain knowledge in planning : representation and use . in _",
    "icaps workshop on pddl .",
    "_    \\1969 .",
    "planner : a language for proving theorems in robots . in _",
    "ijcai_. 295302 .",
    "the role of domain - specific knowledge in the planning as satisfiability framework . in _",
    "aips98_. 181189 .",
    "depth - first iterative - deepening : an optimal admissible tree search .",
    "_ 27 , _  1 , 97109 .",
    "north holland , elsevier .    ,",
    "reiter , r. , lesprance , y. , lin , f. , and scherl , r.  b. 1997 .",
    "logic programming language for dynamic domains .  _ 31 ,",
    "_  1 - 3 , 5983 .",
    "answer set programming and plan generation .",
    "_ 138 , _  1 - 2 , 3954 .",
    "\\1998 . the planning domain definition language manual .",
    "cvc report 98 - 003 , yale computer science report 1165 .",
    "`` memo '' functions and machine learning .",
    ", 1922 .    ,",
    "nielson , h.  r. , sun , h. , buchholtz , m. , hansen , r.  r. , pilegaard , h. , and seidl , h. 2004 . the succinct solver suite . in _ proc .",
    "tools and algorithms for the construction and analysis of systems : 10th international conference ( tacas ) , lncs 2988_. 251265 .",
    "december 2003 . tabled higher - order logic programming .",
    "thesis , technical report cmu - cs-03 - 185 .    ,",
    "ramakrishnan , c.  r. , ramakrishnan , i.  v. , smolka , s.  a. , swift , t. , and warren , d.  s. 1997 .",
    "efficient model checking using tabled resolution . in _",
    "computer aided verification_. 143154 .",
    "iclp_. 8498 .    ,",
    "alcazar , v. , and borrajo , d. 2014 .",
    "symba : a symbolic bidirectional a planner . in _ the 2014 international planning competition_. 105109 .",
    "\\1974 . : a system for generating plans .",
    "tech . rep .",
    "dcl memo 76 , university of edinburgh .",
    "memoing for logic programs .   _ 35 _ , 93111 .",
    "combinatorial search with picat . .",
    "\\2013 . a tabled prolog program for solving sokoban .",
    "_ 124 , _  4 , 561575 .",
    "efficient tabling of structured data with enhanced hash - consing .",
    "_ 12 , _  4 - 5 , 547563 .    ,",
    "kameya , y. , and sato , t. 2010 .",
    "mode - directed tabling for dynamic programming , machine learning , and constraint solving . in _",
    "ictai_. 213218 .    ,",
    "sato , t. , and shen , y .- d .",
    "linear tabling strategies and optimizations .",
    "_ 8 , _  1 , 81109 .",
    "in this section we summarize , for reader s convenience , the descriptions of all the domains used as benchmarks .",
    "descriptions are drawn from https://helios.hud.ac.uk/scommv/ipc-14/domains_sequential.html ; picat s complete encodings for these benchmarks are available at http://picat - lang.org / ipc14/.      there is a robot _ barman _ that manipulates drink dispensers , glasses , and a shaker .",
    "the goal is to find a plan of robot s actions that serves a desired set of drinks .",
    "robot hands can grasp at most one object at a time .",
    "glasses need to be empty and clean to be filled .",
    "the benchmark was proposed by sergio jimnez celorrio .          ....",
    "main = >      facts =         $ [ road(c3,c1,40),road(c1,c3,40),road(c3,c2,18 ) ,          road(c2,c3,18),road(c4,c1,36),road(c1,c4,36 ) ,          road(c4,c3,37),road(c3,c4,37),road(c5,c2,24 ) ,          road(c2,c5,24),road(c5,c3,26),road(c3,c5,26 ) ] ,      cl_facts(facts,[$road(+,-,- ) ] ) ,      trucks = [ [ c2,[],3],[c1,[],2 ] ] ,      packages = [ ( c1,c2),(c1,c2),(c3,c1),(c2,c5 ) ] ,      best_plan({sort(trucks),sort(packages)},plan , plancost ) ,      foreach ( { i , action } in zip(1 .. len(plan),plan ) )          printf(\"%3d .",
    "% w\\n\",i , action )      end ,      println(plan_cost = plancost ) . ....      ....    1 .",
    "load(c1 )    2 .",
    "load(c1 )    3 .",
    "load(c2 )    4 . move(c1,c3 )    5 .",
    "move(c2,c5 )    6 .",
    "unload(c5 )    7 .",
    "move(c3,c2 )    8 .",
    "unload(c2 )    9 .",
    "unload(c2 )   10 .",
    "move(c2,c3 )   11 .",
    "load(c3 )   12 .",
    "move(c3,c1 )   13 ."
  ],
  "abstract_text": [
    "<S> this paper describes picat s planner , its implementation , and planning models for several domains used in international planning competition ( ipc ) 2014 . </S>",
    "<S> picat s planner is implemented by use of tabling . during search , </S>",
    "<S> every state encountered is tabled , and tabled states are used to effectively perform resource - bounded search . in picat </S>",
    "<S> , structured data can be used to avoid enumerating all possible permutations of objects , and term sharing is used to avoid duplication of common state data . </S>",
    "<S> this paper presents several modeling techniques through the example models , ranging from designing state representations to facilitate data sharing and symmetry breaking , encoding actions with operations for efficient precondition checking and state updating , to incorporating domain knowledge and heuristics . </S>",
    "<S> broadly , this paper demonstrates the effectiveness of tabled logic programming for planning , and argues the importance of modeling despite recent significant progress in domain - independent pddl planners .    </S>",
    "<S> [ firstpage ] </S>"
  ]
}