{
  "article_text": [
    "since its formulation a decade ago  @xcite , the problem of energy - efficient packet transmission scheduling has drawn considerable interest from the research community  @xcite .",
    "the basic offline problem is to assign transmission durations ( equivalently , code rates ) to a set of packets whose arrival times are known beforehand , so that they are all transmitted within a given time window with minimum total energy .",
    "recently , the problem has been recast with a formulation where the goal is to minimize the _ time _ by which all packets are transmitted , given that energy is harvested at certain known instants  @xcite .    in this paper , we extend the formulation in  @xcite to a multiuser scenario with one sender and multiple receivers . in particular , we assume an awgn broadcast channel where the sender gets replenished with arbitrary amounts of energy at arbitrary points in time . the harvested energy becomes instantly available for use , and the transmission power can be changed at any time by the sender .",
    "the choices of power level and the rates to individual receivers across time is called a _",
    "schedule_. the sender needs to transmit a certain number of bits to each receiver .",
    "we consider the case that these bits are available at the beginning of transmission .",
    "the goal is to find a schedule that achieves the unique minimum time @xmath0 , by which the data of all users can been transmitted using the given sequence of harvests . throughout the paper ,",
    "we focus on the _ offline _ problem , where the energy harvesting times as well as packet arrival times are known in advance .",
    "the online version of the problem in which the times of energy harvests are not known a priori and decisions need to be made in real - time as the harvests occur , is interesting yet analytically less tractable and left outside the scope of this paper .",
    "it is well known that both with optimal and practical coding schemes , the energy per bit increases with the transmission rate , in other words , transmitting fast is inefficient in terms of energy  @xcite .",
    "this is the root of the sender s dilemma : it will pay off for the sender to slow down , yet it needs to minimize the overall transmission duration .",
    "interestingly , it turns out that even if all packets were available in the beginning , the optimal schedule starts slowly , deferring some of the harvested energy for future use .",
    "more precisely , we will show that in the optimal schedule the transmission power is non - decreasing in time , similarly to the point - to - point schedule  @xcite .    in the point - to - point problem",
    ", determining power levels determines the schedule , as transmission rate is a function of average power . in the broadcast problem",
    ", however , there is no one - to - one correspondence between the transmission power and the rate point .",
    "for example , with optimal coding , there is a continuum of rates on the boundary of the capacity region corresponding to a certain average power constraint .",
    "hence , the rates and the power have to be determined together .",
    "we observe that in the optimal schedule , the average rates used by the users are proportional to their numbers of bits , i.e. the schedule always continuously transmits to all users at the same time and finishes transmission to all users at the same time . having made this observation , we can exploit the mathematical similarities between this problem and the problem in  @xcite , and show that the solution is found by the algorithm flowright , defined in  @xcite and adapted here to work with different parameters .    in the next section ,",
    "we make observations about the two - user awgn broadcast channel capacity region .",
    "the statement of the problem as a cost minimization problem , as well as its solution will use certain structural properties of the awgn capacity region , such as the monotonicity and convexity of the average power with respect to the rate pair .",
    "of course , this specific rate region can only be approached under optimal coding as blocklengths and the number of information bits go to infinity .",
    "for example , in the single user awgn channel the numerical value of the minimum energy per bit corresponding to a given reliability monotonically decreases with the number of information bits  @xcite .",
    "however , the basic structural properties of the rate region will be satisfied by the achievable rate regions of many suboptimal practical coding schemes as well as finite blocklength optimal coding schemes .",
    "we define the problem in section [ sec : probdef ] . in section",
    "[ sec : solution ] we explore the properties of the optimal solution .",
    "this is followed by the description of the modified flowright algorithm , and the proof of its convergence and optimality of the resulting schedule .",
    "the complexity of the iterative algorithm is analyzed in section [ sec : algorithmcomplexity ] .",
    "the implementation of this algorithm is discussed , followed by a numerical example in section [ sec : example ] .",
    "section  [ conclusion ] summarizes our conclusions and outlines further directions .",
    "consider a discrete - time awgn broadcast channel with one sender and two receivers .",
    "the signal received by the @xmath1 user at time @xmath2 is given by @xmath3=\\sqrt{s_i}x[k]+z_i[k],\\ ] ] where @xmath4 $ ] is the transmitted signal with average power constraint @xmath5 , @xmath6 s are the channel gains and the @xmath7 $ ] s are i.i.d .",
    "zero - mean gaussian noise with variance @xmath8 .",
    "the capacity region of the channel assuming @xmath9 and @xmath10 are constants and @xmath11 , is the set of rate pairs @xmath12 such that  @xcite @xmath13 for some @xmath14 .",
    "hence , the @xmath15 user is the _ stronger _ user .",
    "it is straightforward to show that , given @xmath9 and @xmath10 , for any @xmath16 , the capacity region corresponding to an average power constraint @xmath17 dominates the one corresponding to @xmath18 .",
    "therefore , given a rate pair @xmath12 , there is a unique @xmath19 ( see  @xcite ) such that @xmath12 lies on the boundary of the rate region with power constraint equal to @xmath5 . after replacing the inequalities in and by equalities , the function @xmath20 is written as follows",
    "can be written as as @xmath21 .",
    "hence , @xmath22 . after substituting into and rearranging the terms ,",
    "we obtain @xmath23    the function @xmath20 is twice continuously differentiable and strictly convex in @xmath24 and @xmath25 . throughout the paper",
    ", it will be useful to express the @xmath24 and @xmath25 as a function of each other and the minimum power @xmath5 . by algebraic manipulation of and , we obtain the following : from and , the function @xmath20 is strictly convex and continuously differentiable in @xmath24 and @xmath25 . @xmath26    the properties satisfied by these rate functions for the awgn bc capacity region with @xmath27 summarized in the following will be used in the rest of the paper .",
    "1 .   nonnegativity : @xmath28 .",
    "monotonicity : @xmath29 , @xmath30 are both monotone decreasing in @xmath31 , and monotone increasing in @xmath5 .",
    "concavity : @xmath29 and @xmath30 are concave in @xmath5 and @xmath31 .",
    "4 .   the rate of the user with the weaker channel satisfies the following : @xmath32 , @xmath33    [ prop : h ] the functions @xmath34 and @xmath35 , defined in , on @xmath36 satisfy the properties of the rate region given by ( 1)-(4 ) .    _ proof .",
    "_ see appendix a.",
    "consider the broadcast link as described in the previous section , with a sender who needs to transmit @xmath37 and @xmath38 bits with a certain degree of reliability to users 1 and 2 , respectively .",
    "also assume that at time @xmath39=0 , sender has @xmath40 units of energy available and at times @xmath41 , energies are harvested with amounts @xmath42 , respectively , as depicted in fig  [ fig : system_model ] .",
    "inter - arrival times of energy harvests are named as _ epochs _ , and marked with @xmath43 .     where @xmath44 } ]    it will be assumed that the sender has the ability to change its rate pair at any time , according to the available energy and remaining number of bits .",
    "such ideal adaptation , which has been used in previous literature ( ,  @xcite , and references therein ) , may be approximated by using adaptive coding and modulation in a practical system .",
    "starting at @xmath45 , let @xmath46 , be the successive pairs of rates used by the sender , and @xmath47 be the respective durations for which these pairs are used . here , @xmath48 is user @xmath49 s rate in the @xmath50 rate pair . by definition ,",
    "at least one user s rate changes from one rate pair to the next one",
    ". we will refer to the sequence of rate pairs and durations as a _ schedule_. the problem of interest is to find an optimal _ offline _ schedule , that is , a schedule that minimizes the overall transmission completion time of the @xmath51 and @xmath52 bits to their respective destinations , with complete knowledge of future energy harvesting instants and the amounts to be harvested",
    ".    it will also be assumed that the problem is feasible ; that is , sufficient energy will be harvested to transmit the given @xmath37 and @xmath38 bits in arbitrarily large but finite total time , @xmath53 .",
    "note that for any given @xmath54 , there is a small enough rate ( equivalently , long enough transmission duration ) such that @xmath51 and @xmath52 bits can be transmitted with energy @xmath54 , provided that the minimum energy per bit required for communication on the broadcast channel for the given finite amount of bits is satisfied  @xcite . in the point - to - point case with infinite blocklengths ,",
    "the well known limit for energy per bit is @xmath55 db . for sending finite amounts of data , the minimum energy per bit",
    "is higher even at nonvanishing values of error probability .",
    "however , the upper and lower bounds in  @xcite on energy per bit come very close to the ideal limit at @xmath56 bits , and even at smaller numbers of bits .    in order to define the two - user broadcast channel offline scheduling problem as an optimization problem",
    ", we will use the set of observations stated in lemmas  [ lmm : closerpowers]-[lmm : tmin_generalepoch ] .",
    "lemma  [ lmm : tmin_generalepoch ] will establish that in an optimal schedule the transmission to both users ends at the same time .",
    "lemma  [ lmm : constantrate ] will establish that in an optimal schedule the rates and power level do not change between energy harvests that are used . as a consequence of these two results , the problem reduces to problem  [ pr : multiuserscheduling ] .",
    "we start by proving a more general result than lemma  [ lmm : constantrate ] which will be used in the proof of lemma  [ lmm : constantrate ] as well as theorem 1 in section  [ sec : probdef ] . specifically , we take a finite time window which is divided into two slots such that different power levels are used in each .",
    "we show that by using a more even distribution of power ( reducing the difference of the power levels ) as much as energy causality permits , at least the same amount of data can be transmitted in the same amount of time using the same amount of energy . in the special case when this time window is within ( or all of ) one epoch , all the energy that is used is available in the beginning",
    "hence the powers can be completely equalized .",
    "[ lmm : closerpowers ] suppose that within a time window @xmath57 , the sender changes its transmit power at point @xmath58 such that @xmath59 . keeping the total consumed energy in @xmath57 constant , the sender can send at least the same number of bits to the users within the same duration by bringing power levels closer to each other , if feasible ( i.e. , unless such a change requires energy to be used before its harvested . )    _ proof .",
    "_ let the total duration be @xmath60 , and the lengths of the two slots @xmath61 and @xmath62 , with power levels in the two slots @xmath17 and @xmath18 , as illustrated in fig.[fig : closerpowers ]",
    ". denote the rate pairs in the @xmath15 and @xmath63 slots as ( @xmath64 , @xmath65 ) and ( @xmath66 , @xmath67 ) , respectively .    .",
    "]    first , consider the case where the power level used in the first slot is smaller : @xmath68 .",
    "when @xmath69 is equal to the total energy available for use in @xmath70 , transferring energy from the second slot to the first is not feasible , and we stop .",
    "however , if it is possible to transfer some positive amount of energy @xmath71 from the second slot to the first , we shall show that we can only improve the allocation .",
    "let us denote the average rates for the _ stronger _ and _ weaker _ users as @xmath72 and @xmath73 , respectively .",
    "we will show that keeping the total consumed energy and @xmath74 constant , the sender can achieve an average rate @xmath75 for the second user such that @xmath76 by changing @xmath17 to @xmath77 and @xmath18 to @xmath78 satisfying @xmath79 while keeping the total energy constant , a certain amount of energy should be transferred from the @xmath63 slot to the @xmath15 one in order to satisfy . in this case",
    ", we have the following @xmath80 average rate belonging to the _ weaker _ user over the whole duration @xmath81 is given by @xmath82 follows from the fact that @xmath83 for all @xmath84 with equality achieved at @xmath85 .",
    "this is a consequence of the properties listed in section  [ sec : bc ] , and proved in section  [ subsec : appendixbeta ] in the appendix .    in the remaining case , @xmath16",
    ", a similar argument holds where @xmath86 . in this case",
    "it is always possible to strictly improve the allocation by transferring a positive amount of energy from the first slot to the second , as energy can always be deferred for future use .",
    "we conclude that keeping the total consumed energy constant , one can find rate pairs such that at least the same number of bits can be transmitted to the users within the same duration by reallocating power levels closer to each other .    ' '' ''    [ corollary : constantpower ] in a schedule that ends at @xmath0 , power does not change _ within _ epochs in @xmath87 $ ] .",
    "the claim is that the power does not change within epochs , of course with the exception of the last epoch .",
    "( in the last epoch that is used , the transmission ends and the power is reduced to zero at some point within the epoch . ) by definition , no new energy or data is added during an epoch , so it is intuitive that the decision on power allocation does not change at a point during an epoch . to reach contradiction ,",
    "suppose that the sender changes its power allocation during an epoch .",
    "from lemma  [ lmm : closerpowers ] , the power levels can be allocated closer to each other so that at least the same number of bits can be transmitted to the users . since this case is not limited by causality , this procedure can be continued until the power levels within the epoch are equalized , strictly improving the schedule , contradicting the optimality of the original schedule .    ' '' ''    [ lmm : constantrate ] in a schedule that ends at @xmath0 , the rate pair does not change _ within _ epochs in @xmath87 $ ] .    _ proof . _ from corollary  [ corollary : constantpower ] , power level stays constant during epochs in an optimal schedule . now , suppose the sender changes its rate pair at some point during an epoch , while the power is constant at @xmath5 .",
    "let the lengths of the two slots as @xmath61 and @xmath62 and the rate pairs in the @xmath15 and @xmath63 slots as ( @xmath64 , @xmath65 ) and ( @xmath66 , @xmath67 ) .",
    "due to the concavity of @xmath30 in @xmath31 , setting @xmath24 to the average rate only improves @xmath25 @xmath88 hence , by equating the rate pair , at least the same number of bits can be transmitted at the same time .    ' '' ''",
    "the next result is an observation of the structure of the basic solution when there is _ only one energy harvest _ ( the one at @xmath45 ) .",
    "[ lmm : tmin_oneepoch ]    suppose @xmath89 in the system model in fig.[fig : system_model ] . to minimize the overall transmission duration",
    ", the sender finishes transmission to both users at the same time .",
    "_ to reach contradiction , suppose that in an optimal solution , the sender finishes transmission to one of the users before the other .",
    "this means that the rate pair changes at some point ( when the transmission of one of the users ends before the other ) , although no new energy has been harvested . by lemma  [ lmm : constantrate ] , averaging the power levels and rates and using one rate pair continuously would enable us to send at least the same number of bits during the same time .",
    "this contradicts the optimality of the original solution .    ' '' ''",
    "lemma  [ lmm : tmin_oneepoch ] tells us that the ratio of the rates @xmath90 is equal to the ratio of the bits @xmath91 .",
    "then , for the awgn case from and the ratio of powers , @xmath92 , can be found by setting : @xmath93 where @xmath94 @xmath95 .",
    "using @xmath96 , one can obtain @xmath97 solving @xmath98 solving @xmath99 for @xmath92 and substituting into and yields a rate pair ( @xmath24 , @xmath25 ) , for a given value of @xmath5 .    before discussing how to find the right value of @xmath5 , it will be illustrative to present an alternative proof for lemma  [ lmm : tmin_oneepoch ] .",
    "suppose the sender has a power level @xmath5 to use .",
    "the question is to obtain the minimum termination time for all the bits , @xmath100 , given by the following : @xmath101    : the rate pair ( @xmath24 , @xmath25 ) that minimizes overall transmission time for the sender to transmit @xmath51 and @xmath52 bits to each user is at point a.(cf .",
    "properties ( 1)-(4 ) , the shaded rate region is convex . ) ]    the contours of constant @xmath102 are shown in figure  [ fig : tmin_constantrate ] .",
    "the value of @xmath103 gets smaller as we move outward from the rate region .",
    "the last contour that still touches the region , touches it at the point labelled a. therefore , @xmath100 is obtained by the rate pair at point a on the boundary of the rate region , which satisfies @xmath96 .",
    "given @xmath54 , @xmath51 , and @xmath52 , determining @xmath100 entails solving a nonlinear equation which can be done iteratively ( see algorithm  [ alg : find_tmin ] ) using the bisection method .",
    "the total energy used to transmit @xmath51 and @xmath52 bits , given by @xmath104 is convex , monotonically decreasing in @xmath53 . combining this with our initial assumption about @xmath54 being large enough to satisfy the minimum energy per bit requirement ( @xmath105 ) ,",
    "there is always a unique smallest value @xmath53 for which @xmath106 is just below @xmath54 . in the bisection method ,",
    "the objective is to find the single root of the equation @xmath107 .",
    "assume that we have an upper bound @xmath108 .",
    "starting with the initial domain interval [ @xmath109 , at each iteration the domain is bisected and the subinterval in which the root @xmath100 lies is selected as follows .",
    "if @xmath110 , then we set @xmath111 , otherwise we set @xmath112 and @xmath53 is selected to be the mid - point of the updated interval for the next iteration .",
    "algorithm converges to the unique solution as the domain is continuous and can be terminated within a certain arbitrarily small tolerance @xmath113 in a practical implementation .",
    "this iterative method has been used in generating the numerical examples given later in the paper where its complexity is also discussed .    * procedure *  ` [ ` @xmath53 ` ] = find_tmin_one_epoch(`@xmath54`,`@xmath51`,`@xmath52`,`@xmath114 ` ) ` @xmath115 , @xmath116 , @xmath117 , @xmath118 @xmath119",
    "@xmath120 + @xmath121 @xmath122 * end procedure *     the following extends the result of lemma  [ lmm : tmin_oneepoch ] to the case with two energy harvests .",
    "[ lmm : tmin_twoepoch ] suppose @xmath123 in the system model in fig .",
    "[ fig : system_model ] . to minimize the overall transmission duration the sender finishes transmission to both users at the same time .",
    ": given two energy harvests , to minimize the overall transmission duration of @xmath51 and @xmath52 bits to each user , the sender finishes the transmission to both users at the same time , i.e. @xmath124 . ]    the proof will make use of lemmas  [ lmm : constantrate ] and  [ lmm : tmin_oneepoch ] . take any rate pair @xmath125 for the @xmath15 epoch resulting in @xmath126 bits being transmitted to the two users .",
    "this leaves @xmath127 bits to be sent in the @xmath63 epoch . by lemma  [ lmm : tmin_oneepoch ] ,",
    "total time to finish these remaining bits , which is @xmath128 will be minimized by setting @xmath124 .",
    "more explicitly , @xmath129    . ]",
    "@xmath130 is obtained by the rate pair satisfying @xmath131 as point a on achievable rate region shown in fig .",
    "[ fig : tmin_twoepoch ] . by lemma  [ lmm : constantrate ] , for the resulting two - epoch schedule to be optimal , a constant power and rate pair must have been used in the @xmath15 epoch , and we have just proved that @xmath124 for any constant choice in the @xmath15 epoch .    ' '' ''    finally , we generalize the first result of lemma  [ lmm : tmin_twoepoch ] , to a general number of energy harvests .",
    "[ lmm : tmin_generalepoch ]    consider the system model with an arbitrary number of energy harvests described in fig .",
    "[ fig : system_model ] . in a schedule that achieves @xmath0",
    ", the transmission to both users ends at the same time .    _ proof .",
    "_ the claim has been proved for @xmath132 energy harvests , in lemma  [ lmm : tmin_twoepoch ] .",
    "we will prove the general case by induction .",
    "suppose that there are @xmath2 energy harvests with the @xmath133 one at time @xmath134 , and the induction hypothesis holds , such that the optimal scheduler finishes transmission to both users at @xmath135 .",
    "now , consider adding a new energy harvest at time @xmath136 .",
    "we have the following possible cases :    1 .",
    "@xmath137 : by the time the @xmath138 energy harvest arrives , the transmission has been completed , so by causality this energy harvest can not help , and @xmath139 .",
    "@xmath140 : in this case , the @xmath138 harvest will be used , to reduce the completion time . starting at time @xmath141 ,",
    "the sequence of rate pairs will change from @xmath142 for @xmath143 to @xmath144 for @xmath143 and @xmath145 for the newly added epoch . as in the proof of lemma  [ lmm : tmin_twoepoch ] ,",
    "whatever the number of bits allocated to the new epoch is , this rate pair will have a slope equal to the ratio of the number of bits remaining for this epoch .",
    "hence , the bits will be terminated at some time @xmath146 .",
    "+    ' '' ''    we are now ready to state the broadcast transmission scheduling problem as an optimization problem . from section  [ sec : bc ] , for a given rate pair , there corresponds a unique power level @xmath5 given by @xmath20 such that this rate pair is on the boundary of the rate region with power constraint @xmath5 .",
    "the function @xmath20 is strictly convex and continuously differentiable in @xmath24 and @xmath25 . using lemmas  [ lmm : constantrate ] and  [ lmm : tmin_generalepoch ]",
    ", the problem can be written in terms of epoch rates .",
    "given @xmath147 , and the sequence @xmath148 , supposing the problem is feasible ( the total amount of energy is sufficient for transmitting the total number of bits ) , one can find an upperbound for the transmission completion time , @xmath149 in several ways .",
    "a simple one ( which is possible when @xmath150 is sufficient for transmitting the total number of bits ) , is to set the power so low such that only the first harvest is used to transmit all the bits . a much better upperbound will be obtained by the procedure that will be described within the initialization step of the flowright algorithm , in section  [ sec : solution ] .    given an upperbound for completion time , @xmath149 , we set @xmath151 equal to the index of the last energy harvest before this time , that is , @xmath152 .",
    "an optimal solution will use at most @xmath151 harvests , and wlog , remaining harvests can be ignored .",
    "hence the problem reduces to finding @xmath153 :    [ pr : multiuserscheduling ] * transmission time minimization of data available at the beginning on an energy harvesting broadcast channel : * @xmath154    the set of constraints in ensure that energy causality is respected . at any time during transmission , the sender should have consumed _ at most _ the energy harvested up to that point , whereas by the end of transmission , it should have consumed _ all _ the harvested energies up to that instant . the constraint in ensures that all the bits of each user have been transmitted by the time @xmath53 .",
    "note that , by assigning nonzero values to all @xmath151 rates , one obtains a continuum of values of @xmath53 that satisfy the constraints ( note the @xmath155 used in the last constraint which sets the result to zero whenever the argument is negative ) , but the infimum of these , @xmath0 , is the solution of the problem .",
    "we shall define @xmath156 , , the index of the last harvest used by a solution that achieves @xmath0 ( it can easily be shown any such solution completely consumes all harvests from @xmath49 to @xmath157 . )    this is not a standard convex optimization problem due to the objective appearing in the final equality constraint . yet , we will establish that this minimization problem can be solved iteratively using an adaptation of the flowright algorithm  @xcite in the rate vector , while we do suspect that @xmath53 is convex in the rate vector . ] . before moving on to the solution",
    ", we present our final observations in the optimal schedule in theorems  [ thm : optpowerallocation]-[thm : optrateallocation ]   have been proven in @xcite through the observation that there is a cut - off level for the total power , below which the weaker user is assigned zero rate . ] using the general result presented in lemma  [ lmm : closerrate ] .",
    "[ thm : optpowerallocation ] _ in an optimal schedule , _    1 .",
    "_ powers assigned to epochs are monotonically nondecreasing , , @xmath158 .",
    "_ energy consumed in any constant power band equals the total energy harvested within that band .",
    ".   _ the power assignment to epochs , @xmath159 $ ] , is unique . _",
    "suppose in an optimal solution we can find @xmath49 s.t .",
    "@xmath160 . from lemma  [ lmm : closerpowers ] , equalizing power over these epochs ( this never violates causality as it corresponds to deferring the use of energy ) , one could find a rate pair with which more bits can be transmitted to each user .",
    "this contradicts the optimality of the original solution .",
    "suppose that @xmath161 for some band of length @xmath162 such that @xmath163 .",
    "but by part-1 , @xmath164 so a positive amount of energy ( up to @xmath165 units ) can be transferred from epoch @xmath166 to @xmath167 to equalize their powers , which by lemma  [ lmm : closerpowers ] , allows rate pairs that send at least the same number of bits to each user . keeping the rates and powers in the rest the same ,",
    "the overall improved schedule is obtained , which contradicts the optimality of the original allocation .",
    "3 .   suppose that there are two different optimal power allocation vectors , @xmath168 and @xmath169 , where @xmath170 for @xmath171 and @xmath172 . from part-1",
    ", power levels are monotonically nondecreasing in the optimal schedule . in this case , if @xmath173 for @xmath174 stays constant , we have @xmath175 , else @xmath176 and we have @xmath177 , both contradicting part-2 .",
    "+    ' '' ''    [ lmm : closerrate ] suppose the sender uses different rates for the _ stronger _ user in the intervals @xmath178 , @xmath179 , such that @xmath59 .",
    "keeping powers levels and the number of bits transmitted to the _ stronger _ user in @xmath57 constant , a larger number of bits can be sent to the _ weaker _ user in @xmath57 by bringing the rates of the _ stronger _ user closer to each other if feasible .",
    "_ consider the notation in figure  [ fig : closerpowers ] and the case @xmath180 .",
    "keeping the avg .",
    "rate of user 1 , @xmath74 , constant , set @xmath64 to @xmath181 , @xmath66 to @xmath182 s.t .",
    "@xmath183 by transferring a certain amount of bits belonging to _ stronger _ user are transferred from the @xmath63 slot to the @xmath15 .",
    "this is feasible unless @xmath64 is already maximal for the given power level ( i.e. @xmath184 ) .",
    "@xmath185 avg .",
    "rate of @xmath63 user over the whole duration is increased from its original level , @xmath186 , to : @xmath187 follows from the fact that @xmath188 for all @xmath189 ( with equality achieved at @xmath85 ) , unless @xmath184 , as proved in app .",
    "[ subsec : appendix_closer_rates ] in the remaining case , @xmath190 , set @xmath191 , which is feasible unless unless @xmath192 , and strictly improves the avg .",
    "rate for user 2 .    ' '' ''    we conclude that keeping @xmath193 constant , one can find rate pairs such that at least the same number of bits can be transmitted to the users within the same duration by reallocating rates of _ stronger _ user .",
    "[ thm : optrateallocation ] _ in an optimal schedule , _    1 .",
    "_ the stronger user s rate is monotone nondecreasing , , @xmath194 ; _ 2 .   _",
    "if @xmath195 for some @xmath196 , then @xmath197 , , if the stronger user s rate changes at the start of the @xmath198 epoch , the weaker user s rate was zero during the @xmath1 epoch ; _ 3 .   _",
    "the weaker user s rate is monotone nondecreasing , , @xmath199 ; _ 4 .   _",
    "the vector of rate pairs , @xmath200 $ ] , is unique . _",
    "suppose the rate of the _ stronger _ user decreases at some point , , @xmath201 for some @xmath49 . from part-1 of theorem",
    "[ thm : optpowerallocation ] and lemma  [ lmm : closerrate ] , at least the same number of bits can be sent to each user ( and more to at least one ) in epochs @xmath202 by assigning the strong user the average rate @xmath193 .",
    "2 .   suppose that in an optimal schedule the weaker user s rate changes at the @xmath198 epoch and @xmath203 .",
    "if the rate of the _ stronger _ user changes , it can only increase , , @xmath204 , by part-1 . from lemma  [ lmm : closerrate ] , the schedule could only be improved by bringing @xmath205 and @xmath206 closer to each other using the energy available for the _ weaker _ user at the @xmath1 epoch , if possible .",
    "hence , the only reason why the rate of the _ stronger _ user can increase at the @xmath198 epoch is that there is no feasible energy available to equalize @xmath205 and @xmath206 , which contradicts @xmath207 .",
    "3 .   suppose that in an optimal schedule @xmath208 .",
    "from part-2 , @xmath209 if @xmath210 . by part-1 of theorem  [ thm : optpowerallocation ] and",
    "@xmath63 property of the rate region , @xmath211 which contradicts initial rate assumption .",
    "4 .   to reach contradiction , suppose that there are two distinct optimal rate - pair vectors , @xmath212 and @xmath213 , where @xmath214 for @xmath171 and @xmath215 .",
    "using part-3 of theorem  [ thm : optpowerallocation ] , we have @xmath216 . from part-2 , @xmath217 .",
    "hence , fewer bits will be transmitted by @xmath212 than @xmath213 , which contradicts the optimality of @xmath212 .",
    "+    ' '' ''    from theorems  [ thm : optpowerallocation ] and [ thm : optrateallocation ] , we conclude that _ the optimal schedule is unique _",
    "( henceforth abbreviated as opt . )",
    "the next section is devoted to the solution of problem [ pr : multiuserscheduling ] .",
    "flowright is an iterative algorithm proposed in the earlier literature  @xciteto solve minimum - energy scheduling problems over multiple - access channels , broadcast channels , and channels with fading when packets of all users need to be transmitted before a deadline t.through a number of steps , it is adapted here to solve problem  [ pr : multiuserscheduling ] .",
    "flowright stars from a feasible initial schedule , and progresses iteratively .",
    "each iteration strictly improves the schedule ( decreases @xmath53 ) , which ultimately converges to the unique optimal @xmath0 .    * initialization : * the energy consumed in each epoch is set precisely equal to the energy harvested at the beginning of that epoch .",
    "this schedule is feasible and @xmath218 .",
    "given @xmath219 , one can assign rate pairs @xmath220 on the achievable rate region boundary such that @xmath221 .",
    "let @xmath222 .",
    "algorithm  [ alg : init ] presents a pseudo - code for this initialization .",
    "@xmath223 i++ select @xmath224 such that : @xmath225 and @xmath226 @xmath227 @xmath228 @xmath229    after initialization , flowright performs _ local optimizations _ on pairs of epochs sequentially , , on epochs @xmath230 , @xmath231 , @xmath232 , ... , until all epoch pairs are processed .",
    "this completes one iteration of the algorithm .",
    "then , it continues with the next iteration , again performing local optimization on pairs of epochs at a time .",
    "the algorithm terminates after @xmath233 iterations such that @xmath234 , where @xmath235 is the transmission completion time at the end of @xmath133 iteration .    *",
    "local optimization : * let @xmath236 be the energy consumed at the @xmath1 epoch and @xmath237 is the number of epochs used at the end of the @xmath133 iteration . then , @xmath238 , @xmath239 .",
    "also , let @xmath240 be the number of bits transmitted to @xmath50 user at @xmath1 epoch at the end of @xmath133 iteration .",
    "now , consider the epoch pair @xmath202 , @xmath241 .",
    "local optimization aims to transmit the total @xmath242 bits in the minimum amount of time by using the total available energy , , @xmath243 while * respecting energy causality * , , using at most @xmath244 amount of energy in the @xmath1 epoch ( see the term @xmath245 in algorithm  [ alg : flowright ] ) . after a local optimization",
    ", we update the rate of the @xmath50 user in the @xmath1 epoch to @xmath246 .",
    "these are the final values of the @xmath1 epoch rates as of the end of the @xmath133 iteration .",
    "we then reset the rate of the @xmath50 user in the @xmath198 epoch to @xmath247 , unless @xmath248 .",
    "the @xmath198 epoch rates as of the @xmath133 iteration are finalized after the local optimization on the epoch pair @xmath249 has been performed .",
    "then , we continue with local optimization on the epoch pair @xmath249 .",
    "we proceed in this way to obtain @xmath250 for @xmath251 .",
    "when the @xmath133 iteration is finished , we start from the beginning and update rates two epochs at a time similar to the above .",
    "it will be shown in theorem  [ thm : flowright_stops ] that transmission completion time strictly decreases after each iteration , and the number of epochs used , @xmath252 , is non - increasing from iteration to iteration .",
    "we terminate after @xmath233 iterations , where @xmath234 . algorithm  [ alg : flowright ] is the main pseudo - code for flowright .",
    "@xmath253 @xmath254 @xmath255 @xmath256=@xmath257 @xmath256=@xmath258 ` calculate_t(&`@xmath259 ` ) `    * details of the local optimization * the local iteration step is described in algorithm  [ alg : localopt ] which mainly checks whether it is possible to transmit @xmath260 and @xmath261 bits , * ( by respecting energy causality ) * in the minimum amount of time via equalizing power and rates in two epochs ( it is optimal from lemmas  [ lmm : closerpowers ] and  [ lmm : closerrate ] ) , or not . if feasible , then min .",
    "transmission time is found by treating the epoch pair @xmath202 as a single epoch with duration @xmath262 .",
    "then , alg .",
    "[ alg : find_tmin ] starting with the initial @xmath263 $ ] domain will find the unique solution of local optimization . if power can not be equalized , then we are at an energy causality boundary . in this case , alg .  [ alg : localopt_causality ] , which can be implemented using the bisection method , is used to find the updated rate pairs @xmath264 .",
    "the local optimization given in alg .",
    "[ alg : localopt_causality ] exploits the structure of a locally optimized epoch pair ( see theorem  [ thm : flowright_properties ] to work efficiently . the proof of this structure is omitted for brevity but follows similar arguments on bisection method of alg .",
    "[ alg : find_tmin ] .",
    "* procedure *  [ @xmath265`,`@xmath266`,`@xmath267`,`@xmath268`,`@xmath269`,`@xmath270 = ` find_local_optimal(`@xmath271`,`@xmath272`,`@xmath273`,`@xmath260`,`@xmath261`,`@xmath274`,`@xmath275 ` ) ` @xmath243 + @xmath100`= find_tmin_one_epoch(`@xmath271`,`@xmath276`,`@xmath277`,`@xmath278 ` ) ` @xmath279 @xmath280    @xmath100`= find_tmin_one_epoch(`@xmath281`,`@xmath276`,`@xmath277`,`@xmath278 ` ) ` @xmath282 \\{update energy within the @xmath1 epoch } @xmath283 @xmath284 @xmath285 @xmath286 ` [ ` @xmath287`,`@xmath288`]=find_tmin_two_epoch(`@xmath269`,`@xmath273`,`@xmath260`,`@xmath261`,`@xmath274`,`@xmath275 ` ) ` * ( see algorithm  [ alg : localopt_causality])*. @xmath289 * end procedure *     * procedure *  ` [ ` @xmath205`,`@xmath290 ` ] = find_tmin_two_epoch(`@xmath291`,`@xmath292`,`@xmath293`,`@xmath294`,`@xmath274`,`@xmath275 ` ) ` @xmath295 , @xmath296 @xmath297 , @xmath298 , @xmath299 , @xmath300    @xmath301 + @xmath302 + @xmath303 , @xmath304 + @xmath305 ` find_tmin_one_epoch(`@xmath292`,`@xmath306`,`@xmath307`,`@xmath275 ` ) `    @xmath308 @xmath301 + @xmath302 + @xmath303 , @xmath304 + @xmath305 @xmath309 @xmath310 * end procedure *     next , we first establish that the cost function ( that is , the completion time t ) strictly decreases after each iteration of flowright , until it stops .",
    "we then show that the algorithm always stops .",
    "[ thm : flowright_stops ]    the following statements hold :    1 .",
    "_ as flowright runs , objective function @xmath53 of prob .",
    "[ pr : multiuserscheduling ] strictly decreases _ after each iteration .",
    "conversely , if @xmath53 did not change after an iteration , then flowright stopped at the previous one .",
    "flowright stops , and returns a sequence @xmath311 .",
    "_    _ proof .",
    "suppose that we are on the @xmath133 iteration of the algorithm , and so far local optimizations have been performed on all epoch pairs up to @xmath312 . during the @xmath313 iteration , local optimization on epochs @xmath249 has updated @xmath314 with the corresponding bits @xmath315 .",
    "as the @xmath133 iteration progress , local optimization on the epochs @xmath312 determines @xmath316 and resets @xmath317 .",
    "suppose that this local optimization results in @xmath100 before the end of the @xmath1 epoch .",
    "hence in the rest of that epoch , rate pair changes to @xmath318 , , a gap occurs .",
    "let @xmath319 be the total bits to be transmitted in epochs @xmath202 . from lemma  [ lmm : constantrate ] , by using a constant rate pair within the @xmath1 epoch , , filling the gap within the epoch , at least the same number of bits can be transmitted to each user as in the original , slotted allocation . as the @xmath133 iteration progress",
    ", local optimization on the epochs @xmath202 determines @xmath250 and resets @xmath314 by at least trying to assign a constant rate pair in the @xmath1 epoch using the same amount of energy , hence reducing the number of bits to be transmitted in the @xmath198 epoch .",
    "then , transmission surely ends before the end of the @xmath198 epoch , , the gap moves from the @xmath1 epoch to the @xmath198 .",
    "therefore , after local optimization , the total time to transmit @xmath260 and @xmath261 bits within the epoch pair @xmath202 reduces . continuing this way , the gap propagates to the end of the @xmath133 iteration , hence the initial @xmath51 and @xmath52 bits are transmitted by the time @xmath320 .",
    "+ to prove the converse claim , suppose that after @xmath133 iteration , @xmath53 did not change .",
    "then , no gap has occurred during local optimizations ; otherwise it would have propagated to the last epoch used and hence , reduced @xmath53 .",
    "therefore , performing further iterations can not create any gaps meaning that algorithm has indeed stopped at @xmath321 iteration .",
    "flowright initially starts from a feasible @xmath322 , which is obviously lower bounded by @xmath323 , the unique smallest completion time . from part-1 , @xmath324 is a strictly decreasing real sequence bounded below by @xmath325 , hence the iterations eventually stop .",
    "therefore , the rate pairs @xmath326 converge to some final value @xmath311 .",
    "+    ' '' ''    now , we show in the following theorem that the schedule returned by flowright possesses the properties of opt listed in theorem  [ thm : optpowerallocation ] and  [ thm : optrateallocation ] .",
    "[ thm : flowright_properties ]    when flowright stops ,    1 .",
    "_ powers are monotonically nondecreasing , , @xmath327 .",
    "_ energy consumed during any constant power allocation band equals the total energy harvested in that band . _ 3 .",
    "_ the stronger user s rate is monotone nondecreasing , , @xmath328 , _ 4 .   _",
    "if the stronger user s rate changes at the @xmath198 epoch , the weaker user s rate is zero at the @xmath1 epoch , _ 5 .",
    "_ the weaker user s rate is monotone nondecreasing , , @xmath329 .",
    "_    _ proof .",
    "suppose that we can find two epochs @xmath49 and @xmath330 with powers such that @xmath331 .",
    "from lemma  [ lmm : constantrate ] , by bringing power levels closer to each other ( this never violates energy causality ) , further local improvement on these epochs is ensured which contradicts the fact that flowright has stopped .",
    "2 .   suppose that @xmath332 for some band of length @xmath162 such that @xmath333 .",
    "then , from part-1 , we have @xmath334 .",
    "but we can transfer up to @xmath335 units of energy from epoch @xmath166 to @xmath167 , only improving the schedule ( cf .",
    "lemma  [ lmm : closerpowers ] ) .",
    "this contradicts the assumption that flowright has stopped .",
    "3 .   suppose @xmath336 . from part-1 and lemma  [ lmm : closerrate ] , by assigning the average rate @xmath337 to the _ stronger _ user in epochs ,",
    "more bits can be transmitted to the _ weaker _ user which means further local improvement on these epochs is ensured .",
    "this contradicts the assumption that flowright stopped .",
    "4 .   suppose that the _ stronger _ user s rate changes at the @xmath198 epoch and @xmath203 .",
    "the _ stronger _",
    "user s rate can only increase , , @xmath204 , by part-3 . from lemma",
    "[ lmm : closerrate ] , by bringing @xmath205 and @xmath206 closer to each other using the energy available for the _ weaker _ user at the @xmath1 epoch , overall transmission duration is decreased which contradicts the assumption that flowright stopped .",
    "suppose that @xmath208 .",
    "from part-5 , @xmath338 since @xmath210 . from part-3 ,",
    "the power is monotone increasing . since @xmath30 is monotone increasing in @xmath5 by the properties of rate region , @xmath339 , which contradicts @xmath208 .",
    "+    ' '' ''    before moving on with the last theorem proving that * flowright * solves problem  [ pr : multiuserscheduling ] , we explain the details of algorithm  [ alg : localopt_causality ] ( local optimization when energy causality is met ) in the following . from theorem  [ thm : flowright_properties ] , equalizing the rates of _ stronger _ user is optimal when it is feasible . then , given @xmath291 , @xmath292 and @xmath340 , @xmath341 , @xmath100 can be determined iteratively ( see algorithm  [ alg : localopt_causality ] ) using bisection method .",
    "suppose that the algorithm selects @xmath342 such that @xmath260 bits are transmitted to the _ stronger _ user as in the optimal solution . hence , transmission duration in the @xmath198 epoch is @xmath343 .",
    "then , objective is to find the single root of the monotone decreasing function @xmath344 , where @xmath345 is the number of bits transmitted to the _ weaker _ user by the end of transmission .",
    "starting with initial domain interval [ 0,@xmath346 , at each iteration interval is bisected and the subinterval in which the root @xmath100 lies is selected .",
    "algorithm converges in the limit to the unique solution as the domain is continuous and can be terminated within a certain arbitrarily small tolerance @xmath113 in practical implementation .",
    "[ thm : flowright_optimal ] _ the schedule returned by flowright is optimal , , _ @xmath347 .    _",
    "_ suppose that flowright stops and returns a schedule @xmath348 , with completion time @xmath349 .",
    "as flowright respects feasibility , @xmath350 can not be smaller than @xmath323 .",
    "suppose @xmath351 .",
    "consider the case that @xmath323 is in the @xmath352 epoch and @xmath350 is in the @xmath353 epoch with @xmath354 .     in the proof of theorem  [ thm : flowright_optimal ] .",
    "]    there must be a schedule @xmath355 that achieves @xmath323 .",
    "suppose that @xmath356 and @xmath357 are equal up to epoch @xmath167 , which is the _ first _ time they differ either in terms of power level or rates , or both .",
    "let us denote the power allocated in epoch @xmath167 in @xmath356 as @xmath358 and in @xmath357 as @xmath359 .",
    "consider the following .",
    "@xmath360 : from part-2 of theorem  [ thm : optpowerallocation ] , all the harvested energies are consumed within any constant power band of @xmath356 .",
    "then , starting from epoch @xmath167 when @xmath356 consumes all the energy at the end of that constant power region , @xmath357 would have consumed more energy than @xmath356 by part-1 of theorem  [ thm : flowright_properties ] , contradicting the fact that flowright always respects energy causality .",
    "@xmath361 : suppose that @xmath359 increases to @xmath362 at some further epoch @xmath363 before @xmath323 .",
    "from lemma  [ lmm : closerpowers ] , by bringing power levels @xmath364 and @xmath362 of the epoch pair @xmath365 closer to each other ( this never violates energy causality ) , further local improvement on these epochs is ensured which contradicts the fact that flowright has stopped .",
    "+ ) that at the first change between opt and the schedule returned by flowright , power level of opt is greater than that of the schedule returned by flowright . ]    hence , @xmath357 can not have higher power level than @xmath356 until @xmath323 . moreover , if power level of @xmath357 becomes lower than that of @xmath356 , then it should stay constant until @xmath323 .",
    "these results are shown in the general case in figure  [ fig : flowright_vs_optimal ] .    )",
    "that @xmath357 and @xmath356 differ in power at _ k _ constant power bands and differs in both power and rate at _",
    "l _ constant power bands .",
    "]    now , suppose that the _ first _ change occurs when @xmath366 and the rate pairs , @xmath367 and @xmath368 , differ from each other in the general case .",
    "consider the following .",
    "1 .   @xmath369 : since @xmath370 , rate of _ stronger _ user in the @xmath356 should stay constant after epoch @xmath167 by theorem  [ thm : optrateallocation ] .",
    "since @xmath371 and @xmath372 , @xmath357 should have transmitted more bits to _ stronger _ user than @xmath356 , which contradicts the fact that flowright always respects _ bit feasibility _ , , @xmath357 transmits exactly the same number of bits to each user as @xmath356 by the time @xmath350 .",
    "@xmath373 : we have @xmath374 ; therefore , @xmath375 by theorem  [ thm : flowright_properties ] .",
    "then , bit feasibility requires @xmath376 , where @xmath377 is the rate of _ stronger _ user for the @xmath1 constant power band whereas @xmath378 is the duration of that band . rearranging the terms we have @xmath379 , where @xmath380 , @xmath381 .",
    "moreover , from part-2 of theorem  [ thm : flowright_properties ] we have @xmath382 , where @xmath383 is the power of the @xmath1 constant power band ( see fig.[fig : flowright_vs_optimal ] ) . rearranging the terms",
    "we have @xmath384 where @xmath385 , @xmath381 and @xmath386 . now , let @xmath387 and @xmath388 be the number of bits transmitted to the @xmath63 user from epoch @xmath167 till @xmath389 by @xmath357 and till @xmath323 by @xmath356 , respectively .",
    "then , we have @xmath390 + eq  , eq   and eq   follows from the @xmath63 property of the rate region while eq   and eq   follows from the @xmath391 .",
    "hence , @xmath357 transmits more bits to the @xmath63 user than @xmath356 , contradicting the fact that flowright always respects bit feasibility .    ) that  ]    then , power allocation and rate pairs of @xmath356 and @xmath357 can not differ , so @xmath392 and @xmath393 .    ' '' ''",
    "the core computational step in the algorithm is the local optimization ( algorithm  [ alg : localopt ] ) .",
    "this entails the solution of a nonlinear equation , which in our numerical computations has been done iteratively using the bisection method ( detailed in algorithms  [ alg : find_tmin ] and  [ alg : localopt_causality ] ) .",
    "the exact number of iterations , hence the convergence rate depends on the selected tolerance level @xmath394 , but in our experiments convergence time of a local computation is typically on the order of milliseconds .",
    "maximum number of iterations of algorithm  [ alg : find_tmin ] is proportional to @xmath395 whereas that of algorithm  [ alg : localopt_causality ] is proportional to @xmath396 .",
    "then , the worst case computation time of local optimization be @xmath397 . for @xmath398 epochs , @xmath399 local optimizations",
    "are performed at each iteration .",
    "hence , the worst case computation time of an iteration is @xmath400 .",
    "while flowright theoretically terminates when @xmath53 does not change from one iteration to the next , in terms of implementation it would make sense to stop the iterations when the change is within some @xmath394 of the average epoch size .",
    "the choice of @xmath394 will determine the number of iterations and hence the linear scaling coefficient of complexity . in our extensive simulations based on randomized energy harvest amounts , epoch durations and bits to be transmitted",
    ", we observed that the number of iterations for achieving convergence sufficient for all practical purposes is on the order of @xmath401 .",
    "hence , the worst case computation time of flowright is @xmath402 which has polynomial time complexity in @xmath403 .",
    "consider a two - user awgn broadcast channel with bandwidth @xmath404khz and noise power spectral density @xmath405 watts / hz .",
    "suppose that the path loss from sender to the _ stronger _ and _ weaker _ users are 70db and 75db , respectively .",
    "the sender needs to transmit @xmath406mbits to the _ stronger _ user and @xmath404mbits to the _ weaker _ user .",
    "energy harvests of amounts [ 10 , 10 , 20 , 40 , 60 , 70 , 90 , 180 , 190 , 100 , 50 , 30 , 10 ] joules arrive at [ 0 , 2 , 5 , 7 , 9 , 10 , 11 , 13 , 14 , 15 , 18 , 20 , 23 ] hours .",
    "flowright computes the final schedule shown in fig .",
    "[ fig : numex ] .",
    "the stopping criterion used in this example was successive iterations being within @xmath407 where @xmath408 . running on a pc with intel core 2 duo cpu ( 2.26ghz ) and 2 gb ram",
    ", the algorithm stopped after 59 iterations in 1.29 second . in the resulting optimal schedule , the last two energy harvests are not used .",
    "note that in the final schedule , transmit powers remain constant during epochs , and are non - decreasing in time .",
    "= 20.08 hours , after the initialization phase and the final transmission completion time , @xmath100=19.20 hours after the termination of the algorithm to transmit @xmath51=800mbits and @xmath52=100mbits for the given energy harvest instants with the corresponding energy amounts . in the bottom figure ,",
    "transmit powers are shown to be [ 1.11 , 2.78 , 5.56 , 15.28 , 23.30 ] mw for the durations [ 5 , 2 , 2 , 4 , 6.20 ] hours in the final schedule .",
    "the final schedule is @xmath409=[(1.6 , 0),(1.6 , 0),(4.0 , 0),(7.8 , 0),(18.7 , 0.6),(18.7 , 0.6),(18.7 , 0.6),(18.7 , 4.1),(18.7 , 4.1),(18.7 , 4.1),(18.7 , 4.1)]kbps with durations @xmath410 as shown in the last figure . ]",
    "in this paper , we formulated and solved the offline transmission completion time minimization problem on an energy harvesting broadcast link .",
    "we have observed that , in the optimal solution , energy harvests may not necessarily be depleted at the end of each epoch , and could be deferred for later use .",
    "the schedule tries to `` hurry up and be lazy '' at the same time .",
    "the sender picks rates from the broadcast capacity region judiciously , such that it completes transmission to both users at the same time , @xmath53 . in the optimal schedule",
    ", the powers are non - decreasing in time , so that transmission rate is highest toward the end .",
    "we have shown that the problem can be solved efficiently with a modification of the flowright algorithm .",
    "our proposed algorithm starts with an upperbound on @xmath53 and strictly improves it after every iteration or ",
    "pass \" through the schedule , and stops when @xmath53 converges to the optimal value .",
    "there are a number of directions for further work related to the problem presented in this paper .",
    "one of these is solving the offline minimization problem when data arrive during transmission , rather than being available in the beginning .",
    "our preliminary work on this modification of the problem indicates that its solution has similar structural properties to the first problem , such as the powers being nondecreasing in time , and rates not changing between data arrival or energy harvest instants . here , the optimal solution has more reason to be  lazy \" in terms of transmission rate , as data will continue to come and it may be wise to save energy for future data arrivals .",
    "we believe that a further modified version of the iterative algorithm described in this paper solves this version of the problem .    a second direction for further work is addressing the multiple - access version of this problem . there",
    ", energy harvests will be occurring at the senders , possibly at different points in time . finding a distributed solution for that case may be a difficult yet interesting problem .    finally , another issue of interest is time - varying channel gain .",
    "the case of time - varying channel gain is interesting , and perhaps more meaningful to be setup as an online problem , rather than an offline problem , as channel gain variation is often difficult to predict ( whereas energy harvesting times or packet formation times may be known ahead of time in some applications . )",
    "as the offline problem formulation has facilitated the analysis of the problem , going to an online formulation is arguably the most important challenge .",
    "while there are different ways to formulate the online problem , for example , as a dynamic control problem , our intuition is that approximate methods that leverage the offline formulation may be more tractable and insightful .",
    "[ conclusion ]",
    "we thank s. ulukus and k. leblebicioglu for useful discussions .",
    "from and , @xmath29 and @xmath30 are nonnegative . monotonicity follows from and as the signs of the first order partial derivatives of @xmath29 and @xmath30 in their respective domains are always fixed . from and , @xmath29 and @xmath30 are concave in power and , respectively rate , when the other parameter is held constant .",
    "the last property follows from and .      using ,",
    "can be written as @xmath412 the @xmath63 order derivative of @xmath413 with respect to @xmath414 is the following   and @xmath415 represent the first order partial derivatives of @xmath416 with respect to @xmath5 and @xmath31 , respectively .",
    "second order partial derivatives of @xmath416 are represented by @xmath417 , @xmath418 , @xmath419 and @xmath420 @xmath421 @xmath422          substituting @xmath423 and @xmath424 in to , we have the following .",
    "@xmath425 the @xmath63 order derivative of @xmath426 with respect to @xmath414 is the following @xmath427 according to the properties of the rate region ( 1)-(4 ) , always holds . hence @xmath426 is concave in @xmath414 .",
    "12 b. prabhakar , e. uysal - biyikoglu , and a. el gamal ,  energy - efficient transmission over a wireless link via lazy packet scheduling \" , _ ieee infocom _ , pp . 386 - 394 , 2001 .",
    "r. a. berry and r. g. gallager ,  communication over fading channels with delay constraints , \" _ ieee transactions on information theory _ ,",
    "vol.48 , pp .",
    "1135 - 1149 , may 2002 .",
    "p. nuggehalli , v. srinivashan , and r. r. rao , ",
    "delay constrained energy efficient transmission strategies for wireless devices , \" _ in proc.ieee infocom _ , vol.3 , new york , june 2002 , pp .",
    "1765 - 1772 . m. a. zafer and e. modiano ,  a calculus approach to energy - efficient data transmission with quality of service constraints , \" _ ieee / acm transactions on networking _ , vol.17 , pp .",
    "898 - 911 , june 2009 .",
    "j. yang and s. ulukus ,  optimal packet scheduling in an energy harvesting communication system \" , submitted for publication , 2010 .",
    "e. uysal - biyikoglu and a. el gamal ,  on adaptive transmission for energy efficiency in wireless data networks \" , _ ieee transsactions on information theory _ ,",
    "vol.50 , pp.3081 - 3094 , dec 2004 .",
    "t.m . cover and j.a .",
    "thomas , _ elements of information theory_. wiley series in telecommunications .",
    "john wiley & sons , inc . , 1991 .",
    "e. uysal - biyikoglu , b. prabhakar , and a. el gamal ,  energy - efficient transmission over a wireless link via lazy packet scheduling , \" _ ieee trans .",
    "networking _ , aug .",
    "2002 , pp .",
    "487 - 499 .",
    "aman jain , sanjeev r. kulkarni and sergio verdu ,  minimum energy per bit for gaussian broadcast channels with cooperating receivers and common message , \" _ proc .",
    "forty - seventh annual allerton conference on communication , control , and computing _ ,",
    "monticello , usa , sep . 2009 .",
    "y. polyanskiy , h. v. poor and s. verdu ,  minimum energy to send k bits with and without feedback , \" _ 2010 ieee int .",
    "symposium on information theory _",
    ", austin , texas , june 13 - 18 , 2010 . j. yang , o. ozel and s. ulukus ,  broadcasting with an energy harvesting rechargeable transmitter , \" arxiv:1010.2993v1 ."
  ],
  "abstract_text": [
    "<S> the minimization of transmission completion time for a given number of bits per user in an energy harvesting communication system , where energy harvesting instants are known in an offline manner is considered . </S>",
    "<S> an achievable rate region with structural properties satisfied by the 2-user awgn broadcast channel capacity region is assumed . </S>",
    "<S> it is shown that even though all data are available at the beginning , a non - negative amount of energy from each energy harvest is deferred for later use such that the transmit power starts at its lowest value and rises as time progresses . </S>",
    "<S> the optimal scheduler ends the transmission to both users at the same time . exploiting the special structure in the problem , the iterative offline algorithm , flowright , from earlier literature , </S>",
    "<S> is adapted and proved to solve this problem . </S>",
    "<S> the solution has polynomial complexity in the number of harvests used , and is observed to converge quickly on numerical examples .    </S>",
    "<S> packet scheduling , energy harvesting , awgn broadcast channel , flowright , energy - efficient scheduling . </S>"
  ]
}