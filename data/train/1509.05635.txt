{
  "article_text": [
    "geographic or geometric routing is a routing approach for wireless sensor networks that became popular recently .",
    "it uses geographic coordinates of sensor nodes to route messages between them .",
    "one simple routing strategy is greedy routing . upon receipt of a message",
    ", a node tries to forward it to a neighbor node that is closer to the destination than itself .",
    "however , delivery can not be guaranteed , since a message may get stuck in a local minimum or _",
    "void_. more advanced geometric routing protocols employ strategies like face routing  @xcite and related techniques based on planar graphs to get out of local minima ; see  @xcite for an overview .",
    "an alternative approach is to decompose the network into components , such that in each of them greedy routing is likely to perform well  @xcite .",
    "a global data structure of preferably small size is used to store interconnectivity between components .",
    "one such network decomposition approach has been recently proposed by tan and kermarrec  @xcite .",
    "they model the network as a polygonal region with obstacles or holes inside it and try to partition this region into a minimum number of polygons , in which greedy routing works between any pair of points .",
    "they call such components _ greedily routable regions ( grrs)_. for intercomponent routing , region adjacencies are stored in a graph .",
    "the protocol is able to guarantee finding paths of bounded stretch .",
    "the size of the routing state depends on the number of grrs .",
    "the authors prove that partitioning a polygon with holes into a minimum number of regions is -hard and propose a simple heuristic .",
    "its solution may strongly deviate from the optimum even for very simple polygons ; see fig .",
    "[ fig : heuristic - bad ] .    in this paper",
    ", we approach the problem of finding minimum or approximately minimum grr decompositions by first considering the special case of partitioning drawings of graphs , which can be interpreted as very thin polygons .",
    "we notice that in this scenario , grrs coincide with _ increasing - chord _ drawings of trees as studied by alamdari et al .",
    "@xcite .",
    "a _ self - approaching _ curve is a curve , where for any point @xmath1 on the curve , the distance to @xmath1 decreases continuously while traversing the curve from the start to @xmath1  @xcite .",
    "an _ increasing - chord _ curve is a curve that is self - approaching in both directions .",
    "the name is motivated by the equivalent characterization as those curves , where for any four points @xmath2 in this order along the curve , it is @xmath3 .",
    "a graph drawing is self - approachingor increasing - chordif each pair of vertices is joined by a self - approachingor increasing - chordpath , respectively .",
    "the study of self - approachingand increasing - chordgraph drawings was initiated by alamdari et al .",
    "they studied the problem of recognizing whether a given graph drawing is self - approaching and gave a complete characterization of trees admitting self - approaching drawings . in our own previous work",
    "@xcite , we studied self - approachingand increasing - chorddrawings of triangulations and 3-connected planar graphs .",
    "furthermore , the problem of connecting given points to an increasing - chorddrawing has been investigated  @xcite .",
    "[ [ contributions . ] ] contributions .",
    "+ + + + + + + + + + + + + +    first , we show that partitioning a plane graph drawing into a minimum number of increasing - chordcomponents is -hard .",
    "this strengthens the result of tan and kermarrec  @xcite for polygons with holes .",
    "next , we consider plane drawings of trees .",
    "we show how to model the decomposition problem using minimum multicut , which provides a polynomial - time 2-approximation .",
    "we then solve the partitioning problem for trees optimally in polynomial time using dynamic programming .",
    "finally , we use the insights gained for decomposing graphs and apply them to the problem of minimally decomposing simple triangulated polygons into grrs .",
    "we provide a polynomial - time 2-approximation for decompositions that are formed along chords of the triangulation .",
    "in the following , let  @xmath4 be a closed subset of  @xmath0 without articulation points , and let  @xmath5 denote its boundary .    for @xmath6 ,",
    "let  @xmath7 denote the  @xmath8 of  @xmath9 , i.e. , the set of points in  @xmath4 reachable from  @xmath9 by a straight - line movement . for directions",
    "@xmath10 and  @xmath11 , let  @xmath12 denote the angle between them .    for an  @xmath13 path  @xmath14 and a point  @xmath15 on  @xmath14 ,",
    "we define the _ forward tangent _ on  @xmath14 in  @xmath9 as the direction @xmath16 .",
    "next , we formally define paths resulting from greedy routing inside  @xmath4 .",
    "we call such paths  _ greedy_. note that this definition of greediness is different from the one used in the context of greedy embeddings of graphs  @xcite .    for points  @xmath17 ,",
    "an  @xmath13 path  @xmath14 is _ greedy _ if the distance to  @xmath18 strictly decreases along  @xmath14 and if for each point  @xmath19 on  @xmath14 , the forward tangent  @xmath20 on  @xmath14 in  @xmath21 has the minimum angle with  @xmath22 among all vectors  @xmath23 for any  @xmath24 .",
    "[ def : greedy - path ]      greedily routable regions were introduced by tan and kermarrec  @xcite as follows .",
    "a polygon  @xmath4 is a _ greedily routable region ( grr ) _",
    ", if for any two points  @xmath25 , @xmath26 , point  @xmath27 can always move along a straight - line segment within  @xmath4 to some point  @xmath21 such that @xmath28 .",
    "[ def : grr ]    it is easy to show that  @xmath4 is a grr if and only if each pair of its points is connected by such greedy path .",
    "therefore , definition  [ def : grr ] is equivalent to the one used in the abstract .",
    "[ lem : grr - equiv ] polygon @xmath4 is a grr if and only if for every  @xmath29 there exists a greedy  @xmath13 path  @xmath30 .",
    "i )  first , let  @xmath4 be a grr , and consider points  @xmath31 . consider a path  @xmath14 constructed by the following procedure .",
    "* first , we set  @xmath32 . *",
    "if possible , we move  @xmath9 to the first intersection of @xmath33 and  @xmath5",
    ". otherwise ,  @xmath34 . *",
    "if  @xmath9 is in the interior of a boundary edge  @xmath35 , we move  @xmath9 to the vertex  @xmath36 minimizing the angle between  @xmath37 and  @xmath38 , for  @xmath39 , and return to  step  2 . * if  @xmath9 coincides with the vertex  @xmath40 incident to boundary edges  @xmath35 and  @xmath41 , we also move  @xmath9 to the vertex  @xmath36 minimizing the angle between  @xmath42 and  @xmath38 , for  @xmath43 .",
    "go to  step  2 .",
    "* we proceed until  @xmath9 reaches  @xmath18 or until none of the above movements is possible .",
    "we consider the segments of  @xmath14 iteratively and show that each of them would be taken by a greedy path . since  @xmath4 is a grr , every point  @xmath6 can get closer to  @xmath18 by a linear movement . if all points on  @xmath44 sufficiently close to  @xmath9 are in  @xmath4 , a greedy path would move along  @xmath44 , until it hits  @xmath5 .",
    "assume all points on  @xmath44 sufficiently close to  @xmath9 are not in  @xmath4 .",
    "then ,  @xmath9 is on  @xmath45 .",
    "let  @xmath10 and  @xmath11 be the two tangents in  @xmath9 on the paths that start at  @xmath9 and go along  @xmath45 .",
    "let  @xmath46 be the cone of directions spanned by  @xmath10 and  @xmath11 , such that  @xmath47 .",
    "then ,  @xmath46 contains the directions of all possible straight - line movements from  @xmath9 . by definition  [ def : grr ] ,",
    "for some direction  @xmath48 , it must hold : @xmath49 .",
    "but then , it must hold : @xmath50 .",
    "it follows that , when moving along  @xmath14 , point  @xmath9 either moves directly to  @xmath18 or slides along a boundary edge until it reaches one of the endpoints .",
    "therefore , point  @xmath9 never reenters an edge and must finally reach  @xmath18 .",
    "the forward tangent on  @xmath14 always satisfies the condition of definition  [ def : greedy - path ] , therefore ,  @xmath14 is a greedy @xmath13  path .",
    "ii )  now consider  @xmath17 connected by a greedy @xmath13 path  @xmath14 .",
    "then , the first segment  @xmath51 of  @xmath14 satisfies the condition in definition  [ def : grr ] .    a _ decomposition _ of a polygon",
    "@xmath4 is a partition of  @xmath4 into simple polygons  @xmath52 , @xmath53 , such that  @xmath54 and no  @xmath52 , @xmath55 with @xmath56 share an interior point .",
    "a decomposition of @xmath4 is a _ grr decomposition _ if each component  @xmath52 is a grr .",
    "using the concept of a _ conflict relationship _ between polygon edges ( see fig .",
    "[ fig : conflict ] ) , tan and kermarrec give a convenient characterization of grrs .",
    "let  @xmath4 be a polygon , @xmath57 a boundary edge and  @xmath9 a point on  @xmath58 .",
    "let  @xmath59 denote a ray with origin in  @xmath9 orthogonal to  @xmath58 , such that all points on this ray sufficiently close to  @xmath9 are not in the interior of  @xmath4 .",
    "( if  @xmath9 is an acute reflex angle , no such ray exists . )    let  @xmath60 and  @xmath61 be two edges of a polygon  @xmath4 .",
    "if for some point  @xmath9 in the interior of  @xmath60 , @xmath62 intersects  @xmath61 , then  @xmath60 _ conflicts _ with  @xmath61 .",
    "a polygon is a grr if and only if it has no pair of conflicting edges  @xcite .",
    "now consider a straight - line plane drawing  @xmath63 of a graph  @xmath64 .",
    "we identify the edges of  @xmath65 with the corresponding line segments of  @xmath63 and the vertices of  @xmath65 with the corresponding points .",
    "planar straight - line drawings can be considered as infinitely thin polygons .",
    "the routing happens along the edges of  @xmath63 , and we call  @xmath63 a grr if for any two points  @xmath26 on  @xmath63 there exists a point  @xmath21 on the same edge as  @xmath27 , such that  @xmath28 .",
    "assume @xmath66 for an interior point @xmath27 on an edge  @xmath60 of  @xmath63 crosses another edge  @xmath61 in point  @xmath18 .",
    "then , any movement along  @xmath60 starting from  @xmath27 increases the distance to  @xmath18 .",
    "we call such edges _ conflicting_. it is easy to see that  @xmath63 is a grr if it contains no pair of conflicting edges .",
    "obviously , such a drawing  @xmath63 contains no cycles .",
    "in fact , a straight - line drawing of a tree is increasing - chordif and only if it has no conflicting edges  @xcite , which implies the following lemma .",
    "the following two properties are equivalent for a straight - line drawing  @xmath63 to be a grr .",
    "1 )  @xmath63 is connected and has no conflicting edges ; 2 )  @xmath63 is an increasing - chorddrawing of a tree .",
    "[ lem : tree - grr ]      consider a straight - line plane drawing  @xmath63 of a graph  @xmath64 .",
    "we now discuss splitting  @xmath63 at non - vertices .",
    "consider each pair of original edges  @xmath67 .",
    "for  @xmath68 , let  @xmath69 be the normal on  @xmath70 in  @xmath71 . if  @xmath69 intersects  @xmath72 , we subdivide  @xmath72 at the intersection . since we consider only original edges of  @xmath63 , the resulting subdivision  @xmath73 has @xmath74 vertices .    each grr partition of  @xmath63 can be transformed into a grr partition of  @xmath73 without increasing its size .",
    "[ lem : split ]    consider edge  @xmath75 of the subdivision  @xmath73 , a point  @xmath76 in its interior and assume an increasing - chordcomponent  @xmath77 ( green in fig .",
    "[ fig : trees : splits ] ) contains  @xmath78 , but not  @xmath79 .",
    "we claim that we can reassign  @xmath79 to  @xmath77 .    for points",
    "@xmath80 , let  @xmath81 denote the halfplane not containing @xmath9 bounded by the line through  @xmath82 orthogonal to the segment  @xmath83 .",
    "let @xmath84 be an original edge of  @xmath63 , such that  @xmath40 is in  @xmath77 .",
    "the halfplane @xmath85 contains  @xmath86 , and its boundary does not cross  @xmath58 by construction .",
    "thus , @xmath85 contains  @xmath58 .",
    "furthermore , @xmath87 .",
    "therefore , the union of  @xmath77 and  @xmath79 is increasing - chord .",
    "finally , removing  @xmath79 from the components containing it does nt disconnect them , since no edge or edge part is attached to  @xmath76 ( or any other intermediate point on  @xmath79 ) .",
    "we show that finding a minimum decomposition of a straight - line plane drawing  @xmath63 into increasing - chordtrees is -hard .",
    "this strengthens the -hardness result by tan and kermarrec  @xcite for minimum grr decompositions of polygons with holes .",
    "both our -hardness proof and the proof in  @xcite are reductions from the -complete problem planar 3sat  @xcite .",
    "recall that a boolean 3sat formula @xmath88 is called _ planar _ , if the corresponding variable clause graph @xmath89 having a vertex for each variable and for each clause and an edge for each occurrence of a variable ( or its negation ) in a clause is a planar graph .",
    "in fact , @xmath89 can be drawn in the plane such that all variable vertices are aligned on a vertical line and all clause vertices lie either to the left or to the right of this line and connect to the variables via e- or @xmath90-shapes  @xcite .",
    "the variable gadgets in  @xcite are cycles formed by t - shaped polygons which can be made arbitrarily thin .",
    "thus , in the case of straight - line plane drawings we can use very similar variable gadgets ( see fig .  [ fig : cycles : arm ] ) .",
    "the clause gadgets in  @xcite , however , are squares , at which three variable cycles meet .",
    "this construction can not be adapted for straight - line plane drawings and we have to construct a significantly different clause gadget ; see fig .  [",
    "fig : cycles : clause ] .",
    "consider a variable gadget consisting of  @xmath91 t - shapes as shown in fig .",
    "[ fig : cycles : arm ] . on each t -",
    "shape we place one black and one white point as shown in the figure .",
    "it is easy to verify that neither two black points nor two white points can be in one increasing - chordcomponent .",
    "thus , a minimum grr decomposition of a variable gadget contains at least  @xmath91 components .",
    "if it contains exactly  @xmath91 components , then each component must contain one black and one white point , and there are exactly two possibilities .",
    "each black point has exactly two white points it can share a grr with , and once one pairing is picked , it fixes all the remaining pairings .",
    "the corresponding possibilities are shown in fig .",
    "[ fig : cycles : arm - pos - true ] and  [ fig : cycles : arm - pos - false ] and will be used to encode the values _ true _ and _ false _ , respectively .    to pass the truth assignment of a variable to a clause",
    "it is part of , we use _ arm _ gadgets . in total twelve variations of the arm gadget",
    "will be used , depending on the position of the literal in the clause , the position of the clause , and whether the literal is negated or not .",
    "since in @xmath89 each clause @xmath92 connects to three variables , we denote these variables or literals as the _ upper _ , _ middle _ , and _ lower _ variables of @xmath92 .",
    "similarly , an arm of @xmath92 is called an _ upper _ , _ middle _ , or _ lower _",
    "arm if it belongs to a literal of the same type in @xmath92 .",
    "an arm is called a _ right _",
    "_ left _ ) arm if it belongs to a clause that lies to the right ( resp .",
    "left ) of the vertical variable line .",
    "finally , an arm of @xmath92 is _ positive _ if the corresponding literal is positive in @xmath92 and it is _ negative _ otherwise .",
    "the basic principle of operation of any arm gadget is the same ; as an example consider the right upper positive arm in fig .",
    "[ fig : cycles : arm ] . fig .",
    "[ fig : cycles : arm-2 ] , [ fig : cycles : arm-3 ] , [ fig : cycles : arm - inv ] and the proof of lemma  [ lem : cycles : arms ] cover the remaining arm types .",
    "note that each arm can be arbitrarily extended both horizontally and vertically to reach the required point of its clause gadget .",
    "we select again black and white points ( also called _ distinguished _ points ) on the line segments of the arm gadget .",
    "we shall prove the following property which is crucial for our construction .",
    "consider a drawing  @xmath93 of a variable gadget together with all of its arms .",
    "then , neither two black nor two white points on  @xmath93 can be in one grr . in a minimum grr decomposition of  @xmath93 , each component has one black and one white point , and exactly two such pairings of points are possible , one for each truth assignment .",
    "consider two such drawings  @xmath93 , @xmath94 for two different variables .",
    "then , no distinguished point of  @xmath93 can be in the same grr as a distinguished point of  @xmath94 .",
    "[ lem : np : black - white - points ]    part  1 of property  [ lem : np : black - white - points ] extends the same property that we already showed for variable gadgets without arms to the case including all arms .",
    "it is easy to verify that it holds in all our constructions of the arm gadgets .",
    "part  2 follows from the way the arms are connected by a clause , i.e. , in fig .",
    "[ fig : cycles : clause ] no pair of points from  @xmath95 , @xmath96 , @xmath97 can be in same grr .",
    "for each arm gadget we select a special _ red _ point  @xmath82 ; see fig .",
    "[ fig : cycles : arm ] .",
    "point  @xmath82 is neither white nor black .",
    "the clause gadget ( green in fig .",
    "[ fig : cycles : clause ] , partly drawn in fig .",
    "[ fig : cycles : arm ] ) is connected to the arm by a horizontal segment with a distinguished point  @xmath9 on its end , which is either black or white depending on the arm type .",
    "each clause has a distinguished point  @xmath92 chosen as shown in fig .",
    "[ fig : cycles : clause ] .",
    "if points  @xmath82 and  @xmath9 are in the same grr , then this grr obviously can not contain any point of a green clause segment ( see fig .",
    "[ fig : cycles : arm - pos - false ] ) . in the proof of the following lemma",
    "we show that points  @xmath9 and  @xmath82 are in the same grr exactly for the decomposition corresponding to the variable state that does _ not _ satisfy the clause .     in a minimum grr decomposition ,",
    "the distinguished point  @xmath92 of a clause gadget can share a grr with a black or white point of an arm gadget if and only if the corresponding literal is in the _ true _ state .",
    "[ lem : cycles : arms ]    1 )  we first show the lemma exemplarily for a positive right upper arm .",
    "we use the notation from fig .",
    "[ fig : cycles : arm ] to refer to the distinguished points . in the _ true _ state ( see fig .",
    "[ fig : cycles : arm - pos - true ] ) , points  @xmath98 , @xmath99 and  @xmath82 are in the same grr .",
    "points  @xmath100 and  @xmath9 are in another grr ( e.g. , the green one in fig .",
    "[ fig : cycles : arm ] ) which can contain the distinguished point  @xmath92 of the clause .    in",
    "the _ false _ state ( see fig .  [",
    "fig : cycles : arm - pos - false ] ) , the points  @xmath99 and  @xmath9 are in the same grr .",
    "moreover , point  @xmath82 can share a grr with exactly one point from  @xmath99 , @xmath100 or  @xmath101 .",
    "but if  @xmath82 were with  @xmath100 or  @xmath101 , then  @xmath99 would be disconnected from any white point , a contradiction to the minimality of the decomposition .",
    "thus , points  @xmath82 , @xmath99 and  @xmath9 are in the same grr , which can not contain a point of the clause .",
    "2 )  we now show the lemma for a negative right lower arm .",
    "we use the notation from fig .",
    "[ fig : cycles : arm-2 ] . in the _ false _ state ,",
    "points  @xmath98 , @xmath99 and  @xmath82 are in the same grr ; see fig .",
    "[ fig : cycles : arm - neg - false-2 ] points  @xmath100 and  @xmath9 are in another grr ( e.g. , the green one in fig .",
    "[ fig : cycles : arm ] ) which can contain the entire clause ; see the lower arm in fig .",
    "[ fig : cycles : clause ] .    now consider a _ true _",
    "state ; see fig .  [",
    "fig : cycles : arm - neg - true-2 ] .",
    "point  @xmath82 shares a grr with exactly one point from  @xmath99 , @xmath100 or  @xmath101 .",
    "if  @xmath82 is with  @xmath100 or  @xmath101 , then  @xmath99 is disconnected from any white point , a contradiction to the minimality of the decomposition .",
    "thus , points  @xmath82 , @xmath99 and  @xmath9 are in the same grr , which can not contain a point of the clause .",
    "3 )  next , consider a positive right middle arm ; see fig .",
    "[ fig : cycles : arm-3 ] .",
    "we identify points  @xmath9 and  @xmath99 .",
    "point  @xmath82 is either with  @xmath99 or  @xmath100 .",
    "if  @xmath82 is with  @xmath100 , then  @xmath98 is disconnected from all black points , contradicting the minimality .",
    "thus ,  @xmath82 is always with  @xmath99 .    in",
    "the _ true _ state , points  @xmath102 , @xmath82 and  @xmath99 are in the same grr , which can be merged with the clause gadget ; see fig .",
    "[ fig : cycles : arm - neg - true-3 ] and  [ fig : cycles : clause ] .",
    "in the _ false _ state , points @xmath98 , @xmath82 and  @xmath99 are in the same grr , which can not contain point  @xmath92 of the clause .",
    "4 )  to construct the negative right upper arm , the positive right lower arm and the negative right middle arm , we invert the arm gadgets constructed before . the inverted gadgets are shown in fig .  [ fig : cycles : arm - inv ] .",
    "the proofs are analogous to the respective non - inverted cases .    5 )",
    "the left arms are constructed by mirroring .",
    "+    the remaining ingredient is to show the following property .",
    "if a variable assignment satisfies a clause , then its entire clause gadget can be contained in a grr of the corresponding arm .",
    "[ prop : cycles : merge - clause ]    in fig .",
    "[ fig : cycles : clause:3true ] , each variable is in a state that satisfies the clause .",
    "the lengths of the blue and green segments are chosen such that each blue component can be merged with the clause gadget ( green ) into a single grr as indicated by the dashed lines .",
    "finally , we can prove the -hardness result by showing that any satisfying truth assignment for a formula @xmath88 yields a grr decomposition into a fixed number @xmath91 of grrs , where @xmath91 is the total number of black points in our construction .",
    "likewise , we can show that any decomposition into @xmath91 grrs necessarily satisfies each clause in @xmath88 .    for  @xmath103 , deciding",
    "whether a plane straight - line drawing can be partitioned into  @xmath91 increasing - chordcomponents is -complete .",
    "[ thm : cycles : nphard ]    first , we show that the problem is in  .",
    "given a plane straight - line drawing  @xmath63 , we construct its subdivision  @xmath73 as described in section  [ sec : split ] . by lemma  [ lem : split ] , it is sufficient to consider only partitions of edges in  @xmath73 into  @xmath91 components . testing if each component is increasing - chordcan be done in polynomial time .",
    "next , we show -hardness . given a planar 3sat formula  @xmath88",
    ", we construct a planar straight - line drawing @xmath104 using the gadgets described above .",
    "it is easy to see that @xmath104 can be constructed on an integer grid of polynomial size and in polynomial time .",
    "assume  @xmath104 contains  @xmath91 black points in total .",
    "we claim that  @xmath104 can be decomposed in  @xmath91 grrs if and only if  @xmath88 is satisfiable .",
    "consider a truth assignment of the variables satisfying  @xmath88 .",
    "we decompose each variable gadget and the attached arms accordingly , which yields exactly  @xmath91 grrs . by property",
    "[ prop : cycles : merge - clause ] , each clause gadget can be merged with the grr of the arm of a literal which satisfies the clause .",
    "therefore , we have  @xmath91 grrs in total .    conversely , consider a decomposition of  @xmath104 into  @xmath91 grrs .",
    "then , each variable and the attached arms must be decomposed minimally and , by property  [ lem : np : black - white - points ] , must be either in the _ true _ or in the _ false _ state . furthermore , each distinguished point  @xmath92 of a clause must be in a component belonging to one of the arms of the clause .",
    "but then , the corresponding variable must satisfy the clause by lemma  [ lem : cycles : arms ] .",
    "this induces a satisfying variable assignment for  @xmath88 .",
    "we consider greedy tree decompositions , or gtds . for trees ,",
    "greedy regions correspond to increasing - chorddrawings . in the following , we consider a plane straight - line drawing of a tree @xmath105 , @xmath106 .",
    "we identify the tree with its drawing , the vertices with the corresponding points and the edges with the corresponding line segments .",
    "we want to partition it into a minimum number of increasing - chordsubdrawings .",
    "in such a partition , each pair of components shares at most one point .",
    "we make a restriction by only allowing contacts of the following type .",
    "two drawings of trees with the only common point  @xmath9 have a _ proper contact _ if  @xmath9 is a leaf in at least one of them .",
    "this definition forbids grrs to have contacts as in fig .",
    "[ fig : trees : non - proper ] .",
    "first , assume  @xmath107 is split only at its vertices .",
    "as shown in section  [ sec : split ] , we can drop this restriction and adapt our algorithms to compute minimum or approximately minimum grr decompositions of plane straight - line tree drawings which allow splitting tree edges at interior points .",
    "we show how to partition the edges of  @xmath107 into a minimum number of increasing - chordcomponents with proper contacts using minimum multicuton trees . given an edge - weighted graph  @xmath64 and a set of terminal pairs  @xmath108 ,  , @xmath109 , an edge set  @xmath110 is a _ multicut _ if removing  @xmath111 from  @xmath65 disconnects each pair  @xmath112 , @xmath113 .",
    "a multicut is minimum if the total weight of its edges is minimum . for the complexity of minimum multicuton special graph types , see the survey by costa et al .",
    "@xcite . computing minimum multicutis @xmath114-hard even for unweighted binary trees  @xcite , but has a polynomial - time 2-approximation  @xcite .    consider a plane straight - line drawing of a tree  @xmath105 .",
    "we construct a tree  @xmath115 as follows .",
    "tree  @xmath115 has a vertex  @xmath116 for each vertex  @xmath117 and a vertex  @xmath118 for each edge  @xmath119 . for each  @xmath120 , edges  @xmath121 and  @xmath122 are in  @xmath115 .",
    "the set of terminals is defined as  @xmath123 .",
    "let the set of edges  @xmath124 of  @xmath115 form a minimum multicut .",
    "assume removing  @xmath124 from  @xmath115 disconnects  @xmath115 into connected components  @xmath125 .",
    "then , components  @xmath126 form a minimum grr decomposition of  @xmath107 . [",
    "prop : trees : minmult ]    consider a multicut  @xmath124 of  @xmath115 , @xmath127 .",
    "consider a component  @xmath128 .",
    "then , the edges in  @xmath129 are conflict - free and form a connected subtree  @xmath130 of  @xmath107 .",
    "thus ,  @xmath130 is a grr by lemma  [ lem : tree - grr ] .",
    "next , consider a grr decomposition of  @xmath107 into  @xmath91 subtrees  @xmath131 with proper contacts .",
    "assume  @xmath130 , @xmath132 touch at vertex  @xmath117.let edge  @xmath57 be in  @xmath130 , and let  @xmath86 be a leaf in  @xmath130 .",
    "then , we add edge  @xmath122 of  @xmath115 to set  @xmath111 ; see fig .",
    "[ fig : trees : minmult-1 ] and  [ fig : trees : minmult-2 ] .",
    "it is  @xmath133 . after removing  @xmath111 from  @xmath115",
    ", no connected component contains vertices  @xmath134 for a pair of conflicting edges  @xmath60 , @xmath61 .",
    "thus ,  @xmath111 is a multicut .",
    "note that minimum multicutis polynomial in directed trees  @xcite , i.e. , trees whose edges can be directed such that for each terminal pair  @xmath135 , the  @xmath136-@xmath137 path is directed .",
    "we are unable to apply this result , since we can get minimum multicutinstances for which no such orientation is possible , see fig .  [",
    "fig : trees : minmult-2 ] .    given a plane straight - line drawing of a tree  @xmath105 ,",
    "a partition of  @xmath138 into @xmath139 increasing - chordsubtrees of  @xmath107 having only proper contacts can be computed in time polynomial in  @xmath140 , where @xmath141 is the minimum size of such a partition .      in the following",
    "we show how to compute an optimal solution for this problem in polynomial time via a dynamic program .",
    "[ thm : trees : partition - edges ] given a plane straight - line drawing of a tree  @xmath105 , a partition of  @xmath138 into minimum number of increasing - chordsubtrees of  @xmath107 ( minimum gtd ) having only proper contacts can be computed in time @xmath142 .    as it is the case with minimum partitions of simple hole - free polygons into convex  @xcite or star - shaped  @xcite components , our algorithm is based on dynamic programming .",
    "assume  @xmath107 is rooted at vertex  @xmath143 with degree  1 .",
    "for each vertex  @xmath144 with parent  @xmath145 , let  @xmath146 be the subtree of  @xmath144 together with edge  @xmath147 .",
    "a minimum partition is constructed from the solutions of subinstances as follows .",
    "we shall store minimum partitions of  @xmath146 for various possibilities of the greedy component containing  @xmath144 .",
    "we shall call this component the _ root _ component . for subtrees",
    "@xmath148 ,  , @xmath149 whose only common vertex is  @xmath144 , a minimum partition of  @xmath150 is formed by choosing partitions of  @xmath151 and possibly merging some of the components containing  @xmath152 , i.e. , the root components of  @xmath151 .    given a tree root , the number of different subtrees containing it might be exponential , e.g. , it is  @xmath153 in a star . the key observation for our algorithm is that we do not need to store a partition for each possible root component .",
    "we require the following notation .",
    "consider directed non - crossing paths  @xmath154 , @xmath155 , @xmath156 with common origin  @xmath143 , endpoints @xmath157 , @xmath158 , @xmath159 and , possibly , common prefixes .",
    "let  @xmath160 be vertices of  @xmath161 , @xmath162 , and let  @xmath107 be the tree formed by the union of  @xmath163 and  @xmath156 .",
    "we say that  @xmath155 is _ clockwise between _",
    "@xmath154 and  @xmath156 , if the clockwise traversal of the outer face of  @xmath107 visits  @xmath157 , @xmath158 , @xmath159 in this order ; see fig .",
    "[ fig : path - clockwise - between ] .",
    "[ def : path - clockwise - between ]    note that in def .",
    "[ def : path - clockwise - between ] the three paths may ( partially ) coincide . lemma  [ lem : trees : combine : paths ] shows that to decide whether a union of two subtrees is increasing - chord , it is sufficient to consider only the two pairs of `` outermost '' root - leaf paths of each subtree .",
    "this result is crucial for limiting the number of representative decompositions that need to be considered during our dynamic programming approach .",
    "the statement of the lemma is illustrated in fig .",
    "[ fig : trees : combine : paths ] .",
    "[ lem : trees : combine : paths ]    let  @xmath164 , @xmath165 be trees drawn with increasing chords having the only common vertex  @xmath143 .",
    "let all tree edges be directed away from  @xmath143 .",
    "let paths  @xmath154 , @xmath155 in  @xmath164 and  @xmath156 , @xmath166 in  @xmath165 be paths from  @xmath143 to a leaf , such that :    every directed path from  @xmath143 in  @xmath164 is clockwise between  @xmath154 and  @xmath155 ;    every directed path from  @xmath143 in  @xmath165 is clockwise between  @xmath156 and  @xmath166 ;    for  @xmath167 , path  @xmath161 is clockwise between  @xmath168 and  @xmath169 ( mod 4 ) .",
    "if the union of paths  @xmath170 is drawn with increasing chords , then so is the union of trees @xmath164 and  @xmath165 .",
    "consider trees  @xmath164 , @xmath165 and paths  @xmath171 satisfying the precondition of the lemma ; see fig .  [",
    "fig : trees : combine : paths ] for a sketch .",
    "note that  @xmath154 and  @xmath155 might have common prefixes , and so might  @xmath156 and  @xmath166 .",
    "assume the four paths @xmath171 are drawn with increasing chords , but the union  @xmath172 of the trees  @xmath164 and  @xmath165 is not .",
    "then , there exist edges  @xmath173 in  @xmath164 and  @xmath174 in  @xmath165 , such that the normal  @xmath175 on  @xmath173 in  @xmath176 crosses edge  @xmath174 .    without loss of generality",
    ", we may assume the following ; see fig .",
    "[ fig : trees : combine : paths : proof:1 ] , [ fig : trees : combine : paths : proof:2 ] .",
    "edge  @xmath173 points vertically upwards ,    edge  @xmath174 is the first edge on the @xmath143-@xmath177 path  @xmath178 crossed by  @xmath175 and points upwards ,    vertex  @xmath179 is on  @xmath175 and to the right of  @xmath176 .",
    "we ensure  ( i ) by rotation .",
    "then , point  @xmath143 is below  @xmath175 ( or on it ) , since the @xmath143-@xmath180 path  @xmath181 is increasing - chord . for",
    "( ii ) , we choose  @xmath174 as the first edge with this property . if it points downwards , there is an edge on the  @xmath143-@xmath179 path crossed by  @xmath175 . for  ( iii ) , if  @xmath175 crosses  @xmath174 in an interior point  @xmath9 , we subdivide the edge at  @xmath9 and replace  @xmath174 by  @xmath182 .",
    "if  @xmath179 is left of  @xmath176 , we mirror the drawing horizontally .",
    "this proves the claim .",
    "first , assume that  @xmath180 , @xmath177 are not on paths @xmath183 .",
    "recall that two of the paths  @xmath170 ( without loss of generality , @xmath155 and  @xmath156 ) are between  @xmath181 and  @xmath178 .",
    "let @xmath184 and  @xmath185 be the last two edges on  @xmath155 and  @xmath156 , respectively .",
    "note that @xmath186 and  @xmath187 must diverge , and so must  @xmath187 and  @xmath188 .",
    "if @xmath189 points upwards and to the left as in fig .",
    "[ fig : trees : combine : paths : proof:1 ] , then  @xmath188 and  @xmath190 must converge ; a contradiction .",
    "thus , @xmath184 , @xmath185 and  @xmath174 point upwards and to the right ; see fig .",
    "[ fig : trees : combine : paths : proof:2 ] . since  @xmath164 as well as the union of  @xmath154 and  @xmath155 is increasing - chord , the angles  @xmath191 , @xmath192 , @xmath193 and  @xmath194 are between  @xmath195 and  @xmath196 .",
    "therefore , vertices  @xmath197 and  @xmath198 must lie below  @xmath175 .",
    "let  @xmath199 be the normal on  @xmath185 in  @xmath198 .",
    "since  @xmath165 is drawn with increasing chords , @xmath174 must lie below  @xmath199 , a contradiction .",
    "the proof works similarly if  @xmath173 is on  @xmath155 ( by identifying  @xmath173 and  @xmath84 ) , and the remaining cases are symmetric .",
    "we now describe our dynamic program in detail . for a root component  @xmath200 of  @xmath146 ,",
    "let the _ leftmost path _ ( or , respectively , the _ rightmost path _ ) be the simple path in  @xmath200 starting at  @xmath145 which always chooses the next counterclockwise ( clockwise ) edge .",
    "let  @xmath201 .",
    "for each pair of vertices  @xmath202 in  @xmath146 , cell  @xmath203 $ ] of a table  @xmath204 stores the size of a minimum grr decomposition of  @xmath146 , in which the root component has the @xmath145-@xmath157 path and the @xmath145-@xmath158 path as its leftmost and rightmost path , respectively , and such that  @xmath144 has degree  @xmath205 in the root component . furthermore , define @xmath206 = \\min_{\\delta    = 0,\\dots,3 } \\tau_\\delta[u , t_1 , t_2]$ ] and @xmath207 = \\min_{t_1 , t_2 } \\tau[u , t_1 , t_2]$ ] .    clearly , for each leaf  @xmath144 , it is @xmath208=1 $ ] , and  @xmath209 = \\infty$ ] for all other values of  @xmath210 .",
    "let  @xmath86 be the only neighbor of the tree root  @xmath143 .",
    "then ,  @xmath211 $ ] is the size of a minimum grr decomposition of  @xmath107 .    for ease of presentation , we use the following notations .",
    "vertex  @xmath144 is not a leaf and has children  @xmath212 .",
    "vertices  @xmath213 are in the subtree of  @xmath71 , vertices  @xmath214 are in the subtree of  @xmath215 , vertices  @xmath216 are in the subtree of  @xmath217 and  vertex  @xmath218 in the subtree of  @xmath219 . for  @xmath220 ,",
    "let  @xmath221 denote the  @xmath144-@xmath222 path .",
    "it is always assumed that the  @xmath222 are such that paths  @xmath223 are in this clockwise order .",
    "[ lem : trees : recurrences ] we have the recurrences    [ algo : trees : t1 ]     [ algo : trees : t2 ]     [ algo : trees : t3 ]     [ algo : trees : t0:0 ]     [ algo : trees : t0:1 ]    [ algo : trees : t0:2 ]    [ algo : trees : t0:3 ]        where the minimizations in lines [ algo : trees : t2 ] , [ algo : trees : t3 ] , [ algo : trees : t0:1 ] , [ algo : trees : t0:2 ] , and  [ algo : trees : t0:3 ] consider only vertices such that @xmath224 , @xmath225 , @xmath226 , @xmath227 , and  @xmath228 are increasing - chord , respectively .",
    "assume  @xmath144 is not a leaf .",
    "each increasing - chordtree drawing either has maximum degree at most  three or is a subdivision of  @xmath229 ( star with four leaves )  @xcite .",
    "this fact limits the number of possibilities of how the root component of  @xmath146 can be created from the root components of  @xmath151 , @xmath230 .",
    "consider a grr decomposition of  @xmath146 of size  @xmath76 with root component  @xmath200 which has @xmath145-@xmath157 and @xmath145-@xmath158 paths as its leftmost and rightmost path , respectively .",
    "if  @xmath144 has degree  2 in  @xmath200 , then it induces grr decompositions of all  @xmath231 with  @xmath232 with sizes  @xmath233 .",
    "note that  @xmath234 . by definition ,",
    "@xmath235 \\leq x_m$ ]",
    ". moreover , the root component of  @xmath151 is  @xmath236 and has  @xmath154 and  @xmath155 as its leftmost and rightmost path ; see fig .",
    "[ fig : trees : combine:1 ] . therefore ,  @xmath237 \\leq    x_i$ ] .",
    "it follows that the right - hand side of recurrence  [ algo : trees : t1 ] is at most  @xmath76 .",
    "thus , the right - hand side of recurrence  [ algo : trees : t1 ] is bounded by its left - hand side .",
    "conversely , assume that the right - hand side of recurrence  [ algo : trees : t1 ] sums to  @xmath238 .",
    "then , there exist grr decompositions of  @xmath231 of size  @xmath235 $ ] for  @xmath239 , and a grr decomposition of  @xmath151 of size  @xmath237 $ ] whose root component  @xmath240 has  @xmath154 and  @xmath155 as leftmost and rightmost path , respectively . by lemma  [ lem : trees",
    ": combine : paths ] and the assumption that  @xmath241 is increasing - chord , it follows that  @xmath242 is increasing - chord .",
    "together , we obtain a grr decomposition of  @xmath146 of size  @xmath76 , whose root component has its leftmost and rightmost paths ending at  @xmath157 and  @xmath158 , respectively .",
    "thus , the left - hand side of recurrence  [ algo : trees : t1 ] is bounded by its right - hand side .",
    "this finishes the proof for recurrence  [ algo : trees : t1 ] .",
    "the remaining recurrences can be proved analogously .",
    "the notable differences are as follows . in recurrence  [ algo : trees : t2 ] , the root component of the decomposition of  @xmath146 is obtained by merging root components of decompositions of  @xmath151 and  @xmath243 as well as edge  @xmath147 ; see fig .",
    "[ fig : trees : combine:2 ] . hence , the number of components in the whole decomposition decreases by  1 . in recurrence  [ algo : trees : t3 ] , we merge three root components with edge  @xmath147",
    ". then ,  @xmath144 has degree  4 , and , thus , each of the three root components must be a path . in recurrence  [ algo : trees : t0:0 ] , the root component of a decomposition of  @xmath146 is the single edge  @xmath147 .",
    "it may , however , be beneficial to merge up to four root components of children of  @xmath144 , provided their boundary paths are such that their union is a grr ; see lemma  [ lem : trees : combine : paths ] .    theorem  [ thm : trees : partition - edges ] follows by applying lemma  [ lem : trees : recurrences ] to  @xmath107 bottom - up .",
    "for the running time , the limiting factor is considering all possible choices of @xmath244 in recurrence  [ algo : trees : t0:1 ] to compute  @xmath245 $ ] . applying results from section  [ sec : split ]",
    "allows us to compute minimum partitions where we also allow splits in the interior of edges .",
    "[ thm:1 ] an optimal partition of a plane straight - line tree drawing in grrs with proper contacts allowing edge splits can be computed in  @xmath246 time .",
    "we now consider partitioning a hole - free polygon @xmath247 with a fixed triangulation into a minimum number of grrs by cutting it along chords of  @xmath247 contained in the triangulation . for such decompositions",
    "we only consider grrs each consisting of a group of triangles of the triangulation that together form a simple polygon without articulation points .",
    "we reduce the problem to minimum multicuton trees and use it to give a polynomial - time @xmath248-approximation , where @xmath249 is the number of grrs in an optimal partition . recall that a polygon is a grr if and only if it has no conflict edges  @xcite .",
    "let  @xmath250 be the triangle defined by three non - collinear points @xmath251 .",
    "[ lem : add - deg-2 ] let  @xmath247 be a simple polygon , @xmath58 an edge on its boundary and  @xmath252 another point , such that @xmath253",
    ". if  @xmath247 is not a greedy region , neither is  @xmath254 .",
    "polygon @xmath255 can become greedy only if  @xmath58 is a conflict edge in  @xmath247 .",
    "then , there exists a point  @xmath9 in the interior of  @xmath58 , such that  @xmath59 crosses the boundary @xmath256 of  @xmath247 .",
    "let  @xmath257 be the first intersection point ; see fig .",
    "[ fig : add - deg-2 ] .",
    "then , either  @xmath258 or  @xmath259 must also cross @xmath256 . without loss of generality",
    ", there exists a point  @xmath76 on @xmath256 , such that : @xmath78 and  @xmath58 are orthogonal , @xmath260 , and adding edge  @xmath78 to  @xmath247 would create an inner face  @xmath261 , such that  @xmath144 is not on the boundary of  @xmath261 ; see fig .",
    "[ fig : add - deg-2 ] .",
    "let  @xmath14 be the @xmath86-@xmath76 path on the boundaries of both  @xmath247 and  @xmath261",
    ". without loss of generality , let  @xmath58 point upwards , and let  @xmath76 lie to the right of  @xmath58 .",
    "then ,  @xmath262 must lie to the right of the line through  @xmath58 , and there must exist a point  @xmath82 on  @xmath263 , such that  @xmath264 intersects  @xmath14 .    from now on , let  triangles @xmath265 form a triangulation of a simple hole - free polygon  @xmath247 , and let  @xmath107 be its corresponding dual binary tree . for simplicity we use @xmath266 to refer both to a triangle in @xmath247 and its dual node in @xmath107 .    for three non - collinear points  @xmath267 ,",
    "let @xmath268 denote the set of points covered by shifting  @xmath269 orthogonally to itself and away from  @xmath176 ( blue in fig .",
    "[ fig : confl - triang ] ) .",
    "let  @xmath270 and  @xmath271 be two triangles such that the two edges dual to  @xmath272 and  @xmath273 are on the  @xmath266-@xmath274 path in  @xmath107 .",
    "we call  @xmath266 , @xmath274 _ conflicting _ , if @xmath275 contains an interior point of  @xmath274 .",
    "[ lem : greedy - subtree ] let @xmath276 be a subtree of @xmath107 and let @xmath277 be the corresponding simple polygon dual to @xmath172 . then @xmath277 is a grr if and only if no two triangles @xmath278 in @xmath277 are conflicting .",
    "assume there are two conflicting triangles @xmath279 in @xmath172 .",
    "let @xmath280 denote the polygon defined by the @xmath266-@xmath274 path in @xmath172 and assume that the two edges dual to  @xmath272 and  @xmath273 are on the  @xmath266-@xmath274 path .",
    "since @xmath266 and @xmath274 are conflicting , there is , without loss of generality , a point @xmath9 on @xmath70 such that @xmath281 intersects an edge of @xmath274 .",
    "hence , @xmath280 is not greedy .",
    "moreover , @xmath277 is obtained from @xmath280 by adding triangles .",
    "thus lemma  [ lem : add - deg-2 ] implies that @xmath277 can not be greedy .",
    "conversely , assume @xmath277 is not greedy .",
    "there exists an outer edge @xmath58 of @xmath277 and a point @xmath76 in the interior of @xmath58 such that @xmath282 crosses another boundary edge of @xmath277 in a point @xmath257 .",
    "let @xmath283 be the triangles with @xmath284 and @xmath285",
    ". then @xmath286 and @xmath287 are conflicting .    by lemma  [ lem : greedy - subtree ] ,",
    "the decompositions of @xmath247 in @xmath91 grrs correspond bijectively to the multicuts @xmath124 of @xmath107 with @xmath127 where the terminal pairs are the pairs of conflicting triangles .",
    "we now use the 2-approximation for minimum multicuton trees  @xcite to give a @xmath248-approximation for the minimum grr decomposition of @xmath247 .",
    "let @xmath124 be a 2-approximation of minimum multicutin @xmath107 with respect to the pairs of conflicting triangles .",
    "by the above observation the minimum multicut for @xmath107 has size @xmath288 , hence @xmath289 , which in turn yields a decomposition into @xmath290 regions . thus the approximation guarantee is @xmath291 .",
    "we summarize this in theorem  [ thm : triang : decomp ] .",
    "there is a polynomial - time @xmath248-approximation for minimum grr decomposition of triangulated simple polygons .",
    "[ thm : triang : decomp ]",
    "motivated by a geographic routing protocol for dense wireless sensor networks proposed by tan and kermarrec  @xcite , we further studied the problem of finding minimum grr decompositions of polygons .",
    "we considered the special case of decomposing plane straight - line drawings of graphs , which correspond to infinitely thin polygons .",
    "for this case , we could apply insights gained from the study of self - approaching and increasing - chord drawings by the graph drawing community .",
    "we strengthened the result of tan and kermarrec  @xcite for polygons with holes by showing that partitioning a plane graph drawing into a minimum number of increasing - chord components is -hard .",
    "we then considered plane drawings of trees and showed how to model the decomposition problem using minimum multicut , which provided a polynomial - time 2-approximation .",
    "we solved the partitioning problem for trees optimally in polynomial time using dynamic programming .",
    "finally , using insights gained from the decomposition of graph drawings , we gave a polynomial - time 2-approximation for decomposing triangulated polygons along their chords .        for decomposing polygons",
    ", many problems remain open .",
    "we plan to investigate whether minimum decomposition is -hard for simple polygons for different types of allowed partition types .",
    "is finding the optimum solution hard for partitioning triangulations as in section  [ sec : triang ] ? is the minimum grr partition problem hard if we allow cutting the polygon at any diagonal ? is it hard",
    "if arbitrary polygonal cuts are allowed , i.e. , the partition can use steiner points ? finally , are there approximations for partitioning polygons with and without holes into grrs ?",
    "nllenburg , m. , prutkin , r. , rutter , i. : on self - approaching and increasing - chord drawings of 3-connected planar graphs . in : duncan , c.a . ,",
    "symvonis , a. ( eds . ) gd 2014 .",
    "lncs , vol .",
    "8871 , pp .",
    "476487 . springer ( 2014 )"
  ],
  "abstract_text": [
    "<S> a greedily routable region ( grr ) is a closed subset of  @xmath0 , in which each destination point can be reached from each starting point by choosing the direction with maximum reduction of the distance to the destination in each point of the path . </S>",
    "<S> recently , tan and kermarrec proposed a geographic routing protocol for dense wireless sensor networks based on decomposing the network area into a small number of interior - disjoint grrs . </S>",
    "<S> they showed that minimum decomposition is -hard for polygons with holes .    </S>",
    "<S> we consider minimum grr decomposition for plane straight - line drawings of graphs . here , </S>",
    "<S> grrs coincide with self - approaching drawings of trees , a drawing style which has become a popular research topic in graph drawing . </S>",
    "<S> we show that minimum decomposition is still -hard for graphs with cycles , but can be solved optimally for trees in polynomial time . </S>",
    "<S> additionally , we give a 2-approximation for simple polygons , if a given triangulation has to be respected . </S>"
  ]
}