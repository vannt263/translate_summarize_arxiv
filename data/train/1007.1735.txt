{
  "article_text": [
    "forward error correction codes designed for streaming sources require that ( a ) the channel input stream be produced sequentially from the source stream ( b ) the decoder sequentially reconsructs the source stream as it observes the channel output .",
    "in contrast , traditional error correction codes such as maximum distance separable ( mds ) codes map blocks of data to a codeword and the decoder waits until the entire codeword is received before the source data can be reproduced .",
    "rateless codes such as the digital fountain codes also do not form ideal streaming codes .",
    "first they require that the entire source data be available before the output stream is reproduced .",
    "secondly they provide no guarantees on the sequential reconstruction of the source stream .",
    "non - block codes such as convolutional codes in conjunction with sequential decoding can be designed for low delay applications  @xcite .",
    "however to our best knowledge , these constructions need to be optimized through a numerical search for finite constraint lengths .",
    "low - delay codes with feedback are recently studied in  @xcite while compression of streaming sources is studied in  @xcite .    in  (",
    "* chapter 8) a new class of codes ,   _ streaming erasure codes _ ( sco ) are proposed .",
    "the encoder observes a semi - infinite source stream  one packet is revealed in each time slot  and maps it to a coded output stream of rate @xmath0 .",
    "the channel is modelled as a burst - erasure channel .",
    "starting at an arbitrary time , it introduces an erasure - burst of maximum length @xmath1 .",
    "the decoder is required to reconstruct each source packet with a maximum delay @xmath2 . a fundamental relationship between @xmath0 , @xmath1 and @xmath2 is established and sco codes are constructed that achieve this tradeoff .",
    "we emphasize that the parity check symbols in these constructions involve a careful combination of source symbols .",
    "in particular , random linear combinations , popularly used in e.g. , network coding , do not attain the optimal performance .",
    "the sco framework however requires that the value of @xmath1 and @xmath2 be known apriori . in practice",
    "this forces a conservative design i.e. , we design the code for the worst case @xmath1 thereby incurring a higher overhead ( or a larger delay ) even when the channel is relatively good .",
    "moreover there is often a flexibility in the allowable delay .",
    "techniques such as adaptive media playback  @xcite have been designed to tune the play - out rate as a function of the received buffer size to deal with a temporary increase in delay .",
    "hence it is not desirable to have to fix @xmath2 during the design stage either .",
    "the streaming codes introduced in this work do not commit apriori to a specific delay .",
    "instead they realize a delay that depends on the channel conditions . at an information theoretic level",
    ", our setup extends the point - to - point link in  @xcite to a multicast model  there is one source stream and two receivers .",
    "the channel for each receiver introduces an erasure - burst of length @xmath3 and each receiver can tolerate a delay of @xmath4 .",
    "we investigate multicast streaming erasure code ( mu - sco ) constructions that achieve the maximum rate under these constraints .",
    "we primarily focus on a particular subclass  diversity embedded streaming erasure codes ( de - sco ) .",
    "these codes modify a single user sco such that the resulting code can support a second user , whose channel introduces a larger erasure - burst , without sacrificing the performance of the first user .",
    "our construction embeds new parity checks in an sco code in a manner such that ( a ) no interference is caused to the stronger ( and low delay ) user and ( b ) the weaker user can use some of the parity checks of the stronger user as side information to recover part of the source symbols .",
    "de - sco constructions outperform baseline schemes that simply concatenate the single user sco for the two users .",
    "an information theoretic converse establishes that de - sco achieves the minimum possible delay for the weaker receiver without sacrificing the performance of the stronger user .",
    "finally all our code constructions can be encoded and decoded with a polynomial time complexity in @xmath2 and @xmath1 .",
    "the transmitter encodes a stream of source packets @xmath5 \\}_{t \\geq 0}$ ] intended to be received at two receivers as shown in fig .  [ problemformulationfigure ] .",
    "the channel packets @xmath6 \\}_{t \\geq 0}$ ] are produced causally from the source stream , @xmath7 = f_t ( s[0],\\dots , s[t])$ ] .",
    "the channel of receiver @xmath8 introduces an erasure - burst of length @xmath3 i.e. , the channel output at receiver @xmath8 at time @xmath9 is given by    @xmath10 =   \\left\\ { \\begin{array}{ll } \\star & t \\in [ j_i , j_i + b_i - 1 ] \\\\",
    "x[t ] & \\text{otherwise } \\end{array } \\right.\\ ] ]    for @xmath11 and for some @xmath12 .",
    "furthermore , user @xmath8 tolerates a delay of @xmath4 , i.e. , there exists a sequence of decoding functions @xmath13 and @xmath14 such that @xmath15 = \\gamma_{it } ( y_1[0],y_1[1],\\dots , y_1[i+t_i ] ) , \\qquad i=1,2,\\ ] ] and @xmath16 \\neq \\hat{s}_i[t ] ) = 0 , \\ ; \\ ; \\ ; \\ ;   \\forall t \\geq 0 , \\ ; \\;$ ] .",
    "the source stream is an i.i.d",
    ".  process ; each source symbol is sampled from a distribution @xmath17 .",
    "the rate of the multicast code is defined as ratio of the ( marginal ) entropy of the source symbol to the ( marginal ) entropy of each channel symbol i.e. , @xmath18 .",
    "optimal multicast streaming erasure code ( mu - sco ) _ achieves the maximum rate for a given choice of @xmath19 .",
    "of particular interest is the following subclass .",
    "[ defn : de - sco ] consider the multicast model in fig .",
    "[ problemformulationfigure ] where the channels of the two receivers introduce an erasure burst of lengths @xmath20 and @xmath21 respectively with @xmath22 .",
    "a de - sco is a rate @xmath23 mu - sco construction that achieves a delay @xmath24 at receiver @xmath25 and supports receiver @xmath26 with delay @xmath27 .",
    "an optimal de - sco minimizes the delay @xmath27 at receiver @xmath26 for given values of @xmath20 , @xmath24 and @xmath21 .",
    "our setup generalizes the point - to - point case in  ( * ? ? ?",
    "* chapter 8) where single user sco codes for parameters @xmath28 achieve the streaming capacity @xmath29 .",
    "an optimal mu - sco construction , attains the maximum rate for fixed parameters @xmath30 .",
    "an optimal de - sco fixes the rate to the capacity of user 1 , and supports user @xmath26 with the minimum possible delay @xmath27 .",
    "note that our model only considers a single erasure burst on each channel . as is the case with ( single user )",
    "sco , our constructions correct multiple erasure - bursts separated sufficiently apart .",
    "also we only consider the erasure channel model .",
    "it naturally arises when these codes are implemented in application layer multimedia encoding .",
    "more general channel models can be transformed into an erasure model by applying an appropriate inner code  ( * ? ? ?",
    "* chapter 7 ) .",
    "we first highlight our results via a numerical example : @xmath31 and @xmath32 .",
    "single user sco constructions from  @xcite for both users are illustrated in table  [ code1224](a ) and  [ code1224](b ) respectively . in each case , the source symbol @xmath33 $ ] is split into two sub - symbols @xmath34,{\\mathsf{s}}_1[i])$ ] and the channel symbol @xmath35 $ ] is obtained by concatenating the source symbol @xmath33 $ ] with a parity check symbol @xmath36 $ ] . in the @xmath37 sco construction ,",
    "parity check symbol @xmath38 = s_1[i-1]\\oplus s_0[i-2]$ ] is generated by combining the source sub - symbols diagonally across the source stream as illustrated with the rectangular boxes .",
    "for the @xmath39 , the choice @xmath40 = s_1[i-2]\\oplus s_0[i-4]$ ] is similar , except that an interleaving of step of size @xmath26 is applied before the parity checks are produced .    how can we construct a single code that simultaneously supports both @xmath41 ? the first approach is to concatenate the two parity check streams as shown in table .  [",
    "code1224](c ) .",
    "each receiver ignores the parity check rows of the other receiver and performs single user decoding .",
    "however such a concatenated streaming code ( cc - sco ) achieves a rate of @xmath42 , whereas the optimal mu - sco construction achieves a rate of @xmath43 . before specifying the optimal mu - sco code construction ,",
    "let us first consider designing a de - sco ( see def .",
    "[ defn : de - sco ] ) for this setup .",
    "recall that this code , of rate @xmath44 , satisfies @xmath45 , also achieves minimum delay @xmath27 for @xmath46 .    [ cols=\"^,^,^,^,^,^ \" , ]     in table  [ code1225](a ) we illustrate a rate @xmath47 code that achieves @xmath48 .",
    "it is obtained by shifting the parity checks of the sco code in table  [ code1224](b ) to the right by two symbols and combining with the parity checks of the sco code in table  [ code1224](a ) i.e. , @xmath49 = p_a[i ] \\oplus p_b[i-2]$ ] .",
    "note that parity check symbols @xmath50 $ ] do not interfere with the parity checks of user @xmath25 i.e. , when @xmath51 $ ] is erased , receiver 1 can recover @xmath52 $ ] and @xmath53 $ ] from @xmath54 $ ] and @xmath55 $ ] respectively by cancelling @xmath50 $ ] that combine with these symbols .",
    "it then recovers @xmath51 $ ] .",
    "likewise if @xmath51 $ ] and @xmath56 $ ] are erased , then receiver @xmath26 recovers @xmath57,\\ldots , p_b[i+4]$ ] from @xmath58,\\ldots , q[i+6]$ ] respectively by cancelling out the interfering @xmath59 $ ] , thus yielding @xmath60 .",
    "the interference avoidance strategy illustrated above is sub - optimal .",
    "[ code1225](b ) shows the de - sco construction that achieves the minimum possible delay of @xmath61 . in this construction",
    "we first construct the parity checks @xmath62 = s_1[i-2]\\oplus s_0[i-1]$ ] by combining the source symbols along the opposite diagonal of the @xmath37 sco code in table  [ code1224](a ) . note that @xmath63 , { \\check{p}}_b[i])$ ] is also a single user @xmath37 sco code .",
    "we then shift the parity check stream to the right by @xmath64 symbols and combine with @xmath38 $ ] i.e. , @xmath49 = p_a[i ] \\oplus { \\check{p}}_b[i-3]$ ] . in the resulting code , receiver @xmath25 is still able to cancel the effect of @xmath65 $ ] as before and achieve @xmath66 .",
    "furthermore at receiver @xmath26 if @xmath51 $ ] and @xmath56 $ ] are erased , then observe that receiver @xmath26 obtains @xmath67 $ ] and @xmath68 $ ] from @xmath55 $ ] and @xmath58 $ ] respectively and @xmath69 $ ] and @xmath70 $ ] from @xmath71 $ ] and @xmath72 $ ] respectively , thus yielding @xmath73 symbols .    finally , the @xmath74 , mu - sco @xmath41 construction is as follows .",
    "split each source symbol @xmath51 $ ] into six sub - symbols @xmath67,\\ldots , s_5[i]$ ] and construct an expanded source sequence @xmath75 $ ] such that @xmath76 = ( s_0[i],s_1[i],s_2[i])$ ] and @xmath77=(s_3[i],s_4[i],s_5[i])$ ] .",
    "there exists a @xmath78 de - sco code ( see thm .",
    "[ thm : de - sco ] ) that we apply to @xmath75 $ ] to produce the parity checks @xmath79 $ ] and transmit @xmath36 = ( { \\tilde{p}}[2i],{\\tilde{p}}[2i+1])$ ] along with @xmath51 $ ] at time @xmath8 .",
    "due to the properties of the de - sco construction and our source expansion , the resulting code corrects a single erasure with a delay of @xmath26 symbols and an erasure - burst of length @xmath26 with a delay of @xmath80 .",
    "an explicit construction is provided in the full paper  @xcite due to space constraints .",
    "in this section we describe the de - sco construction .",
    "we rely on several properties of the single user sco ; see  ( * ? ? ?",
    "* chapter 7 - 8),@xcite for the background ;  @xcite for a detailed proof .",
    "[ thm : de - sco ] let @xmath81 and suppose @xmath82 where @xmath83 is any integer that exceeds @xmath25 .",
    "the minimum possible delay for any code of rate @xmath84 is @xmath85and is achieved by the optimal de - sco construction .    the converse in theorem  [ thm : de - sco ] states that the rate of any @xmath86 mu - sco with @xmath87 is strictly below @xmath0 .",
    "we establish this by constructing a periodic burst - erasure channel in which every period of @xmath88 symbols consists of a sequence of @xmath89 erasures followed by a sequence of non - erased symbols . following a similar line of reasoning as in  (",
    "* theorem 2 ) we can show that a mu - sco code corrects all erasures on this channel .",
    "the rate of the mu - sco code then must not exceed @xmath90 which is less than @xmath0 if @xmath91 .    for achievability , @xmath92 in",
    "we construct the following code :    * let @xmath93 be the single user @xmath94 sco obtained by splitting each source symbol @xmath51 $ ] into @xmath2 sub - symbols @xmath95,\\ldots , s_t[i])$ ] and producing @xmath1 parity check sub - symbols @xmath96,\\ldots , p^a_b[i])$ ] at each time by combining the source sub - symbols along the main diagonal i.e.,@xmath97 = a_{k}(s_1[i - t-(k-1)],\\ldots , s_t[i-1-(k-1)])\\ ] ] * let @xmath98 be a @xmath99 sco also obtained by splitting the source symbols into @xmath2 sub - symbols @xmath95,\\ldots , s_t[i])$ ] and then constructing a total of @xmath1 parity checks @xmath100,\\ldots , p^b_b[i])$ ] by combining the source sub - symbols along the opposite diagonal and with an interleaving step of size @xmath101 i.e.,@xmath102 = b_k(s_1[i-\\ell-(k-1)\\ell],\\ldots , s_t[i- \\ell t - ( k-1)\\ell]).\\ ] ] * introduce a shift @xmath103 in the stream @xmath50 $ ] and combine with the parity check stream @xmath104 $ ] i.e. , @xmath105 = { \\mathbf{p}}^a[i]\\oplus { \\mathbf{p}}^b[i-\\delta]$ ] .",
    "the output symbol at time @xmath8 is @xmath106 = ( s[i],{\\mathbf{q}}[i])$ ]    since there are @xmath1 parity check sub - symbols for every @xmath2 source sub - symbols it follows that the rate of the code is @xmath107 .",
    "suppose that the symbols at time @xmath108 are erased by the channel of user @xmath25 .",
    "user 1 first recovers parity checks @xmath109,\\ldots , { \\mathbf{p}}^a[i+t-1]$ ] from @xmath105,\\ldots , { \\mathbf{q}}[i+t-1]$ ] by cancelling the parity checks @xmath110 $ ] that combine with @xmath111 $ ] in this period .",
    "indeed at time @xmath112 the interfering parity check is @xmath113={\\mathbf{p}}^b[i - b-1]$ ] , which clearly depends on the ( non - erased ) source symbols before time @xmath114 .",
    "all parity checks @xmath110 $ ] before this time are also non - interfering .",
    "the erased source symbols can be recovered from @xmath109,\\ldots , { \\mathbf{p}}^a[i+t-1]$ ] by virtue of code @xmath93 .",
    "suppose that the symbols at times @xmath115 are erased for receiver 2 .",
    "the decoding proceeds as follows :    1 .   at times",
    "@xmath116 , the decoder recovers parity check @xmath117 $ ] from @xmath118 $ ] by cancelling the parity checks @xmath119 $ ] which depend only on ( non - erased ) source symbols at time @xmath8 or later .",
    "2 .   at times",
    "@xmath120 the decoder uses @xmath118 $ ] and at times @xmath121 , the decoder uses @xmath117 $ ] ( obtained in step 1 ) , to recover symbols @xmath122\\}_{\\tau",
    "= i-{\\alpha}b}^{i-1}$ ] where @xmath123=(s_1[\\tau],\\ldots , s_{t - b}[\\tau])$ ] denotes the set of _ non - urgent _ sub - symbols for @xmath98  @xcite .",
    "the decoder then retrieves symbols @xmath124 = ( s_{t - b+1}[\\tau],\\ldots , s_{t}[\\tau])$ ] for @xmath125 at time @xmath126 using the parity check symbols @xmath117 $ ] and the previously decoded non - urgent symbols .",
    "the sub - symbols @xmath127 $ ] are the urgent sub - symbols of @xmath98  @xcite .",
    "steps 1 and 3 above follow from the single user sco construction of @xmath93 and @xmath98 respectively .",
    "step 2 is established  @xcite via a recursive decoder stated in lemma  [ lem : iter ] . in the following we define @xmath128,\\ldots , s_t[i+t-1])$ ] , @xmath129,\\ldots , s_t[i\\ ! - ( t\\ ! -1)\\ell\\!])$ ] as the sub - symbols involved in   and respectively .",
    "[ lem : iter]the decoder for user 2 recovers the non - urgent symbols @xmath130 $ ] in the following order    1 .",
    "recover the non - urgent symbols in @xmath131 using the parity check symbols @xmath132\\}_{t = i+t}^{{\\mathcal{t}}-1}$ ] ; 2 .   recover the parity checks @xmath109,\\ldots , { \\mathbf{p}}^a[i+t-1]$ ] from @xmath105,\\ldots,{\\mathbf{q}}[i+t-1]$ ] .",
    "3 .   recover the non - urgent symbols in @xmath133 using the parity checks @xmath109,\\ldots , { \\mathbf{p}}^a[i+t-1]$ ] .",
    "4 .   for each @xmath134",
    "recursively recover the remaining non - urgent symbols as follows : * recover the non - urgent sub - symbols in @xmath135 using the non - urgent sub - symbols in @xmath136 and parity checks @xmath111 $ ] between @xmath137 . * recover the non - urgent sub - symbols in @xmath138 using @xmath139 and the parity checks @xmath110 $ ] between @xmath140 .",
    "+ once this recursion terminates , all the non - urgent sub - symbols @xmath122\\}_{\\tau = i-{\\alpha}b}^{i-1}$ ] are recovered by time @xmath141 .    fig .",
    "[ decodingexample ] illustrates the de - sco @xmath142 construction .",
    "each column represents one time - index between @xmath143 $ ] shown in the top row of the table .",
    "we assume that a burst - erasure occurs between time @xmath144 $ ] and only show the relevant symbols and parity - checks .",
    "each source symbol is split into seven sub - symbols , each occupying one row .",
    "each source sub - symbol has two labels - one number and one letter .",
    "the letter represents the main diagonal that passes through the sub - symbol e.g. , sub - symbols in @xmath145 are marked @xmath146 .",
    "the number represents the off - diagonal that passes through the sub - symbols e.g. , sub - symbols in @xmath147 are marked @xmath148 .",
    "the next four rows denote the parity check sub - symbols .",
    "the parity checks for @xmath93 , generated by diagonal @xmath149 , ( c.f .  ) are marked by the same letter .",
    "the four top rows , in lighter font , show the parity checks generated by the diagonal @xmath150 for @xmath98 , shifted by @xmath151 slots .",
    "these parity checks are combined with the corresponding parity checks of @xmath93 as shown in fig .",
    "[ decodingexample ] .",
    "for example the cell marked @xmath152 at time @xmath153 indicates that this sub - symbol of @xmath154 $ ] results by adding the parity check of @xmath93 , marked @xmath155 , with the parity check of @xmath98 , marked @xmath25 , at @xmath153 .",
    "we illustrate the decoding steps in lemma  [ lem : iter ] . by construction of @xmath93 all the parity checks @xmath119",
    "$ ] after time @xmath156 do not involve the erased symbols .",
    "in particular the parity checks marked by @xmath146 , @xmath157 and @xmath155 at @xmath158 can be canceled to recover parity checks marked by @xmath25 , @xmath26 , @xmath159 and more generally all @xmath117 $ ] for @xmath156 .",
    "note that this allows us to recover the non - urgent ( i.e. , the top three rows ) erased sub - symbols in @xmath160 by @xmath161 .",
    "next , compute parity checks marked by @xmath25 , @xmath26 , @xmath159 of @xmath98 in the shaded area in fig .",
    "[ decodingexample ] and cancel them and recover the parity checks marked by @xmath146 , @xmath157 and @xmath155 . at this point",
    "we have all the parity checks @xmath111 $ ] for @xmath162 .",
    "since the diagonals @xmath163 involve four or fewer erasures we can now recover these sub - symbols .",
    "the remaining non - urgent sub - symbols need to be recovered in a recursive manner .",
    "note that @xmath164 , marked by @xmath165 , has five erased symbols .",
    "however the first symbol marked by @xmath166 also belongs to @xmath167 and has already been recovered .",
    "the remaining four sub - symbols can be recovered by the four available parity checks of @xmath59 $ ] marked by @xmath165 .",
    "similarly @xmath168 , marked by @xmath169 , also has five erasures , but the first symbol @xmath170 also belongs to @xmath171 and has been recovered .",
    "hence the remaining parity checks can be recovered using the parity checks of @xmath110 $ ] .",
    "of these , by construction of @xmath98 , the non - urgent symbols will be recovered by time @xmath172 .",
    "the decoder then recovers @xmath173 and @xmath174 in the next step to recover all non - urgent sub - symbols",
    ".    to show ( 1 ) , consider a hypothetical channel that introduces an erasure burst of length @xmath175 between times @xmath176 . by construction",
    "@xcite , the sco code @xmath98 recovers the non - urgent symbols in @xmath177 via parity checks that belong to @xmath110 $ ] between @xmath178 and that do not combine with source sub - symbols after time @xmath179 . since these parity check columns are also available in step ( 1 ) the claim follows .    to show ( 2 ) , note that at the latest time , @xmath180 , via",
    ", the interfering parity check column @xmath181 $ ] is a function of the diagonal source vectors @xmath182 for @xmath183 .",
    "furthermore from the property of sco codes , any urgent symbols for @xmath98 that combine in this column must be from source sub - symbols at time @xmath184 which is strictly less than @xmath185 .",
    "the non - urgent symbols in these source vectors are recovered in step ( 1 ) .",
    "thus the parity checks @xmath110 $ ] can be canceled and the claim follows .",
    "the claim in ( 3 ) follows by noting that the parity checks in @xmath93 that yield the erased symbols in @xmath186 do not combine with source symbols that are erased before time @xmath114 and lie in the duration @xmath187 $ ] .",
    "finally we consider the recursion in step ( 4 ) .",
    "consider the case when @xmath188 . according to ind .",
    "@xmath25 the non - urgent symbols @xmath189 are available ( from step 1 ) . to recover @xmath190 , note that the only erased symbol in this vector before time @xmath114 is @xmath191 $ ] which has already been recovered in @xmath192 .",
    "hence the parity checks of @xmath93 between @xmath187 $ ] suffice to recover the remaining symbols . according to ind .",
    "2 the non - urgent sub - symbols in @xmath193 have been recovered ( in step 3 ) .",
    "furthermore in vectors @xmath194 the only erased symbols after time @xmath179 are @xmath195,\\ldots , s[i - b+{\\alpha}-2]$ ] , which are available from @xmath193 . using these the parity checks @xmath110 $ ]",
    "can be used to recover the remaining non - urgent sub - symbols in these vectors . for @xmath196 ,",
    "the vector @xmath197 has two source sub - symbols before time @xmath114 : @xmath198 $ ] , @xmath191 $ ] .",
    "since these sub - symbols also belong to @xmath199 and @xmath200 , which are recovered by @xmath188 , the remaining sub - symbols in @xmath197 can now be recovered using the parity checks of @xmath93 as stated in ind .  1 .",
    "likewise , the vectors @xmath201 in ind .",
    "2 for @xmath196 contain no more than two erased sub - symbols after time @xmath114 : these are @xmath202)$ ] to @xmath203,s_2[i - b+{\\alpha}-1)$ ] respectively .",
    "all of these belong to vectors @xmath204 which have been recovered when @xmath188 .",
    "hence the remaining non - urgent symbols in @xmath201 can now be recovered using the parity checks of @xmath110 $ ] as stated . continuing this recursion",
    ", our claim follows .",
    "the de - sco construction in the previous section simultaneously satisfies two receivers with parameters @xmath28 and @xmath205 , and @xmath206 for any integer @xmath207 with a rate @xmath208 . from the single user capacity bound ,",
    "clearly this is the maximum possible rate for any mu - sco code .",
    "furthermore @xmath209 is also optimal for any other receiver with @xmath210 .",
    "below we state the regimes in which the optimal mu - sco constructions are known  @xcite .",
    "suppose that the burst - delay parameters for user @xmath25 and @xmath26 are @xmath211 and @xmath212 respectively .",
    "suppose that @xmath205 for some integer @xmath207",
    ". then optimal mu - sco constructions are known for the following values of @xmath27 : @xmath213    the different regions in   are also summarized in fig .  [ regions ] . for clarity",
    "we ignore the integer proportionality constraints on the parameters in this figure ( extension for non - integer values is included in @xcite ) .",
    "the first case in   corresponds to regions marked ( a ) and ( b ) . in region ( a ) , the capacity can be achieved by a simpler interference avoidance construction ( illustrated in table .",
    "[ code1225](a ) ) rather than the des - co construction .",
    "region ( c ) corresponds to case @xmath26 in  .",
    "the capacity is achieved through a des - co construction for a modified value of @xmath24 .",
    "the example of @xmath214 in section  [ sec : example ] falls in this region .",
    "the full derivation is provided in  @xcite .",
    "region ( f ) corresponds to case @xmath159 in  .",
    "the capacity is achieved by a @xmath215 sco code and finally for region ( g ) , which corresponds to the last case in  , the capacity is achieved by a @xmath212 sco code . in regions ( d ) and",
    "( e ) the capacity remains open except for a special case when @xmath216 and @xmath217 where the concatenation based scheme is known to be optimal  @xcite .",
    "this paper constructs a new class of streaming erasure codes that do not commit apriori to a given delay , but rather achieve a delay based on the channel conditions .",
    "we model this setup as a multicast problem to two receivers whose channels introduce different erasure - burst lengths and require different delays .",
    "the de - sco construction embeds new parity checks into the single - user code , in a such a way that the weaker receiver can also recover the stream with an information theoretically optimum delay .",
    "mu - sco constructions that are optimal for a range of burst - delay parameters are also provided .    at a broader level ,",
    "our paper sheds insight into the interesting impact delay can have in multiuser channels",
    ". how can one order two receivers  one with a weaker channel but a relaxed delay constraint and one with a stronger channel but a stringent delay requirement ?",
    "the present paper illustrates the intricate interaction between delay and channel quality .",
    "we hope that this paper sparks further interest into this fascinating area .",
    "m.kalman ,  e.steinbach,and  b.girod ,  adaptive media playout for low - delay video streaming over error - prone channels , \" ieee trans . on circuits and systems for video technology , vol .",
    "14 , pp .",
    "841851 , 2004 ."
  ],
  "abstract_text": [
    "<S> streaming erasure codes encode a source stream to guarantee that each source packet is recovered within a fixed delay at the receiver over a burst - erasure channel . </S>",
    "<S> this paper introduces _ diversity embedded streaming erasure codes _ </S>",
    "<S> ( de - sco ) , that provide a flexible tradeoff between the channel quality and receiver delay . </S>",
    "<S> when the channel conditions are good , the source stream is recovered with a low delay , whereas when the channel conditions are poor the source stream is still recovered , albeit with a larger delay . </S>",
    "<S> information theoretic analysis of the underlying burst - erasure broadcast channel reveals that de - sco achieve the minimum possible delay for the weaker user , without sacrificing the performance of the stronger user . a larger class of multicast streaming erasure codes ( mu - sco ) that achieve optimal tradeoff between rate , delay and erasure - burst length </S>",
    "<S> is also constructed . </S>"
  ]
}