{
  "article_text": [
    "in computational combinatorics , it is important to be able to _ efficiently _ rank , unrank , and randomly generate ( uniformly ) basic classes of combinatorial objects . a ranking algorithm for a finite set @xmath4 is a bijection from @xmath4 to the set @xmath5 .",
    "an unranking algorithm is the inverse of a ranking algorithm . ranking and unranking techniques are useful for storage and retrieval of elements of @xmath4 .",
    "uniform random generation plays a role in monte carlo methods and in search algorithms such as hill climbing or genetic algorithms over classes of combinatorial objects .",
    "uniform random generation of objects is always possible if one has an unranking algorithm since one can generate , uniformly , an integer in @xmath6 and unrank .",
    "given the set @xmath7 , we consider the set @xmath8 of trees with vertex set @xmath9 .",
    "these trees are sometimes called cayley trees and can be viewed as the set of spanning trees of the complete graph @xmath10 . ranking and unranking algorithms for the set @xmath8 have been described by many authors .",
    "indeed , efficient ranking and unranking algorithms have been given for classes of trees and forests that considerably generalize the cayley trees ( e.g. , [ 3 ] , [ 4 ] , [ 5 ] , [ 6 ] , [ 7 ] ) .",
    "in this paper we consider more refined problem , namely , ranking and unranking subsets of @xmath8 with specified degree sequences or a specified multisets of degrees .",
    "the resolution of this refined problem hinges on having a bijection with certain very special properties .",
    "let @xmath11 be the set of directed trees on @xmath9 that are rooted at 1 .",
    "that is , a directed tree @xmath12 has all its edges directed towards its root 1 .",
    "we replace @xmath8 with the equivalent set @xmath11 . for any tree @xmath13 , @xmath14 .",
    "let @xmath15 be any sequence of positive integers such that @xmath16",
    ". then we let @xmath17 .",
    "it will easily follow from our results in section 2 that @xmath18 is a multiset such that @xmath19 and @xmath20 , then we let @xmath21 .",
    "it is easy to see from ( [ count1 ] ) that @xmath22 between the class of functions @xmath23 and the set @xmath11 .",
    "we shall exploit a key property of this bijection which is that for any vertex @xmath24 , @xmath25 equals that degree of @xmath24 in the tree @xmath26 when @xmath27 is considered as an undirected graph .",
    "this property allows us to reduce the problem or ranking and unranking trees in @xmath28 or @xmath29 to the problem of ranking and unranking certain set partitions .",
    "we then use known techniques for ranking and unranking set partitions @xcite .",
    "note that both the @xmath30 and @xmath31 can be as large as as the order of @xmath1 so that the numbers involved in ranking and unranking will require on the order of @xmath32 bits just to write down .",
    "we shall show that our algorithms for the ranking and unranking algorithms for @xmath28 and @xmath29 are as efficient as can be expected in that given a tree @xmath33 , it will require at most @xmath34 comparisons of numbers @xmath35 plus @xmath36 operations of multiplication , division , addition , substraction and comparision on numbers @xmath37 ( @xmath38 ) to find the rank of @xmath33 in @xmath28 ( @xmath29 ) so that it will take @xmath39 bit operations for ranking in either @xmath28 or @xmath29 . similarly , we will show that that the unranking algorithms @xmath28 or @xmath29 will reqire at most @xmath39 bit operations .",
    "the outline of this paper is as follows . in section  2",
    ", we describe the bijection @xmath40 of @xcite and discuss some of its key properties . in section  3 , we show that both @xmath41 and @xmath42 can be computed in linear time .",
    "this result allows us to reduce the problem of efficiently ranking and unranking trees in @xmath28 or @xmath29 to the problem of efficiently ranking and unranking certain classes of set partitions . in section  4",
    ", we shall give ranking and unranking algorithms for the classes of set partitions corresponding the sets @xmath28 and @xmath29 .",
    "in this section , we shall review the bijection @xmath43 due to eeciolu and remmel @xcite and give some of its properties .",
    "let @xmath44 = \\{1 , 2 , \\ldots , n\\}$ ] .",
    "for each function @xmath45 $ ] , we associate a directed graph @xmath46 , @xmath47,e)$ ] by setting @xmath48 . following @xcite , given any directed edge @xmath49 where @xmath50 , we define the weight of @xmath49 , @xmath51 , by @xmath52 where @xmath53 are variables for @xmath54 .",
    "we shall call a directed edge @xmath49 a _ descent edge _ if @xmath55 and an _ ascent edge _ if @xmath56 .",
    "we then define the weight of any digraph @xmath57 , e)$ ] by @xmath58 a moment s thought will convince one that , in general , the digraph corresponding to a function @xmath59 will consists of @xmath60 root - directed trees rooted at vertices @xmath61 and @xmath0 respectively , with all edges directed toward their roots , plus a number of directed cycles of length @xmath62 . for each vertex @xmath63 on a given cycle , there is possibly a root - directed tree attached to @xmath63 with @xmath63 as the root and all edges directed toward @xmath63 .",
    "note the fact that there are trees rooted at vertices @xmath61 and @xmath0 is due to the fact that these elements are not in the domain of @xmath46 .",
    "thus there can be no directed edges out of any of these vertices .",
    "we let the weight of @xmath46 , @xmath64 , be the weight of the digraph @xmath65 associated with @xmath46 .    to define the bijection @xmath41",
    ", we first imagine that the directed graph corresponding to @xmath66 is drawn so that    ( a ) : :    the trees rooted at @xmath0 and @xmath61 are drawn on    the extreme left and the extreme right respectively with their edges    directed upwards , ( b ) : :    the cycles are drawn so that their vertices form a directed path on    the line between @xmath0 and @xmath67 , with one back    edge above the line , and the root - directed tree attached to any vertex    on a cycle is drawn below the line between @xmath0 and    @xmath61 with its edges directed upwards , ( c ) : :    each cycle @xmath68 is arranged so that its maximum element    @xmath69 is on the right , and ( d ) : :    the cycles are arranged from left to right by decreasing maximal    elements",
    ".    figure  1 pictures a function @xmath46 drawn according to the rules ( a)-(d ) where @xmath70 .",
    "this given , suppose that the digraph of @xmath46 is drawn as described above and the cycles of @xmath46 are @xmath71 , reading from left to right .",
    "we let @xmath72 and @xmath73 denote the right and left endpoints of the cycle @xmath74 for @xmath75 .",
    "note that if @xmath74 is a 1-cycle , then we let @xmath76 be the element in the 1-cycle .",
    "@xmath27 is obtained from @xmath46 by simply deleting the back edges @xmath77 for @xmath78 and adding the directed edges @xmath79 for @xmath80 plus the directed edges @xmath81 and @xmath82 .",
    "that is , we remove all the back edges that are above the line , and then we connect @xmath0 to the lefthand endpoint of the first cycle , the righthand endpoint of each cycle to the lefthand endpoint of the cycle following it , and we connect the righthand endpoint of the last cycle to @xmath61 .",
    "for example , @xmath27 is pictured in figure  2 for the @xmath46 given in figure  1 .",
    "if there are no cycles in @xmath46 , then @xmath27 is simply the result of adding the directed edge @xmath83 to the digraph of @xmath46 .    ]    to see that @xmath41 is a bijection , we shall describe how to define @xmath42 .",
    "the key observation is that we need only recover that the directed edges @xmath79 for @xmath80 .",
    "however it is easy to see that @xmath84 is the largest element on the path from @xmath0 to @xmath61 in the tree @xmath27 .",
    "that is , @xmath85 is then largest element in its cycle and by definition , it is larger than all the largest elements in any other cycle so that @xmath85 must be the largest interior element on the path from @xmath0 to 1 .",
    "then by the same reasoning , @xmath86 is the largest element on the path from @xmath85 to 1 , etc .",
    "thus we can find @xmath87 .",
    "more formally , given a tree @xmath88 , consider the path @xmath89 where @xmath69 is the maximum interior vertex on the path from @xmath90 to @xmath61 , @xmath91 .",
    "if @xmath92 is an edge on this path , then it is understood that @xmath93 consists of just one vertex and we define @xmath94 .",
    "note that by definition @xmath95 .",
    "we obtain the digraph @xmath96 from @xmath33 via the following procedure .",
    "+   + * procedure for computing @xmath97 *    \\(1 ) first we declare that any edge @xmath98 of @xmath33 which is not an edge of the path from @xmath0 to @xmath67 is an edge of @xmath96 .",
    "+   + ( 2 ) next we remove all edges of the form @xmath99 or @xmath100 for @xmath91 .",
    "+   + finally for each @xmath24 with @xmath91 , we consider the subpath @xmath101 .",
    "+   + ( 3 ) if @xmath102 , create a directed loop @xmath103 .",
    "+   + ( 4 ) if @xmath104 , convert the subpath @xmath101 into the + directed cycle @xmath105 .",
    "+   + next we consider two important properties of the bijection @xmath41 .",
    "first @xmath41 has an important weight preserving property .",
    "we claim that if @xmath106 , then @xmath107 that is , by our conventions , any backedge @xmath108 are descent edges so that its weight is @xmath109 .",
    "thus the total weight of the backedges is @xmath110 our argument above shows that all the new edges that we add are also descent edges so that the weight of the new edges is @xmath111 since all the remaining edges have the same weight in both the digraph of @xmath46 and in the digraph @xmath27 , it follows that @xmath112 as claimed .",
    "it is easy to see that @xmath113.\\ ] ] thus we have the following result which is implicit in @xcite and it explicit in @xcite .    [ weightthm1 ] @xmath114.\\ ] ]    next we turn to a second key property of the @xmath41 bijection .",
    "it is easy to see from figures 1 and 2 that deleting the back edges @xmath77 for @xmath78 in @xmath65 and adding the directed edges @xmath79 for @xmath80 plus the directed edges @xmath81 and @xmath82 to get @xmath27 does not change the indegree of any vertex except vertex 1 .",
    "that is , @xmath115 it is also easy to see that in going from @xmath65 to @xmath27 , the indegree of vertex 1 increases by 1 , i.e. , @xmath116 when we consider @xmath27 as an undirected graph @xmath33 , then it is easy to see that @xmath117 .",
    "thus since the outdegree of @xmath24 in @xmath27 is 1 if @xmath118 and the outdegree of 1 in @xmath27 is zero , equations ( [ deg1 ] ) and ( [ deg2 ] ) imply the following theorem .",
    "[ degthm ] suppose that @xmath33 is the undirected tree corresponding to @xmath27 where @xmath59 , then for @xmath119 , @xmath120    _ proof _ by our definition of @xmath65 , it follows that @xmath121 for @xmath119 .",
    "thus by ( [ deg1 ] ) , for @xmath122 , @xmath123 similarly by ( [ deg2 ] ) , @xmath124 @xmath125",
    "in this section , we shall briefly outline the proof that one can compute the bijections @xmath41 and its inverse in linear time .",
    "suppose we are given @xmath59 .",
    "our basic data structure for the function @xmath46 is a list of pairs @xmath126 for @xmath127 .",
    "our goal is to construct the directed graph of @xmath27 from our data structure for @xmath46 , that is , for @xmath54 , we want to find the set of pairs , @xmath128 , such that there is directed edge from @xmath24 to @xmath129 in @xmath27 .",
    "we shall prove the following .",
    "[ linbij ] we can compute the bijection @xmath40 and its inverse in linear time .    _",
    "_ we shall not try to give the most efficient algorithm to construct @xmath27 from @xmath46 .",
    "instead , we shall give an outline the basic procedure which shows that one can construct @xmath27 from @xmath46 in linear time .",
    "for ease of presentation , we shall organize our procedure so that it makes four linear time passes through the basic data structure for @xmath46 to produce the data structure for @xmath27 .",
    "+   + * pass 1 . *",
    "_ goal : find , in linear time in @xmath0 , a set of representatives @xmath130 of the cycles of the directed graph of the function @xmath46 .",
    "_ + to help us find @xmath130 , we shall maintain an array @xmath131 , a[3 ] , \\cdots a[n-1]$ ] , where for each @xmath24 , @xmath132=(c_i , p_i , q_i)$ ] is a triple of integers such @xmath133 and @xmath134 .",
    "the @xmath68 s will help us keep track of what loop we are in relative to the sequence of operations described below .",
    "then our idea is to maintain , through the @xmath135 and @xmath136 , a doubly linked list of the locations @xmath24 in @xmath137 where @xmath138 , and we obtain pointers to the first and last elements of this doubly linked list .",
    "it is a standard exercise that these data structures can be maintained in linear time .",
    "initially , all the @xmath68 s will be zero .",
    "in general , if @xmath138 , then @xmath135 will be the largest integer @xmath67 such that @xmath139 for which @xmath140 if there is such a @xmath67 and @xmath141 otherwise . similarly , we set @xmath142 to be the smallest integer @xmath143 such that @xmath144 for which @xmath145 if there is such a @xmath143 and @xmath146 if there is no such @xmath143 .",
    "if @xmath147 , then @xmath148 is the smallest integer @xmath149 such that @xmath140 and @xmath150 if there is no such integer @xmath67 .",
    "if @xmath151 , then @xmath152 is the largest integer @xmath153 such that @xmath145 and @xmath154 if there is no such integer @xmath143 .",
    "we initialize @xmath137 by setting @xmath131=(0,-1,q_{2})$ ] , @xmath132=(0,i-1,i+1)$ ] for @xmath155 , and @xmath156=(0,p_{n-1},-1)$ ] . if @xmath157 then @xmath158 and @xmath159 .",
    "otherwise ( @xmath160 ) , these quantities are both @xmath161 .",
    "+   + * loop(1 ) : * start with @xmath162 , setting @xmath163 .",
    "compute @xmath164 , each time updating @xmath137 by setting @xmath165 and adjusting pointers , until , prior to setting @xmath166 , we discover that either +   + ( 1 ) @xmath167 , in which case we have reached a node in @xmath168 which is not in the domain of @xmath46 and we start over again with the @xmath60 replaced by the smallest @xmath24 for which @xmath138 , or +   + ( 2 ) @xmath169 already satisfies @xmath170 .",
    "this condition indicates that the value @xmath171 has already occurred in the sequence @xmath172 .",
    "then we set @xmath173 .",
    "+   + * loop(2 ) : * start with @xmath174 which is the location of the first @xmath24 such that @xmath138 , and repeat the calculation of loop1 with @xmath175 instead of @xmath162 . in this manner ,",
    "generate @xmath176 , each time updating @xmath137 by setting @xmath177 and adjusting pointers , until either +   + ( 1 ) @xmath178 , in which case we have reached a node in @xmath168 which is not in the domain of @xmath46 and we start over again with the @xmath175 replaced by the smallest @xmath24 for which @xmath138 , or +   + ( 2 ) @xmath179 already satisfies @xmath180 .",
    "( this condition indicates that the value @xmath171 has already occurred in the sequence @xmath181 . )",
    "then we set @xmath182 .",
    "+   + we continue this process until @xmath183 . at this point",
    ", we will have generated @xmath130 , where the last loop was loop(@xmath184 ) .",
    "the array @xmath137 will be such that , for all @xmath185 , @xmath186 identifies the loop in which that particular domain value @xmath24 occurred in our computation described above .",
    "+   + * pass 2 . *",
    "_ goal : for @xmath187 , find the largest element @xmath69 in the cycle determined by @xmath129 .",
    "_ + it is easy to see that this computation can be done in linear time by one pass through the array @xmath137 computed in pass 1 above . at the end of pass 2 , we set @xmath188 .",
    "thus when we draw the cycle containing @xmath129 according to our definition of @xmath189 , @xmath69 will be right most element in the and @xmath190 will be the left most element of the cycle containing @xmath129 .",
    "however , at this point , we have not ordered the cycles appropriately .",
    "this ordering will be done in the next pass . +   + * pass 3 . *",
    "_ goal : sort @xmath191 so that they are appropriately ordered according the criterion for the bijection @xmath27 as described in by condition ( a ) -(d)_. +   + since we order the cycles from left to right according to decreasing maximal elements , it is then easy to see that our desired ordering can be constructed via a lexicographic bucket sort .",
    "( see williamson s",
    "book @xcite for details on the fact that a lexicographic bucket sort can be carried out in linear time . ) +   + * pass 4 . *",
    "_ goal : construct the digraph of @xmath27 from the digraph of @xmath46 .",
    "_ +   + we modify the table for @xmath46 to produce the table for @xmath27 as follows .",
    "assume that @xmath191 is the sorted list coming out of pass 3 .",
    "then we modify the table for @xmath46 so that we add entries for the directed edges @xmath192 and @xmath193 and modify entries of the pairs starting with @xmath194 so that their corresponding second elements are @xmath195 respectively .",
    "this can be done in linear time using our data structures .",
    "next , consider the problem of computing the inverse of @xmath41 .",
    "suppose that we are given the data structure of the tree @xmath196 , i.e. we are given a set of pairs , @xmath197 , such that there is a directed edge from @xmath24 to @xmath129 in @xmath33 .",
    "recall that the computation of @xmath96 consists of two basic steps .",
    "+   + * step 1 . * given a tree @xmath12 , consider the path @xmath89 where @xmath69 is the maximum interior vertex on the path from @xmath90 to @xmath61 , @xmath91 .",
    "if @xmath92 is an edge on this path , then it is understood that @xmath93 consists of just one vertex and we define @xmath94 .",
    "note that by definition @xmath95 .",
    "+   + first it is easy to see that by making one pass through the data structure for @xmath198 , we can construct the directed path @xmath199 where @xmath200 . in fact , we can construct a doubly linked list @xmath201 with pointers to the first and last elements in linear time .",
    "if we traverse the list in reverse order , @xmath202 , then it easy to see that @xmath203 , @xmath204 is the next element in the list @xmath205 which is greater than @xmath206 and , in general , having found @xmath207 , then @xmath90 is the first element in the list @xmath208 which is greater than @xmath69 .",
    "thus it is not difficult to see that we can use our doubly linked list to produce the factorization @xmath89 in linear time .",
    "+   + * step 2 .",
    "* we obtain the digraph @xmath96 from @xmath33 via the following procedure .",
    "+   + * procedure for computing @xmath209 *    \\(1 ) first we declare that any edge @xmath98 of @xmath33 which is not an edge of the path from @xmath0 to @xmath61 is an edge of @xmath96 .",
    "+   + ( 2 ) next we remove all edges of the form @xmath99 or @xmath100 for @xmath91 .",
    "+   + finally for each @xmath24 with @xmath91 , we consider the subpath @xmath101 . +   + ( 3 ) if @xmath102 , create a directed loop @xmath103 . +   + ( 4 ) if @xmath104 , then , convert the subpath @xmath101 into the + directed cycle @xmath105 .",
    "+   + again it is easy to see that we can use the data structure for @xmath33 , our doubly linked list , and our path factorization , @xmath210 to construct the data structure for @xmath65 where @xmath211 in linear time .",
    "@xmath125 .",
    "given that we can carry out the bijection @xmath41 and its inverses in linear time , it follows that in linear time , we can reduce the problem of constructing ranking and unranking algorithms for @xmath11 to the problem of constructing ranking and unranking algorithms for the corresponding function class @xmath212 . in the next section",
    ", we will construct our desired ranking and unranking algorithms for the function classes corresponding to sets of trees @xmath28 and @xmath29 described in the introduction .",
    "recall that if @xmath13 , then @xmath14 .",
    "let @xmath15 be any sequence of positive integers such that @xmath16 .",
    "then we define @xmath213 .",
    "similarly if @xmath214 is a multiset such that @xmath215 and @xmath20 , then we define @xmath216 .",
    "the main goal of this section is to construct @xmath217 time algorithms for ranking and unranking trees in @xmath28 and @xmath29 .",
    "so assume that @xmath218 is a sequence of positive integers such that @xmath219 . by theorem [ degthm ]",
    ", it follows that if @xmath220 , then @xmath221 for @xmath222 .",
    "it follows that @xmath223 since a function @xmath59 is clearly determined by the sequence @xmath224 , it follows from our results in section 2 that the problem of finding an algorithms to rank and unrank trees @xmath28 can be reduced to the problem of ranking and unranking ordered set partitions @xmath225 of @xmath226 where the sizes of the sets are specified .",
    "that is , we need to find an algorithm to rank and unrank ordered set partitions in @xmath227 , the set of all sequences of pairwise disjoint sets @xmath225 such that @xmath228 and @xmath229 for @xmath230 .",
    "the total number of elements in @xmath227 is clearly the multinomial coefficient @xmath231 .",
    "thus our first step is to develop a simple algorithm to rank and unrank objects corresponding to a product of binomial coefficients @xmath232 .    for a single binomial coefficient @xmath233 , we shall rank and unrank the set @xmath234 of decreasing functions @xmath235 relative to lexicographic order .",
    "a number of authors have developed ranking and unranking algorithms for @xmath234 .",
    "we shall follow the method of williamson @xcite .",
    "first , we identify a function @xmath235 with the decreasing sequence @xmath236 where @xmath237 .",
    "we can then think of the sequences as specifying a node in a planar tree @xmath238 which can be constructed recursively as follows .",
    "at level 1 , the nodes of @xmath238 are labeled @xmath239 from left to right specifying the choices for @xmath240 .",
    "next below a node @xmath67 at level one , we attach a tree corresponding to @xmath241 where a tree @xmath242 consists of a tree with a single vertex labeled @xmath243 .",
    "figure 3 pictures the tree @xmath244 .",
    "then the decreasing sequence ( 6,2,1 ) corresponds to the node which is specified with an arrow .",
    "it is clear that the sequences corresponding to the nodes at the bottom of the tree @xmath244 appear in lexicographic order from left to right .",
    "thus the rank of any sequence @xmath245 is the number of nodes at the bottom of the tree to the left of the node corresponding to @xmath246 .",
    "hence the sequence @xmath247 has rank 10 in the tree @xmath244 .",
    "this given , suppose we are given a sequence @xmath236 in @xmath238 .",
    "then the number of leaves in the subtrees corresponding the nodes @xmath248 are respectively @xmath249 . thus the total number of leaves in those subtrees is @xmath250 here we have used the well known identity that @xmath251 .",
    "it follows that the rank of @xmath236 in @xmath238 equals @xmath252 plus the rank of @xmath253 in @xmath254 .",
    "the following result , stated in @xcite , then easily follows by induction .",
    "note that @xmath269 .",
    "thus we can use @xmath270 as the set of objects corresponding to a product of binomial coefficients .",
    "we shall idenitfy an element @xmath271 with a sequence @xmath272 and rank these sequences according to lexicographic order . to define our ranking and unranking proceedure for this set of sequences , we first need to define a product relation on planar trees .",
    "given a rooted planar tree @xmath33 , let @xmath273 be the numbers of leaves of @xmath33 and @xmath274 be the set of paths which go from the root to a leaf . then for any path @xmath275 , we define the rank of @xmath276 relative to @xmath33 , @xmath277 , to be the number of leaves of @xmath33 that lie to the left of @xmath276 .    given two rooted planar trees @xmath278 and @xmath279",
    ", @xmath280 is the tree that results from @xmath278 by replacing each leaf of @xmath278 by a copy of @xmath279 , see figure 3 .",
    "if the vertices of @xmath278 and @xmath279 are labeled , then we shall label the vertices of @xmath280 according to the convention that each vertex @xmath63 in @xmath278 have the same label in @xmath280 that it has in @xmath278 and each vertex @xmath281 in a copy of @xmath279 that is decendent from a leaf labeled @xmath282 in @xmath278 has a label @xmath283 where @xmath284 is the label of @xmath281 in @xmath279 . given",
    "rooted planar trees @xmath285 where @xmath286 , we can define @xmath287 by induction as @xmath288 .",
    "similarly if @xmath289 are labeled rooted planar trees , we can define the labeling of @xmath287 by the same inductive process .",
    "now suppose that we are given two rooted planar trees @xmath278 and @xmath279 and suppose that @xmath290 and @xmath291 .",
    "then we define the path @xmath292 in @xmath280 which follows @xmath293 to its leaf @xmath282 in @xmath278 and then follows @xmath294 in the copy of @xmath279 that sits below leaf @xmath282 to a leaf @xmath295 in @xmath280 .",
    "similarly , given paths @xmath296 for @xmath297 , we can define a path @xmath298 by induction as @xmath299 .",
    "first suppose that @xmath305 and that @xmath293 is a path that goes from the root of @xmath278 to a leaf labeled @xmath306 and @xmath294 goes from the root of @xmath279 to a leaf labeled @xmath307 .",
    "thus @xmath292 goes from the root of @xmath280 to the leaf @xmath308 in @xmath278 and then proceeds to the leaf @xmath309 in @xmath280 .",
    "now for each leaf @xmath310 to the left of @xmath308 in @xmath279 , there are @xmath311 leaves of @xmath280 that lie to left of @xmath309 coming from the leaves of the copy of @xmath279 that sits below @xmath310 .",
    "thus there are a total of @xmath312 such leaves .",
    "the only other leaves of @xmath280 that lie to left of @xmath292 are the leaves of the form @xmath313 where @xmath314 is to left of @xmath294 in @xmath279 .",
    "there are @xmath315 such leaves .",
    "thus there are a total of @xmath316 leaves to left of @xmath292 and hence @xmath317 as desired .",
    "it follows that ranking and unranking our sequences @xmath272 coresponding to an element @xmath324 , we need only rank and unrank the leaves with respect to the tree @xmath325 that is , consider a path @xmath326 . for each @xmath24",
    ", @xmath135 corresponds to a sequence @xmath327 in @xmath328 and hence @xmath276 corresponds to the sequence @xmath329    we are now in position to give an algorithm to rank and unrank ordered set partitions in @xmath227 , the set of all sequences of pairwise disjoint sets @xmath225 such that @xmath228 and @xmath229 for @xmath230 . since the total number of elements in @xmath227 is clearly the multinomial coefficient @xmath231 , we shall identify an ordered set partition @xmath330 with an element @xmath331 as follows .",
    "suppose that @xmath332 and @xmath333 .",
    "note that @xmath334 so that this is a possible degree sequence for a tree in @xmath335 .",
    "for example , the tree @xmath336 pictured in figure 5 has this degree sequence when considered as a tree .",
    "note that in this case , @xmath337 .",
    "also in figure 5 , we have pictured the graph of @xmath338 and in this case @xmath339 it will be more efficient for our ranking and unranking procedure to order the set partition by increasing size of the parts . thus we will make one pass through the to extract the @xmath340 for each @xmath24 and its relative rank for those parts of the same size . in this case , we would produce the following list + @xmath341 .",
    "+ here for example , then entry @xmath342 means that the size of @xmath343 is 2 and there is one element @xmath344 such that @xmath345 .",
    "we can then do a lexicographic bucket sort to produce a list of the elements according to lexicographic order on the last two entries of this list in linear time , see @xcite .",
    "thus in our example we would produce the following list .",
    "+ @xmath346 .",
    "+ the set partition corresponding to this order is @xmath347 we can ignore the @xmath348 s and just consider the reduced partition @xmath349 more generally , let @xmath350 .",
    "let @xmath351 be an ordered set partition of @xmath352 where each block @xmath353 is nonempty and ordered in decreasing order , @xmath354 , that comes from some element @xmath355 in @xmath356 as described above .",
    "let @xmath357 be the ordered sequence of ranks of the respective @xmath358 in @xmath352 .",
    "in general , let @xmath359 be the ranks of the respective @xmath360 in @xmath361 . for @xmath362 , + @xmath363 can be considered an element of @xmath364 + @xmath365 can be considered an element of @xmath366 + @xmath367 can be considered an element of @xmath368 + @xmath369 can be considered an element of @xmath370 + @xmath371 can be considered an element of @xmath372 + thus we can think of @xmath362 as the sequence @xmath373 coming from an element of @xmath374 or as a leaf in the tree @xmath375 .",
    "note that the size of the trees needed for the product lemma , lemma [ prodrank ] , are + @xmath376 , + @xmath377 , + @xmath378 , + @xmath379 , + @xmath380 .",
    "+ thus we can apply lemma [ prodrank ] and conclude that the @xmath381 by theorem [ rankdecfn ] , we have that @xmath382 thus @xmath383 hence the tree @xmath384 pictured in figure 5 has rank 35,601 among all the trees + @xmath385 .",
    "if we are given , the degree sequence @xmath386 , we can assume that we preprocess the sizes of the trees needed to apply the product lemma , lemma [ prodrank ] .",
    "thus we need only compute @xmath36 products , additions , and multinomial coefficients .",
    "again given , @xmath386 , we can construct a table of all the possible binomial coefficients that we need as part of the preprocessing .",
    "thus to find the rank of tree @xmath384 requires only a linear number of muliplications , additions and table look ups for numbers @xmath37 .",
    "since each @xmath171 requires at most @xmath387 bits , it is easy to see that these operations require at most @xmath39 bit operations .",
    "the only other contribution to the complexity of the algorithm is the time it takes go from the representation of the tree to the corresponding rank sequences @xmath388 it is easy to see from the fact that we can compute @xmath42 in linear time that we can start with a tree and produce the ordered set partition @xmath389 in linear time .",
    "thus to complete our analysis of the the complexity of the ranking prodeedure , we need to know the complexity of the transformation between the @xmath390 and ranks @xmath391    [ rankthm ] let @xmath350 .",
    "let @xmath390 be an ordered partition of @xmath352 where each block @xmath353 is nonempty and ordered in decreasing order , @xmath392 .",
    "let @xmath357 be the ordered sequence of ranks of the respective @xmath358 in @xmath352 .",
    "in general , let @xmath359 be the ranks of the respective @xmath360 in @xmath361 .",
    "given the sequences @xmath359 , @xmath393 , the sets partition @xmath394 can be constructed in worst case time @xmath39 .",
    "conversly , given the set partition @xmath394 the sequences @xmath359 , @xmath393 can be constructed in worst case time @xmath39 .    _",
    "proof_. first we can make one pass through the list and set @xmath395 so @xmath390 become an ordered partition of @xmath396 .",
    "conversly , we can go from an ordered set partition @xmath390 of @xmath396 to an ordered set partition of @xmath226 by setting @xmath397 .",
    "thus there is no loss in assuming that @xmath390 is an ordered partition of @xmath396 .",
    "this given , it will then be the case that @xmath398",
    ". then it will take @xmath36 comparisions of numbers less than or equal to @xmath0 to construct a sequence @xmath399 where @xmath400",
    ". then it will take @xmath32 steps to create the sequences @xmath401 for @xmath402 where @xmath403 .",
    "it then easily follows that we have reduced the problem to finding the transformation from the ranks @xmath359 , @xmath404 , to set partitions @xmath405 which we can do by recursion .",
    "it then easily follows that given the set partition @xmath394 the sequences @xmath359 , @xmath393 can be constructed in worst case time @xmath39 and that given the @xmath359 , @xmath393 , we can construct the set partition @xmath394 in worst case time @xmath39 .",
    "@xmath125      the unranking procedure for @xmath406 comes from simply reversing the ranking procedure using theorem [ unrankdecfn ] and lemma [ produnrank ] .",
    "again we will exhibit the procedure by finding the tree @xmath278 whose rank is 50,005 in @xmath407 .",
    "the first step is to carry out the series of quotients and remainders according to lemma [ produnrank ] . in our case",
    ", this leads to the following calculations . @xmath408",
    "it then follows that we can construct the sequence corresponding to @xmath409 by concatonating the sequences @xmath410 where    1 .",
    "@xmath411 is the decreasing function of rank 6 in @xmath364 , 2 .",
    "@xmath412 is the decreasing function of rank 22 in @xmath366 , 3 .",
    "@xmath413 is the decreasing function of rank 2 in @xmath368 , 4 .",
    "@xmath414 is the decreasing function of rank 5 in @xmath370 and 5 .",
    "@xmath415 is the decreasing function of rank 0 in @xmath372 .      to find the element @xmath417 of rank 22 in @xmath366 , we use the procedure in theorem [ unrankdecfn ] .",
    "we start by setting @xmath418 and @xmath419 . since @xmath420 , then @xmath421 and hence @xmath422 .",
    "then we set @xmath423 and @xmath424 .",
    "since @xmath425 , we get that @xmath426 or @xmath427 .",
    "thus @xmath428 has rank 22 in @xmath366 .    to find the element @xmath417 of rank 2 in @xmath368",
    ", we again use the procedure in theorem [ unrankdecfn ] .",
    "we start by setting @xmath429 and @xmath419 . since @xmath430 , then @xmath431 and hence @xmath432 .",
    "then we set @xmath433 and @xmath424 .",
    "since @xmath425 , we get that @xmath426 or @xmath427 .",
    "thus @xmath434 has rank 2 in @xmath368 .    to find the element @xmath417 of rank 5 in @xmath370",
    ", we again use the procedure in theorem [ unrankdecfn ] .",
    "we start by setting @xmath429 and @xmath419 . since @xmath435 , @xmath436 and hence @xmath437 .",
    "then we set @xmath438 and @xmath424 .",
    "since @xmath439 , we get that @xmath440 or @xmath441 .",
    "thus @xmath442 has rank 2 in @xmath370 .",
    "finally there is only one element in @xmath372 which is @xmath443 .",
    "since the last step is alway trivial , it is most efficient to have the last sequence be as long as possible .",
    "this is why we order the sizes of the set partition by increasing order .",
    "thus the sequence corresponding to the tree @xmath409 is @xmath444 it is easy to reconstruct @xmath409 from this sequence and hence @xmath445 it then follows that @xmath446 the function @xmath447 corresponding to @xmath448 and its image under @xmath41 are pictured in figure 6 .",
    "the problem of ranking and unranking trees with a given multiset of degrees is just an extension of the the problem ranking and unranking trees with a given sequence of degrees .",
    "that is , the distribution of degrees is just another set partition .",
    "for example , consider the sequence of degrees for the tree @xmath384 pictured in figure 5 , @xmath449 .",
    "we can view that sequence as a set partition , @xmath450 where @xmath451 is the set of places where @xmath24 appears in the sequence @xmath386 . in our example",
    ", we would identify @xmath386 with the set partition @xmath452    just as in the case where we ranked and unranked set partitions associated with trees in @xmath28 , it is more efficient if we rearrange the set partition by increasing size .",
    "this means that we must have a data structure to record the degrees associated with the set partition which in this case is just the triples @xmath453 .",
    "it is easy to see that we can produce such a list in linear time from the tree . in our example",
    ", we would produce the list @xmath454 using a lexicographic bucket sort algorithm @xcite , we can sort this list according to the lexicographic order on the last two entries of the triples to produce the list @xmath455 then we use this ordering to produce an ordered set partition @xmath456 where we ignore any empty partitions . in our example , we would produce @xmath457 finally , we use this set partition to produce a sequence of decreasing functions .",
    "that is , we let @xmath458 .",
    "let @xmath459 be an ordered set partition of @xmath460 where each block @xmath461 is nonempty and ordered in decreasing order , @xmath462 , that comes from some element @xmath355 in @xmath456 as described above .",
    "let @xmath357 be the ordered sequence of ranks of the respective @xmath463 in @xmath460 .",
    "in general , let @xmath359 be the ranks of the respective @xmath464 in @xmath465 .",
    "for our example , + @xmath466 can be considered an element of @xmath467 + @xmath468 can be considered an element of @xmath469 + @xmath470 can be considered an element of @xmath471 + @xmath472 can be considered an element of @xmath473 .",
    "+ thus we produce the sequence @xmath474 to code the sequence @xmath386 which can be considered an element of @xmath475 .",
    "we can then concatenate this sequence @xmath476 with the sequence @xmath362 to produce a sequence @xmath477 . in our example , @xmath478 coming from an element of @xmath479 or as a leaf in the tree @xmath480 note that the size of the trees needed for the product lemma , lemma [ prodrank ] , are + @xmath376 , + @xmath377 , + @xmath378 , + @xmath481 + @xmath482 , + @xmath483 + @xmath484 , + @xmath485 + @xmath486 , + @xmath487 + @xmath488 , + @xmath489 + @xmath490 , + @xmath491 + @xmath492 .",
    "+ thus there are a total of 1,197,504,000 trees in @xmath493 whose degree sequence yields the multiset @xmath494 .",
    "we can then use the product lemma , lemma [ prodrank ] , to compute the rank of @xmath384 in @xmath495 as follows .",
    "@xmath496 by theorem [ rankdecfn ] , we have that + @xmath497 , + @xmath498 , + @xmath499 , + @xmath500 , + @xmath501 , + @xmath502 , + @xmath503 , + @xmath504 . +",
    "thus @xmath505 thus the tree @xmath384 pictured in figure 5 has rank 843,342,641 among all the trees @xmath506 .",
    "the unranking procedure for @xmath29 comes from simply reversing the ranking procedure using theorem [ unrankdecfn ] and lemma [ produnrank ] .",
    "again we will exhibit the procedure by finding the tree @xmath279 whose rank is 60,000,00 in @xmath507 .",
    "the first step is to carry out the series of quotients and remainder according to lemma [ produnrank ] . in our case",
    ", this leads to the following calculations . @xmath508",
    "it then follows that we can construct the sequence corresponding to @xmath509 by concatonating the sequences @xmath510 where    1 .",
    "@xmath511 is the decreasing function of rank 6 in @xmath467 , 2 .",
    "@xmath512 is the decreasing function of rank 0 in @xmath469 , 3 .",
    "@xmath513 is the decreasing function of rank 16 in @xmath471 , 4 .",
    "@xmath514 is the decreasing function of rank 0 in @xmath515 and 5 .",
    "@xmath516 is the decreasing function of rank 5 in @xmath364 .",
    "@xmath517 is the decreasing function of rank 2 in @xmath366 .",
    "@xmath518 is the decreasing function of rank 18 in @xmath368 .",
    "@xmath519 is the decreasing function of rank 0 in @xmath370 .",
    "@xmath520 is the decreasing function of rank 0 in @xmath372 .",
    "+ it is clear that the sequence of rank 6 in @xmath467 is @xmath416 and the sequence of rank 0 in @xmath469 is @xmath521 .",
    "+   + to find the element @xmath522 of rank 16 in @xmath471 , we use the procedure in theorem [ unrankdecfn ] .",
    "we start by setting @xmath523 and @xmath524 . since @xmath525 , then @xmath526 and hence @xmath527 .",
    "then we set @xmath528 and @xmath529 .",
    "since @xmath530 , then @xmath531 and hence @xmath532 .",
    "finally we set @xmath533 and @xmath424 .",
    "since @xmath534 , we get that @xmath535 or @xmath536 .",
    "thus @xmath537 has rank 16 in @xmath471 .",
    "+   + it is clear that the sequence of rank 0 in @xmath515 is @xmath538 .",
    "+   + next it is clear that element of rank 5 in @xmath364 is @xmath539 .",
    "+   + to find the element @xmath417 of rank 2 in @xmath366 , we use the procedure in theorem [ unrankdecfn ] .",
    "we start by setting @xmath429 and @xmath419 . since @xmath430 , then @xmath431 and hence @xmath432 .",
    "then we set @xmath540 and @xmath424 .",
    "since @xmath425 , we get that @xmath426 or @xmath427 .",
    "thus @xmath434 has rank 2 in @xmath366 .",
    "+   + to find the element @xmath417 of rank 18 in @xmath368 , we again use the procedure in theorem [ unrankdecfn ] .",
    "we start by setting @xmath541 and @xmath419 . since @xmath542 , then @xmath543 and hence @xmath544 .",
    "then we set @xmath545 and @xmath424 .",
    "since @xmath546 , we get that @xmath547 or @xmath548 .",
    "thus @xmath549 has rank 18 in @xmath368 .",
    "+   + finally the sequence of rank 0 in @xmath368 is clearly @xmath550 and the element of rank 0 in @xmath372 is @xmath551 .",
    "+   + thus the sequences corresponding to the set partitions @xmath476 and @xmath552 are @xmath553          we note that essentially the same analysis of the complexity of ranking and unranking relative @xmath28 applies to the complexity of ranking and unranking relative to @xmath29 for any multiset @xmath4 so that it requires @xmath39 bit operations to rank and unrank relative @xmath29 .",
    "o. eeciolu , j. b. remmel and s. g. williamson , _ a class of graphs which has efficient ranking and unranking algorithms for spanning trees and forests _ , to appear in the international journal of the foundations of computer science ."
  ],
  "abstract_text": [
    "<S> in this paper , we provide algorithms to rank and unrank certain degree - restricted classes of cayley trees . </S>",
    "<S> specifically , we consider classes of trees that have a given degree sequence or a given multiset of degrees . using special properties of a bijection due to eeciolu and remmel @xcite , we show that one can reduce the problem of ranking and unranking these classes of degree - restricted trees to corresponding problems of ranking and unranking certain classes of set partitions . </S>",
    "<S> if the underlying set of trees have @xmath0 vertices , then the largest ranks involved in each case are of order @xmath1 so that it takes @xmath2 bits just to write down the ranks . </S>",
    "<S> our ranking and unranking algorithms for these degree - restricted classes are as efficient as can be expected since we show that they require @xmath3 bit operations if the underlying trees have @xmath0 vertices . </S>"
  ]
}