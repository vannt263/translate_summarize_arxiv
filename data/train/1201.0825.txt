{
  "article_text": [
    "while profound connections between computer programs and mathematical proofs have been studied and are known ( e.g. the curry - howard correspondence ) , little has been done to connect the two fields at the level of empirical practice .",
    "we present an experimental approach to the question of optimal proving times for automatic theorem provers , which bears out calude and stay s theoretical findings that programs either stop quickly or never halt @xcite .    working with self - delimiting programs , that is , programs that are not the beginning of any other valid programs , chaitin defined the complexity of the runtime of a program which eventually halts that we can not effectively compute @xcite , and calude and stay",
    "have recently proven @xcite that even though short programs can run for a very long time , long programs are the scarcest because most of them will stop rather quickly  if they ever do  depending on their length .",
    "thus , the probability of a machine halting decreases the longer it takes to halt , if it ever does .",
    "just as calude and stay suggest that most turing machines are fully determined qua termination by a small number of computational steps , and that the error margin drops drastically , in @xcite we have also shown that turing machines are fully determined qua extensionality by a small number of initial input values ( a theoretical value for the error margin has yet to be determined but the very few data points that we could generate suggest to follow at least a polynomial distribution ) .",
    "we undertake an experimental approach to the runtimes of deterministic turing machines up to three states and two symbols in connection , and empirical evidence , to calude and stay s theoretical results .",
    "then we undertake the same experimental approach to formulas of predicate calculus , in order to find some ( if any ) evidence in favour of a possible similar non - linear phenomenon in the distribution of proof lengths of ( dis)proven theorems in random axiom systems and turing machines .",
    "traditional intuition might make one think this an ill - fated approach . on the one hand because undecidability would interfere in any such experimental attempt , and on the other hand , because small systems may say more about design choices than about important results . even though possible limiting effects may appear",
    "right away one can limitedly circumvent these limits ( as the busy beaver problem does ) in an effort tantamount to other interesting experiments including some of calude s own interest @xcite or of my own @xcite , this latter providing useful applications for the evaluation of the algorithmic complexity of short strings difficult to calculate with the other alternative ( lossless compression algorithms ) . with the intuition one",
    "gets from studying small systems ( see @xcite ) , it seems worth it and insightful to undertake these kind of experiments .",
    "the halting problem for turing machines involves deciding whether an arbitrary turing machine @xmath0 eventually halts on an arbitrary input @xmath1 .",
    "one can ask whether there is a turing machine halt @xmath0 which , given code @xmath2 and the input @xmath1 , eventually stops and produces 1 if @xmath3 stops , and 0 if @xmath3 does not stop .",
    "turing s seminal result states that this problem can not be solved by any turing machine , i.e. there is no such halt @xmath0 .",
    "halting can be recognized by simply running the machine in question ; the main difficulty is to detect non - halting machines .",
    "since many real - world problems arising in the fields of compiler optimization , automatized software engineering , formal proof systems , and so forth are deeply connected to the halting problem , there is an interest in understanding the problem in order to translate theoretical results into practical applications .    in @xcite , it was observed that for any computable probability distribution , most long times are effectively rare , so that at the limit they all had the same behavior regardless of the choice of distribution .",
    "they proved that the exact time at which a program stops is not too complicated algorithmically .",
    "it is ( algorithmically ) non - random because most programs either stop ` quickly ' or never halt . since non - random times",
    "are ( effectively ) rare , according to calude and stay , the density of times at which an @xmath4-bit program can stop decreases quickly .",
    "there are @xmath5 possible @xmath6 deterministic turing machines with @xmath7 states and 2 symbols .",
    "we denote by @xmath8 the class ( or space ) of all @xmath7-state @xmath9-symbol turing machines having a bidirectional tape and remaining on the same cell when entering the ( additional to @xmath7 ) halting state . among the machines that halt ,",
    "there are some that print more 1s on their output tapes than any other turing machines of the same size , and some that reach a maximum number of steps upon halting .    if @xmath10 is the number of 1s on the tape of a turing machine @xmath11 upon halting , then : @xmath12 with @xmath7 the number of states of the turing machine .",
    "if @xmath13 is the number of steps that a machine @xmath11 takes upon halting , then @xmath14 with @xmath7 the number of states of the turing machine .",
    "@xmath15 and @xmath16 are noncomputable functions @xcite by reduction to the halting problem .",
    "yet values are known for @xmath6 with @xmath17 .",
    "the solution for @xmath6 with @xmath18 is trivial ; the process leading to the solution in @xmath19 is discussed by lin and rado @xcite ; and the process leading to the solution in @xmath20 is discussed in @xcite .",
    "it is easy to see that @xmath21 and @xmath22 .",
    "lin and rado @xcite proved @xmath23 and brady @xcite that @xmath24 .",
    "the exact known values for @xmath25 are @xmath26 , @xmath27 , @xmath28 , @xmath29 .",
    "these busy beaver values are for 2-symbol turing machines .",
    "these numerical values of the busy beaver functions have been calculated by a combination of techniques , notably the exhaustive simulation of a reduced number of non - equivalent turing machines , as it turns out that many can be decided ( e.g. evident loops , etc ) and because the number of cases is small enough one can either analyse case by case or actually run the machines and analyse their behaviour until deciding whether it halts or not .",
    "this is evidently possible because of the relatively small number of turing machines with up to the number of states for for which the values of the busy beaver functions are known .    a program showing the evolution of all known busy beaver machines developed by this paper s authors is available online @xcite .",
    "the formalism followed in this paper is the same as the one originally described and followed for the busy beaver problem as introduced by rado @xcite .",
    "it is worth noting that the busy beaver problem is defined for turing machines with initial empty tapes , and turing machines studied in this paper are all provided with an initially empty tapes too .",
    "turing universality tells us , however , that for every turing machine with an arbitrary input there is a turing machine with empty input computing the same function , hence turing machines with empty tapes cover all possible cases ( the translation may only result in some extra states ) .",
    "calude and stay showed that  long - running \" turing machines can only halt at non - random times ; the density of non - random times near @xmath7 is about @xmath30 .  long - running \"",
    "means that if we have a universal turing machine @xmath31 and machine @xmath0 is implemented by a program @xmath9 for @xmath31 of length @xmath7 , then @xmath32 runs for more than @xmath33 steps , where @xmath34 is some uncomputable constant depending on @xmath31 .",
    "we know that a machine halts if it enters the halting state before reaching the known busy beaver value @xmath16",
    ". if it does not , then it never halts .",
    "the halting problem and the halting probability problem are closely related to the busy beaver problem in that a solution to any one of them would yield a solution to each of the others .",
    "consider the halting space of all @xmath35 turing machines ( with an extra halting state ) provided with an empty tape .",
    "the table in fig . [ rundist ] shows the runtime distribution at which all machines in @xmath35 halt ( or do not ) .",
    "[ rundist ] @xmath36    there are 10000 2-state , 2-symbol turing machines ( the 10000 figure comes simply from the formula giving the number of turing machines with @xmath37 states @xmath5 ) .",
    "no other turing machine halts after @xmath38 steps ( see fig . [ rundist ] ) in @xmath35 .",
    "machines that never halt are @xmath39 in number , representing around @xmath40 of the total .    what we term a runtime space is the product of a class of @xmath8 turing machines for fixed @xmath7 and @xmath9 , where programs are uniformly distributed , and the time space , which is discrete , has a halting time mapped to a greyscale color ( the lighter the color , the sooner it halted ; white means the program never halted and red means it reached the busy beaver value @xmath16 ) .    [ haltingspectra ]   ( the last color is red , visible in the online and printed versions only).,title=\"fig : \" ]    [ peanopacking1 ]   compressed in a peano curve packing array ( preserving the enumeration distance between machines ) . some clusters may emerge due to the enumeration ( e.g. terms involving transition rule parameters grouping turing machines ) . the plot may look as if it had less than the necessary rows and columns to represent all the 10000 turing machines , but that is a consequence of the peano packing , each apparent pixel is in fact a small cluster of several machines.,title=\"fig:\",height=288 ]    each point in fig . [ peanopacking1 ] represents a turing machine and as defined by the corresponding spectrum in fig .",
    "[ haltingspectra ] , the lighter the square the sooner it halted .",
    "white cells represent machines that do nt halt .",
    "red cells ( only visible in the online and color printed versions ) show the busy beaver machines ( for this space , with runtime @xmath27 steps ) .    among all the @xmath41 turing machines in @xmath35 that halt ,",
    ".65 of them do so after the first step , @xmath42 do so after the second , @xmath43 after the third , and so on .",
    "in other words , @xmath44 out of the @xmath41 @xmath35 turing machines that halted did so at the first step , @xmath45 halted before or by the second step at the latest , @xmath46 before or by the third step at the latest , and so on ( see fig . [ accumulated ] ) .",
    "[ tm32 ] @xmath47     that halt step by step versus @xmath48 ( dark line ( blue in color version)).,height=192 ]    [ accumulated ]   ( left ) and @xmath19 ( right ) that halt step by step.,title=\"fig:\",height=137 ]   ( left ) and @xmath19 ( right ) that halt step by step.,title=\"fig:\",height=137 ]    interesting output distribution facts :    * out of 7529536 machines only 2146912 halt .",
    "* there are 5382624 machines that do not halt .",
    "* those machines that halt only produce @xmath49 different output strings , with the largest being @xmath38 digits in length ( the busy beavers ) . *",
    "exactly @xmath42 of the turing machines produce a @xmath50 or a @xmath51 as output .",
    "the fact that the figures are mostly white and lightly colored is an indicator of the sparsity of non - halting or quickly - halting machines .    .",
    "last color in the spectrum is red ( only visible in the online and color printed versions ) ]    [ deepfield ]    .",
    "the @xmath19 busy beavers are barely visible as isolated red points ( online and color printed versions only).,height=288 ]     zoom from a 10th .",
    "square area of the original ( fig .",
    "[ deepfield ] ) image.,height=259 ]",
    "inspired by @xcite where wolfram undertakes an exhaustive investigation of the space of propositional logic formulas , i extended his ideas to investigate the space of first order logic .",
    "the extension was nt trivial , among other reasons because unlike propositional calculus , predicate calculus is undecidable , meaning that one may come across cases where formulas ( or their negations ) are not proven or disproven in an axiom system of first order logic .",
    "proof lengths are , of course , not bounded , or one would be able to decide whether a formula in an axiom system can be proven or not if it has reached a limit .",
    "frequency of proof lengths for randomly generated formulas , however , can be studied and analyzed .",
    "frequency distributions of ( dis)proven formulas turn out to follow a similar distribution to those of randomly generated computer programs , in which most programs , just as we found for formulas , halt ( or are ( dis)proven ) quickly , with their number diminishing fast over time . when i met cris calude and became acquainted with his fascinating work , including a recent collaboration with michael stay on the distribution of halting times of random computer programs @xcite , it prompted me to seek connections with these other findings  persuaded as i was of the strong connections known to exist between computation and proof theory  and to undertake an empirical investigation of both the halting runtimes of turing machines that calude and stay had calculated theoretically , and the lengths of proofs found by automatic theorem provers .",
    "it follows from chaitin @xcite and calude and stay @xcite that to ( dis)prove a formula in an axiom system one only needs to check up to the runtime for which the turing machine encoding the proof no longer halts .",
    "busy beavers , as used in the previous section , are therefore relevant to automatic theorem proving because they provide an upper bound on the length of proofs .",
    "one only needs to run the computer to ( dis)prove the formula up to the busy beaver value of the size of the turing machine , and if it can not be proven by then then it is undecidable for that axiom system .",
    "moreover , calude and stay s work may then suggest that chances of proving a formula should decrease over time , or that if a formula can be ( dis)proven it will likely do so early in time rather than later meaning that one can set an optimal time for a given provability certainty goal .",
    "optimal proving times are relevant because , on the one hand , they may allow one to set a maximum waiting time , given that proofs may never arrive if a theorem is undecidable in an axiom system , but also because one would know how long to wait before giving up with a certain degree of certainty of provability .",
    "if one had a goal ( say to prove a fraction of .90 of a set of formulas ) one could calculate an optimal timeout and a maximum waiting time , taking advantage of the fact that in the case of theorem provers running on digital computers , there is a correspondence between runtime and proof length .",
    "the numbers involved are so large and grow so fast because of the combinatoric explosion ( in the number of formulas as well as the number of turing machines ) .",
    "we were only able to explore the tip of the iceberg of the space of all possible first - order formulas , but with interesting and encouraging results nonetheless .",
    "a number of sound and complete calculi have been developed enabling fully automated theorem provers for first - order logic .",
    "equational logic is quite simple , and yet powerful @xcite .",
    "its atomic formulas are equations , making it very easy to encode and deal with . in our formalism , terms are first - order formulas built from variables and constants using function symbols .",
    "equalities of the form @xmath52 are the atomic formulas in our language , where @xmath53 and @xmath54 are terms .",
    "one can represent most mathematical axiom systems and theorems in equational form , so it is expressively very rich . a logical system which possesses an explicitly stated set of axioms from which theorems can be derived is an axiomatic system .    in predicate calculus ,",
    "a formula is in _ prenex _ normal form if it can be written as a string of quantifiers followed by a quantifier - free part .",
    "all first - order well - formed formulas ( hereafter simply ` formulas ' ) are logically equivalent to some formula in _ prenex _ normal form .",
    "_ skolemization _ is a way of removing existential quantifiers from a formula .",
    "variables bound by existential quantifiers which are not within the scope of universal quantifiers can simply be replaced by the appropriate constants . both will be used in order to enumerate all possible quantified axioms and formulas of first order logic .",
    "all equational formulas can be represented with two binary operators @xmath55 and @xmath56 , where @xmath56 is a pairing function and @xmath55 is an indexing operator ( any possible binary function ) .",
    "the first parameter of @xmath55 will be a constant determining its index , while the second is any other term ( variable , constant , @xmath55 itself or @xmath56 ) .",
    "when the existential quantifier is inside a universal quantifier , the bound variable must be replaced by a skolem function of the variables bound by universal quantifiers .",
    "we can then specify any constant using a formula of the form : @xmath57 . and",
    "the @xmath58th constant can be defined in terms of @xmath55 and @xmath56 recursively as follows :     +    or in a single @xmath59 expression :    to represent all possible functions one can combine both @xmath55 and @xmath56 . for instance , @xmath60 is the expression representing the @xmath61-th function ( the function with index @xmath61 ) of @xmath1 .",
    "this assumes that there are an infinite number of individuals in the most general case .",
    "notice that @xmath1 may be a list built from pairs .",
    "formulas were enumerated and generated by the number of variables and constants on both sides of the equality .",
    "there are no formulas of length 1 , simply because an equality requires at least 2 terms on each side .",
    "finally , all single axioms were arranged by length .",
    "the length of an equational formula is the sum of the bound variables on both sides of the equality .",
    "axiom systems are simply all the possible subsets over the formulas of fixed length .",
    "applying this operation makes the number of axiom systems to grow exponentially , so we were able to proceed exhaustively only up to 3 bound variables formulas and to generate a sample of 1000 axiom systems only ( an initial segment ) for 4 bound variables formulas .",
    "an automatic theorem prover was fed with all 4 bound variable single formulas as its proving goal for each of the generated axiom system , producing almost @xmath62 proofs . among the initial 1000 axiom systems , 607 were used only , as they were proven to be consistent ( no axiom was the negation of any other ) and independent ( no axiom could be derived from the others ) .",
    "an example of a formula with 3 bound variables is : @xmath63 and with four : @xmath64 .",
    "an example of an axiom system consisting of 2 axioms each with 2 bound variables is : @xmath65 .",
    "notice that one does not need to further compose @xmath55 with @xmath56 or @xmath56 with @xmath55 in order to produce other possible formulas , because @xmath55 is a general function with an index as first parameter and any term as second parameter which can be @xmath56 or @xmath55 itself , without the need of infinitely nesting each into the other in order to reach other possible constructions .",
    "the project was undertaken using _ mathematica _ s built - in implementation of the well known and award - winning theorem prover _",
    "_ waldmeister__. _ waldmeister _ returns true after evaluating an expression in _ mathematica _ if it can prove the conclusions from the given axioms , and false if it can prove that the conclusions do not follow from the axioms .",
    "if it can not prove either , it returns unevaluated .",
    "the axiom systems generated  as described in section [ intro]were first checked for logical consistency and internal axiom independence , these being two of the most important qualities of conventional mathematical axiom systems .",
    "@xmath66 is said to be consistent if no theorem and its negation can be derived from @xmath66 . on the other hand ,",
    "if @xmath66 is an axiom system and @xmath67 , then a is considered independent in @xmath66 , or an independent axiom of @xmath66 if @xmath68 can not be derived from @xmath69 . as with any axiomatic system , we want this axiomatic system to be minimal , i.e. to contain no superfluous axiom . from this point on",
    ", only consistent axiom systems were taken into account . +",
    "miscellaneous interesting first results :    * it was found that only @xmath70 out of a total of @xmath71 axiomatic systems with 1 or 2 axioms of length up to 3 bound variables were non - independent , i.e. one of its members could be derived from a combination of the others . * all the @xmath72 axiomatic systems of length 3 with 2 or more axioms were independent . this could be explained by the way in which the axiomatic systems were enumerated , because axioms closer to each other in the enumeration seem to have a better chance of being derived from each other .",
    "the condition of being a theorem or an axiom is evidently an arbitrary convention . *",
    "the number of consistent axiom systems of length 3 was only @xmath73 percent of a total of @xmath74 initial axiomatic systems .",
    "* in the case of axiom systems of length 4 ( composed by formulas of that size ) , @xmath75 of them were found to be consistent .",
    "this may be interpreted in two different ways : that even when the complexity of the axiom systems grows , the overall inconsistency does not increase , or else that the process only unveils the tip of the iceberg , where they are consistent chiefly due to their simplicity ( both in terms of number of axioms per axiom system and the length of the axioms themselves , thereby reducing the possible number of clashes ) .",
    "the relation between the length of the formulas and the optimal runtime limit is of particular utility when no upper bound is known ( or possible ) , when , for example , there are non - provable formulas for which longer runtimes will not make any difference  which , as verified herein , would cover a negligible number of cases .    a total of 89145 formulas out of the 97727 with at most 4 variables were proven to be theorems ( or their negations ) after a single step .",
    "one can call such a theorem _ trivial _ simply because its proof , requiring only 1 step , can be accomplished with an axiom , therefore itself being an axiom .",
    "the proof length ( @xmath76 ) distribution ( in percentage ) of formulas with up to 4 variables is as shown in fig .",
    "[ theo ] .",
    "[ theo ] @xmath77    proof length distribution of ( dis)proven theorems . where @xmath76 is the number of steps the theorem prover has taken to produce the proof , @xmath78 the number of machines that halted at @xmath76 , and @xmath79 is the halting probability of having ( dis)proven @xmath80 theorems in time @xmath76 from which one can build a probability distribution @xmath79 .",
    "it is worth noting that the behavior of [ theo ] graph resembles the first case of @xmath35 turing machines , where the number of machines that halted was not strictly decreasing ( unlike @xmath19 that was monotonically decreasing ) .",
    "already @xmath81 out of the total number of theorems are proven by the very first step , with that number dropping as the total is approached . from the distribution",
    "it follows that going beyond the 7th .",
    "step to the 17 steps that require the longest proofs only adds @xmath82 new ( dis)proven formulas to the total .",
    "summary of proving times :    * a total of @xmath83 formulas out of @xmath84 were immediately proved ( or disproved ) after the first step ( i.e. @xmath85 ) .",
    "* @xmath86 were proven after @xmath87 steps , and @xmath88 formulas were proven after @xmath89 steps ( which is almost half of the @xmath90 maximum number of steps reached by the formulas with @xmath91 bound variables ) .",
    "that is , @xmath92 of the total .",
    "* letting the theorem prover run up to @xmath90 steps only generates @xmath93 new proofs , that is only @xmath94 of the total .",
    "[ truthspace ]     axis ) against 161 formulas ( @xmath95 axis ) from formulas with 4 bound variables .",
    "every dot is a proof , a black square indicates that a particular theorem holds in a particular axiom system ( which explains the diagonal , among other patterns ) and white means the formula was proven to be false in the corresponding axiom system ( i.e. the negation is a theorem ) .",
    "no undecidable candidate was found.,height=136 ]        [ godelspace ]    .,height=141 ]    as for turing machines ( see fig .",
    "[ deepfield ] ) , the space of proof lengths ( fig .",
    "[ godelspace ] ) is mostly white and lightly colored as an indicator of the sparsity of long proof lengths given that most formulas are ( dis)proven very quickly , suggesting that the distribution of proof lengths follows the distribution of program runtimes .",
    "[ limit2 ]    @xmath96",
    "as for busy beaver turing machines , the values of which depend on the size of the turing machines ( states and symbols ) , proof lengths depend on the length of the formulas .",
    "one can define _ busy beaver formulas _ ( the values of which will be denoted by @xmath97 ) as the formulas for which an automatic theorem prover takes more time to ( dis)prove whether a theorem is decidable , or to produce the longest proof , among all the formulas of a fixed length . unlike turing machines , however , the size of a formula can take many forms , and may depend on the number of bound variables ( as was the case in the experiments undertaken here ) , the number of logical operators or the number of symbols in general .",
    "it also depends on the formalism , just as busy beavers depend on the formalism used by rado @xcite . following the analogy",
    ", the values of @xmath97 would therefore work in a similar way and may be used just as busy beaver turing machine values are currently used  for defining maximum runtimes and maximum output lengths for ( small ) turing machines , saving time once an upper limit is known .",
    "the exact relation would also save considerable computational resources in automatic theorem proving .    as explained",
    "before , the theoretical algorithmic analysis in @xcite indicates that a program that has not stopped after running for a long time has smaller and smaller chances of eventually stopping , so the longer the time @xmath76 the more unlikely the program is to halt .",
    "calude and stay s results can be interpreted as follows : most turing machines are fully determined qua termination by a small number of computational steps , and the error margin upon betting that a turing machine will halt drops exponentially . because proofs are programs for automatic theorem prover and one can connect this interpretation to the probability of a formula to be ( dis)proven in an axiom system with a confidence error margin to be proven dropping fast .",
    "let the `` optimal timeout '' be the number of steps for which a fraction of formulas from a set of fixed length is ( dis)proven .",
    "evidently , proving time is asymptotically optimal , in the sense that the closest to the maximum runtime ( the busy beaver formula values ) , the greatest the fraction of ( dis)proven formulas .",
    "an optimal time @xmath98 for a given goal @xmath99 implies that upon @xmath76 one has reached a fraction @xmath99 of ( dis)proved formulas .",
    "thus @xmath100 , where @xmath7 is the length of the set of formulas , @xmath99 the desired fraction of ( dis)proved formulas and @xmath101 the number of formulas proven at time @xmath102 .",
    "obviously @xmath103 for each time @xmath104 , and @xmath105 if @xmath106 , that is , if the fraction of formulas to be ( dis)proved is 1 ( i.e. if the goal is to ( dis)prove all the formulas of a fixed length ) .    just as with busy beavers , the exact value of @xmath107 is uncomputable and unpredictable in general , but one can approach it .",
    "for example , in our formalism , for 4 bound variables it can be calculated from the probability distribution in [ limit2 ] .",
    "one can ascertain , for example , that from a uniform distribution of randomly generated formulas , nearly .90 of the formulas will be proven after the first step . and that the number of new proofs from then on will rapidly drop as a function of the number of steps .",
    "the value of @xmath107 can also determine a timeout for single formulas , given a confidence expectation . which is to say that a single formula has , for example , a .90 chance of being ( dis)proven in the first step , and that it has diminishing possibilities , if any , of being ( dis)proven thereafter .",
    "we think that the results are robust enough to model specifications of theorem provers , despite not being completely independent .",
    "we were able to verify the results using another very different theorem prover , the automatic proof search or apros @xcite for propositional logic and predicate calculus ( the theorem prover deals , however , with all sorts of other classical and non - classical calculus ) .",
    "apros uses the intercalation method to search for normal natural deduction proofs not requiring a language in which the atomic formulas are identities , unlike _",
    "waldmeister_. notice that for this new case , the definition of the length of formulas was adjusted to the new framework , given that since the prover calculus does not require equality , no sense can be given to left or right hand sides .",
    "the set of randomly chosen operators used to generate formulas were the classic _ and _ , _ or _ , _ implies _ and _ double implies_. apros found proofs for .12 of the assertions ( and for .353 of a set of assertions with no - double conditionals ) , out of a random choice of 1000 automatically generated predicate calculus assertions with up to 4 quantifiers , 3 general functions , 3 logical operators and 3 variables .",
    "the longest proof length ( runtime ) was 42 with an average proof length of 13 , and a distribution very close to the one described by _",
    "waldmeister _ using _",
    "a logically significant question concerns the structure of the theorems established .",
    "if significant structural features are uncovered , then one could generate randomly formulas of that structure and repeat the proof length and runtime distribution experiments",
    ". it would be quite interesting , if one could find , for example , systematic biases for different theorem provers and theorem proving techniques when deviating in distribution from each other .",
    "one can continue the process of generalizing theoretical results from computer programs to proof lengths and seek the equivalent of busy beavers in sets of well defined proofs and theorem provers .",
    "just as for larger busy beaver turing machine values , the computer time and resources to explore much larger sets of proofs are out of reach .",
    "the experiments suggest that the statistics for theorem proving times from randomly generated formulas may follow a similar trend to the distribution of runtimes of random computer programs . and that when searching for proofs , appropriate timeouts can be set and optimal waiting times defined depending on the size of the formulas as it has been determined that runtimes depend on the size of machines .",
    "it is too soon , however , to declare any true resemblance and there are always dangers of extrapolating from the behavior of small systems .",
    "i am grateful to cris calude who encouraged me to publish these results in connection with his own work @xcite .",
    "i am also indebted to stephen wolfram , todd rowland and matthew szudzik for their support and guidance during and after the 2005 nks summer school at brown university , when i started this project as part of a 3-week summer project and inspired by stephen wolfram s own work in @xcite , intending to extend his results from propositional logic to predicate calculus .",
    "i am also grateful to j .- p .",
    "delahaye with whom i ve undertaken related research @xcite , studying the output distribution of abstract computing machines . to wilfried sieg for his guidance and for introducing me to apros , which i used to strengthen the experimental results in this paper while a visiting scholar at carnegie mellon , and to jeremy avigad who brought me to carnegie mellon . and to the anonymous referee .",
    "any error or omission remains , of course , the sole responsibility of this author .",
    "brady , the determination of the value of rado s noncomputable function for four - state turing machines , _ math .",
    "_ 40 , pp . 647665 , 1983 .",
    "p. baumgartner and h. zhang , on using ground joinable equations in equational theorem proving , proceedings of the 3rd international workshop on first order theorem proving ( st andrews , scotland ) , fachberichte informatik 5/2000 , pp .",
    "3343 , universitt koblenz - landau , 2000 .",
    "c. calude , m.j .",
    "dinneen and c .- k .",
    "shu , computing a glimpse of randomness , _ experimental mathematics _",
    "calude , m.a .",
    "stay , most programs stop quickly or never halt , _ advances in applied mathematics , _ 40 , pp .",
    "295308 , 2005 . g. j. chaitin , computing the busy beaver function . in information , randomness & incompleteness , pp . 7476 , 1984 .",
    "chaitin , a theory of program size formally identical to information theory , j. acm 22 , pp . 329340 , 1975 .",
    "delahaye and h. zenil , numerical evaluation of algorithmic complexity for short strings : a glance into the innermost structure of randomness , forthcoming in _ applied mathematics and computation , _ 2011 .",
    "j. joosten , f. soler - toscano and h. zenil , program - size versus time complexity , speed - up and slowdown phenomena in small turing machines , _ international journal of unconventional computing _ , 2011 .",
    "t. rado , on non - computable functions , bell system technical j.41 , pp . 877884 , 1962 .",
    "w. sieg , the apros project : strategic thinking & computational logic . _ logic journal of the igpl , _",
    "15(4 ) : pp . 359368 , 2007 .",
    "s. lin and t. rado , computer studies of turing machine problems .",
    "_ j. acm _ 12 , pp . 196212 , 1965 .",
    "a. voronkov , the next _ waldmeister _ loop , proceedings of the 18th international conference on automated deduction , ( copenhagen , denmark ) , pp .",
    "486 - 500 , _ lecture notes in artificial intelligence _ 2392 , springer - verlag .",
    "s. wolfram , _ a new kind of science .",
    "_ wolfram media , 2002 .",
    "zvonkin and l.a .",
    "levin , the complexity of finite objects and the development of the concepts of information and randomness by means of the theory of algorithms .",
    "russian math . surveys , 25(6 ) : pp . 83124 , 1970 . h. zenil , `` busy beaver '' , from the _ wolfram demonstrations project _"
  ],
  "abstract_text": [
    "<S> this paper is an experimental exploration of the relationship between the runtimes of turing machines and the length of proofs in formal axiomatic systems . </S>",
    "<S> we compare the number of halting turing machines of a given size to the number of provable theorems of first - order logic of a given size , and the runtime of the longest - running turing machine of a given size to the proof length of the most - difficult - to - prove theorem of a given size . </S>",
    "<S> it is suggested that theorem provers are subject to the same non - linear tradeoff between time and size as computer programs are , affording the possibility of determining optimal timeouts and waiting times in automatic theorem proving . </S>",
    "<S> i provide the statistics for some small choices of parameters for both of these systems . </S>",
    "<S> + * keywords * : halting problem , halting probability , proof length , automatic theorem proving , busy beaver problem , program - size complexity , small turing machines . </S>"
  ]
}