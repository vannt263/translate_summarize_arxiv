{
  "article_text": [
    "this paper examines two formulas for computing entries in the character table ( hereafter called _ character values _ ) of the symmetric group , @xmath4 , from the standpoint of computational complexity .",
    "the formulas that we consider are the classical murnaghan - nakayama rule @xcite and the rule recently discovered by roichman @xcite for the kazhdan - lusztig characters of @xmath1 hecke algebras of type @xmath2 .",
    "the discussion is motivated by a remark in @xcite , in which the authors state that they are unaware of a comparison of the two rules in terms of algorithmic complexity , and that  one would expect that they have the same complexity \" .",
    "the irreducible characters of @xmath0 are a distinguished set of class functions @xmath5 ( for a complete description see * ? ? ?",
    "a character value of @xmath4 is indexed by an ordered pair @xmath6 of partitions of @xmath7 and is denoted by @xmath8    a formula for @xmath9 suggests a systematic way for computing character values  an algorithm whose input is a pair of partitions @xmath6 and whose output is the integer @xmath10 .",
    "it is such an algorithm s computational complexity that is examined for each of the two rules .",
    "the rest of the paper is organized as follows : in section [ sec : mn ] we present the murnaghan - nakayama rule and specify an algorithm based on it . in section [ sec : roi ] we treat roichman s rule similarly .    section [ sec : instance ] gives the complexity of computing a single character value using each of the two algorithms .",
    "two enumeration problems , of young diagrams and of young tableaux , occur in the dominant factors in the complexity of the murnaghan - nakayama rule ( eq .  [ eq : tmn ] ) and roichman s rule ( eq .  [ eq : troi ] ) , respectively .",
    "finally , in section [ sec : comp ] , we compare the algorithms in terms of their worst - case complexity on the family of characters indexed by partitions in the @xmath11 hook .      given @xmath7 and partitions @xmath12 and @xmath13 of @xmath7 we show that :    1 .",
    "the running time of our murnaghan - nakayama - based algorithm is , up to a factor of order @xmath7 , the number of young diagrams that are contained in the young diagram of @xmath12 and satisfy an additional constraint determined by @xmath13 ( see proposition [ pr : tmn1 ] ) .",
    "lemma [ le : r_la ] gives a determinantal formula for this number when the constraint is empty .",
    "the running time of the algorithm based on roichman s rule is , up to a factor of order @xmath7 , the number of standard young tableaux whose shape is contained in the young diagram of @xmath12 that satisfy an additional constraint determined by @xmath13 ( see proposition [ pr : troi ] ) . by lemma [ le : q_la ] , when the constraint is empty , this number is @xmath14 , where @xmath15 is the degree of @xmath12 , that is the number of standard young tableaux of shape @xmath12 .",
    "given @xmath16 and @xmath17 , worst - case analysis of the family of characters where the choice of @xmath12 is restricted to the @xmath11 hook shows that in this case the murnaghan - nakayama - based algorithm s complexity is @xmath18 ( see proposition [ pr : klhookmn ] ) whereas the complexity of the algorithm based on roichman s rule is in @xmath19 for some constant @xmath20 ( see proposition [ pr : klhookroi ] ) .    some experimental results for characters not in the above family are also included in subsection [ sub : generaldiagrams ] .",
    "a shape @xmath21 is said to be _ edgewise connected _ if @xmath22 and for all @xmath23 @xmath24 ( i.e. each cell is exactly one horizontal or vertical step away from its predecessor ) .",
    "for example , @xmath25 is edgewise connected , but @xmath26 is not .",
    "let @xmath27 .",
    "a skew diagram @xmath28 is said to be a _ rim hook _ of @xmath12 if @xmath29 is edgewise connected and contains no @xmath30 subset of cells ( ( 2,2 ) ) . in this case",
    "we write @xmath31 and say that @xmath13 is obtained by _ removing _ the rim hook @xmath29 from @xmath12 . for example , if @xmath32 , then @xmath33 is a rim hook of @xmath12 , but @xmath34 are not : the former is not edgewise connected , and the latter contains a @xmath30 block .",
    "the _ leg length of a rim hook _",
    "@xmath29 is @xmath35    let @xmath36 denote the partition @xmath37 .",
    "note that the notation @xmath38 is reserved for skew diagrams , while @xmath39 and @xmath40 are always ordinary diagrams .",
    "the following is the classical recursive formula for computing characters of @xmath0 .",
    "[ t : mn ] let @xmath41 .",
    "then @xmath42 where the sums runs over all rim hooks @xmath29 of @xmath12 having @xmath43 cells , and @xmath44 .",
    "a proof appears in @xcite .",
    "[ ex : mn ] calculating @xmath10 where @xmath45 and @xmath46 .",
    "the computation process can be viewed as a tree .",
    "the appropriate signs appear beside the arrows indicating the removal of rim hooks .",
    "@xmath47 @xmath48      computing the sum in requires enumerating all rim hooks of certain length of a given partition .",
    "this is done using partition sequences ( @xcite , @xcite ) .    a _ partition sequence _",
    "@xmath49 is a doubly infinite sequence of binary digits starting with an infinite sequence of zeros and ending with an infinite sequence of ones .",
    "for example , @xmath50 where the dots at the beginning ( end ) represent an infinite sequence of * 0*s ( * 1*s ) , is a partition sequence",
    ".    we shall refer to the finite subsequence of @xmath49 starting with the first * 1 * and ending with the last * 0 * as the _ essential part of @xmath49 _ , which we will denote by @xmath51 .",
    "given a partition @xmath52 , its partition sequence is defined as @xmath53    for example , the partition sequence of @xmath45 is @xmath54    the graphic version of this construction is a walk along the borderline of @xmath12 , coming form the south on the vertical line , going along the border and leaving on the horizontal line eastwards , recording each vertical step by a * 0 * and each horizontal step by a * 1*. in our example , the borderline of the young diagram of @xmath45 is @xmath55 which indeed gives the sequence @xmath56    consider the rim hook @xmath29 of @xmath45 : @xmath57 the partition sequence of @xmath58 is @xmath59 and the partition sequence of @xmath12 is @xmath60 we observe that @xmath61 differs from @xmath49 only by the exchange with one another of the two digits in the positions marked in the above sequences , changing their order from the * 1 * being to the left of the * 0 * in @xmath49 , to the * 0 * being to the left of the * 1 * in @xmath61 .",
    "moreover , we note that the two digits are @xmath62 positions apart from each other and that there is exactly @xmath63 * 0 * between them .",
    "this is not by coincidence , as the following definitions and the next proposition show .",
    "let @xmath49 be a partition sequence .",
    "a _ rim hook in _",
    "@xmath49 is a pair consisting of a * 0 * and a * 1 * in @xmath49 such that the * 1 * appears to the left of the * 0*. the distance between the * 0 * and the * 1 * is the _ length _ of the rim hook , and the number of * 0*s strictly between them is the _ leg length _ of the rim hook .",
    "the rim hook is _ removed _ by exchanging the * 0 * with the * 1*. for example , the marked pair of digits in @xmath64 is a rim hook of length 6 and of leg length 2 . the partition sequence obtained from @xmath49 by removing this rim hook is @xmath65    there is a bijection between rim hooks in the partition sequence @xmath49 of a partition @xmath12 and rim hooks of the young diagram of @xmath12 . moreover ,",
    "this bijections preserves the notions of length and leg length , and the removal of a rim hook in the partition sequence corresponds to the removal of the corresponding rim hook of the young diagram .    based on this , the following algorithm , _ mninner _ , finds all rim hooks @xmath29 of @xmath12 having length @xmath43 simply by going over all pairs of digits that are @xmath43 places apart from each other in @xmath66 , where @xmath49 is the partition sequence of @xmath12 .",
    "a variable @xmath67 keeps track of @xmath68 . if and only if the left digit in such a pair is * 1 * and the right digit is * 0 * , then it is a rim hook , and then the partition sequence of @xmath69 is obtained by exchanging the * 0 * with the * 1*. _ mninner _ then proceeds recursively to compute @xmath70 and adds @xmath71 to the sum .    function _ mninner _ ( @xmath72 ) + input : a sequence of binary digits @xmath73 and an index @xmath74 + output : = @xmath75 where @xmath76 is the partition whose partition sequence + is @xmath77 and @xmath78 .",
    "+ if = @xmath79 + then @xmath80 + else = @xmath81 ` + @xmath82 + for = @xmath83 to @xmath84 ` + do if @xmath85 then @xmath86 + for = @xmath87 to @xmath88 + do = @xmath89 then @xmath86 + if = @xmath90 is a rim hook , @xmath29 + then = exchange between @xmath91 and @xmath92 .",
    "+ @xmath93_mninner_(@xmath94 ) + exchange between @xmath91 and @xmath92 .",
    "+ return @xmath95    a major inefficiency of _ mninner _ is that character values that occur more than once in the expansion of the right hand side of are re - computed each time . in example",
    "[ ex : mn ] , @xmath96 occurs twice ( and therefore so does @xmath97 ) , so _",
    "mninner _ is invoked twice to compute it .",
    "this is overcome in the following algorithm , _",
    "mn1inner _ , by saving intermediate results in a table and using it to look up character values before computing them . each time a value @xmath75 is computed ,",
    "it is recorded in a table @xmath98 , and each time a value is required , it is first looked up in @xmath98 , and only if it is not there , then it is computed .",
    "@xmath98 is indexed by partitions @xmath76 rather than by pairs @xmath99 of partitions , since for any @xmath75 appearing in the expansion of we have that @xmath100 is the tail of @xmath13 of weight @xmath101 .",
    "_ mn1inner _ ( @xmath72 ) + input : a sequence of binary digits @xmath73 and an index @xmath74 + output : = @xmath75 where @xmath76 is the partition whose partition sequence + is @xmath77 and @xmath78 .",
    "+ if = @xmath79 + then @xmath80 + else = @xmath81 ` + @xmath82 + for = @xmath83 to @xmath84 ` + do if @xmath85 then @xmath86 + for = @xmath87 to @xmath88 + do = @xmath89 then @xmath86 + if = @xmath90 is a rim hook , @xmath29 + then = exchange between @xmath91 and @xmath92 . + if = @xmath102 is empty , where @xmath103 is the partition + whose partition sequence is  * 0*@xmath104 * 1 *  +",
    "then = @xmath105_mn1inner_(@xmath94 ) + @xmath106 + exchange between @xmath91 and @xmath92 . + return @xmath95    given partitions @xmath12 and @xmath13 , to compute @xmath9",
    "one needs to compute the essential part of @xmath12 s partition sequence , @xmath66 , and then to invoke _",
    "mn1inner_(@xmath107 ) .",
    "this is what algorithms _ partseq _ and _ murnak _ do .",
    "partseq_(@xmath12 ) + input : a partition @xmath108 .",
    "@xmath109 + output : @xmath66 , the essential part of the partition sequence of @xmath12 + @xmath110 an empty sequence + @xmath111 + for = @xmath112 down to @xmath113 + do = = @xmath114 to @xmath115 + do = @xmath116 + @xmath117 + return @xmath66    function _ murnak _ ( @xmath118 ) + input : partitions @xmath12 and @xmath13 of the same weight + output : @xmath9 + @xmath119 a 1-dimensional sparse array + @xmath120 + @xmath121 + return @xmath95",
    "let @xmath122 be a coxeter system , and let @xmath123 , @xmath124 be the length function with respect to @xmath125 .",
    "the @xmath1 hecke algebra @xmath126 of @xmath127 is the algebra spanned by the set @xmath128 over the ring of laurent polynomials @xmath129 $ ] subject only to the following relations : @xmath130 @xmath131 where @xmath132 acts as the identity .",
    "@xcite gives a distinguished basis @xmath133 for @xmath126 and a partition of the coxeter group @xmath127 into _ kazhdan - lusztig cells_. each left kazhdan - lusztig cell @xmath134 has a left representation of @xmath126 associated to it .",
    "let @xmath135 be the character of that representation .",
    "then for any @xmath136 and finite cell @xmath137 @xmath138 where @xmath139 is the coefficient of @xmath140 in @xmath141 .",
    "@xcite gives a formula for @xmath142 where @xmath143 , subject to certain relations between the @xmath144 . in the case",
    "@xmath145 , the formula applies to all of the summands in .",
    "furthermore in the @xmath145 case , the kazhdan - lusztig characters are exactly the irreducible characters , and the robinson - schensted - knuth correspondence gives rise to a canonical map between the kazhdan - lusztig and young s natural characters of @xmath4 , allowing for the formulation of the character as a weighted sum over standard tableaux .",
    "if @xmath146 , define @xmath147 .",
    "for example , if @xmath148 then @xmath149 .",
    "recall that a _",
    "standard tableau _ is a tableau whose rows and columns are increasing .",
    "the _ descent set _ of a standard tableau @xmath98 is @xmath150 the descent set of the inverse of the reading word of @xmath98 , also characterized by @xmath151 where  southwest \" means strictly below and weakly to the left .",
    "for example , the descent set of @xmath152 is @xmath153 .",
    "define @xmath154 , @xmath155 by @xmath156    [ t : roi ] let @xmath157 , and let @xmath158 be the corresponding character of the @xmath1 hecke algebra of @xmath4 .",
    "let @xmath159 be any element in the hecke algebra indexed by a permutation @xmath160 of cycle type @xmath13 .",
    "then @xmath161 where the sum runs over all standard tableaux @xmath98 of shape @xmath12 .",
    "substituting 1 for @xmath1 in the above we get a rule for the characters of @xmath4 : @xmath162 where the sum runs over all standard tableaux @xmath98 of shape @xmath12 .",
    "[ ex : roi ] calculating @xmath10 where @xmath163 and @xmath164 .",
    "we have @xmath165 and @xmath166[20pt]{1pt}{$t$ } & $ f^1_\\mu(t,1)$ & $ f^1_\\mu(t,2)$ & $ f^1_\\mu(t,3)$ & $ \\prod_{1\\le i<4}f^1_\\mu(t , i)$ \\\\",
    "\\hline \\parbox[c][36pt]{15pt}{{{\\tiny \\young(12,3,4 ) } } } &   $ 0 $ & $ -1 $ & $ 1 $ &   $ 0 $ \\\\",
    "\\hline \\parbox[c][36pt]{15pt}{{{\\tiny \\young(13,2,4 ) } } } & $ -1 $ &   $ 1 $ & $ 1 $ & $ -1 $ \\\\",
    "\\hline \\parbox[c][36pt]{15pt}{{{\\tiny \\young(14,2,3 ) } } } & $ -1 $ & $ -1 $ & $ 1 $ &   $ 1 $ \\\\ \\hline \\end{tabular}\\ ] ] hence @xmath167 .",
    "the nave way to compute @xmath10 using roichman s rule would be to construct all standard tableaux of shape @xmath12 , and for each tableau @xmath98 to compute the values of @xmath168 for all @xmath169 ( or until a 0 value is encountered ) , and finally to take the products and their sum .",
    "however , it can easily be shown that @xmath154 depends only on the first @xmath170 entries of @xmath98 .",
    "an improvement over the nave approach is achieved by using this observation , as follows :    let @xmath98 be a standard tableau",
    ". denote by @xmath171 the standard tableau obtained by deleting all entries @xmath172 from @xmath98 .",
    "for example , @xmath173 .    define @xmath174    let @xmath175 be a standard tableau of shape @xmath176 , @xmath177 . define @xmath178 where the sum runs over all standard tableaux @xmath98 of shape @xmath12 containing @xmath175 ( i.e. such that @xmath179 ) .",
    "note that @xmath180 where the sums run over all standard tableaux of shape @xmath98 , so can be rewritten as : @xmath181    the following proposition follows easily from the definitions .",
    "[ pr : recursivea ] we have the following recursive formula : @xmath182 where the sum runs over all standard tableaux @xmath125 such that @xmath183 , @xmath184 and @xmath185 , i.e. the tableaux @xmath125 are those obtained by adding @xmath186 to @xmath175 in a position belonging to @xmath12 .    calculating @xmath10 where @xmath163 and @xmath164 , hence @xmath165 .",
    "each node in the following tree shows a tableau @xmath175 of some shape contained in @xmath12 , starting with the empty tableau .",
    "each node s children are all the tableaux @xmath125 of shape contained in @xmath12 that can be obtained by adding one entry to @xmath175 .",
    "the number in parentheses above each tableau @xmath175 is @xmath187 where @xmath188 is the number of entries in @xmath175 , also appearing in the column to the left of the tree .",
    "the numbers in the last row are @xmath189 for the tableaux above them .",
    "@xmath190 @xmath191 .      the following algorithm , _ roiinner _ , computes @xmath192 according to proposition [ pr : recursivea ] , computing values of @xmath193 and invoking itself recursively as necessary .",
    "it assumes that the global variable @xmath194 is assigned the values @xmath195 . in the case @xmath196 of",
    ", it computes @xmath197 by checking for the first case of ( note that the second case of can not occur for @xmath198 since @xmath199 always ) . in the case @xmath200 of , the algorithm computes the sum by going over the rows of @xmath175 , checking for each row whether by adding @xmath186 at its end one gets a tableau @xmath125 such that @xmath201 .",
    "if so , it sets the variable @xmath202 to indicate whether @xmath203 and determines @xmath204 , which is assigned to the variable @xmath20 . finally , if @xmath205 , it proceeds recursively to compute @xmath206 and adds @xmath207 to the sum .",
    "roiinner_(@xmath208 ) + input : a partition @xmath209 , @xmath210 , a row index @xmath211 and an indicator @xmath212 .",
    "+ output : = @xmath192 where @xmath175 is any of the tableaux such that + @xmath213 , @xmath188 appears on row @xmath211 of @xmath175 and @xmath212 indicates whether @xmath214 .",
    "+ if = @xmath196 + then = = ( @xmath215 and @xmath216 ) + then= @xmath217 + else = @xmath218 + else = @xmath219 + for = @xmath114 to @xmath17 + do if = ( ( @xmath220 or @xmath221 ) and @xmath222 ) + then = = @xmath223 + then @xmath224 yes + else @xmath225 no + if = ( @xmath226 or @xmath227 ) + then @xmath228 + else if = @xmath229 + then @xmath230 + else if = ( @xmath231yes and @xmath232no and @xmath233 ) + then @xmath234 + else @xmath228 + if = @xmath205 + then = @xmath235 + @xmath236 + @xmath237   + return a    given partitions @xmath12 and @xmath13 , to compute @xmath9 one needs to initialize the global variable @xmath238 to contain @xmath239 and then to compute @xmath240 using _",
    "roiinner_. this is what the algorithm _ roich _ does",
    ".    function _",
    "roich_(@xmath118 ) + input : partitions @xmath241 and @xmath242 of the same weight . @xmath243 + output : @xmath9 + @xmath244 + for = @xmath87 to @xmath16 + do = = @xmath83 to @xmath245 + do @xmath246 + @xmath247 + @xmath248_roiinner_(@xmath249 ) + return @xmath95",
    "a _ problem instance _ in the case of computing character values of the symmetric group is simply an ordered pair @xmath6 of partitions of the same integer .",
    "let @xmath250 be the set of partitions appearing in the expansion of the right hand side of .",
    "more precisely , define @xmath251 which is the set of partitions one can obtain starting with @xmath12 by removing a sequence of rim hooks @xmath252 of lengths @xmath253 respectively , @xmath254 .",
    "in example [ ex : mn ] , for instance , @xmath255    denote @xmath256 by @xmath257 .",
    "[ pr : tmn1 ] let @xmath258 be the running time of _ murnak _ on input @xmath6 .",
    "then @xmath259 where @xmath260 is the @xmath261 hook number of @xmath12 .    in computing @xmath262 , _",
    "mn1inner _ is invoked precisely once for each node in the  recursion graph \" . in each one of these @xmath257 invocations of _ mn1inner",
    "_ , the length of its first parameter , @xmath104 , is the same as the length of the essential part of the partition sequence of @xmath12 , which is @xmath263 .",
    "let @xmath264 be the running time of _ mn1inner _ , excluding the recursion , on input @xmath265 , @xmath266 .",
    "mn1inner _ performs @xmath84 iterations in the first loop and @xmath88 iterations in the second loop . in both loops ,",
    "the time for each iteration is @xmath267 .",
    "therefore @xmath268    it follows that each invocation of _",
    "mn1inner _ during the computation of _",
    "murnak_(@xmath118 ) takes time @xmath269 , with the possible exception of one invocation with the trivial case @xmath79 which takes @xmath267 . however , this possible exception is negligible as long as @xmath270 .    consequently , @xmath271    if @xmath272 then for any @xmath273 , @xmath274 and consequently @xmath275 .",
    "define @xmath276 the number of partitions @xmath277 such that @xmath278 .",
    "[ le : r_la ] let @xmath279 .",
    "then @xmath280    the lemma follows from @xcite , ch .  3 , ex .  63 : substituting the empty partition for @xmath13 and @xmath113 for @xmath7 , it states that @xmath281 by definition of @xmath282 , @xmath283 noting that the partial order @xmath284 defined in the exercise coincides with containment of young diagrams ,",
    "we have @xmath285      let latexmath:[\\[\\mathcal q_{{\\lambda},\\mu } = \\ { q { \\;\\big | \\;}q \\text { is a standard tableau of shape $ \\alpha\\subseteq{\\lambda}$ and } g_\\mu(q , i)\\neq 0 , 1\\le i \\le    contained in @xmath12 such that the values + @xmath287 alone , where @xmath288 , are insufficient to determine whether @xmath289 for all @xmath98 such that @xmath179 .",
    "( hence , for each @xmath290 , _ roiinner _ is invoked to compute @xmath192 ) .",
    "for instance , in example [ ex : roi ] , @xmath291 note that @xmath292 , since @xmath293 .",
    "consequently , the algorithm does not compute @xmath206 .",
    "define @xmath294    @xmath295 is just the set of non - leaf nodes in the recursion tree of _",
    "roiinner_. since the algorithm s work on each such node is linear in @xmath296 , and the work on each leaf node is constant , we have    [ pr : troi ] let @xmath297 be the running time of _ roich _ on input @xmath6 .",
    "then @xmath298    it is clear from that if @xmath299 then @xmath300 for every tableau @xmath175 and @xmath301 .",
    "thus for any @xmath273 , @xmath302 , and consequently @xmath303 .",
    "define @xmath304 the number of standard tableaux of shapes contained in @xmath12 .",
    "[ le : q_la ] let @xmath272 .",
    "then @xmath305 where @xmath15 is the number of standard young tableaux of shape @xmath12 .",
    "let @xmath306 then @xmath307 and the lemma follows since @xmath308 .",
    "recall that problem instances in the case of computing character values of the symmetric group , are simply pairs @xmath6 of partitions of the same integer . in order to compare the algorithms running times",
    ", we express them as functions of the _ problem instance size_. a natural measure of instance size is the weight @xmath7 of the partitions @xmath12 and @xmath13 .    in worst case analysis we consider the maximum running time of each of the algorithms on a problem instance of size @xmath7 , namely @xmath309 and @xmath310 by proposition [ pr : tmn1 ] , @xmath311 and by proposition [ pr : troi ] , @xmath312 hence we seek expressions for ( bounds on ) @xmath313 and @xmath314 as functions of @xmath7 .",
    "we consider only certain families of problem instances , namely those in which @xmath12 is restricted to a given @xmath11 hook ( see below ) .",
    "the _ @xmath11 hook _ is the infinite shape @xmath315 .",
    "let @xmath316 be the set of all partitions of @xmath7 lying inside the @xmath11 hook , that is @xmath317    the two propositions in this subsections show that for partitions in the @xmath11 hook , _ murnak _ runs in polynomial time @xmath18 whereas _ roich _",
    "s running time is exponential in @xmath7 , being in @xmath318 for some constant @xmath20 .",
    "[ pr : klhookmn ] fix @xmath16 and @xmath17 .",
    "then @xmath319 where @xmath320 .",
    "the proof requires the following lemmas .",
    "we use the notations @xmath321    [ le : h_11_for_hooks ] fix @xmath16 and @xmath17 . if @xmath322 then @xmath323 .",
    "@xmath324    so @xmath325 on the other hand , @xmath326 so @xmath327 therefore @xmath328    [ le : mrow ] let @xmath329 .",
    "then @xmath330    set @xmath331 let @xmath332 .",
    "then there exists a permutation @xmath333 such that @xmath334 .",
    "we claim that @xmath335 .",
    "indeed , @xmath277 is a partition , and for all @xmath169 we have @xmath336 whence @xmath337 .",
    "it follows that for every @xmath338 there exist @xmath339 and @xmath340 such that @xmath341 .",
    "thus @xmath342 , so @xmath343 the other inequality in follows from the fact that @xmath344 .    without loss of generality ,",
    "assume @xmath345 .",
    "we have @xmath346 where @xmath347    let @xmath348 .",
    "there is a bijection between @xmath349 and ordered triplets of partitions @xmath350 such that + 1 .",
    "@xmath277 is contained in the @xmath351 rectangle , that is @xmath352 .",
    "@xmath353 where @xmath354 .",
    "@xmath355 where @xmath356 .",
    "+ the following figure illustrates this bijection , showing @xmath357 in white and @xmath358 shaded :    @xmath359    it follows that @xmath360 where @xmath361 if @xmath352 and @xmath362 , @xmath363 are as above , then @xmath364 , thus @xmath365 . otherwise , the partition sequence of @xmath277 is @xmath366 where @xmath367 is any sequence containing exactly @xmath368 * 1*s and @xmath369 * 0*s , whence @xmath370 for @xmath371 , @xmath372 .",
    "thus @xmath373 since @xmath374 for all values of @xmath362 and @xmath363 in the sum and does not depend on @xmath12 , @xmath375 whence @xmath376 and therefore , by , @xmath377 finally , by lemma [ le : h_11_for_hooks ] @xmath378    the running time of _ roich _ for partitions in the @xmath11 hook is determined up to a factor of order @xmath379 in the following proposition .",
    "[ pr : klhookroi ] fix @xmath16 and @xmath17 .",
    "then @xmath380 for a certain constant @xmath20 .",
    "the proposition follows immediately from lemma [ le : q_la ] and from the following theorem .",
    "assume @xmath7 is large and @xmath322 maximizes @xmath15 .",
    "there exist constants @xmath381 and @xmath20 such that @xmath382    table [ tb : hook ] shows the running times of the two algorithms on @xmath383 for several @xmath12s in the @xmath384 hook .",
    "maximal @xmath385 and @xmath386 values for each @xmath7 appear in boldface .",
    "table [ tb : general ] shows the running times of the two algorithms for several pairs @xmath6 .",
    "the values of @xmath257 and @xmath387 were obtained by running _",
    "murnak _ and _ roich _ on each pair and counting invocations of _ mn1inner _ and _ roiinner _ respectively .",
    "maximal @xmath388 and @xmath389 values for each @xmath7 appear in boldface .",
    "this paper is based on work conducted for my m.sc .",
    "thesis , under the supervision of professor amitai regev .",
    "i would like to thank him for his patient guidance , helpful advice and constant encouragement , and specifically for reviewing and commenting on drafts of this paper .",
    "i would also like to thank yuval roichman for his comments .",
    "barcelo , h. , ram , a. , 1999 .",
    "combinatorial representation theory , new perspectives in algebraic combinatorics ( berkely , ca , 19961997 ) , 2390 , math .",
    "38 , cambridge university press , cambridge ."
  ],
  "abstract_text": [
    "<S> the murnaghan - nakayama rule is the classical formula for computing the character table of @xmath0 . </S>",
    "<S> y.  roichman ( roichman 1997 ) has recently discovered a rule for the kazhdan - lusztig characters of @xmath1 hecke algebras of type @xmath2 , which can also be used for the character table of @xmath0 . for each of the two rules </S>",
    "<S> , we give an algorithm for computing entries in the character table of @xmath0 . </S>",
    "<S> we then analyze the computational complexity of the two algorithms , and in the case of characters indexed by partitions in the @xmath3 ) hook , compare their complexities to each other . </S>",
    "<S> it turns out that the algorithm based on the murnaghan - nakayama rule requires far less operations than the other algorithm . </S>",
    "<S> we note the algorithms complexities relation to two enumeration problems of young diagrams and young tableaux . </S>"
  ]
}