{
  "article_text": [
    "magnetism has been one of the most important subjects in physics , and many of technological applications are based upon ordered behaviors of magnetic materials .",
    "this leads us to both a theoretical and practical question about how to understand collective behaviors observed in magnetic systems .",
    "a particularly interesting case to us is rare - earth compounds in which magnetic spins at low temperatures can be basically regarded as two - dimensional ( 2d )  @xcite and the exchange interaction is relatively weak  @xcite because one can easily make use of theoretical frameworks developed to study such continuous spin models in statistical physics .",
    "let us consider a square lattice of @xmath0-like spins governed by the dipole interaction .",
    "if the linear size of the lattice is @xmath1 , the total number of spins will be @xmath2 , and the corresponding hamiltonian is given as follows : @xmath3 / r_{ij}^5 , \\label{eq : h}\\ ] ] where @xmath4 represents interaction strength and the summation runs over every distinct spin pair of @xmath5 and @xmath6 at @xmath7 and @xmath8 , respectively .",
    "the distance between this spin pair is denoted as @xmath9 .",
    "since the periodic boundary condition is employed to reduce unwanted boundary effects , the relative displacement @xmath10 between @xmath7 and @xmath8 is chosen as the one with minimal length among every possible pair of their periodic images . in case",
    "that more than one periodic image of a spin has the same minimal length from another spin , ambiguity can enter in defining the interaction within this pair due to the anisotropy manifested in the second term of eq .",
    "( [ eq : h ] ) . to be simple",
    ", we neglect the interaction in such a case , and this choice does not hurt any essential properties of the system .",
    "it is notable that the interaction energy between @xmath5 and @xmath6 has an overall distance dependence as @xmath11 and is determined by both their phase difference and the relative displacement , @xmath10 . in a numerical analysis , the long - range character implies computational complexity of @xmath12 for the simple metropolis algorithm ( see , however , ref .",
    "@xcite for a possible modification of this approach ) . for this reason",
    ", it has not been easy to precisely determine the physical properties of the phase transition in a dipole system  ( see refs .",
    "@xcite and references therein ) , and it still remains to be investigated from an algorithmic point of view .    in this work ,",
    "we try to implement a wolff - type single - cluster update algorithm  @xcite for a dipole system to challenge this issue . specifically , we combine the luijten - blte ( lb ) algorithm  @xcite and the dotsenko - selke - talapov ( dst ) algorithm  @xcite to analyze eq .",
    "( [ eq : h ] ) and check the results in comparison to the metropolis single - spin update algorithm .",
    "this work is organized as follows : we begin with the lb algorithm in sec .  [ sub : lb ] and the dst algorithms will be given in sec .",
    "[ sub : dst ] .",
    "then we combine them to construct the cluster - update algorithm and present results in sec .",
    "[ sub : com ] .",
    "this work is summarized in sec .",
    "[ sec : sum ] .",
    "let us begin with a 2d ferromagnetic system described as @xmath13 where @xmath14 and each index runs from 1 to @xmath15 .",
    "we regard @xmath16 as an ising spin for a while .",
    "if one directly applies the wolff algorithm , the updating procedure would be as follows .    1 .",
    "pick a spin randomly and add its index into a stack .",
    "[ itm : get ] retrieve an element @xmath17 from the stack .",
    "[ itm : chk ] for every other spin @xmath6 ( @xmath18 ) in the system , add its index @xmath19 into the stack with probability @xmath20 \\delta_{\\boldsymbol{s}_i , \\boldsymbol{s}_j}$ ] with the boltzmann constant @xmath21 .",
    "4 .   if the stack is not empty , go to step  [ itm : get ] .",
    "otherwise , flip the cluster .",
    "it is obvious that step  [ itm : chk ] spends time proportional to @xmath12 for every retrieval if the program checks whether @xmath22 for each spin pair .",
    "the idea of the lb algorithm is that we may first assume @xmath23 to calculate @xmath24 , which is fixed throughout the whole computation .",
    "note that the index @xmath17 is irrelevant because every point is equivalent under the periodic boundary condition .",
    "hence , instead of checking this probability for every spin , we can build a probability table in advance to correctly pick up possible @xmath6 s in terms of a position relative to @xmath5 .",
    "this saves time to @xmath25 , where @xmath26 appears in looking up the table with the binary search  @xcite .",
    "if the picked @xmath6 does not point in the same direction as @xmath5 , we do not add it into the stack because we need to recover @xmath27 .",
    "specifically , the prescription in ref .",
    "@xcite can be written as follows :    1 .",
    "assume that we have chosen @xmath5 from which we grow a cluster .",
    "2 .   a spin @xmath16 ( @xmath18 )",
    "can be chosen with probability @xmath28 .",
    "let s say @xmath6 is picked up by performing this step .",
    "3 .   the next spin is then selected according to a new probability distribution , @xmath29 .",
    "this step is repeated : that is , whenever a spin @xmath30 is selected , we work with @xmath31 to find the next one .",
    "this repetition stops when no more spins are picked up .    by doing this ,",
    "each spin @xmath6 is chosen with its own correct probability , @xmath32 . to demonstrate this ,",
    "let us set @xmath33 when @xmath16 is picked up and @xmath34 in the other case .",
    "if we denote @xmath35 as the probability of each possible event , the sum of all the probabilities to choose @xmath36 then reads as @xmath37 likewise , the total probability to select @xmath38 is @xmath39 and one can readily generalize this for any arbitrary @xmath6 .",
    "it is also clear that this holds true no matter how one indexes spins as long as the index is used consistently throughout the calculation even though ref .",
    "@xcite makes it with respect to physical distances .    in picking up a spin index from such a procedure , it is convenient to work with a cumulative distribution , that is , @xmath40,\\nonumber\\\\ & & -\\frac{1}{2 } \\ln \\left [ 1-c_j(n ) \\right ] = \\sum_{l = j+1}^n j_{il}/k_b t \\equiv s_j(n ) .",
    "\\label{eq : cj}\\end{aligned}\\ ] ] and one will find which spin should be picked by comparing @xmath41 with a random number uniformly drawn over @xmath42 .",
    "a beauty of the lb algorithm is that updating of @xmath41 with picking a spin hardly needs any additional computation because @xmath19 only enters as a starting index of the summation in eq .",
    "( [ eq : cj ] ) so that @xmath43 for @xmath44 .",
    "in other words , it suffices to compute @xmath45 once and to memorize it for every @xmath46 in advance of the monte carlo iterations .",
    "one needs to reset the starting index as @xmath19 when having picked up spin @xmath19 , and then one will get the correct @xmath47 ( accordingly , correct @xmath48 ) for spin @xmath49 each time by using eq .",
    "( [ eq : cj ] ) .",
    "note that it is most natural to define @xmath50 as zero .",
    "then , the lb algorithm for solving eq .",
    "( [ eq : iso ] ) modifies the wolff algorithm given above in the following way :    1 .",
    "choose @xmath5 placed at a certain position , and make an array of partial sums @xmath45 with relative displacements from this chosen spin site .",
    "2 .   pick a spin randomly and add its index into a stack . set @xmath51 as zero",
    "[ itm : get2 ] retrieve an element @xmath17 from the stack and do the following : 1 .",
    "[ itm : cum ] draw a uniform random number @xmath52 and find an index @xmath53 that satisfies @xmath54 .",
    "if there is no such @xmath53 , terminate this loop for @xmath17 .",
    "otherwise , set @xmath51 as @xmath53 for the next iteration .",
    "2 .   since @xmath53 indicates only a relative position with respect to @xmath17 , translate it into the actual position @xmath55 .",
    "3 .   add @xmath55 into the stack if @xmath56 ; go to step  [ itm : cum ] .",
    "4 .   if the stack is not empty , go to step  [ itm : get2 ] . otherwise , flip the cluster .",
    "indexed with reference to the spin at the top left position @xmath57 .",
    "note that the spin with index @xmath58 has _ two _ different shortest paths to the spin with index @xmath59 due to the periodic boundary condition .",
    "( b ) the indices are translated with a new reference point at @xmath60.,title=\"fig:\",scaledwidth=35.0% ]    indexed with reference to the spin at the top left position @xmath57 .",
    "note that the spin with index @xmath58 has _ two _ different shortest paths to the spin with index @xmath59 due to the periodic boundary condition .",
    "( b ) the indices are translated with a new reference point at @xmath60.,title=\"fig:\",scaledwidth=35.0% ]    for example , let us consider a @xmath61 square lattice with periodic boundaries , where the spin sites @xmath62 can be thus indexed by @xmath63 , ranging from @xmath58 to @xmath64 [ fig .",
    "[ fig : ex](a ) ] . in step 1",
    ", we may locate @xmath65 at @xmath57 on the lattice , so @xmath66 .",
    "with respect to this spin , one can compute @xmath67 for every other spin @xmath68 .",
    "we exclude self - interaction by setting @xmath69 , and @xmath67 should also be zero when @xmath70 or @xmath71 because their relative displacement is not unique due to the periodic boundary condition . in this way , one can readily construct the array @xmath45 . once computed in step 1 ,",
    "it can be used at any spin site @xmath62 to calculate the probability to add another spin to the stack because the interaction depends only on the relative displacement between them .",
    "the relative position of @xmath68 with respect to @xmath65 needs to be converted to the actual position on the lattice in step 3(b ) .",
    "suppose that a spin at @xmath72 , i.e. , @xmath73 , is retrieved from the stack .",
    "then , the situation with this spin as a reference point is equivalent to fig .",
    "[ fig : ex](b ) under a simple translation .",
    "we check which other spins can be added to the stack by comparing the random number @xmath74 with @xmath41 in step 3(a ) [ see eq .",
    "( [ eq : cj ] ) ] .",
    "if this procedure tells us to add @xmath75 , this correspond to spin @xmath59 according to the original index in fig .",
    "[ fig : ex](a ) . therefore , we should add spin @xmath59 to the stack .",
    "now , the starting index in eq .",
    "( [ eq : cj ] ) is changed to @xmath76 .",
    "getting back to step 3(a ) and drawing a new random number , let s say that we get @xmath77 this time . as before , comparing figs .",
    "[ fig : ex](a ) and [ fig : ex](b ) , we add spin @xmath58 to the stack , and go back to step 3(a ) .",
    "the next @xmath78 must be beyond the valid range of spin indices , so we stop considering @xmath79 and retrieve another spin from the stack .",
    "this is repeated until the stack becomes empty .",
    "this algorithm can be extended to simulate @xmath0 spins as well : one should assign a reflection plane by randomly drawing @xmath80 on choosing a seed of the cluster , as originally devised in ref .",
    "every spin inside the generated cluster will be reflected with respect to this plane .",
    "we denote this reflection as an operator @xmath81 so that the operation is represented as @xmath82 . accordingly , whether a spin can be included in the cluster should be also determined by the energy difference due to such a reflection so that the added probability becomes @xmath83 $ ] . the lb algorithm for the ising case",
    "first overestimates @xmath24 and then adjust it by using the kronecker delta @xmath84 . for @xmath0 spins , an overestimate occurs in the same way , but the adjustment should be made by replacing the kronecker delta with the probability @xmath85}{1 - \\exp(-2j_{ij}/k_b t ) } \\right\\}$ ] .",
    "the dst algorithm was devised to use cluster updates in frustrated systems . in order to illustrate the main idea",
    ", we consider a local version of eq .",
    "( [ eq : h ] ) : @xmath86 where the summation runs over all the nearest neighbor pairs  @xcite . in growing a cluster @xmath87",
    ", one considers only the first term in eq .",
    "( [ eq : loc ] ) because it satisfies @xmath88 for any @xmath89 and does not cause any energy difference in the bulk of the cluster .",
    "let us compare two spin configurations @xmath90 and @xmath91 that are related by one cluster flip , i.e. , @xmath92 for every @xmath17 so that @xmath93 for @xmath94 and @xmath95 for @xmath96 . then , the ratio of probabilities to select the configurations is @xmath97\\\\ & = & \\exp \\left [ \\frac{j}{k_b t } \\sum_{\\left < i \\in c , j \\notin c \\right > } ( \\boldsymbol{s}_i \\cdot \\boldsymbol{s}_j - r_\\phi \\boldsymbol{s}_i \\cdot \\boldsymbol{s}_j ) \\right],\\end{aligned}\\ ] ] just as in the wolff algorithm . for this",
    "generated cluster , we compute an additional energy contribution from the last anisotropic term , @xmath98 and accept this cluster move with probability @xmath99 $ ] .",
    "then the acceptance ratios will satisfy @xmath100 and the transition probabilities in total restore the detailed balance as @xmath101 \\right\\}\\\\ & \\times & \\exp \\left\\ { -\\frac{j}{k_b t } \\sum_{\\left < i , j \\right > } \\left [ \\boldsymbol{s}_i ' \\cdot \\boldsymbol{s}_j ' - 3(\\boldsymbol{s}_i ' \\cdot \\boldsymbol{r}_{ij } ) ( \\boldsymbol{s}_j ' \\cdot \\boldsymbol{r}_{ij } ) \\right ] \\right\\}.\\end{aligned}\\ ] ]    although this algorithm certainly works , one should note that the cluster growth does not exactly describe the given system , which means that the cluster update may not be helpful in overcoming critical slowing down  @xcite .",
    "what usually happens is that a cluster grown to a large size is simply rejected at the last step , leading to an amount of inefficiency .",
    "collecting @xmath102 during the cluster growth may reduce this problem to some extent  @xcite : we will check whether this cluster will be accepted every time @xmath103 spins are added . defining @xmath104 $ ] and @xmath105 $ ] , we write down the cluster algorithm for eq .",
    "( [ eq : loc ] ) as follows :    1 .",
    "pick randomly a spin and add its index into a stack .",
    "determine a reflection plane by randomly drawing @xmath80 and set a variable @xmath106 as zero .",
    "[ itm : loc ] retrieve an element @xmath17 from the stack .",
    "3 .   for every nearest neighbor @xmath19 of @xmath17 , 1 .   if @xmath19 is not included in the cluster , add it into the stack with probability @xmath107 $ ] .",
    "add @xmath108 to @xmath106 .",
    "2 .   otherwise , add @xmath109 to @xmath106 .",
    "if @xmath103 spins are added into the cluster or the stack is empty , check whether the cluster can be flipped with probability @xmath110 and then set @xmath106 as zero . 1 .",
    "if the answer is no , finish this monte carlo step .",
    "if the stack is empty and the answer is yes , flip the cluster .",
    "3 .   otherwise ,",
    "go back to step  [ itm : loc ] .",
    "we now combine the lb algorithm and the dst algorithm to solve the long - ranged anisotropic dipole interaction in eq .",
    "( [ eq : h ] ) .",
    "we generate a cluster by using the first term of eq .",
    "( [ eq : h ] ) , which is the same as the lb algorithm ( sec .",
    "[ sub : lb ] ) except that the interaction becomes antiferromagnetic due to @xmath111 .",
    "the dst algorithm ( sec .  [ sub : dst ] ) is needed to take the remaining terms into account . because collecting terms during the cluster growth takes time of @xmath12 on every retrieval from the stack , which is highly time - consuming , we examine the flip after fully generating a cluster at an expense of low acceptance ratio .",
    "the algorithm can be written down as follows :    1 .",
    "imagine that @xmath5 is placed at the center of the square lattice , and make an array of partial sums @xmath45 with relative displacements from this spin site .",
    "2 .   pick randomly a spin and add its index into a stack .",
    "determine a reflection plane by randomly drawing @xmath80 .",
    "[ itm : di ] retrieve an element @xmath17 from the stack and do the following : 1 .",
    "[ itm : dcum ] draw a uniform random number @xmath52 and find an index @xmath53 that satisfies @xmath54 .",
    "if there is no such @xmath53 , terminate this loop for @xmath17 .",
    "otherwise , set @xmath51 as @xmath53 for the next iteration .",
    "2 .   because @xmath53 indicates only a relative position with respect to @xmath17 , translate it into the actual position @xmath55 .",
    "3 .   add @xmath55 into the stack with probability @xmath112}{1 - \\exp(-2j_{ij}/k_b t ) } \\right\\}.\\ ] ] go to step  [ itm : dcum ] .",
    "4 .   if the stack is not empty , go to step  [ itm : di ] .",
    "otherwise , go to the next step .",
    "5 .   for every spin pair @xmath113 inside the generated cluster @xmath87 , calculate the energy difference @xmath114 /r_{ij}^3.\\ ] ] 6 .   for every spin pair @xmath94 and @xmath115 ,",
    "calculate the energy difference @xmath116 /r_{ij}^3.\\ ] ] 7 .",
    "flip the cluster with probability@xmath117 \\right\\}.\\ ] ]     and @xmath118 is the number of cluster flips .",
    "we plot ( a ) the average number of updated spins per flip and ( b ) the magnetic order parameter as a function of @xmath119 , measured for @xmath120 and temperature @xmath121 in units of @xmath122 .",
    "( c ) acceptance ratios of the cluster algorithm and the metropolis algorithm .",
    "the system size is taken as @xmath123 .",
    "( d ) magnetic order parameter obtained by using the cluster algorithm .",
    "the dotted lines show results based on the metropolis algorithm for comparison .",
    ", title=\"fig:\",scaledwidth=45.0% ]   and @xmath118 is the number of cluster flips .",
    "we plot ( a ) the average number of updated spins per flip and ( b ) the magnetic order parameter as a function of @xmath119 , measured for @xmath120 and temperature @xmath121 in units of @xmath122 .",
    "( c ) acceptance ratios of the cluster algorithm and the metropolis algorithm .",
    "the system size is taken as @xmath123 .",
    "( d ) magnetic order parameter obtained by using the cluster algorithm .",
    "the dotted lines show results based on the metropolis algorithm for comparison . , title=\"fig:\",scaledwidth=45.0% ] +   and @xmath118 is the number of cluster flips .",
    "we plot ( a ) the average number of updated spins per flip and ( b ) the magnetic order parameter as a function of @xmath119 , measured for @xmath120 and temperature @xmath121 in units of @xmath122 .",
    "( c ) acceptance ratios of the cluster algorithm and the metropolis algorithm .",
    "the system size is taken as @xmath123 .",
    "( d ) magnetic order parameter obtained by using the cluster algorithm .",
    "the dotted lines show results based on the metropolis algorithm for comparison .",
    ", title=\"fig:\",scaledwidth=45.0% ]   and @xmath118 is the number of cluster flips . we plot ( a ) the average number of updated spins per flip and ( b ) the magnetic order parameter as a function of @xmath119 , measured for @xmath120 and temperature @xmath121 in units of @xmath122 .",
    "( c ) acceptance ratios of the cluster algorithm and the metropolis algorithm .",
    "the system size is taken as @xmath123 .",
    "( d ) magnetic order parameter obtained by using the cluster algorithm .",
    "the dotted lines show results based on the metropolis algorithm for comparison .",
    ", title=\"fig:\",scaledwidth=45.0% ]    as one sees in sec .",
    "[ sub : dst ] , the energy contribution due to the anisotropy should be calculated inside the cluster and at its surface . if the generated cluster has a size @xmath124 , the computation for the bulk part roughly takes @xmath125 while the surface part needs @xmath126 . in order for the whole system",
    "to be updated , this should be repeated @xmath127 times . hence , as a whole , it takes @xmath128 \\times n / c = n^2 \\left [ 1-\\frac{c}{2n } \\right]$ ] .",
    "in other words , @xmath12 complexity does not disappear , but decreases to a limited extent .",
    "figure  [ fig : perf](a ) shows how many spins one cluster flip actually updates , which is a small number . here",
    ", the temperature @xmath129 is chosen to be around the order - disorder transition point  @xcite . if we measure time in terms of the number of flipped spins as in ref .",
    "@xcite , the magnitude of staggered magnetization , @xmath130 , is observed to equilibrate substantially faster than the standard metropolis algorithm [ fig .",
    "[ fig : perf](b ) ] . here",
    ", the staggered magnetization is defined as @xmath131 with @xmath132 $ ] , where the position of each spin is given as @xmath133 and the spin variable is written as @xmath134  @xcite .",
    "we take the magnitude @xmath135 as the order parameter of this dipole system .",
    "figure  [ fig : perf](b ) implies that the global update indeed carries out nontrivial moves , even though this factor is largely compensated by the low acceptance ratio in practical computations [ fig  [ fig : perf](c ) ] .",
    "a trick to get a higher acceptance ratio is to perform occasionally such a move that rotates every spin in the generated cluster by @xmath136 because this is the only possible global move that does not cause @xmath137 .",
    "however , this trivial move hardly makes any essential difference in performance .",
    "figure  [ fig : perf](d ) shows the outcomes from this algorithm , as well as results based on the metropolis algorithm for comparison .",
    "the nice agreement found in the order parameter confirms the validity of this cluster algorithm .",
    "the autocorrelation time @xmath138 can be measured by integrating the autocorrelation for an equilibrated time series of @xmath130 . in fig .",
    "[ fig : co ] , we compare @xmath138 of our cluster algorithm with that of the metropolis algorithm .",
    "we have very limited sizes so it is not easy to quantify the critical behavior @xmath139 . for the metropolis algorithm",
    ", however , @xmath140 seems to be a plausible description up to the sizes used in this work [ fig .",
    "[ fig : co](a ) ] . on the other hand ,",
    "the cluster algorithm shows only a little increase in @xmath138 at @xmath120 [ fig .",
    "[ fig : co](b ) ] , which suggests that @xmath138 can be a sublinear function of @xmath1 .     at @xmath141 in the metropolis algorithm , where one monte carlo step is defined as attempting to flip every spin in the system .",
    "( b ) the same quantity in the cluster algorithm , where one monte carlo step corresponds to a cluster generation.,title=\"fig:\",scaledwidth=45.0% ]   at @xmath141 in the metropolis algorithm , where one monte carlo step is defined as attempting to flip every spin in the system .",
    "( b ) the same quantity in the cluster algorithm , where one monte carlo step corresponds to a cluster generation.,title=\"fig:\",scaledwidth=45.0% ]",
    "a recent numerical observation based on extensive use of the metropolis algorithm suggests that the order - disorder transition of the 2d square dipole lattice is consistent with the 2d ising universality class  @xcite , which has been inconclusive to a large extent .",
    "we have reached the same conclusion by running the metropolis algorithm on a number of cpu s in parallel  @xcite .",
    "when run on a single cpu , the agreement of the cluster - algorithm approach found in fig .",
    "[ fig : perf](d ) is striking , and this shows that the main obstacle in identifying the critical behavior has been the equilibration rate , as suggested in ref .",
    "an efficient algorithm is , therefore , called for in order to obtain more precise critical properties of the dipole lattices , and we hope that this cluster algorithm can be a step toward it .    even though the complexity of @xmath12 still remains in our cluster algorithm , it has an advantage over the simple metropolis algorithm when time is measured by spin flips [ fig  [ fig : perf](b ) ] .",
    "the problem is that it shows little gain in terms of real time due to the low acceptance ratio , which comes from collecting the anisotropic contributions .",
    "this possibly indicates a direction to improve this cluster - update approach .",
    "10 [ 2]#2 [ 1]#1 [ 1]#1 , , , , , and , , ( ) . , , , and , , ( ) .",
    ", , ( ) . and , , ( ) .",
    ", , and , , ( ) . , , ( ) . and , , ( ) . , , and , , ( )",
    ". and , , ( ) . and , , ( )",
    ". and , , ( ) .",
    ", , , , and , , ( ) .",
    ", , ( ) . and , , ( ) .",
    ", , , and , , ( ) ."
  ],
  "abstract_text": [
    "<S> we implement a cluster - update monte carlo algorithm to simulate magnetic dipoles of the @xmath0-spin type confined in a two - dimensional plane . </S>",
    "<S> the long - range character and anisotropy in the dipole interaction are handled by using the luijten - blte algorithm and the dotsenko - selke - talapov algorithm , respectively . </S>",
    "<S> we have checked the performance of this cluster - update algorithm in comparison to the metropolis algorithm and found that it equilibrated the system faster in terms of the number of flipped spins , although the overall computational complexity of the problem remained the same . </S>"
  ]
}