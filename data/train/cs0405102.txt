{
  "article_text": [
    "we address in this paper the problem of extracting negative information from functional logic programs . the question of negation is a main topic of research in the logic programming field , and the most common approach is _ negation as failure _ @xcite , as an easy effective approximation to the _ cwa _ ( _ closed world assumption _ ) , which is a simple , but uncomputable , way of deducing negative information from positive programs ( see e.g. for a survey on negation in logic programming ) .    on the other hand , functional logic programming ( _ flp _ for short ) is a powerful programming paradigm trying to combine the nicest properties of functional and logic programming ( see for a now ` classical ' survey on _ flp _ ) .",
    "a mainstream in current _ flp _ research considers languages which are biased to the functional programming style , in the sense that programs define functions , but having logic programming capabilities because their operational mechanisms are based on narrowing .",
    "some existing systems of this kind are @xmath0@xcite or the various implementations of _ curry _ @xcite . in the rest of the paper we have in mind such approach when we refer to _",
    "_ flp _ subsumes _ pure _ logic programming : predicates can be defined as functions returning the value ` true ' , for which definite clauses can be written as conditional rewrite rules . in some simple cases it is enough , to handle negation , just to define predicates as two - valued boolean functions returning the values ` true ' or ` false ' .",
    "but negation as failure is far more expressive , as we see in the next section , and it is then of clear interest to investigate a similar notion for the case of _",
    "flp_. failure in logic programs , when seen as functional logic programs , corresponds to failure of reduction to ` true ' .",
    "this generalizes to a natural notion of failure in _ flp _ , which is ` failure of reduction to ( partial ) data constructor value ' , or in other terms , ` failure of reduction to head normal form ' ( _ hnf _ for short ) .",
    "as technical setting for our work we have chosen _ crwl _",
    "@xcite , a well established theoretical framework for _ flp_. the fundamental notion in _ crwl _ is that of non - strict non - deterministic function , for which _ crwl _ provides a firm logical basis . instead of equational logic , which is argued to be unsuitable for _ flp _ in , _ crwl _ considers a constructor based rewriting logic , presented by means of a proof calculus , which determines what statements can be deduced from a given program .",
    "in addition to the proof - theoretic semantics , @xcite develop a model theoretic semantics for _ crwl _ , with existence of distinguished free term models for programs , and a sound and complete lazy narrowing calculus as operational semantics .",
    "the interest of _ crwl _ as a theoretical framework for _ flp _ has been mentioned in , and is further evidenced by its many extensions incorporating relevant aspects of declarative programming like ho features @xcite , polymorphic and algebraic types @xcite , or constraints @xcite .",
    "the framework , with many of these extensions ( like types , ho and constraints ) has been implemented in the system @xmath1 .",
    "here we are interested in extending the proof - theoretic side of _ crwl _ to cope with failure .",
    "more concretely , we look for a proof calculus , which will be called _ crwlf _",
    "( ` _ crwl _ with failure ' ) , which is able to prove failure of reduction in _ crwl_. since reduction in _ crwl _ is expressed by proving certain statements , our calculus will provide proofs of unprovability within _",
    "crwl_. as for the case of _ cwa _ , unprovability is not computable , which means that our calculus can only give an approximation , corresponding to cases which can be intuitively described as ` finite failures ' .",
    "there are very few works about negation in _",
    "flp_. in the work of stuckey about _ constructive negation _",
    "@xcite is adapted to the case of _ flp _ with strict functions and innermost narrowing as operational mechanism . in a similar work",
    "is done for the case of non - strict functions and lazy narrowing .",
    "the approach is very different of the proof - theoretic view of our work .",
    "the fact that we also consider non - deterministic functions makes a significant difference .    the proof - theoretic approach , although not very common , has been followed sometimes in the logic programming field , as in , which develops for logic programs ( with negation ) a framework which resembles , in a very general sense , @xmath2 : a program determines a deductive system for which deducibility , validity in a class of models , validity in a distinguished model and derivability by an operational calculus are all equivalent .",
    "our work attempts to be the first step of what could be a similar programme for _ flp _ extended with the use of failure when writing programs .",
    "the rest of the paper is organized as follows . in section 2",
    "we discuss the interest of using failure as a programming construct in the context of _ flp _ . in section 3",
    "we give the essentials of _ crwl _ which are needed for our work .",
    "section 3 presents the _ crwlf_-calculus , preceded by some illustrative examples .",
    "sections 4 , 5 and 6 constitute the technical core of the paper , presenting the properties of _ crwlf _ and its relation to _",
    "crwl_. finally , section 7 outlines some conclusions and possible future work .",
    "although this work is devoted only to the theoretical aspects of failure in _ flp _ , in this section we argue some possible applications of this resource from the point of view of writing functional logic programs .",
    "_ flp _ combines some of the main capabilities of the two main streams of declarative programming : functional programming ( _ fp _ ) and logic programming ( _ lp _ ) .",
    "theoretical aspects of _ flp _ are well established ( see e.g. ) and there are also practical implementations such as _ curry _ or @xmath1 . disregarding syntax , both pure prolog and",
    "( a wide subset of ) haskell are subsumed by those systems .",
    "the usual claim is then that by the use of an _ flp _ system one can choose the style of programming better suited to each occasion .",
    "however there are features related to failure , mainly in _ lp _ ( but also in _ fp _ ) yet not available in _ flp _ systems .",
    "this poses some problems to _ flp _ : if a logic program uses negation ( a very common situation ) , it can not be seen as an _ flp _ program .",
    "this is not a very serious inconvenience if other features of _ flp _ could easily replace the use of failure .",
    "but if the _ flp _ solution ( without failure ) to a problem is significantly more complex than , say , an _ lp _ solution making use of failure , then it is not worth to use _ flp _ for that problem , thus contradicting in practice the claim that _ flp _ can successfully replace _ lp _ and _ fp _ .",
    "we now give concrete examples of the potential use of a construction to express failure in _ flp _ programs .",
    "we assume for the examples below that we incorporate to _ flp _ the following function to express failure of an expression :    @xmath3    the sensible notion to consider is _ failure of reduction to head normal form _ , since head normal forms ( i.e. , variables or expressions @xmath4 , where @xmath5 is a constructor symbol ) are the expressions representing , without the need of further reduction , defined ( maybe partial ) values .",
    "[ failure to express negation in _ lp _ ]    the most widespread approach to negation in the _ lp _ paradigm is _ negation as failure _ @xcite , of which all _ prolog _ systems provide an implementation .",
    "typically , in a logic program one writes clauses defining the positive cases for a predicate , and the effect of using negation is to ` complete ' the definition with the negative cases , which correspond to failure of the given clauses .",
    "for example , in _ lp _ the predicate _ member _ can be defined as :    @xmath6).\\\\      member(x,[y|ys])\\leftarrow member(x , ys ) .",
    "\\end{array}$ ]    this defines _",
    "member(x , l ) _ as a semidecision procedure to check if @xmath7 is an element of @xmath8 .",
    "if one needs to check that @xmath7 is not an element of @xmath8 , then negation can be used , as in the clause    @xmath9 ) : - not\\   member(x , l).$ ]    predicates like _ member _ can be defined in _",
    "flp _ as _ true_-valued functions , converting clauses into conditional rules returning _ true _ :    @xmath10 ) { \\rightarrow}true \\leftarrow x { \\bowtie}y\\\\      member(x,[y|ys ] ) { \\rightarrow}true \\leftarrow member(x , ys){\\bowtie}true    \\end{array}$ ]    to achieve linearity ( i.e. , no variable repetition ) of heads , a usual requirement in _ flp _ , the condition @xmath11 is used in the first rule .",
    "the symbol @xmath12 ( taken from @xcite ) is used throughout the paper to express ` joinability ' , which means that both sides can be reduced to the same data value ( for the purpose of this example , @xmath12 can be read simply as strict equality ) .    what can not be directly translated into _ flp _ ( without failure ) is a clause like that of _ add _ , but with failure it is immediate :    @xmath13 ) { \\rightarrow}true \\leftarrow   { \\it fails}(member(x , l ) ) { \\bowtie}true , x ' { \\bowtie}x , l ' { \\bowtie}l$ ]    in general , any literal of the form _ not goal _ in a logic program can be replaced by @xmath14 in its _ flp_-translation .",
    "this serves to argue that _ flp _ with failure subsumes _ lp _ with negation , but of course this concrete example corresponds to the category of ` dispensable ' uses of failure , because there is a natural failure - free _ flp _ counterpart to the predicate _ member _ in the form of a bivaluated boolean function , where the failure is expressed by the value _",
    "false_. the following could be such a definition of _ member _ :",
    "@xmath15 ) & \\rightarrow & { \\it false}\\\\      member(x,[y|ys ] ) & \\rightarrow & true \\leftarrow x { \\bowtie}y\\\\      member(x,[y|ys ] ) & \\rightarrow & member(x , ys)\\leftarrow x { \\mathrel{\\mathord{<}\\mkern-4mu\\mathord{>}}}y    \\end{array}$ ]    the symbol @xmath16 ( corresponding to disequality @xmath17 of @xcite ) expresses ` divergence ' , meaning that both sides can be reduced to some extent as to detect inconsistency , i.e. , conflict of constructors at the same position ( outside function applications ) .",
    "now _ add _ can be easily defined without using failure :    @xmath13 ) { \\rightarrow}true \\leftarrow member(x , l ) { \\bowtie}false , x ' { \\bowtie}x , l ' { \\bowtie}l$ ]    the next examples show situations where the use of negation is more ` essential ' , in the sense that it is the natural way ( at least a very natural way ) of doing things .",
    "[ grafo ]    non - deterministic constructs are a useful way of programming problems involving search . in _ flp _",
    "one can choose to use predicates , as in _ lp _ , or non - deterministic functions .",
    "in these cases , the use of failure can greatly simplify the task of programming .",
    "we see an example with non - deterministic functions , a quite specific _ flp _ feature which is known to be useful for programming @xcite in systems like _ curry _ or @xmath1 .",
    "consider the problem of deciding , for acyclic directed graphs , if there is a path connecting two nodes .",
    "a graph can be represented by a non - deterministic function _",
    "next _ , with rules of the form @xmath18 , indicating that there is an arc from @xmath19 to @xmath20 . a concrete graph with nodes _ a _ , _ b _ , _ c _ and _ d _ could be given by the rules :    @xmath21 + @xmath22 + @xmath23 + @xmath24 +    and to determine if there is a path from @xmath7 to @xmath25 we can define :    @xmath26    notice that _ path _ behaves as a semidecision procedure recognizing only the positive cases , and there is no clear way ( in ` classical ' _ flp _ ) of completing its definition with the negatives ones , unless we change from the scratch the representation of graphs .",
    "therefore we can not , for instance , program in a direct way a property like    _ safe(x ) : : = x is not connected with d _    using failure this is an easy task :    @xmath27    with this definition , @xmath28 becomes @xmath29 , while @xmath30 , @xmath31 and @xmath32 are all @xmath33 .",
    "[ failure in search problems ii ] [ nim ]    we examine now an example mentioned in as one striking illustration of the power of failure as expressive resource in _ lp _ . we want to program a two - person finite game where the players must perform alternate legal moves , until one of them , the loser , can not move .",
    "we assume that legal moves from a given state are programmed by a non - deterministic function _",
    "move(state ) _ returning the new state after the movement . using failure",
    "it is easy to program a function to perform a winning movement from a given position , if there is one :    @xmath34    we think it would be difficult to find a simpler coding without using failure .    as a concrete example we consider the well - known game _",
    ", where there are some rows of sticks , and each player in his turn must pick up one or more sticks from one of the rows .",
    "a player loses when he can not make a movement , that is , when there are not more sticks because the other player ( the winner ) has picked up the last one .",
    "nim states can be defined by a list of natural numbers ( represented by @xmath35 and @xmath36 as usual ) , and the non - deterministic function @xmath37 can be programmed as :    @xmath38 ) { \\rightarrow}[pick(n ) |",
    "ns]\\\\   move([n|ns ] ) { \\rightarrow}[n | move(ns)]\\\\[1ex ]   pick ( s(n ) ) { \\rightarrow}n\\\\   pick ( s(n ) ) { \\rightarrow}pick(n ) \\end{array}$ ]    a winning move from the state @xmath39 $ ] can be obtained by reducing the expression @xmath40)$ ] . the proof calculus presented in sect .",
    "[ sec : cal_crwl ] can prove that it can be reduced to @xmath41 $ ] , and it is easy to check that this move guarantees the victory .",
    "compared to the case of _ lp _ , failure is not a so important programming construct in _",
    "fp_. there is still one practical feature of existing _ fp _ languages somehow related to failure , which is the possibility of defining functions with _",
    "default rules_. in many _",
    "systems pattern matching determines _ the _ applicable rule for a function call , and as rules are tried from top to bottom , default rules are implicit in the definitions .",
    "in fact , the @xmath42-th rule in a definition is only applied if the first @xmath43 rules are not applicable .",
    "for example , assume the following definition for the function @xmath44 :    @xmath45    the evaluation of the expression @xmath46 in a functional language like haskell @xcite , will produce the value @xmath35 by the first rule .",
    "the second rule is not used for evaluating @xmath46 , even if pattern matching would succeed if the rule would be considered in isolation .",
    "this sequential treatment of rules is useful in some cases , specially for writing ` last ' rules covering default cases whose direct formulation with pattern matching could be complicated . but observe that in systems allowing such sequential trials of pattern matching , rules have not a declarative meaning by themselves ; their interpretation depends also on the previous rules .",
    "this contrasts with functional logic languages which try to preserve the declarative reading of each rule . in such systems",
    "the expression @xmath46 of the example above is reducible , by applying in a non - deterministic way any of the rules , to the values @xmath35 and @xmath47 .    to achieve ( and generalize ) the effect of default rules in _ flp _ , an explicit syntactical construction _",
    "default _ can be introduced , as it has been done in @xcite .",
    "the function @xmath44 could be defined as :    @xmath48    the intuitive operational meaning is : to reduce a call to @xmath44 proceed with the first rule for @xmath44 ; if the reduction fails then try the default rule .",
    "the problem now is how to achieve this behavior while preserving the equational reading of each rule . using conditional rewrite rules and our function @xmath49",
    ", we can transform the definition of a function to eliminate default rules . in the general case we can consider conditional rewrite rules for the original definition .",
    "let @xmath50 be a function defined as :    @xmath51    the idea of the transformation is to consider a new function @xmath52 defined by the first @xmath43 rules of @xmath50 .",
    "the original @xmath50 will be defined as @xmath52 if it succeeds and as the default rule if @xmath52 fails :    @xmath53      h'(\\overline{t}_1 ) \\to e_1 \\leftarrow \\overline{c}_1\\\\      ... \\\\",
    "h'(\\overline{t}_n ) \\to e_n \\leftarrow \\overline{c}_n\\\\    \\end{array}$ ]    applying this transformation to our function example @xmath44 , we obtain :    @xmath54      f'(0 ) \\to 0\\\\[0.2 cm ]   \\end{array}$ ]    with this definition we have got the expected behavior for @xmath44 without losing the declarative reading of rules .",
    "as another example , we can use a default rule to complete the definition of the function _ path _ in the example [ grafo ] above :    @xmath55    the function _",
    "safe _ can now be written as : @xmath56 where @xmath57 is the boolean function    @xmath58    notice that in this example the ( implicit ) condition for applying the default rule of _ path _ is far more complex than a merely syntactical default case expressing failure of pattern matching , a feature recently discussed in @xcite as useful for _ flp_. of course , default rules in the sense of @xcite and of this paper also cover such syntactical cases .",
    "we give here a short summary of ( a slight variant of ) _ crwl _ , in its proof - theoretic face .",
    "model theoretic semantics and lazy narrowing operational semantics are not considered here .",
    "full details can be found in @xcite .",
    "we assume a signature @xmath59 where @xmath60 is a set of _ constructor _ symbols and @xmath61 is a set of _ function _ symbols , all of them with associated arity and such that @xmath62 .",
    "we also assume a countable set @xmath63 of _ variable _ symbols .",
    "we write @xmath64 for the set of ( total ) _ terms _ ( we say also _ expressions _ ) built up with @xmath65 and @xmath63 in the usual way , and we distinguish the subset @xmath66 of ( total ) constructor terms or ( total ) _ c - terms _ , which only make use of @xmath67 and @xmath63 .",
    "the subindex @xmath65 will usually be omitted .",
    "terms intend to represent possibly reducible expressions , while c - terms represent data values , not further reducible .",
    "we will need sometimes to use the signature @xmath68 which is the result of extending @xmath65 with the new constant ( 0-arity constructor ) @xmath69 , that plays the role of the undefined value . over @xmath68",
    ", we can build up the sets @xmath70 and @xmath71 of ( partial ) terms and ( partial ) c - terms respectively .",
    "partial c - terms represent the result of partially evaluated expressions ; thus , they can be seen as approximations to the value of expressions .    as usual notations",
    "we will write @xmath72 for variables , @xmath73 for constructor symbols , @xmath74 for functions , @xmath75 for terms and @xmath76 for c - terms . in all cases , primes (  ) and subindices can be used .    we will use the sets of substitutions @xmath77 and @xmath78 .",
    "we write @xmath79 for the result of applying @xmath80 to @xmath75 .",
    "given a set of constructor symbols @xmath81 we say that the c - terms @xmath82 and @xmath83 have an _",
    "@xmath81-clash _ if they have different constructor symbols of @xmath81 at the same position .",
    "a _ crwl_-program @xmath84 is a finite set of conditional rewrite rules of the form :    @xmath85    where @xmath86 , and fulfilling the following conditions :    * @xmath87 is a linear tuple ( each variable in it occurs only once ) with @xmath88 ; * @xmath89 ; * each @xmath90 is a constraint of the form @xmath91 ( _ joinability _ ) or @xmath92 ( _ divergence _ ) where @xmath93 ; * _ extra variables _ are not allowed , i.e. , all the variables appearing in the body @xmath75 and the condition @xmath94 must also appear in the head @xmath95 ( @xmath96 ) .",
    "this condition is not required in @xcite ; see the end of this section for a discussion of this issue .",
    "the reading of the rule is : @xmath97 reduces to @xmath75 if the conditions @xmath98 are satisfied .",
    "we write @xmath99 for the set of defining rules of @xmath44 in @xmath84 .    given a program @xmath84 , the proof calculus for _ crwl",
    "_ can derive from it three kinds of statements :    * _ reduction or approximation statements _ : @xmath100 , with @xmath101 and @xmath102 .",
    "the intended meaning of such statement is that @xmath75 can be reduced to @xmath82 , where reduction may be done by applying rewriting rules of @xmath84 or by replacing subterms of @xmath75 by @xmath69 .",
    "if @xmath103 can be derived , @xmath82 represents one of the possible values of the denotation of @xmath75 . * _ joinability statements _ : @xmath104 , with @xmath105 .",
    "the intended meaning in this case is that @xmath75 and @xmath106 can be both reduced to some common totally defined value , that is , we can prove @xmath100 and @xmath107 for some @xmath108 . * _ divergence statements _ : @xmath109 , with @xmath105 .",
    "the intended meaning now is that @xmath75 and @xmath106 can be reduced to some ( possibly partial ) c - terms @xmath82 and @xmath83 having a @xmath110-clash . in @xcite divergence conditions are not considered .",
    "they have been incorporated to _",
    "crwl _ in as a useful and expressive resource for programming that is implemented in the system @xmath1 .",
    "when using function rules to derive statements , we will need to use what are called _ c - instances _ of such rules .",
    "the set of c - instances of a program rule @xmath111 is defined as :    @xmath112_{\\bot}=\\{r\\theta | \\theta\\in csubst_{\\bot}\\}$ ]    parameter passing in function calls will be expressed by means of these c - instances in the proof calculus .",
    "l + ( 1)@xmath113 @xmath114              e\\to\\bot\\\\              \\\\[-0.4 cm ]            \\end{array}$}}$ ] + ( 2)@xmath113 @xmath114              x\\to x\\\\              \\\\[-0.4 cm ]            \\end{array}$}}$ ] @xmath115 + ( 3)@xmath113 @xmath116              e_1\\to t_1, ... ,e_n\\to t_n\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              c(e_1, ... ,e_n)\\to c(t_1, ...",
    ",t_n)\\\\              \\\\[-0.4 cm ]            \\end{array}$}}$ ] @xmath117 +",
    "( 4)@xmath113 @xmath116              e_1\\to s_1, ... ,e_n\\to s_n\\quad c\\quad e\\to t\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(e_1, ... ,e_n)\\to t\\\\              \\\\[-0.4 cm ]            \\end{array}$}}$ ] @xmath118_{\\bot }          \\end{array}$ ] + ( 5)@xmath113 @xmath116              e\\to t\\quad e'\\to t\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              e { \\bowtie}e'\\\\              \\\\[-0.4 cm ]            \\end{array}$}}$ ] @xmath119 if @xmath108 + ( 6)@xmath113 @xmath116              e\\to t\\quad e'\\to t'\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              e { \\mathrel{\\mathord{<}\\mkern-4mu\\mathord{>}}}e'\\\\              \\\\[-0.4 cm ]            \\end{array}$}}$ ] @xmath119 if @xmath120 and have a @xmath121clash +    [ tab : crwl ]    table [ tab : crwl ] shows the proof calculus for _ crwl_. we write @xmath122 for expressing that the statement @xmath123 is provable from the program @xmath84 with respect to this calculus .",
    "the rule ( 4 ) allows to use c - instances of program rules to prove approximations .",
    "these c - instances may contain @xmath69 and by rule ( 1 ) any expression can be reduced to @xmath69 .",
    "this reflects a non - strict semantics .",
    "a variable @xmath7 can only be approximated by itself ( rule 2 ) and by @xmath69 ( rule 1 ) , so a variable is similar to a constant in derivations with this calculus .",
    "nevertheless , when using function rules of the program a variable of such rule can take any value by taking the appropriate c - instance .",
    "the rule ( 3 ) is for term decomposition and rules ( 5 ) and ( 6 ) corresponds to the definition of @xmath12 and @xmath16 respectively .",
    "a distinguished feature of _ crwl _ is that functions can be _ non - deterministic_. for example , assuming the constructors @xmath124 ( zero ) and @xmath125 ( successor ) for natural numbers , a non - deterministic function _ coin _ for expressing the possible results of throwing a coin can defined by the rules :    @xmath126    it is not difficult to see that the previous calculus can derive the statement @xmath127 and also @xmath128 .",
    "the use of c - instances in rule @xmath129 instead of general instances corresponds to _ call time choice _ semantics for non - determinism ( see @xcite ) . as an example , in addition to _ coin _ consider the functions _ add _ and _ double _ defined as :    @xmath130    it is possible to build a _",
    "crwl_-proof for the statement @xmath131 and also for @xmath132 , but not for @xmath133 . as an example of derivation",
    ", we show a derivation for @xmath131 ; at each step we indicate by a number on the left the rule of the calculus applied :    @xmath134          z\\to z\\\\          \\\\[-0.4 cm ]        \\end{array}$}}}}{\\mbox{$        \\begin{array}{c }          \\\\[-0.5 cm ]          coin\\to z          \\\\[-0.3 cm ]        \\end{array } $ } } } \\quad { \\mbox{\\tiny{4}}\\ ! \\frac{{\\mbox{\\tiny{3}}\\ ! \\frac{}{\\mbox{$        \\begin{array}{c }          \\\\[-0.4 cm ]          z\\to z\\\\          \\\\[-0.4 cm ]        \\end{array}$}}}\\quad { \\mbox{\\tiny{3}}\\ ! \\frac{}{\\mbox{$",
    "\\begin{array}{c }          \\\\[-0.4 cm ]          z\\to z\\\\          \\\\[-0.4 cm ]        \\end{array}$}}}\\quad { \\mbox{\\tiny{3}}\\ ! \\frac{}{\\mbox{$",
    "\\begin{array}{c }          \\\\[-0.4 cm ]          z\\to z\\\\          \\\\[-0.4 cm ]        \\end{array}$}}}}{\\mbox{$add(z , z)\\to z$}}}}{\\mbox{$double(coin)\\to z$}}}$ ]    observe that @xmath16 is not the logical negation of @xmath12 .",
    "they are not even incompatible : due to non - determinism , two expressions @xmath135 can satisfy both @xmath104 and @xmath109 ( although this can not happen if @xmath135 are c - terms ) . in the ` coin ' example",
    ", we can derive both @xmath136 and @xmath137 .",
    "the _ denotation _ of an expression @xmath75 can be defined as the set of c - terms to which @xmath75 can be reduced according to this calculus :    @xmath138\\ ! ]",
    "= \\ { t\\in cterm_{\\bot } | \\mathcal{p}{\\vdash_{\\textit{\\tiny crwl}}}e\\to t\\}$ ]    for instance , @xmath139\\ ! ]",
    "= \\{\\bot , z , s(\\bot),s(z)\\}$ ] .    to end our presentation of the _ crwl _ framework we discuss the issue of extra variables ( variables not appearing in left hand sides of function rules ) , which are allowed in @xcite , but not in this paper .",
    "this is not _ as _ restrictive as it could appear : function nesting can replace the use ( typical of logic programming ) of variables as repositories of intermediate values , and in many other cases where extra variables represent unknown values to be computed by search , they can be successfully replaced by non - deterministic functions able to compute candidates for such unknown values .",
    "a concrete example is given by the function _",
    "next _ in example [ grafo ] .",
    "more examples can be found in @xcite .",
    "the only extra variable we have used in sect . [ sec : interest ] is @xmath140 in the definition    @xmath141    of example [ nim ] .",
    "it can be removed by introducing an auxiliary function :    @xmath142    the effect of the condition @xmath143 it to compute a normal form for @xmath144 , which is required in this case to avoid a diverging computation for _",
    "we now address the problem of failure in _",
    "crwl_. our primary interest is to obtain a calculus able to prove that a given expression fails to be reduced .",
    "since reduction corresponds in _ crwl _ to approximation statements @xmath100 , we can reformulate our aim more precisely : we look for a calculus able to prove that a given expression @xmath75 has no possible reduction ( other than the trivial @xmath145 ) in _ crwl _ , i.e. , @xmath138\\ ! ] = \\{\\bot\\}$ ] .    of course",
    ", we can not expect to achieve that with full generality since , in particular , the reason for having @xmath138\\ ! ] = \\{\\bot\\}$ ] can be non - termination of the program as rewrite system , a property which is uncomputable . instead , we look for a suitable computable approximation to the property @xmath138\\ ! ] = \\{\\bot\\}$ ] , corresponding to cases where failure of reduction is due to ` finite ' reasons , which can be constructively detected and managed .",
    "previous to the formal presentation of the calculus , which will be called ( for ` _ crwl _ with failure ' ) we give several simple examples for a preliminary understanding of some key aspects of it , and the reasons underlying some of its technicalities .",
    "consider the following functions , in addition to @xmath146 , defined in sect .",
    "[ sec : cal_crwl ] :    @xmath147    we discuss several situations involving failure with this program :    * the expressions @xmath148 and @xmath149 fail to be reduced , but for quite different reasons .",
    "in the first case @xmath148 does not terminate .",
    "the only possible proof accordingly to _ crwl _ is @xmath150 ( by rule @xmath47 ) ; any attempt to prove @xmath151 with @xmath152 would produce an ` infinite derivation ' . in the second case ,",
    "the only possible derivation is again @xmath153 , but if we try to prove @xmath154 with @xmath152 we have a kind of ` _ finite failure _ ' : rule @xmath155 needs to solve the parameter passing @xmath156 , that could be finitely checked as failed , since no rule of the _ crwl_-calculus is applicable .",
    "the _ crwlf_-calculus does not prove non - termination of @xmath148 , but will be able to detect and manage the failure for @xmath149 .",
    "in fact it will be able to perform a _ constructive proof _ of this failure .",
    "* consider now the expression @xmath157 .",
    "again , the only possible reduction is @xmath158 and it is intuitively clear that this is another case of finite failure . but this failure is not as simple as in the previous example for @xmath149 : in this case the two possible reductions for @xmath146 to defined values are @xmath159 and @xmath160 . both of @xmath124 and @xmath161 fail to match the pattern @xmath162 in the rule for @xmath163 , but",
    "none of them can be used separately to detect the failure of @xmath157 .",
    "a suitable idea is to collect the set of defined values to which a given expression can be reduced . in the case of @xmath146",
    "that set is @xmath164 .",
    "the fact that @xmath165 is the collected set of values of @xmath75 is expressed in _",
    "crwlf _ by means of the statement @xmath166 . in our example , _ crwlf _ will prove @xmath167 .",
    "statements @xmath166 generalize the approximation statements @xmath103 of _ crwl _ , and in fact can replace them .",
    "crwlf _ will not need to use explicit @xmath103 statements . *",
    "how far should we go when collecting values ?",
    "the idea of collecting all values ( and to have them completely evaluated ) works fine in the previous example , but there are problems when the collection is infinite .",
    "for example , according to its definition above , the expression @xmath50 can be reduced to any positive natural number , so the corresponding set would be @xmath168 . then , what if we try to reduce the expression @xmath169 ? from an intuitive point of view",
    "it is clear that the value @xmath124 will not appear in @xmath170 , because all its elements have the form @xmath171 .",
    "the partial value @xmath172 is a common approximation to all the elements of @xmath170 .",
    "here we can understand @xmath69 as an _ incomplete information _ : we know that all the values for @xmath50 are successor of ` something ' , and this implies that they can not be @xmath124 , which suffices for proving the failure of @xmath169 .",
    "the _ crwlf_-calculus will be able to prove the statement @xmath173 , and we say that @xmath172 is a _ sufficient approximation set _",
    "( _ sas _ ) for @xmath50 .",
    "+ in general , an expression will have multiple _ sas _ s .",
    "any expression has @xmath174 as its simplest _ sas_. and , for example , the expression @xmath50 has an infinite number of _ sas _ s : @xmath174 , @xmath175 , @xmath176 , ... the _ sas _ s obtained by the calculus for @xmath146 are @xmath174 , @xmath177,@xmath178 , @xmath179 , @xmath180 and @xmath181 .",
    "the _ crwlf_-calculus provides appropriate rules for working with _ sas _ s .",
    "the derivation steps will be guided by these _ sas _ s in the same sense that _ crwl _ is guided by approximation statements .",
    "* failure of reduction is due in many cases to failure in proving the conditions in the program rules .",
    "the calculus must be able to prove those failures .",
    "consider for instance the expression @xmath182 .",
    "in this case we would try to use the c - instance @xmath183 that allows to perform parameter passing .",
    "but the condition @xmath184 is clearly not provable , so @xmath182 must fail . for achieving it",
    "we must be able to give a proof for _ ` @xmath185 can not be proved with respect to _",
    "crwl_'_. for this purpose we introduce a new constraint @xmath186 that will be true if we can build a _ proof of non - provability _ for @xmath104 . in our case",
    ", @xmath187 is clear because of the clash of constructors . in general",
    "the proof for a constraint @xmath186 will be guided by the corresponding _ sas _",
    "s for @xmath75 and @xmath106 as we will see in the next section . as our initial _",
    "crwl _ framework also allows constraints of the form @xmath109 , we need also another constraint @xmath188 for expressing ` failure of @xmath16 ' .",
    "* there is another important question to justify : we use an explicit representation for failure by means of the new constant symbol @xmath189 .",
    "let us examine some examples involving failures .",
    "first , consider the expression @xmath190 ; for reducing it we would need to do parameter passing , i.e. , matching @xmath191 with some c - instance of the pattern @xmath162 of the definition of @xmath163 .",
    "as @xmath149 fails to be reduced the parameter passing must also fail . if we take @xmath174 as an _ sas _ for @xmath149 we have not enough information for detecting the failure ( nothing can be said about the matching of @xmath162 and @xmath192 ) .",
    "but if we take @xmath193 as an _ sas _ for @xmath149 , this provides enough information to ensure that @xmath194 can not match any c - instance of the pattern @xmath162 .",
    "notice that we allow the value @xmath189 to appear inside the term @xmath194 .",
    "one could think that the information @xmath194 is essentially the same of @xmath189 ( for instance , @xmath189 also fails to match any c - instance of @xmath162 ) , but this is not true in general .",
    "for instance , the expression @xmath195 is reducible to @xmath124 .",
    "but if we take the _",
    "@xmath193 for @xmath149 and we identify the expression @xmath196 with @xmath189 , matching with the rule for @xmath163 would not succeed , and the reduction of @xmath195 would fail",
    ".    we can now proceed with the formal presentation of the _ crwlf_-calculus .",
    "for dealing with failure we consider two new syntactical elements in _ crwlf _ : a function @xmath197 and a constant @xmath189 .",
    "the first one is directly included into the signature , so we consider @xmath198 , where @xmath110 and @xmath199 are sets of _ constructor _ symbols and ( user - defined ) _ functions _ respectively .",
    "this symbol , @xmath197 , stands for a predefined function whose intuitive meaning is :    @xmath3    the boolean constants @xmath200 and",
    "@xmath201 must belong to @xmath110 , as they are needed to define the function @xmath197 . the formal interpretation of this function will be defined by specific rules at the level of the proof - calculus ( table [ tab : crwlf ] ) .",
    "the second syntactical element , the constant @xmath189 , is introduced as an extension of the signature ( as it was the element @xmath69 in _ crwl _ ) .",
    "so we use the extended signature @xmath202 .",
    "we do not include it directly in the signature @xmath65 because its role is to express failure of reduction and it is not allowed to appear explicitly in a program . in the case of the function @xmath197 we want to allow to use it in programs as we have seen in the examples of sect . [",
    "sec : interest ] .",
    "the sets @xmath203 are defined in the natural way , and also the set of substitutions @xmath204 .    a natural _ approximation ordering _",
    "@xmath205 over @xmath206 can be defined as the least partial ordering over @xmath206 satisfying the following properties :    * @xmath207 for all @xmath208 , * @xmath209 , if @xmath210 for all @xmath211 , @xmath212    the intended meaning of @xmath213 is that @xmath75 is less defined or has less information than @xmath106 .",
    "two expressions @xmath214 are _ consistent _ if they can be refined to obtain the same information , i.e. , if there exists @xmath215 such that @xmath216 and @xmath217 .",
    "notice that the only relations satisfied by @xmath189 are @xmath218 and @xmath219 .",
    "in particular , @xmath189 is maximal .",
    "this is reasonable , since @xmath189 represents ` failure of reduction ' and this gives no further refinable information about the result of the evaluation of an expression .",
    "this contrasts with the status given to failure in @xcite , where @xmath189 is chosen to verify @xmath220 for any @xmath82 different from @xmath69 .",
    "we will frequently use the following notation : given @xmath208 , @xmath221 stands for the result of replacing by @xmath69 all the occurrences of @xmath189 in @xmath75 ( notice that @xmath222 , and @xmath223 iff @xmath224 ) .",
    "programs in _ crwlf _ are sets of rules with the same form as in _ crwl _ , but now they can make use of the function @xmath197 in the body and in the condition part , i.e. , _ crwlf _ extends the class of programs of _ crwl _ by allowing the use of _ fails _ in programs . on the other hand , in _ crwlf _",
    "five kinds of statements can be deduced :    * @xmath166 , intended to mean ` _ @xmath225 is an _ sas _ for @xmath75",
    "* @xmath226 , @xmath227 , with the same intended meaning as in _ crwl_. * @xmath228 , @xmath229 , intended to mean failure of @xmath230 and @xmath227 respectively .",
    "we will sometimes speak of @xmath231 as ` constraints ' , and use the symbol @xmath232 to refer to any of them .",
    "the constraints @xmath233 and @xmath12 are called the _ complementary _ of each other ; the same holds for @xmath188 and @xmath16 , and we write @xmath234 for the complementary of @xmath232 .    when proving a constraint @xmath235 the calculus _",
    "crwlf _ will evaluate an _",
    "sas _ for the expressions @xmath75 and @xmath106 .",
    "these _ sas _ s will consist of c - terms from @xmath236 , and provability of the constraint @xmath235 depends on certain syntactic ( hence decidable ) relations between those c - terms .",
    "actually , the constraints @xmath12 , @xmath16 , @xmath233 and @xmath188 can be seen as the result of generalizing to expressions the relations @xmath237 and @xmath238 on c - terms , which we define now .",
    "[ def : arrows ]    * @xmath239 * @xmath240 and @xmath83 have a @xmath110-clash * @xmath241 or @xmath83 contain @xmath189 as subterm , or they have a @xmath110-clash * @xmath238 is defined as the least symmetric relation over @xmath236 satisfying : * * @xmath242 , for all @xmath243 * * @xmath244 , for all @xmath245 * * if @xmath246 then @xmath247 , for @xmath248    the relations @xmath249 and @xmath250 do not take into account the presence of @xmath189 , which behaves in this case as @xmath69 .",
    "the relation @xmath249 is _ strict _ equality , i.e. , equality restricted to total c - terms .",
    "it is the notion of equality used in lazy functional or functional - logic languages as the suitable approximation to ` true ' equality ( @xmath251 ) over @xmath252 .",
    "the relation @xmath250 is a suitable approximation to ` @xmath253 ' , and hence to ` @xmath254 ' ( where @xmath255 stands for logical negation ) .",
    "the relation @xmath256 is also an approximation to ` @xmath254 ' , but in this case using failure information ( @xmath256 can be read as ` @xmath249 fails ' ) . notice that @xmath256 does not imply ` @xmath253 ' anymore ( we have , for instance , @xmath257 ) .",
    "similarly , @xmath238 is also an approximation to ` @xmath258 ' which can be read as ` @xmath250 fails ' .",
    "the following proposition reflects these and more good properties of @xmath259 .",
    "[ prop:1 ] the relations @xmath260 satisfy    * for all @xmath261 * * @xmath262 and @xmath263 * * @xmath264 * * @xmath265 * @xmath266 are monotonic , i.e. , if @xmath267 and @xmath268 then : @xmath269 , where @xmath270 .",
    "furthermore @xmath271 and @xmath272 are the greatest monotonic approximations to @xmath273 and @xmath274 respectively , where @xmath275 is the restriction of @xmath276 to the set of ground ( i.e. , without variables ) c - terms from @xmath236 .",
    "* @xmath249 and @xmath238 are closed under substitutions from @xmath277 ; @xmath256 and @xmath250 are closed under substitutions from @xmath278    we prove each property separately :    * * * * * * @xmath262 : two terms satisfying the relation @xmath249 can not contain @xmath69 neither @xmath189 .",
    "hence @xmath279 and @xmath280 , and the equivalence is trivial .",
    "* * * @xmath263 : the relation @xmath250 is satisfied when the terms have a @xmath110-clash at some position @xmath281 ; since @xmath82 and @xmath282 ( @xmath83 and @xmath283 resp . )",
    "have the same constructor symbols at the same positions , the equivalence is clear . * * the implication @xmath284 is clear from definitions of @xmath250 and @xmath256 . for @xmath285 : if @xmath286 then either @xmath189 appears in @xmath82 or @xmath83 , or @xmath82 and @xmath83 have a @xmath110-clash . in both cases",
    "@xmath287 does not hold . * * for @xmath288 : if @xmath287 then @xmath289 with @xmath108 and we have @xmath290 by applying repeatedly @xmath291 and @xmath292 of the definition of @xmath238 . for @xmath293 let us assume @xmath294 and proceed by induction on the depth @xmath295 of @xmath82 : + @xmath296 :",
    "if @xmath297 or @xmath298 then @xmath82 and @xmath83 can not have any @xmath110-clash and then @xmath299 is not true . if @xmath300 or @xmath301 then @xmath294 implies that @xmath302 or @xmath303 ; therefore @xmath82 and @xmath83 can not have any @xmath110-clash and @xmath299 is not true .",
    "+ @xmath304 : if @xmath305 , then either @xmath306 and @xmath307 is not true , or @xmath308 with @xmath309 for all @xmath211 ; in this case , by i.h . there is not a pair @xmath310 with a @xmath110-clash , so neither @xmath82 and @xmath83 have @xmath110-clashes , and therefore @xmath299 is not true . *",
    "we prove monotonicity for each relation : * * for @xmath249 : by definition of @xmath249 , if @xmath287 then @xmath311 ( they are maximal with respect to @xmath205 ) , hence @xmath312 and @xmath313 and then @xmath314 . * * for @xmath250 : if @xmath299 then @xmath82 and @xmath83 have a @xmath110-clash at some position . as @xmath267 and @xmath268",
    ", then @xmath125 and @xmath315 will have the same @xmath110-clash at the same position , so @xmath316 . * * for @xmath256 : if @xmath82 and @xmath83 have a @xmath110-clash , @xmath125 and @xmath315 will contain the same @xmath110-clash , as in @xmath317 .",
    "if one of them has @xmath189 as subterm , by definition of @xmath205 it is clear that @xmath125 or @xmath315 will also contain @xmath189 , so @xmath318 . * * for @xmath238 : here we proceed by induction on the depth @xmath295 of the term @xmath82 : + @xmath296 : let us check the possibilities for @xmath82 .",
    "if @xmath319 or @xmath320 , then @xmath294 implies @xmath321 or @xmath306 ; since @xmath322 are maximal with respect to @xmath205 , then @xmath312 and @xmath313 , so we will also have @xmath323 .",
    "if @xmath324 then @xmath325 and then it is clear that @xmath323 . if @xmath297 then @xmath326 and it is clear that @xmath323 .",
    "+ @xmath304 : in this case @xmath305 and then either @xmath306 , what implies @xmath327 and then @xmath323 , or @xmath308 with @xmath328 for all @xmath211 . from @xmath267 and @xmath268",
    "it follows that @xmath329 and @xmath330 , and by i.h .",
    "we have @xmath331 for all @xmath332 , what implies @xmath323 .",
    "+ now we prove that @xmath271 and @xmath272 are the greatest monotonic approximations to @xmath273 and @xmath274 respectively .",
    "we note by @xmath333 the set of all ground @xmath334 . * * for @xmath271 , assume that a relation @xmath335 verifies + @xmath336 + we must prove that @xmath111 is included in @xmath271 , that is : @xmath337 , for any @xmath338 .",
    "we reason by contradiction .",
    "assume @xmath339 and @xmath340 .",
    "then , by definition of @xmath271 , @xmath82 and @xmath83 do not contain @xmath189 and do not have a @xmath110-clash .",
    "then either @xmath341 , or @xmath82 and @xmath83 differ because at some positions one of them has @xmath69 while the other has not . in both cases",
    "it is easy to see that there exists @xmath342 ( totally defined ) such that @xmath267 and @xmath343 . by monotonicity of @xmath111",
    "we have @xmath344 what implies @xmath345 , what is a contradiction , since @xmath346 . * * for @xmath272 we proceed in a similar way as in the previous point : assuming that @xmath335 verifies + @xmath347 + we must prove @xmath348 .",
    "but if @xmath339 then @xmath349 , so @xmath82 and @xmath83 can not have any @xmath110-clash . they could contain @xmath189 as subterm but then , by @xmath317 and @xmath292 of the definition of @xmath238 , we will have @xmath350 . *",
    "the property is clear for @xmath249 : if we replace in a c - term all the occurrences of a variable by a totally defined c - term , we will obtain a totally defined c - term . for @xmath250 ,",
    "such substitution preserves the @xmath110-clash of the original c - terms .",
    "+ for @xmath256 , if some of the original c - terms had @xmath189 as a subterm , the substitution preserves this occurrence of @xmath189 . on the other hand ,",
    "if they had a @xmath110-clash , then it is clear that this clash will also be present under the substitution . + for @xmath238 , suppose @xmath294 and @xmath351 ; we proceed by induction on the depth @xmath295 of the term @xmath82 : + @xmath296 : if @xmath324 , then @xmath352 and it is clear that @xmath353 . for the cases",
    "@xmath319 and @xmath354 we have two possibilities for @xmath83 : @xmath306 or @xmath321 ; if @xmath306 the result is clear .",
    "if we have @xmath355 it is not difficult to prove that @xmath356 by applying repeatedly @xmath291 and @xmath292 of definition of @xmath238 .",
    "the last case , if @xmath357 is trivial because @xmath80 does not change the terms .",
    "+ @xmath304 : in this case @xmath305 .",
    "if @xmath306 the proof is as in the base case , otherwise @xmath308 with @xmath358 for all @xmath332 . by i.h .",
    "we have @xmath359 and then , by @xmath292 of the definition of @xmath238 we will have @xmath353 .",
    "@xmath360    by _ ( b ) _ , we can say that @xmath260 behave well with respect to the information ordering : if they are true for some terms , they remain true if we refine the information contained in the terms . furthermore , _",
    "( b ) _ states that @xmath361 are defined ` in the best way ' ( at least for ground c - terms ) as computable approximations to @xmath362 and @xmath363 . for c - terms with variables ,",
    "we must take care : for instance , given the constructor @xmath124 , we have @xmath364 , but not @xmath365 .",
    "actually , to have @xmath365 would violate a basic intuition about free variables in logical statements : if the statement is true , it should be true for any value ( taken from an appropriate range ) substituted for its free variables .",
    "the part _ ( c ) _ shows that the definitions of @xmath260 respect such principle .",
    "propositions [ prop:2 ] and [ prop:3 ] of the next section show that monotonicity and closure by substitutions are preserved when generalizing @xmath260 to @xmath231 .",
    "we can present now the proof rules for the _ crwlf_-calculus , which are shown in table [ tab : crwlf ] . the rules 6 and 7 use a generalized notion of c - instances of a rule @xmath111 : @xmath112_{\\bot,{\\textsf{\\scriptsize f } } } = \\ { r\\theta\\   | \\",
    "\\theta\\in csubst_{\\bot,{\\textsf{\\scriptsize f } } } \\}$ ] .",
    "we will use the notation @xmath366 ( @xmath367 resp . ) for expressing that the statement @xmath123 is provable ( is not provable resp . ) with respect to the calculus _",
    "crwlf _ and the program @xmath84 .",
    "_ crwlf_-derivations have a tree structure ( see e.g. example [ ex:5 ] ) ; many results in the following sections use induction over the _ size _ of the derivation , i.e. , the number of nodes in the derivation tree , which corresponds to the number of inference steps .",
    "l    ( 1)@xmath113 @xmath368              \\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              e{\\vartriangleleft}\\ { \\bot\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] + ( 2)@xmath113 @xmath368              \\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              x{\\vartriangleleft}\\ { x\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] @xmath369 + ( 3)@xmath113 @xmath368              e_1{\\vartriangleleft}{\\mathcal{c}}_1\\quad ... \\quad e_n{\\vartriangleleft}{\\mathcal{c}}_n\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              c(e_1, ... ,e_n){\\vartriangleleft}\\{c(t_1 , ... , t_n)\\ | \\ \\overline{t}\\in          { \\mathcal{c}}_1\\times ... \\times{\\mathcal{c}}_n \\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] @xmath370 + ( 4)@xmath113 @xmath368              e_1{\\vartriangleleft}{\\mathcal{c}}_1\\quad ... \\quad e_n{\\vartriangleleft}{\\mathcal{c}}_n\\quad ...",
    "\\quad          f(\\overline{t}){\\vartriangleleft_{_r}}{\\mathcal{c}}_{r,\\overline{t}}\\quad ... \\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(e_1, ... ,e_n){\\vartriangleleft}\\bigcup_{r\\in\\mathcal{p}_f , \\overline{t}\\in{\\mathcal{c}}_1\\times ...",
    "\\times{\\mathcal{c}}_n }          { \\mathcal{c}}_{r,\\overline{t}}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] @xmath371 + ( 5)@xmath113 @xmath368              \\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(\\overline{t}){\\vartriangleleft_{_r}}\\ { \\bot\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] + ( 6)@xmath113 @xmath368              e{\\vartriangleleft}{\\mathcal{c}}\\quad \\overline{c}\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(\\overline{t}){\\vartriangleleft_{_r}}{\\mathcal{c}}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] @xmath119 @xmath372_{\\bot,{\\textsf{\\scriptsize f}}}$ ] + ( 7)@xmath113 @xmath368              e_i\\tilde{\\diamondsuit } e'_i\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(\\overline{t}){\\vartriangleleft_{_r}}\\ { { \\textsf{\\scriptsize f}}\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] @xmath119 @xmath373_{\\bot,{\\textsf{\\scriptsize f}}}$ ] , where @xmath211 + ( 8)@xmath113 @xmath368              \\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(t_1, ... ,t_n){\\vartriangleleft_{_r}}\\ { { \\textsf{\\scriptsize f}}\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ]    .rules for _ crwlf_-provability [ cols= \" < \" , ]      + ( 9)@xmath113 @xmath368              e{\\vartriangleleft}{\\mathcal{c}}\\quad e'{\\vartriangleleft}{\\mathcal{c}}'\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              e { \\bowtie}e'\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] @xmath374 + ( 10)@xmath113 @xmath368              e{\\vartriangleleft}{\\mathcal{c}}\\quad e'{\\vartriangleleft}{\\mathcal{c}}'\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              e{\\mathrel{\\mathord{<}\\mkern-4mu\\mathord{>}}}e'\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] @xmath375 + ( 11)@xmath113 @xmath368              e{\\vartriangleleft}{\\mathcal{c}}\\quad",
    "e'{\\vartriangleleft}{\\mathcal{c}}'\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              e{\\not\\bowtie}e'\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] @xmath376 + ( 12)@xmath113 @xmath368              e{\\vartriangleleft}{\\mathcal{c}}\\quad e'{\\vartriangleleft}{\\mathcal{c}}'\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              e{\\mathrel{\\mathord{<}\\mkern-6mu\\mathord{/}\\mkern-6mu\\mathord{>}}}e'\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] @xmath377 + ( 13)@xmath113 @xmath368              e{\\vartriangleleft}\\{{\\textsf{\\scriptsize f}}\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              { \\it fails}(e){\\vartriangleleft}\\{{\\it true}\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] + ( 14)@xmath113 @xmath368              e{\\vartriangleleft}{\\mathcal{c}}\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              { \\it fails}(e){\\vartriangleleft}\\{{\\it false}\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] @xmath378 +    [ tab : crwlf ]    the first three rules are analogous to those of the _ crwl_-calculus , now dealing with _ sas _",
    "s instead of simple approximations ( notice the cross product of _ sas _ s in rule 3 ) .",
    "rule 4 is a complex rule which requires some explanation to make clear its reading and , more importantly , its decidability : to obtain an _ sas _",
    "@xmath379 for an expression @xmath380 ( that is , to derive @xmath381 ) we must first obtain _ sas _",
    "s for @xmath382 ( that is , we must derive @xmath383 ) ; then for each combination @xmath384 of values in these _ sas _ s ( that is , for each @xmath385 ) and each program rule @xmath111 for @xmath44 , a part @xmath386 of the whole _",
    "sas _ is produced ; the union of all these partial _ sas _ s constitutes the final _ sas _",
    "@xmath379 for @xmath387 .",
    "notice that since _ sas _",
    "s are finite sets and programs are finite sets of rules , then there is a finite number of @xmath386 to be calculated in the premises of the rule , and the union of all of them ( the final calculated _ sas _ in the rule ) is again a finite set .",
    "rule 4 is quite different from rule 4 in _ crwl _ , where we could use any c - instance of any rule for @xmath44 ; here we need to consider simultaneously the contribution of each rule to achieve ` complete ' information about the values to which the expression can be evaluated .",
    "we use the notation @xmath388 to indicate that only the rule @xmath111 is used to produce @xmath379 .",
    "rules 5 to 8 consider all the possible ways in which a concrete rule @xmath111 can contribute to the _ sas _ of a call @xmath95 , where the arguments @xmath384 are all in @xmath236 ( they come from the evaluation of the arguments of a previous call @xmath387 )",
    ". rules 5 and 6 can be viewed as _ positive _ contributions .",
    "the first one obtains the trivial _ sas _ and 6 works if there is a c - instance of the rule @xmath111 with a head identical to the head of the call ( parameter passing ) ; in this case , if the constraints of this c - instance are provable , then the resulting _ sas _ is generated by the body of the c - instance .",
    "rules 7 and 8 consider the _ negative _ or _ failed _ contributions",
    ". rule 7 applies when parameter passing can be done , but it is possible to prove the complementary @xmath389 of one of the constraints @xmath390 in the condition of the used c - instance . in this case",
    "the constraint @xmath390 ( hence the whole condition in the c - instance ) fails . finally , rule 8 considers the case in which parameter passing fails because of a @xmath391-clash between one of the arguments in the call and the corresponding pattern in @xmath111 .",
    "we remark that for given @xmath95 and @xmath111 , the rule 5 and at most one of rules 6 to 8 are applicable .",
    "this fact , although intuitive , is far from being trivial to prove and constitutes in fact an important technical detail in the proofs of the results in the next section .    rules 9 to 12 deal with constraints . with the use of the relations",
    "@xmath259 introduced in sect .",
    "3.3 the rules are easy to formulate .",
    "for @xmath104 it is sufficient to find two c - terms in the _ sas _",
    "s verifying the relation @xmath249 , what in fact is equivalent to find a common totally defined c - term such that both expressions @xmath75 and @xmath106 can be reduced to it ( observe the analogy with rule 5 of _ crwl _ ) . for the complementary constraint",
    "@xmath233 we need to use all the information of _ sas _ s in order to check the relation @xmath256 over all the possible pairs .",
    "the explanation of rules 10 and 12 is quite similar",
    ".    finally rules 13 and 14 provide together a formal definition of the function @xmath197 supported by the notion of _",
    "sas_. notice that the _ sas _ s @xmath174 or @xmath392 do not provide enough information for reducing a call to @xmath197 .",
    "the call @xmath393 is only reduced to @xmath394 when every possible reduction of the expression @xmath75 is failed ; and it is reduced to @xmath395 there is some reduction of @xmath75 to some ( possible partial ) c - term of the form @xmath396 ( @xmath397 ) or @xmath7 .",
    "the next example shows a derivation of failure using the _ crwlf_-calculus .",
    "[ ex:5 ]    let us consider a program @xmath84 with the constructors @xmath398 for natural numbers , @xmath399 $ ] and `",
    "@xmath400 ' for lists ( although we use prolog - like notation for them , that is , @xmath401 $ ] represents the list @xmath402 ) and also the constructors @xmath403 that represent the boolean values _",
    "true _ and _ false_. assume the functions @xmath146 and @xmath50 defined in sect .",
    "[ sec : cal_crwl ] and sect .",
    "[ sec : examples ] respectively and also the function @xmath404 ( member ) defined as :    @xmath405){\\rightarrow}\\mathsf{t}\\leftarrow x{\\bowtie}y\\\\    mb(x,[y | \\mathit{ys}]){\\rightarrow}\\mathsf{t}\\leftarrow mb(x,\\mathit{ys}){\\bowtie}\\mathsf{t } \\end{array}$ ]    if we try to evaluate the expression @xmath406)$ ] it will fail . intuitively ,",
    "from definition of @xmath50 the list in the second argument can be reduced to lists of the form @xmath407 $ ] and the possible values of @xmath146 , @xmath124 and @xmath408 , do not belong to those lists .",
    "the _ crwlf_-calculus allows to build a proof for this fact , that is , @xmath406){\\vartriangleleft}\\{{\\textsf{\\scriptsize f}}\\}$ ] , in the following way : by application of rule 4 the proof could proceed by generating _ sas _ s for the arguments    @xmath409{\\vartriangleleft}\\ { [ s(s(\\bot))]\\}\\quad ( \\varphi_2)$ ]    and then collecting the contributions of rules of @xmath404 for each possible combination of values for the arguments ; for the pair @xmath410)$ ] the contribution of the rules defining @xmath404 ( here we write @xmath411 to refer to the first rule of _ mb _ and @xmath412 for the second ) will be    @xmath413){\\vartriangleleft}_1\\{{\\textsf{\\scriptsize f}}\\}\\quad ( \\varphi_3)\\qquad\\quad mb(z,[s(s(\\bot))]){\\vartriangleleft}_2\\{{\\textsf{\\scriptsize f}}\\}\\quad ( \\varphi_4)$ ]    and for the pair @xmath414)$ ] we will have    @xmath415){\\vartriangleleft}_1\\{{\\textsf{\\scriptsize f}}\\}\\quad ( \\varphi_5)\\qquad\\quad mb(s(z),[s(s(\\bot))]){\\vartriangleleft}_2\\{{\\textsf{\\scriptsize f}}\\}\\quad ( \\varphi_6)$ ]    the full derivation takes the form :    @xmath416                 \\varphi_{1}\\quad\\varphi_{2}\\quad\\varphi_{3}\\quad\\varphi_{4}\\quad    \\varphi_{5}\\quad\\varphi_{6}\\quad\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              mb(coin,[s(h)]){{\\vartriangleleft}}\\{{\\textsf{\\scriptsize f}}\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ]    the _ sas _ @xmath193 in the conclusion comes from the union of all the contributing _ sas _",
    "s of @xmath417 , @xmath418 , @xmath419 and @xmath420 .",
    "the statements @xmath421 to @xmath420 require of course their own proof , which we describe now . at each step ,",
    "we indicate by a number on the left the rule of the calculus applied in each case :    the derivation for @xmath421 is not difficult to build , and for @xmath422 it is :    @xmath423          z{{\\vartriangleleft}}\\ { \\bot\\}\\\\          \\\\[-0.3 cm ]        \\end{array } $ } } } } { \\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          s(z){{\\vartriangleleft}}\\ { s(\\bot)\\}\\\\          \\\\[-0.3 cm ]        \\end{array } $ } } } } { \\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          h{{\\vartriangleleft}}_{_{1\\!}}\\ { s(\\bot)\\}\\\\          \\\\[-0.3 cm ]        \\end{array } $ } } } \\quad { \\mbox{\\tiny{6}}\\ ! \\frac{{\\mbox{\\tiny{3}}\\ !",
    "\\frac{{\\mbox{\\tiny{1}}\\ ! \\frac{}{\\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          h{{\\vartriangleleft}}\\ { \\bot\\}\\\\          \\\\[-0.3 cm ]        \\end{array } $ } } } } { \\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          s(h){{\\vartriangleleft}}\\ { s(\\bot)\\}\\\\          \\\\[-0.3 cm ]        \\end{array } $ } } } } { \\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          h{{\\vartriangleleft}}_{_{2\\!}}\\ { s(\\bot)\\}\\\\          \\\\[-0.3 cm ]        \\end{array } $ } } } } { \\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          h{{\\vartriangleleft}}\\ { s(\\bot)\\}\\\\          \\\\[-0.3 cm ]        \\end{array } $ } } } } { \\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          s(h){{\\vartriangleleft}}\\ { s(s(\\bot))\\}\\\\          \\\\[-0.3 cm ]        \\end{array } $ } } } \\quad { \\mbox{\\tiny{3}}\\ ! \\frac{}{\\mbox{$",
    "\\begin{array}{c }          \\\\[-0.3 cm ]          [ \\ ] { { \\vartriangleleft}}\\ { [ \\ ] \\}\\\\          \\\\[-0.3 cm ]        \\end{array } $ } } } } { \\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          [ s(h)]{{\\vartriangleleft}}\\ { [ s(s(\\bot))]\\}\\\\          \\\\[-0.3 cm ]        \\end{array } $ } } } $ ]    for @xmath417 it can be done as follows :    @xmath424          z{{\\vartriangleleft}}\\{z\\}\\\\          \\\\[-0.3 cm ]        \\end{array } $ } } } \\quad { \\mbox{\\tiny{3}}\\ !    \\frac{{\\mbox{\\tiny{3}}\\ ! \\frac{{\\mbox{\\tiny{1}}\\ ! \\frac{}{\\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          \\bot{{\\vartriangleleft}}\\{\\bot\\}\\\\          \\\\[-0.3 cm ]        \\end{array } $ } } } } { \\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          s(\\bot){{\\vartriangleleft}}\\{s(\\bot)\\}\\\\          \\\\[-0.3 cm ]        \\end{array }        $ } } } } { \\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          s(s(\\bot)){{\\vartriangleleft}}\\{s(s(\\bot))\\}\\\\          \\\\[-0.3 cm ]        \\end{array }        $ } } } } { \\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          z{\\not\\bowtie}s(s(\\bot))\\\\          \\\\[-0.3 cm ]        \\end{array } $ } } } } { \\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          \\varphi_3\\equiv mb(z,[s(s(\\bot))]){{\\vartriangleleft}}_{_1\\!}\\{{\\textsf{\\scriptsize f}}\\}\\\\          \\\\[-0.3 cm ]        \\end{array } $ } } } $ ]    here , the failure is due to a failure in the constraint @xmath425 of the used program rule , what requires to prove the complementary constraint @xmath426 by rule ( 11 ) . in this case",
    "there is a clear clash of constructors ( @xmath124 and @xmath125 ) .",
    "for @xmath418 a derivation might be this one :    @xmath427          z{{\\vartriangleleft}}\\{z\\}\\\\          \\\\[-0.3 cm ]        \\end{array } $ } } } \\",
    "{ \\mbox{\\tiny{3}}\\ ! \\frac{}{\\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          [ \\ ] { { \\vartriangleleft}}\\ { [ \\ ] \\}\\\\          \\\\[-0.3 cm ]        \\end{array }        $ } } } \\ { \\mbox{\\tiny{8}}\\ ! \\frac{}{\\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          mb(z,[\\ ] ) { { \\vartriangleleft}}_{_{1\\!}}\\{{\\textsf{\\scriptsize f}}\\}\\\\          \\\\[-0.3 cm ]        \\end{array }        $ } } } \\ { \\mbox{\\tiny{8}}\\ ! \\frac{}{\\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          mb(z,[\\ ] ) { { \\vartriangleleft}}_{_{2\\!}}\\{{\\textsf{\\scriptsize f}}\\}\\\\          \\\\[-0.3 cm ]        \\end{array }        $ } } } } { \\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          mb(z,[\\ ] ) { { \\vartriangleleft}}\\{{\\textsf{\\scriptsize f}}\\}\\\\          \\\\[-0.3 cm ]        \\end{array }        $ } } } \\",
    "{ \\mbox{\\tiny{3}}\\ ! \\frac{}{\\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          \\mathsf{t}{{\\vartriangleleft}}\\ { \\mathsf{t}\\}\\\\          \\\\[-0.3 cm ]        \\end{array }        $ } } } } { \\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          mb(z,[\\ ] ) { \\not\\bowtie}\\{\\mathsf{t}\\}\\\\          \\\\[-0.3 cm ]        \\end{array }        $ } } } } { \\mbox{$        \\begin{array}{c }          \\\\[-0.3 cm ]          \\varphi_4\\equiv mb(z,[s(s(\\bot))]){{\\vartriangleleft}}_{_2\\!}\\{{\\textsf{\\scriptsize f}}\\}\\\\          \\\\[-0.3 cm ]        \\end{array }        $ } } } $ ]    the failure is due again to a failure in the constraint of the rule and in this case the complementary constraint is @xmath428){\\not\\bowtie}\\ \\mathsf{t}$ ] .",
    "now it is involved the failure for the expression @xmath428)$ ] that is proved by rule ( 4 ) of the calculus .",
    "the _ sas _",
    "s for the arguments only produce the combination @xmath429)$ ] and both rules of @xmath404 fail over it by rule ( 8) of the calculus .",
    "the derivations for @xmath419 and @xmath420 are quite similar to those of @xmath417 and @xmath418 respectively .",
    "all the contributions obtained from @xmath430 and @xmath431 are @xmath193 , and putting them together we obtain @xmath193 as an _ sas _ for the original expression @xmath406)$ ] , as it was expected .",
    "in this section we explore some technical properties of the _ crwlf_-calculus which are the key for proving the results of the next section , where we relate the _ crwlf_-calculus to the _ crwl_-calculus . in the following we assume a fixed program @xmath432 .",
    "the non - determinism of the _ crwlf_-calculus allows to obtain different _ sas _",
    "s for the same expression . as an _",
    "sas _ for an expression is a finite approximation to the denotation of the expression it is expected some kind of consistency between _ sas _",
    "s for the same expression",
    ". given two of them , we can not ensure that one _ sas _ must be more defined than the other in the sense that all the elements of the first are more defined than all of the second .",
    "for instance , two _",
    "s for @xmath146 are @xmath178 and @xmath433 .",
    "the kind of consistency for _ sas _ s that we can expect is the following :    two sets @xmath434 are _ consistent _ iff for all @xmath435 there exists @xmath436 ( and vice versa , for all @xmath436 there exists @xmath435 ) such that @xmath82 and @xmath83 are consistent .    our first result states that two different _ sas _",
    "s for the same expression must be consistent .",
    "[ th:1 ] given @xmath208 , if @xmath437 and @xmath438 , then @xmath379 and @xmath439 are consistent .",
    "this result is a trivial corollary of part @xmath440 of the following lemma .",
    "[ lem : consist ] for any @xmath441    * if @xmath442 are consistent , @xmath437 and @xmath443 , then @xmath379 and @xmath439 are consistent . *",
    "if @xmath444 are consistent and @xmath445 are also consistent , then : @xmath446    for proving the consistency lemma we will split @xmath447 into @xmath448 and also strengthen the lemma with a new part @xmath449 :    * if @xmath444 are consistent and @xmath445 are also consistent , then : * * @xmath450 * * @xmath451 * given @xmath452 pairwise consistent and @xmath453 , if @xmath454 , then @xmath379 and @xmath439 are consistent",
    ".    now we will prove @xmath455 and @xmath449 simultaneously by induction on the size @xmath456 of the derivation for @xmath457 in @xmath440 , @xmath458 in @xmath459 , @xmath460 in @xmath461 and @xmath462 in @xmath449 .",
    "@xmath463 :    * the possible derivations in one step are : * * @xmath464 .",
    "sas _ is consistent with any other ; * * @xmath465 . then either @xmath466 or @xmath467 , so the possibilities for @xmath439 are @xmath468 or @xmath174 , both consistent with @xmath468 ; * * @xmath469 , where @xmath470 . in this case",
    "@xmath106 must be @xmath5 or @xmath69 , whose possible _ sas _ s are @xmath471 and @xmath174 , that are consistent with @xmath471 .",
    "* there is no derivation of the form @xmath104 or @xmath109 in one step . * the possible derivations of the form @xmath462 are : * * @xmath472 .",
    "sas _ is consistent with any other ; * * @xmath473 , by means of rule 8 , i.e. , there exists some @xmath474 and some @xmath475 such that @xmath476 and @xmath477 have a @xmath391-clash at some position @xmath281 .",
    "the _ sas _",
    "@xmath439 for @xmath478 using the function rule @xmath111 must be done by one of the rules 5 to 8 : * * * if rule 5 is used then @xmath479 that is consistent with @xmath379 ; * * * rule 6 is not applicable : @xmath477 and @xmath480 are consistent because @xmath384 and @xmath481 are pairwise consistent ; then either @xmath480 at position @xmath281 has the same constructor symbol as @xmath477 ( and then the clash with @xmath476 remains ) , or @xmath480 at @xmath281 or some of its ancestor positions has @xmath69 . in both cases",
    "it is clear that there is not any c - instance of @xmath111 for using rule 6 ; * * * by rules 7 or 8 the _ sas _ is @xmath193 that is consistent with the initial one @xmath193 .",
    "@xmath482 :    * in @xmath483 steps the possible derivations for @xmath457 are : * * @xmath368              e_1{\\vartriangleleft}{\\mathcal{c}}_1\\quad ...",
    "\\quad e_n{\\vartriangleleft}{\\mathcal{c}}_n\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              e = c(e_1, ... ,e_n){\\vartriangleleft}\\ { c(t_1, ... ,t_n ) | \\overline{t}\\in{\\mathcal{c}}_1\\times        ... \\times{\\mathcal{c}}_n\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$ } } } $ ] by rule 3 , where @xmath248 ( @xmath484 ) . then either @xmath467 , whose only possible _ sas _",
    "is @xmath174 , that is consistent with any other , or @xmath485 with @xmath486 and @xmath487 being consistent for @xmath488 and the _ sas _ is produced by rule 3 : @xmath489              e'_1{\\vartriangleleft}{\\mathcal{c}}'_1\\quad ... \\quad e'_n{\\vartriangleleft}{\\mathcal{c}}'_n\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              e'=c(e'_1, ... ,e'_n){\\vartriangleleft}\\ { c(t'_1, ... ,t'_n ) | \\overline{t}'\\in{\\mathcal{c}}'_1\\times        ... \\times{\\mathcal{c}}'_n\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}\\ ] ] by i.h .",
    "@xmath490 is consistent with @xmath491 for all @xmath211 and then it is clear that @xmath379 and @xmath439 are also consistent . * * @xmath368              e_1{\\vartriangleleft}{\\mathcal{c}}_1\\quad ...",
    "\\quad e_n{\\vartriangleleft}{\\mathcal{c}}_n\\quad f(\\overline{t}){\\vartriangleleft_{_r}}{\\mathcal{c}}_{r,\\overline{t}}\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              e = f(e_1, ... ,e_n){\\vartriangleleft}\\bigcup_{r\\in\\mathcal{p}_f,\\overline{t}\\in{\\mathcal{c}}_1\\times          ...",
    "\\times{\\mathcal{c}}_n } { \\mathcal{c}}_{r,\\overline{t}}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] by rule 4",
    ". then either @xmath467 whose only possible _",
    "sas _ is @xmath174 that is consistent with any other , or @xmath492 with @xmath493 consistent for all @xmath332 .",
    "if the _ sas _ for @xmath106 is generated by rule 1 of the calculus , the result would be clear and for rule 4 we have @xmath368              e'_1{\\vartriangleleft}{\\mathcal{c}}'_1\\quad ...",
    "\\quad e'_n{\\vartriangleleft}{\\mathcal{c}}'_n\\quad f(\\overline{t}'){\\vartriangleleft_{_r}}{\\mathcal{c}}_{r,\\overline{t}'}\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              e'=f(e'_1, ... ,e'_n){\\vartriangleleft}\\bigcup_{r\\in\\mathcal{p}_f,\\overline{t}'\\in{\\mathcal{c}}'_1\\times          ...",
    "\\times{\\mathcal{c}}'_n } { \\mathcal{c}}_{r,\\overline{t}'}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] + by i.h . @xmath491 and @xmath490 are consistent for all @xmath211 , what means that for each @xmath494 there exists @xmath495 consistent with @xmath384 . again by i.h .",
    "we have that each _",
    "@xmath386 is consistent with @xmath496 and it can be easily proved that @xmath497 is then consistent with @xmath498 . *",
    "* @xmath368              e_1{\\vartriangleleft}\\{{\\textsf{\\scriptsize f}}\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              e={\\it fails}(e_1){\\vartriangleleft}\\{{\\it true}\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] by rule 13 .",
    "if @xmath467 the result is clear , else @xmath499 .",
    "then the _ sas _ for @xmath106 requires to obtain an _",
    "@xmath439 for @xmath500 .",
    "by i.h . , @xmath439 must be consistent with @xmath193 what means that @xmath501 or @xmath502 .",
    "then , the possible _ sas _",
    "s for @xmath106 are @xmath174 and @xmath394 ( by the same rule 13 ) , both consistent with @xmath394 .",
    "* * @xmath368              e_1{\\vartriangleleft}{\\mathcal{c}}_1\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              e={\\it fails}(e_1){\\vartriangleleft}\\{{\\it false}\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] by rule 14 , such that there exists @xmath503 with @xmath152 , @xmath504 .",
    "if @xmath467 the result is clear . otherwise , if @xmath499 the _ sas _ for @xmath106 must be obtained by one of the rules 1 , 13 or 14 . by rule 1 it would be @xmath174 consistent with any other one ; rule 13 would need to obtain the _ sas _",
    "@xmath193 for @xmath500 , but this is not possible because it must be consistent with @xmath505 by i.h .",
    ", so rule 13 is not applicable ; and rule 14 would provide the _",
    "@xmath395 for @xmath106 , consistent with itself .",
    "* if we have a derivation for @xmath458 by rule 9 , there exist two _ sas _",
    "s @xmath506 and @xmath507 such that @xmath508 and there exist @xmath509 with @xmath287 . +",
    "now , let @xmath510 be consistent with @xmath511 respectively , and assume that @xmath512 can be proved .",
    "we reason by contradiction .",
    "since @xmath512 is provable , we can prove @xmath513 such that for all @xmath514 it will be @xmath318 .",
    "@xmath506 is consistent with @xmath515 , what implies that there exists @xmath516 consistent with @xmath82 , and then there exists @xmath517 such that @xmath518 . in a similar way",
    ", there exists @xmath519 consistent with @xmath83 , so there exists @xmath520 such that @xmath521 . + as @xmath516 and @xmath519 we would have @xmath522 ; by monotonicity of @xmath256 we have @xmath523 , what implies @xmath524 .",
    "but monotonicity of @xmath249 , together with @xmath525 , implies @xmath526 , what is a contradiction .",
    "* the case of @xmath460 proceeds similarly to @xmath459 , using in this case monotonicity of @xmath250 and @xmath238 .    in @xmath483",
    "steps the possible derivations for @xmath462 where @xmath527 , are :    * @xmath368              e\\theta{\\vartriangleleft}{\\mathcal{c}}\\quad \\overline{c}\\theta\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(\\overline{t}){\\vartriangleleft_{_r}}{\\mathcal{c}}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] by rule 6 , using the c - instance @xmath528 ( @xmath529 ) , such that @xmath530 .",
    "the derivation @xmath531 must be done by one of the rules 5 to 8 : * * if @xmath532 by rule 5 , it is clear that this _",
    "sas _ is consistent with @xmath379 ; * * if the derivation is done by rule 6 , it will have the form @xmath368",
    "e\\theta'{\\vartriangleleft}{\\mathcal{c}}'\\quad \\overline{c}\\theta'\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(\\overline{t}'){\\vartriangleleft_{_r}}{\\mathcal{c}}'\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] using a c - instance @xmath533 of @xmath111 .",
    "in particular , we have @xmath534 and we also had @xmath530 .",
    "as @xmath384 and @xmath481 are pairwise consistent , and @xmath535 it is not difficult to see that @xmath79 and @xmath536 must be consistent . then by i.h .",
    "( part @xmath440 ) we deduce that @xmath379 and @xmath439 are consistent _ sas _ s . * * rule 7 is not applicable : suppose that we have the derivation @xmath368              \\widetilde{c_i}\\theta'\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(\\overline{t}'){\\vartriangleleft_{_r}}\\{{\\textsf{\\scriptsize f}}\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] using a c - instance @xmath533 of @xmath111 and @xmath537 being a constraint of @xmath538 .",
    "analogously to the previous case , we have that both members of @xmath537 are consistent with the corresponding ones of @xmath539 ; as @xmath539 is provable then by i.h .",
    "( part @xmath447 ) , @xmath540 is not provable , what means that rule 7 can not be applied . * * rule 8 is not applicable : there can not be a pair of @xmath481 and @xmath541 with a @xmath391-clash because then the corresponding pair of @xmath481 and @xmath542 would have the same clash ( the substitution @xmath80 can not make disappear the clash ) .",
    "* @xmath368              \\widetilde{c_i}\\theta\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(\\overline{t}){\\vartriangleleft_{_r}}\\{{\\textsf{\\scriptsize f}}\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] by rule 7 , being @xmath528 a c - instance of the rule @xmath111 such that @xmath530 .",
    "the derivation @xmath531 can be done by one of the rules 5 to 8 : * * by rule 5 , the _ sas _ is @xmath174 that is consistent with any other ; * * it is not possible to use rule 6 because we would need to prove a constraint @xmath537 of a c - instance @xmath533 of @xmath111 .",
    "as @xmath543 and @xmath544 are pairwise consistent and @xmath545 , both members of @xmath539 and @xmath537 will be also consistent . then by i.h .",
    "( part @xmath447 ) , as @xmath546 is provable , @xmath537 will not be provable . * * if 7 or 8 applies we will have @xmath501 that is consistent with @xmath547 ( in fact , 8 would not be applicable ) .",
    "@xmath360    as a trivial consequence of part @xmath447 we have :    @xmath548 , for all @xmath214    this justifies indeed our description of @xmath233 and @xmath188 as computable approximations to the negations of @xmath12 and @xmath16 .",
    "another desirable property of our calculus is _ monotonicity _ , that we can informally understand in this way : the information that can be extracted from an expression can not decrease when we add information to the expression itself .",
    "this applies also to the case of constraints : if we can prove a constraint and we consider more defined terms in both sides of it , the resulting constraint must be also provable . formally :    [ prop:2 ] for @xmath441    * if @xmath549 and @xmath437 , then @xmath550 * if @xmath551 , @xmath552 and @xmath553 then @xmath554 , where    again we need to strengthen the result with a new part @xmath449    * given @xmath555 such that @xmath556 for all @xmath332 and @xmath453 , if @xmath462 then @xmath557    we will prove parts @xmath455 and @xmath449 simultaneously by induction on the size @xmath456 of the derivation for @xmath457 in @xmath440 , @xmath558 in @xmath447 and @xmath462 in @xmath449 :    @xmath463 :    * the derivation of @xmath457 in one step can be : * * @xmath464 , and it is clear that also @xmath559 * * @xmath465 : then @xmath560 * * @xmath469 , @xmath561 : then @xmath562 * for @xmath558 there are not possible derivations in one steps . * for @xmath462 the derivations can be : * * @xmath472 , using rule 5 .",
    "then for all @xmath481 we have @xmath532 * * @xmath473 , using rule 8 .",
    "then @xmath563 and @xmath384 and @xmath541 have a @xmath110-clash at some position .",
    "if @xmath564 then @xmath481 and @xmath541 have the same clash , and rule 8 allows to prove also @xmath565 .",
    "@xmath482 :    * we distinguish three cases for the derivation of @xmath457 : * * @xmath566 .",
    "then the derivation of @xmath457 must use the rule 3 and take the form : @xmath368              e_1{\\vartriangleleft}{\\mathcal{c}}_1\\ ... \\",
    "e_n{\\vartriangleleft}{\\mathcal{c}}_n\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              c(e_1, ... ,e_n){\\vartriangleleft}\\ { c(t_1, ... ,t_n ) | \\overline{t}\\in{\\mathcal{c}}_1\\times ... \\times{\\mathcal{c}}_n\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] since @xmath549 , @xmath106 must take the form @xmath485 with @xmath567 . by i.h .",
    "we have @xmath568 and with the same rule 3 we can build a derivation for @xmath569 . * * @xmath570 .",
    "then the derivation of @xmath457 must use rule 4 and take the form : @xmath368              e_1{\\vartriangleleft}{\\mathcal{c}}_1\\ ... \\",
    "e_n{\\vartriangleleft}{\\mathcal{c}}_n\\ f(\\overline{t}){\\vartriangleleft_{_r}}{\\mathcal{c}}_{r,\\overline{t}}\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(e_1, ... ,e_n){\\vartriangleleft}\\bigcup_{r\\in \\mathcal{p}_f,\\overline{t}\\in{\\mathcal{c}}_1\\times          ... \\times{\\mathcal{c}}_n }",
    "{ \\mathcal{c}}_{r,\\overline{t}}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] @xmath106 must take the form @xmath492 with @xmath571 . by i.h .",
    "we will have @xmath568 and then we have the same tuples @xmath384 , the same _ sas _",
    "s @xmath386 and finally the same _ sas _ for @xmath572 . * * @xmath573",
    ". then @xmath499 .",
    "the derivation @xmath457 must be done by one of the rules 13 or 14 , that require to obtain an _ sas _ for @xmath574 . by i.h .",
    "if @xmath575 then @xmath576 and then the same rule ( and only that ) is applicable to obtain the same _ sas _ for @xmath106 , that will be @xmath394 if rule 13 is applicable or @xmath395 if rule 14 is applied .",
    "* the derivation @xmath558 with @xmath577 will be done by generating the _ sas _",
    "s @xmath575 and @xmath578 . by i.h .",
    "we have @xmath579 and then it is clear that @xmath580 is also provable .",
    "* we distinguish the following cases according to the rule used for the derivation of @xmath462 : * * by rule 6 the derivation would be : @xmath368              e\\theta{\\vartriangleleft}{\\mathcal{c}}\\ \\overline{c}\\theta\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(t_1, ... ,t_n){\\vartriangleleft_{_r}}{\\mathcal{c}}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] where the rule @xmath111 is @xmath581 and @xmath582 such that @xmath542 .",
    "+ we will show that the same rule 6 is applicable for generating an _ sas _ for @xmath478 being @xmath556 for all @xmath211 .",
    "the idea is that if @xmath556 then @xmath480 is the result of replacing some subterms @xmath69 of @xmath477 by c - terms more defined than @xmath69 . as @xmath583 then the corresponding positions or some ancestors must have variables in @xmath476 . then we can get a substitution @xmath584 such that @xmath585 and @xmath586 .",
    "a formal justification of this fact may be done by induction on the syntactic structure of @xmath477 and , as @xmath541 is a linear tuple , the result can be extended in such a way that @xmath587 .",
    "+ we also have that @xmath588 , so by i.h .",
    "we have @xmath589 . as the constraints @xmath538 are provable and @xmath590 , then by i.h .",
    "@xmath447 , the constraints @xmath591 will also be provable .",
    "so we can build a derivation for @xmath557 by rule 6 . * * by rule 7 the derivation would be :   @xmath368              \\widetilde{c}_i\\theta\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(\\overline{t}){\\vartriangleleft_{_r}}\\{{\\textsf{\\scriptsize f}}\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] where the rule @xmath111 is @xmath592 and @xmath593 is such that @xmath543 . + as @xmath594 , in a similar way as before there exists @xmath595 such that @xmath596 and by i.h .",
    "we can prove @xmath540 , what implies that we can build the derivation for @xmath597 , using rule 7 .",
    "@xmath360    * remark : * monotonicity , as stated in prop . [ prop:2 ] , refers to the degree of evaluation of expressions and does not contradict the well known fact that negation as failure is a non - monotonic reasoning rule . in our setting it is also clearly true that , if we ` define more ' the functions ( i.e , we refine the program , by adding new rules to it ) , an expression can become reducible when it was previously failed .",
    "the next property says that what is true for free variables is also true for any possible ( totally defined ) value , i.e. , provability in _ crwlf _ is closed under total substitutions .",
    "[ prop:3 ] for any @xmath598 , @xmath214    * @xmath599 * @xmath600    again we need to strengthen the result , with a new part @xmath449 :    * @xmath601 , for any @xmath602    we prove simultaneously the three parts by induction on the size @xmath456 of the derivations .",
    "@xmath463 : in one step we can have the derivations @xmath603 ( @xmath604 ) and @xmath465 .",
    "the property is obvious for the first two and the third follows from the fact that if @xmath245 then @xmath605 is provable ( this can be proved by induction on the depth of the term @xmath82 ) .",
    "notice that @xmath606 , so @xmath607 .",
    "@xmath482 : now we can have the following derivations :    * by rule 3 we have @xmath368              e_1{\\vartriangleleft}{\\mathcal{c}}_1\\quad ... \\quad e_n{\\vartriangleleft}{\\mathcal{c}}_n\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              c(e_1, ... ,e_n){\\vartriangleleft}\\{c(t_1 , ... , t_n)\\ | \\ \\overline{t}\\in { \\mathcal{c}}_1\\times      ... \\times{\\mathcal{c}}_n \\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] by i.h .",
    "we have @xmath608 for all @xmath211 and again by rule 3 we can build a derivation for @xmath609 * by rule 4 we have @xmath368              e_1{\\vartriangleleft}{\\mathcal{c}}_1\\quad ... \\quad e_n{\\vartriangleleft}{\\mathcal{c}}_n\\quad ... \\quad      f(\\overline{t}){\\vartriangleleft_{_r}}{\\mathcal{c}}_{r,\\overline{t}}\\quad ... \\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(e_1, ... ,e_n){\\vartriangleleft}\\bigcup_{r\\in\\mathcal{p}_f , \\overline{t}\\in{\\mathcal{c}}_1\\times        ...",
    "\\times{\\mathcal{c}}_n } { \\mathcal{c}}_{r,\\overline{t}}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] by i.h",
    ". we have @xmath608 for all @xmath211 and @xmath610 for each @xmath611 and each rule @xmath453 .",
    "so we can get a derivation for @xmath612 * by rule 5 we have @xmath368              \\\\",
    "\\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(\\overline{t}){\\vartriangleleft_{_r}}\\ { \\bot\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] and it is clear @xmath613 * by rule 6 we have @xmath368              e\\theta'{\\vartriangleleft}{\\mathcal{c}}\\quad \\overline{c}\\theta'\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(\\overline{t}){\\vartriangleleft_{_r}}{\\mathcal{c}}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] where @xmath614 and @xmath615 is such that @xmath616 . for the call",
    "@xmath617 we can get the appropriate c - instance by composing @xmath595 and @xmath80 , so @xmath618 . by i.h .",
    "we have @xmath619 and @xmath620 , and then @xmath621 by the same rule 6 .",
    "* by rule 7 we have @xmath368              e_i\\theta'\\tilde{\\diamondsuit } e'_i\\theta'\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(\\overline{t}){\\vartriangleleft_{_r}}\\ { f\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] where @xmath614 and @xmath615 is such that @xmath616 .",
    "as before , for the call @xmath617 we can get the appropriate c - instance by composing @xmath595 and @xmath80 , so @xmath622 . by i.h .",
    "we have @xmath623 , and then @xmath624 * by rule 8 we have @xmath368              \\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              f(t_1, ... ,t_n){\\vartriangleleft_{_r}}\\ { f\\}\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] where @xmath625 and such that @xmath477 and @xmath476 have a @xmath391-clash for some @xmath211 .",
    "it is clear that @xmath626 and @xmath476 will have the same clash so @xmath627 * by rules 9 to 12 , the derivation would have the form @xmath235 . by i.h .",
    "we have @xmath628 . now ,",
    "if we take @xmath629 and @xmath630 holds ( where @xmath631 ) , then @xmath632 also holds , by prop .",
    "[ prop:1 ] .",
    "it follows that @xmath633 .",
    "* by rule 13 ( or rule 14 ) , it must be @xmath573 .",
    "this rule requires to obtain an _",
    "sas _ for @xmath574 ,",
    "say @xmath575 . then by i.h . @xmath634 and it is clear that rule 13 will be applicable to derive @xmath635 ( or @xmath636 by rule 14 ) . @xmath360",
    "the _ crwlf_-calculus has been built as an _ extension _ of _ crwl _ for dealing with _",
    "failure_. here we show that our aims have been achieved with respect to these two emphasized aspects .",
    "in order to establish the relations between both calculus we consider in this section the class of programs defined for _ crwl _ , i.e. , rules can not use the function @xmath197 .",
    "this means that rules 13 and 14 of the _ crwlf_-calculus are not considered here .",
    "first , we show that the _ crwlf_-calculus indeed extends _",
    "crwl_. parts _ a ) _ and _ b ) _ of the next result show that statements @xmath637 generalize approximation statements @xmath103 of _ crwl_. parts _ c ) _ and _ d ) _ show that _ crwlf _ and _ crwl _ are able to prove exactly the same joinabilities and divergences ( if @xmath189 is ignored for the comparison ) .",
    "[ prop:4 ] for any @xmath214    * @xmath638 * @xmath639 such that @xmath435 and @xmath437 * @xmath640 * @xmath641    in order to prove the property we split it into two separate lemmas .",
    "the first one contains @xmath440 , the right implication of @xmath449 and @xmath642 and a new part @xmath643 :    let @xmath84 a _ crwlf_-program .",
    "then :    * @xmath638 * @xmath644 * @xmath645 * given @xmath646 and @xmath647 : @xmath648    we prove simultaneously all the parts by induction on the size @xmath456 of the corresponding derivation :    @xmath463 : the derivation can be :    * @xmath649 , and we have @xmath650 * @xmath651 , we have @xmath652 and @xmath653 * @xmath654 , where @xmath561 and we have @xmath655 and @xmath656 * @xmath657 , we have @xmath658 and @xmath659 * @xmath660 , and we have @xmath661 * @xmath662 , and we have @xmath661    @xmath482 : the derivation can be :    * @xmath663 , then by the rule 3 of _ crwlf _ , it must be @xmath664 . by i.h .",
    "we have @xmath665 and then we can build the derivation @xmath666 , by the rule 3 of _ crwl_. * @xmath667 . this derivation must use the rule 4 of _ crwlf _ , and then we will have the derivations @xmath668 for all @xmath211 and @xmath669 .",
    "it must be @xmath670 for some @xmath671 and @xmath647 . by i.h .",
    "we will have @xmath672 * @xmath673 by rule 6 of _ crwlf _ , for which we take @xmath674 such that @xmath675 .",
    "we can define @xmath676 as @xmath677 if @xmath678 and @xmath679 , in other case .",
    "so we have @xmath680 , @xmath681 and @xmath682 .",
    "now we can take @xmath683_{\\bot}$ ] .",
    "we also have @xmath684 and if @xmath435 by i.h .",
    "we have @xmath685 , or what is the same , @xmath686 . also by i.h .",
    "@xmath687 is provable within _ crwl _ , and therefore @xmath688 by rule 4 of _ crwl_. * @xmath689 and we have @xmath661 * @xmath690 using the rule 9 of _",
    "then we will have @xmath437 , @xmath443 and there exist @xmath629 such that @xmath691 ( by definition of @xmath249 it is easy to see that @xmath289 ) . by i.h .",
    "we have @xmath692 and @xmath693 and by rule 5 of _ crwl _ we have @xmath694 . * @xmath695 using the rule 10 of _",
    "then we will have @xmath437 , @xmath443 and there exist @xmath629 such that @xmath696 . by definition of @xmath250 , @xmath82 and",
    "@xmath83 have a @xmath110-clash . by i.h",
    "we have @xmath692 and @xmath693 and by rule 5 of _ crwl _ we have @xmath697 . @xmath360    we now state the second lemma for proposition [ prop:4 ] , in which the part @xmath447 and the left implications of @xmath449 and @xmath642 will be proved .    for any @xmath214    * @xmath639 such that @xmath435 and @xmath437 * @xmath698",
    "* @xmath699    we prove the three parts simultaneously by induction on the size @xmath456 of the derivation :    @xmath463 : the derivation can be :    * @xmath650 and it is clear that @xmath649 * @xmath653 and it is clear that @xmath651 * @xmath656 with @xmath561 and it is clear that @xmath654    @xmath482 : the derivation can be of the following four forms :    * @xmath700 by rule 3 of _ crwl _ and then we have @xmath701 for all @xmath702 . by i.h . we have @xmath703 with @xmath704 and by rule 3 of _ crwlf _ we have @xmath705 with @xmath706 . * @xmath707 , then there must exist a rule @xmath708 and @xmath709 such that by rule 4 of _ crwl _ we will have the derivation + @xmath368              \\hat{e_1}\\to s_1\\theta\\quad ... \\quad \\hat{e_n}\\to s_n\\theta\\quad e\\theta\\to      t\\quad \\overline{c}\\theta\\\\              \\\\[-0.4 cm ]            \\end{array}$ } }        { \\mbox{$            \\begin{array}{c }              \\\\[-0.4 cm ]              \\widehat{f(e_1, ...",
    ",e_n)}\\to t\\\\              \\\\[-0.4 cm ]            \\end{array}$}}}$ ] by i.h .",
    "we have : * * there exists @xmath491 such that @xmath703 with @xmath710 * * there exists @xmath439 such that @xmath711 with @xmath712 * * @xmath713 + from @xmath317 and @xmath292 , by rule 6 of _ crwlf _ we can build the derivation @xmath714 using the c - instance @xmath528 . with this derivation and @xmath291",
    "we have @xmath715 such that @xmath716 , so @xmath435 .",
    "* @xmath717 , using the rule 5 of _ crwl_. it follows that @xmath718 and @xmath719 for some @xmath720 . by i.h . @xmath437 and @xmath443 where @xmath721 .",
    "taking into account that @xmath722 for all @xmath108 , by rule 9 of _ crwlf _ we can build a derivation for @xmath690 .",
    "* @xmath723 , using the rule 6 of _ crwl_. it follows that @xmath718 and @xmath724 where @xmath725 and have a @xmath110-clash . by i.h . @xmath437 and @xmath443 where @xmath435 and @xmath436 . by definition of @xmath250 and by rule 10 of _ crwlf",
    "_ we can build a derivation for @xmath695 .",
    "@xmath360    all the previous results make easy the task of proving that we have done things right with respect to failure .",
    "we will need a result stronger than prop .",
    "[ prop:4 ] , which does not provide enough information about the relation between the denotation of an expression and each of its calculable _ sas _ s .",
    "[ prop:5 ] given @xmath208 , if @xmath437 and @xmath718 , then there exists @xmath726 such that @xmath125 and @xmath82 are consistent .",
    "assume @xmath437 and @xmath727 . by part @xmath447 of prop .",
    "[ prop:4 ] there exists @xmath439 such that @xmath438 with @xmath712 .    by theorem [ th:1 ]",
    "it follows that @xmath379 and @xmath439 are consistent . by definition of consistent",
    "s , as @xmath712 , then there exist @xmath726 such that @xmath82 and @xmath125 are consistent .",
    "we easily arrive now at our final result .",
    "[ th:2 ] given @xmath208 , if @xmath728 then @xmath729\\ ! ] = \\{\\bot\\}$ ]    assume @xmath730\\ ! ] $ ] .",
    "this means that @xmath718 , which in particular implies @xmath102 . on the other hand , since @xmath728 , we know from prop .",
    "[ prop:5 ] that @xmath189 and @xmath82 must be consistent .",
    "as @xmath189 is consistent only with @xmath69 and itself , and @xmath102 , we conclude that @xmath297 .",
    "we have investigated how to deduce negative information from a wide class of functional logic programs .",
    "this is done by considering failure of reduction to head normal form , a notion playing a similar role , in the _ flp _ setting , to that of negation as failure in logic programming , but having quite a different starting point .",
    "negation as failure in _ lp _ can be seen mainly as an operational idea ( existence of a finite , failed search tree ) of which a logical interpretation can be given ( successful negated atoms are logical consequences of the completion of the program ) .",
    "the operational view of negation leads to an immediate implementation technique for negation included in all prolog systems : to solve the negation of a goal , try to solve the goal and succeed if this attempt ends in failure .",
    "unfortunately , as it is well - known , this implementation of negation is logically sound only for ground goals ( see e.g. ) .",
    "our approach has been different : we have given a logical status to failure by proposing the proof calculus _",
    "( constructor based rewriting logic with failure ) , which allows to deduce failure of reduction within _ crwl _",
    "@xcite , a well established theoretical framework for _",
    "we must emphasize the fact that _ crwlf _ is _ not _ an operational mechanism for executing programs using failure , but a deduction calculus fixing the logical meaning of such programs .",
    "exactly the same happens in @xcite with the proof calculus of _ crwl _ , which determines the logical meaning of a _ flp _ program , but not its execution . the operational procedure in _ crwl _",
    "is given by a narrowing - based goal solving calculus , which is proved to be sound and complete with respect to the proof calculus .",
    "our idea with _ crwlf _ is to follow a similar way : with the proof calculus as a guide , develop a narrowing - based operational calculus able to compute failures ( even in presence of variables ) .",
    "we are currently working on this issue .",
    "it is nevertheless interesting to comment that the operational approach to failure mentioned at the beginning of the section for the case of prolog , can be also adopted for _ flp _ , leading to a very easy implementation of failure : to evaluate @xmath393 , try to compute a head normal form of @xmath75 ; if this fails , return _ true _ , otherwise return _ false_. this is specially easy to be done in systems having a prolog - based implementation like _ curry _ or @xmath1 .",
    "we have checked that all the examples in section [ sec : interest ] are executable in @xmath0with this implementation of failure , if the function @xmath197 is only applied to ground expressions .",
    "for instance , the goal @xmath731 succeeds with answer @xmath732 , and @xmath733 succeeds with answer @xmath734 . if @xmath197 is applied to expressions with variables , this implementation is unsound .",
    "for instance , the goal @xmath735 succeeds without binding @xmath7 , which is incorrect . the relationship between this kind of failure and _ crwlf",
    "_ is an interesting issue to investigate , but it is out of the scope of this paper .    the most remarkable technical insight in _ crwlf _ has been to replace the statements @xmath103 of _ crwl _ ( representing a single reduction of @xmath75 to an approximated value @xmath82 ) by @xmath637 ( representing a whole , somehow complete , set @xmath379 of approximations to @xmath75 ) . with the aid of @xmath736 we have been able to cover all the derivations in _ crwl _",
    ", as well as to prove failure of reduction and , as auxiliary notions , failure of joinability and divergence , the two other kinds of statements that _ crwl _ was able to prove .",
    "the idea of collecting into an _ sas _",
    "values coming from different reductions for a given expression @xmath75 presents some similarities with abstract interpretation which , within the _ flp _ field , has been used in for detecting unsatisfiability of equations @xmath737 ( something similar to failure of our @xmath226 ) .",
    "we can mention some differences between our work and :    * programs in are much more restrictive : they must be confluent , terminating , satisfy a property of stratification on conditions , and define strict and total functions . * in our setting ,",
    "sas _ for an expression @xmath75 consists of ( down ) approximations to the denotation of @xmath75 , and the set of _ sas _",
    "s for @xmath75 determines in a precise sense ( propositions [ prop:4 ] and [ prop:5 ] ) the denotation of @xmath75 . in the abstract interpretation approach one",
    "typically obtains , for an expression @xmath75 , an abstract term representing a _ superset _ of the denotation of all the instances of @xmath75 . but some of the rules of the _ crwlf_-calculus ( like ( 9 ) or ( 10 ) ) are not valid if we replace _ sas _ s by such supersets . to be more concrete , if we adopt an abstract interpretation view of our _ sas _",
    "s , it would be natural to see @xmath738 as standing for the set of all constructor terms ( since @xmath738 is refinable to any value ) , and therefore to identify an _ sas _ like @xmath739 with @xmath740 .",
    "but from @xmath166 we can deduce @xmath741 , while it is not correct to do the same from @xmath742 .",
    "therefore , the good properties of _ crwlf _ with respect to _ crwl _ are lost .",
    "we see our work as a step in the research of a whole framework for dealing with failure in _ flp_. some natural future steps are to develop model theoretic and operational semantics for programs making use of failure information . on the practical side",
    ", we are currently working on an implementation of failure for the _ flp _ system @xmath0@xcite .            ,",
    "lpez - fraguas f.j . and rodrguez - artalejo , m. 1999",
    ". functional plus logic programming with built - in and symbolic constraints . in _ proceedings of the first international conference onprinciples and practice of declarative programming ( ppdp99)_. springer lncs 1702 , 152169 .",
    ", hortal - gonzlez , t. , lpez - fraguas , f.j . and rodrguez - artalejo , m. 1996 . a rewriting logic for declarative programming . in _ proceedings of the 6th european symposium on programming ( esop96)_. springer lncs 1058 , 156172 .",
    ", hortal - gonzlez , t. and rodrguez - artalejo , m. 1997 . a higher order rewriting logic for functional logic programming . in _ proceedings of the 14th international conference on logic programming ( iclp97)_. the mit press , 153167",
    ".                  \\1996 .",
    "extending constructive negation for partial functions in lazy functional - logic languages . in _ proceedings of the 5th international workshop on extensions of logic programming ( elp96)_. springer lnai 1050 , 213227 ."
  ],
  "abstract_text": [
    "<S> how to extract negative information from programs is an important issue in logic programming . here </S>",
    "<S> we address the problem for functional logic programs , from a proof - theoretic perspective . </S>",
    "<S> the starting point of our work is _ crwl _ ( constructor based rewriting logic ) , a well established theoretical framework for functional logic programming , whose fundamental notion is that of non - strict non - deterministic function . </S>",
    "<S> we present a proof calculus , _ crwlf _ , which is able to deduce negative information from _ crwl_-programs . </S>",
    "<S> in particular , _ crwlf _ is able to prove ` finite ' failure of reduction within _ </S>",
    "<S> crwl_.    constructive failure , functional logic programming , proof calculi .    submitted : </S>",
    "<S> dec 22 , 2000 , revised : feb 21 , 2002 , accepted : sept 27 2002 . </S>"
  ]
}