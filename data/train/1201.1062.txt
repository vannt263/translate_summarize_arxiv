{
  "article_text": [
    "determining network coding capacity regions ( the set of link capacities and source rates admitting a network coding solution for a given multicast ) is a fundamental problem in information theory and communications .",
    "recently , the network coding capacity region for general network coding problems was implicitly determined using entropy functions  @xcite and as needed throughout the paper . ] .",
    "this characterisation has a similar ( but slightly more complicated ) form to the outer bound in  ( * ? ? ?",
    "* section 15.5 ) , which is expressed in terms of almost entropic functions .",
    "explicit characterisation of the set of entropy functions ( or its closure ) is however a very difficult open problem ( for instance , it is known that this set is not polyhedral  @xcite ) .",
    "it is therefore natural to wonder whether there might be a simpler , explicit characterisation of network coding capacity regions which somehow avoid the use of entropy functions .",
    "however , these two problems are inextricably linked , and in general , determining network coding capacity regions is as hard as finding the set of all entropy functions , or equivalently , determining all information inequalities  @xcite .",
    "one approach to avoid these intrinsic challenges of the general case is to seek special cases , or specific classes of networks for which an explicit , computable solution is possible . to date",
    ", only a few such special cases have been found .",
    "one notable example is where a single source data stream is unicast to multiple destinations . in this case",
    ", the capacity region is characterised by graph - theoretic maximal flow / minimum cut bounds , and linear codes are optimal  @xcite .",
    "as second example is a secure network coding problem when all links have equal capacities and the eavesdropper s capability is only limited by the total number of links it can wiretap . in this case , the minimum cut bound is also tight  @xcite .",
    "another approach is to develop computable bounds on the capacity region .",
    "relaxation from entropy functions to polymatroids yields the so - called linear programming bound  ( * ? ? ?",
    "* section 15.6 ) .",
    "although this bound is explicit , both the number of variables and the number of constraints increase exponentially with the number of links in the network , making the bound computationally infeasible even for modest networks . other works such as @xcite aim to obtain useful outer bounds with computationally efficient algorithms for their evaluation .",
    "in fact , it can be shown that all of the bounds obtained in those works are relaxations of the linear programming bound from ( * ? ? ? * section 15.6 ) .",
    "this paper extends @xcite in several aspects . in both  @xcite and @xcite , vanishing",
    "decoder error probabilities are allowed . in section [ sec : part1 ]",
    ", we will extend these results to the case where the decoding error probability must be exactly zero .",
    "we also prove that when all the sources are colocated , the outer bound  @xcite is in fact zero - error achievable and tight . for the general non - colocated source case ,",
    "we show that tightness of the outer bound reduces to a question of whether or not the addition of a zero - rate link can change the capacity region of a particular network that we derive from the original network .",
    "this leads us to conjecture tightness of the bound in general .",
    "the existing capacity result  @xcite does not place any constraints on the operation of intermediate nodes , allowing arbitrary network coding operations .",
    "we further extend this entropy - function based approach to three different practically - motivated cases where additional constraints are placed on the network : ( a ) all nodes use linear encoding , ( b ) all , or some nodes can only perform routing , and ( c ) we desire secrecy in the presence of an eavesdropper .    in section [ sec : part2 ] , we consider the case where only linear network codes are allowed .",
    "we prove equivalence of zero - error and vanishing - error achievability , and characterise the linear network coding capacity region using representable functions .",
    "when comparing the performance of network coding to routing - only networks ( where nodes can only store and forward received packets ) , it may be useful to have a capacity characterisation for routing in terms of entropy functions . in section [ sec : part3 ]",
    "we introduce almost atomic functions which provide just such a characterisation .",
    "we go on to consider heterogeneous networks , containing both network coding nodes and routing nodes , and show how to obtain an entropy function characterisation of the capacity region .    in section [ sec :",
    "part4 ] , we impose secrecy constraints , where we assume the presence of eavesdropper who has access to certain links and desires to decode particular sets of sources .",
    "the objective is to design a transmission scheme such that the eavesdropper remains ignorant of the source messages .",
    "we will once again characterise the resulting general secure network coding capacity region via representable functions .    finally , in section [ sec : challenges ]",
    ", we will consider two very simple network coding problems where despite the apparent simplicity of the setup , characterisation of the capacity region turns out to be extremely difficult , and linear codes may be suboptimal .",
    "the first is incremental multicast , where the sources and sinks are ordered such that sink @xmath0 demands sources @xmath1 .",
    "the second example is secure unicast of a single source .",
    "this demonstrates that the seemingly innocuous addition of a security constraint loosens the minimum cut bound  @xcite .",
    "similarly we see that the min - cut result from  @xcite does not hold even for this simple case .",
    "_ notation : _",
    "@xmath2 is the set of all real numbers and @xmath3 is the set of all nonnegative real numbers .",
    "random variables will be denoted by uppercase roman letters @xmath4 and sets will be denoted using uppercase script @xmath5 .",
    "the power set @xmath6 is the set of all subsets of @xmath5 . for a discrete random variable @xmath4 taking values in the set ( or alphabet ) @xmath5 , its _ support _",
    "@xmath7 is @xmath8 realisations of a random variable will typically denoted via lowercase @xmath9 .    for sets @xmath10 and @xmath11",
    ", the subscript notation @xmath12 will mean @xmath13 . where it will cause no confusion ,",
    "set notation braces will be omitted from singletons and union will be denoted by juxtaposition .",
    "thus @xmath14 can be written @xmath15 and so on .",
    "ordered tuples will be denoted @xmath16",
    "in this section we provide the formal problem definition for transmission of information in networks consisting of error - free broadcast links .",
    "this includes representation of such networks as hypergraphs , the notions of a multicast connection requirement , network codes and zero - error or vanishing - error achievability .",
    "we then review existing results on characterisation of the network coding capacity via the use of entropy functions . in this section",
    ", we do not impose any additional constraints ( such as linearity or security ) beyond zero- or vanishing - decoding - error probability .",
    "we represent a communication network by a directed hypergraph @xmath17 .",
    "the set of nodes @xmath18 and the set of hyperedges @xmath19 respectively model the set of communication nodes and error - free broadcast links .",
    "in particular , each hyperedge @xmath20 is defined by a pair @xmath21 , where @xmath22 is the transmit node and @xmath23 is the set of nodes which receive identical error - free transmissions from @xmath24 .",
    "when @xmath25 is a singleton , @xmath26 models an ordinary point - to - point link .",
    "we assume that the network is free of directed cycles ( a nonempty sequence of links @xmath27 such that @xmath28 for @xmath29 and @xmath30 ) .",
    "[ df : cc ] for a given communication network @xmath31 , a _ connection constraint _",
    "@xmath32 is a tuple @xmath33 , where @xmath34 indexes the sources , @xmath35 specifies the source locations and @xmath36 specifies the sink nodes . unless specified otherwise , we let @xmath37 be the index set of @xmath38 independent sources .",
    "source @xmath39 is available at every node in @xmath40 .",
    "note that in general each source can be available to more than one network node .",
    "the sink nodes @xmath41 are nodes where source @xmath42 should be reconstructed according to some desired error criteria .",
    "it is conceptually useful to imagine each source @xmath42 as a message sent along an imaginary source edge , which for simplicity will also be labelled @xmath42 . in this case",
    ", we can use the notation @xmath43 to denote @xmath44 . for any @xmath45 and @xmath46",
    ", we define @xmath47 in other words , @xmath48 is the set of incoming edges ( including the imaginary source edges ) .",
    "solution of the network coding problem @xmath49 requires a transmission scheme allowing source @xmath42 to be reliably reconstructed at the sink nodes @xmath50 .",
    "we have not yet specified the transmission capacity of each hyperedge , or the rate of each source .",
    "characterisation of the capacity region for network coding means determination of the combinations of source rates and hyperedge capacities which admit a network coding solution . before we can proceed",
    ", we need to formalise what we mean by _ network code _ , _ reliable _ and _ rate - capacity tuple_.    [ df : nc ] a network code @xmath51 for the problem @xmath49 is a set of local encoding functions @xmath52 where @xmath53 is the alphabet of source @xmath39 and @xmath54 is the alphabet for messages transmitted on hyperedge @xmath20 .",
    "each network code induces a set of random variables @xmath55 as follows :    1 .",
    "@xmath56 is a set of mutually independent random variables , each of which is uniformly distributed over its support and denotes a message generated by a source .",
    "2 .   for each @xmath20 , @xmath57 and denotes the message transmitted on hyperedge @xmath20 .",
    "if the set of random variables induced by a network code is given , then the local encoding functions are determined with probability one . in other words ,",
    "if @xmath58 then for all @xmath59 , @xmath60 for this reason , we will often specify a network code by its set of induced random variables .",
    "the following lemma follows directly from the above definitions and gives a necessary and sufficient condition under which a set of random variables is induced by a network code .",
    "[ lemma : networkcodedef ] a set of random variables @xmath61 defines a network code , with respect to a network coding problem @xmath62 , if and only if    1 .",
    "@xmath63 is uniformly distributed over its support for all @xmath39 .",
    "2 .   @xmath64 .",
    "@xmath65 for all @xmath66 .",
    "conditions 2 ) and 3 ) are due to the mutual independence of the sources and the deterministic encoding constraints .    for a network coding problem",
    "@xmath62 let @xmath67 be the set of all _ rate - capacity tuples _",
    "@xmath68 for @xmath62 .",
    "[ df : ratesupport ] a rate - capacity tuple @xmath69 is _ fit _ for a network code @xmath70 on @xmath62 if there exists @xmath71 such that for all @xmath72 and @xmath39 , @xmath73 the tuple is _ asymptotically fit _ for a sequence of network codes @xmath74 for @xmath75 if there exists a sequence @xmath76 such that for all @xmath72 and @xmath39 , @xmath77    note that fitness does not imply achievability of a rate - capacity tuple , rather that the tuple is not impossible .",
    "fitness indicates that ( up no normalisation ) each individual source rate is not too large to be achieved by the corresponding source variable with the given alphabet size , and that each hyperedge capacity is large enough to carry the corresponding edge variable regardless of particular distribution .",
    "[ df : admissible ] a rate capacity tuple @xmath78 is called _ zero - error achievable _ , or",
    "_ @xmath79-achievable _ if there exists a sequence of network codes @xmath80 and corresponding induced random variables @xmath81 such that    1 .",
    "@xmath82 is asymptotically fit for @xmath83 .",
    "2 .   for any source @xmath39 and receiver node @xmath84",
    ", the source message @xmath85 can be uniquely determined from the received messages @xmath86 . in other words ,",
    "+ @xmath87    in definition [ df : admissible ] , each network code in the sequence has zero probability of decoding error . relaxing this criteria to allow decoding error probability that vanishes in the limit",
    ", we have the following definition .",
    "[ df : achievable ] a rate capacity tuple @xmath82 is called _ vanishing error achievable _ , or @xmath88-achievable  if the tuple is asymptotically fit , and    1 .   for all @xmath39 and @xmath84",
    ", there exists decoding functions @xmath89 such that @xmath90 in other words , decoding error probabilities vanish asymptotically .    for any subset @xmath91 ,",
    "define @xmath92 as the subset of @xmath93 containing all tuples @xmath94 such that there exists a sequence of @xmath95 and positive numbers @xmath96 satisfying @xmath97 clearly , if every tuple in @xmath98 is @xmath79-achievable/@xmath88-achievable , then @xmath92 is also @xmath79-achievable/@xmath88-achievable .",
    "the central theme of this paper is the characterisation of @xmath79-achievable  and @xmath88-achievable  regions for network coding via the use of _ entropy functions_.    a set of random variables @xmath99 ( where @xmath100 is some index set ) induces a real _ entropy function _",
    "@xmath101 such that for any @xmath102 , @xmath103 is the joint shannon entropy whenever @xmath104 is an empty set .",
    "] of @xmath105 , which according to our notational conventions we will also write @xmath106 .",
    "let @xmath107 \\triangleq   { { \\mathbb{r}}}^{2^{|{{\\mathcal n}}|}}\\ ] ] be the @xmath108-dimensional euclidean space whose coordinates are indexed by subsets of @xmath109 .",
    "thus , any element @xmath110 $ ] has coordinates @xmath111 .",
    "elements of @xmath112 $ ] are called _ _",
    "rank functions__. clearly , entropy functions are rank functions .",
    "a rank function @xmath113 $ ] is    * _ entropic _ if @xmath114 is the entropy function of a set of @xmath115 random variables .",
    "the set of entropic functions is denoted @xmath116 $ ]  @xcite . when the index set @xmath100 for the set of random variables",
    "is understood , we simply denote the set of entropic functions as @xmath117 . * _ weakly entropic _ if there exists @xmath71 such that @xmath118 is entropic . *",
    "_ almost entropic _ if there exists a sequence of weakly entropic functions @xmath119 such that @xmath120 the set of almost entropic functions is @xmath121 .    for any rank function @xmath110",
    "$ ] , define the notations @xmath122 if @xmath123 is in fact an entropy function induced by random variables @xmath124 , then @xmath125 is the usual conditional entropy @xmath126 and @xmath127 is the usual mutual information @xmath128 .",
    "we avoid the standard notation @xmath129 since it hides the underlying entropy function , which will be critical in most of what we do .",
    "the set @xmath117 plays an important role in information theory .",
    "characterisation of this set amounts to characterising every possible information inequality .",
    "thus @xmath117 essentially fixes the `` laws '' of information theory .",
    "however it turns out that @xmath117 has a very complex structure and an explicit characterisation is still missing  @xcite .",
    "it has been proved that the closure @xmath130 is a closed convex cone  @xcite and hence is more analytically manageable than @xmath117 . for many applications ,",
    "it is in fact sufficient to consider @xmath130 .",
    "however , it was proved in @xcite that when @xmath131 , @xmath132      for a given network coding problem @xmath49 , let @xmath133 and @xmath134 $ ] respectively denote @xmath135 and @xmath136 $ ] .",
    "define the coordinate projection @xmath137 \\mapsto { \\chi}(\\problem)\\ ] ] such that for any @xmath138 $ ] , @xmath139(s ) & = h(s ) , \\ : \\forall s\\in\\sessions \\\\",
    "\\proj_{\\problem}[h](e ) & = h(e ) , \\ : \\forall e\\in\\edges\\end{aligned}\\ ] ] similarly , for any subset @xmath140 $ ] , @xmath141 \\define \\ { \\proj_{\\problem}[h ] : h\\in{{\\mathcal r } } \\}.\\end{aligned}\\ ] ] again , if the underlying network coding problem @xmath62 is understood implicitly , we will simply use the notations @xmath142 $ ] and @xmath143 $ ] .",
    "consider any network coding problem @xmath144 .",
    "define the following subsets of @xmath134\\defined { { \\mathcal h}}[\\sessions \\cup \\edges ] $ ] : @xmath145 :      { h}({{{\\mathcal s } } } )   = \\sum_{s\\in\\sessions } { h } ( s ) \\right\\ } , \\label{eq : constraint1 } \\\\ { { \\mathcal c}}_{\\net } ( \\problem ) & \\define    \\left\\ {       \\begin{array}{l } \\hspace{-0.2 cm } h \\in{{\\mathcal h}}[\\problem ] : h\\left ( s\\mid    \\incoming(e ) \\right )   = 0 ,    \\forall   e\\in\\edges       \\end{array } \\right\\},\\\\ { { \\mathcal c}}_{\\de } ( \\problem ) & \\define \\left\\ {       \\begin{array}{l } \\hspace{-0.2 cm } h \\in{{\\mathcal h}}[\\problem ] : h\\left ( s\\mid   \\incoming(u ) \\right )   = 0 , \\\\        \\hspace{2.5 cm } \\forall",
    "s\\in\\sessions , u\\in\\destinationlocation(s )       \\end{array } \\right\\}. \\label{eq : constraint3}\\end{aligned}\\ ] ] the above subsets will be denoted by @xmath146 and @xmath147 respectively if the network coding problem @xmath62 is understood implicitly . consider a network code @xmath148 with induced entropy function @xmath149 $ ] . by lemma  [ lemma : networkcodedef ]",
    "we see that @xmath150 since the sources are mutually independent , and @xmath151 due to deterministic transmission through the network .",
    "if the network code is zero - error , @xmath152 follows from the decodability constraint  .",
    "the set of @xmath88-achievable  rate - capacity tuples can be characterised exactly as follows  @xcite .",
    "[ thm : yanbd ] for a given network coding problem @xmath153 , a rate - capacity tuple @xmath154 is @xmath88-achievable  if and only if @xmath155 ) .",
    "\\end{aligned}\\ ] ]    inner and outer bounds for the @xmath79-achievable  region were also investigated in  @xcite using a similar framework as in  @xcite .",
    "however , @xcite allowed the use of variable length coding , where the amount of data traffic on a particular link is measured as the average number of transmitted bits .",
    "in contrast , this paper studies the _ worst case _ scenario where the amount of traffic is measured by the maximum number of bits transmitted on a link ( hence , it is sufficient to consider fixed - length codes ) .",
    "it is worth pointing out that when decoding error is not allowed , there is a significant difference between using the average or the maximum number of transmitted bits .",
    "for example , consider a source @xmath4 compressed / encoded by an optimal uniquely - decodable code .",
    "the average length of resulting codeword is roughly equal to @xmath156 .",
    "however , for all uniquely - decodable codes , the maximum length of the encoded codeword must be at least @xmath157 , which can be much greater than @xmath156 if @xmath4 is heavily biased .",
    "the following outer bound follows directly from theorem [ thm : yanbd ] , but was proved earlier in  @xcite    [ cor : ourbd ] if a rate - capacity tuple @xmath158 is @xmath88-achievable , then @xmath159).\\end{aligned}\\ ] ]    this bound is not necessarily tight , since @xmath160 is not closed and convex in general .",
    "therefore , @xmath161 theoretically may be a proper subset of @xmath162 where @xmath163 follows from that @xmath164 is a closed and convex cone .",
    "it is clear that if @xmath165 is @xmath79-achievable , then it is also @xmath88-achievable  and hence must satisfy the outer bound in corollary [ cor : ourbd ] .",
    "in fact , it can be seen directly that   must be an outer bound for the set of @xmath79-achievable  rate - capacity tuples .",
    "suppose @xmath166 is @xmath79-achievable .",
    "then there exists a sequence of network codes @xmath167 with induced entropy functions @xmath168 and positive constants @xmath96 such that for all @xmath20 and @xmath169 @xmath170 and that @xmath171 .",
    "consequently , @xmath172).\\ ] ] the proof that is an outer bound for @xmath88-achievable  tuples is similar .",
    "however , as vanishing error is allowed , fano s inequality is invoked to ensure @xmath173 .    in the next section ,",
    "we deliver our first main result , namely that   is tight when the sources are colocated .",
    "the analytical challenges in characterising @xmath117 ( let alone its intersection with @xmath174 and @xmath175 ) may render theorem  [ thm : yanbd ] unattractive as a characterisation of the network coding capacity region . in this section",
    "we show that the more manageable bound of corollary  [ cor : ourbd ] , which involves the closure of @xmath117 is in fact tight when the sources are colocated , a notion that we make precise below in definition  [ df : colocated ] . our proof will use quasi - uniform random variables , discussed in  [ sec : tools ] , which are a valuable tool in proving zero - error results .",
    "the proof of the main result , theorem  [ thm : arbitrarymain ] is given in  [ sec : proof ] .",
    "[ df : colocated ] consider a network coding problem @xmath176 .",
    "its sources are called _ colocated _ if @xmath177    in other words , if a node has an access to any source @xmath42 , it also has access to all the other sources .",
    "[ thm : arbitrarymain ] consider a network coding problem @xmath49 with colocated sources according to definition  [ df : colocated ]",
    ". then    1 .",
    "a rate - capacity tuple @xmath178 is @xmath79-achievable  if and only if it is @xmath88-achievable .",
    "the outer bound in corollary [ cor : ourbd ] is tight .",
    "we fail to prove the tightness of the outer bound in corollary [ cor : ourbd ] when sources are not colocated .",
    "however , we will give evidence in [ sec : general ] to support our conjecture that the outer bound should be tight in general .",
    "before we prove theorem [ thm : arbitrarymain ] in section  [ sec : proof ] , we introduce key tools and intermediate results .",
    "in particular , the proof relies on the concept of quasi - uniform random variables , which are crucial for proving zero - error results .",
    "[ df : qu ] a set of random variables @xmath179 is called _ quasi - uniform _ if for any subset @xmath180 , the random variable @xmath181 is uniformly distributed over its support , or equivalently , @xmath182    [ lemma : quw ] suppose @xmath183 is quasi - uniform . then one can construct a random variable @xmath184 such that @xmath185    as @xmath183 is quasi - uniform , it can be proved from definition  [ df : qu ] that for any @xmath186 , @xmath187 assume without loss of generality that @xmath188 is the set of all elements in @xmath189 such that @xmath190 let @xmath184 be a random variable such that for any @xmath191 in @xmath192 , @xmath193 the lemma can then be verified directly .",
    "[ df : classification ] a rank function @xmath194 $ ] is called    * _ quasi - uniform _ if @xmath114 is the entropy function of a set of @xmath195 quasi - uniform random variables .",
    "* _ weakly quasi - uniform _ if there exists @xmath196 such that @xmath197 is quasi - uniform ; * _ almost quasi - uniform _ if there exists a sequence of weakly quasi - uniform rank functions @xmath198 such that @xmath199    [ lem : qusum ] if @xmath200 $ ] are quasi - uniform , then their sum , defined for all @xmath201 as @xmath202 , is also quasi - uniform .",
    "suppose @xmath203 and @xmath204 are two independent sets of quasi - uniform random variables whose entropy functions are @xmath205 and @xmath206 respectively .",
    "it is straightforward to construct a new set of variables @xmath207 with entropy function @xmath208 , via @xmath209 the lemma follows , since @xmath210 , and hence @xmath208 , is quasi - uniform .    for any weakly entropic function @xmath114 , @xcite explicitly constructed a sequence of weakly quasi - uniform functions with limit @xmath114 .",
    "it can be verified directly that this sequence of weakly quasi - uniform functions satisfies the same functional dependency constraints as @xmath114 .",
    "hence , we have the following proposition .    [ prop:3.supporta ] for any weakly entropic rank function @xmath211",
    ", there exists a sequence of quasi - uniform random variables @xmath212 and positive numbers @xmath213 such that    1 .   for any @xmath214 , @xmath215 2 .   if @xmath216 , then @xmath217 in other words , @xmath114 is the limit of a sequence of weakly quasi - uniform functions @xmath218 where @xmath219    in fact , proposition [ prop:3.supporta ] remains valid even if @xmath114 is almost entropic .",
    "[ prop:3.support ] for any almost entropic rank function @xmath220 , there exists a sequence of quasi - uniform random variables @xmath221 and positive numbers @xmath213 such that and hold .",
    "by @xcite , there exists a sequence of quasi - uniform random variables @xmath221 and positive numbers @xmath213 such for all @xmath214 , @xmath222 the challenge however is that may not hold if @xmath114 is not weakly entropic ( we only know that @xmath114 is the limit of a sequence of weakly entropic functions ) . in the following , we will show how to modify the @xmath221 such that indeed holds .",
    "first , notice that @xmath223 is quasi - uniform .",
    "hence , for any @xmath224 and @xmath102 , @xmath225 is quasi - uniform . by lemma [ lemma : quw ]",
    ", one can construct a random variable @xmath226 such that @xmath227 let @xmath228 then @xmath229 where ( @xmath230 ) follows from .",
    "consequently , @xmath231 we now construct our new set of random variables , @xmath232 by defining @xmath233 it is obvious that @xmath234 for all @xmath235 .",
    "let @xmath218 be the entropy function of @xmath236 .",
    "then by  , for any @xmath237 , @xmath238 where ( b ) is by  .",
    "consequently , @xmath239 since @xmath218 is weakly entropic and @xmath240 for all @xmath241 , we can once again use proposition [ prop:3.supporta ] to construct a sequence of weakly quasi - uniform functions @xmath242 such that @xmath243 and @xmath244 for all @xmath235 .",
    "the first claim of theorem [ thm : arbitrarymain ] is that the @xmath88-achievableand @xmath79-achievable  regions are equivalent when sources are colocated . for any network coding problem @xmath245 ,",
    "it is clear that if @xmath165 is @xmath79-achievable , then it is also @xmath88-achievable  and hence must satisfy the outer bound in corollary [ cor : ourbd ] .",
    "thus , to prove theorem [ thm : arbitrarymain ] , it suffices to show that for colocated sources , the rate - capacity tuple @xmath246 $ ] is @xmath79-achievable  for all @xmath247 .",
    "our proof technique is similar to that used in  @xcite .",
    "however , instead of constructing network codes from strongly typical sequences , we use quasi - uniform random variables .",
    "codes constructed from typical sequences admit a small ( but vanishing ) error .",
    "however , as we shall see , codes constructed from quasi - uniform random variables can be carefully designed to ensure zero decoding error probability .",
    "consider a network coding problem @xmath49 where all sources are colocated .",
    "suppose @xmath248 since @xmath114 is almost entropic , proposition [ prop:3.support ] implies the existence of a sequence of quasi - uniform random variables @xmath249 and positive numbers @xmath96 such that @xmath250 where @xmath163 is due to @xmath251 and @xmath252 is due to @xmath253 .",
    "furthermore , by lemma  [ lem : qusum ] the sum of two quasi - uniform rank functions is quasi - uniform .",
    "hence , we can assume without loss of generality that @xmath254 and @xmath255 grows unbounded . this assumption will be used in the latter part when we construct a zero - error network code .    in the following , for each @xmath256",
    ", we will construct a zero - error network code @xmath257 from each set of quasi - uniform random variables @xmath258 such that @xmath259 and consequently , @xmath246 $ ] is @xmath79-achievable  and the outer bound is tight .      for simplicity of notation , we will drop the superscript @xmath256 in and directly denote the set of quasi - uniform random variables by @xmath260    suppose first that the @xmath261 are mutually independent .",
    "the @xmath262 are quasi - uniform and hence uniformly distributed over their support",
    ". thus holds and lemma [ lemma : networkcodedef ] implies that @xmath263 in fact defines a network code .",
    "furthermore , by , the decoding error probability is zero , and theorem [ thm : arbitrarymain ] is proved for this special case of independent sources .",
    "unfortunately , @xmath264 need not be mutually independent in general . to address this problem",
    ", we will modify these variables to satisfy the independency constraint .",
    "this is when we require all sources to be colocated .",
    "since the network @xmath31 is acyclic , repeated application of can be used to prove that @xmath265 hence , for any @xmath20 , there exists functions @xmath266 such that @xmath267 similarly , for any @xmath20 , @xmath39 and @xmath268 , there exists functions @xmath269 and @xmath270 such that for all @xmath271 , @xmath272 where @xmath163 follows from and @xmath252 from .",
    "let @xmath273 be an index set .",
    "partition _ of a set @xmath5 into @xmath274 partitions is a mapping @xmath275 where @xmath276 is the set of elements in partition @xmath277 . if the @xmath278 are disjoint then the partition @xmath279 is called _",
    "disjoint_.    [ df : regularpartition ]",
    "let @xmath280 be random variables with supports @xmath281 . for @xmath39 ,",
    "define the index sets @xmath282 , where @xmath283 , and let @xmath284 be a disjoint partition of @xmath281 into @xmath285 subsets .",
    "we call the set of partitions @xmath286 a _ regular partition set _ for @xmath287 if and only if for all @xmath288 @xmath289    note that   is a non - trivial condition , since in general @xmath290 when the @xmath291 are not necessarily independent",
    ".    we will now construct a zero - error network code @xmath292 from a regular partition set .",
    "let @xmath286 be a regular partition set according to definition  [ df : regularpartition ] .",
    "by , for each @xmath39 , there exists mappings    @xmath293    such that for @xmath39 and @xmath294 , @xmath295 we can write this more concisely as @xmath296 by , @xmath297 and as @xmath298 is a disjoint partition , @xmath299 can be uniquely determined from @xmath300 .",
    "now let @xmath301 be a set of mutually independent random variables such that for each @xmath39 , @xmath302 is uniformly distributed over @xmath303 . also , for each @xmath39 , define auxiliary random variables @xmath304 such that @xmath305 by and , it is easy to see that @xmath306 further define @xmath307 it is now easy to see that @xmath308 following from , we have that @xmath309 whenever @xmath310 for some @xmath311 and @xmath312 .",
    "let @xmath313 for all @xmath20 . if @xmath314 , then @xmath315 where ( @xmath0 ) follows from , ( @xmath316 ) from and ( @xmath317 ) from the fact that @xmath318 . now ,",
    "suppose @xmath319 .",
    "as all sources are colocated in @xmath62 , then @xmath320 . in this case ,",
    "application of and yields @xmath321 finally , for any @xmath39 and @xmath322 , @xmath323 where @xmath163 follows from .",
    "hence @xmath324 defines a zero - error network code for @xmath62 .",
    "furthermore , it is easy to see that @xmath325 hence , @xmath326 is @xmath79-achievable  where @xmath327    the final ingredient of the proof is the following proposition which will be proved in appendix [ appendix : a ] .",
    "[ prop : regular ] let @xmath328 be a set of quasi - uniform random variables .",
    "if @xmath329 is sufficiently large , then there exists at least one regular partition set @xmath330 for @xmath331 where @xmath332    by proposition [ prop : regular ] ( and ) , we can construct a sequence of zero - error network codes such that @xmath333 finally , from and that @xmath334 , we can prove that @xmath335 for all @xmath39 and @xmath20 .",
    "thus , @xmath246 $ ] is @xmath79-achievable  and theorem [ thm : arbitrarymain ] follows .",
    "assuming that all sources are colocated , we proved in the previous subsection that a rate - capacity tuple is @xmath88-achievable  if and only if it is indeed @xmath79-achievable , and that the outer bound in corollary [ cor : ourbd ] is indeed tight .",
    "we conjecture that the same outer bound remains tight even for sources are not colocated . in this subsection",
    ", we will give some arguments to justify our conjecture , which hinges on whether or not removing a zero - rate link can change the capacity of a certain modification of the original network .",
    "let @xmath336 where @xmath337 and @xmath338 .",
    "we make no assumption that the sources are colocated .",
    "now consider two variations on the network coding problem @xmath62 .",
    "_ variation 1  addition of a `` super node '' : _ let @xmath339 , where the underlying network @xmath340 is obtained from @xmath341 via inclusion of a `` super node '' @xmath342 and links @xmath343 , @xmath344 such that @xmath345 and @xmath346 . here",
    ", the links @xmath347 are just like an imaginary source edge .",
    "the connection constraint @xmath348 is @xmath349 where for all @xmath39 , @xmath350 in other words , source @xmath42 is available not only at source node @xmath44 but also at the super node @xmath342 .",
    "_ variation 2 : _ let @xmath351 , where the underlying network @xmath352 is the same as in @xmath353 , but the connection constraint @xmath354 is modified as follows : @xmath355 hence , all sources are available only at the super node @xmath342 .",
    "in addition , source @xmath42 is required to be reconstructed not only at the nodes in @xmath356 ( the sinks in the original multicast problem @xmath62 ) but also at the original source nodes @xmath44 in @xmath62 .",
    "figure [ fig : variations ] illustrates the differences between the original problem @xmath62 and its two variations @xmath353 and @xmath357 . in this figure , a sink node is denoted by an open square .",
    "labels beside each sink node indicate the set of sources required for reconstruction .",
    "sources are indicated by a double circle with an imaginary link ( labeled with the source index ) directed from it to the nodes where that source is available according to the connection constraint .    given a rate - capacity tuple @xmath358 , let @xmath359 $ ] be a rate capacity tuple in @xmath360 ( for the network coding problem @xmath361 ) such that @xmath362(s ) & = \\lambda(s ) , \\quad \\forall s\\in\\sessions ,   \\\\",
    "t^{1}[\\lambda,\\omega](e ) & = \\omega(e ) , \\quad \\forall e\\in\\edges , \\\\ t^{1}[\\lambda,\\omega](f_{s } ) & = 0 , \\quad \\forall s\\in\\sessions.\\end{aligned}\\ ] ] in other words , the source rates and the hyperedge capacities remain the same for those elements existing in the original network , and the hyperedge capacities of the new links from the super - node @xmath363 to each of the original source nodes are all zero .",
    "similarly , let @xmath364 $ ] be respectively the rate capacity tuple in @xmath365 ( for the network coding problem @xmath366 ) such that @xmath367(s ) & = \\lambda(s ) , \\quad \\forall s\\in\\sessions , \\\\",
    "t^{2}[\\lambda,\\omega](e )   & = \\omega(e ) , \\quad \\forall e\\in\\edges , \\\\ t^{2}[\\lambda,\\omega](f_{s } ) & =   \\lambda(s ) , \\quad \\forall s\\in\\sessions.\\end{aligned}\\ ] ]    then , it is straightforward to prove the following :    1 .",
    "@xmath359 $ ] is @xmath88-achievable  with respect to @xmath361 if and only if @xmath364 $ ] is @xmath88-achievable with respect to @xmath366 .",
    "2 .   if @xmath94 is @xmath88-achievable  with respect to @xmath62 , then @xmath359 $ ] and @xmath364 $ ] are @xmath88-achievable  with respect to @xmath361 and @xmath366 respectively .",
    "[ conj : two ] a rate - capacity tuple @xmath94 is @xmath88-achievable  with respect to a network coding @xmath62 if @xmath359 $ ] is @xmath88-achievable  with respect to the modified problem @xmath361 .",
    "the main difference between @xmath62 and @xmath361 are the zero - capacity links @xmath347 for @xmath39 . at first sight",
    "it might be tempting to think that zero - capacity links can not change the capacity region , and as a result that the conjecture is trivially true .",
    "however proving the conjecture is not straightforward .",
    "a zero - capacity link does not mean that absolutely nothing can be transmitted on the link .",
    "in fact according to the definitions , a finite amount of information ( that does not scale with @xmath256 ) could be transmitted along the link .",
    "thus the links @xmath368 can in fact be used ( as long as their capacities vanish asymptotically ) in any sequence of network codes achieving @xmath359 $ ] .",
    "in fact there exists known examples where zero - capacity links can indeed modify the capacity of certain multi - terminal problems , in particular when there are correlated sources , or non - ergodic sources .",
    "if conjecture  [ conj : two ] does not hold , it is equivalent to saying that a link with `` vanishing capacity '' can indeed change the set of achievable tuples , even when all sources are independent and ergodic .",
    "suppose conjecture  [ conj : two ] holds .",
    "then the outer bound in corollary [ cor : ourbd ] is tight even when sources are not colocated .",
    "let @xmath369 .",
    "define a rank function @xmath370\\ ] ] such that for any @xmath371 @xmath372 where @xmath373 it is straightforward to prove that if @xmath374 then @xmath375 by theorem [ thm : arbitrarymain ] , @xmath376 $ ] is @xmath88-achievable  with respect to network coding problem @xmath366 . as @xmath377",
    "= \\proj_{\\problem^{2}}[g ] \\ ] ] and is achievable with respect to @xmath366 , @xmath378 $ ] is achievable with respect to @xmath361 . by conjecture  [ conj : two ] , @xmath379",
    "$ ] is achievable with respect to @xmath62 .",
    "consequently , the outer bound in corollary [ cor : ourbd ] is tight .",
    "in the previous section , the network codes were not subject to any constraints , other than those required by definition  [ df : nc ] and that decoding error probabilities must be zero or vanishing , according to definition  [ df : admissible ] or definition  [ df : achievable ] .",
    "for the remainder of the paper , we will consider various subclasses of network codes which result from imposing different kinds of additional constraints .    to begin with , in this section we will study _ linear network codes _",
    "@xcite , which have relatively low encoding and decoding complexities , making them more attractive for practical implementation .",
    "let @xmath380 be a network code ( according to definition  [ df : nc ] ) for a problem @xmath62 on a network @xmath381 , with local encoding functions @xmath382 the code is called _ @xmath383-linear _ ( or simply linear ) if it satisfies the following conditions :    1 .   for @xmath39",
    ", @xmath302 is a random row vector such that each of its entries is selected independently and uniformly over @xmath384 .",
    "2 .   all the local encoding functions are linear .",
    "a network coding problem is said to be subject to a _",
    "@xmath383-linearity constraint _ if only @xmath383-linear network codes are allowed .",
    "let the row vector @xmath302 have @xmath385 elements . clearly , for a linear network code , one can construct a @xmath386 matrix @xmath387 for any @xmath388 such that @xmath389 where @xmath390 $ ] is the length @xmath391 row vector obtained from the concatenation of the @xmath392 and @xmath393 is the usual vector - matrix multiplication .",
    "similarly , as all local encoding functions are linear , for each @xmath20 , there exists a @xmath394 matrix @xmath266 such that @xmath395 hence , the symbol transmitted on link @xmath396 is a length @xmath397 vector over @xmath384 .",
    "following the nomenclature in @xcite , the matrices @xmath398 , @xmath399 will be called the _ global encoding kernels_. they define the linear relation between @xmath396 ( the message sent along edge @xmath26 ) and @xmath301 ( the symbols generated at the sources ) .",
    "it is easy to prove that @xmath400 with equality holding in when @xmath266 has full column rank .",
    "a sink node @xmath401 can uniquely decode a source @xmath302 if and only if it can solve for @xmath302 ( but not necessarily all other @xmath402 , @xmath403 ) from the following linear system with unknowns @xmath404 : @xmath405 it is clear that if @xmath302 can not be uniquely determined from , then there must be at least @xmath383 solutions to such that the values of @xmath302 in each solution are all different . we can easily show that with maximum likelihood decoding , the decoding error probability must be at least @xmath406 .",
    "consequently , for a network coding problem subject to a @xmath383-linearity constraint , a rate - capacity tuple @xmath94 is @xmath79-achievable  if and only if it is @xmath88-achievable .",
    "therefore , we will always assume that linear codes are zero - error codes .",
    "as in theorem [ thm : arbitrarymain ] for general ( possibly non - linear ) network codes , a characterisation for the set of @xmath79-achievablerate - capacity tuples subject to a @xmath383-linearity constraint can be obtained by using entropy functions .",
    "however as we shall see , the entropy functions for linear network codes will be constrained to be _",
    "representable _",
    "@xcite in the sense of matroid theory .",
    "[ df : repfn ] a rank function @xmath407 $ ] is called",
    "_ @xmath383-representable _ if there exists vector subspaces @xmath408 over @xmath384 such that for all @xmath409 , @xmath410 where @xmath411 denotes the dimension of the smallest vector space containing all of the @xmath412 .    in an abstract sense ,",
    "representable rank functions are similar to entropy functions , where the entropies of random variables are replaced by dimensions of vector spaces .",
    "it is well - known that representable functions are indeed entropy functions ( and hence also polymatroidal )  @xcite .",
    "hence we will sometimes use the following conventions . for vector spaces @xmath413 and @xmath414 , we will use @xmath415 to respectively denote @xmath416 as if @xmath413 and @xmath414 were random variables .",
    "similar to definition [ df : classification ] we can define weakly- and almost - representable functions .",
    "a function @xmath114 is called    * _ weakly @xmath383-representable _ if @xmath417 is @xmath383-representable for some @xmath196 * _ almost @xmath383-representable _ if it is the limit of a sequence of weakly @xmath383-representable functions .",
    "we use @xmath418 and @xmath419 to respectively denote the sets of @xmath383-representable and almost @xmath383-representable rank functions in @xmath136 $ ] .",
    "[ thm : mainlinear ] for any network coding problem @xmath420 subject to a @xmath383-linearity constraint , a rate - capacity tuple @xmath178 is @xmath79-achievable  if and only if @xmath421\\right ) .",
    "\\end{aligned}\\ ] ] theorem [ thm : mainlinear ] ( for linear network codes ) is a counterpart to theorem [ thm : arbitrarymain ] ( for general network codes codes ) .",
    "however , unlike in theorem [ thm : arbitrarymain ] , theorem [ thm : mainlinear ] holds _ even when the sources are not colocated_.    before we proceed to prove theorem [ thm : mainlinear ] ( which involves proving both an if - part and an only - if part ) , we will illustrate the main idea by proving the following special case of the if - part of theorem [ thm : mainlinear ] .",
    "[ prop:5.1 ] consider a @xmath383-representable function @xmath422 such that @xmath423 and let @xmath424 $ ] .",
    "then @xmath94 is 0-achievable by @xmath383-linear network codes .    by definition",
    "[ df : repfn ] , there exists a collection of subspaces @xmath425 over @xmath384 such that @xmath426 as @xmath427 , @xmath428 therefore , @xmath429 similarly , as @xmath430 , we can prove that @xmath431 for all @xmath20 .",
    "consequently , @xmath432 let @xmath433 . by and , we may assume without loss of generality that all elements in @xmath434 are length @xmath435 column vectors for @xmath399 . for each @xmath39",
    ", let @xmath436 be a @xmath437 full column rank matrix such that the space spanned by its columns is equal to @xmath438 .",
    "similarly , for each @xmath20 , let @xmath439 be a @xmath440 full column rank matrix such that the space spanned by its columns is equal to @xmath441 .",
    "let @xmath442 be a length @xmath435 row vector such that each of its entries is independently and uniformly selected from @xmath384 .",
    "then @xmath442 , together with the matrices @xmath443 induces a set of random variables @xmath444 such that @xmath445 for all @xmath399 . setting @xmath446 $ ] , and similarly @xmath447 $ ] we have @xmath448 by , it is easy to see that @xmath449 must be a @xmath450 invertible matrix",
    ". therefore @xmath451 and consequently , @xmath452 where @xmath453 .    in the following",
    ", we will prove that @xmath454 is indeed a zero - error linear network code . to see this , first notice that @xmath302 is a random row vector of length @xmath455 and all its entries",
    "are independently and uniformly distributed over @xmath384 .",
    "now , consider any @xmath20 .",
    "as @xmath456 , @xmath457 therefore , @xmath458 or equivalently , @xmath459    consequently , we can construct a matrix @xmath460 such that @xmath461\\times\\psi_{e}\\ ] ] therefore , @xmath462 \\times \\psi_{e } \\nonumber \\\\ & =   [ z\\times m_{f } , f\\in\\incoming(e )   ] \\times\\psi_{e }   \\nonumber\\\\ & =   [ y_{f } , f\\in\\incoming(e )   ] \\times\\psi_{e } \\label{eq:85}.\\end{aligned}\\ ] ] the equation clearly indicates that the local encoding functions are indeed linear .    similarly , as @xmath463 , @xmath464 for any @xmath401 .",
    "we can once again construct a `` decoding function '' @xmath465 such that @xmath466 \\times\\psi_{s , u}.\\ ] ] hence , the receiver node @xmath467 can uniquely decode @xmath302 from @xmath468 and the probability of decoding failure is zero . as @xmath469 is a zero - error linear network code , together with - , @xmath94 is @xmath79-achievable  by linear network codes .",
    "our next step is to prove that proposition [ prop:5.1 ] holds , even when the function @xmath114 in is almost @xmath383-representable .",
    "before we prove this extension , we will need a few basic results from linear algebra .",
    "[ lemma:5.1 ] let @xmath470 be vector subspaces . then there exists a subspace @xmath471 such that @xmath472 consequently , @xmath473 .    using lemma [ lemma:5.1 ] , for any subspace @xmath474 of @xmath475 , one can easily construct a vector subspace @xmath476 of @xmath477 such that @xmath478 any vector @xmath479 can be uniquely expressed as the sum of vectors @xmath480 and @xmath481 . for notational simplicity",
    ", we use @xmath482 to denote @xmath483 . similarly , @xmath484 clearly , if @xmath414 is a subspace , then so is @xmath485 . in general",
    ", @xmath486 depends on the specific choice of @xmath487 .",
    "however , all the results mentioned in this paper involving @xmath488 remain valid for any legitimate choice of @xmath476 . the following lemma may be directly verified .",
    "[ lemma:5.properties ] for any subspaces @xmath489 , @xmath490 furthermore , if @xmath491 , then @xmath492    using @xmath488 , we can `` transform '' a set of subspaces @xmath493 into another set of subspaces @xmath494 satisfying lemmas  [ lemma:5.3 ] and  [ lemma:5.4 ] below , which are direct consequences of lemma [ lemma:5.properties ] .",
    "[ lemma:5.3 ] @xmath495    [ lemma:5.4 ] if @xmath496 or equivalently , @xmath497 , then @xmath498    [ prop:5.5 ] consider any almost @xmath383-representable function @xmath499 $ ] .",
    "let @xmath500 then there exists a sequence of weakly @xmath383-representable rank functions @xmath501 $ ] such that @xmath502 and @xmath503 for all positive integers @xmath504 , and @xmath235 .    by definition , for any almost @xmath383-representable function @xmath505 , there exists a sequence @xmath506 , @xmath507 of collections of subspaces over @xmath384 and @xmath508 such that for any @xmath312 , @xmath509 for every pair of @xmath235 , by using lemma [ lemma:5.1 ] , we can construct a subspace @xmath510 such that @xmath511 let @xmath512 . by - and",
    "the fact that @xmath513 we have @xmath514    define a new collection of subspaces @xmath515 and let @xmath516 be the representable function induced by @xmath517 obviously , for all @xmath235 , @xmath518 is a subspace of @xmath519 , or equivalently , @xmath520 . by , using a similar argument as given in - in the proof of proposition [ prop:3.support ]",
    ", we can also prove that @xmath521 the proposition then follows by letting @xmath522 .    in the proof for theorem [ thm : arbitrarymain ] , an extra step ( via the introduction of a regular partition set )",
    "is taken to construct a network code from a set of quasi - uniform random variables .",
    "this extra step requires that all sources are colocated .",
    "as we shall see , when we construct linear codes from a set of subspaces , the colocated assumption is no longer needed .",
    "[ lemma:5.5 ] for any subspaces @xmath523 , @xmath524    direct verification .",
    "[ lemma:5.6 ] let @xmath525 be a collection of subspaces .",
    "then there exists a subspace @xmath474 such that @xmath526 and @xmath527    let @xmath528 and @xmath529 .",
    "then @xmath530 where @xmath163 follows from that @xmath531 , @xmath532 from that @xmath533 , and @xmath534 from lemma [ lemma:5.5 ] .",
    "as all the above inequalities are in fact equalities , we have @xmath535 finally , as @xmath536 , @xmath537    we now have all the elements required to prove theorem [ thm : mainlinear ] .",
    "we begin with the if - part .",
    "suppose @xmath538 using proposition [ prop:5.5 ] , we can construct a sequence of @xmath383-representable functions @xmath539 and @xmath540 such that @xmath541 and each @xmath218 satisfies all of the same functional dependencies as @xmath114 , i.e. @xmath542 in particular , @xmath543 for each @xmath504 , by definition , there exists subspaces @xmath544 over @xmath384 such that @xmath545 .",
    "then by lemma [ lemma:5.6 ] , there exists a subspace @xmath546 such that @xmath547 and @xmath548 let @xmath516 be the representable function induced by the subspaces @xmath549 then by , @xmath550 . as each @xmath551 , by lemma [ lemma:5.4 ] , @xmath552 . by proposition [ prop:5.1 ] ,",
    "@xmath553 $ ] is @xmath79-achievable .",
    "due to , @xmath554 and hence , @xmath555 thus , @xmath246 $ ] is also @xmath79-achievable  and the if - part of theorem [ thm : mainlinear ] is proved .",
    "now , we will prove the only - if part .",
    "suppose @xmath556 is @xmath79-achievable  subject to a @xmath383-linearity constraint .",
    "then there exists a sequence of zero - error linear network codes @xmath167 and positive constants @xmath96 such that @xmath557 again , each set of random variables @xmath558 induces a @xmath383-representable function @xmath559 such that @xmath560 for all @xmath561 .",
    "since @xmath558 is a zero - error linear code , we have @xmath562 . therefore ,",
    "@xmath563 and the theorem is proved .",
    "another class of network coding constraints that is of great practical importance is _ routing _ , which requires that network nodes perform only store - and - forward operations .",
    "we will consider two main cases . in section  [ sec : routingonly ] we consider networks where _ all _ nodes must perform routing . in section  [ sec : routingcoding ]",
    "we consider heterogeneous networks consisting of both routing and network coding nodes .",
    "we first consider networks where the nodes are only able to perform routing .",
    "we will formalise what we mean by `` routing '' later , and proposed a generalisation . in such routing - based schemes ,",
    "information is transmitted from the sources to the destinations via a collection of `` routing subnetworks '' .",
    "[ df : routingsubnetwork ] for any given network coding problem @xmath564 , a routing subnetwork is a subset @xmath565 of @xmath566 such that    1",
    ".   @xmath567 .",
    "thus , @xmath565 is associated with a source and we denote that unique source in @xmath568 by @xmath569 .",
    "2 .   for any link @xmath570 , @xmath571 . in other words , either there exists another link @xmath572 such that @xmath573 or @xmath574 , i.e. , the originating node of link @xmath26 is a source node of @xmath569 .",
    "hence , the subnetwork formed by the set of links in @xmath565 is in fact `` connected '' and is `` rooted '' at @xmath575 .",
    "a routing subnetwork is in fact a simple generalisation of the usual multicast trees used in networks with point - to - point links ( i.e. the underlying network is a directed graph ) for constructing a routing solution ( where messages are being forwarded and relayed at intermediate nodes without coding ) .",
    "while it is sufficient to consider multicast trees in such networks , the concept of multicast trees does not extend naturally to wireless networks ( where the underlying network is a directed _ hypergraph _ ) . in particular , in our hypergraph model , links @xmath576 are broadcast , i.e. , the message sent over a link @xmath26 can be received by more than one node .",
    "therefore , it is not reasonable ( and also not necessary ) to insist that there is a unique path connecting a source to a sink . according to our definition of a multicast constraint",
    ", sources may also be available at more than one node .",
    "therefore , the condition @xmath577 means that there exists a node @xmath578 such that @xmath579 .",
    "[ df : routingadmissible ] a rate - capacity tuple @xmath580 is called @xmath79-achievable  subject to a _ routing constraint _ if there exists a collection of routing subnetworks @xmath581 and _ subnetwork capacities _ @xmath582 such that    ( r1 ) : :    for any edge @xmath20 , @xmath583 ( r2 ) : :    for any @xmath0 and @xmath584 , there exists    @xmath585 such that    @xmath586 . in other words ,",
    "the node    @xmath467 is on the routing subnetwork .",
    "( r3 ) : :    for any source @xmath39 ,    @xmath587    clearly , these three conditions are not chosen arbitrarily but have a meaning in practice .",
    "suppose @xmath94 is @xmath79-achievable  subject to a routing constraint .",
    "this tuple corresponds to a zero - error routing solution defined as follows : assume without loss of generality that @xmath588 and @xmath589 are all positive integers . for each @xmath39 , let the source message @xmath302 be a @xmath383-ary row vector of length @xmath590 . for each @xmath0",
    ", one can use the routing subnetwork @xmath581 to transmit @xmath589 @xmath383-ary symbols of @xmath302 from the source nodes ( which have access to the source @xmath302 ) to all sink nodes @xmath401 . by ( r2 )",
    ", it is guaranteed that all sink nodes receive all @xmath590 @xmath383-ary symbols of @xmath302 and hence can decode @xmath302 .",
    "furthermore , a link @xmath20 is used in the routing subnetwork @xmath581 if @xmath591 .",
    "therefore , @xmath592 is the total number of @xmath383-ary symbols that have been transmitted on link @xmath26 .",
    "clearly , the rate - capacity tuple @xmath94 is fit for this routing based solution .    in this routing solution",
    ", a source node does not perform any coding , except for partitioning a source message into several independent segments , and forwarding each segment via a routing subnetwork to the corresponding sink nodes .",
    "this corresponds to the usual concept of routing in networks consisting of point - to - point links . for successful decoding ,",
    "a sink node must receive every segment of the source message from the required sources .",
    "in the following , we consider a slight generalisation of the concept of routing , where source nodes can encode source messages into _ correlated _ segments ( corresponding to intra - session coding ) . by doing so",
    ", we can weaken the conditions ( r2 ) and ( r3 ) .",
    "[ df : generalisedrouting ] a rate - capacity tuple @xmath94 is called @xmath79-achievable  subject to a _ generalised routing constraint _ if there exists a collection of routing subnetworks @xmath581 and _ subnetwork capacities _ @xmath582 satisfying ( r1 ) and the following condition :    ( r2@xmath593 ) : :    for any source @xmath39 and any sink node    @xmath401 ,    @xmath594    again , each @xmath79-achievable  tuple @xmath94 subject to a generalised routing constraint is fit for a zero - error routing scheme as follows :",
    "let @xmath302 be a @xmath383-ary row vector of length @xmath590 . instead of partitioning a source message @xmath302 into independent pieces , one can encode ( e.g. using simple codes for erasure channels ) @xmath302 into @xmath595 @xmath383-ary symbols such that any @xmath590 encoded symbols can reconstruct @xmath302 with no error .",
    "these @xmath595 symbols will be forwarded via the routing subnetworks @xmath581 ( where @xmath596 ) to sink nodes in @xmath50 .",
    "as before , all intermediate network nodes perform only store - and - forward operations .",
    "the condition ( r2@xmath593 ) then guarantees that each sink node @xmath401 receives at least @xmath590 coded symbols of @xmath302 .",
    "hence , the node can decode @xmath302 without error .    in the following , we will characterise the set of 0-achievable tuples subject to a ( generalised ) routing constraint using a similar framework as developed in sections [ sec : part1 ] and [ sec : part2 ] . developing a characterisation within this same framework",
    "provides a convenient way to evaluate how a routing constraint may reduce the set of @xmath79-achievable  tuples .",
    "we should point out that we are not the first to characterise @xmath79-achievablerate - capacity tuples subject to ( generalised ) routing constraints .",
    "in fact , if @xmath597 then the characterisation of @xmath79-achievable  rate - capacity tuples subject to ( generalised ) routing constraint can be obtained by solving variations of the fractional steiner tree packing problem  @xcite .",
    "our characterisation is however unified with the entropy function formulation used for network coding and highlights the differences ( and similarities ) between different characterisations with or without ( generalised ) routing constraints .",
    "so far we have seen that entropy functions and representable entropy functions were the key ingredients in characterising the capacity regions for general network codes and for linear codes . for networks with routing constraints",
    ", we introduce _ almost atomic functions _ which in theorem  [ thm : routing1 ] below will provide the corresponding characterisation of the set of @xmath79-achievable  tuples .",
    "a rank function @xmath149 $ ] is called _ atomic _ if there exists @xmath598 such that @xmath599 it is called _ almost atomic _ if it can be written @xmath600 where for all @xmath0 , @xmath582 and @xmath601 is atomic .",
    "aa    let @xmath602 , or simply @xmath603 , be the set of all almost atomic rank functions in @xmath136 $ ] .",
    "it can be easily proved that @xmath603 is a closed and convex cone contained in @xmath160 .",
    "thus , almost atomic rank functions are entropic .",
    "[ prop : routingequivalence ] let @xmath114 be an atomic function such that there exists nonempty subset @xmath604 and holds . then @xmath565 is a routing subnetwork ( for network coding problem @xmath62 ) if and only if @xmath605    we first prove the _ only - if _ part .",
    "let @xmath565 be a routing subnetwork .",
    "by definition , @xmath606 .",
    "it can be verified directly from definition that @xmath607 hence , @xmath608 .",
    "it remains to prove that @xmath609 .    for any @xmath20 ,",
    "if @xmath610 , then @xmath611 by . on the other hand , suppose @xmath612 .",
    "again as @xmath565 is a routing subnetwork , @xmath613 is nonempty .",
    "thus , @xmath614 hence , @xmath615 for all @xmath20 . consequently , @xmath616 .",
    "the only - if part follows .",
    "now , we will prove the _ if_-part .",
    "suppose @xmath617 .",
    "then @xmath618 . as @xmath456 ,",
    "@xmath619 and consequently @xmath620 . by",
    ", @xmath621 and condition 2 ) of definition  [ df : routingsubnetwork ] is satisfied .",
    "as @xmath334 , it can verified directly that @xmath622 . since the network @xmath31 is acyclic and there are only finite number of links , there must exist at least one @xmath39 such that @xmath623 .",
    "consequently , @xmath624 .",
    "hence condition 1 ) of definition  [ df : routingsubnetwork ] is satisfied and the proposition follows .",
    "[ thm : routing1 ] a rate - capacity tuple @xmath94 is @xmath79-achievable  subject to a routing constraint if and only if @xmath625).\\ ] ]    we will first prove the _ only - if _ part .",
    "suppose @xmath94 is @xmath79-achievable  subject to a routing constraint . by definition  [ df : routingadmissible ]",
    ", there exists a collection of routing subnetworks @xmath581 and nonnegative real numbers @xmath589 such that conditions ( r1 )  ( r3 ) hold .",
    "by proposition [ prop : routingequivalence ] , each @xmath581 is associated with an atomic rank function @xmath626 such that @xmath627 for all sink nodes @xmath628 , ( r2 ) implies that @xmath629 .",
    "hence , @xmath630 . on the other hand , if @xmath631 , then @xmath632 and @xmath633 .",
    "consequently , @xmath634 .",
    "let @xmath635 .",
    "since @xmath636 for all @xmath0 , @xmath114 is also in @xmath637 .",
    "finally , ( r2 ) and ( r3 ) imply that for any @xmath39 @xmath638 similarly , ( r1 ) implies @xmath639 for all @xmath20 .",
    "thus , @xmath640)$ ] and the only - if part follows .",
    "now , we will prove the _ if - part_. it is easy to prove that if @xmath94 is @xmath79-achievable  subject to a routing constraint , then all tuples in @xmath641 are also @xmath79-achievable .",
    "therefore , it is sufficient to prove that @xmath246 $ ] is @xmath79-achievable  subject to a routing constraint for all @xmath642 since @xmath114 is almost atomic , there exist atomic functions @xmath643 such that @xmath635 .",
    "as each @xmath601 is entropic ( and hence polymatroidal ) and @xmath589 is nonnegative for all @xmath0 , @xmath644 implies that @xmath645 by proposition [ prop : routingequivalence ] , each @xmath581 is in fact a routing subnetwork .",
    "also , @xmath634 implies that for any @xmath646 , @xmath647 this implies @xmath648 and hence ( r2 ) is satisfied .    for any @xmath39 , and @xmath401 , @xmath649 where ( @xmath0 ) follows from the fact that @xmath650 if @xmath651 .",
    "hence ( r3 ) is satisfied .",
    "condition ( r1 ) can also be proved directly . the if - part",
    "is then proved .    using a similar approach as in theorem [ thm : routing1 ] , we can also characterise the set of @xmath79-achievable  rate - capacity tuples subject to the generalised routing constraint .",
    "[ thm : grouting ] consider a network coding problem @xmath62 .",
    "a rate - capacity tuple @xmath94 is 0-achievable subject to the generalised routing constraint of definition  [ df : generalisedrouting ] if and only if @xmath652 ) .\\ ] ] where @xmath653(s ) & \\defined   \\min_{u\\in\\destinationlocation(s ) } { h } ( s \\wedge \\incoming(u ) ) \\\\",
    "\\proj^{*}_{\\problem}[h](e ) & \\defined \\ ; h(e ) .",
    "\\end{aligned}\\ ] ]    starting with the _ only - if _",
    "part , suppose @xmath94 is @xmath79-achievable  subject to the generalised routing constraint . by definition  [ df : generalisedrouting ] , there exists a collection of routing subnetworks @xmath581 , and nonnegative constants @xmath589 such that conditions ( r1 ) and ( r2@xmath654 ) hold .",
    "each @xmath581 is associated with a rank function @xmath655 defined as in .",
    "let @xmath656 again , ( r1 ) implies that @xmath657 by ( r2@xmath654 ) , for any @xmath39 and @xmath401 , @xmath658 where @xmath163 follows from that @xmath659    as holds for all @xmath401 , we have @xmath660(s ) .",
    "\\end{aligned}\\ ] ] thus , @xmath661)$ ] and the only - if part follows .",
    "now , we will prove the _ if_-part .",
    "let @xmath662 and @xmath663)$ ] .",
    "as before , we can construct a collection of functions @xmath601 , routing subnetworks @xmath581 and positive constants @xmath589 such that @xmath635 and holds . by definition , @xmath664 and for any @xmath39 and @xmath322 , @xmath660(s ) \\\\      & \\le   { h}(s\\wedge \\incoming(u ) ) \\\\      & = \\sum_{i : \\incoming(u ) \\cap { { \\mathcal t}}_{i } \\neq \\emptyset \\text { and } s\\in{{\\mathcal t}}_{i }   } c_{i}.     \\end{aligned}\\ ] ] then both ( r1 ) and ( r2@xmath654 ) are satisfied and the result follows .      in the previous section , we considered two varieties of routing schemes defined by routing subnetworks . in those schemes ,",
    "each subnetwork is dedicated to sending a segment of data from a source to its respective sinks .",
    "intermediate network nodes can only perform store - and - forward operations to forward the same data segment across a subnetwork . as only store - and - forward operations are performed , the computational requirements for intermediate nodes are relatively low . despite this advantage , such routing - based schemes may suffer loss in throughput , as evidenced by the now famous example of the butterfly network  @xcite .",
    "in some cases , this loss can be significant .    in this section",
    ", we will consider more advanced schemes where some subsets of the intermediate nodes have sufficient computational resources to permit more sophisticated data processing in order to increase the throughput .",
    "thus the network now consists of two types of nodes : routing nodes and network coding nodes . as demonstrated by the butterfly network example , there are known instances where the maximum possible throughput can in fact be achieved with only one network coding node , and all other nodes performing routing .    the aim of this section is to extend out methodology to such heterogeneous networks . as a first step , we need to clarify the concept of store - and - forward . figure [ fig : eg1 ] is a subnetwork of @xmath31 such that the node @xmath665 is a `` routing node '' ( where only store - and - forward operation is allowed ) .",
    "the node has two incoming links and one outgoing link .",
    "suppose that @xmath665 receives @xmath666 from the incoming link @xmath667 and @xmath668 from link @xmath669 .",
    "a natural question is : if @xmath665 can only perform store - and - forward operations , which types of outgoing message it can send ?        naturally , we should allow the routing node @xmath665 to send @xmath670 for any @xmath671 , but not @xmath672 .",
    "the question however is if @xmath665 can send @xmath673 which is a function of the incoming message from @xmath667 ?    in this paper , we will assume that @xmath665 , as a routing node , is in fact permitted to perform intra - edge coding and send @xmath674 .",
    "we do not allow inter - edge coding across different incoming links . using this slightly generalised definition of routing",
    ", we can once again use the tools developed earlier to characterise @xmath79-achievable/@xmath88-achievable  rate - capacity tuples for heterogeneous networks with `` partial routing '' constraints .    with respect to a network code @xmath675",
    ", an intermediate node @xmath665 is said to be a _ routing node _ if for all outgoing links @xmath26 of @xmath665 ( i.e. , @xmath676 ) , there exist auxiliary random variables @xmath677 such that @xmath678 in other words , the outgoing message @xmath396 is formed by a set @xmath679 such that each element @xmath680 is a function of the incoming message @xmath681 from the link @xmath682 . _ routing links _ are defined as outgoing links from a routing node .",
    "let @xmath683 be the set of all routing links .",
    "in other words , @xmath684 if and only if @xmath24 is a routing node .",
    "we refer to @xmath685 as a _ partial routing constraint_.    a network code satisfying the partial routing constraint @xmath685 is a set of random variables @xmath686 such that @xmath687 is an ordinary network code according to definition [ df : nc ] and in addition , and hold for all @xmath688 .",
    "we refer to such a code as a @xmath685-network code    to go along with our definition of a network code with partial routing constraints , we need to update our definition of fitness .",
    "a rate - capacity tuple @xmath94 is _ fit _ for a @xmath685-network code @xmath689 if @xmath690    note that we use rather than to highlight that the outgoing message @xmath396 will not be jointly compressed by the routing node .",
    "the set of @xmath79-achievable  and @xmath88-achievablerate - capacity tuples subject to a partial routing constraint @xmath685 can be defined similar to definitions [ df : admissible ] and [ df : achievable ] .",
    "our approach for characterisation of the set of @xmath79-achievable  or @xmath88-achievablerate - capacity tuples for @xmath685-codes is to transform the problem with partial routing constraints into an equivalent unconstrained problem @xmath691 .    given a network coding problem @xmath692 with partial routing constraint @xmath685 , define @xmath693 as follows    1 .",
    "add new nodes : @xmath694 } , e\\in\\routing , j \\in",
    "\\incoming(e ) \\}.\\ ] ] 2 .",
    "add new links : @xmath695 , e\\in\\routing , j \\in \\incoming(e )   \\}\\ ] ] such that @xmath696 ) } & = { { \\sf tail}(e ) } \\\\ { { \\sf tail}([j , e ] ) } & = v_{[j , e]}.\\end{aligned}\\ ] ] 3 .",
    "modifying existing link connections : for all @xmath697 , the set @xmath698 is modified as @xmath699 } : \\ :   e\\in\\routing , f\\in \\incoming(e ) \\}.\\end{aligned}\\ ] ] in other words , if a link @xmath682 was directed to a routing node @xmath24 for some @xmath688 , it will be redirected to the newly created node @xmath700}$ ] .",
    "figure [ fig : b ] is an example illustrating how to modify a network to remove the partial routing constraint . in this example , figure [ fig : b](a ) is one part of the network where @xmath688 is a routing link .",
    "figure [ fig : b](b ) shows how that part of the network is transformed . in the new network ,",
    "we no longer impose any routing constraint .",
    "[ thm : nettransform ] a rate - capacity tuple @xmath94 is @xmath79-achievable/@xmath88-achievable  with respect to a network coding problem @xmath701 subject to a partial routing constraint @xmath685 if and only if there exists a @xmath79-achievable/@xmath88-achievable  rate - capacity tuple @xmath702 for the network coding problem @xmath703 where @xmath704 } , \\quad \\forall e\\in   \\routing.\\label{eq : omegaprime }    \\end{aligned}\\ ] ]    by direct verification .    the construction of @xmath705 together with relationships between @xmath706 and @xmath707 remove the partial routing constraint by making the capacity of the links @xmath688 in @xmath705 sufficiently large such that network coding is never required at @xmath25 , which has sufficient capacity to simply forward all of the incoming messages .",
    "also note that the choice of @xmath708}$ ] are free , apart from the constraints  .    as a corollary of theorem [ thm : nettransform ] ,",
    "all of the results obtained in the earlier sections can also be applied to network coding problems with partial routing constraints .",
    "so far we have considered two classes of constraints on network codes . in section",
    "[ sec : part2 ] we considered linear network codes , which may be attractive for practical implementation . in section",
    "[ sec : part3 ] we considered networks where some , or all of the nodes are constrained to perform only store - and - forward types of operations . another important class of constraints to consider for network coding are motivated by security considerations .",
    "the objective is to determine the achievable network coding rates when we require secret transmission that is impervious to specified eavesdropping attacks .",
    "assume that there are @xmath709 adversaries in the network .",
    "adversary @xmath710 observes messages transmitted along links in the set @xmath711 and aims to reconstruct the set of sources indexed by @xmath712 .",
    "we refer to @xmath713 as the _ wiretapping pattern _ of the network .",
    "we will use the notation @xmath714 to denote the network coding problem subject to a secrecy constraint , also referred to as a _ secure network coding problem_. here , @xmath31 and @xmath32 are as usual the network topology and the connection constraint .",
    "the secure communications objective is to transmit information over a network satisfying the multicast requirements while simultaneously ensuring that the eavesdroppers gain no information about their desired sources .",
    "before we characterise the set of @xmath79-achievable/@xmath88-achievable  rate - capacity tuples for secure network coding , we need to point out a significant difference between ordinary and secure network codes . without a secrecy constraint , the transmitted message on any network link @xmath26 can be assumed without loss of generality to be a function of the source inputs and received messages available at the node @xmath24 . however , when secrecy constraints are enforced , it is usually necessary to encode messages _ stochastically _ to prevent an eavesdropper from learning any useful information about its desired sources .",
    "[ df : stochasticnc ] a _ stochastic network code _ is defined by a set of random variables @xmath715 with entropy function @xmath114 such that @xmath302 is uniformly distributed over its alphabet set for all @xmath716 and @xmath717 where    @xmath718 : \\\\           \\quad { h}({{{\\mathcal s } } } , \\nodes )   = \\sum_{s\\in\\sessions } { h } ( s )          + \\sum_{u\\in\\nodes }          h(u )   \\end{array}\\right\\ }      \\label{eq : sconstraint1 } \\\\      { { \\mathcal c}}_{\\net } ( \\problem ) & \\define       \\left\\ {         \\begin{array}{l }          \\hspace{-0.2 cm } h \\in{{\\mathcal h}}[\\sessions\\cup\\edges\\cup\\nodes ] : \\\\           \\quad h\\left ( s\\mid    \\incoming(e ) , { { \\sf tail}(e ) } \\right )   = 0 ,    \\forall   e\\in\\edges         \\end{array }      \\right\\}. \\label{eq : sconstraint2 }     \\end{aligned}\\ ] ]    in the definition , @xmath719 and @xmath720 are again the set of random sources ( indexed by @xmath39 ) and the set of messages ( transmitted on hyperedges @xmath20 )",
    ". the random variables @xmath721 can be thought of as the _ random keys _",
    "available at nodes @xmath722 for stochastic encoding .",
    "specifically , each link @xmath20 is associated with a local encoding function such that @xmath723 clearly , we have @xmath724 and hence . furthermore , we want to point out that the random keys @xmath721 are _ not _ like the usual secret keys that are privately shared between nodes in shannon - style secure communications . instead , they are locally ( and hence independently ) generated at each node . in other words , there are _ no _ correlated or common keys shared privately between nodes in advance .",
    "therefore , we will assume that @xmath725 are mutually independent , and require to hold .",
    "for a secure network coding problem @xmath726 , a rate - capacity tuple @xmath94 is called @xmath79-achievable  subject to a _ weak secrecy _",
    "constraint if there exists a sequence of stochastic network codes @xmath727 and positive normalising constants @xmath96 such that    1 .   for all @xmath72 and @xmath39 , @xmath728 2 .   for @xmath39 and @xmath729 , @xmath730 3",
    ".   for all @xmath731 , @xmath732",
    "similarly , a rate capacity tuple @xmath733 is called @xmath88-achievable  subject to a weak secrecy constraint if there exists a sequence of network codes @xmath734 satisfying ( s1 ) and ( s3 ) and the following condition ( s2@xmath654 ) :    1 .   for @xmath39 and @xmath84 , there exists decoding functions @xmath89 such that @xmath90    the following theorem can be proved by using the same technique as in corollary [ cor : ourbd ] . for brevity , we state the theorem without proof .    [ thm : mainsecure ]",
    "consider any secure network coding problem @xmath726 subject to a weak secrecy constraint .",
    "let @xmath735 : h\\left ( s\\mid   \\incoming(u ) \\right )   = 0 , \\\\",
    "\\hspace{2.5 cm }",
    "\\forall   s\\in\\sessions , u\\in\\destinationlocation(s )       \\end{array } \\right\\ } , \\label{eq : sconstraint3 } \\\\ { { \\mathcal c}}_{\\sec } ( \\problem ) & \\define \\left\\ { h\\in{{\\mathcal h}}[\\sessions\\cup\\edges\\cup\\nodes ] : h\\left({{\\mathcal a}}_{r } \\wedge { { \\mathcal b}}_{r}\\right ) = 0 , \\forall r\\in{{\\mathcal r } } \\right\\}.\\label{eq : sconstraint4}\\end{aligned}\\ ] ] if a rate - capacity tuple @xmath736 is @xmath88-achievable , then there exists @xmath737 such that @xmath738 or equivalently , @xmath739).\\ ] ]    the condition corresponds to the decoding constraint , requiring that any node @xmath401 can decode the source @xmath42 with vanishingly small error .",
    "the condition is the secrecy constraint , ensuring that an adversary can learn no information about the sources it is interested in .    unlike in theorem",
    "[ thm : arbitrarymain ] , we do not claim tightness of the outer bound even for colocated sources . this is because secure network nodes may locally generate random keys for the purpose of stochastic encoding .",
    "these keys , to a certain extent , behave like sources ( with no corresponding sink nodes ) , and hence the colocated source condition fails , even if the actual sources are colocated .",
    "weak secrecy requires that the amount of information leakage vanishes asymptotically after normalisation . in other words ,",
    "the amount of information leakage is negligible ( when compared with the size of the source messages ) .",
    "we can also consider a _",
    "strong secrecy constraint _",
    ", where we require the information leakage to be exactly zero .",
    "a rate - capacity tuple @xmath94 is @xmath79-achievable  subject to a",
    "_ strong secrecy _",
    "constraint if there exists a sequence of network codes @xmath740 and positive normalising constants @xmath96 satisfying ( s1 ) , ( s2 ) and the following condition    1 .",
    "@xmath741 for all @xmath256 and @xmath710 .",
    "similarly , it is @xmath88-achievable  subject to a strong secrecy constraint if the sequence of codes satisfies ( s1 ) , ( s2@xmath654 ) and ( s3@xmath654 ) .    in general",
    ", it is very hard to characterise the set of achievable rate - capacity tuples subject to a strong secrecy constraint , even implicitly via entropy functions .",
    "however , under the additional constraint of linearity , the set of @xmath79-achievable  rate - capacity tuples can in fact be characterised implicitly via the use of representable functions .",
    "let @xmath742 be a stochastic network code ( according to definition  [ df : stochasticnc ] ) for a secure network coding problem @xmath62 on a network @xmath381 .",
    "the code is called _ @xmath383-linear _ ( or simply linear ) if it satisfies the following conditions :    1 .   for @xmath743",
    ", @xmath681 is a random row vector such that each of its entries is selected independently and uniformly over @xmath384 .",
    "2 .   for any @xmath20",
    ", there exists a linear function @xmath744 such that @xmath745    a network coding problem is said to be subject to a _ @xmath383-linearity constraint _ if only @xmath383-linear network codes are allowed .",
    "consider a secure network coding problem @xmath62 where @xmath746 for all @xmath39 .",
    "a rate - capacity tuple @xmath94 is 0-achievable subject to @xmath383-linearity and strong secrecy if and only if @xmath747).\\ ] ]    we first prove the _ only - if _ part .",
    "suppose @xmath178 is 0-achievable subject to linearity and strong secrecy constraints .",
    "by definition , there exists a sequence of linear codes @xmath748 with entropy function @xmath559 and normalising constants @xmath76 such that ( s1 ) , ( s2 ) and ( s3@xmath654 ) hold . by ( s2 ) and ( s3@xmath654 ) , @xmath749 and hence , @xmath750 .",
    "consequently , @xmath751).\\ ] ] and the only - if part follows .",
    "now let @xmath752 to prove the _",
    "if_-part , it suffices to prove that @xmath246 $ ] is 0-achievable . as in the proof of theorem [ thm : mainlinear ]",
    ", there exists a sequence of @xmath383-representable functions @xmath753 and positive scalars @xmath754 such that @xmath755 for each @xmath256 , @xmath559 induces a zero - error linear network code @xmath756 such that @xmath757 however , the linear network code need not be strongly secure ( i.e. , @xmath758 ) . in the following , we will create from @xmath559 another representable function @xmath759 such that @xmath760    since @xmath559 is @xmath383-representable , there exists subspaces @xmath761 such that for all @xmath762 , @xmath763 for each @xmath710 and @xmath764 , we define @xmath765 then by direct verification , @xmath766 and hence @xmath767 .",
    "let @xmath768 by lemma [ lemma:5.1 ] , for every @xmath39 , there exists a subspace @xmath769 of @xmath770 such that @xmath771    for any @xmath39 , let @xmath44 be the unique source node where the @xmath772 source is available .",
    "let @xmath773    on the other hand , @xmath774 as @xmath775 we have @xmath776    since @xmath777 , @xmath778 as @xmath779 for @xmath39 , @xmath780    let @xmath759 be the representable function induced by @xmath781 then , it can be directly verified that    1 .",
    "@xmath782 where @xmath759 is the rank function induced by @xmath783 , and 2 .",
    "@xmath784 .",
    "consequently , @xmath785 $ ] , and also @xmath786 $ ] and @xmath246 $ ] , are 0-achievable subject to the two constraints .",
    "in secret sharing  @xcite , a secret is shared among a set of users @xmath100 where each user holds a component of the secret .",
    "the main objective is to ensure that only specified legitimate subgroups of users ( indexed by a subset @xmath787 of @xmath100 ) can successfully decode the secret .",
    "all other illegitimate subgroups of users should receive no information about the secret .",
    "the collection of all legitimate subsets @xmath788 is called the _ access structure _ of the secret sharing problem .",
    "we can reformulate a secret sharing problem as a secure network coding problem @xmath789 . in this secure network coding problem ,",
    "there is only one source ( the secret ) which is only available at the source node @xmath790 .",
    "there are @xmath115 intermediate nodes , each of which represents a user .",
    "the transmitted message an intermediate node ( or a user ) received from the source corresponds to the component of the secret that it holds .",
    "there are @xmath791 sink nodes indexed by @xmath792 .",
    "the sink node @xmath793 is connected to nodes ( or users ) @xmath794 and aims to reconstruct the secret .",
    "we also assume that each @xmath795 , is associated with an eavesdropper who can wiretap the set of edges @xmath796 .",
    "the secrecy constraint implies that all illegitimate subgroups of users have no information about the secret .",
    "mathematically , the secure network coding problem is defined as follows .",
    "1 .   @xmath797 where @xmath798 and @xmath799 ; 2 .   for any @xmath800 , @xmath801 , @xmath802 , @xmath803 and @xmath804 ; 3 .",
    "@xmath805 where ( @xmath0 ) @xmath806 , ( @xmath316 ) @xmath807 and ( @xmath317 ) @xmath808 ; 4 .",
    "@xmath809 .    by translating a secret sharing problem to a secure network coding problem",
    ", the results obtained in this paper can be applied to secret sharing .",
    "characterising the set of achievable rate - capacity tuples for a network coding problem is generally very hard . so far , there are only a limited number of scenarios where the sets of @xmath79-achievable/@xmath88-achievablerate - capacity tuples have been explicitly determined .",
    "one scenario is when there is only one source , @xmath810 and no partial routing constraint or secrecy constraints . in this case , the set of achievable rate - capacity tuples is explicitly characterised by the cut - set bound  @xcite .",
    "if a secrecy constraint is additionally imposed , the set of achievable tuples can still be determined if _",
    "( i ) _ all links have unit capacity and _ ( ii ) _ the eavesdropper is _",
    "@xmath811-uniform _ in the sense that an eavesdropper can wiretap any @xmath811 links in the network  @xcite . in both cases ,",
    "linear codes are optimal .",
    "it is natural to wonder whether there is any hope that wide classes of network coding problems could have simple , explicit characterisations . in the following two subsections",
    ", we will show that even in some very simple scenarios , finding the set of achievable rate - capacity tuples can be extremely hard .",
    "the first scenario will be an incremental multicast .",
    "the second scenario is a secure multicast .      in a _",
    "incremental multicast _ problem , sources are totally ordered such that a receiver who wants to reconstruct source @xmath42 is also required to reconstruct all other sources @xmath0 for @xmath812 . here , the symbol @xmath813 is defined with respect to the total ordering of the sources .",
    "incremental multicast is common in multimedia transmission , where data such as video or audio may be encoded into multiple layers .",
    "a layer can only be used for reconstruction at a receiver if all its previous layers are also available .",
    "this leads directly to an incremental multicast problem .",
    "we will construct the simplest case of a incremental multicast problem involving two layers , colocated at the same source node . hence , there are two types of receivers : those which request source @xmath814 , and those which request both sources ( @xmath814 and @xmath815 ) .",
    "even for such a simple setup , we will show that determining the set of achievable rate - capacity tuples can be as hard as solving any network coding problem in general .",
    "to prove our claim , we consider any ordinary network coding problem @xmath245 , where sources may or may not be colocated .",
    "we will transform @xmath62 into a two - layer incremental multicast problem @xmath816 and prove in theorem [ thm : challenge1 ] that determining the set of achievable tuples in the incremental multicast problem @xmath817 is at least as hard as determining the outer bound of corollary [ cor : ourbd ] for the problem @xmath62 .",
    "the network @xmath818 is obtained from its subgraph @xmath31 by adding nodes and hyperedges @xmath819 with connections @xmath820 for all @xmath821 .",
    "in addition to augmenting the network , we also need to define the connection requirement @xmath822 . in our two - layer incremental multicast problem",
    "there are two sources indexed by @xmath823 all the sources are colocated at the node @xmath824 , i.e. , @xmath825 finally , the destination location mapping @xmath826 is defined as @xmath827 figure [ fig : challenge1 ] exemplifies how to convert an ordinary network coding problem @xmath62 ( which has two sources ) into a two layers incremental multicast problem . here , a source will be denoted by a double circle , and a sink by an open square .",
    "the label beside a source or a sink denotes the index of the sources which are available or are required at the node .",
    "note that in the figure , the sink nodes @xmath467 and @xmath828 in the original problem @xmath62 are no longer sink nodes in the incremental multicast problem @xmath817 .",
    "any rate - capacity tuple @xmath829 for @xmath62 induces another rate - capacity tuple @xmath830 in @xmath831 for @xmath817 such that @xmath832 where @xmath833 and @xmath834 .",
    "[ thm : challenge1 ] let @xmath94 be a rate - capacity tuple in @xmath835",
    ". then the following two claims are valid .    1 .",
    "if @xmath836 ) , $ ] then @xmath837).\\ ] ] 2 .",
    "if a rate - capacity tuple @xmath94 for @xmath62 is 0-achievable , then @xmath838 is 0-achievable with respect to @xmath817 .",
    "see appendix  [ app : challenge1 ]    using a similar arguments as in theorem [ thm : challenge1 ] , we can also prove the following theorem , whose proofs we omit for brevity .",
    "[ thm : challenge1linear ] let @xmath94 be a rate - capacity tuple in @xmath835",
    ". then the following two claims are valid .    1 .",
    "if @xmath839 ) , $ ] then @xmath840).\\ ] ] 2 .   if @xmath94 is 0-achievable with respect to @xmath62 subject to the @xmath383-linearity constraint , then @xmath838 is also 0-achievable with respect to @xmath817 , subject to the @xmath383-linearity constraint .",
    "[ cor : challenge1 ] suppose all the sources are colocated in @xmath62",
    ". then    1 .",
    "@xmath94 is 0-achievable with respect to @xmath62 if and only if @xmath838 is also 0-achievable with respect to @xmath817 .",
    "2 .   @xmath94 is 0-achievable with respect to @xmath62 subject to the @xmath383-linearity constraint if and only if @xmath838 is also 0-achievable with respect to @xmath817 subject to the same linearity constraint .    a direct consequence of theorems [ thm : arbitrarymain ] , [ thm : mainlinear ] , [ thm : challenge1 ] and [ thm : challenge1linear ] .    in @xcite , a specific network coding problem @xmath62",
    "was proposed , such that all sources are colocated and that determining the set of @xmath88-achievable rate - capacity tuple is at least as hard as determining the set of all information inequalities .",
    "furthermore , it was also proved that linear codes are not optimal for @xmath62 which is not achievable when subject to the additional linearity constraint . ] .",
    "therefore , by corollary [ cor : challenge1 ] , we can directly prove the following proposition .",
    "[ prop : challenge1 ] there exists a two - layer incremental multicast network coding problem @xmath817 such that    1 .",
    "characterising the set of achievable rate - capacity tuples for a two - layer incremental network is in general no simpler than determining the set of all information inequalities .",
    "2 .   linear codes are not optimal .      in this subsection",
    ", we consider another scenario , very simple secure network coding problem with only one source .",
    "we will again show that solving the resulting secure network coding problem can be as hard as solving a general multi - source unconstrained network coding problem .",
    "our approach is essentially the same as that used in the previous subsection for the incremental multicast .",
    "we will construct a simple single - source secure network coding problem @xmath841 from an ordinary network coding problem @xmath49 .",
    "we will then show that solving the so - constructed secure network coding problem is as hard as solving the original network coding problem .",
    "construct the network @xmath842 in @xmath843 by adding nodes and hyperedges @xmath844 with link connections : @xmath845 for all @xmath846 .",
    "the connection requirement @xmath847 is defined as follows : @xmath848 where @xmath849    figure [ fig : thenetwork ] exemplifies how to convert an unconstrained network coding problem @xmath62 into a single - source secure network coding problem .    as before , for any rate - capacity tuple @xmath850",
    ", we define a tuple @xmath851 as follows : @xmath852 for all @xmath833 and @xmath322 .",
    "[ thm : challenge2 ] let @xmath94 be a rate - capacity tuple in @xmath835",
    ". then the following two claims are valid .    1 .",
    "if @xmath853 for some @xmath854 then @xmath855 2 .   if a rate - capacity tuple @xmath94 for @xmath62 is 0-achievable , then @xmath856 is 0-achievable with respect to @xmath843 subject to the strong secrecy constraint",
    ".    see appendix  [ app : challange2 ]    the following theorem is the counterpart of theorem [ thm : challenge1linear ] .",
    "again , its proof will be omitted .",
    "[ thm : challenge2linear ] let @xmath94 be a rate - capacity tuple in @xmath835 .",
    "then the following two claims are valid .    1 .",
    "if @xmath857 ) , $ ] then @xmath840).\\ ] ] 2 .   if @xmath94 is 0-achievable with respect to @xmath62 subject to the @xmath383-linearity constraint , then @xmath856 is also 0-achievable with respect to @xmath843 , subject to the strong secrecy and @xmath383-linearity constraint .",
    "suppose all the sources are colocated in @xmath62",
    ". then    1 .",
    "@xmath94 is 0-achievable with respect to @xmath62 if and only if @xmath856 is also 0-achievable with respect to @xmath843 subject to the strong secrecy constraint .",
    "@xmath94 is 0-achievable with respect to @xmath62 subject to the @xmath383-linearity constraint if and only if @xmath856 is also 0-achievable with respect to @xmath843 subject to the strong secrecy and @xmath383-linearity constraint .",
    "[ prop : challenge2 ] there exists a single source secure multicast network coding problem @xmath843 such that    1 .",
    "characterising the set of achievable rate - capacity tuples for @xmath843 is in general no simpler than determining the set of all information inequalities .",
    "2 .   linear codes may not be optimal .",
    "* remark : * in @xcite , it was proved that in the single - source case , if all links have equal capacity and the eavesdroppers capability is limited by the total number of links it can wiretap , then linear network codes are optimal",
    ". therefore , proposition [ prop : challenge2 ] is indeed a surprising result proving that linear network codes are not optimal in general .",
    "characterisation of the set of zero - error or vanishing - error achievable rate - capacity tuples for network coding is a fundamental problem in multiterminal information theory . in @xcite",
    ", it was proved that this characterisation problem is extremely difficult in general and is as hard as determining the set of all information inequalities .",
    "this goes some way toward explaining why the problem has so far been solved only for a few special cases .",
    "the authors in @xcite and @xcite used entropy functions to implicitly characterise the set of achievable rate - capacity tuples for general networks .",
    "although this characterisation is implicit , it offers insights about the structure of the set of achievable tuples .",
    "for example , knowing that the set of almost entropic functions @xmath858 is not polyhedral , @xcite proved that the set of achievable tuples also is not polyhedral in general .",
    "this paper extended @xcite and @xcite in several aspects .",
    "first , we proved that when sources are colocated , the outer bound given in ( * ? ? ?",
    "* section 15.5 ) is indeed tight . in particular",
    ", we showed that the set of rate - capacity tuples achievable with vanishing error , and the set achievable with zero error are indeed the same .",
    "we also gave evidence to support our conjecture that the outer bound in ( * ? ? ?",
    "* section 15.5 ) remains tight even when sources are not colocated .",
    "secondly , we considered network coding problems subject to several practically - motivated constraints , such as linear coding , the restriction of some or all nodes to perform only routing , and security requirements .",
    "for these cases we characterised the set of zero - error and vanishing - error achievable rate - capacity tuples .",
    "finally in section [ sec : challenges ] , we proved that even for very simple network coding problems , such as the incremental multicast problem and the single source secure network coding problem with arbitrary wiretapping patterns , characterisation of achievable tuples is as hard as the characterisation problem for general unconstrained network coding .",
    "we also proved that linear codes are suboptimal for both the general incremental multicast problem and for the single source secure network coding problem .",
    "consider the following combinatorial problem .",
    "suppose that there are @xmath435 boxes , @xmath811 of which are nonempty .",
    "if we randomly select @xmath859 distinct boxes , then the probability that all selected boxes are empty is upper bounded by @xmath860    let @xmath861 .",
    "since @xmath862 , there exists @xmath863 such that @xmath864 for all @xmath865 .",
    "hence , can be relaxed as @xmath866    let @xmath867 be a pair of quasi - uniform random variables . as @xmath868 is uniform over its support , @xmath869 .",
    "let @xmath870 partition the set @xmath871 randomly into @xmath872 subsets , each of which is of size @xmath859 .",
    "these disjoint subsets will be denoted by @xmath873 where @xmath874    for any @xmath875 and @xmath876 , let @xmath877 be the event that @xmath878 in other words , the event is equivalent to the existence of an element @xmath879 such that @xmath880 . in the following , we will prove that the probability of @xmath877 is `` arbitrarily close to one asymptotically '' for all @xmath881 and @xmath882 .    for any @xmath883",
    ", it is easy to see that @xmath884 and @xmath885 , implies that @xmath886 and hence via the union bound , the probability that the event @xmath877 occurs for all @xmath887 and @xmath888 is at least @xmath889    this probability approaches to 0 as @xmath890 goes to infinity . consequently , if the entropy @xmath891 ( and hence also @xmath890 ) is sufficiently large , there exists a way to partition @xmath871 such that for any @xmath881 and @xmath888 , there exists at least one @xmath892 such that @xmath893 .",
    "assume without loss of generality that @xmath894 .",
    "repeating the same argument , we can recursively prove that for any set of quasi - uniform random variables @xmath895 and @xmath329 sufficiently large , there exists at least a way to partition @xmath896 into @xmath897 subsets @xmath898 where @xmath899 such that for any @xmath900 and @xmath901 , there exists at least one @xmath902 such that @xmath903 .",
    "hence , the proposition is proved .",
    "we first prove the first claim .",
    "suppose @xmath904)\\ ] ] for some @xmath905 then by definition , @xmath906    consequently , by  and  , @xmath907 where @xmath908 follows from the fact that @xmath909 ( and hence is polymatroidal ) .",
    "similarly , we can also prove that @xmath910    let @xmath123 be the `` projection '' of @xmath911 on @xmath136 $ ] such that for any @xmath912 and @xmath913 , @xmath914 in the following , we will prove that @xmath915)\\ ] ] and @xmath916    first , @xmath917 .",
    "hence , its projection @xmath123 is also in @xmath918 .",
    "second , the network @xmath705 contains @xmath31 as a subnetwork and @xmath919 . in other words , if a node @xmath467 has access to the source @xmath42 in the network coding problem @xmath62 , then @xmath467 also has access to what is being transmitted along the link @xmath920 in @xmath817 .",
    "the link @xmath920 in @xmath705 is thus like an imaginary source link in @xmath31 .",
    "it can then be verified directly that @xmath921 .",
    "now , we will prove that @xmath922 .",
    "as @xmath923 and that the set of links @xmath924 separates the source node @xmath824 from the sink node @xmath925 in @xmath705 , @xmath926 consequently , @xmath927 where @xmath908 follows from the fact that @xmath928 and @xmath929 follows from .",
    "similarly , the set of links @xmath930 separates the source node @xmath824 from the sink node @xmath931 in @xmath705 .",
    "hence , @xmath932    therefore , all the inequalities in and are in fact equalities .",
    "in particular , @xmath933 and @xmath934    by , @xmath935 . hence , @xmath936 and @xmath937 . furthermore , as @xmath938 we prove that @xmath915).\\ ] ]    1h^ now , it remains to show that @xmath939 .",
    "first , consider any @xmath39 and @xmath401 . by ",
    ", @xmath940 as @xmath941 , @xmath942 .",
    "hence , @xmath943 together with the decoding constraint ( for the receiver @xmath944 ) @xmath945 we can prove that @xmath946 finally , using and that @xmath947 , we have @xmath948 thus , @xmath949 and @xmath950 . the first claim is proved .    to prove the second claim ,",
    "suppose @xmath94 is 0-achievable with respect to @xmath62 .",
    "by definition , there exists a sequence of zero - error network codes @xmath951 for @xmath62 , and a sequence of positive constants @xmath754 such that @xmath952 assume without loss of generality that @xmath953 for each @xmath256 , define a new set of random variables @xmath954 such that for any @xmath39 and @xmath401 ,    1 .",
    "@xmath955 ; 2 .   @xmath956",
    "@xmath957 is a set of mutually independent random variables such that each of which is uniformly distributed over @xmath958 and @xmath959 4 .",
    "@xmath960 ; 5 .",
    "@xmath961 ; 6 .",
    "@xmath962 ; 7 .",
    "@xmath963 .",
    "it can then be proved directly that @xmath964 is a sequence of zero - error network codes for the network coding problem @xmath817 .",
    "consequently , @xmath965 is 0-achievable with respect to @xmath817 .",
    "the theorem is proved .",
    "we first prove the first claim .",
    "let @xmath966 for some @xmath967      recall that @xmath972 is a rank function in the space @xmath973 $ ] .",
    "let @xmath123 be its `` projection '' on @xmath136 $ ] such that for any @xmath912 and @xmath913 , @xmath974 in the following , we will prove that @xmath975)\\ ] ] and @xmath976        on the other hand , the decoding constraint @xmath987 ( for the sink node @xmath925 ) , we have @xmath988 together with  , ( and with the fact that @xmath989 is a polymatroid ) implies that @xmath990 by the upper bounds on @xmath991 and @xmath992 in  , we can in fact prove that @xmath993              similarly , focusing on the receiver @xmath944 , the decoding constraint @xmath1010 and that @xmath1011 imply that @xmath1012 and @xmath1013 by , @xmath1014 . on the other hand , by and @xmath1015 furthermore , by the topology constraint @xmath1016 therefore , together with , we have @xmath1017    similarly , by and , @xmath1018 and hence @xmath1019 consequently , we have @xmath1020 on the other hand , by the topology constraint , @xmath1021 again , by , @xmath1022 . then , by , we can prove that @xmath1023      finally , notice that @xmath1026 where @xmath908 , @xmath929 and @xmath1027 follow respectively , and . by and",
    ", we have @xmath1028 together with  , we can prove that @xmath1029 thus , @xmath1030 and @xmath1031 thus , @xmath1032 and the first claim is proved .",
    "we will now prove the second claim .",
    "the idea of the proof is similar to that in the incremental multicast scenario .",
    "suppose @xmath94 is 0-achievable with respect to @xmath62 .",
    "by definition , there exists a sequence of zero - error network codes @xmath951 for @xmath62 , and a sequence of positive constants @xmath754 such that @xmath952 assume without loss of generality that @xmath1033 ( i.e. , the support of @xmath1034 ) is equal to @xmath1035 . for each @xmath256 , construct the following set of random variables @xmath1036 such that for all @xmath833 and @xmath401 ,    1 .",
    "@xmath1037 ; 2 .",
    "@xmath1038 ; 3 .",
    "@xmath1039 is uniformly distributed over @xmath1033 for all @xmath39 and that @xmath959 4 .",
    "@xmath1040 ; 5 .",
    "@xmath1041 6 .",
    "@xmath1042 ; 7 .",
    "@xmath1043 ( i.e. , @xmath1044 is a deterministic random variable ) for all @xmath1045 ;    again , it can be verified directly that @xmath1046 is a strongly secure zero - error network codes for @xmath843 .",
    "consequently , @xmath965 is 0-achievable with respect to @xmath1047 , subject to strong secrecy constraint ."
  ],
  "abstract_text": [
    "<S> in this paper , we use entropy functions to characterise the set of rate - capacity tuples achievable with either zero decoding error , or vanishing decoding error , for general network coding problems . </S>",
    "<S> we show that when sources are colocated , the outer bound obtained by yeung , _ a first course in information theory _ , section 15.5 ( 2002 ) is tight and the sets of zero - error achievable and vanishing - error achievable rate - capacity tuples are the same . </S>",
    "<S> we also characterise the set of zero - error and vanishing - error achievable rate capacity tuples for network coding problems subject to linear encoding constraints , routing constraints ( where some or all nodes can only perform routing ) and secrecy constraints . </S>",
    "<S> finally , we show that even for apparently simple networks , design of optimal codes may be difficult . </S>",
    "<S> in particular , we prove that for the incremental multicast problem and for the single - source secure network coding problem , characterisation of the achievable set is very hard and linear network codes may not be optimal . </S>"
  ]
}