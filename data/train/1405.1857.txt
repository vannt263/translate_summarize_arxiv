{
  "article_text": [
    "a _ switched system _ comprises of two components  a family of systems and a switching signal .",
    "the _ switching signal _ selects an active subsystem from the family at every instant of time @xcite , and the family of systems may contain nonlinear dynamics , systems with delays , etc .",
    "switching signals are broadly classified as time - dependent ( depends only on time ) , state - dependent ( depends on state as well ) , and with memory ( also depends on the history of active subsystems ) @xcite .    in this article",
    "we stay within the confines of discrete - time switched linear systems with purely time - dependent switching signals .",
    "stability of such systems has been studied extensively by researchers over the past few decades , see e.g. , @xcite for detailed surveys .",
    "this study can be broadly classified into two categories  stability under _ arbitrary switching _ and stability under _ constrained switching_. in the former category , conditions on the family of systems are identified such that the resulting switched system is asymptotically stable under all admissible switching signals @xcite ; in the latter category , given a family of systems , conditions on the switching signals are identified such that the resulting switched system is asymptotically stable @xcite .    our focus in this article is on stability of discrete - time switched linear systems under constrained switching @xcite .",
    "stability conditions in this direction primarily rely on the idea of _ slow switching _",
    "vis - a - vis _ ( average ) dwell time _ switching .",
    "these results were originally developed in the context of continuous - time switched systems , but they can be readily extended to the discrete - time setting @xcite , ( * ? ? ?",
    "* chapter 3 ) , with the ( average ) dwell time expressed in terms of the number of time steps @xcite .",
    "this classical theory pertains to switched systems in which all subsystems are stable . in case",
    "there are unstable systems , slow switching alone is not sufficient to guarantee stability of the switched system , and additional conditions are required to ensure that the switched system does not spend too much time on the unstable subsystems ; see e.g. , @xcite .",
    "departing from this set of results , in @xcite the authors study global exponential stability of a discrete - time switched linear system in which not all subsystems are schur stable ( or possibly no subsystem is schur stable ) but the unstable subsystems form a stable combination .",
    "the characterization of the stabilizing switching signal in this new setting involves a modified definition of average dwell time ( * ? ? ?",
    "* chapter 3 ) , @xcite , and the rule of activating the schur stable subsystems ( if any ) arbitrarily but activating the unstable subsystems depending on a prespecified ratio .",
    "in @xcite the authors present a general class of switching signals for global asymptotic stability of switched linear systems .",
    "our conditions involve _ only _ certain asymptotic properties of the switching signal and do not involve nor imply point - wise bounds on the number of switches  unlike in the case of average dwell time switching .",
    "consequently , there is plenty of flexibility insofar as the transient behaviour of the switching signals are concerned .",
    "although this is not the first instance when unstable systems in the family are considered ( e.g. , @xcite ) , to the best of our knowledge , this is the first instance when unstable systems in the family are considered _ and _ the stabilizing conditions depend only on asymptotic behaviour of the switching signal . on the one hand ,",
    "our conditions require the presence of at least one asymptotically stable system in the family and is therefore `` conservative '' compared to the ones in the literature that accommodate families with all unstable systems ( e.g. , @xcite ) . on the other hand , we do not require the unstable systems in the family to form an asymptotically stable combination .",
    "the conditions proposed in @xcite are also numerically easier to verify than verifying semidefinite programming based conditions ( e.g. , @xcite ) on the given family of systems .    in this article",
    "we address the important aspect of existence and algorithmic synthesis of the class of stabilizing switching signals proposed in @xcite . given a family of systems ,",
    "the aspect of algorithmic synthesis of a class of stabilizing switching signals is important for obvious reasons and is not new in the switched systems literature , see e.g. , @xcite , where randomized algorithms to synthesize stabilizing state - dependent switching rules for multimodal systems are presented , and @xcite , where the authors propose optimization - based methods to verify the average dwell time property . in @xcite the authors provide a partial solution towards existence and algorithmic synthesis of the class of stabilizing switching signals under consideration .",
    "here we extend the proposed techniques further and provide an array of results .",
    "the overarching contributions of this article are twofold , the first of which addresses the following pair of questions :    1 .",
    "given a family of systems , possibly containing unstable dynamics , under what condition does there exist a switching signal that satisfies the conditions proposed in ( * ? ? ?",
    "* theorem 1 ) ? 2 .",
    "if there exists such a switching signal , then how to detect / design it algorithmically ?    * towards answering ( a ) and ( b ) , we employ graph - theoretic terminology and arguments in our analysis .",
    "a weighted digraph is associated to a family of subsystems and the admissible transitions between them , and a switching signal is represented by an infinite walk on the above digraph , both in a natural way ; see  [ ss : swsigprop ] for precise details .",
    "we are interested in the class of infinite walks corresponding to the class of stabilizing switching signals proposed in @xcite .",
    "we shall henceforth freely switch between system - theoretic and the corresponding graph - theoretic terminology in the above sense .",
    "* we propose sufficient conditions for the desired infinite walk to admit what we call a closed contractive walk , the latter necessarily of finite length , and also discuss algorithmic detection / design of such walks .",
    "a closed contractive walk gives rise to an infinite walk corresponding to a stabilizing switching signal in a natural way , as we shall see momentarily .",
    "* given a weighted digraph , we provide two necessary and sufficient conditions for the existence of the aforementioned closed contractive walk in terms of a contractive circuit and a contractive cycle .",
    "for a contractive circuit we discuss an algorithm based on a linear program to detect such a circuit , and if it exists , we construct it algorithmically . for a contractive cycle",
    "we show that it is equivalent to detecting / designing a cycle of `` negative weight '' and employ standard algorithms for the same .",
    "[ s : sola ] for details .    the second major contribution of this article is towards posing and answering a more ambitious question :    1 .",
    "what class of switched systems admits the class of switching signals that satisfy the conditions proposed in ( * ? ? ?",
    "* theorem 1 ) ?",
    "* this question necessarily entails a shift in paradigm : while ( a ) and ( b ) dealt with conditions for a `` given '' switched system , ( c ) seeks to identify a suitable `` class of switched systems '' . at the level of generality that ( c ) pertains to ,",
    "there are two natural candidate apparatuses to turn to for providing its answers  baire category theory and probability .",
    "we turn to the latter , and under mild conditions provide a randomized algorithmic mechanism to identify a class of switched systems that satisfy the conditions proposed in ( * ? ? ?",
    "* theorem 1 ) . * our contributions in this direction , presented in  [ s : solb ] , may be viewed from the following four perspectives : * * firstly , our algorithm detects cycles on ( the underlying digraph of ) switched systems that are `` typical '' with high probability , and under mild conditions we guarantee that such cycles are contractive . * * secondly , the deterministic algorithms that are employed for answers to ( a ) and ( b ) above may not be applicable to switched systems whose underlying digraphs are large , especially if their sizes are so large that not all the weights can be kept in memory at once . for such large digraphs",
    "our algorithm provides probabilistic guarantees in the spirit of randomized algorithms for detection and design of contractive cycles . * * thirdly , and in cue with the preceding point , our algorithm is of an `` online '' nature in the following way : starting with a rough probabilistic description of the underlying weighted digraph , ( i.e. , without knowledge of the precise values of the weights , ) we explore the digraph and synthesize a cycle during this exploration that is contractive with high probability . on the other hand ,",
    "the traditional algorithms for detecting cycles require complete knowledge of the digraph and the vertex and edge weights a priori . * * fourthly , if the constituent subsystems of a switched systems are prone to evolve over time in a manner that is not precisely known but certain statistical estimates of the nature of evolution are available , our algorithm applies and constructs a contractive cycle with uniform probabilistic guarantees over all such evolutions . see  [",
    "s : solb ] for details .",
    "the remainder of this article is organized as follows : in  [ s : prelims ] we briefly recall the class of stabilizing switching signals proposed in @xcite and formulate the problems under consideration .",
    "our main results appear in  [ s : sola ] and  [ s : solb ] .",
    "we provide numerical examples in ",
    "[ s : numex ] .",
    "we conclude in  [ s : concln ] with a brief discussion on future directions .",
    "the proofs of our main results are provided in a consolidated fashion in ",
    "[ s : proofs ] .",
    "* notation*. @xmath0 is the set of natural numbers , @xmath1 , and @xmath2 is the set of real numbers . for a finite set @xmath3 , @xmath4 denotes its cardinality and @xmath5 denotes the disjoint union of @xmath3 with another finite set @xmath6 . for a digraph @xmath7 such that @xmath8 , @xmath9 denotes the outdegree of a vertex @xmath10",
    ", @xmath11 denotes the set of outneighbours of a vertex @xmath12 in @xmath13 , and @xmath14 denotes the outdegree of @xmath12 in @xmath13 . for a walk @xmath15 on @xmath7",
    ", @xmath16 denotes its length .",
    "we consider a family of discrete - time linear systems @xmath17 where @xmath18 is the vector of states at time @xmath19 , @xmath20 is a finite index set , and @xmath21 is a known constant full - rank matrix for each @xmath22 .",
    "let @xmath23 be a _ switching signal _ that specifies at every time @xmath19 , the index of the active subsystem from the family . the discrete - time",
    "_ switched linear system _ generated by the given family of systems and the switching signal @xmath24 is given by @xmath25 given a family of systems , in @xcite the authors identify a general class of switching signals @xmath24 that admits a crisp characterization under which the resulting switched system is globally asymptotically stable . recall that by definition , the switched system is _ globally asymptotically stable _",
    "( gas ) for a given switching signal @xmath24 if is    * lyapunov stable , and * globally asymptotically convergent : @xmath26 , @xmath27 .",
    "preparatory to our results , we begin with :      let @xmath28 and @xmath29 be the sets of indices of the asymptotically stable and unstable systems in the family , respectively .",
    "[ fact : key ] for each @xmath22 there exists a pair @xmath30 , where @xmath31 is a symmetric and positive definite matrix , and    * if @xmath32 , then @xmath33 ; * if @xmath34 , then @xmath35 ;    such that , with @xmath36 , we have @xmath37 , where @xmath38 solves the @xmath39th recursion in , @xmath22 .",
    "we call @xmath40 , @xmath22 , lyapunov - like functions .",
    "[ fact : muij ] there exist numbers @xmath41 such that @xmath42 for all @xmath43 , whenever it is admissible to switch from @xmath44 to @xmath45 , @xmath46 . in particular , the smallest such constants @xmath47 are given by @xmath48 , where for a matrix @xmath49 having real spectrum",
    ", @xmath50 denotes its maximal eigenvalue .",
    "we associate a weighted digraph @xmath51 with a switched system in the following fashion :    * the index set @xmath52 denotes the set of vertices of @xmath53 , * the set of edges @xmath54 of @xmath53 consists of : * * a directed edge from @xmath44 to @xmath45 , @xmath46 , whenever a switching from system @xmath44 to system @xmath45 is admissible , and * * a self - loop at vertex @xmath45 , @xmath55 , whenever it is admissible to dwell on system @xmath45 for at least two consecutive time steps . *",
    "@xmath56 , @xmath57 (  la fact [ fact : muij ] ) and @xmath58 , @xmath55 , (  la fact [ fact : key ] ) denote the edge weights and vertex weights of @xmath51 , respectively .",
    "we may abbreviate @xmath51 by @xmath53 if there is no risk of confusion .",
    "recall that a _ walk _",
    "@xmath15 on a digraph @xmath7 @xcite is an alternating sequence of vertices and edges @xmath59 , where @xmath60 , @xmath61 , @xmath62 .",
    "the _ initial vertex _ of @xmath15 is @xmath63 and the _ final vertex _ of @xmath15 is @xmath64 .",
    "if @xmath65 , we say that the walk is closed . in this article",
    "we follow the convention : a closed walk @xmath66 is a _ circuit _ if all its edges are distinct .",
    "@xmath15 is said to be a _ cycle _ if the vertices @xmath67 , @xmath68 are distinct from each other and @xmath63 .",
    "the length of a walk @xcite is its number of edges , counting repetitions , e.g. , in the above case @xmath15 the length of the walk @xmath15 is @xmath69 . in the sequel by the term _ infinite walk",
    "_ we mean a walk of infinite length , i.e. , it has infinitely many edges .",
    "an _ initial _",
    "_ subwalk _ @xmath70 of a walk @xmath15 is an initial segment of @xmath15 , which we write as @xmath71 .",
    "the following essentially obvious fact associates a switching signal @xmath24 to an infinite walk on the weighted digraph @xmath53 :    [ fact : walk ] the set of switching signals @xmath72 and the set of infinite walks on @xmath51 ( defined as above ) are in bijective correspondence .    for a walk @xmath15 on @xmath53 :    * let @xmath73 be the number of distinct vertices that appear in @xmath15 , and define @xmath74 to be the _ transition frequency _ of @xmath15 ; * we define the function @xmath75 where @xmath76 and @xmath77 denote the number of times the edge @xmath78 and the vertex @xmath45 appear in @xmath15 , respectively .      in the light of fact [ fact :",
    "walk ] we rephrase ( * ? ? ?",
    "* theorem 1 ) in the following manner :    [ t : recallthm ] consider the underlying weighted digraph @xmath53 of the switched system .",
    "the switched system is gas under all switching signals @xmath24 , whose corresponding infinite walks (  la fact [ fact : walk ] ) @xmath15 satisfy @xmath79 and @xmath80 where @xmath81 and @xmath82 are as defined in and , respectively .",
    "[ r : condn1 ] since we are in the discrete - time setting , the association (  la fact [ fact : walk ] ) of the length of a walk with time is natural .",
    "condition in the above theorem corresponds to the condition that the switching frequency of @xmath24 is not asymptotically vanishingly small ( * ? ? ?",
    "* theorem 1 ) . in the presence of unstable systems in , this condition is necessary to ensure that the switched system does not eventually adhere to an unstable system .",
    "the first term in the numerator of @xmath82 captures the number of times each admissible transition @xmath83 occurs in @xmath24 till time @xmath19 , weighted by @xmath84 , where @xmath85 is as in fact [ fact : muij ] .",
    "the term @xmath86 ( and @xmath87 ) captures the number of times system @xmath88 ( resp .",
    "@xmath89 ) is activated till time @xmath90 by @xmath24 , weighted by @xmath91 , where @xmath92 obeys fact [ fact : key ] .",
    "[ r : coselection ] of course there is an element of `` choice '' in the selection of the lyapunov - like functions in fact [ fact : key ] and consequently , @xmath93 s and @xmath47 s are not unique .",
    "ideally one would like to algorithmically determine the possibility of co - designing the matrices @xmath94 s and the scalars @xmath93 s such that switching signals satisfying exist , and if so , to construct such a switching signal .",
    "this particular co - design problem , to our knowledge , is numerically difficult and in the absence of a numerical solution to it , we consider the matrices @xmath94 s and the scalars @xmath93 s as given , and focus on algorithmic synthesis of switching signals satisfying .    given a family of systems , both    1 .",
    "the admissible transitions ( connectivity of @xmath53 ) , and 2 .",
    "the edge and vertex weights of @xmath53    play a role in determining whether there exists an infinite walk @xmath15 that satisfies . indeed :    effect of ( a ) : :    consider @xmath95 with    @xmath96 ,    @xmath97    and    @xmath98 .    consequently , @xmath99 and    @xmath100 .",
    "let    @xmath101 . in this case , even    without the knowledge of the edge and vertex weights",
    ", we can conclude    that there exists no infinite walk on @xmath53 that satisfies    condition because the term in the denominator of    @xmath82 , i.e. , @xmath102 for    all walks on @xmath53 .",
    "effect of ( b ) : :    consider the given family of systems as in the above case .",
    "assume that    @xmath103 .",
    "from fact [ fact : key ]    and fact [ fact : muij ] , we have the following estimates :    @xmath104 , @xmath105 ,    @xmath106 and    @xmath107 .",
    "the term    @xmath108    is greater than the denominator    @xmath109 for all    walks on @xmath53 .",
    "consequently , condition is not satisfied .    in view of the above observations , given the underlying weighted digraph of the switched system , we arrive at the important and natural question :    1 .",
    "[ problem : aprime]_given a weighted digraph @xmath51 , does there exist an infinite walk @xmath15 on @xmath51 that satisfies ?",
    "if yes , can we provide a mechanism to detect / synthesize it ?",
    "_    in the language of switched systems , of course ,",
    "[ problem : aprime ] is : `` does there exist a switching signal @xmath24 satisfying ?",
    "if such a @xmath24 exists , then can we provide an algorithmic mechanism to detect / synthesize it ? ''",
    "[ r : infwalk ] it is important to clarify what we mean by algorithmic solutions to [ problem : aprime ] .",
    "we provide an algorithm that consists of ( i ) a finite walk @xmath110 of length @xmath111 , and ( ii ) an iterative process consisting of a mechanism requiring a bounded quantum of memory , to generate finite walks @xmath112 of length @xmath113 , @xmath114 , satisfying the condition that the final vertex of @xmath115 is identical to the initial vertex of @xmath116 for each @xmath117 .",
    "we build the infinite walk @xmath15 as the limit of @xmath118 , @xmath114 .",
    "suppose that for a weighted digraph @xmath53 there is a self - loop at a vertex @xmath88 .",
    "consider a walk @xmath15 on @xmath53 such that it begins at this vertex @xmath45 and keeps on traversing that self - loop repeatedly . in this case @xmath119",
    "by fact [ fact : muij ] and no vertex @xmath120 is visited .",
    "consequently , the infinite walk generated satisfies .",
    "given a weighted digraph @xmath53 , the above walk @xmath15 can be obtained from an algorithm that detects the above vertex @xmath88 .",
    "however , given a weighted digraph @xmath53 , detection of an infinite walk @xmath15 satisfying is not simple beyond the above trivial case .",
    "indeed , finding an infinite walk on @xmath53 that satisfies some prespecified condition involving the vertex and edge weights of @xmath53 is a computationally difficult problem .",
    "we define    [ d : contrawalk ] a walk @xmath15 on the weighted digraph @xmath51 as _ contractive _ if @xmath121    given a weighted digraph @xmath53 , we provide :    1 .   [",
    "solution : aprime ] we establish a sufficient condition for the existence of an infinite walk satisfying in terms of a closed contractive walk ( necessarily of finite length ) on @xmath53 .",
    "this settles [ problem : aprime ] .",
    "we propose algorithmic techniques for synthesis of the above closed walk . towards this",
    ", we derive a set of necessary and sufficient conditions in terms of a contractive _ circuit _ and a contractive _ cycle _ for the existence of a closed contractive walk on @xmath53 , and apply numerically tractable algorithms to detect / design this circuit and/or cycle on @xmath53 .    moving a step ahead from [ problem : aprime ] , and entailing a shift in paradigm , we pose :    1 .   [",
    "problem : cprime]_what class of weighted digraphs admits an infinite walk that satisfies ? _    at the level of abstractness that [ problem : cprime ] pertains to , there are two natural apparatuses to turn to : the first is the baire category theorem and its consequences , and the second is probability theory . considering the ensemble of switched systems as the sample space",
    ", we ask how likely is a switched system sampled from this ensemble to admit closed contractive switching signals , and to [ problem : cprime ] we provide :    1 .",
    "[ solution : cprime ] we propose a polynomial time algorithm that detects a _ cycle _ of a certain fixed maximal length on @xmath53 . under mild assumptions on the connectivity and the weights associated to the vertices and edges of @xmath53 we provide probabilistic guarantee that the above cycle is contractive .",
    "other perspectives and salient features of our algorithm have already been mentioned in the introduction .",
    "[ solution : aprime ] and [ solution : cprime ] are provided in the following two sections [ s : sola ] and [ s : solb ] , respectively .",
    "in this section we expose [ solution : aprime ] .",
    "since our solutions must be algorithmic ( see remark [ r : infwalk ] ) , we specialize to finitary objects directly in :    [ lem : closedwalk ] consider the underlying weighted digraph @xmath51 of the switched system .",
    "if there exists a closed contractive walk @xmath15 on @xmath51 , then the infinite walk obtained by repeating the closed walk @xmath15 satisfies .",
    "the task of algorithmic detection of a closed contractive walk on @xmath53 is computationally simpler under lemma [ lem : closedwalk ] since the length of the walk is finite .",
    "[ conv : weightconv ] the total number of times a closed walk @xmath15 visits a vertex @xmath55 is the same as the total number of times @xmath15 visits the outgoing edges of the vertex @xmath55 .",
    "consequently , for a vertex @xmath55 , @xmath77 can be replaced by @xmath122 .",
    "since we are concerned with an infinite walk constructed by repeating the closed contractive walk @xmath15 indefinitely many times , the above convention is no loss of generality .",
    "following convention [ conv : weightconv ] , the condition becomes @xmath123 the mechanism explained in remark [ r : infwalk ] shows that for a walk @xmath15 generated by concatenating the walks @xmath124 and @xmath125 satisfying the usual contractivity condition , we have @xmath126 .    however , algorithmic detection of a closed contractive walk on @xmath53 is also difficult due to the absence of a bound on the length of the closed walk @xmath15 .",
    "consequently , the length at which the algorithm that attempts to detect a closed contractive walk should terminate must be specified and its selection is a difficult task a priori . a natural alternative is to specialize the closed walk @xmath15 to a walk of bounded length , for example , a circuit or a cycle .",
    "our first main result provides necessary and sufficient conditions for the existence of a closed contractive walk on @xmath53 in terms of a contractive circuit and a contractive cycle :    [ t : mainres1 ] consider the underlying weighted digraph @xmath51 of the switched system as discussed in  [ s : prelims ] .",
    "the following are equivalent : +   + i ) @xmath51 admits a closed contractive walk , + ii ) @xmath51 admits a closed contractive circuit , + iii ) @xmath51 admits a closed contractive cycle .",
    "+   + consequently , the infinite walk obtained by repeating one of the above satisfies .",
    "see  [ s : proofs ] for a detailed proof of theorem [ t : mainres1 ] .    theorem [ t : mainres1 ] gives a set of necessary and sufficient conditions for the existence of a closed contractive walk on a given weighted digraph @xmath53 .",
    "we now seek algorithms that detect / design a contractive circuit or a contractive cycle on @xmath53 .",
    "this task is numerically simpler compared to detection / design of a closed contractive walk of some length that is not known a priori for obvious reasons . in the remainder of this section we address these two algorithmic detection / design issues .",
    "an algorithm that detects a contractive circuit on the given weighted digraph @xmath53 is discussed in ( * ? ? ?",
    "* theorem 2(b ) and ( c ) ) .",
    "here we improve upon the above algorithm to find a contractive circuit @xmath15 on @xmath53 that minimizes @xmath127 , if one such circuit @xmath15 exists .",
    "as regard to a contractive cycle , we demonstrate the applicability of the existing algorithms in our context .",
    "given a weighted digraph @xmath53 , our algorithm for detection / design of a contractive circuit on @xmath53 is motivated by the shortest path algorithm proposed in @xcite .",
    "[ prop : algo ] let the underlying weighted digraph @xmath51 of the switched system as defined in ",
    "[ s : prelims ] be given .",
    "step 1 : :    a contractive circuit @xmath15 on    @xmath51 that minimizes    @xmath127 is obtained from the solution to the    following feasibility problem in the variable    @xmath128 :    @xmath129 where @xmath130 is the node ( arc )    incidence matrix of    @xmath51.$ ] @xcite of    @xmath53 is defined by @xmath131 ] step 2 : :    from the solution to the feasibility problem , a contractive circuit    @xmath15 on @xmath51    that minimizes @xmath127 can be obtained by the    application of hierholzer s algorithm .",
    "\\a ) there are two steps to the algorithm in proposition [ prop : algo ] : in step 1 , we employ a feasibility problem to determine a contractive circuit @xmath15 on @xmath51 that minimizes @xmath127 , if @xmath51 admits such a circuit .",
    "the feasibility problem involves solving a linear program for the vector @xmath132 .",
    "even though is a bona fide linear program , ( * ? ? ?",
    "* corollary to theorem 13.3 ) guarantees that it has integer optimal solutions .",
    "in other words , the condition @xmath133 for all @xmath134 implies that each entry of the feasible solution vector @xmath132 is either @xmath135 or @xmath136 , corresponding to whether an edge is included in the circuit or not , respectively . by definition of a circuit ,",
    "the size of the vector @xmath132 is at most @xmath137 .",
    "if the feasibility problem has a solution , we obtain a subgraph on @xmath53 from the vector @xmath132 that admits a circuit satisfying condition .",
    "if the feasibility problem has a solution , we proceed to step 2 and apply hierholzer s algorithm to find such a circuit on @xmath53 .",
    "hierholzer s algorithm admits the above subgraph as input in step 2 .",
    "recall @xcite that given an eulerian graph @xmath138 , hierholzer s algorithm finds an eulerian circuit of @xmath138 .",
    "the applicability of this algorithm in our context is explained in detail in the proof of proposition [ prop : algo ] @xcite .",
    "+ b ) the condition @xmath139 in the feasibility problem corresponds a circuit , and this equation always has a trivial solution where vector @xmath132 has all entries equal to @xmath136 . the condition @xmath140 prevents the above trivial solution .",
    "[ r : algomod ] with respect to ( * ? ? ?",
    "* theorem 2(a ) and ( b ) ) , we have modified the `` objective function '' in above .",
    "this ensures that the solution to the feasibility problem ( if any ) corresponds to a contractive circuit on @xmath53 that minimizes @xmath127 .      given a weighted digraph @xmath53 ,",
    "the algorithmic detection / design of a contractive cycle is equivalent to finding what is commonly known as a negative cycle .",
    "indeed , a negative cycle is one for which the sum of the edge weights is less than zero , which is precisely condition .",
    "a large class of algorithms is available to achieve the above ; see e.g. , @xcite for detailed surveys .",
    "perhaps the most well - known one in this class is the bellman - ford - moore algorithm , which is a shortest path algorithm , and it detects and reports negative weight cycles that are reachable from a pre - specified source vertex @xcite . in our context , the bellman - ford - moore algorithm suffices insofar as the detection of a contractive cycle on @xmath53 is concerned ; further work is however required for constructing a negative cycle if such a cycle exists . beyond the bellman - ford - moore algorithm , a newer algorithm proposed in @xcite lists all elementary negative cycles on a given weighted digraph ; this particular algorithm jointly serves purposes of detection and design of negative cycles .",
    "[ r : circuitvscycle ] since we are interested in detecting / designing _ an _ infinite walk that satisfies , algorithmically finding either a contractive circuit or a contractive cycle and designing an infinite walk by repeating the above suffices .",
    "however , the question of whether to find a contractive circuit or a contractive cycle algorithmically based on the following aspect appears to be interesting : consider minimizing @xmath127 in the sense of maximally negative @xmath127 over all contractive circuits or cycles @xmath15 on a given weighted digraph @xmath53 .    * on the one hand , a contractive cycle is necessarily a contractive circuit . on the other hand , although a contractive circuit is not necessarily a contractive cycle , it necessarily contains at least one contractive cycle .. ] consequently , a contractive circuit @xmath15 on @xmath53 that minimizes @xmath127 may contain one or more contractive cycles . *",
    "the algorithm in proposition [ prop : algo ] detects a contractive circuit @xmath15 on @xmath53 that minimizes @xmath127 .",
    "if this circuit is only a contractive cycle , then the output of the above algorithm is a contractive cycle as well .",
    "* to obtain a cycle @xmath15 on @xmath53 that minimizes @xmath127 by the application of negative cycle detection / design algorithms , a two step mechanism is required : first , to list all elementary negative cycles on @xmath53 ( by applying the algorithm in @xcite ) and second , to find the most negative one from this list . * instead of applying the above mechanism to @xmath53",
    ", we may apply it to the subgraph of @xmath53 obtained from the feasibility problem in proposition [ prop : algo ] . since this subgraph admits a circuit @xmath15 that minimizes @xmath127",
    ", it necessarily admits the most negative cycle on @xmath53 .",
    "it is immediate that considering a subgraph of @xmath53 instead of @xmath53 reduces both time and space complexity associated to the search of the most negative cycle .",
    "we first propose the following algorithm for detection of cycles in @xmath28 ; it will be utilized in theorem [ t : mainres2 ] below to furnish certain genericity assertions ( see remark [ r : mainres2 ] ) .",
    "[ algo : cyclealgo ]    step 1 : :    set @xmath141 .",
    "+    pick @xmath142 uniformly at random .",
    "step 2 : :    if    @xmath143 , +    pick    @xmath144    uniformly at random .",
    "+    set @xmath145 .",
    "+    go to step 2 .",
    "+    else +    pick @xmath146 such that    @xmath147 and    @xmath148 is maximum .",
    "+    go to step 3 .",
    "step 3 : :    end .",
    "for example , let @xmath149 with @xmath150 and @xmath151 .",
    "let @xmath152 let @xmath153 .",
    "then @xmath154 is selected from @xmath155 .",
    "let @xmath156 .",
    "then @xmath157 is selected from @xmath158 .",
    "consequently , @xmath159 .",
    "now , @xmath160 . as a result , @xmath161 .",
    "so we obtain the walk @xmath162 , which contains the cycle @xmath163 .    in the remainder of this section",
    "we show that under mild connectivity and generic weight assumptions on the given weighted digraph @xmath53 , a cycle obtained from algorithm [ algo : cyclealgo ] satisfies with high probability .",
    "let @xmath164 be a monotone increasing function .",
    "[ d : niceconnwt ] a weighted digraph @xmath51 is said to be    * _ nicely connected _",
    "if @xmath165 for all @xmath55 ; * _ nicely weighted _ if the vertex and edge weights on @xmath53 satisfy the following conditions : * * there exist @xmath166 satisfying @xmath167 such that the vertex weights @xmath168 are independent and @xmath169 with @xmath170 = \\beta$ ] for all @xmath55 , and * * there exist constants @xmath171 and @xmath172 such that for every @xmath57 , the edge weight @xmath173 $ ] and @xmath174\\leq\\alpha$ ] .    [",
    "r : constancy of weight bounds ] the condition that the vertex and edge weights @xmath168 and @xmath175 are uniformly bounded if @xmath53 is nicely weighted is no loss of generality on account of the graph @xmath53 being finite . however , it is also possible to consider the case in which the bounds on the weights depend on the size of the graph @xmath53 , as explained in remark [ r : variable weight bounds ] below .",
    "we stick to the simpler case for ease of exposition .",
    "the following lemma guarantees the existence of a cycle in @xmath28 of length at least @xmath176 .",
    "[ lem : cyclelem ] if the given weighted digraph @xmath51 is nicely connected , then algorithm [ algo : cyclealgo ] detects a cycle @xmath15 on @xmath51 such that all vertices in @xmath15 are from @xmath28 and the length of @xmath15 is at least @xmath176 .",
    "see  [ s : proofs ] for a short proof of lemma [ lem : cyclelem ] .",
    "our final result is the following :    [ t : mainres2 ] consider the switched system and the underlying weighted digraph @xmath51 as described in ",
    "[ s : prelims ] .",
    "suppose that @xmath51 is nicely connected and nicely weighted .",
    "then a cycle of length at least @xmath176 on @xmath51 obtained from algorithm [ algo : cyclealgo ] is contractive with probability at least @xmath177 consequently , the infinite walk obtained by repeating the above cycle satisfies .",
    "we present a proof of theorem [ t : mainres2 ] in  [ s : proofs ] .",
    "[ r : mainres2 ] theorem [ t : mainres2 ] asserts that a cycle obtained via algorithm [ algo : cyclealgo ] is contractive with high probability provided @xmath178 is large .",
    "consequently , repeating such a cycle derived from algorithm [ algo : cyclealgo ] generates an infinite walk @xmath15 that , in view of lemma [ lem : closedwalk ] , satisfies .",
    "this in turn identifies a class of switched systems ( whose underlying weighted directed graph @xmath53 is nicely connected and nicely weighted ) that admits switching signals satisfying the conditions proposed in ( * ? ? ?",
    "* theorem 1 ) with overwhelming probability .",
    "[ r : variable weight bounds ] the primary engine leading to the estimate in theorem [ t : mainres2 ] is azuma s inequality .",
    "our assumption of a uniform bound for the weights due to @xmath53 being nicely weighted led to a uniform bound on the martingale increments @xmath179 in the proof of theorem [ t : mainres2 ] , and our estimate followed at once from azuma s inequality .",
    "a more general version of azuma s inequality may be employed in an identical fashion to cater to vertex- and edge - dependent weights , leading to a possibly sharper bound .",
    "the numerical value of the confidence with which a contractive cycle may be found , however , depends on the size of @xmath180 and the ability of the function @xmath181 in definition [ d : niceconnwt ] to dominate the accumulation of the weights along the martingale increments .",
    "[ r : algofeatures ] given the underlying weighted digraph @xmath53 of the switched system , the deterministic algorithms for detection / design of a contractive cycle , as discussed in ",
    "[ ss : algocycle ] , require the complete knowledge of all the vertex and edge weights of @xmath53 prior to their application .",
    "consequently , these are ill suited for large graphs where all the weights can not be stored in the memory at once . in contrast , algorithm [ algo : cyclealgo ] explores @xmath53 without prior knowledge of the vertex and edge weights and during this exploration designs a cycle , which is contractive with high probability .",
    "in particular , this lends an `` online '' flavour to our algorithm .",
    "consequantly , it is suited for a class of large weighted digraphs for which deterministic guarantees are difficult or impossible to give .",
    "in addition , consider the case when certain parameters of the subsystems in the given family ( and consequently the vertex and edge weights of @xmath53 ) evolve over time in a manner that is not completely known .",
    "a cycle obtained from algorithm [ algo : cyclealgo ] is contractive with high probability independent of this evolution as long as @xmath53 is nicely weighted .",
    "this example corresponds to our [ solution : aprime ] . based on our discussion regarding `` contractivity '' in  [ s : sola ] , we select the algorithm in proposition [ prop : algo ] to find a `` most '' contractive circuit .",
    "we consider the family of systems with @xmath182 , where @xmath183 for this family @xmath184 and @xmath185 .",
    "let all transitions among the systems in the given family be admissible .",
    "let it also be permissible for switching signals to dwell on systems @xmath186 and @xmath187 for two ( or more ) consecutive time steps .",
    "that is , @xmath188 we construct the node(arc ) incidence matrix @xmath130 as described in .",
    "such that @xmath45 has a self - loop , we associate an auxiliary vertex @xmath189 .",
    "the transitions @xmath45 to @xmath189 and @xmath189 to @xmath45 represent the self - loops .",
    "] we avoid presenting the matrix here for reasons of space .",
    "the elements of the column vector @xmath132 are associated with the entries of @xmath54 .    for the given family of systems",
    ", we obtain an estimate for the numbers @xmath93 and @xmath47 from fact [ fact : key ] and fact [ fact : muij ] , respectively . @xmath190 and associate @xmath91 and @xmath191 as vertex weights @xmath168 and edge weights @xmath192 of @xmath53 , respectively .    solving the feasibility problem in the context of this setting with the aid of matlab by employing the program yalmip @xcite and the solver sdpt3 @xcite",
    ", we obtain the following solution : @xmath193 with the corresponding @xmath194 .",
    "a circuit @xmath15 obtained from the vector @xmath132 with the aid of hierholzer s algorithm is : @xmath195 we consider the switching signal corresponding to the infinite walk obtained by repeating the above circuit @xmath15 and study @xmath196 for 100 different initial conditions chosen uniformly at random from the interval @xmath197^{2}$ ] .",
    "for 100 different initial conditions chosen uniformly at random from the interval @xmath197 $ ] . ]    this example corresponds to [ solution : cprime ] . consider a nicely connected and nicely weighted directed graph @xmath53 with    * @xmath198 , * @xmath199 , * @xmath200 for all @xmath55 , and * @xmath201 , @xmath202 , @xmath203 and @xmath204 .",
    "we extract and fix a cycle @xmath15 obtained from algorithm [ algo : cyclealgo ] on @xmath205 .",
    "the vertex and edge weights on @xmath15 are sampled uniformly at random @xmath206 times from the intervals as stipulated in definition [ d : niceconnwt ] .",
    "we calculate @xmath207 , as defined in empirically for @xmath208 being the length of the cycle @xmath15 .",
    "the above experiment is repeated for cycles of different length @xmath208 obtained from algorithm [ algo : cyclealgo ] with uniformly randomly selected initial vertex .",
    "we plot the empirical probability of @xmath209 vs length @xmath208 of the cycle in figure [ fig : plot ] .     with @xmath210 . ]",
    "observe that the detection of a contractive cycle from algorithm [ algo : cyclealgo ] does not require a priori knowledge of the vertex and edge weights of @xmath53 .",
    "it is evident from this example as we first fix a cycle @xmath15 and then select weights from a specified interval .",
    "this is not the case with deterministic negative cycle detection algorithms , which require complete knowledge of the vertex and edge weights of @xmath53 prior to their application .",
    "in addition , the weights are sampled uniformly at random 1000 times and we find high empirical probability for @xmath209 .",
    "this highlights the feature that even if the systems in the given family are prone to evolve over time , our algorithm provides uniform probabilistic guarantees .",
    "in this article we discussed several methods to algorithmically synthesize members of the class of stabilizing switching signals proposed in @xcite .",
    "a weighted digraph was associated to a switched system and the switching signal is expressed as an infinite walk on this weighted digraph in a natural way . in this setting we proposed a sufficient condition for the existence of an infinite walk whose corresponding switching signal satisfies the conditions in ( * ? ? ?",
    "* theorem 1 ) , and discussed algorithms for the synthesis of the above infinite walk .",
    "thereafter we tackled the question of how likely is it for a `` generic '' switched system to admit a stabilizing switching signal , and we identified such a class of switched systems in terms of connectivity and vertex and edge weights of the underlying weighted digraph of the switched system .",
    "necessary conditions for the existence of the above infinite walk is currently under investigation and will be reported elsewhere .",
    "* proof of theorem [ t : mainres1 ] * : i ) @xmath211 ii ) assume that the given weighted digraph @xmath53 admits a closed contractive walk @xmath66 of length @xmath69 , but does not admit a contractive circuit . by assumption ,",
    "@xmath15 is not a circuit .",
    "we claim that @xmath15 can be recursively decomposed into circuits .",
    "+ suppose that @xmath15 has @xmath208 edges , @xmath212 , which appear more than once in @xmath15 .",
    "+ _ basis step _ : pick any one of the edges , say @xmath213 , that appears more than once in @xmath15 .",
    "obtain @xmath124 and @xmath125 such that @xmath124 is the subwalk generated by concatenating the following :    * @xmath214 , i.e. , the walk from the beginning of @xmath15 till the _ first _ instance of @xmath213 in @xmath15 , and * @xmath215 , i.e. , the walk beginning after the _ last _ instance of @xmath213 in @xmath15 till the end of @xmath15 ;    and @xmath216 is the subwalk generated by removing @xmath124 from @xmath15 .",
    "clearly , @xmath124 is a closed walk with at most @xmath217 edges , which appear more than once , and @xmath125 is a closed walk with at most @xmath208 edges , that appear more than once . in case @xmath218",
    ", @xmath124 is a circuit .",
    "if in addition @xmath213 appears exactly twice , @xmath125 is also a circuit .",
    "since @xmath15 satisfies @xmath219 , one of the following three conditions holds : i. @xmath220 , ii .",
    "@xmath221 , iii . both @xmath222 and @xmath221 .",
    "+ _ recursive step _ : in case one of the first two conditions holds , we select the subwalk @xmath223 that satisfies @xmath224 . in case",
    "the last condition holds , we select the subwalk @xmath223 with fewer number of edges , that appear more than once .",
    "if the selected @xmath223 is a circuit , we stop ; else we generate @xmath225 and @xmath226 by the same procedure explained in basis step and continue till we obtain @xmath227 , @xmath228 as a circuit .",
    "armed with the above claim , consider the case when a closed contractive walk @xmath15 that satisfies @xmath219 is decomposed into @xmath229 circuits  @xmath230 . now , since @xmath219 , at least one of the @xmath223 s , @xmath231 , satisfies @xmath224 .",
    "a circuit @xmath223 satisfying @xmath224 is the one that we are looking for .",
    "it contradicts our assumption that there is no circuit on @xmath53 that is contractive .",
    "\\ii ) @xmath211 iii ) assume that there is a contractive circuit @xmath66 of length @xmath69 on the given weighted digraph @xmath53 but no contractive cycle .",
    "by assumption , @xmath15 is not a cycle .",
    "we claim that @xmath15 can be recursively decomposed into cycles .",
    "+ _ basis step _ : .",
    "suppose @xmath63 appears @xmath208 times other than at the first and last positions of @xmath15 .",
    "if @xmath232 , apply step 2 on @xmath15 ; else decompose @xmath15 into subwalks @xmath233 in the following fashion :    * @xmath124 is the subwalk from the beginning of @xmath15 till the first repeated instance of @xmath63 , * @xmath125 is the subwalk beginning from the first repeated instance of @xmath63 till the second repeated instance of @xmath63 , + @xmath234 * @xmath235 is the subwalk beginning from the @xmath208th repeated instance of @xmath63 till the end of @xmath15 .",
    "clearly , each of the above subwalks is a circuit .",
    "since @xmath15 satisfies @xmath219 , there is at least one @xmath44 , @xmath236 such that @xmath224 .",
    "consider the @xmath223 from above that satisfies @xmath224 . in case",
    "there are more than one such @xmath223 s , we select the one with the least number of vertices that appear more than once .",
    "if the selected @xmath223 is a cycle , we stop ; else we proceed to step 2 .",
    "+ . pick a vertex @xmath67 , @xmath237 that appears more than once in @xmath223 .",
    "consider the subwalks    * @xmath225 obtained by concatenating @xmath238 + @xmath239 ( beginning from the initial vertex of @xmath223 and ending at the first instance of @xmath67 ) , and @xmath240 ( beginning from the last instance of @xmath67 and ending at the final vertex of @xmath223 ) ; * @xmath226 beginning from the first instance of @xmath67 and ending at the last instance of @xmath67 .",
    "since @xmath223 satisfies @xmath224 , one of the following is true : i. @xmath241 , ii .",
    "@xmath242 , iii . both @xmath243 and @xmath244 .",
    "+ _ recursive step _ : in case i. or ii",
    ". holds , we select the subwalk @xmath227 , @xmath228 that satisfies @xmath245 . in case of the last one , we select the subwalk @xmath227 with less number of vertices , which appear more than once .",
    "if the selected @xmath227 is a cycle , we stop ; else we generate @xmath246 and @xmath247 by the same procedure explained in step 2 ( basis step ) and continue till we obtain a cycle .",
    "armed with the above claim , consider the case when a closed contractive circuit @xmath15 satisfies @xmath219 is decomposed into @xmath229 cycles  @xmath230 .",
    "now , since @xmath219 , at least one of the @xmath223 s , @xmath231 satisfies @xmath224 . a cycle @xmath223 satisfying @xmath248 is the one that we are looking for .",
    "it contradicts our assumption that there is no cycle on @xmath53 that is contractive .",
    "\\iii ) @xmath211 ii ) a contractive cycle @xmath15 is a contractive circuit . if not , then there is at least one edge in @xmath15 that is repeated .",
    "but then the corresponding vertices are also repeated , which contradicts the definition of a cycle .",
    "* proof of lemma [ lem : cyclelem ] * : let @xmath250 + @xmath251 be a walk obtained from algorithm [ algo : cyclealgo ] .",
    "consider the sub - walk @xmath252 @xmath253 which is a cycle by construction . by of algorithm",
    "[ algo : cyclealgo ] all the vertices of @xmath15 are in @xmath28 . we claim that @xmath254 . assume , if possible , @xmath255 . but @xmath256 by hypothesis , @xmath257 , which implies that @xmath258 by choice of @xmath259 in algorithm [ algo : cyclealgo ] , @xmath260 from and , it follows that @xmath261 . but",
    "@xmath262 , which implies that + @xmath263 , and it is a contradiction .",
    "consequently , @xmath264.@xmath249    * proof of theorem [ t : mainres2 ] * : since the given weighted digraph @xmath51 is nicely connected , by lemma [ lem : cyclelem ] there exists cycle on @xmath51 with all vertices of the cycle being in @xmath28 and the length of the cycle is at least @xmath176 .",
    "such a cycle can be detected by algorithm [ algo : cyclealgo ] .",
    "consider a cycle @xmath265 + @xmath266 of length exactly @xmath267 ( say ) .",
    "since @xmath268 , can be written as : @xmath269 .",
    "let @xmath270 define the filtration @xmath271 by @xmath272 since @xmath53 is nicely weighted , @xmath273 & = x_{k-1 } + { \\mathsf{e}}^{\\mathfrak{f}_{k-1}}[w(j_{k-1},j_{k } ) - w(j_{k})]\\nonumber\\\\                  & = x_{k-1 } + \\alpha - \\beta\\nonumber\\\\                  & < x_{k-1}\\:\\:\\text{since $ \\alpha < \\beta$ by definition \\ref{d : niceconnwt}.}\\label{e : secpf1 }              \\end{aligned}\\ ] ] let @xmath274 denote the a.s .",
    "unique doob decomposition ( * ? ? ?",
    "* theorem 5.2.10 ) of the process @xmath275 .",
    "in other words , with @xmath276 and @xmath277 , we have @xmath278\\bigr),\\\\                  & a_{m } { \\coloneqq}\\sum_{k=1}^{m}\\bigl({\\mathsf{e}}^{\\mathfrak{f}_{k-1}}[x_{k } ] - x_{k-1}\\bigr ) ,              \\end{aligned }",
    "\\right.\\qquad m = 1,\\cdots , n,\\ ] ] the inequality shows that @xmath279 is an @xmath280 strict supermartingale ; the compensator process @xmath281 is , therefore , strictly decreasing .",
    "the definition of @xmath282 shows that @xmath283 , and from we get @xmath284 . since @xmath285",
    "we apply azuma s inequality ( * ? ? ?",
    "* theorem 7.2.1 ) to the zero - mean martingale process @xmath286 to get @xmath287 which gives the estimate in the theorem .",
    "the final assertion follows at once from lemma [ lem : closedwalk].@xmath249        n.  alon and j.  h. spencer . .",
    "wiley - interscience series in discrete mathematics and optimization .",
    "john wiley & sons , inc . ,",
    "hoboken , nj , third edition , 2008 . with an appendix on the life and work of paul erds .",
    "a.  kundu and d.  chatterjee .",
    "stabilizing discrete - time switched linear systems .",
    "proceedings of the 17th acm international conference on hybrid systems : computation & control , 2014 , berlin , germany , pp .",
    "11 - 20 .",
    "s.  mitra , n.  lynch , and d.  liberzon .",
    "verifying average dwell time by solving optimization problems . in _",
    "hybrid systems : computation and control _ , volume 3927 of _ lecture notes in comput .",
    "_ , pages 476490 .",
    "springer , berlin , 2006 .",
    "k.  c. toh , m.  j. todd , and r.  h. ttnc . on the implementation and usage of sdpt3a matlab software package for semidefinite - quadratic - linear programming , version 4.0 . in _",
    "handbook on semidefinite , conic and polynomial optimization _",
    ", volume 166 of _ internat .",
    "management sci .",
    "_ , pages 715754 .",
    "springer , new york , 2012 ."
  ],
  "abstract_text": [
    "<S> in this article we study algorithmic synthesis of the class of stabilizing switching signals for discrete - time switched linear systems proposed in @xcite . </S>",
    "<S> a weighted digraph is associated in a natural way to a switched system , and the switching signal is expressed as an infinite walk on this weighted digraph . </S>",
    "<S> we employ graph - theoretic tools and discuss different algorithms for designing walks whose corresponding switching signals satisfy the stabilizing switching conditions proposed in @xcite . </S>",
    "<S> we also address the issue of how likely / generic it is for a family of systems to admit stabilizing switching signals , and under mild assumptions give sufficient conditions for the same . </S>",
    "<S> our solutions have both deterministic and probabilistic flavours .    ,    ,    switched systems ; digraph ; azuma s inequality ; algorithmic synthesis . </S>"
  ]
}