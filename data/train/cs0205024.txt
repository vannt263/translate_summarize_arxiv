{
  "article_text": [
    "it s well known that in most cases huffman encoding is not the optimal encoding of a stream of characters of an alphabet associatd with a probabilistic model @xcite .",
    "although a huffman encoded sequence of data can look like `` random '' , most likely it is not a real noise- like the one can get from ` /dev",
    "/ random ` in some unix(-like ) systems . in the present article",
    "we give a `` proof of concept '' implementation of a statistical model capable of detecting the deviation of the data being encoded from the notion of `` real noise '' .",
    "we break the input data into consequtive blocks @xmath0 of size @xmath1 bits each .",
    "each block @xmath2 is being encoded in the following way :    1 .",
    "count the number of 1 s @xmath3 in @xmath2 .",
    "2 .   let @xmath4 , @xmath5 .",
    "the probability to encounter a 0 in the block is @xmath6 , and for 1 is @xmath7 3 .   encode a bit of the block with the calculated probabilities . depending on its value",
    "we decrease either @xmath8 or @xmath9 .",
    "4 .   proceed with all the bits of the block .",
    "note : obviously the last bit wo nt need to be encoded , because we know its value with probability 1 .",
    "anyway , a decently implemented arithmetic encoder should not encode anything when given probability 1 .",
    "the sequence @xmath3 is also a data stream , which needs to be encoded for obvious reasons .",
    "the most reasonable scheme for its encoding is 0-order adaptive statistical model + arithmetic encoding . for `` real noise '' @xmath3",
    "is supposed to have a binomial distribution : @xmath10 and `` slightly compressible data '' ( `` not - so - real noise '' ) could be expected to have some deviation from this distribution .",
    "we make a plausible conjecture that data whose @xmath3 is deviating from , is compressible .",
    "an example of such deviation is shown in the figure .",
    "we provide the c++ source code for the implementation of the algorithm described above . the remaining source modules- implementation of arithmetic encoding , front end , error handling etc . , necessary to compile a working program , are not included , but easy to implement @xcite .",
    "static long double facto(int k ) {    long double res ;    res=1 ;    while(k>1)res*=k-- ;    return res ; } class chistomodel { public :    int n ;    int * tab ;    float pro(int k )    {    return facto(n)/(facto(k)*facto(n - k)*2.0 ) ;    }    ~chistomodel ( ) {    if(tab )      delete tab ;    }    chistomodel(){tab = null ; }    chistomodel(int n )    { tab = null;init(n ) ; }    void init(int n ) {    } } ;    # if 1 # define b_size 32 # else # define b_size 32 # endif # define bitsinblock ( b_size*8 ) class ccmodel { public :    int tab[bitsinblock+2 ] ;    unsigned short scale(){return tab[bitsinblock+1 ] ; }    ccmodel(){init ( ) ; }    void init ( )    {    int i ;    for(i=0;i<=bitsinblock+1;i++ )      tab[i]=i ;    }    void update(int c )    {    int i ;    if(tab[bitsinblock+1]>=maxscale )      rescale ( ) ;    for(i = c+1;i<=bitsinblock+1;i++ )      tab[i]++ ;    }    void rescale ( )    {    unsigned weights[bitsinblock+1 ] ;    int i ;    for(i=0;i <",
    "bitsinblock+1;i++ )      {      weights[i]=(tab[i+1]-tab[i])>>1 ;      if(!weights[i ] )        weights[i]=1 ;      }    for(i=0;i <",
    "bitsinblock+1;i++ )      tab[i+1]=tab[i]+weights[i ] ;    }    void chartosymb(int c , csymbol*s )    {    s->low_count = tab[c ] ;    s->high_count = tab[c+1 ] ;    s->scale = tab[bitsinblock+1 ] ;    }    int counttochar(short int count , csymbol*s )    {    int l , h , m ;    l=0 ;    h = bitsinblock+1 ;    while(h - l>1 )      {      m=(h+l)>>1 ;      if(tab[m]<=count )        l = m ;      else        h = m ;      }    s->low_count = tab[l ] ;    s->high_count = tab[l+1 ] ;    s->scale = tab[bitsinblock+1 ] ;    return l ;    } } ; extern int bittable [ ] ; unsigned char block[b_size ] ; int br ; ccmodel countmodel ; void decode_block(carithmeticdecoder&ari ) {    int s , count ;    int bit1cnt , bit0cnt ;    unsigned mask ;    csymbol symb ;    count = ari.get_current_count(countmodel.scale ( ) ) ;    bit1cnt = countmodel.counttochar(count,&symb ) ;    ari.remove_symbol_from_stream(symb.low_count ,                  symb.high_count ,                  symb.scale ) ;    bit0cnt = br*8-bit1cnt ;    countmodel.update(bit1cnt ) ;    for(s=0;s < br;s++ )    {      block[s]=0 ;      for(mask=0x80;mask;mask>>=1 )      {        count = ari.get_current_count(bit0cnt+bit1cnt ) ;        if(count <",
    "bit0cnt )        {          ari.remove_symbol_from_stream(0 ,                        bit0cnt ,                        bit0cnt+bit1cnt ) ;          bit0cnt-- ;        }        else        {          block[s]|=mask ;          ari.remove_symbol_from_stream(bit0cnt ,                        bit0cnt+bit1cnt ,                        bit0cnt+bit1cnt ) ;          bit1cnt-- ;        }      }    } } void encode_block(carithmeticencoder&ari ) {    int i ;    int bit1cnt=0,bit0cnt ;    int mask ;    csymbol symb ;    for(i=0;i <",
    "br;i++ )    bit1cnt+=bittable[block[i ] ] ;    bit0cnt = br*8-bit1cnt ; # if 1 # if 1    fprintf(stdout,\"%d\\n\",bit1cnt ) ; # else    fputc(bit1cnt , stdout ) ; # endif # endif #",
    "if 0    if(bit1cnt>255 )    fprintf(stderr,\"$%d\\n\",bit1cnt ) ; # endif    countmodel.chartosymb(bit1cnt,&symb ) ;    ari.encode_symbol(symb.low_count ,            symb.high_count ,            symb.scale ) ;    countmodel.update(bit1cnt ) ;    for(i=0;i < br;i++ )    {      for(mask=0x80;mask;mask>>=1 )      if(block[i]&mask )        {        symb.low_count=bit0cnt ;        symb.high_count=bit0cnt+bit1cnt ;        symb.scale=bit0cnt+bit1cnt ;        ari.encode_symbol(symb.low_count ,                  symb.high_count ,                  symb.scale ) ;        bit1cnt-- ;        }      else        {        symb.low_count=0 ;        symb.high_count=bit0cnt ;        symb.scale=bit0cnt+bit1cnt ;        ari.encode_symbol(symb.low_count ,                  symb.high_count ,                  symb.scale ) ;        bit0cnt-- ;        }    } } void do_compress ( ) {    long length , l ;    coutbitstream outstr ;    carithmeticencoder ari ;    l = length = filelen(infile ) ;    fwrite(&length , sizeof(length),1,outfile ) ;    outstr.init(outfile ) ;    ari.init(&outstr ) ;    while(1 )    {      br = fread(block,1,b_size , infile ) ;      l-=br ;      encode_block(ari ) ;      if((br <",
    "b_size)||(l<1 ) )      break ;    }    ari.flush ( ) ;    outstr.flush ( ) ; } void do_decompress ( ) {    long length , l ;    cinbitstream instr ;    carithmeticdecoder ari ;    csymbol symb ;    fread(&length , sizeof(length),1,infile ) ;    l = length ;    instr.init(infile ) ;    ari.init(&instr ) ;    while(l>0 )    {      br = l < b_size?l : b_size ;      l-=br ;      decode_block(ari ) ;      fwrite(block,1,br , outfile ) ;    } }    int bittable[]= { 0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3 , 4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4 , 4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4 , 5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5 , 4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3 , 4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5 , 5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8 } ; ...."
  ],
  "abstract_text": [
    "<S> we give an implementation of a statistical model , which can be successfully applied for compressing of a sequence of binary digits with behavior close to random .    * a ( non)static 0-order statistical model + and its implementation for compressing virtually uncompressible data *    evgeniy vitchev   +   + department of physics and astronomy , rutgers university + piscataway , nj 08855 - 0849 , usa </S>"
  ]
}