{
  "article_text": [
    "the construction of higher order discretization schemes of one - step type for the numerical solution of evolution equations is typically based on the setup and solution of a large system of polynomial equations for a number of unknown coefficients .",
    "classical examples are runge - kutta methods , and their various modifications , see e.g.  @xcite .",
    "to design particular schemes , we need to understand    * how to generate a system of algebraic equations for the coefficients sought , * how to solve the resulting system of polynomial equations .    here , we focus on ( i ) which depends on the particular class of methods one is interested in .",
    "we consider _ splitting methods , _ which are based on the idea of approximating the exact flow of an evolution equation by compositions based on ( usually two ) separate subflows which are easier to evaluate .",
    "computer algebra is an indispensable tool for solving such a problem , and there are different algorithmic approaches . in general",
    "there is a tradeoff between ` manual ' a priori analysis and machine driven automatization .    for splitting methods ,",
    "a well - known approach is based on recursive application of the baker - campbell - hausdorff ( bch ) formula , see  @xcite . instead , we follow another approach based on taylor expansion and a theoretical result concerning the structure of the leading term in this expansion .",
    "this has the advantage that explicit knowledge of the bch - coefficients is not required .",
    "moreover , our approach adapts easily to splitting into more than two parts , and even to pairs of splitting schemes akin to runge - kutta methods .",
    "topic ( ii ) is not discussed in this paper .",
    "details concerning the theoretical background and a discussion concerning concrete results and optimized schemes obtained are given in  @xcite , and a collection of optimized schemes can be found at  @xcite .",
    "we note that a related approach has recently also been considered in  @xcite .      in many applications ,",
    "the right hand side @xmath0 of an evolution equation @xmath1 splits up in a natural way into two terms @xmath2 and @xmath3 , where the separate integration of the subproblems @xmath4 is much easier to accomplish than for the original problem .",
    "[ exa : lie - trotter ] the solution of a linear ode system with constant coefficients , @xmath5 is given by @xmath6 the simplest splitting approximation ( ` lie - trotter ' ) , starting at some initial value @xmath7 and applied with a time step of length @xmath8 , is given by @xmath9 this is not exact ( unless @xmath10 ) , but it satisfies @xmath11 and the error of this approximation depends on behavior of the commutator @xmath12 = ab - ba $ ] .",
    "a general splitting method takes steps of the form we denote the flow associated with the equation @xmath13 , and @xmath14 are defined analogously . ]",
    "[ ab - scheme ] @xmath15 with @xmath16    where the ( real or complex ) coefficients @xmath17 have to be found such that a certain desired order of approximation for @xmath18 is obtained .    the local error of a splitting step is denoted by @xmath19    for our present purpose of finding asymptotic order conditions it is sufficient to consider the case of a linear system , @xmath20 with linear operators @xmath21 and  @xmath22 .",
    "we denote @xmath23 then ,    [ ab - scheme - linear ] @xmath24 with @xmath25    for the linear case the local error   is of the form @xmath26 with the linear operator @xmath27 .",
    "commutators of the involved operators play a central role . for formal consistency ,",
    "we call @xmath21 and @xmath22 the ` commutators of degree 1 '",
    ". there is ( up to sign ) one non - vanishing and @xmath22 ) . ]",
    "commutator of degree  2 , @xmath28 : = a\\,b - b\\,a,\\ ] ] and there are two non - vanishing commutators of degree  3 , @xmath29 = a\\,[a , b ] - [ a , b]\\,a , \\quad [ [ a , b],b ] = [ a , b]\\,b - b\\,[a , b],\\ ] ] and so on ; see section  [ subsec : locerr ] for commutators of higher degrees .",
    "consider the taylor expansion , about @xmath30 , of the local error operator @xmath31 of a consistent one - step method ( satisfying the basic consistency condition @xmath32 ) , @xmath33 the method is of asymptotic order @xmath34 iff @xmath35 for @xmath18 ; thus the conditions for order @xmath36 are given by @xmath37 the formulas in   need to be presented in a more explicit form , involving the operators @xmath38 and @xmath39 .",
    "for a splitting method  , a calculation based on the leibniz formula for higher derivatives shows and @xmath22 commute , i.e. , @xmath10 , then all these expressions vanish . ]",
    "( see  @xcite ) @xmath40 with @xmath41 .",
    "[ [ representation - of - in - maple . ] ] representation of   in maple .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + +    the non - commuting operators @xmath21 and @xmath22 are represented by symbolic variables a and b , which can be declared to be non - commutative making use of the corresponding feature implemented in the package physics .",
    "now it is straightforward to generate the sum  , with unspecified coefficients @xmath17 , using standard combinatorial tools ; for details see section  [ sec : impl ] .",
    "formally , the multinomial sums in the expressions   are multivariate homogeneous polynomials of total degree @xmath42 in the variables @xmath43 , and the coefficients of these polynomials are power products of total degree @xmath42 composed of powers of the non - commutative symbols  @xmath21 and  @xmath22 .",
    "[ exa : s = p=2 ] for @xmath44 we obtain @xmath45 { \\frac{{{\\rm d}}^{2}}{{{\\rm d}}h^{2}}}\\,{\\mathcal{l}}(h)\\,\\big|_{h=0 } & = ( ( a_1+a_2)^2)\\,a^2   \\label { oc - s=2 - 2 }                     + { } { ( 2\\,a_2\\,b_1)}\\,a\\,b \\\\                  & \\quad { } + ( 2\\,a_1\\,b_1 + 2\\,a_1\\,b_2 + 2\\,a_2\\,b_2)\\,b\\,a                     + ( ( b_1+b_2)^2)\\,b^2 \\\\[\\jot ]                   & \\quad \\,-\\,(a^2 + a\\,b + b\\,a + b^2).\\end{aligned}\\ ] ] the consistency condition for order @xmath46 reads @xmath47 , which is equivalent to @xmath48 and @xmath49 .    at first sight , for order @xmath50 we need 4 , or ( at second sight ) 2  additional equations to be satisfied , such that @xmath51 .",
    "however , assuming that the conditions for order @xmath46 are satisfied , the second derivative @xmath52 simplifies to the commutator expression @xmath53,\\ ] ] giving the single additional condition @xmath54 for order @xmath50 .",
    "assuming now that @xmath55 and @xmath56 are chosen such that all conditions for @xmath50 are satisfied , the third derivative @xmath57 , which now represents the leading term of the local error , simplifies to a linear combination of the commutators @xmath58 $ ] and @xmath59,b ] $ ] , of degree  3 , namely @xmath60                                 + { } { ( 3\\,a_2\\,b_1 ^ 2 - 1)}\\,[[a , b],b ] . \\qquad\\qed\\ ] ]    the classical second - order strang splitting method corresponds to the choice @xmath61 , or @xmath62 .    the observation from this simple example generalizes as follows :    [ pro : leading - lie ] the leading term @xmath63 of the taylor expansion of the local error @xmath31 of a splitting method of order @xmath34 is a lie element , i.e. , it is a linear combination of commutators of degree @xmath64 .",
    "see  @xcite .",
    "[ exa : higher - comm ] assume that the coefficients @xmath43 have been found such that the associated splitting scheme is of order @xmath65 ( this necessitates @xmath66 ) .",
    "this means that @xmath67 and from proposition  [ pro : leading - lie ] we know that @xmath68 ] + \\gamma_2\\,[a,[[a , b],b ] ] + \\gamma_3\\,[[[[a , b],b],b]\\ ] ] holds , with certain coefficients @xmath69 depending on the @xmath70 and @xmath71 .",
    "here we have made use of the fact that there are three independent commutators of degree @xmath72 in @xmath38 and @xmath39 .",
    "targeting for higher - order methods one needs to know a _",
    "basis of commutators _ up to a certain degree .",
    "the answer to this question is known , and a full set of independent commutators of degree @xmath42 can be represented by a set of words of length @xmath42 over the alphabet @xmath73 .",
    "a prominent example is the set of _ lyndon - shirshov words _ ( see  @xcite ) displayed in table  [ tab : lyndon - ab ] . a combinatorial algorithm due to duval  @xcite",
    "can be used to generate this table .    here , for instance , the word aabbb represents the commutator @xmath74,b],b ] ] = \\\\ & \\quad a^2 b^3 - 3abab^2 + 3ab^2ab - 2ab^3a + 3bab^2a - 3b^2aba + b^3a^2,\\end{aligned}\\ ] ] with leading power product @xmath75 ( w.r.t .",
    "lexicographical order ) .",
    ".@xmath76 is the number of words of length  @xmath42 .",
    "[ tab : lyndon - ab ] [ cols=\">,>,<\",options=\"header \" , ]      on the basis of proposition  [ pro : leading - lie ] , and with a table of lyndon - shirshov words available , we can build up a set of conditions for order @xmath36 for a splitting method with @xmath77 stages in the following way ( recall the notation @xmath78 , @xmath79 ) :    _ for @xmath80 : _    * generate the symbolic expressions   in the indeterminate coefficients @xmath17 and the non - commutative variables a and b. * extract the coefficients of the power products ( of degree @xmath42 ) represented by all lyndon - shirshov words of length @xmath42 , resulting in a set of @xmath76 polynomials @xmath81 of degree @xmath42 in the coefficients @xmath70 and @xmath71 .    the resulting set of @xmath82 multivariate polynomial equations @xmath83 represents the desired conditions for order @xmath34 .",
    "we call this procedure _ implicit recursive elimination , _ because the equations generated in this way are correct in an ` a  posteriori ' sense ( cf",
    ".  example  [ exa : s = p=2 ] ) :    1 .   for @xmath84 , the basic consistency equations @xmath85 are obtained .",
    "assume _ that   is satisfied .",
    "then , due to proposition  [ pro : leading - lie ] , the additional ( quadratic ) equation ( note that @xmath86 ) @xmath87 represents one additional condition for a scheme of order @xmath88 .",
    "_ assume _ that   and   are satisfied .",
    "then , due to proposition  [ pro : leading - lie ] , the additional ( cubic ) equations ( note that @xmath89 ) @xmath90 represent two additional conditions for a scheme of order @xmath91 .",
    "the process is continued in the same manner .",
    "if we ( later ) find a solution @xmath92 of the resulting system @xmath93 of multivariate polynomial equations , this means that @xmath94 and so on . by induction",
    "we conclude that the whole procedure is correct .",
    "see  @xcite for a more detailed exposition of this argument .",
    "in addition , it makes sense to generate the additional conditions for order @xmath64 .",
    "even if we do not solve for these conditions , they represent the leading term of the local error , and this can be used to search for optimized solutions for order @xmath34 , where the coefficients in @xmath63 become minimal in size .",
    "in our maple code , a table of lyndon - shirshov words up to a fixed length ( corresponding to the maximal order aimed for ; see table  [ tab : lyndon - ab ] ) is included as static data .",
    "the procedure order_conditions displayed below generates a set of order conditions using the algorithm described in section  [ subsec : ire ] .",
    "* fist of all , we activate the package physics and declare the symbols a and b as non - commutative . * for organizing the multinomial expansion according to   we",
    "use standard functions from the packages combinat and combstruct . *",
    "the number of terms during each stage rapidly increases as more stages are to be computed .",
    "therefore we have implemented a parallel version based on the package grid .",
    "parallelization is taken into account as follows : * * on a multi - core processor , all threads execute the same code .",
    "each thread identifies itself via a call to mynode ( ) , and this is used to control execution .",
    "communication between the threads is realized via message passing . * * thread  0 is the master thread controlling the overall execution . * * for @xmath80 : * * * each of the working threads generates symbolic expressions of the form ( recall @xmath95 , @xmath96 ) @xmath97 appearing in the sum  . here",
    "the work is equidistributed over the threads , i.e. , each of them generates a subset of @xmath98 in parallel . *",
    "* * for each of these expressions @xmath99 , the coefficients of all lyndon - shirshov monomials of degree @xmath42 are computed , and the according subsets of coefficients are summed up in parallel . * * * finally , the master thread 0 sums up the results received from all the working threads .",
    "this results in the set of multivariate polynomials representing the order conditions at level  @xmath42 . *",
    "the maple code displayed below is , to some extent , to be read as pseudo - code . for simplicity of presentation",
    "we have ignored some technicalities , e.g. , concerning the proper indexing of combinatorial tupels , etc .",
    "the original , working code is available from the authors .    ....",
    "> with(combinat ) >",
    "with(combstruct ) >",
    "with(grid ) > with(physics ) >   setup(noncommutativeprefix={a , b } )    > order_conditions : = proc ( )    global p , s , oc ,     # i / o parameters via global variables           lyndon      # assume that table of lyndon monomials is available    this_thread : = mynode ( )    # each thread identifies itself    max_threads : = numnodes ( ) # number of available threads    for j from 1 to s do        a_j[j ] : = a[j]*a        b_j[j ] : = b[j]*b        term[-1][j ] : = 1    end do    oc=[0$p ]    for q from 1 to p do      if this_thread>0 then   # working threads start computing                             # master thread 0 is waiting         mn : = allstructs(composition(q+2),size=2 )         for j from 1 to s do             term[q-1][j ] : = 0             for mn from 1 to nops(mn ) do                 term[q-1][j ] : =                   term[q-1][j ] +                     multinomial(q , mn[mn])*b_j[j]^mn[mn][2]*a_j[j]^mn[mn][1 ]             end do         end do         k : = iterstructs(composition(q+s),size = s )         oc_q_this_thread : = [ 0$nops(lyndon[q ] ) ]         while not finished(k ) do # generate expansion ( 7 ) term by term           ms : = nextstruct(k )           if get_active(this_thread ) then # get_active :                                           #    auxiliary boolean function                                           #    for equidistributing workload              pi_k : = 1              for j from s to 1 by -1 do                  pi_k : = pi_k*term[ms[j]-1][j ]              end do              pi_k : = multinomial(q , ms)*expand(pi_k )              oc_q_this_thread : = # compare coefficients of lyndon monomials                oc_q_this_thread +                  [ seq(coeff(pi_k , lyndon[q][l]),l=1 .. nops(lyndon[q ] ) ) ]           end if         end do         send(0,oc_q_this_thread ) # send partial sum to master thread      else # master thread 0 receives and sums up           #    partial results from working threads         oc[q ] : = [ ( -1)$nops(lyndon[q ] ) ] # initialize sum         for i_thread from 1 to max_threads-1 do             oc[q ] : = oc[q ] + receive(i_thread )         end do      end if end do end proc    > # example : > p : = 4 > s : = 4 > launch(order_conditions , imports=[\"p\",\"s\"],exports=[\"oc \" ] )   # run    > oc[1 ]    [ a[1]+a[2]+a[3]+a[4]-1 ,     b[1]+b[2]+b[3]+b[4]-1 ]    > oc[2 ]    [ 2*a[2]*b[1]+2*a[3]*b[1]+2*a[3]*b[2 ]     + 2*a[4]*b[1]+2*a[4]*b[2]+2*a[4]*b[3]-1 ]    > oc[3 ]    [ 3*a[2]^2*b[1]+6*a[2]*a[3]*b[1]+6*a[2]*a[4]*b[1 ]     + 3*a[3]^2*b[1]+3*a[3]^2*b[2]+6*a[3]*a[4]*b[1]+6*a[3]*a[4]*b[2 ]      + 3*a[4]^2*b[1]+3*a[4]^2*b[2]+3*a[4]^2*b[3]-1 ,     3*a[2]*b[1]^2 + 3*a[3]*b[1]^2 + 6*a[3]*b[1]*b[2 ]      + 3*a[3]*b[2]^2 + 3*a[4]*b[1]^2 + 6*a[4]*b[1]*b[2]+6*a[4]*b[1]*b[3 ]       + 3*a[4]*b[2]^2 + 6*a[4]*b[2]*b[3]+3*a[4]*b[3]^2 - 1 ]    > oc[4 ]    [ 4*a[2]^3*b[1]+12*a[2]^2*a[3]*b[1]+12*a[2]^2*a[4]*b[1 ]     + 12*a[2]*a[3]^2*b[1]+24*a[2]*a[3]*a[4]*b[1]+12*a[2]*a[4]^2*b[1 ]      + 4*a[3]^3*b[1]+4*a[3]^3*b[2]+12*a[3]^2*a[4]*b[1 ]       + 12*a[3]^2*a[4]*b[2]+12*a[3]*a[4]^2*b[1]+12*a[3]*a[4]^2*b[2 ]        + 4*a[4]^3*b[1]+4*a[4]^3*b[2]+4*a[4]^3*b[3]-1 ,     6*a[2]^2*b[1]^2 + 12*a[2]*a[3]*b[1]^2 + 12*a[2]*a[4]*b[1]^2      + 6*a[3]^2*b[1]^2 + 12*a[3]^2*b[1]*b[2]+6*a[3]^2*b[2]^2       + 12*a[3]*a[4]*b[1]^2 + 24*a[3]*a[4]*b[1]*b[2]+12*a[3]*a[4]*b[2]^2        + 6*a[4]^2*b[1]^2 + 12*a[4]^2*b[1]*b[2]+12*a[4]^2*b[1]*b[3 ]         + 6*a[4]^2*b[2]^2 + 12*a[4]^2*b[2]*b[3]+6*a[4]^2*b[3]^2 - 1 ,     4*a[2]*b[1]^3 + 4*a[3]*b[1]^3 + 12*a[3]*b[1]^2*b[2 ]      + 12*a[3]*b[1]*b[2]^2 + 4*a[3]*b[2]^3 + 4*a[4]*b[1]^3       + 12*a[4]*b[1]^2*b[2]+12*a[4]*b[1]^2*b[3]+12*a[4]*b[1]*b[2]^2        + 24*a[4]*b[1]*b[2]*b[3]+12*a[4]*b[1]*b[3]^2 + 4*a[4]*b[2]^3         + 12*a[4]*b[2]^2*b[3]+12*a[4]*b[2]*b[3]^2 + 4*a[4]*b[3]^3 - 1 ] ....    for practical use some further tools have been developed , e.g.for generating tables of polynomial coefficients for further use , e.g. , by numerical software other than maple .",
    "this latter job can also be parallelized .",
    "some special cases are of interest :    * _ symmetric schemes _ are characterized by the property @xmath100 . here , either @xmath101 or @xmath102 , and the remaining coefficient sets @xmath103 and @xmath104 are palindromic .",
    "symmetric schemes have an even order @xmath34 , and the order conditions for even orders need not be included ; see  @xcite .",
    "thus , we use a special ansatz and generate a reduced set of equations . *",
    "_ palindromic schemes _ were introduced in  @xcite and characterized by the property @xmath105 , where @xmath106 denotes the scheme @xmath107 with the role of @xmath21 and @xmath22 interchanged . in this case",
    ", the full coefficient set @xmath108 is palindromic . as for symmetric schemes",
    ", this means that a special ansatz is used , and again it is sufficient to generate a reduced set of equations , see  @xcite .",
    "apart from these modifications , the basic algorithm remains unchanged .",
    "our algorithm directly generalizes to the case of splitting into more than two operators .",
    "consider evolution equations where the right - hand side splits into three parts , @xmath109 and associated splitting schemes ,      see  @xcite . here",
    "the linear representation   generalizes as follows , with @xmath112 , and @xmath41 , @xmath113 : @xmath114 on the basis of these identities , the algorithm from section  [ subsec : ire ] generalizes in a straightforward way .",
    "the lyndon basis representing independent commutators now corresponds to lyndon words over the alphabet @xmath115 , see  @xcite .",
    "concerning special cases ( symmetries etc . ) and parallelization , similar considerations as before apply .",
    "for the purpose of adaptive time - splitting algorithms , the construction of ( optimized ) pairs of schemes of orders @xmath116 is favorable . generating a respective set of order conditions",
    "can also be accomplished by a modification of our code ; the difference lies in the fact that some coefficients are chosen a priori ( corresponding to a given method of order @xmath64 ) , but apart from this the generation of order conditions for an associated scheme of order @xmath34 works analogously as before . finding optimal schemes",
    "is then accomplished by tracing a large set of possible solutions ; see  @xcite .",
    "auzinger , w. , hofsttter , h. , ketcheson , d. , koch , o. : practical splitting methods for the adaptive integration of nonlinear evolution equations .",
    "part i : construction of optimized schemes and pairs of schemes .",
    "asc report no .",
    "25/2015 , tu wien , ( 2015 ) ; submitted .",
    "blanes s. , casas , f. , farrs , a. , laskar , j. , makazaga , j. , a.  murua , a. : new families of symplectic splitting methods for numerical integration in dynamical astronomy .",
    "68 , 5872 ( 2013 )    bokut , l. , sbitneva , l. , shestakov , i. : yndon - shirshov words , grbner - shirshov bases , and free lie algebras . in `",
    "non - associative algebra and its applications ' , chapter  3 .",
    "chapman & hall / crc , boca raton , fl ."
  ],
  "abstract_text": [
    "<S> this article is based on  @xcite and  @xcite , where an approach based on taylor expansion and the structure of its leading term as an element of a free lie algebra was described for the setup of a system of order conditions for operator splitting methods . along with a brief review of these materials and some theoretical background </S>",
    "<S> , we discuss the implementation of the ideas from these papers in computer algebra , in particular using . ] maple  18 . </S>",
    "<S> a parallel version of such a code is described . </S>"
  ]
}