{
  "article_text": [
    "the package btovvana has been developed to analyze the decays of neutral pseudoscalar b - mesons into two vector mesons decaying into two muons and two pseudoscalar mesons .",
    "two channels of this type are included in the b - physics generator simub  @xcite used here for precise testing of the package btovvana : @xmath8 and @xmath9 .",
    "these channels contain rich physics information because of nontrivial angular distributions and time dependence of the decays .    at present",
    "we have the information from d0 experiment at the tevatron about observation of 337 events with decay of the first type @xmath10 and 1370 events of the second type @xmath11  @xcite .",
    "the d0 data sample corresponds to an integrated luminosity 0.22 fb@xmath12 , collected in 2002 - 2004 .",
    "the statistics will be increased up to 4000 @xmath10 events at the d0 in the nearest future . assuming the @xmath13 cross section to be 100 @xmath14b",
    ", the number of expected @xmath10 events , using 2 fb@xmath12 of integrated lumunosity , will be equal to 41400 in the btev experiment  @xcite .",
    "about 8500 @xmath11 events are reconstructed in a date sample taken by the belle detector in the kekb @xmath15 collider  @xcite .",
    "the systematic study of these decays will be performed after 2007 year on the lhc detectors . about 200000 @xmath10 events at the cms , 100 000 events at the atlas and 75 000 events at the lhcb",
    "are expected to be obtained during first year of low luminosity operation  @xcite .",
    "possibilities of the current experiments for these important decays can be improved by using optimal methods of the analysis . for large statistics",
    "the best method is likelihood fit while for small statistics this method becomes unstable for big number of unknown physics parameters , and the angular moments method is more preferable  @xcite .",
    "the latest method allows one to build a sequencial chain of extraction of the physics parameters  @xcite .",
    "the goal of the paper is to formulate an optimal scenario of this analysis which can be realized for real data by using the package btovvana presented here .",
    "theoretical ideas realized in btovvana are based on papers  @xcite and  @xcite .",
    "files of the package btovvana are kept under the btovvana directory which contains subdirectories mak , src , doc , res : directory src contains the source codes of the program ; mak contains makefile , command files for compilation make_release and execution run ; bin contains the results of the compilation ( object files ) and the executable file ( this directory is created authomatically by command make_release ) ; doc includes documentations ; res is the user directory for data and results .",
    "the structure of the directory tree one can be found in makefile :    .... source_dirs = .. /mak source_dirs+=t_run_read source_dirs+=t_run_read / t_accum_measure source_dirs+=t_run_read / t_accum_measure / t_angmommethod source_dirs+=t_run_read / t_accum_measure / t_angmommethod / t_weightfunc source_dirs+=t_run_read / t_accum_measure / t_angmommethod / t_standardmodel_dg source_dirs+=t_run_read / t_accum_measure / t_angmommethod / t_weightfunc\\              /t_timeintobs",
    "source_dirs+=t_run_read / t_accum_measure / t_angmommethod / t_weightfunc              /t_timeintobs / t_physics source_dirs+=t_utility ....    the directory tree reflects a logical structure and dependences of the classes of the package .",
    "command make_release processes all .c files in directories included in the list above . as a rule the name of the directory coincides with the name of the class which is placed in the directory . the structure of the program is shown in fig.1 .",
    "class t_run_read is intended for reading the events from external files .",
    "this class contains the main loop over events . for mode mode_loop",
    "= 2 the loop calls the virtual dummy method which will be overlapped in the derived class .",
    "class t_run_read contains the methods for regime mode_loop = 3 in which the angle and time distributions are created ( see fig .",
    "the daughter class t_accum_measure overlaps some dummy methods of the mother class t_run_read and is intended for regime mode_loop = 2 .",
    "the main data members of the class are the so called `` containers '' which acummulate the information event by event , average the observables , and write the results to the final listing .",
    "the class t_angmommethod carries out the extraction of the observables by using the angular moments method .",
    "two `` containers '' are impemented in the class t_accum_measure : both of the `` containers '' are described as objects of the same class t_angmommethod with different angular weighting functions .",
    "the main data members of the class t_angmommethod are four objects of the class t_timeintobs and three objects of the class t_standardmodel_dg .",
    "the class t_timeintobs contains descriptions of the time - integrated observables which are obtained by accumulation of the event weights .",
    "the class t_standardmodel_dg performs calculations of the width @xmath16 and width difference @xmath3 by using the found observables in case of the standard model prediction of the small cp - violating weak phase .",
    "the weights of the events are found by using the class t_weightfunc which is the mother class for class t_timeintobs .",
    "extraction of the final observables based on some predefined physics parameters with its errors which described in class t_physics .",
    "the object of this class should be created in the main program by the user in case of processing the real data . in case of processing the data from generator simub one needs to set logical parameter brealdata = false in the main function . in this case",
    "the program will read the generator physics parameters from the first event .",
    "directory t_utility includes some auxiliary functions and classes .",
    "the structure of the package btovvana is the same as the structure of the generator simub  @xcite which allows to obtain the events @xmath17 and @xmath18 with full physics contents and high precision of generation of the kinematical variables .",
    "subpackage simub / bb_dec allows to obtain the events with @xmath0 and @xmath11 decays with full physics contents by setting the channel option `` copt si1 '' in command file bb_dec / mak / run  @xcite and using the decay mechanism option `` b0sm 1 '' ( `` b0 dm 1 '' ) and decay channel option `` b0sc 1 '' ( `` b0dc 1 '' ) for @xmath19 ( @xmath20 ) mesons .",
    "the format of the simub event is defined by option frmt .",
    "subpackage simub / bb_dec has a mode mode_loop==2 to produce events in the format readable by the program btovvana .",
    "the variable mode_loop is set in the file bb_dec / mak / run by option modd 2 . in this case",
    "the format defined by option frmt is ignored and the events are written in root tree in the format defined in the constructor of class t_loop ( subpackage simub / bb_dec ) in the following way :    .... if(mode_loop==2 ) {    hfile= new tfile(fname,\"recreate\",\"b0s->j / psiphi or b0d->j / psik * tree \" ) ;   tree = new ttree(\"t\",\"b0s->j / psiphi decay tree \" ) ;   tree->branch(\"vb \" , & vb , \" x / d : y : z : t : tau \" ) ;   tree->branch(\"pb \" , & pb , \" x / d : y : z : e : m \" ) ;   tree->branch(\"pa \" , & pa , \" x / d : y : z : e : m \" ) ;   tree->branch(\"pa1\",&pa1,\"x / d : y : z : e : m \" ) ;   tree->branch(\"pa2\",&pa2,\"x / d : y : z : e : m \" ) ;   tree->branch(\"pb \" , & pb , \" x / d : y : z : e : m \" ) ;   tree->branch(\"pb1\",&pb1,\"x / d : y : z : e : m \" ) ;   tree->branch(\"pb2\",&pb2,\"x / d : y : z : e : m \" ) ;   tree->branch(\"dfg\",&dfg,\"delta1/d : delta2:wphi : na02:nap2:nat2 :      gb : gl : gh : dg : mb : ml : mh : dm : dx : dy : dz : dt : tmax : cthb1:ctha1:schi :      cchi : chi : blifetime : fdist : kfcode / i \" ) ; } ....    here the fname is a name of the output file defined by option outf name.root , the branches vb and pb define the secondary 4-vertex of @xmath21-decay and 4-momentum of b - meson , branches pa and pb define 4-momentum of @xmath22 and @xmath23 ( @xmath24 ) mesons , branches pa1 and pa2 define 4-momentum of @xmath25 and @xmath26 mesons , branches pb1 and pb2 define 4-momentum of @xmath27 and @xmath28 mesons (",
    "@xmath29 and @xmath30 for @xmath24 ) , the branch dfg defines the physics parameters of the decay @xmath31 ( @xmath11 ) : strong cp - conserving phases @xmath32 ( named as delta1 ) and @xmath33 ( delta2 ; we set @xmath34 ) , weak cp - violating phase @xmath23 ( wphi ) , initial transversity amplitudes squared @xmath35 ( names na02 , nap2 , nat2 ) , @xmath36 ( @xmath20 ) width @xmath16 , widths of light and heavy states @xmath37 , @xmath38 ( with the corresponding program names gb , gl , gh , dg ) , @xmath21 mass @xmath39 and masses of light and heavy states @xmath40 , @xmath41 ( program names mb , ml , mh , dm ) , generator resolutions  @xcite or detector resolution named by dx , dy , dz , dt for four kinematical variables @xmath42 , @xmath43 , @xmath44 and @xmath45 , correspondently , where three angles are defined in fig .  2 , and @xmath45 is the @xmath21 meson proper lifetime .    if the program btovvana is used for the generator data , then the data members from the branch dfg contain physics parameters from the generator . in case of analysis of real data these data members should contain theoretical predictions to calculate some values which depend on the measured values and external parameters and for comparison .",
    "any number of the input files with events can be treated by the program btovvana .",
    "the names of these files are written in the main program .",
    "the package is tested on linux ( redhat 7.x , 8.x ) platforms and uses the root package  @xcite . to run the package , it is necessary to set the environment variables of the root .    to install the program ,",
    "it is enough to untar the file btovvana.tar.gz in the working directory and the btovvana directory with the structure described above will be created .",
    "the main function is placed in the file mak / t_accum_measure_main.c .",
    "the user can set here the following parameters :    * code of b - meson kf_code ( pythia kf - code is 531 for @xmath19 and 511 for @xmath20 ) ; * number of the input files nfiles and its names collected in the array cfile ; * mode_loop = 2 to extract the physics parameters or mode_loop = 3 to draw the angular and proper time distributions ; * maximal proper lifetime used to select the events ( or for monte carlo generation in generator ) time_maximal_mmdc ; * the upper limit for the proper lifetime of b - meson time_up_mmdc ( in units of [ mm / c ] ) , time_up_mmdc = time_maximal_mmdc as a rule ; * second choice of the upper limits for proper lifetime time_zero_mmdc ; * parameter gammas_mmdcm1 may be set as arbitrary ; to minimize the errors of measurements , one needs to set gammas_mmdcm1 closely to the true value of @xmath16 ( @xmath16 is b - meson width in units [ mm / c]@xmath12 ) ; * logical parameter brealdata = true in case of analysis of real data , otherwise the program will process the events from the generator ; the only difference is that in case of brealdata = false the user does not need to define the object of t_physics * phys in the main finction because this object will be defined within the program as the data member by method parameter_simub of the class t_angmommethod by using the special physics records in the events written by generator simub ( see branch dfg in the class t_run_read which one can found in package btovvana and in generator simub ) ; in case of brealdata = true the user needs to set an object of the class t_physics in the main function by using the data from the previous run of the program or from other sources ; * number of events nevents ( will be ignored if it is less than the number of the events in all the input files ) ; * to draw a simple histogram , one has to set bsimple_histogr = true otherwise it will be drawn histograms with error bars as it is shown in fig.3 ; * logical variable debug = true for extended information in the listing used for debug of the program ; * logical variable bshortinf = true for short information in the listing ;    to compile the program , one has to go into mak directory and execute the command make_release .",
    "after that , one should start the program by the command run .",
    "example of the main program and listing with results of the program are placed in section `` test run input and output '' .",
    "the main part of the class t_run_read was done authomatically by the root method makeclass of the ttree class .",
    "the constructor of the class t_run_read contains the following parameters : kf_bmeson is a pythia kf - code of b - meson , numbfiles is a number of the files for analysis , mode_loop is a processing mode , and cfile [ ] is a list of the file names .",
    "class t_run_read contains the loop which reads the data and writes the event information in the folowing data members of the class :    .... double vb_x ,   vb_y ,   vb_z ,   vb_t , vb_tau , //",
    "vertex and lifetime    pb_x ,   pb_y ,   pb_z ,   pb_e ,   pb_m ,      //",
    "b momentum and mass    pa_x ,   pa_y ,   pa_z ,   pa_e ,   pa_m ,      //j / psi momentum and mass   pa1_x , pa1_y , pa1_z , pa1_e , pa1_m ,      //   mu+ momentum and mass   pa2_x , pa2_y , pa2_z , pa2_e , pa2_m ,",
    "//   mu- momentum and mass    pb_x ,   pb_y ,   pb_z ,   pb_e ,   pb_m ,      //   phi / ktar momentum and mass   pb1_x , pb1_y , pb1_z , pb1_e , pb1_m ,      //",
    "k+(k )   momentum and mass   pb2_x , pb2_y , pb2_z , pb2_e , pb2_m ;      //",
    "k-(pi ) momentum and mass     // physics , kinematics and monte carlo parameters ( branch dfg ) : double dfg_delta1,dfg_delta2,// strong cp conserving phases   dfg_wphi ,",
    "// weak cp violating phase   dfg_na02,dfg_nap2,dfg_nat2 ,    //",
    "initial polarized amplitudes squared ( 0,||,t )   dfg_gb   , dfg_gl , dfg_gh , dfg_dg,// see definition in previous section    dfg_mb , dfg_ml , dfg_mh , dfg_dm ,   // see definition in previous section   dfg_dx , dfg_dy , dfg_dz , dfg_dt ,   // see definition in previous section   dfg_tmax ,                      //",
    "maximal alowed b lifetime    dfg_cthb1,dfg_ctha1 ,           //",
    "cos(theta_k+ ) cos(theta_mu+ )   dfg_schi , dfg_cchi , dfg_chi ,    //",
    "cos(chi),sin(chi ) , chi   dfg_blifetime ,        //",
    "b lifetime   dfg_fdist ;            // value of distribution function for given                         //",
    "cos(theta_k+),cos(theta_mu+ ) , chi , b - lifetime   int dfg_kfcode ;       // pythia kf code of b meson ....    using the method mom_to_lorentzvector the event momenta and vertex are rewritten in root lorentz vector variables : p_b_l , p_a_l , p_a1_l , p_a2_l , p_b_l , p_b1_l , p_b2_l , v_b_gen , v_b_dec , dvertex_b = v_b_dec - v_b_gen .",
    "the data members - cthe_b1_r , cthe_a1_r , chi_r , b_lifetime_r - present the values @xmath42 , @xmath43 , @xmath44 , @xmath45 ( see fig.2 ) which are calculated for the current event by the method reco_helicity_angles ( if the position of a method is not given , then the method belongs to the class t_run_read in this section by default ) .    the number of the input files for the processing is set in the constructor of the class t_run_read by parameter n_umbfiles .",
    "the file names are collected in the character array in the main program and passed in the constructor by the parameter cfile [ ] .",
    "the method loop(nevents ) performs the loop over all the events in the file chain .",
    "the user can find two logical keys bsimub_angles and bsimple_histogr inside the method loop .",
    "if bsimub_angles = true , then the angles and b lifetime directly from generator simub ( from the branch dfg ) will be used for histograms , otherwise the angles and b lifetime which were reconstructed from the momenta and vertex , are used for histograms ; if bsimple_histogr = true , then we can obtain the pictures with simple histograms for the three angles and b lifetime , while for bsimple_histogr = false one can obtain histograms with error bars .",
    "the latest kind of pictures for decay @xmath0 can be seen in fig .  3 for 100000 events .",
    "we have used the `` main setting '' of physics parameters by default for @xmath0(@xmath1 ) decays : @xmath46 , @xmath47 , @xmath48 , @xmath49 , @xmath50 , @xmath51 , @xmath52 , @xmath53 , @xmath54 , @xmath55 , @xmath56 , @xmath57 , @xmath58 , @xmath59 , where the values for @xmath1 are shown in brackets if they do not coincide .",
    "switch of regimes mode_loop are placed in the main program .",
    "class t_run_read includes methods in a simple mode mode_loop = 3 .",
    "methods for the mode_loop = 2 are placed in the derived class t_accum_measure ( see the next section ) .",
    "all other values of mode_loop are not used in the current version of the program .",
    "it is convenient to create a separate derived class t_accum_measure specially to treat the events .",
    "the main loop over the events is placed in class t_run_read with non virtual definition and therefore it is not redefined in the derived class t_accum_measure .",
    "the program uses the same method loop placed in the parent class t_run_read for all regimes .",
    "the method loop contains the switch on different regimes of processing by the key mode_loop .",
    "this switch has the following form ( it is a simplifyed form of the loop ) :    ....    for(jentry=0 ; jentry < nevents ; jentry++ ) {      if(mode_loop==2 )       if(!reco_accum_measure ( ) ) out(\"$warning 1(goto next evt)\",0 ) ;      else if(mode_loop==3 ) fill_hist_reco ( ) ; }    if      ( mode_loop==2 ) average_measure_outresult ( ) ;    else if(mode_loop==3 ) draw_hist(0 ) ; ....    within the class t_run_read there are dummy virtual methods reco_accum_measure and average_measure_outresult which are overlapped in the derived class .",
    "the method reco_accum_measure transforms the momenta of the particles into angles and accumulats observables .",
    "the method average_measure_outresult performs averaging and printing the results of the observables extraction .",
    "class t_accum_measure has t_run_read as a parent class and its constructor has the form :    .... t_accum_measure(bool debug ,     int kf_b_to_analyse , int numbfiles ,   char * cfile [ ] ,     int mode_loop , double timeup_mmdc , double time_maximal_mmdc ,      double time_zero_mmdc , double gammas_mmdcm1 ,     bool brealdata , t_physics * phys ) ; ....    where the parameters debug , kfb_to_analyse , numbfiles , cfile [ ] and modeloop are used for the constructor of the parent class t_run_read described in the previous section .",
    "all other parameters are described in section 4 .    at present",
    "the class t_accum_measure includes the extraction of observables by the angular moments method described in  @xcite .",
    "the main methods of the class overlap the parent virtual methods reco_accum_measure and average_measure_outresult .",
    "these methods are called by derived method t_run_read::loop which is not overlapped in the class t_accum_measure .",
    "class t_accum_measure has the `` containers '' to accumulate the information in the loop over the events .",
    "these data are processed and printed in their final form in function average_measure_outresult .",
    "`` containers '' are represented as the following data members of the class :    ....    t_angmommethod * angmommethod_a ;    t_angmommethod * angmommethod_b ; ....    where angmommethod_a(angmommethod_b ) are used to treat the events by using the angular moments method with the weighting function which is described in  @xcite as `` set a''(``set b '' ) .",
    "the user can introduce new `` containers '' for other ways of treatment .",
    "for example , tagged events of decay @xmath60 containing the oscillation phenomenon allow to extract the parameter @xmath61 . according to the scenario presented here , the extraction of the @xmath61 by using the tagged samples should be done after analysis of the untagged sample .",
    "the method to extract @xmath61 and corresponding `` container '' will be developed in the next version of the program btovvana .",
    "a pointer to the object of the class t_accum_measure * am is defined in the main function .",
    "constructor of the class t_accum_measure defines the `` containers '' ( parameters of the constructor will be described in the following section ) :    ....   angmommethod_a = new t_angmommethod(1 , ... ) ;   angmommethod_b = new t_angmommethod(2 , ... ) ; ....    then the main program calls the loop method inherited from the parent class am @xmath5 loop(500000 ) .",
    "it passes the number of events to the loop to be processed .",
    "the events from the external files are read and written into the data members of the parent class t_run_read .",
    "the structure of the loop was shown in the previous section .",
    "as you can see , the loop calls the method reco_accum_measure which is overlapped in the class t_accum_measure and has the following form :    .... bool t_accum_measure::reco_accum_measure ( ) {    mom_to_lorentzvector ( ) ;     reco_helicity_angles ( ) ;    count_measureev++ ; if(count_measureev==1 ) measure_init ( ) ;    measure_accum ( ) ; return true ; } ....    the first method mom_to_lorentzvector transforms the momenta to the root lorentz vectors and to the angles ( in the frame shown in fig .  2 ) and the b - meson proper lifetime calculated by using the function reco_helicity_angles .",
    "the last function is placed in directory t_utility / f_reco_helicityangles .    before treatment of the first event the initialization",
    "is performed by means of the method measure_init . in the treatment of events from the generator",
    "simub the method measure_init calls the method parameter_simub to initialize the `` containers '' angmommethod_a and angmommethod_b by the physics parameters ( in this section the methods without references have the placement in the class t_accum_measure by default ) .",
    "these parameters are used to extract the observables from the time - integrated observables which have been obtained by class t_timeintobs , and to perform analytical calculations to compare them with the approximate estimations obtained by the monte carlo method ( see description of the class t_physics below ) .",
    "it is helpful to test the both the event generator and the analysing package btovvana .",
    "as it is described in the previous section , the method loop derived from class t_run_read calls the virtual method reco_accum_measure which overlapped in the class described in this section .",
    "further the chain of calls is the following : reco_accum_measure ( ) @xmath5 measure_accum ( ) @xmath5 measure_accum_angmommethod ( ) . the structure of the latest method is very general :    .... void t_accum_measure::measure_accum_angmommethod ( ) {   angmommethod_a->init_angles(cthe_b1_r , cthe_a1_r , chi_r , b_lifetime_r ) ;   angmommethod_a->accumulation_timeintobs   ( ) ;   angmommethod_a->set_false_flaginit_angles ( ) ;   angmommethod_b->init_angles(cthe_b1_r , cthe_a1_r , chi_r , b_lifetime_r ) ;   angmommethod_b->accumulation_timeintobs   ( ) ;   angmommethod_b->set_false_flaginit_angles ( ) ; } ....    it is not difficult to include other user `` containers '' into this method .    in method t_run_read::loop(int ) after the loop the method + average_measure_outresult is called .",
    "this method performs averaging and printing the results of the measurements ( it is a simplified form ) :    .... void t_accum_measure::average_measure_outresult ( ) {   angmommethod_a->average_timeintobs    ( ) ;   angmommethod_a->out_result_timeintobs ( \" set a \") ;   angmommethod_b->average_timeintobs    ( ) ;   angmommethod_b->out_result_timeintobs ( \" set b \" ) ; } ....",
    "the main data members of the class t_angmommethod are four pointers to the objects of the class t_timeintobs and three pointers to the objects of the class t_standardmodel_dg :    ....    t_timeintobs   * obs_tg0 ;   //    t , gp = 0    t_timeintobs   * obs_tgp ;   //    t , gp = g '    t_timeintobs   * obs_t0g0 ;   //    t0 , gp = 0    t_timeintobs   * obs_t0gp ;   //    t0 , gp",
    "= g '    t_standardmodel_dg   * sm_dg_tgp_tg0 ;    t_standardmodel_dg   * sm_dg_tgp_t0gp ;    t_standardmodel_dg   * sm_dg_tg0_t0g0 ; ....    two different definitions of the time - integrated observables can be considered according to  @xcite : @xmath62 and @xmath63 .",
    "the first case corresponds to the zero parameters @xmath64 and the second one - to nonzero @xmath65 defined by the user ( see the next section about definition of @xmath65 ) . in the program",
    "the user can set also two different values of the upper time limit @xmath66 and @xmath67 .",
    "constructor and methods of the class t_angmommethod are    ....",
    "t_angmommethod       ( ... ) ;    void init_angles     ( ... ) ;    void parameter_simub ( ... )    void accumulation_timeintobs   ( ) ;    void average_timeintobs        ( ) ;    void out_result_timeintobs     ( const char_t * cc ) ;    virtual void show              ( const char_t * c ) ; ....    the constructor calls four constructors for four objects of the class t_timeintobs . each of the methods listed above calls four methods with the same name for the four objects of the class t_timeintobs and for the three objects of the class t_standardmodel_dg . for example ,    .... void t_angmommethod::accumulation_timeintobs ( ) {   obs_tg0 ->accumulation_timeintobs ( ) ;   obs_tgp ->accumulation_timeintobs ( ) ;   obs_t0g0->accumulation_timeintobs ( ) ;   obs_t0gp->accumulation_timeintobs ( ) ;   sm_dg_tgp_tg0 ->accumulation ( ) ;   sm_dg_tgp_t0gp->accumulation ( ) ;   sm_dg_tg0_t0g0->accumulation ( ) ; } ....    some features in using the objects of the classes t_timeintobs and t_standardmodel_dg the user can find in the method parameter_simub ( this method calls the methods of t_timeintobs objects only ) , and in the method average_timeintobs :    .... void t_angmommethod::average_timeintobs ( ) {   obs_tg0 ->average_timeintobs ( ) ; ... ;   sm_dg_tgp_tg0->t_standardmodel_dg_init(*obs_tgp , * obs_tg0 ) ;   sm_dg_tgp_tg0->average ( ) ; sm_dg_tgp_tg0->calc_dg(true ) ; ... ; } ....    method t_standardmodel_dg_init initiates the object to extract @xmath16 and @xmath3 .",
    "method average averages values to calculate the correlation between two types of the observables .",
    "method calc_dg calculates @xmath16 and @xmath3 .",
    "two types of the angular weighting function are proposed in  @xcite to extract the observables : @xmath68 and @xmath69 ( @xmath70 ) . as it is shown in  @xcite , it is helpful to consider the time dependent weighting functions which can be written in the general case as @xmath71 and similarly for @xmath72 . weighting function @xmath73 is named in the class t_weightfunc as method wi ( @xmath74 ) .",
    "the integer data member wf_type of the class t_weightfunc sets the type of weighting functions ( @xmath75 ) and it is initialized by the class constructor .",
    "the parameters of the weighting functions @xmath65 and @xmath66 are the constructor input parameters , named as gammas_mmdcm1 ( in unit ( mm / c)@xmath12 ) and timeup_mmdc ( in unit ( mm / c ) ) . the @xmath65 represents a first approximation for the measured value @xmath16 to be corrected in the current analysis of the untagged decays .    together with method",
    "wi there are also the methods with names wi_ctha1 , wi_cthb1 , wi_chi and wi_t in the class t_weightfunc .",
    "these methods represent the derivatives of the function wi with respect to arguments @xmath76 , @xmath77 , @xmath44 and @xmath45 , correspondently .",
    "the derivatives are used in class t_timeintobs to calculate the systematical errors or to estimate the detector response  @xcite .",
    "class t_timeintobs is a derived class to the class t_weightfunc .",
    "it is used to accumulate and average the time - integrated observable , and to extract the physics parameters .    in the general form by means of the weighting function @xmath78 ( @xmath79 ) on the set of the @xmath80 events we have observables and their statistical errors in the following form  @xcite : @xmath81 ^ 2 } , \\nonumber\\end{aligned}\\ ] ] where @xmath82 is a value of the weighting function for the @xmath83-th event . including the time dependent @xmath84-function in the weighting function allows to keep the time informative contents in the value @xmath85 and in the same time to have good statistical errors which are caused by a large size of the proper time interval @xmath86 $ ] .",
    "the class constructor t_timeintobs is defined by the following signature :    .... t_timeintobs(char * cc , int type_wf ,                double gammas_mmdcm1 , timeup_mmdc , timemax_mmdc ,               bool    debug , brealdata , t_physics * p_hys ) ; ....    three parameters type_wf , gammas_mmdcm1 , timeup_mmdc are sent to the mother class t_weightfunc ( see the previous section ) .",
    "parameter timemax_mmdc defines the value @xmath87 .    by means of the logical parameter brealdata",
    "the user can set either the mode for the real data or the mode for the generator data .",
    "the latest case does not use the method parameter p_hys and data member phys of the class will be filled by the generator data taken from the first event by the method parameter_simub .    in case of brealdata",
    "= true the user has to define the object of the class t_physics in the main program and send it into the object of the class t_accum_measure defined in the main program .",
    "the constructor and list of the methods of the class are as follows :    ....    t_timeintobs(char * cc , int   type_wf ,                 double gammas_mmdcm1 , timeup_mmdc , timemax_mmdc ,                 bool debug , b_realdata , t_physics * p_hys ) ;    void finalobserv_timeintobs ( const char_t * c ) ;    void parameter_simub(double delta1 , delta2 , totalphaseweak ,      na0_02 , na0_p2 , na0_t2 , gamma_bmes_gev , gp_gev , gm_gev , delta_g_gev ,       gen_dctb1 , gen_dcta1 , gen_dchi , gen_dt ) ;    void accumulation_timeintobs ( ) ;    void average_timeintobs      ( ) ;    void out_result_timeintobs   ( const char_t * c ) ;    virtual void show            ( const char_t * c ) ; ....    if we compare this list with the list of the methods of the class t_angmommethod , it is possible to note that the last 5 methods have the same names as the method names of the class t_angmommethod because the calls of these methods are the main purpose of the corresponding methods of the class t_angmommethod ( see explanation in the description of the class t_angmommethod ) .",
    "method finalobserv_timeintobs is called by method out_result_timeintobs and calculates the final observables or their combinations according to the formulae  @xcite : @xmath88 where we consider the initial amplitudes normalized as @xmath89 @xmath90 .",
    "we have introduced the function @xmath91 : @xmath92 @xmath93 are measured parameters related with physics values of widths of light and heavy states @xmath94 by @xmath95    the method finalobserv_timeintobs also calculates two values : @xmath96 where @xmath97 eqs .",
    "( [ sphi ] ) contain the weak phase in the left- and right - handed side and might be helpful in case of large values of weak phase @xmath98 when a large violation of the standard model predictions , @xmath99 , takes place",
    ".    values @xmath100 and @xmath101 are calculated in the data member t_physics * phys of the class t_timeintobs .",
    "the results of extraction of final observables  ( [ observ_tild_ut_3 ] ) and  ( [ sphi ] ) are given in tabls .  1 and  2 .",
    "the direct numerical calculations have shown that the difference between the values of observables @xmath102 @xmath103 , calculated with @xmath104 and @xmath105 , does not exceed 0.01% . even in case of statistics of 100  000 events",
    "this difference is negligibly small as compared with statistical errors for these observables .",
    "therefore , the assumption @xmath106 is a good approximation in case of standard model .    to determine the initial transversity amplitudes in case of sm , it is convenient to use @xmath64 and for large @xmath66 we have @xmath107 .",
    ".time - integrated observables obtained by data member obs_tg0 of class t_angmommethod .",
    "the sample of 300000 ( 3000 in parentheses ) untagged @xmath0 events from simub generator with the `` main setting '' of physics parameters ( see section 5 ) is used [ cols=\"^,^,^,^,^ \" , ]     to avoid the superfluous information , the user needs to set debug = false and bshortinf = true . in this case",
    "the listing consists of two parts for two methods of treatment by using the `` set a '' and `` set b '' weighting functions  @xcite ( in section `` test run input and output '' you can see the listing with the case of `` set b '' only ) .",
    "the `` set b '' weighting functions are the linear combinations of six angular functions which define the amplitude of the process while the `` set a '' weighting functions are not expressed linearly via the angular functions .",
    "this is the main reason why the statistical errors for observables in case of `` set b '' is about 2 times smaller than for the `` set a '' . in previous sections",
    "we have described the results for `` set b '' only .    in previous sections",
    "we have used three keys for tuning the program btovvana : @xmath65 , @xmath66 and @xmath67 . to improve solving the equations for @xmath108 , the user can change limits of arguments in the method mu_dg_equa_solut ( class t_standardmodel_dg ) which solves the equations .",
    "extraction of physics information in decays @xmath0 and @xmath1 by using the angular moments method with time dependent and time - integrated observables , has a number of attractive features , which are demonstrated by package btovvana :    * it is an unbinned method ; * it uses full time informative contents of time - dependent decays ; * it uses full available statistics ; * it gives stable results in case of small statistics ; * it allows one to separate the extraction of physics values ; * it allows one to use different scenarios in case of the signals beyond standard model , or in case when it is justified ; * it is a flexible tool because it has a different ways to tune the extraction of observables ( for example , to tune solving the equations ) in the process of the real data treatment ; * and it is a visual method ( see , for example , the fig.4 in  @xcite for dependences of @xmath109 on @xmath3 ) .",
    "the detailed tests have been performed for the package btovvana by means of a precise generator simub .",
    "the tests have checked mutually the both programs simub and btovvana with high precision .",
    "the complex btovvana - simub can be used to test other methods of extraction of physics information from decays @xmath0 and @xmath1 .",
    "the program btovvana has clear structure and can be used as template to include new methods of treatments .",
    "this work is dedicated to memory of who was the initiator of this work .",
    "99 a.  belkov and s.  shulga , comp.phys.com . 156",
    "( 2004 ) 221 - 240 ; a.  belkov and s.  shulga , part .",
    ", 2[117 ] ( 2003 ) 12 , hep - ph/0301105 ; see also http://cmsdoc.cern.ch/~shulga/simub/simub.html .",
    "v.m.abazov e.a .",
    "fermilab - pub-04/225-e , hep - ex/0409043 v3 ( 10 dec 2004 ) ; k.yip , in proceedings of 39th rencontres de moriond on qcd and high - energy hadronic interactions , la thuile , italy , 28 mar - 4 apr 2004 , hep - ex/0405024 .",
    "proceedings of the workshop `` the ckm matrix and the unitary triangle '' , 13 - 16 february , 2002 , chapt.3 .",
    "editors : m.battaglia , a.j.buras , p.gambino and a.stocchi , cern-2003 - 002-corr , 10 october 2003 , hep - ph/0304132 . k. abe e.a .",
    "belle - conf-0438/ichep04 8 - 0864 .",
    "proceedings of the workshop on standard model physics ( and more ) at the lhc .",
    "sect.``b decays '' .",
    "editors : g.altarelli , m.l.mangano , cern 2000 - 004 , 9 may 2000 . a.s .",
    "dighe , i.  dunietz and r.  fleischer , eur .",
    "j. c6 ( 1999 ) 647 .",
    "r.  brun and f.  rademakers , nucl .",
    "instrum . meth .",
    "a389 ( 1997 ) 81 ; see also http://root.cern.ch/.",
    "user defined parameters are defined in section 4 and placed in main program :    .... troot root(\"program btovvana \" , \" xxx \") ; int main(int argc , char * * argv ) {   tapplication * theapp= new tapplication(\"app \" , & argc , argv ) ;   cout < < \" * * * * * main ( ) start * * * * * \" < < endl ; //============= user set , files with events and parameters = = = = =   const int_t nfiles = 10 ; const char_t * cfile[nfiles ] ;   cfile [ 0 ] = \" $ dat1/10000ev_b0sjpsiphi_1.root \" ;   cfile [ 1 ] = \" $ dat1/10000ev_b0sjpsiphi_2.root \" ;   ...   cfile [ 9 ] = \" $ dat1/10000ev_b0sjpsiphi_10.root \" ;   int_t kf_code         = 531 ;   //",
    "531 - > b0s , bbar0s , 511 - > b0d , bbar0d   bool_t debug          = false;// switch for extended listing   bool_t bshortinf      = true ;   int_t   mode_loop      = 2 ;     // 2 : dgamma measurement ; 3 : angle distributions   double_t time_up_mmdc=2.,time_maximal_mmdc=2.,time_zero_mmdc=0.5;//mm / c   double_t gammas_mmdcm1 ;    if     ( kf_code = = 531 ) gammas_mmdcm1 = 2.278 ;   else if(kf_code==511 ) gammas_mmdcm1 = 2.27844;// gd = 2.12326 ;   else out_exit(\"main : check kf_code or set gammas_mmdcm1 . stop . \" ) ;   bool_t    brealdata    = false ;   double_t errfactor=0.2,reso_costhetap=0.022,reso_costhetakp=0.0076 ,        reso_chi=0.04,reso_t=0.03 ; // [ reso_t ] = mm / c   int_t   nevents = 100000 ;   bool_t bsimple_histogr = false ; //============= end user setting .",
    "= = = = = = = = = = = = = = = =   t_physics * phys = new t_physics ( ) ;   phys->init(time_up_mmdc , time_maximal_mmdc , 0 . , errfactor*0 . ,",
    "3.14 , errfactor*3.14 , 0 . , errfactor*0 . , 0.33 , errfactor*0.33 ,      0.33 , errfactor*0.33 , 0.33 , errfactor*0.33 ,      true , gammas_mmdcm1*phys->mmdcm1_to_gev ,      gammas_mmdcm1*phys->mmdcm1_to_gev*1.2 , // gl      errfactor*gammas_mmdcm1*phys->mmdcm1_to_gev*1.2 , // gl err      gammas_mmdcm1*phys->mmdcm1_to_gev*0.8 , //",
    "gh      errfactor*gammas_mmdcm1*phys->mmdcm1_to_gev*0.8 , //",
    "gh err      reso_costhetap , reso_costhetakp , reso_chi , reso_t ) ;   if(mode_loop==2 ) {    t_accum_measure * am = new t_accum_measure(debug , bshortinf ,       kf_code , nfiles , cfile , mode_loop ,        time_up_mmdc , time_maximal_mmdc , time_zero_mmdc ,       gammas_mmdcm1 , brealdata , phys ) ;    am->loop(nevents , bsimple_histogr ) ;   }   else if(mode_loop==3 ) {    t_run_read * sram = new t_run_read(kf_code , nfiles , cfile , mode_loop , debug ) ;    sram->loop(nevents , bsimple_histogr , 0 ) ;   }   if(mode_loop==3 ) theapp->run ( ) ;   cout < < \" * * * * * main ( ) end * * * * * \" < < endl ; } ....    the output listing in short format has the form :    ....   * * * * * main ( ) start * * * * *   --- ctor t_accum_measure --- weight func [ set b ] --- ctor t_timeintobs : ---    gamma^prime = 4.49511e-13 gev = 2.278 [ mm / c]^-1    t_imeup_mmdc = 1.01355e+13 gev^-1 = 2 mm / c    t_imemax_mmdc= 1.01355e+13 gev^-1 = 2 mm / c [ initial condition for other three kind of observables is placed here ] inform from t_timeintobs::parameter_simub in case of bsimub_test :    gamma_b0s   = 4.49598e-13 gev = 2.27844   [ mm / c]^-1   dg          = -8.99197e-14 gev = -0.455689 [ mm / c]^-1   gp(gl )      = 4.94558e-13 gev = 2.50629",
    "[ mm / c]^-1   gm(gh )      = 4.04638e-13 gev = 2.0506    [ mm / c]^-1   0.5*(gm+gp)= 4.49598e-13 gev = 2.27844   [ mm / c]^-1   ( gm - gp)= -8.99197e-14 gev = -0.455689    [ mm / c]^-1   dg / g    = -0.2   resolution : dctb1 , dcta1 , dchi , dt = 4e-05 , 4e-05 , 0.000125664 , 4e-05 ------------------------------------------- begin :   t_accum_measure::average_measure_outresult   * * * [ set b ] * * *   t_accum_measure::average_measure_outresult    nevent = 100000 timeup = 2 mm / c ,    gammas = 2.278 [ mm / c]^-1 -------------- begin   tgp   -2prime- begin ---   o0= 2.1242+/-0.024 (   1.1%)+/-0.0000(0%)= 2.1169   = oe0 o1= 1.0584+/-0.033 (   3.1%)+/-0.0000(0%)= 1.1760   = oe1 o2= 1.0787+/-0.035 (   3.2%)+/-0.0000(0%)= 0.9889   = oe2 o3=-0.0165+/-0.031(188.3%)+/-0.0000(0%)= 0.0099   = oe3 o4=-1.5242+/-0.049 (   3.2%)+/-0.0000(0%)=-1.5778   = oe4 o5= 0.0469+/-0.047 ( 99.8%)+/-0.0000(0%)=-0.0133   = oe5   from t_reco_cumobs::out_result_cumobs * * *   -------------------------------------------------------------------------       cval       theor     mc   er_mc(erv / v% ) er_st_cor(e / ev% ) er_phys(e / ev% )        a_02/a_p2   1.8000   2.0070 0.072 (   3.6% ) 0.072 (   3.6% ) 0.00 (   0.0% )        a_p2/a_02   0.5556   0.4983 0.018 (   3.6% ) 0.018 (   3.6% ) 0.00 (   0.0% )        a_t2/a_02   0.2963   0.3221 0.26 ( 79.5% ) 0.012 (   3.6% ) 0.26 ( 99.9% )              a02   0.5400   0.5493 0.077 ( 14.1% ) 0.005 (   0.9% ) 0.077 ( 99.8% )              ap2   0.3000   0.2737 0.039 ( 14.3% ) 0.008 (   2.9% ) 0.039 ( 97.9% )              at2   0.1600   0.1769 0.12 ( 65.5% ) 0.006 (   3.4% ) 0.12 ( 99.9% )       cos(d2-d1 ) -1.0000 -1.0166 0.036 (   3.6% ) 0.036 (   3.6% ) 0.00 (   0.0% ) cos(d1)*sin(phi ) 0.0400 -0.0672 0.14 ( 201.4% ) 0.13 ( 188.3% ) 0.048 ( 35.5% ) cos(d2)*sin(phi)-0.0400   0.1350 0.17 ( 122.7% ) 0.13 ( 99.8% ) 0.096 ( 58.2% ) -------------- end   tgp   -2prime- end ------------------ [ ... output for other three observables is placed here ] sm_dg_tgp_tg0   from t_angmommethod::out_result_timeintobs # begin   -----------------------------------------------------------   cval val_theorc   val_mc+/-erval_mc(erv / v%)+/- er_sys(e / ev% )    dgl_0    -0.4566 -0.4493+/-   0.0388 (   8.6%)+/-   0.0000 ( 0% )    dgl_1    -0.4566 -0.8170+/-   0.1113 ( 13.6%)+/-   0.0000 ( 0% )    dgh_2    -0.4548 -0.6876+/-   0.0912 ( 13.3%)+/- -0.0000 ( 0% )    dgl_4    -0.4566 -0.5358+/-   0.1068 ( 19.9%)+/-   0.0000 ( 0% )     dg_0    -0.4557 -0.5685+/-   0.0496 (   8.7%)+/-   0.0000 ( 0% )     dg_1    -0.4557 -0.7523+/-   0.0720 (   9.6%)+/-   0.0000 ( 0% )     dg_4    -0.4557 -0.6117+/-   0.0703 ( 11.5%)+/-   0.0000 ( 0% )     g_0      2.2784   2.2184+/-   0.0248 (   1.1%)+/-   0.0000 ( 0% )     g_1      2.2784   2.3103+/-   0.0360 (   1.6%)+/-   0.0000 ( 0% )     g_4      2.2784   2.2401+/-   0.0351 (   1.6%)+/-   0.0000 ( 0% )   dg_0/g_0 -0.2000 -0.2563+/-   0.0225 (   8.8%)+/- -0.0000 ( 0% )   dg_1/g_1 -0.2000",
    "-0.3256+/-   0.0316 (   9.7%)+/- -0.0000 ( 0% )   dg_4/g_4 -0.2000 -0.2731+/-   0.0317 ( 11.6%)+/- -0.0000 ( 0% )   ---------------------------------------------------------- [ ... output for other two types of dg extraction is placed here ] end * * * t_accum_measure::average_measure_outresult ( ) end * * * # # # # # # # t_run_read::loop end t_run_read::loop ( )",
    ". # # # # # # # #   * * * * * main ( ) end * * * * *   ....",
    "* figure 1 . * structure of the package btovvana . inserted squares mean derived classes .",
    "diamond inside the class means the data members of the classes shown by arrow ."
  ],
  "abstract_text": [
    "<S> c++ package btovvana is aimed to extract physics parameters in decays of the scalar neutral b - meson to two vector particles in the intermediate state , and two leptons and two pseudoscalar mesons in the final state . </S>",
    "<S> improved angular moments method is implemented in the package btovvana : the method uses the time dependent weighting functions and time - integrated observables with variable upper time limit . </S>",
    "<S> these observables allow to keep full time informative contents of the decay . by using the package btovvana </S>",
    "<S> it was shown that the statistical errors of extraction of the observables strongly depends on the choice of the angular weighting functions . </S>",
    "<S> the best angular weighting functions , which are the linear combinations of the amplitude angular functions , are implemented in the package btovvana . </S>",
    "<S> the first version of the program contains algorithms to extract physics parameters in the case of untagged decays . </S>",
    "<S> the package btovvana and program codes for the channels @xmath0 and @xmath1 in the monte carlo generator simub were written in parallel and mutually tested with high precision .    </S>",
    "<S> = -25 mm    = 151 mm = 231 mm    * program summary *    * _ title of the program : _ * btovvana + * _ catalogue identifier : _ * xxxx + * _ program summary url : _ * xxxx + * _ program obtainable from : _ * http://cmsdoc.cern.ch/@xmath2shulga/btovvana/btovvana.html + * _ computer : _ * pc , two intel 2.0 ghz processors , 512 mb ram + * _ operating system : _ * linux red hat 6.1 , 7.2 , 7.3 and other platforms which allow to set root package + * _ programming language used : _ * c++ : gcc 2.96 or 2.95.2 compiler suite with g++ + * _ size of the package : _ * 2.3 mb ( 0.4 mb compressed distribution archive ) , without root libraries ( additional 120 mb ) and without input files with events + * _ distribution format : _ * tar gzip file + * _ additional disk space required : _ * depends on the number of events : 35 mb for 100000 events ( output of simub generator ) + * _ pacs : _ * 02.70.tt ; 02.70.uu ; 07.05.tt ; 13.25.hw ; + * _ keywords : _ * particle physics , decay simulation , monte carlo methods , exclusive b - meson decay , angular moments method , cp - violation + * _ nature of the physical problem : _ * the package btovvana has been developed to study the performance of the angular moments method of the @xmath3 determination from analysis of untagged decays @xmath4 . by using the package btovvana </S>",
    "<S> it was shown that the method of angular moments gives stable results and is found to be an efficient and flexible tool for measurements with @xmath0 and @xmath1 decays . </S>",
    "<S> + * _ method of solution : _ * the method of angular moments allows to construct a sequencial chain of extraction of the physics parameters from events : @xmath3 @xmath5 initial transversity amplitudes @xmath5 weak cp - violating phase @xmath5 strong cp - conserving phases @xmath6 . </S>",
    "<S> standard angular moments method was improved by using the time dependent weighting function and time - integrated observables with variable upper time limit . </S>",
    "<S> these observables allow to keep full time informative contents of the decay . </S>",
    "<S> this improved method is used in the package btovvana . </S>",
    "<S> it was shown that the statistical errors of extraction of the observables strongly depends on the choice of the angular weighting functions . </S>",
    "<S> the best weighting functions were found and implemented in the package btovvana . </S>",
    "<S> the program btovvana includes methods of extractions of observables as independent modules . </S>",
    "<S> in frame of the package btovvana user can include new analysis modules . </S>",
    "<S> the package btovvana and program codes for the channels @xmath0 and @xmath1 in the monte carlo generator simub were written in parallel and mutually tested with high precision . + * _ restrictions on the complexity of the problem : _ * program processes any number of files with any number of events ; program tested with about 200 files including @xmath7 events + * _ typical running time : _ * on a pc / linux with 2.0 ghz processors btovvana package spends 15 seconds for every 100 000 events . </S>"
  ]
}