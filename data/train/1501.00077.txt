{
  "article_text": [
    "index coding in @xcite is a transmission technique for noiseless broadcasting channel consisting of a transmitter and a set of users .",
    "the transmitter wishes to deliver multiple packets to their respective users over a shared noiseless link .",
    "each user has its own prior knowledge of a subset of the packets .",
    "the transmitter sends a signal per time slot and all the users receive it without noise .",
    "the goal is to design transmit codes to minimize the number of required transmissions so that all users decode the desired packets with their own side - information and the received signals from the transmitter .",
    "this class of problems has recently received attention because of its connections to network coding @xcite and topological interference management @xcite . designing an efficient index code",
    "is tightly related with the constructing codes for caching @xcite and distributed storage systems @xcite .",
    "there has been extensive work on characterizing the optimal index code length ( the minimum number of transmissions ) @xcite .",
    "approaches based on graph theory are popular because of the strong connection between the optimal index code length and graph - theoretical quantities @xcite . for instance , when each user wants distinct packets , an index code design problem is equivalently represented in terms of a directed side - information graph @xmath0 .",
    "it was shown in @xcite that , for the given direct side - information graph @xmath0 , the optimal index code length is lower and upper bounded by the maximum independent set number of the corresponding graph , @xmath1 , and the chromatic number of its complement , @xmath2 .",
    "these approaches @xcite are useful in characterizing the bounds of the optimal index code length and in obtaining the optimal index code for a certain class of side - information graphs ( e.g. , vertex - coloring methods @xcite ) .",
    "algebraic approaches are also effective methods to characterize the optimal index code length .",
    "one key result is that the optimal binary index code length equals to the minimum rank ( minrank ) of a matrix that fits the side - information graph @xmath0 , i.e. , @xmath3 @xcite .",
    "this algebraic expression yields a new way of constructing index codes by solving a matrix completion problem over a finite field .    in this letter",
    ", we consider a generalization of index coding when the side information packets can be themselves coded . specifically , unlike the conventional assumption that each user independently knows a subset of other users packets as side - information @xcite , we admit a coded structure in generating side - information so that each user is able to have any linear combinations of all packets as side - information .",
    "as is well - known , index coding is already tremendously challenging even the side information packets are not coded .",
    "however , the idea of allowing coded side information is useful ( beyond mathematical interest as a natural generalization ) since in many situations side information is created by overhearing previous transmissions which will be very frequently coded .",
    "this is especially relevant in caching scenarios where helpers try to assist in content dissemination @xcite .    to explain the index coding problem with coded side - information , we provide a motivating example . as depicted in fig .",
    "[ fig:1 ] , a transmitter desires to deliver @xmath4 , @xmath5 , and @xmath6 to user 1 , 2 , and 3 , respectively .",
    "let us first consider the uncoded side - information case where each user separately knows the others desired information bits . in such case ,",
    "one xored transmission @xmath7 suffices to make all three users decode the desired information bits , if user 1 , 2 , and 3 stored two bits @xmath8 , @xmath9 , and @xmath10 , where @xmath11 represents an xor operation or addition over the binary field @xmath12 .",
    "next , let us consider a different scenario in which each user may only store one bit due to the lack of memory in the device . in this case , if user 1 , 2 , and 3 have coded side - information of @xmath13 , @xmath14 , and @xmath15 , the same xored transmission @xmath7 are enough to satisfy all three users .",
    "this example reveals the benefit of coding over side - information in reducing the size of cache while maintaining the transmission rate . for the case of uncoded side - information ,",
    "each user requires cache memory with two bits to decode the desired information bit from the xored transmission @xmath7 by the transmitter .",
    "whereas , if each user strores the xored bit instead of saperately storing them , cache memory with one bit is enough to extract the desired information bit .     by the transmitter . whereas , if each user strores the xored bit instead of saperately storing them , cache memory with one bit is enough to extract the desired information bit.,width=336 ]    our main contribution is to characterize the optimal binary vector linear index code length in terms of the minrank of a matrix when the users have coded side - information .",
    "our key finding is that the minrank expression is a function of 1 ) a set of the packet indices requested by the users and 2 ) a set of side - information encoding matrices . with the derived equivalence between the optimal index code length and the minrank expression ,",
    "we propose a random greedy algorithm that minimizes the rank of the derived matrix .",
    "the index coding problem with coded side - information , in fact , was initially considered in @xcite where a linear index code with coded side - information can be found equivalently by solving a system of multi - variable polynomial equations , which is difficult to solve in general .",
    "we show how to design index codes by minimizing the rank of a derived matrix .",
    "this rank minimization formulation allows us to connect the index code design problem to a matrix completion problem over finite fields @xcite .",
    "consider one transmitter and @xmath16 users in a network .",
    "the transmitter has @xmath17 packets , each with @xmath18 bits , @xmath19 for @xmath20 .",
    "we denote a sequence of all packets by @xmath21^t\\in \\mathbb{f}_2^{fn}$ ] .",
    "user @xmath22 requests a set of packets @xmath23 for @xmath24 ( @xmath25 is a subset of @xmath26 ) .",
    "for example , if @xmath27 , then user @xmath28 desires to decode packets @xmath29 and @xmath30 .",
    "further , user @xmath31 has coded side - information @xmath32 with the size of @xmath33 bits for @xmath34 . assuming a linear encoding method , side - information given to user @xmath28 , @xmath35 , is created by a side - information generating matrix @xmath36 as @xmath37 with knowledge of the set of encoding matrices @xmath38",
    ", the transmitter sends different linear combinations of packets @xmath39 over @xmath40 time slots ( channel uses ) so that all users successfully decode the requested packets by exploiting their coded side - information @xmath35 .    under the restriction of linear coding ,",
    "the transmitter uses an index coding matrix as an encoding function , i.e. , @xmath41\\in \\mathbb{f}^{lf\\times nf}$ ] . note that the @xmath28-th sub - matrix @xmath42 is the precoding matrix carrying the @xmath28-th packet @xmath43 .",
    "when the transmitter sends @xmath44 packets with the index coding matrix @xmath45 over a noiseless link , user @xmath28 obtains the information vector @xmath46 over @xmath40 channel uses as @xmath47 applying a linear decoder @xmath48 , user @xmath49 decodes packet @xmath50 for @xmath51 using both the received signal @xmath52 and the coded side - information vector @xmath35 .",
    "the decodablity condition at user @xmath28 is @xmath53= { \\bf r}_k{\\bf x},\\label{eq : dec_cond_k}\\end{aligned}\\ ] ] where @xmath54 denotes the index matrix of the requested packets by user @xmath28 and @xmath55 . hence , the index matrix @xmath56 is a block matrix whose @xmath57 sub - block is an identity matrix @xmath58 if @xmath59 ; otherwise the remaining blocks are zero matrices . with the decodability condition in ( [ eq : dec_cond_k ] ) , we define a valid linear index code and its optimal code length .",
    "( valid linear index code ) the index coding matrix @xmath60 is valid over @xmath12 with the length @xmath40 if every user is able to decode its desired sets of packets from the transmitted packets and side - information available at user @xmath28 . in other words ,",
    "all users simultaneously satisfy the decodability conditions in ( [ eq : dec_cond_k ] ) .",
    "( optimal linear index code length ) it is said that the index coding matrix @xmath60 has the optimal length @xmath61 if @xmath60 is valid and with the minimum number of rows @xmath62 .",
    "in this section , we characterize the minrank expression of the index code length for the class of index coding problems with coded side - information .",
    "the following theorem is the main result of this paper .",
    "[ theorem1]for the given set of side - information generating matrices @xmath63 and the desired packet index matrices @xmath64 , the optimal linear vector index code length @xmath65 over @xmath12 is obtained by solving the following optimization problem : @xmath66\\right),\\label{eq : th1}\\end{aligned}\\ ] ] where @xmath67 .",
    "we prove theorem [ theorem1 ] using an algebraic approach .",
    "recall the decodability condition of user @xmath31 in ( [ eq : dec_cond_k ] ) .",
    "we decompose the decoding matrix @xmath68 into two sub matrices @xmath69 and @xmath67 as @xmath70,\\end{aligned}\\ ] ] where sub - matrices @xmath71 and @xmath72 are multiplied to the received signal vector @xmath52 and side - information vector @xmath35 , respectively . with these sub - matrices , the decodability condition in ( [ eq : dec_cond_k ] ) at user @xmath28",
    "is equivalently decomposed as @xmath73 using the fact that @xmath74 and @xmath75 , the decodability condition in ( [ eq : dec_cond_k_compact ] ) is rewritten as @xmath76 since @xmath39 is non - degenerate , the decodability condition in ( [ eq : dec_k_mat ] ) simplifies further as @xmath77 where the last equality is due to the addition over @xmath12 .",
    "since every users needs to satisfy the decodability condition in ( [ eq : dec_k_mat_2 ] ) , the decodability condition for all the users is given by @xmath78}_{(\\sum_{k=1}^k|\\mathcal{t}_k|)f\\times lf } \\!\\!\\!\\!\\underbrace{{\\bf c}_{\\rm ic}}_{lf\\times nf}=\\underbrace{\\left[% \\begin{array}{c }   { \\bf r}_1+{\\bf a}_1^t{\\bf s}_1   \\\\ \\vdots \\\\ { \\bf r}_k+{\\bf a}_k^t{\\bf s}_k \\end{array}% \\right]}_{(\\sum_{k=1}^k|\\mathcal{t}_k|)f\\times",
    "nf}.\\label{eq : dec_cond_global}\\end{aligned}\\ ] ] notice that the rank of each matrix in the left - hand side in ( [ eq : dec_cond_global ] ) respectively equals to @xmath40 .",
    "this is because , by definition , @xmath45 should have @xmath40 linearly independent rows as a transmitter sends out a linearly independent linear combination of packets per time slot .",
    "furthermore , the concatenating matrix of all decoding matrices @xmath79 also has @xmath40 linearly independent columns to employ received vector @xmath80 in decoding .",
    "we denote the concatenating matrix of all decoding matrices by @xmath81^t$ ] . from the rank inequality ,",
    "the rank of the product of the two matrices is upper bounded by @xmath82 furthermore , applying sylvester s rank inequality , we obtain the lower bound on the rank as @xmath83 as a result , we conclude that the rank of the matrix in the right - hand side in ( [ eq : dec_cond_global ] ) equals to @xmath40 , namely , @xmath84\\right ) .",
    "\\label{eq : rankmat}\\end{aligned}\\ ] ] since we are interested in finding the minimum @xmath40 , the optimal index code length @xmath85 is obtained by minimizing the rank of the matrix in ( [ eq : rankmat ] ) with respective to over all possible indeterminate elements in @xmath86 .",
    "consequently , the minimum index code length is obtained by solving the optimization problem stated in ( [ eq : th1 ] ) .",
    "theorem 1 shows that the optimal linear index code length is determined by two factors : 1 ) the set of the packet index matrices @xmath87 and 2 ) the set of side - information encoding matrices @xmath88 .",
    "furthermore , the derived minrank expression in ( [ eq : th1 ] ) is useful to design the optimal index coding matrix @xmath45 with the rank of @xmath61 .",
    "this is because , under the premise that @xmath89 is predefined as @xmath90 for @xmath31 , it is possible to attain the optimal index coding matrix with rank @xmath61 , @xmath91 , by arbitrary selecting a set of the @xmath61 linearly independent rows in ( [ eq : th1 ] ) with @xmath92 .",
    "therefore , the index coding matrix can be obtained by carefully completing the indeterminate elements in @xmath92 so that they provide the minimum rank of the resultant matrix .",
    "this motivates us to design an algorithm that finds the index coding matrix via a matrix completion approach , which will be explained in section iv .    to shed further light on the significance of theorem [ theorem1 ] , it is instructive to consider certain special cases and examples .",
    "a special case is when @xmath93 , @xmath94 , and @xmath95 .",
    "user @xmath96 requests packet @xmath97 with one bit file size , i.e. , @xmath98 and @xmath99 .",
    "therefore , the packet requested by user @xmath28 is simply written as a unit vector whose @xmath28-th element is one , @xmath100 .",
    "further , we assume that the memory size of user @xmath28 is one bit , i.e. , @xmath95 for @xmath101 .",
    "then , the coded side - information generating matrix becomes a vector @xmath102 . in this reduced setup ,",
    "the optimal index code length is stated in the following corollary .",
    "[ corollary1 ] when @xmath94 and @xmath103 , the optimal scalar linear index code length is obtained by solving the following optimization problem @xmath104\\right ) \\nonumber \\\\ & = \\min_{{\\bf \\bar a } } { \\rm rk}\\left ( { \\bf i}_k + { \\bf \\bar s}{\\bf \\bar a}\\right ) , \\label{eq : cor1}\\end{aligned}\\ ] ] where @xmath105 $ ] and @xmath106^t$ ] .    without loss of generality , we assume that user @xmath28 desires to decode file @xmath107 , i.e. , @xmath108 with side - information @xmath109 .",
    "then , from theorem 1 , the optimal index code length is obtained by solving the problem stated in ( [ eq : cor1 ] ) .",
    "* example 1 ( optimal side - information encoding structure ) : * for the given @xmath110 , if we choose @xmath111 where @xmath112 is a all - ones matrix , then the rank of the matrix @xmath113 becomes one as @xmath114 and @xmath115 . as a result",
    ", we conclude that the optimal index code with the length one is achievable _ if and only if _ the product of the side - information encoding matrix and the free variables in @xmath116 ( decoding matrix ) has a particular structure of @xmath117 .",
    "this confirms the intuition that if each user knows xored information of all packets excepting for its desired one as side - information , it is possible to satisfy all users by sending xored information of all packets within one channel use .",
    "* example 2 ( connection to index coding with uncoded side - information ) : * let us consider the following index coding problem where @xmath118 and @xmath93 . user @xmath119 desires to decode @xmath120 with the set of uncoded side - information as follows :    * user 1 has @xmath121 and @xmath122 , i.e. , @xmath123^t \\in \\mathbb{f}_2^{2\\times 5}$ ] , * user 2 has @xmath124 and @xmath122 , i.e. , @xmath125^t \\in \\mathbb{f}_2^{2\\times 5}$ ] , * user 3 has @xmath121 and @xmath126 , i.e. , @xmath127^t \\in \\mathbb{f}_2^{2\\times 5}$ ] , * user 4 has @xmath121 and @xmath128 , i.e. , @xmath129^t \\in \\mathbb{f}_2^{2\\times 5}$ ] , * user 5 has @xmath124 , @xmath128 , and @xmath126 , i.e. , @xmath130^t \\in \\mathbb{f}_2^{3 \\times 5}$ ] .    note that since the side - information is uncoded , each row in side - information matrix @xmath131 contains a non - zero element .",
    "denoting @xmath132\\in \\mathbb{f}_2^{2\\times 1}$ ] for @xmath133 and @xmath134\\in\\mathbb{f}_2^{3\\times 1}$ ] , from theorem 1 , we are able to find the optimal index coding matrix @xmath45 by solving the following optimization problem : @xmath135}\\right ) \\label{eq : ex2_uncoded}. \\end{aligned}\\ ] ] now , we consider the same index coding problem but side - information is coded as follows :    * user 1 has @xmath136 , i.e. , @xmath137^t \\in \\mathbb{f}_2^{1\\times 5}$ ] , * user 2 has @xmath138 , i.e. , @xmath139^t \\in \\mathbb{f}_2^{1\\times 5}$ ] , * user 3 has @xmath140 , i.e. , @xmath141^t \\in \\mathbb{f}_2^{1\\times 5}$ ] , * user 4 has @xmath142 , i.e. , @xmath143^t \\in \\mathbb{f}_2^{1\\times 5}$ ] , * user 5 has @xmath144 , i.e. , @xmath145^t \\in \\mathbb{f}_2^{1\\times 5}$ ] .    since each user has coded side - information , unlike the uncoded case , the decoding matrix for user @xmath28 becomes @xmath146\\in\\mathbb{f}_2^{1}$ ] . as a result ,",
    "using theorem 1 , the optimal index coding matrix for the coded case is obtained by solving the following optimization problem : @xmath147\\right ) \\label{eq : ex2_coded}. \\end{aligned}\\ ] ] from ( [ eq : ex2_uncoded ] ) and ( [ eq : ex2_coded ] ) , we observe that the two minrank optimization problems are equivalent , provided that , in ( [ eq : ex2_uncoded ] ) , the additional constraints are imposed on indeterminate elements per each rows such that @xmath148 for @xmath149 . intuitively , for the uncoded case , we are able to exploit different side - information separately in decoding , which provides more degrees of freedom to choose the indeterminate elements . for the coded case ,",
    "however , the side - information is only used in the coded fashion in decoding , which imposes the constraints on the indeterminate elements .",
    "* example 3 ( coding over side - information in a caching problem ) : * suppose the case of @xmath150 in which a server intends to deliver two files with file size @xmath151 , i.e. , @xmath152^t$ ] and @xmath153^t$ ] to the user 1 and 2 , each with one bit cache memory @xmath154 .",
    "the coded caching method proposed in @xcite is to store @xmath155 and @xmath156 to user 1 and user 2 in the caching phase . during the delivery phase",
    ", the transmitter sends @xmath157 and @xmath158 over two channel uses to satisfy the users request .    in our framework ,",
    "this caching method can be realized by choosing the side - information matrices such that @xmath159~~ \\rm{and}~~{\\bf s}_2=[0~ 1~ 0~ 1].\\end{aligned}\\ ] ] since user 1 and user 2 desire to decode file @xmath29 and @xmath30 , the requested packet index matrices are @xmath160 ~~{\\rm and}~~ { \\bf i}_2=\\left[% \\begin{array}{cccc }   0 & 0 & 1&0 \\\\   0 & 0 & 0&1 \\\\",
    "\\end{array}% \\right].\\end{aligned}\\ ] ] by selecting the indeterminate elements as @xmath161^t$ ] and @xmath162^t$ ] , we obtain the minimum index code length with two because @xmath163\\right ) \\nonumber \\\\   & = { \\rm rk}\\left(\\left[% \\begin{array}{cccc }   0&0&1&0 \\\\   0&1&0&0 \\\\   0&0&1&0 \\\\",
    "0&1&0 & 0 \\\\ \\end{array}% \\right]\\right ) = 2 .",
    "\\label{eq : example_caching_twouser}\\end{aligned}\\ ] ] as shown in the rows of the resultant matrix in ( [ eq : example_caching_twouser ] ) , there are two possible transmission schemes that satisfy the users requests within two channel uses .",
    "the methods are to choose the index coding matrix @xmath45 as either the first two rows in ( [ eq : example_caching_twouser ] ) or the third and last rows in ( [ eq : example_caching_twouser ] ) .",
    "in this section , we propose a index code design algorithm that leverages the minrank expression derived in theorem 1 . from theorem 1",
    ", we observed that the optimal linear index coding matrix can be obtained by solving a matrix completion problem over a finite field .",
    "it is notable that the matrix competition problem to minimize the rank of the resultant matrix in ( [ eq : th1 ] ) is different from the conventional matrix completion problems in @xcite .",
    "this discrepancy comes from the fact that , in our problem , an indeterminate element in @xmath92 affects the multiple entries in the resultant matrix in ( [ eq : th1 ] ) , which is not the case for the conventional matrix completion problems .",
    "using theorem 1 , we propose a greedy random search algorithm that finds a linear index coding matrix with the rank of @xmath164 .",
    "the proposed algorithm initially computes the rank of the matrix over @xmath12 , assuming that @xmath165 is a matrix of zeros .",
    "then , the algorithm runs over until no rank change is detected over @xmath166 iterations in sequence . for the @xmath167-th iteration",
    ", we first update the elements of @xmath168 randomly according to bernoulli distribution with parameter @xmath169 .",
    "subsequently , we compute the rank of the matrix with the updated matrices @xmath170 and store them if the rank decreases compared to the previous one .",
    "the algorithm is summarized in table [ tab : greedy_alg ] . in the proposed algorithm , the number of iterations @xmath166 plays a role in balancing between the performance and complexity . on the one hand ,",
    "when the number of iterations @xmath166 is chosen sufficiently large , the proposed algorithm is able to yield the optimal minimum rank with high probability . on the other hand , when @xmath166 is not large enough , the probability that the algorithm reaches the minimum rank becomes low by reducing the computational complexity .",
    "furthermore , the parameter @xmath169 controls the likelihood that side - information matrix @xmath88 is used in decoding .",
    "this is because indeterminate elements in @xmath171 is multiplied with the elements in side - information matrix @xmath131 .",
    "[ tab : greedy_alg ]    to verify the performance of the proposed algorithm .",
    "we consider the coded side - information case in example 2 .",
    "@xmath172\\right ) \\label{eq : ex3}. \\end{aligned}\\ ] ] note that the minimum rank of the matrix in ( [ eq : ex3 ] ) is two , which is obtained when every side - information is used in decoding , i.e. , @xmath110 for @xmath119 . applying the proposed random greedy search method , we are able to compute the average of the rank @xmath173 $ ] as a function of the number of iterations @xmath166 . as illustrated in fig .",
    "[ fig:2 ] , when @xmath174 ( the probability that each user does not use coded side - information in decoding ) , the proposed algorithm achieves the minrank of 2 almost surely by searching @xmath175 points randomly among @xmath176 full search space .",
    "furthermore , once the solutions @xmath110 are determined , we obtain the index coding matrix by arbitrary selecting two independent rows ( 2 and 3 ) in the matrix ( [ eq : ex3 ] ) . as a result , it is possible for all users to decode @xmath107 if the transmitter sends @xmath177 and @xmath178 with two channel uses .",
    "[ fig2 ]   and @xmath169.,title=\"fig:\",width=316 ]",
    "in this letter , we studied a class of index coding problems with coded side - information .",
    "the optimal binary linear index code length is characterized in terms of the minrank expression of a matrix using an algebraic approach . by leveraging the derived minrank expression , we proposed a simple algorithm that solves a matrix completion problem to design index codes .",
    "the analytical minrank expression derived in this letter can be applied to design caching algorithms in many content distribution systems ."
  ],
  "abstract_text": [
    "<S> this letter investigates a new class of index coding problems . </S>",
    "<S> one sender broadcasts packets to multiple users , each desiring a subset , by exploiting prior knowledge of linear combinations of packets . </S>",
    "<S> we refer to this class of problems as index coding with _ </S>",
    "<S> coded _ side - information . </S>",
    "<S> our aim is to characterize the minimum index code length that the sender needs to transmit to simultaneously satisfy all user requests . </S>",
    "<S> we show that the optimal binary vector index code length is equal to the minimum rank ( minrank ) of a matrix whose elements consist of the sets of desired packet indices and side - information encoding matrices . </S>",
    "<S> this is the natural extension of matrix minrank in the presence of coded side information . using the derived expression </S>",
    "<S> , we propose a greedy randomized algorithm to minimize the rank of the derived matrix .    index coding and coded side - information </S>"
  ]
}