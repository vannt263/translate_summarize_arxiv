{
  "article_text": [
    "in this paper we compare different formalisms that can be used to specify and model systems which are distributed , concurrent and mobile , as those that are usually found in the global computing area .",
    "+ global computing is becoming very important because of the great development of networks which are deployed on huge areas , first of all internet , but also other kinds of networks such as networks for wireless communications . in order to build and program these networks",
    "one needs to deal with issues such as reconfigurability , synchronization and transactions at a suitable level of abstraction .",
    "thus powerful formal models and tools are needed .",
    "until now no model has been able to emerge as the standard one for this kind of systems , but there are a lot of approaches with different merits and drawbacks .",
    "+ an important approach is based on process calculi , like milner s ccs and hoare s csp . these two calculi deal with communication and synchronization in a simple way , but they lack the concept of mobility . an important successor of ccs , the @xmath0-calculus @xcite , allows to study a wide range of mobility problems in a simple mathematical framework .",
    "we are mainly interested in the _ fusion calculus _",
    "@xcite , which is an evolution of @xmath0-calculus .",
    "the interesting aspect of this calculus is that it has been obtained by simplifying and making more symmetric the @xmath0-calculus .",
    "+ one of the known limitations of process - calculi when applied to distributed systems is that they lack an intuitive representation because they are equipped with an _ interleaving _ semantics and they use the same constructions for representing both the agents and their configurations .",
    "an approach that solves this kind of problems is based on _ graph transformations _ @xcite . in this case",
    "the structure of the system is explicitly represented by a graph which offers both a clean mathematical semantics and a suggestive representation . in particular",
    "we represent computational entities such as processes or hosts with hyperedges ( namely edges attached to any number of nodes ) and channels between them with shared nodes .",
    "as far as the dynamic aspect is concerned , we use _ synchronized hyperedge replacement _ with _ hoare synchronization _ ( hshr ) @xcite .",
    "this approach uses productions to specify the behaviour of single hyperedges , which are synchronized by exposing actions on nodes .",
    "actions exposed by different hyperedges on the same node must be compatible . in the case of hoare synchronization",
    "all the edges must expose the same action ( in the csp style ) .",
    "this approach has the advantage , w.r.t .",
    "other graphical frameworks such as double pushout @xcite or bigraphs @xcite , of allowing a distributed implementation since productions have a local effect and synchronization can be performed using a distributed algorithm .",
    "+ we use the extension of hshr with _ mobility _",
    "@xcite , that allows edges to expose node references together with actions , and nodes whose references are matched during synchronization are unified .",
    "+ for us hshr is a good step in the direction of _ logic programming _ @xcite .",
    "we consider logic programming as a formalism for modelling concurrent and distributed systems .",
    "this is a non - standard view of logic programming ( see for a presentation of our approach ) which considers goals as processes whose evolution is defined by horn clauses and whose interactions use variables as channels and are managed by the unification engine . in this framework",
    "we are not interested only in refutations , but in any partial computation that rewrites a goal into another .",
    "+ in this paper we analyze the relationships between these three formalisms and we find tight analogies among them , like the same parallel composition operator and the use of unification for name mobility .",
    "however we also emphasize the differences between these models :    * the fusion calculus is interleaving and relies on _ milner synchronization _ ( in the ccs style ) ; * hshr is inherently _ concurrent _ since many actions can be performed at the same time on different nodes and uses hoare synchronization ; * logic programming is concurrent , has a wide spectrum of possible controls which are based on the hoare synchronization model , and also is equipped with a more complex data management .",
    "we will show a mapping from fusion calculus to hshr and prove a correspondence theorem .",
    "note that hshr is a good intermediate step between fusion calculus and logic programming since in hshr hyperedges can perform multiple actions at each step , and this allows to build chains of synchronizations .",
    "this additional power is needed to model milner synchronization , which requires synchronous , atomic routing capabilities . to simplify our treatment we consider only reduction semantics .",
    "the interleaving behaviour is imposed with an external condition on the allowed hshr transitions .",
    "+ finally we present the connections between hshr and logic programming . since the logic programming paradigm allows for many computational strategies and",
    "is equipped with powerful data structures , we need to constrain it in order to have a close correspondence with hshr .",
    "we define to this end _ synchronized logic programming _ ( slp ) , which is a transactional version of logic programming .",
    "the idea is that function symbols are pending constraints that must be satisfied before a transaction can commit , as for zero tokens in zero - safe nets @xcite . in the mapping from hshr to slp edges",
    "are translated into predicates , nodes into variables and parallel composition into and composition . +",
    "this translation was already presented in the msc .",
    "thesis of the first author @xcite and in .",
    "fusion calculus was mapped into shr with milner synchronization ( a simpler task ) in where fusion lts was considered instead of fusion reduction semantics .",
    "the paper also contains a mapping of ambient calculus into hshr .",
    "this result can be combined with the one here , thus obtaining a mapping of ambient calculus into slp .",
    "an extensive treatment of all the topics in this paper can also be found in the forthcoming ph.d .",
    "thesis of the first author @xcite .",
    "+ since logic programming is not only a theoretical framework , but also a well developed programming style , the connections between fusion , hshr and logic programming can be used for implementation purposes .",
    "slp has been implemented in through meta - interpretation .",
    "thus we can use translations from fusion and hshr to implement them .",
    "in particular , since implementations of logic programming are not distributed , this can be useful mainly for simulation purposes .",
    "+ in section [ section : background ] we present the required background , in particular we introduce the fusion calculus ( [ subsection : fusion ] ) , the algebraic representation of graphs and the hshr ( [ subsection : shr ] ) , and logic programming ( [ subsection : logicprog ] ) .",
    "section [ section : fusion2shr ] is dedicated to the mapping from fusion calculus to hshr .",
    "section [ section : hshr2lp ] analyzes the relationships between hshr and logic programming , in particular we introduce slp ( [ subsection : slp ] ) , we prove the correspondence between it and hshr ( [ subsection : hshr2lp ] ) and we give some hints on how to implement fusion calculus and hshr using prolog ( [ subsection : meta ] ) . in section [ section :",
    "conclusion ] we present some conclusions and traces for future work .",
    "finally , proofs and technical lemmas are in [ appendix : proofs ] .",
    "[ [ mathematical - notation . ] ] mathematical notation .",
    "+ + + + + + + + + + + + + + + + + + + + + +    we use @xmath1 to denote the application of substitution @xmath2 to @xmath3 ( where @xmath3 can be a term or a set / vector of terms ) .",
    "we write substitutions as sets of pairs of the form @xmath4 , denoting that variable @xmath5 is replaced by term @xmath6 .",
    "we also denote with @xmath7 the composition of substitutions @xmath8 and @xmath9 . we denote with @xmath10 the set of elements mapped to @xmath5 by @xmath2 .",
    "we use @xmath11 to denote the operation that computes the number of elements in a set / vector . given a function @xmath12",
    "we denote with @xmath13 its domain , with @xmath14 its image and with @xmath15 the restriction of @xmath12 to the new domain @xmath16 .",
    "we use on functions and substitutions set theoretic operations ( such as @xmath17 ) referring to their representation as sets of pairs .",
    "similarly , we apply them to vectors , referring to the set of the elements in the vector . in particular , @xmath18 is set difference . given a set @xmath16 we denote with @xmath19 the set of strings on @xmath16 . also , given a vector @xmath20 and an integer @xmath21 ,",
    "@xmath22 $ ] is the @xmath21-th element of @xmath23 .",
    "finally , a vector is given by listing its elements inside angle brackets @xmath24 .",
    "the fusion calculus @xcite is a calculus for modelling distributed and mobile systems which is based on the concepts of _ fusion _ and scope .",
    "it is an evolution of the @xmath0-calculus @xcite and the interesting point is that it is obtained by simplifying the calculus .",
    "in fact the two action prefixes for input and output communication are symmetric , whereas in the @xmath0-calculus they are not , and there is just one binding operator called scope , whereas the @xmath0-calculus has two ( restriction and input ) . as shown in , the @xmath0-calculus is syntactically a subcalculus of the fusion calculus ( the key point is that the input of @xmath0-calculus is obtained using input and scope ) . in order to have these properties fusion actions have to be introduced .",
    "an asynchronous version of fusion calculus is described in , , where name fusions are handled explicitly as messages . here",
    "we follow the approach by parrow and victor .",
    "+ we now present in details the syntax and the reduction semantics of fusion calculus . in our work",
    "we deal with a subcalculus of the fusion calculus , which has no match and no mismatch operators , and has only guarded summation and recursion .",
    "all these restrictions are quite standard , apart from the one concerning the match operator , which is needed to have an expansion lemma . to extend our approach to deal with match",
    "we would need to extend shr by allowing production applications to be tagged with a unique identifier .",
    "we leave this extension for future work . in our discussion",
    "we distinguish between _ sequential processes _ ( which have a guarded summation as topmost operator ) and general processes .",
    "+ we assume to have an infinite set @xmath25 of names ranged over by @xmath26 and an infinite set of agent variables ( disjoint w.r.t .",
    "the set of names ) with meta - variable @xmath27 .",
    "names represent communication channels .",
    "we use @xmath28 to denote an equivalence relation on @xmath25 , called fusion , which is represented in the syntax by a finite set of equalities .",
    "function @xmath29 returns all names which are fused , i.e.  those contained in an equivalence class of @xmath28 which is not a singleton .",
    "the prefixes are defined by : @xmath30    the agents are defined by : @xmath31 @xmath32    the scope restriction operator is a binder for names , thus @xmath5 is bound in @xmath33 .",
    "similarly @xmath34 is a binder for agent variables",
    ". we will only consider agents which are closed w.r.t .",
    "both names and agent variables and where in @xmath35 each occurrence of @xmath27 in @xmath36 is within a sequential agent ( guarded recursion ) .",
    "we use recursion to define infinite processes instead of other operators ( e.g.  replication ) since it simplifies the mapping and since their expressive power is essentially the same .",
    "we use infix @xmath37 for binary sum ( which thus is associative and commutative ) .",
    "+ given an agent @xmath36 , functions @xmath38 , @xmath39 and @xmath40 compute the sets @xmath41 , @xmath42 and @xmath43 of its free , bound and all names respectively .",
    "+ processes are agents considered up to structural axioms defined as follows .",
    "[ defin : congrfusion ] the structural congruence @xmath44 between agents is the least congruence satisfying the @xmath45-conversion law ( both for names and for agent variables ) , the abelian monoid laws for composition ( associativity , commutativity and 0 as identity ) , the scope laws @xmath46 , @xmath47 , the scope extrusion law @xmath48 where @xmath49 and the recursion law @xmath50 .",
    "note that @xmath38 is also well - defined on processes .    in order to deal with fusions",
    "we need the following definition .    a substitutive effect of a fusion",
    "@xmath28 is any idempotent substitution @xmath51 having @xmath28 as its kernel .",
    "in other words @xmath52 iff @xmath53 and @xmath2 sends all members of each equivalence class of @xmath28 to one representative in the class is a most general unifier of @xmath28 , when it is considered as a set of equations . ] .",
    "the reduction semantics for fusion calculus is the least relation satisfying the following rules .",
    "[ defin : redfusion ] @xmath54 where @xmath55 and @xmath2 is a substitutive effect of @xmath56 such that @xmath57 .",
    "@xmath58 where @xmath2 is a substitutive effect of @xmath28 such that @xmath57 .",
    "@xmath59      synchronized hyperedge replacement ( shr ) @xcite is an approach to ( hyper)graph transformations that defines _ global transitions _ using _ local productions_. productions define how a single ( hyper)edge can be rewritten and the _ conditions _ that this rewriting imposes on adjacent nodes .",
    "thus the global transition is obtained by applying in parallel different productions whose conditions are compatible .",
    "what exactly compatible means depends on which _ synchronization model _ we use . in this work",
    "we will use the hoare synchronization model ( hshr ) , which requires that all the edges connected to a node expose the same action on it . for a general definition of synchronization models see .",
    "+ we use the extension of hshr with _ mobility _",
    "@xcite , that allows edges to expose node references together with actions , and nodes whose references are matched during synchronization are unified .",
    "+ we will give a formal description of hshr as labelled transition system , but first of all we need an algebraic representation for graphs .",
    "an edge is an atomic item with a label and with as many ordered tentacles as the rank @xmath60 of its label @xmath61 .",
    "a set of nodes , together with a set of such edges , forms a graph if each edge is connected , by its tentacles , to its attachment nodes .",
    "we will consider graphs up to isomorphisms that preserve nodes , labels of edges , and connections between edges and nodes .",
    "+ now , we present a definition of graphs as syntactic judgements , where nodes correspond to names and edges to basic terms of the form @xmath62 , where the @xmath63 are arbitrary names and @xmath64 . also , @xmath65 represents the empty graph and @xmath66 is the parallel composition of graphs ( merging nodes with the same name ) .",
    "let @xmath25 be a fixed infinite set of names and @xmath67 a ranked alphabet of labels .",
    "a syntactic judgement ( or simply a judgement ) is of the form @xmath68 where :    1 .",
    "@xmath69 is the ( finite ) set of nodes in the graph .",
    "2 .   @xmath70 is a term generated by the grammar + @xmath71 + where @xmath72 is a vector of names and @xmath61 is an edge label with @xmath73 .",
    "we denote with @xmath40 the function that given a graph @xmath70 returns the set @xmath74 of all the names in @xmath70 .",
    "we use the notation @xmath75 to denote the set obtained by adding @xmath5 to @xmath76 , assuming @xmath77 .",
    "similarly , we write @xmath78 to state that the resulting set of names is the disjoint union of @xmath79 and @xmath80 .",
    "[ defin : structural ]    the structural congruence @xmath44 on terms @xmath70 obeys the following axioms : @xmath81 @xmath82 @xmath83    the well - formed judgements @xmath68 over @xmath67 and @xmath25 are those where @xmath84 .",
    "axioms ( ag1),(ag2 ) and ( ag3 ) define respectively the associativity , commutativity and identity over @xmath65 for operation @xmath66 .",
    "+ well - formed judgements up to structural axioms are isomorphic to graphs up to isomorphisms . for a formal statement of the correspondence see .",
    "we will now present the steps of a shr computation .",
    "[ defin : shrtrans ] let @xmath85 be a set of actions . for each action @xmath86 ,",
    "let @xmath87 be its arity . + a shr transition is of the form : @xmath88{\\lambda,\\pi } \\phi \\vdash g'\\ ] ] where @xmath68 and @xmath89 are well - formed judgements for graphs , @xmath90 is a total function and @xmath91 is an idempotent substitution .",
    "function @xmath92 assigns to each node @xmath5 the action @xmath93 and the vector @xmath94 of node references exposed on @xmath5 by the transition .",
    "if @xmath95 then we define @xmath96 and @xmath97 .",
    "we require that @xmath98 , namely the arity of the action must equal the length of the vector .",
    "+ we define :    * @xmath99 + set of exposed names ; * @xmath100 + set of fresh names that are exposed ; * @xmath101 + set of fused names .",
    "substitution @xmath0 allows to merge nodes .",
    "since @xmath0 is idempotent , it maps every node into a standard representative of its equivalence class .",
    "we require that @xmath102 , i.e.  only references to representatives can be exposed .",
    "furthermore we require @xmath103 , namely nodes are never erased .",
    "nodes in @xmath104 are fresh internal nodes , silently created in the transition .",
    "we require that no isolate , internal nodes are created , namely @xmath105 .",
    "note that the set of names @xmath106 of the resulting graph is fully determined by @xmath76 , @xmath92 , @xmath0 and @xmath107 thus we will have no need to write its definition explicitly in the inference rules .",
    "notice also that we can write a shr transition as : @xmath88{\\lambda,\\pi }   \\gamma\\pi,\\gamma_{\\lambda},\\gamma_{int } \\vdash g'.\\ ] ]    we usually assume to have an action @xmath108 of arity @xmath109 to denote `` no synchronization '' .",
    "we may not write explicitly @xmath0 if it is the identity , and some actions if they are @xmath110 . furthermore we use @xmath111 to denote the function that assigns @xmath110 to each node in @xmath76 ( note that the dependence on @xmath76 is implicit ) .",
    "we derive shr transitions from basic productions using a set of inference rules .",
    "productions define the behaviour of single edges .",
    "[ defin : production ] a production is a shr transition of the form : @xmath112{\\lambda,\\pi } \\phi   \\vdash g\\ ] ] where all @xmath63 , @xmath113 are distinct .",
    "+ productions are considered as schemas and so they are @xmath45-convertible w.r.t",
    ".  names in @xmath114 .",
    "we will now present the set of inference rules for hoare synchronization .",
    "the intuitive idea of hoare synchronization is that all the edges connected to a node must expose the same action on that node .",
    "[ defin : hoarerules ]    @xmath115{\\lambda , \\pi } \\phi \\vdash g_2 \\quad \\gamma ' \\vdash g'_1 \\xrightarrow[]{\\lambda',\\pi ' } \\phi ' \\vdash g'_2 \\quad ( \\gamma \\cup \\phi ) \\cap ( \\gamma ' \\cup \\phi')=\\emptyset}{\\gamma , \\gamma ' \\vdash g_1|g'_1 \\xrightarrow[]{\\lambda \\cup \\lambda ' ,",
    "\\pi \\cup \\pi ' } \\phi , \\phi ' \\vdash g_2|g'_2}\\ ] ]    @xmath116{\\lambda ,   \\pi } \\phi \\vdash g_2 \\quad \\forall x , y \\in \\gamma .",
    "x\\sigma = y\\sigma \\wedge x \\neq y \\rightarrow",
    "\\operatorname{act}_{\\lambda}(x ) = \\operatorname{act}_{\\lambda}(y)}{\\gamma\\sigma \\vdash g_1\\sigma   \\xrightarrow[]{\\lambda ' , \\pi ' } \\phi ' \\vdash g_2\\sigma\\rho}\\ ] ] where @xmath117 is an idempotent substitution and :    1 .",
    "[ merge : rho ] @xmath118 whenever possible 2 .",
    "[ merge : lambda ] @xmath119 3 .",
    "[ merge : pi ] @xmath120    @xmath121{\\lambda_{\\epsilon},id } \\gamma \\vdash g\\ ] ]    @xmath122{\\lambda,\\pi }   \\phi \\vdash g_2 \\quad x \\notin",
    "\\gamma \\quad \\vec y \\cap ( \\gamma \\cup \\phi \\cup \\{x\\})= \\emptyset}{\\gamma , x \\vdash g_1 \\xrightarrow[]{\\lambda \\cup   \\{(x , a,\\vec y)\\},\\pi } \\phi ' \\vdash g_2}\\ ] ]    a transition is obtained by composing productions , which are first applied on disconnected edges , and then by connecting the edges by merging nodes . in particular rule ( par ) deals with the composition of transitions which have disjoint sets of nodes and rule ( merge ) allows to merge nodes ( note that @xmath2 is a projection into representatives of equivalence classes ) .",
    "the side condition requires that we have the same action on merged nodes .",
    "definition [ merge : rho ] introduces the most general unifier @xmath123 of the union of two sets of equations : the first set identifies ( the representatives of ) the tuples associated to nodes merged by @xmath2 , while the second set of equations is just the kernel of @xmath0 .",
    "thus @xmath123 is the merge resulting from both @xmath0 and @xmath2 .",
    "note that [ merge : lambda ] @xmath92 is updated with these merges and that [ merge : pi ] @xmath124 is @xmath123 restricted to the nodes of the graph which is the source of the transition .",
    "rule ( idle ) guarantees that each edge can always make an explicit idle step .",
    "rule ( new ) allows adding to the source graph an isolated node where arbitrary actions ( with fresh names ) are exposed .",
    "+ we write @xmath125{\\lambda,\\pi }   \\phi \\vdash g')$ ] if @xmath126{\\lambda,\\pi } \\phi   \\vdash g'$ ] can be obtained from the productions in @xmath127 using hoare inference rules . + we will now present an example of hshr computation .",
    "we show now how to use hshr to derive a 4 elements ring starting from a one element ring , and how we can then specify a reconfiguration that transforms the ring into the star graph in figure [ figure : star4 ] .",
    "we use the following productions : @xmath128{(x , \\epsilon , \\langle \\rangle ) ,   ( y , \\epsilon , \\langle \\rangle ) } x , y , z \\vdash c(x , z)|c(z , y)\\ ] ] @xmath128{(x , r , \\langle w \\rangle ) , ( y , r ,   \\langle w \\rangle ) } x , y , w \\vdash s(y , w)\\ ] ] that are graphically represented in figure [ figure : prod ] .",
    "notice that @xmath92 is represented by decorating every node @xmath5 in the left hand with @xmath129 and @xmath130 .",
    "the first rule allows to create rings , in fact we can create all rings with computations like : @xmath131 in order to perform the reconfiguration into a star we need rules with nontrivial actions , like the second one .",
    "this allows to do : @xmath132{(x , r , \\langle w \\rangle),(y , r , \\langle w \\rangle),(z , r , \\langle w \\rangle),(v , r , \\langle w \\rangle)}\\\\ \\rightarrow x , y , z , v , w \\vdash s(x , w)|s(y , w)|s(z , w)|s(v , w)\\end{gathered}\\ ] ] note that if an edge @xmath133 is rewritten into an edge @xmath16 , then all the edges in the ring must use the same production , since they must synchronize via action @xmath134 .",
    "they must agree also on @xmath130 for every @xmath5 , thus all the newly created nodes are merged .",
    "the whole transition is represented in figure [ figure : reconf ] .",
    "it is easy to show that if we can derive a transition @xmath3 , then we can also derive every transition obtainable from @xmath3 by applying an injective renaming .",
    "[ lemma : injren ] let @xmath127 be a set of productions and @xmath2 an injective substitution .",
    "+ @xmath125{\\lambda,\\pi } \\phi   \\vdash g')$ ] iff : + @xmath135{\\lambda',\\pi ' } \\phi\\sigma \\vdash g'\\sigma)$ ] + where @xmath136 and @xmath137 .    by rule induction .      in this paper",
    "we are not interested in logic computations as refutations of goals for problem solving or artificial intelligence , but we consider logic programming @xcite as a _ goal rewriting mechanism_. we can consider logic subgoals as concurrent communicating processes that evolve according to the rules defined by the clauses and that use _ unification _ as the fundamental interaction primitive .",
    "a presentation of this kind of use of logic programming can be found in .",
    "+ in order to stress the similarities between logic programming and process calculi we present a semantics of logic programming based on a labelled transition system .",
    "[ defin : plgrammar ] we have for clauses ( @xmath133 ) and goals ( @xmath70 ) the following grammar :    @xmath138 @xmath139    where @xmath140 is a logic atom , `` , '' is the and conjunction and @xmath141 is the empty goal .",
    "+ we can assume `` , '' to be associative and commutative and with unit @xmath141 .",
    "the informal semantics of @xmath142 is `` for every assignment of the variables , if @xmath143 are all true , then @xmath140 is true '' .",
    "a logic program is a set of clauses .",
    "derivations in logic programming are called sld - derivations ( from `` linear resolution for definite clauses with selection function '' ) .",
    "we will also consider partial sld - derivations .",
    "[ defin : sld ] let @xmath36 be a logic program . + we define a step of a sld - resolution computation using the following rules : + @xmath144{\\theta } ( b_1,\\dots , b_k)\\rho\\theta } \\qquad   \\textrm{atomic goal}\\ ] ] where @xmath123 is an injective renaming of variables such that all the variables in the clause variant @xmath145 are fresh .",
    "@xmath146{\\theta } f}{p",
    "\\vdash g , g '   \\xrightarrow[]{\\theta } f , g'\\theta } \\qquad \\textrm{conjunctive goal}\\ ] ] we will omit @xmath147 if @xmath36 is clear from the context . + a partial sld - derivation of @xmath148 is a sequence ( possibly empty ) of steps of sld - resolution allowed by program @xmath36 with initial goal @xmath70 .",
    "in this section we present a mapping from fusion calculus to hshr . +",
    "this mapping is quite complex since there are many differences between the two formalisms .",
    "first of all we need to bridge the gap between a process calculus and a graph transformation formalism , and this is done by associating edges to sequential processes and by connecting them according to the structure of the system .",
    "moreover we need to map milner synchronization , which is used in fusion calculus , into hoare synchronization . in order to do this",
    "we define some connection structures that we call amoeboids which implement milner synchronization using hoare connectors .",
    "since hoare synchronization involves all the edges attached to a node while milner one involves just pairs of connectors , we use amoeboids to force each node to be shared by exactly two edges ( one if the node is an interface to the outside ) since in that case the behaviour of hoare and milner synchronization is similar .",
    "an amoeboid is essentially a router ( with no path - selection abilities ) that connects an action with the corresponding coaction .",
    "this is possible since in hshr an edge can do many synchronizations on different nodes at the same time",
    ". finally , some restrictions have to be imposed on hshr in order to have an interleaving behaviour as required by fusion calculus .",
    "+ we define the translation on processes in the form @xmath149 where @xmath36 is the parallel composition of sequential processes .",
    "notice that every process can be reduced to the above form by applying the structural axioms : recursive definitions which are not inside a sequential agent have to be unfolded once and scope operators which are not inside a sequential agent must be taken to the outside .",
    "we define the translation also in the case @xmath149 is not closed w.r.t .  names ( but it must be closed w.r.t .",
    "process variables ) since this case is needed for defining productions .",
    "+ in the form @xmath149 we assume that the ordering of names in @xmath150 is fixed , dictated by some structural condition on their occurrences in @xmath36 . + for our purposes , it is also convenient to express process @xmath36 in @xmath151 as @xmath152 , where @xmath153 is a linear agent , i.e.  every name in it appears once .",
    "we assume that the free names of @xmath153 are fresh , namely @xmath154 , and again structurally ordered .",
    "the corresponding vector is called @xmath155 . + the decomposition @xmath156 highlights the role of amoeboids .",
    "in fact , in the translation , substitution @xmath2 is made concrete by a graph consisting of amoeboids , which implement a router for every name in @xmath41 .",
    "more precisely , we assume the existence of edge labels @xmath157 and @xmath158 of ranks @xmath159 and @xmath160 respectively .",
    "edges labelled by @xmath157 implement routers among @xmath21 nodes , while @xmath158 edges `` close '' restricted names @xmath72 in @xmath161 .",
    "+ finally , linear sequential processes @xmath16 in @xmath153 must also be given a standard form .",
    "in fact , they will be modelled in the hshr translation by edges labelled by @xmath162 , namely by a label encapsulating @xmath16 itself .",
    "however in the derivatives of a recursive process the same sequential process can appear with different names an unbound number of times . to make the number of labels ( and also of productions , as we will see in short ) finite , for every given process",
    ", we choose standard names @xmath163 and order them structurally : + @xmath164 with @xmath165 implying @xmath166 and @xmath167 .",
    "+ we can now define the translation from fusion calculus to hshr .",
    "the translation is parametrized by the nodes in the vectors @xmath20 and @xmath168 we choose to represent the names in @xmath72 and @xmath155 .",
    "we denote with @xmath169}_{x \\in s } g_x$ ] the parallel composition of graphs @xmath170 for each @xmath171 .",
    "[ defin : fc2hshr ] @xmath172}_{x \\in \\vec v } n(x)$ ] + where : + @xmath173 , + @xmath174 , + @xmath175 + and with : + @xmath176 .",
    "+ @xmath177 + @xmath178 with @xmath179 + @xmath180 + @xmath181}_{x \\in \\operatorname{im}(\\sigma ) } m_{k+1}(x,\\sigma^{-1}(x))$ ] where @xmath182 .    in the above translation",
    ", graph @xmath183 consists of a set of disconnected edges , one for each sequential process of @xmath184 .",
    "the translation produces a graph with three kinds of nodes .",
    "the nodes of the first kind are those in @xmath168 .",
    "each of them is adjacent to exactly two edges , one representing a sequential process of @xmath153 , and the other an amoeboid .",
    "also the nodes in @xmath20 are adjacent to two edges , an amoeboid and an @xmath158 edge",
    ". finally the nodes in @xmath185 are adjacent only to an amoeboid . +",
    "as mentioned above , translation @xmath186 builds an amoeboid for every free name @xmath5 of @xmath187 : it has @xmath188 tentacles , where @xmath189 are the occurrences of @xmath5 in @xmath187 , namely the free names of @xmath153 mapped to it .",
    "notice that the choice of the order within @xmath10 is immaterial , since we will see that amoeboids are commutative w.r.t .",
    "their tentacles .",
    "however , to make the translation deterministic , @xmath10 could be ordered according to some fixed precedence of the names .",
    "let @xmath190 .",
    "the translation of @xmath2 is in figure [ figure : amoeboids ] .",
    "[ ex : processtr ] let us consider the ( closed ) process @xmath191 .",
    "we can write it in the form @xmath192 as : + @xmath193 + furthermore we can decompose @xmath36 into @xmath187 where : + @xmath194 + @xmath195 . + we can now perform the translation .",
    "+ we choose @xmath196 and @xmath197 : @xmath198    now we define the productions used in the hshr system .",
    "+ we have two kinds of productions : auxiliary productions that are applied to amoeboid edges and process productions that are applied to process edges .",
    "+ before showing process productions we need to present the translation from fusion calculus prefixes into hshr transition labels .",
    "[ defin : acttransl ] the translation from fusion calculus prefixes into hshr transition labels is the following : + @xmath199 where + if @xmath200 then @xmath201 , @xmath202 if @xmath203 with @xmath204 , @xmath205 + if @xmath206 then @xmath207 , @xmath202 if @xmath203 and @xmath204 , @xmath205 + if @xmath208 then @xmath209 and @xmath0 is any substitutive effect of @xmath28 .",
    "+ we will write @xmath210 and @xmath211 as @xmath212 and @xmath213 respectively .    [ defin : processprod ] we have a process production for each prefix at the top level of a linear standard sequential process ( which has @xmath214 as free names ) .",
    "let @xmath215 be such a process .",
    "its productions can be derived with the following inference rule : @xmath216{{\\llbracket \\alpha_j \\rrbracket } } \\gamma,\\gamma ' \\vdash g|{\\llbracket \\xi \\rrbracket}|{\\llbracket \\pi \\rrbracket}|\\operatorname{\\big[\\!\\!\\big]}_{x \\in \\gamma '' } n(x)}\\ ] ] if @xmath217 , @xmath214 and @xmath218 are pairwise disjoint with @xmath219 injective renaming from @xmath220 to fresh names , @xmath221 and @xmath222 .",
    "we add some explanations on the derivable productions .",
    "essentially , if @xmath223 is a possible choice , the edge labelled by the process can have a transition labelled by @xmath224 to something related to @xmath225 .",
    "we use @xmath226 instead of @xmath227 ( and then we add the translation of @xmath219 ) to preserve the parity of the number of amoeboid edges on each path ( see definition [ defin : structured ] ) .",
    "the parameter @xmath20 of the translation contains fresh nodes for restricted names that are taken to the top level during the normalization of @xmath227 while @xmath168 contains the free names in the normalization of @xmath227 ( note that some of them may be duplicated w.r.t .",
    "@xmath227 , if this one contains recursion ) .",
    "if @xmath228 is a fusion @xmath28 , according to the semantics of the calculus , a substitutive effect @xmath0 of it should be applied to @xmath227 , and this is obtained by adding the amoeboids @xmath229 in parallel .",
    "furthermore , @xmath68 must be enriched in other two ways : since nodes can never be erased , nodes which are present in the sequential process , i.e.  the nodes in @xmath230 , must be added to @xmath76 .",
    "also `` close '' @xmath158 edges must be associated to forgotten nodes ( to forbid further transitions on them and to have them connected to exactly two edges in the result of the transition ) , provided they are not exposed , i.e.  to nodes in @xmath231 .",
    "+ note that when translating the rhs @xmath232 of productions we may have names in @xmath233 which occur just once .",
    "since they are renamed by @xmath2 and @xmath219 , they will produce in the translation some chains of @xmath234 connectors of even length , which , as we will see shortly , are behaviourally equivalent to simple nodes . for simplicity , in the examples we will use the equivalent productions where these connectors have been removed and the nodes connected by them have been merged .",
    "[ ex : productions ] let us consider firstly the simple agent @xmath235 .",
    "+ the only production for this agent ( where @xmath236 ) is : + @xmath237{(x_1,out_1,\\langle x_2 \\rangle ) } x_1,x_2 \\vdash n(x_1)$ ] + where we closed node @xmath238 but not node @xmath239 since the second one is exposed on @xmath238 .",
    "+ let us consider a more complex example : + @xmath240 .",
    "+ the process @xmath241 where @xmath242 can be transformed into : + @xmath243 + where @xmath244 . +",
    "its translation ( with @xmath245 and @xmath246 ) is : @xmath247 thus the production is : @xmath248{(x_1,in_1,\\langle x_2 \\rangle)}\\\\   x_1,x_2,x_3,x_4,x_5,x_6,y_3,y_4,y_5,y_6,y_7,y_8,y , x'_5,x'_6 \\vdash\\\\   l_{\\overline{x_1}x_2.0}(x_3,x_4)| l_{x_1x_2.(\\overline{x_3}x_4.0|\\operatorname{rec}x .",
    "( ( x ) x_5x.(\\overline{x_6}x.0|x)))}(y_3,y_4,y_5,y_6,y_7,y_8)|\\\\ m_3(x'_5,y_3,y_7)|m_3(x'_6,y_5,y_8)|m_3(y , y_4,y_6)|n(y)|m_2(x_5,x'_5)|m_2(x_6,x'_6)|n(x_1)\\end{gathered}\\ ] ] where for simplicity we collapsed @xmath249 with @xmath250 and @xmath251 with @xmath252 .",
    "we will now show the productions for amoeboids .",
    "we have auxiliary productions of the form : @xmath253{(x_1,in_n,\\vec y_1),(x_2,out_n,\\vec y_2 ) } \\gamma,\\vec y_1,\\vec y_2 \\vdash m_k(\\gamma )    we need such a production for each @xmath189 and @xmath158 and each pair of nodes @xmath238 and @xmath239 in @xmath76 where @xmath76 is a chosen tuple of distinct names with @xmath189 components and @xmath254 and @xmath255 are two vectors of fresh names such that @xmath256 .",
    "+ note that we also have the analogous production where @xmath238 and @xmath239 are swapped .",
    "in particular , the set of productions for a @xmath257 edge is invariant w.r.t .",
    "permutations of the tentacles , modelling the fact that its tentacles are essentially unordered .",
    "+ we have no productions for edges labelled with @xmath158 , which thus forbid any synchronization .",
    "the notion of amoeboid introduced previously is not sufficient for our purposes .",
    "in fact , existing amoeboids can be connected using @xmath234 edges and nodes that are no more used can be closed using @xmath158 edges .",
    "thus we present a more general definition of amoeboid for a set of nodes and we show that , in the situations of interest , these amoeboids behave exactly as the simpler @xmath157 edges .",
    "[ defin : structured ] given a vector of nodes @xmath258 , a structured amoeboid @xmath259 for the set of nodes @xmath16 containing all the nodes in @xmath258 is any connected graph composed by @xmath260 and @xmath158 edges that satisfies the following properties :    * its set of nodes is of the form @xmath261 , with @xmath262 ; * nodes in @xmath16 are connected to exactly one edge of the amoeboid ; * nodes in @xmath263 are connected to exactly two edges of the amoeboid ; * the number of edges composing each path connecting two distinct nodes of @xmath16 is odd .",
    "nodes in @xmath16 are called _ external _ , nodes in @xmath263 are called _",
    "internal_. we consider _ equivalent _ all the amoeboids with the same set @xmath16 of external nodes .",
    "the last condition is required since each connector inverts the polarity of the synchronization , and we want amoeboids to invert it .",
    "+ note that @xmath264 is an amoeboid for @xmath16 .",
    "[ lemma : amoeboid ] if @xmath259 is a structured amoeboid for s , the transitions for @xmath259 which are non idle and expose non @xmath265 actions on at most two nodes @xmath266 are of the form : @xmath267{\\lambda , id } s , i , i',\\vec y_1,\\vec y_2 \\vdash m(\\vec s ) |",
    "|\\vec y_1| } m(\\vec y_1[i],\\vec y_2[i ] ) | \\operatorname{\\big[\\!\\!\\big]}\\tilde m(\\emptyset)\\ ] ] where @xmath268 and @xmath269 ( non trivial actions may be exposed also on some internal nodes ) and @xmath254 and @xmath255 are two vectors of fresh names such that @xmath256 . here",
    "@xmath270 contains rings of @xmath234 connectors connected only to fresh nodes which thus are disconnected from the rest of the graph .",
    "we call them _ pseudoamoeboids_. furthermore we have at least one transition of this kind for each choice of @xmath238 , @xmath239 , @xmath254 and @xmath271 .",
    "see [ appendix : proofs ] .",
    "thanks to the above result we will refer to structured amoeboids simply as amoeboids .    we can now present the results on the correctness and completeness of our translation .    [",
    "theorem : hoarecorrectness ] for each closed fusion process @xmath36 and each pair of vectors @xmath20 and @xmath168 satisfying the constraints of definition [ defin : fc2hshr ] , if @xmath272 then there exist @xmath92 , @xmath76 and @xmath70 such that @xmath273{\\lambda , id } \\gamma \\vdash g$ ] .",
    "furthermore @xmath274 is equal to @xmath275 ( for some @xmath276 and @xmath277 ) up to isolated nodes , up to injective renamings , up to equivalence of amoeboids ( @xmath68 can have a structured amoeboid where @xmath275 has a simple one ) and up to pseudoamoeboids .",
    "the proof is by rule induction on the reduction semantics .",
    "+ see [ appendix : proofs ] .",
    "[ theorem : hoarecompleteness ] for each closed fusion process @xmath36 and each pair of vectors @xmath20 and @xmath168 if @xmath273{\\lambda,\\pi } \\gamma \\vdash g$ ] with a hshr transition that uses exactly two productions for communication or one production for a fusion action ( plus any number of auxiliary productions ) then @xmath278 and @xmath68 is equal to @xmath279 ( for some @xmath276 and @xmath277 ) up to isolate nodes , up to injective renamings , up to equivalence of amoeboids ( @xmath68 can have a structured amoeboid where @xmath275 has a simple one ) and up to pseudoamoeboids .",
    "see [ appendix : proofs ] .",
    "these two theorems prove that the allowed transitions in the hshr setting correspond to reductions in the fusion calculus setting .",
    "note that in hshr we must consider only transitions where we have either two productions for communication or one production for a fusion action .",
    "this is necessary to model the interleaving behaviour of fusion calculus within the hshr formalism , which is concurrent . on the contrary",
    ", one can consider the fusion equivalent of all the hshr transitions : these correspond to concurrent executions of many fusion reductions .",
    "one can give a semantics for fusion calculus with that behaviour .",
    "anyway in that case the notion of equivalence of amoeboids is no more valid , since different amoeboids allow different degrees of concurrency .",
    "we thus need to constrain them .",
    "the simplest case is to have only simple amoeboids , that is to have no concurrency inside a single channel , but there is no way to force normalization of amoeboids to happen before undesired transitions can occur .",
    "the opposite case ( all the processes can interact in pairs , also on the same channel ) can be realized , but it requires more complex auxiliary productions .",
    "+ note that the differences between the final graph of a transition and the translation of the final process of a fusion calculus reduction are not important , since the two graphs have essentially the same behaviours ( see lemma [ lemma : injren ] for the effect of an injective renaming and lemma [ lemma : amoeboid ] for the characterization of the behaviour of a complex amoeboid ; isolated nodes and pseudoamoeboids are not relevant since different connected components evolve independently ) .",
    "thus the previous results can be extended from transitions to whole computations .",
    "+ note that in the hshr model the behavioural part of the system is represented by productions while the topological part is represented by graphs .",
    "thus we have a convenient separation between the two different aspects .",
    "[ ex : fusion2hoare ] we will now show an example of the translation . let us consider the process : @xmath280 note that it is already in the form @xmath149 .",
    "it can do the following transition : @xmath281 we can write @xmath36 in the form : + @xmath282 + where : + @xmath283 . + a translation of the starting process is : @xmath284 a graphical representation is in figure [ figure : process1 ] .",
    "+    we have the following process productions : @xmath285{(y_1,out_2,\\langle y_2,y_3 \\rangle)}\\\\   y_1,y_2,y_3,y_4,y_5 \\vdash l_{r(x_1,x_2)}(y_4,y_5)|n(y_1)\\end{gathered}\\ ] ] @xmath286{(y_1,in_2,\\langle y_2,y_3 \\rangle)}\\\\   y_1,y_2,y_3,y_4,y_5 \\vdash l_{s(x_1,x_2)}(y_4,y_5)|n(y_1)\\end{gathered}\\ ] ] in order to apply ( suitable variants of ) these two productions concurrently we have to synchronize their actions .",
    "this can be done since in the actual transition actions are exposed on nodes @xmath287 and @xmath288 respectively , which are connected to the same @xmath289 edge .",
    "thus the synchronization can be performed ( see figure [ figure : process2 ] ) and we obtain as final graph :    @xmath290    which is represented in figure [ figure : process3 ] .",
    "+    the amoeboids connect the following tuples of nodes : + @xmath291 , @xmath292 , @xmath293 .",
    "thus , if we connect these sets of nodes with simple amoeboids instead of with complex ones , we have up to injective renamings a translation of @xmath294 as required",
    ".    we will show here an example that uses recursion .",
    "let us consider the closed process @xmath295 .",
    "the translation of this process , as shown in example [ ex : processtr ] is : @xmath296    we need the productions for two sequential edges ( for the first step ) : @xmath235 and @xmath297 .",
    "+ the productions are the ones of example [ ex : productions ] ( we write them here in a suitable @xmath45-converted form ) : @xmath298{(u_1,out_1,\\langle",
    "z_1 \\rangle ) } u_1,z_1 \\vdash n(u_1)\\hspace{2cm}\\end{gathered}\\ ] ] @xmath299{u_2,in_1,\\langle y_1 \\rangle}\\\\   u_2,y_1,u_3,y_2,u_4,u_5,w_1,w_2,w_3,w_4,w_5,w_6,y',u'_4,u'_5 \\vdash\\\\   l_{\\overline{x_1}x_2.0}(u_3,y_2)| l_{x_1x_2.(\\overline{x_3}x_4.0|\\operatorname{rec}x .   ( ( x ) x_5x.(\\overline{x_6}x.0|x)))}(w_1,w_2,w_3,w_4,w_5,w_6)|\\\\ m_3(u'_4,w_1,w_5)|m_3(u'_5,w_3,w_6)|m_3(y',w_2,w_4)|n(y')|m_2(u_4,u'_4)|m_2(u_5,u'_5)|n(u_2)\\end{gathered}\\ ] ] by using these two productions and a production for @xmath300 ( the other edges stay idle ) we have the following transition : @xmath301{(u_1,out_1,\\langle z_1 \\rangle)(u_2,in_1,\\langle y_1 \\rangle)}\\\\ u , y , z , x , u_1,z_1,u_2,y_1,u_3,y_2,u_4,u_5,w_1,w_2,w_3,w_4,w_5,w_6,y',u'_4,u'_5   \\vdash\\\\ n(u_1)|l_{\\overline{x_1}x_2.0}(u_3,y_2)| l_{x_1x_2.(\\overline{x_3}x_4.0|\\operatorname{rec}x .",
    "( ( x )   x_5x.(\\overline{x_6}x.0|x)))}(w_1,w_2,w_3,w_4,w_5,w_6)|\\\\ m_3(u'_4,w_1,w_5)|m_3(u'_5,w_3,w_6)|m_3(y',w_2,w_4)|n(y')|m_2(u_4,u'_4)|m_2(u_5,u'_5)|n(u_2)|\\\\ m_6(u , u_1,u_2,u_3,u_4,u_5)|m_2(z_1,y_1)|m_2(z , z_1)|m_3(y , y_1,y_2)|n(u)|n(z)|n(y)\\end{gathered}\\ ] ] the resulting graph is , up to injective renaming and equivalence of amoeboids , a translation of : + @xmath302 + as required .",
    "we end this section with a simple schema on the correspondence between the two models .",
    "+    l|l|l|l fusion & hshr & fusion & hshr + closed process & graph & reduction & transition + sequential process & edge & name & amoeboid + prefix execution & production & 0 & @xmath303 +    as shown in the table , we represent ( closed ) processes by graphs where edges are sequential processes and amoeboids model names .",
    "the inactive process @xmath109 is the empty graph @xmath65 . from a dynamic point of view",
    ", fusion reductions are modelled by hshr transitions obtained composing productions that represent prefix executions .",
    "we will now present a mapping from hshr into a subset of logic programming called synchronized logic programming ( slp ) .",
    "the idea is to compose this mapping with the previous one obtaining a mapping from fusion calculus into logic programming .      in this subsection",
    "we present synchronized logic programming .",
    "+ slp has been introduced because logic programming allows for many execution strategies and for complex interactions .",
    "essentially slp is obtained from standard logic programming by adding a mechanism of transactions .",
    "the approach is similar to the zero - safe nets approach @xcite for petri nets .",
    "in particular we consider that function symbols are resources that can be used only inside a transaction .",
    "a transaction can thus end only when the goal contains just predicates and variables . during a transaction , which is called big - step in this setting",
    ", each atom can be rewritten at most once .",
    "if a transaction can not be terminated , then the computation is not allowed .",
    "a computation is thus a sequence of big - steps .",
    "this synchronized flavour of logic programming corresponds to hshr since :    * used goals correspond to graphs ( goal - graphs ) ; * clauses in programs correspond to hshr productions ( synchronized clauses ) ; * resulting computations model hshr computations ( synchronized computations ) .",
    "[ defin : goalgraph ] we call goal - graph a goal which has no function symbols ( constants are considered as functions of arity @xmath109 ) .    [ defin : syncprograms ] a synchronized program is a finite set of synchronized rules , i.e.   definite program clauses such that :    * the body of each rule is a goal - graph ; * the head of each rule is @xmath304 where @xmath305 is either a variable or a single function ( of arity at least @xmath160 ) symbol applied to variables .",
    "if it is a variable then it also appears in the body of the clause .",
    "[ ex : synchronized ] +    [ cols=\"^ , < \" , ]     in the mapping , the transaction mechanism is used to model the synchronization of hshr , where edges can be rewritten only if the synchronization constraints are satisfied . in particular ,",
    "a clause @xmath306 will represent a production where the head predicate @xmath140 is the label of the edge in the left hand side , and the body @xmath143 is the graph in the right hand side .",
    "term @xmath305 in the head represents the action occurring in @xmath63 , if @xmath307 is the edge matched by the production .",
    "intuitively , the first condition of definition [ defin : syncprograms ] says that the result of a local rewriting must be a goal - graph .",
    "the second condition forbids synchronizations with structured actions , which are not allowed in hshr ( this would correspond to allow an action in a production to synchronize with a sequence of actions from a computation of an adjacent subgraph ) .",
    "furthermore it imposes that we can not disconnect from a node without synchronizing on it .",
    "action on the node we disconnect from and make sure that all the other edges can freely do the same action . for example we can rewrite @xmath308 as @xmath309 , which is an allowed synchronized rule .",
    "an explicit translation of action @xmath265 can be used too . ]",
    "now we will define the subset of computations we are interested in .    given a synchronized program @xmath36",
    "we write : + @xmath310 iff @xmath311{\\theta'}\\operatorname{\\!\\!\\mbox{}^*\\,\\,}g_2 $ ] and all steps performed in the computation expand different atoms of @xmath312 , @xmath313 and both @xmath312 and @xmath314 are goal - graphs .",
    "+ we call @xmath315 a big - step and all the @xmath316 steps in a big - step small - steps . +",
    "a slp computation is : + @xmath317 i.e.  a sequence of 0 or more big - steps .",
    "we want to use slp to model hshr systems . as a first step",
    "we need to translate graphs , i.e.  syntactic judgements , to goals . in this translation ,",
    "edge labels are mapped into slp predicates .",
    "goals corresponding to graphs will have no function symbols .",
    "however function symbols will be used to represent actions . in the translation",
    "we will lose the context @xmath76 .",
    "we define the translation operator @xmath318 as :    @xmath319 @xmath320 @xmath321    sometimes we will omit the @xmath76 part of the syntactic judgement .",
    "we can do this because it does not influence the translation . for simplicity",
    ", we suppose that the set of nodes in the shr model coincides with the set of variables in slp ( otherwise we need a bijective translation function ) .",
    "we do the same for edge labels and names of predicates , and for actions and function symbols .",
    "let @xmath68 and @xmath322 be graphs .",
    "we define the equivalence relation @xmath323 in the following way : @xmath324 iff @xmath325 .",
    "observe that if two judgements are equivalent then they can be written as : + @xmath326 + @xmath327 + where @xmath328 .",
    "the operator @xmath318 defines an isomorphism between judgements ( defined up to @xmath323 ) and goal - graphs .",
    "the proof is straightforward observing that the operator @xmath318 defines a bijection between representatives of syntactic judgements and representatives of goal - graphs and the congruence on the two structures is essentially the same .",
    "we now define the translation from hshr productions to definite clauses .",
    "[ defin : tuostoruletranslation ] we define the translation operator @xmath318 as : @xmath329{\\lambda,\\pi } g \\rrbracket } =   l(a_1(x_1\\pi,\\vec y_1 ) , \\dots , a_n(x_n\\pi,\\vec y_n ) ) \\leftarrow { \\llbracket g \\rrbracket}\\ ] ] if @xmath330 for each @xmath331 and if @xmath332 .",
    "if @xmath333 we write simply @xmath334 instead of @xmath335 .",
    "the idea of the translation is that the condition given by an action @xmath336 is represented by using the term @xmath337 as argument in the position that corresponds to @xmath5 .",
    "notice that in this term @xmath93 is a function symbol and @xmath0 is a substitution . during unification ,",
    "@xmath5 will be bound to that term and , when other instances of @xmath5 are met , the corresponding term must contain the same function symbol ( as required by hoare synchronization ) in order to be unifiable .",
    "furthermore the corresponding tuples of transmitted nodes are unified .",
    "since @xmath5 will disappear we need another variable to represent the node that corresponds to @xmath5 .",
    "we use the first argument of @xmath93 to this purpose .",
    "if two nodes are merged by @xmath0 then their successors are the same as required .",
    "+ observe that we do not need to translate all the possible variants of the rules since variants with fresh variables are automatically built when the clauses are applied .",
    "notice also that the clauses we obtain are synchronized clauses .",
    "+ the observable substitution contains information on @xmath92 and @xmath0 .",
    "thus given a transition we can associate to it a substitution @xmath338 .",
    "we have different choices for @xmath338 according to where we map variables .",
    "in fact in hshr nodes are mapped to their representatives according to @xmath0 , while , in slp , @xmath338 can not do the same , since the variables of the clause variant must be all fresh .",
    "the possible choices of fresh names for the variables change by an injective renaming the result of the big - step .",
    "[ defin : associated2 ] let @xmath126{\\lambda,\\pi } \\phi \\vdash g'$ ] be a transition .",
    "we say that the substitution @xmath339 associated to this transition is : + @xmath340 + for some injective renaming @xmath123 .",
    "we will now prove the correctness and the completeness of our translation .",
    "[ theorem : tuostocorrectness ] let @xmath127 be a set of productions of a hshr system as defined in definitions [ defin : production ] and [ defin : hoarerules ] .",
    "let @xmath36 be the logic program obtained by translating the productions in @xmath127 according to definition [ defin : tuostoruletranslation ] .",
    "if : + @xmath125{\\lambda,\\pi } \\phi   \\vdash g')$ ] + then we can have in @xmath36 a big - step of synchronized logic programming : + @xmath341 + for every @xmath123 such that @xmath342 is a fresh variable unless possibly when @xmath343 . in that case",
    "we may have @xmath344 .",
    "furthermore @xmath345 is associated to @xmath346{\\lambda,\\pi } \\phi \\vdash g'$ ] and @xmath347 .",
    "finally , used productions translate into the clauses used in the big - step and are applied to the edges that translate into the predicates rewritten by them .",
    "the proof is by rule induction .",
    "+ see [ appendix : proofs ] .    [",
    "theorem : tuostocompleteness ] let @xmath127 be a set of productions of a hshr system .",
    "let @xmath36 be the logic program obtained by translating the productions in @xmath127 according to definition [ defin : tuostoruletranslation ] .",
    "if we have in @xmath36 a big - step of logic programming : + @xmath348 + then there exist @xmath123 , @xmath349 , @xmath92 , @xmath0 , @xmath106 and @xmath107 such that @xmath350 is associated to @xmath346{\\lambda,\\pi } \\phi \\vdash g'$ ] .",
    "furthermore @xmath351 and @xmath352{\\lambda,\\pi } \\phi \\vdash g')$ ] .",
    "see [ appendix : proofs ] .",
    "[ ex : fusion2lp ] we continue here example [ ex : fusion2hoare ] by showing how that fusion computation can be translated into a synchronized logic programming computation .",
    "@xmath281 remember that a translation of the starting process is : @xmath284 we have the following productions : @xmath285{(y_1,out_2,\\langle y_2,y_3 \\rangle)}\\\\   y_1,y_2,y_3,y_4,y_5 \\vdash l_{r(x_1,x_2)}(y_4,y_5)|n(y_1)\\end{gathered}\\ ] ] @xmath286{(y_1,in_2,\\langle y_2,y_3 \\rangle)}\\\\   y_1,y_2,y_3,y_4,y_5 \\vdash l_{s(x_1,x_2)}(y_4,y_5)|n(y_1)\\end{gathered}\\ ] ] that corresponds to the clauses ( we directly write suitably renamed variants ) : + @xmath353 + @xmath354 + plus the clause obtained from the auxiliary production : @xmath355 we obtain the big - step represented in figure [ figure : bigstep ] .",
    "@xmath356{out_2(u'_1,x_2,y_2)/u_1,x_2/x'_2,y_2/y'_2,u_2/u'_2,x_3/x'_3}\\\\ l_{q(x_1,x_2,x_3)}(x_1,y_1,z_1),l_{r(x_1,x_2)}(u_2,x_3),n(u'_1 ) , l_{x_1x_2x_3.s(x_4,x_5)}(u_3,z_2,w_1,z_3,w_2),\\\\ m_4(u , out_2(u'_1,x_2,y_2),u_2,u_3),m_4(x , x_1,x_2,x_3),m_3(y , y_1,y_2),\\\\ m_4(z , z_1,z_2,z_3),m_3(w , w_1,w_2),n(u),n(x),n(y),n(w),n(z)\\\\ \\xrightarrow[]{u / u'',u'_1/u''_1,x_2/x''_2,y_2/y''_2,u_2/u''_2,in_2(u''_3,z''_2,w''_1)/u_3}\\\\ l_{q(x_1,x_2,x_3)}(x_1,y_1,z_1),l_{r(x_1,x_2)}(u_2,x_3),n(u'_1),\\\\ l_{x_1x_2x_3.s(x_4,x_5)}(in_2(u''_3,z''_2,w''_1),z_2,w_1,z_3,w_2),\\\\ m_4(u , u'_1,u_2,u''_3),m_2(x_2,z''_2),m_2(y_2,w''_1),m_4(x , x_1,x_2,x_3),m_3(y , y_1,y_2),\\\\ m_4(z , z_1,z_2,z_3),m_3(w , w_1,w_2),n(u),n(x),n(y),n(w),n(z)\\\\ \\xrightarrow[]{u''_3/u'''_3,z_2/z''_2,w_1/w''_1,z_2/z'''_2,w_1/w'''_1,z_3/z'''_3,w_2/w'''_2}\\\\ l_{q(x_1,x_2,x_3)}(x_1,y_1,z_1),l_{r(x_1,x_2)}(u_2,x_3),n(u'_1),l_{s(x_1,x_2)}(z_3,w_2),n(u''_3),\\\\ m_4(u , u'_1,u_2,u''_3),m_2(x_2,z_2),m_2(y_2,w_1),m_4(x , x_1,x_2,x_3),m_3(y , y_1,y_2),\\\\ m_4(z , z_1,z_2,z_3),m_3(w , w_1,w_2),n(u),n(x),n(y),n(w),n(z)\\end{gathered}\\ ] ]    the observable substitution of the big - step is @xmath357 .",
    "this is associated to the wanted hshr transition with @xmath358 and by applying @xmath123 to the final graph of the hshr transition we obtain : @xmath359 that , translated , becomes the final goal of the big - step as required .",
    "we end this section with a simple schema on the correspondence between the two models .",
    "+    l|l|l|l hshr & slp & hshr & slp + graph & goal & transition & big - step + edge & atomic goal & node & variable + parallel comp .",
    "& and comp . &",
    "@xmath303 & @xmath141 + production & clause & action & function s. +    essentially the correspondence is given by the homomorphism between graphs and goals , with edges mapped to atomic goals , nodes to variables , parallel composition to and composition and @xmath65 to @xmath141 .",
    "dynamically , hshr transitions are modelled by big - steps , that are transactional applications of clauses which model productions .",
    "finally , hshr actions are modelled by function symbols .",
    "the theorems seen in the previous sections can be used for implementation purposes . as far as synchronized logic programming is concerned , in a simple meta - interpreter",
    "is presented .",
    "the idea is to use prolog ability of dynamically changing the clause database to insert into it a set of clauses and a goal and to compute the possible synchronized computations of given length .",
    "this can be directly used to simulate hshr transitions . in order to simulate fusion calculus processes we have to implement amoeboids using a bounded number of different connectors (",
    "note that @xmath234 , @xmath360 and @xmath158 are enough ) and to implement in the meta - interpreter the condition under which productions can be applied in a single big - step .",
    "this can be easily done .",
    "furthermore this decreases the possible choices of applicable productions and thus improves the efficiency w.r.t .  the general case .",
    "in this paper we have analyzed the relationships between three different formalisms , namely fusion calculus , hshr and logic programming .",
    "the correspondence between hshr and the chosen transactional version of logic programming , slp , is complete and quite natural .",
    "thus we can consider hshr as a `` subcalculus '' of ( synchronized ) logic programming .",
    "the mapping between fusion calculus and hshr is instead more involved because it has to deal with many important differences :    * process calculi features vs graph transformation features ; * interleaving models vs concurrent models ; * milner synchronization vs hoare synchronization .",
    "hoare synchronization was necessary since our aim was to eventually map fusion calculus to logic programming .",
    "if the aim is just to compare fusion calculus and shr it is possible to use shr with milner synchronization , achieving a much simpler and complete mapping , which considers the lts of fusion calculus instead of reductions ( see ) .",
    "+ we think that the present work can suggest several interesting lines of development , dictated by the comparison of the three formalisms studied in the paper .",
    "first , our implementation of routers in terms of amoeboids is rather general and abstract , and shows that fusion calculus names are a rather high level concept .",
    "they abstract out the behaviour of an underlying network of connections which must be open and reconfigurable .",
    "had we chosen @xmath0-calculus instead ( see a translation of @xmath0-calculus to milner shr in @xcite ) , we would have noticed important differences .",
    "for instance , fusions are also considered in the semantics of _ open _",
    "@xmath0-calculus by davide sangiorgi @xcite , but in that work not all the names can be fused : newly extruded names can not be merged with previously generated names .",
    "this is essential for specifying nonces and session keys for secure protocols .",
    "instead , fusion calculus does not provide equivalent constructs .",
    "looking at our translation , we can conclude that logic programming does not offer this feature , either .",
    "thus logic programming is a suitable counterpart of fusion calculus , but it should be properly extended for matching open @xmath0-calculus and security applications .    in a similar line of thought , we observe that we have a scope restriction operator in the fusion calculus , but no restriction is found in our version of hshr .",
    "we think this omission simplifies our development , since no restriction exists in ordinary logic programming , either",
    ". however versions of shr with restriction have been considered @xcite .",
    "also ( synchronized ) logic programming can be smoothly extended with a restriction operator @xcite .",
    "more importantly , fusion calculus is equipped with an observational abstract semantics based on ( hyper ) bisimulation .",
    "we did not consider a similar concept for shr or logic programming , since we considered it outside the scope of the paper .",
    "furthermore our operational correspondence between hshr and slp is very strong and it should respect any reasonable abstract semantics .",
    "the mapping from fusion calculus into hshr deals only with closed terms , thus no observations can be considered .",
    "however a bisimulation semantics of shr has been considered in @xcite , and an observational semantics of logic programming is discussed in @xcite .",
    "another comment concerns concurrency . to prove the equivalence of fusion calculus and of its translation into hshr we had to restrict the possible computations of the latter . on the contrary , if all computations were allowed , the same translation would yield a concurrent semantics of fusion calculus , that we think is worth studying .",
    "for instance in the presence of concurrent computations not all equivalent amoeboids would have the same behaviour , since some of them would allow for more parallelism than others .",
    "finally we would like to emphasize some practical implication of our work .",
    "in fact , logic programming is not only a model of computation , but also a well developed programming paradigm . following the lines of our translation ,",
    "implementations of languages based on fusion calculus and hshr could be designed , allowing to exploit existing ideas , algorithms and tools developed for logic programming .",
    "zero - safe nets : comparing the collective and individual token approaches .",
    "_ 156 , _  1 - 2 , 4689 .    , montanari , u. , and rossi , f. 2001 .",
    "an interactive semantics of logic programming .",
    "_ 1 , _  6 , 647690 .",
    "\\1987 . a model for distributed systems based on graph rewriting .",
    "_ 34 , _  2 , 411449 .    ,",
    "kreowski , h .- j . ,",
    "montanari , u. , and rozenberg , g. , eds . 1999 . .",
    "world scientific .    ,",
    "pfender , m. , and schneider , h.  j. 1973 .",
    "graph grammars : an algebraic approach . in _ proc . of ieee conference on automata and switching theory_. ieee computer society , 167180 .    , montanari , u. , and tuosto , e. 2001 .",
    "a lts semantics of ambients via graph synchronization with mobility . in _ proc . of ictcs01_. lncs ,",
    "springer , 116 .",
    ". explicit fusions . in _ mathematical foundations of computer science_. 373382 .    \\2004 .",
    "strong bisimulation for the explicit fusion calculus . in _ proc . of fossacs04_. lncs ,",
    "springer , 484498 .",
    "graph transformation models for software architecture styles .",
    "thesis , departamento de computacin , facultad de ciencias exactas y naturales , universidad de buenos aires , argentina .",
    ", inverardi , p. , and montanari , u. 2000 .",
    "reconfiguration of software architecture styles with name mobility . in _ proc . of coordination",
    "2000_. lncs , vol .",
    "springer , 148163 .",
    "\\2001 . synchronized hyperedge replacement with name mobility . in _ proc . of concur01_. lncs ,",
    "springer , 121136 .",
    "bigraphs and transitions .",
    "_ 38 , _  1 , 3849 .",
    "observational equivalence for synchronized graph rewriting . in _ proc . of tacs01_. lncs ,",
    "springer , 145164 .",
    "process synchronization in distributed systems via horn clauses .",
    "thesis , computer science department , university of pisa , pisa , italy .",
    "downloadable from ` http://www.di.unipi.it/~lanese/tesi.ps ` .",
    "synchronization strategies for global computing models . ph.d .",
    "thesis , computer science department , university of pisa , pisa , italy .",
    "forthcoming .",
    "software architectures , global computing and graph transformation via logic programming . in _",
    "proc sbes2002 - 16th brazilian symposium on software engineering_. anais , 1135 .",
    "2004a . a graphical fusion calculus . in _ proc",
    "of the workshop of the cometa project on computational metamodels_. electronic notes in theoretical computer science , vol .",
    "elsevier science , 199215 .    2004b .",
    "synchronization algebras with mobility for graph transformations . in _ proc . of fguc04",
    " foundations of global ubiquitous computing_. electronic notes in theoretical computer science , vol . 138 .",
    "elsevier science , 4360 .",
    "springer .    , parrow , j. , and walker , d. 1992 . a calculus of mobile processes .",
    "_ 100 _ , 177 .",
    "algebraic properties of idempotent substitutions . in _ proc . of icalp90_. lncs , vol . 443 .",
    "springer , 386399 .",
    "the fusion calculus : expressiveness and symmetry in mobile processes . in _ proc . of lics",
    "98_. ieee , computer society press .",
    "\\1993 . a theory of bisimulation for the pi - calculus . in _ proc .",
    "of concur93_. lncs , vol . 715 .",
    "springer , 127142 .",
    "the fusion calculus : expressiveness and symmetry in mobile processes .",
    "thesis , dept .  of computer systems , uppsala university ,",
    "we have here the proofs that are missing in the main part and some lemmas used in these proofs .",
    "lemmas are just before the proofs that use them .",
    "notice that all the auxiliary productions perform two non trivial actions , and because of hoare synchronization and because each node is shared by at most two edges , synchronizing edges form chains .",
    "there are two alternatives : each chain either starts and begins on an external node , or it is a cycle that contains only internal nodes .",
    "exactly one chain must be of the first type .",
    "in fact if we have no chain of that kind we have only trivial actions on nodes in @xmath16 .",
    "also , if we have more than one , we have more than two non trivial actions on nodes in @xmath16 .",
    "thanks to the last condition of definition [ defin : structured ] this chain contains an odd number of connectors , which must be @xmath260 connectors .",
    "one can easily check by induction on the ( odd ) length of the chain that the transition creates an amoeboid @xmath361,\\vec y_2[i])$ ] for each component of vectors @xmath362 and @xmath255 of fresh names and that these vectors are exposed on the external nodes together with an @xmath363 and an @xmath364 action , where @xmath365 .",
    "let us now consider the other kind of chains : these chains produce rings of @xmath234 edges connected only to fresh nodes , which thus correspond to isolate subgraphs .",
    "furthermore , they affect only the labels of internal nodes as required .",
    "since we are working up to injective renamings we only have to prove that two names are connected by @xmath367}_{i=1 \\dots n } m(x_i , y_i)$ ] iff they are merged by @xmath368 and that all the paths connecting external nodes in the final graph have odd length . by definition",
    "two names are connected by @xmath186 iff they are merged by @xmath2 .",
    "assume that two names @xmath5 and @xmath369 are merged by @xmath368 .",
    "then their images along @xmath2 are merged by @xmath338 .",
    "this means that we have in @xmath28 a chain of equalities from @xmath370 to @xmath371 .",
    "thus we have amoeboids connecting the amoeboids of @xmath370 and of @xmath371 , thus @xmath5 and @xmath369 are connected .",
    "assume now that @xmath5 and @xmath369 are connected .",
    "then there exists an amoeboid connecting the amoeboids for @xmath370 and for @xmath371 .",
    "thus @xmath338 merges @xmath370 and @xmath371 as required .",
    "finally note that all the paths between external nodes are created by connecting existing paths via new amoeboids .",
    "in particular , each new path is composed by @xmath158 old paths and @xmath372 new amoeboids .",
    "thus its length is the sum of @xmath373 odd lengths and thus it is odd .      in order for that process to be in the standard form we just need to make @xmath374 sequential by unfolding recursion and taking bound names to the outside if required . for simplicity , we show just the case where @xmath374 is already sequential , the other being essentially equal .",
    "@xmath390{(u'_1,in_{|\\vec x'|},\\vec x ' ) } \\vec p_1,\\vec x',\\vec v_p \\vdash { \\llbracket p \\rrbracket}_{\\vec v_p,\\vec w_p}|\\operatorname{\\big[\\!\\!\\big]}_{x \\in \\gamma''_p } n(x)\\ ] ] @xmath391{(u'_2,out_{|\\vec y'|},\\vec y ' ) } \\vec q_1,\\vec y',\\vec v_q \\vdash { \\llbracket q \\rrbracket}_{\\vec v_q,\\vec w_q}|\\operatorname{\\big[\\!\\!\\big]}_{x \\in \\gamma''_q } n(x)\\ ] ]",
    "the choice of the parameters @xmath392 and @xmath393 is not important since they are fresh names and we work up to injective renamings .",
    "the choice of @xmath394 and @xmath395 is important instead , since they have to correspond to the nodes in the lhs that are still used by the process .",
    "the choice performed in definition [ defin : processprod ] ensures that .    note",
    "that @xmath396 contains an amoeboid for a set @xmath397 with @xmath398 .",
    "thus from lemma [ lemma : amoeboid ] the two above productions can synchronize via the amoeboid . using rule ( idle ) for the other edges , we obtain as a result :    @xmath399}_{x \\in \\gamma''_p } n(x)|{\\llbracket q \\rrbracket}_{\\vec v_q,\\vec",
    "w_q}|\\operatorname{\\big[\\!\\!\\big]}_{x \\in \\gamma''_q } n(x)|{\\llbracket \\theta \\rrbracket}|\\operatorname{\\big[\\!\\!\\big]}_{x \\in \\vec v } n(x)| \\\\",
    "\\operatorname{\\big[\\!\\!\\big]}_{i=1 \\dots     note that the fusion @xmath0 of the transition is the identity since each synchronization involves two edges , and at least one of them is an amoeboid which exposes fresh names .",
    "furthermore amoeboids expose each fresh name twice .",
    "thus no names in @xmath76 are merged .",
    "also , in the final graph each node is shared by two edges .",
    "in fact , the only connections whose cardinality is not preserved by productions are the ones between nodes whose references are exposed , namely @xmath400 and @xmath401 , and the corresponding process edges , but these nodes are connected to the new @xmath402 amoeboids created by the auxiliary productions .    in particular , @xmath169}_{x \\in \\gamma''_p } n(x)|\\operatorname{\\big[\\!\\!\\big]}_{x \\in \\gamma''_q } n(x)|{\\llbracket \\theta \\rrbracket}$ ] is an amoeboid for @xmath403 .",
    "furthermore thanks to lemma [ lemma : amoeboidconn ] by adding in parallel @xmath169}_{i=1 \\dots          the rhs of the fusion rule is @xmath406 , which has to be normalized into @xmath407 with @xmath408 and @xmath409 .",
    "furthermore we can choose the names ( since we are reasoning up to injective renamings ) in such a way that @xmath410 ( plus an injective renaming on names in @xmath411 and @xmath393 which corresponds to an equivalence on the resulting amoeboids ) .",
    "in particular , @xmath169}_{x \\in \\gamma''_p } n(x)|{\\llbracket \\theta \\rrbracket}$ ] is an amoeboid for @xmath418 .",
    "furthermore , note that @xmath186 has the form @xmath169}_{i=1 \\dots",
    "n } m_2(x_{i},y_{i})$ ] and thus thanks to lemma [ lemma : amoeboidconn ] by adding it in parallel we obtain an amoeboid for @xmath419 .",
    "the rhs of the fusion rule is @xmath421 , which has to be normalized into @xmath422 with @xmath408 .",
    "furthermore we can choose the names ( since we are reasoning up to injective renamings ) in such a way that @xmath423 ( plus an injective renaming on names in @xmath392 which corresponds to an equivalence on the resulting amoeboids ) .",
    "@xmath59 equivalent agents are converted into the same representative ( up to @xmath45-conversion ) before being translated , thus the translation of @xmath36 and @xmath153 are equal up to injective renamings .",
    "similarly for the translation of @xmath425 and @xmath426 , thus the thesis follows .",
    "[ lemma : det ] given a graph @xmath68 and one or zero productions for each edge in @xmath70 let : + @xmath126{\\lambda_1,\\pi_1 } \\phi_1 \\vdash g'_1 $ ] + @xmath126{\\lambda_2,\\pi_2 } \\phi_2 \\vdash g'_2 $ ] + be two transitions obtained by applying the chosen production for each edge ( and using the ( idle ) rule if no production is chosen ) .",
    "then there exists an injective renaming @xmath2 such that :      the proof is a simple rule induction if one proves that derivations can be done in a standard way , namely by applying to the axioms first rules ( par ) , then rule ( merge ) and finally rules ( new )",
    ". this can be proved by showing that one can exchange the order of rules and that one can substitute two applications of ( merge ) with substitutions @xmath2 and @xmath435 with just one application with substitution @xmath436 .",
    "we have many cases to consider , but they are not so interesting . as examples we will show the detailed proof for commutation of rule ( merge ) and ( par ) and for composition of two different rules ( merge ) .",
    "@xmath437{\\lambda_1 \\cup \\lambda ' , \\pi_1 \\cup \\pi ' } \\phi_1 , \\phi ' \\vdash g_2\\sigma\\rho|g'_2 }     { \\infer         { \\gamma\\sigma \\vdash g_1\\sigma \\xrightarrow[]{\\lambda_1 , \\pi_1 } \\phi_1 \\vdash g_2\\sigma\\rho }          { \\gamma \\vdash g_1 \\xrightarrow[]{\\lambda , \\pi } \\phi \\vdash g_2 }     & \\gamma ' \\vdash g'_1 \\xrightarrow[]{\\lambda ' , \\pi ' } \\phi ' \\vdash g'_2     } \\ ] ]    where for readability we have not written explicitly the side conditions ( see definition [ defin : hoarerules ] ) . then we must also have a derivation for the same transition obtained applying rule ( par ) first and then rule ( merge ) :    @xmath438{\\lambda '' , \\pi '' } \\phi '' \\vdash ( g_2|g'_2)\\sigma\\rho ' }     { \\infer{\\gamma , \\gamma ' \\vdash g_1|g'_1 \\xrightarrow[]{\\lambda \\cup \\lambda ' , \\pi \\cup \\pi ' } \\phi , \\phi ' \\vdash g_2|g'_2 }          { \\gamma \\vdash g_1 \\xrightarrow[]{\\lambda , \\pi } \\phi \\vdash g_2 & \\gamma ' \\vdash g'_1 \\xrightarrow[]{\\lambda ' , \\pi ' } \\phi ' \\vdash g'_2 }     } \\ ] ]    we have to prove that this derivation is allowed and that the resulting transition is the one derived also by derivation [ eqn : merge - par ] .",
    "the first step is allowed iff @xmath439 . since the first derivation is allowed by hypothesis , then @xmath440 .",
    "thus the only problem is when a name which is after renamed ( by @xmath2 or @xmath123 ) creates a conflict . in that case",
    "thanks to lemma [ lemma : injren ] we can suppose to start with a different name . the final result of the derivation is not changed by that since the name disappears .",
    "thus the first step is legal .    for the second step",
    "we need @xmath441 . note that",
    "since @xmath439 and @xmath442 , we have that @xmath2 is the identity on @xmath230 , thus the only @xmath443 such that @xmath444 are in @xmath76 , thus the condition is satisfied since it was satisfied in derivation [ eqn : merge - par ] .",
    "furthermore we have @xmath445 and @xmath446 .",
    "we must now consider @xmath447 .",
    "we have : latexmath:[\\[\\rho ' = \\operatorname{mgu}(\\{(\\operatorname{n}_{\\lambda \\cup \\lambda'}(x))\\sigma= ( \\operatorname{n}_{\\lambda \\cup \\lambda'}(y))\\sigma|x\\sigma= y\\sigma \\ } \\cup \\ { x\\sigma = y\\sigma              @xmath456{\\lambda '' , \\pi '' } \\phi '' \\vdash g_2\\sigma\\rho\\sigma'\\rho ' }     { \\infer{\\gamma\\sigma \\vdash g_1\\sigma \\xrightarrow[]{\\lambda ' , \\pi ' } \\phi ' \\vdash g_2\\sigma\\rho }          { \\gamma \\vdash g_1 \\xrightarrow[]{\\lambda , \\pi } \\phi \\vdash g_2 }     } \\ ] ]        first of all we have to prove that the step is allowed .",
    "the required condition is that @xmath459 .",
    "we have two cases . if @xmath52 then the thesis follows from the analogous condition of the first step of derivation [ eqn : merge - merge ] .",
    "otherwise we can rewrite the condition as @xmath460 .",
    "note that @xmath461 thus we can rewrite the condition as @xmath462 what is the condition for the second step of derivation [ eqn : merge - merge ] .",
    "we add some explanations for that ( long ) sequence of equations .",
    "step @xmath160 is just the definition of @xmath468 .",
    "step @xmath469 is allowed by lemma [ lemma : mgusubst ] .",
    "step @xmath470 is a simple mathematical transformation .",
    "step @xmath471 applies the definition of @xmath123 .",
    "step @xmath472 is lemma [ lemma : mgusubst ] again .",
    "step @xmath473 creates a new @xmath123 on the outside using idempotence , then it brings it inside using lemma [ lemma : mgusubst ] and uses idempotence again to delete it where it is not necessary .",
    "it uses the definition of @xmath474 too .",
    "step @xmath475 is lemma [ lemma : mgusubst ] again .",
    "steps @xmath476 and @xmath477 are trivial mathematics .",
    "step @xmath478 is another application of lemma [ lemma : mgusubst ] .",
    "finally , step @xmath479 is justified since the names in the domain of @xmath480 are neither in the domain of @xmath435 ( since otherwise they would be in @xmath124 ) nor in the domain of @xmath447 ( since @xmath447 is computed after having applied @xmath123 , which is idempotent ) .",
    "thus an allowed @xmath481 is a subset of @xmath482 which can be deleted by idempotence .      in order to apply them",
    "we need two sequential process edges to be rewritten .",
    "each production needs to be synchronized with at least another one since each node is shared by exactly two edges . since process edges are connected only through amoeboids we can have a synchronization only if the two actions done by process edges are equal to two actions allowed by amoeboids .",
    "thanks to lemma [ lemma : amoeboid ] , they must be two complementary actions , i.e.  an @xmath363 and an @xmath364 . furthermore they have to be done on the same amoeboid , that is on two names merged by the substitution @xmath2 corresponding to the amoeboids .",
    "we must have @xmath487 and @xmath488 ( or swapped ) with @xmath489 .",
    "furthermore @xmath2 merges @xmath287 and @xmath490 thus we have a transition @xmath278 that corresponds to the synchronized execution of the two prefixes .    the productions to be applied are thus forced except for the ones inside the amoeboids , but the only difference among the choices ( as shown by lemma [ lemma : amoeboid ] ) amounts to pseudoamoeboids and exchanges between equivalent amoeboids in the result . from lemma [ lemma : det ] we know that the result of a transition is determined up to injective renamings ( and actions on isolated nodes ) by the starting graph and the productions chosen . thus the transition that corresponds to @xmath272 for theorem [ theorem : hoarecorrectness ] is equal up to injective renamings to a transition that differs from @xmath491{\\lambda , id } \\gamma ' \\vdash g$ ] only for pseudoamoeboids and substitutions of equivalent amoeboids . the thesis follows .",
    "we want to build a big - step where the clause unified with @xmath493 is @xmath494 , if any ( some @xmath493 may not be replaced , in that case as notation we use @xmath495 ) . as a notational convention we use @xmath496 to denote the arguments of @xmath493 and @xmath497 to denote the jth argument of @xmath498 if it is a complex term and @xmath499 if it is a variable ( note that we have different names for the same variable , one for each occurrence ) . all these are undefined if @xmath493 is not replaced , @xmath500 and @xmath501 are undefined also if the jth argument of @xmath498 is a variable",
    ".            @xmath508,\\vec { [ y'_{i , j}]})/x_{i , j } | a_{i , j } \\textrm { is defined}\\ } \\cup \\ { [ v_k]/v_k | ( v_k = x'_{i , j } \\lor v_k=\\vec y'_{i , j}[l ] \\lor ( v_k = x_{i , j } \\land a_{i , j } \\textrm { is undefined } ) ) \\land [ v_k ] \\neq v_k \\}$ ]          we will prove a more general result by induction on the number of `` considered '' atoms , that is we consider an increasing chain of derivations , and considered atoms are the ones that , if expanded in the complete derivation , have already been expanded . for simplicity ,",
    "atoms are considered in numeric order , i.e.  at step @xmath260 atoms @xmath511 have already been considered , and atom @xmath512 becomes considered .",
    "we will prove that a computation of the form @xmath513{\\theta } \\operatorname{\\!\\!\\mbox{}^*\\,\\,}g_1,\\dots , g_n$ ] where we substitute only atoms in the starting goal and where the atoms generated by considered atoms do not contain function symbols exists iff : + @xmath514 and that furthermore :    * @xmath508',\\vec { [ y'_{i , j}]'})/x_{i , j } | a_{i , j }   \\textrm { is defined } \\land i \\leq m\\ } \\cup \\ { [ v_k]'/v_k | ( v_k   = x'_{i , j } \\lor v_k=\\vec y'_{i , j}[l ] \\lor ( v_k = x_{i , j } \\land a_{i , j } \\textrm { is undefined } ) ) \\land [ v_k ] ' \\neq v_k\\}$ ] ; * @xmath515 ;        base case , @xmath518 ) we have the following transition : + @xmath519{\\theta_1 } ( b_1,a_2,\\dots , a_n ) \\theta_1 $ ] + where @xmath427 is an mgu of @xmath520 .",
    "this transition exists iff @xmath427 exists .",
    "+ we have : + @xmath521 .",
    "+ note that if @xmath522 then the mgu does not exist ( if @xmath500 and @xmath523 are both defined , otherwise they have to be both undefined since if just one of them is defined then a function symbol will remain in the considered part against the hypothesis ) .",
    "thus we have : + @xmath526'=v_k|[v_k ] ' \\neq v_k\\})$ ] .",
    "+ to have the real mgu we just need to apply @xmath516 to the equations in the first part ( note that @xmath527 is unified with some other variable only if @xmath528 is undefined thus the domain variables of the first part are not changed ) .",
    "+ this proves the first part since this mgu exists and the second one since it has the wanted form . +",
    "the third part follows from the observation that @xmath529 .",
    "inductive case , @xmath530 ) assume that @xmath531{\\theta_g } \\operatorname{\\!\\!\\mbox{}^*\\,\\,}g_1,\\dots , g_n$ ] is a logic computation where we substitute only atoms in the starting goal , where atoms @xmath532 are considered and where the atoms generated by them do not contain function symbols .        * @xmath508,\\vec { [ y'_{i , j}]})/x_{i , j } | a_{i , j }   \\textrm { is defined } \\land i \\leq m \\ }",
    "\\cup \\ { [ v_k]/v_k | ( v_k =   x'_{i , j } \\lor v_k=\\vec y'_{i , j}[l ] \\lor ( v_k = x_{i , j } \\land a_{i , j } \\textrm { is   undefined } ) ) \\land [ v_k ] \\neq v_k\\}$ ] ; + * @xmath533 .",
    "we will now consider the atom @xmath534 .",
    "if it is not substituted then the thesis follows trivially ( note that @xmath534 does not contain variables substituted with a complex term by @xmath338 , since this can happen only if we have @xmath535 with @xmath536 , @xmath537 defined and @xmath538 undefined , and this is forbidden ; thus we have @xmath539 ) .",
    "let us consider the case in which it is substituted .",
    "we will have a small step of the form : + @xmath540{\\theta ' } ( \\   g_1,\\dots , g_{m+1},a_{m+2},\\dots , a_n)\\theta\\theta'$ ] + where @xmath541 ( note that we can assume that @xmath338 is also applied to @xmath542 since we can assume @xmath543 ) .",
    "we have : @xmath544 for each binding we must consider two cases : either the variable @xmath545 appears in already considered atoms ( we call it an _ old variable _ ) or it does not ( we call it a _ new variable _ ) . in the second case",
    "@xmath338 is the identity on that variable . in the first case",
    "if @xmath546 is defined then the mgu exists iff we have @xmath547 where @xmath548 is the function symbol in the binding for @xmath545 in @xmath338 .",
    "note that if @xmath548 is undefined then also @xmath546 must be undefined otherwise the function symbol remains in the final goal .",
    "thus we will have : @xmath549,\\vec { [ y'_{p , q } ] } ) = a_{m+1,j}(x'_{m+1,j},\\vec y'_{m+1,j})|a_{m+1,j } \\textrm { is defined } \\land \\\\",
    "\\land x_{p , q}=x_{m+1,j } \\land x_{m+1,j } \\textrm { is old } \\ } \\cup \\{[x_{m+1,j}]=x'_{m+1,j}|a_{m+1,j } \\textrm { is undefined}\\ } \\cup \\\\ \\cup \\ { x_{m+1,j}=a_{m+1,j}(x'_{m+1,j},\\vec y'_{m+1,j})|a_{m+1,j } \\textrm { is defined } \\land x_{k+1,j } \\textrm { is new}\\}=\\\\ = \\operatorname{mgu}(\\ { [ x'_{p , q}]=x'_{m+1,j } , \\vec{[y'_{p , q}]}=\\vec y'_{m+1,j}|a_{m+1,j } \\textrm { is defined } \\land \\\\",
    "\\land x_{p , q}=x_{m+1,j } \\land x_{m+1,j } \\textrm { is old } \\ }",
    "\\cup \\{[x_{m+1,j}]=x'_{m+1,j}|a_{m+1,j } \\textrm { is undefined}\\ } \\cup \\\\ \\cup \\ { x_{m+1,j}=a_{m+1,j}(x'_{m+1,j},\\vec y'_{m+1,j})|a_{m+1,j } \\textrm { is defined } \\land x_{m+1,j } \\textrm { is new}\\}\\end{gathered}\\ ] ] where we use @xmath550 $ ] to denote the representative of the equivalence class according to @xmath338 .",
    "we can reorder this substitution into : @xmath551=x'_{m+1,j } ,   \\vec{[y'_{p , q}]}=\\vec y'_{m+1,j}|a_{k+1,j } \\textrm { is defined } \\land\\\\ \\land x_{p , q}=x_{m+1,j } \\land x_{m+1,j } \\textrm { is old } \\ } \\cup   \\{[x_{m+1,j}]=x'_{m+1,j}|a_{m+1,j } \\textrm { is undefined}\\}\\end{gathered}\\ ] ] note that the second part is a renaming that does not involve variables in the domain of the first part . thus we can define new equivalence classes @xmath550'$ ] according to this substitution @xmath516 and put the substitution in the resolved form : @xmath552',[\\vec y'_{m+1,j}]')|a_{m+1,j }   \\textrm { is defined } \\land x_{m+1,j } \\textrm { is new}\\ } \\cup \\\\ \\cup \\ { [ v_k]'=v_k|[v_k ] ' \\neq v_k\\})\\end{gathered}\\ ] ] thus the mgu exists and the first part of the thesis is proved .",
    "let us consider the substitution @xmath553 .",
    "note that the renaming part of @xmath349 substitutes variables according to the equivalence between variables in the @xmath554 and representatives of the corresponding variables in @xmath534 thus the composed substitution @xmath555 maps each variable to the representative of the equivalence class that is defined by the union of the two sets of equations as required .",
    "furthermore bindings with complex terms ( the first part of the substitution ) have disjoint domains and thus the union of them is made .",
    "bindings coming from @xmath349 have already the wanted representatives in the image , while to bindings in @xmath338 the renaming is applied , mapping variables into the representatives of their equivalence classes .",
    "thus @xmath556 has the wanted form w.r.t .",
    "the equivalence classes determined by all the equivalences on variables .      note that this result does not depend on the order of application of clauses and that after having chosen which clauses to apply and to which atoms it is deterministic up to an injective renaming ( which depends on the choice of names for new variables and on the choice of representatives for the equivalence classes ) .",
    "we can have an applicable variant of this clause for each injective renaming @xmath123 that maps each variable to a fresh one .",
    "let us consider the goal : + @xmath565 + it unifies with the clause variant : + @xmath566 + with mgu @xmath339 : + @xmath567 .",
    "+ note that @xmath568 .",
    "we can see that @xmath339 is associated to @xmath569{\\lambda,\\pi } \\phi \\vdash g$ ] as required .",
    "observe also that the result of the computation is : + @xmath570 + because @xmath571 .",
    "this proves the thesis . to deal with the missing possibilities for @xmath123 w.r.t .",
    "the theorem statement note that bindings in the last part of @xmath339 can also be resolved also as @xmath572 . in that case",
    "we have no binding for @xmath63 in @xmath339 .",
    "this is equivalent to defining @xmath573 , and this covers the missing cases for @xmath123 .",
    "rule ( par ) ) @xmath574{\\lambda , \\pi } \\phi \\vdash g_2 \\quad \\gamma ' \\vdash g'_1 \\xrightarrow[]{\\lambda',\\pi ' } \\phi ' \\vdash g'_2 \\quad ( \\gamma \\cup \\phi ) \\cap ( \\gamma ' \\cup \\phi')=\\emptyset}{\\gamma , \\gamma ' \\vdash g_1|g'_1 \\xrightarrow[]{\\lambda \\cup \\lambda ' , \\pi \\cup \\pi ' } \\phi , \\phi ' \\vdash g_2|g'_2}\\ ] ]      * @xmath575 + where @xmath339 is associated to @xmath576{\\lambda,\\pi } \\phi \\vdash g_2 $ ] and @xmath577 ; * @xmath578 + where @xmath579 is associated to @xmath580{\\lambda',\\pi ' } \\phi ' \\vdash g'_2 $ ] and @xmath581 .    in both cases by inductive hypothesis we used as clauses the translations of the productions used in the proof of the hshr transition applied to the translations of the edges on which the productions were applied .",
    "+ thanks to lemma [ lemma : injren ] we can assume that the sets of variables used in the two computations are disjoint .",
    "thanks to lemma [ lemma : bigstep ] we know that these big - steps exist iff @xmath582 . since the used variable sets are disjoint the same condition guarantees the existence of a big - step of the form : + @xmath583{\\theta_{\\rho}\\theta'_{\\rho ' } } \\operatorname{\\!\\!\\mbox{}^*\\,\\,}t , t'$ ] + where we used as clauses the unions of the clauses used in the two smaller computations , applied to the same predicates .",
    "rule ( merge ) ) @xmath574{\\lambda ,   \\pi } \\phi \\vdash g_2 \\quad \\forall x , y \\in \\gamma .",
    "x\\sigma = y\\sigma \\wedge x \\neq y \\rightarrow \\operatorname{act}_{\\lambda}(x ) = \\operatorname{act}_{\\lambda}(y)}{\\gamma\\sigma \\vdash g_1\\sigma   \\xrightarrow[]{\\lambda ' , \\pi ' } \\phi ' \\vdash g_2\\sigma\\rho_g}\\ ] ] where @xmath117 is an idempotent substitution and :      where we used @xmath591 instead of @xmath123 to avoid confusion with the injective renaming @xmath123 . for inductive hypothesis",
    "we have : + @xmath575 + where @xmath339 is associated to @xmath576{\\lambda,\\pi } \\phi \\vdash g_2 $ ] and @xmath577 and we used as clauses the translations of the productions used in the proof of the hshr transition applied to the translations of the edges on which the productions were applied .",
    "* @xmath592 + @xmath593 + * @xmath508,\\vec { [ y'_{i , j}]})/x_{i , j } | a_{i , j }   \\textrm { is defined}\\ } \\cup \\ { [ v_k]/v_k | ( v_k = x'_{i , j } \\lor   v_k=\\vec y'_{i , j}[l ] \\lor ( v_k = x_{i , j } \\land a_{i , j } \\textrm { is undefined } ) )   \\land [ v_k ] \\neq v_k \\}$ ] + * @xmath594        we want to find a big - step that uses the same clauses of the previous one applied to the same atoms , but starting from this new goal .",
    "we will use an overline to denote the components of the new big - step .",
    "thanks to lemma [ lemma : bigstep ] such a big - step exists iff : + @xmath597 + but if @xmath598 this has already been proved , otherwise this is guaranteed by the applicability conditions of the rule .",
    "we have to prove that @xmath599 is associated to : + @xmath600{\\lambda ' , \\pi ' } \\phi '   \\vdash g_2\\sigma\\rho_g$ ] .",
    "+ from lemma [ lemma : bigstep ] we have : + @xmath601',\\vec   { [ y'_{i , j}]'})/x_{i , j}\\sigma | a_{i , j } \\textrm { is defined}\\ } \\cup \\ {   [ v_k]'/v_k | ( v_k = x'_{i , j } \\lor v_k=\\vec y'_{i , j}[l ] \\lor ( v_k = x_{i , j } \\land   a_{i , j } \\textrm { is undefined } ) ) \\land [ v_k ] ' \\neq v_k \\}$ ] + where @xmath550'$ ] maps each variable to the representative of the equivalence class given by : @xmath602 is never unified with a primed variable unless @xmath500 is undefined .      from the hypothesis and from lemma",
    "[ lemma : mgusubst ] we have that @xmath607 .",
    "the first and the third part are equal ( adding primes ) to the equations for @xmath550'$ ] . as far as the second part is concerned , @xmath123 maps variables merged by @xmath0 to the same primed variable , thus these equations become trivial .          rule ( new ) ) @xmath574{\\lambda,\\pi }   \\phi \\vdash g_2 \\quad x \\notin \\gamma \\quad \\vec y \\cap ( \\gamma \\cup \\phi \\cup \\{x\\})= \\emptyset}{\\gamma , x \\vdash g_1 \\xrightarrow[]{\\lambda \\cup   \\{(x , a,\\vec y)\\},\\pi } \\phi ' \\vdash g_2}\\ ] ] for inductive hypothesis we have in @xmath36 the following big - step of synchronized logic programming : + @xmath612{\\theta_{\\rho } } \\operatorname{\\!\\!\\mbox{}^*\\,\\,}t$ ] + where @xmath339 is associated to : + @xmath613{\\lambda,\\pi } \\phi \\vdash g_2 $ ] + and @xmath614 but because @xmath615 we have that @xmath339 is also associated to : + @xmath616{\\lambda \\cup \\{(x , a,\\vec y)\\},\\pi }   \\phi ' \\vdash g_2 $ ] + the thesis follows .",
    "the translation @xmath617 can be written in the form @xmath492 where the @xmath618 are translations of single edges .",
    "we want to associate a hshr production to each @xmath493 . for edges associated to atoms that are rewritten in @xmath619",
    "we use an instance of the axiom that corresponds to the clause used to rewrite it , otherwise the rule obtained from rule ( idle ) applied to that edge and to nodes that are all distinct .",
    "let @xmath620 be the heads of these rules .",
    "we choose the names in the following way : for each first occurrence of a variable in @xmath492 we use the same name for the node in the corresponding position , we use new names for all other occurrences .",
    "note that there exists a substitution @xmath2 such that @xmath621 and that @xmath2 is idempotent .",
    "note also that for each @xmath21 all names in @xmath622 are distinct .    for each @xmath21",
    "we can choose an instance @xmath623 of the associated rule with head @xmath622 such that for each @xmath624 we have @xmath625 .",
    "as notation we use : + @xmath626{\\lambda_i , \\pi_i } \\phi_i \\vdash   g'_i$ ] + since all the rules have a disjoint set of names we can apply @xmath372 times rule ( par ) in order to have : + @xmath627}_i g_i \\xrightarrow[]{\\bigcup_i \\lambda_i ,   \\bigcup_i \\pi_i } \\bigcup_i \\phi_i \\vdash \\operatorname{\\big[\\!\\!\\big]}_i g'_i$ ] + now we want to apply rule ( merge ) with substitution @xmath2 . we can do it since @xmath2 is idempotent .",
    "we have to verify that @xmath628 .",
    "this happens thanks to lemma [ lemma : bigstep ] .",
    "thus we obtain a rule of the form : + @xmath629{\\lambda , \\pi } \\phi   \\vdash g'$ ] + thanks to theorem [ theorem : tuostocorrectness ] we can have in @xmath36 the following big - step of synchronized logic programming : + @xmath630 + for every @xmath123 that satisfies the freshness conditions .",
    "furthermore @xmath631 is associated to @xmath632{\\lambda,\\pi } \\phi \\vdash g'$ ] and @xmath633 .",
    "finally we used as clauses the translations of the productions used in the proof of the hshr rewriting . note that @xmath634 . since the result of a big - step",
    "is determined up to injective renaming by the starting goal and the used clauses ( see lemma [ lemma : bigstep ] ) then we must have @xmath635 and @xmath636 for some injective renaming @xmath447 .",
    "note that @xmath637 satisfies the freshness conditions ( since variables generated in logic programming are always fresh ) and we also have @xmath638 .",
    "+ thus we have that @xmath338 is associated to @xmath346{\\lambda,\\pi } \\phi \\vdash g'$ ] and that @xmath639 .",
    "this proves the thesis ."
  ],
  "abstract_text": [
    "<S> in this paper we compare three different formalisms that can be used in the area of models for distributed , concurrent and mobile systems . </S>",
    "<S> in particular we analyze the relationships between a process calculus , the _ fusion calculus _ , graph transformations in the _ synchronized hyperedge replacement _ with hoare synchronization ( hshr ) approach and _ logic programming_. we present a translation from fusion calculus into hshr ( whereas fusion calculus uses milner synchronization ) and prove a correspondence between the reduction semantics of fusion calculus and hshr transitions . </S>",
    "<S> we also present a mapping from hshr into a transactional version of logic programming and prove that there is a full correspondence between the two formalisms . </S>",
    "<S> the resulting mapping from fusion calculus to logic programming is interesting since it shows the tight analogies between the two formalisms , in particular for handling name generation and mobility . </S>",
    "<S> the intermediate step in terms of hshr is convenient since graph transformations allow for multiple , remote synchronizations , as required by fusion calculus semantics . to appear in theory and practice of logic programming ( tplp ) .    </S>",
    "<S> fusion calculus , graph transformation , synchronized hyperedge replacement , logic programming , mobility </S>"
  ]
}