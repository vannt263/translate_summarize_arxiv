{
  "article_text": [
    "the set covering problem ( scp ) and set partitioning problem ( spp ) are representative combinatorial optimization problems that have many real - world applications , such as crew scheduling @xcite , vehicle routing @xcite , facility location @xcite and logical analysis of data @xcite .",
    "real - world applications of scp and spp are comprehensively reviewed in @xcite .    given a ground set of @xmath1 elements",
    "@xmath2 , @xmath3 subsets @xmath4 ( @xmath5 ) , and their costs @xmath6 for @xmath7 , we say that @xmath8 is a cover of @xmath9 if @xmath10 holds .",
    "we say that @xmath8 is a partition of @xmath9 if @xmath10 and @xmath11 hold for all @xmath12 .",
    "the goals of scp and spp are to find a minimum cost cover and a partition @xmath13 of @xmath9 , respectively . in this paper",
    ", we consider the following class of binary integer programs ( bips ) including scp and spp : @xmath14 where @xmath15 and @xmath16 ( @xmath17 is the set of non - negative integer values ) . we note that @xmath18 if @xmath19 holds and @xmath20 otherwise , and @xmath21 if @xmath22 and @xmath23 otherwise .",
    "that is , a column vector @xmath24 of the matrix @xmath25 represents the corresponding subset @xmath26 by @xmath27 , and the vector @xmath28 also represents the corresponding cover ( or partition ) @xmath13 by @xmath29 . for notational convenience , for each @xmath30 ,",
    "let @xmath31 be the index set of subsets @xmath26 that contain the elements @xmath32 and let @xmath33 be the left - hand side of the @xmath32th constraint .",
    "the scp and spp are known to be np - hard in the strong sense , and no polynomial time approximation scheme ( ptas ) exists unless p = np .",
    "however , worst case performance analysis does not necessarily represent the experimental performance in practice .",
    "continuous development of mathematical programming has much improved the performance of heuristic algorithms and this has been accompanied by advances in computing machinery .",
    "many efficient exact and heuristic algorithms for large - scale scp and spp instances have been developed @xcite , many of which are based on variable fixing techniques that reduce the search space to be explored by using the optimal values obtained by linear programming ( lp ) and/or lagrangian relaxation as lower bounds . however , many large - scale scp and spp instances still remain unsolved because there is little hope of closing the large gap between the lower and upper bounds of the optimal values . in particular , the equality constraints of spp often make variable fixing techniques less effective because they often prevent solutions from containing highly evaluated variables together . in this paper , we consider an alternative approach for extracting useful features from the instance to be solved with the aim of reducing the search space of local search algorithms for large - scale scp and spp instances .    in the design of local search algorithms for large - scale combinatorial problems , as the instance size increases , improving the computational efficiency becomes more effective than using sophisticated search strategies .",
    "the quality of locally optimal solutions typically improves if a larger neighborhood is used .",
    "however , the computation time of searching the neighborhood also increases exponentially . to overcome this",
    ", extensive research has investigated ways to efficiently implement neighborhood search , which can be broadly classified into three types : ( i )  reducing the number of candidates in the neighborhood @xcite , ( ii )  evaluating solutions by incremental computation @xcite , and ( iii )  reducing the number of variables to be considered by using linear programming and/or lagrangian relaxation @xcite .    to suggest an alternative",
    ", we develop a data mining approach for reducing the search space of local search algorithms .",
    "that is , we construct a @xmath0-nearest neighbor graph by extracting variable associations from the instance to be solved in order to identify promising pairs of swapping variables in the large neighborhood search .",
    "we also develop a 4-flip neighborhood local search algorithm that flips four variables alternately along 4-paths or 4-cycles in the @xmath0-nearest neighbor graph ( section  [ sec : variable - association ] ) .",
    "we incorporate an efficient incremental evaluation of solutions ( section  [ sec : local - search ] ) and an adaptive control of penalty weights ( section  [ sec : weight - control ] ) into the 4-flip neighborhood local search algorithm .",
    "local search ( ls ) starts from an initial solution @xmath28 and then iteratively replaces @xmath28 with a better solution @xmath34 in the neighborhood @xmath35 until no better solution is found in @xmath35 .",
    "for some positive integer @xmath36 , let the @xmath36-flip neighborhood @xmath37 be the set of solutions obtainable by flipping at most @xmath36 variables in @xmath28 .",
    "we first develop a 2-flip neighborhood local search ( 2-fnls ) algorithm as a basic component of our algorithm . in order to improve efficiency ,",
    "the 2-fnls first searches @xmath38 , and then searches @xmath39 only if @xmath28 is locally optimal with respect to @xmath38 .",
    "the bip is np - hard , and the ( supposedly ) simpler problem of judging the existence of a feasible solution is np - complete , since the satisfiability ( sat ) problem can be reduced to this problem .",
    "we accordingly consider the following formulation of a bip that allows violations of the constraints and introduce over and under penalty functions with penalty weight vectors @xmath40 : @xmath41 for a given @xmath42 , we can easily compute optimal @xmath43 and @xmath44 , where we denote @xmath45 .    because the region searched by a single application of ls is limited , ls is usually applied many times .",
    "when a locally optimal solution is found , a standard strategy is to update the penalty weights and to resume ls from the obtained locally optimal solution .",
    "we accordingly evaluate solutions by using an alternative function @xmath46 , where the original penalty weight vectors @xmath47 are replaced by @xmath48 , and these are adaptively controlled during the search ( see section  [ sec : weight - control ] for details ) .",
    "we first describe how 2-fnls is used to search @xmath38 , which is called the 1-flip neighborhood .",
    "let @xmath49 and @xmath50 denote the increases in @xmath46 due to flipping @xmath51 and @xmath52 , respectively .",
    "2-fnls first searches for an improved solution by flipping @xmath51 for @xmath53 .",
    "if an improved solution is found , it chooses @xmath54 that has the minimum value of @xmath55 , otherwise it searches for an improved solution by flipping @xmath52 for @xmath22 .",
    "we next describe how 2-fnls is used to search @xmath39 , which is called the 2-flip neighborhood .",
    "we derive conditions that reduce the number of candidates in @xmath39 without sacrificing the solution quality by expanding the results as shown in @xcite .",
    "let @xmath56 denote the increase in @xmath46 due to simultaneously flipping the values of @xmath57 and @xmath58 .",
    "[ lem : nb1 ] if a solution @xmath28 is locally optimal with respect to @xmath38 , then @xmath59 holds only if @xmath60 .",
    "see [ app : nb1 ] .    based on this lemma , we consider only the set of solutions obtainable by simultaneously flipping @xmath61 and @xmath62 .",
    "we now define @xmath63 where @xmath64 . by lemma  [ lem : nb1 ]",
    ", the 2-flip neighborhood can be restricted to the set of solutions satisfying @xmath60 and @xmath65 .",
    "however , it might not be possible to search this set efficiently without first extracting it .",
    "we thus construct a neighbor list that stores promising pairs of variables @xmath57 and @xmath58 for efficiency ( see section [ sec : variable - association ] for details ) .",
    "to increase the efficiency of 2-fnls , we decompose the neighborhood @xmath66 into a number of sub - neighborhoods .",
    "let @xmath67 denote the subset of @xmath66 obtainable by flipping @xmath61 .",
    "2-fnls searches @xmath67 for each @xmath68 in ascending order of @xmath69 .",
    "if an improved solution is found , the pair @xmath70 and @xmath71 that has the minimum value of @xmath56 among @xmath67 is selected .",
    "2-fnls is formally described as follows .",
    "input : : :    a solution @xmath28 and penalty weight vectors    @xmath72 and    @xmath73 .",
    "output : : :    a solution @xmath28 .",
    "step  1 : : :    if    @xmath74    holds , choose @xmath75 that has the    minimum value of @xmath49 ,    set @xmath76 , and return to step  1 .",
    "step  2 : : :    if    @xmath77    holds , choose @xmath78 that has    the minimum value of    @xmath50 , set    @xmath79 , and return to step  2 .",
    "step  3 : : :    for each @xmath68 in ascending order of    @xmath69 , if    @xmath80    holds , choose @xmath81 that has the    minimum value of @xmath56 and    set @xmath82 and    @xmath83 .",
    "if the current solution    @xmath28 has been updated at least once in step  3 , return    to step  1 , otherwise output @xmath28 and exit .",
    "if implemented naively , 2-fnls requires @xmath84 time to compute the value of the evaluation function @xmath46 for the current solution @xmath28 , where @xmath85 denote the number of non - zero elements in the constraint matrix @xmath25 .",
    "this computation is quite expensive if we evaluate the neighbor solutions of the current solution @xmath28 independently . to overcome this , we first develop a standard incremental evaluation of @xmath49 and @xmath50 in @xmath86 time by keeping the values of the left - hand side of constraints @xmath87 ( @xmath30 ) in memory .",
    "we further develop an improved incremental evaluation of @xmath49 and @xmath50 in @xmath88 time by keeping additional auxiliary data in memory ( see [ app : eval ] for details ) . by using this ,",
    "2-fnls is also able to evaluate @xmath56 in @xmath86 time by using ( [ eq:2-flip ] ) .",
    "it is known that the quality of locally optimal solutions improves if a larger neighborhood is used . however , the computation time to search the neighborhood @xmath37 also increases exponentially with @xmath36 , since @xmath89 generally holds .",
    "a large amount of computation time is thus needed in practice in order to scan all candidates in @xmath66 for large - scale instances with millions of variables . to overcome this",
    ", we develop a data mining approach that identifies promising pairs of flipping variables in @xmath66 by extracting variable associations from the instance to be solved using only a small amount of computation time .    ]    based on lemma  [ lem : nb1 ] , the 2-flip neighborhood can be restricted to the set of solutions satisfying @xmath60 and @xmath65 .",
    "we further observe from ( [ eq:2-flip ] ) that it is favorable to select pairs of flipping variables @xmath57 and @xmath58 which gives a larger size @xmath90 in order to obtain @xmath59 . based on this observation , we keep a limited set of pairs of variables @xmath57 and @xmath58 for which @xmath90 is large in memory , and we call this the neighbor list ( figure  [ fig : nb - list ] ) . we note that @xmath90 represents a certain kind of similarity between the subsets @xmath91 and @xmath92 ( or column vectors @xmath93 and @xmath94 of the constraint matrix @xmath25 ) and we keep the @xmath0-nearest neighbors for each subset @xmath26 ( @xmath95 ) in the neighbor list .    for each variable @xmath57 ( @xmath96 ) , we first enumerate @xmath58 ( @xmath97 ) satisfying @xmath98 and @xmath99 to generate the set @xmath100 $ ] , and store the first @xmath101 variables @xmath58 ( @xmath102 $ ] ) in descending order of @xmath90 in the @xmath70th row of the neighbor list , where @xmath103 and @xmath104 is a program parameter that we set to five .",
    "let @xmath105 $ ] be the set of variables @xmath58 stored in the @xmath70th row of the neighbor list .",
    "we then reduce the number of candidates in @xmath66 by restricting the pairs of flipping variables @xmath57 and @xmath58 to pairs in the neighbor list @xmath68 and @xmath106 $ ] .",
    "we note that it is still expensive to construct the whole neighbor list for large - scale instances with millions of variables . to overcome this",
    ", we develop a lazy construction algorithm for the neighbor list .",
    "that is , 2-fnls starts from an empty neighbor list and generates the @xmath70th row of the neighbor list @xmath105 $ ] only when 2-fnls searches @xmath67 for the first time .",
    "-nearest neighbor graph[fig : graph ] ]    we can treat the neighbor list as an adjacency - list representation of a directed graph , and represent associations between variables by a corresponding directed graph called the @xmath0-nearest neighbor graph ( figure  [ fig : graph ] ) . using the @xmath0-nearest neighbor graph , we extend 2-fnls to search a set of promising neighbor solutions in @xmath107 . for each variable @xmath57 ( @xmath68 )",
    ", we keep @xmath106 $ ] that has the minimum value of @xmath56 in memory as @xmath108 .",
    "the extended 2-fnls , called the 4-flip neighborhood search ( 4-fnls ) algorithm , then searches for an improved solution by flipping @xmath61 , @xmath109 , @xmath110 and @xmath111 for @xmath68 and @xmath112 $ ] satisfying @xmath113 and @xmath114 , i.e. , flipping the values of variables alternately along 4-paths or 4-cycles in the @xmath0-nearest neighbor graph .",
    "let @xmath115 denote the increase in @xmath46 due to simultaneously flipping @xmath61 , @xmath62 , @xmath110 and @xmath116 .",
    "4-fnls computes @xmath115 in @xmath86 time by applying the standard incremental evaluation alternately .",
    "4-fnls is formally described by replacing the part of the 2-fnls algorithm after step  2 with the following :    step  3@xmath117 : : :    for each @xmath68 in ascending order of    @xmath69 , if    @xmath118 \\mid \\delta \\tilde{z}_{j_1,j_2}(\\bm{x } ) < 0 \\ } \\not= \\emptyset$ ]    holds , choose @xmath81 that has the    minimum value of @xmath56 and    set @xmath82 and    @xmath83 . if the current solution    @xmath28 has been updated at least once in    step  3@xmath117 , return to step  1 .",
    "step  4@xmath117 : : :    for each @xmath68 in ascending order of    @xmath119 , if    @xmath120 \\mid j_3 \\not= j_1 , \\pi(j_3 ) \\not= \\pi(j_1 ) , \\delta \\tilde{z}_{j_1,\\pi(j_1),j_3,\\pi(j_3)}(\\bm{x } ) < 0 \\ } \\not= \\emptyset$ ]    holds , choose @xmath121 that has the    minimum value of    @xmath122 and    set @xmath82 ,    @xmath123 ,    @xmath124 and    @xmath125 . if the current solution    @xmath28 has been updated at least once in    step  4@xmath117 , return to step  1 , otherwise output    @xmath28 and exit .",
    "although a similar approach has been developed in local search algorithms for the euclidean traveling salesman problem ( tsp ) in which a sorted list containing only the @xmath0-nearest neighbors is stored for each city by using a geometric data structure called the @xmath0-dimensional tree @xcite , it is not suitable for finding the @xmath0-nearest neighbors efficiently in high - dimensional spaces .",
    "we thus extend it for application to the high - dimensional column vectors @xmath126 ( @xmath95 ) of bips by using a lazy construction algorithm for the neighbor list .",
    "in our algorithm , solutions are evaluated by the alternative evaluation function @xmath46 in which the fixed penalty weight vectors @xmath127 , @xmath128 in the original evaluation function @xmath129 has been replaced by @xmath72 , @xmath73 , and the values of @xmath130 ( @xmath131 ) , @xmath132 ( @xmath133 ) are adaptively controlled in the search .",
    "it is often reported that a single application of ls tends to stop at a locally optimal solution of insufficient quality when large penalty weights are used .",
    "this is because it is often unavoidable to temporally increase the values of some violations @xmath134 and @xmath135 in order to reach an even better solution from a good solution through a sequence of neighborhood operations , and large penalty weights thus prevent ls from moving between such solutions . to overcome this",
    ", we incorporate an adaptive adjustment mechanism for determining appropriate values of penalty weights @xmath130 ( @xmath131 ) , @xmath132 ( @xmath133 ) @xcite .",
    "that is , ls is applied iteratively while updating the values of the penalty weights @xmath130 ( @xmath131 ) , @xmath132 ( @xmath133 ) after each call to ls .",
    "we call this sequence of calls to ls the weighting local search ( wls ) according to @xcite .",
    "this strategy is also referred as the breakout algorithm @xcite and the dynamic local search @xcite in the literature .",
    "let @xmath28 denote the solution at which the previous local search stops .",
    "we assume that the original penalty weights @xmath136 ( @xmath131 ) , @xmath137 ( @xmath133 ) are sufficiently large .",
    "wls resumes ls from @xmath28 after updating the penalty weight vectors @xmath72 , @xmath73 . starting from the original penalty weight vectors @xmath138 , the penalty weight vectors @xmath72 , @xmath73",
    "are updated as follows .",
    "let @xmath139 denote the best solution obtained so far with respect to the original evaluation function @xmath129 .",
    "if @xmath140 holds , wls uniformly decreases the penalty weights by @xmath141 , where @xmath142 is a program parameter that is adaptively computed so that the new value of @xmath50 becomes negative for 10% of variables @xmath143 ( @xmath22 ) .",
    "otherwise , wls increases the penalty weights by @xmath144 wls iteratively applies ls , updating the penalty weight vectors @xmath72 , @xmath73 after each call to ls until the time limit is reached .",
    "note that we modify 4-fnls to evaluate solutions with both @xmath46 and @xmath129 , and update the best solution @xmath139 with respect to the original objective function @xmath129 whenever an improved solution is found .",
    "wls is formally described as follows .",
    "note that we set the initial solution to @xmath145 in practice .",
    "input : : :    an initial solution @xmath28 .",
    "output : : :    the best solution @xmath139 with respect to    @xmath129 .",
    "step  1 : : :    set @xmath146 ,    @xmath147 and    @xmath138 .",
    "step  2 : : :    apply    4-fnls(@xmath148 )    to obtain an improved solution @xmath149 .",
    "let @xmath34 be the best solution with respect to    the original evaluation function @xmath129 obtained    during the call to    4-fnls(@xmath148 ) .",
    "set @xmath150 . step  3 : : :    if @xmath151 holds , then set    @xmath152 . if the time    limit is reached , output @xmath139 and halt . step  4 : : :    if @xmath153 holds ,    then uniformly decrease the penalty weights by    @xmath141 ,    otherwise , increase the penalty weight vectors    @xmath154 by    ( [ eq : weighting ] ) . return to step  2",
    "we report computational results of our algorithm for the scp instances from @xcite and the spp instances from @xcite . tables  [ tb : scp - instance ] and [ tb : spp - instance ] summarize the information about the original and pre - solved instances .",
    "the first column shows the name of the group ( or the instance ) , and the numbers in parentheses show the number of instances in the group . the second column `` @xmath155 '' shows the optimal values of the lp relaxation problems .",
    "the third column `` @xmath156 '' shows the best upper bounds among all algorithms and the settings in this paper .",
    "the fourth and sixth columns `` # cst . ''",
    "show the number of constraints , and the fifth and seventh columns `` # vars . ''",
    "show the number of variables .",
    "since several preprocessing techniques that often reduce the size of instances by removing redundant rows and columns are known @xcite , all algorithms are tested on the pre - solved instances .",
    "the instances marked `` @xmath157 '' are hard instances that can not be solved optimally within at least 1  h by the latest mixed integer programming ( mip ) solvers .",
    "= 0.5em    .benchmark instances for scp[tb : scp - instance ] [ cols=\"<,>,>,>,>,^ , > , > , > \" , ]     from the results , we can see that the overall computational efficiency of our algorithm was improved 16.90-fold and 17.26-fold on average for scp and spp instances , respectively in comparison with the naive algorithm that has neither the neighbor list nor the improved incremental evaluation ( i.e. , only applying the standard incremental evaluation ) , and our algorithm attains good performance even when the size of the neighbor list is considerably small .",
    "we also observe that the 4-flip neighborhood search substantially improves the performance of our algorithm , even though there are fewer calls to 4-fnls compared to 2-fnls .",
    "we present a data mining approach for reducing the search space of local search algorithms for a class of bips including scp and spp . in this approach",
    ", we construct a @xmath0-nearest neighbor graph by extracting variable associations from the instance to be solved in order to identify promising pairs of flipping variables in the 2-flip neighborhood .",
    "we also develop a 4-flip neighborhood local search algorithm that flips four variables alternately along 4-paths or 4-cycles in the @xmath0-nearest neighbor graph .",
    "we incorporate an efficient incremental evaluation of solutions and an adaptive control of penalty weights into the 4-flip neighborhood local search algorithm . computational comparison with the latest solvers",
    "shows that our algorithm achieves sufficiently good upper bounds for scp and spp instances , particularly for hard spp instances .",
    "we expect that data mining approaches could also be beneficial for efficiently solving other large - scale combinatorial optimization problems , particularly for hard instances that have large gaps between the lower and upper bounds of the optimal values .",
    "achterberg , t. ( 2009 ) .",
    "scip : solving constraint integer programs .",
    "_ mathematical programming computation _ , 1 , 141 .",
    "agarwal , y. , mathur , k. , & salkin , h.  m. ( 1989 ) . a set - partitioning - based exact algorithm for the vehicle routing problem .",
    "_ networks _ , 19 , 731749 .",
    "atamtrk , a. , nemhauser , g.  l. , & savelsbergh , m.  w.  p. ( 1995 ) .",
    "a combined lagrangian , linear programming , and implication heuristic for large - scale set partitioning problems .",
    "_ journal of heuristics _",
    ", 1 , 247259",
    ".    balas , e. , & padberg , m.  w. ( 1976 ) . set partitioning : a survey .",
    "_ siam review _",
    ", 18 , 710760 .",
    "barahona , f. & anbil , r. ( 2000 ) .",
    "the volume algorithm : producing primal solutions with a subgradient method .",
    "_ mathematical programming _ , a87 , 385399 .",
    "barnhart , c. , johnson , e.  l. , nemhauser , g.  l. , savelsbergh , m.  w.  p. , & vance , p.  h. ( 1998 ) .",
    "branch - and - price : column generation for solving huge integer programs . _ operations research _",
    ", 46 , 316329 .",
    "bastert , o. , hummel , b. & de vries , s. ( 2010 ) . a generalized wedelin heuristic for integer programming .",
    "_ informs journal on computing _ , 22 , 93107 .",
    "beasley , j.  e. ( 1990 ) . or - library : distributing test problems by electronic mail .",
    "_ journal of the operational research society _",
    ", 41 , 10691072 .",
    "benoist , t. , estellon , b. , gardi , f. , megel , r. , & nouioua , k. ( 2011 ) .",
    "localsolver 1.x : a black - box local - search solver for 0 - 1 programming .",
    "_ 4or  a quarterly journal of operations research _ , 9 , 299316 .",
    "borndrfer , r. ( 1998 ) .",
    "_ aspects of set packing , partitioning and covering_. ph .",
    "d. dissertation , berlin : technischen universitt .",
    "boros , e. , hammer , p.  l. , ibaraki , t. , kogan , a. , mayoraz , e. , & muchnik , i. ( 2000 ) . an implementation of logical analysis of data . _ ieee transactions on knowledge and data engineering _ , 12 , 292306 .",
    "boros , e. , ibaraki , t. , ichikawa , h. , nonobe , k. , uno , t. , & yagiura , m. ( 2005 ) .",
    "heuristic approaches to the capacitated square covering problem .",
    "_ pacific journal of optimization _",
    ", 1 , 465490 .    boschetti , m.  a. , mingozzi , a. & ricciardelli , s. ( 2008 ) . a dual ascent procedure for the set partitioning problem .",
    "_ discrete optimization _ , 5 , 735747 .",
    "bramel , j. , & simchi - levi , d. ( 1997 ) . on the effectiveness of set covering formulations for the vehicle routing problem with time windows .",
    "_ operations research _ , 45 , 295301 .",
    "caprara , a. , fischetti , m. , & toth , p. ( 1999 ) . a heuristic method or the set covering problem . _ operations research _ , 47 , 730743 .",
    "caprara , a. , toth , p. , & fischetti , m. ( 2000 ) .",
    "algorithms for the set covering problem .",
    "_ annals of operations research _ , 98 , 353371 .",
    "caserta , m. ( 2007 ) .",
    "tabu search - based metaheuristic algorithm for large - scale set covering problems . in w.",
    "j.  gutjahr , r.  f.  hartl , & m.  reimann ( eds . ) , _ metaheuristics : progress in complex systems optimization _",
    "( pp .  4363 ) .",
    "berlin : springer .",
    "ceria , s. , nobili , p. , sassano , a. ( 1997 ) . set covering problem . in m.",
    "dellamico , f.  maffioli & s.  martello ( eds . ) : _ annotated bibliographies in combinatorial optimization _ , ( pp .  415428 ) .",
    "new jersey : john wiley & sons .",
    "ceria , s. , nobili , p. , & sassano , a. ( 1998 ) . a lagrangian - based heuristic for large - scale set covering problems .",
    "_ mathematical programming _ , 81 , 215288 .",
    "chu p.  c. , & beasley , j.  e. ( 1998 ) .",
    "constraint handling in genetic algorithms : the set partitioning problem .",
    "_ journal of heuristics _",
    ", 11 , 323357 .",
    "farahani , r.  z. , asgari , n. , heidari , n. , hosseininia , m. , & goh , m. ( 2012 ) . covering problems in facility location : a review .",
    "_ computers & industrial engineering _ , 62 , 368407 .",
    "hammer , p. l. , & bonates , t. o. ( 2006 ) .",
    "logical analysis of data  an overview : from combinatorial optimization to medical applications .",
    "_ annals of operations research _ , 148 , 203225 .",
    "hashimoto , h. , ezaki , y. , yagiura , m. , nonobe , k. , ibaraki , t. , & lkketangen , a. ( 2009 ) .",
    "a set covering approach for the pickup and delivery problem with general constraints on each route .",
    "_ pacific journal of optimization _",
    ", 5 , 183200 .",
    "hoffman , k.  l. , & padberg , a. ( 1993 ) .",
    "solving airline crew scheduling problems by branch - and - cut . _ management science _",
    ", 39 , 657682 .",
    "hutter , f. , tompkins , d.  a.  d. , & hoos , h.  h. ( 2002 ) .",
    "scaling and probabilistic smoothing : efficient dynamic local search for sat",
    ". _ proceedings of international conference on principles and practice of constraint programming ( cp ) _",
    ", 233248 .",
    "johnson , d.  s. , & mcgeoch , l.  a. ( 1997 ) .",
    "the traveling salesman problem : a case study . in e.",
    "aarts , & k.  lenstra ( eds . ) , _ local search in combinatorial optimization _",
    "( pp .  215310 ) .",
    "new jersey : princeton university press .",
    "koch , t. , achterberg , t. , andersen , e. , bastert , o. , berthold , t. , bixby , r.  e. , danna , e. , gamrath , g. , gleixner , a.  m. , heinz , s , lodi , a. , mittelmann , h. , ralphs , t. , salvagnin , d. , steffy , d.  e. , & wolter , k. ( 2011 ) .",
    "miplib2010 : mixed integer programming library version 5 .",
    "_ mathematical programming computation _",
    ", 3 , 103163 .",
    "linderoth , j.  t. , lee , e.  k. , & savelbergh , m.  w.  p. ( 2001 ) . a parallel , linear programming - based heuristic for large - scale set partitioning problems .",
    "_ informs journal on computing _ , 13 , 191209 .",
    "michel , l. & van hentenryck , p. ( 2000 ) .",
    "_ constraints : an international journal _ , 5 , 4384 .",
    "mingozzi , a. , boschetti , m.  a. , ricciardelli , s. , & bianco , l. ( 1999 ) . a set partitioning approach to the crew scheduling problem .",
    "_ operations research _ , 47 , 873888 .",
    "morris , p. ( 1993 ) .",
    "the breakout method for escaping from local minima .",
    "_ proceedings of national conference on artificial intelligence ( aaai ) _ , 4045 .",
    "nonobe , k. , & ibaraki , t. ( 2001 ) .",
    "an improved tabu search method for the weighted constraint satisfaction problem .",
    "_ infor _ , 39 , 131151 .",
    "pesant , g. , & gendreau , m. ( 1999 ) . a constraint programming framework for local search methods .",
    "_ journal of heuristics _",
    ", 5 , 255279 .",
    "selman , b. , & kautz , h. ( 1993 ) .",
    "domain - independent extensions to gsat : solving large structured satisfiability problems .",
    "_ proceedings of international conference on artificial intelligence ( ijcai ) _ , 290295 .",
    "shaw , p. , backer , b.  d. , & furnon , v. ( 2002 ) . improved local search for cp toolkits . _",
    "annals of operations research _ , 115 , 3150 .",
    "thornton , j. ( 2005 ) .",
    "clause weighting local search for sat . _",
    "journal of automated reasoning _",
    ", 35 , 97142 .",
    "umetani , s. , & yagiura , m. ( 2007 ) .",
    "relaxation heuristics for the set covering problem .",
    "_ journal of the operations research society of japan _ , 50 , 350375 .",
    "umetani , s. , arakawa , m. , & yagiura , m. ( 2013 ) . a heuristic algorithm for the set multicover problem with generalized upper bound constraints . _ proceedings of learning and intelligent optimization conference ( lion ) _ , 7580 .",
    "umetani , s. ( 2015 ) . exploiting variable associations to configure efficient local search in large - scale set partitioning problems .",
    "_ proceedings of aaai conference on artificial intelligence ( aaai ) _ , 12261232 .",
    "van hentenryck , p. , & michel , l. ( 2005 ) . _ constraint - based local search _ , cambridge : the mit press .",
    "voudouris , c. , dorne , r. , lesaint , d. , & liret , a. ( 2001 ) .",
    "iopt : a software toolkit for heuristic search methods .",
    "_ proceedings of principles and practice of constraint programming ( cp ) _ , 716729 .",
    "wedelin , d. ( 1995 ) .",
    "an algorithm for large - scale 0 - 1 integer programming with application to airline crew scheduling . _",
    "annals of operations research _ , 57 , 283301 .",
    "yagiura , m. & ibaraki , t. ( 1999 ) .",
    "analysis on the 2 and 3-flip neighborhoods for the max sat .",
    "_ journal of combinatorial optimization _ , 3 , 95114 .",
    "yagiura , m. , kishida , m. , & ibaraki , t. ( 2006 ) . a 3-flip neighborhood local search for the set covering problem .",
    "european journal of operational research _",
    ", 172 , 472499 .",
    "we show that @xmath158 holds if @xmath159 .",
    "first , we consider the case of @xmath160 . by the assumption of the lemma",
    ", @xmath161 holds for both @xmath162 .",
    "we then have @xmath163 where @xmath164 .",
    "next , we consider the case of @xmath165 . by the assumption of the lemma , @xmath166 holds for both @xmath162 .",
    "we then have @xmath167 where @xmath168 .",
    "we first consider a standard incremental evaluation of @xmath49 and @xmath50 in @xmath86 time using the following formulas : @xmath169 @xmath170 where 2-fnls keeps the values of the left - hand side of constraints @xmath87 ( @xmath30 ) in memory .",
    "2-fnls updates @xmath87 ( @xmath19 ) in @xmath86 time by @xmath171 and @xmath172 when the current solution @xmath28 moves to @xmath34 by flipping @xmath51 and @xmath52 , respectively .",
    "we further develop an improved incremental evaluation of @xmath49 and @xmath50 in @xmath88 time by directly keeping @xmath173 , @xmath174 ( @xmath53 ) and @xmath175 , @xmath176 ( @xmath22 ) in memory .",
    "when the current solution @xmath28 moves to @xmath34 by flipping @xmath51 , 2-fnls first updates @xmath87 ( @xmath19 ) in @xmath86 time by @xmath171 , and then updates @xmath177 , @xmath178 , @xmath179 , @xmath180 ( @xmath181 , @xmath19 ) in @xmath182 time using the following formulas : @xmath183 where @xmath184 similarly , when the current solution @xmath28 moves to @xmath34 by flipping @xmath52 , 2-fnls first updates @xmath87 ( @xmath19 ) in @xmath86 time , and then updates @xmath177 , @xmath178 , @xmath179 , @xmath180 ( @xmath181 , @xmath19 ) in @xmath182 time .",
    "we note that the computation time for updating the auxiliary data has little effect on the total computation time of 2-fnls because the number of solutions actually visited is much less than the number of neighbor solutions evaluated in most cases ."
  ],
  "abstract_text": [
    "<S> we present a data mining approach for reducing the search space of local search algorithms in a class of binary integer programs including the set covering and partitioning problems . </S>",
    "<S> we construct a @xmath0-nearest neighbor graph by extracting variable associations from the instance to be solved , in order to identify promising pairs of flipping variables in the neighborhood search . </S>",
    "<S> we also develop a 4-flip neighborhood local search algorithm that flips four variables alternately along 4-paths or 4-cycles in the @xmath0-nearest neighbor graph . </S>",
    "<S> we incorporate an efficient incremental evaluation of solutions and an adaptive control of penalty weights into the 4-flip neighborhood local search algorithm . computational comparison with the latest solvers </S>",
    "<S> shows that our algorithm performs effectively for large - scale set covering and partitioning problems .    </S>",
    "<S> * keyword : * combinatorial optimization , heuristics , set covering problem , set partitioning problem , local search </S>"
  ]
}