{
  "article_text": [
    "map labeling is a well - known cartographic problem in computational geometry  ( * ? ? ?",
    "* chapter 58.3.1),@xcite . depending on the type of map features , one can distinguish labeling of _ points _ , _ lines _ , and _",
    "areas_. common cartographic quality criteria are that labels must be disjoint and clearly identify their respective map features  @xcite .",
    "most of the previous work concerns point labeling , while labeling line and area features received considerably less attention . in this paper",
    "we address labeling linear features , namely roads in a road map .    geometrically ,",
    "a _ road map _ is the representation of a _ road graph _ @xmath0 as an arrangement of fat curves in the plane @xmath1 . each _ road _ is a connected subgraph of @xmath0 ( typically a simple path ) and each edge belongs to exactly one road .",
    "roads may intersect each other in _ junctions _ , the vertices of @xmath0 , and we denote an edge connecting two junctions as a _ road section_. in road labeling the task is to place the road names inside the fat curves so that the road sections are identified unambiguously , see fig .  [",
    "fig : goodbad ] .",
    "chiri  @xcite presented a set of rules and quality criteria for label placement in road maps based on interviews with cartographers .",
    "this includes that ( c1 ) labels are placed inside and parallel to the road shapes , ( c2 ) every road section between two junctions should be clearly identified , and ( c3 ) no two road labels may intersect .",
    "further , he gave a mathematical description for labeling a single road and introduced a heuristic for sequentially labeling all roads in the map .",
    "imhof s foundational cartographic work on label positioning in maps lists very similar quality criteria  @xcite .",
    "edmondson et al .",
    "@xcite took an algorithmic perspective on labeling a single linear feature ( such as a river ) . while edmondson et al",
    ".  considered _ non - bent _ labels , wolff et al .",
    "@xcite introduced an algorithm for single linear feature that places labels following the curvature of the linear feature .",
    "strijk @xcite considered static road labeling with embedded labels and presented a heuristic for selecting non - overlapping labels out of a set of label candidates .",
    "seibert and unger  @xcite considered grid - shaped road networks .",
    "they showed that in those networks it is -complete and -hard to decide whether for every road at least one label can be placed . yet , neyer and wagner  @xcite introduced a practically efficient algorithm that finds such a grid labeling if possible .",
    "maass and dllner  @xcite presented a heuristic for labeling the roads of an interactive 3d map with objects ( such as buildings ) .",
    "apart from label - label overlaps , they also resolve label - object occlusions .",
    "vaaraniem et al .",
    "@xcite used a force - based labeling algorithm for 2d and 3d scenes including road label placement .",
    "[ [ contribution . ] ] contribution .",
    "+ + + + + + + + + + + + +    while in grid - shaped road networks it is sufficient to place a single label per road to clearly identify all its road sections , this is not the case in general road networks . consider the example in fig .",
    "[ fig : goodbad ] . in fig .",
    "[ fig : goodbad]a ) , it is not obvious whether the orange road section in the center belongs to _ knuth st . _  or to  _ turing",
    "st_. simply maximizing the number of placed labels , as often done for labeling point features , can cause undesired effects like unnamed roads or clumsy label placements ( e.g. , around _",
    "dijkstra st .",
    "_  and _ hamming st .",
    "_ in fig .",
    "[ fig : goodbad]a ) )",
    ". therefore , in contrast to seibert and unger  @xcite , we aim for maximizing the number of  _ identified _ road sections , i.e. , road sections that can be clearly assigned to labels ; see fig .",
    "[ fig : goodbad]b ) .    based on criteria ( c1)(c3 )",
    "we introduce a new and versatile model for road labeling in section  [ sec : model ] . in section  [ sec : np - hardness ] we show that the problem of maximizing the number of identified road sections is  -hard for general road graphs , even if each road is a path . for the special case",
    "that the road graph is a tree , we present a polynomial - time algorithm in section  [ sec : tree - algorithm ] .",
    "this special case is not only of theoretical interest , but our algorithm in fact provides a very useful subroutine in exact or heuristic algorithms for labeling general road graphs . our initial experiments , sketched in section  [ sec : appendix : experiments ] , show that real - world road networks decompose into small subgraphs , a large fraction of which ( more than 85.1% ) are actually trees , and thus can be labeled optimally by our algorithm .",
    "as argued above , a road map is a collection of fat curves in the plane , each representing a particular piece of a named road .",
    "if two ( or more ) such curves intersect , they form junctions .",
    "a _ road label _ is again a fat curve ( the bounding shape of the road name ) that is contained in and parallel to the fat curve representing its road .",
    "we observe that labels of different roads can intersect only within junctions and that the actual width of the curves is irrelevant , except for defining the shape and size of the junctions .",
    "these observations allow us to define the following more abstract but equivalent road map model .    a _ road map _  @xmath2 is a planar _ road graph _ @xmath3 together with a planar embedding @xmath4 , which can be thought of as the geometric representation of the road axes as thin curves ; see fig  [ fig : goodbad]c ) .",
    "we denote the number of vertices of @xmath0 by @xmath5 , and the number of edges by @xmath6 .",
    "observe that since @xmath0 is planar @xmath7 .",
    "each edge @xmath8 is either a _ road section _ , which is not part of a junction , or a _ junction edge _ , which is part of a junction .",
    "each vertex @xmath9 is either a _ junction vertex _",
    "incident only to junction edges , or a _ regular vertex _ incident to one road section and at most one junction edge , which implies that each regular vertex has degree at most two .",
    "a junction vertex @xmath10 and its incident edges are denoted as a _",
    "junction_. the edge set @xmath11 decomposes into a set @xmath12 of edge - disjoint _ roads _",
    ", where each road @xmath13 induces a connected subgraph of @xmath0 . without loss of generality",
    "we assume no two road sections  @xmath0 are incident to the same vertex .",
    "thus , a road decomposes into road sections , separated by junction vertices and their incident junction edges . in realistic road networks",
    "the number of roads connected passing through a junction is small and does not depend on the size of the road network .",
    "we therefore assume that each vertex in  @xmath0 has constant degree .",
    "we assume that each road  @xmath14 has a name whose length we denote by  @xmath15 .    for simplicity",
    ", we identify the embedding @xmath4 with the points in the plane covered by @xmath4 , i.e.  @xmath16 .",
    "we also use @xmath17 , @xmath18 , and @xmath19 to denote the embeddings of a vertex @xmath10 , an edge @xmath20 , and a road @xmath21 .",
    "we model a label as a simple open curve @xmath22\\to \\e(g)$ ] in  @xmath4 .",
    "unless mentioned otherwise , we consider a curve  @xmath23 always to be simple and open , i.e. , @xmath23 has no self - intersections and its end points do not coincide . in order to ease the description ,",
    "we identify a curve @xmath23 in @xmath4 with its image , i.e. ,  @xmath23 denotes the set  @xmath24\\}$ ] .",
    "the start point of @xmath23 is denoted as the _ head _ @xmath25 and the endpoint as the _ tail _ @xmath26 .",
    "the length of  @xmath23 is denoted by @xmath27 .",
    "the curve @xmath23 _ identifies _ a road section @xmath28 if @xmath29 . for a set @xmath30 of curves",
    "@xmath31 is the number of road sections that are identified by the curves in  @xmath30 . for a single curve  @xmath23",
    "we use  @xmath32 instead of  @xmath33 . for two curves",
    "@xmath34 and @xmath35 it is not necessarily true that @xmath36 , because they may identify the same road section twice .    a _ label _ @xmath23 for a road @xmath21 is a curve @xmath37 of length @xmath15 whose endpoints must lie on road sections and not on junction edges or junction vertices .",
    "requiring that labels end on road sections avoids ambiguous placement of labels in junctions where it is unclear how the road passes through it .",
    "@xmath30 for a road map with road set @xmath38 is a set of mutually non - overlapping labels , where we say that two labels @xmath23 and @xmath39 _ overlap _ if they intersect in a point that is not their respective head or tail .    following the cartographic quality criteria  ( c1)(c3 ) , our goal is to find a labeling @xmath30 that maximizes the number of identified road sections , i.e. , for any labeling @xmath40 we have @xmath41 .",
    "we call this problem  maxidentifiedroads",
    ".    note that assuming the road graph  @xmath0 to be planar is not a restriction in practice .",
    "consider for example a road section  @xmath28 that overpasses another road section  @xmath42 , i.e. , @xmath28 is a bridge over  @xmath42 , or @xmath42 is a tunnel underneath  @xmath28 . in order to avoid overlaps between labels placed on @xmath28 and @xmath42 , we either can model the intersection of  @xmath28 and @xmath42 as a regular crossing of two roads or we split  @xmath42 in smaller road sections that do not cross  @xmath28 . in both cases the corresponding road graph becomes planar . in the latter case we may obtain more independent roads created by chopping  @xmath42 into smaller pieces .",
    "we first study the computational complexity of road labeling and prove -hardness of maxidentifiedroadsin the following sense .",
    "we perform a reduction from the -complete planar monotone 3-sat problem  @xcite .",
    "an instance of planar monotone 3-sat is a boolean formula @xmath44 with @xmath5 variables and @xmath6 clauses ( disjunctions of at most three literals ) that satisfies the following additional requirements : ( i ) @xmath44 is _ monotone _ , i.e. , every clause contains either only positive literals or only negative literals and ( ii ) the induced variable - clause graph @xmath45 of @xmath44 is planar and can be embedded in the plane with all variable vertices on a horizontal line , all positive clause vertices on one side of the line , all negative clauses on the other side of the line , and the edges drawn as rectilinear curves connecting clauses and contained variables on their respective side of the line .",
    "represented as road graph @xmath46 .",
    "truth assignment is @xmath47 , @xmath48 , @xmath49 , @xmath50 and @xmath51 .",
    "( b )  clause gadget in two states .",
    "( c )  the chain is the basic building block for the proof .",
    "( d )  schematized fork gadget . ]",
    "we construct a road map @xmath46 that mimics the shape of the above embedding of @xmath45 by defining variable and clause gadgets , which simulate the assignment of truth values to variables and the evaluation of the clauses .",
    "we refer to fig .",
    "[ fig : gadgets ] for a sketch of the construction .",
    "_ chain gadget .",
    "_ the basic building block is the _ chain gadget _ , which consists of an alternating sequence of equally long horizontal and vertical roads with identical label lengths that intersect their respective neighbors in the sequence and form junctions with them as indicated in fig .",
    "[ fig : gadgets]c ) .",
    "assume that the chain consists of @xmath52 roads .",
    "then each road except the first and last one decomposes into three road sections split by two junctions , a longer central section and two short end sections ; the first and last road consist of only two road sections , a short one and a long one , separated by one junction .",
    "( these two roads will later be connected to other gadgets ; indicated by dotted squares in fig .",
    "[ fig : gadgets]c ) . ) the label length and distance between junctions is chosen so that for each road either the central and one end section is identified , or no section at all is identified .",
    "for the first and last road , both sections are identified if the junction is covered and otherwise only the long section can be identified .",
    "we have @xmath53 roads and @xmath54 junctions .",
    "each label must block a junction , if it identifies two sections .",
    "so the best possible configuration blocks all junctions and identifies @xmath55 road sections .",
    "the chain gadget has exactly two states , in which @xmath56 road sections are identified .",
    "either the label of the first road does not block a junction and identifies a single section and all subsequent roads have their label cover the junction with the preceding road in the sequence , or the label of the last road does not block a junction and all other roads have their label cover the junction with the successive road in the sequence . in any other configuration there is at least one road without any identified section and thus at most @xmath57 sections are identified .",
    "we use the two optimal states of the gadget to represent and transmit the values _ true _ and _ false _ from one end to the other .",
    "_ fork gadget .",
    "_ the _ fork gadget _ allows to split the value represented in one chain into two chains , which is needed to transmit the truth value of a variable into multiple clauses . to that end",
    "it connects to an end road of three chain gadgets by sharing junctions .",
    "the core of the fork consists of six roads  @xmath58 , whereas @xmath59 , @xmath60 , and @xmath61 are vertical line segments and @xmath62 , @xmath63 and @xmath64 are horizontal line segments ; see fig .",
    "[ fig : np : fork ] .",
    "we arrange those roads such that @xmath59 and @xmath60 have each one junction with  @xmath62 and one junction with  @xmath63 .",
    "further , @xmath61 has one junction with @xmath62 , one with  @xmath63 and one with @xmath64 .",
    "the label length of those roads is chosen so that it is exactly the length of the roads .",
    "hence , a placed label idenfies all road sections of the roads .",
    "further , there are three roads @xmath65 ,",
    "@xmath66 , @xmath67 such that @xmath65 has one junction with  @xmath59 , @xmath66 has one junction with @xmath60 and @xmath67 has one junction with @xmath64 . in all three cases",
    "we place the junction so that it splits the road in a short road section that is shorter than the road s label length and a long road section that has exactly the road s label length .",
    "we call @xmath65 , @xmath66 and @xmath67 _ gates _ , because later these roads will be connected to the end roads of chains by junctions .",
    "to that end those _ connecting _ junctions will be placed on the long road sections of the gates ; see violet dotted areas in fig .",
    "[ fig : np : fork ] .",
    "the fork gadget has exactly two states , in which 16 road sections are identified . in the first state the labels of @xmath59 , @xmath60 and @xmath61 are placed ; see fig  [ fig : fork : false ] .",
    "hence , the labels of @xmath65 and @xmath66 identify only the long road sections of @xmath65 and @xmath66 , but not the short ones .",
    "the label of @xmath67 idenfies both the long and short road section of  @xmath67 . in the second state",
    "the labels of @xmath62 , @xmath63 , @xmath64 are placed ; see fig  [ fig : fork : true ] .",
    "hence , the labels of @xmath65 and @xmath66 identify the long and short road sections of  @xmath65 and @xmath66 , while only the long road section of  @xmath67 is identified by a label . in any other configuration fewer road sections",
    "are identified by labels .",
    "we use the two optimal states of the gadget to represent and transmit the values _ true _ and _ false _ from one gate to the other two gates .",
    "more specifically the gates @xmath65 and @xmath66 are connected with chains that lead to the same literal , while @xmath67 is connected with a chain that leads to the complementary literal",
    ".    _ variable gadget . _",
    "we define the _ variable gadgets _ simply by connecting chain and fork gadgets into a connected component of intersecting roads .",
    "this construction already has the functionality of a variable gadget : it represents ( in a labeling identifying the maximum number of road sections ) the same truth value in all of its branches , synchronized by the fork gadgets , see the blue chains and yellow forks in fig .",
    "[ fig : gadgets]a ) .",
    "more precisely , we place a sequence of chains linked by fork gadgets along the horizontal line on which the variable vertices are placed in the drawing @xmath45 .",
    "each fork creates a branch of the variable gadget either above or below the line .",
    "we create as many branches above ( below ) the line as the variable has occurrences in positive ( negative ) clauses in @xmath44 .",
    "the first and last chain on the line also serve as branches .",
    "the synchronization of the different branches via the forks is such that either all top branches have their road labels pushed away from the line and all bottom branches pulled towards the line or vice versa . in the first case",
    ", we say that the variable is in the state _",
    "false _ and in the latter case that it is in the state _",
    "true_. the example in fig .",
    "[ fig : gadgets ] has two variables set to _ true _ and three variables set to _",
    "_ clause gadget .",
    "_ finally , we need to create the clause gadget , which links three branches of different variables .",
    "the core of the gadget is a single road that consists of three sub - paths meeting in one junction .",
    "each sub - path of that road shares another junction with one of the three incoming variable branches . beyond each of these three junctions",
    "the final road sections are just long enough so that a label can be placed on the section . however , the section between the central junction of the clause road and the junctions with the literal roads is shorter than the label length .",
    "the road of the clause gadget has six sections in total and we argue that the six sections can only be identified if at least one incoming literal evaluates to _ true_. otherwise at most five sections can be identified . by construction , each road in the chain of a false literal has its label pushed towards the clause , i.e. , it blocks the junction with the clause road . as long as at least one of these three junctions is not blocked ,",
    "all sections can be identified ; see fig .",
    "[ fig : gadgets]b ) .",
    "but if all three junctions are blocked , then only two of the three inner sections of the clause road can be identified and the third one remains unlabeled ; see fig .  [",
    "fig : gadgets]b ) .",
    "_ reduction .",
    "_ obviously , the size of the instance @xmath46 is polynomial in @xmath5 and @xmath6 .",
    "if we have a satisfying variable assignment for @xmath44 , we can construct the corresponding road labeling and the number of identified road sections is six per clause and a fixed constant number @xmath68 of sections in the variable gadgets , i.e. , at least @xmath69 . on the other hand , if we have a road labeling with at least @xmath43 identified sections , each variable gadget is in one of its two maximum configurations and each clause road has at least one label that covers a junction with a literal road , meaning that the corresponding truth value assignment of the variables is indeed a satisfying one .",
    "this concludes the reduction .",
    "since  maxidentifiedroadsis an optimization problem , we only present the  -hardness proof .",
    "still , one can argue that the corresponding decision problem is -complete by guessing which junctions are covered by which label and then using linear programming for computing the label positions .",
    "we omit the technical details .",
    "further , most roads in the reduction are paths , except for the central road in each clause gadget , which is a degree-3 star .",
    "in fact , we can strengthen theorem  [ thm : npc ] by using a more complex clause gadget instead that uses only paths ; see appendix  [ apx : alt - clause ] .        in this section",
    "we describe a clause gadget that can be used as an alternative to the one presented in section  [ sec : np - hardness ] .",
    "since it consists only of roads that are paths , this gadget strengthens theorem  [ thm : npc ] .",
    "the clause gadget consists of ten roads , @xmath28 , @xmath382 , @xmath383 , @xmath384 , @xmath385 , @xmath386 and @xmath387 with  @xmath388 that all are paths ; see fig .",
    "[ fig : np : clause2 ] . going along  @xmath28 from one end to the other , the junctions with the roads @xmath385",
    ", @xmath386 and @xmath387 ( @xmath389 ) occur in three densely packed blocks .",
    "the blocks are described by the sequence of roads intersecting  @xmath28 .",
    "the first block is  @xmath390 , the second block is @xmath391 and the third block is @xmath392 .",
    "the label length of  @xmath28 is chosen so that at most three labels can be placed on @xmath28 , but each road section is shorter than a label of  @xmath28 .",
    "choosing the length of the road sections appropriately , we further ensure that we can place a label that crosses all junctions of one of the blocks without crossing the junctions of another block .",
    "we now describe junctions of the roads  @xmath382 , @xmath383 , @xmath384 , @xmath385 , @xmath386 and @xmath387 with  @xmath388 . the road  @xmath393 first intersects @xmath382 and then @xmath28 twice .",
    "let  @xmath394 , @xmath395 , @xmath396 and  @xmath397 denote these road sections in that particular order .",
    "the length of  @xmath394 is chosen so that a single label can be placed on  @xmath394 , while the others are shorter than the label length of  @xmath393 .",
    "more specifically , we define @xmath393 s label length such that a label identifies the sections in either @xmath398 , @xmath399 , @xmath400 , @xmath401 or @xmath402",
    ". we define the intersections and the label length for  @xmath403 , analogously .",
    "further ,  @xmath382 intersects @xmath393 and @xmath403 in one junction , i.e. , the edge of  @xmath382 connecting both junction vertices is a junction edge . the label length of  @xmath382 is chosen so that a label can cross  @xmath382 s only junction .",
    "the length of  @xmath382 s road sections is at least as long as @xmath382 s label length .",
    "we call @xmath382 a _ gate _",
    ", because later this road will be connected to the end road of a chain by a junction ; see violet square in fig .",
    "[ fig : np : clause2:structure ] . for @xmath404 , @xmath405 , @xmath219 , @xmath220",
    "we introduce analogous junctions and road sections , however , @xmath404 and @xmath405 intersect  @xmath383 instead of  @xmath382 , and @xmath219 and @xmath220 intersect  @xmath384 instead of  @xmath382 .    in order to identify both road sections of a gate ,",
    "either two labels can be placed on the road sections separately , or one label that goes through the junction . in the former case",
    "the gate is _ open _ and in latter case it is _ closed _ ; see fig .",
    "[ fig : np : clause2:true ] .",
    "we observe that it only makes sense to close a gate , if at least one road section of the gate does not allow to place a label that is only contained in that road section .",
    "this case will occur if and only if the connected chain transmits the value _",
    "false _ to the clause .",
    "assume that at least one gate is open , i.e. , one literal of the clause is true ; see fig .",
    "[ fig : np : clause2:true ] . without loss of generality",
    "let  @xmath382 be open .",
    "we place a label  @xmath406 on @xmath28 such that it crosses the junctions of block @xmath407 and identifies 5 sections .",
    "since  @xmath382 is open , we can place a label  @xmath34 that identifies  @xmath394 and @xmath395 .",
    "analogously , we can place a label  @xmath35 identifying @xmath408 and @xmath409 . placing further labels as indicated in fig .",
    "[ fig : np : clause2:true ] , we identify five road sections of  @xmath28 and all road sections of any other road except for  @xmath410 , @xmath411 .",
    "hence , 33 road sections are identified .",
    "we observe that we can place the labels of @xmath404 , @xmath405 , @xmath219 , @xmath220 such that they do not cross the junctions of  @xmath383 and @xmath384 , respectively .",
    "hence , it does not matter whether @xmath383 and @xmath384 are closed or open , i.e. , it does not matter whether the corresponding literals are _ true _ or _",
    "false_.    we now argue that this is an optimal labeling .",
    "if  @xmath410 or @xmath411 were labeled , the label @xmath406 must be placed such that the junctions of @xmath28 with  @xmath220 and @xmath404 are not crossed , respectively .",
    "this decreases the number of identified road sections as least as much identifying @xmath410 and @xmath411 increases the number of identified road sections . in order to identify at least one of the unidentified road sections of  @xmath28",
    ", we need to place a label that crosses  @xmath412 or @xmath413 .",
    "obviously , this yields a smaller number of identified road sections than 31 .",
    "finally , assume that all gates are closed ; see fig .",
    "[ fig : np : clause2:false ] .",
    "consider , the same labeling as before .",
    "however , this time we can not label  @xmath395 and @xmath409 anymore . hence , this labeling has only 29 identified road sections .",
    "obviously , it can not be improved by changing the placement of the remaining labels or adding labels .",
    "maxidentifiedroadsfor trees ; section  [ sec : trees - faster ] shows how to improve its running time and space consumption .",
    "our approach uses the basic idea that removing the vertices , whose embeddings lie in a curve @xmath71 , splits the tree into independent parts . in particular this",
    "is true for labels .",
    "we assume that  @xmath72 is rooted at an arbitrary leaf  @xmath73 and that its edges are directed away from  @xmath73 ;  see fig .",
    "[ fig : tree : basic - definitions ] . for two points @xmath74",
    "we define @xmath75 as the length of the shortest curve in  @xmath76 that connects  @xmath77 and  @xmath78 . for two vertices @xmath79 and @xmath10 of  @xmath72 we also write @xmath80 instead of @xmath81 . for a point",
    "@xmath82 we abbreviate the distance  @xmath83 to the root  @xmath73 by  @xmath84 . for a curve  @xmath23 in @xmath76 ,",
    "we call  @xmath85 the _ lowest point _ of  @xmath23 if @xmath86 for any  @xmath87 .",
    "as  @xmath72 is a tree ,  @xmath77 is unique .",
    "we distinguish two types of curves in  @xmath76 .",
    "a curve  @xmath23 is  _ vertical _ if  @xmath25 or  @xmath26 is the lowest point of  @xmath23 ; otherwise we call @xmath23 _ horizontal _ ( see  [ fig : tree : basic - definitions ] ) . without loss of generality",
    "we assume that the lowest point of each vertical curve @xmath23 is its tail @xmath26 .",
    "since labels are modeled as curves , they are also either vertical or horizontal . for a vertex @xmath88 let @xmath89 denote the subtree rooted at @xmath79 .",
    "we first determine a finite set of candidate positions for the heads and tails of labels , and transform @xmath72 into a tree @xmath90 by subdividing some of @xmath72 s edges so that it contains a vertex for every candidate position . to that end",
    "we construct for each regular vertex @xmath91 a chain of tightly packed vertical labels that starts at @xmath17 , is directed towards @xmath73 , and ends when either the road ends , or adding the next label does not increase the number of identified road sections .",
    "more specifically , we place a first vertical label  @xmath34 such that @xmath92 . for @xmath93 we add a new vertical label @xmath94 with @xmath95 = @xmath96 , as long as @xmath95 and @xmath97 do not lie on the same road section and none of @xmath94 s endpoints lie on a junction edge .",
    "we use the tails of all those labels to subdivide the tree @xmath72 . doing this for all regular vertices of  @xmath72 we obtain the tree  @xmath98 , which we call the _ subdivision tree _ of  @xmath72 .",
    "the vertices in @xmath99 are neither junction vertices nor regular vertices .",
    "since each chain consists of @xmath100 labels the cardinality of  @xmath101 is  @xmath102 .",
    "we call an optimal labeling @xmath103 of @xmath72 an _ canonical labeling _ if for each label @xmath104 there exists a vertex @xmath10 in   @xmath98 with @xmath105 or @xmath106 .",
    "the next lemma proves that is sufficient to consider canonical labelings .",
    "let  @xmath30 be an optimal labeling of  @xmath72 .",
    "we _ push _ the labels of @xmath30 as far as possible towards the leaves of  @xmath72 without changing the identified road sections ; see fig .  [",
    "fig : tree : packed - labels ] .",
    "more specifically , starting with the labels closest to the leaves , we move each label away from the root as far as possible while its head and tail must remain on their respective road sections . for a vertical label",
    "this direction is unique , while for horizontal labels we can choose any of the two .",
    "then , for each label its head or tail either coincides with a leaf of @xmath72 , with some internal regular vertex , or with the head of another label . consequently , each vertical label belongs to a chain of tightly packed vertical labels starting at a regular vertex  @xmath107 .",
    "further , the head or tail of each horizontal label coincides with the end of a chain of tightly packed vertical labels or a regular vertex of  @xmath72 , which proves the claim .        a maximum number of road sections in @xmath72 only using valid labels in @xmath110 , where @xmath111 denotes the subtree of @xmath98 rooted at  @xmath79 .",
    "note that those labels also may identify the incoming road section of @xmath79 , e.g. , label  @xmath23 in fig .",
    "[ fig : tree : packed - labels]b ) identifies the edge  @xmath112 .",
    "further , the children of a vertex @xmath108 are denoted by the set  @xmath113 ; we explicitly exclude the parent of  @xmath79 from @xmath113 .",
    "further , consider an arbitrary curve  @xmath23 in @xmath76 and let  @xmath114 .",
    "we observe that removing all vertices of @xmath98 contained in @xmath39 together with their incident outgoing edges creates several independent subtrees .",
    "we call the roots of these subtrees ( except the one containing @xmath73 ) _ children _ of @xmath23 ( see fig .  [",
    "fig : tree : basic - definitions ] ) .",
    "if no vertex of  @xmath98 lies in  @xmath39 , the curve is contained in a single edge  @xmath115 . in that case",
    "@xmath10 is the only child of  @xmath23 .",
    "we denote the set of all children of @xmath23 as @xmath116 .    for each vertex @xmath79 in @xmath98",
    "we introduce a set @xmath117 of _ candidates _ , which model potential labels with lowest point  @xmath118 . if  @xmath79 is a regular vertex of  @xmath72 or  @xmath119 , the set  @xmath117 contains all vertical labels  @xmath23 with lowest point  @xmath118 .",
    "if  @xmath79 is a junction vertex , @xmath117 contains all horizontal labels that start or end at a vertex of @xmath98 and whose lowest point is  @xmath118 . in both cases we assume that  @xmath117 also contains the degenerated curve  @xmath120 , which is the",
    "_ dummy label _ of  @xmath79 .",
    "we set @xmath121 and  @xmath122 .",
    "for a curve  @xmath23 we define @xmath123 .",
    "thus , @xmath124 is a labeling comprising @xmath23 and the labels of its children s optimal labelings .",
    "we call a label @xmath125 with @xmath126 an _ optimal candidate _ of  @xmath79 .",
    "next , we prove that it is sufficient to consider optimal candidates to construct a canonical labeling .",
    "first note that @xmath129 because both labelings @xmath109 and @xmath130 only contain labels that are embedded in @xmath110 . by lemma  [ lem :",
    "tree : canonical - labeling ] we can assume without loss of generality that  @xmath109 is a canonical labeling . let  @xmath23 be the label of @xmath109 with @xmath118 as the lowest point of  @xmath23 ( if it exists ) .",
    "if @xmath23 exists , then the vertices in  @xmath116 are roots of independent subtrees , which directly yields @xmath131 . by construction of @xmath117",
    "we further know that  @xmath23 is contained in  @xmath117 .",
    "hence , @xmath23 is an optimal candidate of  @xmath79 , which implies  @xmath132 .",
    "if  @xmath23 does not exist , then we have @xmath133 equality @xmath134 follows from @xmath121 and the definition that @xmath135 does not identify any road section .",
    "since  @xmath135 is contained in @xmath117 , the dummy label @xmath135 is the optimal candidate  @xmath127 .",
    "algorithm  [ algo : basic - approach ] first constructs the subdivision tree @xmath136 from @xmath72 .",
    "then starting with the leaves of  @xmath98 and going to the root  @xmath73 of  @xmath98 , it computes an optimal candidate  @xmath137`optcandidate`@xmath138 for each vertex  @xmath108 in a bottom - up fashion . by lemma  [ lem :",
    "tree : basic - approach ] the labeling  @xmath139 is an optimal labeling of  @xmath111 . in particular",
    "@xmath140 is the optimal labeling of  @xmath72 .      due to the size of the subdivision tree",
    "@xmath98 we consider @xmath102 vertices .",
    "implementing @xmath143 , which computes an optimal candidate  @xmath127 for @xmath79 , naively , creates  @xmath117 explicitly .",
    "we observe that if @xmath79 is a junction vertex , @xmath117 may contain @xmath102 labels ; @xmath102 pairs of road sections of different subtrees of @xmath79 can be connected by horizontal labels .",
    "each label can be constructed in  @xmath100 time using a breadth - first search .",
    "thus , for each vertex  @xmath79 the procedure ` optcandidate ` needs in a naive implementation @xmath144 time , which yields @xmath145 running time in total .",
    "further , we need @xmath102 storage to store @xmath98 .",
    "note that we do not need to store @xmath109 for each vertex  @xmath79 of @xmath98 , but by lemma  [ lem : tree : basic - approach ] we can reconstruct it using @xmath146 , where  @xmath127 is the optimal candidate of  @xmath79 . to that end",
    "we store for each vertex of @xmath98 its optimal candidate  @xmath127 and @xmath147 .      in case",
    "that all roads are paths , algorithm  [ algo : basic - approach ] runs in  @xmath148 time , because for each @xmath108 the set  @xmath117 contains  @xmath100 labels .",
    "further , besides the _ primary objective _ to identify a maximum number of road sections , chiri  @xcite also suggested several additional _ secondary objectives _ , e.g. , labels should overlap as few junctions as possible .",
    "our approach allows us to easily incorporate secondary objectives by changing the weight function @xmath149 appropriately .        for an edge",
    "@xmath150 we call a vertical curve @xmath151 an _ @xmath20-rooted _ curve , if  @xmath152 , @xmath25 lies on a road section , and @xmath153 , i.e. , @xmath23 emanates from  @xmath118 passing through  @xmath20 ; for example the red label in fig .",
    "[ fig : tree : packed - labels]b ) is an @xmath20-rooted curve .",
    "an @xmath20-rooted curve  @xmath23 is _ maximal _ if there is no other @xmath20-rooted curve  @xmath39 with @xmath154 and @xmath155 .",
    "we observe that in any canonical labeling each vertical label  @xmath23 is a  @xmath156-rooted curve with  @xmath115 , and each horizontal label  @xmath23 can be composed of a @xmath157-rooted curve  @xmath34 and a @xmath158-rooted curve  @xmath35 with  @xmath159 and  @xmath118 is the lowest point of  @xmath23 ; see fig .",
    "[ fig : tree : regular - vertex ] and fig .",
    "[ fig : tree : junction - vertex ] , respectively .",
    "further , for a vertical curve  @xmath160 in @xmath76 its _ distance interval @xmath161 _ is @xmath162 $ ] . since  @xmath72 is a tree , for every point @xmath77 of @xmath160 we have @xmath163 .",
    "next , we introduce a data structure that encodes for each edge  @xmath156 of  @xmath72 all maximal @xmath156-rooted curves as  @xmath100 superposition - free curves in @xmath166 .",
    "in particular , each of those curves lies on a single road section such that all @xmath156-rooted curves ending on that curve are maximal and identify the same number of road sections .",
    "we define this data structure as follows .",
    "assume that we apply algorithm  [ algo : basic - approach ] on @xmath98 and that we currently consider the vertex @xmath79 of @xmath98 .",
    "hence , we can assume that for each vertex @xmath176 of @xmath111 its optimal candidate and @xmath177 is given .",
    "we first explain how to speed up  ` optcandidate ` using linearizations .",
    "afterwards , we present the construction of linearizations .",
    "_ case 1 , @xmath79 is regular . _",
    "if  @xmath79 is a leaf , the set @xmath117 contains only  @xmath135 .",
    "hence , assume that  @xmath79 has one outgoing edge  @xmath178 , which belongs to a road  @xmath21 .",
    "let @xmath179 be the longest path of vertices in  @xmath111 that starts at  @xmath79 and does not contain any junction vertex .",
    "note that the path must be unique .",
    "further , by construction of  @xmath98 the last vertex  @xmath180 of @xmath179 must be a regular vertex in  @xmath181 , but not in @xmath99 .",
    "we consider two cases ; see fig  [ fig : tree : regular - vertex ] .      if @xmath182 , the optimal candidate is either @xmath135 or the @xmath20-rooted curve  @xmath23 of length  @xmath15 that ends on @xmath183 . by assumption and due to @xmath184 , we decide in @xmath185 time whether @xmath186 , obtaining the optimal candidate .    if @xmath187 , the optimal candidate is either  @xmath135 or goes through a junction .",
    "since  @xmath180 is regular , it has only one outgoing edge  @xmath188 .",
    "further , by the choice of  @xmath179 the edge  @xmath112 is a junction edge in @xmath72 ; therefore the linearization @xmath168 of @xmath112 is given .",
    "in linear time we search for the curve @xmath189 such that there is an @xmath20-rooted curve  @xmath23 of length  @xmath15 with its head on @xmath160 . to that end",
    "we consider for each curve  @xmath189 its distance interval @xmath161 and check whether there is @xmath190 with @xmath191 .",
    "note that using a binary search tree for finding  @xmath160 speeds this procedure up to @xmath192 time , however , this does not asymptotically improve the total running time .",
    "the @xmath20-rooted curve  @xmath23 then can be easily constructed in @xmath100 time by walking from  @xmath160 to  @xmath79 in  @xmath76 .",
    "note that we have @xmath184 and @xmath193 .",
    "if @xmath160 does not exist , again by definition of a linearization there is no vertical label  @xmath194 and @xmath135 is the optimal candidate . _",
    "case 2 , @xmath79 is a junction vertex . _",
    "the set @xmath117 contains horizontal labels .",
    "let  @xmath23 be such a label and let @xmath195 and @xmath196 be two junction edges in @xmath11 covered by  @xmath23 ; see fig .",
    "[ fig : tree : junction - vertex ] .",
    "then there is an @xmath197-rooted curve @xmath34 and an @xmath198-rooted curve @xmath35 whose composition is  @xmath23 .",
    "further , we have @xmath199 .",
    "we use this as follows .",
    "let @xmath197 and @xmath198 be two outgoing edges of  @xmath79 that belong to the same road  @xmath21 , and let @xmath200 and @xmath201 be the linearizations of @xmath197 and @xmath198 , respectively .",
    "we define for @xmath197 and @xmath198 and their linearizations the operation @xmath202 that finds an optimal candidate of @xmath79 restricted to labels identifying @xmath197 and @xmath198 .        applying  @xmath208 on the boundaries of the distance intervals of the curves in @xmath209 , we first mirror these intervals such that they are contained in the interval  @xmath210 $ ]",
    "; see fig .",
    "[ fig : tree : merge - linearizations ] . thus , the curves in  @xmath211 are mutually superposition - free such that their distance intervals lie in  @xmath212 $ ] .",
    "we call an interval @xmath213 \\subseteq j$ ] a _ window _ , if it has length @xmath15 , @xmath214 $ ] and there are curves @xmath215 and @xmath216 with @xmath217 and @xmath218 ; see fig .",
    "[ fig : tree : merge - linearizations ] . by the definition of a linearization",
    "there is a maximal @xmath197-rooted curve @xmath34 ending on @xmath219 and a maximal @xmath198-rooted curve @xmath35 ending on @xmath220 such that @xmath221 .",
    "consequently , the composition of @xmath34 and @xmath35 forms a horizontal label  @xmath23 with @xmath222 ; we call @xmath223 the _ value _ of the window . using a simple sweep from left to",
    "right we compute for the distance interval  @xmath161 of each curve @xmath224 a window  @xmath213 $ ] that starts or ends in @xmath161 ( if such a window exists ) .",
    "the result of @xmath202 is then the label @xmath23 of the window with maximum value . for each pair @xmath197 and @xmath198 of outgoing edges we apply @xmath202 computing a label @xmath23 . by construction",
    "either the label  @xmath23 with maximum @xmath32 or @xmath135 is the optimal candidate for  @xmath79 , which we can check in @xmath185 time . later on",
    "we prove that we consider only linearizations of linear size .",
    "since each vertex of  @xmath98 has constant degree , we obtain the next lemma .",
    "we now show how to recursively construct a linearization for an edge @xmath167 of  @xmath72 . to that end",
    "we assume that we are given the subdivision tree @xmath98 of @xmath72 and the linearizations for the outgoing edges  @xmath226 of  @xmath10 that belong to the same road  @xmath21 as  @xmath20 .",
    "further , we can assume that we have computed the weight @xmath227 for all vertices  @xmath180 in @xmath111 excluding @xmath79 . in case that two vertices of those vertices share the same position in @xmath110 we",
    "remove that one with less weight .",
    "let @xmath228 be the tree induced by the edges @xmath20 , @xmath229 and the edges of the subtree rooted at  @xmath230 .",
    "as a first step we compute for each linearization @xmath168 of each edge  @xmath229 a linearization @xmath231 for @xmath20 restricted to tree  @xmath228 , i.e. , conceptually , we assume that @xmath89 only consists of @xmath228 s edges .      otherwise , if @xmath20 is a road section , let @xmath235 be the vertices of the subdivision tree  @xmath98 that lie on  @xmath20 , i.e. , @xmath236 for all @xmath237 ; see fig .",
    "[ fig : tree : construction - step1 ] .",
    "we assume that @xmath238 , which in particular yields @xmath239 and @xmath240 .",
    "let @xmath219 be the curve  @xmath241 and for @xmath242 let  @xmath243 be the curve @xmath244 .",
    "hence , we have @xmath245 and @xmath246 for @xmath247 .",
    "we set @xmath248 we weight each curve @xmath249 as follows . if @xmath160 is contained in @xmath169 , we set @xmath250 otherwise , @xmath160 is a sub - curve of @xmath18 and there exists a @xmath251 with @xmath252 .",
    "we set @xmath253 where @xmath254 is an @xmath20-rooted curve that starts at @xmath118 and ends on @xmath160 .",
    "the next lemma shows that this transformation yields a linearization as desired .",
    "first of all , the set @xmath255 contains only curves that do not superpose each other : since @xmath255 contains only curves that do not superpose each other , the only curves that could superpose another curve in @xmath169 are contained in @xmath256 .",
    "since @xmath257 is empty for a junction edge , we can assume that  @xmath20 is a road section . by construction those curves in @xmath256",
    "partition  @xmath18 without intersecting each other .",
    "further , by assumption no two road sections share a common vertex and since all curves of  @xmath169 are contained in @xmath258 , the curves in @xmath256 can not superpose any curve in  @xmath169 .        _",
    "condition  ( [ lin : cond2])_. first consider an @xmath20-rooted curve  @xmath23 that either ends on @xmath229 or on an edge of  @xmath259 . recall that @xmath25 must lie on a road section .",
    "then there is an  @xmath229-rooted curve  @xmath39 with  @xmath260 and  @xmath261 .",
    "hence , there is a curve  @xmath171 with @xmath262 .",
    "since  @xmath39 is a sub - curve of  @xmath23 , we also have @xmath263 .",
    "now , consider an @xmath20-rooted curve  @xmath23 that ends on @xmath20 , then  obviously by construction there is a curve  @xmath264 with @xmath263 .    _",
    "condition  ( [ lin : cond3])_. first consider an arbitrary curve  @xmath264 and let  @xmath23 be any @xmath20-rooted curve that ends on @xmath160 .",
    "further , let @xmath235 be the vertices of the subdivision tree  @xmath98 that lie on  @xmath20 as defined above . by construction",
    "there is an edge  @xmath265 with @xmath266 and @xmath267 .",
    "it holds @xmath268 obviously , @xmath23 must be maximal , because there is no other point in @xmath269 having the same distance to  @xmath73 as @xmath25 has .    finally , consider a curve  @xmath171 and let  @xmath23 be any @xmath20-rooted curve that ends on  @xmath160 .",
    "as  @xmath169 is a linearization of  @xmath229 , for each point  @xmath77 on @xmath160 there must be an @xmath229-rooted curve  @xmath39 with  @xmath270 .",
    "we choose  @xmath39 such that  @xmath271 .",
    "since  @xmath39 is a maximal @xmath229-rooted curve , the curve @xmath23 must be a maximal @xmath20-rooted curve .",
    "further , @xmath23 identifies one road section more than  @xmath39 .",
    "hence , we obtain @xmath272      _ condition  ( [ lin : cond3])_. let  @xmath160 be a curve in @xmath255 and let @xmath23 be any @xmath20-rooted curve that ends on  @xmath160 .",
    "further , let  @xmath39 be the @xmath229-rooted sub - curve of  @xmath23 that starts at @xmath17 and ends at @xmath25 ; by definition of @xmath169 such a curve exists .",
    "it holds @xmath274 since  @xmath39 is a maximal  @xmath229-rooted curve , it directly follows that @xmath23 is a maximal @xmath20-rooted curve with respect to  @xmath228 .    in the next step",
    "we define an operation @xmath275 by means of which two linearizations @xmath231 and @xmath276 can be combined to one linearization @xmath277 of @xmath20 that is restricted to the subtree  @xmath278 induced by the edges of @xmath228 and @xmath225 .",
    "consequently , @xmath279 is the linearization of @xmath20 without any restrictions .",
    "we define @xmath281 as follows ; for illustration see also fig .  [",
    "fig : tree : merge ] .",
    "let @xmath282 be the curves of @xmath283 such that for any two curves @xmath284 , @xmath285 with @xmath286 the left endpoint of  @xmath287 lies to the left of the left endpoint of @xmath288 ; ties are broken arbitrarily .",
    "we successively add the curves to  @xmath169 in the given order enforcing that the curves in @xmath169 remain superposition - free .",
    "let @xmath160 be the next curve to be added to @xmath169",
    ".    without loss of generality , let  @xmath289 .",
    "the opposite case can be handled analogously . in case",
    "that there is no curve superposing @xmath160 , we add @xmath160 to @xmath169 and set @xmath290 .",
    "if @xmath160 superposes a curve in @xmath169 , due the order of insertion , there can only be one curve @xmath164 in @xmath169 that superposes @xmath160 .",
    "first we remove @xmath164 from @xmath169 .",
    "let @xmath291 be the interval describing the set @xmath292 , and let @xmath293 and @xmath294 be the intervals describing the set  @xmath295 such that @xmath293 lies to the left of  @xmath291 and  @xmath294 lies to the right of @xmath291 ; see fig .",
    "[ fig : tree : construction - step2 ] .",
    "we now define three curves @xmath296 , @xmath297 and @xmath298 with @xmath299 , @xmath300 and @xmath301 such that each of these three curves is a sub - curve of either  @xmath160 or  @xmath164 . to that end",
    "let @xmath302 $ ] denote the sub - curve of @xmath160 whose distance interval is @xmath303 .",
    "we define the curve @xmath304 with weight @xmath305 as @xmath306,{\\ensuremath{\\overline \\omega}\\xspace}_i(c ) ) , & \\text{if } i_r\\subseteq i(c)\\\\    ( c'[i_r],{\\ensuremath{\\overline \\omega}\\xspace}(c ' ) ) , & \\text{if } i_r\\subseteq i(c')\\\\ \\end{cases}\\ ] ] the curve @xmath296 and its weight @xmath307 is defined analogously .",
    "the curve  @xmath297 and its weight @xmath308 is @xmath309,{\\ensuremath{\\overline \\omega}\\xspace}_i(c ) ) , & \\text{if } { \\ensuremath{\\overline \\omega}\\xspace}_{i}(c)\\geq { \\ensuremath{\\overline \\omega}\\xspace}(c')\\\\    ( c'[i_m],{\\ensuremath{\\overline \\omega}\\xspace}(c ' ) ) , & \\text{if } { \\ensuremath{\\overline \\omega}\\xspace}_{i}(c ) < { \\ensuremath{\\overline \\omega}\\xspace}(c')\\\\ \\end{cases}\\ ] ] the next lemma proves that @xmath277 is a restricted linearization .",
    "[ lem : tree : construct2 ] let @xmath231 and @xmath276 be two linearizations of @xmath167 that are restricted to the trees @xmath228 and @xmath225 , respectively . then @xmath310 is a linearization of @xmath20 restricted to  @xmath278 .",
    "the operation needs @xmath311 time .",
    "first of all , the set @xmath169 contains only curves that are pairwise free from any superpositions .",
    "this directly follows from the construction that curves  @xmath160 and @xmath164 superposing each other are replaced by three superposition - free curves @xmath296 , @xmath297 and @xmath304 . due to @xmath312 the first and second condition of a linearization is satisfied .",
    "we finally prove that condition  ( [ lin : cond3 ] ) of a linearization is satisfied by doing an induction over the curves inserted to  @xmath169 .",
    "let  @xmath313 be  @xmath169 after the @xmath53-th insertion step .",
    "since @xmath314 is empty , the condition obviously holds for @xmath314 .",
    "so assume that we insert @xmath160 to @xmath313 obtaining the set @xmath315 .",
    "without loss of generality assume that  @xmath249 .",
    "if @xmath160 does not superpose any curve in @xmath313 , the condition directly follows from the definition of  @xmath160 .",
    "so assume that  @xmath316 superposes @xmath160 .",
    "since  @xmath249 , the curve  @xmath164 is contained in  @xmath317 .",
    "we remove @xmath164 from  @xmath313 and insert the curves @xmath304 , @xmath297 and @xmath296 as defined above .",
    "we prove that all three curves satisfy condition  ( [ lin : cond3 ] ) .",
    "consider in the following the subtree  @xmath278 of @xmath89 restricted to the edges of  @xmath228 and  @xmath225 .",
    "we set @xmath318 $ ] and set @xmath319 , if @xmath320 . in that case",
    "there is no @xmath20-rooted curve  @xmath321 with  @xmath322 , i.e. , either there is no curve  @xmath23 in @xmath317 with @xmath152 and @xmath322 , or any curve in @xmath317 with @xmath152 and @xmath322 ends on a junction edge .",
    "consequently , any @xmath20-rooted curve @xmath23 with  @xmath322 and in particular any maximal @xmath20-rooted curve  @xmath23 with  @xmath322 lies in @xmath269 .",
    "thus , the curve  @xmath304 satisfies condition  ( [ lin : cond3 ] ) . for the case @xmath323 and the curve @xmath296 we can argue analogously .    so consider the curve  @xmath297 . without loss of generality",
    "we assume that  @xmath324 .",
    "the opposite case can be handled analogously . for any maximal @xmath20-rooted curve  @xmath23 in @xmath317 with @xmath325",
    "it must be true that @xmath326 .",
    "further , since  @xmath327 and @xmath160 satisfies condition  ( [ lin : cond3 ] ) with respect to  @xmath228 , @xmath297 satisfies the condition  ( [ lin : cond3 ] ) with respect to  @xmath278 .      note that when computing optimal candidates ( see _ application of linearizations _ ) we are only interested in @xmath20-rooted curves  @xmath23 that have length at most @xmath15 , where @xmath21 is the road of  @xmath20 .",
    "hence , when constructing @xmath231 for an edge  @xmath229 in the first step , we discard any curve  @xmath160 of  @xmath255 that does not allow an @xmath20-rooted curve that both ends on  @xmath160 and has length at most  @xmath15 ; the curve @xmath160 is not necessary for our purposes .",
    "hence , we conceptually restrict @xmath228 to the edges that are reachable from  @xmath79 by one label length .",
    "it is not hard to see that  @xmath98 restricted to @xmath269 contains only @xmath100 vertices , because each vertex of  @xmath99 is induced by a chain of tightly packed vertical labels , whereas each label has length @xmath15 .",
    "hence , @xmath98 restricted to @xmath269 contains for each such chain at most one vertex of @xmath99 .",
    "further , the endpoints of the curves in  @xmath255 are induced by the vertices of @xmath98 .",
    "hence , by discarding the unnecessary curves of  @xmath255 the set @xmath255 has size @xmath100 . altogether , by lemma  [ lem : tree : construct2 ] and due to the constant degree of each vertex we can construct @xmath330 in @xmath331 time .",
    "when constructing @xmath109 for @xmath79 as described in algorithm  [ algo : basic - approach ] , we first build the linearization  @xmath332 of each of @xmath79 s outgoing edges . by lemma  [ lem : tree : apply - lin ] we can find in @xmath100 time the optimal candidate of @xmath79 .",
    "then , due to the previous reasoning , the linearization of an edge of @xmath72 and the optimal candidate of a vertex  @xmath79 can be constructed in  @xmath100 time .",
    "altogether we obtain the following result .",
    "since  @xmath98 contains @xmath102 vertices , the algorithm needs  @xmath102 space .",
    "this can be improved to  @xmath100 space . to that end",
    "@xmath98 is constructed _ on the fly _ while executing algorithm  [ algo : basic - approach ] .",
    "parts of  @xmath98 that become unnecessary are discarded .",
    "we prove that it is sufficient to store @xmath100 vertices of  @xmath98 at any time such that the optimal labeling can still be constructed .",
    "afterwards we discard the linearizations of those outgoing edges . since each vertex has constant degree , considering the vertices of @xmath98 in an appropriate order , it is sufficient to maintain a constant number of linearizations at any time .",
    "hence , because each linearization has size @xmath100 , we need @xmath100 space for storing the required linearizations in total .",
    "however , we store for each vertex  @xmath79 of  @xmath98 the weight  @xmath333 and its optimal candidate .",
    "as  @xmath98 has size @xmath102 the space consumption is @xmath102 . in the following we",
    "improve that bound to  @xmath100 space .",
    "we call a vertex  @xmath334 _ reachable _ from a vertex  @xmath108 , if there is a curve  @xmath335 that starts at  @xmath118 and that is contained in the embedding of a road  @xmath21 with @xmath336 such that  @xmath337 or @xmath338 , where  @xmath27 denotes the length of  @xmath23 ; see fig .  [",
    "fig : tree : reachable ] .",
    "the set  @xmath339 contains all vertices of  @xmath111 that are reachable from  @xmath79 .",
    "the next lemma shows that  @xmath339 has linear size .",
    "recall how @xmath98 is constructed : for each vertex @xmath91 we construct a chain  @xmath340 of tightly packed vertical valid labels , which starts at @xmath17 , is directed towards @xmath73 , and ends when either the road ends , or adding the next label does not increase the number of identified road sections .",
    "each label of such a chain @xmath340 induces one vertex of @xmath98 .",
    "hence ,  @xmath340 induces a set  @xmath341 of vertices in @xmath98 .",
    "we show that for each chain @xmath340 the set @xmath342 contains at most two vertices .",
    "as we construct @xmath5 chains in order to build @xmath98 the claim follows",
    ".    for the sake of contradiction assume that there is a chain @xmath340 and a vertex  @xmath79 in @xmath98 such that  @xmath342 contains more than two vertices . without loss of generality",
    "we assume that @xmath343 contains three vertices , which we denote by @xmath344 , @xmath345 and @xmath346 .",
    "we further assume that @xmath347 . by construction",
    "all labels in  @xmath340 lie in the embedding of the same road  @xmath348 , and @xmath349 and @xmath350 . by definition of @xmath340",
    "there is a vertical curve  @xmath351 that starts at @xmath118 and contains @xmath344 , @xmath345 and @xmath346 .",
    "let  @xmath20 be the outgoing edge of  @xmath79 in @xmath98 whose embedding is covered by @xmath23 and consider the sub - curve  @xmath260 with length  @xmath352 that starts at  @xmath79 . by definition of  @xmath339 , we know for each  @xmath353 with @xmath354 that either its embbeding is contained in  @xmath39 or @xmath355 . from the definition of  @xmath356 and the fact that all three vertices lie on  @xmath23",
    ", it directly follows that only  @xmath346 may be contained in  @xmath356 .",
    "hence , @xmath357 .",
    "further , because  @xmath358 , we have @xmath359 , which implies @xmath360 and contradicts @xmath361 .",
    "assume that we apply algorithm  [ algo : basic - approach ] considering the vertex  @xmath79 .",
    "when constructing @xmath79 s optimal candidate , by lemma  [ lem : tree : reachable ] it is sufficient to consider the vertices of  @xmath111 that lie in  @xmath339 . on that account we discard all vertices of @xmath111 that lie in @xmath99 , but not in  @xmath339 .",
    "further , we compute the vertices of @xmath99 that subdivide the incoming edge  @xmath362 _ on demand _ , i.e. , we compute them , when constructing the optimal candidate of  @xmath363 . hence , we have linear space consumption .    however , when discarding vertices of @xmath98 , we lose the possibility of reconstructing the labeling .",
    "we therefore annotate each vertex  @xmath88 of the original tree  @xmath72 with further information . to that end consider a canonical labeling  @xmath30 of  @xmath72 .",
    "let  @xmath23 be a horizontal label of  @xmath30 and let  @xmath20 be the edge of  @xmath72 on which  @xmath23 s head is located .",
    "either , no other label of  @xmath30 ends on @xmath20 , or another label  @xmath39 ends on @xmath20 that belongs to a chain  @xmath364 of tightly packed vertical labels .",
    "analogously , we can define the chain  @xmath365 with respect to edge  @xmath112 on which @xmath366 tail is located . on that account we store for a junction vertex  @xmath88 not only its optimal candidate  @xmath367 , but also the two chains  @xmath364 and @xmath365 , if they exist .",
    "note that such a chain of tightly packed vertical labels is uniquely defined by its start and endpoint , which implies that @xmath185 space is sufficient to store both chains . using a breadth - first search we can easily reconstruct those chains in linear time . for a regular vertex  @xmath88 we analogously store @xmath364 of its optimal candidate  @xmath368 , if it exists . since  @xmath23 is vertical , we do not need to consider its tail .",
    "for the special case that  @xmath369 , we define that  @xmath364 is the chain of tightly packed vertical labels that ends on the only outgoing edge  @xmath20 of  @xmath79 .",
    "summarizing , the additional information together with the optimal candidates stored at the vertices  @xmath88 of the original tree are sufficient to reconstruct the labeling of  @xmath72 . together with proposition  [ prop : tree ]",
    "we obtain the following result .",
    "although the underlying road graphs of real - world road maps are rarely trees , our algorithm for labeling trees is still of practical interest as we show in first initial experiments . the obtained data shall give the reader evidence of the practicability and relevance of our algorithm , but they are not yet a complete experimental study . for a companion paper we are working on a detailed evaluation of our approach and",
    "are investigating several practical heuristics that are based on the tree labeling algorithm .    to evaluate the usefulness of our algorithm we considered the road networks of several large cities .",
    "we extracted the road graphs from the data provided by openstreetmap and drew them mimicking the style used on openstreetmap.org as standard .",
    "in particular , we adapted the zoom level @xmath370 , which maps @xmath371 to @xmath372 pixels .",
    "on each road graph we first applied a simple preprocessing strategy removing and cutting road sections that can be labeled trivially without violating any optimal solution .",
    "in particular we applied the following rules .",
    "remove any road section that is sufficiently long to completely contain a label and whose adjacent road sections are also sufficiently long to completely contain a label . here",
    "two road sections are called _ adjacent _ , if they are connected by a path containing only junction edges .",
    ".number of connected subgraphs and road sections for road networks of five cities .",
    "the column _ subgraphs _ contains the number of connected subgraphs into which the graph is decomposed after preprocessing : 1 .",
    "the total number of subgraphs , 2 .  the number of trees , 3 .",
    "the number of subgraphs with one cycle , and 4 .  the number of subgraphs with more than one cycle .",
    "the column _ road sections _ contains the number of road sections 1 .  in total , 2 .",
    "matched by the preprocessing strategy , 3 .",
    "contained in trees , 4 .  contained in subgraphs with one cycle and 5 .  contained in subgraphs with more than one cycle .",
    "[ cols=\"^,^,^,^,^,^,^,^,^,^,^ \" , ]     that preprocessing strategy decomposed the road graphs into a large number of subgraphs ; see table  [ table : properties ] .",
    "for example , for the road network of london , which consists of @xmath373 road sections , the rules of the preprocessing strategy matched @xmath374 road sections , so that the road graph decomposed into @xmath375 subgraphs . note that if we are able to label those subgraphs optimally , we obtain an optimal labeling for the whole road network by the choice of the preprocessing rules .",
    "table  [ table : properties ] further shows that most of those subgraphs are trees ( @xmath376 for berlin as a minimum and @xmath377 for los angeles as a maximum ) .",
    "hence , using our tree labeling algorithm we can label a large number of the remaining subgraphs optimally .",
    "we conjecture that using the preprocessing strategy in combination with the tree labeling algorithm and some heuristics or exact methods for the non - tree subgraphs we can label real - world instances near - optimally .",
    "this hypothesis is also supported by the observation that most of the road sections are either matched by the preprocessing strategy or are contained in trees ( @xmath378 for paris as a minimum and @xmath379 for los angeles as a maximum ) . for our planned companion paper we are currently working on corresponding experiments investigating that conjecture .",
    "further , we are developing heuristics and exact algorithms for labeling the remaining non - tree subgraphs .            in the first case we can remove @xmath340 completely from the subgraph , such that it decomposes into a set of trees . in the second and third case",
    "the label  @xmath23 splits the cycle @xmath340 so that the remaining road sections form trees .",
    "we explore all choices of @xmath23 taking the best choice .",
    "hence , we can label subgraphs containing exactly one cycle optimally , which further increases the number of optimally labeled subgraphs ( @xmath380 for new york city as a minimum and @xmath381 for london as a maximum ) .",
    "in this paper we investigated the problem of maximizing the number of identified road sections in a labeling of a road map ; we showed that it is -hard in general , but can be solved in @xmath144 time and linear space for the special case of trees .",
    "the underlying road graphs of real - world road maps are rarely trees",
    ". initial experimental evidence indicates , however , that road maps can be decomposed into a large number of subgraphs by placing trivially optimal road labels and removing the corresponding edges from the graph .",
    "it turns out that between 85.1% and 97.7% of the resulting subgraphs are actually trees , which we can label optimally by our proposed algorithm . as a consequence , this means that a large fraction ( between 88.6% and 96.1% ) of all road sections in our real - world road graphs can be labeled optimally by combining this simple preprocessing strategy with the tree labeling algorithm .",
    "we are investigating further heuristic and exact approaches for labeling the remaining non - tree subgraphs ( e.g. , by finding suitable spanning trees and forests ) for a separate companion paper .",
    "s.  maass and j.  dllner .",
    "embedded labels for line features in interactive 3d virtual environments . in _ proc .",
    "computer graphics , virtual reality , visualisation and interaction in africa _ , afrigraph 07 , pages 5359 .",
    "acm , 2007 .",
    "m.  vaaraniemi , m.  treib , and r.  westermann .",
    "temporally coherent real - time labeling of dynamic scenes . in _ proc .",
    "conf . comput .",
    "geospatial research appl .",
    "_ , com.geo 12 , pages 17:117:10 .",
    "acm , 2012 .",
    "a.  wolff , l.  knipping , m.  van kreveld , t.  strijk , and p.  k. agarwal .",
    "a simple and efficient algorithm for high - quality line labeling . in _ innovations in gis",
    "vii : geocomputation _ , chapter  11 , pages 147159 .",
    "taylor & francis , 2000 ."
  ],
  "abstract_text": [
    "<S> a road map can be interpreted as a graph embedded in the plane , in which each vertex corresponds to a road junction and each edge to a particular road section . </S>",
    "<S> we consider the cartographic problem to place non - overlapping road labels along the edges so that as many road sections as possible are identified by their name , i.e. , covered by a label . </S>",
    "<S> we show that this is -hard in general , but the problem can be solved in polynomial time if the road map is an embedded tree . </S>"
  ]
}