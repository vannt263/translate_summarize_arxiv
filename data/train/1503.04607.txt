{
  "article_text": [
    "many basic problems from physics and other natural sciences can be solved by one - dimensional analysis , mainly due to the symmetries of nature .",
    "a successful approach is often to search for symmetric solutions , or ( through separation of variables for linear problems ) solutions which can be composed of single - variable functions with simple symmetry behavior .",
    "however , not all problems of interest enjoy a high degree of symmetry .",
    "many of them are still amenable to numerical analysis , although not always in any easily available manner . in this note",
    "we present an attempt to improve this situation for a particular class of problems from quantum mechanics , eigenvalue equations like @xmath0 \\psi_n(\\bm{r } )      = e_n \\psi_n(\\bm{r } ) ,      \\label{schrodingerequation}\\ ] ] or variants and extensions of such equations .",
    "our own interests in this class of problems arose when we attempted to generalize our method of very - high - precision solutions of such equations in one dimension @xcite to higher dimensions .",
    "our method works faster and most straightforward with some prior knowledge of eigenvalues and eigenfunctions . for one - dimensional problems such knowledge can f.i .",
    "be obtained by use of the wkb method @xcite .",
    "the corresponding information is less accessible through analytic means in higher dimensions @xcite .",
    "a numerical approach looks like a faster and more general strategy , which for most practical applications may anyway be sufficient .",
    "we believe that a numerical solver where the user can simply provide an essentially analytic formula for @xmath1 in , plus some information related boundary conditions and desired accuracy of the numerical approximation , would be of general interest .",
    "this can be realized using the freely available packages in ` numpy ` @xcite and ` scipy ` @xcite .",
    "three python classes developed to simplify the numerical solution of partial differentials in general have recently been announced @xcite .",
    "we have refactored our original code to make use of these classes .    for many problems of interesting complexity and size",
    ", the resulting code can be run on a normal laptop  and of course on more powerful computer systems .",
    "our code is constructed as a python class , ` schrodingerequation ` which inherits the ` latticeoperator ` class , and requires the ` lattice ` and ` latticefunction ` classes , plus routines from the ` numpy ` and ` scipy ` packages .",
    "the latter packages are freely available for windows , mac osx , and linux platforms , or in ( perhaps ) numerically more efficient commercial versions .",
    "they allow a relatively simple formulation and organization of the problem in python , with all heavy numerical calculations delegated to fast compiled routines .      for discretization the continuum of positions",
    "@xmath2 is replaced by a rectangular @xmath3-dimensional lattice of ` shape ` @xmath4 so that the total number of lattice points is @xmath5 .",
    "it is our experience that a modern high - end laptop can handle models for which @xmath6 .",
    "this allows resonably accurate treatment of one - particle problems in @xmath7 dimensions , two - particle problems in @xmath8 dimensions , and three - particle problems in one dimension .    note that in python all array positions are counted from zero .",
    "hence each point of this lattice is described by an index vector @xmath9    geometry can be introduced through a mapping @xmath10 .",
    "the definition of a lattice model , along with a simple set of possible ( rectangular ) geometries , is implemented in the ` lattice ` class .",
    "two ` dim`-dimensional parameters , ` re ` and ` r0 ` , can be given .",
    "they specify respectively the length of each lattice side ( by default 1 ) , and the position of the `` lower left '' corner of space ( by default the origin ) .",
    "note that all lattice points lie _ inside _ the spatial region defined in this way , half a lattice cell away from the edges .",
    "since the lattice must necessarily be finite for any finite - memory computer , it is necessary to define boundary conditions ` bc ` on @xmath11 at its edges , or more precisely how @xmath11 should be extended beyond the edges .",
    "some choices commonly used in quantum mechanics are :    1",
    ".   periodic extension , ` ' p ' ` .",
    "symmetric extension , ` ' s ' ` .",
    "antisymmetric extension , ` ' a ' ` .",
    "extension with zero values , ` ' z ' ` .",
    "these choices may be different in different directions of the lattice , and  except for ` ' p ' `  different at the two edges of a given direction .",
    "all the above boundary conditions are implemented in the ` lattice ` class .",
    "the simplest implementation of a lattice laplacian in one dimension is by use of the common discretization formula @xmath12 where @xmath13 is the distance between nearest - neighbor lattice points .",
    "the generalizes to the standard @xmath14-stensil definition of the lattice laplacian , @xmath15/{dr_k^2}.    \\label{2dplus1stensil}\\end{aligned}\\ ] ] here @xmath16 ! } $ ] is the sidelength of the lattice cell in @xmath17 direction , and @xmath18 the discretization error of is of order @xmath19 with periodic boundary conditions equation   is straightforward to implement in ` numpy ` by use of the ` roll ` operation .",
    "other boundary conditions require more considerations and code , which have been incorporated in the ` lattice ` and ` latticeoperator ` classes .",
    "an arbitrary ( short - range ) operator @xmath20 , represented by a stensil @xmath21 such that @xmath22 is supported . here",
    "@xmath23 is interpreted according to its boundary conditions when @xmath24 falls outside the lattice .",
    "the stensil ` so ` can be any @xmath3-dimensional ` numpy ` array provided by the user ( but the program will run slowly if it is too large , since the sum over @xmath25 is executed in native python ) . by default ` so ` is set to the stensil defined by equation  .",
    "it follows from the discussion above that a basic implementation of the ` schrodingerequation ` class is quite straightforward .",
    "the lattice parameters can be set up by use of the ` lattice ` class , and a standard approximation of the laplace operator in equation   is already available in the ` latticeoperator ` class ( or an alternative sensil can be provided ) .",
    "we further need to define an array representing the potential @xmath26 on every site of the lattice ; this can be done in various ways by methods in the ` latticefunction ` class .",
    "we combine these to a method ` tplusvstensil(psi ) ` in the class ` schrodingerequation ` .",
    "this performs the mapping @xmath27 for any given input array @xmath28 .",
    "this method can be used ( i ) to construct an explicit matrix representation of the linear operator in question , using the ` matrix ( ) ` method , for further analysis by standard dense matrix routines in ` scipy.linalg ` , or ( ii ) as a ` linearoperator ` alternative to an explicit sparse matrix , for further analysis by the appropriate iterative routines in ` scipy.sparse.linalg ` .",
    "the implementation of the metod is straightforward and short :    .... def tplusvstensil(self , psi ) :      \" \" \" return ( t + v ) psi . \"",
    "\" \"      psio = -self.stensop(psi )      if self.def_v is not none :          psio + = self.valuesv*psi      return psio ....    the bulk of the code lies in the method ` stensop ` , inherited from ` latticeoperator ` , and methods in ` lattice ` called by this routine .",
    "note that all lattice dimensions and sizes ( restricted by available computer memory ) , and all combinations of boundary conditions discussed above ( ten possibilities for each direction ) , is handled transparently to the user .",
    "the stensil used to represent the operator @xmath29 is stored in the ` dim`-dimensional array ` self.stensil ` .",
    "it is by default the standard @xmath14-stensil for the lattice laplacian , but is easily changed to any preferred array .",
    "consider the eigenvalue problem of the one - dimensional harmonic oscillator , @xmath30 the eigenvalues are @xmath31 for @xmath32 , and the extent of the wavefunction @xmath33 can be estimated from the requirement that a classical particle of energy @xmath34 is restricted to @xmath35 .",
    "a quantum particle requires a little more space .",
    "the numerical analysis of this problem is indicated by the code snippet    .... myl = lattice(shape=(2**7 , ) , bc='z ' , re=(25 , ) , r0=(-12.5 , ) ) defv = lambda x : x[0]**2 mys = schrodingerequation(myl , def_v = defv ) mys.varop = mys.tplusvstensil h = mys.matrix ( ) evals = eigvalsh(h ) ....    in lines 1 we define a geometric region of size @xmath36 , with origin in the middle , and cover it with a one - dimensional lattice of @xmath37 sites . in line 2",
    "we define the potential @xmath38 , and use this and ` myl ` to define an _ instance _ of ` schrodingerequation ` in lines 3 .",
    "the property ` varop ` specifies a operator used by ` schrodingerequation ` in many situations .",
    "this is set to ` tplusvstensil ` ( different from the default ) in line 4 .",
    "a @xmath39 dense matrix representation , ` h ` , of the operator is calculated in line 5 .",
    "finally all eigenvalues of ` h ` are computed in line 6 . here",
    "almost all computational work is executed in lines 56 .    the behavior of the resulting eigenvalues is shown in fig .  [ figure1 ] .",
    "the 128 lowest eigenvalues of equation  , computed with the standard @xmath40-stensil approximation for the laplace operator ( here the kinetic energy @xmath29 ) .",
    "the parameters are chosen to illustrate two typical effects : with ` bc='z ' ` boundary conditions the harmonic oscillator potential is effectively changed to @xmath41 for @xmath42 , thereby modifying the behavior of extended ( highly exited ) states .",
    "the effect of this is to increase the eigenenergies of such states , to a behavior more similar to a particle - in - box .",
    "this is visible for @xmath43 .",
    "the effect of using the @xmath40-stensil approximation for @xmath29 is to change the spectrum of this operator from @xmath44 to ( the slower rising ) @xmath45 .",
    "this is visible in the sublinear rise of the spectrum for @xmath46 . ]    for a better quantitative assessment we plot some energy differences , @xmath47 , in fig .",
    "[ figure2 ] .     the discretization error of energy eigenvalues when using the standard @xmath40-stensil approximation for the one - dimensional laplace operator ( here the kinetic energy @xmath48 ) .",
    "there is no improvement in @xmath49 beyond certain @xmath50 , because the corresponding oscillator state is too large for the geometric region .",
    "for the other states the improvement is consistent with the expectation of an error proportional to @xmath51 .",
    "this predicts an accuracy improvement of magnitude @xmath52 when the number of lattice sites increases from @xmath46 to @xmath53 for a fixed geometry .",
    "the eigenvalues are computed by the dense matrix routine ` eigvalsh ` from ` scipy.linalg ` . ]",
    "this _ brute force _ method leads to a dramatic increase in memory requirement with increasing lattice size . for a lattice with @xmath54 sites ,",
    "the matrix requires storage of @xmath55 double precision ( 8 byte ) numbers . for @xmath56",
    "this corresponds to about @xmath57 of memory , for @xmath58 about @xmath59 .",
    "the situation becomes even worse in higher dimensions .",
    "assuming that we are only interested some of the lowest eigenvalues , an alternative approach is to calculate these by iterative routine ` eigsh ` from ` scipy.sparse.linalg ` .",
    "the most straightforward change is to replace lines 56 in the previous code with the snippet    ....",
    "n = myl.size h = linearoperator((n , n ) , matvec = mys.linop , dtype = float ) evals = eigsh(h , which='sm',tol=10**(-8 ) , k=128 , return_eigenvectors = false ) ....    which will compute the lowest 128 eigenvalues ( still a rather generous amount ) .",
    "this allows extension to larger lattices , as shown in fig .",
    "[ figure3 ] .",
    "the discretization error computed by the routine ` eigsh ` from ` scipy.sparse.linalg ` . for a fixed lattice size",
    "the discretization error is essentially the same as with dense matrix routines .",
    "however , with a memory requirement proportional to the lattice size ( instead of its square ) it becomes possible to go to much larger lattices .",
    "this figure also demonstrates ( @xmath60 ) that the error can be limited by boundary effects instead of a finite discretization length @xmath13 . ]    with a sparse eigenvalue solver the calculation becomes limited by available computation time , which often is a much weaker constraint . with proper planning and organization of calculations",
    "the relevant timescale is the time to analyze and publish results ( i.e.  weeks or months ) .",
    "the computation time is nevertheless of interest ( it should nt be years @xcite ) .",
    "we have measured the wall clock time used to perform the computations for figs .",
    "[ figure2][figure3 ] , performed on a 2012 mac mini with 16 gb of memory , and equipped with a parallellized ` scipy ` library .",
    "hence , the ` eigvalsh ` and ` eigsh ` routines are running with 4 threads .",
    "the results are plotted in fig .",
    "[ figure4 ] .     the wall clock time used to find the lowest 128 eigenvalues , for various systems and methods .",
    "we have also used the dense matrix routine ` eigvalsh ` to compute the eigenvalues of a @xmath39 ( @xmath61 ) two - dimensional lattice ; not unexpected it takes the same time as for a @xmath62 one - dimensional lattice .",
    "somewhat surprisingly , with ` eigsh ` it is much faster to find the eigenvalues for two - dimensional lattice than for a one - dimensional with the same number of sites , and somewhat faster to find the eigenvalues for a three - dimensional lattice than for the two - dimensional with the same number of sites . ]    here we have used the ` eigsh ` routine in the most straightforward manner , using default settings for most parameters .",
    "this means , in particular , that the initial vector for the iteration ( and the subsequent set of trial vectors ) may not be chosen in a optimal manner for our category of problems .",
    "it is interesting to observe that ` eigsh ` works better for higher - dimensional problems .",
    "the ( brief ) ` scipy ` documentation @xcite says that the underlying routines works best when computing eigenvalues of largest magnitude , which are of no physical interest for our type of problems .",
    "it is our experience that the suggested strategy , of using the _ shift - invert _ mode instead , does not work right out - of - the - box for problems of interesting size ( i.e. , where dense solvers can not be used ) .",
    "we were surprised to observe that the computation time may _ decrease _ if the number of computed eigenvalues increases , cf .",
    "[ figure5 ]",
    ".     one may think that it takes longer to compute more eigenvalues .",
    "this is not always the case when the number of eigenvalues is small , as demonstrated by this figure .",
    "the default choice of ` eigsh ` is to compute @xmath63 eigenvalues . for our two- and three - dimensional problems this looks close to the optimal value , but it is too low for the one - dimensional problem . ]",
    "the @xmath3-dimensional harmonic oscillator @xmath64 \\psi_n(\\bm{r } ) =       e_n\\,\\psi_n(\\bm{r}),\\ ] ] has eigenvalues @xmath65 , for @xmath66 .",
    "the degeneracy of the energy level @xmath34 is @xmath67 in two dimensions , and @xmath68 in three dimensions . ] .",
    "these degeneracies may be significantly broken by the numerical approximation .",
    "for a numerical solution we only have to change lines 12 of the previous code snippet to    .... myl = lattice(shape=(2**7,)*2 , bc='z ' , re=(25 , ) * 2 , r0=(-12.5 , ) * 2 ) defv = lambda x : x[0]**2 + x[1]**2 ....    in two dimensions , and    .... myl = lattice(shape=(2**7,)*3 , bc='z ' , re=(25 , ) * 3 , r0=(-12.5 , ) * 3 ) defv = lambda x : x[0]**2 + x[1]**2 + x[2]**2 ....    in three dimensions .",
    "as already discussed , the routine ` eigsh ` works somewhat faster in higher dimensions than in one dimension ( for the same total number @xmath50 of lattice points ) .",
    "the corresponding discretization error is shown in figs .",
    "[ figure6]-[figure7 ] ,     the discretization error of energy eigenvalues when using the standard 5-stensil approximation for the two - dimensional laplace operator .",
    "exactly , the states @xmath69 and @xmath49 are the two edges of a @xmath70-member multiplet with energy @xmath71 , and the state @xmath72 is the middle member of a @xmath73-member multiplet with energy @xmath74 . with",
    "the chosen parameters all states considered a well confined inside the geometric region ; hence we do not observe any boundary correction effects . ]     the discretization error of energy eigenvalues when using the standard 7-stensil approximation for the three - dimensional laplace operator .",
    "exactly , the states @xmath75 and @xmath76 are the two edges of a @xmath77-member multiplet with energy @xmath78 , and the state @xmath79 is the middle member of a @xmath74-member multiplet with energy @xmath80 . ]    the discretization error continues to scale like @xmath51 .",
    "this means that a reduction of this error by a factor @xmath81 requires an increase in the number of lattice points by a factor @xmath82 in @xmath3 dimensions .",
    "this means that is becomes more urgent to use a better representation of the laplace operator in higher dimensions .",
    "fortunately , as we shall see in the next sections , better representations are available for our type of problems .",
    "one improvement is to use the reflection symmetry of each axis ( @xmath83 , @xmath84 , etc . ) to reduce the size of the spatial domain .",
    "this reduces @xmath13 by a half , without changing the number of lattice points .",
    "a much more dramatic improvement is to use some variant of a fast fourier transform ( fft ) : after a fourier transformation , @xmath85 , the laplace operator turns into multiplication , @xmath86 .",
    "this means that application of the laplace operator can be represented by ( i ) a fourier transform , followed by ( ii ) multiplication by @xmath87 , and finally ( iii ) an inverse fourier transform .",
    "essentially the same procedure works for the related trigonometric transforms .",
    "these are also practical procedures for lattice approximations , due to the existence of efficient and accurate with double precision numbers . however , when an error of this order is multiplied by @xmath87 it can be amplified by several orders of magnitude .",
    "hence , the range of @xmath87-values should not be chosen significantly larger than required to represent @xmath88 to sufficient accuracy . ]",
    "algoritms for discrete fourier and trigonometric transforms .",
    "the time to perform the above procedure is not significantly longer than the corresponding stensil operations .",
    "the benefit is that the laplace operator becomes exact on the space of functions which can be represented by the modes included in the discrete transform .    with the ` schrodingerequation ` class it is easy to employ the fft representation .",
    "this is built into the method ` tplusv ` , which is the default setting for ` varop ` .",
    "thus we only have to comment out ( or remove ) line 4 in the first code snippet above :    .... # mys.varop = mys.tplusvstensil ....    the obtainable accuracy with this procedure increases dramatically , as illustrated in figs .  [ figure8]-[figure11 ] .     with a fft representation of the laplace operator",
    "the discretization error drops exceptionally fast with @xmath89 .",
    "when it becomes `` small enough '' the effect of numerical roundoff becomes visible ; the latter leads to an _ increase _ in error with @xmath13 .",
    "the results in this figure is for a one - dimensional lattice , but the behavior is the same in all dimensions .",
    "the lesson is that we should make @xmath13 `` small enough '' ( which in general may be difficult to determine _ a priori _ ) , but not smaller",
    ". it may be possible to rewrite the eigenvalue problem to a form with less amplification of roundoff errors . ]",
    "accuracy of computed eigenvalues for a @xmath90 oscillator .",
    "this figure may suggest that an increase in the number of lattice size @xmath50 will lead to a accurate treatment of states with higher @xmath91 .",
    "our findings are that this is _ not _ the case : the results for @xmath46 and @xmath92 have essentially the same behavior as for @xmath93 . ]",
    "accuracy of computed eigenvalues for a @xmath94 oscillator . as can be seen , a large number of the lowest eigenvalues can be computed to an absolute accuracy in the range @xmath95@xmath96 with lattice of size @xmath97 .",
    "we observe not improvement by going to @xmath98 lattice , but no harm either ( except for an increase in the wall clock execution time from about 3 to 30 seconds for each combination of boundary conditions ) . ]",
    "accuracy of computed eigenvalues for a @xmath99 oscillator . as can be seen , a large number of the lowest eigenvalues can be computed to an absolute accuracy in the range @xmath95@xmath96 with lattice of size @xmath100 .",
    "we observe no improvement by going to @xmath101 lattice , but no harm either ( except for an increase in the wall clock execution time from about 6 to 95 minutes for each combination of boundary conditions ) . ]",
    "it might be that the harmonic oscillator systems are particulary favorable for application of the fft representation .",
    "one important feature is that the fourier components of the harmonic oscillator wavefunctions vanishes exponentially fast , like @xmath102 , with increasing wavenumbers @xmath87 .",
    "this feature is shared with all eigenfunctions of polynomial potential schrdinger equations , but usually with different powers of @xmath103 in the exponent ( which may lead to a quantitative different behavior ) .",
    "further , for systems with singular wavefunctions the corresponding fourier components may vanish only algebraically with @xmath87 .",
    "the dramatic increase in accuracy can not be expected for such cases .",
    "the ` schrodingerequation ` class works with any computable potential . all one has to do is to change the definition of the function assigned to ` def_v ` .",
    "however , in most cases we no longer know the exact answer ; this makes it difficult to assess the accuracy of the result .",
    "one simple test is to consider two - dimensional potentials of the form @xmath104 for various values of @xmath105 . for @xmath106 and @xmath107 this system",
    "an be separated to a set of two one - dimensional anharmonic oscillators ( with @xmath108 type potential ) , and for @xmath109 it can be separated in cylinder coordinates . here",
    "comparison with essentially exact solutions of the separated one - dimensional problems can be made . even in the absence of these",
    ", one may check for degeneracies in the spectrum .",
    "for some problems one may perform a partial ( or full ) symmetry reduction of equation  .",
    "an example is @xmath110\\ , \\psi(r , z )     \\nonumber\\\\     & \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad = e\\,\\psi(r , z ) .",
    "\\label{radialequation}\\end{aligned}\\ ] ] in this case there is a natural boundary at @xmath111 .",
    "this is also a singular line for the equation .    what is the natural boundary condition at @xmath111 ?",
    "equation is often symmetric under @xmath112 , depending on the form of @xmath113 . with this symmetry equation",
    "may be extended to @xmath114 , and the solutions classified according to their transformation under @xmath112 .",
    "this makes symmetric or antisymmetric boundary conditions the natural choice .",
    "surprisingly , discussions of numerical approximation schemes for ( very common ) singular equations like are difficult to find in the textbook literature",
    ". it may be tempting to introduce a new wavefunction , @xmath115 , in order to eliminate the first order derivative in .",
    "this would transform the equation into the general form .",
    "however , this would also make the searched - for solution @xmath116 singular at @xmath111 , hence difficult to approximate numerically .",
    "there is also a convenient way to define domains of general shape in ` numpy ` , by specifying a boolan vector which is ` true ` for all points in the domain , and ` false ` for all points outside . in this case",
    "we find only the ` ' z ' ` boundary conditions to be a general and unambiguous option . stensil approximations of the laplace operator may be the best choice for such cases .",
    "we thank dr .  asif mushtaq for useful discussions .",
    "we also acknowledge support provided by statoil via roger sollie , through a professor ii grant in applied mathematical physics .",
    "a.  mushtaq , a.  noreen , k.  olaussen , and i.  verb , `` very - high - precision solutions of a class of schrdinger type equations '' , _ computer physics communications _ , * 182 * , 18101813 ( 2011 ) ; ` arxiv:1008.0834[math - ph ] `    a.  noreen and k.  olaussen , `` very - high precision normalized eigenfunctions for a class of schrdinger type equations '' , _ proceedings of world academy of science , engineering and technology _ , * 76 * , 831836 ( 2011 ) ; ` arxiv:1105.1460[math - ph ] `    a.  noreen and k.  olaussen , `` high precision series solution of differential equations : oridnary and regular singular point of second order odes '' , _ computer physics communications _ , * 183 * , 22912207 ( 2012 ) ; ` arxiv:1205.2221[math - ph ] `    a.  noreen and k.  olaussen , `` estimating coefficients of frobenius series by legendre transform and wkb approximations '' , _ proceedings of the world congress on engineering 2012 _ vol ii , wce 2012 , july 46 , 2012 , london , u.k ; ` arxiv:1205.2221[math - ph ] `"
  ],
  "abstract_text": [
    "<S> we announce a python class for numerical solution of schrdinger equations in one or more space dimensions , employing some recently developed general classes for numerical solution of partial differential equations , and routines from ` numpy ` and ` scipy.sparse.linalg ` ( or ` scipy.linalg ` for smaller problems ) .    </S>",
    "<S> quantum mechanics , anharmonic oscillators , sparse scipy routines . </S>"
  ]
}