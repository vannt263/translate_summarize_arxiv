{
  "article_text": [
    "quantum information is information stored in a quantum mechanical system @xcite . the systems themselves are either collections of qubits , two - dimensional systems , or qudits , @xmath0-dimensional systems .",
    "for example , a qubit exists in a two dimensional space spanned by two orthonormal states , which are denoted by @xmath1 and @xmath2 .",
    "while a classical bit can be either @xmath3 or @xmath4 , a qubit can be in any superposition of @xmath1 and @xmath2 , i.e. @xmath5 .",
    "this fact leads to large differences in the properties of classical and quantum information .",
    "once one has information is in the form of qubits of qudits , one would like to do something with it .",
    "ultimately , in order to extract the information stored in the system , it will be necessary to measure the it , but before doing so , it is usually useful to perform some operations on the system .",
    "for example , one might want to ( approximately ) copy it , compare it with known quantum states or with information stored in other quantum systems , or perform an operation on it .",
    "the devices that accomplish these tasks are quantum machines . they can either be single - purpose or programmable and able to perform many tasks .    in the case of programmable systems , the program can be either quantum or classical .",
    "examples of a classical programs are a sequence of laser pulses to put a molecule into a particular quantum state or a sequence of radio frequency pulses to control the dynamics of a system of nuclear spins @xcite . here",
    ", we want to consider programs that are themselves states of quantum systems , i.e. we want to perform quantum programming .",
    "quantum programs have some properties that classical ones do not . for example",
    ", they can exist in superposition states , which means that a quantum processor can perform several programs simultaneously .",
    "in addition , quantum programs are necessary when the information on which the program is based is , in fact , quantum information .",
    "we shall provide examples of each of this situations .",
    "as we shall see , in a number of cases , it is not possible to perform the desired task perfectly .",
    "for example , the no - cloning theorem prohibits the perfect copying of quantum information @xcite .",
    "we are then faced with deciding how to perform the task as best as we can .",
    "this usually amounts to adopting one of two possible strategies .",
    "the first is to produce an output state that is as close as possible to the ideal output , that is we approximately perform the desired task .",
    "the second is to perform the task with some probability in such a way that we know whether the proper task has been performed or not . in that case",
    ", the task has been performed probabilistically .",
    "we shall begin by discussing single - purpose machines , in particular cloners and machines that perform the discrimination of quantum states .",
    "next , we shall move on to a general discussion of programmable machines and outline the deterministic and probabilistic approaches to them .",
    "we will present a no - go theorem that shows that a deterministic programmable machine can not be universal .",
    "we then consider the problem of implementing a one - parameter unitary group on a programmable machine and discuss the approximate and probabilistic strategies .",
    "we also show how , in the probabilistic case , to increase the probability of success by increasing the size of the program space .",
    "finally , we make a case for why quantum programs are useful .",
    "as was mentioned in the introduction , the no - cloning theorem prohibits the perfect copying of quantum information .",
    "the theorem states that if we have a quantum system in the state @xmath6 , we can not build a machine whose output will be @xmath7 , for all @xmath6 .",
    "the proof relies simply on the linearity of quantum mechanics @xcite .",
    "if the machine clones each vector of a basis for the input space , then its action is completely determined , and it is incompatible with the transformation @xmath8 .    an approximate cloner for qubits can be constructed from four controlled - not gates and three qubits ( see figure 1 ) @xcite .",
    "a controlled - not gate is a two - qubit gate .",
    "the first qubit is the control qubit , and the second is the target qubit .",
    "if the state of the control qubit is @xmath1 , then nothing happens to the states of either the control or the target qubits .",
    "however , if the state of the control qubit is @xmath2 , then the state of the control qubit is again unchanged , but the state of the target qubit is flipped , i.e. if it was @xmath1 it becomes @xmath2 , and vice versa .",
    "returning now to the cloner , we have that the first qubit , in the state @xmath9 , where @xmath10 is the orthonormal qubit basis , is the one to be copied , and second qubit will become the copy . in order to see how this works ,",
    "define the two two - qubit states latexmath:[\\[\\begin{aligned }     we now note that if qubit @xmath4 is in the state @xmath12 and qubits @xmath13 and @xmath14 are in one of the two states above , then the cloning circuit will implement the following transformations latexmath:[\\[\\begin{aligned }     examining these equations , we see that in the first the quantum information from the first qubit appears in output @xmath4 , and in the second it appears in output @xmath13 .",
    "this suggests that if instead of sending either @xmath16 or @xmath17 into inputs @xmath13 and @xmath14 , we send in a linear combination of them , some of the quantum information from qubit @xmath4 will appear in output @xmath4 and some of it will appear in output @xmath13 , thereby cloning the state .",
    "this is , in fact , exactly what happens .",
    "if we choose @xmath18 as the input state for qubits @xmath13 and @xmath14 , with @xmath19 and @xmath20 real for simplicity , then the reduced density matrices for outputs @xmath4 and @xmath13 are @xmath21 note that by choosing @xmath19 and @xmath20 we can control how much information about @xmath6 goes to which output .",
    "in particular , if we choose @xmath22 , then the information is divided equally , and we find that @xmath23 where @xmath24 is the qubit state orthogonal to @xmath6 .",
    "therefore , the fidelity of the cloner output @xmath25 ( or @xmath26 , since they are the same in this case ) to the ideal output , @xmath6 , which is given by @xmath27 , is @xmath28 .",
    "a fidelity of one would imply perfect cloning , so what we have here is a device that produces two copies of the input qubit that are pretty good approximations to it .",
    "note that the cloner employs three qubits , and we have only discussed the final state of two of them .",
    "one might wonder if the output state of the third qubit is of interest .",
    "the answer `` yes . ''",
    "its state is the best approximation to the state orthogonal to that of the input qubit that can be realized .",
    "a machine that sends a qubit in an arbitrary input state @xmath6 into the state orthogonal to it , @xmath24 , is known as a universal - not , or unot , gate , and this transformation is also impossible to perform exactly @xcite .",
    "it can , however , be performed approximately , and the best fidelity that can be obtained is @xmath29 .",
    "this can be achieved by measuring the original qubit along an arbitrary axis and then producing an output qubit whose state is orthogonal to the state obtained as the result of the measurement .",
    "for example , if one measured along the @xmath30 axis and found the result @xmath31 , one would create a qubit in the @xmath32 direction .",
    "the same result can be achieved by taking the third qubit , the one which is not a clone , from the output of a quantum cloning machine .",
    "this output qubit is sometimes referred to as an anticlone .",
    "there have been a number of realizations of a quantum cloning machine , most based on a device known as an optical parametric amplifier @xcite .",
    "this device takes one photon at frequency @xmath33 and converts it into two photons at frequency @xmath34 .",
    "a strong beam at @xmath33 will amplify a weaker beam at frequency @xmath34 via stimulated emission .",
    "when this device is used as a cloner , the qubits are the polarization states of the photons .",
    "a photon in an arbitrary polarization state at frequency @xmath34 will produce three photons , all at frequency @xmath34 , at the output .",
    "two of them will approximate clones , and the third will be an approximate anticlone .    a second cloning strategy is a probabilistic one @xcite .",
    "in this case ,",
    "one wants to clone a quantum state that is selected from a known , finite set of states . for simplicity ,",
    "let us assume that this set contains two elements , @xmath35 and @xmath36 .",
    "our machine is then to do the following . given an input qubit that is in either the state @xmath35 or @xmath36 , we do nt know which , it is to produce two copies of the input state .",
    "if the two input states are not orthogonal , this can not be done perfectly .",
    "it can , however , be done probabilistically .",
    "the machine either produces two perfect copies of the input , or it fails , and it tells us which of these two possibilities has occurred .",
    "the probability of successfully cloning the input is given by @xmath37 note that this is one if the states are orthogonal , and decreases as their overlap increases .",
    "the problem in quantum state discrimination is , given a particle in an unknown state selected from a known set of states , determine the quantum state of the particle @xcite .",
    "if the set of possible states contains states that are not orthogonal to each other , then this can not be done perfectly .",
    "again , for simplicity , let us assume that our set of possible states contains only two states , @xmath35 and @xmath36 .",
    "we shall again explore two strategies for accomplishing this task .",
    "the first is the minimum - error strategy , which is a strategy that approximately discriminates the two states @xcite .",
    "it can make mistakes , but the probability of making a mistake is minimized .",
    "a machine that implements this strategy is given an input , which is equally likely to be @xmath35 or @xmath36 , and it then tells us which of the two states it was given .",
    "the probability of the output being incorrect is @xmath38 note that when the states are orthogonal , this is zero , but that it increases as the overlap between the states increases .",
    "the second strategy is known as unambiguous state discrimination @xcite . in this case",
    "our machine has three outputs , one corresponding to state @xmath4 , one corresponding to state @xmath13 , and a third corresponding to failure .",
    "this machine will never incorrectly identify a state , but it may fail . for example , if the input is in @xmath35 , the machine will either tell us the input was in state @xmath35 , or fail , but it will never tell us the input was in state @xmath36 . assuming that each input state is equally likely , the probability of successfully identifying the state is @xmath39",
    "as has been the case before , the probability of successful identifying the input state is one if the states are orthogonal , and decreases as the overlap of the states increases .",
    "we now want to consider programmable quantum machines , which we shall often refer to as quantum processors @xcite .",
    "these have two inputs , one for the data , which is to be acted upon , and one for the program , which will specify the operation to be performed on the data .",
    "both the data and the program are quantum states . in particular , the processor is a unitary operator acting on the hilbert space @xmath40 , where @xmath41 is the data hilbert space and @xmath42 is the program hilbert space .",
    "the machine can act in either a deterministic or probabilistic fashion . in the case of a deterministic machine",
    ", we always accept the output , and the action of the machine on the data state is described by a trace - preserving completely positive map , which is a result of tracing out the program state output . in the case of a probabilistic machine ,",
    "we measure the program state output , and only accept the data state output if a particular result is obtained .",
    "we shall examine both scenarios .",
    "it is , perhaps , best to begin with an example @xcite .",
    "let us go back and consider the three - qubit circuit for the approximate cloner .",
    "qubit @xmath4 will now be our data state , and qubits @xmath13 and @xmath14 will be our program .",
    "we will denote the data state by @xmath12 and the program state by @xmath43 .",
    "define the two - qubit bell states to be @xmath44 , @xmath45 , and @xmath46 are the pauli matrices .",
    "if we choose the program @xmath47 then operating our machine in the deterministic mode , by tracing out the program state output , we obtain for the data state output @xmath48 in the above equation , we have set @xmath49 . examining the output state",
    ", we see that this circuit can implement a number of quantum channels : the bit - flip channel ( @xmath50 ) , which flips a bit , with a certain probability , the phase - flip channel ( @xmath51 ) , which sends @xmath52 and @xmath53 , with a certain probability , and the depolarizing channel ( @xmath54 ) , in which the input state is replaced by the completely mixed state , with a certain probability @xcite .",
    "the same processor can be used in the probabilistic mode .",
    "suppose we want to implement the operator @xmath55 on the data state , where @xmath56 is a specified one - qubit state .",
    "the operator @xmath57 is similar to @xmath46 , but instead of flipping the phase of the state @xmath2 , it flips the phase of the state @xmath56 . defining the two - qubit operator , @xmath58 , @xmath59 we choose for our program state @xmath60 where @xmath61 is the qubit state orthogonal to @xmath56 . at the program state output , we project onto the state @xmath62 , and if we get one , we keep the data state output",
    ". this will happen with a probability of @xmath63 , independent of the state @xmath56 .",
    "if we do get one , then the data state output will be in the state @xmath64 .",
    "now , let us return to deterministic processors and examine the resources that are necessary in order to implement a given set of operations on the data .",
    "suppose that our data state is a qubit , and we want to implement a one - parameter unitary group @xmath65 , where @xmath66 , on it .",
    "we want to encode the angle @xmath67 in the program state .",
    "it turns out that this can not be done with a finite dimensional program space , due to a no - go theorem due to nielsen and chuang @xcite .",
    "it states that if the program @xmath68 implements the unitary operator @xmath69 on the data state , and @xmath70 implements the unitary operator @xmath71 , then @xmath72 .",
    "this implies that for every unitary operator that the processor can implement on the data state , we need an extra dimension in the program space . in the case of our one - paramenter group , there are an infinite number of operators , so it clearly can not be implemented on a processor with a finite - dimensional program space .",
    "given this result , we can adopt the same strategies we did in the case of single - purpose machines that were prohibited by a no - go theorem .",
    "we have already seen in our example , that a probabilistic machine has no problem implementing an infinite number of operations .",
    "the only remaining issue in that case is figuring out how to make the success probability as large as possible .",
    "this we shall address shortly .",
    "the other strategy is to construct a machine that carries out a set of operations approximately .",
    "it is this type of machine we shall discuss now @xcite .",
    "we have seen that deterministic processors implement trace - preserving , completely positive maps .",
    "therefore , when considering approximate deterministic processor , we need to have some kind of a measure of how close two such maps are . we shall use the process fidelity @xcite , which has a number of useful properties @xcite .",
    "let @xmath73 and @xmath74 be two trace - preserving , completely positive maps , mapping the space , @xmath75 , of linear operators on a @xmath0-dimensional hilbert space , @xmath76 , into itself .",
    "the jamiolkowski isomorphism associates a density matrix on @xmath77 to each trace - preserving , completely positive map on @xmath75 .",
    "letting @xmath78 be an orthonormal basis for @xmath76 , define the maximally entangled state , @xmath79 in @xmath77 @xmath80 the density matrix associated with the trace - preserving , completely positive map , @xmath81 , is @xmath82 where @xmath83 is the identity map .",
    "if @xmath84 is the density matrix associated with @xmath73 and @xmath85 is the density matrix associated with @xmath74 , the the process fidelity between @xmath73 and @xmath74 is @xmath86^{2 }   .\\ ] ]    we will not discuss the case of a general approximate processor , but will look at a specific type .",
    "suppose we have a processor that is a controlled - u gate .",
    "that means that if our program space , @xmath42 , has dimension @xmath87 , there is an orthonormal basis of @xmath42 , @xmath88 such that the processor acts as follows @xmath89 where @xmath90 is a unitary operator on the data space .",
    "therefore , this processor implements the set of unitary operators @xmath91 perfectly .",
    "now suppose we want to use this processor to approximate another unitary operator @xmath92 , which is not in @xmath93 .",
    "we want to choose a program state that maximizes the process fidelity between the map it generates and @xmath92 .",
    "what one finds is that the best program is one of the basis states @xmath94 , and it is the one for which @xmath95 is a maximum . in this case , one simply chooses the unitary operator in @xmath93 that is closest to @xmath92 and implements that operator . using a program state that is a superposition of different basis vectors does not help .    let us look at an example of this situation .",
    "we wish to implement the operator , for @xmath96 , @xmath97   , \\ ] ] on our data state , which is a qubit . here",
    "@xmath96 , and @xmath98 .",
    "our program state has dimension @xmath87 , and an orthonormal basis @xmath99 .",
    "define the operators @xmath100 on the program space by @xmath101 , where the addition and subtraction are modulo @xmath87 .",
    "now let the overall processor unitary operator , which acts on the tensor product of the data and program spaces , be @xmath102 , \\ ] ] and consider the program states @xmath103 when @xmath104 , for @xmath105 an integer between @xmath3 and @xmath106 , we find that @xmath107 where @xmath6 is a general qubit state . therefore , this processor implements the operations @xmath108 perfectly .",
    "now suppose we want to implement @xmath109 for a value of @xmath110 that is not one of the @xmath111 . the optimal strategy is to find the @xmath111 closest to @xmath110 and to send in the program state @xmath112 corresponding to that value .",
    "if we do so we find that @xmath113 rather than determining which @xmath111 is the best one to use , a simpler procedure is just to use the program state @xmath114 .",
    "there should be some cost to doing this , and , indeed , we find that the process fidelity in this case is approximately @xmath115 .",
    "the optimal program has an error that goes like @xmath116 while the simpler procedure gives an error of @xmath117 .",
    "determining whether the extra accuracy is worth the extra work in determining the best program would depend on the application .",
    "now let us return to probabilistic programmable devices .",
    "suppose our data system is a qubit , and we want to implement the one parameter group we mentioned earlier , @xmath118 , where @xmath66 .",
    "this can be accomplished with a success probability of @xmath119 by using a qubit program and a controlled - not gate . as was noted before",
    ", the controlled - not gate has two inputs , a control input and a target input .",
    "the state of the control qubit is not changed , and if the state of the control qubit is @xmath1 , neither is the state of the target qubit . however , if the control qubit is in the state @xmath2 , then the operator @xmath120 is applied to the target qubit .",
    "it is , in fact , a controlled - u gate with the two unitary operators being the identity and @xmath120 . in our case ,",
    "the target qubit is the program and the control qubit is the data .",
    "the program states are @xmath121 if the data state input is @xmath6 , the output of this processor is then latexmath:[\\[|\\psi_{out}\\rangle = \\frac{1}{\\sqrt{2}}(u(\\alpha ) |\\psi\\rangle |0\\rangle + u^{-1}(\\alpha ) |\\psi\\rangle",
    "@xmath10,and keeping the result only if we get @xmath1 , which happens with a probability of @xmath119 , we obtain the data state output @xmath123 , which is the desired result .",
    "a closely related programmable device has been recently realized experimentally @xcite .",
    "it carries out the transformation @xmath124 where the angle @xmath125 is encoded in a second qubit .",
    "the qubits are polarization states of photons , with @xmath126 representing a horizontally polarized photon and @xmath127 representing a vertically polarized one . a polarizing beam splitter , which transmits horizontally polarized photons and reflects vertically polarized ones is the main component of the device .",
    "the beam splitter has two input modes , which we shall label @xmath4 and @xmath13 , and two output modes , which we shall also denote as @xmath4 and @xmath13 . for a photon incident in input mode @xmath4 we would have @xmath128 and @xmath129 .",
    "input mode @xmath13 behaves similarly .",
    "if two photons , one in the state @xmath130 ( data ) and the other in the state @xmath131 ( program ) are incident on the polarizing beam splitter , then in the cases in which a single photon emerges from each output , which happens with a probability of @xmath119 , the conditional output state is @xmath132 basis , then the remaining photon is in either the state @xmath133 , if our measurement result was @xmath134 , and @xmath135 , if our measurement result was @xmath136 .",
    "if we obtain the result @xmath136 we can apply a correcting operation on the remaining qubit that sends @xmath137 and @xmath138 .",
    "the final result is that this device implements the transformation @xmath139 with a probability of @xmath119 .",
    "suppose that we want to increase the probability of a successful outcome .",
    "one possibility is to try again if get the wrong result of our measurement on the program state @xcite .",
    "if we obtained the result @xmath2 from our measurement , then the data qubit is in the state @xmath140 .",
    "we can take this quibit and run it through the processor again , but this time use the program @xmath141 .",
    "if we do so , the output state is @xmath142 we again measure the program state and keep the result if we get @xmath1",
    ". this again happens with a probability of @xmath119 .",
    "adding this second step has increased our overall success probability to @xmath143 , and the procedure can be repeated to bring the success probability as close to one as we wish .",
    "what we need to do this , however , is a collection of qubits in the proper program states , that is , besides a qubit in the state @xmath144 , we need an additional one in the state @xmath145",
    ".    we can also accomplish the same thing by enlarging our program space @xcite .",
    "our data space still consists of one qubit , but the program space now contains two qubits .",
    "let us label the three inputs , input @xmath4 being the data input , input @xmath13 the first program input and input @xmath14 the second program input .",
    "the processor now consists of two gates .",
    "the first is a controlled - not gate whose control qubit is qubit @xmath4 and whose target qubit is qubit @xmath13 .",
    "the second gate is a toffoli gate .",
    "this gate has two control qubits and one target qubit .",
    "the states of the control qubits are not changed , and if they are in the states @xmath146 , @xmath147 , or @xmath148 , neither is the state of the target qubit .",
    "however , if they are in the state @xmath149 , then @xmath120 is applied to the target qubit . in our processor , qubits @xmath4 and @xmath13 are the control qubits and qubit @xmath14 is the target qubit .",
    "the input state is @xmath150 , and the output state is latexmath:[\\[|\\psi_{out}^{\\prime\\prime}\\rangle = \\frac{1}{2}[u(\\alpha ) |\\psi\\rangle_{1 } ( |0\\rangle_{2}|0\\rangle_{3 }   + |0\\rangle_{2}|1\\rangle_{3}+|1\\rangle_{2}|0\\rangle_{3})+ u^{-1}(3\\alpha ) |\\psi\\rangle |1\\rangle_{2 }    computational basis and keep the data state output if we get @xmath146 , @xmath147 , or @xmath148 . if we do , the data output is in the state @xmath123 , and we have achieved our goal .",
    "this happens with a probability of @xmath143 . by increasing the dimension of the program space further",
    ", we can increase our probability of success .",
    "we have , therefore , two strategies for increasing the success probability for a probabilistic processor .",
    "the programs in the quantum processors we have been discussing have been quantum states .",
    "one might wonder whether this is necessary and whether classical programs would suffice .",
    "that is , one could have gates that can perform a number of operations , but the selection of which operation they do perform is governed by a classical input .",
    "do quantum programs provide an advantage ?",
    "there are several scenarios that suggest themselves for which quantum programs would be useful .",
    "one is that the information on which the program is based is intrinsically quantum .",
    "we shall explore an example of this situation when we discuss programmable state discriminators .",
    "this could also occur if the program is the result of an earlier quantum computation .",
    "a second situation is one in which we would like to apply quantum information processing techniques , such as a grover search , to programs . in that case",
    ", the programs must be quantum .",
    "let us first consider programmable state discriminators .",
    "the first such device was proposed by buek and duek @xcite . here",
    "we will discuss a different version , which is a type of universal state discriminator @xcite .",
    "so far , when discussing state discriminators , we have assumed we knew the set of states we were trying to discriminate among .",
    "this knowledge was built into the discriminator .",
    "the resulting discriminator is useful for discriminating states from that particular set , but it is not useful for discriminating among members of other sets of states .",
    "suppose , however , that we would like a discriminator that would work for any set of states , i.e. a universal discriminator . in that case",
    ", we have to provide information about the set of possible states as well as the quantum system whose state we want to determine with the machine .",
    "the information about the set of possible states will be the program .",
    "let us consider the simplest version of such a device .",
    "it will unambiguously discriminate between two different qubit states .",
    "the program consists of two states , one in each of the states we want to discriminate between , which we shall call @xmath35 and @xmath36 .",
    "the data qubit is in either @xmath35 or @xmath36 , and we would like to know which . what the machine does is implement a povm , which takes advantage of the symmetry of the three - qubit input state .",
    "let us call the program inputs @xmath152 and @xmath153 , and the data input @xmath154 .",
    "our task is to discriminate between the states @xmath155 the first and third qubits are in the same state , while in @xmath156 the second and third qubits are in the same state .",
    "therefore , if we project the three - qubit input state onto the antisymmetric subspace of qubits @xmath152 and @xmath154 , and we get a nonzero result , then we know that qubit @xmath154 was in the state @xmath36 .",
    "similarly , if we project qubits @xmath153 and @xmath154 onto the antisymmetric subspace of two qubits , and we get a nonzero result , then we know that qubit @xmath154 was in the state @xmath35 .",
    "there will also be a `` do nt know '' result in which the measurement fails , and we want to minimize the probability of obtaining this result . if the two states are equally likely , and averaging over @xmath35 and @xmath36 , since we do not know what they are , we find that the optimal probability of identifying the input data state is @xmath157 .",
    "note that in this case , the information contained in the program was quantum information , in particular , it consisted of examples of quantum states , and this necessitated the program itself being quantum .",
    "now let us look at an example in which it is useful to apply quantum information processing techniques to quantum programs . in order to do so",
    ", we first need to explain the quantum search algorithm due to lov grover @xcite .",
    "we have a black box that evaluates a boolean function .",
    "a boolean function is one whose value is either zero or one .",
    "we send in an input , which is an @xmath158-digit binary number , @xmath159 , and the output of the box is @xmath160 .",
    "this particular function is zero on all inputs except one , which we shall call @xmath161 , and @xmath162 .",
    "our object is to find @xmath161 with a minimum number of uses of the black box .",
    "classically , we simply send in different inputs to the black box until we find one that gives one as an output . on average",
    "we will have to make @xmath163 tries .",
    "the grover algorithm works in a completely different way , and its result is a considerable improvement over the classical one .",
    "it starts with an input state that is an equal superposition of all possible input values .",
    "by successively applying the black box followed by an operator grover called `` inversion about the mean '' approximately @xmath164 times , the initial state is rotated into the state @xmath165 , and then one simply measures this state in the computational basis to find out what @xmath161 is .",
    "note that the black box was only used @xmath164 times in this case , which means that the number of evaluations in the grover algorithm is approximately the square root of the number of evaluations that are necessary in the classical case .",
    "now consider the following problem @xcite .",
    "we have a set of @xmath166 permutations on @xmath87 objects .",
    "in particular let @xmath167 be the set of objects being permuted , and let @xmath168 be the set of permutations .",
    "for some specified @xmath169 , we are promised that there is one @xmath170 such that @xmath171 , and we want to find which permutation satisfies this property .",
    "a variant of this problem , determining whether there is a @xmath170 such that @xmath172 , can be used to attack the conjugacy problem in group theory .",
    "if @xmath173 is a group , and @xmath174 , we would like to know whether @xmath175 and @xmath176 are conjugate to each other , that is , whether there is an @xmath177 , such that @xmath178 .",
    "the connection between this problem and the one involving the permutations is provided by realizing that the automorphism @xmath179 given by @xmath180 is just a permutation on @xmath173 .",
    "thus , the conjugacy problem is reduced to determining whether there is an @xmath181 such that @xmath182 .",
    "we suppose we have a quantum processor , which acts on the hilbert space @xmath183 , where @xmath184 is spanned by the orthonormal basis @xmath185 and @xmath186 is spanned by the orthornormal basis @xmath187 .",
    "we regard @xmath186 as the program space , and @xmath184 as the data space .",
    "the processor acts as follows @xmath188 where @xmath189 .",
    "once we have this processor , we can do a grover search on the programs in order to find the permutation that satisfies @xmath172 .",
    "this will require approximately @xmath190 uses of the processor , whereas classically @xmath166 uses would be required .",
    "it is the fact that the programs are quantum states that allows us to search among them by using a quantum search procedure .",
    "as we have seen , quantum machines have been developed for a number of information processing tasks .",
    "cloners move quantum information around and discriminators allow one to distinguish among nonorthogonal quantum states .",
    "discriminators can be generalized to distinguish between nonorthogonal subspaces as well @xcite .",
    "in addition , we have seen that it is possible to construct programmable quantum machines , which are capable of performing a number of different tasks .",
    "the capabilities of programmable machines are still not well understood .",
    "we concentrated mainly on processors that implement unitary operators , but , as we saw processors can also implement more general maps .",
    "some families of maps , for example , those in eq .",
    "( [ procmap ] ) , can be implemented with a finite - dimensional program space , while others , such as a one - parameter unitary group , can not .",
    "what determines whether a set of maps can be programmed with a finite- dimensional program ?",
    "another issue is the equivalence of programmable processors .",
    "suppose we have two processors , both of which can perform the same set of operations but they do so with different programs .",
    "this could happen , for example , if the one of the processors differed from the other simply by having a fixed unitary gate at the input to its program register .",
    "given two processors , is there a simple way of telling whether or not the set of operations they can implement is the same ?",
    "these are only two questions about the properties of quantum processors , and we suspect there are many more .",
    "this work was supported by the european union projects hip and qap , by slovak grant agencies apvv and vega via projects rpeu-0014 - 06 and 2/0092/09 , respectively .",
    "99 michael a.  nielsen and isaac l.  chuang , _ quantum computation and quantum information _",
    "( cambridge university press , cambridge , 2000 ) .",
    "domenico dalessandro , _ introduction to quantum control and dynamics _",
    "( chapman & hall / crc , boca raton , 2008 ) .",
    "william k.  wooters and wojcek h.   zurek , nature * 229 * , 802 ( 1982 ) .",
    "vladimir buek and mark hillery , phys .",
    "a * 54 * , 1844 ( 1996 ) .",
    "samuel l.  braunstein , vladimir buek , and mark hillery , phys .",
    "a * 63 * , 052313 ( 2001 ) . for reviews of quantum cloning",
    "see valerio scarani , sofyan iblisdir , nicolas gisin , and antonio acin , rev .",
    "phys .  * 77 * , 1225 ( 2005 ) and n.  j.  cerf and j.  fiuraek , progress in optics * 49 * , 455 ( 2006 ) .",
    "v.  buek , m.  hillery , and r.  f.  werner , phys .  rev .",
    "a * 60 * r2626 ( 1999 ) .",
    "v.  buek , .",
    "hillery , and r.  werner , j.  mod .",
    "opt .  * 47 * , 987 ( 2000 ) .",
    "f.  de martini , v.  mussa , and f.  bovino , opt",
    ".  commun .",
    "* 179 * , 581 ( 2000 ) .",
    "f.  de martini , v.  buek , f.  sciarrino , and c.  sias , nature * 419 * , 815 ( 2002 ) .",
    "a.  lamas - linares , c.  simon , j.  c.  howell , and d.  bouwmeester , science * 296 * , 712 ( 2002 ) .",
    "lu - ming duan and guang - can guo , phys .",
    "lett .  * 80 * , 4999 ( 1998 ) . for",
    "a review of the theory of state discrimination see janos a. bergou , ulrike herzog , and mark hillery in _ quantum state estimation _ edited by m.  g.  a.  paris and j.  ehaek ( springer verlag , berlin , 2004 ) p. 417 . for a review of experimental state discrimination see anthony chefles in _ quantum state estimation _ edited by m.  g.  a.  paris and j.  ehaek ( springer verlag , berlin , 2004 ) p. 467 .",
    "c.  w.  helstrom , _ quantum detection and estimation theory _",
    "( academic press new york 1976 ) .",
    "i.  d.  ivanovic , phys .",
    "a * 123 * , 257 ( 1987 ) .",
    "d.  dieks , phys .",
    "a * 126 * , 303 ( 1988 ) .",
    "a.  peres , phys .",
    "a * 128 * , 19 ( 1988 ) . for a detailed review of programmable quantum processors see vladimir buek , mark hillery , mario ziman , and marian roko , quantum information processing * 5 * , 313 ( 2006 ) .",
    "mark hillery , vladimir buek , and mario ziman , phys .",
    "a * 65 * , 022301 ( 2002 ) .",
    "michael a.  nielsen and isaac l.  chuang , phys .",
    "lett .  * 79 * , 321 ( 1997 ) .",
    "m.  raginsky , phys .",
    "lett .  a * 290 * , 11 ( 2001 ) .",
    "a.  gilchrist , n.  k.  langford , and m.  nielsen , phys .",
    "a * 71 * , 062310 ( 2005 ) .",
    "mark hillery , mario ziman , and vladimir buek , phys .",
    "a * 73 * , 022345 ( 2006 ) .",
    "michal micuda , miroslav jeek , miloslav duek , and jaromir fiuraek , phys .",
    "a * 78*. 062311 ( 2008 ) .",
    "john preskill , proc .",
    "a * 454 * , 385 ( 1998 ) .",
    "g.  vidal , l.  masanes , and j.  i.  cirac , phys .",
    "lett .  * 88 * , 047905 ( 2002 ) .",
    "vladimir buek and miloslav duek , phys .",
    "a * 66 * , 0022112 ( 2002 ) .",
    "janos bergou and mark hillery , phys .",
    "* 94 * , 160501 ( 2005 ) .",
    "lov k.  grover , phys .",
    "lett .  * 79 * , 325 ( 1997 ) .",
    "marianna bonanome , mark hillery , and vladimir buek , phys .",
    "rev .  a * 76 * , 012324 ( 2007 ) .",
    "janos bergou , edgar feldman , and mark hillery , phys .",
    "a * 73 * , 032107 ( 2006 ) ."
  ],
  "abstract_text": [
    "<S> we discuss quantum information processing machines . </S>",
    "<S> we start with single purpose machines that either redistribute quantum information or identify quantum states . </S>",
    "<S> we then move on to machines that can perform a number of functions , with the function they perform being determined by a program , which is itself a quantum state . </S>",
    "<S> examples of both deterministic and probabilistic programmable machines are given , and we conclude with a discussion of the utility of quantum programs . </S>"
  ]
}