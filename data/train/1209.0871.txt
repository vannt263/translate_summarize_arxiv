{
  "article_text": [
    "the _ graph isomorphism problem _ the problem of deciding whether two finite graphs are isomorphic or not has a long history in mathematics and computer science .",
    "it is one of the most important decision problems for which the computational complexity is not known yet  @xcite , and it is believed to be neither in p nor np - complete .",
    "its uncertain status has led to the definition and study of the class gi of the decision problems that are polynomial - time turing reducible to it @xcite .",
    "the best current theoretical algorithm for the solution of the graph isomorphism problem is due to eugene luks @xcite .",
    "his algorithm runs in time @xmath0 , where @xmath1 is the number of nodes in the graphs , and it relies on the classification of finite simple groups @xcite . without using this major result ,",
    "whose proof consists of tens of thousands of pages in several hundred journal articles and for which a unified , simplified and revised version is still in progress , babai and luks @xcite gave an algorithm that runs in @xmath2 time .",
    "the graph isomorphism problem has many practical applications outside mathematics .",
    "our interest in it stems from its applications in computational biology and bioinformatics .",
    "graphs are ubiquitous in biology as models of different complex systems : molecular structures , phylogenetic trees and networks , metabolical pathways , protein - protein interaction ( ppi ) networks , gene expression networks , etc . @xcite . in all these fields ,",
    "the comparison of graphs is an important computational problem .",
    "for instance , a protein s function is closely related to its three - dimensional shape , which at an intermediate level of detail is modeled by a contact graph , and thus the comparison of such contact graphs is a key tool in the prediction of proteins function @xcite ; the comparison of phylogenies is acknowledged to be one of the main problems in phylogenetics @xcite ; and the comparison of metabolic pathways and ppi networks is currently one of the hot tools in the study of evolution @xcite .",
    "the most basic graph comparison problem in all these contexts is , of course , the detection of equalities . without being able to decide efficiently whether two such graphs are isomorphic or not , we can not expect to define metrics , matchings or alignments that can be computed efficiently .",
    "so , it is important to design efficient algorithms to test if two graphs are isomorphic , at least for some special classes of graphs with practical applications .",
    "the aforementioned algorithm by luks @xcite is fixed - parameter tractable , in the sense that it runs in polynomial time if we consider an upper bound @xmath3 for the degrees of the graphs under comparison as a constant .",
    "such an algorithm , even for _ ternary graphs _ ( graphs with all their nodes of degree at most 3 ) , has relevant applications in computational biology : for instance , in phylogenetics , in the comparison of arbitrary fully resolved rooted phylogenetic networks , and in the comparison of split networks @xcite ; in both types of networks , all nodes have total degrees at most 3 . for these networks ,",
    "no specific polynomial - time isomorphism test has been devised yet , and the authors working with them simply quote luks result when they need to state that their isomorphism can be decided in polynomial time ; see , for instance , @xcite or @xcite .",
    "the problem with luks algorithm is that it is purely theoretical , very difficult to use in practice , and , in particular , we have not been able to find any implementation of it in the literature .",
    "the main goal of this paper is , then , to present an efficient implementation of this algorithm in the sage system .",
    "we also present an implementation of an adaptation of this algorithm that solves the isomorphism problem for fully resolved rooted phylogenetic networks .",
    "this paper is based on the first author s master thesis @xcite , where we refer the reader for more details .",
    "in this section we explain luks algorithm for _ ternary _ graphs , that is , for connected graphs with all their nodes of degree at most @xmath4 .",
    "we shall omit all proofs , which can be found in the original paper by luks @xcite or , with more detail , in the first author s master thesis @xcite .",
    "we begin by reducing the graph isomorphism problem to a problem about isomorphisms of groups . given two ternary graphs @xmath5 and @xmath6 , and two edges @xmath7 and @xmath8 , consider the ternary graph @xmath9 obtained by splitting @xmath10 and @xmath11 by means of new nodes @xmath12 and @xmath13 , respectively , and then connecting these new nodes @xmath12 and @xmath13 by means of a new edge @xmath14 . then , @xmath15 and @xmath16 are isomorphic if , and only if , given any @xmath7 , there exist some @xmath8 and some automorphism @xmath17 of @xmath18 such that @xmath19 , and in particular such that @xmath20 . and then , if any such automorphism of @xmath18 does exist , then any set of generators of @xmath21 , the group of automorphisms of @xmath22 that fixes @xmath14 , will contain some .",
    "this provides the following algorithm .",
    "[ isotoaute ]    so , we are reduced to compute a set of generators of @xmath23 , for a ternary graph @xmath18 and any @xmath24 .",
    "this group is determined through a natural sequence of successive `` approximations '' @xmath25 , where each @xmath26 is the subgraph consisting of all nodes and all edges of @xmath18 which appear in paths of length @xmath27 containing @xmath14 .",
    "more formally , if @xmath28 , let @xmath29 and , for every @xmath30 , @xmath31 there exist natural homomorphisms @xmath32 defined by the restriction of the automorphisms .",
    "these homomorphisms allow us to construct recursively a generating set for @xmath33 from one for @xmath25 by solving , for every @xmath34 , the following two problems :    1 .",
    "compute a set @xmath35 of generators of @xmath36 .",
    "2 .   compute a set @xmath37 of generators of @xmath38 .    indeed ,",
    "if @xmath39 is any set of pre - images of @xmath37 in @xmath33 , then @xmath40 generates @xmath33 .",
    "so , if we know how to solve problems i and ii , the algorithm to compute a set of generators of @xmath23 is the following . in it , and in the sequel , given two elements @xmath41 of a set @xmath42 ,",
    "we denote by @xmath43 the transposition @xmath44 .",
    "[ aute ]    set now @xmath45 and @xmath46 , and consider the mapping @xmath47 defined by @xmath48 ; we call @xmath49 the _ neighbor set _ of @xmath50 .",
    "the following result solves problem i.    [ k ] @xmath51    moreover , the fact that each @xmath36 is generated by transpositions implies , by induction , the following result , which will be useful later .",
    "[ tutte ] for each @xmath52 , @xmath25 is a @xmath53-group .",
    "so , our graph isomorphism problem is reduced to solve problem ii .",
    "now , consider the following three subsets of @xmath54 : @xmath55 we have the following result .",
    "@xmath38 is the set of those @xmath56 that stabilize the sets @xmath57 , @xmath58 , and @xmath59 .",
    "now , set @xmath60 and extend the action of @xmath25 on @xmath61 to @xmath62 in the natural way : if @xmath63 , then @xmath64 .",
    "color each element of @xmath62 with one of five colors that distinguish , on the one hand , whether or not it is in @xmath59 , and , on the other hand , whether it is in @xmath57 , or @xmath58 , or neither .",
    "only five colors are needed , since @xmath65 .    by the previous proposition , @xmath66 if and only if @xmath17 preserves these colors in @xmath54 .",
    "therefore , the isomorphism problem for ternary graphs is polynomial - time reducible to the following color automorphism problem ( taking @xmath67 , @xmath68 , @xmath69 ) .",
    "[ problem4 ] given    * a set of generators for a @xmath53-subgroup @xmath22 of the symmetric group @xmath70 of a colored set @xmath71 * a @xmath22-stable subset @xmath72 * a permutation @xmath73    find @xmath74 , where , for every @xmath75 @xmath76    now , the following three lemmas are the basis of algorithm [ cb(g ) ] that solves problem [ problem4 ] in polynomial - time , and thus it completes the graph isomorphism test we were looking for .",
    "[ leftcoset ] let @xmath22 be a subgroup of @xmath70 , @xmath77 and @xmath78 a @xmath22-stable subset of @xmath71 such that @xmath74 is not empty .",
    "then , @xmath79 is a subgroup of @xmath22 and @xmath74 it is a left coset of the subgroup @xmath79 .",
    "[ lemafilter ] given a set of generators of a subgroup @xmath22 of a symmetric group , one can compute in polynomial time a set of generators of any subgroup of @xmath22 that is known to have polynomially bounded index in @xmath22 and for which a polynomial - time membership test is available .",
    "[ lemablocksystem ] given a set of generators of a subgroup @xmath22 of a symmetric group and a @xmath22-orbit @xmath78 , one can determine in polynomial time a minimal @xmath22-block system in @xmath78 .",
    "[ cb(g ) ]    [ th : cost ] algorithm [ isotoaute ] solves the ternary graph isomorphism in time @xmath80 , with @xmath1 the size of the input graphs .",
    "the cost of computing ` buildx ` applied to a pair of graphs of size @xmath1 and a pair of edges is in @xmath81 time .",
    "for every @xmath52 , a set of generators of @xmath36 can be computed as explained in lemma [ k ] in @xmath82 time , a set of generators of @xmath83 can be computed , by reducing this computation to problem [ problem4 ] and then using algorithm [ cb(g ) ] , in @xmath84 time , and a set of preimages in @xmath33 of the latter can be computed in @xmath82 time .",
    "since there are at most @xmath81 indices @xmath52 , we conclude that the cost of computing a set of generators of @xmath23 by means of algorithm [ aute ] is in @xmath85 .",
    "since algorithm [ isotoaute ] calls algorithm [ aute ] @xmath81 times , the final cost of algorithm [ isotoaute ] is in @xmath80 .",
    "in our implementation we have improved the efficiency of luks algorithm by :    a.   reducing the size of the set @xmath54 . b.   representing the groups by means of smooth generating sequences . c.   precomputing the blocks .",
    "d.   running initial tests , to avoid trivial cases .",
    "e.   removing , for every @xmath52 , the permutations that do not swap the two `` parts '' @xmath15 and @xmath16 of @xmath18 .    with these improvements , the cost of the computation decreases to @xmath86 .",
    "we explain now in some detail the improvements ( a)(c ) , which were inspired by @xcite . for more details , see @xcite .    [ triplets ]",
    "as far as improvement ( a ) goes , we have been able to remove the triplets from @xmath62 , by replacing each node @xmath50 with a 3-elements neighbor set by a triangle with nodes at `` level '' @xmath87 and labeled edges : cf . .",
    "in this way , we can replace the graph @xmath18 by a new graph @xmath88 with some edges labeled .",
    "the automorphisms of @xmath88 must preserve labels , and therefore the computation of @xmath89 is the same as that of @xmath23 , except for the following facts : @xmath62 needs only to include the subsets of @xmath90 of size 1 or 2 ; we split @xmath91 into @xmath92 and we modify the set of colors on @xmath62 to distinguish , on the one hand , whether or not an element is in @xmath93 , or @xmath94 , or neither , and , on the other hand , whether it is in @xmath57 , or @xmath58 , or neither .    as to ( b ) , we represent 2-groups in a way that makes easier several key computations .",
    "let @xmath22 be a 2-group generated by @xmath95 .",
    "the sequence @xmath96 is a _",
    "smooth generating sequence _",
    ", for short ) for @xmath22 if @xmath97 \\leq 2 $ ] , for @xmath98 .",
    "sgs are preserved by homomorphisms and liftings , and if we know a sgs for a 2-group @xmath22 , then it is easy construct an sgs for a subgroup @xmath99 of index 2 @xcite .",
    "let @xmath22 be a 2-group , @xmath96 a sgs for it , and @xmath99 a subgroup of index 2 .",
    "let @xmath100 and set , for @xmath101 , @xmath102 then @xmath103 is a sgs for @xmath99 , and this sequence is computed in @xmath104 times the required time of a membership test for @xmath99 .",
    "let us consider finally improvement ( c ) . as we have seen in the proof of theorem [ th : cost ] , the most expensive part of luks algorithm is the recursive calls performed by algorithm [ cb(g ) ] .",
    "the task carried out by this algorithm can be reorganized so as to limit the number of different blocks visited .",
    "these blocks form a tree that is precomputed and guides the recursion .",
    "let @xmath22 be a 2-group acting on a stable subset @xmath78 of a colored set @xmath71 .",
    "we call a binary tree @xmath105 a _ structure tree _ for @xmath78 with respect to @xmath22 , @xmath106 , if the set of leaves of @xmath105 is @xmath78 , and the action of any @xmath107 on @xmath78 can be lifted to an automorphism of @xmath105 .",
    "let @xmath108 be a fixed color of @xmath71 ( in our application , it will be the color of the elements of @xmath54 that do not belong to @xmath109 ) . a node @xmath110 of @xmath111 will be called _ active _ if @xmath112 . an active node @xmath110 is _ facile _ if @xmath22 is intransitive on @xmath110 and the latter has exactly one active child .",
    "let @xmath113 denote the closest non facile descendant of @xmath110 in @xmath105 .",
    "we can precompute the entire structure tree @xmath114 for a given pair @xmath115 using algorithm [ t(b , g ) ) ] below . with this algorithm",
    ", we can construct every structure tree @xmath116 in @xmath82 time , and we can compute the mapping @xmath117 and the set of active nodes in @xmath118 time . using structure trees to guide the recursion , the cost of computing @xmath119 decreases to @xmath86 .",
    "[ t(b , g ) ) ]      we have implemented luks algorithm using the language python and some specific sage libraries for handling graphs and groups of permutations .    besides the obvious classes and functions necessary to implement the algorithm , we use a new class , called ` node ` , for the structure tree .",
    "this class has four attributes :    * ` node ` , the content of the node . * ` left ` , the left child . * ` right ` , the right child .",
    "* ` parent ` , the parent .    when we build a new ` node",
    "` without some attributes , they will be empty arrays .",
    "this class has the necessary functions to modify its attributes , as well as the following functions :    * ` isleaf ( ) ` , to know whether the node is a leaf . * ` istransitive ( ) ` , to know whether @xmath22 is transitive on the node . * ` isactive(q ) ` , to know whether the node is active w.r.t . @xmath108 .",
    "* ` isfacile(q ) ` , to know whether the node is facile w.r.t . @xmath108 . * ` delta(q ) ` , to know the nearest non facile descendant of the node .",
    "to test whether two graphs are isomorphic or not , we can use two different functions , ` isomorphism ` and ` isomorphism2 ` .",
    "both functions answer the question whether the input graphs are isomorphic , but moreover the first function returns the whole group of automorphisms that fix the distinguished edge @xmath14 of the graph @xmath9 , while the second one only returns the subgroup of those automorphisms of @xmath18 that swap the parts @xmath15 and @xmath16 .",
    "finally , we have adapted luks algorithm to test the isomorphism of fully resolved rooted phylogenetic networks on a given set of taxa .",
    "a _ rooted phylogenetic network _",
    ", on a set of taxa @xmath120 is a rooted , directed , acyclic graph with its leaves bijectively labeled in @xmath120 .",
    "these graphs are used as explicit models of evolutionary histories that , besides mutations , include reticulate evolutionary events like genetic recombinations , lateral gene transfers or hybridizations .",
    "an evolutionary network is _ fully resolved _ , or binary ,",
    "when , for every node @xmath50 in it , the ordered pair @xmath121 is either @xmath122 ( the root ) , @xmath123 ( the leaves ) , @xmath124 ( the _ tree nodes _ ) or @xmath125 ( the _ reticulate nodes _ ) .",
    "two evolutionary networks on @xmath120 are _ isomorphic _ when they are isomorphic as directed graphs and the isomorphism preserves the leaves labels . for more on phylogenetic networks ,",
    "see @xcite .",
    "the main difference between the case of rooted phylogenetic networks and the general case is that , in the former , the isomorphisms map the root to the root , and therefore the graph @xmath126 can be simply obtained by connecting the roots by an edge @xmath14 . in particular , algorithm [ isotoaute ] needs not to call @xmath81 times algorithm [ aute ] , but only once , and the resulting cost is then in @xmath127 .    to test the isomorphism of",
    "fully resolved rooted phylogenetic networks we have defined the function ` isomorphismphilo ` , which has the following parameters :    * ` x1 ` , the first phylogenetic network . * ` x2 ` , the second phylogenetic network . * ` n ` , the number of nodes of x1 . * ` dic1 ` , the dictionary with the labels of the nodes of the first graph . * ` dic2 ` , the dictionary with the labels of the nodes of the second graph . * ` r1 ` , the root of the first graph . * ` r2 ` , the root of the second graph .    `",
    "isomorphismphilo ` accepts networks with _ inner taxa _",
    "( with internal labeled nodes ) as well as _ multilabeled networks _ ( where different nodes can have the same label ) , although these features are not used ( yet ) in the phylogenetic networks literature . for the moment",
    ", the algorithm only accepts phylogenetic networks created with sage s function ` graph ` , but in the near future we plan to adapt it so that it accepts networks described in the format enewick @xcite .",
    "we have performed several tests on our implementation , which we report in the next subsection . in the first and the third tests , we have used sage functions to generate random graphs and we have then made these graphs connected and trivalent , by randomly adding or removing edges when it was necessary . in the second test",
    ", we have used the function ` graphs.degreesequence ` that , given a sequence of degrees , returns a graph whose nodes have this sequence of degrees , if some exists . this has allowed us to know the probability that the graphs under comparison were isomorphic .    to perform the tests on phylogenetic networks we defined some functions to create random",
    "fully resolved rooted phylogenetic networks :    * ` createdic(nodes , n ) ` , which , given a set of nodes , returns the following dictionary : @xmath128 * ` createdic2(nodes , n ) ` , as above , but the selected nodes are labeled `` a '' or `` b '' equiprobably . * ` leaves(x1 ) ` , returns the set of nodes of the network x1 .",
    "then , we have developed an algorithm ` randomtree(n ) ` that returns a fully resolved rooted phylogenetic network with @xmath1 nodes . by default , each internal node has a probability of @xmath129 of being hybrid , but it can be changed by simply changing the probability parameter from @xmath129 to the desired probability .",
    "the documentation of the whole module can be found in http://www.alumnos.unican.es/aam35/sage-epydoc/index.html and the code in http://www.alumnos.unican.es/aam35/isotrigraph.py .",
    "the first two examples show that the code works correctly , and then the tests prove that it runs in a reasonable time , comparable to the speed of the own sage algorithm to test isomorphisms of graphs .",
    "[ imptestex1 ] consider the graphs @xmath15 and @xmath16 depicted in fig .",
    "[ example1 ] .",
    "these graphs are created in sage with :    ....   sage : x3=graph([(1 , 7 ) , ( 1 , 10 ) , ( 2 , 3 ) , ( 2 , 4 ) , ( 3 , 4),(4 , 9 ) ,          ( 5,6),(6 , 8) , ( 7 , 8) , ( 7 , 9),(8 , 9 ) ] )   sage : x4=graph([(2 , 3 ) , ( 2 , 10 ) , ( 1 , 7 ) , ( 1 , 4 ) , ( 7 , 4),(4 , 9 ) ,          ( 5 , 6),(6 , 8) , ( 3 , 8) , ( 3 , 9),(8 , 9 ) ] ) ....     the graphs @xmath15 ( left ) and @xmath16 ( right ) in example [ imptestex1],title=\"fig : \" ] the graphs @xmath15 ( left ) and @xmath16 ( right ) in example [ imptestex1],title=\"fig : \" ]    we test whether they are isomorphic :    .... sage : isomorphism2(x3,x4,10,iso = true ) 1 -- > 2 2 -- > 1 3 --",
    "> 7 4 -- > 4 5 -- > 5 6 -- > 6 7 -- > 3 8 -- > 8 9 -- > 9 10 -- > 10 true ....    and , indeed , it is obvious that this is an isomorphism between @xmath15 and @xmath16 .",
    "[ imptestex2 ] consider now the graphs @xmath15 and @xmath16 depicted in fig .",
    "[ example2 ] .",
    ".... sage : x1=graph([(1 , 7 ) , ( 1 , 8) , ( 1 , 10 ) , ( 2 , 3 ) , ( 3 , 6 ) ,        ( 4 , 5 ) , ( 5 , 6 ) , ( 6 , 10 ) , ( 7,9 ) , ( 7 , 10 ) , ( 8 , 9 ) ] ) sage : x2=graph([(1 , 7 ) , ( 1 , 9 ) , ( 2 , 3 ) , ( 2 , 5 ) , ( 2 , 10 ) ,         ( 4 , 5 ) , ( 4 , 6 ) , ( 4 , 10 ) , ( 6,8 ) , ( 7 , 8) , ( 7 , 10 ) ] ) sage : isomorphism(x1,x2,10 ) false    ....    and , indeed , they are clearly non isomorphic .     the graphs @xmath15 ( left ) and @xmath16 ( right ) in example [ imptestex2],title=\"fig : \" ] the graphs @xmath15 ( left ) and @xmath16 ( right ) in example [ imptestex2],title=\"fig : \" ]    fig .",
    "[ graphic1 ] shows the time needed by ` isomorphism2 ` to test whether two random graphs are isomorphic , as a function of the numbers of nodes in the graphs .",
    "the times are so small because two random graphs with the same number of nodes have probably different numbers of edges , a property that our program checks before proceeding with luks algorithm .",
    "although in most cases the algorithm detected non - isomorphism by trivial reasons , the algorithm is also relatively efficient in non trivial cases .        in this test we fix the degrees of @xmath130 nodes in the graphs , and the degree of the last node is chosen at random . in this way we guarantee that the probability of two graphs being isomorphic is @xmath131 . in this case",
    ", our algorithm also runs in reasonable time : see figs .",
    "[ graphic2 ] and [ graphic3 ] .        ]    fig .",
    "[ graphic4 ] shows the times ( red dots ) needed by the algorithm to detect the isomorphism between pairs of isomorphic graphs with @xmath1 nodes , and it compares this time with the functions @xmath132 , @xmath133 , @xmath134 , and @xmath135 .    ]",
    "our last test deals with rooted phylogenetic networks .    fig .",
    "[ graphic5 ] displays the relation running time - number of nodes for our algorithm when applied to random fully resolved rooted phylogenetic networks on the same sets of taxa , and fig .",
    "[ graphic6 ] shows this relation for phylogenetic networks that are isomorphic as undirected graphs but need not be isomorphic as phylogenetic networks .",
    "in this paper we have presented our implementation in sage of luks polynomial - time algorithm for testing the isomorphism of ternary graphs .",
    "this algorithm has interesting applications in phylogenetics , as it allows , for instance , to detect whether two fully resolved rooted phylogenetic networks are isomorphic .",
    "therefore , we have adapted and implemented luks algorithm for this type of graphs .",
    "our adaptation has been , except for one point , a direct translation of luks algorithm .",
    "fully resolved rooted phylogenetic networks have specific characteristics that could be used to improve the algorithm to make it still more efficient in this specific application .",
    "it is in our research agenda to develop such an adaptation , and we hope to present it elsewhere .    * acknowledgements . *",
    "this research has been partially supported by the spanish government and the ue feder program , through project mtm2009 - 07165 .",
    "we thank prof .",
    "t. recio for encouraging us to write this report , and for his comments on a first version of it ."
  ],
  "abstract_text": [
    "<S> the graph isomorphism problem has a long history in mathematics and computer science , with applications in computational chemistry and biology , and it is believed to be neither solvable in polynomial time nor np - complete . </S>",
    "<S> e. luks proposed in 1982 the best algorithm so far for the solution of this problem , which moreover runs in polynomial time if an upper bound for the degrees of the nodes in the graphs is taken as a constant . </S>",
    "<S> unfortunately , luks algorithm is purely theoretical , very difficult to use in practice , and , in particular , we have not been able to find any implementation of it in the literature . </S>",
    "<S> the main goal of this paper is to present an efficient implementation of this algorithm for ternary graphs in the sage system , as well as an adaptation to fully resolved rooted phylogenetic networks on a given set of taxa . </S>"
  ]
}