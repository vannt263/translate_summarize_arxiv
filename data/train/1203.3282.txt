{
  "article_text": [
    "ever since random coding schemes were demonstrated to approach the capacity of additive white gaussian noise ( awgn ) channels @xcite , enormous research has taken place to find _ structured _ coding schemes which can accomplish the same job .",
    "the need for structured coding schemes is to facilitate simpler analysis of the code structure and to achieve reduced complexity in encoding and decoding .",
    "a well known method of obtaining structured codes is to carve out a finite set of lattice points from dense lattices @xcite-@xcite .",
    "such codes are referred to as lattice codes , and are usually obtained as a set of coset representatives of a suitable quotient lattice .",
    "further , the lattice codes have the advantage of inheriting most of the code properties from the parent lattice , and as a result , the choice of the lattice is crucial to the performance of the code .      in this paper",
    ", we are interested in carving lattice codes from barnes - wall ( bw ) lattices @xcite , @xcite .",
    "our goal is to construct efficient bw lattice codes of large block lengths which work with low - complexity encoders and decoders . in particular , efficient low - complexity decoders for complex bw lattices are readily available in @xcite , @xcite .",
    "therefore , if lattice codes from complex bw lattices are employed for communication over awgn channels , then the decoders of @xcite , @xcite can be used to recover information with low computational complexity . in @xcite ,",
    "the authors have proposed two low - complexity implementations of the bounded distance decoder for bw lattices , namely ( _ i _ ) the sequential bounded distance decoder , and ( _ ii _ )  the parallel bounded distance decoder .",
    "inspired by the parallel decoder in @xcite , list decoders for bw lattices have been recently proposed in @xcite .",
    "we note that the parallel decoders of @xcite and @xcite have low - complexity only when implemented on sufficiently large number of parallel processors .",
    "if the above decoders are implemented on a single processor , then the complexity advantages are lost , and specifically , the complexity of the list decoder grows larger than that of the sequential decoder in @xcite . since we are interested in lattice codes of large block lengths , we focus on the sequential bounded distance decoder which seems more suitable for implementation ( see section [ sec5_subsec2 ] for more details on the complexity advantages of sequential bounded distance decoder over the list decoder ) . the sequential decoder in @xcite",
    "was proven to correct any error up to the packing radius .",
    "however , the possibility of correct decoding is not known when the received vector falls outside the bounded decoding ball of packing radius . in a nutshell",
    ", the exact error performance of the decoder is not known .",
    "the existence of this low - complexity decoder has motivated us to study its error performance , and use it to decode bw lattice codes .",
    "we refer to this decoder as the sequential bw lattice decoder ( sbwd ) .",
    "the contribution of this paper on the construction and decoding of complex bw lattices are given below .    1 .",
    "we introduce construction @xmath0 of lattices which enables us to generate some well structured lattices from linear codes over _ polynomial rings _ @xcite . as an immediate application",
    ", we apply construction @xmath0 to obtain bw lattices of dimension @xmath1 for any @xmath2 .",
    "the proposed method is yet another construction of bw lattices ( shown in section [ sec3 ] ) and shows a new connection between codes over polynomial rings and lattices .",
    "we show that the proposed construction provides an explicit method of obtaining and bit - labelling complex bw lattice codes .",
    "2 .   we study the error performance of the sbwd in awgn channels .",
    "since the error performance of the sbwd depends on the error performance of the underlying soft - input reed - muller ( rm ) decoders , we study the error performance of the soft - input rm decoder as used in the sbwd .",
    "first , we use the jacobi - theta functions @xcite to characterize the virtual binary channels that arise in the decoding process .",
    "subsequently , we study the noise statistics in the algorithm , and provide an upper bound on the error performance of the soft - input rm decoders . through computer simulations ,",
    "we obtain the error performance of the sbwd , and show that the decoder is powerful in making correct decisions well beyond the packing radius @xcite ( see table i in section [ sec5 ] for the effective radius of the sbwd decoder ) .",
    "this is the first work that showcases the error performance of sbwd in decoding bw lattices of large block lengths .",
    "3 .   to decode the lattice code in awgn channels ,",
    "we employ the sbwd along with a noise trimming technique , wherein the components of the received vector are appropriately scaled before passing it to the sbwd . with the noise - trimming technique ,",
    "the sbwd is forced to decode to a codeword in the code which in turn improves the error performance .",
    "we refer to this decoder as the _ bw lattice code decoder _ ( bwcd ) .",
    "we obtain the bit error rate ( ber ) of the bwcd for codes in complex dimension @xmath3 , and @xmath4 , and show that the bwcd outperforms the sbwd by @xmath5 db .",
    "the bw lattices @xcite is a special family of @xmath6-dimensional lattices that exist when @xmath6 is a power of @xmath7 .",
    "these lattices were originally discovered as a solution to finding extreme quadratic forms in 1959 @xcite . only in 1983 , the now well known connection between bw lattices and reed - muller codes was discovered by @xcite .",
    "this connection is found in several works @xcite , @xcite , @xcite in different forms .",
    "other than its construction through reed muller codes , the generator matrices of the bw lattices are also known to be obtained though kronecker products @xcite , @xcite . in 1989 ,",
    "forney proposed a low - complexity bounded distance decoding algorithm for leech lattices @xcite .",
    "as a generalization , in the same paper , a similar algorithm has been shown to be applicable in decoding all construction @xmath8 lattices .",
    "as bw lattices are known to be obtained through construction @xmath8 @xcite , bounded distance decoders for bw lattices were known in principle since @xcite . only in the 1990 s ,",
    "explicit bounded distance decoders for bw lattices were implemented for dimension up to @xmath9 , and numerical results on the error performance were reported @xcite , @xcite . in 2008 ,",
    "micciancio and nicolosi @xcite have proposed two low - complexity implementations of bounded distance decoder for bw lattices , namely ( _ i _ ) the sequential bounded distance decoder , and ( _ ii _ ) the parallel bounded distance decoder .",
    "if @xmath10 denotes the dimension of complex bw lattice , the worst - case complexity of the decoders has been shown to be @xmath11 and @xmath12 for the fully sequential decoder and the fully parallel decoder , respectively .",
    "for the fully sequential decoder , the algorithm is assumed to be implemented on a single processor , whereas for the fully parallel decoder , the algorithm is assumed to be implemented on @xmath13 parallel processors . inspired by the fully parallel implementation in @xcite , list decoders for bw lattices have been recently proposed in @xcite where the list decoder outputs a list of bw lattice points within any given radius from the target vector . the complexity of the list decoder is shown to be polynomial in the dimension of the lattice , and polynomial in the list size , which is a function of the euclidean radius .",
    "note that the sbwd exploits the construction @xmath8 structure of bw latices as a multilevel code of nested binary reed - muller ( rm ) codes , and decodes each rm code through a successive interference cancellation technique . on the other hand ,",
    "the list decoder does not exploit construction @xmath8 structure of bw lattices , and hence , does not need the support of any soft - input rm decoders .",
    "the rest of this paper is organized as follows : in section [ sec2 ] , we provide a background on lattice constructions from linear codes . in section [ sec3 ] ,",
    "we introduce construction @xmath0 of complex bw lattices . in section [ sec4 ] ,",
    "we study the error performance of the sbwd , while in section [ sec5 ] and section [ sec6 ] , we use the sbwd to decode the bw lattice code .",
    "finally , in section [ sec7 ] , we conclude this paper and provide some directions for future work .    _",
    "* notations * : _ throughout the paper , boldface letters and capital boldface letters are used to represent vectors and matrices , respectively . for a complex matrix @xmath14 ,",
    "the matrices @xmath15 , @xmath16 and @xmath17 denote the transpose , real part and imaginary part of @xmath14 , respectively .",
    "the set of integers , real numbers , and complex numbers are denoted by @xmath18 , @xmath19 , and @xmath20 , respectively .",
    "we use @xmath21 to represent @xmath22 for an @xmath23-length vector @xmath24 , we use @xmath25 to represent the @xmath26-th component of @xmath24 .",
    "cardinality of a set @xmath27 is denoted by @xmath28 .",
    "magnitude of a complex number @xmath29 is denoted by @xmath30 .",
    "the number of ways of picking @xmath23 objects out of @xmath31 objects is denoted by @xmath32 . the symbol @xmath33 denotes the nearest integer of a real number ,",
    "and we set @xmath34 for any @xmath35",
    ". finally , we use @xmath36 to denote the probability operator .",
    "a complex lattice @xmath37 over @xmath38 $ ] is a discrete subgroup of @xmath39 @xcite .",
    "alternatively , @xmath37 is a @xmath38$]-module generated by a basis set @xmath40 as @xmath41 \\right\\rbrace.$ ] it is well known that dense lattices can be obtained via binary linear codes @xcite . depending on the structure of the underlying linear codes , lattice construction can be categorized into different types . in this section , we recall two well known constructions for the case of complex lattices  @xcite .",
    "* construction @xmath42 : * +    [ def0_1 ] a complex lattice @xmath37 is obtained by construction @xmath42 from the binary linear code @xmath43 if @xmath37 can be represented as @xmath44^{n } \\oplus \\mathcal{l}_{0},\\ ] ] where @xmath45 is a lattice code obtained by the component - wise mapping @xmath46 $ ] given by @xmath47 and @xmath48 on the alphabet of @xmath43 , where @xmath49 .    *",
    "construction @xmath8 : * +    [ def_cons_d ] a complex lattice @xmath37 is obtained by construction @xmath8 from a family of nested binary linear codes @xmath50 if @xmath37 can be represented as @xmath51^{n } \\oplus ( 1+i)^{m-1}\\mathcal{l}_{m-1 } \\oplus \\cdots \\oplus ( 1+i)\\mathcal{l}_{1 } \\oplus \\mathcal{l}_{0},\\ ] ] where @xmath52 is obtained by the component - wise mapping @xmath46 $ ] given by @xmath47 and @xmath48 on the alphabet of @xmath53 .",
    "a bw lattice can be obtained via construction @xmath8 as a @xmath38 $ ] lattice as follows @xcite .",
    "suppose we want to construct the complex lattice @xmath54 of dimension @xmath1 where @xmath2 , let @xmath55 be the binary reed - muller ( rm ) code ( sec .",
    "3 , @xcite ) of length @xmath56 and of order @xmath57 .",
    "then , @xmath54 can be constructed as @xmath58^{2^{m } } \\right\\}\\ ] ] where @xmath59 is as given in definition [ def_cons_d ] .",
    "for notational convenience , we also write as @xmath60^{2^{m } } \\oplus \\bigoplus_{r=0}^{m-1 } ( 1+i)^{r}\\mathcal{rm}(r , m).\\ ] ] this method generates @xmath54 as a multi - level structure of nested rm codes and hence it falls under construction @xmath8 @xcite .",
    "* generalized construction @xmath42 @xcite @xcite : * +    apart from construction @xmath8 , the bw lattice codes can be obtained by the generalized construction @xmath42 . for the complex bw lattice @xmath54 ,",
    "let @xmath61 denote the generator matrix in the triangular form , where the rows @xmath62 of @xmath63 forms a basis set of @xmath54 , where @xmath10 .",
    "let @xmath64 represent the diagonal elements , where @xmath65 for some integer @xmath66 , and @xmath67 .",
    "for this lattice construction , one can easily map binary data to lattice points as follows :    1 .   * bit labelling : * map @xmath68 information bits to @xmath69 /p_{j}\\mathbb{z}[i]$ ] where @xmath70 and @xmath71 is the cardinality of @xmath38 /p_{j}\\mathbb{z}[i]$ ] .",
    "* encoding : * using @xmath72 , a lattice point is obtained as @xmath73 .",
    "* shaping : * since @xmath74^{n } + \\mathcal{l}$ ] , a lattice point within @xmath75 can be obtained as @xmath76 mod @xmath77^{n}$ ] .",
    "* motivation for construction @xmath0 : * +    in the bit - labelling step above , binary digits have to be mapped to the symbols of @xmath38 /p_{i}\\mathbb{z}[i]$ ] .",
    "some of the well - known bit - labelling methods include gray - mapping and set - partitioning based methods .",
    "/p_{i}\\mathbb{z}[i]$ ] is not necessarily optimal since it does not guarantee that the neighbouring lattice points in the lattice code are separated by maximum number of information bits .",
    "efficient bit labelling of lattice codes is a separate problem of its own and is out of the scope of this work .",
    "] unlike the case of real integer lattice , @xmath38 /p_{i}\\mathbb{z}[i]$ ] is an arbitrary subset of @xmath38 $ ] , and bit mapping to @xmath38 /p_{j}\\mathbb{z}[i]$ ] is not straightforward unless the set of representatives for @xmath38 /p_{j}\\mathbb{z}[i]$ ] is chosen with good shaping property . through construction @xmath0 , we facilitate bit - labelling on complex integers by using the truncated binary expansion of the elements of @xmath38 /p_{j}\\mathbb{z}[i]$ ] over the base @xmath78 @xcite . with this ,",
    "the bits labelled on @xmath69 /p_{j}\\mathbb{z}[i]$ ] are nothing but the bits in the truncated binary expansion of @xmath79 . to assist the bit - labelling step",
    ", we use polynomial rings over @xmath80 to represent the elements of @xmath38 /p_{j}\\mathbb{z}[i]$ ] . for the encoding step ,",
    "we use a linear code over polynomial rings , and obtain the lattice points as embedding of the codewords a of linear code into the euclidean space . finally ,",
    "for the shaping step , we propose an appropriate mapping on @xmath38 $ ] which provides a label code with appropriate shaping property , i.e. , we explicitly provide a method of bit - labelling complex bw lattices .",
    "our construction is an extension of construction @xmath42 and hence we refer to it as construction @xmath0 .",
    "we now define polynomial rings and codes over polynomial rings .",
    "( ch . 4 in @xcite )",
    "we define the polynomial quotient ring @xmath81 \\diagup u^{m}$ ] in variable @xmath82 for any @xmath2 as @xmath83 with regular polynomial addition and multiplication over @xmath80 coefficients along with the quotient operation @xmath84 which is equivalent to cancelling all the terms of degree greater than or equal to @xmath31 .",
    "a linear code @xmath43 over @xmath85 is a subset of @xmath86 which can be obtained through a generator matrix @xmath87 as @xmath88 for some @xmath89 and the matrix multiplication is over the ring @xmath85 .",
    "we now introduce construction @xmath90 in the following definition .",
    "[ def1 ] a complex lattice @xmath37 is obtained by construction @xmath0 from a linear code @xmath43 over @xmath85 for some @xmath2 if @xmath37 can be written as @xmath91^{n } + \\mathcal{ec},\\ ] ] where @xmath92^{n}$ ] is a lattice code obtained from the linear code @xmath43 through the mapping @xmath93 $ ] given by @xmath94 such that @xmath46 $ ] given by @xmath47 and @xmath48 , and @xmath95 .",
    "note that construction @xmath42 can be obtained as a special case from construction @xmath0 when @xmath96 , wherein the embedding operation @xmath97 coincides with @xmath98 given in definition [ def_cons_d ] . in the following subsections , we use construction @xmath0 to obtain complex bw lattices of dimension @xmath1 for any @xmath2 by embedding a linear code @xmath43 ( denoted by @xmath99 ) over the quotient ring @xmath85 to a lattice code @xmath100 ( denoted by @xmath101 ) .      in order to obtain @xmath54 as construction @xmath0 , we first need to find a suitable linear code @xmath99 over the ring @xmath85 .",
    "we propose such a linear code which can be obtained by the following the generator matrix @xmath102^{\\otimes m},\\ ] ] where the tensor operation is over the ring @xmath85 .",
    "to obtain @xmath103 , the linear code @xmath104 can be generated using @xmath105 \\in \\mathcal{u}_{2}^{4 \\times 4}.\\ ] ]    @xmath106 + * encoding of linear code @xmath99 * + by using @xmath107 as a matrix over @xmath85 , the code @xmath99 is obtained as follows : let @xmath108 , i.e. , the @xmath26-th component of @xmath109 is given by @xmath110 where @xmath111 for all @xmath112 .",
    "using @xmath109 and @xmath107 , the code @xmath113 can be obtained as @xmath114 where the matrix multiplication is over @xmath85 .",
    "we now provide an example for the proposed encoding technique , showing the positions of the information bits that get encoded to the codewords of @xmath99 .    for @xmath115 , the input vector @xmath109 and the generator matrix @xmath116",
    "are of the form , @xmath117 \\mbox { and } \\textbf{g}_{4 } = \\left[\\begin{array}{cccc } 1 & 1 & 1 & 1\\\\ 0 & u & 0 & u\\\\ 0 & 0 & u & u\\\\ 0 & 0 & 0 & 0\\\\ \\end{array}\\right].\\ ] ]    @xmath106 + we define the rate of the linear code @xmath99 as the ratio of the number of information bits per codeword and the length of the code ( which is also known as the spectral - efficiency of the code ) .",
    "[ prop1 ] the rate of the code @xmath99 is @xmath118 .",
    "each component of @xmath109 carries @xmath31 information bits in the variables @xmath119 as shown in .",
    "this amounts to a total of @xmath120 bits carried by @xmath109 .",
    "however , since the matrix multiplication is over @xmath85 , not all the information bits @xmath119 are encoded as codewords of @xmath99 ( since @xmath121 for @xmath122 ) . using the structure of @xmath107 it is possible to identify the indices @xmath123 of information bits @xmath119 which get encoded into the codewords of @xmath99 as follows .",
    "let the set @xmath124 denote the indices of the rows of @xmath107 whose components take values @xmath125 or @xmath126 for each @xmath127 . due to the quotient operation @xmath128 ,",
    "the components of @xmath109 which are in the index set @xmath124 are restricted to be of the form , @xmath129 for example , @xmath130 and @xmath131 . using the structure of @xmath107",
    "we observe that the cardinality of @xmath124 denoted by @xmath132 is @xmath133 , and hence we find the total number of information bits per codeword of @xmath99 as @xmath134    we now show the equivalence of our encoding technique to construction @xmath8 . in other words",
    ", the following theorem shows that the codewords generated in can be uniquely represented as vectors of a multi - level code of nested rm codes .",
    "the codewords generated in can be uniquely represented as codewords obtained through construction @xmath8 .",
    "see the proof of theorem 1 in @xcite .",
    "till now , we have presented the linear code @xmath99 and its encoding technique over the quotient ring @xmath85 .",
    "now , we discuss the embedding operation of @xmath99 into the euclidean space . by using the map @xmath95 on @xmath99 , we get the lattice code @xmath101 .",
    "note that @xmath101 can be used as a _ tile _ in constructing the bw lattice , i.e. , @xmath54 can be obtained by replicating @xmath101 in @xmath38^{2^{m}}$ ] as @xmath135^{2^{m } } + \\mathcal{ec}_{2^{m}}.$ ] it can be verified that @xmath101 is an arbitrary subset of @xmath54 and does not have cubic shaping . in fig .",
    "[ tiling ] , we plot the complex points generated as @xmath136 for @xmath137 .",
    "note that the points generated by @xmath138 are marked in black , whereas the points in other shades correspond to the shifted version of @xmath138 by constants @xmath139 and @xmath140 .     for @xmath137.,width=336 ]",
    "note that the code @xmath101 does not have good shaping , we observe that the average transmit power of the scheme is not small . to fix this problem , we propose a one - to - one mapping @xmath141 on @xmath101 to obtain a new lattice code denoted by @xmath142 such that it has good shaping property .      here",
    ", we propose a one - to - one mapping @xmath141 on @xmath101 to obtain a new lattice code @xmath142 which has the cubic shaping property when @xmath31 is even , and the rectangular shaping property when @xmath31 is odd . for any @xmath143 \\in \\mathcal{ec}_{2^{m}}$ ] , the mapping @xmath141 operates on each component of @xmath24 as , @xmath144 where @xmath145 is defined on @xmath146 $ ] as @xmath147 the mapping @xmath141 guarantees the following property on @xmath142 : @xmath148\\right\\}^{2^{m } } , \\mbox { if } m \\mbox { is even};\\\\~~\\\\ \\left\\{\\mathbb{z}_{2^{\\frac{m+1}{2}}}\\right\\}^{2^{m } } + i\\left\\{\\mathbb{z}_{2^{\\frac{m-1}{2}}}\\right\\}^{2^{m } } , \\mbox { if } m \\mbox { is odd}.\\\\ \\end{array }   \\right.\\end{aligned}\\ ] ] from , note that each component of the vector in @xmath142 is in a cubic box and a rectangular box , when @xmath31 is even and odd , respectively . in fig .",
    "[ cubic_shaping ] , we present the complex points @xmath138 with and without the mapping @xmath141 for @xmath137 . with this , the lattice code @xmath142 can be obtained from @xmath99 through the composition map @xmath149 where @xmath97 and @xmath141 are given in definition [ def1 ] and respectively .",
    "the following proposition shows that @xmath150 is a one - to - one map on @xmath99     and @xmath151 for @xmath137.,width=336 ]    the mapping @xmath152 given in is one - to - one .",
    "since @xmath152 is a composition mapping of @xmath97 and @xmath141 , and @xmath153 is a substitution operation using binary representation of complex numbers over the base @xmath154 , we have to prove that @xmath141 given in is one - to - one . here",
    ", we provide the proof when @xmath31 is even .",
    "for any @xmath155 such that @xmath156 , we prove that @xmath157 . applying the modulo operation in",
    ", @xmath158 satisfies @xmath159 for each @xmath160 , where @xmath161 and @xmath162^{2^m}$ ] .",
    "this implies @xmath163 for some @xmath164^{2^m}$ ] .",
    "the second equality follows as @xmath165 .",
    "further , since each component of @xmath158 is of the form @xmath138 for @xmath166 , the r.h.s of is nothing but the binary decomposition of @xmath167 over the base @xmath154 .",
    "since the radix representation over @xmath154 is unique , we have @xmath168 only if @xmath169 .",
    "this completes the proof when @xmath31 is even .",
    "the one - to - one nature of @xmath141 can be proved on the similar lines when @xmath31 is odd .",
    "the above proposition implies that mapping @xmath141 provides a new lattice code with better shaping property .",
    "the following theorem shows that @xmath142 can be used as a tile to obtain bw lattices .",
    "[ thm2 ] the lattice code @xmath142 and the lattice @xmath54 are related as @xmath170^{2^m } \\oplus \\mathcal{l}_{2^{m}}.$ ]    see the proof of theorem 2 in @xcite .    using the results of theorem [ thm2 ] ,",
    "@xmath54 is given by @xmath171^{2^{m } } \\oplus \\mathcal{l}_{2^{m}},$ ] where @xmath142 is the lattice code obtained from @xmath99 through the mapping @xmath172 on @xmath85 .",
    "in this section , we study the error performance of the sbwd in decoding the infinite bw lattice . in @xcite , it is shown that for @xmath173 , if there exists @xmath174 such that @xmath175 , where @xmath10 , then the sbwd correctly finds ( or decodes ) the lattice point @xmath176 . in the context of using sbwd in awgn channels , the vector @xmath177 corresponds to @xmath178 , where @xmath173 and @xmath179 .",
    "this implies that the codeword error rate ( cer ) of the sbwd given by @xmath180 is upper bounded as @xmath181 note that @xmath182 is the packing radius of @xmath54 , and hence the above bound is the well known _",
    "sphere upper bound _ ( sub ) @xcite . in @xcite ,",
    "the focus was only on the complexity of the decoder but not on the analysis of the tightness of the sub .",
    "in other words , the possibility of correct decision is not known when @xmath183 .",
    "we study the error performance and show that the decoder is powerful in making correct decisions well beyond the packing radius . without loss of generality ,",
    "we study the error performance when the zero lattice point is transmitted .",
    "we analyze the sbwd algorithm and point out the reason for the improvement in the error performance ( with reference to the sub ) .",
    "we first recall the sbwd algorithm of @xcite .    *",
    "the sequential bw lattice decoding algorithm : *    * function * seqbw@xmath184 , @xmath185 + @xmath186**if * * @xmath187 and @xmath188 + @xmath186 @xmath186 return @xmath189 ; + @xmath186**else * * + @xmath186 @xmath186 @xmath190 ; + @xmath186 @xmath186 @xmath191 ; + @xmath186 @xmath186 @xmath192 ; + @xmath186 @xmath186 @xmath193 ; + @xmath186 @xmath186 return @xmath194 ; + @xmath186**end if * * + * end function *    the above decoder is a successive interference cancellation ( sic ) type decoder which exploits the bw lattice structure as a multi - level code of nested rm codes ( as per construction @xmath8 ) . at each level",
    ", the algorithm uses a variant of the soft - input rm decoder @xcite ( denoted by the function rmdec which is given as algorithm 3 in @xcite ) to decode , and cancel the rm codeword at that level .",
    "therefore , the error performance of the sbwd is fundamentally determined by the error performance of the underlying soft - input rm decoders .",
    "in particular , we have @xmath195 where @xmath196 denotes an error event while decoding @xmath55 .",
    "hence , it is important to compute @xmath197 for each @xmath55 . along that direction",
    ", it is necessary to model the effective binary channel induced for each rm code @xmath55 .",
    "we propose a model for such a binary channel which is accurate for @xmath198 , while for @xmath199 , it neglects the error propagation in the sic decoder algorithm . to decode the rm code at each level",
    ", a hard - decision binary value @xmath200 is obtained from @xmath201 as @xmath202 due to the combination of the round and the modulo operation ( henceforth referred to as the round - modulo operation ) in , the codewords of @xmath55 are passed through a virtual binary channel with the cross - over probability given by , @xmath203 where @xmath204 . since the zero lattice point is transmitted ,",
    "@xmath205 is the all zero codeword for each @xmath55 , and hence the relevant cross - over probability is @xmath206 .",
    "the following theorem shows that @xmath207 can be upper bounded by a jacobi - theta function @xcite .",
    "the cross - over probability @xmath207 induced by the round - modulo operation in is upper bounded as @xmath208 where @xmath209 is the jacobi - theta function given by @xmath210    we first compute @xmath207 , and then propose an upper bound . to assist compute @xmath207 , we compute the probability that @xmath211 ( or @xmath212 ) falls within an interval @xmath213 $ ] centred around an integer @xmath214 , when @xmath215 . since the additive noise is circularly symmetric , it is sufficient to calculate the above probability for either @xmath211 or @xmath212 .",
    "we use @xmath216 to denote either @xmath217 ) or @xmath212 . for the odd integer case",
    ", we have @xmath218 , \\nonumber \\\\ & = & \\sum_{a = -\\infty}^{\\infty } \\left [ q\\left(\\frac{2a + 0.5}{\\sigma/\\sqrt{2}}\\right ) - q\\left(\\frac{2a + 1.5}{\\sigma/\\sqrt{2}}\\right ) \\right],\\end{aligned}\\ ] ] where @xmath219 is the probability density function of @xmath216 , @xmath220 , and @xmath221 is the variance of @xmath216 . for the even integer case , we have @xmath222 , \\nonumber \\\\ &   = & \\sum_{a = -\\infty}^{\\infty } \\left [ q\\left(\\frac{2a - 0.5}{\\sigma/\\sqrt{2}}\\right ) - q\\left(\\frac{2a + 0.5}{\\sigma/\\sqrt{2}}\\right ) \\right].\\end{aligned}\\ ] ] note that @xmath200 is @xmath223 whenever @xmath224 is an odd number .",
    "this can happen when ( _ i _ ) @xmath225 is odd and @xmath226 is even , or ( _ ii _ ) @xmath225 is even and @xmath226 is odd . from and , we can write @xmath227 by dropping the term @xmath228 , we upper bound @xmath207 as @xmath229 \\label{drop_q},\\\\ & \\leq & \\sum_{a = -\\infty}^{\\infty } e^{-\\frac{(2a + 0.5)^{2}}{\\sigma^{2 } } } \\label{apply_chernoff } , \\\\ & = & e^{-\\frac{(0.5)^{2}}{\\sigma^{2 } } } \\sum_{a = -\\infty}^{\\infty } e^{\\frac{-4a^{2 } - 2a}{\\sigma^{2 } } } , \\nonumber\\\\ & = & \\left ( e^{-\\frac{1}{4\\sigma^{2}}}\\right ) \\vartheta \\left(\\frac{i 4}{\\pi \\sigma^{2 } } , \\frac{i } { \\pi \\sigma^{2}}\\right ) , \\nonumber\\end{aligned}\\ ] ] where the bound in comes from dropping the terms of the form @xmath230 in , and the bound in is due to the chernoff bound @xmath231 .",
    "note that the jacobi - theta function can be evaluated at any pair ( @xmath232 , @xmath214 ) . in fig .",
    "[ pc_jacobi ] , the empirical values of @xmath207 are presented along with the bound in for various values of @xmath233 .",
    "we point out that the bound is not tight due to the chernoff - bound on each @xmath234 function .",
    "it is well known that @xmath207 determines the error - performance of a hard decision decoder .",
    "since we have a soft - input decoder , we need to obtain the relevant statistics on the soft inputs .",
    "we now study the soft - input rm decoder used in the sbwd . unlike the codewords of rm code in @xcite , the rm codewords at each level of bw lattice take values over @xmath235 .",
    "the soft - input used for the rm decoder is @xmath236 where @xmath237 . also , unlike the soft metric in @xcite",
    ", @xmath238 is bounded in the interval @xmath239 $ ] .",
    "this is because @xmath240 $ ] , which is a result of the round - modulo operation in .",
    "one could imagine @xmath241 and @xmath242 to be obtained from the received vector in a virtual additive noise channel , wherein each component of the received vector is always within a distance of @xmath5 from either @xmath125 or @xmath223 .",
    "therefore , if @xmath205 denotes a rm codeword at a particular level of the transmitted bw lattice point , then the effective noise @xmath243 as seen by the soft - input rm decoder at that level is of the form , @xmath244 for @xmath245 .",
    "note that @xmath246 has bounded support in the interval @xmath247 $ ] .",
    "for an analogy with respect to the model in @xcite , the code alphabet @xmath248 in @xcite corresponds to the code alphabet @xmath249 in @xcite and the effective noise @xmath243 in @xcite corresponds to the awgn in @xcite . at each level of the bw lattice , the lattice code @xmath250 for any @xmath251",
    "has the minimum squared euclidean distance of @xmath6 . by using the proposition in section iv.a of @xcite ,",
    "the probability of incorrect decision of the soft - input rm decoder at each level of sbwd is upper bounded as shown in the proposition below .",
    "the codeword error rate @xmath197 for each @xmath55 is upper bounded as , @xmath252    it is important to note that the above bound is different from @xmath253 since @xmath254 is gaussian distributed .",
    "we do not have closed form expression on the distribution of either @xmath255 or @xmath256 . in fig .",
    "[ hist ] , we display the histogram of the realizations of @xmath255 for various values of @xmath257 , when the zero rm codeword is the transmitted .",
    "note that for @xmath257 = @xmath125 db , the histogram of @xmath255 has the triangular shape centred around @xmath5 , which implies a very high ( close to 0.5 ) cross - over probability when obtaining the hard decision vector @xmath241 . on the other hand , at lower values of @xmath257 ,",
    "the distribution is skewed towards zero indicating smaller cross - over probability .     when snr = @xmath258 takes the values 0 db , 5 db , 10 db and 25 db.,width=336 ]",
    "in this section , we discuss the use of sbwd to decode the lattice code @xmath142 .",
    "first , we describe a method to transmit the codewords of @xmath142 . for any @xmath259 ,",
    "the transmitted vector is of the form towards the origin to reduce the average transmit energy . ]",
    "@xmath260 where @xmath261 using the scale and the shift operation in , each component of @xmath262 takes value from the regular @xmath1-qam constellation . in particular , the qam constellation is square and non - square when @xmath31 is even and odd , respectively .",
    "when @xmath262 is transmitted , the received vector @xmath263 is given by @xmath264 where @xmath265 is the awgn with @xmath266 . in this section , snr of the channel is defined as @xmath267 , where @xmath268 denotes the average energy of @xmath1-qam constellation . with the inverse operation to as @xmath269 ,",
    "the equivalent awgn channel becomes @xmath270 where @xmath259 and @xmath271 .",
    "we use the sbwd @xcite on to decode the lattice code @xmath142 .",
    "when a codeword of @xmath142 is transmitted , the sbwd decodes to a lattice point in the infinite lattice @xmath54 . in such a decoding method , irrespective of whether the decoded lattice point falls in the code or not , the information bits can be recovered from the decoded rm codewords at every level of sbwd ( as shown in the algorithm in sec .",
    "[ sec4 ] ) .      in this subsection",
    ", we present the cer of the sbwd along with some upper bounds and lower bounds . for the simulation results , we use @xmath272 , where @xmath268 denotes the average energy of the regular @xmath1-qam constellation . in each of fig .",
    "[ ild_m_2]-[ild_m_10 ] , we present ( _ i _ ) the cer of the sbwd , ( _ ii _ ) the sub ( section iv.d , @xcite ) , ( _ iii _ ) the sphere lower bound ( slb ) ( section iv.d , @xcite ) , ( _ iv _ ) the cer in decoding @xmath273 at the first level of the sbwd , and ( _ v _ ) the upper bound on the cer in decoding @xmath273 given by @xmath274 ( obtained through simulation results by empirically generating @xmath243 ) .",
    ".,width=336 ]    .,width=336 ]    .,width=336 ]    .,width=336 ]    .,width=336 ]    from fig .",
    "[ ild_m_2]-[ild_m_10 ] , we make the following observations : the sub is not a tight upper bound on the cer of sbwd . also , @xmath274 is an upper bound on the cer of sbwd , and in particular , it is a tighter upper bound than the sub .",
    "the cer of the soft - input rm decoder for @xmath273 is a tight lower bound on the cer of the sbwd .",
    "this implies that if there is no error at the first level of the decoder , then with high probability , there will be no errors at subsequent levels of the soft - input rm decoder . in summary",
    ", the simulation results highlight that the sbwd is quite powerful in making correct decisions even beyond the packing radius , and the deviation from the sub increases for larger dimensions . as a result sbwd",
    "can be employed to efficiently decode lattice codes of large block lengths with low - complexity .",
    "this behaviour in the error performance of sbwd was not known in the literature .      in this subsection",
    ", we compare the complexity of the sbwd with the bw list decoder @xcite . for a fair comparison , we assume that the list decoder is implemented on a single processor . on a single processor ,",
    "the complexity of the sbwd is @xmath275 , whereas the complexity of the list decoder is @xmath276 , where @xmath277 is the worst case list size at a relative squared distance of @xmath278 ( the relative squared distance is the squared euclidean distance normalized by the dimension of the lattice ) .",
    "we compare the complexity of the two decoders for a codeword error rate of @xmath279 .",
    "in particular , we first approximate the error performance of the sbwd as a bounded distance decoder for some radius @xmath280 , and then compute the complexity of the list decoder with the corresponding value of @xmath280 . in table",
    "[ table_complexity ] , we display the lower bound ( as given in theorem 1.3 in @xcite ) on the complexity of the list decoder to achieve the error performance of sbwd .",
    "the table shows that the list decoder has higher complexity than the sbwd to achieve the same performance . in summary , for single processor implementation , sbwd can be preferred to the list decoder to decode bw lattice codes of large block lengths .",
    "however , for codeword error rates lower than that of sbwd , the list decoder has to be used , preferably on parallel processors . table [ table_complexity ]",
    "also shows the potential of sbwd to decode well beyond the relative squared distance of @xmath281 . for complex dimensions of @xmath282 and @xmath283 ,",
    "the effective radius of sbwd is as high as @xmath284 and @xmath285 , respectively .",
    ".complexity of the list decoder @xcite to achieve the performance of sbwd [ cols=\"^,^,^,^,^,^,^,^,^,^,^\",options=\"header \" , ]     [ table_complexity ]",
    "when a codeword of @xmath142 is transmitted , the sbwd decodes to a lattice point in the infinite lattice @xmath54 . in such a decoding method , irrespective of whether the decoded lattice point falls in the code or not , the information bits can be recovered from the decoded rm codewords at every level of sbwd ( as shown in the algorithm in sec .",
    "[ sec4 ] ) . to further improve the error performance",
    ", we force the sbwd to specifically decode to a codeword in the lattice code , and subsequently recover the information bits , with more reliability .",
    "we refer to such a decoder as the bw lattice code decoder ( bwcd ) .",
    "we use a technique that forces the sbwd to decode to a codeword in the lattice code @xmath142 .",
    "we refer to this technique as the noise trimming technique , which exploits the structure of @xmath142 . from , we know that each component of a codeword is within a rectangular box @xmath286 . in particular , the box @xmath287 shares its edges with @xmath288 $ ] and @xmath289 when @xmath31 is even and odd , respectively . in order to use sbwd , and to decode to a codeword within the code ,",
    "we _ trim _ the in - phase and quadrature components of the received vector ( the algorithm is given below ) to be within a box @xmath290 marginally larger than @xmath287 by length @xmath291 on each dimension .",
    "then , we feed the trimmed received vector to the sbwd and decode the information bits . note that the choice of @xmath291 is crucial to decode a codeword within the code , and to improve the ber with reference to the sbwd",
    "we now provide an algorithm for the trimming method , which works independently on the in - phase and quadrature component of the scalars in @xmath292 $ ] in . in particular",
    ", the algorithm presented in the sequel works on the in - phase and quadrature component of @xmath201 when @xmath31 is even .",
    "extension to the case when @xmath31 is odd is straightforward .",
    "* algorithm for the trimming technique when @xmath31 is even : *    input @xmath293 ( either @xmath211 or @xmath212 ) +    * function * trim@xmath294 , @xmath295 + @xmath186 @xmath296 = @xmath297 + @xmath186 @xmath298 = @xmath216 - @xmath296 + @xmath186 @xmath299 = @xmath296 + @xmath291 + @xmath186 * if * @xmath300 + @xmath186 @xmath186 @xmath301 = @xmath302 + @xmath186 @xmath186 @xmath303 + @xmath186 * else * + @xmath186 @xmath186 @xmath304 + @xmath186 * end if * + @xmath186 return @xmath305 + @xmath296 + * end function *    using bwcd , we have obtained ber for dimensions when @xmath306 , and compared them with the ber of the sbwd .",
    "the plots as shown in fig .",
    "[ ber_ibwd_fbwd ] indicate that bwcd outperforms sbwd by 0.5 db . for the presented results , we have used @xmath307 , which corresponds to the packing radius of @xmath182 .",
    "the above value of @xmath291 was optimized based on the simulation results by comparing the ber for various values of @xmath291 . intuitively , trimming the received vector to fall within the packing radius of a lattice point in the edge of the lattice code forces to sbwd to decode to a lattice point in the edge of the code rather than a lattice point outside the lattice code .",
    "in the first part of this paper , we have introduced a new method of encoding complex bw lattices , which facilitates bit labelling of bw lattice points . as a generalization ,",
    "the proposed technique is applicable to encode all construction @xmath8 complex lattices . in the second part of this paper",
    ", we have used complex bw lattice codes for communication over awgn channels . to encode the code ,",
    "we have used construction @xmath0 , and to decode the code we have used the sbwd .",
    "we have studied the error performance of the sbwd , and have shown that the jacobi - theta functions can characterize the virtual binary channels that arise in the decoding process .",
    "we have also shown that the sbwd is powerful in making correct decisions beyond the packing radius .",
    "subsequently , we have used the sbwd to decode the complex lattice code through the noise trimming technique .",
    "this is the first work that uncovers the potential of sbwd ( in terms of the error performance ) in decoding lattice codes of large - block lengths with low - complexity .",
    "this work can be extended in one of the following ways :    * the sbwd proposed in @xcite uses a soft - input , hard - output rm decoder at each level of construction @xmath8 .",
    "it will be interesting to study the error performance of the lattice decoder with soft - input , soft - output iterative rm decoders .",
    "* we have presented the error performance of the sbwd through simulation results , and hence we now know the sbwd error performance with reference to the sphere lower bound and the sphere upper bound .",
    "a closed form expression on the error performance of the sbwd could be obtained for a better understanding of the decoder performance .",
    "this work was performed within the monash software defined telecommunications lab and supported by the monash professional fellowship 2012 - 2013 and dp 130100103 .                g. e. wall , j. pitman , r. b. potts , ",
    "eric stephen barnes 1924-2000 , \" _ historical records of australian science _ ,",
    "1 , june 2004 , pp .",
    "e. s. barnes , and n. j. a sloane ,  new lattice packings of spheres , \" _ canadian journal of mathematics _ , vol .",
    "35 , 1983 , pp .",
    "117130 .",
    "g. nebe , e. m. rains and n. j. a. sloane ,  a simple construction of the barnes - wall lattices , \" in _ codes , graphs , and systems : a celebration of the life and career of g. david forney , jr . on the occasion of his sixtieth birthday _ , 2002 , pp .",
    "333342 .",
    "e. grigorescu and c. peikert ,  list decoding barnes - wall lattices , \" in the proc . of _",
    "ieee conference on computational complexity 2012 _ , pp .",
    "316325 , porto , portugal .",
    "also available online at arxiv:1112.1994v1 , dec .",
    "2011 .",
    "j. harshan , e. viterbo , and j - c .",
    "belfiore , `` practical decoders for barnes - wall lattice constellations , '' in _ 20th international symposium on mathematical theory of networks and systems2012 _ , melbourne , australia , july 2012 ."
  ],
  "abstract_text": [
    "<S> in this paper , we address the design of high spectral - efficiency barnes - wall ( bw ) lattice codes which are amenable to low - complexity decoding in additive white gaussian noise ( awgn ) channels . </S>",
    "<S> we propose a new method of constructing complex bw lattice codes from linear codes over polynomial rings , and show that the proposed construction provides an explicit method of bit - labelling complex bw lattice codes . to decode the code , </S>",
    "<S> we adapt the low - complexity sequential bw lattice decoder ( sbwd ) recently proposed by micciancio and nicolosi . </S>",
    "<S> first , we study the error performance of sbwd in decoding the infinite lattice , wherein we analyze the noise statistics in the algorithm , and propose a new upper bound on its error performance . </S>",
    "<S> we show that the sbwd is powerful in making correct decisions well beyond the packing radius . </S>",
    "<S> subsequently , we use the sbwd to decode lattice codes through a novel noise - trimming technique . </S>",
    "<S> this is the first work that showcases the error performance of sbwd in decoding bw lattice codes of large block lengths .    </S>",
    "<S> barnes - wall lattices , lattice codes , low - complexity lattice decoders . </S>"
  ]
}