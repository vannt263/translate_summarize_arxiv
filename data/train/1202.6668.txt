{
  "article_text": [
    "plain kolmogorov complexity @xmath2 of a binary string @xmath1 was defined in  @xcite as the minimal length of a program that computes @xmath1 .",
    "( see the preliminaries or  @xcite for the details . )",
    "it was clear from the beginning ( see , e.g. ,  @xcite ) that complexity function is not computable : no algorithm can compute @xmath2 given @xmath1 . in  @xcite a stronger non - uniform version of this result was proven : for every @xmath0 there exists a string @xmath1 of length @xmath0 such that conditional complexity @xmath12 , i.e. , the minimal length of a program that maps @xmath1 to @xmath2 , is at least @xmath13 .",
    "( if complexity function were computable , this conditional complexity would be bounded . )    in section  [ sec : gacs ] we revisit this classical result and improve it a bit by removing the @xmath14 term .",
    "no further improvement is possible because @xmath15 , therefore @xmath16 for all  @xmath1 .",
    "we use a game technique that was developed by andrej muchnik ( see  @xcite ) and turned out to be useful in many cases .",
    "recently elena kalinina ( in her master thesis  @xcite ) used it to provide a proof of gacs result .",
    "we use a more detailed analysis of essentially the same game to get a better bound .    for some @xmath6 ,",
    "a bit string @xmath1 is @xmath17-random if @xmath9 .",
    "note that @xmath18 is the smallest upper bound for @xmath2 .",
    "a variant of plain complexity is prefix - free or self - delimiting complexity , which is defined as the shortest program that produces @xmath1 on a turing machine with binary input tape , i.e. without blanc or terminating symbol .",
    "( see the preliminaries or  @xcite for the details . )",
    "the smallest upper bound for @xmath19 for strings of length @xmath0 is @xmath20 . for some @xmath6 , the string @xmath1 is defined to be @xmath21-random if @xmath22 .",
    "robert solovay  @xcite observed that @xmath21-random strings are also @xmath17-random strings ( for some @xmath23 ) , but not vice versa .",
    "moreover , he showed that some @xmath6 and infinitely many @xmath1 satisfy @xmath7 and @xmath24 he also showed that for @xmath17-random @xmath1 the left - hand side of the equation is upper - bounded by @xmath11 , which is bounded by @xmath25 .    in section  [ sec :",
    "solovay ] we provide a short proof for solovay s result using the improved version of gacs theorem",
    ". then we generalize it by showing that for some @xmath6 and every @xmath0 there are strings @xmath1 of length @xmath0 with @xmath9 and @xmath26 this is very close to the upperbound @xmath27 , which was shown by solovay  @xcite . by the improved version of gacs result",
    ", we can choose @xmath0 such that @xmath28 .",
    "for such @xmath0 we obtain solovay s theorem with the @xmath29 term replaced by a @xmath30 constant .",
    "[ th : main ] there exist some constant @xmath6 such that for every @xmath0 there exists a string @xmath1 of length @xmath0 such that @xmath31 .    to prove this theorem , we first define some game and show a winning strategy for the game .",
    "( the connection between the game and the statement that we want to prove will be explained later . )",
    "game @xmath32 has parameter @xmath0 and is played on a rectangular board divided into cells .",
    "the board has @xmath33 columns and @xmath0 rows numbered @xmath34 ( the bottom row has number @xmath35 , the next one has number @xmath36 and so on , the top row has number @xmath37 ) , see fig .",
    "[ fig : board ] .",
    "initially the board is empty .",
    "two players : white and black , alternate their moves . at each move ,",
    "a player can pass or place a pawn ( of his color ) on the board .",
    "the pawn can not be moved or removed afterwards .",
    "also black may blacken some cell instead .",
    "let us agree that white starts the game ( though it does not matter ) .",
    "the position of the game should satisfy some restrictions ; the player who violates these restrictions , loses the game immediately .",
    "formally the game is infinite , but since the number of ( non - trivial ) moves is a priori bounded , it can be considered as finite , and the winner is determined by the last ( limit ) position on the board .",
    "_ restrictions _ : ( 1 )  each player may put at most @xmath38 pawns in row @xmath39 ( thus the total number of black and white pawns in a row can be at most @xmath40 ) ; ( 2 )  in each column black may blacken at most half of the cells .",
    "we say that a white pawn is _ dead _ if either it is on a blackened cell or has a black pawn in the same column strictly below it .",
    "_ winning rule _ :",
    "black wins if he killed all white pawns , i.e. , if each white pawn is dead in the final position .",
    "[ fig : board ]    for example , if the game ends in the position shown at fig",
    ".  [ compcomp-1.mps ] , the restrictions are not violated ( there are @xmath41 white pawns in row @xmath42 and @xmath43 white pawn in row @xmath36 , as well as @xmath44 black pawn in row @xmath42 and @xmath45 black pawn in row  @xmath35 ) .",
    "black loses because the white pawn in the third column is not dead : it has no black pawn below and the cell is not blackened .",
    "( there is also one living pawn in the fourth column . )",
    "the strategy is quite simple .",
    "white starts by placing a white pawn in an upper row of some column and waits until black kills it , i.e. , blackens the cell or places a black pawn below . in the first case",
    "white puts her pawn one row down and waits again .",
    "since black has no right to make all cells in a column black ( at most half may be blackened ) , at some point he will be forced to place a black pawn below the white pawn in this column .",
    "after that white switches to some other column .",
    "( the ordering of columns is not important ; we may assume that white moves from left to right . )",
    "note that when white switches to a next column , it may happen that there is a black pawn in this column or some cells are already blackened . if there is already a black pawn , white switches again to the next column ; if some cell is blackened , white puts her pawn in the topmost white ( non - blackened ) cell .",
    "this strategy allows white to win .",
    "indeed , black can not place his pawns in all the columns due to the restrictions ( the total number of his pawns is @xmath46 , which is less than the number of columns ) .",
    "white also can not violate the restriction for the number of her pawns on some row @xmath39 : all dead pawns have a black pawns strictly below them , so the number of them on row @xmath39 is @xmath47 , hence white can put an additional pawn .",
    "in fact we may even allow black to blacken all the cells except one in each column , and white will still win , but this is not needed ( and the @xmath48 restriction will be convenient later ) .",
    "let us show that for each @xmath0 there exists a string @xmath1 of length @xmath0 such that @xmath49 .",
    "note that here @xmath50 is used instead of @xmath2 ; the difference between these two numbers is @xmath51 since @xmath0 can be described by @xmath52 bits , so the difference between the complexities of these two numbers is @xmath53 .    consider the following strategy for black ( assuming that the columns of the table are indexed by strings of length @xmath0 ) :    * black blackens the cell in column @xmath1 and row @xmath39 as soon as he discovers that @xmath54 .",
    "( the constant @xmath36 guarantees that less than half of the cells will be blackened . )",
    "note that kolmogorov complexity is an upper semicomputable function , and black approximates it from above , so more and more cells are blackened . * black puts a black pawn in a cell @xmath55 when he finds a program of length @xmath39 that produces @xmath1 with input @xmath0 ( this implies that @xmath56 ) .",
    "note that there are at most @xmath38 programs of length @xmath39 , so black does not violate the restriction for the number of pawns on any row @xmath39 .",
    "let white play against this strategy ( using the strategy described above ) .",
    "since the strategy is computable , the behavior of white is also computable .",
    "one can construct a decompressor @xmath57 for the strings of length @xmath0 as follows : each time white puts a pawn in a cell @xmath55 , a program of length @xmath39 is assigned to @xmath1 . by white s restriction ,",
    "no more than @xmath38 programs need to be assigned . by universality ,",
    "a white pawn on cell @xmath55 implies that @xmath58 .",
    "if white s pawn is alive in column @xmath1 , there is no black pawn below , so @xmath59 , and therefore @xmath60 .",
    "moreover , for a winning pawn , the cell @xmath55 is not blackened , so @xmath61 .",
    "therefore , @xmath62 .",
    "* remark * : the construction also guarantees that @xmath63 for that @xmath1 .",
    "( here the factor @xmath64 can be replaced by any @xmath65 if we change the rules of the game accordingly . ) indeed , according to white s strategy , he always plays in the highest non - black cell of some column , and at most half of the cells in a column can be blackened , therefore no white pawns appear in the lower half of the board .",
    "now we need to get rid of the condition @xmath0 and show that for every @xmath0 there is some @xmath1 such that @xmath66 .",
    "imagine that white and black play simultaneously all the games @xmath32 .",
    "black blackens the cell @xmath55 in game @xmath67 when he discovers that @xmath68 , as he did before , and puts a black pawn in a cell @xmath55 when he discovers an _ unconditional _ program of length @xmath39 for @xmath1 . if black uses this strategy , he satisfies the stronger restriction : the total number of pawns in row @xmath39 _ on all boards _ is bounded by @xmath38 .",
    "assume that white uses the described strategy on each board .",
    "what can be said about the total number of white pawns in row @xmath39 ?",
    "the dead pawns have black pawns strictly below them and hence the total number of them does not exceed @xmath69 . on the other hand , there is at most one live white pawn on each board .",
    "we know also that in @xmath32 white pawns never appear below row @xmath70 , so the number of live white pawns does not exceed @xmath71 .",
    "therefore we have @xmath72 white pawns on the @xmath39-th row in total .    for each @xmath0",
    "there is a cell @xmath55 in @xmath32 where white wins in @xmath32 .",
    "hence , @xmath73 ( because of property just mentioned and the computability of white s behavior ) , @xmath74 and @xmath75 ( by construction of black s strategies and the winning condition ) . theorem  [ th : main ] is proven .",
    "[ th : prefix - max ] there exist some constant @xmath6 such that for every @xmath0 there exists a string @xmath1 of length @xmath0 such that @xmath76 and @xmath77 .",
    "this also implies that @xmath78 .",
    "the proof of @xmath79 goes in the same way .",
    "black places a pawn in cell @xmath80 if some program of length @xmath39 for a prefix - free ( unconditional ) machine computes @xmath1 ( and hence @xmath81 ) ; white uses the same strategy as described above .",
    "the sum of @xmath82 for all black pawns is less than @xmath36 ( kraft - inequality ) ; some white pawns are dead , i.e. , strictly above black ones , and for each column the sum of @xmath83 where @xmath84 is the row number , does not exceed @xmath85 .",
    "hence the corresponding sum for all dead white pawns is less than @xmath36 ; for the rest the sum is bounded by @xmath86 , so the total sum is bounded by a constant , and we conclude that for @xmath1 in the winning column the row number is @xmath87 , and this cell is not blackened .",
    "in this section we compare two measures of non - randomness .",
    "let @xmath1 be a string of length @xmath0 ; we know that @xmath88 , and the difference @xmath89 measures how `` nonrandom '' @xmath1 is .",
    "let us call it @xmath17-deficiency of @xmath1 . on the other hand , @xmath90 ,",
    "so @xmath91 also measures `` nonrandomness '' in some other way ; we call this quantity @xmath21-deficiency of  @xmath1 .",
    "the following proposition means that @xmath21-random strings ( for which @xmath21-deficiency is small ; they are also called `` chaitin random '' ) are always @xmath17-random ( @xmath17-deficiency is small ; such strings are also called `` kolmogorov random '' ) .",
    "we use a result of levin : for every string @xmath94 @xmath95 and , on the other hand , for any positive or negative integer number @xmath6 : @xmath96 implies @xmath97 maps numbers at distance @xmath6 to numbers at distance @xmath98 , hence , the fixed point @xmath2 must be unique within an @xmath30 constant . furthermore , for any @xmath39 , the fixed point must be within distance @xmath99 from @xmath39 , hence @xmath100 . ] .",
    "r.  solovay showed that the reverse statement is not always true : a @xmath17-random string may be not @xmath21-random .",
    "however , as the following result shows , the @xmath21-deficiency still can be bounded for @xmath17-random strings :          to prove proposition  [ prop : solovayoptimal ] , notice that @xmath111 with @xmath112-precision . by additivity",
    "we have : @xmath113 . putting these observations together ,",
    "we get ( with @xmath112-precision ) @xmath114 observe that @xmath115 , hence the @xmath21-deficiency is bounded by @xmath116 .        by corollary ,",
    "infinitely many @xmath17-random strings have @xmath21-deficiency @xmath120 .",
    "indeed , for @xmath0 such that @xmath28 , we have @xmath121 , and hence , a slightly stronger statement than proved by solovay  @xcite is obtained .",
    "first we choose @xmath0 , the length of string @xmath1 .",
    "it is chosen in such a way that @xmath124 and @xmath125 ( theorem  [ th : prefix - max ] ) .",
    "( so the bound of proposition  [ prop : solovayoptimal ] is not an obstacle . )",
    "we know already ( see equation  [ eq : gap ] ) that for a string @xmath1 with @xmath17-deficiency @xmath6 the value of @xmath21-deficiency is @xmath112-close to @xmath126 .",
    "this means that adding @xmath127 in the condition should decrease the complexity , so let us include @xmath127 in @xmath1 somehow .",
    "we also have to guarantee maximal @xmath17-complexity of @xmath1 .",
    "this motivates the following choice :    * choose @xmath128 of length @xmath129 such that @xmath130 .",
    "note that this implies @xmath131 , since the length of @xmath128 is determined by the condition ; * let @xmath132 , the concatenation of @xmath133 ( in binary ) with @xmath128 .",
    "note that @xmath134 has at most @xmath25 bits for every @xmath0 , and by choice of @xmath0 has at least @xmath135 bits , hence @xmath136 .",
    "* knowing @xmath0 , we can split @xmath1 in two parts @xmath140 and @xmath128 .",
    "hence , @xmath141 , and this equals @xmath142 , i.e. , @xmath129 by choice of @xmath128 . * to compute @xmath143 , we use additivity : @xmath144 by choice of @xmath0 , we have @xmath145 , and the last term simplifies to @xmath146 , and this equals @xmath147 by choice of  @xmath128 . hence @xmath148 .",
    "* remark 1 : * one can also ask how many strings exist that satisfy the conditions of corollary [ cor : solovay2 ] . by proposition",
    "[ prop : solovayoptimal ] , the length @xmath0 of such a string must satisfy @xmath149 . by theorem  [ th : prefix - max ] , there is at least one such an @xmath0 for every length of @xmath0 in binary .",
    "hence such @xmath0 , can be found within exponential intervals .",
    "* remark 2 : * one can ask for these @xmath0 , how many strings @xmath1 of length @xmath0 satisfy the conditions of corollary [ cor : solovay2 ] . by a theorem of chaitin @xcite",
    ", there are at least @xmath150 strings with @xmath21-deficiency @xmath151 , hence we can have at most @xmath152 such strings .",
    "it turns out that indeed at least a fraction @xmath153 of them satisfy the conditions of corollary [ cor : solovay2 ] . to show this , note that in the proof theorem [ th : solovay2alln ] , every different @xmath128 of length @xmath154 leads to the construction of a different @xmath1 .",
    "for such @xmath128 we essentially need @xmath155 . _ in the proof above , in order to obtain a large value @xmath126 , we incorporated @xmath127 in a direct way ( as @xmath156 ) in @xmath1 . to show that @xmath157 is large we essentially used that the length of @xmath156 equals @xmath11 . for general @xmath0",
    ", this trick does not work anymore , but we can use a shortest program for @xmath127 given @xmath0 ( on a plain machine ) . for every @xmath0 we can construct @xmath1 as follows :    * let @xmath158 be a shortest program that computes @xmath127 from @xmath0 on a _ plain _ machine ( if there are several shortest programs , we choose the one with shortest running time ) .",
    "note that @xmath159 ( remind that by adding some fixed instructions , a program can print itself , and that a shortest program is always incompressible , thus up to @xmath30 constants : @xmath160 ) , by levin s result ( conditional version ) , the last term also equals @xmath161 ; * let @xmath128 have length @xmath162 , such that @xmath163 .",
    "note that this implies @xmath164 , ( since the length of @xmath128 is determined by the condition ) .",
    "* we define @xmath1 as the concatenation @xmath165 .",
    "we show that @xmath166 and that the @xmath21-deficiency is at least @xmath167 . to show that this implies the theorem",
    ", we need that @xmath168 which is for @xmath169 the conditioned version of lemma [ lem : plainprefixhelp ] : @xmath170 following the same structure as the proof above , it remains to show that @xmath171 and @xmath138 ( the latter equality implies @xmath139 ) ; all the equalities here and below are up to @xmath30 additive term .",
    "* knowing @xmath172 , we can split @xmath1 in two parts @xmath158 and @xmath128 .",
    "hence , @xmath173 . given @xmath174 we can search for a program of length @xmath172 that on input @xmath0 outputs @xmath127 ; the one with shortest computation time is @xmath158 .",
    "hence , @xmath175 , i.e. , @xmath162 by choice of @xmath128 , and therefore @xmath176 .",
    "* to compute @xmath143 , we use additivity : @xmath177 by choice of @xmath158 we have @xmath178 , and hence by levin s result @xmath179 .",
    "the last term is @xmath180 which equals @xmath181 by choice of  @xmath128 .",
    "hence , @xmath182 .      note that @xmath184 .",
    "indeed , any program for a plain machine can be considered as a program for a prefix - free machine conditional to it s length .",
    "hence , we can transform a plain program @xmath185 to a prefix - free program by adding a description of @xmath186 of length @xmath187 to @xmath185 .",
    "hence it remains to show @xmath188 .",
    "solovay  @xcite showed that @xmath189 hence , @xmath190",
    "zvonkin , l.a .",
    "levin , _ the complexity of finite objects and the development of the concepts of information and randomness by means of the theory of algorithms _ , _ russian math . surveys _ , * 25 * , issue  6(156):83124 , 1970 ."
  ],
  "abstract_text": [
    "<S> peter gacs showed  @xcite that for every @xmath0 there exists a bit string @xmath1 of length @xmath0 whose plain complexity @xmath2 has almost maximal conditional complexity relative to @xmath1 , i.e. , @xmath3 . here @xmath4 etc . </S>",
    "<S> following elena kalinina  @xcite , we provide a game - theoretic proof of this result ; modifying her argument , we get a better ( and tight ) bound @xmath5 . </S>",
    "<S> we also show the same bound for prefix - free complexity .    </S>",
    "<S> robert solovay s showed  @xcite that infinitely many strings @xmath1 have maximal plain complexity but not maximal prefix - free complexity ( among the strings of the same length ) ; i.e. for some @xmath6 : @xmath7 and @xmath8 . using the result above </S>",
    "<S> , we provide a short proof of solovay s result </S>",
    "<S> . we also generalize it by showing that for some @xmath6 and for all @xmath0 there are strings @xmath1 of length @xmath0 with @xmath9 , and @xmath10 . </S>",
    "<S> this is very close to the upperbound @xmath11 proved by solovay . </S>"
  ]
}