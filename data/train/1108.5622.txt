{
  "article_text": [
    "in safety - critical systems implement complex algorithms and feedback laws that control the interaction of physical devices with their environments .",
    "examples of such systems are abundant in aerospace , automotive , and medical applications .",
    "the range of theoretical and practical issues that arise in analysis , design , and implementation of safety - critical software systems is extensive , see , e.g. , @xcite , @xcite , and @xcite .",
    "while safety - critical software must satisfy various resource allocation , timing , scheduling , and fault tolerance constraints , the foremost requirement is that it must be free of run - time errors .",
    "formal verification methods are model - based techniques @xcite , @xcite , @xcite for proving or disproving that a mathematical model of a software ( or hardware ) satisfies a given _ specification , _",
    "i.e. , a mathematical expression of a desired behavior .",
    "the approach adopted in this paper too , falls under this category .",
    "herein , we briefly review _ model checking _ and _ abstract _ _ interpretation_.    [ [ model - checking ] ] model checking + + + + + + + + + + + + + +    in _ model checking _",
    "@xcite the system is modeled as a finite state transition system and the specifications are expressed in some form of logic formulae , e.g. , temporal or propositional logic .",
    "the verification problem then reduces to a graph search , and symbolic algorithms are used to perform an exhaustive exploration of all possible states .",
    "model checking has proven to be a powerful technique for verification of circuits @xcite , security and communication protocols @xcite , @xcite and stochastic processes @xcite . nevertheless , when the program has non - integer variables , or when the state space is continuous , model checking is not directly applicable . in such cases ,",
    "combinations of various abstraction techniques and model checking have been proposed @xcite ; scalability , however , remains a challenge .",
    "[ [ abstract - interpretation ] ] abstract interpretation + + + + + + + + + + + + + + + + + + + + + + +    is a theory for formal approximation of the _ operational semantics _ of computer programs in a systematic way @xcite .",
    "construction of abstract models involves abstraction of domains****typically in the form of a combination of sign , interval , polyhedral , and congruence abstractions of sets of data****and functions .",
    "a system of fixed - point equations is then generated by symbolic forward / backward executions of the abstract model .",
    "an iterative equation solving procedure , e.g. , newton s method , is used for solving the nonlinear system of equations , the solution of which results in an inductive invariant assertion , which is then used for checking the specifications . in practice , to guarantee finite convergence of the iterates , narrowing ( outer approximation ) operators are constructed to estimate the solution , followed by widening ( inner approximation ) to improve the estimate @xcite .",
    "this compromise can be a source of conservatism in analysis @xcite .",
    "nevertheless , these methods have been used in practice for verification of limited properties of embedded software of commercial aircraft @xcite .",
    "alternative formal methods can be found in the computer science literature mostly under _ deductive verification _",
    "@xcite , _ type inference",
    "_ @xcite _ _ , _ _ and _ data flow analysis _ @xcite .",
    "these methods share extensive similarities in that a notion of program abstraction and symbolic execution or constraint propagation is present in all of them .",
    "further details and discussions of the methodologies can be found in @xcite , and @xcite .      while software analysis has been the subject of an extensive body of research in computer science , treatment of the topic in the control systems community",
    "has been less systematic .",
    "the relevant results in the systems and control literature can be found in the field of hybrid systems @xcite .",
    "much of the available techniques for safety verification of hybrid systems are explicitly or implicitly based on computation of the reachable sets , either exactly or approximately .",
    "these include but are not limited to techniques based on quantifier elimination @xcite , ellipsoidal calculus @xcite , and mathematical programming @xcite .",
    "alternative approaches aim at establishing properties of hybrid systems through barrier certificates @xcite , numerical computation of lyapunov functions @xcite , or by combined use of bisimulation mechanisms and lyapunov techniques @xcite .    inspired by the concept of lyapunov functions in stability analysis of nonlinear dynamical systems @xcite , in this paper we propose lyapunov invariants for analysis of computer programs .",
    "while lyapunov functions and similar concepts have been used in verification of stability or temporal properties of system level descriptions of hybrid systems @xcite , @xcite , @xcite , to the best of our knowledge , this paper is the first to present a systematic framework based on lyapunov invariance and convex optimization for verification of a broad range of code - level specifications for computer programs .",
    "accordingly , it is in the systematic integration of new ideas and some well - known tools within a unified software analysis framework that we see the main contribution of our work , and not in carrying through the proofs of the underlying theorems and propositions .",
    "the introduction and development of such framework provides an opportunity for the field of _ control _ to systematically address a problem of great practical significance and interest to both computer science and engineering communities .",
    "the framework can be summarized as follows :    1 .",
    "dynamical system interpretation and modeling ( section [ modeling ] ) .",
    "we introduce generic dynamical system representations of programs , along with specific modeling languages which include mixed - integer linear models ( milm ) , graph models , and mil - over - graph hybrid models ( mil - ghm ) .",
    "lyapunov invariants as behavior certificates for computer programs ( section [ chapter : lyapunovinvs ] ) .",
    "analogous to a lyapunov function , a lyapunov invariant is a real - valued function of the program variables , and satisfies a _ difference inequality _  along the trace of the program .",
    "it is shown that such functions can be formulated for verification of various specifications .",
    "3 .   a computational procedure for finding the lyapunov invariants ( section [ chapter : computation ] ) . the procedure is standard and constitutes  these steps : ( i ) restricting the search space to a linear subspace .",
    "( ii ) using convex relaxation techniques to formulate the search problem as a convex optimization problem , e.g. , a linear program ( lp ) @xcite , semidefinite program ( sdp ) @xcite , or a sum - of - squares ( sos ) program @xcite . (",
    "iii ) using convex optimization software for numerical computation of the certificates.@xmath0",
    "we interpret computer programs as discrete - time dynamical systems and introduce generic models that formalize this interpretation .",
    "we then introduce milms , graph models , and mil - ghms as structured cases of the generic models .",
    "the specific modeling languages are used for computational purposes.@xmath2        we will consider generic models defined by a finite state space set @xmath3 with selected subsets @xmath4 of initial states , and @xmath5 of terminal states , and by a set - valued state transition function @xmath6 , such that @xmath7 we denote such dynamical systems by @xmath8    [ concreterepdef]the dynamical system @xmath9 is a @xmath10-representation of a computer program @xmath11 if the set of all sequences that can be generated by @xmath12 is equal to the set of all sequences @xmath13 of elements from @xmath14 satisfying@xmath15 the uncertainty in @xmath16 allows for dependence of the program on different initial conditions , and the uncertainty in @xmath17 models  dependence on parameters , as well as the ability to respond to real - time inputs .",
    "[ integerdiv - ex]*integer division * ( adopted from @xcite ) :  the functionality of program 1 is to compute the result of the integer division of @xmath18 ( dividend ) by @xmath19 ( divisor ) .",
    "a @xmath10-representation of the program is displayed alongside .",
    "note that if @xmath20 and @xmath21 then the program never exits the while  loop and the value of @xmath22 keeps increasing , eventually leading to either an overflow or an erroneous answer .",
    "the program terminates  if @xmath18 and @xmath19 are positive .    @xmath23{cl}% \\begin{tabular } [ c]{|l|}\\hline $ % \\begin{array } [ c]{l}% \\mathrm{int~integerdivision~(~int~dd , int~dr~)}\\\\ \\vspace*{-0.46in}\\\\ \\mathrm{\\{int~q=\\{0\\};~int~r=\\{dd\\};}\\\\ \\vspace*{-0.46in}\\\\ \\mathrm{{while}\\text { } { ( r>=dr)}}\\\\ \\vspace*{-0.46in}\\\\ \\mathrm{{{{\\{\\hspace{0.13in}q = q+1;}}}}\\\\ \\vspace*{-0.46in}\\\\ \\mathrm{{{\\hspace{0.24in}r = r - dr;\\}}}}\\\\ \\vspace*{-0.46in}\\\\ \\mathrm{return~r;\\}}% \\end{array } $ \\\\\\hline \\end{tabular } & \\hspace*{-0.05in}% \\begin{tabular } [ c]{|l|}\\hline $ % \\begin{array } [ c]{l}% \\underline{\\mathbb{z}}=\\mathbb{z\\cap}\\left [   -32768,32767\\right ] \\\\",
    "\\vspace*{-0.46in}\\\\ x=\\underline{\\mathbb{z}}^{4}\\\\ \\vspace*{-0.46in}\\\\ x_{0}=\\left\\ {   ( \\mathrm{dd},\\mathrm{dr},\\mathrm{q},\\mathrm{r})\\in x~|~\\mathrm{q}=0,\\text { } \\mathrm{r}=\\mathrm{dd}\\right\\ } \\\\ \\vspace*{-0.46in}\\\\ x_{\\infty}=\\left\\ {   ( \\mathrm{dd},\\mathrm{dr},\\mathrm{q},\\mathrm{r})\\in x~|~\\mathrm{r}<\\mathrm{dr}\\right\\ }",
    "\\\\ \\vspace*{-0.35in}\\\\ f:(\\mathrm{dd},\\mathrm{dr},\\mathrm{q},\\mathrm{r})\\mapsto\\left\\ { \\begin{array } [ c]{l}% \\vspace*{-0.44in}\\\\ ( \\mathrm{dd},\\mathrm{dr},\\mathrm{q}+\\mathrm{1},\\mathrm{r}-\\mathrm{dr}),\\\\ \\vspace*{-0.44in}\\\\ ( \\mathrm{dd},\\mathrm{dr},\\mathrm{q},\\mathrm{r } ) , \\end{array } \\right .",
    "\\begin{array } [ c]{l}% \\vspace*{-0.44in}\\\\ ( \\mathrm{dd},\\mathrm{dr},\\mathrm{q},\\mathrm{r})\\in x\\backslash x_{\\infty}\\\\ \\vspace*{-0.44in}\\\\ ( \\mathrm{dd},\\mathrm{dr},\\mathrm{q},\\mathrm{r})\\in x_{\\infty}% \\end{array } \\end{array } $ \\\\\\hline \\end{tabular } \\end{array } \\\\",
    "\\text{{program 1 : the integer division program ( left ) and its dynamical system model ( right)\\vspace*{-0.2in}}}%\\end{gathered}\\ ] ]      in a @xmath10-representation , the elements of the state space @xmath3 belong to a finite subset of the set of rational numbers that can be represented by a fixed number of bits in a specific arithmetic framework , e.g. , fixed - point or floating - point arithmetic . when the elements of @xmath3 are non - integers , due to the quantization effects , the set - valued map @xmath17 often defines very complicated dependencies between the elements of @xmath14 even for simple programs involving only elementary arithmetic operations .",
    "an abstract model over - approximates the behavior set in the interest of tractability .",
    "the drawbacks are conservatism of the analysis and ( potentially ) undecidability .",
    "nevertheless , abstractions in the form of formal over - approximations make it possible to formulate computationally tractable , sufficient conditions for a verification problem that would otherwise be intractable .",
    "[ def : abst]given a program @xmath12 and its @xmath24-representation @xmath9 , we say that @xmath25 is an @xmath26-representation , i.e. , an _ abstraction _ of @xmath12 , if @xmath27 , @xmath28 , and @xmath29  for all @xmath30 and the following condition holds:@xmath31    thus , every trajectory of the actual program is also a trajectory of the abstract model .",
    "the definition of @xmath32 is slightly more subtle . for proving finite - time termination ( ftt ) , we need to be able to infer that if all the trajectories of @xmath33 eventually enter @xmath34 then all trajectories of @xmath35 will eventually enter @xmath36 it is tempting to require that @xmath37 , however , this may not be possible as @xmath38 is often a discrete set , while @xmath32 is dense in the domain of real numbers .",
    "the definition of @xmath32 as in ( [ terminalabstract ] ) resolves this issue .",
    "construction of @xmath39 from @xmath9 involves abstraction of each of the elements @xmath40 in a way that is consistent with definition [ def : abst ] .",
    "abstraction of the state space @xmath3 often involves replacing the domain of _ floats _ or integers or a combination of these by the domain of real numbers .",
    "abstraction of @xmath41 or @xmath38 often involves a combination of domain abstractions and abstraction of functions that define these sets .",
    "semialgebraic set - valued abstractions of some commonly used nonlinearities is presented in appendix i. also , abstractions of fixed - point and floating point arithmetic operations based on ideas from @xcite and @xcite are discussed in appendix i. a case study in application of these methods to analysis of a program with floating - point operations is presented in section [ sec : casestudy2 ] .",
    "specific modeling languages are particularly useful for automating the proof process in a computational framework . here , three specific modeling languages are proposed : _ mixed - integer linear models ( milm ) , _ _ graph models _ , and _ mixed - integer linear over graph hybrid models ( mil - ghm ) .",
    "_      proposing milms for software modeling and analysis is motivated by the observation that by imposing linear equality constraints on boolean and continuous variables over a quasi - hypercube , one can obtain a relatively compact representation of arbitrary piecewise affine functions defined over compact polytopic subsets of euclidean spaces ( proposition [ milm - prop ] ) .",
    "the earliest reference to the statement of universality of milms appears to be @xcite , in which a constructive proof is given for the one - dimensional case . a constructive proof for the general case is given in appendix ii .",
    "[ milm - prop]*universality of mixed - integer linear models .",
    "* let @xmath42 be a piecewise affine map with a closed graph , defined on a compact state space @xmath43   ^{n},$ ] consisting of a finite union of compact polytopes .",
    "that is:@xmath44 where , each @xmath45 is a compact polytopic set .",
    "then , @xmath17 can be specified precisely , by imposing linear equality constraints on a finite number of binary and continuous variables ranging over compact intervals .",
    "specifically , there exist matrices @xmath46 and @xmath47 such that the following two sets are equal:@xmath48{cccc}% \\hspace*{-0.04in}\\vspace*{0.04in}x\\hspace*{-0.02 in } & \\hspace*{-0.02in}% w\\hspace*{-0.02 in } & \\hspace*{-0.02in}v\\hspace*{-0.02 in } & \\hspace * { -0.02in}1\\hspace*{-0.04in}% \\end{array } ] ^{^{t}}=y,\\text { } h[% \\begin{array } [ c]{cccc}% \\hspace*{-0.04in}\\vspace*{0.04in}x\\hspace*{-0.02 in } & \\hspace*{-0.02in}% w\\hspace*{-0.02 in } & \\hspace*{-0.02in}v\\hspace*{-0.02 in } & \\hspace * { -0.02in}1\\hspace*{-0.04in}% \\end{array } ] ^{^{t}}=0,\\text { } \\left (   w , v\\right )   \\in\\left [   -1,1\\right ]   ^{n_{w}}% \\times\\left\\ {   -1,1\\right\\ }   ^{n_{v}}\\}\\end{aligned}\\ ] ]    mixed logical dynamical systems ( mlds ) with similar structure were considered in @xcite for analysis of a class of hybrid systems .",
    "the main contribution here is in the application of the model to software analysis . a mil model of a computer program",
    "is defined via the following elements :    1 .",
    "the state space @xmath49   ^{n}$ ] .",
    "2 .   letting @xmath50 the state transition function @xmath6  is defined by two matrices @xmath51  and @xmath52  of dimensions @xmath53-by-@xmath54  and @xmath55-by-@xmath54  respectively , according to : @xmath56{cccc}% \\hspace*{-0.04in}\\vspace*{0.04in}x\\hspace*{-0.02 in } & \\hspace*{-0.02in}% w\\hspace*{-0.02 in } & \\hspace*{-0.02in}v\\hspace*{-0.02 in } & \\hspace * { -0.02in}1\\hspace*{-0.04in}% \\end{array } ] ^{^{t}}~|~~h[% \\begin{array } [ c]{cccc}% \\hspace*{-0.04in}\\vspace*{0.04in}x\\hspace*{-0.02 in } & \\hspace*{-0.02in}% w\\hspace*{-0.02 in } & \\hspace*{-0.02in}v\\hspace*{-0.02 in } & \\hspace * { -0.02in}1\\hspace*{-0.04in}% \\end{array } ] ^{^{t}}=0,\\text { } \\left (   w , v\\right )   \\in\\left [   -1,1\\right ]   ^{n_{w}}% \\times\\left\\ {   -1,1\\right\\ }   ^{n_{v}}\\right\\ }   .\\vspace*{-0.05in}\\label{milm1}%\\ ] ] 3 .",
    "the set of initial conditions is defined via either of the following : 1 .",
    "if @xmath41  is finite with a small cardinality , then it can be conveniently specified by extension .",
    "we will see in section [ chapter : computation ] that per each element of @xmath57  one constraint needs to be included in the set of constraints of the optimization problem associated with the verification task .",
    "if @xmath41  is not finite , or @xmath58  is too large , an abstraction of @xmath41  can be specified by a matrix @xmath59  which defines a union of compact polytopes in the following way:@xmath60{cccc}% \\hspace*{-0.04in}\\vspace*{0.04in}x\\hspace*{-0.02 in } & \\hspace*{-0.02in}% w\\hspace*{-0.02 in } & \\hspace*{-0.02in}v\\hspace*{-0.02 in } & \\hspace * { -0.02in}1\\hspace*{-0.04in}% \\end{array } ] ^{^{t}}=0,~\\left (   w , v\\right )   \\in\\left [   -1,1\\right ]   ^{n_{w}}\\times\\left\\ { -1,1\\right\\ }   ^{n_{v}}\\}.\\vspace*{-0.1in}\\label{milm2}%\\ ] ] 4 .",
    "the set of terminal states @xmath38  is defined by@xmath61{cccc}% \\hspace*{-0.04in}\\vspace*{0.04in}x\\hspace*{-0.02 in } & \\hspace*{-0.02in}% w\\hspace*{-0.02 in } & \\hspace*{-0.02in}v\\hspace*{-0.02 in } & \\hspace * { -0.02in}1\\hspace*{-0.04in}% \\end{array } ] ^{^{t}}\\neq0,~\\forall w\\in\\left [   -1,1\\right ]   ^{n_{w}},~\\forall v\\in\\left\\ { -1,1\\right\\ }   ^{n_{v}}\\}.\\vspace*{-0.1in}\\label{milm3}%\\ ] ]    therefore , @xmath9 is well defined .",
    "a compact description of a milm of a program is either of the form @xmath62 or of the form @xmath63 .",
    "the milms can represent a broad range of computer programs of interest in control applications , including but not limited to control programs of gain scheduled linear systems in embedded applications .",
    "in addition , generalization of the model to programs with piecewise affine dynamics subject to quadratic constraints is straightforward .",
    "a milm of an abstraction of the integerdivision program ( program 1 : section [ sec : genrep])@xmath64 with all the integer variables replaced with real variables , is given by @xmath65 where@xmath66@xmath67{lll}% h_{0}= & h= & f=\\\\ \\left [ \\begin{array } [ c]{rrrrrrrr}% \\vspace*{-0.42 in } &   &   &   &   &   &   & \\\\ 1 & 0 & 0 & -1 & 0 & 0 & 0 & 0\\vspace*{-0.12in}\\\\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\vspace*{-0.12in}\\\\ 0 & -2 & 0 & 0 & 0 & 1 & 0 & 1\\vspace*{-0.12in}\\\\ -2 & 0 & 0 & 0 & 0 & 0 & 1 & 1\\vspace*{-0.07in}% \\end{array } \\right ]   , & \\left [   \\hspace*{-0.05in}% \\begin{array } [ c]{rrrrrrrr}% \\vspace*{-0.42 in } &   &   &   &   &   &   & \\\\ 0 & 2 & 0 & -2 & 1 & 0 & 0 & 1\\vspace*{-0.12in}\\\\ 0 & -2 & 0 & 0 & 0 & 1 & 0 & 1\\vspace*{-0.12in}\\\\ -2 & 0 & 0 & 0 & 0 & 0 & 1 & 1\\vspace*{-0.07in}% \\end{array } \\hspace*{-0.05in}\\right ]   , & \\left [ \\begin{array } [ c]{rrrrrrrr}% \\vspace*{-0.42 in } &   &   &   &   &   &   & \\\\ 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\vspace*{-0.12in}\\\\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\vspace*{-0.12in}\\\\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1/m\\vspace*{-0.12in}\\\\ 0 & -1 & 0 & 1 & 0 & 0 & 0 & 0\\vspace*{-0.07in}% \\end{array } \\right ] \\end{array}\\ ] ] here , @xmath68 is a scaling parameter used for bringing all the variables within the interval @xmath69",
    ".\\vspace*{-0.05in}$ ]      practical considerations such as universality and strong resemblance to the natural flow of computer code render graph models an attractive and convenient model for software analysis . before we proceed , for convenience , we introduce the following notation : @xmath70 denotes the projection operator defined as @xmath71 for all @xmath72 and all @xmath73    a graph model is defined on a directed graph @xmath74 with the following elements :    1 .",
    "a set of nodes @xmath75 these can be thought of as line numbers or code locations . nodes @xmath76 and @xmath77 are starting and terminal nodes , respectively .",
    "the only possible transition from node @xmath77 is the identity transition to node @xmath78 2 .",
    "a set of edges @xmath79 where the _ outgoing set _",
    "@xmath80 is the set of all nodes to which transition from node @xmath81 is possible in one step .",
    "definition of the _ incoming set _",
    "@xmath82 is analogous .",
    "the third element in the triplet @xmath83 is the index for the @xmath84th edge between @xmath81 and @xmath85 and @xmath86 3 .",
    "a set of program variables @xmath87 @xmath88 given @xmath89 and @xmath53 , the state space of a graph model is @xmath90 .",
    "the state @xmath91 of a graph model has therefore , two components : the discrete component @xmath92 and the continuous component @xmath93 .",
    "4 .   a set of _ transition _ labels",
    "@xmath94 assigned to every edge @xmath95 , where @xmath96 maps @xmath97 to the set @xmath98 where @xmath99   ^{n_{w}}\\times\\left\\ {   -1,1\\right\\ } ^{n_{v}},$ ] and @xmath100 is a polynomial function and @xmath101 is a semialgebraic set@xmath102 if @xmath94 is a deterministic map , we drop @xmath101 and define @xmath103 .",
    "a set of _ passport _ labels @xmath104 assigned to all edges @xmath95 , where @xmath104 is a semialgebraic set .",
    "a state transition along edge @xmath83 is possible if and only if @xmath105 6 .",
    "semialgebraic invariant sets @xmath106 @xmath107 are assigned to every node on the graph , such that @xmath108 equivalently , a state @xmath109 satisfying @xmath110 is unreachable .",
    "therefore , a graph model is a well - defined specific case of the generic model @xmath111 with @xmath112 @xmath113 @xmath114 and @xmath6 defined as:@xmath115    conceptually similar models , namely control flow graphs , have been reported in @xcite ( and the references therein )  for software verification , and in @xcite for modeling and verification of hybrid systems .    * * remarks**@xmath116    1 .",
    "the invariant set of node @xmath76 contains all the available information about the initial conditions of the program variables : @xmath117 2 .",
    "multiple edges between nodes enable modeling of logical `` or '' or `` xor '' type conditional transitions .",
    "this allows for modeling systems with nondeterministic discrete transitions.@xmath118 3 .",
    "the transition label @xmath94  may represent a simple update rule which depends on the real - time input . for instance , if @xmath119  and @xmath120   , $ ]  then @xmath121   \\right\\ } .$ ]  in other cases , @xmath94  may represent an abstraction of a nonlinearity .",
    "for instance , the assignment @xmath122  can be abstracted by @xmath123 ( see eqn .",
    "( [ sinabst ] ) in appendix i).@xmath124 4 .",
    "graph models with state - dependent or time - varying transitions labels arise , for instance , in modeling computer programs that involve arithmetic operations with array elements .",
    "for instance , consider the case where the transition functions are parametrized , and the parameters are drawn from a finite set , e.g. , a multidimensional array .",
    "the dependence on the array elements can be random , resulting time - varying transition labels , or it can be in the form of a functional dependence on other program variables .",
    "systematic treatment of such models is discussed in appendix i.    before we proceed , we introduce the following notation :  given a semialgebraic set @xmath125 and a polynomial function @xmath126 we denote by @xmath127 the set : @xmath128    [ [ construction - of - simple - invariant - setssecconstabst ] ] construction of simple invariant sets[sec : constabst ] + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    simple invariant sets can be included in the model if they are readily available or easily computable .",
    "even trivial invariants can simplify the analysis and improve the chances of finding stronger invariants via convex relaxations , e.g. , the @xmath35-procedure ( cf .",
    "section [ chapter : computation ] ) .    1 .",
    "simple invariant sets may be provided by the programmer .",
    "these can be trivial sets representing simple algebraic relations between variables , or they can be more complicated relationships that reflect the programmer s knowledge about the functionality and behavior of the program .",
    "2 .   invariant propagation : assuming that @xmath129 are deterministic and invertible , the set@xmath130 is an invariant set for node @xmath131 furthermore , if the invariant sets @xmath132 are strict subsets of @xmath133  for all @xmath134 then ( [ constraint prop ] )  can be improved .",
    "specifically , the set@xmath135 is an invariant set for node @xmath131 note that it is sufficient that the restriction of @xmath129 to the lower dimensional spaces in the domains of @xmath136 and @xmath132 be invertible .",
    "3 .   preserving equality constraints :  simple assignments of the form @xmath137 result in invariant sets of the form @xmath138 at node @xmath139 provided that @xmath129 does not simultaneously update @xmath140 formally , let @xmath129 be such that @xmath141 is non - zero for at most one element @xmath142 and that @xmath143 is independent of @xmath144 then , the following set is an invariant set at node @xmath145 @xmath146   x=0\\right\\ }   \\vspace*{-0.15in}%\\ ] ]      the mil - ghms are graph models in which the effects of several lines and/or _ functions _ of code are compactly represented via a milm . as a result ,",
    "the graphs in such models have edges ( possibly self - edges ) that are labeled with matrices @xmath46 and @xmath52 corresponding to a milm as the transition and passport labels .",
    "such models combine the flexibility provided by graph models and the compactness of milms .",
    "an example is presented in section [ sec : casestudy ] .",
    "the specification that can be verified in our framework can generically be described as unreachability and finite - time termination .    [ unreachability]a",
    "program @xmath147 is said to satisfy the unreachability property with respect to a subset @xmath148 if for every trajectory @xmath149 of ( [ softa1 ] ) , and every @xmath150 @xmath151 does not belong to @xmath152 a program @xmath147 is said to _ terminate in finite time _",
    "if every solution @xmath153 of ( [ softa1 ] ) satisfies @xmath154 for some @xmath155    several critical specifications associated with runtime errors are special cases of unreachability .",
    "absence of overflow can be characterized as a special case of unreachability by defining:@xmath156 where @xmath157 is the overflow limit for variable @xmath131 we say that @xmath158 specifies the overflow limit.@xmath159      an out - of - bounds array indexing error occurs when a variable exceeding the length of an array , references an element of the array . assuming that @xmath160 is the corresponding integer index and @xmath161 is the array length",
    ", one must verify that @xmath160 does not exceed @xmath161 at location @xmath139 where referencing occurs .",
    "this can be accomplished by defining @xmath162 over a graph model and proving that @xmath163 is unreachable .",
    "this is also similar to assertion checking  defined next .",
    "an _ assertion _ is a mathematical expression whose validity at a specific location in the code must be verified .",
    "it usually indicates the programmer s expectation from the behavior of the program .",
    "we consider _ assertions _ that are in the form of semialgebraic set memberships .",
    "using graph models , this is done as follows:@xmath164{llccl}% \\text{at location } i : & \\text{assert } x\\in a_{i } & \\rightarrow & \\text{define } & x_{-}=\\left\\ {   \\left (   i , x\\right )   \\in x~|~x\\in x\\backslash a_{i}\\right\\ } , \\\\[-0.05in]% \\text{at location } i : & \\text{assert } x\\notin a_{i } & \\rightarrow & \\text{define } & x_{-}=\\left\\ {   \\left (   i , x\\right )   \\in x~|~x\\in a_{i}\\right\\ } .",
    "\\end{array } \\vspace*{-0.1in}%\\ ] ] in particular , safety assertions for division - by - zero or taking the square root ( or logarithm ) of positive variables are standard and must be automatically included in numerical programs ( cf .",
    "[ sec : bc ] , table [ table ii ] ) .",
    "a program invariant is a property that holds throughout the execution of the program .",
    "the property indicates that the variables reside in a semialgebraic subset @xmath165 .",
    "essentially , any method that is used for verifying unreachability of a subset @xmath148 can be applied for verifying invariance of @xmath166 by defining @xmath167 and vice versa .      for mathematical correctness",
    ", we must show that if an @xmath168-representation of a program satisfies the unreachability and ftt specifications , then so does the @xmath10-representation , i.e. , the actual program .",
    "this is established in the following proposition .",
    "[ abstraction]let @xmath169 be an @xmath26-representation of program @xmath12 with @xmath10-representation @xmath8 let @xmath170 and @xmath171 be such that @xmath172 assume that the unreachability property w.r.t .",
    "@xmath173 has been verified for @xmath33 .",
    "then , @xmath12 satisfies the unreachability property w.r.t .",
    "@xmath152 moreover , if the ftt property holds for @xmath33 , then @xmath12 terminates in finite time .",
    "see appendix ii .",
    "since we are not concerned with undecidability issues , and in light of proposition [ abstraction ] , we will not differentiate between abstract or concrete representations in the remainder of this paper .",
    "analogous to a lyapunov function , a lyapunov invariant is a real - valued function of the program variables satisfying a _ difference inequality _ along the execution trace .",
    "[ def : lyapinv]a @xmath174__-lyapunov invariant _ _ for @xmath9 is a function @xmath175 such that@xmath176 where @xmath177 .",
    "thus , a lyapunov invariant satisfies the _ difference inequality _ ( [ softa2 ] ) along the trajectories of @xmath35 until they reach a terminal state @xmath38 .",
    "it follows from definition [ def : lyapinv ] that a lyapunov invariant is not necessarily nonnegative , or bounded from below , and in general it need not be monotonically decreasing .",
    "while the zero level set of @xmath178 defines an invariant set in the sense that @xmath179 implies @xmath180 , for all @xmath181 monotonicity depends on @xmath182 and the initial condition .",
    "for instance , if @xmath183 @xmath184 then ( [ softa2 ] ) implies that @xmath185 along the trajectories of @xmath186 however , @xmath187 may not be monotonic if @xmath188 though it will be monotonic for @xmath189 furthermore , the level sets of a lyapunov invariant need not be bounded closed curves .",
    "proposition [ prop : milmlyap ]  ( to follow ) formalizes the interpretation of definition [ def : lyapinv ] for the specific modeling languages .",
    "natural lyapunov invariants for graph models are functions of the form@xmath190@xmath191 which assign a polynomial lyapunov function to every node @xmath192 on the graph @xmath193    [ prop : milmlyap]let @xmath194 and properly labeled graph @xmath195 be the mil and graph models for a computer program @xmath196 the function @xmath197   ^{n}\\mapsto\\mathbb{r}$ ] is a @xmath198-lyapunov invariant for @xmath12 if it satisfies:@xmath199   ^{n}\\times\\xi,\\vspace*{-0.2in}%\\ ] ] where@xmath200{cccc}% \\hspace*{-0.04in}\\vspace*{0.04in}x\\hspace*{-0.02 in } & \\hspace*{-0.02in}% w\\hspace*{-0.02 in } & \\hspace*{-0.02in}v\\hspace*{-0.02 in } & \\hspace * { -0.02in}1\\hspace*{-0.04in}% \\end{array } ] ^{^{t}}=0,\\text { } \\left (   w , v\\right )   \\in\\left [   -1,1\\right ]   ^{n_{w}}% \\times\\left\\ {   -1,1\\right\\ }   ^{n_{v}}\\}.\\vspace*{-0.17in}%\\ ] ] the function @xmath201 satisfying ( [ nodewiselyap ] ) is a @xmath202-lyapunov invariant for @xmath12 if@xmath203 @xmath204 note that a generalization of ( [ softa2 ] ) allows for @xmath182 and @xmath205 to depend on the state @xmath206 although simultaneous search for @xmath207 and @xmath187 leads to non - convex conditions , unless the dependence of @xmath182 on @xmath97 is fixed a - priori .",
    "we allow for dependence of @xmath182 on the discrete component of the state in the following way:@xmath208@xmath209        the following proposition is applicable to ftt analysis of both finite and infinite  state models .",
    "[ ftt2]*finite - time termination . *",
    "consider a program @xmath11 and its dynamical system model @xmath210 .",
    "if there exists a @xmath202-lyapunov invariant @xmath211 uniformly bounded on @xmath212 satisfying ( [ softa2 ] ) and the following conditions@xmath213@xmath214 where @xmath215 then @xmath12 terminates in finite time , and an upper - bound on the number of iterations is given by@xmath216{lcl}% \\displaystyle\\frac{\\log\\left (   \\mu+\\left (   \\theta-1\\right )   \\left\\vert v\\right\\vert _ { \\infty}\\right )   -\\log\\left (   \\mu\\right )   } { \\log\\theta } & , & \\theta\\neq1,~\\mu>0\\vspace*{0.1in}\\\\ \\displaystyle\\frac{\\log\\left (   \\left\\vert v\\right\\vert _ { \\infty}\\right ) -\\log\\left (   \\eta\\right )   } { \\log\\theta } & , & \\theta\\neq1,~\\mu=0\\\\ \\left\\vert v\\right\\vert _ { \\infty}/\\mu & , & \\theta=1 \\end{array } \\right .",
    "\\label{bnd on no .",
    "itrn.}%\\]]@xmath217    the proof is presented in appendix ii .",
    "when the state - space @xmath3 is finite , or when the lyapunov invariant @xmath178 is only a function of a subset of the variables that assume values in a finite set , e.g. , integer counters , it follows from proposition [ ftt2 ] that @xmath178 being a @xmath202-lyapunov invariant for any @xmath218 and @xmath219 is sufficient for certifying ftt , and uniform boundedness of @xmath178 need not be established a - priori .    consider the integerdivision program presented in example [ integerdiv - ex ] .",
    "the function @xmath211 defined according to @xmath220 is a @xmath221-lyapunov invariant for integerdivision :  at every step , @xmath178 decreases by @xmath222 since @xmath3 is finite , the program integerdivision terminates in finite time .",
    "this , however , only proves absence of infinite loops . the program could terminate with an overflow .",
    "let @xmath178 be a lyapunov invariant satisfying ( [ softa2 ] ) with @xmath223 the level sets of @xmath224 defined by @xmath225 are invariant with respect to ( [ softa1 ] ) in the sense that @xmath226 whenever @xmath227 .",
    "however , for @xmath228 the level sets @xmath229 remain invariant with respect to ( [ softa1 ] ) for any nonnegative @xmath230 this is an important property with the implication that @xmath231 ( i.e. , monotonicity ) is not necessary for establishing a separating manifold between the reachable set and the unsafe regions of the state space ( cf .",
    "theorem [ bddness ] ) .",
    "[ bddness]*lyapunov invariants as separating manifolds .",
    "* let @xmath232 denote the set of all @xmath202-lyapunov invariants satisfying ( [ softa2 ] ) for  program @xmath233 let @xmath234 be the identity map , and for @xmath235 define@xmath236 a subset @xmath148 where @xmath237 can never be reached along the trajectories of @xmath11 if there exists @xmath238 satisfying@xmath239 and either @xmath240 or one of the following two conditions hold:@xmath241    the proof  is presented in appendix ii .",
    "the following corollary  is based on theorem [ bddness ] and proposition [ ftt2 ]  and presents computationally implementable criteria ( cf .",
    "section [ chapter : computation ] ) for simultaneously establishing ftt and absence of overflow .",
    "[ bddness and ftt]*overflow and ftt analysis * consider a program @xmath11 and its dynamical system model @xmath210 .",
    "let @xmath242 be a diagonal matrix specifying the overflow limit@xmath64 and let @xmath243 let @xmath244 @xmath245 and let the function @xmath175 be a @xmath202-lyapunov invariant for @xmath35 satisfying@xmath246 v\\left (   x\\right )    &   \\geq\\sup\\left\\ {   \\left\\vert \\alpha^{-1}h\\left ( x\\right )   \\right\\vert _ { q}-1\\right\\ }   \\text{\\hspace{0.2in}}\\forall x\\in x.\\vspace*{-0.3in}\\label{three3}%\\end{aligned}\\]]@xmath247 then , an _ overflow runtime error _ will not occur during any execution of @xmath196 in addition , if @xmath219 and @xmath248 then , @xmath12 terminates in at most @xmath249 iterations where @xmath250 if @xmath240 and for @xmath251 we have:@xmath252 where @xmath253@xmath254    the proof  is presented in appendix ii .    *",
    "remarks *    1",
    ".   application of corollary [ bddness and ftt ] with @xmath255 typically leads to much less conservative results compared with @xmath256 , though the computational costs are also higher .",
    "2 .   an alternative , less conservative formulation is obtained when ( [ three3 ] ) is replaced by @xmath53 constraints in the following way:@xmath257 where @xmath258 is the overflow limit for scalar variable @xmath259 since @xmath260 is a scalar quantity , @xmath261 and ( [ remarktos ] ) can be used in conjunction with quadratic lyapunov invariants and the @xmath35-procedure for convex relaxation to formulate the problem of searching for @xmath262 as semidefinite optimization problem ( cf .",
    "section [ chapter : computation ] ) . however , ( [ remarktos ] ) is computationally more expensive than ( [ three3 ] ) , as it increases the number of constraints .",
    "an even less conservative but computationally more demanding alternative would be to construct a different lyapunov invariant for each variable and rewrite ( [ remarktos ] ) , ( [ three3 ] ) , ( [ one1 ] ) along with ( [ softa2 ] ) , for @xmath53 different functions @xmath263 . for instance:@xmath264    [ [ general - unreachability - and - ftt - analysis - over - graph - models ] ] general unreachability and ftt analysis over graph models",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the results presented so far in this section ( theorem [ bddness ] , corollary [ bddness and ftt ] , and proposition [ ftt2 ] ) are readily applicable to milms .",
    "these results will be applied in section [ chapter : computation ] to formulate the verification problem as a convex optimization problem .",
    "herein , we present an adaptation of these results to analysis of graph models .    a cycle @xmath265 on a graph @xmath266 is an ordered list of @xmath267 triplets @xmath268 @xmath269  @xmath270 where @xmath271 and @xmath272 @xmath273 a simple cycle is a cycle with no strict sub - cycles .",
    "[ safetygraphcor1]*unreachability and ftt  analysis of graph models*. consider a program @xmath12 and its graph model @xmath274 let @xmath275 be a lyapunov invariant for @xmath276 satisfying ( [ arcwiselyap ] ) and@xmath203@xmath277 and either one of the following two conditions:@xmath66@xmath278 where@xmath279 then , @xmath12 satisfies the unreachability property w.r.t .",
    "the collection of sets @xmath280 @xmath281 in addition , if for every simple cycle @xmath282 we have:@xmath283@xmath284 where@xmath159 @xmath285 then @xmath12 terminates in at most @xmath249 iterations where@xmath286    the proof  is presented in appendix ii .    for verification against an overflow violation specified by a diagonal matrix @xmath287 corollary [ safetygraphcor1 ]",
    "is applied with @xmath288 hence , ( [ sgc2 ] ) becomes @xmath289@xmath290 @xmath291 where @xmath292 .",
    "user - specified assertions , as well as many other standard safety specifications , such as absence of division - by - zero can be verified using corollary [ safetygraphcor1 ] ( see table i ) .",
    "[ [ identification - of - dead - code ] ]  identification of dead code + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    suppose that we wish to verify that a discrete location @xmath293 in a graph model @xmath294 is unreachable .",
    "if a function satisfying the criteria of corollary [ safetygraphcor1 ] with @xmath295 can be found , then location @xmath81 can never be reached .",
    "condition ( [ sgc2 ] ) then becomes @xmath296,@xmath297    @xmath298{clcl } &   &   & \\\\ &   &   & \\\\\\cline{4 - 4 } &   &   & \\multicolumn{1}{|l|}{apply corollary \\ref{safetygraphcor1 } with:}\\\\\\hline \\multicolumn{1}{|c}{at location $ i$ : } & \\multicolumn{1}{|l}{assert $ x\\in x_{a}$ } & \\multicolumn{1}{|c}{$% \\begin{array } [ c]{c}% \\vspace*{-0.12in}\\\\ \\rightarrow\\\\ \\vspace*{-0.12in}% \\end{array } $ } & \\multicolumn{1}{|l|}{$x_{i-}:=\\left\\ {   x\\in\\mathbb{r}^{n}~|~x\\in \\mathbb{r}^{n}\\backslash x_{a}\\right\\ }   $ } \\\\\\hline \\multicolumn{1}{|c}{at location $ i$ : } & \\multicolumn{1}{|l}{assert $ x\\notin x_{a}$ } & \\multicolumn{1}{|c}{$% \\begin{array } [ c]{c}% \\vspace*{-0.12in}\\\\ \\rightarrow\\\\ \\vspace*{-0.12in}% \\end{array }",
    "$ } & \\multicolumn{1}{|l|}{$x_{i-}:=\\left\\ {   x\\in\\mathbb{r}^{n}~|~x\\in x_{a}\\right\\ }   $ } \\\\\\hline \\multicolumn{1}{|c}{at location $ i$ : } & \\multicolumn{1}{|l}{(expr.)/$x_{o}$ } & \\multicolumn{1}{|c}{$% \\begin{array } [ c]{c}% \\vspace*{-0.12in}\\\\ \\rightarrow\\\\ \\vspace*{-0.12in}% \\end{array } $ } & \\multicolumn{1}{|l|}{$x_{i-}:=\\left\\ {   x\\in\\mathbb{r}^{n}~|~x_{o}% = 0\\right\\ }   $ } \\\\\\hline \\multicolumn{1}{|c}{at location $ i$ : } & \\multicolumn{1}{|l}{$\\sqrt[2k]{x_{o } } $ } & \\multicolumn{1}{|c}{$% \\begin{array } [ c]{c}% \\vspace*{-0.12in}\\\\ \\rightarrow\\\\ \\vspace*{-0.12in}% \\end{array } $ } & \\multicolumn{1}{|l|}{$x_{i-}:=\\left\\ {   x\\in\\mathbb{r}^{n}~|~x_{o}% < 0\\right\\ }   $ } \\\\\\hline",
    "\\multicolumn{1}{|c}{at location $ i$ : } & \\multicolumn{1}{|l}{$\\log\\left ( x_{o}\\right )   $ } & \\multicolumn{1}{|c}{$% \\begin{array } [ c]{c}% \\vspace*{-0.12in}\\\\ \\rightarrow\\\\ \\vspace*{-0.12in}% \\end{array } $ } & \\multicolumn{1}{|l|}{$x_{i-}:=\\left\\ {   x\\in\\mathbb{r}^{n}~|~x_{o}% \\leq0\\right\\ }   $ } \\\\\\hline \\multicolumn{1}{|c}{at location $ i$ : } & \\multicolumn{1}{|l}{dead code } & \\multicolumn{1}{|c}{$% \\begin{array } [ c]{c}% \\vspace*{-0.12in}\\\\ \\rightarrow\\\\ \\vspace*{-0.12in}% \\end{array } $ } & \\multicolumn{1}{|l|}{$x_{i-}:=r^{n}$}\\\\\\hline \\end{tabular } $ ]    consider the following program note that @xmath299 can be zero right after the assignment @xmath300 however , at location @xmath301 , @xmath299 can not be zero and division - by - zero will not occur .",
    "the graph model of an abstraction of program 3 is shown next to the program and is defined by the following elements : @xmath302 and @xmath303   .$ ] the other transition labels are identity .",
    "the only non - universal passport labels are @xmath304 and @xmath305 as shown in the figure .",
    "define@xmath306 \\sigma_{0}\\left (   \\mathrm{x}\\right )    & = \\sigma_{1}\\left (   \\mathrm{x}\\right ) = \\sigma_{4}\\left (   \\mathrm{x}\\right )   = \\sigma_{8}\\left (   \\mathrm{x}\\right ) = -\\mathrm{x}^{2}+2\\mathrm{x}-3.\\vspace*{-0.1in}%\\end{aligned}\\ ] ] it can be verified that @xmath307 is a @xmath308-lyapunov invariant for program 3 with variable rates : @xmath309 and @xmath310 for all @xmath311 .",
    "since@xmath312 the state @xmath313 can not be reached .",
    "hence , a division by zero will never occur .",
    "we will show in the next section how to find such functions in general.@xmath66",
    "it is well known that the main difficulty in using lyapunov functions in system analysis is finding them . naturally , using lyapunov invariants in software analysis",
    "inherits the same difficulties .",
    "however , the recent advances in hardware and software technology , e.g. , semi - definite programming @xcite , @xcite , and linear programming software @xcite present an opportunity for new approaches to software verification based on numerical optimization .",
    "the chances of finding a lyapunov invariant are increased when ( [ softa2 ] ) is only required on a subset of @xmath314 .",
    "for instance , for @xmath315 it is tempting to replace ( [ softa2 ] ) with@xmath316 in this formulation @xmath178 is not required to satisfy ( [ softa2 ] ) for those states which can not be reached from @xmath317 however , the set of all functions @xmath175 satisfying ( [ softa4 ] ) is not convex and finding a solution for ( [ softa4 ] ) is typically much harder than ( [ softa2 ] ) .",
    "such non - convex formulations are not considered in this paper .",
    "the first step in the search for a function @xmath175 satisfying ( [ softa2 ] ) is selecting a finite - dimensional linear parameterization of a candidate function @xmath178:@xmath318 where @xmath319 are fixed basis functions .",
    "next , for every @xmath320 let @xmath321 ( assuming for simplicity that the maximum does exist ) . since @xmath322 is a maximum over @xmath97 of a family of linear functions in @xmath323 , @xmath324 is a convex function .",
    "if minimizing @xmath324 over the unit disk yields a negative minimum , the optimal @xmath325 defines a valid lyapunov invariant @xmath326 .",
    "otherwise , no linear combination ( [ softa7 ] ) yields a valid solution for ( [ softa2 ] ) .",
    "the success and efficiency of the proposed approach depend on computability of @xmath324 and its subgradients . while @xmath324 is convex , the same does not necessarily hold for @xmath327 as a function of @xmath97 .",
    "in fact , if @xmath314 is non - convex , which is often the case even for very simple programs , computation of @xmath324 becomes a non - convex optimization problem even if @xmath328 is a nice ( e.g. linear or concave and smooth ) function of @xmath329 to get around this hurdle , we propose using convex relaxation techniques which essentially lead to computation of a convex upper bound for @xmath330 .",
    "such techniques constitute a broad class of techniques for constructing finite - dimensional , convex approximations for difficult non - convex optimization problems . some of the results most relevant to the software verification framework presented in this paper can be found in @xcite  for sdp relaxation of binary integer programs , @xcite and @xcite for sdp relaxation of quadratic programs , @xcite  for @xmath331-procedure in robustness analysis , and @xcite,@xcite for sum - of - squares relaxation in polynomial non - negativity verification .",
    "we provide a brief overview of the latter two techniques .",
    "[ [ the - mathcals - procedure - sections - procedure ] ] the @xmath35-procedure [ section : s - procedure ] + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the @xmath35-procedure is commonly used for construction of lyapunov functions for nonlinear dynamical systems .",
    "let functions @xmath332 @xmath333 and @xmath334 @xmath335 be given , and suppose that we are concerned with evaluating the following assertions:@xmath336    the implication ( ii )  @xmath337 ( i ) is trivial . the process of replacing assertion ( i ) by its",
    "_ relaxed _ version ( ii ) is called the @xmath35-procedure .",
    "note that condition ( ii ) is convex in decision variables @xmath338 and @xmath339 the implication ( i ) @xmath337 ( ii ) is generally not true and the @xmath35-procedure is called lossless for special cases where ( i ) and ( ii ) are equivalent .",
    "a well - known such case is when @xmath340 @xmath341 and @xmath342 @xmath343 are quadratic functionals@xmath102 a comprehensive discussion of the @xmath35-procedure as well as available results on its losslessness can be found in @xcite .",
    "other variations of @xmath35-procedure with non - strict inequalities exist as well .    [",
    "[ sum - of - squares - sos - relaxation - sectionsos - relaxation ] ] sum - of - squares ( sos ) relaxation [ section : sos - relaxation ] + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the sos  relaxation technique can be interpreted as the generalized version of the @xmath35-procedure and is concerned with verification of the following assertion:@xmath344 where @xmath345 are polynomial functions .",
    "it is easy to see that the problem is equivalent to verification of emptiness of a semialgebraic set , a necessary and sufficient condition for which is given by the positivstellensatz theorem @xcite . in practice ,",
    "sufficient conditions in the form of nonnegativity of polynomials are formulated .",
    "the non - negativity conditions are in turn relaxed to sos conditions .",
    "let @xmath346   $ ] denote the set of sos polynomials in @xmath267 variables @xmath347 , i.e. the set of polynomials that can be represented as @xmath348 @xmath349 where @xmath350 is the polynomial ring of @xmath267 variables with real coefficients . then",
    ", a sufficient condition for ( [ semialgformulae ] ) is that there exist sos  polynomials @xmath351   $ ] and polynomials @xmath352 such that@xmath353 matlab toolboxes sostools @xcite , or yalmip @xcite automate the process of converting an sos problem to an sdp , which is subsequently solved by available software packages such as lmilab @xcite , or sedumi @xcite .",
    "interested readers are referred to @xcite for more details .",
    "natural lyapunov invariant candidates for milms are quadratic and affine functionals .",
    "the linear parameterization of the space of quadratic functionals mapping @xmath354 to @xmath355 is given by : where @xmath356 is the set of @xmath53-by-@xmath53 symmetric matrices .",
    "we have the following lemma .",
    "[ mipl_invariance_lemma]consider a program @xmath12 and its milm @xmath357 the program admits a quadratic @xmath202-lyapunov invariant @xmath358 if there exists a matrix @xmath359 @xmath50 a diagonal matrix @xmath360 a positive semidefinite diagonal matrix @xmath361 and a symmetric matrix @xmath362 satisfying the following lmis : [ milp_invariance_lmi ] @xmath363 \\lambda & = \\operatorname{trace}d_{xw}+\\operatorname{trace}d_{v}\\vspace*{-1in}%\\end{aligned}\\ ] ] where    the proof is presented in appendix ii    the following theorem summarizes our results for verification of absence of overflow and/or ftt for milms .",
    "the result follows from lemma [ mipl_invariance_lemma ] and corollary [ bddness and ftt ] with @xmath364 , @xmath365 though the theorem is presented without a detailed proof .",
    "[ milp_correctness_theorem]*optimization - based milm  verification . *",
    "let @xmath366 be a diagonal positive definite matrix specifying the overflow limit .",
    "an overflow runtime error does not occur during any execution of @xmath12 if there exist matrices @xmath367 diagonal matrices @xmath368 positive semidefinite diagonal matrices @xmath369 and a symmetric matrix @xmath370 satisfying the following lmis : [ milp_thm ] @xmath371{cc}% x_{0 } & 1 \\end{array } ] p[% \\begin{array } [ c]{cc}% x_{0 } & 1 \\end{array } ] ^{t }   & \\leq0,\\text{\\qquad}\\forall x_{0}\\in x_{0}\\label{milp_thm_a}% \\\\[-0.06 in ] l_{1}^{t}pl_{1}-\\theta l_{2}^{t}pl_{2 }   & \\preceq\\operatorname{he}\\left ( y_{1}h\\right )   + l_{3}^{t}d_{1xw}l_{3}+l_{4}^{t}d_{1v}l_{4}-\\left (   \\lambda _ { 1}+\\mu\\right )   l_{5}^{t}l_{5}\\label{milp_thm_b}\\\\[-0.06 in ] l_{1}^{t}\\lambda l_{1}-l_{2}^{t}pl_{2 }   & \\preceq\\operatorname{he}\\left ( y_{2}h\\right )   + l_{3}^{t}d_{2xw}l_{3}+l_{4}^{t}d_{2v}l_{4}-\\lambda_{2}% l_{5}^{t}l_{5}\\label{milp_thm_c}%\\end{aligned}\\]]@xmath247 where @xmath372 @xmath373 and @xmath374 @xmath375 in addition , if @xmath248 then @xmath12 terminates in a most @xmath249 steps where @xmath249 is given in ( [ upperboundontu ] ) .",
    "affine lyapunov invariants can often establish strong properties , e.g. , boundedness , for  variables with simple uncoupled dynamics ( e.g. counters ) at a low computational cost . for variables with more complicated dynamics , affine invariants may simply establish sign - invariance ( e.g. , @xmath376 ) or more generally , upper or lower bounds on some linear combination of certain variables . as we will observe in section [ sec : casestudy ] , establishing these simple behavioral properties",
    "is important as they can be recursively added to the model ( e.g. , the matrix @xmath52 in a milm , or the invariant sets @xmath45 in a graph model ) to improve the chances of success in proving stronger properties via higher order invariants .",
    "the linear parameterization of the subspace of linear functionals mapping @xmath354 to @xmath377is given by:@xmath378   ^{t},~k\\in\\mathbb{r}^{n+1}\\right\\ }   .\\vspace * { -0.12in}\\label{milp_linear_fctn}%\\ ] ] it is possible to search for the affine invariants via semidefinite programming or linear programming .    [ mipl_linearinvariance_lemma]*sdp characterization of linear invariants : * there exists a @xmath202-lyapunov invariant @xmath379 for a program @xmath380 if there exists a matrix @xmath381 a diagonal matrix @xmath382 a positive semidefinite diagonal matrix @xmath383 and a matrix @xmath384 satisfying the following lmi:@xmath385 where @xmath386 and @xmath387    [ mipl_linearinvariance_lemma_lp]*lp characterization of linear invariants : * there exists a @xmath202-lyapunov invariant for a program @xmath388 in the class @xmath389 if there exists a matrix @xmath390 and nonnegative matrices @xmath391  @xmath392 and a matrix @xmath393 satisfying :    [ milp - lp - lp]@xmath394    @xmath214 where @xmath395 is either @xmath396 or @xmath397 as a special case of ( [ milp - lp - lp ] ) ,  a subset of all the affine invariants is characterized by the set of all solutions of the following system of linear equations : @xmath398    when the objective is to establish properties of the form @xmath399 for a fixed @xmath400 ( e.g. , when establishing sign - invariance for certain variables ) , matrix @xmath401 in ( [ milp - li - sdp])@xmath402([milp - lp - lp - simple ] ) is fixed and thus one can make @xmath182 a decision variable subject to @xmath403 exploiting this convexity is extremely helpful for successfully establishing such properties .",
    "the advantage of using sdp for computation of linear invariants is that efficient sdp relaxations for treatment of binary variables exists @xcite , @xcite , @xcite , though the computational costs are typically higher than the lp - based approaches . in contrast , linear programming relaxations of the binary constraints are more involved than the corresponding sdp relaxations .",
    "two extreme remedies can be readily considered .",
    "the first is to relax the binary constraints and treat the variables as continuous variables .",
    "the second is to consider each of the @xmath404 different possibilities ( one for each vertex of @xmath405 ) separately .",
    "this approach is practical only if @xmath406 is small .",
    "more sophisticated schemes can be developed based on hierarchical relaxations or convex hull approximations of binary integer programs @xcite , @xcite .",
    "a linear parameterization of the subspace of polynomial functionals with total degree less than or equal to @xmath407 is given by:@xmath408 where @xmath409 is a vector of length @xmath410 consisting of all monomials of degree less than or equal to @xmath407 in @xmath53 variables @xmath411 a linear parametrization of lyapunov invariants for graph models is defined according to ( [ nodewiselyap ] ) , where for every @xmath92 we have @xmath412 where @xmath413 is a selected degree bound for @xmath414 depending on the dynamics of the model , the degree bounds @xmath415 and the convex relaxation technique , the corresponding optimization problem will become a linear , semidefinite , or sos optimization problem .",
    "we present generic conditions for verification over graph models using sos  programming . for the specific case of verification of",
    "_ linear graph models _ via quadratic invariants and the @xmath35-procedure for relaxation of non - convex constraints we present explicit lmis .",
    "the corresponding matlab code is available at @xcite .",
    "the following theorem follows from corollary [ safetygraphcor1 ] .",
    "[ thm : graphnodepoly]*optimization - based graph model verification . *",
    "consider a program @xmath12 , and its graph model @xmath416 let @xmath417 be given by ( [ nodewiselyap ] ) , where @xmath418 then , the functions @xmath419 @xmath192 define a lyapunov invariant for @xmath11 if for all @xmath95 we have:@xmath420   \\text { subject to } \\left ( x , w\\right )   \\in\\left (   \\left (   x_{i}\\cap\\pi_{ji}^{k}\\right )   \\times \\lbrack-1,1]^{n_{w}}\\right )   \\cap s_{ji}^{k}\\vspace*{-0.2in}\\label{d1d1}%\\ ] ] furthermore , @xmath12 satisfies the unreachability property w.r.t .",
    "the collection of sets @xmath280 @xmath421 if there exist @xmath422 @xmath291 such that@xmath423   \\text { subject to } x\\in x_{\\emptyset}\\vspace*{-0.2in}\\label{d1d0}\\\\ \\sigma_{i}\\left (   x\\right )   -\\varepsilon_{i }   & \\in\\sigma\\left [   x\\right ] \\text { subject to } x\\in x_{i}\\cap x_{i-},\\ i\\in\\mathcal{n}\\backslash\\left\\ { \\emptyset\\right\\ }   \\vspace*{-0.25in}\\label{d1d3}%\\end{aligned}\\]]@xmath424 as discussed in section [ section : sos - relaxation ] , the sos relaxation techniques can be applied for formulating the search problem for functions @xmath425 satisfying ( [ d1d1])([d1d3 ] ) as a convex optimization problem .",
    "for instance , if @xmath426^{n_{w}% } \\right )   \\cap s_{ji}^{k}=\\left\\ {   \\left (   x , w\\right )   ~|~f_{p}\\left ( x , w\\right )   \\geq0,\\text { } h_{l}\\left (   x , w\\right )   = 0\\right\\ }   , \\vspace * { -0.2in}%\\ ] ] then , ( [ d1d1 ] ) can be relaxed as an sos optimization problem of the following form : @xmath427   , \\text { s.t . }",
    "\\tau_{p}% , \\tau_{pq}\\in\\sigma\\left [   x , w\\right ]   .\\vspace*{-0.2in}%\\ ] ] software packages such as sostools @xcite or yalmip @xcite can then be used for formulating the sos optimization problems as semidefinite programs .      in a quasi - linear graph model ,",
    "all the transition labels are linear .",
    "the passport labels and the invariant sets are defined by linear and/or quadratic functions .",
    "let @xmath428^{t},$ ] @xmath429 and let , for all  @xmath430 a compact description of the set @xmath431 be given by:@xmath432 where @xmath433 @xmath434 @xmath435 @xmath436 and @xmath437 @xmath438 where @xmath101 and @xmath439 are some sets . for all @xmath95 let the transitions be given by @xmath440 where @xmath441   ^{q_{ji}^{k}}.$ ] before proceeding to the next theorem , for convenience , we define the following matrices : @xmath442    [ thm : graphmodellmi]*sdp - based verification of quasi - linear graph models . * consider a program @xmath12 , and its quasi - linear graph model @xmath443 for @xmath444 let @xmath445 be a diagonal matrix specifying the overflow limit and let @xmath446 let @xmath447 for all @xmath448 an overflow runtime error does not occur during any execution of @xmath11 if for all @xmath449 the following lmis are satisfied:@xmath450 \\mathcal{f}^{t}\\lambda_{j}\\mathcal{f}^{t}-\\mathcal{l}^{t}p_{i}\\mathcal{l }   & \\preceq\\mathcal{w}^{t}\\widetilde{d}\\mathcal{w}-\\operatorname{tr}(\\widetilde { d})\\mathcal{k}^{t}\\mathcal{k}+\\operatorname{he}(\\widetilde{y}\\mathcal{hl+}% \\widetilde{z}\\mathcal{gl)}+\\widetilde{\\lambda}_{ji}^{k}\\label{lgmlmi2.}%\\end{aligned}\\ ] ] @xmath451 where for all @xmath95 we have@xmath452 \\widetilde{\\lambda}_{ji}^{k }   & = \\sum\\limits_{s}\\widetilde{\\eta}_{ji , s}% ^{k}\\mathcal{l}^{t}q_{ji , s}^{k}\\mathcal{l}+\\sum\\limits_{m}\\widetilde{\\rho } _ { ji , m}^{k}\\mathcal{l}^{t}r_{ji , m}^{k}\\mathcal{l}\\label{eq2:thm : gmlmi}% \\\\[-0.05 in ] ( y,\\widetilde{y},z,\\widetilde{z},d,\\widetilde{d } )   & = ( y_{ij}^{k}% , \\widetilde{y}_{ij}^{k},z_{ij}^{k},\\widetilde{z}_{ij}^{k},d_{ij}% ^{k},\\widetilde{d}_{ij}^{k})\\label{eq3:thm : gmlmi}\\\\[-0.05 in ] \\left (   \\mathcal{f},\\mathcal{g},\\mathcal{h},\\mathcal{k},\\mathcal{l}% , \\mathcal{w}\\right )     & = ( f_{ji}^{k},g_{ji}^{k},h_{ji}^{k},k_{ji}^{k}% , l_{ji}^{k},w_{ji}^{k})\\label{eq4:thm : gmlmi}%\\end{aligned}\\ ] ] @xmath451 where the @xmath35-procedure multipliers in ( [ eq1:thm : gmlmi])@xmath402([eq3:thm : gmlmi ] ) are constrained as follows:@xmath453 \\rho_{ji , m}^{k},~\\widetilde{\\rho}_{ji , m}^{k }   & \\in\\mathbb{r},\\qquad \\forall\\left (   i , j , k\\right )   \\in\\mathcal{e},\\text { } m\\in m_{ji}^{k}% \\label{mult2}\\\\[-0.05 in ] y_{ji}^{k},~\\widetilde{y}_{ji}^{k }   & \\in\\mathbb{r}^{(n+q_{ji}^{k}+1)\\times h_{ji}^{k}},\\qquad\\forall\\left (   i , j , k\\right )   \\in\\mathcal{e}\\label{mult3}\\\\[-0.05 in ] z_{ji}^{k},~\\widetilde{z}_{ji}^{k }   & \\in\\mathbb{r}_{-}^{(n+q_{ji}% ^{k}+1)\\times g_{ji}^{k}},\\qquad\\forall\\left (   i , j , k\\right )   \\in \\mathcal{e}\\label{mult4}\\\\[-0.05 in ] d_{ij}^{k},~\\widetilde{d}_{ij}^{k }   & \\in\\mathbb{d}_{+}^{q_{ji}^{k}\\times q_{ji}^{k}},\\qquad\\forall\\left (   i , j , k\\right )   \\in\\mathcal{e},\\label{mult5}%\\end{aligned}\\ ] ] @xmath451 and the matrices in ( [ eq4:thm : gmlmi ] ) are defined in ( [ eq : compactpi])@xmath402([eq : wandk ] ) .",
    "in addition , if for every simple cycle @xmath454 we have:@xmath283@xmath455 with @xmath456 and @xmath457 defined as in ( [ multiplicativethetandefs ] ) , then @xmath12 terminates in at most @xmath249 iterations where@xmath458    see appendix ii .    *",
    "remarks *    1 .   a simpler , computationally less demanding but possibly more conservative variation of theorem [ thm : graphmodellmi ] can be formulated by replacing ( [ lgmlmi2 . ] ) with @xmath459 @xmath460 subsequently , all the associated multipliers ( i.e. , the variables denoted by _ tilde _ characters in ( [ mult1])@xmath402([mult5 ] ) ) will be eliminated .",
    "it is possible to use the same set of multipliers ( i.e. , the variables defined in ( [ mult1])@xmath402([mult5 ] ) ) across all edges @xmath461 this approach would also result in a computationally less demanding but possibly conservative formulation .",
    "3 .   to improve the chances of finding stronger invariants , quadratic equality and inequality constraints can be generated from linear constraints and added to the set of quadratic constraints in characterization of the set  @xmath431 ( cf . equation [ eq : compactpi])@xmath102 given scalar linear constraints of the form @xmath462 @xmath463 and/or @xmath464 @xmath465 define  @xmath466 @xmath467 and @xmath468 then , we have @xmath469 @xmath470 and @xmath471 for all @xmath472 and @xmath473 4 .",
    "replacing with @xmath474 where @xmath475 is a decision variable can improve the scaling and numerical conditioning of the associated semidefinite program , resulting in stronger invariants and improved analysis .",
    "the statement of the theorem on absence of overflow remains unchanged under this modification .",
    "only the upper bound on the maximum number of iterations needs to be adjusted accordingly since we now have @xmath476 instead of @xmath477 the same scaling arguments apply to .",
    "matlab implementations of theorem [ thm : graphmodellmi ]  and a few variations of it can be found in @xcite .",
    "in this section we apply the framework to the analysis of program 4 displayed below.program 4 takes two positive integers @xmath478   $ ] and @xmath479   $ ] as the input and returns their greatest common divisor by implementing the euclidean division algorithm .",
    "note that the main function in program 4 uses the integerdivision program ( program 1 ) .",
    "a global model can be constructed by embedding the dynamics of the integerdivision program within the dynamics of main .",
    "a labeled graph model is shown alongside the text of the program .",
    "this model has a state space @xmath480 ^{7},$ ] where @xmath89 is the set of nodes as shown in the graph , and the global state @xmath481   $ ] is an element of the hypercube @xmath482",
    "^{7}.$ ] a _ reduced _ graph model can be obtained by combining the effects of consecutive transitions and relabeling the reduced graph model accordingly . while analysis of the full graph model is possible , working with a _ reduced _ model is computationally advantageous . furthermore , mapping the properties of the reduced graph model to the original model is algorithmic .",
    "interested readers may consult @xcite for further elaboration on this topic .",
    "for the graph model of program 4 , a reduced model can be obtained by first eliminating nodes @xmath483 @xmath484 @xmath485 @xmath486 @xmath487 @xmath488 @xmath489",
    "@xmath490 and @xmath491 ( figure [ fig : redmodel ] left ) and composing the transition and passport labels . node @xmath492 can be eliminated as well to obtain a further reduced model with only three nodes : @xmath493 @xmath494 @xmath495 ( figure [ fig : redmodel ] right ) .",
    "[ tbh ]    eucdivfigreducednew.pdf    this is the model that we will analyze .",
    "the passport and transition labels associated with the reduced model are as follows : @xmath496{rllcrrll}% \\overline{t}_{\\mathrm{f}2\\mathrm{f}2}^{1 } & \\hspace*{-0.06in}:\\hspace * { -0.06 in } & \\mathrm{x}\\mapsto\\left [ \\mathrm{x,\\ y,\\ rem,\\ dd,\\ dr,\\ q+1,\\ r - dr}\\right ]   & \\vspace*{-0.05 in } &   & \\overline{t}_{\\mathrm{f}2\\mathrm{f}2}^{2 } & \\hspace*{-0.06in}:\\hspace * { -0.06 in } & \\mathrm{x}\\mapsto\\left [   \\mathrm{y,\\ r,\\ r,\\ y,\\ r,\\ 0,\\ y}% \\right ] \\\\",
    "\\overline{t}_{\\mathrm{l}0\\mathrm{f}2 } & \\hspace*{-0.06in}:\\hspace*{-0.06 in } & \\mathrm{x}\\mapsto\\left [   \\mathrm{x,\\ y,\\ 0,\\ x,\\ y,\\ 0,\\ x}\\right ]   & \\vspace*{-0.05 in } &   & \\overline{t}_{\\mathrm{f}2\\mathrm{l}\\join } & \\hspace*{-0.06in}:\\hspace*{-0.06 in } & \\mathrm{x}\\mapsto\\left [ \\mathrm{y,\\ r,\\ r,\\ dd,\\ dr,\\ q,\\ r}\\right ] \\end{array } \\\\ & \\begin{array } [ c]{rllcrrlllllll}% \\pi_{\\mathrm{f}2\\mathrm{f}2}^{2 } & \\hspace*{-0.06in}:\\hspace*{-0.06 in } & \\left\\ {   \\mathrm{x~|~1\\leq r\\leq dr-1}\\right\\ }   &   &   & \\pi_{\\mathrm{f}% 2\\mathrm{f}2}^{1 } & \\hspace*{-0.06in}:\\hspace*{-0.06in}\\vspace*{-0.05 in } & \\left\\ {   \\mathrm{x~|~r\\geq dr}\\right\\ }   &   &   & \\pi_{\\mathrm{f}2\\mathrm{l}% \\join } & \\hspace*{-0.06in}:\\hspace*{-0.06 in } & \\left\\ {   \\mathrm{x~|~r\\leq dr-1,}\\text { } \\mathrm{r\\leq0}\\right\\ } \\end{array}\\end{aligned}\\ ] ]    finally , the invariant sets that can be readily included in the graph model ( cf . section [ sec : constabst ] ) are:@xmath497 we are interested in generating certificates of termination and absence of overflow .",
    "first , by recursively searching for linear invariants we are able to establish simple lower bounds on all variables in just two rounds ( the properties established in the each round are added to the model and the next round of search begins ) .",
    "for instance , the property @xmath498 is established only after @xmath499 is established .",
    "these results , which were obtained by applying the first part of theorem [ thm : graphnodepoly ] ( equations ( [ d1d1])-([d1d0 ] ) only )  with linear functionals are summarized in table  ii .",
    "@xmath500{|r|c|c|c|c|c|c|c|}\\hline $ \\text{property}$ & $ \\mathrm{q}\\geq\\mathrm{0}$ & $ \\mathrm{y}\\geq\\mathrm{1}$ & $ \\mathrm{\\mathrm{dr}}\\geq\\mathrm{\\mathrm{1}}$ & $ \\mathrm{\\mathrm{rem}}% \\geq\\mathrm{0}$ & $ \\mathrm{\\mathrm{dd}}\\geq\\mathrm{\\mathrm{1}}$ & $ \\mathrm{x}\\geq\\mathrm{1}$ & $ \\mathrm{r}\\geq\\mathrm{0}$\\\\\\hline $ \\text{proven in round}$ & $ \\mathrm{\\mathrm{i}}$ & $ \\mathrm{\\mathrm{i}}$ & $ \\mathrm{\\mathrm{i}}$ & $ \\mathrm{\\mathrm{i}}$ & $ \\mathrm{\\mathrm{ii}}$ & $ \\mathrm{\\mathrm{ii}}$ & $ \\mathrm{\\mathrm{ii}}$\\\\\\hline $ \\sigma_{\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   = $ & $ -\\mathrm{q}$ & $ \\mathrm{1}-\\mathrm{y}$ & $ \\mathrm{1}-\\mathrm{dr}$ & $ -\\mathrm{\\mathrm{rem}}$ & $ \\mathrm{1}-\\mathrm{dd}$ & $ \\mathrm{1}-\\mathrm{x}$ & $ -\\mathrm{r}$\\\\\\hline $ \\left",
    "(   \\theta_{\\mathrm{f}2\\mathrm{f}2}^{1},\\mu_{\\mathrm{f}2\\mathrm{f}2}% ^{1}\\right )   $ & $ \\left (   1,1\\right )   $ & $ \\left (   1,0\\right )   $ & $ \\left ( 1,0\\right )   $ & $ \\left (   1,0\\right )   $ & $ \\left (   0,0\\right )   $ & $ \\left ( 0,0\\right )   $ & $ \\left (   0,0\\right )   $ \\\\\\hline $ \\left (   \\theta_{\\mathrm{f}2\\mathrm{f}2}^{2},\\mu_{\\mathrm{f}2\\mathrm{f}2}% ^{2}\\right )   $ & $ \\left (   0,0\\right )   $ & $ \\left (   0,0\\right )   $ & $ \\left ( 0,0\\right )   $ & $ \\left (   0,0\\right )   $ & $ \\left (   0,0\\right )   $ & $ \\left ( 0,0\\right )   $ & $ \\left (   0,0\\right )   $ \\\\\\hline \\end{tabular}\\end{gathered}\\ ] ] we then add these properties to the node invariant sets to obtain stronger invariants that certify ftt and boundedness of all variables in @xmath501   $ ] . by applying theorem [ thm : graphnodepoly ] and sos programming using yalmip @xcite ,",
    "the following invariants are found and different rounding schemes lead to different invariants .",
    "note that rounding is not essential . ]",
    "( after post - processing , rounding the coefficients , and reverifying ) : @xmath164{llll}% \\sigma_{1\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   = 0.4\\left (   \\mathrm{y}% -\\mathrm{m}\\right )   \\left (   2+\\mathrm{m}-\\mathrm{r}\\right )   &   &   & \\sigma_{2\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   = \\left (   \\mathrm{q}% \\times\\mathrm{y}+\\mathrm{r}\\right )   ^{2}-\\mathrm{m}^{2}\\\\ \\sigma_{3\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   = \\left (   \\mathrm{q}% + \\mathrm{r}\\right )   ^{2}-\\mathrm{m}^{2 } &   &   & \\sigma_{4\\mathrm{f}_{2}% } \\left (   \\mathrm{x}\\right )   = 0.1\\left (   \\mathrm{y}-\\mathrm{m}+5\\mathrm{y}% \\times\\mathrm{m}+\\mathrm{y}^{2}-6\\mathrm{m}^{2}\\right ) \\\\",
    "\\sigma_{5\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   = \\mathrm{y}+\\mathrm{r}% -2\\mathrm{m}+\\mathrm{y}\\times\\mathrm{m}-\\mathrm{m}^{{\\normalsize 2 } } &   &   & \\sigma_{6\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   = \\mathrm{r}\\times \\mathrm{y}+\\mathrm{y}-\\mathrm{m}^{2}-\\mathrm{m}% \\end{array}\\ ] ] the properties proven by these invariants are summarized in the table iii .",
    "the specifications that the program terminates and that @xmath502   ^{7}$ ] for all initial conditions @xmath503   , $ ] could not be established in one shot , at least when trying polynomials of degree @xmath504 for instance , @xmath505 certifies boundedness of all the variables except @xmath506 while @xmath507 and @xmath508 which certify boundedness of all variables including @xmath22 do not certify ftt .",
    "furthermore , boundedness of some of the variables is established in round ii , relying on boundedness properties proven in round i. given @xmath509 ( which is found in round i ) , second round verification can be done by searching for a strictly positive polynomial @xmath510 and a nonnegative polynomial @xmath511 satisfying:@xmath512 where the inequality ( [ eq : roundii ] ) is further subject to boundedness properties established in round i , as well as the usual passport conditions and basic invariant set conditions .",
    "@xmath513{|r|c|c|c|c|}\\hline invariant $ \\sigma_{\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   = \\hspace * { -0.02in}$ & $ \\sigma_{1\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   $ & $ \\hspace*{-0.02in}\\sigma_{2\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right ) , \\sigma_{3\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   \\hspace*{-0.02in}$ & $ \\sigma_{4\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   $ & $ \\sigma_{5\\mathrm{f}% _ { 2}}\\left (   \\mathrm{x}\\right )   , \\sigma_{6\\mathrm{f}_{2}}\\left ( \\mathrm{x}\\right )   $ \\\\\\hline $ % \\begin{array } [ c]{c}% \\left (   \\theta_{\\mathrm{f}2\\mathrm{f}2}^{1},\\mu_{\\mathrm{f}2\\mathrm{f}2}% ^{1}\\right )   \\smallskip \\end{array } \\hspace*{-0.02in}$ & $ \\left (   1,0\\right )   $ & $ \\left (   1,0\\right )   $ & $ \\left (   1,0\\right )",
    "$ & $ \\left (   1,1\\right )   $ \\\\\\hline $ % \\begin{array } [ c]{c}% \\left (   \\theta_{\\mathrm{f}2\\mathrm{f}2}^{2},\\mu_{\\mathrm{f}2\\mathrm{f}2}% ^{2}\\right )   \\smallskip \\end{array } \\hspace*{-0.02in}$ & $ \\left (   1,0.8\\right )   $ & $ \\left (   0,0\\right )   $ & $ \\left (   1,0.7\\right )   $ & $ \\left (   1,1\\right )   $ \\\\\\hline \\multicolumn{1}{|l|}{round i : $ % \\begin{array } [ c]{c}% \\mathrm{x}_{i}^{2}\\leq\\mathrm{m}^{2}\\text { for } \\mathrm{x}_{i}\\mathrm{=}% \\smallskip\\hspace*{-0.08in}% \\end{array } \\hspace*{-0.02in}$ } & $ \\hspace*{-0.02in}\\mathrm{y , x , r , dr , rem , dd}% \\hspace*{-0.02in}$ & $ \\hspace*{-0.02in}\\mathrm{q , y , dr , rem}\\hspace*{-0.02in}$ & $ \\hspace*{-0.02in}\\mathrm{y , x , r , dr , rem , dd}\\hspace*{-0.02in}$ & $ \\hspace * { -0.02in}\\mathrm{y , dr , rem}\\hspace*{-0.02in}$\\\\\\hline \\multicolumn{1}{|l|}{round ii:$% \\begin{array } [ c]{c}% \\mathrm{x}_{i}^{2}\\leq\\mathrm{m}^{2}\\text { for } \\mathrm{x}_{i}\\mathrm{=}% \\smallskip\\hspace*{-0.08in}% \\end{array } \\hspace*{-0.02in}$ } &   & $ \\mathrm{x , r , dd}$ &   & $ \\mathrm{x , r , dd}$\\\\\\hline certificate for ftt$\\hspace*{-0.02in}$ & no & no & no & yes , $ t_{u}% = 2\\mathrm{m}^{2}$\\\\\\hline \\end{tabular}\\end{gathered}\\ ] ] in conclusion , @xmath514 or @xmath515 in conjunction with @xmath516 or @xmath517 prove finite - time termination of the algorithm , as well as boundedness of all variables within @xmath501   $ ] for all initial conditions @xmath518   , $ ] for any @xmath519 the provable bound on the number of iterations certified by @xmath516 and @xmath517 is @xmath520 ( corollary [ safetygraphcor1])@xmath102 if we settle for more conservative specifications , e.g. , @xmath521 ^{7}$ ] for all initial conditions @xmath522   $ ] and sufficiently large @xmath523 then it is possible to prove the properties in one shot .",
    "we show this in the next section .      for comparison , we also constructed the mil - gh model associated with the reduced graph in figure [ fig : redmodel ] .",
    "the corresponding matrices are omitted for brevity , but details of the model along with executable matlab verification codes can be found in  @xcite .",
    "the verification theorem used in this analysis is an extension of theorem [ milp_correctness_theorem ] to analysis of mil - ghm for specific numerical values of @xmath524 though it is certainly possible to perform this modeling and analysis exercise for parametric bounded values of @xmath525 the analysis using the mil - ghm is in general more conservative than sos optimization over the graph model presented earlier .",
    "this can be attributed to the type of relaxations proposed ( similar to those used in lemma [ milp_invariance_lmi ] ) for analysis of milms and mil - ghms .",
    "the benefits are simplified analysis at a typically much less computational cost .",
    "the certificate obtained in this way is a single quadratic function ( for each numerical value of @xmath526 ) , establishing a bound @xmath527 satisfying @xmath528 table iv summarizes the results of this analysis which were performed using  both sedumi 1_3 and lmilab solvers .",
    "@xmath529{|r|c|c|c|c|c|}\\hline $ \\mathrm{m}$ & $ 10^{2}$ & $ 10^{3}$ & $ 10^{4}$ & $ 10^{5}$ & $ 10^{6}$\\\\\\hline solver : lmilab \\cite{gahinetlmilab } : $ \\gamma\\left (   \\mathrm{m}\\right )   $ & $ 5.99\\mathrm{m}$ & $ 6.34\\mathrm{m}$ & $ 6.43\\mathrm{m}$ & $ 6.49\\mathrm{m}$ & $ 7.05\\mathrm{m}$\\\\\\hline solver : sedumi \\cite{strum1999 } : $ \\gamma\\left (   \\mathrm{m}\\right )   $ & $ 6.00\\mathrm{m}$ & $ 6.34\\mathrm{m}$ & $ 6.44\\mathrm{m}$ & $ 6.49\\mathrm{m}$ & nan\\\\\\hline $ % \\begin{array } [ c]{c}% \\left (   \\theta_{\\mathrm{f}2\\mathrm{f}2}^{1},\\mu_{\\mathrm{f}2\\mathrm{f}2}% ^{1}\\right )   \\smallskip \\end{array } \\hspace*{-0.02in}$ & $ \\left (   1,10^{-3}\\right )   $ & $ \\left (   1,10^{-3}\\right ) $ & $ \\left (   1,10^{-3}\\right )   $ & $ \\left (   1,10^{-3}\\right )   $ & $ \\left ( 1,10^{-3}\\right )   $ \\\\\\hline $ % \\begin{array } [ c]{c}% \\left (   \\theta_{\\mathrm{f}2\\mathrm{f}2}^{2},\\mu_{\\mathrm{f}2\\mathrm{f}2}% ^{2}\\right )   \\smallskip \\end{array } \\hspace*{-0.02in}$ & $ \\left (   1,10^{-3}\\right )   $ & $ \\left (   1,10^{-3}\\right ) $ & $ \\left (   1,10^{-3}\\right )   $ & $ \\left (   1,10^{-3}\\right )",
    "$ & $ \\left ( 1,10^{-3}\\right )   $ \\\\\\hline upperbound on iterations$\\hspace*{-0.02in}$ & $ t_{u}=2$e$4 $ & $ t_{u}=8$e$4 $ & $ t_{u}=8$e$5 $ & $ t_{u}=1.5$e$7 $ & $ t_{u}=3$e$9$\\\\\\hline \\end{tabular}\\end{gathered}\\ ] ]      the preceding results were obtained by analysis of a global model which was constructed by embedding the internal dynamics of the program s functions within the global dynamics of the main function .",
    "in contrast , the idea in _ modular analysis _ is to model software as the interconnection of the program s `` building blocks '' or `` modules '' , i.e. , functions that interact via a set of _ global _ variables .",
    "the dynamics of the functions are then abstracted via input / output behavioral models , typically constituting equality and/or inequality constraints relating the input and output variables . in our framework , the invariant sets of the terminal nodes of the modules ( e.g. , the set @xmath530 associated with the terminal node @xmath531 in program 4 ) provide such i / o model .",
    "thus , richer characterization of the invariant sets of the terminal nodes of the modules are desirable .",
    "correctness of each sub - module must be established separately , while correctness of the entire program will be established by verifying the unreachability and termination properties w.r.t .",
    "the global variables , as well as verifying that a terminal global state will be reached in finite - time .",
    "this way , the program variables that are _ private _ to each function are abstracted away from the global dynamics .",
    "this approach has the potential to greatly simplify the analysis and improve the scalability of the proposed framework as analysis of large size computer programs is undertaken . in this section ,",
    "we apply the framework to modular analysis of program 4 .",
    "detailed analysis of the advantages in terms of improving scalability , and the limitations in terms of conservatism the analysis is an important and interesting direction of future research .",
    "the first step is to establish correctness of the integerdivision module , for which we obtain@xmath532 the function @xmath533 is a @xmath534-invariant proving boundedness of the state variables of integerdivision .",
    "subject to boundedness , we obtain the function@xmath535 which is a @xmath536-invariant proving termination of integerdivision .",
    "the invariant set of node @xmath531 can thus be characterized by@xmath537   ^{4}~|~\\mathrm{r\\leq dr-1}\\right\\ }   \\vspace*{-0.15in}%\\ ] ] the next step is construction of a global model .",
    "given @xmath530 , the assignment at @xmath538 : @xmath539 can be abstracted by @xmath540 , \\text{~}\\mathrm{w}\\leq\\mathrm{y-1,}\\vspace*{-0.2in}%\\ ] ] allowing for construction of a global model with variables @xmath541and @xmath542 and an external state - dependent input @xmath543   \\mathrm{,}$ ] satisfying @xmath544 finally , the last step is analysis of the global model .",
    "we obtain the function @xmath545 which is @xmath536-invariant proving both ftt and boundedness of all variables within @xmath546   .$ ]      program 4 has been adopted with some minor modifications from a similar program analyzed by astree @xcite . the only modification that we have made",
    "is the addition of the real - time input @xmath547   $ ] in line @xmath548 note that when @xmath549 ( in line @xmath550 )  we have the same program reported in @xcite . in program 4",
    ", the function @xmath551 truncates the real - time input @xmath552 so that @xmath547   $ ] is guaranteed .",
    "we first build a graph model of this program .",
    "the variables of the graph model are :    the variable is boolean which we model by @xmath553 in the following way:@xmath554 the graph model of this program is shown in figure [ figastree ] .",
    "@xmath555{|l|}\\hline% \\begin{tabular } [ c]{l}% \\begin{tabular } [ c]{ll } & { \\small \\textrm{/ * filter.c * /\\vspace*{-0.18in}}}\\\\ & { \\small \\textrm{typedef enum \\{false = 0 , true = 1\\ } boolean;\\vspace * { -0.18in}}}\\\\ & { \\small \\textrm{boolean init ; { float y=\\textrm{\\{0\\ } } , z=\\{0\\};}% \\vspace*{-0.18in}}}\\\\ { \\small \\textrm{f}}${\\small 0:\\hspace*{0.04in}}$ & { \\small \\textrm{void filter ( ) \\{\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{f}}${\\small 1:\\hspace*{0.04in}}$ & { \\small \\textrm{static float e[2 ] , s[2];\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{f}}${\\small 2:\\hspace*{0.04in}}$ & { \\small \\textrm{if ( init ) \\{\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{f}}${\\small 3:\\hspace*{0.04in}}$ & \\qquad{\\small \\textrm{s[0 ] = z;\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{f}}${\\small 4:\\hspace*{0.04in}}$ & \\qquad{\\small \\textrm{y = z;\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{f}}${\\small 5:\\hspace*{0.04in}}$ & \\qquad{\\small \\textrm{e[0 ] = z;\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{f}}${\\small 6:\\hspace*{0.04in}}$ & { \\small \\textrm{\\ } else \\{\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{f}}${\\small 7:\\hspace*{0.04in}}$ & \\qquad{\\small \\textrm{y = ( ( ( ( ( 0.5*z ) - ( e[0]*0.7 ) ) + ( e[1]*0.4 ) ) + ( s[0]*1.5 ) ) - ( s[1]*0.7));\\vspace * { -0.18in}}}\\\\ { \\small \\textrm{f}}${\\small 8:\\hspace*{0.04in}}$ & \\qquad { \\small \\textrm{\\}\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{f}}${\\small 9:\\hspace*{0.04in}}$ & { \\small \\textrm{e[1 ] = e[0];\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{f}}${\\small 10:\\hspace*{0.04in}}$ & { \\small \\textrm{e[0 ] = z;\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{f}}${\\small 11:\\hspace*{0.04in}}$ & { \\small \\textrm{s[1 ] = s[0];\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{f}}${\\small 12:\\hspace*{0.04in}}$ & { \\small \\textrm{s[0 ] = y;\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{f}}${\\small 13:\\hspace*{0.04in}}$ & { \\small \\textrm{\\}}}% \\end{tabular } \\\\ $ % \\begin{tabular } [ c]{ll}% { \\small \\textrm{l}}${\\small 0:\\hspace*{0.1in}}$ & { \\small \\textrm{void main ( ) \\{\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{l}}${\\small 1:\\hspace*{0.1in}}$ & { \\small \\textrm{z = 0.2 * z + 5;\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{l}}${\\small 2:\\hspace*{0.1in}}$ & { \\small \\textrm{init = true;\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{l}}${\\small 3:\\hspace*{0.1in}}$ & { \\small \\textrm{while ( 1 ) \\ { \\vspace*{-0.18in}}}\\\\ & \\qquad{\\small \\textrm{wait ( 0.001 ) ;",
    "w = saturate(}}$\\mathrm{{\\small \\ast ptrtoinput);}}$ { \\small \\textrm{/*updates real - time input*/\\vspace*{-0.18in}}% } \\\\ { \\small \\textrm{l}}${\\small 4:\\hspace*{0.1in}}$ & \\qquad{\\small \\textrm{z = 0.9 * z + 35+b*w;\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{l}}${\\small 5:\\hspace*{0.1in}}$ & \\qquad{\\small \\textrm{filter ( ) ; \\vspace*{-0.18in}}}\\\\ { \\small \\textrm{l}}${\\small 6:\\hspace*{0.1in}}$ & \\qquad{\\small \\textrm{init = false;\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{l}}${\\small 7:\\hspace*{0.1in}}$ & \\qquad { \\small \\textrm{\\}\\vspace*{-0.18in}}}\\\\ { \\small \\textrm{l}}${\\small \\join}{\\small : \\hspace*{0.1in}}$ & { \\small \\textrm{\\}}}% \\end{tabular } $ % \\end{tabular } \\\\\\hline \\end{tabular } \\\\[0.2in]% \\begin{array } [ c]{c}% \\begin{array } [ c]{cccccc } &   &   & \\text{program 4 : example of filtering in safety - critical software } & & \\end{array } \\\\ \\text{example adapted from reference \\cite{astree - web } with minor modifications.}\\\\ \\end{array}\\end{gathered}\\ ] ]    [ ptb ]    figureastree2.pdf    in order to construct a more compact model , several lines of code corresponding to consecutive transitions have been combined , and only the first line corresponding to a series of consecutive transitions has been assigned a node on the graph . specifically , the combined lines are : @xmath556 @xmath557 and @xmath558 and @xmath559 the net effect of the eliminated lines is captured in the model by taking the composition of the functions that are coded at these lines .    letting @xmath560 @xmath561,\\ e[1],\\ s[0],\\ s[1],\\ v}% \\right ]   ^{t},$ ] the state space of the graph model is @xmath562 where @xmath563 as shown in figure [ figastree ] .",
    "the initial condition is fixed : @xmath564 where @xmath565   ^{t}.$ ] the corresponding passport and transition labels are as follows:@xmath496{rllcrrll}% t_{\\mathrm{l}3\\mathrm{l}1 } & \\hspace*{-0.06in}:\\hspace*{-0.06 in } & \\mathrm{x}\\mapsto\\left",
    "[   0.2\\mathrm{z}% + 5\\mathrm{,\\ y,\\ e[0],\\ e[1],\\ s[0],\\ s[1],\\ } 1\\right ]    & \\vspace*{-0.05 in } & &   &   & \\\\ t_{\\mathrm{l}5\\mathrm{l}4 } & \\hspace*{-0.06in}:\\hspace*{-0.06 in } & \\mathrm{x}\\mapsto\\left [   0.9\\mathrm{z}% + 35+\\mathrm{bw,\\ y,\\ e[0],\\ e[1],\\ s[0],\\ s[1],\\ v}\\right ]    & \\vspace * { -0.05 in } &   &   &   & \\\\ t_{\\mathrm{l}3\\mathrm{l}6 } & \\hspace*{-0.06in}:\\hspace*{-0.06 in } & \\mathrm{x}\\mapsto\\left [   \\mathrm{z,\\ y,\\ e[0],\\ e[1],\\ s[0],\\ s[1],\\ -1}% \\right ]    &   &   &   &   & \\\\ t_{\\mathrm{f}9\\mathrm{f}3 } & \\hspace*{-0.06in}:\\hspace*{-0.06 in } & \\mathrm{x}\\mapsto\\left [   \\mathrm{z,\\ z,\\ z,\\ e[1],\\ z,\\ s[1],\\ v}\\right ]    & &   &   &   & \\\\ t_{\\mathrm{f}9\\mathrm{f}7 } & \\hspace*{-0.06in}:\\hspace*{-0.06 in } & \\mathrm{x}\\mapsto\\left [   \\mathrm{z,\\ } 0.5\\mathrm{z}-0.7\\mathrm{e[0]}% + 0.4\\mathrm{e[1]}+1.5\\mathrm{s[0]}% -0.7\\mathrm{s[1],\\ e[0],\\ e[1],\\ s[0],\\ s[1],\\ v}\\right ]    &   &   &   &   & \\\\ t_{\\mathrm{f}13\\mathrm{f}9 } & \\hspace*{-0.06in}:\\hspace*{-0.06 in } & \\mathrm{x}\\mapsto\\left [   \\mathrm{z,\\ y,\\ z,\\ e[0],\\ y,\\ s[0],\\ v}\\right ]    & &   &   &   & \\end{array } \\\\[-0.1 in ] & \\begin{array } [ c]{rllcrrllllllllllll}% \\pi_{\\mathrm{f}3\\mathrm{f}2 } & \\hspace*{-0.06in}=\\hspace*{-0.06 in } & \\left\\ { \\mathrm{x~|~v=1}\\right\\ }   , &   &   & \\pi_{\\mathrm{f}6\\mathrm{f}2 } & \\hspace*{-0.06in}=\\hspace*{-0.06in}\\vspace*{-0.05 in } & \\left\\ { \\mathrm{x~|~v=-1}\\right\\ }   , &   &   & \\pi_{\\mathrm{l}4\\mathrm{l}3 } & \\hspace*{-0.06in}=\\hspace*{-0.06in}\\vspace*{-0.05 in } & \\mathbb{r}^{7 } , &   &   & \\pi_{\\mathrm{l}\\join\\mathrm{l}3 } & = & \\mathbb{\\varnothing}. \\end{array}\\end{aligned}\\ ] ]    the other transitions are identity maps .",
    "theorem [ thm : graphmodellmi ] can be applied for verification of absence of overflow ( note that the program does not terminate ) .",
    "we apply theorem [ thm : graphmodellmi ] for two different values of @xmath566 @xmath549 which corresponds to no real - time input , and @xmath567 for each value of @xmath568 , absence of overflow is verified using two different methods . in method",
    "i , we set @xmath569 and thus , we obtain a certificate for @xmath570 using one quadratic invariant . in method",
    "ii , for each @xmath571 we set @xmath572 where @xmath573 is the @xmath81-th standard unit vector in @xmath574 ( cf .",
    "corollary [ bddness and ftt ] and equation ) . as a result",
    ", we obtain a much tighter upperbound in the form of @xmath575 at the expense of more computations .",
    "table v summarizes the results of this analysis .",
    "analysis of the floating - point operations is based on the abstractions discussed in appendix i. the corresponding matlab codes can be found in @xcite . in this analysis ,",
    "the solver sedumi version 1.3 @xcite is used for semidefinite optimization , and yalmip @xcite for compilation . for comparison",
    "we point out that the static analyzer astree reports a bound of @xmath576 for the @xmath549 case @xcite .",
    "@xmath577{|r|r|c|c|c|l|}\\hline & computations : & infinite - precision & $ 64$-bit double precision & $ 32$-bit single precision & \\\\\\hline \\multicolumn{1}{|l|}{method i } & \\multicolumn{1}{|c|}{$\\mathrm{b}=0 $ } & $ \\mathrm{m}=884.95 $ & $ \\mathrm{m}=884.96 $ & $ \\mathrm{m}=884.96 $ & $ \\mathrm{m}\\geq\\left\\vert \\mathrm{x}\\right\\vert _ { 2}\\geq\\left\\vert \\mathrm{x}\\right\\vert _",
    "{ \\infty}$\\\\\\hline \\multicolumn{1}{|l|}{method ii } & \\multicolumn{1}{|c|}{$\\mathrm{b}=0 $ } & $ \\mathrm{m}=373.11 $ & $ \\mathrm{m}=373.12 $ & $ \\mathrm{m}=373.12 $ & $ \\mathrm{m}\\geq\\left\\vert \\mathrm{x}\\right\\vert _ { \\infty}$\\\\\\hline \\multicolumn{1}{|l|}{method",
    "i } & \\multicolumn{1}{|c|}{$\\mathrm{b}=20 $ } & \\multicolumn{1}{|c|}{$\\mathrm{m}=1400.95 $ } & \\multicolumn{1}{|c|}{$\\mathrm{m}% = 1402.81 $ } & $ \\mathrm{m}=1402.87 $ & $ \\mathrm{m}\\geq\\left\\vert \\mathrm{x}% \\right\\vert _ { 2}\\geq\\left\\vert \\mathrm{x}\\right\\vert _",
    "{ \\infty}$\\\\\\hline \\multicolumn{1}{|l|}{method ii } & \\multicolumn{1}{|c|}{$\\mathrm{b}=20 $ } & $ \\mathrm{m}=609.83 $ & $ \\mathrm{m}=609.83 $ & $ \\mathrm{m}=609.83 $ & $ \\mathrm{m}\\geq\\left\\vert \\mathrm{x}\\right\\vert _ { \\infty}$\\\\\\hline & $ % \\begin{array } [ c]{c}% \\left (   \\theta_{\\mathrm{ij}},\\mu_{\\mathrm{ij}}\\right )   \\smallskip \\end{array } \\hspace*{-0.02in}$ & $ \\left (   0.98,0\\right )   $ & $ \\left (   0.98,0\\right )   $ & $ \\left (   0.98,0\\right )   $ & \\\\\\hline \\end{tabular}\\end{gathered}\\ ] ]",
    "we took a systems - theoretic approach to software analysis , and presented a framework based on convex optimization of lyapunov invariants for verification of a range of important specifications for software systems , including finite - time termination and absence of run - time errors such as overflow , out - of - bounds array indexing , division - by - zero , and user - defined program assertions .",
    "the verification problem is reduced to solving a numerical optimization problem , which when feasible , results in a certificate for the desired specification .",
    "the novelty of the framework , and consequently , the main contributions of this paper are in the systematic transfer of lyapunov functions and the associated computational techniques from control systems to software analysis . the presented work can be extended in several directions .",
    "these include understanding the limitations of modular analysis of programs , perturbation analysis of the lyapunov certificates to quantify robustness with respect to round - off errors , extension to systems with software in closed loop with hardware , and adaptation of the framework to specific classes of software .",
    "1 .   trigonometric functions :    abstraction of trigonometric functions can be obtained by approximation of the taylor series expansion followed by representation of the absolute error by a static bounded uncertainty .",
    "for instance , an abstraction of the @xmath578 function can be constructed as follows:@xmath579{|l|l|l|}\\hline abstraction of $ \\sin\\left (   x\\right )   $ & $ x\\in\\lbrack-\\frac{\\pi}{2},\\frac { \\pi}{2}]$ & $ x\\in\\lbrack-\\pi,\\pi]$\\\\\\hline $ \\overline{\\sin}\\left (   x\\right )   \\in\\left\\ {   x+aw~|~w\\in\\left [   -1,1\\right ] \\right\\ }   $ & $ a=0.571 $ & $ a=3.142$\\\\\\hline $ \\overline{\\sin}\\left (   x\\right )   \\in\\{x-\\frac{1}{6}x^{3}+aw~|~w\\in\\left [ -1,1\\right ]   \\}$ & $ a=0.076 $ & $ a=2.027$\\\\\\hline \\end{tabular}\\ ] ] abstraction of @xmath580 is similar .",
    "it is also possible to obtain piecewise linear abstractions by first approximating the function by a piece - wise linear ( pwl ) function and then representing the absolute error by a bounded uncertainty .",
    "section [ section : specmodels ] ( proposition [ milm - prop ] ) establishes universality of representation of generic pwl functions via binary and continuous variables and an algorithmic construction is given in the proof of the proposition in appendix ii .",
    "for instance , if @xmath581 $ ] then a piecewise linear approximation with absolute error less than @xmath582 can be constructed in the following way :    [ sinabst]@xmath583   , \\hspace*{0.02in}\\left (   w , v\\right )   \\in\\left [ -1,1\\right ]   ^{2}\\times\\left\\ {   -1,1\\right\\ }   \\right\\ } \\label{sinabsta}\\\\ \\hspace*{-0.1in}\\overline{\\sin}\\left (   x\\right )   \\hspace{-0.02 in } & \\in\\hspace{-0.02in}\\left\\ {   tx_{e}~|~x_{e}\\in s\\right\\ }   , \\text{\\ } % t : x_{e}\\mapsto0.45\\left (   1+v\\right )   x+\\left (   1-v\\right )   \\left ( 0.2x+0.2\\right )   + 0.06w_{1}%\\end{aligned}\\ ] ]    1 .   the sign function ( @xmath584 ) and the absolute value function ( @xmath585 ) :    the sign function ( @xmath586 ) may appear explicitly as one of the program s functions , or implicitly as a model for conditional switching .",
    "a particular abstraction of @xmath587 is as follows : @xmath588 .",
    "note that @xmath589 is equal to @xmath590 while the abstraction is multi - valued at zero@xmath591 @xmath592 the absolute value function can be represented ( precisely ) over @xmath69   $ ] in the following way : @xmath593   \\times\\left\\ { -1,1\\right\\ }   \\right\\ }   \\vspace*{-0.25in}%\\ ] ]    1 .   modulo arithmetic :    consider the function @xmath594 defined in the following way:@xmath595 abstraction of the function @xmath596 over bounded subsets of the set of integers is as follows .",
    "let @xmath597 , where @xmath598 is an integer .",
    "then:@xmath599 it follows from ( [ moda ] ) that the result of summation modulo @xmath600 of two integers @xmath601 can be abstracted in the following way:@xmath602      this subsection is based on @xcite , chapter 7 .",
    "interested readers are referred to @xcite for a more comprehensive discussion of computations with floats . for computations with floating - point numbers ,",
    "the ieee 754 - 1985 norm has become the hardware standard , and is supported by most popular programming languages such as c. in this standard , a _ float _",
    "number is represented by a triplet @xmath603 where:@xmath66    * @xmath604 is the sign bit.@xmath159 * @xmath17 is the fractional part , represented by a @xmath605-bit unsigned integer : @xmath606 @xmath607 * @xmath608 is the biased exponent , represented by a @xmath609-bit unsigned integer : @xmath610 @xmath611    a floating point number @xmath612 is then in one of the following forms :    * @xmath613 when @xmath614 * @xmath615 when @xmath616 and @xmath617 * @xmath618 ( when @xmath619 ) and @xmath620 ( when @xmath621 ) and @xmath622 * @xmath623 ( when @xmath619 ) and @xmath624 ( when @xmath621 ) and @xmath625 @xmath617 * @xmath626 @xmath627 when @xmath628 @xmath629    the values of @xmath630 @xmath631 and @xmath632 depend on the specific format :    * if format is 32-bit single precision ( f=32 ) , then @xmath633 @xmath634 and @xmath635 * if format is 64-bit double precision ( f=64 ) , then @xmath636 @xmath637 and @xmath638    other formatting standards such as _ long double _ or _ quadruple _ precision also exist . in floating point computations , the result of performing the arithmetic operation @xmath639 on two _ float _ variables @xmath97 and @xmath640",
    "is stored in a _",
    "variable @xmath641 which is a complicated function of @xmath206 @xmath642 and the format f. examples of the format f include the ieee 754 with 32-bit single precision , or ieee 754 with 64-bit double precision@xmath102 a floating - point operation is equivalent to performing the operation over the set of real numbers followed by rounding the result to a _ float _ @xcite . in ieee 754",
    "the possible rounding modes are rounding towards @xmath396 , towards @xmath643 , towards @xmath644 , and to the nearest ( n ) .",
    "the rounding function @xmath645 maps a real number to a float number or to runtime error @xmath646 , depending on the format ` f ' and the rounding mode ` m ' .",
    "we refer the reader to @xcite for more details on the rounding function . for our purposes , it is sufficient to say that for all rounding modes , the following relation holds:@xmath647:\\left\\vert \\gamma_{\\text{f , m}}\\left (   x\\right )   -x\\right\\vert \\leq\\gamma_{\\text{f}% } \\left\\vert x\\right\\vert + \\beta_{\\text{f}}\\vspace*{-0.15in}%\\ ] ] where @xmath648 and @xmath649 is the largest non - infinite number , and @xmath650 is the smallest non - zero positive number .    based on the above discussions , an abstraction of the floating - point arithmetic operators can be constructed in the following way:@xmath164{c}% x+y\\in\\lbrack-\\alpha_{\\text{f}},\\alpha_{\\text{f}}]\\rightarrow \\operatorname{float}\\left (   x+y\\right )   = z\\in\\left\\ {   x+y+\\delta w~|~w\\in\\left [   -1,1\\right ]   , \\text { } \\delta=\\gamma_{\\text{f}}\\left ( \\left\\vert x\\right\\vert + \\left\\vert y\\right\\vert \\right )   + \\beta_{\\text{f}% } \\right\\ } \\\\ x - y\\in\\lbrack-\\alpha_{\\text{f}},\\alpha_{\\text{f}}]\\rightarrow \\operatorname{float}\\left (   x - y\\right )   = z\\in\\left\\ {   x - y+\\delta w~|~w\\in\\left [   -1,1\\right ]   , \\text { } \\delta=\\gamma_{\\text{f}}\\left ( \\left\\vert x\\right\\vert + \\left\\vert y\\right\\vert \\right )   + \\beta_{\\text{f}% } \\right\\ }",
    "\\\\ x\\times y\\in\\lbrack-\\alpha_{\\text{f}},\\alpha_{\\text{f}}]\\rightarrow \\operatorname{float}\\left (   x\\times y\\right )   = z\\in\\left\\ {   x\\times y+\\delta w~|~w\\in\\left [   -1,1\\right ]   , \\text { } \\delta=\\gamma_{\\text{f}}\\left ( \\left\\vert x\\right\\vert \\times\\left\\vert y\\right\\vert \\right )   + \\beta _ { \\text{f}}\\right\\ } \\\\",
    "x\\div y\\in\\lbrack-\\alpha_{\\text{f}},\\alpha_{\\text{f}}]\\rightarrow \\operatorname{float}\\left (   x\\div y\\right )   = z\\in\\left\\ {   x\\div y+\\delta w~|~w\\in\\left [   -1,1\\right ]   , \\text { } \\delta=\\gamma_{\\text{f}}\\left ( \\left\\vert x\\right\\vert \\div\\left\\vert y\\right\\vert \\right )   + \\beta_{\\text{f}% } \\right\\ } \\end{array}\\ ] ] where the constants @xmath651 @xmath652 and @xmath653 are defined as before .",
    "the above abstractions can still be complicated as the magnitude of @xmath654 depends on the operands @xmath97 and @xmath655 if all of the program variables ( including the result of the arithmetic operation ) reside in @xmath656   $ ] where @xmath657 then a simpler but more conservative abstraction can be constructed in the following way:@xmath203@xmath658\\rightarrow\\operatorname{float}\\left ( x\\circledast y\\right )   = z\\in\\left\\ {   x\\circledast y+\\delta w~|~w\\in\\left [ -1,1\\right ]   , \\text { } \\delta=\\alpha\\gamma_{\\text{f}}+\\beta_{\\text{f}}\\right\\ } \\vspace*{-0.15in}%\\ ] ] for instance , if f=32 and @xmath659 then @xmath660 and if f=64 and @xmath661 then @xmath662 abstractions of arithmetic operations in fixed - point computations is similar to the above . the magnitude of @xmath654 will depend on the number of bits and the dynamic range .",
    "for instance , in the two s complement format we have : @xmath663 where @xmath664 is the dynamic range and @xmath665 is the number of bits .",
    "a case study in software verification based on the above discussed abstractions of floating - point computations has been presented in section [ sec : casestudy2 ] .",
    "consider the following fragment from a program with two variables : @xmath666 and @xmath667@xmath164{c}% \\begin{tabular } [ c]{|l|}\\hline $ % \\begin{array } [ c]{cl}% \\text{\\textrm{l}}1 : & x = a\\left [   i\\right ]   x;\\\\ \\text{\\textrm{l}}2 : & \\text{expression}% \\end{array } $ \\\\\\hline \\end{tabular } \\vspace*{0.1in}% \\end{array}\\ ] ] then , the state transition from node @xmath668 to @xmath669 is defined by @xmath670   x , i\\right )   , $ ] where @xmath671 is an array of size @xmath669 .",
    "an algorithm similar to the one used in construction of milms ( cf .",
    "proposition [ milm - prop ] ) can be used to construct a transition label using semi - algebraic set - valued maps . for the above example",
    ", this can be done in the following way:@xmath283@xmath164{rll}% \\overline{t}_{21}\\left (   x , i\\right )   & = & \\{t_{21}\\left (   x , i , v_{1}% , v_{2}\\right )   ~|~\\left (   x , i , v_{1},v_{2}\\right )   \\in s_{21}\\}.\\\\ t_{21}\\left (   x , i , v_{1},v_{2}\\right )   & = & a\\left [   1\\right ]   v_{1}x+a\\left [ 2\\right ]   v_{2}x.\\\\ s_{21 } & = & \\left\\ {   \\left (   x , i , v_{1},v_{2}\\right )   ~|~v_{1}+v_{2}=1,\\text { } v_{1},v_{2}\\in\\left\\ {   0,1\\right\\ }   , \\text { } v_{1}\\left (   i-1\\right ) + v_{2}\\left (   i-2\\right )   = 0\\right\\ }   .",
    "\\end{array}\\ ] ] in light of proposition [ milm - prop ] , generalization of this technique to multidimensional arrays with arbitrary finite size is straightforward .",
    "however , the number of binary decision variables grows ( linearly ) with the number of elements in the array , which can be undesirable for large arrays .",
    "an alternative approach to constructing graph models with fixed labels is to attempt to derive a fixed map by computing the net effect of several lines of code @xcite .",
    "when applicable , the result is a fixed map which is obtained by taking the composition of several functions .",
    "this is an instance of a more general concept in computer science , namely , extracting the higher level semantics , which allows one to define more compact models of the software .",
    "for instance , consider the following code fragment :    [ ptb ]    foorloops2.pdf    @xmath555{|l|}\\hline $ % \\begin{array } [ c]{ll}% \\begin{array } [ c]{c}% \\mathrm{l}1 : \\end{array } & \\begin{array } [ c]{c}% \\text{{\\small for ( k = 1 ; k = = n ; k++)\\qquad\\{}}% \\end{array } \\vspace*{-0.15in}\\\\% \\begin{array } [ c]{c}% \\mathrm{l}2 : \\end{array } & \\begin{array } [ c]{c}% \\text{{\\small y [ k ] = x [ k ] ; x [ k ] = 0 ; \\}}}% \\end{array } \\vspace*{-0.15in}\\\\% \\begin{array } [ c]{c}% \\mathrm{l}3 : \\end{array } & \\begin{array } [ c]{c}% \\text{{\\small for ( i = 1 ; i = = n ; i++)\\qquad\\{}}% \\end{array } \\vspace*{-0.15in}\\\\% \\begin{array } [ c]{c}% \\mathrm{l}4 : \\end{array } & \\begin{array } [ c]{c}% \\text{\\qquad{\\small for ( j = 1 ; j = = n ; j++)\\qquad\\{}}% \\end{array } \\vspace*{-0.15in}\\\\% \\begin{array } [ c]{c}% \\mathrm{l}5 : \\end{array } & \\begin{array } [ c]{c}% \\qquad\\text{\\qquad{\\small x [ i ] = x [ i ] + y [ j ] * a [ i ] [ j ] ; } } % \\end{array } \\vspace*{-0.15in}\\\\% \\begin{array } [ c]{c}% \\mathrm{l}6 : \\end{array } & \\begin{array } [ c]{c}% \\text{{\\small \\}\\}}}% \\end{array } \\end{array } $ \\\\\\hline \\end{tabular } \\\\[0.1 in ] \\text{program 5 : a code fragment from a linear filtering application}%\\end{gathered}\\ ] ]    a graph model of this code fragment is shown in figure [ foorloops2 ] , where:@xmath283@xmath672   \\cdots y\\left [   n\\right ]   \\right ] ^{t},\\text { } x=\\left [   x\\left [   1\\right ]   \\cdots x\\left [   n\\right ]   \\right ] ^{t}\\\\[0.25 in ] t_{\\ast2}\\left [   k\\right ]    & : \\left [ \\begin{array } [ c]{c}% \\vspace*{-0.5in}\\\\ y\\\\ \\vspace*{-0.5in}\\\\ x\\\\ \\vspace*{-0.4in}% \\end{array } \\right ]   \\rightarrow\\left [ \\begin{array } [ c]{cc}% \\vspace*{-0.5 in } & \\\\ i - e_{kk } & e_{kk}\\\\ \\vspace*{-0.5 in } & \\\\ 0 & i - e_{kk}\\\\ \\vspace*{-0.4 in } & \\end{array } \\right ]   \\left [ \\begin{array } [ c]{c}% \\vspace*{-0.5in}\\\\ y\\\\ \\vspace*{-0.5in}\\\\ x\\\\ \\vspace*{-0.4in}% \\end{array } \\right ]   , \\\\[0.25 in ] t_{\\ast5}\\left [   i , j\\right ]    & : \\left [ \\begin{array } [ c]{c}% \\vspace*{-0.5in}\\\\ y\\\\ \\vspace*{-0.5in}\\\\ x\\\\ \\vspace*{-0.4in}% \\end{array } \\right ]   \\rightarrow\\left [ \\begin{array } [ c]{cc}% \\vspace*{-0.5 in } & \\\\ i & 0\\\\ \\vspace*{-0.5 in } & \\\\ a_{ij}e_{ij } & i\\\\ \\vspace*{-0.4 in } & \\end{array } \\right ]   \\left [ \\begin{array } [ c]{c}% \\vspace*{-0.5in}\\\\ y\\\\ \\vspace*{-0.5in}\\\\ x\\\\ \\vspace*{-0.4in}% \\end{array } \\right ]   , \\end{aligned}\\ ] ] where @xmath673 is an @xmath674 matrix which is zero everywhere except at the @xmath675-th entry which is @xmath590 and @xmath676 denotes the @xmath675-th entry of @xmath671 ( @xmath677 \\left [   j\\right ]   $ ] ) which is an @xmath674 array in the code @xcite .",
    "the remaining transition labels correspond to the counter variables @xmath678 and have been specified on the graph in figure [ foorloops2 ] . from node @xmath679 to node @xmath680 the net effect is:@xmath681",
    "@xmath682   = \\left [ \\begin{array } [ c]{cc}% \\vspace*{-0.5 in } & \\\\ 0 & i\\\\ \\vspace*{-0.5 in } & \\\\ 0 & 0\\\\ \\vspace*{-0.45 in } & \\end{array } \\right ]   , \\ ] ] and from node @xmath683 to node @xmath301 the net effect is:@xmath66@xmath684",
    "= \\left [ \\begin{array } [ c]{cc}% \\vspace*{-0.5 in } & \\\\ i & 0\\\\ \\vspace*{-0.5 in } & \\\\ a & 0\\\\ \\vspace*{-0.4 in } & \\end{array } \\right ]   .\\ ] ]",
    "[ proof of proposition [ milm - prop]]the proof is by construction .",
    "let @xmath685 where the @xmath45 s are compact polytopic sets .",
    "further , assume that each @xmath45 is characterized by a finite set of linear inequality constraints : @xmath686 let @xmath687 and consider the following sets:@xmath688 first , we prove that @xmath689 define @xmath690 binary vectors : @xmath691 @xmath692 according to the following rule : @xmath693 if and only if @xmath694 also define @xmath695 now , let @xmath696 then@xmath697 therefore , @xmath698 which by supposition , implies that @xmath699 this proves that @xmath700 now , let @xmath701 then , there exists @xmath702 such that @xmath703 hence , there exists @xmath692 such that @xmath704 and @xmath705 it follows from the definition of @xmath17 that @xmath706 this proves that @xmath707 we have shown that @xmath708 it remains to show that @xmath709 has a representation equivalent to @xmath710 define new variables @xmath711   ^{n}.$ ] then@xmath712{r}% \\left (   x , y\\right )   ~|~y=\\sum_{i=1}^{n}\\left (   a_{i}x+a_{i}u_{i}+b_{i}% + b_{i}v_{i}\\right )   , \\text { } \\mathbf{s}_{i}u_{i}+\\mathbf{s}_{i}x-\\mathbf{s}% _ { i}v_{i}-\\mathbf{s}_{i}\\leq0\\\\ \\sum_{i=1}^{n}v_{i}=-n+2,\\text { } u_{i}=xv_{i},\\text { } v_{i}\\in\\left\\ { -1,1\\right\\ }   : i\\in\\mathbb{z}\\left (   1,n\\right ) \\end{array } \\right\\ }   .\\vspace*{-0.05in}\\label{conditional polytopic ss}%\\ ] ] the nonlinear map @xmath713 can be represented by an affine transformation involving auxiliary variables @xmath714   ^{n},$ ] and @xmath715   ^{n},$ ] subject to a set of linear constraints , in the following way:@xmath283@xmath716 equivalently:@xmath203@xmath717 where @xmath718   ^{n}.$ ] since by assumption each @xmath45 is bounded , for all @xmath719 and all @xmath720 the quantities@xmath283@xmath721 exist , are finite and can be computed by solving @xmath722 linear programs given in ( [ lp ] ) ( @xmath723 and @xmath724 denote the @xmath725-th row of @xmath726 and @xmath727 respectively ) .",
    "let @xmath728 then @xmath709 as defined in ( [ conditional polytopic ss ] ) is equivalent to:@xmath66@xmath712{r}% \\left (   x , y\\right )   ~|~y=\\sum_{i=1}^{n}\\left (   a_{i}x+a_{i}u_{i}+b_{i}% + b_{i}v_{i}\\right )   , \\text { } \\left (   x , u_{i},v_{i}\\right )   \\in\\mathbf{h}% \\end{array } \\right\\ }   \\label{fmat}%\\ ] ] where @xmath729 satisfy ( [ hmat ] ) for some @xmath730   ^{n},$ ] and @xmath731   ^{n_{i}}\\}:$]@xmath732{rcllrll}% 0\\hspace{-0.06 in } & \\hspace{-0.06in}=\\hspace{-0.06 in } & \\hspace{-0.06in}% \\mathbf{s}_{i}u_{i}+\\mathbf{s}_{i}x-\\mathbf{s}_{i}v_{i}-\\mathbf{s}% _ { i}-\\underline{r}_{i}\\left (   w_{i}+\\mathbf{1}_{n_{i}}\\right )   \\vspace * { -0.05 in } &   & \\underline{z}_{i } & \\hspace{-0.06in}=\\hspace{-0.06 in } & \\hspace{-0.06in}x-\\overline{z}_{i}-\\boldsymbol{1}_{n},\\text { \\ } \\underline { z}_{i},\\overline{z}_{i}\\in\\left [   -1,1\\right ]   ^{n}\\\\ u_{i}\\hspace{-0.06 in } & \\hspace{-0.06in}=\\hspace{-0.06 in } & \\hspace { -0.06in}2\\underline{z}_{i}-x-\\left (   v_{i}-1\\right )   \\boldsymbol{1}% _ { n}\\vspace*{-0.05 in } &   & \\overline{z}_{i } & \\hspace{-0.06in}=\\hspace { -0.06 in } & \\hspace{-0.06in}\\left (   -v_{i}-1\\right )   \\boldsymbol{1}% _ { n}+\\overline{w}_{i},\\\\ \\underline{z}_{i}\\hspace{-0.06 in } & \\hspace{-0.06in}=\\hspace{-0.06 in } & \\hspace{-0.06in}\\left (   v_{i}-1\\right )   \\boldsymbol{1}_{n}+\\underline{w}_{i } & & \\sum_{i=1}^{n}v_{i } & \\hspace{-0.06in}=\\hspace{-0.06 in } & \\hspace { -0.06in}-n+2,\\text { } v_{i}\\in\\left\\ {   -1,1\\right\\ } \\end{array } \\hspace{-0.06in}\\right\\ }   \\hspace{-0.06in}\\label{hmat}%\\ ] ] the equality constraints that define the matrix @xmath52 are precisely the equalities in ( [ hmat ] ) , while the equality constraint in ( [ fmat ] ) defines the matrix @xmath46 .",
    "this completes the proof .",
    "[ proof of proposition [ abstraction]]first , consider the unreachability property .",
    "assume to the contrary , that @xmath12 does not satisfy unreachability w.r.t . @xmath163 .",
    "then , there exists a solution @xmath733 of @xmath734 and a positive integer @xmath735 such that @xmath736 , and @xmath737 .",
    "it follows from @xmath738 and @xmath29 that @xmath733 is also a solution of @xmath739 therefore , we have:@xmath740 however , @xmath741 contradicts the fact that @xmath742 satisfies safety w.r.t .",
    "proof of ftt is similar : let @xmath733 be any solution of @xmath9 .",
    "since @xmath733 is also a solution of @xmath743 it follows that there exists @xmath744 such that @xmath745 since @xmath746 is also an element of @xmath14 it follows that @xmath747 since by definition @xmath748 holds@xmath64 we must have @xmath749    [ proof of proposition [ ftt2]]note that ( [ softa2a1])@xmath402([softa2a3 ] ) imply that @xmath178 is negative - definite along the trajectories of @xmath186 except possibly for @xmath750 which can be zero when @xmath751 let @xmath752 be any solution of @xmath753 since @xmath178 is uniformly bounded on @xmath3 , we have:@xmath283 @xmath754 now , assume that there exists a sequence @xmath755 of elements from @xmath3 satisfying ( [ softa1 ] ) , but not reaching a terminal state in finite time .",
    "that is , @xmath756 @xmath757 then , it can be verified that if @xmath758 where @xmath249 is given by ( [ bnd on no .",
    "itrn . ] ) , we must have : @xmath759 which contradicts boundedness of @xmath760    [ proof of theorem [ bddness]]assume that @xmath35 has a solution @xmath761 where @xmath762 and @xmath763 let @xmath764 first , we claim that @xmath765 if @xmath766 we have @xmath767 and @xmath768 if @xmath769 we have @xmath770 and @xmath771 hence the claim .",
    "now , consider the @xmath231 case@xmath102 since @xmath178 is monotonically decreasing along solutions of @xmath186 we must have:@xmath66@xmath772 which contradicts ( [ inf g than sup])@xmath102 note that if @xmath219 and @xmath766 then ( [ inf l than sup ] ) holds as a strict inequality and we can replace ( [ inf g than sup ] ) with its non - strict version .",
    "next , consider case @xmath773 for which , @xmath178 need not be monotonic along the trajectories .",
    "partition @xmath41 into two subsets @xmath774 and @xmath775 such that @xmath776 and@xmath66@xmath777 now , assume that @xmath35 has a solution @xmath778 where @xmath779 and @xmath780 since @xmath781  and @xmath188 we have @xmath782 therefore,@xmath203 @xmath783 which contradicts ( [ inf g than sup])@xmath102 next , assume that @xmath35 has a solution @xmath784 where @xmath785 and @xmath786 in this case , regardless of the value of @xmath787 we must have @xmath788 @xmath789 implying that @xmath790 and hence , contradicting ( [ inf g than zero])@xmath102 note that if @xmath256 and either @xmath791 or @xmath792 then ( [ inf g than zero ] ) can be replaced with its non - strict version . finally , consider case @xmath793 .",
    "due to ( [ sup l than zero ] ) , @xmath178 is strictly monotonically decreasing along the solutions of @xmath753 the rest of the argument is similar to the @xmath231 case .    [ proof of corollary [ bddness and ftt]]it follows from ( [ three3 ] ) and the definition of @xmath163 that:@xmath794 it then follows from ( [ o69 ] ) and ( [ one1 ] ) that:@xmath795 hence , the first statement of the corollary follows from theorem [ bddness ] .",
    "the upperbound on the number of iterations follows from proposition [ ftt2 ] and the fact that @xmath796    [ proof of corollary [ safetygraphcor1]]the unreachability property follows directly from theorem [ bddness ] .",
    "the finite time termination property holds because it follows from ( [ arcwiselyap ] ) , ( [ sgc1 ] ) and ( [ multiplicativetheta ] ) along with proposition [ ftt2 ] , that the maximum number of iterations around every simple cycle @xmath10 is finite .",
    "the upperbound on the number of iterations is the sum of the maximum number of iterations over every simple cycle .    [ proof of lemma [ mipl_invariance_lemma]]define @xmath797 where @xmath798   ^{n},$ ] @xmath441 ^{n_{w}},$ ] @xmath799 recall that @xmath800 and that for all @xmath801 satisfying @xmath802 there holds : @xmath803 it follows from proposition [ prop : milmlyap ] that ( [ softa2 ] ) holds if:@xmath804 ^{n+n_{w}},\\text { } l_{4}x_{e}\\in\\left\\ {   -1,1\\right\\ }   ^{n_{v}}.\\vspace * { -0.1in}\\label{milp_1}%\\ ] ] recall from the @xmath35-procedure ( ( [ needs - s - procedure ] ) and ( [ s - procedure - sufficient ] ) ) that the assertion @xmath805 @xmath806   ^{n}$ ] holds if there exist nonnegative constants @xmath807 @xmath808 such that @xmath809where @xmath810 similarly , the assertion @xmath811 holds if there exist constants @xmath812 such that @xmath813 where @xmath814 applying these relaxations to ( [ milp_1 ] ) , we obtain sufficient conditions for ( [ milp_1 ] ) to hold:@xmath815 together with @xmath816 the above condition is equivalent to the lmis in lemma [ milp_invariance_lmi ] .",
    "[ proof of theorem [ thm : graphmodellmi]]since @xmath447 for all @xmath817 we have @xmath818 for all @xmath725 in the outgoing set of node @xmath819 this replaces condition ( [ sgc1 ] ) in corollary [ safetygraphcor1 ] .",
    "the first part of the theorem thus follows from corollary [ safetygraphcor1 ] and an application of the @xmath35-procedure relaxation technique in a similar fashion to the proof of lemma [ mipl_invariance_lemma ] .",
    "the second part of the theorem also follows from corollary [ safetygraphcor1 ] by noting that due to ( [ lgmlmi2 . ] ) , we have @xmath820 for every simple cycle @xmath821      r. alur , c. courcoubetis , n. halbwachs , t. a. henzinger , p .- h .",
    "ho x. nicollin , a. oliviero , j. sifakis , and s. yovine . the algorithmic analysis of hybrid systems , _ theoretical computer science _ , vol .",
    "138 , pp . 334 , 1995 .",
    "b. blanchet , p. cousot , r. cousot , j. feret , l. mauborgne , a. min , d. monniaux , and x. rival .",
    "design and implementation of a special - purpose static program analyzer for safety - critical real - time embedded software .",
    "lncs v. 2566 , pp .",
    "85108 , springer - verlag , 2002 .",
    "e. m. clarke , o. grumberg , h. hiraishi , s. jha , d.e .",
    "long , k.l .",
    "mcmillan , and l.a .",
    "verification of the future - bus+cache coherence protocol . in _",
    "formal methods in system design _ , 6(2):217232 , 1995 .",
    "p. cousot , and r. cousot .",
    "abstract interpretation : a unified lattice model for static analysis of programs by construction or approximation of fixpoints . in _",
    "4th acm sigplan - sigact symposium on principles of programming languages _ , pages 238252 , 1977 .",
    "p. cousot .",
    "proving program invariance and termination by parametric abstraction , lagrangian relaxation and semidefinite programming . in verification , model checking , and abstract interpretation",
    "6th international conference , vmcai 2005 .",
    "proceedings in lecture notes in computer science v. 3385 , 2005 .",
    "abstraction mechanisms accross the board :  a  short introduction . in _ a workshop on robustness , abstractions and computations _ ,",
    "philadelphia , march 18 , 2004 .",
    "presentations available at : http://web.mit.edu/feron/public/wkshop_pres            m. x. goemans , and d. p. williamson , improved approximation algorithms for maximum cut and satisfiability problems using semidefinite programming .",
    "_ journal of the association for computing machinery ( acm ) _",
    ", 42(6):11151145 , 1995 .",
    "g. naumovich , l. a. clarke , and l. j. osterweil .",
    "verification of communication protocols using data flow analysis .",
    "in _ proc .",
    "4-th acm sigsoft symposium on the foundation of software engineering _ , pages 93105 , 1996 .",
    "nesterov , h. wolkowicz , and y. ye .",
    "semidefinite programming relaxations of nonconvex quadratic optimization . in _",
    "handbook of semidefinite programming : theory , algorithms , and applications_. dordrecht , kluwer academic press , pp .",
    "361419 , 2000 .",
    "p. a. parrilo . minimizing polynomial functions . in _ algorithmic and quantitative real algebraic geometry_. dimacs series in discrete mathematics and theoretical computer science , v. 60 , pp .",
    "83 - 100 , 2003 .",
    "m. roozbehani , e. feron , and a. megretski .",
    "modeling , optimization and computation for software verification . in _",
    "hybrid systems : computation and control_. lecture notes in computer science , v. 3414 , pp .",
    "606622 , springer - verlag 2005 .",
    "m. roozbehani , a. megretski , e. frazzoli , and e. feron .",
    "distributed lyapunov functions in analysis of graph models of software . in hybrid systems",
    ": computation and control , springer lncs 4981 , pp 443 - 456 , 2008 ."
  ],
  "abstract_text": [
    "<S> the paper proposes a control - theoretic framework for verification of numerical software systems , and puts forward software verification as an important application of control and systems theory . </S>",
    "<S> the idea is to transfer lyapunov functions and the associated computational techniques from control systems analysis and convex optimization to verification of various software safety and performance specifications . </S>",
    "<S> these include but are not limited to absence of overflow , absence of division - by - zero , termination in finite time , presence of dead - code , and certain user - specified assertions . </S>",
    "<S> central to this framework are lyapunov invariants . </S>",
    "<S> these are properly constructed functions of the program variables , and satisfy certain properties****resembling those of lyapunov functions****along the execution trace . </S>",
    "<S> the search for the invariants can be formulated as a convex optimization problem . </S>",
    "<S> if the associated optimization problem is feasible , the result is a certificate for the specification .    </S>",
    "<S> software verification , lyapunov invariants , convex optimization . </S>"
  ]
}