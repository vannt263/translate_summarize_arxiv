{
  "article_text": [
    "ensuring accountability for security violations is essential in a wide range of settings .",
    "for example , protocols for authentication and key exchange  @xcite , electronic voting  @xcite , auctions  @xcite , and secure multiparty computation ( in the semi - honest model )  @xcite ensure desirable security properties if protocol parties follow their prescribed programs .",
    "however , if they deviate from their prescribed programs and a security property is violated , determining which agents should be held accountable and appropriately punished is important to deter agents from committing future violations .",
    "indeed the importance of accountability in information systems has been recognized in prior work @xcite .",
    "our thesis is that _ actual causation _",
    "( i.e. , identifying which agents actions caused a specific violation ) is a useful building block for accountability in decentralized multi - agent systems , including but not limited to security protocols and ceremonies  @xcite .",
    "causation has been of interest to philosophers and ideas from philosophical literature have been introduced into computer science by the seminal work of halpern and pearl  @xcite . in particular ,",
    "counterfactual reasoning is appealing as a basis for study of causation .",
    "much of the definitional activity has centered around the question of what it means for event @xmath0 to be an actual cause of event @xmath1 .",
    "an answer to this question is useful to arrive at causal judgments for specific scenarios such as `` john s smoking causes john s cancer '' rather than general inferences such as `` smoking causes cancer '' ( the latter form of judgments are studied in the related topic of type causation  @xcite ) .",
    "notably , hume  @xcite identified actual causation with counterfactual dependence ",
    "the idea that @xmath0 is an actual cause of @xmath1 if had @xmath0 not occurred then @xmath1 would not have occurred .",
    "while this simple idea does not work if there are independent causes , the counterfactual interpretation of actual causation has been developed further and formalized in a number of influential works ( see , for example ,  @xcite ) .",
    "even though applications of counterfactual causal analysis are starting to emerge in the fields of ai , model - checking , and programming languages , causation has not yet been studied in connection with security protocols and violations thereof . on the other hand",
    ", causal analysis seems to be an intuitive building block for answering some very natural questions that have direct relevance to accountability such as ( i ) _ why _ a particular violation occurred , ( ii ) _ what _ component in the protocol is blameworthy for the violation and ( iii ) _ how _ the protocol could have been designed differently to preempt violations of this sort .",
    "answering these questions requires an in - depth study of , respectively , explanations , blame - assignment , and protocol design , which are interesting problems in their own right , but are not the explicit focus of this paper .",
    "instead , we focus on a formal definition of causation that we believe formal studies of these problems will need .",
    "roughly speaking , explanations can be used to provide an _ account _ of the violation , _ blame assignment _ can be used to hold agents _ accountable _ for the violation , and protocol design informed by these would lead to protocols with better accountability guarantees .",
    "we further elaborate on explanations and blame - assignment in section  [ sec : domains ] .    formalizing actual causes as a building block for accountability in decentralized multi - agent systems raises new conceptual and technical challenges beyond those addressed in the literature on events as actual causes .",
    "in particular , prior work does not account for the program dynamics that arise in such settings .",
    "let us consider a simple protocol example . in the movie _ flight _",
    "@xcite , a pilot drinks and snorts cocaine before flying a commercial plane , and the plane goes into a locked dive in mid - flight .",
    "while the pilot s behavior is found to be deviant in this case  he does not follow the prescribed protocol ( program ) for pilots  it is found to not be an actual cause of the plane s dive .",
    "the actual cause was a deviant behavior by the maintenance staff  they did not replace a mechanical component that should have been replaced .",
    "ideally , the maintenance staff should have inspected the plane prior to take - off according to their prescribed protocol .",
    "this example is useful to illustrate several key ideas that influence the formal development in this paper .",
    "first , it illustrates the importance of capturing the _ actual interactions _ among agents in a decentralized multi - agent system with non - deterministic execution semantics .",
    "the events in the movie could have unfolded in a different order but it is clear that the actual cause determination needs to be done based on the sequence of events that happened in reality .",
    "for example , had the maintenance staff replaced the faulty component _ before _ the take - off the plane would not have gone into a dive .",
    "second , the example motivates us to hold accountable agents who exercise their choice to execute a deviant _ program _ that actually caused a violation .",
    "the maintenance staff had the choice to replace the faulty component or not where the task of replacing the component could consist of multiple steps .",
    "it is important to identify which of those steps were crucial for the occurrence of the dive .",
    "thus , we focus on formalizing _ program actions _ executed in sequence ( by agents ) as actual causes of violations rather than individual , independent events as formalized in prior work .",
    "finally , the example highlights the difference between deviance and actual causes  a difference also noted in prior work on actual causation .",
    "this difference is important from the standpoint of accountability . in particular",
    ", the punishment for deviating from the prescribed protocol could be suspension or license revocation whereas the punishment for actually causing a plane crash in which people died could be significantly higher ( e.g. , imprisonment for manslaughter ) .",
    "the first and second ideas , reflecting our program - based treatment , are the most significant points of difference from prior work on actual causation  @xcite while the third idea is a significant point of difference from prior work in accountability  @xcite .",
    "the central contribution of this paper is a formal definition of _ program actions as actual causes_. specifically , we define what it means for a set of program actions to be an actual cause of a violation .",
    "the definition considers a set of interacting programs whose concurrent execution , as recorded in a log , violates a trace property .",
    "it identifies a subset of actions ( program steps ) of these programs as an actual cause of the violation .",
    "the definition applies in two phases .",
    "the first phase identifies what we call _ lamport causes_. a lamport cause is a minimal prefix of the log of a violating trace that can account for the violation . in the second phase ,",
    "we refine the actions on this log by removing the actions which are merely _ progress enablers _ and obtain _ actual action causes_. the former contribute only indirectly to the cause by enabling the actual action causes to make progress ; the exact values returned by progress enabling actions are irrelevant .",
    "we demonstrate the value of this formalism in two ways .",
    "first , we prove that violations of a precisely defined class of safety properties always have an actual cause .",
    "thus , our definition applies to relevant security properties .",
    "second , we provide a cause analysis of a representative protocol designed to address weaknesses in the current public key certification infrastructure .",
    "moreover , our example illustrates that our definition cleanly handles the separation between joint and independent causes a recognized challenge for actual cause definitions  @xcite .",
    "in addition , we discuss how this formalism can serve as a building block for causal explanations and exoneration ( i.e. , soundly identifying agents who should not be blamed for a violation ) .",
    "we leave the technical development of these concepts for future work .",
    "the rest of the paper is organized as follows .",
    "section  [ sec : example ] describes a representative example which we use throughout the paper to explain important concepts .",
    "section  [ sec : definitions ] gives formal definitions for program actions as actual causes of security violations .",
    "we apply the causal analysis to the running example in section  [ sec : application ] .",
    "we discuss the use of our causal analysis techniques for providing explanations and assigning blame in section  [ sec : domains ] .",
    "we survey additional related work in section  [ sec : related ] and conclude in section  [ sec : conclusion ] .",
    "in this section we describe an example protocol designed to increase accountability in the current public key infrastructure .",
    "we use the protocol later to illustrate key concepts in defining causality .",
    "[ [ security - protocol ] ] security protocol + + + + + + + + + + + + + + + + +    consider an authentication protocol in which a user ( @xmath21 ) authenticates to a server ( @xmath31 ) using a pre - shared password over an adversarial network .",
    "@xmath21  sends its user - id to @xmath31  and obtains a public key signed by @xmath31 .",
    "however , @xmath21  would need inputs from additional sources when @xmath31  sends its public key for the first time in a protocol session to verify that the key is indeed bound to @xmath31 s identity .",
    "in particular , @xmath21  can verify the key by contacting multiple notaries in the spirit of _ perspectives _  @xcite .",
    "for simplicity , we assume @xmath21  verifies @xmath31 s public key with three authorized notaries@xmath41 , @xmath42 , @xmath43and accepts the key if and only if the majority of the notaries say that the key is legitimate . to illustrate some of our ideas",
    ", we also consider a parallel protocol where two parties ( @xmath22 and @xmath23 ) communicate with each other .",
    "we assume that the prescribed programs for @xmath31 , @xmath21 , @xmath41 , @xmath42 , @xmath43 , @xmath22 and @xmath23 impose the following requirements on their behavior : ( i ) @xmath31stores @xmath21 s password in a hashed form in a secure private memory location .",
    "( ii ) @xmath21  requests access to the account by sending an encryption of the password ( along with its identity and a timestamp ) to @xmath31  after verifying @xmath31 s public key with a majority of the notaries .",
    "( iii ) the notaries retrieve the key from their databases and attest the key correctly .",
    "( iv ) @xmath31  decrypts and computes the hashed value of the password .",
    "( v ) @xmath31  matches the computed hash value with the previously stored value in the memory location when the account was first created ; if the two hash values match , then @xmath31  grants access to the account to @xmath21 .",
    "( vi ) in parallel , @xmath22 generates and sends a nonce to @xmath23 .",
    "( vii ) @xmath23 generates a nonce and responds to @xmath22 .",
    "[ [ security - property ] ] security property + + + + + + + + + + + + + + + + +    the prescribed programs in our example aim to achieve the property that only the user who created the account and password ( in this case , @xmath21 ) gains access to the account .    [",
    "[ compromised - notaries - attack ] ] compromised notaries attack + + + + + + + + + + + + + + + + + + + + + + + + + + +    we describe an attack scenario and use it to illustrate nuances in formalizing program actions as actual causes .",
    "@xmath21executes its prescribed program .",
    "@xmath21  sends an access request to @xmath31 .",
    "an @xmath5  intercepts the message and sends a public key to @xmath21  pretending to be @xmath31 .",
    "@xmath21  checks with @xmath41 , @xmath42  and @xmath43  who falsely verify @xmath5 s public key to be @xmath31 s key .",
    "consequently , @xmath21  sends the password to @xmath5 .",
    "@xmath5  then initiates a protocol with @xmath31 and gains access to @xmath21 s account . in parallel , @xmath22sends a request to @xmath31 and receives a response from @xmath31 .",
    "following this interaction , @xmath22 forwards the message to @xmath23 .",
    "we assume that the actions of the parties are recorded on a _ log _ , say @xmath6 .",
    "note that this log contains a violation of the security property described above since @xmath5  gains access to an account owned by @xmath21 .",
    "first , our definition finds _ program actions as causes _ of violations . at a high - level ,",
    "as mentioned in the introduction , our definition applies in two phases . the first phase ( section  [ sec : definitions ] , definition  [ definition : cause1 ] ) identifies a minimal prefix ( phase  1 , _ minimality _ ) of the log that can account for the violation i.e. we consider all scenarios where the sequence of actions execute in the same order as on the log , and test whether it suffices to recreate the violation in the absence of all other actions ( phase  1 , _ sufficiency _ ) . in our example",
    ", this first phase will output a minimal prefix of log @xmath6 above . in this case , the minimal prefix will not contain interactions between @xmath22 and @xmath23 after @xmath31 has granted access to the @xmath5  ( the remaining prefix will still contain a violation ) .",
    "second , a nuance in defining the notion of _ sufficiency _ ( phase  1 , definition  [ definition : cause1 ] ) is to constrain the interactions which are a part of the actual cause set in a manner that is consistent with the interaction recorded on the log .",
    "this constraint on interactions is quite subtle to define and depends on how strong a coupling we find appropriate between the log and possible counterfactual traces in sufficiency : if the constraint is too weak then the violation does not reappear in all sequences , thus missing certain causes ; if it is too strong it leads to counter - intuitive cause determinations .",
    "for example , a weak notion of consistency is to require that each program locally execute the same prefix in sufficiency as it does on the log i.e. consistency w.r.t .",
    "program actions for individual programs .",
    "this notion does not work because for some violations to occur the _ order of interactions _ on the log among programs is important .",
    "a notion that is too strong is to require matching of the total order of execution of all actions across all programs .",
    "we present a formal notion of _ consistency _ by comparing log projections ( section  [ sec : support - defs ] ) that balance these competing concerns .",
    "third , note that while phase  1 captures a minimal prefix of the log sufficient for the violation , it might be possible to remove actions from this prefix which are merely required for a program execution to progress .",
    "for instance note that while all three notaries actions are required for @xmath21  to progress ( otherwise it would be stuck waiting to receive a message ) and the violation to occur , the actual message sent by one of the notaries is irrelevant since it does not affect the majority decision in this example .",
    "thus , separating out actions which are _ progress enablers _ from those which provide information that causes the violation is useful for fine - grained causal determination .",
    "this observation motivates the final piece ( phase  2 ) of our formal definition ( definition  [ definition : cause2a ] ) .",
    "finally , notice that in this example @xmath5 , @xmath41 , @xmath42 , @xmath43 , @xmath31 and @xmath22 deviate from the protocol described above .",
    "however , the deviant programs are not sufficient for the violation to occur without the involvement of @xmath21 , which is also a part of the causal set .",
    "we thus seek a notion of sufficiency in defining a set of programs as a joint actual cause for the violation .",
    "joint causation is also significant in legal contexts  @xcite .",
    "for instance , it is useful for holding liable a group of agents working together when none of them satisfy the cause criteria individually but together their actions are found to be a cause .",
    "the ability to distinguish between joint and independent ( i.e. , different sets of programs that independently caused the violation ) causes is an important criterion that we want our definition to satisfy .",
    "in particular , phase  2 of our definition helps identify independent causes .",
    "for instance , in our example , we get three different independent causes depending on which notary s action is treated as a progress enabler .",
    "our ultimate goal is to use the notion of actual cause as a building block for accountability  the independent vs. joint cause distinction is significant when making deliberations about accountability and punishment for liable parties .",
    "we can use the result of our causal determinations to further remove deviants whose actions are required for the violation to occur but might not be blameworthy ( section  [ sec : domains ] ) .",
    "we present our language model in section  [ sec : model ] , auxiliary notions in section  [ sec : support - defs ] , properties of interest to our analysis in section  [ sec : properties ] , and the formal definition of program actions as actual causes in section  [ sec : cause1 ] .      we model programs in a simple concurrent language , which we call @xmath7 .",
    "the language contains sequential expressions , @xmath1 , that execute concurrently in threads and communicate with each other through ` send ` and ` recv ` commands .",
    "terms , @xmath8 , denote messages that may be passed through expressions or across threads .",
    "variables @xmath9 range over terms .",
    "an expression is a sequence of actions , @xmath10 .",
    "an action may do one of the following : execute a primitive function @xmath11 on a term @xmath8 ( written @xmath12 ) , or send or receive a message to another thread ( written @xmath13 and @xmath14 , respectively ) .",
    "we also include very primitive condition checking in the form of @xmath15 .",
    "@xmath16    each action @xmath10 is labeled with a unique line number , written @xmath17 .",
    "line numbers help define traces later .",
    "we omit line numbers when they are irrelevant .",
    "every action and expression in the language evaluates to a term and potentially has side - effects .",
    "the term returned by action @xmath10 is bound to @xmath9 in evaluating @xmath18 in the expression @xmath19 .",
    "following standard models of protocols , @xmath20 and @xmath21 are untargeted in the operational semantics : a message sent by a thread may be received by any thread .",
    "targeted communication may be layered on this basic semantics using cryptography .",
    "for readability in examples , we provide an additional first argument to @xmath20 and @xmath21 that specifies the _ intended _",
    "target ( the operational semantics ignore this intended target ) .",
    "action @xmath13 always returns @xmath22 to its continuation .",
    "primitive functions @xmath11 model thread - local computation like arithmetic and cryptographic operations .",
    "primitive functions can also read and update a _ thread - local state _",
    ", which may model local databases , permission matrices , session information , etc .",
    "if the term @xmath8 in @xmath15 evaluates to a non - true value , then its containing thread gets stuck forever , else @xmath15 has no effect .",
    "we abbreviate @xmath23 to @xmath24 and @xmath25 to @xmath26 when @xmath9 is not free in @xmath1 . as an example",
    ", the following expression receives a message , generates a nonce ( through a primitive function @xmath27 ) and sends the concatenation of the received message and the nonce on the network to the intended recipient @xmath28 ( line numbers are omitted here ) .",
    "@xmath29 for the purpose of this paper , we limit attention to this simple expression language , without recursion or branching .",
    "our definition of actual cause is general and applies to any formalism of ( non - deterministic ) interacting agents , but the auxiliary definitions of log projection and the function @xmath30 introduced later must be modified .    [",
    "[ app : operational : semantics ] ] operational semantics + + + + + + + + + + + + + + + + + + + + +    the language @xmath7 s operational semantics define how a collection of _ threads _ execute concurrently .",
    "each thread @xmath31 contains a unique thread identifier @xmath32 ( drawn from a universal set of such identifiers ) , the executing expression @xmath1 , and a local store .",
    "a _ configuration _ @xmath33 models the threads @xmath34 executing concurrently .",
    "our reduction relation is written @xmath35 and defined in the standard way by interleaving small steps of individual threads ( the reduction relation is parametrized by a semantics of primitive functions @xmath11 ) .",
    "importantly , each reduction can either be internal to a single thread or a _ synchronization _ of a ` send ` in one thread with a ` recv ` in another thread .",
    "we make the locus of a reduction explicit by annotating the reduction arrow with a _ label _",
    "this is written @xmath37 .",
    "a label is either the identifier of a thread @xmath32 paired with a line number @xmath17 , written @xmath38 and representing an internal reduction of some @xmath12 in thread @xmath32 at line number @xmath17 , or a tuple @xmath39 , representing a synchronization between a ` send ` at line number @xmath40 in thread @xmath41 with a ` recv ` at line number @xmath42 in thread @xmath43 , or @xmath44 indicating an unobservable reduction ( of @xmath8 or @xmath15 ) in some thread .",
    "labels @xmath45 are called _ local labels _ , labels @xmath46 are called _ synchronization labels _ and labels @xmath44 are called _",
    "silent labels_.    an _ initial configuration _ can be described by a triple @xmath47 , where @xmath48 is a finite set of thread identifiers , @xmath49 and @xmath50 .",
    "this defines an initial configuration of @xmath51 threads with identifiers in @xmath48 , where thread @xmath32 contains the expression @xmath52 and the store @xmath53 . in the sequel",
    ", we identify the triple @xmath54 with the configuration defined by it .",
    "we also use a configuration s identifiers to refer to its threads .    given an initial configuration @xmath55 , a run is a finite sequence of labeled reductions @xmath56 .",
    "a pre - trace is obtained by projecting only the stores from each configuration in a run .",
    "let @xmath56 be a run and let @xmath57 be the store in configuration @xmath58 .",
    "then , the pre - trace of the run is the sequence @xmath59 .",
    "if @xmath60 , then the @xmath32th step is an unobservable reduction in some thread and , additionally , @xmath61 .",
    "a trace is a pre - trace from which such @xmath44 steps have been dropped .",
    "the trace of the pre - trace @xmath59 is the subsequence obtained by dropping all tuples of the form @xmath62 .",
    "traces are denoted with the letter @xmath8 .      to define actual causation",
    ", we find it convenient to introduce the notion of a log and the log of a trace , which is just the sequence of non - silent labels on the trace .",
    "a log is a sequence of labels other than @xmath44 .",
    "the letter @xmath6 denotes logs .",
    "given a trace @xmath63 , the log of the trace , @xmath64 , is the sequence of @xmath65 .",
    "( the trace @xmath8 does not contain a label @xmath66 that equals @xmath44 , so neither does @xmath64 . )",
    "we need a few more straightforward definitions on logs in order to define actual causation .    given a log @xmath6 and a thread identifier @xmath32 , the projection of @xmath6 to @xmath32 , written @xmath67 is the subsequence of all labels in @xmath6 that mention @xmath32 .",
    "formally , @xmath68    we call a log @xmath69 a _ projected prefix _ of the log @xmath6 , written @xmath70 , if for every thread identifier @xmath32 , the sequence @xmath71 is a prefix of the sequence @xmath67 .",
    "the definition of projected prefix allows the relative order of events in two different non - communicating threads to differ in @xmath6 and @xmath69 but lamport s happens - before order of actions  @xcite in @xmath69 must be preserved in @xmath6 .",
    "similar to projected prefix , we define projected sublog .",
    "we call a log @xmath69 a _ projected sublog _ of the log @xmath6 , written @xmath72 , if for every thread identifier @xmath32 , the sequence @xmath71 is a subsequence of the sequence @xmath67 ( i.e. , dropping some labels from @xmath67 results in @xmath71 ) .",
    "a _ property _ is a set of ( good ) traces and violations are traces in the complement of the set .",
    "our goal is to define the cause of a violation of a property .",
    "we are specifically interested in ascribing causes to violations of safety properties  @xcite because safety properties encompass many relevant security requirements .",
    "we recapitulate the definition of a safety property below . briefly",
    ", a property is safety if it is fully characterized by a set of finite violating prefixes of traces .",
    "let @xmath73 denote the universe of all possible traces .",
    "a property @xmath74 ( a set of traces ) is a safety property , written @xmath75 , if @xmath76 .    as we explain soon",
    ", our causal analysis ascribes thread actions ( or threads ) as causes .",
    "one important requirement for such analysis is that the property be closed under reordering of actions in different threads if those actions are not related by lamport s happens - before relation  @xcite . for properties that are not closed in this sense ,",
    "the _ global order _ between actions in a race condition may be a cause of a violation . whereas causal analysis of race conditions may be practically relevant in some situation , we limit attention only to properties that are closed in the sense described here .",
    "we call such properties reordering - closed or @xmath77 .",
    "two traces @xmath78 starting from the same initial configuration are called reordering - equivalent , written @xmath79 if for each thread identifier @xmath32 , @xmath80 .",
    "note that @xmath81 is an equivalence relation on traces from a given initial configuration .",
    "let @xmath82_\\sim$ ] denote the equivalence class of @xmath8 .",
    "a property @xmath74 is called reordering - closed , written @xmath83 , if @xmath84 implies @xmath82_\\sim \\subseteq p$ ] .",
    "note that @xmath83 iff @xmath85 .",
    "in the sequel , let @xmath86 denote the _ complement _ of a reordering - closed safety property of interest .",
    "( the subscript @xmath87 stands for `` violations '' . ) consider a trace @xmath8 starting from the initial configuration @xmath55 .",
    "if @xmath88 , then @xmath8 violates the property @xmath89 .",
    "a violation of the property @xmath89 is a trace @xmath88 .",
    "our definition of actual causation identifies a subset of actions in @xmath90 as the cause of a violation @xmath88 .",
    "the definition applies in two phases .",
    "the first phase identifies what we call _ lamport causes_. a lamport cause is a minimal projected prefix of the log of a violating trace that can account for the violation . in the second phase ,",
    "we refine the log by removing actions that are merely _ progress enablers _ ; the remaining actions on the log are the _ actual action causes_. the former contribute only indirectly to the cause by enabling the actual action causes to make progress ; the exact values returned by progress enabling actions are irrelevant .",
    "the following definition , called phase 1 , determines lamport causes .",
    "it works as follows .",
    "we first identify a projected prefix @xmath6 of the log of a violating trace @xmath8 as a potential candidate for a lamport cause .",
    "we then check two conditions on @xmath6 .",
    "the _ sufficiency _ condition tests that the threads of the configuration , when executed at least up to the identified prefix , preserving all synchronizations in the prefix , suffice to recreate the violation .",
    "the _ minimality _ condition tests that the identified lamport cause contains no redundant actions .",
    "[ definition : cause1 ] let @xmath88 be a trace starting from @xmath91 and @xmath6 be a projected prefix of @xmath64 , i.e. , @xmath92 .",
    "we say that @xmath6 is the lamport cause of the violation @xmath8 of @xmath86 if the following hold :    1 .",
    "[ sufficiency1 ] * ( sufficiency ) * let @xmath31 be the set of traces starting from @xmath93 whose logs contain @xmath6 as a projected prefix , i.e. , @xmath94 .",
    "then , every trace in @xmath31 has the violation @xmath86 , i.e. , @xmath95 .",
    "( because @xmath96 , @xmath31 is non - empty . ) 2 .   [ minimality1 ] * ( minimality ) * no proper prefix of @xmath6 satisfies condition  [ sufficiency1 ] .    at the end of phase 1 ,",
    "we obtain one or more minimal prefixes @xmath6 which contain program actions that are sufficient for the violation .",
    "these prefixes represent independent lamport causes of the violation . in the phase 2 definition",
    "below , we further identify a sublog @xmath97 of each @xmath6 , such that the program actions in @xmath97 are actual causes and the actions in @xmath98 are progress enabling actions which only contribute towards the _ progress _ of actions in @xmath97 that cause the violation .",
    "in other words , the actions not considered in @xmath97 contain all labels whose actual returned values are irrelevant .    briefly , here s how our phase 2 definition works .",
    "we first pick a candidate projected sublog @xmath97 of @xmath6 , where log @xmath6 is a lamport cause identified in phase 1 .",
    "we consider counterfactual traces obtained from initial configurations in which program actions omitted from @xmath97 are replaced by actions that do not have any effect other than enabling the program to progress ( referred to as no - op ) .",
    "if a violation appears in all such counterfactual traces , then this sublog @xmath97 is a good candidate . of all such good candidates , we choose those that are minimal .",
    "the key technical difficulty in writing this definition is replacing program actions omitted from @xmath97 with no - ops .",
    "we can not simply erase any such action because the action is expected to return a term which is bound to a variable used in the action s continuation .",
    "hence , our approach is to substitute the variables binding the returns of no - oped actions with arbitrary ( side - effect free ) terms @xmath8 .",
    "formally , we assume a function @xmath99 that for line number @xmath17 in thread @xmath32 suggests a suitable term @xmath100 that must be returned if the action from line @xmath17 in thread @xmath32 is replaced with a no - op . in our cause definition we universally quantify over @xmath101 , thus obtaining the effect of a no - op . for technical convenience , we define a syntactic transform called @xmath102 that takes an initial configuration , the chosen sublog @xmath97 and the function @xmath101 , and produces a new initial configuration obtained by erasing actions not in @xmath97 by terms obtained through @xmath101 .",
    "[ def : dummify ] let @xmath54 be a configuration and let @xmath97 be a log .",
    "let @xmath99 .",
    "the dummifying transform @xmath103 is the initial configuration @xmath104 , where for all @xmath105 , @xmath106 is @xmath52 modified as follows :    * if @xmath107 appears in @xmath52 but @xmath38 does not appear in @xmath97 , then replace @xmath108 with @xmath109 $ ] in @xmath52 . *",
    "if @xmath110 appears in @xmath52 but @xmath111 does not appear in @xmath97 and @xmath112 , then replace @xmath113 with @xmath114 $ ] in @xmath52 .",
    "we now present our main definition of actual causes .    [",
    "definition : cause2a ] let @xmath88 be a trace from the initial configuration @xmath54 and let the log @xmath92 be a lamport cause of the violation determined by definition  [ definition : cause1 ] .",
    "let @xmath97 be a projected sublog of @xmath6 , i.e. , let @xmath115 .",
    "we say that @xmath97 is the actual cause of violation @xmath8 of @xmath86 if the following hold :    1 .",
    "[ sufficiency2 ] ( * sufficiency * ) pick any @xmath101 .",
    "let @xmath116 and let @xmath31 be the set of traces starting from @xmath117 whose logs contain @xmath97 as a projected sublog , i.e. , @xmath118 .",
    "then , @xmath31 is non - empty and every trace in @xmath31 has the violation @xmath86 , i.e , @xmath95 .",
    "[ minimality2 ] ( * minimality * ) no proper sublog of @xmath97 satisfies condition  [ sufficiency2 ] .    at the end of phase  2 ,",
    "we obtain one or more sets of actions @xmath97 .",
    "these sets are deemed the independent actual causes of the violation @xmath8 .",
    "the following theorem states that for all safety properties that are re - ordering closed , the phase 1 and phase 2 definitions always identify at least one lamport and at least one actual cause .",
    "suppose @xmath86 is reordering - closed and the complement of a safety property , i.e. , @xmath119 and @xmath120 .",
    "then , for every @xmath88 : ( 1 )  our phase 1 definition ( definition  [ definition : cause1 ] ) finds a lamport cause @xmath6 , and ( 2 )  for every such lamport cause @xmath6 , the phase 2 definition ( definition  [ definition : cause2a ] ) finds an actual cause @xmath97 .",
    "( 1 )  pick any @xmath88 .",
    "we follow the phase 1 definition .",
    "it suffices to prove that there is a log @xmath92 that satisfies the sufficiency condition .",
    "since @xmath121 , there is a prefix @xmath122 of @xmath8 s.t . for all @xmath123 , @xmath124 .",
    "choose @xmath125 . since @xmath122 is a prefix of @xmath8 , @xmath126 . to prove sufficiency ,",
    "pick any trace @xmath127 s.t .",
    "@xmath128 . it suffices to prove @xmath129 . since @xmath128 , for each @xmath32 , @xmath130 for some @xmath131 .",
    "let @xmath132 be the ( unique ) subsequence of @xmath127 containing all labels from the logs @xmath133 .",
    "consider the trace @xmath134 .",
    "first , @xmath135 extends @xmath122 , so @xmath136 .",
    "second , @xmath137 because @xmath138 . since @xmath139 , @xmath129 .",
    "( 2 )  pick any @xmath88 and let @xmath6 be a lamport cause of @xmath8 as determined by the phase 1 definition . following the phase  2 definition",
    ", we only need to prove that there is at least one @xmath115 that satisfies the sufficiency condition .",
    "we choose @xmath140 .",
    "to show sufficiency , pick any @xmath101 . because @xmath141 , @xmath97 specifies an initial prefix of every @xmath52 and the transform @xmath142 has no effect on this prefix",
    "first , we need to show that at least one trace @xmath127 starting from @xmath143 satisfies @xmath144 . for this",
    ", we can pick @xmath145 .",
    "second , we need to prove that any trace @xmath127 starting from @xmath146 s.t .",
    "@xmath147 satisfies @xmath129 .",
    "pick such a @xmath127 .",
    "let @xmath122 be the prefix of @xmath8 corresponding to @xmath6 .",
    "then , @xmath148 for each @xmath32 .",
    "it follows immediately that for each @xmath32 , @xmath149 for some @xmath150 .",
    "let @xmath132 be the unique subsequence of @xmath127 containing all labels from traces @xmath151 .",
    "let @xmath134 .",
    "first , because for each @xmath32 , @xmath152 , @xmath153 trivially .",
    "because @xmath6 is a lamport cause , it satisfies the sufficiency condition of phase 1 , so @xmath154 . since @xmath120 , and @xmath135 extends @xmath122 , @xmath136 .",
    "second , @xmath155 because @xmath156 and both @xmath135 and @xmath127 are traces starting from the initial configuration @xmath146 . hence , by @xmath119 , @xmath129 .",
    "our phase 2 definition identifies a set of program actions as causes of a violation .",
    "however , in some applications it may be necessary to ascribe thread identifiers ( or programs ) as causes .",
    "this can be straightforwardly handled by lifting the phase 2 definition : a thread @xmath32 ( or @xmath52 ) is a cause if one of its actions appears in @xmath97 .",
    "[ definition : cause2b ] let @xmath97 be an actual cause of violation @xmath86 on trace @xmath8 starting from @xmath157 .",
    "we say that the set @xmath158 of thread identifiers is a cause of the violation if @xmath159 .",
    "[ [ remarks ] ] remarks + + + + + + +    we make a few technical observations about our definitions of cause .",
    "first , because lamport causes ( definition  [ definition : cause1 ] ) are projected _ prefixes _ , they contain all actions that occur before any action that actually contributes to the violation .",
    "many of actions in the lamport cause may not contribute to the violation intuitively . our actual cause definition filters out such `` spurious '' actions .",
    "as an example , suppose that a safety property requires that the value @xmath160 never be sent on the network .",
    "the ( only ) trace of the program @xmath161 violates this property . the lamport cause of this violation contains all four actions of the program , but it is intuitively clear that the two actions @xmath162 and @xmath163 do not contribute to the violation .",
    "indeed , the actual cause of the violation determined by definition  [ definition : cause2a ] does not contain these two actions ; it contains only @xmath164 and @xmath165 , both of which obviously contribute to the violation .",
    "second , our definition of dummification is based on a program transformation that needs line numbers .",
    "one possibly unwanted consequence is that our traces have line numbers and , hence , we could , in principle , specify safety properties that are sensitive to line numbers .",
    "however , our definitions of cause are closed under bijective renaming of line numbers , so if a safety property is insensitive to line numbers , the actual causes can be quotiented under bijective renamings of line numbers .",
    "third , our definition of actual cause ( definition  [ definition : cause2a ] ) separates actions whose return values are relevant to the violation from those whose return values are irrelevant for the violation .",
    "this is closely related to noninterference - like security definitions for information flow control , in particular , those that separate input presence from input content  @xcite .",
    "lamport causes ( definition  [ definition : cause1 ] ) have a trivial connection to information flow : if an action does not occur in any lamport cause of a violation , then there can not be an information flow from that action to the occurrence of the violation .",
    "in this section , we model an instance of our running example based on passwords ( section  [ sec : example ] ) in order to demonstrate our actual cause definition . as explained in section  [ sec : example ] , we consider a protocol session where @xmath31 , @xmath21 , @xmath22 , @xmath23  and multiple notaries interact over an adversarial network to establish access over a password - protected account .",
    "we describe a formal model of the protocol in our language , examine the attack scenario from section  [ sec : example ] and provide a cause analysis using the definitions from section  [ sec : definitions ] .",
    "we consider our example protocol with eight threads named \\{@xmath31 , @xmath21 , @xmath5 , @xmath41 , @xmath42 , @xmath43 , @xmath22 , @xmath23}. in this section , we briefly describe the protocol and the programs specified by the protocol for each of these threads .",
    "for this purpose , we assume that we are provided a function @xmath166 such that @xmath167 is the program that _ ideally should have been _ executing in the thread @xmath32 . for each @xmath32 , we call @xmath167 the _ norm _ for thread @xmath32 . the violation is caused because some of the executing programs are different from the norms .",
    "these actual programs , called @xmath168 as in section  [ sec : definitions ] , are shown later .",
    "the norms are shown here to help the reader understand what the ideal protocol is and also to facilitate some of the development in section  [ sec : domains ] .",
    "the appendix describes an expansion of this example with more than the eight threads considered here to illustrate our definitions better .",
    "the proof included in the appendix deals with timestamps and signatures .",
    "the norms in figure  [ fig : norms1 ] and the actuals in figure  [ fig : actuals1 ] assume that @xmath21 s account ( called @xmath169 in @xmath31 s program ) has already been created and that @xmath21 s password , @xmath170 is associated with @xmath21 s user i d , @xmath171 .",
    "this association ( in hashed form ) is stored in @xmath31 s local state at pointer @xmath172 .",
    "the norm for @xmath31 is to wait for a request from an entity , respond with its ( @xmath31 s ) public key , wait for a username - password pair encrypted with that public key and grant access to the requester if the password matches the previously stored value in @xmath31 s memory at @xmath172 . to grant access",
    ", @xmath31  adds an entry into a private access matrix , called @xmath74 .",
    "( a separate server thread , not shown here , allows @xmath21 to access its account if this entry exists in  @xmath74 . )",
    "the norm for @xmath21 is to send an access request to @xmath31 , wait for the server s public key , verify that key with three notaries and then send its password @xmath170 to @xmath31 , encrypted under @xmath31 s public key . on receiving @xmath31 s public key",
    ", @xmath21 initiates a protocol with the three notaries and accepts or rejects the key based on the response of a majority of the notaries . for simplicity , we omit a detailed description of this protocol between @xmath21 and the notaries that authenticates the notaries and ensures freshness of their responses . these details are included in our appendix . in parallel , the norm for @xmath22  is to generate and send a nonce to @xmath23 . the norm for @xmath23 is to receive a message from @xmath22 , generate a nonce and send it to @xmath22 .",
    "each notary has a private database of _",
    "( public_key , principal ) _ tuples .",
    "the notaries norms assume that this database has already been created correctly .",
    "when @xmath21 sends a request with a public key , the notary responds with the principal s identifier after retrieving the tuple corresponding to the key from its database .      the programs in this example use several primitive functions @xmath11 . @xmath173 and @xmath174 denote encryption and decryption of message @xmath175 with key @xmath176 and @xmath177 respectively .",
    "@xmath178 generates the hash of term @xmath175 .",
    "@xmath179 denotes message @xmath175 signed with the key @xmath176 , paired with @xmath175 in the clear . @xmath180 and @xmath181 denote the public and private keys of thread @xmath32 , respectively . for readability",
    ", we include the intended recipient @xmath32 and expected sender @xmath28 of a message as the first argument of @xmath182 and @xmath183 expressions .",
    "as explained earlier , @xmath32 and @xmath28 are ignored during execution and a network adversary , if present , may capture or inject any messages .",
    "the security property of interest to us is that if at time @xmath184 , a thread @xmath176 is given access to account @xmath185 , then @xmath176 owns @xmath185 .",
    "specifically , in this example , we are interested in case @xmath186 and @xmath187 .",
    "this can be formalized by the following logical formula , @xmath89 : @xmath188 here , @xmath189 is the state of the access control matrix @xmath74 for @xmath31 at time @xmath184 .",
    "note that , if any two of the three notaries had attested the @xmath5 s key to belong to @xmath31 , the violation would have still happened .",
    "consequently , we may expect three independent program causes in this example : \\{@xmath5 , @xmath21 , @xmath31 , @xmath41 , @xmath42 } with the action causes @xmath97 as shown in figure  [ fig : log1](c ) , \\{@xmath5 , @xmath21 , @xmath31 , @xmath41 , @xmath43 } with the actions @xmath190 , and \\{@xmath5 , @xmath21 , @xmath31 , @xmath42 , @xmath43 } with the actions @xmath191 where @xmath190 and @xmath191 can be obtained from @xmath97 ( figure  [ fig : log1](c ) ) by considering actions for \\{@xmath41 , @xmath43 } and \\{@xmath42 , @xmath43 } respectively , instead of actions for \\{@xmath41 , @xmath42}. the following theorem states that our definitions determine exactly these three independent causes .    [ theorem - passwords2 ] let @xmath192 , and @xmath193 and @xmath168 be as described above .",
    "let @xmath8 be a trace from @xmath157 such that @xmath194 for each @xmath105 matches the corresponding log projection from figures  [ fig : log1](a ) and  [ fig : log2 ] .",
    "then , definition  [ definition : cause2b ] determines three possible values for the program cause @xmath195 of violation @xmath88 : \\{@xmath5 , @xmath21 , @xmath31 , @xmath41 , @xmath42 } , \\{@xmath5 , @xmath21 , @xmath31 , @xmath41 , @xmath43 } , and \\{@xmath5 , @xmath21 , @xmath31 , @xmath42 , @xmath43 } where the corresponding actual causes are @xmath196 and @xmath191 respectively .",
    "it is instructive to understand the proof of this theorem , as it illustrates our definitions of causation .",
    "we verify that our phase  1 and phase  2 definitions ( definitions  [ definition : cause1 ] ,  [ definition : cause2a ] ,  [ definition : cause2b ] ) yield exactly the three values for @xmath195 mentioned in the theorem .",
    "we show that any @xmath6 whose projections match those shown in figure  [ fig : log1](b ) satisfies sufficiency and minimality . from figure",
    "[ fig : log1](b ) , such an @xmath6 has no actions for @xmath23 , @xmath24 , @xmath44 , @xmath32 and only those actions of @xmath22 that are involved in synchronization with @xmath31 . for all other threads ,",
    "the log contains every action from @xmath8 .",
    "the intuitive explanation for this @xmath6 is straightforward : since @xmath6 must be a ( projected ) _ prefix _ of the trace , and the violation only happens because of @xmath197 in the last statement of @xmath31 s program , every action of every program before that statement in lamport s happens - before relation must be in @xmath6 .",
    "this is exactly the @xmath6 described in figure  [ fig : log1](b ) .",
    "formally , following the statement of sufficiency , let @xmath31 be the set of traces starting from @xmath198 ( figure  [ fig : actuals1 ] ) whose logs contain @xmath6 as a projected prefix . pick any @xmath199 .",
    "we need to show @xmath129 .",
    "however , note that any @xmath127 containing all actions in @xmath6 must also add @xmath200 to @xmath201 , but @xmath202 .",
    "hence , @xmath129 .",
    "further , @xmath6 is minimal as described in the previous paragraph .",
    "phase 2 ( definitions  [ definition : cause2a ] ,  [ definition : cause2b ] ) determines three independent program causes for @xmath195 : \\{@xmath5 , @xmath21 , @xmath31 , @xmath41 , @xmath42 } , \\{@xmath5 , @xmath21 , @xmath31 , @xmath41 , @xmath43 } , and \\{@xmath5 , @xmath21 , @xmath31 , @xmath42 , @xmath43 } with the actual action causes given by @xmath196 and @xmath191 , respectively in figure  [ fig : log1](c ) .",
    "these are symmetric , so we only explain why @xmath97 satisfies definition  [ definition : cause2a ] .",
    "( for this @xmath97 , definition  [ definition : cause2b ] immediately forces @xmath203 . )",
    "we show that ( a ) @xmath97 satisfies sufficiency , and ( b ) no proper _ sublog _ of @xmath97 satisfies sufficiency ( minimality ) .",
    "note that @xmath97 is obtained from @xmath6 by dropping @xmath43 , @xmath22 and @xmath23 , and all their interactions with other threads .",
    "we start with ( a ) .",
    "let @xmath97 be such that @xmath204 matches figure  [ fig : log1](c ) for every @xmath32 .",
    "fix any dummifying function @xmath101 .",
    "we must show that any trace originating from @xmath205 , whose log contains @xmath97 as a projected sublog , is in @xmath86 .",
    "additionally we must show that there is such a trace .",
    "there are two potential issues in mimicking the execution in @xmath97 starting from @xmath206  first , with the interaction between @xmath21 and @xmath43 and , second , with the interaction between @xmath31 and @xmath22 .",
    "for the first interaction , on line  7 , @xmath207 ( figure  [ fig : actuals1 ] ) synchronizes with @xmath43 according to @xmath6 , but the synchronization label does not exist in @xmath97 .",
    "however , in @xmath208 , the @xmath14 on line  10 in @xmath207 is replaced with a dummy value , so the execution from @xmath208 progresses .",
    "subsequently , the majority check ( assertion [ b ] ) succeeds as in @xmath6 , because two of the three notaries ( @xmath41 and @xmath42 ) still attest the @xmath5 s key .",
    "a similar observation can be made about the interaction between @xmath31 and @xmath22 .",
    "line  4 , @xmath209 ( from figure  [ fig : log1](b ) ) synchronizes with @xmath22 according to @xmath6 , but this synchronization label does not exist in @xmath97 .",
    "however , in @xmath208 , the @xmath14 on line  4 in @xmath209 is replaced with a dummy value , so the execution from @xmath208 progresses .",
    "subsequently , @xmath31 still adds permission for the @xmath5 .",
    "next we prove that every trace starting from @xmath208 , whose log contains @xmath97 ( figure  [ fig : log1](c ) ) as a projected _ sublog _ , is in @xmath86 .",
    "fix a trace @xmath127 with log @xmath69 .",
    "assume @xmath69 coincides with @xmath97 .",
    "we show @xmath129 as follows :    1 .",
    "since the synchronization labels in @xmath69 are a superset of those in @xmath97 , @xmath31 must execute line  10 of its program @xmath210 in @xmath127 .",
    "after this line , the access control matrix @xmath201 contains @xmath211 for some @xmath212 .",
    "when @xmath209 writes @xmath213 to @xmath201 at line  10 , then @xmath212 is the third component of a tuple obtained by decrypting a message received on line  7 .",
    "since the synchronization projections on @xmath69 are a superset of @xmath97 , and on @xmath97 @xmath214 synchronizes with @xmath215 , @xmath212 must be the third component of an encrypted message sent on line  10 of @xmath216 .",
    "the third component of the message sent on line  10 by @xmath5 is exactly the term `` @xmath5 '' .",
    "( this is easy to see , as the term `` @xmath5 '' is hardcoded on line 9 . )",
    "hence , @xmath217 .",
    "this immediately implies that @xmath129 since @xmath218 , but @xmath219 .",
    "last , we prove ( b )  that no proper subsequence of @xmath97 satisfies sufficiency. note that @xmath97 ( figure  [ fig : log1](c ) ) contains exactly those actions from @xmath6 ( figure  [ fig : log1 ] ) on whose returned values the last statement of @xmath31 s program ( figure  [ fig : actuals1 ] ) is data or control dependent .",
    "consequently , all of @xmath97 as shown is necessary to obtain the violation .    in particular ,",
    "observe that if labels for @xmath31 ( @xmath220 ) are not a part of @xmath190 , then @xmath31 s labels are not in @xmath208 and , hence , on any counterfactual trace @xmath31 can not write to @xmath201 , thus precluding a violation .",
    "therefore , the sequence of labels in @xmath220 are required in the actual cause .    by sufficiency , for any @xmath101",
    ", the log of trace @xmath127 of @xmath208 must contain @xmath97 as a projected _ sublog_.",
    "this means that in @xmath127 , the assertion [ a ] of @xmath209 must succeed and , hence , on line 7 , the correct password @xmath221 must be received by @xmath31 , independent of @xmath101 .",
    "this immediately implies that @xmath5 s action of sending that password must be in @xmath97 , else some dummified executions will have the wrong password sent to @xmath31 and the assertion [ a ] will fail .    extending this logic further",
    ", we now observe that because @xmath5 forwards a password received from @xmath21 ( line 4 of @xmath222 ) to @xmath31 , the send action of @xmath223 will be in @xmath97 ( otherwise , some dummifications of line 4 of @xmath216 will result in the wrong password being sent to @xmath31 , a contradiction ) .",
    "since @xmath223 s action is in @xmath97 and @xmath69 must contain @xmath97 as a _ sublog _ , the majority check of @xmath207 must also succeed .",
    "this means that at least two of @xmath224 must send the confirmation to @xmath21 , else the dummification of lines 8  10 of @xmath225 will cause the assertion [ b ] to fail for some @xmath101 .",
    "since we are looking for a minimal _ sublog _ therefore we only consider the send actions from two threads i.e. @xmath226 . at this point",
    "we have established that each of the labels as shown in figure  [ fig : log1](c ) are required in @xmath97 .",
    "hence , @xmath227 ."
  ],
  "abstract_text": [
    "<S> protocols for tasks such as authentication , electronic voting , and secure multiparty computation ensure desirable security properties if agents follow their prescribed programs . </S>",
    "<S> however , if some agents deviate from their prescribed programs and a security property is violated , it is important to hold agents _ accountable _ by determining which deviations actually caused the violation . </S>",
    "<S> motivated by these applications , we initiate a formal study of _ program actions as actual causes_. specifically , we define in an interacting program model what it means for a set of program actions to be an actual cause of a violation . </S>",
    "<S> we present a sound technique for establishing program actions as actual causes . </S>",
    "<S> we demonstrate the value of this formalism in two ways . </S>",
    "<S> first , we prove that violations of a specific class of safety properties always have an actual cause . </S>",
    "<S> thus , our definition applies to relevant security properties . </S>",
    "<S> second , we provide a cause analysis of a representative protocol designed to address weaknesses in the current public key certification infrastructure .    </S>",
    "<S> security protocols , accountability , audit , causation </S>"
  ]
}