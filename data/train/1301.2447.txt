{
  "article_text": [
    "in the last decades , practicable and reliable code clone detection tools  @xcite have been developed .",
    "these tools are able to find different kinds of clones , which are all important in some situations .",
    "developers , who are interested in the removal of clones by refactoring  @xcite , want to know whether and how a clone can be eliminated .",
    "a refactoring is a change to the source code that alters ( typically improves ) the design , but does not change the observable behavior of the software .",
    "we present an approach that gives precise refactoring suggestions depending on the set of available refactorings .",
    "fowler et al . provided in @xcite a comprehensive catalog of such refactorings .",
    "a developer may use for example the rename method refactoring to change the name of a method to a more expressive one .",
    "a tool that offers this refactoring has to make sure that the name of the method is not only changed in the declaration of the method , but as well at every method invocation .",
    "as the same name might be used for different methods in different scopes , a textual `` search and replace '' is not guaranteed to keep the observable behavior intact .",
    "the tool needs to know the abstract syntax tree of the code including resolved bindings to methods .",
    "jtransformer  @xcite provides this information for java programs as facts on which logic programs can reason .",
    "_ identical _ clones can be removed by extract method , extract class , pull up method refactorings together with the appropriate adaptations at the call side .",
    "if the clones have some _ differences _ , we suggest to start with the program dependence graphs  @xcite ( pdg ) for the clone instances , to identify the statements that are _ equal or unifiable _ ( i.e. can be made equal through refactorings ) and finally rearrange the control flow based on the pdg so that all non - unifiable statements are separated .",
    "the example in the figures  1 to 3 illustrates our approach .",
    "we start with two potential clone candidates . these may have been found with one of the existing clone detection tools like simian @xcite or scorpio @xcite . for each of the clone candidates we build the pdg .",
    "such a pdg consists of one node for every statement and of two kind of edges representing control and data dependencies .",
    "there is a _ control dependency _ from a control statement to all directly enclosed statements . in our example",
    "the for - loop in line 4 controls the execution of line 5 and 6 while the execution of line 7 in turn is controlled by line 6 .",
    "there is a _ data dependency _ from a statement @xmath0 to a statement @xmath1 , if @xmath0 writes a variable that is read in @xmath1 and there is at least one possible execution on which @xmath0 is the last statement writing this variable before reaching @xmath1 . in our example",
    "there is a data dependency from statement 2 to statement 9 as the for - loop might not be executed .",
    "in extension to the established definition our data dependencies take as well method invocations into account .",
    "if a method returns a value without performing side effects we consider the method invocation only as a _",
    "read access _ to the object .",
    "if the method does have side effects , we consider the invocation as a _ write and read access _ to the object .",
    "the pdg in figure [ fig_pdg ] gives an example of a data dependency resulting from this approach .",
    "this is still a heuristic way to transfer the concept of a data dependency to the object - oriented setting .",
    "deeper analysis could label the data dependencies with a more precise characterization of the state that is changed by the method .",
    "in addition alias analysis could find additional hidden dependencies as a change to one object via one variable is a change to the object behind its aliases .",
    "once we have build the pdgs of the clone candidates , they are compared and nodes for equal or unifiable statements are mapped to each other . whether two statements are unifiable depends on the refactorings that are considered .    .",
    "the invocation of add in line  7 is interpreted as a write on adults leading to the data dependency from 7 to 9 .",
    "the invocation of getage in line  5 is interpreted as a read on p , so that there is no data dependency from 5 to 7 .",
    "the extra statement in line  3 has no data dependencies , so that it can freely be moved below node  1 .",
    "the data dependencies of the non - unifiable statement in line  5 forbid reordering but allow extracting into a lambda expression.,width=355 ]",
    "the rename refactoring allows us to consistently change the names of local variables and parameters or even fields and methods",
    ". therefore we take at least the rename refactoring into account .",
    "our example in figure  [ fig_clones ] and [ fig_refactored ] illustrates this .",
    "if we consider further refactorings more statements become unifiable although some at the price of complexer parameter lists .",
    "differences in literals can be removed with the introduce parameter refactoring .",
    "the generalize types refactoring @xcite allows to find differences in type declarations that are more specific than required by the usage of the declared object .",
    "if a type generalization is not possible e.g. because different specific return types are required by the callers of a method , the refactoring introduce type parameter can help .",
    "finally method signatures that differ just in the order of parameters can be unified with the reorder parameters refactoring .",
    "in our example the difference between line  5 and line  14 can not be removed and the statement in line  3 has no counterpart in the second method .",
    "these differences require changes to the control flow .",
    "the pdg contains only as much information about the control flow as is relevant for the state of the variables at each line of the method .",
    "therefore a node can freely be reordered ( directly ) below the node that controls it as long as the order of nodes with data dependencies is preserved .",
    "this allows us to separate non - unifiable statement from unifiable statements , as it is the case with node  3 in our example .",
    "another possibility to `` remove '' non - unifiable statements is to use the extract method refactoring .",
    "a group of contiguous statements is extractable if the corresponding nodes have to other statements only outgoing data dependencies for at most one variable and no outgoing control dependency  @xcite . in the pdg in figure  [ fig_pdg ] the nodes  5 , 6 , and 7 together as well as",
    "the node  5 on its own is extractable .",
    "the extract method refactoring is especially helpful if the clones are in classes that are siblings in the class hierarchy .",
    "if in this case all differences can be extracted the remaining method can be pulled up to a common ancestor of the siblings .",
    "this sequence of refactorings is called form template method and is explained in detail in @xcite .",
    "if the classes containing the clones are unrelated the strategy design pattern in combination with template method may be used @xcite .",
    "but , if there is only one or two differences and these differences are small , these pattern do not pull their weight and the introduction of lambda expressions is the method of choice .",
    "the preconditions for the extract lambda expression refactoring are the same as for extract method .",
    "our example illustrates the use of lambda expressions to extract the difference between line  5 and 14 .",
    "clonedifferentiator  @xcite analyses and visualises the differences between the pdg of clones .",
    "the refactorings extract method , introduce parameter and the use of generics are suggested .",
    "aries  @xcite calculates metrics to decide whether a refactoring is appropriate . for example",
    "extract method is only recommended when the fragment refers to only a few variables outside the fragment .",
    "we described a process that derives for related clones one ( or more ) ways to remove the clones , by applying a series of refactorings .",
    "the parameters of the refactorings can be precisely ( although not necessarily uniquely ) derived from the context so that a tool can present precise refactoring suggestions to the developer .",
    "elements of the presented approach such as the generation of the pdg are implemented as part of cultivate @xcite .",
    "the approach to search for a sequence of refactoring steps by exploring the different possibilities to unify statements and control flow naturally arises from the problem . as we start with clone candidates found by existing tools , the amount of data to be processed is limited : we know already which methods to compare and do not have to compare all possible method pairs .",
    "in addition typically only a few statements in the methods are unifiable , so that the graph matching is not as expensive as in the general case .",
    "f.  tip , a.  kieun and d.  bumer , _",
    "refactoring for generalization using type constraints_.1em plus 0.5em minus 0.4em18th conference on object - oriented programing , systems , languages , and applications , 1326 , 2003 ."
  ],
  "abstract_text": [
    "<S> cloned code is one of the most important obstacles against consistent software maintenance and evolution . </S>",
    "<S> although today s clone detection tools find a variety of clones , they do not offer any advice how to remove such clones . </S>",
    "<S> we explain the problems involved in finding a sequence of changes for clone removal and suggest to view this problem as a process of stepwise unification of the clone instances . </S>",
    "<S> consequently the problem can be solved by backtracking over the possible unification steps .    </S>",
    "<S> , backtracking , clone analysis , refactoring , program dependence graph , lambda expression </S>"
  ]
}