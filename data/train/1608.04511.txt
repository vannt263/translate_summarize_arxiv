{
  "article_text": [
    "patrolling is continuously traveling through an environment in order to supervise or guard it .",
    "although mostly used to refer to humans guarding an area , the term patrolling is also used to describe surveying through a digital , virtual environment .",
    "consider , for example , the task of repeatedly reading web pages from the world - wide - web in order to keep an updated database representing the links between pages , possibly for the purpose of later retrieval of pages in an a accurate and prompt manner .",
    "these problems exhibit similarities , in the sense that they can be represented as traveling through the vertices of a graph .",
    "but there are also differences : a physical area is usually fixed in size , whereas the virtual area is , in general , prone to constant change .",
    "the number of human guards is , generally , fixed for the particular area being patrolled , while the number of software agents or `` bots '' performing a large scale patrolling task may be subject to change as well .    partitioning a graph into similar sized components is an important and difficult task in many areas of science and engineering . to name few examples , we can mention the partitioning of a netlist of an electronic vlsi design @xcite , the need for clustering in data mining @xcite , and the design of systems that balance the load on computer resources in a networked environment @xcite .",
    "the general graph partition problem is loosely defined as dividing a graph into disjoint , connected components , such that the components are _ similar _ to each other in some sense .",
    "practical considerations impose additional constrains .",
    "for example , an important problem , known as the _ graph k - cut _ , requires a partition where the sum of the _ weights _ of vertices belonging to each component _ _ is more or less equal , and additionally , the number and/or the sum of weights of edges that _ connect disjoint components _ is minimized @xcite .",
    "the _ k - cut _ problem can model the distribution of tasks between computers on a network , while minimizing communication requirements between them .    in this work",
    "we define a patrolling strategy that fairly divides the work of patrolling the environment among several a(ge)nts by partitioning it into regions of more or less the same size .",
    "we have no constraints on edges connecting different components , but we impose strict restrictions on our patrolling agents in search for a heuristic multi - agent graph partitioning algorithm that may continuously run in the background of a host application .",
    "we are interested in programming the same behavior for each individual ant - like agent , which should be very simple in terms of resources , hardware or communications .",
    "furthermore the agents have no i d s , hence are part of a team of units that are anonymous and indistinguishable to each other .",
    "our a(ge)nts should have very little knowledge about the system or environment they operate in , have no awareness on the size or shape of the graph , no internal memory to accumulate information , nor a sense of the number and locations of other agents active in the system .",
    "these limitations mean that such a multi agent process has inherent scalability ; the environment might be large , complex , and subject to changes , in terms of vertices , edges and even the number of agents , and our simple agents should still be able to patrol it , while also evolving towards , and ultimately finding balanced partitions , if such partitions exist . to simplify the discussion , we will think of a graph to be partitioned as a planar area , and the task at hand will be to partition the area into regions of more or less the same size . the area is modeled as a grid , where each vertex is a unit area , thus a balanced partition should have components of roughly the same number of vertices . in our scheme , agents are each given the task to _ patrol _ and define a region of their own , and have the ability to expand their region via conquests . like ants ,",
    "our agents leave pheromone marks on their paths . the marks decay with time and are subsequently used as cues by all the agents to make decisions about their patrolling route and about the possibility to expand their region . by assumption , each agent operates _ locally _ , thus it can sense levels of pheromones or leave pheromone marks on the vertex it is located , on its edges and on adjacent vertices .    while patrolling its region , an agent visits a vertex and reads the intensity of pheromone marks that remain from previous visits",
    "it then uses the reading , and the known rate of pheromone decay , to calculate the vertex s idle - time  the time that passed since the previous visit . using the decaying pheromone mark",
    "we can chose a patrolling rule according to which the agents visit the vertices of their region in repetitive cycles , each vertex being marked with a pheromone once on each cycle .",
    "the patrolling process hence ensures that the idle - time measured by agents on visits to their region s vertices is the same , effectively encoding their region s _ cover time _",
    " the time that takes for an a(ge)nt to complete a full patrolling cycle  and therefore it can also be used to estimate the region s size : the shorter the cover time , the smaller the region .",
    "we assume that each agent detects pheromones without being able to distinguish between them , except for recognizing its own pheromone .",
    "when an a(ge)nt hits a border edge  an edge that connects its region with one that is patrolled by another agent - it can use the neighbor s idle - time ( encoded in its pheromone marks ) to calculate the size of the neighboring region , and thereby decide whether to try to conquer the vertex `` on the other side of the border '' .",
    "this causes an effect that mimics pressure equalization between gas - filled balloons : at two vertices on opposing ends of a border edge , the agent that hits the border more frequently is the agent with a shorter cover time ( patrolling the smaller region ) hence it may attempt a conquest .",
    "we define that in a balanced partition , any pair of neighboring regions have a size difference of at most one vertex .",
    "this means that for a graph @xmath0 and @xmath1 agents , our partitioning heuristics ensures a worst case difference of @xmath2 vertices between the largest and smallest of the regions , once a balanced partition is reached .",
    "for example in a graph of 1 million vertices ( e.g. database entries , each representing a web page ) and 10 agents ( network bots patrolling the pages ) , this difference is truly negligible",
    ". additionally , the length of the patrolling path is predetermined , and is proportional to the size of the region being patrolled , therefore when a balanced partition is reached , the algorithm guarantees that the idleness of any of the vertices of the graph is bounded by a number of steps equal to @xmath3 , about twice the size of the largest possible region ( note that @xmath4denotes the number of vertices in the graph @xmath0 ) .    in figure",
    "[ fig : evolution intro ] one can see a series of snapshots depicting 8 patrolling agents working to partition a 50x50 grid .",
    "the first snapshot shows an early phase of the joint patrolling algorithm , where agents already captured some of the vertices around their initial random locations , in the second , the area is almost covered and most of the vertices of the graph are being patrolled , the third exhibits a phase when all the area is covered but the regions are not balanced , and finally , the last snapshot shows a balanced partition that the system evolved into .",
    "evolution of a 50x50 grid graph partitioning by 8 a(ge)nts , title=\"fig : \" ] evolution of a 50x50 grid graph partitioning by 8 a(ge)nts , title=\"fig : \" ]   evolution of a 50x50 grid graph partitioning by 8 a(ge)nts , title=\"fig : \" ] evolution of a 50x50 grid graph partitioning by 8 a(ge)nts , title=\"fig : \" ]    this figure exhibits typical stages in the evolution of such a system , for which balanced partitions exist , and the environment graph remains stationary for a time long enough for agents to find one of them .",
    "often , the agents will relatively quickly find a partition that covers the graph , and is _ close _ to being balanced . then",
    ", on stationary graphs , they may spend a rather long time to reach a perfectly balanced partition . in a time",
    "varying environment the system will continuously adapt to the changing conditions .",
    "the concept of partitioning a graph with a(ge)nts patrolling a region and exerting pressure on neighboring regions was first presented by elor and bruckstein in @xcite .",
    "they proposed a patrol algorithm named bdfs balloon dfs  and this work is a follow up research on this problem . according to bdfs , an agent patroling a smaller region conquers vertices from a neighboring larger region . to achieve the goal of patrolling an area",
    ", bdfs uses a variation of multi - level depth - first - search ( mldfs ) , an algorithm presented by wagner , lindenbaum and bruckstein in @xcite .",
    "the task of the mldfs too , was to distribute the work of covering `` tiles on a floor '' among several identical agents .",
    "the floor - plan mapping of the tiles is unknown and may even be changing , an allegory for moving furniture around while agents are busy cleaning the floor .",
    "mldfs implements a generalization on dfs : agents leave decaying pheromone marks on their paths as they advance in the graph , and then use them either to move to the vertex least recently visited or to backtrack . when none of the choices are possible , either when the graph covering ends , or following to changes in the graph or loss of tracks due to noise in the pheromone marks , agents _ reset , _ thus starting a new search .",
    "the time of reset , named `` the time where new history begins '' , is stored in the agents memory , as a * search - level * variable . after a _ reset , _",
    "the cycle repeats , hence an agent traces pheromone marks left in an earlier cycle .",
    "the mere existence of a pheromone mark is , however , not sufficient for agents to choose a path not yet taken during the current search cycle . to select the next step , agents use the value stored in the * search - level * variable as a threshold :",
    "any pheromone that was marked on a vertex or edge prior to this time must have been the result of marking in an earlier cycle . in mldfs , pheromones of all agents are the same , and agents are allowed to step on each other s paths",
    ". for the task of partition a graph , in bdfs each agent has its own pheromone and it performs mldfs cycles on its `` own '' region of the graph , leaving its particular pheromone marks .",
    "as long as the region is stationary , bdfs agents exactly repeat their previous route .",
    "if the region changes , either expands or shrinks , it will cause bdfs to look for a new and possibly substantially different route before settling into the next search cycle .",
    "this occurs due to a subtlety in the way that depth - first - search defines a spanning tree , a special type of tree called a _ palm tree _",
    ", were each edge @xmath5 in the spanning tree connects a vertex @xmath6 with one of its ancestors , see e.g. tarjan @xcite .",
    "the spanning tree defined during a bdfs search cycle does not consider all edges emanating from _ all _ of the region s vertices , simply because some of the edges connect to vertices _ on neighboring _",
    "_ when bdfs conquers a vertex , it is possible that this vertex has more than one edge connecting to the region .",
    "all these edges will now be considered during the next search cycle , a process that may dictate a different palm tree .",
    "we call this event - _ respanning_. in the algorithm we define here , named _ ant patrolling and partitioning , or antpap _ , we use a different generalization of dfs that avoids respanning .",
    "furthermore we reduce the requirements on the agent s capabilities .",
    "for example , our agents have no memory , and also can not control the levels of pheromones they leave , the pheromone level at the time of a marking is always the same .",
    "we further add the possibility for agents to _ lose _ a vertex if a conquest fails , and we provide a proof of convergence to balanced partitions , while experimentally observing much faster evolution towards such partitions .    the subject of multi - agent patrolling has been extensively studied .",
    "lauri and charpillet @xcite also use an `` ants paradigm '' , where a method based on ant colony optimization ( aco ) , introduced by dorigo , maniezzo , and colorni in @xcite .",
    "aco provides multi - agent solutions for various problems , for example the traveling salesman problem ( tsp ) in complete and weighted graphs by a so - called _ ant - cycle _ algorithm .",
    "ants move to the next vertex according to a probability that is biased by two parameters : the closest neighbor vertex ( corresponding to the lowest edge weight ) and the level of pheromone on the edge . during their search",
    ", ants record their path to avoid visiting the same vertex twice .",
    "since at each step all ants traverse one edge to a neighboring vertex , all ants complete their travel at the same time .",
    "thereafter each ant leaves pheromone marks on the entire path it took .",
    "due to the probability bias , shorter edges have a higher probability to be traversed , thus it is probable that multiple ants traversed them , hence they tend to accumulate stronger pheromone levels .",
    "the cycles repeat , and with each cycle the biasing gets stronger towards the shortest path .",
    "the process ends after a a - priori given number of cycles complete or when the ants all agree on the shortest path . for the patrolling problem , lauri et .",
    "@xcite used this method to find multiple paths , one for each agent , _ before _ the agents begin their joint work .",
    "their algorithm employs multiple colonies of ants where each agent is assigned one ant on each colony .",
    "ants in a colony cooperate ( exchange information regarding their choices ) to divide the exploration into disjoint paths , leading the agents to eventually cooperate in the patrolling task .",
    "unlike for the tsp , the environment graph is not required to be complete , and ants are allowed to visit a vertex more than once when searching for a patrolling route .",
    "chevaleyre , yann , sempe , and ramalho @xcite compared cyclic patrolling strategies , in which agents tend to follow each other , to partitioning strategies , in which agents patrol each its own region . by applying several algorithms on several graphs examples",
    ", they found that the choice of strategy should be based on the shape of the graph .",
    "the partitioning based strategy gets better results on `` graphs having long corridors connecting sub - graphs '' , i.e. if there are high weight edges that are slow to traverse , it is better not traverse them at all by allocating them to connect disjoint partitions .",
    "there is substantial research on heuristics for partitioning of a graph , and some of it even related to multi - agent scenarios .",
    "inspired by ants , comellas and sapena @xcite presented yet another _ ants _ algorithm to find a _",
    "k - cut _ solution to a graph .",
    "the system is initiated by randomly coloring all the graph vertices in a more or less even number of colors and positioning the agents randomly on the graph .",
    "then a _ local cost _ value is calculated for each of the vertices , storing the percentage of neighbors that have the same color as its own .",
    "agents will then iteratively move to a neighboring vertex @xmath6 that has the lowest cost ( i.e. with the most neighbors of a _ different _ color than its own ) , and then switch colors with a random vertex @xmath7 on the graph , where the color of @xmath7 is the one most suitable for @xmath6 , i.e. similar to most of @xmath6 s neighbors .",
    "@xmath7 is selected from from a random list of vertices colored with the same color as @xmath7 , by choosing from this list the one with lowest cost ( most neighbors colored _ differently _ than @xmath7 ) .",
    "then the cost value is refreshed for both @xmath6 and @xmath7 . on each iteration",
    "the number of cuts , defined as the number of edges connecting vertices of different colors , is calculated over all the edges of the graph and the lowest value is stored .",
    "the choices of agent moves are stochastic , i.e. agents have a probability @xmath8 to select the next vertex to move to by using the cost value , otherwise it selects another neighbor vertex at random .",
    "this allows the system to escape from local minima . unlike our algorithm , agents of comellas and sapena _ _ s ants _ _ aim to find a _ k - cut _ , and while doing so do not leave pheromones to be used as cues on vertices and edges they visit as our agents do . also , their _ _",
    "agents are assumed to have the ability to look at vertices that are anywhere in the graph and change their values , thus their sensing is not local as in our algorithm . in _",
    "ants _ , each iteration relies on a global calculation that involves access to values on _ all _ edges of the graph , in order to measure the quality of the partition so far determined , as well as storing the result .",
    "inspired by bee foraging , mccaffrey @xcite simulates a bee colony in order to find a _",
    "k - cut _ graph partition .",
    "each of the agents , in this case called _ bees _ , is assumed to know in advance the size and shape of the graph , as well as the number of components desired .",
    "the agent must have an internal memory to store an array of vectors listing the vertices of all sub - graphs of a proposed solution , as well as the number of cuts this partition has , as a measure of its quality . in a hive ,",
    "some 10% of the bees are considered _ scouts , _ all other agents being in one of two states , _ active _ or _ inactive .",
    "_ emulated scouts select a random partition of the graph . if the selection is better than what the scout previously found , it stores it in its memory and communicates it to other bees in the hive that are in an _ inactive _ state .",
    "some of those store the scout s solution in their own memory , change their state to _ active _ and begin to search for a better partition around this solution .",
    "if an active bee finds an improved solution it communicates it to the bees that are left in the hive . after looking at neighboring solutions for a long enough time , the _ active _ bee returns to the hive and becomes _ inactive _ again .",
    "the algorithm , therefore , is constantly searching for improvements in the quality of the partition that the bees collectively determine .    the partitioning and patrolling multi - agent algorithms that we have surveyed above ,",
    "all assume that agents posses substantial internal memory .",
    "some algorithms assume that the agents are able to sense and even change values of vertices and/or edges in graph locations that are distant from their position in the graph , and sometimes they can even sense and/or store a representation of the whole graph in their memory .",
    "patrolling algorithms may be partition based , and then the task is divided into two stages . in the first stage",
    "the graph is partitioned into disjoint components , and at the second stage each of the agents patrols one of those components .    in our case , partitioning the graph , and thereby balancing the workload among our agents , is a requirement .",
    "our algorithm does not have stages , the agents simply perform pheromone directed local steps thereby carrying out a _ patrolling _ algorithm , and while doing so also implicitly cooperate in partitioning the graph .",
    "our agents have no internal memory at all .",
    "their decisions are based on pheromone readings from vertices and edges alone , and they can only sense or leave pheromone marks around their graph location .",
    "one may view our solution for patrolling and partitioning the graph environment as using the graph as a shared distributed memory for our oblivious agents .",
    "the task analyzed here is the partition of an area or environment into regions of similar size by a set of agents with severe restrictions on their capabilities .",
    "the inspiration for the algorithm are gas filled balloons ; consider a set of elastic balloons located inside a box , and being inflated at a constant and equal rate , until the balloons occupy the entire volume of the box . while inflating , it may be that one balloon disturbs the expansion of another balloon .",
    "this may cause a momentarily difference of the pressure in the balloons , until the pressure difference is large enough to displace the disturbing balloon and provide space for the expansion of the other . since the amount of gas is equal for all balloons",
    ", they will each occupy the same part of the volume , effectively partitioning it into equal parts .",
    "our agents mimic this behavior by patrolling a region of the area `` of their own '' , while continuously aiming to expand it .",
    "the area is modeled by a graph and the region is a connected component of the graph .",
    "when expanding regions touch , the agent on the smaller region may conquer vertices of the larger region .",
    "we assume that initially a given number of agents are randomly placed in the environment , they start the process of expanding and this process goes on forever .",
    "eventually the expansion is `` contained '' due to the interaction between the regions of the agent , hence the process will lead to an equalization of the sizes of the regions patrolled by the agents . in the discrete world of our agents a partition to regions of exactly the same size may not exist , therefore we define a balanced partition as such that any two neighboring regions may have a size difference of at most one vertex .    * *    for simplicity , a(ge)nts operate in time slots , in a strongly asynchronous mode , i.e. within a time interval every agent operates at some random time , so that they do not interfere with each other . during a given time slot",
    ", each agent may move over an edge to another vertex , and may leave pheromone marks on a vertex and/or edges .",
    "the marks , if made , are assumed to erase or coexist with the pheromone that remained there from the previous visit .",
    "agents have no control over the amount of pheromone they leave , its initialization level being always the same .",
    "thereafter , the pheromone level decays in time .",
    "each agent has its own pheromone , thus pheromones are like colors identifying the disjoint components and hence the partitioning of the graph .",
    "the agents themselves can only tell if a pheromone is their own or not .",
    "agents are oblivious , i.e. have no internal memory . on each time slot ,",
    "an agent reads remaining pheromone levels previously marked on the vertex it is located and its surroundings , and bases its decisions upon these readings .",
    "the readings and decisions are transient , in the sense that they are forgotten when the time slot advances .",
    "decaying pheromone marks on vertices and edges linger , serving both as distributed memory as well as means of communication . in our model",
    ", agents leave pheromones in two patterns : one pheromone pattern is marked when agents advance in their patrolling route , and the second pattern is used when agents decide to remain on the same vertex .",
    "pheromones are decaying in time , thus once marked on a vertex or edge , their level on the vertex or edge decreases with each time step .",
    "a straightforward way for implementing such behavior in a computer program , is to use the equivalent `` time markings '' , i.e. stamping the _ time _ at which a pheromone is marked on the vertex or edge .",
    "we therefore denote by @xmath9 the time of pheromone marking on vertex @xmath6 , hence @xmath10 means that an agent left a pheromone on vertex @xmath6 at time @xmath11 . as time advances , the  age  of the pheromone on vertex @xmath6 ,",
    "i.e. the time interval since it was marked , which can be calculated as @xmath12 where @xmath13 is the current time , advances as well .",
    "this is equivalent to measuring the level of the temporally decaying pheromone on vertex @xmath6 , and using its value along with the known rate of decay to calculate its `` age '' .",
    "similarly , @xmath14 is a time marking , equivalent to the decaying pheromone level on the edge , where @xmath15 and @xmath16 are not necessarily the same .",
    "the use of time markings require the computer program implementation to know the current time @xmath13 in order to be able to calculate the age of pheromones .",
    "however , the knowledge of current time is strictly limited to its use in the emulation of temporally decaying pheromones by equivalent time markings , thus it does not depart from our paradigm of obliviousness and local decisions based on decaying pheromone markings only .",
    "when an agent decides to leave a pheromone mark on a vertex , it may avoid erasing the pheromone that remains from the previous ( most recent ) visit .",
    "we denote the previous time marking as @xmath17 , thus when an agent marks a pheromone on vertex @xmath6 , the computer program implementation moves the value stored in @xmath9 to @xmath17 and afterwards sets the new time mark to @xmath9 .",
    "hence , the value , @xmath18 encodes the _ idle time _ of the vertex @xmath6 .    * *    agents patrol their region in a dfs - like route , in the sense that they advance into each vertex once and backtrack through the same edge once during a complete traversal of their region . when an agent completes traversing the region it resets ( i.e. it stays at the same location for one time step and refreshes its pheromone mark ) , and",
    "subsequently starts the search again .",
    "the cycles repeat the same route as long as the region is unchanged . when the region does change  either expanding or shrinking  out agents persist on keeping advancing and backtracking into a vertex through the same edge that was used to conquer the vertex .",
    "this is implemented by marking _",
    "`` pair trails '' , _ i.e. leaving pheromones over edges as well as vertices , when conquering and ( subsequently ) advancing into a vertex .",
    "a pair trail is a directed mark from a vertex @xmath7 to an adjacent vertex @xmath6 , of the form @xmath19 , and is one of the two pheromone patterns that agents leave .",
    "this behavior results in a patrolling process that _ follows the pair trails _ , were agents advance through the earliest marked pair trail , refreshing the marks while doing so . when all pair trails to advance through are exhausted , it backtracks through the same pair trail it entered .",
    "an example of a route and the spanning tree it defines are depicted in figure [ fig : patrolling route and tree ] .",
    "the departure from the classic dfs is that edges that are not marked as pair trails are ignored .",
    "the pair trails mark a _ spanning tree _ ( which is not necessarily a palm tree ) of the region , where its root is the vertex where the search cycle begins , and each pair trail marks the path advancing upwards the tree .",
    "when an agent backtracks to the root , it has no untraveled pair trail to advance through , and it restarts the search cycle remaining one time slot in the root .",
    "it then uses the second marking pattern which is simply leaving a pheromone on the vertex , denoted as @xmath20 , where @xmath7 is the root .    since agents advance and",
    "backtrack once from each vertex in their region ( except the root ) and then restart a patrolling cycle in the root , the number of steps in one patrolling cycle , called the _ cover time _",
    ", is @xmath21 .",
    "@xmath22 denotes the region of agent @xmath23 , the set of vertices that are part of @xmath24 patrolling cycle . patrolling cycles",
    "repeat the exact same route as long as the region remains unchanged , hence the _ idle time _ of any vertex @xmath6 of the region is also the region s cover time @xmath25 .",
    "thus the pheromone markings on the vertex can be used to calculate the size of the region @xmath26 .    * *    to expand their region , agents may conquer vertices adjacent to ( vertices of ) their region . for agent @xmath23 to attempt to launch a conquest from a vertex @xmath27 to a target vertex @xmath6",
    ", the following conditions must apply :    1 .",
    "@xmath6 is not part of @xmath23 s region , @xmath28 , let us then assume that @xmath29 of another agent @xmath30 2 .",
    "@xmath7 is subject to a _",
    "double visit _ by @xmath23 , i.e. @xmath23 visits @xmath7 leaving pheromone marks _ twice _ , while @xmath6 was not visited even once by @xmath30 during the same period of time .",
    "since the time difference between the two visits by @xmath23 is the _ cover time _ and the cover time is proportional to the size of the region , it means that @xmath23 s region is smaller than @xmath30 s , @xmath31 . an agent may check for this condition by evaluating if @xmath32 .",
    "if the double visit condition is met , thus @xmath30 s region is larger , allow a conquest attempt if it is not larger by _ exactly one _ vertex  since a difference of one vertex is considered balanced .",
    "4 .   if the double visit condition is met and @xmath30 s region is larger by _ exactly one _ vertex , allow a conquest attempt if vertex @xmath6 is stagnated ",
    "it s pheromones are older than their purported cover time .",
    "an agent checks this by comparing the idle time @xmath12 to the cover time @xmath18 .",
    "depending on the above conditions , an agent may stochastically _ attempt _ the conquest of vertex @xmath6 , with a predefined probability @xmath33 .",
    "this mechanism works even if @xmath6 is not part of any of the other agent s regions , @xmath34 . in such case the pheromone marks on @xmath6",
    "will never be refreshed and the conquest conditions hold .    * *    when a region expands or shrinks as result of conquests , its becomes _ inconsistent _ in the sense that the size of the region changed , but at least some of the pheromone marks on its vertices encoding the _ cover time _",
    "@xmath35 do not reflect that immediately . to regain consistency on a vertex @xmath7 , the pheromone marks on @xmath7",
    "must be _ refreshed _ , hence an agent must leave there a fresh pheromone , and that may occur only when the agent advances into vertex @xmath7 through a pair trail . therefore , there is a delay in the propagation of the change , thus there will be a temporary inconsistency between the actual size of the region and the cover time encoded on region s vertices .",
    "that inconsistency is certainly not desirable since it might result in a miscalculation of conquest conditions .",
    "consider an agent @xmath23 with a larger region than two of its neighbors @xmath30 and @xmath36 .",
    "both neighbors will be attempting to conquer vertices from @xmath23 .",
    "since all agents awareness is local , @xmath30 and @xmath36 have no means to know that @xmath23 is shrinking due to the work of the other as well , and as @xmath30 and @xmath36 repeatedly conquer vertices from @xmath23 , the combined conquests may accumulate to `` eat up '' too much out of @xmath23 s region up to a point where the imbalance is reversed , and the areas of both @xmath30 and @xmath36 are now larger than @xmath23 s . nonetheless , the inconsistency is temporary .",
    "it is convenient to analyze this issue by considering the spanning tree of pair trails .",
    "when an agent conquers a vertex and expands its region , it results in adding a leaf to the spanned tree , and losing a vertex to another agent results in the _ pruning _ of the tree , the splitting of the tree into two or more branches , while the losing agent remains on one of them . in either case ,",
    "the _ follow the pair trails _ strategy ensures that the new route remains well defined .",
    "it is therefore sufficient for an agent to patrol its region twice , to ensure that the region is consistent , as described in the following lemma :    [ lem : a - region - is - consistent]a region is consistent if it has remained unchanged for a period of time which is twice its cover time .    on the first cycle",
    ", the agent leaves a fresh pheromone , @xmath37 , on each vertex , while the previous most recently visit , @xmath38 , may reflect an inconsistent state .",
    "the second cycle repeats the exact same route as the first , since the region remains unchanged , and now both the most recent visit as well as the one preceding it , indicated by pheromone levels @xmath37 and @xmath38 , are updated , thus @xmath39 reflects the cover time on all vertices of the route and the region becomes consistent .    * *    when balloons are inflated in a box , to the observer it looks as a smooth evolution where the balloons steadily grow and occupy more of the volume until the box is filled .",
    "but unlike gas inside a balloon that exerts pressure in all directions concurrently , our discrete agents work in steps , where at each step they attend one vertex of their region , while the other vertices may be subject to conquests by other agents .",
    "since regions are defined by patrolling routes , an agent @xmath23 , by conquest of a single vertex from @xmath30 , may prune @xmath30 s region in a way that leaves @xmath30 to patrol a much smaller region effectively rendering it smaller than @xmath23 s .",
    "now the `` balance tilts '' , as the region that was larger prior to the conquest becomes the smaller .",
    "pruning may cut a spanning tree into two or more sections , but in many cases the sections of the tree may still be _ connected _ by edges that are _ not _ marked by _ _ a pair trail .",
    "in such case , @xmath30 has an opportunity to mark a pair trail over such an edge and regain access to a branch still marked with its own pheromones . yet ,",
    "sometimes the pruning divides the region into two unconnected components .",
    "we call these _ balloon explosions , _ and when these occur it is more difficult for the agent that lost part of its region to regain its loss . therefore , when an agent launches a conquest attempt it is not always clear if its success will advance or set - back the evolution towards convergence .",
    "it is then natural to add the following _ vertex loss _ rule : should an agent fail the conquest attempt , there is a predefined probability @xmath40 for _ losing _ the vertex from which the attempt was launched .",
    "_ losing _ the vertex may indeed be a better evolution step than succeeding in that conquest , resembling actions of withdrawal from local minima used in _",
    "simulated annealing_. in fact , this property becomes instrumental in our convergence proof for the antpap algorithm . in order to prevent",
    "an agent from `` cutting the branch it is sitting on '' , we limit vertex loss events to steps of the patrolling process in which agents backtrack , and , symmetrically restrict conquests to steps in which the agents advance .    we next list the algorithm describing the work of each agent on the graph environment .    -2cm-2 cm    > p9cm >",
    "p7 cm    * *    &   + _ _ entry point of an agent @xmath23 at time step @xmath13 . _ _    _ upon entry , the agent is located on vertex @xmath7 . _     &   +     &   + * * for each * * @xmath41    * * if * * @xmath42    * * @xmath43 or * * @xmath44 * then *     * * if * * @xmath45 * * then * *     * * if @xmath46 then * *     @xmath14 ; @xmath47 ; @xmath48     @xmath49     * * goto * * @xmath6 ; * * return * *     @xmath50     * else * @xmath50    * * if * * @xmath51 * then *     @xmath14 ; @xmath47 ; @xmath48 ; @xmath49    * * goto * * @xmath6 ; * * return * *    * * if * * @xmath52 * then *     * * if * * @xmath53 * * then * *     @xmath54     @xmath14 ; @xmath47 ; @xmath48     * * goto * * @xmath6 ; * * return * *     * * if * * @xmath55 * * then * *     * if * @xmath56 * * then * *     * * @xmath57     * * goto * * @xmath6 ; * * return * *    @xmath58 + * return * & * * * *    for each neighbor @xmath6 of @xmath7 , marked by @xmath23 s pheromone , and meeting the _ double hit . _",
    "if size difference@xmath59 ,   + or @xmath6 is stagnated ( pruned or empty ) then ,    if not backtracked to @xmath7    if chance allows conquest ( x random @xmath60 $ ] ) + * * * *    mark pair - trail into @xmath6    move to @xmath6 and exit this step     if no conquest , set _ _ lose _ _ flag ( y random @xmath60 $ ] )    * *    if @xmath6 has @xmath24 ( self ) mark but _ _ double visit _ _ is met , rejoin @xmath6 .",
    "move to @xmath6 and exit this step    select @xmath6 of the oldest pair - trail +    * *    if pair - trail points into @xmath6 , and mark on @xmath6 is older    keep previous time - mark    refresh the pair - trail pointing to @xmath6    move to @xmath6 and exit this step    * *    if pair - trail points into @xmath7    * *    if _ _ lose _ _ flag is set    remove time marks of @xmath7 and its pair - trails    move to @xmath6 and exit this step    * *    refresh vertex @xmath7 + exit this step +",
    "during a patrolling cycle , an agent attempts conquests over all the border edges of all vertices of its region .",
    "hence its region may expand with additional vertices bordering its route .",
    "this causes the spanning tree defined by its dfs - route to have an ever growing number of branches as the patrolling cycles continue , resulting in a tree shape resembling a `` snow flake '' .",
    "additionally , agents have a strong tendency to form `` rounded '' regions , if the environment and other agents regions allow it .",
    "this happens because vertices that are candidates for conquest and are adjacent to more than one of the region s vertices , have a higher probability to be conquered and incorporated into the patrolled region .",
    "these two properties , the snow - flake like spanning tree and rounded build - ups , often assist in achieving a smooth evolution towards convergence .",
    "thick regions make the possibility of major `` balloon explosions '' unlikely .",
    "the thiner branches at the ends of the snow - flake - like region , cause the pruning of the region by another agent to merely `` shave '' off small fragments from the region , and are less likely to cut out a large portion of its vertices . moreover , if a greater portion was cut out by pruning , it is highly likely that the lost portion is connected by edges that were not pair trails , making it is easier for the losing agent to regain its vertices .",
    "figure [ fig : chart region size vs time ] depicts a chart showing a typically observed evolution of 12 regions in a 50x50 square grid .",
    "the chart describes how the sizes of the regions change with time .",
    "the images of figure [ fig : plausible rounded and thick ] are two snapshots taken during the same evolution , the second snapshot being of the balanced partition that the agents reached .",
    "the chart shows that some regions grew faster than others , then at some point , the regions grew enough so that the graph was covered ( or close to being covered due to continuous pruning ) , and the smaller regions began to grow at the expense of the larger regions until they all reach a very similar size , albeit not yet balanced .",
    "for practical purposes arriving to this state in the graph might suffice , especially if the graph is constantly changing and a partition that is balanced is not well defined .",
    "this process occurs quickly , then there is a much longer phase towards convergence .",
    "the `` turbulence '' seen at about @xmath61 are due to some mild `` balloon explosions '' followed by recovery and convergence .",
    "the last _ plateau _ towards convergence is short in this particular example , but in some other simulated examples it appeared much longer .",
    "this is especially noticeable in cases which the evolution results in the system having two large regions that are adjacent and have very similar sizes but are not yet balanced , e.g. a size difference of 2 vertices .",
    "such scenarios may increase the time required for a double visit , which is a condition for conquest .",
    "figure [ fig : convergence time as func of graph size ] is a chart depicting time to convergence for a system with 5 agents as a function of the graph size , overlaying results of multiple simulation runs .",
    "it shows that the spread in the time to convergence grows with size , but it also clear that the majority , depicted as dense occurrences , are not highly spread in value , indicative of runs of `` typical evolution scenarios '' on square grid , as was the environment tested in these simulations . the dotted line is an interpolation of average convergence time among the results achieved for each graph size .",
    "the above discussed experimental evidence showcases an evolution of the system towards a balanced partition ( when the topology of the environment / graph remains stationary ) , an evolution which is smooth without `` dramatic '' incidents , driven by the antpap algorithm mimicking pressure equalization . however , antpap is a heuristic process , and the experimentally observed smooth convergence is by no means guaranteed . in the evolution towards balanced partitions",
    "there are various events that may substantially alter the size difference between regions , and lead the system to longer and chaotic excursions .",
    "chance dictates the way regions expand and , for example , a region may build up with less thickness in some areas allowing other agents to cut across it causing `` major balloon explosions '' .",
    "furthermore , even a quite well - rounded region may be subject to an `` unfair '' probabilistic attack , driven to cut through its width and eventually succeeding to remove a large portion of its area . to make things even worse",
    ", the portion of the split region that ceased to be patrolled , becomes a readily available prey to neighboring agents .",
    "therefore , although the system is relentlessly progressing towards a balanced partition due to the rules of `` pressure equalization '' , such `` balloon explosions '' are singular events that may significantly derail the smooth evolution towards convergence , slowing the process considerably .",
    "one may wonder if there are conditions were these events occur repeatedly , making the convergence into a balanced partition an elusive target , that may even never be reached .",
    "clearly , there are systems where a balanced partition can not be reached , simply because one does not exist .",
    "an evident example is a graph having the shape of a star .",
    "consider a graph of 7 vertices , one at the center and three branches of two vertices each .",
    "a system with 7 vertices and 2 agents should be partitioned into two connected components , one of 3 vertices and the other of 4 .",
    "but such partition does not exist , thus repeated balloon explosions will forever occur .",
    "interestingly , a balanced partition does exist for the same graph with 3 agents .",
    "therefore , our first step towards proof is to precisely define the systems of interest , which are based on environment - graphs for which a balanced partitions exist for _ any _ number of agents ( up to a bound ) .",
    "the most general set of such graphs is an interesting question in itself . for our purposes",
    ", we shall limit our analysis to systems of the following type :    1 .",
    "the environment is a graph @xmath0 that has a hamiltonian path , a path that passes through every vertex in a graph exactly once , with any number of agents @xmath62 patrolling it . indeed , for any graph @xmath0 that has a hamiltonian path , we can find multiple possibilities for a balanced partition for any number of agents @xmath62 . to name one , the partition where each region includes vertices that are all adjacent one to another along the hamiltonian path , and the regions are chained one after another along the path .",
    "some of the regions can be of size @xmath63 and the others of size @xmath64 .",
    "note that for our purposes , the path does not need to be closed , so the existence of a _",
    "hamiltonian cycle _ is not required .",
    "2 .   the environment is a _ k - connected _ graph , a graph that stays connected when any fewer than @xmath1 of its vertices are removed , with @xmath65 agents patrolling it . in @xcite",
    ", gyori shows that a _ k - connected _ graph can always be partitioned into @xmath1 components , including _",
    "k _ different and arbitrarily selected vertices",
    ".    we shall analyze the evolution of the system as a stochastic process , and base our proof of convergence on the theory of markov chains .",
    "the remainder of this section is organized as follows : we define a `` system configuration '' by considering a simple evolution example and show that there always exists a mapping from configurations to well defined `` states '' .",
    "we then look at more complex configurations and realize that although the set of configurations is not bounded , it can be divided into a finite set of equivalence classes , each class representing a state .",
    "hence , we conclude that the number of states in the markov chain is finite , and the evolution of the configurations maps into corresponding transitions between the states of the chain .",
    "next we use the concept of consistency of a region , as presented in lemma [ lem : a - region - is - consistent ] , to conclude that if a balanced partition is attained , it may persist indefinitely .",
    "this means that balanced partitions map to recurrent states in the markov chain .",
    "we use this result to analyze the structure of the stochastic matrix that describes the chain .",
    "then we turn to prove that it is only the balanced partitions that are mapped to recurrent states .",
    "we first abstract the complexity of the problem by classifying all possible graph partitions into mutually exclusive classes : uncovered , covered but unbalanced , balanced but unstable , balanced and stable",
    ". then we proceed to analyze the changes that may cause the system to shift from a configuration in one class to a configuration in another .",
    "finally we show that when the graph has a hamiltonian path or is _ k - connected _ , despite the possibility that the system may repeatedly transition between these classes , it can not do so indefinitely and will inevitably have to sink into a recurrent state that belongs to a set of states which are all assigned to the same balanced partition , forming a so - called `` recurrent class '' .",
    "the vertices and edges of the graph with their respective pheromone markings , and the agent locations , will be called a configuration of the system , and denoted by @xmath66 .",
    "recall that , as discussed in section [ agents model ] ( sub - section `` agents '' ) , more straightforward time markings , ( in which the current time , @xmath67 , is marked ) , can be used to emulate their equivalent pheromone markings with temporal decay .",
    "the diagram of figure [ fig : 4 first steps ] depicts an example of transitions between configurations of a system of a 4-vertex graph on which two agents , the _ green _ and the _ cyan _ , are active__. _ _ @xmath68 is the initial configuration at _",
    "@xmath69 _ .",
    "agents , shown as dots , are placed at some random initial vertices that are colored according to the agent patrolling them , _ green _ at the top - left vertex and the _ cyan _ at the bottom - right vertex .",
    "the pheromone markings on vertices are shown as ordered pairs of time markings @xmath70 , where @xmath37 is the most recent time that a vertex was marked with pheromone , and @xmath38 is the previous time that the vertex was marked ( so , generally , @xmath71 ) .",
    "when the two agents _ wake up _ at time slot @xmath72 the readings of pheromone marks around are all zero , therefore the _",
    "double visit _",
    "condition @xmath32 , is not met , and conquests are prohibited .",
    "hence the only possible action for the agents is _ reset _ ,",
    "i.e. leaving a fresh pheromone mark @xmath73 ( the current time ) , and thus transitioning to the new configuration @xmath74 . at @xmath75 ,",
    "the double visit condition is again not met , and the system transitions to @xmath76 ( recall that according to the antpap algorithm , at the time that a pheromone is marked on a vertex , the previous mark is moved from @xmath37 to @xmath38 ) . at @xmath77 , conquest conditions are met for both agents , and the system may now transition to any one of the configurations @xmath78 , according to whether one or more conquests succeed , or to @xmath79 , with a probability of @xmath80 , if all 3 conquest attempts fail .",
    "it is important to notice that @xmath79 is equivalent to @xmath76 ( and in fact the configurations are identical in terms of temporally decaying pheromone markings since @xmath81 ) . in",
    "both we have a @xmath37 pheromone that has been freshly marked , so @xmath82 , and a @xmath38 which has been marked on the immediately preceding time slot , hence @xmath83 .",
    "we can , therefore , map each configuration of figure [ fig : 4 first steps ] to distinct `` states '' , states @xmath84 , as depicted in figure [ fig:4 first states ] , and group @xmath79 and @xmath76 into an _ equivalence class _ of system configurations , were configurations in such equivalence class map to the same `` state '' ( in this case the equivalence class that includes @xmath79 and @xmath76 maps to state 3 ) .",
    "calculating transition probabilities between `` states '' is straightforward , but sometimes subtleties arise , for example :    @xmath85@xmath86 ,    @xmath87 ( both agents attempt conquests , but fail ) , and    @xmath88 ( due to the strong asynchronous assumption , the _ cyan _ agent has a probability of @xmath89 to move first within the time slot , and if so , its attempted conquest has a probability @xmath90 to succeed .",
    "the result is multiplied by a probability @xmath91 that the _ green _ agent fails in its conquest .",
    "if the _ green _ moves first , there is a probability @xmath92 that it would fail both attempts , and then a probability @xmath90 that the _ cyan _ succeeds ) .",
    "an edge @xmath93 which is part of a pair - trail pattern marking , so that @xmath94 , will be called a pair - trail edge .    for a time interval in which no conquests or losses of a vertex in a region occur ,",
    "the region is considered `` stable '' .",
    "[ lem : consistent and zero = 00003d m states]a system comprising a graph @xmath0 with time - invariant topology , and @xmath1 agents , in a configuration @xmath95 , satisfying    1 .",
    "the @xmath1 regions marked by the agents are consistent 2 .",
    "pheromone marks exist only on vertices and pair - trail edges inside the k - regions , and no pheromone markings exist elsewhere on the graph ,    will transition through a finite sequence of m of states , where m is the least common multiple of the cover times of the k - regions ( i.e. @xmath96 , prior arriving to a configuration @xmath97 equivalent to @xmath95 ( i.e. @xmath98 , as long as the k regions are stable ( no conquests or losses occur ) .    a consistent region @xmath99 is a region for which @xmath100 , where @xmath101 is the cover time of region @xmath99 ( see lemma [ lem : a - region - is - consistent ] ) . therefore , as long as the region is stable",
    ", all vertices and all pair - trail edges of @xmath99 , cyclically return to the exact same decaying pheromone levels , i.e. exactly the same temporal differences @xmath12 ( where @xmath13 is the current time ) every @xmath101 steps .",
    "we can thereby consider the @xmath1 regions in the partition , each repeating its pheromone level markings independently , as @xmath1 cyclic processes each with its own cycle time .",
    "hence , all the processes complete an integer number of cycles every @xmath102 steps , where @xmath102 is the least common multiple of the cycle times , @xmath103 , which ensures that all vertices of all the @xmath1 regions in the configuration _",
    "@xmath97 _ that was reached have exactly the same temporal differences as in _ @xmath95 , _ and therefore _",
    "_    in the above lemma , we required to have no pheromones at all on edges that are not pair - trail edges .",
    "but , if there were markings on such edges , the patrolling agents would simply ignore them , according to the antpap algorithm .",
    "therefore such markings have no influence on the possible future evolutions of the system .",
    "we shall formally define states of the system by grouping together configurations that have `` the same future evolutions '' , i.e. same possible future configuration transition sequences with the same probabilities .",
    "for example , as seen above , configurations that differ only by levels of pheromones on non pair - trail edges form such equivalence classes , hence each class defines a distinct state . in systems",
    "theory , this is the classical _ nerode _ equivalence way of defining states .",
    "accordingly , two configurations that do not have the exact same patrolling routes ( either not having the same @xmath1 regions , or the agents have developed different patrolling paths within the regions ) can not have the same future evolutions , since , even without any conquests or loses , the future sequences of configurations that the systems go through are different due to the different patrolling steps .",
    "therefore these two configurations can not belong to the same equivalence class thus represent distinct states .",
    "next we turn to discuss pheromone markings that may exist on vertices and edges that are part of any current patrolling route , hence outside of all the regions .",
    "such scenarios may occur as result of a successful conquest by an agent that disconnects the region of a neighbor and hence prunes the spanning tree of that agent , splitting it into two or more disjoint branches .",
    "clearly , the latter agent remains on one of these branches , while the others cease to be part of its patrolling route and remain `` isolated '' .",
    "a segment of a spanning tree ( i.e. a set of vertices marked with pheromones and connected by pair trails ) that is part of a patrolling route , thus not included in any of the regions , forms what we shall call an isolated branch . for completeness , a single such vertex that is not connected by a pair - trail is also considered an isolated branch .    in our pheromone marking model we have not limited the pheromone decay , thus , on an isolated branch , pheromones may decay indefinitely .",
    "this means that there is no bound to the set of configurations , and raises the question of whether there exists a bound to the set of equivalence classes to which they can belong , hence a bound on the number of states of the system .",
    "we shall , therefore , consider configurations that include isolated branches , and analyze the effect of pheromone decay in these branches on the evolution of the system , or more precisely , how such decay influences `` future '' system states .",
    "we have already seen that two configurations that do not have the exact same patrolling routes must represent different states , thus we shall verify that this distinction , by itself , does not produce an unbounded number of states . the number of permutations of possible @xmath1 stable regions is finite ( in a finite graph ) , and for each such permutation , the number of permutations of possible routes for the @xmath1 agents must be finite too ( since each of the @xmath1 regions have a finite number of edges ) .    we are therefore left to show that starting at any arbitrary configuration with @xmath1 agents patrolling @xmath1 regions that also include isolated branches , all future evolutions in an arbitrarily large interval in which all @xmath1 regions remain stable , can be grouped into a finite number of equivalence classes .",
    "let us consider a setup of @xmath1 regions and an isolated branch , where the regions are stable in an arbitrarily large interval , and further assume that a vertex @xmath6 of the isolated branch is adjacent to a vertex @xmath7 in one of the regions ( see figure [ fig : isolated branch prunning ] ) . since the regions are stable , every patrolling cycle the value @xmath105 is refreshed , thus its time - marking increases with each cycle . on the other hand ,",
    "the time marking @xmath9 of the vertex in the branch remains unchanged .",
    "when the agent is on vertex @xmath7 the following scenarios may arise :    1 .",
    "the vertex @xmath6 on the branch might be marked with the same agent s pheromone , and hence moving into the adjacent vertex consists of the action of _ rejoining _ a vertex previously lost . according to antpap",
    ", agents check for a double visit condition , i.e. @xmath32 , prior to this action .",
    "when traversing onto the vertex , e.g. at time @xmath13 , the agent marks there a fresh pheromone @xmath48 .",
    "this may result in splitting the isolated branch into two or more disjoint branches .",
    "the agent will then follow the pair - trails emanating from vertex @xmath6 at which it is presently located , oblivious to the fact that pheromone marks on pair - trails and vertices of the branch are old .",
    "thereafter the agent traverses the section of the previously - isolated branch it is located on , thus refreshing its marks , until all the section is visited ( e.g. , in the example of figure [ fig : isolated branch prunning ] , the agent will visit all vertices on the lower section ) , then it returns to the vertex @xmath7 from which the conquest was launched .",
    "the other disjoint branches ( in the example of figure [ fig : isolated branch prunning ] , the upper section ) remain isolated .",
    "if the branch is marked with another agent s pheromone , and conquest conditions are met ( e.g. double visit ( @xmath32 ) and the regions size difference is not exactly one vertex ( or equivalently the difference in cover time is not 2 , i.e. , @xmath42 ) , the agent may attempt a conquest on the vertex @xmath6 and thereafter on all the vertices of the branch , one by one .",
    "3 .   if the branch is marked with another agent s pheromone but the double visit condition is met ( i.e. @xmath106 ) , it may remain so only for at most two cycles of patrolling .",
    "note that @xmath107 is growing with each agent s visit , while @xmath9 remains unchanged and as a result a double visit condition will necessarily arise .",
    "furthermore , meeting the double visit condition also ensures that all the additional conquest conditions are met at the same time , since either the cover time encoded in the vertex of the isolated branch indicates a region size conducive to conquests , or the agent recognizes that the neighboring region is stagnated ( not being patrolled for too long , i.e. , @xmath44 ) .",
    "therefore any further decay of the pheromone mark on the isolated branch will not influence the future behavior of the system .",
    "a double visit is , therefore , a sufficient condition for an agent to conquer or rejoin a vertex on an adjacent isolated branch , hence we conclude the following :    [ lem : n+m states]a system comprising a graph @xmath0 with time - invariant topology , and @xmath1 agents , in a configuration @xmath66 that includes exactly one isolated branch will transition through a finite sequence of at most @xmath108 states , where @xmath109 and @xmath103 , where @xmath101 is the cover time of region @xmath99 , as long as all the regions are stable ( no conquests or losses occur ) .    the completion of two patrolling cycles of a region by its patrolling agent ensures that the double visit condition is met at any vertex @xmath7 of the region adjacent to a vertex @xmath6 of the isolated branch ( see discussion above ) .",
    "therefore , after an interval of _ @xmath109 _ ( i.e. when the agent on the largest region completed two patrolling cycles ) it is certain that the double visit condition is globally met ( i.e. for any vertex @xmath7 on any of the regions adjacent to any vertex @xmath6 in the isolated branch ) .",
    "moreover , it will be met on any time step that follows ( as long as the regions are stable ) . hence any two configurations on which the double visit condition is globally met , and have the same levels of pheromones on vertices and pair - trail edges that are in the @xmath1 regions ( but may differ in levels of pheromones on the isolated branch ) are equivalent .",
    "since we also know , based on lemma [ lem : consistent and zero = 00003d m states ] , that every + @xmath103 time steps , all pheromones in vertices and pair - trails included in the @xmath1 regions cyclically return to the exact same decaying pheromone levels ( i.e. exactly the same temporal differences ) , we conclude that a system in a configuratio__n _ _ _ @xmath66 , _ will transition at most @xmath110 distinct states to a configuration _ @xmath95 _ ( on which the double visit condition is globally met ) and then will cyclically transition through @xmath102 states reaching , at each cycle , a configuration _ @xmath104 . _",
    "our next analysis is of the effect of multiple isolated branches on future evolutions of a system with stable regions .",
    "consider two scenarios , both starting with the same configuration that has one isolated branch .",
    "an arbitrary time later , a conquest creates another isolated branch , the second branch being the same in both , only the _ time _ of its creation is different .",
    "hence , there can be an arbitrarily large time difference between the creation of the second isolated branch in the two scenarios .",
    "contemplating the case of an arbitrary number of isolated branches created each at an arbitrary time , the complexity of such presented scenarios may substantially grow .",
    "nevertheless , in term of system states the above complexity does not matter .",
    "once the decay of pheromones on an isolated branch is such that the double visit condition is globally met , the conquest or rejoin threshold is triggered , and afterwards no amount of further decay affects the future evolutions of the system .",
    "this insensitivity holds regardless of the presence of other isolated branches , simply because the double visit is a condition , limited to the time difference encoded in pheromones a on a vertex in a region and an adjacent vertex on the branch .",
    "thus , any two configurations that differ only by level of pheromones on isolated branches for which the double visit condition is globally met , are equivalent .",
    "particularly , there must exist a configuration such that the level of pheromones on isolated branches is at its `` highest level '' , i.e. the time marking on each vertex of each isolated branch is the highest that allows the double visit condition to be globally met .",
    "a branch with such `` highest level '' will have one vertex @xmath6 , where @xmath111 with a time - mark value @xmath112 where @xmath13 is the current time ( i.e. a pheromone was left there @xmath113 steps before the current time ) , and all other vertices and edges with ( lower ) values that agree with the ordered directions of pair - trails .",
    "hence we conclude , again , that any configuration @xmath66 that includes multiple isolated branches will transition at most @xmath113 distinct states as long as all the regions remain stable .    for a system with a graph @xmath0 of stationary topology , and",
    "@xmath1 agents , the set @xmath114 of states is finite .",
    "based on the above analysis , we conclude :    1 .",
    "any configuration @xmath66 is equivalent to a configuration @xmath115 identical to @xmath66 except for having no pheromone marking on edges that are not pair trails .",
    "any configuration @xmath115 that includes isolated branches is equivalent to a configuration @xmath68 identical to @xmath115 except by the levels of pheromones on vertices and pair - trail edges in those isolated branches that globally meet the double visit condition on both configurations .",
    "specifically , in @xmath68 , vertices and pair - trail edges on each such isolated branch , will be of a `` highest level '' , i.e. will have one vertex @xmath6 , where @xmath111 with a time - mark value @xmath112 where @xmath13 is the current time ( i.e. a pheromone was left there @xmath113 steps before the current time ) , @xmath109 and @xmath103 , and all other vertices and edges with values that agree to the directions of pair - trails",
    ".    therefore any configuration @xmath66 is grouped in an equivalence class with a correspondingly `` representative '' configuration @xmath68 . to find out how many such classes exist , we observe that a @xmath68 includes the following elements : @xmath1 regions with @xmath1 patrolling routes , isolated branches that do not globally meet the double visit condition and isolated branches of a highest level of time - markings that globally meet the double visit condition .    however , we have that :    1 .",
    "the number of possible choices of @xmath1 regions is finite ( in a finite graph ) .",
    "2 .   for any arbitrary set of @xmath1 regions ,",
    "the number of possible routes in the @xmath1 regions is finite .",
    "3 .   for any arbitrary set of @xmath1 regions ( with a particular selection of @xmath1 routes )",
    "the number of vertices included in these is finite , thus the number of possible isolated branches is finite ( and their possible assignments to whether they meet the double visit condition or not is also finite ) .",
    "therefore the set of possible representative configurations @xmath68 is finite , each defines an equivalence class corresponding to a distinct state of the markov chain , hence the set @xmath114 of system states is finite .    concluding the above analysis we see that in spite of the infinite number of configurations possible for a system , the number of system states , though quite large , is finite .",
    "let us denote the finite set of states of a system by _ s. _",
    "( gallager @xcite ) , a markov chain is an integer - time process , @xmath116 for which the sample values for each random variable @xmath117 lie in a countable set s and depend on the past only through the most recent random variable @xmath118 .",
    "clearly , any state of the system at time @xmath119 , formally represented by @xmath120 , is dependent only on the previous state @xmath121 , since our agents have no memory , and their decisions are based solely on readings from vertices and edges of the configuration , which are completely described by @xmath118 .",
    "we can , therefore , analyze the evolution of the system based on the theory of markov chains .",
    "our aim is to prove that the markov chain is not irreducible ( i.e. given enough time , the probability to reach some of its states tends to zero ) , and that all its recurrent states represent balanced partitions . to proceed with our analysis",
    ", we notice that the size of set @xmath122 grows very fast with the size of the graph .",
    "calculations show that even the simple example of figure [ fig:4 first states ] develops to a surprisingly large chain . in order to be able to describe the evolution of the system in a simple manner",
    ", we also define a _ partition _ of the environment .",
    "the coloring of each vertex of a configuration @xmath66 by its patrolling agent along with the set of unvisited vertices form a partition @xmath123 of the graph .",
    "partitions are unconcerned about the levels of pheromones on the vertices and indifferent to agent locations , thus only exhibit the regions of @xmath66 .",
    "many different configurations ( and hence states too ) correspond to the same partition , therefore we can use the concept of a _ partition _ as an abstraction referring to all those configurations .",
    "figure [ fig : float initial - partition ] is an example of a partition of the environment graph that the system we discussed above arrived to . from our previous discussion",
    "we know that it represents a set of states of the underlying markov chain .",
    "one characteristic of that set of states is that it contains a cyclic path .",
    "this reflects the fact that agents may cyclically repeat their patrolling route for some period of time during which conquests or losses do not occur , and the partition remains stationary .",
    "in fact , having a cyclic path in the underlying markov chain is characteristic of any reachable partition .",
    "eventually conquests or losses are stochastically enabled leading to a different partition , and , as a result , to a different set of underlying states . in figure",
    "[ fig : transition of partitions ] , the system may remain in partition a for a while , as the underlying chain cycles through the relevant states , but eventually it will probabilistically transition to one of the partitions b , c , d , e . note",
    "that the transition from a to d means that both agents conquered one vertex each during the same time - slot .",
    "a _ recurrent class _ in a markov chain is a set of states which are all accessible from each other ( possibly passing through other states ) , and no state outside the set is accessible ( gallager @xcite ) .",
    "the following lemma shows that the set of states corresponding to any balanced partition includes recurrent classes :    [ lem : c4]if a system remains in a balanced partition for a period of time equal to twice the cover time of its largest region , it will remain so indefinitely .    we know",
    "from lemma [ lem : a - region - is - consistent ] , that if a region remains unchanged for a period of time which is twice its cover time , it becomes consistent , so the pheromone levels in all of its vertices correctly indicate its cover time , @xmath124 .",
    "therefore if the system remains in a balanced partition for a period twice the largest cover time ( the cover time of its largest region ) , it is guaranteed that all the regions are consistent .",
    "hence , we conclude that no conquest attempts are subsequently possible , since the system is balanced and conquest conditions can not be satisfied across any border edge .",
    "the conclusion of lemma [ lem : c4 ] is that a balanced partition with all its regions consistent , must correspond to a _ recurrent _ ( and _ periodic _ ) _ class _ in the markov chain__. _ _ the random process continuously repeats a series of states based on the individual agents patrolling cycles . since agents may reach different patrolling routes for the same region , a balanced partition may correspond to multiple recurring classes .",
    "additionally we can conclude the following :    [ cor : c3 - 1]a system may enter a state in which the partition is balanced , and then move into a state in which the partition is not balanced .    clearly , we see while the conditions for consistency are not satisfied for one or more regions in the partition , a conquest or loss may possibly happen , hence the partition may become unbalanced .    since recurrent classes exist , the stochastic transition matrix of the markov chain of the patrolling system must have the form :    @xmath125 $ ]     + where @xmath126 is a matrix of transitions between transient states ( for example those corresponding to non - balanced partitions ) , @xmath127 is a matrix of transitions between states in recurrent classes ( for example those corresponding to balanced partitions with consistent regions ) , and * tr * describes the transitions from transient to recurrent states ( for example those corresponding to balanced partitions with inconsistent regions as described in corollary [ cor : c3 - 1 ] ) . note that we assume an initial distribution given by a row vector @xmath128 and hence the future distributions evolve according to @xmath129 .",
    "each recurrent class representing one particular occurrence of @xmath1 routes in the @xmath1 regions contributes a section * * @xmath130 to * r * , of the form of a shifted identity matrix , +    @xmath131 $ ]     + the rank of @xmath130 is @xmath103 ( i.e. the least common multiple of the cover times of the _ k _ regions ) , and is a function of the sizes of the regions in the partition .",
    "the contribution of a particular balanced partition would be a matrix @xmath132 that comprises of a set of @xmath130 * * matrices on its diagonal , +    * @xmath133\\end{aligned}\\ ] ] *     + where @xmath134 here is the finite number of possible route combinations in the regions that form the partition . therefore our goal is to show that the structure of * r * is +    @xmath135 $ ]     +   + listing contributions from a finite number @xmath119 of possible balanced partitions . to achieve this",
    "we must prove that recurring classes that are representing balanced partitions do not exist .",
    "this is done next .    to visualize the problem",
    ", we will classify all possible partitions as shown in table 1 , recalling that a partition @xmath123 represents a set of states in the underlying markov chain :    cc > p4cm",
    "> p6 cm * partition class * & & * name * & * * description * * + @xmath136 & & not covered & any partition @xmath123 that includes at least one vertex that is part of a patrolling cycle .",
    "+ @xmath137 & & covered ,    not balanced & any partition @xmath138 that includes two adjacent regions with size difference greater than one .",
    "+ @xmath139 & & balanced , unstable & any partition @xmath140 where one or more inconsistent regions .",
    "+ @xmath141 & & balanced , stable ( convergence ) & any partition @xmath140 where all regions are consistent .",
    "+   & & &   +    by construction of the classifications @xmath142 it is clear that these are mutually exclusive as well as complete , hence they divide the set of all possible partitions , so that any partition @xmath123 can belongs to one and only one of the four defined classes .",
    "it also means that any state of the system @xmath143 can be classified to one and only one of the above classes .",
    "@xmath141 includes the set of partitions that comply with lemma [ lem : c4 ] , and @xmath139 includes the partitions of lemma [ cor : c3 - 1 ] .",
    "our goal is to show that from any initial state @xmath143 the system will reach some state in @xmath141 .",
    "figure [ fig : system modes ] , which we will soon justify , depicts the possible _ transitions _ between the classes , i.e. from a state in one class , exists a transition sequence in the markov chain to a state in another class as depicted in the diagram .",
    "we first observe that clearly , any state in @xmath136 or @xmath137 must be _ transient _ , the system can not remain in any one of them indefinitely . in @xmath136",
    "the partition includes free vertices ( that are not part of any region ) . for an agent that persist in visiting a neighboring vertex ,",
    "conquest conditions will be eventually met , and the agent will make repeated attempts to conquer it . eventually all free vertices will be conquered and the graph becomes covered .",
    "similarly , on @xmath137 , when an agent visits a vertex bordering a larger region there is a chance it will conquer the neighboring vertex .",
    "the conquest could cause the pruning of the spanning tree and even a balloon explosion of the larger region , and the system shifts to @xmath136 , or maybe , by chance , it will move to a balanced partition and end up in @xmath139 .    in @xmath139 the system",
    "is balanced but inconsistent .",
    "we know from lemma [ lem : c4 ] that it can become consistent , thus shift to @xmath141 , since there is always a chance that no conquests or losses will occur in any finite period of time .",
    "if a conquest does occur , it may become unbalanced , and then we are back to @xmath136 or @xmath137 .",
    "so any state in @xmath139 is transient and may sink to a state in @xmath141 .",
    "we are left to show that from any state in @xmath136 and @xmath137 there exists a path to @xmath139 .",
    "a sequence of states that switches the system back and forth between @xmath136 and @xmath137 is the scenario were the system repeatedly evolves to a covered graph only to retract by events such as a balloon explosion .",
    "we will show now that from any configuration there is a strictly positive probability to find a balanced partition , hence move to @xmath139 , and as result there is a strictly positive probability to get into @xmath141 .",
    "this means that @xmath141 , the set of balanced partitions , are the only partitions that map to recurrent classes . to do that we recall our restriction to hamiltonian graphs ( or _",
    "_ k-__connected graphs ) and invoke the property of vertex loss .",
    "[ lem : c1-c2 are transient]given a system with an environment graph @xmath0 having a hamiltonian path ( or a k - connected graph ) , and @xmath119 agents , in an arbitrary configuration @xmath144 , there is a strictly positive probability for the system to evolve to a balanced partition .",
    "let us assume the contrary , that there exists a configuration @xmath144 representing a state @xmath145 such that the probability of any arbitrarily long step sequence starting at @xmath144 to arrive into a state in @xmath139 is strictly zero .",
    "we first note that there is a strictly positive probability that the next change of a region is the loss of a vertex .",
    "namely , assume that for a sequence of configurations @xmath146 , where @xmath110 is finite , at configurations @xmath147 there were no changes to any of the regions in the partition of the environment , and at @xmath95 one or more of the regions lost one vertex each , following failed conquest attempts .",
    "this could repeat and consequently , there is a strictly positive ( though very small ) probability for a sequence of configurations @xmath148 , where @xmath102 is finite , to arrive to a configuration @xmath97 where each of the regions is of size 1 .",
    "now , we note that there is a strictly positive probability that the next change of a region is a conquest launched from one vertex to a neighbor along a given hamiltonian path .",
    "this could repeat until the regions form one of the possible balanced partitions along the hamiltonian path and the system is now in @xmath139 .",
    "this evolution contradicts our assumption regarding @xmath144 , and we therefore conclude that @xmath149 is a transient set , thus from any arbitrary configuration there is a strictly positive probability to arrive to a balanced partition .    note that a similar argument can be made for a _",
    "k_-connected environment graph .",
    "we therefore conclude :    a system with a hamiltonian or k - connected graph @xmath0 with stationary topology , and n agents implementing antpap converges in finite expected time to a balanced and stable partition with probability 1 .    the conclusion from lemma [ lem : c1-c2 are transient ] , is that any state @xmath150 is transient .",
    "we also know that any state @xmath151 is transient by lemma [ lem : c4 ] .",
    "this means that all recurrent classes included in the matrix @xmath127 of the stochastic matrix @xmath125 $ ] represent balanced and stable partitions , classified as @xmath141 . a markov chain described by a stochastic matrix of this form ,",
    "will eventually enter a recurrent state , regardless of the initial state , and the probability that this takes more than @xmath13 steps approaches zero geometrically with @xmath13 ( see , for example , gallager @xcite ) .",
    "we conclude that a system with a graph _ @xmath0 _ ( of _ _ stationary _ _ topology ) and @xmath119 agents implementing antpap converges with probability 1 and a finite expected time to a balanced and stable partition .",
    "we presented and thoroughly analyzed the antpap algorithm for continuously patrolling a graph - environment with simple finite state automaton agents ( or bots ) using `` pheromone traces '' .",
    "the simulations presented so far were on an environment in the shape of a square .",
    "on such an environment , we know that many balanced partitions do indeed exist .",
    "practical scenarios are seldom so simplistic . in many important cases ,",
    "the environment graph is , in fact , uncharted and much more complex in its structure .",
    "still , agents implementing antpap will find a balanced partition with probability one ( almost surely ) , if such a partition exists , and will certainly divide their work fairly even when such partitions do not exist .",
    "the shape of the environment considerably affects the time to convergence .",
    "the number of balanced partitions that the environment graph has is , naturally , one of the major factors .",
    "so is their diversity , i.e. how different the balanced partitions are from each other .",
    "if the balanced partitions are similar to one another , the dependency of the time to convergence on the initial locations of the agents tends to be higher than if the solutions are further apart .",
    "consider the system of figure [ fig : t with odd ] .",
    "the initial positions of 7 agents are shown in the first snapshot at @xmath152 .",
    "next , at @xmath153 , the lower section becomes almost covered . at @xmath154",
    "the upper section is almost covered , and the two agents there clearly have larger regions than the agents in the lower section . at @xmath155 , the cyan agent is trapped in the upper section , and we witness a competition between the agents from the lower section to grow their regions into the prolonged section , that the cyan agent abandoned .        at @xmath156 ,",
    "the competition ends after the yellow agent traversed into the upper section .",
    "now we have 3 agents on each of the upper and lower sections , and one on the prolonged section .",
    "soon after , the system reaches a balanced partition . clearly , there are many balanced partitions for this system , but all of them have one agent on the prolonged section , and 3 agents on each of the upper and lower sections",
    ". initial conditions with 3 agents on the upper and lower sections each will ensure faster convergence to a balanced partition . following this experiment and discussion , it is interesting to consider a system with the same environment graph and an number of agents .",
    "since only one balanced partition exists , it is reasonable to predict that the required time for convergence might be substantial .",
    "figure [ fig : t with 2 ] shows snapshots of an evolution of this system .",
    "both the violet and yellow agents are initially located in the lower section .",
    "after a while , the violet agent expands its region so that part of it extends into the upper section .",
    "a while later , the violet region covers almost all of the upper section as well as the prolonged section .",
    "then , the yellow agent begins to expand into the prolonged section , eventually causing a `` balloon explosion '' of violet s region .",
    "soon enough , the violet agent responds , and causes a balloon explosion of the yellow s region .        due to the shape of the graph",
    ", this cycle may repeat over and over again .",
    "it will stop only when the single possible balanced partition is reached , and subsequently the regions `` lock - in '' , and the system remains stable . for that to happen",
    ", an agent must conquer the appropriate half of the vertices of the prolonged section . we know",
    "that this will eventually happen with probability 1 , however the time it will take can be very very long .",
    "the number of agents is also an important factor of convergence time .",
    "generally , more agents hasten the convergence .",
    "figure [ fig : plus w 5 agents ] shows an evolution of a system with 5 agents on a different environment .",
    "we shall call this environment graph the `` cross '' .",
    "figure [ fig : plus w 100 agents ] shows a system with the same `` cross '' graph and 100 agents .",
    "here , the `` pressure '' that an agent `` feels '' from other `` balloons '' quickly accumulates around its region , and the convergence is swift .",
    "figure [ fig : plus agents vs. convergence ] depicts results of multiple simulation runs , of systems with the `` cross '' graph of figure [ fig : plus w 5 agents ] , exhibiting convergence time as a function of the number of agents .    in some systems",
    ", particular numbers of agents may cause a substantially larger time to convergence .",
    "in figure [ fig : rooms balanced ] we present a balanced partition in a graph environment that we call `` 6 rooms '' .    systems with a `` 6 rooms '' graph and 6 agents sometimes require a substantially longer convergence time , as shown in figure [ fig : rooms agents vs. convergence ] . ignoring the outliers at 6 agents , figure [ fig : rooms agents vs. convergence no outliers ] shows that the chart exhibiting convergence time as a function of the number of agents is similar in shape to the one we have seen for the `` cross '' graph , in figure [ fig : plus agents vs. convergence ] .    in the simulations described above , we tested the evolution of the multi - agent patrolling process until convergence to a stable and balanced partition .",
    "however remarkably , the system evolves rather quickly to close - to - balanced partitions due to the `` balloon '' forces implicitly driving the agents behavior . therefore , for practical purposes we see that the antpap algorithm balances the work of the agents much earlier than its convergence time , and the partitioning becomes reasonably good rather quickly .",
    "this property is crucial in case of time varying topologies .",
    "hence , antpap is a versatile and adaptive process .",
    "considering again the `` 6 rooms '' example with 10 agents , we see in figure [ fig : rooms region size evoultion ] a temporal evolution of antpap until a stable and balanced partition is achieved . as is clear on the chart displaying the time evolution of the sizes of the 10 regions , the system reached convergence at approximately @xmath157 steps .",
    "however it is also clear that after approximately @xmath158 steps , the difference between the largest and smallest regions in the partition of the environment graph is already insignificant . in the chart ,",
    "a system is defined as `` close to balanced '' when more than 99% of the graph is covered , and the difference between the largest and smallest regions is less than 5% the ideally balanced size ( i.e. the graph size divided by the number of agents ) .",
    "figure [ fig : rooms balanced with contours ] exhibits a partition reached when the system was `` close to balanced '' .",
    "both snapshots show the same partition ( at two different times ) .",
    "the snapshot at the right also shows the borders between regions that `` reached balance '' ( i.e. their size difference is at most 1 vertex ) depicted in purple .",
    "there is only one border which is not yet balanced , between the magenta region and the dark yellow region , located in the right `` corridor '' .",
    "these regions are close in their sizes , and as a result the double visit condition does not occur very often . despite the partition not being balanced yet ,",
    "the division of work between agents is already fair , hence for practical purposes , a `` close to balanced '' condition is good enough .",
    "we note in summary that antpap does not produce _ k - cut _",
    "partitions @xcite , and generally assumes that there are no constraints on the grouping of vertices .",
    "some important real - world problems impose such constraints , for example , the allocation of users in a social network to hosting servers , according to their interconnections .",
    "other real - world problems , however , do not impose such constrains , for example , the division of work patrolling the world - wide - web for content analysis and classification . in view of the good properties discussed above",
    ", we envision that antpap could become a building block for distributed algorithms aiming to fairly divide between agents the labor of patrolling an environment , using very simple agents constrained to local interactions based on tiny `` pheromone '' marks left in the environment .",
    "10 y. elor , a. m. bruckstein , multi - a(ge)nt graph patrolling and partitioning .",
    "proceedings of the 2009 ieee / wic / acm international joint conference on web intelligence and intelligent agent technology - volume 02 .",
    "ieee computer society , 2009 .",
    "r. g. downey , v. estivill - castro , m. r. fellows , e. prieto , f. a. rosamond , `` cutting up is hard to do : the parameterized complexity of k -cut and related problems '' , electronic notes in theoretical computer science , 78():209222,2003          y. chevaleyre , f. sempe , g. ramalho , a theoretical analysis of multi - agent patrolling strategies .",
    "proceedings of the third international joint conference on autonomous agents and multiagent systems - volume 3 .",
    "ieee computer society , pp .",
    "1524 - 1525 , 2004 ."
  ],
  "abstract_text": [
    "<S> a team of identical and oblivious ant - like agents  a(ge)nts  leaving pheromone traces , are programmed to jointly patrol an area modeled as a graph . </S>",
    "<S> they perform this task using simple local interactions , while also achieving the important byproduct of partitioning the graph into roughly equal - sized disjoint sub - graphs . </S>",
    "<S> each a(ge)nt begins to operate at an arbitrary initial location , and throughout its work does not acquire any information on either the shape or size of the graph , or the number or whereabouts of other a(ge)nts . </S>",
    "<S> graph partitioning occurs spontaneously , as each of the a(ge)nts patrols and expands its own pheromone - marked sub - graph , or region . </S>",
    "<S> this graph partitioning algorithm is inspired by molecules hitting the borders of air filled elastic balloons : an a(ge)nt that hits a border edge from the interior of its region more frequently than an external a(ge)nt hits the same edge from an adjacent vertex in the neighboring region , may conquer that adjacent vertex , expanding its region at the expense of the neighbor . since the rule of patrolling a region ensures that each vertex is visited with a frequency inversely proportional to the size of the region , in terms of vertex count , a smaller region will effectively exert higher `` pressure '' at its borders , and conquer adjacent vertices from a larger region , thereby increasing the smaller region and shrinking the larger . </S>",
    "<S> the algorithm , therefore , tends to equalize the sizes of the regions patrolled , resembling a set of perfectly elastic physical balloons , confined to a closed volume and filled with an equal amount of air . </S>",
    "<S> the pheromone based local interactions of agents eventually cause the system to evolve into a partition that is close to balanced rather quickly , and if the graph and the number of a(ge)nts remain unchanged , it is guaranteed that the system settles into a stable and balanced partition . </S>"
  ]
}