{
  "article_text": [
    "approval voting systems are widely considered  @xcite as an alternative to traditional elections , where each voter may select and support at most some small number of candidates . in approval",
    "voting each voter decides about every single candidate if he approves the candidate or does not approve him / her .",
    "a result is obtained by applying a predefined election rule to the set of collected votes .    in this paper",
    "we study the problem of implementing an appropriate election rule and focus on the minimax objective @xcite : we minimize the biggest dissatisfaction over voters .",
    "the resulting optimization problem is denoted @xmath0 , and it is to select a committee composed of exactly @xmath1 candidates , and minimizing the maximal symmetric difference between the committee and the set of approved candidates by a single voter .    using the string terminology , votes are encoded as strings , and the goal is to find a string encoding a committee minimizing the maximal hamming distance to an input string .",
    "unlike in the related closest string problem , in @xmath0 there is also a constraint : the selected committee must be of fixed size @xmath1 , and hence in the string terminology there must be exactly @xmath1 ones in the string .",
    "many different objective functions have been proposed and studied in the context of selecting the committee based on the set of votes collected in an approval voting system  @xcite .",
    "clearly , optimizing the sum of hamming distances to all votes is an easy task and can be done by simply selecting the @xmath1 candidates approved by the largest number of voters . by contrast , minimax approval voting was shown by legrand  @xcite to be np - hard .",
    "legrand et al .",
    "@xcite obtained @xmath2-approximation by a very simple @xmath1-completion algorithm .",
    "next , carragianis et al .",
    "@xcite gave the currently best @xmath3-approximation algorithm .",
    "the algorithm was obtained by rounding a fractional solution to the natural lp relaxation of the problem , and obtained approximation ratio essentially matches the integrality gap of the lp .    in this paper we give a ptas for the minimax approval voting problem .",
    "our work is based on the ptas for closest string @xcite , which is a similar problem to @xmath0 but there we do not have the restriction on the number of 1 s in the result . technically , our contribution is the method of handling the number of 1 s in the output .",
    "we also believe that our presentation is somewhat more intuitive .",
    "approval voting systems are also analyzed in respect of manipulability , see e.g. , @xcite or @xcite .",
    "in particular , @xcite proved that each strategy - proof algorithm for @xmath0 must have approximation ratio at least @xmath4 , which implies that our ptas can not be strategy - proof .",
    "we will use the following notation : + @xmath5  number of voters , + @xmath6  number of candidates , + @xmath7  a vote of voter @xmath8 , + @xmath9=1 $ ] if voter @xmath8 approves candidate @xmath10 , + @xmath9=0 $ ] if voter @xmath8 does not approve candidate @xmath10 , + @xmath11  the set of collected votes , + @xmath12=1\\}\\big|$ ]  the number of 1 s in @xmath13 . + for @xmath14^m$ ] we define a distance @xmath15-y[j]\\big| = \\lvert x - y \\rvert _ { 1}$ ] .",
    "+ for @xmath16 , @xmath17 is called the hamming distance .",
    "[ def_mavk ] @xmath18 let @xmath19 be an optimal solution , i.e. , @xmath20 .",
    "wlog we assume that @xmath21 . if not , we copy the first string @xmath22 times .",
    "the general idea behind our ptas is to find a small enough subset @xmath23 of votes that is a `` good representation '' of the whole set of votes @xmath24 .",
    "then the candidates are partitioned into those for which voters in @xmath23 agree and the rest of candidates .",
    "for the `` consensus candidates '' we fix our decision to the decision induced by votes in @xmath23 ( additionally correcting the number of selected candidates in the `` consensus '' set ) .",
    "next , we consider the optimization problem of finding a proper subset of the remaining candidates to join the committee .",
    "the key insight is that there exists a small enough subset @xmath23 such that the induced decision for the `` consensus candidates '' will not be a big mistake .",
    "first , in section  [ sec : info_subsets ] we formalize the information we may extract from subset of votes , and introduce a measure of inaccuracy of such a subset .",
    "next , in section  [ sec : existence_of_subset ] we prove the existence of a small subset of votes with stable inaccuracy . in section",
    "[ sec : aux_prob ] we show that the optimization problem of deciding the part of the committee not induced by the subset of votes can be approximated with only a small additional loss in the objective function .",
    "finally , in section  [ sec : alg ] we give an algorithm considering all subsets of a fixed size and show that , in the iteration when the algorithm happens to consider a subset with stable inaccuracy , it will produce a @xmath25-approximate solution to @xmath0 .",
    "we consider subsets of votes and analyze the information they carry .",
    "we measure the inaccuracy of this information with respect to the set of all votes .",
    "we show that there exists a small subset with stable inaccuracy , i.e. , the drop of inaccuracy after including one more vote is small .",
    "let us define an inaccuracy function @xmath26 that measures the inaccuracy if we will consider subset @xmath27 instead of @xmath24 .",
    "the smaller the @xmath28 is the better the common parts of strings in @xmath29 represent @xmath19 .",
    "[ def_ina ] for all @xmath30 we define functions @xmath31 and @xmath32 as follows : @xmath33 =    \\begin{cases }     0 & \\text{if } \\forall_{y \\in y } \\quad y[j]=0\\\\     1 & \\text{if } \\forall_{y \\in y } \\quad y[j]=1\\\\     s_{opt}[j ] & \\text{otherwise , }    \\end{cases}\\ ]",
    "] @xmath34    intuitively @xmath35 is the optimal solution @xmath19 changed at positions where all strings from @xmath29 agree .",
    "also we define the pattern of a subset of votes .",
    "[ def_p ] for all @xmath30 we define pattern @xmath36 as : @xmath37=    \\begin{cases }     0 & \\text{if } \\forall_{y \\in y } \\quad y[j]=0\\\\     1 & \\text{if } \\forall_{y \\in y } \\quad y[j]=1\\\\     * & \\text{otherwise . }",
    "\\end{cases}\\ ] ]    it represents positions that all strings in @xmath29 agree .",
    "`` @xmath38 '' encodes a mismatch .",
    "note that ( from definitions [ def_ina ] and [ def_p ] ) @xmath35 is an optimal solution @xmath19 overwritten by a pattern @xmath39 on no - star positions : @xmath33 =    \\begin{cases }     s_{opt}[j ]    & \\text{if } \\big(p(y)\\big)[j ] = * \\\\     \\big(p(y)\\big)[j ] & \\text{otherwise . }    \\end{cases}\\ ] ]    the inaccuracy function has the following properties :    [ decreasing_ina ] @xmath40 , for all sequences @xmath41 we have @xmath42    it is easy to see that @xmath43 @xmath44 still we need to prove @xmath45 .",
    "pattern @xmath46 is built on strings from @xmath47 and strings from @xmath48 .",
    "so @xmath46 has at least as many @xmath38 as @xmath49 has .",
    "therefore @xmath50 has at least as many positions as @xmath51 has that agree with optimal solution @xmath19 , so @xmath52 . using definition of the inaccuracy function ( definition [ def_ina ] )",
    "we prove the lemma .",
    "@xmath53    intuitively @xmath54 is the decrease of the inaccuracy from adding element @xmath55 to set @xmath29 .",
    "we will show that , when adding one more element @xmath55 to sets @xmath56 such that @xmath57 , the inaccuracy decrease more in a case of adding @xmath55 to the smaller set @xmath29 than adding @xmath55 to the bigger set @xmath58 .",
    "[ supermodular_ina ] if we artificially extend the @xmath59 function for the empty set : + @xmath60 , then function @xmath59 is supermodular is supermodular iff + @xmath61 which is equivalent with @xmath62 . ] , i.e. , @xmath63    let fix @xmath56 and @xmath13 such that @xmath64 and @xmath65 .",
    "[ [ case-1 ] ] * case 1 : * + + + + + + + + +    @xmath66 :    then also @xmath67 , and inequality ( [ supermodular_ina_ieq ] ) holds obviously .",
    "[ [ case-2 ] ] * case 2 : * + + + + + + + + +    @xmath68 :    we have : @xmath69 @xmath70 because we use respectively : lemma [ decreasing_ina ] and the fact that @xmath58 has at least one element ; definition of @xmath59 for empty set and upperbound for @xmath59 function ; assumption that @xmath67 .",
    "[ [ case-3 ] ] * case 3 : * + + + + + + + + +    @xmath71 :    from definition of @xmath59 we have : @xmath72 counting a difference by considering two cases for value of @xmath19 we obtain @xmath73=1 \\wedge t(z \\cup \\{s\\})[j]=1 \\wedge t(z)[j]=0 \\big\\}\\big| + \\ ] ] @xmath74=0 \\wedge t(z",
    "\\cup \\{s\\})[j]=0 \\wedge t(z)[j]=1 \\big\\}\\big| = \\ ] ] using definition of function @xmath75 : @xmath73=1 \\wedge s[j]=1 \\wedge \\;\\forall_{z \\in z } \\ ; z[j]=0 \\big\\}\\big| + \\ ] ] @xmath74=0 \\wedge s[j]=0 \\wedge \\;\\forall_{z \\in z } \\ ; z[j]=1 \\big\\}\\big| \\leqslant\\ ] ] taking an universal quantifier over a smaller subset we obtain : @xmath76=1 \\wedge s[j]=1 \\wedge \\;\\forall_{y \\in y } \\ ; y[j]=0 \\big\\}\\big| + \\ ] ] @xmath77=0 \\wedge s[j]=0 \\wedge \\;\\forall_{y \\in y } \\ ; y[j]=1 \\big\\}\\big| = \\ ] ] reversing all previous transformations finally we obtain : @xmath78@xmath53",
    "[ lem_exists_x ] for any fixed @xmath79 there exists a subset @xmath80 such that @xmath81 we say such @xmath23 is @xmath82-stable .",
    "it means that there exists such a subset of votes @xmath23 that adding one more vote into @xmath23 the inaccuracy decreases by at most @xmath82 .",
    "first , we construct @xmath83 satisfying ( [ lem_x_exists_ina ] ) with at most @xmath84 elements .",
    "let us construct a sequence of subsets @xmath85 .",
    "we take @xmath86 , where @xmath87 is any element of @xmath24 and for @xmath88 we take @xmath89 where @xmath90 is such a vote that after adding it the  inaccuracy function decreases the most , i.e. , @xmath91    [ fig : ina ]   function for the sequence of subsets @xmath92.,title=\"fig : \" ]    we have @xmath93 @xmath94 because ( from lemma [ decreasing_ina ] ) we know that @xmath95 and @xmath96 .",
    "let @xmath97 be a minimizer for the left - hand side of ( [ thm_min_r ] ) , then ( by the choice of @xmath98 in ( [ thm_sir ] ) ) we have : @xmath99 thus @xmath83 satisfies ( [ lem_x_exists_ina ] ) , see figure 1 . if @xmath83 has less elements than @xmath84 we can extend @xmath83 to an @xmath84-elements subset @xmath23 by adding any elements of @xmath24 .",
    "it follows from the supermodularity of @xmath59 . from lemma [ supermodular_ina ]",
    "we have : @xmath100 and hence also : @xmath101 finally , taking ( [ thm_max_diff_ina ] ) and ( [ thm_max_sx_x ] ) we obtain : @xmath102@xmath53    of course we can not construct such a subset efficiently if we do not know @xmath19 . how to find a proper subset @xmath23 ? for constructing our ptas we will fix @xmath103 and consider all subsets @xmath27 with cardinality @xmath84 .",
    "there is less than @xmath104 such subsets . for clarity",
    ", we will use @xmath27 in arguments valid for all subsets considered by the algorithm , and @xmath105 for a @xmath82-stable subset of votes .    for a fixed @xmath30 , wlog",
    "we reorder candidates in such a way that @xmath106 is a lexicographically smallest permutation : @xmath107 the first part ( from the left ) is called `` star positions '' or `` star part '' .",
    "the remaining part is called `` no - star part '' .",
    "we define @xmath108 as the number of @xmath38 in @xmath106 and we denote it @xmath109 : @xmath110= * \\right\\}\\big|.\\ ] ]    in our ptas we essentially fix the `` no - star part '' of the answer to the pattern @xmath106 and optimize over the choices for the `` star part '' of the outcome . if the  number of stars or number of 1 s on star positions of @xmath19 is small enough , then there is only @xmath111 possible solutions and we can consider all of them .",
    "let us analyze the size of the `` star part '' .",
    "[ size_p_star_y ] for all @xmath27 we have @xmath112    consider an arbitrary @xmath113 .",
    "we can construct @xmath29 in the  following 3 phases :    1 .",
    "@xmath114 2 .   for @xmath115 to @xmath116 do 3 .",
    "@xmath117 4 .",
    "@xmath118    after that we obtain set y. let us calculate how many stars @xmath106 has .",
    "in phase  1 there are no stars . in each step in phase",
    "2 we add at most @xmath119 stars , because @xmath120 . in phase 3 we can at most decrease the  number of stars .",
    "so @xmath121.@xmath53    note that for @xmath23 from lemma [ lem_exists_x ] we have @xmath122    let us now introduce some more notation . assuming @xmath27 and",
    "hence also @xmath123 are fixed , we will use the following notation to denote the `` star part '' and the `` no - star part '' of a string @xmath124 : @xmath125\\cdot x[2]\\cdot \\dotsc\\cdot x[\\beta],\\ ] ] @xmath126\\cdot x[\\beta+2]\\cdot\\dotsc\\cdot x[m],\\ ] ] where``@xmath127 '' is a concatenation of strings ( letters ) .",
    "so we divide @xmath128 into two parts : @xmath129 .",
    "let us now define a @xmath1-completion of @xmath124 ( definition from @xcite ) to be a @xmath130 such that @xmath131 and @xmath132 is the minimum possible hamming distance between @xmath128 and any vector with @xmath1 of 1 s . to obtain a @xmath1-completion we only add or only delete a proper number of 1 s . to be more specific in this paper",
    "we assume the @xmath1-completion is always obtained by changing bits at positions with the smallest possible index .",
    "in the following lemma we will show that for the pattern from a stable subset @xmath23 we can change the number of 1 s in the `` no - star part '' to the properly guessed number of 1 s loosing only twice the stability constant .",
    "[ lemma_kbiscompletion ] if @xmath105 is @xmath133-stable , @xmath134 is a @xmath135-completion of @xmath136 , where @xmath137 , then @xmath138    wlog there is insufficient number of 1 s in no - star part of pattern @xmath139 , i.e. , @xmath140 .",
    "the other case is symmetric .",
    "let us fix @xmath141 and consider all combinations of values in strings @xmath136 , @xmath134 , @xmath142 , @xmath143 at the same position @xmath10 .",
    "@xmath144 , for @xmath145 , counts the number of positions @xmath10 with combination @xmath146 , see table 1 .",
    "[ table_cases ]    .combinations of values in strings @xmath147 .",
    "there is only 12 combinations ( no @xmath148 ) , because by the assumption @xmath149 we never change from 1 in @xmath150 to 0 in @xmath134 .",
    "[ cols=\"^,^,^,^,^,^,^,^,^,^,^,^,^ \" , ]     we have : @xmath151 \\neq s_i''[j ] \\}\\big| = \\ ] ] we consider two cases for value of @xmath19 at position @xmath10 : @xmath152 \\neq s_i''[j ] \\wedge ( z''[j ] = s_{opt } \\vee z''[j ] \\neq s_{opt})\\}\\big| = \\ ] ] we divide it into two components : @xmath153 \\neq s_i''[j ]             & & \\}\\big| + \\\\     + & \\big|\\{j :            & & \\ ; z''[j ] \\neq s_i''[j ] = s_{opt } ) & & \\}\\big| =    \\end{aligned}\\ ] ] we use case counts from table 1 to count positions in both components : @xmath154 and we use the definition of the hamming distance : @xmath155 since @xmath156 , @xmath157 @xmath158 also @xmath159 because @xmath23 is @xmath160-stable .",
    "now we are ready to prove equation ( [ lemma_kbis_completion ] ) .",
    "@xmath161 @xmath162 @xmath163 @xmath53",
    "in this section we will consider the optimization problem obtained after guessing the number of 1 s in the two parts and fixing the `` no - star part '' of the outcome .",
    "it has variables for all the positions of the `` star part '' and constraints for all the original votes @xmath141 .",
    "let us define the optimization problem in terms of the integer program @xmath164 by ( [ ip_q])-([ip_p01 ] ) : @xmath165 @xmath166 @xmath167 @xmath168 @xmath169 \\in \\{0,1\\}\\ ] ] where @xmath170 , and @xmath171 is the @xmath135-completion of @xmath172 .",
    "recall that @xmath173 and @xmath172 is the `` no - star part '' of the  pattern @xmath106 .    in the lp relaxation ( [ ip_p01 ] )",
    "is replaced with : @xmath174 \\in [ 0,1]\\ ] ]    constraints ( [ ip_q])-([ip_qg0]),([lp_p01 ] ) are linear because @xmath175,\\ ] ] @xmath176=0)\\cdot s'[j ] + \\chi(s_i'[j]=1)\\cdot(1-s'[j])\\big)\\ ] ] are linear functions of @xmath177 $ ] , where @xmath178 .",
    "[ lem_aprox_ip ] @xmath179 we can find @xmath180-approximation solution for @xmath164 by solving the @xmath181 and considering at most @xmath182    let us fix constants @xmath183 ( for @xmath184 we could use @xmath3-approximation from @xcite ) .",
    "consider three cases :    [ [ case-1 - 1 ] ] * case 1 : * + + + + + + + + +    @xmath185 + there is @xmath186 possibilities for @xmath187 .",
    "+ @xmath188 because @xmath189 and @xmath84 are fixed constants .",
    "so we will check ( in polynomial time ) all possibilities for @xmath187 and we will find optimal solution for the integer program .    [ [ case-2 - 1 ] ] * case 2 : * + + + + + + + + +    @xmath190 + there is @xmath191 possibilities for @xmath187 because we can upperbound the number of possibilities of setting 1 s into @xmath109 positions by : @xmath192 because @xmath189 and @xmath84 are fixed constants .",
    "[ [ case-3 - 1 ] ] * case 3 : * + + + + + + + + +    @xmath193 + we denote an optimal solution of the  @xmath164 by @xmath194 .",
    "let us use lp relaxation and denote an optimal solution of the lp by @xmath195 .",
    "obviously we have @xmath196 .",
    "we can solve the lp in polynomial time but we may obtain a fractional solution .",
    "we want to round it independently .",
    "we will use a randomized rounding defined by distributions on each position @xmath178 : @xmath197=1\\big)= ( s')^{lp}[j ] , \\quad p\\big(s'[j]=0\\big)= 1-(s')^{lp}[j].\\ ] ] we can estimate the expected value of a distance to such a random solution @xmath187 : @xmath198 \\stackrel{\\text{def.}}{= } \\mathbb{e}\\left [ \\sum_{j=1}^\\beta \\big|s'[j]-s_i'[j]\\big| \\right ] = \\ ] ] @xmath199=0)\\cdot s'[j ] \\quad & + \\quad & \\chi(s_i'[j]=1)\\cdot ( 1-s'[j ] ) & & \\big ) \\bigg ] \\stackrel{\\text{lin .",
    "of } \\mathbb{e}}{= }   \\\\   \\stackrel{\\text{lin . of } \\mathbb{e}}{= } &",
    "\\sum_{j=1}^\\beta & \\big ( \\quad & \\chi(s_i'[j]=0)\\cdot \\mathbb{e}\\big[s'[j]\\big]\\quad & + \\quad & \\chi(s_i'[j]=1)\\cdot \\mathbb{e}\\big[1-s'[j]\\big ] & & \\big ) \\stackrel{(\\ref{pse1})}{= } \\\\   \\stackrel{(\\ref{pse1})}{= } & \\sum_{j=1}^\\beta & \\big ( \\quad & \\chi(s_i'[j]=0)\\cdot ( s')^{lp}[j]\\quad & + \\quad & \\chi(s_i'[j]=1)\\cdot \\big(1-(s')^{lp}[j]\\big ) & & \\big ) \\stackrel{\\text{def.}}{=}\\end{aligned}\\ ] ] @xmath200 @xmath201 is a sum of @xmath109 independent 0 - 1 variables . for @xmath202 using chernoff s bound @xcite we have : @xmath203 \\big ) \\leqslant \\exp\\left ( -\\frac{1}{3}(\\epsilon')^2 \\cdot \\mathbb{e}\\big[d(s',s_i')\\big ] \\right).\\ ] ] if we take @xmath204}$ ] then we obtain : @xmath205 } \\right ) \\geqslant p\\big(d(s',s_i ' ) \\geqslant \\mathbb{e}\\big[d(s',s_i')\\big ] + \\epsilon_2 \\cdot q^{ip } \\big ) \\stackrel{(\\ref{exp_d_p_si})}{\\geqslant}\\ ] ] @xmath206 we want to know an upperbound for the probability that we make an error greater than @xmath207 for at least one vote : @xmath208 @xmath209 } \\right ) \\leqslant n \\cdot \\exp\\left ( -\\frac{1}{3 } ( \\epsilon_2)^2 \\cdot q^{ip } \\right),\\ ] ] where the last inequality is because of : @xmath210 \\stackrel{(\\ref{exp_d_p_si})}{\\leqslant } q^{lp}-d(s_{alg}'',s_i '' ) \\leqslant q^{ip}.\\ ] ] we want to further upperbound the probability in ( [ pbb_error_all ] ) . from the assumption about @xmath109 and from lemma  [ size_p_star_y ]",
    "we have : @xmath211 @xmath212 so , finally we have : @xmath213 so with probability at least @xmath214 we obtain : @xmath215 @xmath216 we can also obtain a wrong number o 1 s . the solution @xmath217 for that is to take the @xmath218-completion of @xmath187 .",
    "we will show that the additional error for such operation is not so big .",
    "expected number of 1 s in @xmath187 is equal @xmath218 : @xmath219 \\stackrel{\\rm{def.}}{= } \\mathbb{e}\\left [ \\sum_{j=1}^\\beta s'[j ] \\right ] \\stackrel{\\text{lin .",
    "of } \\mathbb{e}}{= } \\sum_{j=1}^\\beta ( s')^{lp}[j ] \\stackrel{\\rm{def.}}{= } \\big((s')^{lp}\\big)^{(1 ) } \\stackrel{(\\ref{ip_no1})}{= } k'.\\ ] ] we want to know how much we lose taking the @xmath218-completion .",
    "similar as before , @xmath220 $ ] is a sum of @xmath109 independent 0 - 1 variables . for @xmath221 using chernoff s bound @xcite we have : @xmath222 @xmath223 taking both inequalities together , @xmath224 and using assumption @xmath225 we have : @xmath226 @xmath227 so with probability at least @xmath214 the error from taking the @xmath218-completion is not greater than @xmath228 .    combining the above with ( [ eps2_approx_ip ] ) we obtain a @xmath180-approximate solution with probability at least @xmath229 .",
    "we may derandomize the algorithm analogously to how it was done in the ptas for the closest string problem @xcite . for more on derandomization techniques",
    "see  @xcite .",
    "now we are ready to combine the ideas into a single algorithm .",
    "@xmath230 @xmath231 [ forrsubset ] [ approx_opt_problem ] [ forrsubsetend ]    it remains to argue that for a large enough parameter @xmath84 the above algorithm will at some point consider a subset of votes @xmath23 that leads to an accurate enough approximation of the minimax objective function of our problem .",
    "@xmath232 we may compute a @xmath25-approximate solution to minimax approval voting in @xmath233 time .    let @xmath234 .    by lemma [ lem_exists_x ]",
    ", there exists an @xmath235-stable set of votes @xmath236 of cardinality @xmath237 .",
    "consider algorithm alg(r ) . in one iteration it will consider @xmath23 and @xmath238 such that @xmath239 .",
    "recall that @xmath171 is the specific @xmath135-completion of @xmath136 . by lemma [ lemma_kbiscompletion ]",
    "we have : @xmath240 hence @xmath241 is a feasible solution to @xmath242 and the optimal value of @xmath242 is at most @xmath243 .    by lemma [ lem_aprox_ip ] with @xmath244 we find a @xmath245-approximate solution @xmath246 to @xmath242 .",
    "so we have : @xmath247    it remains to observe , that @xmath248 is a solution to @xmath0 of cost @xmath249 .",
    "the algorithm examined @xmath250 subsets @xmath29 , @xmath251 choices of @xmath218 and each time considered @xmath252 @xmath53",
    "we showed the existence of a ptas for minimax approval voting by considering all subsets of a fixed size @xmath84 .",
    "if not the discovered supermodularity for the  inaccuracy function @xmath59 , we would simply consider all subsets of size at most @xmath84 .",
    "although the supermodularity was not essential for our result , it shows that larger subsets of votes are generally more stable ( in the sense of definition in lemma [ lem_exists_x ] ) .",
    "it seems to suggest that an algorithm considering a smaller number of larger subsets of votes would potentially be more efficient in practice .",
    "perhaps the most interesting open question is whether by randomly sampling a number of subsets of votes to examine , one could obtain a more practical fpras for the  problem .",
    "another interesting direction is the optimization of the minimax objective function subject to a restriction that the voting system must be incentive compatible .",
    "according to  @xcite the best possible approximation ratio in this setting is between @xmath4 and @xmath253 , and a natural challenge is to narrow this gap .    finally , we know the complexity of the two extreme objectives , i.e. , minimax and minisum . the latter is easily optimized by selecting the @xmath1 most often approved candidates .",
    "the optimization problem for intermediate objectives such as optimizing the sum of squares of the hamming distances remains unexplored , and it would be interesting to learn which objective functions are more difficult to approximate than minimax in the context of approval voting systems .",
    "we want to thank katarzyna staniewicz for many helpful proofreading comments .",
    "also we want to thank reviewers for their valuable suggestions .",
    "krzysztof sornat was supported by local grant 2139/m / ii/14 .",
    "99 h. aziz , s. gaspers , j. gudmundsson , s. mackenzie , n. mattei , t. walsh .",
    "computational aspects of multi - winner approval voting .",
    "arxiv preprint arxiv:1407.3247v1 , 2014 .",
    "brams , p.c .",
    "approval voting .",
    "2nd edition , springer , 2007 .",
    "brams , d.m .",
    "kilgour , m.r .",
    "sanver . a minimax procedure for electing committees .",
    "public choice , 132(3 - 4 ) : pages 401 - 420 , 2007 .",
    "j. byrka , k. sornat .",
    "ptas for minimax approval voting .",
    "arxiv preprint arxiv:1407.7216v2 , 2014 .",
    "i. caragiannis , d. kalaitzis , e. markakis . approximation algorithms and mechanism design for minimax approval voting . in proceedings of the 24th aaai conference on artificial intelligence ,",
    "pages 737742 , 2010 .",
    "r. legrand .",
    "analysis of the minimax procedure .",
    "technical report wucse-2004 - 67 .",
    "department of computer science and engineering , washington university , st .",
    "louis , missouri , 2004 .",
    "r. legrand , e. markakis , a. mehta . some results on approximating the minimax solution in approval voting .",
    "proceedings of 6th aamas , pages 11931195 , 2007 .",
    "m. li , b. ma , l. wang . on the closest string and substring problems .",
    "journal of the acm , vol .",
    "49 : pages 157171 , 2002 .",
    "r. motvani , p. raghavan .",
    "randomized algoritms .",
    "cambridge university press , chapter 4.1 , 1995 .",
    "p. raghavan .",
    "probabilistic construction of deterministic algorithms : approximate packing integer programs .",
    "journal of computer and system sciences , 37(2 ) , pages 130 - 143 , 1988 .",
    "a. schrijver .",
    "combinatorial optimization : polyhedra and efficiency .",
    "springer , page 766 , 2003 ."
  ],
  "abstract_text": [
    "<S> we consider approval voting systems where each voter decides on a subset of candidates he / she approves . </S>",
    "<S> we focus on the optimization problem of finding the committee of fixed size k , minimizing the maximal hamming distance from a vote . in this paper </S>",
    "<S> we give a ptas for this problem and hence resolve the open question raised by carragianis et al . </S>",
    "<S> [ aaai10 ] . </S>",
    "<S> the result is obtained by adapting the techniques developed by li et al . </S>",
    "<S> [ jacm02 ] originally used for the less constrained closest string problem . </S>",
    "<S> the technique relies on extracting information and structural properties of constant size subsets of votes . </S>"
  ]
}