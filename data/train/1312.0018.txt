{
  "article_text": [
    "function types in traditional type systems only provide information about the arguments and return values of the functions but not about the data that is captured in function closures .",
    "such function types naturally lead to simple and compositional type systems .",
    "recently , syntax - directed type systems have been increasingly used to statically verify strong program properties such as resource usage  @xcite , information flow  @xcite , and termination  @xcite . in such type systems , it is sometimes necessary and natural to include information in the function types about the data that is captured by closures . to see why , assume that we want to design a type system to verify resource usage .",
    "now consider for example the curried append function for integer lists which has the following type in ocaml .",
    "@xmath0 at first glance , we might say that the time complexity of ` append ` is @xmath1 if @xmath2 is the length of the first argument .",
    "but a closer inspection of the definition of ` append ` reveals that this is a gross simplification .",
    "in fact , the complexity of the partial function call ` app_par = append \\ell ` is constant .",
    "moreover , the complexity of the function ` app_par ` is linear  not in the length of the argument but in the length of the list @xmath3 that is captured in the function closure .    in general",
    ", we have to describe the resource consumption of a curried function @xmath4 with @xmath2 expressions @xmath5 such that @xmath6 describes the complexity of the computation that takes place after @xmath7 is applied to @xmath8 arguments @xmath9 .",
    "we are not aware of any existing type system that can verify a statement of this form .",
    "to express the aforementioned statement in a type system , we have to decorate the function types with additional information about the data that is captured in a function closure .",
    "it is however not sufficient to directly describe the complexity of a closure in terms of its arguments and the data captured in the closure .",
    "admittedly , this would work to accurately describe the resource usage in our example function ` append ` because the first argument is directly captured in the closure .",
    "but in general , the data captured in a closure @xmath10 can be any data that is computed from the arguments @xmath9 ( and from the data in the environment ) . to reference this data in the types",
    "would not only be meaningless for a user , it would also hamper the compositionality of the type system .",
    "it is for instance unclear how to define subtyping for closures that capture different data ( which is , e.g. , needed in the two branches of a conditional . )    to preserve the compositionality of traditional type systems , we propose to describe the resource usage of a closure as a function of its argument and the data that is visible in the current environment . to this end",
    "we introduce _ open closure types _ , function types that refer to their arguments and to the data in the current environment .    more formally , consider a typing judgment of the form @xmath11 , in a type system that tracks fine - grained intensional properties characterizing not only the shape of values , but the behavior of the reduction of @xmath12 into a value ( e.g. , resource usage ) . a typing rule for open closure types",
    ", @xmath13(x { \\mathpunct{:}\\!}\\sigma ) } \\to \\tau}$ ] , captures the idea that , under a weak reduction semantics , the computation of the closure itself , and later the computation of the closure _ application _ , will have very different behaviors , captured by two different typing environments @xmath14 and @xmath15 of the same domain , the free variables of @xmath12 .",
    "to describe the complexity of ` append ` , we might for instance have a statement @xmath16(y { \\mathpunct{:}\\!}{\\ensuremath{\\mathit{int\\ list } } } ) } \\to int\\ list } \\ ; . \\belowdisplayskip 0.5em\\ ] ] this puts us in a position to use type annotations to describe the resource usage of @xmath17 as a function of @xmath3 and the future argument @xmath18 .",
    "for example , using type - based amortized analysis  @xcite , we can express a bound on the number of created list notes in ` append ` with the following open closure type .",
    "@xmath19 ( x { \\mathpunct{:}\\!}{\\ensuremath{\\mathit{int\\ list}}}^0 ) } \\to { { [ x { \\mathpunct{:}\\!}{\\ensuremath{\\mathit{int\\ list}}}^1](y { \\mathpunct{:}\\!}{\\ensuremath{\\mathit{int\\ list}}}^0 ) } \\to int\\ list}^0 } \\ ; . \\belowdisplayskip 0.5em\\ ] ] the intuitive meaning of this type for ` append ` is as follows . to pay for the cons operations in the evaluation of @xmath20 we need @xmath21 resource units and to pay for the cons operations in the evaluation of @xmath22 we need @xmath23 resource units .",
    "the development of a type system for open closure types entails some interesting technical challenges : term variables now appear in types , which requires mechanisms for scope management not unlike dependent type theories .",
    "if @xmath24 appears in @xmath25 , the context @xmath26 is not exchangeable with @xmath27 .",
    "similarly , the judgment @xmath28 will not entail @xmath29 , as the return type @xmath25 may contain open closures scoping over @xmath24 , so we need to substitute variables in types .",
    "the main contribution of this paper is a type theory of open closure types and the proof of its main properties .",
    "we start from the simply - typed lambda calculus , and consider the simple intensional property of data - flow tracking , annotating each simply - typed lambda - calculus type with a single boolean variable .",
    "this allows us to study the metatheory of open closure types in clean and straightforward way .",
    "this is the first important step for using such types in more sophisticated type systems for resource usage and termination .",
    "our type system for data - flow tracking captures higher - order data - flow information . as a byproduct ,",
    "we get our secondary contribution , a non - interference property in the sense of information flow theory : high - level inputs do not influence the ( low - level ) results of computations .",
    "to experiment with of our type system , we implemented a software prototype in ocaml ( see section  [ sec : impl ] ) .",
    "a full version of this article , containing the full proofs and additional details and discussion , is available online .      in our type system",
    "we maintain the invariant that open closure types only refer to variables that are present in the current typing context .",
    "this is a feature that distinguishes open closure types from existing formalisms for closure types .",
    "for example , while our function type @xmath30(x { \\mathpunct{:}\\!}\\sigma_1 ) } \\to \\sigma_2}$ ] superficially resembles a contextual arrow type @xmath31(\\sigma_1 \\to \\sigma_2)$ ] of contextual type theory@xcite , we are not aware of any actual connection in application or metatheory with these systems .",
    "in particular , the variable in our captured context @xmath32 are _ bound occurrences _ of the ambient typing context , while the context @xmath33 of a contextual type @xmath31t$ ] _ binds _ metavariables to be used to construct inhabitants .",
    "as such a binding can make sense in any context , our substitution judgment has no counterpart in contextual type theory , or other modal type theories for multi - stage programming ( @xcite ) .    having closure types carry",
    "a set of captured variables has been done in the literature , as for example in leroy  @xcite , which use closure types to keep track of of _ dangerous type variables _ that can not be generalized without breaking type safety , or in the higher - order lifetime analysis of hannan et al .",
    "@xcite , where variable sets denote variables that must be kept in memory .",
    "however , these works have no need to vary function types in different typing contexts and subtyping can be defined using set inclusion , which makes the metatheory significantly simpler . on the contrary",
    ", our scoping mechanism allows to study more complex properties , such as value dependencies and non - interference .",
    "the classical way to understand value capture in closures in a typed way is through the _ typed closure conversion _ of minamide et al .",
    "they use existential types to account for hidden data in function closures without losing compositionality , by abstracting over the difference between functions capturing from different environments .",
    "our system retains this compositionality , albeit in a less apparent way : we get finer - grained information about the dependency of a closure on the ambient typing environment .",
    "typed closure conversion is still possible , and could be typed in a more precise way , abstracting only over values that are outside the lexical context .",
    "petricek et al .",
    "@xcite study _ coeffects _ systems with judgments of the form @xmath34 and function types @xmath35 , where @xmath36 and @xmath37 are coeffect annotations over an indexed comonad @xmath38 .",
    "their work is orthogonal to the present one .",
    "they study comonadic semantics and algebraic structure of effect indices . these indices are simply booleans in our work but we focus on the syntactic scoping rules that arise from tracking each variable of the context separately . the non - interference property that we prove is different from the usual treatment in type systems for information flow like the slam calculus  @xcite . in slam ,",
    "the information flow into closure is accounted for at abstraction time .",
    "in contrast , we account for the information flow into the closure at application time .",
    "we define a type system for the simplest problem domain that exhibits a need for open closure types .",
    "our goal is to determine statically , for an open term @xmath12 , on which variables of the environment the value of @xmath12 depends .",
    "we are interested in weak reduction , and assume a call - by - value reduction strategy . in this context ,",
    "an abstraction @xmath39 is already a value , so reducing it does not depend on the environment at all .",
    "more generally , for a term @xmath12 evaluating to a function ( closure ) , we make a distinction between the part of the environment the reduction of @xmath12 depends on , and the part that will be used when the resulting closure will be applied . for example , the term @xmath40 depends on the variable @xmath18 at evaluation time , but will not need the variable @xmath41 until the closure in the right pair component is applied .",
    "this is where we need open closure types .",
    "our function types are of the form @xmath30(x { \\mathpunct{:}\\!}\\sigma^\\phi ) } \\to \\tau}$ ] , where the mapping @xmath42 from variables to booleans indicates on which variables the evaluation depends at application time .",
    "the boolean @xmath43 indicates whether the argument @xmath24 is used in the function body .",
    "we call @xmath42 the dependency annotation of @xmath14 .",
    "our previous example would for instance be typed as follows .",
    "@xmath44(x { \\mathpunct{:}\\!}\\rho^0 ) } \\to \\tau } )   \\belowdisplayskip 0.5em\\ ] ] the typing expresses that the result of the computation depends on the variable @xmath18 but not on the variable @xmath41 .",
    "moreover , result of the function in the second component of the pair depends on @xmath41 but not on @xmath18 .    in general ,",
    "types are defined by the following grammar . @xmath45(x { \\mathpunct{:}\\!}\\sigma^\\phi ) } \\to \\tau } & \\mbox{closures } \\\\ \\end{array}\\ ] ]    the closure type @xmath30(x { \\mathpunct{:}\\!}\\sigma^\\phi ) } \\to \\tau}$ ] binds the new argument variable @xmath24 , but not the variables occurring in @xmath14 which are reference variables bound in the current typing context .",
    "such a type is _ well - scoped _ only when all the variables it closes over are actually present in the current context . in particular",
    ", it has no meaning in an empty context , unless @xmath14 is itself empty .",
    "we define well - scoping judgments on contexts ( @xmath46 ) and types ( @xmath47 ) .",
    "the judgments are defined simultaneously in figure  [ fig / scoping ] and refer to each another .",
    "they use non - annotated contexts : the dependency annotations characterize data - flow information of _ terms _ , and are not needed to state the well - formedness of static types and contexts .    fig / scopingwell - scoping of types and contexts +    notice that the closure contexts appearing in the return type of a closure , @xmath48 in our rule , may capture the variable @xmath24 corresponding to the function argument , which is why we chose the dependent - arrow  like notation @xmath49 rather than only @xmath50 .",
    "there is no dependency of types on terms in this system , this is only used for scope tracking .",
    "note that @xmath47 implies @xmath46 ( as proved by direct induction until an atom or a function closure is reached ) .",
    "note also that a context type @xmath51(x{\\mathpunct{:}\\!}\\sigma ) } \\to \\tau}$ ] is well - scoped in any larger environment @xmath52 : the context information may only mention variables existing in the typing context , but it need not mention all of them . as a result , well - scoping",
    "is preserved by context extension : if @xmath53 and @xmath54 , then @xmath55 .",
    "our term language , is the lambda calculus with pairs , let bindings and fixpoints .",
    "this language is sufficient to discuss the most interesting problems that arise in an application of closure types in a more realistic language .",
    "@xmath56    for didactic purposes , we start with an intuitive type system presented in figure  [ fig / naive - typing ] .",
    "the judgment @xmath57 means that the expression @xmath12 has type @xmath25 , in the context @xmath14 carrying the intensional information @xmath42 .",
    "context variable mapped to @xmath58 in @xmath42 are not used during the reduction of @xmath12 to a value . we will show that the rules and are not correct , and introduce a new judgment to develop correct versions of the rules .",
    "fig / naive - typingnaive rules for the type system    in a judgment @xmath59(x { \\mathpunct{:}\\!}\\sigma^0 ) } \\to \\tau}$ ] , @xmath14 is bound only in one place ( the context ) , and @xmath60-renaming any of its variable necessitates a mirroring change in its right - hand - side occurrences ( @xmath32 but also in @xmath25 and @xmath48 ) , while @xmath24 is independently bound in the term and in the type , so the aforementioned type is equivalent to @xmath30(y { \\mathpunct{:}\\!}\\sigma ) } \\to \\tau[y / x]}$ ] . in particular , variables occurring in types",
    "do _ not _ reveal implementation details of the underlying term .",
    "the syntax @xmath61 used in the and rules is a product , or conjunction , of the single boolean dependency annotation @xmath43 , and of the vector dependency annotation @xmath42 .",
    "the sum @xmath62 is the disjunction . in the rule for example ,",
    "if the typing of @xmath63 determines that the evaluation of @xmath63 does not depend on the definition @xmath64 ( @xmath43 is @xmath58 ) , then @xmath65 will mark all the variables used by @xmath66 as not needed as well ( all @xmath58 ) , and only the variables needed by @xmath63 will be marked in the result annotation @xmath67 .    in the scoping judgment @xmath68(x { \\mathpunct{:}\\!}\\sigma ) } \\to \\tau}$ ] , the repetition of the judgment @xmath14 is redundant",
    ". we could simply write @xmath69(x { \\mathpunct{:}\\!}\\sigma ) } \\to \\tau}$ ] ;  because in our simplified setting the intensional information @xmath42 can be easily separated from the rest of the typing information , corresponding to simply - typed types . however , we found out that such a reformulation made technical developments harder to follow ; the @xmath32 form allows one to keep track precisely of the domain of the dependency annotation , and domain changes are precisely the difficult technical aspect of open closure types . for a more detailed discussion of this design point , see the full version of this article .    in the introduction we present closure types of the form",
    "@xmath70(x { \\mathpunct{:}\\!}\\sigma ) } \\to \\tau}$ ] , while we here use the apparently different form @xmath30(x { \\mathpunct{:}\\!}\\sigma^\\phi ) } \\to \\tau}$ ] .",
    "this new syntax is actually a simpler special case of the previous one : we could consider a type grammar of the form @xmath71 , and the type @xmath70(x { \\mathpunct{:}\\!}\\sigma ) } \\to \\tau}$ ] would then capture all the needed information , as each type in @xmath14 would come with its own annotation .",
    "instead , we do nt embed dependency information in the types directly , and use annotated context @xmath32 to carry equivalent information .",
    "this simplification makes it easier to control the scoping correctness : it is easier to notice that @xmath32 and @xmath72 are contexts ranging over the same domain than if we wrote @xmath14 and @xmath15 .",
    "it is made possible by two specific aspects of this simple system :    * our intensional information has a very simple structure , only a boolean , that does not apply to the types in depth .",
    "the simplification would not work , for example , in a security type system where products could have components of different security levels ( @xmath73 ) , but the structure of the rules would remain the same . * in this example , we are interested mostly in intensional information on the contexts , rather than the return type of a judgment .",
    "the general case rather suggests a judgment of the form @xmath74 , but with only boolean annotations this boils to a judgment @xmath75 , when we are interested in the value being type - checked , and a trivial judgment @xmath76 , used to type - check terms that will not be used in the rest of the computation , and which degenerates to a check in the simply - typed lambda - calculus .",
    "instead , we define a single judgment @xmath57 corresponding to the case where @xmath43 is @xmath77 , and use the notation @xmath61 to nullify the dependency information coming of from @xmath12 when the outer computation does not actually depend on it ( @xmath43 is @xmath58 ) .",
    "while dependency annotations make the development easier to follow , they do not affect the generality of the type theory , as the common denominator of open closure type systems is more concerned with the scoping of closure contexts than the structure of the intensional information itself .",
    "as pointed out before , the rules and of the system above are wrong ( hence the `` temporary '' name ) : the left - hand - side of the rule assumes that the closure captures the same environment @xmath14 that it is computed in .",
    "this property is initially true in the closure of the rule , but is not preserved by ( for the body type ) or ( for the return type ) .",
    "this means that the intensional information in a type may become stale , mentioning variables that have been removed from the context .",
    "we will now fix the type system to never mention unbound variables .",
    "we need a _ closure substitution mechanism _ to explain the closure type @xmath78(x { \\mathpunct{:}\\!}\\sigma^\\phi ) } \\to \\tau^\\psi}$ ] of a closure @xmath7 in the smaller environment @xmath14 , given dependency information for @xmath18 in @xmath14 .",
    "assume for example that @xmath18 was bound in a let binding @xmath79 and that the type @xmath80 leaves the scope of @xmath18 .",
    "then we have to adapt the type rules to express the following . `` if @xmath7 depends on @xmath18 ( at application time ) then @xmath7 depends on the variables of @xmath14 that @xmath12 depends on . ''",
    "fig / type - substitutiontype substitution    we define in figure  [ fig / type - substitution ] the judgment @xmath81 . assuming that the variable @xmath18 in the context @xmath82 was let - bound to an definition with usage information @xmath72 , this judgment transforms any type @xmath25 in this context in a type @xmath48 in a context @xmath83 that does not mention @xmath18 anymore .",
    "note that @xmath84 and @xmath85 have the same domain , only their intensional information changed : any mention of @xmath18 in a closure type of @xmath84 was removed in @xmath85 .",
    "also note that @xmath86 and @xmath83 , or @xmath25 and @xmath48 , are not annotated with dependency annotations themselves : this is only a scoping transformation that depends on the dependency annotations of @xmath18 _ in the closures _ of @xmath25 and @xmath84 .    as for the scope - checking judgment",
    ", we simultaneously define the substitutions on contexts themselves @xmath87 .",
    "there are two rules for substituting a closure type",
    ". if the variable being substituted is not part of the closure type context ( rule ) , this closure type is unchanged . otherwise ( rule ) the substitution is performed in the closure type , and the neededness annotation for @xmath18 is reported to its definition context @xmath88 .    the following lemma verifies that this substitution preserves well - scoping of contexts and types .",
    "[ lem : substitution_preserves_scoping ] if @xmath89 and @xmath87 then @xmath90 . if @xmath91 and @xmath92 then @xmath93 .    by mutual induction on the judgments @xmath94 and + @xmath95 .       : using , @xmath96 implies @xmath47 , which in turn implies @xmath46 .       : from our hypothesis @xmath97 we deduce @xmath91 . by induction",
    "we can deduce @xmath98 , which gives context well - formedness @xmath90 .",
    ": direct by and induction hypothesis .",
    ": by inversion , the last rule of the derivation of @xmath99 is , so we can proceed by direct induction on the premises of both judgments .       : using our induction hypothesis on @xmath100 we can deduce that @xmath101 and in particular @xmath90 .    by inversion , the last rule of the derivation of @xmath102(y : \\sigma_1^{\\phi_1 } ) } \\to \\sigma_2}$ ] is .",
    "its premises are @xmath103 and @xmath104 , from which we deduce by induction hypothesis @xmath105 and @xmath106 respectively , allowing to deduce that @xmath107(x : \\tau_1 ) } \\to \\tau_2}$ ] , which allows to conclude by weakening with the well - scoped @xmath108 .",
    ": direct by induction and inversion .",
    "we can now give the correct rules for binders :    [ lem : typing_preserves_scoping ] if @xmath109 holds , then @xmath47 holds .",
    "this lemma guarantees that we fixed the problem of stale intensional information : types appearing in the typing judgment are always well - scoped .    by induction on the derivation of @xmath109 .       : from the premise @xmath110 we have @xmath47 .       :",
    "direct by induction .       :",
    "the induction hypothesis is @xmath111 , from which we get @xmath112 ( for @xmath113 ) by inversion .       :",
    "the induction hypothesis is @xmath114 . from this",
    "we get @xmath115 and therefore @xmath47 , which allows to conclude with .",
    ": using our induction hypothesis on the first premise give us that @xmath116(x { \\mathpunct{:}\\!}\\sigma ) } \\to \\tau}$ ] , so by inversion @xmath54 and @xmath117 .",
    "the latter fact can be weakened into @xmath118 , and then combined with the last premise @xmath119 and lemma  [ lem : substitution_preserves_scoping ] to get our goal @xmath120 .",
    ": reasoning similar to the app case .",
    "by induction on the middle premise , we have @xmath114 , combined with the right premise @xmath121 we get @xmath122 .",
    "it is handy to introduce a convenient derived notation @xmath123 that is defined below .",
    "this substitution relation does not only remove @xmath18 from the open closure types in @xmath14 , it also updates the dependency annotation on @xmath14 to add the dependency @xmath33 , corresponding to all the variables that @xmath18 depended on  if it is itself marked as needed .",
    "0em 0em    it is interesting to see that substituting @xmath18 away in @xmath124 changes the annotation on @xmath14 , but not its types ( @xmath14 is unchanged in the output as its types may not depend on @xmath18 ) , while it changes the types in @xmath84 but not its annotation ( @xmath125 is unchanged in the output as a value for @xmath18 may only depend on variables from @xmath14 , not @xmath84 ) .    the following technical results allow us to permute substitutions on unrelated variables",
    ". they will be used in the typing soundness proof of the next section  ( theorem  [ thm : sound ] ) .",
    "[ lem : confluence ] if @xmath126 and @xmath127 then there exists a unique @xmath128 such that @xmath129    without loss of generality we can assume that @xmath130 appears before @xmath131 in @xmath132 , so in particular @xmath133 . for any subcontext of the form @xmath134 , assume that substituting @xmath135 for @xmath130 first results in @xmath136 , while substituting @xmath137 for @xmath131 first results in @xmath138 . substituting @xmath139 for @xmath131 in @xmath136 results in @xmath140 which simplifies to @xmath141 substituting @xmath142 for @xmath130 in @xmath138 results in @xmath143 which simplifies to @xmath144    given that @xmath145 and @xmath146 have the same domain ( only different types ) , the restrictions @xmath147 and @xmath148 are equal , allowing to conclude that the two substitutions indeed end in the same sequent @xmath149    note that we can make sense , informally , of this resulting sequent .",
    "the variable used by this final contexts are    * the variables used of @xmath150 used in the initial judgment ( @xmath151 ) * the variables of @xmath145 ( updated in @xmath146 to remove references to the substituted variable @xmath130 ) used in the initial judgment ( @xmath152 ) * the variables used by @xmath137 , if it is used ( @xmath153 is @xmath77 ) * the variables used by @xmath135 if either @xmath24 was used ( @xmath154 is @xmath77 ) , or if @xmath131 is used ( @xmath153 is @xmath77 ) and itself uses @xmath130 ( @xmath155 is @xmath77 ) .    to get this intuition , we considered again the annotations as booleans , but note that the equivalence proof was done in a purely algebraic manner .",
    "it should therefore be preserved in future work where the intensional information has a richer structure .",
    "[ lem : reordering ] if @xmath135 and @xmath137 have domain @xmath14 , and @xmath156 then there exists @xmath157 such that @xmath158      note that the handles the function type on the left - hand - side of the arrow , @xmath159 , is a specific and subtle way : it must be unchanged by the substitution judgment . under a slightly simplified form ,",
    "the judgment reads :    this corresponds to the usual `` change of direction '' on the left of arrow type .",
    "a substitution @xmath160 is a lossy transformation , as we forget how @xmath18 is used in @xmath48 and instead mix its definition information with the rest of the context information in @xmath161 .",
    "such a loss makes sense for the return type of a function : we forget information about the return value .",
    "but by contravariance of input argument , we should instead _ refine _ the argument types .",
    "but as the gain or loss or precision correspond to variables going out of scope , such a refinement could only happen in smaller nested scopes .",
    "on the contrary , when going out to a wider scope , the only possibility is that the closure type does not depend on the particular variable being substituted ( so the type @xmath25 is preserved , @xmath162 ) . if the variable was used , a loss of precision would be possible : this substitution must be rejected .",
    "consider the following example :    .... ( * in context $ \\gamma$ * )    let x : int = e_x in       let y : bool = e_y in        let f ( g : $ \\tfun{\\gamma^0 , x\\of\\tyc{int}^1}{z:\\tyc{unit^0}}{\\tyc{int}}$ ) : $ \\tyc{int}$ = g ( ) in        f ( $ \\lambda$z .",
    "x ) ;        f ....    in the environment @xmath163 , the type of ` f ` s function argument ` g ` describes a function whose result depends on ` x ` . we can still express this dependency when substituting the variable ` y ` away , that is when considering the type of the expression ` ( let y = ... in let f g = ... in f ) ` as a whole : the argument type will still have type @xmath164(z:{\\mathtt{unit } } ) } \\to { \\mathtt{int}}}$ ] .",
    "however , this dependency on ` x ` can not make sense anymore if we remove ` x ` itself from the context , the substitution does not preserve this function type .",
    "this makes the whole expression ` ( let x = ... in ( let y = ... in let f g = ... in f ) ) ` ill - typed , as ` x ` escapes its scope in the argument function type .",
    "one way to understand this requirement is that there are two parts to having an analysis be fully `` higher - order '' .",
    "fist , it handles programs that take functions as input , and second , it handles programs that return functions as result of computations .",
    "some languages only pass functions as parameters ( this is in particular the case of c with pointers to global functions ) , some constructions such as currying fundamentally rely on function creation with environment capture .",
    "our system proposes a new way to handle this second part , and is intensionally simplistic , to the point of being restrictive , on the rest .    in a non - toy language",
    "one would want to add subtyping of context information , that would allow controlled loss of precision to , for example , create lists of functions with slightly different context information . another useful feature would be context information polymorphism to express functions being parametric with respect to the context information of their argument .",
    "this is intentionally left to future work .",
    "in this section , we will define an operational semantics for our term language , and use it to prove the soundness of the type system ( theorem  [ thm : sound ] ) .",
    "our semantics is equivalent to the usual call - by - value big - step reduction semantics for the lambda - calculus in the sense that computation happens at the same time .",
    "there is however a notable difference .",
    "function closures are not built in the same way as they are in classical big - step semantics .",
    "usually , we have a rule of the form @xmath165 where the closure for @xmath166 is a pair of the value environment @xmath167 ( possibly restricted to its subset appearing in @xmath168 ) and the function code .",
    "in contrast , we capture no values at closure creation time in our semantics : @xmath169 .",
    "the captured values will be added to the closure incrementally , during the reduction of binding forms that introduced them in the context .",
    "consider for example the following two derivations ; one in the classic big - step reduction , and the other in our alternative system .    rather than capturing the whole environment in a closure , we store none at all at the beginning ( merely record their names ) , and add values incrementally , just before they get popped from the environment .",
    "this is done by the _ value substitution _",
    "judgment @xmath170 that we will define in this section .",
    "the reason for this choice is that this closely corresponds to our typing rules , value substitution being a runtime counterpart to substitution in types @xmath171 ; this common structure is essential to prove of the type soundness ( theorem  [ thm : sound ] ) .",
    "note that derivations in this modified system and in the original one are in one - to - one mapping .",
    "it should not be considered a new dynamic semantics , rather a reformulation that is convenient for our proofs as it mirrors our static judgment structure .",
    "values are defined as follows .",
    "\\in j } } , ( x_i \\mapsto v_i)_{{i\\in i } } , { \\lambda x . }",
    "t )                 & \\mbox{function closures } \\\\",
    "\\fixpoint {        & \\mid & ( { [ x_j]}_{{j \\in j } } , ( x_i \\mapsto v_i)_{{i\\in i } } , { \\ensuremath{\\texttt{fix } \\ , f \\ , x . } } t )                 & \\mbox{recursive function closures } \\\\ } { } \\end{array}\\ ] ]    the set of variables bound in a closure is split into an ordered mapping @xmath173 for variables that have been substituted to their value , and a simple list @xmath174}_{{j \\in j}}$ ] of variables whose value has not yet been captured .",
    "they are both binding occurrences of variables bound in @xmath168 ; @xmath60-renaming them is correct as long as @xmath168 is updated as well .    to formulate our type soundness result , we define a typing judgment on values @xmath175 in figure  [ fig / value - typing ] . an intuition for the rule",
    "is the following .",
    "internally , the term @xmath168 has a dependency @xmath32 on the ambient context , but also dependencies @xmath176 on the captured variables . but externally , the type may not mention the captured variables , so it reports a different dependency @xmath177 that corresponds to the internal dependency @xmath32 , combined with the dependencies @xmath178 of the captured values .",
    "both families @xmath179 and @xmath180 are existentially quantified in this rule .    in the judgment rule",
    ", the notation @xmath181 is meant to define the environment of each @xmath182 as @xmath32 , plus all the @xmath183 that come before @xmath184 in the typing judgment @xmath185 .",
    "the notation @xmath186 denotes the sequence of substitutions for all @xmath187 , with the rightmost variable ( introduced last ) substituted first : in our dynamic semantics , values are captured by the closure in the lifo order in which their binding variables enter and leave the lexical scope .",
    "fig / value - typingvalue typing      the value substitution judgment , define in figure  [ fig / value - substitution ] , is an operational counterpart to the substitution of variables in closures types .    in the typing rules",
    ", we use the substitution relation @xmath188 to remove the variable @xmath18 from the closure types in @xmath25 .",
    "correspondingly , in our runtime semantics , we _",
    "add _ the variable @xmath18 to the vector stored in the closure value , by a value substitution judgment @xmath189 ( see figure  [ fig / value - substitution ] ) when the binding of @xmath18 is removed from the evaluation context .",
    "fig / value - substitutionvalue substitution    in the , the notation @xmath190 means that the binding @xmath191 is added in first position in the vector of captured values .",
    "the values @xmath192 were computed in a context depending on @xmath18 , so they need to appear after the binding @xmath191 for the value to be type - correct .",
    "[ lem : value_substitution_preserves_typing ] if @xmath193 , @xmath194 , @xmath195 and @xmath196 hold , then @xmath197 holds .",
    "note that this theorem is restricted to substitutions of the rightmost variable of the context .",
    "while substitution in types needs to operate under binders ( in rule ) , value substitution is a runtime operation that will only be used by our ( weak ) reduction relation on the last introduced variable .    by induction on the value typing judgment @xmath198 .",
    ": by inversion we know that the last rule of @xmath199 is . from the premise @xmath200 and @xmath201 we can deduce from lemma  [ lem : substitution_preserves_scoping ] that @xmath46 , which allows to conclude @xmath202 .",
    ": by inversion , the last rules of @xmath203 and @xmath189 are respectively and , so by induction hypothesis we have @xmath204 and @xmath205 , which allows us to conclude @xmath206 .       . by inversion",
    "we know that the last substitution rules applied are either and , or and , depending on whether the substituted variable is part of the closure context .    in the latter case ,",
    "both the types and the judgments are unchanged , so the result is immediate . if the substituted value is part of the closure context , the rules of the involved judgments are    we can reach our goal by using the following inference rule :    the typing assumptions all match those of our premise . the reduction assumption is simply the composition of the reductions of the premises : @xmath207      we are now equipped to define in figure  [ fig / reduction ] the big - step reduction relation on well - typed terms @xmath208 , where @xmath167 is a mapping from the variables to values that is assumed to contain at least all the free variables of @xmath12 .",
    "the notation @xmath209 denotes the sequence of substitutions for each ( variable , value ) pair in @xmath210 , from the last one introduced in the context to the first ; the intermediate values are unnamed and existentially quantified .",
    "fig / reductionbig - step reduction rules    we write @xmath211 if the context valuation @xmath167 , mapping free variables to values , is well - typed according to the context @xmath14 .",
    "0em0em    [ thm : sound ] if @xmath212 , @xmath211 and @xmath213 then @xmath175 .    by induction on the reduction derivation @xmath213 .       : from @xmath211 we have @xmath214 .       : in the degenerate case where there are no captured values , the value typing rule for @xmath30(x { \\mathpunct{:}\\!}\\sigma^\\phi ) } \\to \\tau}$ ] has as only premise @xmath215 , which is precisely our typing assumption .       , :",
    "direct by induction .       :",
    "the involved derivations are the following :    by induction hypothesis we have @xmath216 , from which we deduce that @xmath217 .",
    "this allows us to use induction again to deduce that @xmath218 .",
    "finally , preservation of value typing by value substitution ( lemma  [ lem : value_substitution_preserves_typing ] ) allows to conclude that the remaining goal @xmath219 holds .       : the involved derivations are the following .",
    "by induction we have that @xmath220 and @xmath221(y { \\mathpunct{:}\\!}\\sigma^\\phi ) } \\to \\tau}$ ] .    by inversion , we know that the derivation for this value typing judgment is of the form @xmath222(y { \\mathpunct{:}\\!}\\sigma^\\phi ) } \\to \\tau}}\\ ] ]    from our result @xmath223 and the premises @xmath224 we deduce that the application valuation is well - typed with respect to the application environment : @xmath225",
    ". it is used in the premise of the body computation judgment , so by induction we get that @xmath226 .",
    "from there , we wish to use preservation of value typing on the chain of value substitutions @xmath227 to conclude that @xmath228 .",
    "however , the type substitutions of our premises are in the reverse order : @xmath229 we therefore need to use our reordering lemma  ( [ lem : reordering ] ) to get them in the right order  note that the annotations @xmath180 and @xmath230 are not changed as they are independent from each other : for any @xmath8 , we have @xmath231 .",
    "@xmath232    fig / classic - reductionclassic big - step reduction rules     +    finally , we recall the usual big - step semantics for the call - by - value calculus with environments , in figure  [ fig / classic - reduction ] , and state its equivalence with our utilitarian semantics .",
    "due to space restriction we will only mention the rules that differ , and elide the equivalence proof , but the long version contains all the details .    there is a close correspondence between judgments of both semantics , but as the value differ slightly , in the general cases the value bindings of the environment will also differ .",
    "we state the theorem only for closed terms , but the proof will proceed by induction on a stronger induction hypothesis using an equivalence between non - empty contexts .    [",
    "thm : sem - equiv ] our reduction relation is equivalent with the classic one on closed terms : @xmath233 holds if and only if @xmath234 also holds .    to formulate our induction hypothesis , we define the equivalence judgment @xmath235 ; on each side of the equal sign there is a context and a value , the right - hand side being considered in the classical semantics .",
    "fig / equivequivalence of semantic judgements .",
    "the stronger version of the theorem becomes the following : if @xmath236 and @xmath213 and @xmath237 , then @xmath235 .",
    "as for subject reduction , we first need to prove that value substitution preserves value equivalence .    if @xmath238 , @xmath239 , and @xmath240 then @xmath241 .       :",
    "direct .       : direct induction .",
    ": we have @xmath242 and @xmath243 .",
    "the latter implies @xmath244 which which in turn implies our goal @xmath245  with the additional premise @xmath236 from our hypothesis @xmath239 .",
    "we can now prove the theorem proper :       , : we check by direct induction on the contexts that if @xmath236 holds , then @xmath246 .",
    ", : the correspondence between @xmath247 and @xmath248 under assumption @xmath236 is direct from the inference rule @xmath249       , and , : direct by induction .       , : by induction hypothesis on the @xmath66 premise , we deduce that @xmath250 , hence @xmath251 .",
    "this lets us deduce , again by induction hypothesis , that @xmath252 .",
    "as value substitution preserves value equivalence , we can deduce from @xmath253 that our goal @xmath254 holds .       , : by induction hypothesis we have that @xmath255 and @xmath256 . by inversion on the value equivalence judgment of the latter we know that @xmath257 .",
    "combined with the former value equivalence , this gives us @xmath258 , so by induction hypothesis and preservation of value equivalence by reduction we can deduce our goal .",
    "we can formulate our dependency information as a _ non - interference _ property .",
    "two valuations @xmath167 and @xmath259 are @xmath42-equivalent , noted @xmath260 , if they agree on all variables on which they depend according to @xmath42 .",
    "we say that @xmath12 respects non - interference for @xmath42 when , whenever @xmath208 holds , then for any @xmath259 such that @xmath260 we have that @xmath261 also holds .",
    "this corresponds to the information - flow security idea that variables marked @xmath77 are low - security , while variables marked @xmath58 are high - security and should not influence the output result .",
    "this non - interference statement requires that the two evaluations of @xmath12 return the same value @xmath262 .",
    "this raises the question of what is the right notion of equality on values .",
    "values of atomic types have a well - defined equality , but picking the right notion of equality for function types is more difficult . while we can state a non - interference result on atomic values only , the inductive subcases would need to handle higher - order cases as well .",
    "syntactic equality ( even modulo @xmath60-equivalence ) is not the right notion of equality for closure values .",
    "consider the following example : @xmath263(z:\\sigma^1 ) } \\to \\sigma}$ ] .",
    "this term contains an occurrence of the variable @xmath24 , but its result does not depend on it .",
    "however , evaluating it under two different contexts @xmath264 and @xmath265 , with @xmath266 , returns distinct closures : @xmath267 on one hand , and @xmath268 on the other .",
    "these closures are not structurally equal , but their difference is not essential since they are indistinguishable in any context .",
    "logical relations are the common technique to ignore those internal differences and get a more observational equality on functional values .",
    "they involve , however , a fair amount of metatheoretical effort that we would like to avoid .",
    "consider a different example : @xmath269(y { \\mathpunct{:}\\!}\\sigma^0 ) } \\to \\tau}$ ] .",
    "again , we could use two contexts @xmath264 and @xmath265 with @xmath266 , and we would get as a result two closures : @xmath270 and @xmath271 . interestingly ,",
    "these two closures are _ not _ equivalent under all contexts : any context applying the function will be able to observe the different results .",
    "however , our notion of interference requires that they can be considered equal .",
    "this is motivated by real - world programming languages that only output a pointer to a closure in a program that returns a function .    while the aforementioned closures are not equal in any context , they are in fact equivalent from the point of view of the particular dependency annotation for which we study non - interference , namely @xmath272 . to observe the difference between those closures",
    ", we would need to apply the closure of type @xmath273(y:\\sigma ) } \\to \\tau}$ ] , so would be in the different context @xmath274 .",
    "this insight leads us to our formulation of value equivalence in figure  [ fig / value - equiv ] . instead of being as modular and general as a logical - relation definition",
    ", we fix a _ global dependency _",
    "@xmath275 that restricts which terms can be used to differentiate values .",
    "fig / value - equivvalue equivalence    our notion of value equivalence , @xmath276 is typed and includes structural equality . in the rule",
    ", we check that the two closures values are well - typed , and only compare captured values whose dependencies are included in those of the global context @xmath275 , as we know that the others will not be used .",
    "this equality is tailored to the need of the non - interference result , which only compares values resulting from the evaluation of the same subterm  in distinct contexts .",
    "[ thm : non - inter ] if @xmath277 holds , then for any contexts @xmath278 such that @xmath279 and values @xmath280 such that @xmath208 and @xmath281 , we have @xmath276",
    ". in particular , if @xmath25 is an atomic type , then @xmath282 holds .",
    "we will proceed by simultaneous induction on the typing derivation @xmath283 and reduction derivation @xmath208 and .",
    "note that we use a different induction hypothesis : for any subderivations @xmath57 and @xmath213 , we will prove that for any @xmath259 that agrees with @xmath167 on @xmath42 modulo @xmath275-equivalence ( @xmath284 , which we still note @xmath260 ) , and with @xmath285 , we have @xmath286 .",
    "we will omit the contexts and types @xmath287 of a value equivalence @xmath276 when they are clear from the context .       : from @xmath288 we have @xmath289 .       :",
    "the returned value does not depend on the environment .",
    ", : direct by induction .       :",
    "the involved derivations are the form    the context equivalence @xmath290 implies the weaker equivalence @xmath291 , from which we can deduce @xmath292 regardless of the value of @xmath43 . indeed , if @xmath43 is @xmath58 this is direct , and if @xmath43 is @xmath77 we get @xmath293 by induction hypothesis . from this equality between contexts",
    "we get @xmath294 by induction hypothesis .",
    "we then reason by case distinction on the property @xmath295 .",
    "if it holds , then again @xmath293 by induction , so substituting @xmath296 in the closures of @xmath297 will preserve @xmath275-equivalence . and",
    "if it does not , those values @xmath296 captured in the closures of @xmath297 will not be tested for @xmath275-equivalence . in any case , we have @xmath298 .       :",
    "the proof for the application case uses the same mechanisms as for the case but is more tedious because of the repeated application and substitution of the closed - over values . to simplify notations",
    ", we will handle the case of a single captured value @xmath299 .",
    "the involved derivations are the following :    from @xmath300 we get by induction that @xmath301(y{\\mathpunct{:}\\!}\\sigma^\\phi ) } \\to \\tau}$ ] .",
    "this equivalence gives us the following premises : @xmath302(y{\\mathpunct{:}\\!}\\sigma^\\phi ) } \\to \\tau}}\\ ] ]    if @xmath303 then @xmath286 , and similarly we get @xmath304 only in the case where @xmath305 , that is @xmath43 ( the argument dependency ) is @xmath77 . in any case ,",
    "@xmath306 and @xmath307 are @xmath275-equivalent by induction , and by construction this is preserved by the substitutions @xmath308 and @xmath309 .",
    "to experiment with our type system , we implemented a software prototype in ocaml . at",
    "around one thousand lines , the implementation mainly contains two parts .    1 .   for each judgement in this paper , a definition of corresponding set of inference rules along with functions for building and checking derivations .",
    "2 .   a ( rudimentary ) command - line interface that is based on a lexer , a parser , and a pretty - printer for the expressions , types , judgments and derivations of our system .    for the scope checking judgments for context and types , the implementation _ checks _ well - scoping of the given contexts and types . it either builds a derivation using the well - scoping rules or fails to do so because of ill - scoped input .    for the typing judgment",
    ", the implementation performs some _ inference_. given a type context @xmath14 and an expression @xmath12 , it returns @xmath42 , @xmath25 , and a derivation @xmath310 if such a derivation exists .",
    "otherwise it fails .",
    "the substitution and reduction judgments are deterministic and computational in nature .",
    "our implementation takes the left - hand side a judgement ( with additional parameters ) and _ computes _ the right - hand - side of the judgment along with a derivation .",
    "below is an example of interaction with the prototype interface :    .... % make % ./closures.byte -str \" let y = ( y1 , y2 ) in ( y , \\(x:\\sigma ) z ) \" parsed expression : let y = ( y1 , y2 ) in ( y , $ \\lambda$(x:$\\sigma$ ) z )    the variables ( y1 , y2 , z ) were unbound ; we add them to the default environment with dummy types ( ty_y1 , ty_y2 , ty_z ) and values ( val_y1 , val_y2 , val_z ) .",
    "inferred typing :    y1:ty_y1$^1$,y2:ty_y2$^1$,z : ty_z$^0 $ $ \\vdash$      let y = ( y1 , y2 ) in ( y , $ \\lambda$(x:$\\sigma$ ) z )      : ( ( ty_y1 * ty_y2 ) * [ y1:ty_y1$^0$,y2:ty_y2$^0$,z : ty_z$^1$](x:$\\sigma^0 $ ) $ \\rightarrow$ ty_z )    result value :      $ \\!$((val_y1 , val_y2 ) , ( [ y1,y2,z ] , ( ( y $ \\mapsto \\!$ ( val_y1 , val_y2 ) ) ) , $ \\lambda$(x ) z ) ) ....    in this example , adapted from the starting example of the article , @xmath311 , one can observe that the value @xmath41 is marked as non - needed by the global value judgment , but needed in the type of the closure @xmath312 . besides , the computed value closure has captured the local variable @xmath18 , but still references the variables @xmath313 , and @xmath41 of the outer context .",
    "the prototype can also produce ascii rendering of the typing and reduction derivations , when passed ` typing - derivation ` or ` reduction - derivation ` .",
    "this can be useful in particular in the case of typing or reduction errors , as a way to locate the erroneous sub - derivation .",
    "the complete source code of the prototype is available at the following url : + http://gallium.inria.fr/~scherer/research/open_closure_types",
    "before we conclude , we highlight three technical points that deserve a more in - depth discussion and that are helpful link our work to existing and future work .",
    "it is interesting to relate our open closure types and typed closure conversion of minamide et al .",
    "@xcite . in the classical semantics ,",
    "a @xmath314-term @xmath315 evaluates under the value binding @xmath316 to a pair @xmath317 , which can be given the type @xmath318 ( writing @xmath14 for the product of all types in the context ) . to combine closures of the same observable type that capture different environments",
    ", one needs to abstract away the environment type by using the existential type @xmath319 .    in our specific semantics , a closure that was originally defined in the environment @xmath320 but is then seen in the environment @xmath14 , only captures the values of variables in @xmath84 . typed closure conversion is still possible , but we would need to give it the less abstract type @xmath321 .",
    "this reflects how our open closure types allow closure types to contain static information about variables of the current lexical context , while still allowing free composition of closures that were initially defined in distinct environments .",
    "our closure types evolve from a very open type , at the closure construction point , into the usual `` closure conversion '' type that is completely abstract in captured values , in the empty environment .",
    "as mentioned , our type system is _ not _ conservative over the simply - typed lambda - calculus because of the restriction on substitution of function types ( domain types must be preserved by substitution ) .",
    "this is not a surprise as our types provide more fine - grained information without giving a way to forget some of this more precise information .",
    "regaining conservativity is very simple .",
    "one needs a notion of subtyping allowing to hide variables present in closure types ( eg . , @xmath322(x:\\sigma_1 ) }",
    "\\to \\sigma_2 } \\leq { { [ \\gamma](x:\\sigma_1 ) } \\to \\sigma_2}$ ] whenever @xmath323 are well - scoped under @xmath14 alone ) . systematically coercing all functions into closures capturing the empty environment",
    "then gives us exactly the simply - typed lambda - calculus .",
    "we feel the two previous points could easily be formally integrated in our work .",
    "a more important difference between our prototypical system and a realistic framework for program analysis is the lack of polymorphism .",
    "this could require significantly more work and is left for future work .",
    "we conjecture that adding abstraction on type variables ( and their annotation @xmath43 ) is direct , but a more interesting question is the abstraction over annotated contexts @xmath32 .",
    "for example , we could want to write the following , where @xmath324 is a formal context variable : @xmath325(x { \\mathpunct{:}\\!}\\alpha ) } \\to { { [ \\kappa](y { \\mathpunct{:}\\!}\\beta ) } \\to \\gamma } } )      \\ !",
    "\\to      ( { { [ \\kappa](y { \\mathpunct{:}\\!}\\beta ) } \\to { { [ \\kappa](x { \\mathpunct{:}\\!}\\alpha ) } \\to \\gamma}})\\ ] ] polymorphism seems to allow greater flexibility in the analysis of functions taking functions as parameters .",
    "this use of polymorphism is related to the `` resource polymorphism '' of @xcite , which serves the same purpose of leaving freedom to input functions .",
    "open closure types on the other hand , are motivated by expressions that _ return _ function closures ; the flip side of the higher - order coin .",
    "we have introduced open closure types and their type theory .",
    "the technical novelty of the type system is the ability to track intensional properties of function application in function closures types . to maintain this information",
    ", we have to update function types when they escape to a smaller context .",
    "this update is performed by a novel non - trivial substitution operation .",
    "we have proved the soundness of this substitution and the type theory for a simply - typed lambda calculus with pairs .    to demonstrate how our open closure types can be used in program verification we have applied this technique to track data - flow information and to ensure non - interference in the sense of information - flow theory .",
    "we envision open closure types to be applied in the context of type systems for strong intensional properties of higher - order programs , and this simple system to serve as a guideline for more advanced applications .",
    "we already have preliminary results from an application of open closure types in amortized resource analysis  @xcite . using them",
    ", we were for the first time able to express a linear resource bound for the curried append function ( see section  [ sec : intro ] ) .",
    "this research is based on work supported in part by darpa crash grant fa8750 - 10 - 2 - 0254 and nsf grant ccf-1319671 .",
    "any opinions , findings , and conclusions contained in this document are those of the authors and do not reflect the views of these agencies ."
  ],
  "abstract_text": [
    "<S> type systems hide data that is captured by function closures in function types . in most cases </S>",
    "<S> this is a beneficial design that enables simplicity and compositionality . </S>",
    "<S> however , some applications require explicit information about the data that is captured in closures .    </S>",
    "<S> this paper introduces open closure types , that is , function types that are decorated with type contexts . </S>",
    "<S> they are used to track data - flow from the environment into the function closure . </S>",
    "<S> a simply - typed lambda calculus is used to study the properties of the type theory of open closure types . </S>",
    "<S> a distinctive feature of this type theory is that an open closure type of a function can vary in different type contexts . to present an application of the type theory , it is shown that a type derivation establishes a simple non - interference property in the sense of information - flow theory . </S>",
    "<S> a publicly available prototype implementation of the system can be used to experiment with type derivations for example programs .    </S>",
    "<S> systems , closure types , information flow </S>"
  ]
}