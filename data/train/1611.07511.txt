{
  "article_text": [
    "the multi- and many - core ( mc ) era we have reached was triggered after the beginning of the century by the stalling of single - processor performance .",
    "technology allowed more transistors to be placed on a die , but they could not reasonably be utilized to increase single - processor performance .",
    "predictions about the number of cores has only partly been fulfilled : today s processors have dozens rather than the predicted hundreds of cores ( although the chinese supercomputer  @xcite announced in the middle of 2016 comprises 260 cores on a die ) . despite this , the big players are optimistic .",
    "they expect that moore - law persists , though based on presently unknown technologies",
    ". the effect of the stalled clock frequency is mitigated , and it is even predicted  @xcite that `` _ _ now that there are multicore processors , there is no reason why computers should nt begin to work faster , whether due to higher frequency or because of parallel task execution . and with parallel task execution it provides even greater functionality and flexibility!. _ _ ''",
    "parallelism is usually considered in many forums  @xcite to be the future , usually as the only hope , rather than as a panacea .",
    "people dealing with parallelism are less optimistic . in general",
    ", the technical development tends to reduce the human effort , but `` _ _ parallel programs ... are notoriously difficult to write , test , analyze , debug , and verify , much more so than the sequential versions _ _ ''",
    "the problems have led researchers to the _ viewpoint _",
    "@xcite , that _ multicore hardware for general - purpose parallel processing is broken_.",
    "the essence of the present viewpoint is that multicore hardware can perhaps be mended .",
    "although one can profoundly agree with the arguments  @xcite that using manycore chips can not contribute much to using parallelism in general , and especially not in executing irregular programs , one has to realize also that this is not the optimal battlefield for the manycore chips , at least not in their present architecture .",
    "present manycore systems comprise many segregated processors , which make no distinction between two processing units that are neighbours within the same chip or are located in the next rack .",
    "the close physical proximity of the processing units offers additional possibilities , and provides a chance to implement amdahl s dream  @xcite of cooperating processors .",
    "paradigms used presently , however , assume a private processor and a private address space for a running process , and no external world . in many - core systems , it is relatively simple to introduce signals , storages , communication , etc . , and deploy them in reasonable times .",
    "they can not , however , be utilized in a reasonable way , if one can not provide compatibiliy facades providing the illusion of the private world .",
    "cooperation must be implemented in a way which provides complete ( upward ) compatibility with the presently exclusively used single - processor approach  ( spa )  @xcite .",
    "it means that on the one hand that new functionality must be formulated using the terms of conventional computing , while on the other , it provides considerably enhanced computing throughput and other advantages .",
    "it is well known , that general purpose processors have a huge handicap in performance when compared to special purpose chips , and that the presently used computing stack is the source of further serious inefficiencies .",
    "proper utilization of available manycore processors can eliminate a lot of these performance losses , and in this way ( keeping the same electronic and programming technology ) can considerably enhance ( apparently ) the performance of the processor .",
    "of course , there is no free lunch .",
    "making these changes requires a _ simultanous _ change in nearly all elements of the present computing stack . before making these changes , one should scrutinize the promised gain , and whether the required efforts will pay off .",
    "cc    = [ scale=0.75 ] ( l1 ) @xmath0 ; ( e1 ) [ above of = l1 ] @xmath1 ; ( e2 m ) [ above of = e1 ] ; ( e2 ) at ( @xmath2 ) @xmath3 ;    ( l2 ) [ right of = l1 ] @xmath4 ; ( l3 ) [ right of = l2 ] @xmath5 ; ( l4 ) [ right of = l3 ] @xmath6 ;    ( x1f ) at ( @xmath7 ) ; ( x1 ) [ below of = x1f ] @xmath8 ; ( x2f ) at ( @xmath9 ) ; ( x2 ) [ below of = x2f ] @xmath10 ;    ( plus ) [ below of = x1 ] @xmath11 ; ( minus ) [ below of = x2 ] @xmath12 ;    \\(a ) [ below of = plus ] @xmath13 ; ( b ) [ below of = minus ] @xmath14 ;    ( l1 ) edge ( x1 ) ( l2 ) edge ( x1 ) ( l3 ) edge ( x2 ) ( l4 ) edge ( x2 ) ; ( x1 ) edge ( plus ) ( x1 ) edge ( minus ) ( x2 ) edge ( plus ) ( x2 ) edge ( minus ) ; ( plus ) edge ( a ) ( minus ) edge ( b ) ;    ( c1 ) [ left of = l1 ] @xmath15 ; @scan@one@point@firstofone(c1 ) @scan@one@point@firstofone(x1 ) @scan@one@point@firstofone(plus )    ( c2 ) at ( @xmath16 ) @xmath17 ; ( c3 ) at ( @xmath18 ) @xmath19 ;    &    = [ scale=0.75 ]    ( o1 ) @xmath20 ; ( h1 ) at ( @xmath21 ) @xmath22 ; ( h2 ) at ( @xmath23 ) @xmath24 ; ( o1 ) edge [ bend left ] node ( h1 ) ( o1 ) edge [ bend left ] node ( h2 ) ;    ( l11 ) at ( @xmath25 ) @xmath26 ; ( l12 ) at ( @xmath27 ) @xmath28 ; ( h1 ) edge [ bend left ] node ( l11 ) ( h1 ) edge [ bend left ] node ( l12 ) ;    ( l21 ) at ( @xmath29 ) @xmath30 ; ( l22 ) at ( @xmath31 ) @xmath32 ; ( h2 ) edge [ bend left ] node ( l21 ) ( h2 ) edge [ bend left ] node ( l22 ) ;    ( x1 ) at ( @xmath33 ) @xmath8 ; ( l11 ) edge [ bend right ] node ( x1 ) ( l12 ) edge node ( x1 ) ; ( x2 ) at ( @xmath34 ) @xmath10 ; ( l21 ) edge [ bend right ] node ( x2 ) ( l22 ) edge node ( x2 ) ;     @scan@one@point@firstofone(o1 ) @scan@one@point@firstofone(x2 ) ( o2 ) at ( @xmath35 ) @xmath36 ; ( x1 ) edge node ( o2 ) ( x2 ) edge [ bend right ] node ( o2 ) ;    ( plus ) at ( @xmath37 ) @xmath11 ; ( minus ) at ( @xmath38 ) @xmath12 ; ( o2 ) edge [ bend left ] node ( plus ) ( o2 ) edge [ bend left ] node ( minus ) ;     @scan@one@point@firstofone(minus ) ( o3 ) at ( @xmath39 ) @xmath40 ; ( plus ) edge node ( o3 ) ( minus ) edge node ( o3 ) ;    ( c1 ) [ left of = o1 ] @xmath15 ; @scan@one@point@firstofone(c1 ) @scan@one@point@firstofone(x1 ) ( c2 ) at ( @xmath16 ) @xmath17 ; @scan@one@point@firstofone(o2 ) ( c3 ) at ( @xmath18 ) @xmath19 ;     +    below , some easy - to follow case studies are presented , all of which lead to the same conclusion : we need a cooperative and flexible rather than rigid architecture comprising segregated mcs , and the 70-years - old von neumann computing paradigms should be extended . at the end , the feasibility of implementing such an architecture is discussed .",
    "the recently introduced explicitly many - processor approach  @xcite seems to be quite promising : it not only provides higher computing throughput , but also offers advantageous changes in the behavior of computing systems .",
    "todays computing utilizes many forms of parallelism  @xcite , both hardware ( hw ) and software ( sw ) facilities .",
    "the software is systematically discussed in  @xcite and hardware methods are scrutinized in  @xcite . a remarkable difference between the two approaches",
    "is , that while the sw methods tend to handle the parallel execution explicitly , the hw methods tend to create the illusion that only one processing unit can cope with the task , although some ( from outside invisible ) helper units are utilized in addition to the visible processing unit .",
    "interestingly enough , both approaches arise from the von neumann paradigms : the abstractions _ process _ and the _ processor _ require so .",
    "the inefficiency of using several processing units is nicely illustrated with a simple example in  @xcite ( see also fig  [ fig : flexibleproc ] , left side ) . a simple calculation comprising 4 operand loadings and 4 aritmetic operations , i.e. altogether 8 machine instructions ,",
    "could be theoretically carried out in 3 clock cycles , provided that only dependencies restrict the execution of the instructions and an unlimited number of processing units ( or at least 4 such units in the example ) are available .",
    "it is shown that a single - issue processor needs 8 clock cycles to carry out the calculation example .",
    "provided that memory access and instruction latency time can not be further reduced , the only possibility to shorten execution time is to use more than one processing unit during the calculation .",
    "obviously , a fixed architecture can only provide a fixed number of processing units . in the example  @xcite",
    "two such ideas are scrutinized : a dual - issue single processor , and a two - core single issue processor .",
    "the hw investment in both cases increases by a factor of two ( not considering the shared memory here ) , while the performance increases only moderately : 7 clock cycles for the dual - issue processor and 6 clock cycles for the dual - core processor , versus the 8 clock cycles of the single - issue single core processor .",
    "the _ obvious reasons here are the rigid architecture and the lack of communication possibilities _ , respectively .",
    "consider now a processor with flexible architecture , where the processor can outsource part of its job : it can rent processing units from a chip - level pool just in the time it takes to execute a few instructions .",
    "the cores are smart : they can communicate with each other , and even they know the task to be solved and are able to organize their own work while outsourcing part of the work to the rented cores .",
    "the sample calculation , borrowed from  @xcite as shown in fig .",
    "[ fig : flexibleproc ] , left side , can then be solved as shown on the right side of the figure .",
    "the core ; originally receives the complete task to make the calculation , as it would be calculated by a conventional single - issue , single core system , in 8 clock cycles .",
    "however , ; is more intelligent . using the hints hidden in the object code",
    ", it notices that the task can be outsourced to another cores . for this purpose",
    "it rents , one by one , cores ; and ; to execute two multiplications .",
    "the rented ; cores are also intelligent , so they also outsource loading the operands to cores ; and ; .",
    "they execute the outsourced job : load the operands and return them to the requesting cores ; , which then can execute the multiplications ( denoted by ;) and return the result to the requesting core , which can then rent another two cores ; and ; for the final operations . two results",
    "are thus produced .",
    "this unusual kind of architecture must respond to some unusual requirements .",
    "first of all , the architecture must be able to organize itself as the received task requires it , and build the corresponding `` processing graph '' , see fig .",
    "[ fig : dynpar ] , for legend see @xcite .",
    "furthermore , it must provide a mechanism for mapping the virtually infinite number of processing nodes to the finite number of cores .",
    "cores ; must receive the address of the operand , i.e. at least some information must be passed to the rented core .",
    "similarly , the loaded operand must be returned to the renting core in a synchronized way . in the first case synchronization",
    "is not a problem : the rented core begins its independent life when it receives its operands . in the second case",
    "the rented core finishes its assigned operation and sends the result asyncronously , independently of the needs of the renting core .",
    "this means that the architecture must provide a mechanism for transferring some ( limited amount of ) data between cores , a signalization mechanism for renting and returning cores , as well as a latched intermediate data storage for passing data in a synchronized way .",
    "the empty circles are the theoretically needed operations , and the shaded ones are additional operations of the `` smart '' cores .",
    "the number of the cores being used changes continuously as they are rented and returned .",
    "although _ physically _ they may be the same core , _ logically _ they are brand new .",
    "note that the `` smart '' operations are much shorter  they comprise simple bit manipulations and multiplexing  , than the conventional ones that comprise complex machine instructions , and since the rented cores work in parallel ( or at least mostly overlap ) , the calculation is carried out in 3 clock periods .",
    "the cycle period is somewhat longer , but the attainable parallelism approaches the theoretically possible one , and is more than twice as high as the one attainable using either two - issue or dual - core processors .",
    "although the average need of cores is about 3 , these cores can be the simplest processors , i.e. the decreasing complexity of the cores ( over)compensates for the increasing complexity of the processor .",
    "in addition , as the control part of the processors increases , the need for the hidden parallelization ( like out - of - order and speculation ) can be replaced by the functionality of the flexible architecture , the calculational complexity can be decreased , and as a result , the clock speed can be increased .",
    "a processor with such an internal architecture appears to the external world as a `` superprocessor '' , having several times greater performance than could be extracted from a single - threaded processor . that processor can adapt itself to the task : unlike in the two issue processor , all ( rented ) units are permanently used .",
    "_ the many - core systems with flexible architecture comprising cooperating cores can approach the theoretically possible maximum parallelism . _ in addition , the number of the cores can be kept at a strict minimum , allowing reduction of the power consumption .",
    "in the many - many processor ( supercomputer ) systems the processing units are assembled using the spa  @xcite , and so their maximum performance is bounded by amdahl s law . although amdahl s original model  @xcite is pretty outdated , its simple and clean interpretation allows us to derive meaningful results even for today s computing systems .",
    "amdahl assumed that in some @xmath41 part of the total time the computing system engages in parallelized activity , in the remaining ( @xmath42 ) part it performs some ( from the point of view of parallelization ) non - payload activity , like sequential processing , networking delay , control or organizational operation , etc .",
    "the essential point here is that all these latter activities behave _ as if they were sequential processing_. under such conditions , the efficiency @xmath43 is calculated as the ratio of the total speedup @xmath44 and the number of processors @xmath45 : @xmath46    although in the case of supercomputers ( @xmath42 ) comprises contributions of a technically different nature ( it can be considered as the `` imperfectness '' of implementation of the supercomputer ) , it also behaves as if it were a sequentially processed code .",
    "[ supercomputertimeline ] shows how this `` imperfectness '' was decreased during the development of supercomputers , calculated from the actual data of the first three supercomputers in the year in question over a quarter of a century .",
    "as the figure shows , this parameter behaves similarly to the moore - observation , but it is independent of that one ( because the parameter is calculated from @xmath47 , any technology dependence is removed ) .    at first glance , it seems to be at least surprising to look for any dependence in function of `` imperfectness '' .",
    "the key is equ .",
    "( [ eq : soverk ] ) .",
    "since the @xmath41 approaches unity , the term @xmath48 determines the overall efficiency of the computing system . to _ increase _ @xmath45 by an order or magnitude alone is useless if not accompanied by an order of magnitude _ decrease _ in the value of ( @xmath42 ) .",
    "however , while increasing @xmath45 is simply a linear function , decreasing ( @xmath42 ) as any kind of increasing perfectness , is exponentially more difficult .",
    "[ supercomputertimeline ] proves that today s supercomputers are built in spa , and makes it questionable whether further significant decrease of value ( @xmath42 ) could be reached at reasonable cost .",
    "this means that it is hopeless _ to build exa - scale computers , using the principles drawn from the spa_.    looking carefully at @xmath48 , one can notice that the two terms describe two important behavioral features of the computing system",
    ". as already discussed , @xmath49 decribes , how much the work of the many - processor system is _",
    "coordinated_. the factor @xmath45 , on the other hand , describes , how much the processing units _",
    "cooperate_. in the case of using the spa , the processing units are segregated entities , i.e. they do not cooperate at all .",
    "if we could make a system where the processing units behave differently in the presence of another processors , we could write @xmath50 in equ .",
    "( [ eq : soverk ] ) . depending on how cores behave together in the presence of another cores when solving a computing task",
    ", the @xmath50 , the cooperation of the processing units can drastically increase the efficiency of the many - processor systems .",
    "in other words , to increase the performance of many - many - processor computers , _ the cores must cooperate _",
    "( at least with some ) other cores . _ using cooperating cores is inevitable for building supercomputers at a reasonable cost . _",
    "a computer computes everything , because it can not do any other type of operations .",
    "computational density has reached its upper bound , so no further performance increase in that direction is possible .",
    "in addition to introducing different forms of hw and sw parallelism , it is possible to omit some non - payload , do - not - care calculations , through providing and utilizing special hw signals instead .",
    "the signals can be provided for the participating cores , and can be used to replace typical calculational instruction sequences by using special hardware signals .",
    "the compilation is simple : where the compiler should generate non - payload loop organization commands , it should give a hint about renting a core for executing non - payload instructions and providing external synchronization signals .    a simple example : when summing up elements of a vector , the only payload instruction is the respective ` add ` .",
    "one has , however , to address the operand ( which includes handling the index , calculating the offset and adding it to the base address ) , to advance the loop counter , to compare it to the loop bound , and to jump back conditionally .",
    "all those non - payload operations can be replaced by handling hw signals , if the cores can cooperate , resulting in a speed gain of about 3 , using an extra core only .",
    "even , since the intermediate sum is also a do - not - care value until the summing is finished , a different sumup method can be used , which may utilize dozens of cores and result in a speed gain of dozens .",
    "when organizing a loop , the partial sum is one of the operands , so it must be read before adding a new summand , and must be written back to its temporary storage , wasting instructions and memory cycles ; in addition it excludes the possibility of parallelizing the sumup operation . for details and examples",
    "see  @xcite .",
    "this latter example also demonstrates that _ the machine instruction is a too rigid atomic unit of processing_. _ utilizing hw signals from cooperating cores rather than providing some conditions through ( otherwise don - not - care ) calculations , allows us to eliminate obsolete calculational instructions , and thus apparently accelerate the computation by a factor of about ten . _",
    "the need for multi - processing ( among others ) forced to use exceptional instruction execution .",
    "i.e. , a running process is _ _",
    "interrupt__ed , its hw and sw state is saved and restored , because the hard and soft parts of the _ only _ processor must be lent to another process .",
    "the code of the interrupting process is effectively inserted in the flow of executing the interrupted code .",
    "this maneuver causes an indeterministic behavior of the processor : the time when two consecutive machine instructions in a code flow are executed , becoming indeterminate .",
    "the above is due to the fact that during development , some of the really successful accelerators , like the internal registers and the highest level cache , became part of the architecture : the soft part of the processor . in order to change to a new thread",
    ", the current soft part must be saved in ( and later restored from ) the memory .",
    "utilizing asynchronous interrupts as well as operating system services , implies a transition to new operating mode , which is a complex and very time - consuming process .",
    "all these extensions were first developed when the computer systems had only one processor , and the only way to provide the illusion of running several processes , each having its own processor , was to detach the soft part from the hard one . because of the lack of proper hardware support , this illusion depended on using sw services and on the architectures being constructed with a spa in mind , conditions that require rather expensive execution time : in modern systems a context change may require several thousands of clock cycles . as the hyper - threading proved , detaching soft and hard part of the processors results in considerable performance enhancement .    by having more than one processor and the explicitly many - processor approach  @xcite , the context change can be greatly symplified .",
    "for the new task , such as providing operating system services and servicing external interrupts a dedicated core can be reserved .",
    "the dedicated core can be prepared and held in supervisor mode .",
    "when the execution of the instruction flow follows , it is enough to clone the relevant part of the soft part : for interrupt servicing nothing is needed , for using os services only the relevant registers and maybe cache .",
    "( the idea is somewhat similar to utilizing shadow registers for servicing an asynchronous interrupt . )",
    "if the processors can communicate among each other using hw signals rather than os actions , and some communication mechanism , different from using ( shared ) memory is employed , the apparent performance of the computing systems becomes much faster .",
    "_ for cooperating cores no machine instructions ( that waste real time , machine and memory cycles ) are needed for a context change , allowing for a several hundredfold more rapid execution in these spots .",
    "_ the application can even run parallel with the system code , allowing further ( apparent ) speedup .    using the many - processor approach",
    "creates many advantageous changes in the real - time behavior of the computing systems .",
    "since the processing units do not need to save or restore anything , the servicing can start immediately and is restricted to the actual payload instructions .",
    "the dedicated processing units can not be addressed by non - legal processing units , so issues like exluding priority inversion are handled at hw level .",
    "and so on .",
    "from all points of view ( the just - a - few and many - many processors , as well as utilizing kernel - mode or real - time services ) we arrive at the same conclusion : segregated processors in the many - processor systems do not allow a greater increase in the performance of our computing systems , while cooperating processors can increase the attainable single - threaded performance .",
    "amdahl contented this by a half century ago : `` _ the organization of a single computer has reached its limits and that truly significant advances can be made only by interconnection of a multiplicity of computers in such a manner as to permit cooperative solution .",
    "@xcite    at this point the many - core architectures have the advantage that they are in the close proximity to one another : there is no essential difference between that a core needing to reach its own register ( or signal ) or that of another core .",
    "the obstacle is actually the spa : for a core and a process , there exists no other core .    in the suggested new approach , which can be called _ explicitly many - processor approach _",
    "( empa ) , the cores ( through their supervisor ) can know about their neighbours . today",
    ", radical departures from conventional approaches ( including rethinking the complete computing stack ) are advanced @xcite , but at the same time a smooth transition must be provided to that radically new technology . _ to preserve compatibility with conventional computing , the empa approach  @xcite is phrased using the terms of conventional computing _",
    "( i.e. it contains spa as a subset ) .",
    "some of the above - mentioned boosting principles are already implemented in the system . from the statistics",
    "one can see that in some spots , performance gain in the range 3 - 30 can be reached .",
    "the different algorithms need different new accelerator building stone solutions in frame of empa .",
    "for example , the gain 3 in an executing loop , when used in an image processing task where for edge detection a 2-dimensional matrix is utilized , means nearly an order of magnitude performance gain , using the same calculational architecture in calculating a new point . and , to consider all points of the picture another double loop is used .",
    "this means , that a 4-core empa processor can produce nearly 100 times more rapid processing ( not considering that several points can be processed in parallel on processors with more cores ) .",
    "this is achieved not by increasing computing density , but by replacing certain non - payload calculations with hw signals , and so executing 100 times less machine instructions .",
    "the mc architecture comprising segregated cores is indeed broken .",
    "it can , however , be mended , if the manycore chips are manufactured in the form using cooperating cores .    as the first step toward implementing such a system , for simulating its sophisticated internal operation and providing tools for understanding and validating it , an empa development system  @xcite has been prepared .",
    "an extended assembler prepares empa - aware object code , while the simulator allows us to watch the internal operation of the empa processor .    to illustrate the execution of programs using the empa method ,",
    "a processing diagram is automatically prepared by the system , and different statistics are assembled .",
    "[ fig : dynpar ] shows the equivalent of fig .",
    "[ fig : flexibleproc ] , running on an 8-core and a 4-core processor , respectively ( for legend see  @xcite ) .",
    "the left hand figure depicts the case when `` unlimited '' number of processing units are available , the right hand one shows the case when the processor has a limited number of computing resources to implement the maximum possible parallelism .",
    "the code assembled by the compiler is the same in both cases .",
    "the supervisor logic detects if not enough cores are available ( see right side ) , and delays the execution ( outsourcing more code ) of the program fragments until some cores are free again .",
    "the execution time gets longer if the processor can not rent enough cores for the processing , but the same code will run in both cases , without deadlock and violating dependencies .    for electronic implementation",
    ", some ideas may be borrowed from the technology of reconfigurable systems . there , in order to minimize the need for transferring data , some local storage ( block - ram ) is located between the logical blocks , and a lot of wires is available for connecting them .    in analogy also with fpgas",
    ", the cores can be implemented as mostly fixed functionality processing units , having multiplexed connecting wires to their supervisor with fixed routing .",
    "some latch registers and non - stored program functionality gates can be placed near those blocks , which can be accessed by both cores and supervisor .",
    "the inter - core latch data can be reached from the cores using pseudo - registers ( i.e. they have a register address , but are not part of the register file ) and the functionality of the cores also depends on the inter - core signals . in the prefetch stage the cores can inform the supervisor about the presence of metainstruction in their object code , and in this way the mixed code instructions can be directed to the right destination . in order to be able to organize execution graphs , the cores ( after renting ) are in parent - child relation to unlimited depth .",
    "as was very correctly stated  @xcite , `` due to its high level of risk , prototype development fits best within the research community . ''",
    "the principles and practice of empa differ radically from those of spa . to compare the performance of both",
    ", empa needs a range of development .",
    "many of the present components , accelerators , compilers , etc .",
    ", with spa in mind , do not fit empa",
    ". the research community can accept ( or reject ) the idea , but it definitely warrants some cooperative work .",
    "h.  esmaeilzadeh .",
    "approximate acceleration : a path through the era of dark silicon and big data . in _ proceedings of the 2015 international conference on compilers , architecture and synthesis for embedded systems _ , cases 15 , pages 3132 , piscataway , nj , usa , 2015 .",
    "ieee press ."
  ],
  "abstract_text": [
    "<S> a suggestion is made for mending multicore hardware , which has been diagnosed as broken . </S>"
  ]
}