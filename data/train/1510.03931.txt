{
  "article_text": [
    "memory components for neural networks has been recently introduced in neural turing machines ( ntms ) [ 2 ] , memory networks [ 1 ] , and dynamic memory networks [ 3 ] .",
    "the purposes of those memory components are similar , which is to simulate `` working memory '' in the brain to store temporary information through time to be used by attention module for reading and writing . in this paper , our focus is on ntms .",
    "they are attractive in that memory could be randomly accessed by controller through blurry `` erase '' and `` write '' operations , which well aligns with turing machine operations .",
    "when memory size is small , nice convergence of the ntm model could be frequently observed , although not always .",
    "but when memory size is large , the model struggles to convergence , and sometimes the test loss jumps drastically in a large range , which is a sign of overfitting , as was observed in our experiments . we think that the dynamics of memory contents takes a crucial role in controlling model convergence speed and quality .",
    "thus , we proposed and experimented different memory structures to explore if specific memory structure could lead to more stable memory contents , or say , perform `` memory smoothing '' so that the memory content generated after read and write operations does not deviate too far from the `` expected '' memory content , so that overfitting of parameters could be in turn alleviated .",
    "we proposed three different architectures , ntm1 , ntm2 and ntm3 , which are explained in detail in section [ sec : arch ] , and experiments are shown in section [ sec : exp ] .     as controllers .",
    "note that every module in those modules are updated recurrently through time using their previous states .",
    "ntm1 contains only one write head , and one of the memory @xmath0 is not written directly by controller , which is different from @xmath1 in ntm2 that is written both by @xmath2 and write head simultaneously .",
    "ntm3 is different from ntm2 in that ntm3 write heads takes inputs from two layers .",
    "ntm3 could also be expanded to multiple layers as well . ]",
    "we show the ntm original architecture introduced by graves et al . [ 2 ] and three variants ntm1 , ntm2 and ntm3 in figure [ fig ] .",
    "details of each model is explained in a moment .",
    "we introduce a notion of _ memory visibility _ : we call memory `` controlled '' if it is modified by controller outputs through write heads directly , or `` hidden '' if not .",
    "* ntm1 * compared to ntm , ntm1 has an additional hidden memory @xmath0 , which is not controlled by controller module , but is connected to the controlled memory @xmath3 .",
    "the hidden memory accumulates the content in the controlled memory , so that a type of memory smoothing is performed to prevent memory from deviating from the `` expected content '' .",
    "specifically , the memory content for hidden memory @xmath4 of time @xmath5 is generated as : @xmath6 @xmath3 is updated by @xmath7 time write head to generate @xmath5 time controlled memory output , which in turn is used to update hidden memory @xmath0 , and then the new hidden memory is used to generate read head at time @xmath5 .",
    "@xmath8 is write weights , @xmath9 is the controller output of time @xmath5 , and @xmath10 is the function that updates controlled memory and write weights that implement `` erase and add '' operations .",
    "@xmath11 is read weights . @xmath12 and @xmath13 are scalar mixture weights , which could be further extended to tensors .",
    "we use scalars in this work .",
    "the read head is reading from @xmath4 instead of @xmath14 as is did in [ 2 ] .    * ntm2 * the second architecture ntm2 is similar to ntm1 in that two memory blocks are used , and they are connected hierarchically .",
    "however , the difference from ntm1 is that hidden memory in ntm2 is no longer hidden from the controller , but connected to controller outputs through another write head .",
    "so two memory blocks are all controlled memories connecting to two different write heads .",
    "the upper level memory is denoted as @xmath2 , and the lower level one as @xmath1 .",
    "@xmath2 is modified solely by l1 write head , but @xmath1 is modified by both @xmath15 contents and l2 write head .",
    "the logic is : @xmath16    additionally , @xmath15 and @xmath17 are all generated by the same head function with same controller input , but with different write weights .",
    "single read head @xmath18 is used , which means the output is only read from the lowest layer memory ( @xmath17 in this case ) . note that the architecture could be easily expanded into multiple layers by increasing number of heads and memory blocks .    * ntm3 * the third architecture is significantly different from the previous two .",
    "first , the controller in the model have multiple layers .",
    "second , each layer output is connecting to a memory by write heads .",
    "different layers of memory contains different level of transformation of the input . in the case where multi - layer lstm is used as ntm controller , output from each layer",
    "goes through the non - linear transformation of write heads , and writes to each individual memory . then the deeper level memory is updated by upper level memory and write head jointly .",
    "@xmath19    in so doing , the memory blocks receives write operations not only from the final layer lstm output , but also from the intermediate layer outputs as well .",
    "the purpose is to smooth the final layer memoroy with intermediate lstm outputs .",
    "we can see in a moment how those three performs on copy and associative recall task .    .",
    "the experiments is to show the convergence speed and quality of those three variants , compared to the ntm setting . in theory , the convergence should happen for every run of every model , which is not the case in practice .",
    "randomness of parameter initialization might be the reason .",
    "but if model convergences , the number of iterations used were quite stable across runs .",
    "thus , to make the evaluation reliable , we repeat experiments at least 5 times for each model and choose the most frequent circumstance for showing .",
    "the tasks we choose for model testing are copy task and associative recall task as in [ 2 ] .",
    "associative recall task requires the model to target an item in sequence , and later on shift to the immediate next item to give as an answer .",
    "copy task requires the model to consecutively output items in original input order , which requires long - term location based addressing capability . in each training iteration",
    ", we randomly generated each item as a binary vector of length 8 .",
    "the number of items is random as well . in recall task , the items , and number of items to be generated",
    "are all chosen at random .",
    "all those randomness is to guarantee that every training iteration uses different training example , so that overfit to specific data set is no longer an issue , to guarantee that algorithms could be learned .",
    "this is critical to our further analysis.for all the models , the training criteria is binary cross entropy , and we use rmsprop [ 4 ] for optimization , with learning rate @xmath20 , momentum @xmath21 , and decay @xmath22 .    in figure",
    "[ fig : converge ] we show our results on copy and recall respectively . copy tasks are four graphs to the left .",
    "x - axis shows the number of iteration used ( sampled every 25 iterations ) , and y - axis is the binary cross entropy loss of each iteration .",
    "the shown result in each graph is representative among 5 runs , among which the selected curve is observed most frequently .",
    "we can see that ntm1 and ntm2 shows faster convergence and less outliers above the convergence range ( closely around 0 near x - axis ) than ntm or ntm3 .",
    "the outliers ( extremely high loss ) means that the prediction on the item in that iteration is significantly incorrect , which is a sign of overfitting or underfitting . in ntm1 and ntm2",
    "runs we see very few outliers , but ntm shows more outliers when using two read and write heads ( the curve with sharp values ) , or does not converge as fast when using 1 read and 1 write head ( flat curve ) .",
    "this pattern is consistently observed over 5 runs as well .",
    "we can also read out from figure `` ntm - copy '' that using 1 read and 1 write head converges significantly slower than 2w / r heads .",
    "the series of experiments on copy task confirms our assumption that the introduction of additional memory in ntm1 and ntm2 do help stabilize the memory component , which in turn leads to better tuning of the parameters .",
    "however , ntm3 does not show nice curves , and produce outlier almost every 1000 iterations or so .",
    "this means that the memory that is attached to the intermediate layers of lstm introduces more noise , which is unexpected .",
    "although less stable , ntm does converge about 500 iterations faster than ntm1 and ntm2 , but we observed the opposite in associative recall task .    for associative recall , we can see that outliers are produced much more frequently when loss significantly reduces , and we rarely observe convergence of original ntm or ntm3 . in `` ntm3-recall '' graph",
    ", we show a non - converged run since it happens frequently for ntm3 . but",
    "ntm1 and ntm2 converges more frequently across runs . and",
    "ntm2 shows much faster convergence , roughly with 37,000 iterations , compared to 50,000 for ntm or ntm1 .",
    "moreover , ntm1 and ntm2 generate less outliers than ntm .",
    "this means that , the prediction accuracy for ntm1 and ntm2 will be higher than ntm , since more training examples are correctly predicted than ntm . and",
    ", ntm1 and ntm2 will have higher probability to be a non - overfitting model than ntm .",
    "unfortunately , ntm3 model does not converge as frequent as ntm1 and ntm2 , which aligns with the observation in copy task about the difference of those models .",
    "this paper discussed three new structured memory architectures for neural turing machines , and showed that organizing memory blocks in a proper hierarchical manner could alleviate overfitting and sometimes increase predictive accuracy compared to ntm .",
    "in the future we would also try ntm1 ntm2 on data sets that require more complex reasoning .",
    "we tested ntm on a synthetic qa data set proposed in [ 1 ] , and observed the instability in convergence .",
    "we would try ntm1 and ntm2 on the same data set .",
    "[ 1 ] jason weston , sumit chopra , & antoine bordes .",
    "memory networks .",
    "_ international conference on representation learning _ , 2015      [ 3 ] ankit kumar , ozan irsoy , jonathan su , james bradbury , robert english , brian pierce , peter ondruska , ishaan gulrajani , & richard socher . ask me anything : dynamic memory networks for natural language processing .",
    "_ arxiv preprint arxiv:1506.07285 ."
  ],
  "abstract_text": [
    "<S> neural turing machines ( ntm ) [ 2 ] contain memory component that simulates `` working memroy '' in the brain to store and retrieve information to ease simple algorithms learning . </S>",
    "<S> so far , only linearly organized memory is proposed , and during experiments , we observed that the model does not always converge , and overfits easily when handling certain tasks . </S>",
    "<S> we think memory component is key to some faulty behaviors of ntm , and better organization of memory component could help fight those problems . in this paper , we propose several different structures of memory for ntm , and we proved in experiments that two of our proposed structured - memory ntms could lead to better convergence , in term of speed and prediction accuracy on copy task and associative recall task as in [ 2 ] . </S>"
  ]
}