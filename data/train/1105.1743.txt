{
  "article_text": [
    "software engineering , compiler optimizations , program parallelization , system verification , and security assurance depend on program analysis , a ubiquitous and central theme of programming language research . at the same time , the production of modern software systems employs expressive , higher - order languages such as java , javascript , c # , python , ruby , etc . , implying a growing need for fast , precise , and scalable higher - order program analyses .",
    "program analysis aims to soundly predict properties of programs before being run .",
    "( _ sound _ in program analysis means `` conservative approximation '' : if a sound analysis says a program must not exhibit behavior , then that program will not exhibit that behavior ; but if a sound analysis says a program may exhibit a behavior , then it may or may not exhibit that behavior . ) for over thirty years , the research community has expended significant effort designing effective analyses for higher - order programs  @xcite .",
    "past approaches have focused on connecting high - level language semantics such as structured operational semantics , denotational semantics , or reduction semantics to equally high - level but dissimilar analytic models .",
    "these models are too often far removed from their programming language counterparts and take the form of constraint languages specified as relations on sets of program fragments  @xcite .",
    "these approaches require significant ingenuity in their design and involve complex constructions and correctness arguments , making it difficult to establish soundness , design algorithms , or grow the language under analysis .",
    "moreover , such analytic models , which focus on `` value flow '' , _ i.e. _ ,  determining which syntactic values may show up at which program sites at run - time , have a limited capacity to reason about many low - level intensional properties such as memory management , stack behavior , or trace - based properties of computation .",
    "consequently , higher - order program analysis has had limited impact on large - scale systems , despite the apparent potential for program analysis to aid in the construction of reliable and efficient software .    in this paper",
    ", we describe a _ systematic approach to program analysis _ that overcomes many of these limitations by providing a straightforward derivation process , lowering verification costs and accommodating sophisticated language features and program properties .",
    "our approach relies on leveraging existing techniques to transform high - level language semantics into _",
    "abstract machines_low - level deterministic state - transition systems with potentially infinite state spaces .",
    "abstract machines  @xcite , and the paths from semantics to machines  @xcite , have a long history in the research on programming languages .    from an abstract machine , which represents the idealized core of a realistic run - time system ,",
    "we perform a series of basic machine refactorings to obtain a _",
    "non - deterministic _ state - transition system with a _",
    "finite _ state space .",
    "the refactorings are simple : ( 1 ) variable bindings and the control stack are redirected through the machine s store and ( 2 ) the store is bounded to a finite size . due to finiteness",
    ", store updates must become merges , leading to the possibility of multiple values residing in a single store location .",
    "this in turn requires store look - ups be replaced by a non - deterministic choice among the multiple values at a given location .",
    "the derived machine computes a sound approximation of the original machine , and thus forms an _ abstract interpretation _ of the machine and the high - level semantics .",
    "the approach scales up uniformly to enable program analysis of realistic language features , including higher - order functions , tail calls , conditionals , side effects , exceptions , first - class continuations , and even garbage collection .",
    "thus , we are able to refashion semantic techniques used to model language features into abstract interpretation techniques for reasoning about the behavior of those very same features .    _",
    "background and notation _ : we present a brief introduction to reduction semantics and abstract machines . for background and a more extensive introduction to the concepts , terminology , and notation employed in this paper , we refer the reader to _ semantics engineering with plt redex _",
    "in this section , we demonstrate our systematic approach to analysis by stepping through a derivation from the high - level semantics of a prototypical higher - order programming language to a low - level abstract machine , and from the abstract machine to a sound and computable analytic model that predicts intensional properties of that machine . as a prototypical language",
    ", we choose the call - by - value @xmath0-calculus @xcite , a core computational model for both functional and object - oriented languages .",
    "we choose to model program behavior with a simple operational model given in the form of a reduction semantics . despite this simplicity ,",
    "reduction semantics scale to full - fledged programming languages  @xcite , although the choice is somewhat arbitrary since it is known how to construct abstract machines from a number of semantic paradigms  @xcite . in subsequent sections ,",
    "we demonstrate the approach handles richer language features such as control , state , and garbage collection , and we have successfully employed the same method to statically reason about language features such as laziness , exceptions , and stack - inspection , and programming languages such as java and javascript . in all cases ,",
    "analyses are derived following the systematic approach presented here .      to begin , consider the following language of expressions:@xmath1 the syntax of expressions includes variables , applications , and functions .",
    "values @xmath2 , for the purposes of this language , include only function terms , @xmath3 .",
    "we say @xmath4 is the _ formal parameter _ of the function @xmath3 , and @xmath5 is its _",
    "body_. a _ program _ is a closed expression , _",
    "i.e. _ ,  an expression in which every variable occurs within some function that binds that variable as its formal parameter .",
    "call - by - value _ reduction _ is characterized by the relation @xmath6 : @xmath7{e}\\text , \\end{array}\\ ] ] which states that a function applied to a value reduces to the body of the function with every occurrence of the formal parameter replaced by the value .",
    "the expression on the left - hand side is a known as a _",
    "redex _ and the right - hand side is its _",
    "contractum_.    reduction can occur within a context of an _ evaluation context _ , defined by the following grammar : @xmath8 { \\mathrel{|}}{{\\mbox{\\tt ( } } e { e}{\\mbox{\\tt ) } } } { \\mathrel{|}}{{\\mbox{\\tt ( } } { v}e{\\mbox{\\tt ) } } } \\text .",
    "\\end{grammar}\\ ] ] an evaluation context can be thought of as an expression with a single `` hole '' in it , which is where a redex may be reduced .",
    "it is straightforward to observe that for all programs , either the program is a value , or it decomposes uniquely into an evaluation context and redex , written @xmath9 $ ] .",
    "thus the grammar as given specifies a deterministic reduction strategy , which is formalized as a _ standard reduction relation _ on programs : @xmath10 \\longmapsto_{{\\mathrel{\\mathbf{v}}}}e[{e}'],\\mbox { if } { e}\\;{{\\mathrel{\\mathbf{v}}}}\\;{e}'\\text.\\ ] ] the _ evaluation _ of a program is defined by a partial function relating programs to values  @xcite : @xmath11 where @xmath12 denotes the reflexive , transitive closure of the standard reduction relation .",
    "we have now established the high - level semantic basis for our prototypical language .",
    "the semantics is in the form of an evaluation function defined by the reflexive , transitive closure of the standard reduction relation .",
    "however , the evaluation function as given does not shed much light on a realistic implementation . at each step",
    ", the program is traversed according to the grammar of evaluation contexts until a redex is found . when found , the redex is reduced and the contractum is plugged back into the context . the process is then repeated , again traversing from the beginning of the program .",
    "abstract machines offer an extensionally equivalent but more realistic model of evaluation that short - cuts the plugging of a contractum back into a context and the subsequent decomposition  @xcite .      the cek machine  ( * ? ? ?",
    "* interpreter  iii)@xcite is a state transition system that efficiently performs evaluation of a program .",
    "there are two key ideas in its construction , which can be carried out systematically  @xcite .",
    "the first is that substitution , which is not a viable implementation strategy , is instead represented in a delayed , explicit manner as an _ environment _ structure .",
    "so a substitution @xmath13{e}$ ] is represented by @xmath5 and an environment that maps @xmath4 to @xmath2 .",
    "since @xmath5 and @xmath2 may have previous substitutions applied , this will likewise be represented with environments .",
    "so in general , if @xmath14 is the environment of @xmath5 and @xmath15 is the environment of @xmath2 , then we represent @xmath13{e}$ ] by @xmath5 in the environment @xmath14 extended with a mapping of @xmath4 to @xmath16 , written @xmath17 $ ] .",
    "the pairing of a value and an environment is known as a _ closure _  @xcite .",
    "the second key idea is that evaluation contexts are constructed inside - out and represent continuations :    1 .",
    "@xmath18 $ ] is represented by @xmath19 ; 2 .",
    "@xmath20 { e}{\\mbox{\\tt ) } } } ] $ ] is represented by @xmath21 where @xmath14 closes @xmath22 to represent @xmath5 and @xmath23 represents @xmath24 ; and 3 .",
    "@xmath25{\\mbox{\\tt ) } } } ] $ ] is represented by @xmath26 where @xmath14 closes @xmath27 to represent @xmath2 and @xmath23 represents @xmath24 .    in this way ,",
    "evaluation contexts form a program stack : @xmath28 is the empty stack , and @xmath29 and @xmath30 are frames",
    ".    states of the cek machine are triples consisting of an expression , an environment that closes the control string , and a continuation : @xmath31    @xmath32 \\hline   \\\\ \\langle{x } , { \\rho } , { \\kappa}\\rangle & \\langle{v},{\\rho } ' , { \\kappa}\\rangle   \\mbox { where } { \\rho}({x } ) = ( { v},{\\rho } ' )   \\\\[1 mm ] \\langle{{\\mbox{\\tt ( } } { e}_0 { e}_1{\\mbox{\\tt ) } } } , { \\rho } , { \\kappa}\\rangle & \\langle{e}_0 , { \\rho } , { \\mathbf{ar}}(e_1 , { \\rho } , { \\kappa})\\rangle \\\\[1 mm ] \\langle{v},{\\rho } , { \\mathbf{ar}}(e,{\\rho}',{\\kappa})\\rangle & \\langle{e},{\\rho}',{\\mathbf{fn}}({v},{\\rho},{\\kappa})\\rangle \\\\[1 mm ] \\langle{v},{\\rho } , { \\mathbf{fn}}({{\\mbox{\\tt ( } } \\uplambda { x}.{e}{\\mbox{\\tt ) } } } , { \\rho}',{\\kappa})\\rangle & \\langle{e},{\\rho}'[{x}\\mapsto ( { v},{\\rho } ) ] , { \\kappa}\\rangle \\end{array}\\ ] ]    the transition function for the cek machine is defined in figure  [ fig : cek ] .",
    "the initial machine state for a program @xmath5 is given by the @xmath33 function : @xmath34 evaluation is defined by the reflexive , transitive closure of the machine transition relation and a `` @xmath35 '' function  @xcite that maps closures to the term represented : @xmath36 which is equivalent to the @xmath37 function of section  [ sec : red ] :    @xmath38 .",
    "we have now established a correct low - level evaluator for our prototypical language that is extensionally equivalent to the high - level reduction semantics . however , program analysis is not just concerned with the result of a computation , but also with _ how _ it was produced , _",
    "i.e. _ ,  analysis should predict intensional properties of the machine as it runs a program . we therefore adopt a reachable states semantics that relates a program to the set of all its intermediate steps : @xmath39 membership in the set of reachable states is straightforwardly undecidable .",
    "the goal of analysis , then , is to construct an _ abstract interpretation _  @xcite that is a sound and computable approximation of the @xmath40 function .",
    "we can do this by constructing a machine that is similar in structure to the cek machine : it is defined by an _",
    "abstract state transition _ relation , @xmath41 , which operates over _ abstract states _ , @xmath42 , that approximate states of the cek machine .",
    "abstract evaluation is then defined as : @xmath43    1 .   _",
    "soundness _ is achieved by showing transitions preserves approximation , so that if @xmath44 and @xmath45 approximates @xmath46 , then there exists an abstract state @xmath47 such that @xmath48 and @xmath47 approximates @xmath49 .",
    "decidability _ is achieved by constructing the approximation in such a way that the state - space of the abstracted machine is finite , which guarantees that for any program @xmath5 , the set @xmath50 is finite .    *",
    "an attempt at approximation * : a simple approach to abstracting the machine s state space is to apply a _ structural abstraction _ , which lifts approximation across the structure of a machine state , _",
    "i.e. _ ,  expressions , environments , and continuations .",
    "the problem with the structural abstraction approach for the cek machine is that both environments and continuations are recursive structures . as a result , the abstraction yields objects in an abstract state - space with recursive structure , implying the space is infinite .    focusing on recursive structure as the source of the problem ,",
    "our course of action is to add a level of indirection , forcing recursive structure to pass through explicitly allocated addresses .",
    "doing so unhinges the recursion in the machine s data structures , enabling structural abstraction via a single point of approximation : the store .",
    "the next section covers the first of the two steps for refactoring the cek machine into its computable approximation : a store component is introduced to machine states and variable bindings and continuations are redirected through the store .",
    "this step introduces no approximation and the constructed machine operates in lock - step with the cek machine .",
    "however , the machine is amenable to a direct structural abstraction .",
    "the states of the cesk@xmath51  machine extend those of the cek machine to include a _ store _ , which provides a level of indirection for variable bindings and continuations to pass through .",
    "the store is a finite map from _ addresses _ to _ storable values _ , which includes closures and continuations , and environments",
    "are changed to map variables to addresses .",
    "when a variable s value is looked - up by the machine , it is now accomplished by using the environment to look up the variable s address , which is then used to look up the value . to bind a variable to a value ,",
    "a fresh location in the store is allocated and mapped to the value ; the environment is extended to map the variable to that address .    to untie the recursive structure associated with continuations , we likewise add a level of indirection through the store and replace the continuation component of the machine with a _ pointer _ to a continuation in the store .",
    "we term the resulting machine the cesk@xmath51 ( control , environment , store , continuation pointer ) machine .",
    "@xmath52    the transition function for the cesk@xmath51  machine is defined in figure  [ fig : cesa ] .",
    "the initial state for a program is given by the @xmath53 function , which combines the expression with the empty environment and a store with a single pointer to the empty continuation , whose address serves as the initial continuation pointer : @xmath54,{a}_0\\rangle\\text.\\ ] ]    an evaluation function based on this machine is defined following the template of the cek evaluation given in section  [ sec : cek ] : @xmath55 where the @xmath35 function is suitably extended to follow the environment s indirection through the store .",
    "we also define the set of reachable machine states : @xmath56    observe that for any program , the cek and cesk@xmath51 machines operate in lock - step : each machine transitions , by the corresponding rule , if and only if the other machine transitions .    @xmath57    the above lemma implies correctness of the machine .",
    "[ lem : pointer - equiv ] @xmath58 .",
    "@xmath59 \\hline & \\\\",
    "\\langle{x } , { \\rho } , { \\sigma } , { a}\\rangle & \\langle{v},{\\rho } ' , { \\sigma } , { a}\\rangle \\mbox { where } ( { v},{\\rho } ' ) = { \\sigma}({\\rho}({x } ) ) \\\\[1 mm ] \\langle{{\\mbox{\\tt ( } } { e}_0 { e}_1{\\mbox{\\tt ) } } } , { \\rho } , { \\sigma } , { a}\\rangle & \\langle{e}_0 , { \\rho } , { \\sigma}[{b}\\mapsto { \\mathbf{ar}}({e}_1 , { \\rho } , { a } ) ] , { b}\\rangle \\\\[1 mm ] \\langle{v},{\\rho},{\\sigma } , { a}\\rangle   \\\\ \\mbox { if } { \\kappa}= { \\mathbf{ar}}({e},{\\rho}',{c } )   & \\langle{e},{\\rho}',{\\sigma}[{b}\\mapsto { \\mathbf{fn}}({v},{\\rho},{c})],{b}\\rangle \\\\ \\mbox { if } { \\kappa}= { \\mathbf{fn}}({{\\mbox{\\tt ( } } \\uplambda { x}.{e}{\\mbox{\\tt ) } } } , { \\rho}',{c } )   & \\langle{e},{\\rho}'[{x}\\mapsto { b } ] , { \\sigma}[{b}\\mapsto ( { v},{\\rho } ) ] , { c}\\rangle \\end{array}\\ ] ]    * addresses , abstraction and allocation * : the cesk@xmath51 machine , as defined in figure  [ fig : cesa ] , nondeterministically chooses addresses when it allocates a location in the store , but because machines are identified up to consistent renaming of addresses , the transition system remains deterministic .    looking ahead , an easy way to bound the state - space of this machine is to bound the set of addresses .",
    "but once the store is finite , locations may need to be reused and when multiple values are to reside in the same location ; the store will have to soundly approximate this by _ joining _ the values .    in our concrete machine , all that matters",
    "about an allocation strategy is that it picks an unused address . in the abstracted machine",
    "however , the strategy _ will all but certainly have to re - use previously allocated addresses_. the abstract allocation strategy is therefore crucial to the design of the analysis ",
    "it indicates when finite resources should be doled out and decides when information should deliberately be lost in the service of computing within bounded resources .",
    "in essence , the allocation strategy is the heart of an analysis .    for this reason",
    ", concrete allocation deserves a bit more attention in the machine .",
    "an old idea in program analysis is that dynamically allocated storage can be represented by the state of the computation at allocation time  ( * ? ? ?",
    "* ; * ? ? ?",
    "* section 1.2.2 ) .",
    "that is , allocation strategies can be based on a ( representation ) of the machine history . since machine histories are always fresh , we we call them _ time - stamps_.    a common choice for a time - stamp , popularized by shivers  @xcite , is to represent the history of the computation as _ contours _ , finite strings encoding the calling context .",
    "we present a concrete machine that uses a general time - stamp approach and is parameterized by a choice of @xmath60 and @xmath61 functions .",
    "the machine states of the time - stamped cesk@xmath51 machine include a _ time _ component , which is intentionally left unspecified : @xmath62 the machine is parameterized by the functions : @xmath63 the @xmath60 function returns the next time ; the @xmath61 function allocates a fresh address for a binding or continuation .",
    "we require of @xmath60 and @xmath61 that for all @xmath64 and @xmath46 , @xmath65 and @xmath66 where @xmath67 .",
    "the time - stamped cesk@xmath51 machine is defined in figure  [ fig : cesat ] .",
    "note that occurrences of @xmath46 on the right - hand side of this definition are implicitly bound to the state occurring on the left - hand side .",
    "the evaluation function @xmath68 and reachable states @xmath69 are defined following the same outline as before and omitted for space .",
    "the initial machine state is defined as : @xmath70,{a}_0,{t}_0\\rangle\\text.\\ ] ]    @xmath71 \\hline \\\\ \\langle{x } , { \\rho } , { \\sigma } , { a},{t}\\rangle & \\langle{v},{\\rho } ' , { \\sigma } , { a},{u}\\rangle \\mbox { where } ( { v},{\\rho } ' ) = { \\sigma}({\\rho}({x } ) ) \\\\[1 mm ] \\langle{{\\mbox{\\tt ( } } { e}_0 { e}_1{\\mbox{\\tt ) } } } , { \\rho } , { \\sigma } , { a},{t}\\rangle   & \\langle{e}_0 , { \\rho } , { \\sigma}[{b}\\mapsto { \\mathbf{ar}}({e}_1 , { \\rho } , { a } ) ] , { b},{u}\\rangle \\\\[1 mm ] \\langle{v},{\\rho},{\\sigma } , { a},{t}\\rangle   \\\\ \\mbox{if } { \\kappa}= { \\mathbf{ar}}({e},{\\rho},{c } )   & \\langle{e},{\\rho},{\\sigma}[{b}\\mapsto { \\mathbf{fn}}({v},{\\rho},{c})],{b},{u}\\rangle \\\\ \\mbox{if } { \\kappa}= { \\mathbf{fn}}({{\\mbox{\\tt ( } } \\uplambda { x}.{e}{\\mbox{\\tt ) } } } , { \\rho}',c )   &   \\langle{e},{\\rho}'[{x}\\mapsto b ] , { \\sigma}[b \\mapsto ( { v},{\\rho } ) ] , c,{u}\\rangle \\end{array}\\ ] ]    satisfying definitions for the parameters are : @xmath72 under these definitions , the time - stamped cesk@xmath51 machine operates in lock - step with the cesk@xmath51 machine , and therefore with the cek machine , implying its correctness .",
    "[ lem : time - stamp - equiv ] @xmath73 .",
    "the time - stamped cesk@xmath51 machine forms the basis of our abstracted machine in the following section .",
    "as alluded to earlier , with the time - stamped cesk@xmath51 machine , we now have a machine ready for direct abstract interpretation via a single point of approximation : the store .",
    "our goal is a machine that resembles the time - stamped cesk@xmath51 machine , but operates over a finite state - space and it is allowed to be nondeterministic .",
    "once the state - space is finite , the transitive closure of the transition relation becomes computable , and this transitive closure constitutes a static analysis . buried in a path through the transitive closure is a possibly infinite traversal that corresponds to the concrete execution of the program .",
    "the abstracted variant of the time - stamped cesk@xmath51 machine comes from bounding the address space of the store and the number of times available . by bounding the address space",
    ", the whole state - space becomes finite .",
    "( syntactic sets like @xmath74 are infinite , but finite for any given program . ) for the purposes of soundness , an entry in the store may be forced to hold several values simultaneously : @xmath75 hence , stores now map an address to a _ set _ of storable values rather than a single value .",
    "these collections of values model approximation in the analysis .",
    "if a location in the store is re - used , the new value is joined with the current set of values . when a location is dereferenced , the analysis must consider any of the values in the set as a result of the dereference .",
    "the abstract time - stamped cesk@xmath51 machine is defined in figure  [ fig : acesat ] . the non - deterministic abstract transition relation changes little compared with the concrete machine .",
    "we only have to modify it to account for the possibility that multiple storable values , which includes continuations , may reside together in the store .",
    "we handle this situation by letting the machine non - deterministically choose a particular value from the set at a given store location .",
    "@xmath76 \\hline & \\\\ \\langle{x } , { \\rho } , { { \\hat{\\sigma } } } , { a},{t}\\rangle & \\langle { v},{\\rho } ' , { { \\hat{\\sigma } } } , { a},{u}\\rangle \\text { where } ( { v},{\\rho } ' ) \\in { { \\hat{\\sigma}}}({\\rho}({x } ) ) \\\\[1 mm ] \\langle{{\\mbox{\\tt ( } } { e}_0 { e}_1{\\mbox{\\tt ) } } } , { \\rho } , { { \\hat{\\sigma } } } , { a},{t}\\rangle   & \\langle{e}_0 , { \\rho } , { { \\hat{\\sigma}}}{\\sqcup}[{b}\\mapsto { \\mathbf{ar}}({e}_1 , { \\rho } , { a } ) ] , { b},{u}\\rangle \\\\[1 mm ] \\langle { v},{\\rho},{{\\hat{\\sigma } } } , { a},{t}\\rangle   \\\\ \\mbox{if } { \\kappa}= { \\mathbf{ar}}({e},{\\rho}',{c } ) & \\langle{e},{\\rho}',{{\\hat{\\sigma}}}{\\sqcup}[{b}\\mapsto { \\mathbf{fn}}({v},{\\rho},{c})],{b},{u}\\rangle \\\\ \\mbox{if } { \\kappa}={\\mathbf{fn}}({{\\mbox{\\tt ( } } \\uplambda { x}.{e}{\\mbox{\\tt ) } } } , { \\rho}',{c } ) & \\langle{e},{\\rho}'[{x}\\mapsto { b } ] , { { \\hat{\\sigma}}}{\\sqcup}[{b}\\mapsto ( { v},{\\rho } ) ] , { c},{u}\\rangle \\end{array}\\ ] ]    the analysis is parameterized by abstract variants of the functions that parameterized the concrete version : @xmath77 in the concrete , these parameters determine allocation and stack behavior . in the abstract",
    ", they are the arbiters of precision : they determine when an address gets re - allocated , how many addresses get allocated , and which values have to share addresses .",
    "recall that in the concrete semantics , these functions consume states  not states and continuations as they do here .",
    "this is because in the concrete , a state alone suffices since the state determines the continuation .",
    "but in the abstract , a continuation pointer within a state may denote a multitude of continuations ; however the transition relation is defined with respect to the choice of a particular one .",
    "we thus pair states with continuations to encode the choice .",
    "the _ abstract _ semantics is given by the reachable states : @xmath78    * soundness and decidability * : we have endeavored to evolve the abstract machine gradually so that its fidelity in soundly simulating the original cek machine is both intuitive and obvious . to formally establish soundness of the abstract time - stamped cesk@xmath51 machine , we use an abstraction function , defined in figure  [ fig : abs - map ] , from the state - space of the concrete time - stamped machine into the abstracted state - space .",
    "@xmath79 }    \\\\    { \\alpha}({\\rho } ) & = \\lambda { x}. { \\alpha}({\\rho}({x } ) ) & & \\text{[environments ] } \\\\    { \\alpha}({\\sigma } ) & = \\lambda { { \\hat{{a}}}}. \\!\\!\\!\\ ! { \\bigsqcup}_{{\\alpha}({a } ) = { { \\hat{{a } } } } } \\!\\!\\!\\ ! { \\left\\{{\\alpha}({\\sigma}({a}))\\right\\ } } & & \\text{[stores ] }    \\\\    { \\alpha}({{\\mbox{\\tt ( } } \\uplambda { x}.{e}{\\mbox{\\tt ) } } } , { \\rho } ) & = ( { { \\mbox{\\tt ( } } \\uplambda { x}.{e}{\\mbox{\\tt ) } } } , { \\alpha}({\\rho } ) ) & & \\text{[closures ] }    \\\\    { \\alpha}({\\mathbf{mt } } ) & = { \\mathbf{mt } } & & \\text{[continuations ] }    \\\\    { \\alpha}({\\mathbf{ar}}({e},{\\rho},{a } ) ) & = { \\mathbf{ar}}({e},{\\alpha}({\\rho}),{\\alpha}({a } ) )    \\\\    { \\alpha}({\\mathbf{fn}}({v},{\\rho},{a } ) ) & = { \\mathbf{fn}}({v},{\\alpha}({\\rho}),{\\alpha}({a}))\\end{aligned}\\ ] ]    the abstraction map over times and addresses is defined so that the parameters @xmath80 and @xmath81 are sound simulations of the parameters @xmath61 and @xmath60 , respectively .",
    "we also define the partial order @xmath82 on the abstract state - space as the natural point - wise , element - wise , component - wise and member - wise lifting , wherein the partial orders on the sets @xmath74 and @xmath83 are flat .",
    "then , we can prove that abstract machine s transition relation simulates the concrete machine s transition relation .",
    "+ if @xmath84 and @xmath85 , then there exists an abstract state @xmath47 , such that @xmath86 and @xmath87 .    by lemmas  [ lem : pointer - equiv ] and  [ lem : time - stamp - equiv ]",
    ", it suffices to prove soundness with respect to @xmath88 .",
    "assume @xmath89 and @xmath85 . because @xmath46 transitioned",
    ", exactly one of the rules from the definition of @xmath90 applies .",
    "we split by cases on these rules .",
    "the rule for the second case is deterministic and follows by calculation . for the remaining ( nondeterministic ) cases",
    ", we must show an abstract state exists such that the simulation is preserved . by examining the rules for these cases ,",
    "we see that all three hinge on the abstract store in @xmath45 soundly approximating the concrete store in @xmath46 , which follows from the assumption that @xmath91 .",
    "+ membership of @xmath45 in @xmath92 is decidable .",
    "the state - space of the machine is non - recursive with finite sets at the leaves on the assumption that addresses are finite .",
    "hence reachability is decidable since the abstract state - space is finite .",
    "we have shown that store - allocated continuations make abstract interpretation of the cesk@xmath93 machine straightforward . in this section ,",
    "we want to show that the tight correspondence between concrete and abstract persists after the addition of language features such as conditionals , side effects , and first - class continuations .",
    "we tackle each feature , and present the additional machinery required to handle each one . in most cases ,",
    "the path from a canonical concrete machine to pointer - refined abstraction of the machine is so simple we only show the abstracted system . in doing so , we are arguing that this abstract machine - oriented approach to abstract interpretation represents a flexible and viable framework for building program analyses .    to handle conditionals , we extend the language with a new syntactic form , @xmath94 , and introduce a base value @xmath95 , representing false .",
    "conditional expressions induce a new continuation form : @xmath96 , which represents the evaluation context @xmath97\\ ; { e}_0\\ ; { e}_1{\\mbox{\\tt ) } } } ] $ ] where @xmath14 closes @xmath98 to represent @xmath99 , @xmath14 closes @xmath100 to represent @xmath101 , and @xmath102 is the address of the representation of @xmath24 .",
    "side effects are fully amenable to our approach ; we introduce scheme s ` set ! ` for mutating variables using the @xmath103 syntax .",
    "the ` set ! ` form evaluates its subexpression @xmath5 and assigns the value to the variable @xmath4 .",
    "although ` set !",
    "` expressions are evaluated for effect , we follow felleisen _ et al .",
    "_  and specify ` set ! `",
    "expressions evaluate to the value of @xmath4 before it was mutated  @xcite . the evaluation context @xmath104{\\mbox{\\tt ) } } } ] $ ] is represented by @xmath105 , where @xmath106 is the address of @xmath4 s value and @xmath107 is the address of the representation of @xmath24 .",
    "first - class control is introduced by adding a new base value callcc which reifies the continuation as a new kind of applicable value .",
    "denoted values are extended to include representations of continuations . since continuations are store - allocated , we choose to represent them by address .",
    "when an address is applied , it represents the application of a continuation ( reified via callcc ) to a value .",
    "the continuation at that point is discarded and the applied address is installed as the continuation .",
    "the resulting grammar is : @xmath108 we show only the abstract transitions , which result from store - allocating continuations , time - stamping , and abstracting the concrete transitions for conditionals , mutation , and control .",
    "the first three machine transitions deal with conditionals ; here we follow the scheme tradition of considering all non - false values as true .",
    "the fourth and fifth transitions deal with mutation .",
    "@xmath109 \\hline & \\\\     \\langle{{\\mbox{\\tt ( } } { \\tt if}\\ ; { e}_0\\ ; { e}_1\\ ; { e}_2{\\mbox{\\tt ) } } } , { \\rho},{{\\hat{\\sigma}}},{a},{t}\\rangle & \\langle{e}_0,{\\rho},{{\\hat{\\sigma}}}\\sqcup [ { b}\\mapsto \\mathbf{if}({e}_1,{e}_2,{\\rho},{a})],{b},{u}\\rangle \\\\[1 mm ] \\langle{{\\mbox{\\tt\\#f}}},{\\rho},{{\\hat{\\sigma}}},{a},{t}\\rangle & \\langle{e}_1,{\\rho}',{{\\hat{\\sigma}}},{c},{u}\\rangle \\\\",
    "\\mbox{if } { \\kappa}=     \\mathbf{if}({e}_0,{e}_1,{\\rho}',{c } ) \\\\[1 mm ] \\langle{v},{\\rho},{{\\hat{\\sigma}}},{a},{t}\\rangle & \\langle{e}_0,{\\rho}',{{\\hat{\\sigma}}},{c},{u}\\rangle \\\\",
    "\\mbox{if } { \\kappa}=     \\mathbf{if}({e}_0,{e}_1,{\\rho}',{c } ) , \\\\",
    "\\text{and }   { v}\\neq{{\\mbox{\\tt\\#f}}}\\\\[1 mm ] \\langle{{\\mbox{\\tt ( } } { \\tt set!}\\ ; { x}\\ ; { e}{\\mbox{\\tt ) } } } , { \\rho},{{\\hat{\\sigma}}},{a},{t}\\rangle & \\langle{e},{\\rho},{{\\hat{\\sigma}}}\\sqcup [ { b}\\mapsto \\mathbf{set}({\\rho}({x } ) , { a})],{b},{u}\\rangle \\\\[1 mm ] \\langle{v},{\\rho},{{\\hat{\\sigma}}},{a},{t}\\rangle & \\langle{v}',{\\rho},{{\\hat{\\sigma}}}{\\sqcup}[{a } ' \\mapsto { v}],{c},{u}\\rangle \\\\ \\mbox { if } { \\kappa}=     \\mathbf{set}({a}',{c } )   & \\mbox{where } { v } ' \\in { { \\hat{\\sigma}}}({a } ' ) \\\\[1 mm ] \\langle { { \\mbox{\\tt ( } } \\uplambda { x}.{e}{\\mbox{\\tt ) } } } , { \\rho},{{\\hat{\\sigma}}},{a},{t}\\rangle   & \\langle { e},{\\rho}[{x}\\mapsto { b}],{{\\hat{\\sigma}}}{\\sqcup}[{b}\\mapsto { c}],{c},{u}\\rangle \\\\ \\mbox{if } { \\kappa}= { \\mathbf{fn}}({\\tt callcc},{\\rho}',{c } ) & \\mbox{where } { c}={{\\widehat{alloc}}}({{\\hat{\\varsigma}}},{\\kappa } ) \\\\[1 mm ] \\langle { c},{\\rho},{{\\hat{\\sigma}}},{a},{t}\\rangle   & \\langle { a},{\\rho},{{\\hat{\\sigma}}},{c},{u}\\rangle   \\\\ \\mbox{if } { \\kappa}= { \\mathbf{fn}}({\\tt callcc},\\rho',{a } ' ) \\\\[1 mm ] \\langle { v},{\\rho},{{\\hat{\\sigma}}},{a},{t}\\rangle   & \\langle { v},{\\rho},{{\\hat{\\sigma}}},{c},{u}\\rangle   \\\\ \\mbox{if } { \\kappa}= { \\mathbf{fn}}({c},{\\rho}',{a } ' ) \\end{array}\\ ] ]    the remaining three transitions deal with first - class control .",
    "in the first of these , callcc is being applied to a closure value @xmath2 .",
    "the value @xmath2 is then `` called with the current continuation '' , _",
    "i.e. _ , @xmath2 is applied to a value that represents the continuation at this point . in the second ,",
    "callcc is being applied to a continuation ( address ) . when this value is applied to the reified continuation , it aborts the current computation , installs itself as the current continuation , and puts the reified continuation `` in the hole '' .",
    "finally , in the third , a continuation is being applied ; @xmath110 gets thrown away , and @xmath2 gets plugged into the continuation @xmath111 . in all cases , these transitions result from pointer - refinement , time - stamping , and abstraction of the usual machine transitions .",
    "garbage collection determines when a store location has become unreachable and can be re - allocated .",
    "this is significant in the abstract semantics because an address may be allocated to multiple values due to finiteness of the address space . without garbage collection ,",
    "the values allocated to this common address must be joined , introducing imprecision in the analysis ( and inducing further , perhaps spurious , computation ) . by incorporating garbage collection in the abstract semantics ,",
    "the location may be proved to be unreachable and safely _ overwritten _ rather than joined , in which case no imprecision is introduced .    like the rest of the features addressed in this paper",
    ", we can incorporate abstract garbage collection into our static analyzers by a straightforward pointer - refinement of textbook accounts of concrete garbage collection , followed by a finite store abstraction .",
    "concrete garbage collection is defined in terms of a gc machine that computes the reachable addresses in a store  @xcite : @xmath112 this machine iterates over a set of reachable but unvisited `` grey '' locations @xmath113 . on each iteration",
    ", an element is removed and added to the set of reachable and visited `` black '' locations @xmath114 .",
    "any newly reachable and unvisited locations , as determined by the `` live locations '' function @xmath115 , are added to the grey set .",
    "when there are no grey locations , the black set contains all reachable locations .",
    "everything else is garbage .",
    "the live locations function computes a set of locations which may be used in the store .",
    "its definition varies based on the machine being garbage collected , but the definition appropriate for the cesk@xmath51 machine of section  [ sec : ceskp ] is : @xmath116 we write @xmath117 to mean @xmath14 restricted to the domain of free variables in @xmath5 .",
    "we assume the least - fixed - point solution in the calculation of the function @xmath118 in cases where it recurs on itself .",
    "the pointer - refinement requires parameterizing the @xmath118 function with a store used to resolve pointers to continuations .",
    "a nice consequence of this parameterization is that we can re - use @xmath118 for _ abstract garbage collection _ by supplying it an abstract store for the parameter .",
    "doing so only necessitates extending @xmath118 to the case of sets of storable values : @xmath119 the cesk@xmath51 machine incorporates garbage collection by a transition rule that invokes the gc machine as a subroutine to remove garbage from the store ( figure  [ fig : gc ] ) .",
    "the garbage collection transition introduces non - determinism to the cesk@xmath51 machine because it applies to any machine state and thus overlaps with the existing transition rules .",
    "the non - determinism is interpreted as leaving the choice of _ when _ to collect garbage up to the machine .",
    "the abstract cesk@xmath51 incorporates garbage collection by the _ concrete garbage collection transition _ , _ i.e. _ , we re - use the definition in figure  [ fig : gc ] with an abstract store , @xmath120 , in place of the concrete one .",
    "consequently , it is easy to verify abstract garbage collection approximates its concrete counterpart .",
    "@xmath121 \\hline & \\\\",
    "\\langle { e},{\\rho},{\\sigma},{a}\\rangle \\qquad\\qquad\\qquad & \\langle { e},{\\rho},\\{\\langle{b},{\\sigma}({b})\\rangle\\ |\\ { b}\\in \\mathcal{l}\\},{a}\\rangle \\\\ \\multicolumn{2}{@{}l } { \\mbox{if } \\langle{\\mathit{ll}}_{\\sigma}({e},{\\rho } ) \\cup { \\mathit{ll}}_{\\sigma}({\\sigma}({a})),\\{{a}\\},{\\sigma}\\rangle { \\longmapsto\\!\\!\\!\\!\\!\\rightarrow}_{\\mathit{gc } } \\langle\\emptyset,\\mathcal{l},{\\sigma}\\rangle } \\end{array}\\ ] ]    the cesk@xmath51 machine may collect garbage at any point in the computation , thus an abstract interpretation must soundly approximate _ all possible choices _ of when to trigger a collection , which the abstract cesk@xmath51 machine does correctly .",
    "this may be a useful analysis _ of _ garbage collection , however it fails to be a useful analysis _ with _ garbage collection : for soundness , the abstracted machine must consider the case in which garbage is never collected , implying no storage is reclaimed to improve precision .",
    "however , we can leverage abstract garbage collection to reduce the state - space explored during analysis and to improve precision and analysis time .",
    "this is achieved ( again ) by considering properties of the _ concrete _ machine , which abstract directly ; in this case , we want the concrete machine to deterministically collect garbage .",
    "determinism of the cesk@xmath51 machine is restored by defining the transition relation as a non - gc transition ( figure  [ fig : cesa ] ) followed by the gc transition ( figure  [ fig : gc ] ) .",
    "this state - space of this concrete machine is `` garbage free '' and consequently the state - space of the abstracted machine is `` abstract garbage free . ''    in the concrete semantics , a nice consequence of this property is that although continuations are allocated in the store , they are deallocated as soon as they become unreachable , which corresponds to when they would be popped from the stack in a non - pointer - refined machine .",
    "thus the concrete machine really manages continuations like a stack .",
    "similarly , in the abstract semantics , continuations are deallocated as soon as they become unreachable , which often corresponds to when they would be popped .",
    "we say often , because due to the finiteness of the store , this correspondence can not always hold .",
    "however , this approach gives a good finite approximation to infinitary stack analyses that can always match calls and returns .",
    "the study of abstract machines for the @xmath0-calculus began with landin s secd machine  @xcite , the systematic construction of machines from semantics with reynolds s definitional interpreters  @xcite , the theory of abstract interpretation with the seminal work of cousot and cousot  @xcite , and static analysis of the @xmath0-calculus with jones s coupling of abstract machines and abstract interpretation  @xcite .",
    "all have been active areas of research since their inception , but only recently have well known abstract machines been connected with abstract interpretation by midtgaard and jensen  @xcite .",
    "we strengthen the connection by demonstrating a general technique for abstracting abstract machines .",
    "the approximation of abstract machine states for the analysis of higher - order languages goes back to jones  @xcite , who argued abstractions of regular tree automata could solve the problem of recursive structure in environments .",
    "we re - invoked that wisdom to eliminate the recursive structure of continuations by allocating them in the store .",
    "midtgaard and jensen present a 0cfa for a cps language  @xcite .",
    "the approach is based on cousot - style calculational abstract interpretation  @xcite , applied to a functional language .",
    "like the present work , midtgaard and jensen start with a known abstract machine for the concrete semantics , the ce machine of flanagan , _ et al . _",
    "@xcite , and employ a reachable - states model .",
    "they then compose well - known galois connections to reveal a 0cfa with reachability in the style of ayers  @xcite .",
    "the ce machine is not sufficient to interpret direct - style programs , so the analysis is specialized to programs in continuation - passing style .",
    "although our approach is not calculational like midtgaard and jensen s , it continues in their vein by applying abstract interpretation to well known machines , extending the application to direct - style machines to obtain a parameterized family of analyses that accounts for polyvariance .",
    "static analyzers typically hemorrhage precision in the presence of exceptions and first - class continuations : they jump to the top of the lattice of approximation when these features are encountered .",
    "conversion to continuation- and exception - passing style can handle these features without forcing a dramatic ascent of the lattice of approximation  @xcite .",
    "the cost of this conversion , however , is lost knowledge  both approaches obscure static knowledge of stack structure , by desugaring it into syntax .    might and shivers introduced the idea of using abstract garbage collection to improve precision and efficiency in flow analysis  @xcite .",
    "they develop a garbage collecting abstract machine for a cps language and prove it correct .",
    "we extend abstract garbage collection to direct - style languages interpreted on the cesk machine .",
    "we have demonstrated a derivational approach to program analysis that yields novel abstract interpretations of languages with higher - order functions , control , state , and garbage collection .",
    "these abstract interpreters are obtained by a straightforward pointer refinement and structural abstraction that bounds the address space , making the abstract semantics safe and computable .",
    "the technique allows concrete implementation technology , such as garbage collection , to be imported straightforwardly into that of static analysis , bearing immediate benefits .",
    "more generally , an abstract machine based approach to analysis shifts the focus of engineering efforts from the design of complex analytic models such as involved constraint languages back to the design of programming languages and machines , from which analysis can be _ derived_. finally , our approach uniformly scales up to richer language features such as laziness , stack - inspection , exceptions , and object - orientation .",
    "we speculate that store - allocating bindings and continuations is sufficient for a straightforward abstraction of most existing machines .",
    "looking forward , a semantics - based approach opens new possibilities for design .",
    "context - sensitive analysis can have daunting complexity  @xcite , which we have made efforts to tame  @xcite , but modular program analysis is crucial to overcome the significant cost of precise abstract interpretation .",
    "modularity can be achieved without needing to design clever approximations , but rather by designing _ modular semantics _ from which modular analyses follow systematically  @xcite . likewise , _",
    "push - down analyses _ offer infinite state - space abstractions with perfect call - return matching while retaining decidability .",
    "our approach expresses this form of abstraction naturally : the store remains bounded , but continuations stay on the stack .",
    "we thank matthias felleisen , jan midtgaard , sam tobin - hochstadt , and mitchell wand for discussions , and the anonymous reviewers of _",
    "icfp10 _ for their close reading and helpful critiques ; their comments have improved this paper .",
    "p.  cousot and r.  cousot .",
    "abstract interpretation : a unified lattice model for static analysis of programs by construction or approximation of fixpoints . in _",
    "popl 77 : proceedings of the 4th acm sigact - sigplan symposium on principles of programming languages _ , pages 238252 .",
    "acm , 1977 .",
    "c.  flanagan , a.  sabry , b.  f. duba , and m.  felleisen . the essence of compiling with continuations . in _",
    "pldi 93 : proceedings of the acm sigplan 1993 conference on programming language design and implementation _ ,",
    "pages 237247 .",
    "acm , june 1993 .",
    "n.  d. jones and s.  s. muchnick . a flexible approach to interprocedural data flow analysis and programs with recursive data structures . in _",
    "popl 82 : proceedings of the 9th acm sigplan - sigact symposium on principles of programming languages _ ,",
    "popl 82 , pages 6674 .",
    "acm , 1982 .",
    "p.  meunier , r.  b. findler , and m.  felleisen .",
    "modular set - based analysis from contracts . in _",
    "popl 06 : conference record of the 33rd acm sigplan - sigact symposium on principles of programming languages _ ,",
    "pages 218231 .",
    "acm , jan .",
    "2006 .",
    "j.  midtgaard and t.  jensen . a calculational approach to control - flow analysis by abstract interpretation . in m.",
    "alpuente and g.  vidal , editors , _ sas _ , volume 5079 of _ lncs _ , pages 347362 .",
    "springer , 2008 .",
    "j.  midtgaard and t.  p. jensen .",
    "control - flow analysis of function calls and returns by abstract interpretation . in _",
    "icfp 09 : proceedings of the 14th acm sigplan international conference on functional programming _ , pages 287298 .",
    "acm , 2009 .",
    "m.  might and o.  shivers . improving flow analyses via @xmath122cfa : abstract garbage collection and counting . in _ proceedings of the 11th acm international conference on functional programming ( icfp 2006 ) _ , pages 1325 , sept .",
    "m.  might , y.  smaragdakis , and d.  van horn . resolving and exploiting the @xmath123-cfa paradox : illuminating functional vs. object - oriented program analysis . in _",
    "pldi 10 : proceedings of the 2010 acm sigplan conference on programming language design and implementation _ , pages 305315 .",
    "acm , 2010 .",
    "d.  van horn and h.  g. mairson .",
    "deciding @xmath123cfa is complete for exptime . in _",
    "icfp 08 : proceeding of the 13th acm sigplan international conference on functional programming _ , pages 275282 .",
    "acm , 2008 ."
  ],
  "abstract_text": [
    "<S> predictive models are fundamental to engineering reliable software systems . however , designing conservative , computable approximations for the behavior of programs ( static analyses ) remains a difficult and error - prone process for modern high - level programming languages . </S>",
    "<S> what analysis designers need is a principled method for navigating the gap between semantics and analytic models : analysis designers need a method that tames the _ interaction _ of complex languages features such as higher - order functions , recursion , exceptions , continuations , objects and dynamic allocation .    </S>",
    "<S> we contribute a _ </S>",
    "<S> systematic approach to program analysis _ that yields novel and transparently sound static analyses . </S>",
    "<S> our approach relies on existing derivational techniques to transform high - level language semantics into low - level deterministic state - transition systems ( with potentially infinite state spaces ) . </S>",
    "<S> we then perform a series of simple machine refactorings to obtain a sound , computable approximation , which takes the form of a _ non - deterministic _ state - transition systems with _ finite _ state spaces . </S>",
    "<S> the approach scales up uniformly to enable program analysis of realistic language features , including higher - order functions , tail calls , conditionals , side effects , exceptions , first - class continuations , and even garbage collection . </S>"
  ]
}