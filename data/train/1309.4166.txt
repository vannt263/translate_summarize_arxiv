{
  "article_text": [
    "we consider index - coding problems , first introduced by birk and kol  @xcite , where a sender communicates with multiple receivers simultaneously through a shared broadcast medium .",
    "the aim is to find the shortest codeword that the sender needs to broadcast in order for each receiver , knowing some of the messages broadcast by the sender a priori , to obtain its requested message .",
    "index - coding problems have been receiving much attention lately due to its equivalence to network - coding problems  @xcite .",
    "each index - coding problem instance can be fully described by a directed or an undirected graph .",
    "bar - yossef et al .",
    "@xcite characterized the optimal index codelength for graphs of the following types : ( a ) directed and acyclic , ( b ) undirected and perfect , ( c ) undirected odd holes of five or more vertices , and ( d ) undirected odd anti - holes of five or more vertices .",
    "in general , the index - coding problem remains open to date , though lower and upper bounds have been obtained  @xcite . a lower bound",
    "is given by the number of vertices in a maximum acyclic induced subgraph ( mais )  @xcite .",
    "the _ minrank _ function  @xcite of the graph gives an upper bound ( i.e. , achievability ) , and it also gives the optimal _ linear _ index codelength .",
    "both the mais lower bound and the minrank upper bound are np - hard to compute  @xcite , and both have been shown to be loose in some instances  @xcite .",
    "this implies that linear index codes , though having practical advantages of simplifying encoding and decoding , are not necessarily optimal .    in this paper ,",
    "we extend existing results to a new class of problem instances : we show that if an mais is formed by removing two or fewer vertices , then the mais lower bound is achievable using linear index codes , meaning that linear index codes are optimal for this class of index - coding problems . to this end , we show that this class of graphs must contain some special configurations ; by proposing a new coding scheme on these special configurations , we are able to construct the required optimal index code .",
    "this incidentally characterizes a class of ( infinitely many ) graphs where the minrank upper bound and the mais lower bound coincide .",
    "let there be @xmath0 receivers , @xmath1 , and each receiver  @xmath2 requests a message @xmath3 from the sender .",
    "the sender knows all the messages , @xmath4 .",
    "it encodes @xmath5 into a length-@xmath6 codeword @xmath7 .",
    "it then broadcasts the codeword to all receivers noiselessly to allow each receiver  @xmath2who knows some prior side information @xmath8to decode its requested message , i.e. , @xmath9 , for all @xmath10 . here , @xmath11 is the index code , and @xmath6 is the index codelength . the aim is the find the minimum index codelength , denoted by @xmath12 .",
    "each index - coding problem instance is completely specified by @xmath13 for all @xmath10 .",
    "it can also be fully described by a directed graph @xmath14 , consisting of a set of vertices @xmath15 and a set of arcs @xmath16 .",
    "an arc from vertex @xmath2 to vertex @xmath17 exists , denoted by @xmath18 , if and only if receiver  @xmath2 knows @xmath19 , or equivalently , @xmath20 . by definition",
    ", there is no self loop or parallel arc . for an arc @xmath21 ,",
    "vertex @xmath2 is the _ tail _ and @xmath17 the _",
    "head_. we term this graphical representation _ side - information graph_. each vertex  @xmath2 in @xmath14 represents both message  @xmath22 and receiver  @xmath2 .    for the special case where for each @xmath18 , there exists an arc @xmath23 , the index - coding problem instance can also be represented by an undirected graph @xmath24 , consisting of the same set of vertices @xmath25 , and a set of edges @xmath26 , where @xmath27 if and only if @xmath18 , which also means @xmath23 .",
    "we denote by @xmath28 the optimal ( or minimum ) index codelength of an index - coding problem instance represented by graph @xmath14 , which can be directed or undirected .",
    "bar - yossef et al .",
    "have shown the following lower bound  @xcite : @xmath29 where @xmath30 is the number of vertices in a maximum acyclic induced subgraph ( mais ) of @xmath14 .",
    "an mais is obtained by finding an acyclic vertex - induced subgraph that has the largest number of vertices . for any @xmath14 , denote an mais by @xmath31 , and the set of vertices removed by @xmath32 , where @xmath33 is the number of removed vertices .",
    "note that @xmath33 for each @xmath14 is fixed , but the mais may not be unique . for a _ vertex - induced _ subgraph ,",
    "when we remove a vertex @xmath34 from a graph @xmath14 , we remove all outgoing arcs from and all incoming arcs to @xmath34 , but we must keep all other remaining arcs in @xmath14 .",
    "in this paper , we derive the optimal index codelength , together with the corresponding optimal index code , for a class of graphs , for any message alphabet size @xmath35 .",
    "recall that for any directed graph @xmath14 , the number of vertices we need to remove to obtain an mais is denoted by @xmath33 . with this",
    ", we now state the main result of this paper .",
    "[ theorem-2 ] for any @xmath14 where @xmath36 , the optimal index codelength is given by @xmath37        consider the index - coding problem instance depicted in figure  [ fig : bipartite](a ) as an example .",
    "an mais can be formed by removing @xmath38 ( the choice is not unique ) . from theorem",
    "[ theorem-2 ] , we have @xmath39 . an optimal index code is @xmath40 ( which is also not unique ) , where @xmath41 denotes addition modulo @xmath42 .",
    "this problem instance is not covered by the results by bar - yossef et al .",
    "@xcite , as the side - information graph is neither acyclic nor undirected .",
    "neely et al .",
    "@xcite and tehrani et al .",
    "@xcite have shown the following achievability :    [ lemma ] if a directed graph @xmath14 contains @xmath43 vertex - disjoint cycles , then the index codelength of @xmath44 is achievable .    for figure  [ fig : bipartite](a )",
    ", their scheme only achieves @xmath45 , which is strictly suboptimal .",
    "recently , shanmugam et al .",
    "@xcite have shown that an upper bound of @xmath12 is given by the _ local chromatic number _ of the complement graph of @xmath14 , denoted by @xmath46 .",
    "the local chromatic number of @xmath46 is the maximum number of colors in any , minimized over all proper coloring of the undirected counterpart ( by ignoring the arc direction ) of @xmath46 . from figure",
    "[ fig : bipartite](c ) , we see that this scheme achieves @xmath47 .",
    "bipartite graphs are also used to represent a more general  in fact , the most general  class of index - coding problem instances where a message can be requested by more than one receiver ( cf .",
    "side - information graphs ) .",
    "neely et al .",
    "* theorem  1 ) found @xmath12 for all acyclic bipartite graphs ; yu and neely  @xcite found @xmath12 for all planar bipartite graphs . the bipartite graph that represents our example is depicted in figure  [ fig : bipartite](b ) , which contains cycles . also , ignoring the arc direction , we _ contract _",
    "the edges @xmath48 to obtain a complete bipartite graph on three and three vertices , commonly denoted by @xmath49 .",
    "since any planar graph can not contain a @xmath49 minor , figure  [ fig : bipartite](b ) is not planar .",
    "tehrani et al .",
    "@xcite have proposed a _",
    "packet decomposition _",
    "scheme to obtain an upper bound on bipartite graphs .",
    "achievability of the scheme was derived on the assumption that @xmath50 is a large finite field . even if the results can be shown to hold for smaller alphabets",
    ", the scheme can only achieve @xmath45 for the instance in figure  [ fig : bipartite](a ) .",
    "consequently , our results strictly extend the existing results .",
    "recently , we built on the results of this paper to characterize @xmath12 for all @xmath14 up to five vertices  @xcite .",
    "the optimal _ linear _ index codelength for any graph @xmath14 is given by its minrank value  @xcite .",
    "characterizing graphs having a certain minrank value is hard ; dau et al .",
    "@xcite managed to characterize all undirected graphs whose minrank value is @xmath51 or @xmath52 , and all directed graphs whose minrank value is 2 or @xmath53 .",
    "they are , however , unable to characterize directed graphs whose minrank value is @xmath52 or @xmath51 . for any directed graph @xmath14 whose @xmath30 equals @xmath52 or @xmath51 , we show in this paper that linear index codes are optimal , meaning that @xmath30 equals its minrank .",
    "so , we have incidentally characterized a subset of directed graphs whose minrank equals @xmath52 or @xmath51 .",
    "as @xmath30 is a lower bound to @xmath12 , we only need to prove achievability . recall that @xmath33 is the minimum number of vertices we need to remove from @xmath14 to make it acyclic , i.e. , to obtain an mais .",
    "firstly , suppose that @xmath33 = 0 .",
    "sending all messages uncoded achieves the index codelength @xmath53 , and we have .",
    "next , suppose that @xmath33 = 1 .",
    "the directed graph @xmath14 must contain at least one cycle ; otherwise , @xmath54 .",
    "it follows from lemma  [ lemma ] that @xmath55 is achievable .",
    "lastly , @xmath56 .",
    "there are two possibilities for @xmath14 :    1 .",
    "there exist two vertex - disjoint cycles , or 2 .",
    "there are no two vertex - disjoint cycles .    for case ( i )",
    ", it again follows from lemma  [ lemma ] that @xmath57 is achievable .",
    "the savings of two symbols ( compared to sending all @xmath53 symbols uncoded ) can be achieved using a cyclic code on each disjoint cycle .",
    "for example , for a cycle of length @xmath58 , say @xmath59 , we send the following @xmath60 coded symbols , thereby saving one symbol : @xmath61 .",
    "since each receiver @xmath2 knows at least one other symbol in the cyclic code , it can decode its required @xmath22 .     is to show that if @xmath62 and condition ( ii ) is true , then @xmath14 must contain a subgraph @xmath63 shown above . here , every arrow represents a path , which is denoted by a capital letter .",
    "the paths do not share common vertices except the end points .",
    "vertices in each path is denoted by the corresponding small letter , indexed in the direction of the arcs , e.g. , path @xmath64 is @xmath65 .",
    "all paths except @xmath66 , @xmath67 , and @xmath68 must contain one or more arcs.,width=283 ]    the main challenge of theorem  [ theorem-2 ] is to show that for case ( ii ) , even though we can not find two vertex - disjoint cycles , we can still save two symbols . to this end , we will show that if @xmath62 and if condition ( ii ) above is true , then there exists a subgraph in @xmath14 of a certain configuration , stated as follows :    [ lemma : special - subgraph ] if @xmath62 , and there are no two vertex - disjoint cycles ( i.e. , condition ( ii ) ) , then @xmath14 must contain a subgraph ( not necessarily an induced subgraph ) shown in figure  [ fig : three - cycles ] .",
    "we will design a special code on this subgraph to show that @xmath51 is indeed achievable .",
    "we will first present the code in the next section , and then prove lemma  [ lemma : special - subgraph ] in section  [ sec : lemma ] .",
    "we now propose a new coding scheme that achieves the codelength @xmath51 for case ( ii ) .",
    "we need to show that each receiver @xmath69 can decode its intended message , i.e. , @xmath22 .",
    "we will propose a code for the subgraph in figure  [ fig : three - cycles ] , denoted by @xmath63 , and send the rest of the messages ( which correspond to the vertices in @xmath70 ) uncoded .",
    "this means all receivers @xmath71 can decode their intended messages , and we only need to show that all receivers @xmath72 can also decode their intended messages .",
    "we propose the following coding strategy : for each vertex  @xmath73 , with all its denoted by @xmath74 , we send the code symbol @xmath75 .    for each path in @xmath63 ( denoted by a capital letter ) , we denote the vertices therein by its corresponding small letter , indexed in the direction of the arcs . for example , path @xmath64 is @xmath65 . in figure",
    "[ fig : three - cycles ] , we have @xmath76 , i.e. , the first vertex in path @xmath64 is the last vertex in path @xmath68 , which is also the first vertex in path @xmath77 .",
    "we use the above coding strategy to send the code symbol for all vertices in @xmath63 except @xmath78 and @xmath79 . by design , all receivers  except @xmath78 and @xmath79can decode their requested messages , as each receiver  @xmath80 knows a priori the messages corresponding to the head of all outgoing arcs from @xmath80 .",
    "so , we only need to show that receivers @xmath78 and @xmath79 can decode their respective requested messages , @xmath81 and @xmath82 .",
    "we start with receiver  @xmath83 .",
    "knowing @xmath84 a priori , it decodes along path  @xmath77 ( i.e. , @xmath85 ) , to get @xmath86 , and continues along path @xmath66 to get @xmath87 . in the event that path @xmath66 has zero arc , it can also obtain @xmath88 , which is @xmath89 . also knowing @xmath90 a priori , receiver  @xmath78 decodes along path @xmath64 to get @xmath91 ,",
    "from which it can decode backward along path @xmath92 to get @xmath93 . having decoded @xmath88 earlier and now @xmath93 , it obtains @xmath94 from @xmath95 . with @xmath94 , it decodes along path @xmath96 and then path @xmath68 to get @xmath97 . in the event that path @xmath68 has zero arc ,",
    "the receiver would have obtained @xmath98 earlier .    for receiver  @xmath79 , knowing @xmath99 , it decodes along path @xmath100 to get @xmath101 .",
    "it then decodes backward along path @xmath96 to get @xmath94 .",
    "also knowing @xmath102 , receiver  @xmath79 decodes along path @xmath103 , and then path @xmath66 to get @xmath104 .",
    "in the even that path @xmath66 has zero arc , receiver  @xmath79 would have obtained @xmath105 earlier .",
    "knowing both @xmath106 and @xmath94 , the receiver obtains @xmath93 from @xmath107 .",
    "it then decodes along path @xmath92 , and then path @xmath67 to get the requested @xmath108 .",
    "if path @xmath67 has zero arc , the receiver can also obtain @xmath109 .    in this coding scheme , we send one symbol for each vertex ( coded symbols for @xmath110 , and uncoded symbols for the rest ) except for @xmath78 and @xmath79 .",
    "we have shown that this index code satisfies the decoding requirements of all receivers , meaning that @xmath51 is achievable .",
    "we first give an intuition for lemma  [ lemma : special - subgraph ] , by showing that there must exists three interlinked cycles in @xmath14 , in subsection  [ sec : intuition ] . in subsections  [",
    "sec : figure ] to [ sec : figure - end ] , we prove that these three interlinked cycles must assume the configuration in figure  [ fig : three - cycles ] .",
    "let @xmath112 , i.e. , vertices  @xmath113 and @xmath114 are removed from @xmath14 to get an mais .",
    "we first show the following :    [ proposition:3-cycles ] there exist three cycles in @xmath14 , each containing either @xmath113 , @xmath114 , or both @xmath113 and @xmath114 .",
    "every cycle must contain @xmath113 , @xmath114 , or both .",
    "otherwise , removing @xmath113 and @xmath114 will not give an acyclic induced subgraph .",
    "suppose that there is only one cycle in @xmath14 .",
    "removing any vertex from the cycle gives an acyclic induced subgraph .",
    "hence , @xmath115 .",
    "( contradiction )    suppose that there are only two cycles in @xmath14 .",
    "note that these two cycles can not be vertex - disjoint , as per condition  ( ii ) above .",
    "so , these two cycles must shared at least one vertex , and removing only this shared vertex gives an acyclic induced subgraph , i.e. , @xmath115 . (",
    "contradiction )    so , there must exist at least three cycles .",
    "we further show some properties of these three cycles :    [ proposition : no - common ] there exist three cycles in @xmath14 , where    1 .",
    "any two cycles must have at least one common vertex , and 2 .",
    "the three cycles do not have any common vertex .",
    "it follows from proposition  [ proposition:3-cycles ] that there are at least three cycles . as no two cycles are vertex - disjoint , we have property  1",
    ". arbitrarily select one cycle , say @xmath116 .",
    "consider every other cycle @xmath117 , and denote the set of common vertices between @xmath118 and @xmath116 as @xmath119 .",
    "since every @xmath118 shares some vertex with @xmath116 , we have @xmath120 .",
    "now suppose that @xmath121 , meaning that some vertex is shared among all cycles . then removing only this vertex from @xmath14",
    "would have resulted in an acyclic subgraph ( contradiction ) .",
    "so , there must exist two cycles , say @xmath122 and @xmath123 , where @xmath124 .",
    "selecting @xmath116 , @xmath122 , and @xmath123 gives property  2 .",
    "denote the subgraph formed by the three cycles in proposition  [ proposition : no - common ] by @xmath63 .",
    "we have the following :    [ proposition : subgraph ] the subgraph @xmath63 , formed by the three cycles in proposition  [ proposition : no - common ] , satisfies both the following : ( 1 ) we can not find two vertex - disjoint cycle in @xmath63 , and ( 2 ) we need to remove two  not fewer  vertices to make @xmath63 acyclic .    since @xmath14 can not contain two vertex - disjoint cycles , so does any of its subgraphs .",
    "we have property  1 .",
    "denote by @xmath43 the minimum number of vertices we need to remove to make @xmath63 acyclic . from proposition  [ proposition : no - common ] , there is no common vertex among the three cycles .",
    "so , removing any one vertex will not disconnect all three cycles simultaneously , i.e. , @xmath125 . on the other hand",
    ", we only need to remove two vertices , @xmath126 , to make @xmath14 acyclic .",
    "so , removing @xmath127 from @xmath63 will definitely make it acyclic , i.e. , @xmath128 .",
    "so , we have property  2 .",
    "note that these three cycles , @xmath63 , capture all the constraints we impose on @xmath14 in lemma  [ lemma : special - subgraph ] .",
    "we will proceed to show that @xmath63 must assume the configuration in figure  [ fig : three - cycles ] .",
    "we will build the configuration from a cycle , say @xmath122 , in @xmath63 .",
    "we call it the _ center cycle_. we re - label the vertices in @xmath63 such that the vertices in @xmath122 are in ascending order in the direction of the arcs , i.e. , @xmath129 , where the choice of vertex  1 is arbitrary .    for any path",
    "@xmath130 that originates from vertex @xmath131 and terminates at vertex @xmath132 , i.e. , @xmath133 , we refer to all @xmath134 as _ inner vertices_. here , we allow @xmath135 ; in such a case , @xmath130 is a cycle .",
    "we first show the following :    [ proposition : outside - cycle ] consider the subgraph @xmath63 and the cycle @xmath122 in the subgraph .",
    "every arc not in @xmath122 belongs to some _ outer path _ , defined as a path that originates from a vertex in @xmath122 and terminates at a vertex ( which can be the same vertex ) in @xmath122 , but with all arcs and all inner vertices ( if exists ) not in @xmath122 .",
    "since @xmath63 is constructed by three cycles , any arc , say @xmath21 , not in @xmath122 must belong to either @xmath123 or @xmath136 ( or both ) .",
    "furthermore , from proposition  [ proposition : no - common ] , @xmath123 and @xmath136 must each share some vertex with @xmath122 .",
    "hence , @xmath21 must belong to an outer path that originates from @xmath122 and terminates at @xmath122 .",
    "note that the outer paths can not form any cycle outside @xmath122 . otherwise , we have two vertex - disjoint cycles .",
    "it follows from proposition  [ proposition : outside - cycle ] that @xmath63 consists of only a cycle @xmath122 and outer paths ( from @xmath122 and back to @xmath122 ) .",
    "figure  [ fig : redraw](a ) shows an example of @xmath63 where @xmath122 is marked with thick arrows and all outer paths thin arrows .",
    "we now prove a key proposition for proving lemma  [ lemma : special - subgraph ] .",
    "[ proposition : outer - path ] remove vertex  1 in @xmath122 .",
    "there exists another cycle in @xmath63 if and only if there is an outer path from some @xmath137 to some @xmath138 , where @xmath139 .",
    "[ the _ only if _ part : ] we remove vertex  1 .",
    "if there is another cycle , then there is a vertex ( not vertex  1 ) in @xmath122 that has a path back to itself ( this is because any cycle must share some vertex with @xmath122 ) .",
    "this can not happen if every outer path terminates at a higher - indexed vertex ( we can ignore all outer paths that originate or terminate at vertex  1 as the vertex has been removed ) .",
    "so , there must exist an outer path with @xmath139 .",
    "[ the _ if _ part : ] clearly , if @xmath135 , we have another cycle formed by the outer path",
    ". otherwise , i.e. , @xmath140 , the outer path and the path along @xmath122 from @xmath132 to @xmath131 form a cycle . see figure  [ fig : looping](a ) for an example .",
    "next , we define a _ looping _ outer path as an outer path that originates and terminates at the same vertex in @xmath122 .",
    "the graph @xmath63 can be categorized as follows :    * there exists one or more looping outer path ( case 1 ) , or * there is no looping outer path ( which we will further divide into cases 2 and 3 ) .",
    "we will show that in any case , we have figure  [ fig : three - cycles ] .     is drawn with thick lines , and the second outer path ( denoted as @xmath130 ) from @xmath131 to @xmath132 , blue lines . to get another cycle after removing vertex  1",
    ", we must have that @xmath141 , as shown in subfigure  ( a ) . however , there are two vertex - disjoint cycles in subfigure  ( a ) .",
    "so , @xmath130 must touch the looping outer path , as shown in subfigure ( b ) . taking the segment of @xmath130 from @xmath122 to the looping outer path , and that from the looping outer path back to @xmath122 , we have subfigure ( c ) .",
    "we can re - draw the path from @xmath142 to @xmath132 and that from @xmath143 to @xmath142 in subfigure ( c ) to get subfigure ( d ) , where we have drawn the new center cycle with thick lines.,width=313 ]      suppose that there exists a looping outer path from and to vertex  @xmath144 .",
    "this incurs no loss of generality as the choice of vertex  1 is arbitrary . removing vertex  1 disconnects cycle @xmath122 and the cycle formed by the looping outer path .",
    "recall that we need to remove two vertices to disconnect all cycles in @xmath63 .",
    "so , there must exist another cycle in @xmath63 .    from proposition  [ proposition : outer - path ] , there exists another outer path @xmath130 from @xmath137 to @xmath138 , where @xmath139 .",
    "the outer path @xmath130 must share some vertex with the looping outer path ; otherwise there exist two cycles as shown in figure  [ fig : looping](a ) .",
    "re - label the inner vertices of the looping outer path in ascending order , as follows : @xmath145 , where @xmath58 is the number of inner vertices .",
    "it follows that the sequence of vertices shared by @xmath130 and the looping outer path ( in the order of the direction of @xmath130 ) must be in ascending order ( see figure  [ fig : looping](b ) ) ; otherwise , a cycle forms outside @xmath122",
    ".    see figure  [ fig : looping](c ) .",
    "consider only the following segments of @xmath130 : ( i ) from @xmath131 to the vertex where @xmath130 first touches the looping outer path , denoted by @xmath146 ; and ( ii ) the vertex where @xmath130 leaves the looping outer path , denoted by @xmath143 , to @xmath132 .",
    "it follows that @xmath147 . by construction ,",
    "all paths in figure  [ fig : looping](c ) do not share inner vertices , i.e. , they touch only at end points .",
    "finally , re - draw figure  [ fig : looping](c ) to get figure  [ fig : looping](d ) , which is isomorphic to figure  [ fig : three - cycles ] .",
    "note that vertices  1 , @xmath131 , and @xmath146 must be unique .",
    "we have shown that if there is a looping outer path , then we have the configuration in figure  [ fig : three - cycles ] , where path @xmath66 has zero arc , paths @xmath67 and @xmath68 possibly have zero arc ( if @xmath148 and/or @xmath149 ) , and all other paths must contain at least one arc .",
    "as in subfigure  ( a ) , i.e. , a center cycle @xmath122 and outer paths from @xmath122 and back to @xmath122 .",
    "subfigure  ( b ) shows the coverage of an outer path , i.e. , vertices in @xmath122 in the gray area _ excluding _ the two end points .",
    "subfigure  ( c ) shows that when multiple outer paths originate from one vertex , we consider only the outer path with the largest coverage , i.e. , the dotted path from @xmath131 to @xmath132 .",
    "the outer paths in subfigure  ( d ) provide full coverage . ]      for a non - looping outer path from vertex @xmath150 to @xmath151 , we say that the vertices from @xmath131 to @xmath132 ( in the direction of the arcs in @xmath122 ) but excluding @xmath131 and @xmath132 is _ covered _ by this outer path .",
    "see figure  [ fig : redraw](b ) for an example . for the purpose of this paper ,",
    "we exclude outer paths with strictly smaller coverage , or multiple outer paths with equal coverage .",
    "referring to figure  [ fig : redraw](c ) , consider an outer path that originates from @xmath131 .",
    "suppose that it has multiple paths back to @xmath122 .",
    "we consider only the path ( back to @xmath122 ) that has the _",
    "largest coverage_. similarly , for any path that terminates at @xmath132 , we consider only the path ( leaving @xmath122 ) that has the largest coverage . by doing this",
    ", each path that we consider has a unique originating vertex and a unique terminating vertex .",
    "we now show the following property :    [ proposition : full - coverage ] if there is no looping outer paths in @xmath63 , then all largest - covering outer paths must , together , provide full coverage for the cycle @xmath122 . in other words , every vertex in @xmath122 must be covered by some outer path(s ) .",
    "consider any vertex @xmath152 .",
    "re - label @xmath80 as vertex  1 , and other vertices @xmath153 in ascending order in the arc direction .",
    "remove vertex  1 from @xmath63 .",
    "there must exist another cycle .",
    "it follows from proposition  [ proposition : outer - path ] that an outer path @xmath130 from @xmath131 to @xmath132 must exist , where @xmath154 ( @xmath155 since there is no looping path ) , meaning that this outer path must cover vertex  1 .",
    "we can safely ignore other outer paths that provide smaller or equal coverage , because if @xmath130 does not cover vertex  1 , then none of the ignored outer paths does . since the choice of @xmath80 is arbitrary ,",
    "we have proposition  [ proposition : full - coverage ] .",
    "for example , the outer paths in figure  [ fig : redraw](d ) provides full coverage for @xmath122 , but the outer paths in figures  [ fig : redraw](b)(c ) do not . removing one",
    "uncovered vertex from @xmath122 makes @xmath63 acyclic .",
    "now , we consider @xmath63 that consists of the cycle @xmath122 and all outer paths that provide the largest coverage ( i.e. , we remove all other arcs have gives smaller or equal coverage ) .",
    "we are ready to proceed with cases 2 and 3 :    * there is no looping outer path , and no two outer paths have any common inner vertex ( case 2 ) .",
    "* there is no looping outer path , and there exist two outer paths sharing the same inner vertex ( case 3 ) .",
    "we will show that we can always choose three outer paths to provide full coverage .",
    "first , note that one outer path can not provide full coverage . now , suppose that we can find two outer paths providing full coverage .",
    "we show in figure  [ fig:2-coverage](a ) that we can always form two vertex - disjoint cycles .",
    "so , this also can not happen .",
    "with @xmath156 outer paths providing full coverage can be converted to @xmath157 outer paths providing full coverage .",
    "( c ) if the blue and the right black outer paths ( non - adjacent ) give overlapping coverage , then the right red outer path is actually redundant , i.e. , @xmath158 outer path is sufficient to give full coverage , instead of @xmath159.,width=321 ]    next , suppose that we can find three outer paths providing full coverage , we have figure  [ fig : three - cycles ] . as there is no looping outer path , the nine paths in figure  [ fig : three - cycles ] each have one or more arcs .",
    "finally , we show that if we can find @xmath156 outer paths providing full coverage , we can always modify the cycles such that @xmath160 outer paths provide full coverage .",
    "we illustrate this in figure  [ fig:2-coverage](b ) .",
    "we do the following :    1 .   combine the dashed blue arrows to be the new @xmath122 .",
    "2 .   combine the two adjacent ( red ) outer paths , and the red arc in @xmath122 that connects the two red outer paths ( i.e. , @xmath130 , which can be of zero length ) into a new outer path .",
    "3 .   remove the two green paths in @xmath122 .",
    "each green path must contain at least one arc ; otherwise , the outer paths can not provide full coverage .    note that by doing this , the new graph still retains the structure of a cycle with outer paths covering it .",
    "the new graph has @xmath157 outer paths providing full coverage .",
    "this reduction is always possible as the coverage of two non - adjacent outer paths does not overlap , illustrated in figure  [ fig:2-coverage](c ) .    by repeating this step , starting from any @xmath156 outer paths",
    ", we can find a graph with @xmath161 or @xmath162 outer paths .",
    "as @xmath161 is not possible , we will always get a graph with @xmath162 outer paths providing full coverage , i.e. , figure  [ fig : three - cycles ] .      let the two outer paths that share some common inner vertex be @xmath130 and @xmath163 , and one of the shared inner vertices be @xmath164 .",
    "further , let the originating and terminating vertices of @xmath130 be @xmath165 and @xmath166 respectively , and those of @xmath163 be @xmath167 and @xmath168 . here , @xmath169 and @xmath170 as there is no looping outer path , and @xmath171 and @xmath172 as no two outer paths have the same originating or terminating vertices .",
    "( @xmath173 ) , and the green line the outer path @xmath163 ( @xmath174),width=302 ]    now , the coverage of @xmath130 and @xmath163 can be either ( a ) non - overlapping , ( b ) overlapping once , or ( c ) overlapping twice , as shown in figure  [ fig : overlapping - coverage ] . the red line shows the coverage of @xmath130 , and the green line @xmath163 . by definition",
    ", there is a subpath from @xmath165 to @xmath164 along @xmath130 and another subpath from @xmath164 to @xmath166 along @xmath130 .",
    "the two subpaths must be vertex - disjoint , except @xmath164 , as there is no cycle in @xmath130 .",
    "similarly , we have two vertex - disjoint paths from @xmath167 to @xmath164 , and from @xmath164 to @xmath168 , both along @xmath163 .",
    "this means , there is an subpath from @xmath165 to @xmath168 through @xmath164 , and another from @xmath167 to @xmath166 through @xmath164 .",
    "so , @xmath175 , @xmath176 , as there is no looping outer path , and hence @xmath165 , @xmath166 , @xmath167 , and @xmath168 are distinct .",
    "suppose that we have figure  [ fig : overlapping - coverage](a ) .",
    "the largest - covering outer path from @xmath165 should terminate at @xmath168 , and that from @xmath167 at @xmath166 .",
    "the outer path from @xmath165 to @xmath168 and that from @xmath167 to @xmath166 should have been chosen .",
    "this means the largest - covering paths actually overlap twice , i.e. , we should have figure  [ fig : overlapping - coverage](c ) .",
    "suppose that we have figure  [ fig : overlapping - coverage](b ) .",
    "the outer path from @xmath165 to @xmath168 , through @xmath164 , gives the largest coverage , and it would have been chosen .",
    "so , we can only have the configuration in figure  [ fig : overlapping - coverage](c ) , where the coverage overlaps twice . the coverage from @xmath165 to @xmath168",
    "is smaller than that from @xmath165 to @xmath166 .",
    "so , the largest - covering outer path from @xmath165 was correctly identified .",
    "similarly , the largest - covering outer path from @xmath167 terminates at @xmath168 .",
    "we will now show that we can always get figure  [ fig : three - cycles ] from figure  [ fig : overlapping - coverage](c ) . recall that there is a subpath from @xmath165 to @xmath164 and another subpath from @xmath164 to @xmath168 , and these two subpaths are vertex - disjoint , except @xmath164 .",
    "we denote the outer path from @xmath165 to @xmath168 ( through @xmath164 ) by @xmath177 ( drawn with a thick dashed line ) .    next ,",
    "recall that there is a subpath from @xmath167 to @xmath164 , and another from @xmath164 to @xmath166 .",
    "so , the subpath from @xmath167 to @xmath164 must meet @xmath177 .",
    "denote the vertex it first meets @xmath177 as @xmath178 .",
    "similarly , the subpath from @xmath164 to @xmath166 must share some common vertices with @xmath177 ( at least vertex  @xmath164 ) .",
    "let the last shared vertex be @xmath179 . with this construction , @xmath177 ,",
    "the subpath from @xmath167 to @xmath178 , and the subpath from @xmath179 to @xmath166 are vertex - disjoint , except at @xmath179 and @xmath178 .",
    "we now re - draw figure  [ fig : overlapping - coverage](c ) as follows : let the path from @xmath168 to @xmath165 along @xmath122 ( drawn with a thick solid line ) plus path @xmath177 ( drawn with a thick dashed line ) be the center cycle , and let the subpaths ( drawn with dotted arrows ) ( i ) from @xmath165 to @xmath168 along @xmath122 , ( ii ) from @xmath179 to @xmath166 , and ( iii ) from @xmath167 to @xmath178 be the three outer paths .",
    "note that only @xmath179 and @xmath178 can co - locate .",
    "this is isomorphic to figure  [ fig : three - cycles ] , with path @xmath66 possibly having zero arc ( if @xmath180 ) .    combining the cases 13 ,",
    "we have lemma  [ lemma : special - subgraph ] . @xmath181",
    "we have solved a new class of index - coding problems , characterized by their side - information graphs .",
    "we have shown that for any side - information graph whose maximum acyclic induced subgraph ( mais ) can be formed by removing two or fewer vertices , the optimal index codelength ( i ) equals the order of the mais , and ( ii ) is achievable by linear index codes .",
    "we proved this by constructing a special subgraph that the side - information graph must contain , and design a linear index code on it .",
    "we then show that the liner index code achieves the mais lower bound .",
    "y.  birk and t.  kol , `` coding on demand by an informed source ( iscod ) for efficient broadcast of different supplemental data to caching clients , '' _ ieee trans .",
    "inf . theory _ ,",
    "52 , no .  6 , pp . 28252830 , june 2006 . + ( the conference version of this paper appeared in _ infocom _ 1998 )    s.  el  rouayheb , a.  sprintson , and c.  georghiades , `` on the index coding problem and its relation to network coding and matroid theory , '' _ ieee trans .",
    "inf . theory _ ,",
    "56 , no .  7 , pp .",
    "31873195 , july 2010 .",
    "m.  f. wong , m.  langberg , and m.  effros , `` on a capacity equivalence between network and index coding and the edge removal problem , '' in _ proc .",
    "inf . theory ( isit ) _ ,",
    "istanbul , turkey , july 712 2013 , pp . 972976 .",
    "r.  m. karp , `` reducibility among combinatorial problems , '' in _ complexity of computer computations _",
    ", r.  e. miller and j.  w. thatcher , eds.1em plus 0.5em minus 0.4emplenum press , new york - london , 1972 , pp . 85104 ."
  ],
  "abstract_text": [
    "<S> we study index - coding problems ( one sender broadcasting messages to multiple receivers ) where each message is requested by one receiver , and each receiver may know some messages a priori . </S>",
    "<S> this type of index - coding problems can be fully described by directed graphs . </S>",
    "<S> the aim is to find the minimum codelength that the sender needs to transmit in order to simultaneously satisfy all receivers requests . </S>",
    "<S> for any directed graph , we show that if a maximum acyclic induced subgraph ( mais ) is obtained by removing two or fewer vertices from the graph , then the minimum codelength ( i.e. , the solution to the index - coding problem ) equals the number of vertices in the mais , and linear codes are optimal for this index - coding problem . </S>",
    "<S> our result increases the set of index - coding problems for which linear index codes are proven to be optimal . </S>"
  ]
}