{
  "article_text": [
    "the study of elections is a complex field .",
    "when deciding between two candidates , one may consider several procedures , but the familiar majority vote can actually be shown to have nice mathematical properties , as described in detail by may in @xcite . unfortunately , these properties are difficult to extend to a multi - agent election , and far less is understood in that setting .",
    "one approach is to run independent 2-candidate majority elections between pairs of candidates , and select a winner based upon those results .",
    "combinatorially , running all such elections would produce a tournament ( an oriented complete graph , in which every pair of vertices spans exactly one directed edge ) summarizing all pairwise preferences .    yet even though such a tournament contains much information about the candidates , selecting a winner given such a tournament , known in the social sciences as a _ tournament solution _ , is a difficult question .",
    "indeed , mcgarvey @xcite showed that even with a number of voters only polynomial in @xmath0 ( the number of agents ) , every possible tournament is already achievable in this way .",
    "so , there may be many lists of preferences among multiple agents that fit the same description .",
    "one natural method is to select a candidate that beats as many other candidates as possible in the pairwise majority elections .",
    "this is known as the _ copeland solution _ , and is equivalent to identifying a vertex of maximum out - degree in the preference tournament .",
    "such a vertex may not be unique , so it is desirable to develop a procedure which selects a vertex with similar properties , while being completely deterministic .",
    "one natural solution is to construct a _ voting tree _ , and this paper analyzes the combinatorial aspects of such structures , inspired by recent work of fischer , procaccia , and samorodnitsky @xcite .",
    "we first coordinate our terminology with that typically used in the social science literature .",
    "let @xmath6 denote the set of all tournaments on the vertex set @xmath7 $ ]",
    ". an _ agenda _ is a mapping from @xmath6 to @xmath7 $ ] .",
    "a _ match _",
    "@xmath8 is a particular agenda of the form @xmath9    we will refer to @xmath8 as the _ match between @xmath10 and @xmath11_. using this as the basic building block , we may now interpret certain labeled binary trees as agendas . indeed , let @xmath12 be a ( not necessarily complete ) binary tree , in which each node has either 0 or 2 children , where each leaf is labeled with an integer in @xmath7 $ ] .",
    "we permit multiple leaves to receive the same label .",
    "the corresponding agenda @xmath13 is computed as follows .",
    "given a tournament @xmath14 on @xmath7 $ ] , we recursively label each node of the tree @xmath12 by the result of the match between its children s labels .",
    "the ultimate label at the root is the output of this agenda , and such agendas are called voting trees . for instance , @xmath8 may be represented by a three node binary tree , as shown below .     voting tree . ]",
    "voting trees were first introduced by farquharson in @xcite and further investigated by various researchers in @xcite , @xcite , @xcite , @xcite , and @xcite .",
    "fischer , procaccia , and samorodnitsky focused on the problem of quantitatively approximating the copeland solution with voting trees . a voting system which is implementable by a voting tree , implies that the system is also implementable via backwards induction , as shown in @xcite . both @xcite and @xcite",
    "provide social choice functions which are implementable via backwards induction .",
    "let the _ performance guarantee _ of a given voting tree @xmath15 be the minimum out - degree which it ever produces on any input , i.e. , @xmath16    when the number of agents @xmath0 is a power of two , it is relatively easy to construct a voting tree with performance guarantee @xmath3 : take a complete binary tree with @xmath0 leaves , and label the leaves with an arbitrary permutation of @xmath7 $ ] .",
    "then , given any tournament as input , the ultimate winner must win exactly @xmath3 matches on the way to the root , and since all leaves are distinctly labeled , the winner must have met a different opponent at each of those matches . therefore , the winner must always have out - degree at least @xmath3 . on the other hand , for this voting tree , an adversary can easily construct a suitable tournament to provide as input such that the winner only has out - degree exactly @xmath17 .",
    "in contrast , it is well - known that every @xmath0-vertex tournament has a vertex of out - degree at least @xmath18 , so this performance guarantee appears to be quite weak .",
    "perhaps surprisingly , prior to our work , this was the best known voting tree according to this metric , despite non - trivial effort : in @xcite , the problem of improving this lower bound was even suspected to currently be `` out of reach . ''",
    "fischer , procaccia , and samorodnitsky also proved the strongest negative result , showing that no tree can guarantee a winner with out - degree at least @xmath19 of the maximum out - degree in the input tournament ; in particular , quantifiably strengthening an earlier result of moulin @xcite which showed that no voting tree can always identify the copeland solution .",
    "srivastava and trick @xcite showed that moulin s result is also a minimal example .",
    "however , these lower and upper bounds are extremely far apart , and even the case @xmath20 is still not settled .",
    "this article proves a number of positive results which demonstrate the rather rich computational power of voting trees .",
    "we first exhibit a construction which substantially improves the logarithmic lower bound of the trivial construction above .",
    "there exist voting trees @xmath21 with performance guarantee at least @xmath22 .",
    "[ thm : lower ]    we then show two constructions which we discovered while investigating this problem .",
    "we feel that they may be of independent interest , to different communities .",
    "the first is relevant to social choice theory , and achieves a rather counterintuitive result . as motivation ,",
    "observe that any upper bound for our problem consists of a procedure that takes a voting tree as input , and produces a suitable tournament as output , such that when tree is applied to the tournament , the resulting winner has low out - degree .",
    "the most natural candidate tournaments have the following form .",
    "a * perfect manipulator tournament * is an @xmath0-vertex tournament with vertex set @xmath23 , where @xmath24 and @xmath25 are nonempty , the single element @xmath26 ( the `` manipulator '' ) defeats every member of @xmath24 , every member of @xmath24 defeats every member of @xmath25 , and every member of @xmath25 defeats @xmath26 .",
    "one might suspect that given any voting tree , if one wants to design a tournament for which a particular vertex @xmath27 $ ] is the winner , this should be accomplished by having all vertices that @xmath26 defeats able to beat all vertices that win against @xmath26 , i.e. , by constructing a suitable perfect manipulator tournament .",
    "the task of improving the upper bound would then be reduced to specifying and controlling the size of the set @xmath24 of vertices defeated by the manipulator @xmath26 . surprisingly , this intuition is completely incorrect .",
    "[ thm : manipulator ] for every integer @xmath28 which is a power of two , there is a voting tree @xmath29 such that for every @xmath27 $ ] and every perfect manipulator tournament @xmath14 with @xmath26 as the manipulator , @xmath26 does not win when @xmath29 is applied to @xmath14 .",
    "note that the result holds regardless of how large @xmath24 is , and in particular , even if @xmath25 , the set of agents who defeat @xmath26 , has size as small as 1 .",
    "the result obviously can not hold for all @xmath0 , because , for example , for @xmath30 , one can construct a suitable perfect manipulator tournament for any tree @xmath15 by letting @xmath14 be the unlabeled directed 3-cycle , and feeding it into @xmath15 ; whichever vertex wins is labeled as the manipulator @xmath26 , and @xmath24 and @xmath25 are assigned cyclically .",
    "ad - hoc constructions exist for several other values of @xmath0 , but these are not easily generalizable .",
    "our final construction demonstrates that voting trees can be harnessed for computation .",
    "the first voting tree we discovered that beat the logarithmic lower bound was built using `` arithmetic gates '' which operated on the most fundamental case @xmath31 .",
    "this is a voting tree analogue of the classical arithmetic circuits built from and and or logical gates .",
    "there exist voting trees @xmath32 and @xmath33 , with leaves labeled by @xmath34 , with the following properties .",
    "let @xmath14 be an arbitrary non - transitive tournament on the vertex set @xmath35 , i.e. , one of the two cyclic orderings of the vertex set .",
    "let @xmath36 and @xmath37 be arbitrary elements of @xmath38 . then",
    ", if in @xmath32 and @xmath33 , all occurrences of @xmath39 and @xmath40 are replaced by @xmath36 and @xmath37 , and both trees are evaluated on @xmath14 , their corresponding outputs are precisely the elements in @xmath38 corresponding to @xmath41 and @xmath42 , respectively .",
    "[ thm : arithmetic ]    these trees @xmath32 and @xmath33 can be interpreted as addition and multiplication gates in the context of voting trees , where the @xmath39 and @xmath40 represent the two inputs to each gate .",
    "these gates can then be chained together as robust building blocks which independently perform consistently across input tournaments .",
    "the requirement of non - transitivity is essential , because if a transitive tournament is input , no non - trivial voting tree can avoid having the dominant vertex win .",
    "we now move to describe the constructions .",
    "we start by creating voting trees @xmath21 with performance guarantees of @xmath43 , where @xmath0 is the number of agents .",
    "the following tree serves as our fundamental building block .",
    "let @xmath10 be a label between 1 and @xmath0 inclusive , and let @xmath44    \\setminus \\{i\\}$ ] be a set of other labels .",
    "construct the complete binary tree with exactly @xmath45 pairs of leaves , and for each label @xmath46 , place the labels @xmath10 and @xmath47 on a distinct pair of leaves , as illustrated in figure [ fig : against - s ] .",
    "we call the resulting voting tree @xmath48 .",
    "[ def : against - s ]     voting tree for @xmath49 . ]",
    "the consequences of placing candidate @xmath10 in competition with every candidate in @xmath12 turn out to be quite convenient .",
    "when @xmath48 is evaluated on a tournament @xmath14 , the result is either @xmath10 , if @xmath10 defeats every element of @xmath12 according to @xmath14 , or the result is some vertex @xmath46 with the property that @xmath47 defeats @xmath10 in @xmath14 .",
    "[ lem : against - s ]    the leaves of this tree consist of independent pairwise matches between @xmath10 and every candidate in @xmath12 .",
    "we start by evaluating the pairwise matches at the leaves , writing the winners of those @xmath45 matches on their parents , and deleting the original leaves",
    ". each of those winners will either be @xmath10 ( if @xmath10 won the match ) , or a candidate of @xmath12 who defeats @xmath10 .",
    "in particular , at this point , if @xmath10 defeats every candidate in @xmath12 , then @xmath10 is the only label that remains , and the winner is clearly @xmath10 , as claimed .",
    "otherwise , all leaves of the tree are now labeled with only two types of candidates : @xmath10 itself , and a nonempty sub - collection @xmath50 of candidates from @xmath12 who defeat @xmath10 .",
    "we now continue to evaluate the tree .",
    "whenever two elements of @xmath51 are matched against each other , one wins , and one element of @xmath51 moves on as the winner .",
    "however , whenever an element of @xmath51 is matched against @xmath10 , the element of @xmath51 wins , and moves on as the winner .",
    "thus , as the evaluation continues , there is always at least one element of @xmath51 .",
    "this holds all the way up to the root layer , and so we conclude that the winner of @xmath48 is an element of @xmath51 , i.e. , a candidate who defeats @xmath10 , as claimed .",
    "we now construct our voting trees @xmath21 recursively .",
    "the following lemma steadily improves the performance guarantee as the number of candidates increases .",
    "let @xmath21 be a voting tree for @xmath0 agents with performance guarantee @xmath52 .",
    "then there is a voting tree @xmath53 for @xmath54 agents with performance guarantee at least @xmath55 .",
    "[ lem : lower - induct ]    to simplify notation , let the @xmath54 candidates be indexed @xmath56 .",
    "let @xmath57 , and consider the tree @xmath58}$ ] from lemma [ lem : against - s ] , where @xmath59 = \\{1 , 2 ,    \\ldots , n\\}$ ] .",
    "for each @xmath60 $ ] , arbitrarily select a distinct subset @xmath61 $ ] of size @xmath0 , and remove the leaf labeled @xmath10 from our original @xmath58}$ ] . in its place , insert the tree @xmath62 , defined as the voting tree @xmath21 for @xmath0 candidates with performance guarantee @xmath52 , but labeled with the @xmath0 elements of @xmath12 instead of the @xmath0 elements @xmath63 .",
    "we claim that the resulting tree guarantees that the winner has out - degree at least @xmath55 . indeed , suppose that it has been fed a tournament on @xmath64 as input .",
    "first , evaluate all @xmath65 of the @xmath62 subtrees , and write their winning candidates at their roots .",
    "the key observation is that at least @xmath55 distinct candidates emerge from these subtrees .",
    "indeed , let @xmath66 be the collection of all such intermediate winners .",
    "if @xmath67 , then there would be some @xmath0-set @xmath68 $ ] which was disjoint from @xmath66 .",
    "the winner of @xmath69 would then be outside @xmath66 , contradiction .    at this point",
    ", we have the structure of @xmath58}$ ] , except that the set @xmath66 appears as the non-0-labeled leaves . by lemma [ lem : against - s ] , either candidate 0 wins , in which case it defeats every candidate in @xmath66 ( producing out - degree at least @xmath55 ) , or some candidate @xmath70 wins , defeating candidate 0 as well . since the out - degree guarantee for @xmath71 was already @xmath52 from its @xmath62 , in which candidate 0 did not appear , we conclude that @xmath71 has out - degree at least @xmath55 , completing the other scenario .",
    "our main asymptotic lower bound now follows by induction .",
    "_ proof of theorem [ thm : lower ] .",
    "_ for @xmath72 , we take a single match between candidates 1 and 2 , and it is clear that this guarantees that the winner has out - degree at least 1 . repeated application of the previous lemma then produces voting trees for @xmath73 candidates which guarantee out - degree at least @xmath52 .",
    "we now proceed to our second result . for this construction ,",
    "let us fix @xmath75 as a power of two .",
    "we begin by introducing compact notation that we will use to describe various voting trees in this section , all of which will be complete binary trees with full bottom layers .",
    "we represent such a tree by listing its leaves from left to right as an @xmath76-tuple @xmath77 of integers in @xmath7 $ ] , where @xmath76 is a power of two .",
    "for example , the @xmath0-tuple @xmath78 corresponds to the voting tree mentioned in the introduction , which achieved the previous best performance guarantee of @xmath3 .    using the above notation",
    ", we now describe our first gadget , which we will use as a building block in our construction",
    ". we will show that it has the property that when it is applied to any perfect manipulator tournament @xmath23 , then the winner is never in @xmath25 .",
    "it is perhaps intuitive that such a voting tree might exist , because candidates in @xmath25 only have a single candidate @xmath26 who they are capable of defeating , and therefore have a disadvantage .",
    "define the permutation @xmath79 of @xmath7 $ ] as : @xmath80 let @xmath81 be the voting tree corresponding to the @xmath82-tuple @xmath83 .",
    "[ def : shuffle - tree ]     for @xmath84 . ]    this tree is illustrated in figure [ fig : shuffle - tree ] .",
    "the action of the permutation is so that the right half of the tree is a perfect shuffle of the left half of the tree .",
    "the utility of this structure will become clear in the proof of the following lemma .    whenever @xmath81 is applied to any perfect manipulator tournament ,",
    "the winner is not in @xmath25 .",
    "[ lem : phi ]    suppose for contradiction that @xmath81 has been applied to such a tournament , and that the winner is in @xmath25 .",
    "the final match of @xmath81 was between the winners of its left and right subtrees , which we will refer to as @xmath85 and @xmath86 .",
    "note that by the assumption that a member of @xmath25 won , the final match must have been between @xmath26 and an element of @xmath25 , or between two elements of @xmath25 , so neither subtree s winner can be in @xmath24 .",
    "assume that the winner of @xmath85 is in @xmath25 .",
    "note that @xmath85 corresponds to the @xmath0-tuple @xmath87 , as defined at the beginning of this section .",
    "so @xmath85 s leaves contain every element of the tournament exactly once , and the label @xmath26 appears in either @xmath85 s left or right subtree as a leaf . without loss of generality ,",
    "suppose that @xmath26 appears in the left subtree of @xmath85 .",
    "any match between an element of @xmath24 and something other than @xmath26 will be won by an element of @xmath24 .",
    "so the right subtree of @xmath85 will be won by an element of @xmath24 if any elements of @xmath24 appear on its leaves , then making it impossible for @xmath85 to be won by an element of @xmath25 .",
    "thus , the right subtree of @xmath85 s must have all of its leaves labeled from @xmath25 .    in @xmath86 ,",
    "each label @xmath88 is initially matched against a label of @xmath89 , due to the action of the shuffle @xmath79 .",
    "these labels appear on the leaves of the left and right subtrees of @xmath85 , respectively .",
    "so in @xmath86 , @xmath26 is matched with an element of @xmath25 , and eliminated in the first round .",
    "since at @xmath24 is nonempty , the elements of @xmath24 will continue to dominate every match of @xmath86 , unchallenged by @xmath26 , and an element of @xmath24 will win @xmath86 .",
    "it then will beat the element of @xmath25 that won @xmath85 , making the winner of @xmath81 an element of @xmath24 , contradicting our assumptions .",
    "the other possibility is that @xmath86 is won by an element of @xmath25 . the same argument we used on @xmath85 shows that either the left or the right subtree of @xmath86 has leaves entirely contained in @xmath25 .",
    "let us suppose that it is the right subtree of @xmath86 , as the other case is similar .",
    "this right subtree contains the nodes @xmath90 .",
    "these are the nodes of the right subtree of the left subtree of @xmath85 and the right subtree of the right subtree of @xmath85 .",
    "so it s clear that those trees must have winners in @xmath25",
    ". therefore @xmath26 can not be the winner of either the left or right subtree of @xmath85 .",
    "however , @xmath26 must be initially matched with an element of @xmath91 in @xmath86 , because otherwise it will be eliminated in the first round , and @xmath24 will win @xmath86 unchallenged , contradicting our assumption that @xmath86 is won by @xmath25 .",
    "since @xmath79 alternately maps indices of the left and right subtrees of @xmath85 into matched pairs , the two subtrees of @xmath85 have the property that one contains @xmath26 , and the other contains @xmath92 and not @xmath26 . as before , the latter subtree will be won by @xmath24 , and the previous paragraph s conclusion implies that the other subtree of @xmath85 is not won by @xmath26 .",
    "therefore , @xmath85 is won by @xmath24 , which then defeats the element of @xmath25 which we assumed as the winner of @xmath86 , contradicting the fact that @xmath81 was won by @xmath25 .",
    "our next gadget enables us to force @xmath26 to lose by transferring the status of the `` perfect manipulator '' to another node of @xmath14 . for each @xmath93",
    "$ ] , define @xmath94 to be the voting tree @xmath48 from definition [ def : against - s ] , with @xmath95 \\setminus \\{i\\}$ ] . to unify notation ,",
    "let @xmath96 in the perfect manipulator tournament .",
    "the same argument as used in lemma [ lem : against - s ] shows that the winners of this tree `` rotate '' the sets @xmath13 , @xmath24 , and @xmath25 .",
    "when @xmath94 is evaluated on a perfect manipulator tournament @xmath14 , the winner is in @xmath25 if @xmath97 , in @xmath13 if @xmath98 , and in @xmath24 if @xmath99 .",
    "[ lem : one - against - all ]    without loss of generality , suppose that @xmath97 .",
    "after all of the initial leaf matches are evaluated , all intermediate winners are either from @xmath13 or @xmath25 , because all candidates from @xmath25 were immediately eliminated by @xmath10 .",
    "importantly , since all three classes @xmath13 , @xmath24 , and @xmath25 are nonempty in perfect manipulator tournaments , at least one element of @xmath25 survives .",
    "now all remaining candidates are from either @xmath13 or @xmath25 , and so just as in the proof of lemma [ lem : against - s ] , @xmath25 is unchallenged , and an element of @xmath25 emerges as the winner .",
    "next , we compose @xmath94 with itself to perform a `` double rotation '' on perfect manipulator tournaments .    for any @xmath100",
    "$ ] , start with the voting tree @xmath94 . at each leaf , note the label ( suppose it was @xmath11 ) , erase the label , and then insert a copy of @xmath101 with its root at that leaf .",
    "call the result @xmath102 .",
    "when @xmath103 is evaluated on a perfect manipulator tournament @xmath14 , the winner @xmath104 is in @xmath24 if @xmath97 , in @xmath25 if @xmath98 , and in @xmath13 if @xmath105 .",
    "[ cor : one - against - all-2 ]    without loss of generality , suppose that @xmath97 .",
    "by lemma [ lem : one - against - all ] , the winner of @xmath94 is in @xmath25 , and elements of both @xmath24 and @xmath13 are represented amongst the winners of the other @xmath101 . therefore , the previous lemma s argument implies that the winner of @xmath102 is from the set which defeats @xmath25 , i.e. , @xmath24 .",
    "we are now ready to describe our main construction for this section .",
    "start with the voting tree @xmath106 and replace each leaf labeled @xmath11 with a copy of the voting tree @xmath81 from definition [ def : shuffle - tree ] and call the resulting tree @xmath29 .",
    "let @xmath14 be the perfect manipulator tournament given as input .",
    "with respect to @xmath14 , when @xmath81 is evaluated we will be given a vertex which is not in @xmath25 .",
    "now when something which is not @xmath25 is feed as input into @xmath103 then we get something which is not in @xmath13 by corollary [ cor : one - against - all-2 ] .",
    "so , the output of the whole tree @xmath29 will not be @xmath26 as desired .",
    "in this section , we construct more complex chains of voting trees for @xmath31 which can perform arithmetic modulo three .",
    "an essential caveat is that such computation is clearly impossible when the input tournament is transitively oriented , and so we design our circuits to succeed no matter which non - transitive tournament is input .",
    "the two such tournaments are shown in figure  [ fig : tournaments ] .",
    "[ fig : tournaments ]    we will now create trees of increasing complexity by developing robust `` gates '' and putting them together . however , this time , because our aim is to send outputs of gates as inputs into other gates , we will design voting trees whose leaves are labeled with both tournament vertices ( 0 , 1 , 2 ) and variables @xmath39 , @xmath40 , etc . our basic building block , which we call a _ yield gate _ , is again along the lines of definition [ def : against - s ] , and is illustrated in figure  [ fig : beatsgate ] .    .",
    "]    the same argument as used in the proof of lemma [ lem : one - against - all ] produces the following conclusion .    for any non - transitive tournament @xmath14 and any vertex @xmath107 ,",
    "if all labels @xmath39 are replaced with @xmath36 in the yield gate , and the tree is evaluated with respect to @xmath14 , then the winner is the unique vertex which beats @xmath36 .",
    "[ cor : yield ]      next , we combine yield gates to create a negative sum gate , which takes @xmath39 and @xmath40 as inputs , and outputs @xmath108 ( modulo 3 ) with respect to any non - transitive tournament . a simple match between two yield gates , shown in figure  [ fig : almostsub ] ,",
    "almost achieves this behavior .",
    "let us analyze the behavior of this tree with respect to the various tournaments and inputs @xmath39 and @xmath40 .",
    "if @xmath109 , then both halves of the tree return the same output , which is @xmath110 for the clockwise tournament , and @xmath111 for the counter - clockwise tournament . now consider the case where @xmath112 , and let @xmath113 be the third vertex ( so @xmath114 ) . in the clockwise tournament , the two halves of the tree would return @xmath110 and @xmath115 .",
    "if @xmath116 then @xmath110 would beat @xmath115 , producing @xmath110 as the winner . here , @xmath117 because @xmath110 is neither @xmath39 nor @xmath40 . on the other hand ,",
    "if @xmath118 then we would have the result be @xmath115 which is again @xmath113 . doing the same calculations for the counter - clockwise tournament , we get that @xmath111 wins if @xmath119 , and @xmath120 wins if @xmath121 . in summary , whenever @xmath122 , regardless of the tournament s orientation , the output is @xmath113 , which equals @xmath108 because @xmath123 and @xmath124 .",
    "so the gate shown in figure  [ fig : almostsub ] gives us the desired outcome of @xmath108 when @xmath112 .",
    "we will now stack several gates of this type together to create our desired gate , as illustrated in figure [ fig : negsum ] .    .",
    "each triangular gate in this arrangement is a copy of the gate shown in figure [ fig : almostsub ] .",
    "the two inputs on the left of each gate correspond to @xmath39 and @xmath40 , and the output on the right is the output of the tree . when the output of a structure is plugged into ( say ) the @xmath39-input of another gate , all copies of @xmath39 in the latter gate are replaced with identical copies of the structure . ]",
    "the gate in figure [ fig : negsum ] computes @xmath108 .",
    "[ lem : negsum ]    first we consider the case @xmath112 , and let @xmath125 .",
    "so , the output of both leftmost trees is @xmath126 .",
    "now @xmath127 and @xmath128 so the next layer of trees output @xmath40 and @xmath39 respectively .",
    "the last gate receives @xmath40 and @xmath39 as input , so outputs @xmath108 as desired .",
    "now we consider the case @xmath109 , starting with the clockwise tournament . by the discussion above",
    ", both leftmost trees output @xmath110 . now",
    "the second layer of trees receive @xmath39 and @xmath110 as input , and therefore both give @xmath111 as output .",
    "the last tree now receives @xmath111 for both inputs , and so gives @xmath129 as output .",
    "this is our desired outcome as @xmath130 ( modulo 3 ) . in the final case , where @xmath109 and the tournament is counter - clockwise , similar calculations yield that the last layer outputs @xmath131 as desired .",
    "observe that if we send the constant 0 as the input for @xmath40 in the @xmath108 gate , we produce a unary negation gate .",
    "if we then feed the output of the negative sum tree through this negation tree , then the output becomes the ordinary sum @xmath132 , which was the objective of this section .",
    "there is a gate which takes inputs @xmath39 and @xmath40 , and outputs their sum @xmath132 ( in @xmath38 ) , when evaluated with respect to any non - transitive tournament on three vertices .",
    "the gates constructed thus far will be used repeatedly in later sections , and figure  [ fig : gates ] shows how they will be compactly represented in the remainder of this paper .",
    "having created our addition gate , we move toward multiplication . to this end , in this section we develop a unary gate which computes the function @xmath133 , regardless of which non - transitive 3-vertex tournament is used .",
    "observe that the squaring function sends 0 to 0 , and sends both 1 and 2 to the same value 1 .",
    "we start by creating a gate ( shown in figure  [ fig : firsthalf ] ) with similar properties .",
    "the gate in figure  [ fig : firsthalf ] sends @xmath134 , @xmath135 , and @xmath136 on the clockwise tournament , and @xmath137 , @xmath138 , and @xmath139 on the counter - clockwise tournament .",
    "[ lem : squaring-1 ]    consider the clockwise tournament . on the top left of the gate ,",
    "if @xmath140 then 0 beats 1 and then 2 beats 0 . otherwise , the top left is simply the winner between 1 and 2 , which in this case is 1 .",
    "feeding this through the yield gate twice we get the top produces 0 when 0 is input , and 2 when either 1 or 2 are input . on the bottom left of the tree , if @xmath140 then 2 beats 0 and then 1 beats 2",
    ". otherwise , the bottom left is again the winner between 1 and 2 which is again 1 .",
    "so , for the clockwise tournament , the bottom always feeds 1 through a yield gate and produces 0 , regardless of the input @xmath39 . matching the outputs of the top and the bottom , and evaluating with respect to the clockwise tournament",
    ", we find that the gate in figure  [ fig : gates ] outputs 0 if @xmath140 and outputs 2 otherwise , as claimed .",
    "it remains to consider the counter - clockwise tournament . on the bottom left of the tree ,",
    "if @xmath140 then 0 beats 2 and then 1 beats 0 . otherwise , the bottom left is simply the winner between 1 and 2 , which is 2 . feeding this through the yield gate ,",
    "we find that the bottom is 2 when 0 is input , and 0 when either 1 or 2 are input . on the top left of the tree , if @xmath140 then 1 beats 0 and then 2 beats 1 . otherwise , the top left is again the winner between 1 and 2 which is again 2 .",
    "so , for the counter - clockwise tournament , the top always feeds 2 through a yield gate twice and produces 1 , regardless of the input @xmath39 . combining the top and the bottom",
    "we conclude that the gate outputs 2 if @xmath140 and outputs 1 otherwise .    at this point",
    "we are relatively close to getting the desired outcome , as for each non - transitive tournament , the inputs 1 and 2 produce one result , and the input 0 produces a different one .",
    "we complete our squaring gate by sending this output into the gate shown in figure [ fig : secondhalf ] .",
    "is used to represent the input to this half , so there is no confusion with the input @xmath39 to the first half ( from figure [ fig : firsthalf ] ) . ]    the composition of the gates in figures [ fig : firsthalf ] and [ fig : secondhalf ] computes the function @xmath141 .",
    "[ lem : square - gate ]    let @xmath40 be the output of the gate in figure [ fig : firsthalf ] when @xmath39 is input . in the case of the clockwise tournament , @xmath142 if @xmath140 and @xmath143 otherwise . feeding this through the two yield gates ,",
    "we get 1 when @xmath140 and 0 otherwise . in the case of the counter - clockwise tournament , @xmath143 if @xmath140 and @xmath144 otherwise .",
    "when this passes through two yield gates , then we again get 1 when @xmath140 and 0 otherwise .",
    "so , regardless of the tournament used , the result after the two yield gates is 1 when @xmath140 , and 0 otherwise .",
    "we wish to have 0 when @xmath140 and 1 otherwise .",
    "this is achieved by subtracting our current result from 1 , which is realized by the negation and addition gates in the right half of figure [ fig : secondhalf ] .      now that we have an addition gate and a squaring gate , we build a multiplication gate via the identity @xmath145 which equals @xmath146 modulo 3 .",
    "the gate in figure  [ fig : multiply ] computes this formula , using the gates that we developed earlier in this section .",
    "this paper presented several constructions which use voting trees to compute natural and non - trivial functions .",
    "in particular , we substantially improve upon the previous best performance guarantee of @xmath3 , constructing trees which achieve order @xmath147 .",
    "we presented our arithmetic gates in our final section because they were initially developed for lower bound constructions for the performance guarantee , and produced our first construction which improved the lower bound .",
    "we also feel that they may be of independent interest , as they demonstrate that the computational power of voting trees is sufficiently rich to perform standard ternary arithmetic ."
  ],
  "abstract_text": [
    "<S> the classical paradox of social choice theory asserts that there is no fair way to deterministically select a winner in an election among more than two candidates ; the only definite collective preferences are between individual pairs of candidates . </S>",
    "<S> combinatorially , one may summarize this information with a graph - theoretic tournament on @xmath0 vertices ( one per candidate ) , placing an edge from @xmath1 to @xmath2 if @xmath1 would beat @xmath2 in an election between only those two candidates ( no ties are permitted ) . </S>",
    "<S> one well - studied procedure for selecting a winner is to specify a complete binary tree whose leaves are labeled by the candidates , and evaluate it by running pairwise elections between the pairs of leaves , sending the winners to successive rounds of pairwise elections which ultimately terminate with a single winner . </S>",
    "<S> this structure is called a _ voting tree_.    much research has investigated which functions on tournaments are computable in this way . </S>",
    "<S> fischer , procaccia , and samorodnitsky quantitatively studied the computability of the _ copeland rule _ , which returns a vertex of maximum out - degree in the given tournament . perhaps surprisingly </S>",
    "<S> , the best previously known voting tree could only guarantee a returned out - degree of at least @xmath3 , despite the fact that every tournament has a vertex of degree at least @xmath4 . in this paper , we present three constructions , the first of which substantially improves this guarantee to @xmath5 . </S>",
    "<S> the other two demonstrate the richness of the voting tree universe , with a tree that resists manipulation , and a tree which implements arithmetic modulo three . </S>"
  ]
}