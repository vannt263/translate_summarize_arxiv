{
  "article_text": [
    "in many crystal - growing procedures of interest , a nano - scale faceted surface appears and proceeds to evolve , often exhibiting coarsening and even dynamic scaling , whereby characteristic statistics describing the surface remain constant even as the characteristic lengthscale increases through the vanishing of small facets . for many evolving faceted surfaces , a _ facet velocity law _",
    "can be observed @xcite , assumed @xcite , or derived @xcite which specifies the normal velocity of each facet , often in configurational form which depends on the geometry of the facet . in this way , the dynamics of a continuous , two - dimensional surface can be concisely represented by a discrete collection of such velocities , and overall computational complexity reduced to that of a system of ode s ; the resulting system is known as a _ piecewise - affine dynamic surface _ , or pads . such theoretical simplification , in turn , enables the large - scale numerical simulations necessary for the statistical investigation of coarsening and dynamic scaling .",
    "the numerics involved in the direct geometric simulation of an arbitrary pads is straightforward for one - dimensional surfaces , requiring nothing beyond traditional ode techniques except simple geometric translation between facet displacement and edge displacement , and a small surface correction associated with each coarsening event .",
    "consequently , such simulations accompany many of the above facet treatments of facet dynamics , and have also been independently repeated elsewhere @xcite .",
    "however , in two dimensions , the corrections due to coarsening events are much more involved , and any code must be able to deal with a family of non - coarsening _ topological events _ that alter the neighbor relations between nearby facets .",
    "consequently , the fewer simulation attempts use either fast but poentially imprecise envelope methods @xcite , or more robust but slower phase - field @xcite or level - set @xcite methods to avoid explicitly performing topological changes . besides the speed / accuracy trade - off exhibited by these approaches , both methods obscure the natural geometric simplicity of the native surface , complicating the extraction of detailed surface statistics which",
    ", after all , motivates large simulations in the first place .",
    "additionally , as will be seen , the presence of non - unique topological events requires explicit intervention regardless of topological scheme , which negates much of the advantage of a `` hands - free '' treatment .    in the previous chapter",
    ", we introduced a direct - simulation method which explicitly performs topological events along the way , thus preserving both simulation speed and topological accuracy .",
    "in addition , by representing the surface as a collection of facets , edges , and junctions , plus the neighbor relations between them , the method mirrors the natural geometry of the surface being modeled , which allows easy extraction of geometric statistics .",
    "there , however , the restricted case of threefold symmetry was chosen for ease of topological implementation ; under this symmetry , a limited number of topological events were observed , and both vanishing facets and non - vanishing surface rearrangements could be handled explicitly using a priori knowledge of the before and after surface states . while many surfaces exhibit threefold symmetry , making the method useful even in this special case , it could not handle other common crystal symmetries , notably fourfold and sixfold .    in this chapter , then , we generalize the previous model to allow the simulation of surfaces with arbitrary symmetry groups .",
    "we begin in section  [ sec : cellular - structure ] with a brief summary of the basic method , including surface representation , facet kinematics , and the application of a dynamics .",
    "next , in section  [ sec : topological events ] , we provide a careful enumeration of topological events which may occur on surfaces of arbitrary symmetry ; this includes discussion of the far - field reconnection algorithm , by which network holes left by vanishing facets may be consistently repaired without knowledge of the post - event state .",
    "then , we provide in section  [ sec : discretization and topology ] a careful consideration of the consequences of using ( necessarily discrete ) timesteps during the simulation of a surface whose evolution equations change qualitatively between steps ( at topological events ) ; the issues that arise are discussed in the context of three sample strategies .",
    "the completed method is illustrated from three- , four- , and six - fold symmetric surfaces in section  [ sec : demonstration ] ; these exhibit all of the topological events likely to be encountered on a real surface , and demonstrate that the method is robust enough to generically simulate faceted surfaces of any symmetry class for which a facet - velocity law is uniquely specified .",
    "finally , in addition to detailing the ffr algorithm , the appendix includes a discussion of kinematically non - unique topological events , where two resolutions are possible , and highlights the need to refer to the dynamics or even first principles to decide how the surface should evolve in those cases .",
    "we consider the evolution of a single - valued , fully - faceted surface @xmath1 ; this definition explicitly forbids overhangs and inclusions .",
    "we assume that the surface bounds a single crystal which exists on exactly one lattice ; thus , we are not treating surfaces with multiple grains .",
    "the surface is piecewise - affine , consisting of facets @xmath2 with fixed normals @xmath3 .",
    "these are bounded by and meet at edges @xmath4 which are necessarily straight line segments ; edges in turn meet at triple - junctions @xmath5 .",
    "this three - component structure is reminiscent of two - dimensional _ cellular networks _ @xcite and indeed , while we consider three dimensional surfaces , the projection of the edge set onto the plane @xmath6 is a 2d cellular network .",
    "this structure and the neighbor relations inherent within it suggest a doubly - linked object - oriented data structure , consisting of : ( 1 ) a set of junctions , each having a location , pointing to three edges and three facets ; ( 2 ) a set of edges , each having a tangent , pointing to two junctions and two facets ; and ( 3 ) a set of facets , each having a normal , pointing to @xmath7 edges and @xmath7 junctions .",
    "these objects and the associated neighbor relations are illustrated in figure  [ fig : neighbor - relations ] ; this structure is the natural structure of the surface , and uniquely and exactly describes it .",
    "we now consider each element in more detail .",
    "[ fig : neighbor - relations ]      a _ junction _ is a point in space formed where edges ( and hence , facets ) intersect .",
    "the * order * @xmath8 of a junction is simply the number of edges which meet there . while junctions of any order @xmath9 are possible , we restrict ourselves here to the case of order @xmath10 junctions or `` triple junctions . ''",
    "this greatly simplifies analysis and code , as triple junctions are uniquely positioned by the three facets meeting there .",
    "the intrinsic geometric information carried by a junction is its location .",
    "junctions are stored in a ` junction ` class , which contains this location , as well as pointers to the three edges and three facets which meet there .",
    "an _ edge _ is a line segment formed by the intersection of exactly two facets , and bounded by exactly two junctions .",
    "the intrinsic geometrical quantity of an edge is its orientation , which is fixed since facets have fixed normals .",
    "edges are stored in the ` edge ` class , which records the tangent , as well as pointers to the two neighboring facets and two bounding junctions . at creation",
    ", edges are `` directed '' : one junction is arbitrarily deemed the origin , and the other the terminus , establishing a _",
    "tangent_. this has two important consequences .",
    "first , if we imagine walking along the edge in the tangent direction , then one neighboring facet may be labeled `` left '' , and the other `` right . ''",
    "this information allows us to distinguish between convex and concave edges , and also to determine the clockwise direction around a given facet , which is necessary for effective navigation of the network , as well as the proper calculation of boundary integrals on facets .",
    "second , the tangent allows us to detect when an edge `` flips '' ( see @xcite ) ; this will be discussed in more detail in section  [ sec : topology - class-1 ] .      a facet is a simply - connected planar polygonal region in space , which is bounded by an equal number of edges and junctions . the intrinsic geometric information carried by a facet is its normal , which is fixed .",
    "our surface definition @xmath11 requires that the normal of each facet is constrained to be on the hemispherical shell of unit - length vectors with positive @xmath12 component .",
    "the imposition of a particular symmetry on the crystal may further restrict available normals , but no such restriction is here assumed .",
    "facets are stored in a ` facet ` class , which contains the normal , as well as a list of bounding edges and junctions , sorted in counter - clockwise order .",
    "the intrinsic geometric means of characterizing surface evolution is by specifying the normal velocity of each point on the surface .",
    "a piecewise - affine surface is composed of a collection of planar , fixed - normal facets , whose motion is limited to displacement along the normal .",
    "therefore , the kinematics @xmath13 of the entire surface may be expressed by a discrete set of individual facet velocities @xmath14 .",
    "as edges and junctions are merely intersections between two and three facets , respectively , their motion is uniquely specified by the motion of the facets that neighbor them . in particular , if @xmath15 is the location in space of a triple junction , then the velocity of that a triple junction may be calculated through the expression @xmath16 where the rows of @xmath17 and entries of @xmath18 are the unit normals and normal velocity , respectively , of the three facets intersecting to form @xmath15 . in practice ,",
    "facet velocities are only used indirectly to calculate junction velocities  if junctions are moved correctly , edges ( connections between two junctions ) and thus faces ( collections of edges ) are necessarily moved correctly as well .",
    "all that remains now is to select a particular dynamics ; that is , to specify an expression for the normal velocity @xmath14 of each facet . having chosen one , we follow @xcite and refer to the resulting evolving structure as a piecewise - affine dynamic surface ( @xmath19 ) .",
    "example dynamics describing many different physical situations were listed in the introduction , and the exact dynamics is not of special concern here ( although we will select one for demonstration later ) .",
    "it is worth noting here , however , that most of the dynamics proposed to date are _ configurational _ , depending on properties of the facet such as area , perimeter , number of junctions , or mean height .",
    "thus , sudden changes in the geometric properties of a facet can lead to sudden changes in its velocity , an issue which will be explored in more detail in section  [ sec : discretization and topology ] .",
    "we have just discussed how elements of each class ( facet , edge , vertex ) neighbor members from each of the other classes . taken together",
    ", the set of all of these neighbor relations comprises the * topological state * of the surface .",
    "it is a complete record of every neighbor relationship on the surface , and is unique for a given surface .",
    "as the system evolves , these neighbor - relations may change as facets exchange neighbors , join together , split apart , or vanish .",
    "each of these cases is an example of a * topological event * , and represents a change to the topological state of the surface ( topological events are a defining feature of evolving cellular networks  again see @xcite ) . to maintain an accurate representation of the surface , a direct geometric method like that described here must manually perform topological events as necessary . because actual surface evolution is fairly trivial , this is the main difficulty of our method .",
    "a natural first question to ask at this point is `` how many topological events are possible ? '' to begin answering this question , we point out that on a physical surface , topological events occur automatically , and by geometric necessity . if a detected event signals the need to change neighbor relationships at some location on the surface , we may therefore infer that failing to change them would produce a cellular network with `` wrong '' relationships , that do not correspond to a physical surface .",
    "we call such erroneous configurations * geometrically inconsistent * ; examples include primarily edge networks that intersect when viewed from above , since these correspond to overhangs and inclusions , which are prohibited .",
    "since topological events serve to avoid possible geometric inconsistencies , we may discover what events are possible by considering how inconsistencies may occur .",
    "this is most easily accomplished by considering each surface element in turn .",
    "we first consider junctions , which are simply a location in space .",
    "a junction can , in the course of surface evolution , leave the periodic domain , in which case it is wrapped to the other side .",
    "however , this is only a bookkeeping operation , and does not represent a real topological event . turning to edges , we note that edges possess a directed length . as already hinted in section  [ sec : edges ] , this length could become negative if the edge were to `` flip '' @xcite a flipped edge has no geometrical meaning on a single - valued surface , and so we introduce a class of * vanishing edge * events which occur when edges reach zero length .",
    "finally , we consider facets .",
    "since a facet has fixed orientation , its changing properties are loosely its shape and size .",
    "specifically , a facet is a _ simply connected _ planar region with _",
    "positive area_. these two defining properties of facets lead , through consideration of their potential violation , to two additional classes of topological event : * facet constriction * events which prevent the formation of self - intersecting facets , and * vanishing facet * events which remove facets from the network when they reach zero area .      an adjacent point - point event occurs when an edge shrinks to zero length , and its junctions meet . to consider what might happen to the faceted surface",
    "when this occurs , we first label the immediate surroundings of an edge .",
    "each edge is composed of two faces of which it is the intersection , its * composite faces * , and stretches between two faces at which it terminates , its * terminal faces*. in addition , we will also use the term * emanating edges * to refer to those edges immediately neighboring the shrinking edge .",
    "now , consider the hemispherical shell of available facet normals ( section  [ sec : faces ] ) .",
    "the ( necessarily distinct ) normals of the composite faces specify a great circle about this hemisphere , which divides it into two parts .",
    "the normals of the terminal faces can not lie on this boundary , and unless they are identical ( a special case ) , they form a second great circle around the hemisphere .",
    "while terminal normals may not lie on the composite great circle , the reverse is not true , and this fact effectively divides vanishing edge events into three sub - classes .    [",
    "fig : shrinking edge classes ]    figure  [ fig : shrinking edge classes ] illustrates this idea , and gives an example of each of the three possible cases . if the terminal great circle touches neither composite point , then the well - studied * neighbor switch * occurs .",
    "if the terminal great circle touches one composite point , then an * irregular neighbor switch * results .",
    "finally , if the terminal normals occupy the same point , then no great circle is defined  the terminal facets have he same normal , and when the edge between them shrinks to zero , they join into a single facet : a * facet join*.      on a general surface , the most common vanishing edge event is the neighbor switch , which is frequently encountered in other evolving cellular networks . in this event , neither composite normal touches the terminal great circle , so any three of the normals involved form a linearly independent set  this property is the defining feature of the neighbor switch .",
    "when an edge with this configuration shrinks to zero length , the surrounding facets simply exchange neighbors . figure",
    "[ fig : t1-illustration ] gives an example of this event .",
    "+    [ fig : t1-illustration ]    _ resolution .",
    "_ the neighbor switch is performed by the ` ns_repairman ` class . to resolve this event",
    ", it simply deletes the old edge , and creates a new edge .",
    "the composite faces which formed the old edge become terminal faces of the new edge , and cease to neighbor each other .",
    "conversely , the terminal faces of the old edge become the composite faces of the new edge , and thus become neighbors . this symmetric exchange in neighbor relations",
    "is the cause of the name neighbor switch , which comes from the grain - growth literature  the less - descriptive name `` t1 process '' in often used in the soap froth literature .",
    "in addition to replacing the vanishing edge , the junctions on either side of this edge are replaced .",
    "each new junction is formed by the intersection of the deleted edge s ( formerly non - adjacent ) terminal faces with one of its composite faces .",
    "_ comments .",
    "_ readers familiar with other cellular - network literature will note that the example neighbor switch in figure  [ fig : t1-illustration ] lacks the typical `` x '' shape .",
    "this is due to the constrained nature of facet normals , and hence , edge orientations .",
    "additionally , we note that the neighbor switch is a reversible event ; in fact it is its own reversal .",
    "finally , a certain sub - class of neighbor switches posessing `` saddle '' structure are non - unique , as was observed by thijssen @xcite . for a discussion of this non - uniqueness and its consequences , see appendix  [ sec : non - uniqueness ] .",
    "when the normal of one of the composite faces lies on the great circle formed by the terminal normals , the neighbor switch can not occur . here",
    ", the terminal faces can not form a new junction with the offending composite face because the three normals involved are not independent . instead ,",
    "when an edge with this configuration shrinks to zero , two closely related events are possible , depending on the configuration of the nearby edges .",
    "these events are collectively called irregular neighbor switches , with two varieties called a `` gap opener '' and `` gap closer '' that are exact opposites .",
    "these are illustrated in figure  [ fig : gap opener ] .",
    "[ fig : gap opener ]    _ resolution . _",
    "the irregular neighbor switch is performed by the ` ins_repairman ` class . because one composite normal lies on the terminal great circle , exactly two of the emanating edges are parallel in @xmath20 .",
    "the gap opener occurs when these edges emanate from the shrinking edge in _ opposite _ directions , while the gap closer occurs when the edges emanate in the _ same _ direction . to resolve the gap opener , we select one of the parallel emanating edges to be split apart ( see below ) .",
    "the gap will go here , filled by the terminal face that touches the other parallel edge , and will extend all the way to the far end of the split edge , where a new edge is introduced to link the two edges resulting from the split edge .",
    "this is all illustrated in figure  [ fig : gap opener ] . to resolve the gap closer , simply reverse the steps .",
    "_ comments .",
    "_ several comments on this pair of events are in order .",
    "first , while the gap closer is uniquely resolved , the gap - opener is an inherently non - unique event , as either of the parallel edges could be the one split ( we will discuss this further in section  [ sec : non - uniqueness ] ) .",
    "second , both resolution options have the potentially dissatisfying property of being non - local in effect , because the collision of two junctions causes an entire edge to split apart . what is perhaps more likely is the nucleation of a new , tiny facet at the moment the junctions collide ; however , we have excluded that possibility from consideration here .",
    "finally , while common experimentally - encountered surfaces usually have either high symmetry ( only a few facet orientations ) or no symmetry ( as many orientations as facets ) , the irregular neighbor switch with its three coplanar orientations requires what may be called `` intermediate symmetry , '' where orientations are limited , but many are available . because it poses resolution difficulties , and",
    "because it is not encountered in any surfaces we wish to study , we have not yet actually implemented this event .",
    "finally , we consider the special case where the terminal normals are identical .",
    "when such an edge shrinks to zero length , the terminal faces meet exactly .",
    "having the same orientation , they then join to form a larger face .",
    "figure  [ fig : face - join - illustration ] depicts a representative facet join event .",
    "[ fig : face - join - illustration ]    _ resolution .",
    "_ facet joins are performed by the ` fjoin_repairman ` class . to perform a facet join ,",
    "a new face is created to replace the joining faces , and all edges and junctions that neighbored the old faces are re - assigned to this new face .",
    "next , the vanishing edge and its two junctions are deleted , leaving the four emanating edges to be considered .",
    "these are most logically grouped into the ( necessarily parallel ) pairs of edges bordering , respectively , the left and right composite faces of the vanished edge . in the example event shown in figure",
    "[ fig : face - join - illustration ] , these two pairs look different : one pair meets side - to - side , while the other pair meets end - to - end .",
    "computationally , however , this makes no difference ; each pair is replaced by a single edge connecting their remaining non - deleted junctions .",
    "this behavior is generic for all face joins .",
    "_ comments .",
    "_ we note that the face join is , strictly speaking , non - reversible ( though see section  [ sec : face - split ] ) .",
    "the exact opposite of the face join would be a facet which spontaneously `` shatters , '' as described in @xcite ; this behavior is certainly worth studying , but is not currently implemented .",
    "second , although this is a `` special case '' in general , for high - symmetry crystal surfaces it may be very common  indeed , for the case of a cubic crystal with only three available facet orientations considered in chapter 2 , facet joins are the only vanishing edge event exhibited .",
    "finally , we note that this event is the only vanishing edge event which does not conserve the number of facets .",
    "it is , in fact , one mechanism by which coarsening may occur , and may be the dominant mechanism for high - symmetry surfaces .",
    "the second class of topological event occurs whenever a facet ceases to be simply - connected , and results in that facet being split into two new facets . remembering that the edges of a facet trace out a polygon in the plane , we observe that the non - simply connected polygon , if allowed to continue evolving , would become self - intersecting , which clearly has no geometrical interpretation .",
    "so , how may an evolving polygon become self - intersecting ?",
    "since the boundary consists of edges and junctions , there are three possible modes : ( a ) two non - adjacent junctions meet , ( b ) a junction meets an edge , or ( c ) two edges meet .",
    "each case has a distinct `` signature , '' illustrated in figure  [ fig : self - intersection - signatures ] , which can be used to tell them apart .",
    "[ fig : self - intersection - signatures ]    the junction - junction collision shown in figure  [ fig : self - intersection - signatures]a represents the formation of a perfect @xmath21 junction . while theoretically interesting , such events are not considered here",
    "; we hypothesize that , given random initial data , two junctions not connected by an edge will never exactly meet .",
    "furthermore , by considering figure  [ fig : self - intersection - signatures ] , it can be seen that all junction - junction collisions , if perturbed as we hypothesize , result in either junction - edge or edge - edge collisions , and can therefore be resolved accordingly .",
    "junction - edge collisions occur when a facet is pinched into two pieces by three of its neighbors , depicted in figure  [ fig : self - intersection - signatures]b .",
    "there , two adjacent neighbors of the facet , forming a wedge , meet a third neighbor and pierce it .",
    "two separate events are possible in this class . in most cases ,",
    "the wedge simply splits the central facet into two parts , in an event called a * facet pierce*. however , if the normals of the wedge facets and the normal of the central facet lie on the same great circle , then , as the central facet is split , the opposing facet opens up a gap in the wedge : an * irregular facet pierce*.    edge - edge collisions occur when a facet is pinched by four neighbors , shown in figure  [ fig : self - intersection - signatures]c . in these events , two non - adjacent , exactly parallel edges meet , which requires that the normals of the impinging facets be coplanar with the normal of the pinched facet .",
    "again , two variations are possible .",
    "if the impinging faces have different normals , the event is called a * facet pinch*. however , if they have the same normal , they join even as they pinch the facet in question , in a process called a * joining facet pinch*. in addition , each event may occur in either symmetrical or asymmetrical flavors , which are shown in figure  [ fig : self - intersection - signatures]c1,c2 respectively .",
    "the meeting of two edges requires the involvement of two junctions ; these lie on the same edge for the symmetrical case , and on different edges for the asymmetrical case , as seen in the figure .",
    "the first self - intersection we will study is the simplest ; the facet pierce .",
    "it is a point - line event as described above ; that is , a facet is split when a triangular wedge formed by two adjacent neighboring facets intersects the edge formed with a third , opposing neighbor .",
    "the facet pierce is functionally the opposite of a facet join , and is illustrated in figure  [ fig : face - split - illustration ] .",
    "[ fig : face - split - illustration ]    _ resolution .",
    "_ each facet pierce is performed by the ` fjoin_repairman ` class .",
    "given the constricted facet , as well as the junction and edge which meet , it can label all of the surrounding facet elements and deterministically reconnect them correctly .",
    "first , two new facets are created to replace the constricted facet .",
    "the junctions and edges that bordered the old facet can be reassigned to these based on the labels created initially .",
    "the colliding junction and edge are deleted , to be replaced by three new junctions and two new edges .",
    "the locations of the former and neighbor relationships of each can be determined by considering figure  [ fig : face - split - illustration ] and using the labels .",
    "_ comments . _ first , technically , at the moment of the event , an @xmath22 junction forms , which as shown in figure  [ fig : face - split - illustration ] may proceed to break in one of three ways .",
    "this does not , however , constitute a non - uniqueness ; rather , the dynamics governing the surface evolution at the moment of topological change specify which exit pathway is chosen .",
    "second , while thijssen @xcite rightly objected to this resolution for the case of separate grains , we find it satisfactory for the case of a single crystal considered here .",
    "a special modification of the facet pierce just described occurs when the normal of the opposing facet shares a great circle with the normals of the facets forming the wedge .",
    "this event is called an irregular facet pierce .",
    "recall that three new junctions were created during the facet pierce .",
    "however here , since the two newly created facets have identical normals , and the remaining three have normals which are not independent , those junctions can not be created . instead",
    ", as the wedge facets meet the opposing facet , one of two things happen  either the center edge of the wedge is split apart by the opposing facet ( a `` wedge split '' ) , or the opposing facet is split apart by the wedge ( a `` wedge extension '' ) . we see an illustration of each possibility in figure  [ fig : table - split - illustration ] .",
    "[ fig : table - split - illustration ]    _ resolution . _",
    "the irregular facet pierce is performed by the ` ifp_repairman ` class , which at instantiation is given the constricted facet , as well as the junction and edge which meet .",
    "this event is repaired quite similarly to the regular facet pierce , with modifications .",
    "as is done there , two new facets are created to replace the constricted facet , and junctions and edges bordering the old facet are reassigned to the new ones .",
    "the resolution differs in how to replace the colliding junction and edge .",
    "if the `` wedge split''resolution is chosen , then the middle edge of the wedge and its far junction are also deleted ",
    "these are replaced by two parallel edges and junctions .",
    "finally , an edge is formed which links them and borders the facet on the far side of the deleted edge . if the `` wedge extension '' resolution is chosen , not only is the constricted facet split apart , but so is the one opposite the edge split by the wedge .",
    "one must first determine which edge of this second split facet the extended wedge will intersect .",
    "having done so , that facet is deleted , to be replaced by two new facets .",
    "the extension is formed by adding two edges parallel to the middle edge of the wedge , and the edge it intersects is split in two .",
    "two new edges and three junctions must be created to link the extension with the edge it intersects .",
    "finally , all edges and junctions bordering the deleted facet , plus those created to form the extension , are re - assigned appropriately to the new facets .",
    "figure  [ fig : table - split - illustration ] is especially helpful here .",
    "_ comments . _",
    "the event clearly recalls the `` gap opener '' described above .",
    "it shares with that event three coplanar surface normals , and as a result , two possible resolutions .",
    "additionally , while the two options here are qualitatively different compared to the symmetric options of the gap opener , they are additionally both non - local effects due to a local cause .",
    "again , perhaps the best resolution is to nucleate a new facet , which we do not yet consider .",
    "finally , both events require `` intermediate symmetry , '' and for the same reasons discussed above , we have not implemented this event .",
    "we now turn to consider the case of edge - edge events , the first of which is called a face pinch . here",
    "the normals of the pinching facets are not identical , and so junctions can be created as needed  an illustration of this event is shown in figure  [ fig : face - pinch - illustration ] .",
    "this event is philosophically similar to the face split described above . in each case , a facet is split into two by non - joining neighbors ; the difference is just whether the procedure is `` sharp '' or `` blunt '' ; i.e. , caused by parallel edges or a junction and an edge .",
    "[ fig : face - pinch - illustration ]    _ resolution .",
    "_ each facet pinch is performed by the ` fpinch_repairman ` class .",
    "because of the similarities between the facet pierce and facet pinch , the associated ` repairman ` classes behave similarly as well . here , the ` repairman ` class constructor takes the constricted facet and the two colliding edges . with this information",
    ", it can label all of the surrounding facet elements and deterministically achieve the change shown in figure  [ fig : face - pinch - illustration ] . as with the facet pierce ,",
    "two new facets are created to replace the constricted facet , and the junctions and edges that bordered the old facet are reassigned as required .",
    "the colliding edges are deleted , as are the associated junctions discussed above .",
    "five edges and four junctions are created to complete the reconnection , as shown in figure  [ fig : face - pinch - illustration ] .",
    "_ comments .",
    "_ this event , like the irregular neighbor switch and irregular facet pierce , requires a surface with `` intermediate symmetry . ''",
    "while it is uniquely resolved and poses no great difficulty of implementation , we have not yet implemented it for this reason .",
    "finally , a special modification of the face - pinch occurs when the impinging facets have identical normals .",
    "the constricted is split in exactly the same way as in a face pinch ; however , since the two facets doing the `` pinching '' are identically oriented , they join together to form a larger facet .",
    "we see an illustration of this situation in figure  [ fig : face - swap - illustration ] .",
    "[ fig : face - swap - illustration ]    _ resolution .",
    "_ each joining facet pinch is performed by the ` jfpinch_repairman ` class , which operates similarly to the ` repairman ` classes associated with the facet pierce and facet pinch .",
    "this class is again instantiated with the constricted facet and the two meeting edges , which allows the necessary labeling .",
    "again , two new facets are created to replace the constricted facet , but in this case the two facets which meet must join , and so another new facet must be created to replace them ",
    "necessary junction and edge reassignments are again easily carried out . finally , rather than deleting the edges which meet and the associated junctions involved , the meeting edges are simply re - connected as shown in figure  [ fig : face - swap - illustration ] .",
    "_ comments . _",
    "note that the final configuration is similar to the original configuration ; in fact , with suitable facet motion , the surface could return to its original configuration via another face swap ; the event is thus self - reversible in a sense .",
    "also , since both a facet pinch and a facet join occur simultaneously , the total numbers of each surface element remain unchanged during this event .",
    "the final class of topological event occurs when a facet shrinks to zero area and is removed .",
    "however , as has been noted numerous times previously in the context of cellular networks , very small facets can result in stiff dynamics that are difficult to numerically simulate accurately .",
    "for this reason , we follow previous authors by pre - emptively removing facets with areas below some small threshold ( but see section  [ sec : pure - predictive - method ] ) .",
    "this process is summarized in figure  [ fig : facet - removal - illustration ] . there , we see a single small flat facet vanishing into a pentagonal well ( [ fig : facet - removal - illustration]a ) . being smaller than the allowed threshold , it is removed , leaving a `` hole '' in the network ( [ fig : facet - removal - illustration]b ) . the facets and edges bordering this hole we call the * far field * , and",
    "they need to be reconnected correctly to patch the hole .",
    "the correct reconnection for this particular well is shown in figure  [ fig : facet - removal - illustration]c .",
    "[ fig : facet - removal - illustration ]    the principal difficulty in this process occurs during the reconnection step ( figure  [ fig : facet - removal - illustration]c ) . here",
    ", we are assigning new neighbor relationships to the far - field facets , which also involves the creation of new edges and junctions to form boundaries between them .",
    "in other cellular - network problems , these neighbor relationships ( and hence the reconnection ) is usually chosen randomly , under the reasoning that any error introduced is small enough to neglect and quickly corrected . however , because the faceted - surface network represents a piecewise - planar geometrical surface , we are not free to choose randomly . since each facet in the far field has a normal and a local height , neighbor relationships determine junction locations and thus edge placement .",
    "however , the final reconnection must be geometrically consistent  all facets must be simply connected , and thus no edges may intersect . if we were to randomly choose our neighbor relationships , the resulting reconnection would likely fail this test , and would thus represent a non - physical `` surface . '' to guarantee a geometrically consistent reconnection , we must search through all _ virtual _ reconnections until we find one that does not result in any self - intersecting facets .    several questions immediately arise :    1 : :    how can we effectively characterize a `` reconnection '' ? 2 : :    how many virtual reconnections are there to search ? 3 : :    how can we efficiently list all these choices ? 4 : :    can we be sure a good reconnection exists ? 5 : :    is this reconnection unique ?    for our method to be effective , all but the last of these questions must be answered satisfactorily .",
    "the detailed answers to ( 1 - 3 ) are found in the appendix , but we will summarize them here . the edges and junctions created during an @xmath23 reconnection may be effectively characterized as a binary tree with @xmath24 nodes .",
    "the number of @xmath25noded binary trees is given by the _",
    "catalan number _ @xmath26 .",
    "finally , these trees may be efficiently listed using a greedy recursive algorithm in @xmath27 time . for the fourth question regarding existence ,",
    "we argue heuristically that a facet reaching zero area proves the existence of its own reconnection , since a surface with a zero - area facet is functionally the same as the surface with that facet removed .",
    "we then assume the existence of that same reconnection for some window of time before the facet reaches zero .",
    "a fuller proof would appeal to manifold theory .",
    "finally , the fifth question regarding uniqueness is addressed in section  [ sec : non - uniqueness ] .",
    "having established these facts , we have a robust method for reconnecting an arbitrary far field of facets . before considering some special cases of this method ,",
    "let us summarize the general process so far : whenever facets smaller than a threshold area are detected , we :    a : :    remove them , leaving a hole in the mesh .",
    "b : :    list all virtual reconnections ( vr s ) as n - node binary trees .",
    "c : :    use associated neighbor relationships to find edge locations .",
    "d : :    test each vr until one with no intersecting edges is found .",
    "we note that this approach represents a comprehensive reconnection method for _ any _ cellular network problem .",
    "though it is necessary for the faceted surface problem , it may be useful in any situation where a verifiably optimal reconnection is sought .",
    "it is possible for _ groups _ of facets to shrink together , in such a way that they can not be removed sequentially . for an example , consider the configurations in figure  [ fig : volume - removal ] .",
    "in such a case , it is necessary to identify and collect a contiguous group of small facets for simultaneous deletion  we call this a * near field*. any facet neighboring the near field is assigned to the far field , which may be reconnected as described previously after the near field is deleted .",
    "[ fig : volume - removal ]    to gather the near - field facets , we maintain a second , more liberal threshold . whenever a face shrinks below the first threshold , as described above",
    ", its neighbors are recursively examined to collect those smaller than the second threshold .",
    "this method is rather simplistic , and , in cases of oddly - shaped pyramids , may not return the entire near field .",
    "this , in turn , will result in an incorrect far field , which will most likely be non - reconnectable .",
    "however , a group of facets vanishing together eventually all head to zero area , and for some window of time before they would physically vanish , all are small enough to be detected in this way .",
    "thus , we allow the code to `` skip over '' small facet combinations that it can not remove successfully , and try again during a future timestep .",
    "it is also possible , on high - symmetry crystal surfaces , that the small facet or group of facets forms a `` step '' between two much larger facets of identical orientation , but different height .",
    "figure  [ fig : step - removal ] illustrates this situation , in which the near field is bounded by exactly four facets , two of which have identical orientations . in such a case , the final fate of the surface is that the small facets vanish _ as the large facets join together_. the method described above contains no provision for joining far - field facets during reconnection , and so there is no way to reconnect the far field produced in this case .",
    "[ fig : step - removal ]    having identified a near field as forming a step , one solution is to delete the small facets , then move the two large faces to the same height and join them .",
    "this results in two pairs of unconnected edges , which are each deleted and replaced with an appropriate single edge .",
    "since facet groups forming steps are , in fact , bordered by four facets generically , a separate ` repairman ` class could be written to handle this case .",
    "however , the small adjustment to the positions of the large facets can lead to subtle problems , as will be seen in section  [ sec : discretization and topology ] .",
    "therefore , a more robust if less elegant approach is to simply add one of the large parallel facets to the ( step - forming ) near field ; a good choice is the one with fewer edges .",
    "since the far field surrounding this modified near field requires no joins , it can be repaired using the ffr method .",
    "again , failures are possible as described in the above section , but resolution is always possible near enough to the time the event would physically occur .",
    "we have now discussed the general kinematics of a @xmath19 , and surveyed all topological events which may occur as the surface evolves . before our treatment is complete , however , we must consider with care the application of a time - stepping scheme .",
    "the accurate performance of topological events under such a scheme is problematic because , while events on a continuously evolving surface happen at precise times ( @xmath28 at @xmath29 ) , any time - stepping method invariably skips over these times .",
    "this has three consequences , concerning detection , consistency , and accuracy . after discussing them briefly",
    ", we will present three possible timestepping methods which illustrate them in more detail .",
    "* detection . * because timestepping will always skip over moments of topological change , we must abandon hope of simply finding topological events ready to perform . instead",
    ", we must either look ahead before each timestep and anticipate when events will occur ( a _ predictive _ method ) ; or step before looking , and then by examining the network infer where events should have occurred ( a _ corrective _ method ) .",
    "class a events can be easily be detected either way , while class b events are easier to correct , and class c are easier to predict .",
    "* consistency .",
    "* once the occurrence of an event has been detected by either means , it must be performed in a way that preserves geometric consistency ",
    "i.e. , the network always corresponds to a physical surface @xmath30 .",
    "for example , two joining facets can only be mechanically fused if they exhibit the same local height .",
    "if , in addition to the occurrence of an event , a detection scheme can determine the exact time at which it occurred , then one strategy is to move the network to the precise event time , at which resolution is trivial .",
    "however , one may wish to attempt resolutions at other times , and the geometric consequences of doing so must be weighed .",
    "* accuracy * finally , we must consider the possibility of error that is produced during topological change .",
    "this error is most easily understood if we view the evolving surface in its abstract form as a highly nonlinear system of ode s .",
    "the ( usually configurational ) evolution function is moderated by the topological state ; thus , topological events can represent sudden , qualitative changes in the evolution function .",
    "a naive time - stepping scheme which steps over these without appropriate measures will produce large localized errors at moments of topological change .",
    "assume that , at all times , we accurately predict the time and location of the next topological event .",
    "then , a straightforward timestepping strategy which avoids consistency and accuracy concerns is to continually calculate the time of the next topological event ( accurate to the the order of the time - stepping method ) , and then step from event to event . under this approach ,",
    "time is divided into slices with constant equations of motion , guaranteeing that that the system always evolves under the correct equations , and accurately representing the continuously evolving surface .",
    "in addition , high - order single - step methods such as runga - kutta methods may be used to obtain high accuracy .    though neatly eliminating consistency and accuracy concerns",
    ", this method has a serious disadvantage .",
    "the frequency of topological events scales with the system size , and since we can never step farther than the next event , we effectively make the timestep dependent on system size  @xmath31 .",
    "since moving the system through a single timestep is itself an @xmath32 operation , then advancing the system through any @xmath33 period of time takes @xmath34 time . while acceptable for the detailed study of a small surface , it is obviously undesirable for the statistical study of large surfaces",
    "this is chiefly because , consistency concerns aside , it makes little sense to halt the entire surface at every single topological event , when each of these involves only a few facets .",
    "thus , our next method has as its chief objective the use of timesteps which are independent of system size .",
    "a second strategy is to take fixed timesteps , use a corrective method of topological detection , and attempt to perform topological corrections late .",
    "since timestep is independent of system size , many events will now occur per timestep , the size of which is chosen to produce a fixed small _ percentage _ of facets undergoing topological change each step .",
    "while this approach theoretically eliminates the @xmath34 contribution to running time , it introduces hurdles to event detection , as well as geometrically consistent and accurate resolution .    * detection .",
    "* we just stated that , in this corrective detection scheme , more than one event occurs per timestep .",
    "whether or not this is a problem depends on the * domain of influence * of each event , defined to be the set of network elements that event affects .",
    "if these sets contain no common elements , then the associated events occur too far apart in space to affect each other  they are independent .",
    "consequently , a detection routine can hand them in arbitrary order to the repair routines , there to be confidently performed in isolation .",
    "however , occasionally two or more domains of influence overlap . in this situation , called a * discrete compound event * , the associated topological events are no longer independent , and a detection routine can no longer ensure _ a priori _ their correct , consistent resolution when handed off .",
    "even worse , the very signatures used to identify separate events may be obscured in the resulting `` tangle , '' such that the routine does not even recognize what has happened .",
    "given the variety of event signatures described in section  [ sec : topological events ] , and the many combinations in which they might occur , creating a complete list of all dce s would be prohibitive if not impossible .",
    "instead , we reason that , on a random surface , no two events will ever occur at exactly the same moment ( it is possible to artificially construct faceted surfaces such two or more events must occur simultaneously ",
    "we do not consider this case ) .",
    "thus , if we simply refine our timestep when necessary , formerly overlapping events can be sorted out , and detected in sequence . a robust strategy for handling compound events",
    "is thus to ( a ) _ retrace _ the problematic timestep , ( b ) _ refine _ it into smaller slices , and ( c ) _ repeat _ steps ( a ) and ( b ) recursively , until only single events are detected",
    ".    * consistency . *",
    "since the surface is allowed to evolve unrepaired past numerous topological events per timestep , surface regions near these events will be geometrically inconsistent after the step .",
    "to say the same thing , facets involved in the bypassed events will have incorrect neighbor relationships .",
    "however , we have already classified all possible events , so having identified which event occurred , and which facets were involved , we know _ a priori _ what the correct neighbor relationships should be after the event .",
    "this knowledge , along with knowledge of the position of each facet involved , allows us to reconstruct the consistent surface that should have emerged during the event .",
    "unfortunately , not all events can be consistently corrected at a late time in this way .",
    "in particular , facet joins and joining facet pinches involve the joining of two facets that meet each other at a single local height .",
    "since this condition exists for only a single instant , such events can not be performed in a geometrically consistent way at any time other than the `` correct '' one . to accommodate this requirement",
    "while preserving a topology - independent timestep , we are forced to manually adjust the height of the joining facets before the event is performed .",
    "besides the error induced by this strategy ( discussed next ) , this need illustrates a second problem that can arise . in a * repair - induced inconsistency * , the very act of performing one event , because it is done late , triggers a second event that was not detected originally .",
    "an example is when the just - described height adjustment required for the delayed repair of a facet join triggers , say , a neighbor - switching event .",
    "since this newly - triggered event was not originally detected , the system is left in an inconsistent state after all repairs are made .",
    "an ad - hoc strategy to find such rii s is infeasible for the same reason as is a complete listing of all possible discrete compound events ( indeed , an rii may produce a dce , which rules out a simple multiple - rechecking strategy ) .",
    "thus , a similar retrace / refine / repeat strategy is required , with the added requirement that all events performed prior to detecting the rii must first be undone .    * accuracy . * finally ,",
    "as alluded above , repairing topological events _ after _ they occur can introduce large isolated errors .",
    "this can be due to the `` fudging '' required for the delayed repair of facet joins and swaps , but more generally is caused by facets involved in ( uncorrected ) topological events having been evolved under the wrong equations of motion for part of the relevant timestep .",
    "consider an event @xmath35 , with domain of influence @xmath36 .",
    "since topological events likely correspond to a change in the surface s evolution equation , the facets in @xmath36 are moved using the wrong equations for the time interval @xmath37 $ ] .",
    "since the equations guiding @xmath36 are wrong by as much as @xmath33 for a time of order @xmath38 , facets in @xmath36 may accumulate @xmath39 location errors during the timestep in which the event occurs .",
    "since the quantity of topological events does not depend on @xmath40 , the method retains first order accuracy globally .",
    "however , this error introduces a barrier to achieving higher - order accuracy later on .      the previous method , alas , contains one subtle problem that keeps it from being a true @xmath32 method .",
    "this problem is that the frequency of dces and riis , though small , still scales with the system size , and these necessitate timestep refinement .",
    "so although the late method does not have to explicitly step according to the @xmath41 time between topological events , yet to accurately detect and resolve those events it is still implicitly driven by the refinement strategy to step along a time associated with dces and riis .",
    "while this characteristic time is longer than that between individual topological events , and does not greatly slow the simulation of tens of thousands of facets , it still results in a method that is formally @xmath34 , which becomes prohibitive when considering systems of millions of facets .",
    "thus , we now sketch a third method , not yet implemented , which eliminates this effect all together .",
    "in addition , the method allows us to perform topological events in a way which confers all the accuracy benefits of the first , predictive method .",
    "we first re - state that , on any given timestep , _ most _ facets are not involved in any topological changes .",
    "while it was therefore obviously wasteful to move the entire surface from event to event in the first method , it is also conceptually wasteful to perform a global retrace / refine / repeat step to dces and riis in the second method . instead , after every timestep , we should identify for each dce / rii the * topological subdomain * containing all facets involved in the event .",
    "the few facets within these subdomains would be retraced / refined / repeated as required , while the rest of the ( unaffected ) facets would be left undisturbed in their post - timestep state .",
    "since operating on a given , constant number of facets takes @xmath33 time , and since the number of events per timestep scales only like @xmath32 , we see that a single timestep and all associated corrections  including dces and riis  can now be performed in @xmath32 time , with a final state that is guaranteed to be consistent .",
    "this produces a true @xmath32 method .",
    "in addition , this `` localized replay '' strategy has an accuracy benefit .",
    "regular , recognized topological events also have easily identifiable topological subdomains .",
    "if the facets within these domains are retraced , then the predictive detection mechanism of the first method can be applied within the domain to eliminate consistency and accuracy problems associated with late removal .",
    "one difficulty remains , however .",
    "facets involved in topological events may , under configurational facet - velocity laws , exhibit abrupt changes in velocity a result of the event . during the remaining segment of timestep",
    ", these facets may `` break out '' of the subdomain initially created to contain them , and begin interacting with facets outside of it .",
    "thus , we would need a mechanism to detect this , and start over with a larger subdomain if it occurs .",
    "finally , if subdomains can change size , then there is the possibility that two nearby subdomains will come to overlap as the algorithm progresses .",
    "therefore , we must include the ability to merge them if necessary , start over with the new , larger sub - domain , and repeat adaptively until everything can be sorted .",
    "this adaptivity ensures the robustness of the method , as highlighted by the method s formal name of * adaptive localized replay*. the reader may note that the pattern of adaptive repetition is similar to that used to resolve dces and riis above , and worry that another , even smaller @xmath34 effect lurks in the shadows .",
    "however , in both of the previous methods , such effects were due to the _ global _ response to a _ local _ problem .",
    "since this latter method is designed to be localized , there is no longer any mechanism to generate such effects .",
    "we demonstrate our method using the sample dynamics derived in chapter 1 , associated with the directional solidification of a strongly anisotropic dilute binary alloy .",
    "when a sample is solidified at a pulling velocity which is greater than some critical value , solute gradients caused by solute rejection at the interface create a solute gradient which opposes and overcomes the thermal gradient , resulting in a negative effective thermal gradient . in this environment , facets move away from the freezing isotherm at a rate proportional to their mean distance from the isotherm , as given by the dynamics @xmath42    in figures  [ fig : threefold ] , [ fig : fourfold ] , and [ fig : sixfold ] , this dynamics is applied to surfaces with common three- , four- , and six - fold symmetries to illustrate the flexibility of our topology - handling approach .",
    "a series of snapshots from the coarsening surface are presented , in which surface configurations near to many of the topological events described above may be observed .",
    "( however , neither the irregular neighbor switch , irregular facet pierce , nor facet pinch occur because no three facet normals are coplanar in these symmetries ; indeed , these events are not expected to occur on most physical surfaces , and were included for theoretical completeness . )",
    "[ fig : threefold ]    about half of computational time is spent looking for topological changes , which is significant but not prohibitive . with appropriate timestep choice , using even the still - inefficient timestepping method 2 above , a surface of @xmath43 facets",
    "may be simulated to a @xmath44 percent coarsened state in about an hour on currently available workstations . with the implementation of method 3 above",
    ", this time should be cut in half , and since method 3 is truly @xmath32 , a single million - facet simulation should take about a day .",
    "looking further ahead , since facet velocity calculations and topology checks require only local information , the method should be easily parallelizable , making possible even larger speed gains .",
    "we have presented a complete method for the simulation of fully - faceted interfaces of a single bulk crystal , with arbitary symmetry , where an effective facet velocity law is known .",
    "the surface , which is reminiscent of two - dimensional cellular networks , is encoded numerically in a geometric three - component structure consisting of facets , edges , and junctions , and the neighbor relationships between them .",
    "consistent surface evolution specified by the facet velocity law is accomplished via a simple relationship between facet motion and junction motion .",
    "although requiring the explicit handling of topological events , the method is efficient , using the natural structure of the surface , and accessible , allowing easy extraction of geometrical data .",
    "this combination makes it ideal for the statistical study of extremely large surfaces necessary for the investigation of dynamic scaling phenomena .",
    "a comprehensive listing of all topological events has been presented .",
    "these allow single - crystal surface with arbitrary symmetry ( or no symmetry at all ) to be simulated .",
    "events are classified into three categories , representing three ways that surface elements can become geometrically inconsistent .",
    "these are : edges which approach zero length , facets which become constricted , and facets which approach zero area .",
    "resolution strategies for the former two classes can be determined a priori , while repairing surface `` holes '' left by vanishing facets requires a novel far - field reconnection algorithm , which iteratively searches through all virtual reconnections to find one which produces a consistent surface .",
    "finally , intrinsic non - uniqueness of several events is discussed ; since ours is a purely kinematic method , decisions regarding resolution of these events must be made ahead of time through consideration of the dynamics or other physics .",
    "in addition , a detailed discussion of the issues associated with a discrete time - stepping scheme has been presented .",
    "the core issue is that topological events , which occur at discrete times throughout surface evolution , invariably fall between timesteps , with consequences for the detection of events , as well as their geometrically consistent and numerically accurate resolution . since topological change corresponds",
    "( under configurational facet velocity laws at least ) to qualitative changes in the local evolution function , some way to reach these in - between times must be introduced , while recognizing that only a few facets are involved in topological change during each timestep .",
    "a comparison of three approaches showed that the optimal solution is one of localized adaptive replay , where large timesteps are taken to improve speed , but local surface subdomains associated with topological change are reverted , and then replayed in a way that re - visits events with the necessary precision as necessary . while further work remains to implement this approach , the method as presented is capable of comparing million - facet datasets via averaged runs .",
    "our method of removing facets and facet groups requires patching a `` hole '' in the network left by the deleted facets .",
    "this requires selecting a geometrically consistent reconnection from a list of potential , or virtual reconnections . as outlined in the text , this involves searching through a complete list of virtual reconnections and testing each for geometric consistency . in this appendix",
    ", we address in more detail questions ( 1 - 3 ) posed in section  [ sec : vanishing - facets ] regarding the details of this method . for convenience , we repeat them here :    1 : :    how can we effectively characterize a `` reconnection '' ? 2 : :    how many potential reconnections are there to search ? 3 : :    how can we efficiently list all potential choices ?    we show here that an effective means of answer these questions is to think of reconnections as extended binary trees .",
    "this characterization enables us to easily count potential reconnections , distinguish them through naming , and suggests an algorithm for efficiently listing them for testing .",
    "an exhaustive illustration of the process is given for the case of an @xmath22 far field in figure  [ fig : binary tree listing ] .",
    "it will be useful to refer to that diagram during the following discussion .",
    "[ fig : binary tree listing ]      patching network holes always involves finding unknown neighbor relations between a given number of adjacent facets  that is , no facets are ever created , only edges and junctions .",
    "these are always connected into a single graph .",
    "in fact , the edges and junctions created during reconnection ( the `` reconnection set '' ) form a binary tree . in figure",
    "[ fig : binary tree listing ] , the trees associated with each possible reconnection are shown in thick blue lines . the far - field edges touching",
    "the reconnection set shown in gray represent the _ completion _ of this tree .",
    "that is , they take the interior tree , and add leaves to it so that every node of the interior tree is a triple - node . each virtual reconnection corresponds to a unique interior tree and completed tree in this manner .",
    "the counting of binary trees is , fortunately , a solved problem of graph theory . given @xmath8 nodes ,",
    "they may be arranged in @xmath45 distinct binary trees , where @xmath45 is the @xmath46 _ catalan number _ ; @xmath47 now , re - connecting an @xmath23 far field requires the creation of @xmath48 edges and @xmath24 nodes ; this may be visually confirmed for the case @xmath49 in figure  [ fig : binary tree listing ] .",
    "this creates an @xmath24 noded binary tree , and so an @xmath23 far field has @xmath50 virtual reconnections to search .",
    "if take the completed binary tree and arbitrarily select a _",
    "root node _ , then from each virtual interior tree we can generate a unique sequence of letters which identify it and encode its construction . this can be formed in one of two ways .",
    "the first way is to specify the tree by a set of recursive function calls .",
    "each branch point has left and right branches , each of which may terminate in either a leaf , or another branch point .",
    "the middle column of figure  [ fig : binary tree listing ] gives such a function for each tree shown in the left column .",
    "the second way is to walk around the tree in a counter - clockwise manner , recording each branch point or leaf as it is encountered .",
    "either method produces a series of letters that uniquely identify the tree .",
    "since the beginning lb and terminal ll are guaranteed , we may use only an abbreviated version consisting of @xmath48 of each letter .",
    "the problem is now reduced to generating all possible letter combinations .",
    "we can recursively build these combinations letter by letter using a greedy algorithm which chooses b over l if possible .",
    "this approach is subject to three restrictions which must be true of a `` legal '' word . at each step ,",
    "( a ) @xmath51 , ( b ) @xmath52 , ( c ) @xmath53 .",
    "the function we use is sufficiently short that we simply reproduce it here :    ....    list_trees(n ) {      rec_list_trees(n , 0 , 0 , '' ) ;    }      rec_list_trees(n , leaves , branches , word ) {      max = n-3 ;      if ( branches < max )         rec_list_trees(n , leaves , branches+1 , word+'b ' ) ;      if ( leaves < max and leaves < = branches )        rec_list_trees(n , leaves+1 , branches , word+'l ' ) ;      if ( leaves = = max and branches = = max )        print(word ) ;    } ....    thus , using this algorithm to generate a complete list of reconnection labels , we perform the reconnection associated with each one , and test it for geometric consistency .",
    "this allows us to efficiently find the correct reconnection .",
    "we have already mentioned that certain topological events are ambiguous in their resolution . here",
    "we review the instances of non - uniqueness , discuss their cause and implications , and suggest a method of treating them in a numerical scheme .",
    "we begin our list with an important ambiguity not discussed in the main text .",
    "as noted by thijssen @xcite , the lowly neighbor switch can be non - unique if the four facets involved have a `` saddle '' configuration  where the edges neighboring the vanishing edge ( the emanating edges ) form an alternating sequence of two valleys and two ridges .",
    "this is illustrated in figure  [ fig : non - uniqueness]a .",
    "there , from either starting position on the left , two topological resolutions are possible .",
    "one involves changing neighbor - relations , while the other does not .",
    "this latter resolution , which we term a `` neutral pass , '' represents a vanishing edge event which needs no resolution .",
    "however , it still results in a ( prohibited ) flipped edge , so if it is to actually occur , a bookkeeping operation must take place to correct this . moving on",
    ", we recall the non - unique `` gap opener '' flavor of irregular neighbor switch , which is not reproduced here . however , as a vanishing edge event , it may also come in the saddle variety , and admits a neutral - pass resolution option which is displayed in figure  [ fig : non - uniqueness]b .",
    "finally , the irregular facet pierce event is also not reproduced .",
    "none of these cases of ambiguity of resolution can be resolved at the kinematic level . since the particular evolution pathway leading to such ambiguities is the product of a long chain of mathematical reasoning , we therefore look backward in this chain to resolve them .",
    "the kinematics are most directly provided by the dynamics , which is a good first place to start .",
    "one option is to see which resolution is more strongly self - reinforcing ; if one choice under the given dynamics immediately works to reverse itself , for example , the other option should probably be chosen . moving farther back the chain of reasoning , one may consider the argument used to derive the given dynamics .",
    "for example , the dynamics ( [ eqn : solidification - dynamics ] ) comes from the constant reduction of an undercooling energy by moving away from the maximally - expensive @xmath6 isotherm .",
    "therefore , an energy - informed choice is to choose the resolution which minimizes this energy , i.e. , maximizes the total integrated distance from @xmath6 . taking another step back , perhaps such arguments come , as this one does , from a partial differential equation describing surface evolution .",
    "such equations can be simulated directly , and the resulting resolution choices studied .",
    "ultimately , the original physical model may have to be considered , perhaps at the atomic level .",
    "for each dynamics we wish to study , one must apply this chain of reasoning to find the correct ambiguity - resolution strategy .",
    "ideally , considerations at all levels should produce identical results .",
    "the non - uniqueness of particular topological events reflects a deeper , underlying problem . for each non - unique event , facet heights of competing resolutions",
    "are identical ; only neighbor relationships between these facets differ .",
    "thus , non - uniqueness in topological events indicates the presence of , and indeed is caused by , multiple possible ffr - style reconnections of a given group of far - field facets .",
    "what are the implications for the ffr algorithm of early facet removal ?",
    "while it may seem helpful at first to list prohibited resolution configurations and feed these to the ffr algorithm , this approach grows increasingly brittle as the number of prohibited configurations grows .",
    "instead , a more robust approach is to cause an ffr yielding multiple valid results to fail .",
    "having discovered resolution strategies for each individual event as described above , we simply let these rules apply until the far field is small enough to be unique ( similar to @xcite ) .",
    "a theory predicting when far fields will have multiple resolutions would aid in this process .",
    "finally , we note that the benefits of phase - field and level - set methods , which automatically capture topological change , are only clear if topological changes are unique .",
    "these methods are ultimately only kinematic , and offer no clear criteria for resolving kinematic non - uniqueness .",
    "thus , a dynamic selection criteria would seem to be required no matter the method used , and indeed , the implicit handling of topology offered by these methods may actually hinder the dynamic selection of kinematically ambiguous events ."
  ],
  "abstract_text": [
    "<S> we fully generalize a previously - developed computational geometry tool @xcite to perform large - scale simulations of arbitrary two - dimensional faceted surfaces @xmath0 . </S>",
    "<S> our method uses a three - component facet / edge / junction storage model , which by naturally mirroring the intrinsic surface structure allows both rapid simulation and easy extraction of geometrical statistics . </S>",
    "<S> the bulk of this paper is a comprehensive treatment of topological events , which are detected and performed explicitly . </S>",
    "<S> in addition , we also give a careful analysis of the subtle pitfalls associated with time - stepping schemes for systems with topological changes . </S>",
    "<S> the method is demonstrated using a simple facet dynamics on surfaces with three different symmetries . </S>",
    "<S> appendices detail the reconnection of `` holes '' left by facet removal and a strategy for dealing with the inherent kinematic non - uniqueness displayed by several topological events . </S>"
  ]
}