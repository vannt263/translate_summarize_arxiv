{
  "article_text": [
    "adiabatic quantum optimization ( aqo ) applies the principles of quantum computing to solve unconstrained optimization problems . in particular",
    ", the aqo algorithm interpolates between two quantum logical hamiltonians in order to adiabatically transform an initial quantum state to a computational solution state @xcite .",
    "this specialized application of adiabatic quantum computing has been used to solve a variety of problems including , for example , instances of satisfiability ( sat ) @xcite and exact cover @xcite , finding ramsey numbers @xcite , classifying binary images @xcite , training classifiers for machine learning @xcite and finding the lowest free - energy configuration in folded proteins @xcite .",
    "benchmarking the efficiency of the aqo algorithm is currently of significant interest in quantum computer science . whereas some studies of optimization problems have uncovered runtimes that scale polynomially in problem size , others suggest worst - case exponential behavior , or even trapping in local minima @xcite . interpreting these analyses",
    "are difficult , in part , because of the manner in which instance - specific information alters the implementation of the algorithm , i.e. , programming .",
    "as emphasized by others @xcite , choices made in programming the aqo algorithm greatly impact its runtime and , consequently , the observed scaling behavior .    benchmarking adiabatic algorithms is further complicated when the design of the logical hamiltonians is constrained .",
    "because the aqo algorithm uses a reduction of the classical optimization problem to a quantum logical representation , i.e. , a hamiltonian , any constraints placed on this underlying logical fabric can only limit performance .",
    "understanding the impact of the logical fabric is especially pertinent since existing aqo hardware supports a specific topology over a relatively modest number of qubits @xcite .",
    "adiabatic quantum programming has been described previously as requiring two steps : parameter setting @xcite and minor embedding @xcite .",
    "minor embedding , in particular , uses explicit information about the logical fabric as well as the problem to generate the implementation of the aqo algorithm .",
    "choi has demonstrated how an arbitrary input graph can be minor embedded within one type of highly regular fabric , a square lattice of @xmath0 s , complete bipartite graphs with eight vertices . in the current paper , we also present algorithms for minor embedding into additional logical fabrics , namely , square lattices of @xmath1 with @xmath2 .",
    "we present an attempt at a brute force embedding via graph isomorphism in maximal minors ( henceforth called maximal minor embedding ) as well as an algorithm for complete - graph embedding .",
    "we compare these algorithms in terms of their complexity as well as the scaling of the embedding result .",
    "notwithstanding algorithms for the unit - cell lattice , an open question in adiabatic quantum programming is how to handle fabrics containing randomized hard faults .",
    "hard faults refer to defects in the logical fabric that compromise its regularity .",
    "as their locations are random , the embedding algorithm must handle a variety of target graphs . in the current paper",
    ", we present methods for minor embedding that use heuristics to adapt to random faults in the logical fabric ( hardware ) .",
    "we analyze algorithmic performance in terms of the maximum embeddable complete graph obtained using numerical simulations .",
    "these studies quantify the impact of faults on the required logical footprint and provide performance expectations for hard fault - tolerant adiabatic quantum programming .",
    "the paper is organized as follow : sec .",
    "ii defines the role of minor embedding in adiabatic quantum optimization ; sec .",
    "iii briefly reviews previous work ; sec  iv defines nomenclature and presents implications of treewidth on graph embeddability ; sec",
    ".  v recounts properties of the unit - cell lattice ; sec .",
    "vi determines treewidth for hardware graphs @xmath3 ; sec .",
    "vii presents embedding of a complete graph in @xmath3 ; sec .",
    "viii presents two algorithms for embedding with hard faults and numerical tests of these algorithms using randomized fault placement ; finally , sec .",
    "ix presents our conclusions .",
    "the aqo algorithm is based on the reduction of an unconstrained optimization problem to a quantum logical hamiltonian that is diagonal in the computational basis @xcite .",
    "the reduction most naturally begins in terms of binary variables that can then be mapped to the qubits of a logical hamiltonian @xmath4 .",
    "for aqo , the problem hamiltonian takes the form @xmath5 where @xmath6 is the weight on the @xmath7-th qubit , @xmath8 is the coupling between qubits @xmath7 and @xmath9 , and the sets @xmath10 and @xmath11 denote the vertices and edges of the graph @xmath3 describing the logical fabric ; a more formal definition of the hardware graph is found in sec .",
    "[ sec : bgt ] . in this",
    "setting , the pauli @xmath12 operator defines the computational basis for the @xmath7-th qubit .",
    "the 2-local form of eq .  ( [ hf ] ) restricts the optimization problems that can be mapped directly into @xmath4 .",
    "specifically , any binary optimization problem can be recast to have at most quadratic interactions , i.e. , as a quadratic unconstrained binary optimization ( qubo ) problem .",
    "this reduction can be done by , e.g. , substituting the product of two variables with a new one and adding a corresponding penalty term @xcite .",
    "the aqo program input is therefore defined as the qubo problem @xmath13 where * x * is a vector of @xmath14 binary variables and * p * is an @xmath14-by-@xmath14 symmetric real - valued matrix .    in programming the qubo problem , the interactions between variables represented by * p * must be mapped into the quantum logical fabric .",
    "we interpret * p * as a weighted version of the adjacency matrix of an input ( problem ) graph @xmath15 describing these dependencies .",
    "hence , programming the aqo algorithm requires embedding @xmath15 in the graph @xmath3 representing the logical fabric .",
    "we defer the formal definition of minor embedding to sec .",
    "ii.b , but it suffices to say that this yields a graph @xmath16 contained within the logical fabric , over which a hamiltonian @xmath17 is defined as @xmath18 with @xmath19 and @xmath20 the corresponding weights and couplings . setting these parameters requires both the matrix @xmath21 and the embedding into the logical fabric specified by @xmath22 @xcite .    the program for the aqo algorithm is then expressed by the time - dependent hamiltonian @xmath23 where @xmath24 and @xmath25 control the time - dependent interpolation between an initial hamiltonian @xmath26 and the final embedded problem hamiltonian @xmath17 .",
    "the time @xmath27 represents the annealing time of the algorithm , such that @xmath28 .",
    "running the program @xmath29 requires initializing the quantum register state to be a ground state of @xmath30 .",
    "this is followed by annealing to the time @xmath27 after which the register is measured .",
    "provided the conditions of the adiabatic theorem are met , the state of the register at @xmath27 will be a ground state of @xmath17 and a solution to the qubo problem . in order to meet these conditions ,",
    "@xmath27 must scale inversely with the minimum spectral gap of @xmath29 @xcite .",
    "the gap , of course , depends on the programmed implementation and we may expect that the choice of embedding plays a role in satisfying this condition .",
    "in @xcite , choi described a hardware graph for minor embedding a large clique , @xmath31 , in a limited number of qubits .",
    "this layout was called triad .",
    "choi also discussed using the triad scheme on a 128 qubit hardware made up of a @xmath32 grid of @xmath0 cells to achieve the embedding of @xmath33 .",
    "we note the figure in @xcite corresponding to this description in that paper only embeds a @xmath34 , but it is possible to embed @xmath33 using the triad scheme .",
    "it is also worth noting that while the text claimed a requirement of only 6 physical vertices for each logical qubit , this is not achievable with the given hardware ( and is not realized in the example given ) .",
    "our work results in the same embedding for @xmath33 on the @xmath32 grid , but then extends the algorithm to work on a large family of related logical fabrics . we also provide a straightforward algorithm for extending an embedding from an @xmath35 grid to an @xmath36 grid of @xmath1 cells .",
    "this paper additionally determines the treewidth of the family of fabric graphs , which enables better screening of qubos for feasible embeddability .",
    "perhaps most importantly , prior work did not consider the case of faulty fabric , which we address with two algorithms and a set of simulations to demonstrate performance .",
    "a _ graph _ @xmath37 is a set of vertices @xmath38 and a set of edges @xmath39 formed by unordered pairs of vertices . in this paper ,",
    "all graphs are finite , simple ( no loops or multiple edges ) , and undirected .",
    "a graph @xmath40 is a _ subgraph _ of @xmath41 , denoted @xmath42 , if @xmath43 and @xmath44 .",
    "a _ path _ in @xmath45 is a sequence of vertices @xmath46 such that for @xmath47 , @xmath48 .",
    "a _ cycle _ is a path where @xmath49 .",
    "if there are no repeated vertices , the path ( cycle ) is a _ simple path ( cycle)_.    a graph is _ connected _ if there is a path from @xmath50 to @xmath51 for every pair of distinct vertices @xmath52 in @xmath38 .",
    "a _ tree _ is a connected graph which does not contain any simple cycles as subgraphs .",
    "we say a graph @xmath53 is a _ subtree _ of @xmath41 if @xmath42 and @xmath53 is a tree .    programming adiabatic quantum computing hardware to solve a specific problem requires embedding a _ problem graph _",
    "@xmath54 representing the qubo problem ( elements of @xmath55 correspond to qubo variables and @xmath56 ) into a _ hardware graph _",
    "@xmath57 whose vertices representing the qubits and edges are determined by couplings in the logical fabric . in some cases ,",
    "this can be done in a one - to - one manner through subgraph embedding .",
    "[ def : subgraph ] a _ subgraph embedding _ of @xmath15 into @xmath3 is a mapping @xmath58 such that :    * each vertex in @xmath55 is mapped to a unique vertex in @xmath10 . * if @xmath59 , then @xmath60 . +    note that if such an @xmath61 exists , @xmath15 is a _ subgraph _ of @xmath3 , @xmath62 .",
    "however , due to design constraints on the underlying logical fabric , in order to consider a large class of qubo problems , @xmath15 will need to be embedded into @xmath3 as a minor .",
    "[ def : minor ] a _ minor embedding _ of @xmath15 in @xmath3 is defined by a mapping @xmath63 such that :    * each vertex @xmath51 in @xmath55 is mapped to the vertex set of a connected subtree @xmath64 of @xmath3 . * if @xmath59 , then there exist @xmath65 such that @xmath66 , @xmath67 , and @xmath68 .",
    "+    if such a mapping @xmath69 exists , then @xmath15 is _ minor - embeddable _ in @xmath3 or @xmath15 is a",
    "_ minor _ of @xmath3 , written @xmath70 .",
    "equivalently , @xmath15 is minor - embeddable in @xmath3 if @xmath15 can be obtained from @xmath3 by a series of edge deletions and contractions ( see @xcite for more information on graph minors ) .",
    "note that every subgraph embedding is also a minor embedding ( since @xmath71 is a single node subtree of @xmath3 ) .",
    "furthermore , the property of being a minor is transitive : @xmath72 and @xmath73 implies @xmath74 .",
    "closely related to the idea of a graph minor is the concept of a tree decomposition , a combinatorial way of measuring how  tree - like \" a graph is .",
    "many early results on graph minors were first proved for trees @xcite .",
    "additionally , certain problems which have exponential complexity on arbitrary graphs have been shown to have polynomial complexity on graphs of bounded treewidth .",
    "more importantly , certain properties of tree decompositions , including upper bounds on treewidth ( the definition of which can be found below ) , are closed under the taking of minors .",
    "understanding the tree decomposition of the hardware graph gives us information about the properties of the minors the graph has and , thus , what sort of qubo problems can be embedded .",
    "[ def : treedecomp ] given a graph @xmath75 let @xmath76 be a tree , and @xmath77 be a family of vertex sets ( also called _ bags _ ) with @xmath78 indexed by the elements of @xmath79 . the pair @xmath80 forms a _ tree decomposition _ of @xmath41 if the following hold :    1 .",
    "2 .   if @xmath82 , then there exists @xmath83 such that @xmath84 .",
    "3 .   for @xmath85 , if @xmath86 lies on the path in @xmath27 between @xmath87 and @xmath88 , then @xmath89 .",
    "equivalently , for any vertex @xmath90 , @xmath91 forms a connected subtree of @xmath27 .",
    "+    to avoid confusion , the elements of @xmath38 are referred to as the _ vertices _ of g and the elements of @xmath79 as the _ nodes _ of @xmath27 .",
    "the _ width _ of a tree decomposition @xmath80 is given by @xmath92 .",
    "the _ treewidth _",
    "@xmath93 of a graph @xmath41 is the minimum width over all tree decompositions of @xmath41 .",
    "note that the width of any tree decomposition of @xmath41 gives an upper bound on @xmath93 .",
    "the following lemmas are well - known in graph theory and are useful for using treewidth to analyze the quantum hardware graphs described in sec .",
    "[ sec : hardwaregraph ] .",
    "+    [ lem : twlowerbound ] if @xmath53 is a minor of @xmath41 ( i.e. @xmath53 is minor - embeddable in @xmath41 ) , then @xmath94 .",
    "+    thus , given the treewidth of a logical fabric @xmath3 , it is possible to automatically narrow down the class of qubo problems for which it may be possible to find an embedding .",
    "the treewidth of several classic families of graphs is known exactly : +    [ lem : twkn , n][lem : twkn ] let @xmath31 be the complete graph on @xmath14 vertices and @xmath95 the complete bipartite graph on @xmath96 vertices .",
    "1 .   @xmath97 .",
    "2 .   @xmath98 .",
    "the treewidth of an @xmath99 2-d planar grid is given by @xmath100 .",
    "for more information on tree decomposition and graph minors ( including the proofs of the above lemmas ) see @xcite , chapter 12 of @xcite , and @xcite .",
    "in this section , we review the hardware graph that has been the basis for several proposed or demonstrated experimental studies @xcite .",
    "the building blocks of this graph are 8-qubit unit cells whose internal couplings form @xmath0 @xcite .",
    "unit cells are tiled together with each qubit on the left half of a @xmath0 connected to its image in the cells directly above and below , and each qubit on the right half of the @xmath0 connected to its image in the cells directly to the left and right . a representation of the graph formed by sixteen cells is shown in fig .",
    "[ fig : blankhardware ] . note that due to the way the qubits are physically connected @xcite , when there is a failure , it will be the failure of a qubit and not an individual coupler . in terms of the hardware graph , this means vertices ( and all their adjacent edges ) will fail , not individual edges .    4 array of @xmath0 unit cells coupled as in the hardware graph from @xcite.,scaledwidth=35.0% ]    in our analysis , we consider extensions of the unit cell design to include an increase in the number of qubits forming a cell .",
    "we also parameterize the hardware fabric to allow for expanding the grid of unit cells . in general , our results are applicable in the setting where cells consist of @xmath101 qubits forming a @xmath1 and are attached to form an @xmath102 grid in the same manner as described above .",
    "we denote a hardware graph of this form as @xmath103 .",
    "for example , the hardware graph shown in fig .",
    "[ fig : blankhardware ] corresponds to @xmath104 .    for ease of reference",
    ", we define a labeling on @xmath105 .",
    "first , we number a single cell : the vertices on the left half of the @xmath1 as @xmath106 from top to bottom , and the vertices on the right half of the @xmath1 as @xmath107 , again from top to bottom .",
    "[ subfig : qubitnumbering ] for an example of this numbering in a @xmath0 cell .",
    "each vertex in @xmath105 is then given a label of the form @xmath108 where @xmath109 is the ( row , column ) position of the cell containing the vertex in the @xmath102 grid - with cell ( 1,1 ) in the upper left corner - and @xmath110 corresponds to the position of the vertex inside the individual cell , as described above .",
    "as seen in lemma [ lem : twlowerbound ] , if the treewidth of the hardware graph is known , it can be used to a priori rule out the possibility of embedding certain classes of qubos .",
    "however , in general , determining the treewidth of an arbitrary graph @xmath41 is np - complete @xcite . in @xcite",
    ", bodlaender describes a linear time algorithm to determine whether a graph has treewidth at most @xmath111 , for a given fixed @xmath111 . however , the constants for the algorithm are extremely large ( and grow exponentially with @xmath111 ) , making it impractical for most graphs , including the hardware graphs of interest here .",
    "amir describes a polynomial - time algorithm which finds a factor-@xmath112 approximation of the treewidth of a graph @xmath41 @xcite , however we have tighter bounds for the treewidth of the hardware graph @xmath103 , as presented below .",
    "+    [ thm : hardwaretreewidth ] let @xmath103 be a hardware graph made up of an @xmath102 array of cells , attached as described in sec . [ sec : hardwaregraph ] , where each cell contains @xmath101 qubits connected to form a @xmath1 .",
    "then ,    1 .",
    "the treewidth of a single cell ( @xmath113 ) is @xmath114 .",
    "2 .   @xmath115 for @xmath116 .",
    "+    [ cor : pnotembeddable ] any qubo problem @xmath15 of treewidth @xmath117 is not minor embeddable in the hardware graph @xmath103 .",
    "+    [ cor : nobigkn ] any qubo problem which contains a @xmath118 ( either as a subgraph or as a minor ) can not be embedded into the hardware graph @xmath103 .",
    "+    [ cor : nobiggrid ] any qubo problem which contains a @xmath119 grid ( either as a subgraph or as a minor ) can not be embedded into the hardware graph @xmath103 .",
    "+    thus , even though the hardware graph described in corollary [ cor : nobigkn ] contains @xmath120 qubits , a @xmath118 , which would need only @xmath121 logical qubits ( if they were all coupled in the fabric ) , is shown to not be embeddable , due to its treewidth .",
    "+    the proof of ( 1 ) follows directly from lemma [ lem : twkn , n ] .",
    "furthermore , the lower bound of ( 2 ) follows from using the algorithm in sec .",
    "[ sec : algorithm ] to embed a @xmath122 into @xmath41 , since by lemma [ lem : twkn ] , @xmath123 , and lemma [ lem : twlowerbound ] implies @xmath124    the upper bound is slightly harder to compute .",
    "the proof consists of constructing a tree decomposition of @xmath103 with width @xmath125 .",
    "then , since the treewidth of @xmath103 is the minimum width over all tree decompositions , @xmath125 is an upper bound .    to form a tree decomposition @xmath126 of width @xmath125",
    ", we start with @xmath127 @xmath128 . that is",
    ", @xmath129 contains the right half of every cell in the first column of the grid plus the left half of the @xmath130 cell .",
    "the idea is to create all other bags of the decomposition by sequentially dropping / adding the left / right halves of individual cells .",
    "each new bag will be formed by removing one of these sets of four vertices from an existing bag , and adding a ( different ) set of four - specifically one that is not yet contained in any existing bag .",
    "the large amount of overlap between the bags is to ensure that the third requirement of def .",
    "[ def : treedecomp ] is satisfied .",
    "the bags @xmath131 of the decomposition are formed by dropping the right sides of cells in the first column and picking up the left sides , one - by - one .",
    "that is , @xmath132 contains the right half of cells @xmath133 through @xmath134 in the first column , the left half of cells 1 through @xmath135 , and all of cell @xmath7 .",
    "more formally , for @xmath136 , @xmath137 @xmath138 @xmath139 @xmath140 . in the tree being formed , @xmath27 , the first @xmath134 nodes form a path .",
    "the next @xmath134 bags are formed by ( again ) starting with @xmath129 but adding the right hand sides of the cells in the second column : for @xmath141 we drop the remaining four vertices in the left half of the first column and add the top four in the right half of the second ; for @xmath142 with @xmath136 , we add @xmath143 , and remove @xmath144 .",
    "bag @xmath145 is then formed by dropping the last four vertices from the first column and adding the four left vertices of the top cell in the second column .",
    "note that @xmath145 is the exact same `` shape '' as @xmath129 , only one column over .",
    "there is an edge between node 1 and node @xmath146 in @xmath27 , then nodes @xmath147 through @xmath148 continue the path .    at this point , the tree decomposition branches , with two new bags attached to @xmath145 ( analogous to @xmath129 ) .",
    "the first is @xmath149 , which starts the branch consisting of @xmath150 , with @xmath151 dropping @xmath152 and adding @xmath153 .",
    "note this is equivalent to how @xmath154 were created . also attached to @xmath145",
    "is @xmath155 , formed by removing the four righthand vertices from the top cell and adding the top four vertices from the right half of the third column .",
    "this branch continues to form @xmath156 analogously to @xmath157 , so that @xmath158 has the same shape as @xmath159 , only one column over .",
    "the remainder of the tree decomposition is created starting from @xmath160 ( formed analogously to @xmath145 ) , until each column has been covered with a set of bags which are formed like @xmath154 .",
    "this generates a total of @xmath161 bags , each containing exactly @xmath162 vertices of @xmath103 .",
    "a small example of the beginning of this process on a @xmath163 grid of @xmath0 cells can be seen in fig .",
    "[ fig : treedecomp ] .",
    "the tree associated with this tree decomposition can be found in fig .",
    "[ subfig:3x3tree ] , along with the trees associated with the tree decompositions of the @xmath164 and the @xmath32 grids in fig .",
    "[ subfig:2x2tree ] and [ subfig:4x4tree ] respectively .",
    "note that these three trees have the same general shape , with only the length of their branches changing , dependent on @xmath134 .",
    "we now show why @xmath126 satisfies the three properties of a tree decomposition from def .",
    "[ def : treedecomp ] :    1 .",
    "every vertex of @xmath103 is in at least one bag .",
    "2 .   every edge is contained in at least one bag .",
    "this can be verified by noticing that every cell is fully contained in exactly one bag , covering all edges within @xmath1 .",
    "additionally , for each column , there is a bag containing all of the left side vertices of the cells in the column , and thus all the vertical intercell edges in the column .",
    "finally , as the bags move from one column to the next , the right halves of each pair of horizontally adjacent cells are contained in a unique bag , thus covering all horizontal intercell edges .",
    "let @xmath51 be an arbitrary vertex in @xmath103 and let @xmath165 be the lowest index bag in which @xmath51 appears . then , as we walk along @xmath27 starting at node @xmath111 and traveling in the direction of increasing node labels , once @xmath51 is dropped from the bag ( on any branch ) it is never picked up again .",
    "thus , the nodes of @xmath27 which correspond to bags that contain @xmath51 form a connected subtree of @xmath27 .    since @xmath126 is a tree decomposition of @xmath103 where every bag contains @xmath162 vertices , it has width @xmath125 , so @xmath166    while these bounds are not tight for all choices of @xmath114 , they are best possible when @xmath167 , as @xmath168 .    determining bounds on the treewidth of the hardware graph is useful because it allows us to automatically dismiss the possibility of embedding certain classes of qubo problems , members of which we might otherwise have spent considerable time attempting to embed .",
    "if lower bounds on the treewidth of the qubo problems are known , these can be combined with the bounds on the treewidth of the hardware graph to rule out even more qubo problems .",
    "there are many graph - theoretic methods for finding lower bounds on treewidth , which use various graph properties including smallest degree , second smallest degree , girth , and spectral radius .",
    "applying lower bounds to classes of qubo problems is beyond the scope of this paper , but an overview of common lower - bound algorithms can be found in @xcite .",
    "in general , determining whether an arbitrary graph @xmath53 can be minor - embedded into an arbitrary fabric @xmath3 is np - complete .",
    "the best - known general algorithms assume a fixed input graph @xmath53 @xcite , which is the opposite of the situation in the quantum programming problem .",
    "additionally , although there are polynomial time recognition algorithms for the existence of an embedding , they do not produce the embedding and , in all cases , the hidden constants are prohibitively large @xcite .",
    "algorithms which allow @xmath53 to vary along with @xmath3 are no longer polynomial @xcite or are limited to specific classes of graphs which do not include the hardware graphs described in sec .",
    "[ sec : hardwaregraph ] @xcite .      given a fabric @xmath3 on @xmath14 vertices , the method for finding and embedding every possible minor - embeddable problem graph @xmath15",
    "involves solving an np - complete problem .",
    "first , all the minors of @xmath3 must be found and , second , we must determine whether @xmath15 is a subgraph of any of them .",
    "the first step can be done when fabric is defined but even once all the minors are known , every new problem graph @xmath15 must be checked against them for subgraph containment , which is still np - complete on arbitrary inputs .",
    "the brute force algorithm for finding all possible minors of @xmath3 involves finding the maximal minors : a set of minors of @xmath3 such that every other minor is a subgraph of one of the maximal minors .",
    "the first maximal minor is @xmath3 itself .",
    "subsequent maximal minors are found by contracting an edge in @xmath3 to form a minor and checking it for subgraph containment against the list of maximal minors .",
    "if it is not a subgraph of any of these , it is added to the list . once",
    "every minor of size @xmath169 is found ( i.e. every possible edge contraction of @xmath3 has been tested ) , the process is repeated by contracting edges in these minors .",
    "the process is completed at step @xmath111 when no new maximal minors of size @xmath170 are found .",
    "an example of a set of maximal minors can be found in fig .",
    "[ fig : maxminors ] , which shows the four distinct maximal minors of @xmath104 .",
    "conceptually , maximal minor embedding is very straightforward .",
    "the input graph @xmath15 is compared to the known list of maximal minors for @xmath3 .",
    "however , the comparison requires testing for subgraph containment , which is a combinatorial in the number of checks that must be performed .",
    "consequently , maximal minor embedding suffers from two distinct bottlenecks , i.e. , finding the maximal minor and finding the embedding .",
    "nonetheless , this method has the benefit of finding the optimal embedding with respect to the size of the embedded problem .",
    "because smaller embedding sizes may be expected to contribute favorably to the scaling of the energy gap , the effort required must be weighed against its advantages .      instead of trying to find every possible minor of the hardware graph",
    ", we can find an embedding of @xmath122 .",
    "then , for any qubo problem of size @xmath171 or smaller , the embedding problem is solved .",
    "the downside of this approach is that it will fail to embed many problems that are indeed embeddable in the hardware .",
    "for example , although the graphs in fig .",
    "[ fig : maxminors](b ) and ( c ) are embeddable in a @xmath0 cell , they are not embeddable in @xmath172 , which is the largest @xmath31 minor in the cell . because of this , the complete - graph embedding algorithm ( as described in sec .",
    "[ sec : algorithm ] ) requires a @xmath164 array of four cells in order to find an embedding for qubo problems corresponding to either of those graphs .    unlike maximal minor embedding",
    ", the complete - graph embedding algorithm is computationally simple albeit at the cost of increasesd usage of the logical fabric .",
    "this illustrates that the two methods described here represent a tradeoff between the computational complexity of the embedding algorithm and the potential computational complexity of the quantum program as measured by the area of the computational fabric .",
    "given a hardware graph as described in sec .",
    "[ sec : hardwaregraph ] , our algorithm to embed @xmath122 as a minor in the @xmath173 grid of @xmath1 cells is recursive in nature , and constructs the mapping @xmath69 described in def .",
    "[ def : minor ] . for the sake of clarity , in the description of the algorithm ,",
    "the elements of the @xmath122 will be referred to as nodes and the elements of the hardware graph will be referred to as vertices .",
    "let @xmath174 be the nodes of the @xmath122 that we are trying to embed .",
    "the algorithm begins by embedding the first @xmath175 nodes ( forming a @xmath176 ) into the cell in the upper left corner of the hardware .",
    "this is done by pairing left and right vertices @xmath177 times .",
    "that is , for @xmath178 , @xmath179 .",
    "the next two nodes are each initially mapped to a set containing a single vertex : @xmath180 , and @xmath181 . see fig .",
    "[ fig : singlecellembedding ] for an example of embedding @xmath172 in a @xmath0 cell of 8 qubits .",
    "we provide an instance of this algorithm in a matlab - style pseudocode for a function which produces an embedding into non - faulty @xmath103 hardware .",
    "1em after embedding a @xmath176 into the first cell of the hardware graph , the @xmath182 remaining steps of the algorithm extend the embedding into the subsequent row and column of the @xmath102 grid .",
    "for each step @xmath136 , the embedding forms an _ extendable _ clique minor in the @xmath183 grid .",
    "we say a minor is extendable if it satisfies two conditions : first for @xmath184 , @xmath185 the set @xmath186 is non - empty .",
    "second , each set has at least one vertex with an edge into the next row or column .    for all nodes @xmath184 ,",
    "at least one vertex of @xmath186 is connected to a cell in the next row and/or column of the grid .",
    "these vertices are added to the set @xmath186 . for nodes @xmath187 and @xmath188 , one vertex is added to @xmath189 and @xmath190 at each layer @xmath7 . for all other nodes",
    "@xmath184 , two new vertices are added to @xmath186 .",
    "the sets @xmath191 through @xmath192 are formed by picking one of the unclaimed vertices on the right side of cell @xmath193 .",
    "this is extended by following the edges from cell to cell along row @xmath7 .",
    "when column @xmath7 is reached , one edge is taken within the cell , then edges from cell to cell are followed up along column @xmath7 . at the end of this process , each of these sets will contain @xmath194 vertices : for @xmath195 , @xmath196 .",
    "this process is continued until @xmath122 is fully embedded in the @xmath102 grid .",
    "[ fig : knembedding ] for an extension of a @xmath197 embedding in a @xmath163 grid of @xmath0 cells to a @xmath33 embedding in a @xmath32 grid of cells .    in the description of the hardware graph in sec .",
    "[ sec : hardwaregraph ] , the vertices were given labels of the form @xmath108 . in the matlab - style pseudocode",
    "found below , they are numbered from 1 to @xmath198 .",
    "the numbering starts in the cell in the upper left corner as described in fig [ subfig : qubitnumbering ] and this numbering is continued across the row , then across subsequent rows .",
    "given a node position in the form @xmath108 , the equivalent number in the code below is @xmath199 . given a node numbered @xmath14 in the code below",
    ", the equivalent label is given by @xmath108 with @xmath200 , @xmath201 , and @xmath202 , with @xmath203 if @xmath204 .",
    "the complete - graph embedding algorithm presented in sec .",
    "[ sec : algorithm ] assumed that there are no failures in the hardware .",
    "however , the hardware may exhibit some percentage of failed vertices which prevent a full @xmath122 embedding ( e.g. in the case of any single qubit failure , the biggest clique embeddable is @xmath205 ) . instead of losing a node from the @xmath122 for each failed qubit , techniques can be employed to embed in a way that attempts to minimize the number of sets @xmath206 which contain any failed qubits .",
    "we present two algorithms below in order to handle the case of fabrics with hard faults .",
    "these approaches to embedding test the different starting points available from the four corners of the @xmath102 grid and then return the best possible embedding that results .",
    "additionally , if the largest @xmath31 found is smaller than the largest possible in an @xmath207 grid , from each corner , we drop the first row and column and reattempt the embedding . this  dropping down \"",
    "procedure continues until a large enough clique is found or @xmath208 rows and columns have been dropped .    at the same time",
    ", the grid is scanned and the largest @xmath31 embeddable in a single cell ( @xmath209 ) is found .",
    "if a complete cell is found , this is @xmath176 .",
    "the reported largest embeddable @xmath31 output by the algorithm is the maximum of the largest clique embeddable inside a single cell and the four cliques found from starting at the four corners .",
    "combining these two procedures yields a `` flip and drop - down '' method that we compare to the single , nominal attempt at embedding , i.e. , starting in the upper left corner . in all cases ,",
    "the worst performance possible is to embed a @xmath210 , since we assume there is at least one working qubit in the hardware .",
    "note details of the corner selection and drop - down methods are not shown in the pseudocode .",
    "given an @xmath102 hardware graph with cells of @xmath1 , one way to deal with failed qubits is to find the largest @xmath211 , @xmath212 , such that there is a complete @xmath102 grid of @xmath213 s and use the algorithm described in section  [ sec : algorithm ] to embed into this sub - grid .",
    "this will lead to an embedding of size @xmath214 .",
    "once the @xmath211 has been determined , the embedding can be found by renumbering the vertices of the hardware graph to reflect the new cell size and running no_failure_embedding(@xmath215 ) .      as can be seen in fig .",
    "[ fig : knembedding ] , given a perfect @xmath102 grid of @xmath1 cells , for each node @xmath50 of the embedded @xmath122 ( other than nodes @xmath187 and @xmath188 started in the first cell ) , @xmath206 contains @xmath148 vertices .",
    "these consist of two sets of @xmath134 vertices : a connected set consisting of one vertex from the left side of each cell in the a single column in the grid and a connected set consisting of one vertex from the right side of each cell in the row of the same number . due to the pattern in which cells are connected , within both of these sets every vertex occupies the same position in the cell it comes from .",
    "the greedy failure algorithm works to maximize the size of the complete @xmath31 which can be embedded in the hardware graph with failed vertices , by attempting to pair up sets containing failed vertices with other sets containing failed vertices to create full nodes .",
    "these `` match - ups '' occur in the diagonal cells of the grid . in the case of no failures ,",
    "each horizontal set ( of vertices from the right halves of cells ) is matched with a vertical set ( of vertices from the left halves of cells ) whose vertices occupy the same ` height ' inside a single cell . when there are errors , however , horizontal sets containing failed vertices attempt to match with vertical sets that also contain failed vertices , regardless of the heights at which the vertices sit inside a cell . by matching sets which contain failures ,",
    "the number of complete nodes ( all of which except @xmath187 and @xmath188 are made up of two sets ) containing failures is reduced and , consequently , a larger embedded @xmath31 is achieved .    the matlab - style pseudocode for a function which produces the nodes of the embedding described above and outputs the number of nodes containing no errors can be found at right .",
    "a comprehensive set of experiments were run to see how well the fallback and greedy algorithms from secs .",
    "[ sec : fallback ] and [ sec : greedy ] , respectively , performed under various conditions of vertex failure .",
    "these experiments were run using a single attempt at embedding that begins in the upper left corner of the grid of cells as well as a run using the flip and drop - down scheme described at the beginning of sec .",
    "[ sec : failures ] . in all cases ,",
    "the hardware graph was an @xmath102 grid of @xmath0 cells .",
    "the grid sizes tested were @xmath216 and 32 .",
    "for each of these grid sizes , the algorithms were run with a percentage of failed vertices of @xmath217 .",
    "the failed vertices were uniformly distributed across the hardware graph . in each of the 148 cases ( defined by algorithm , scheme , grid size , and failure rate )",
    ", 10,000 randomized instances were run to compute statistical averages .    a comparison of the results shown by figs .",
    "[ fig : singlevdropdown ] and [ fig : fallbackvgreedy ] illustrates that the flip and drop - down embedding scheme performs better than a single attempt at embedding from the upper left corner and that the greedy algorithm performs better than the fallback method . in both schemes ,",
    "the greedy algorithm embeds a @xmath31 with @xmath14 approximately 85% of the optimum value at two percent failure rate .    at fixed failure rate , the percent of the maximum embeddable @xmath31 for both algorithms decreases as the grid size @xmath134 grows .",
    "this is due to the fact that the number of hardware vertices mapped to a single node of the @xmath31 minor increases linearly with grid size . on the @xmath32 grid ,",
    "each set @xmath206 is made up of 8 vertices ( except for 2 special cases ) .",
    "given a 2% failure rate , this means that any @xmath206 on the @xmath32 grid ( with no attempt at a ` smart ' embedding scheme ) has a 16% chance that the set contains at least one failed vertex ( and thus can not augment the size of the @xmath31 embedded ) .",
    "similarly , on the @xmath218 grid , each @xmath206 contains 64 vertices , and for 2% failure having at least one failed vertex per cell is highly likely .    at 2% failure rate ,",
    "the greedy embedding scheme with flips and drop - downs achieves embedding of a complete graph of over 40% the size of the maximum @xmath31 embeddable . for the worst case scenario , and with no attempt at a ` smart ' embedding , it would only take one failed vertex to destroy each logical qubit . even at only a 2% failure rate ,",
    "the @xmath218 grid has on average 163 failed vertices .",
    "if the algorithm did not adapt , this high failure density would completely destroy the maximum embeddable clique , which is a @xmath219 .",
    "in the case of a 25% failure rate , the number of failed vertices jumps to 2048 , yet the greedy failure algorithm is still able to embed a @xmath220 on average .    we have also analyzed the variances in embeddability from these experiments . in the case of a single attempt at embedding , the distribution of embeddable graphs tends to be narrower than when using the drop - down scheme . for larger grid sizes and for higher percentages of failure",
    ", the variance of the single attempt falls to zero .",
    "this is caused by the fact that the algorithm never does better than embedding a @xmath172 into a single , complete cell .",
    "however , this happens less often for the drop - down embedding scheme , yielding larger average @xmath31 with higher variances .",
    "an example of this behavior is shown in fig .",
    "[ fig : variancehist ] for the case of @xmath104 when varying the percent failure rate .",
    "it is notable that while the variance of the fallback method is relatively large for small error rates , the greedy algorithm maintains a near constant , much lower variance across all failure rates . in fig .",
    "[ fig : embedhist ] , the distribution of achieved embeddings over 10,000 trials using the flip and drop down scheme on @xmath104 , with the percentage of failed vertices at @xmath221 and 10 , is shown .",
    "the embeddings achieved by the greedy algorithm are both more clustered and larger than those achieved by the fallback algorithm . with the added evidence of panel ( b ) in figs .  [",
    "fig : singlevdropdown ] and [ fig : fallbackvgreedy ] , this demonstrates the greedy approach is more robust in the presence of hard faults .",
    "we have presented methods for adiabatic quantum programming that embed problem specific information into an underlying quantum logical fabric .",
    "our methods include an embeddability analysis based on the treewidth of an @xmath134-by-@xmath134 lattice of @xmath1 unit cells , which is a generalization of existing adiabatic quantum hardware .",
    "this has provided bounds on the graphs that can be embedded in a predefined logical fabric and should be useful for guiding adiabatic quantum programmed implementations .",
    "in addition , we have presented two new methods for finding an embedding of a complete graph in faulty fabric .",
    "the first method handles failures by falling back to a set of smaller available unit cells , while the second searches for embeddings that minimize the number of affected logical qubits using matching within cells on the diagonals .",
    "the latter was shown to have greater power for programming implementations of arbitrary qubo instances .",
    "numerical studies of embeddability run against randomized failures further showed the relative robustness of the second algorithm and the remarkably smaller variance in embeddable graphs .    in our study of embedding for adiabatic quantum programming ,",
    "we have neglected any question regarding the subsequent computational complexity .",
    "the question of how a particular embedding algorithm impacts the complexity of the resulting aqo program is a point for future research .",
    "the current work , however , is expected to support uncovering the dependency of the computational complexity on both the embedding and parameter setting methods used .",
    "we believe that the embedding algorithms explored here , which provide a constructive approach to programming , will be useful for providing a consistent means of comparing the aqo algorithm across different problem sizes and hardware .",
    "this work was supported by the lockheed martin corporation under contract no .",
    "nfe-11 - 03394 .",
    "the authors thank greg tallant ( lockheed ) for technical interchange and daniel pack ( ornl ) for help preparing figure 2 .",
    "this manuscript has been authored by a contractor of the u.s .",
    "government under contract no .",
    "de - ac05 - 00or22725 .",
    "accordingly , the u.s .",
    "government retains a non - exclusive , royalty - free license to publish or reproduce the published form of this contribution , or allow others to do so , for u.s . government purposes ."
  ],
  "abstract_text": [
    "<S> adiabatic quantum programming defines the time - dependent mapping of a quantum algorithm into an underlying hardware or logical fabric . </S>",
    "<S> an essential step is embedding problem - specific information into the quantum logical fabric . </S>",
    "<S> we present algorithms for embedding arbitrary instances of the adiabatic quantum optimization algorithm into a square lattice of specialized unit cells . </S>",
    "<S> these methods extend with fabric growth while scaling linearly in time and quadratically in footprint . </S>",
    "<S> we also provide methods for handling hard faults in the logical fabric without invoking approximations to the original problem , and illustrate their versatility through numerical studies of embeddabilty versus fault rates in square lattices of complete bipartite unit cells . </S>",
    "<S> the studies show these algorithms are more resilient to faulty fabrics than naive embedding approaches , a feature which should prove useful in benchmarking the adiabatic quantum optimization algorithm on existing faulty hardware .    </S>",
    "<S> quantum computing , adiabatic quantum optimization , graph embedding , fault - tolerant computing </S>"
  ]
}