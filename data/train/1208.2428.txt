{
  "article_text": [
    "while for many years scientists and engineers could , to a large extend , assume that each year their computer programs would run much faster only because of a steady , rapid growth of the hardware capabilities , this assumption is no longer valid . with processor clock speeds flattening or even dropping to save energy , any further performance improvements must be coming from increased parallelism @xcite .",
    "however , of the two major types of software parallelism , coarse - grained and fine - grained , so far only the former has been widely adopted in computational science , mostly through message - passing or shared memory interfaces , whereas the latter tends to remain a niche technology , mostly because they introduce an additional level of programming complexity .",
    "this , however , leads to underutilization of the available resources in many areas of computational science , a problem that is getting only more acute as new or improved hardware solutions supporting fine - grained parallelism are being released .",
    "two such relatively new technologies are the advanced vector extensions ( avx ) , supported by new generations of intel and amd processors , and general - purpose computing on graphics processing units ( gpgpu ) , supported by graphics cards from amd and nvidia .",
    "both technologies exploit single instruction multiple data ( simd ) computing units for fine grained - parallelism . however , while avx is a relatively simple extension to the i383 instruction set , gpu is a separate coprocessor that must be programmed using dedicated programming languages and programming tools .",
    "although originally designed to support `` data - oriented '' programming in video and multimedia processing , both can be used to accelerate general computations .",
    "this arises the question whether they can be used to accelerate scientific computations on a much wider scale than to date .",
    "here we investigate avx- and gpu - accelerated implementations of the frish - hasslacher - pomeau ( fhp ) model of fluid flow @xcite .",
    "this model is an important example of a cellular automaton , a broad class of numerical algorithms applicable in various areas of science and engineering @xcite .",
    "typical cellular automata reduce the physical space to a regular grid of cells , each one in a finite number of states , evolving concurrently in discrete time steps according to some rules based on the states of neighboring cells .",
    "what distinguishes cellular automata from other numerical models used in physics is that the states are represented by small integers or even small sets of independent boolean variables rather than by floating - point numbers .",
    "thus , from a programmer s point of view , fhp is an example of a numerical algorithm in which huge amounts of integer data are arranged in a regular grid , and the evolution can be performed in parallel using bitwise operators between the data fetched from the nearest - neighbor cells .",
    "note that even though this algorithm is amenable to massive fine - grained parallelization , so far most research has focused on sequential architectures @xcite .",
    "therefore our goal is to investigate its parallelization properties .    of the two general - purpose computing systems available for gpus , opencl ( open standard ) and cuda ( proprietary , nvidia ) @xcite , we chose the latter for its better support for scientific computing .",
    "in contrast to cpus , gpus run in a multi - core mode by default .",
    "therefore a fair comparison between gpu and cpu implementations requires that their efficiency be compared processor for processor rather than core for core @xcite .",
    "therefore in the cpu implementation we used posix threads to fully utilize all available processor resources .",
    "we also implemented a sse version of the cpu code to check how much avx outperforms its predecessor , sse .",
    "we believe that other cellular automata algorithms exhibit similar potential for acceleration using avx and gpu technology .",
    "in the fhp model one considers a triangular lattice updated at discrete time steps @xmath0 .",
    "seven boolean variables are assigned to each of its nodes to represent the presence or absence of a particle with a given velocity @xmath1 , @xmath2 .",
    "the values of velocities are related to the lattice vectors @xmath3 through @xmath4 , @xmath5 , and @xmath6 corresponds to a particle at rest .",
    "thus , at each lattice node there can be up to 7 particles , each with a different velocity .",
    "since the fhp model is designed to simulate fluid flows in arbitrary ( two - dimensional ) geometries , usually the 8-th boolean variable is added to each node to distinguish whether it is occupied by fluid or by impenetrable boundary .",
    "consequently , a convenient representation of a node state is an 8-bit word , or byte , see fig .",
    "[ fig : bit ] . for example , a bit pattern @xmath7 corresponds to a node with two particles , one moving with velocity @xmath8 and the other with @xmath9 , located in the area free occupied by the fluid .    ]",
    "evolution in each time step consists of two parts :    * motion  each particle moves to the adjacent node or stays at rest , according to its current velocity , * scattering  particles in each node collide and change their velocities according to the physical laws of conservation of momentum and mass , see fig .",
    "[ fig : rules ] .",
    "this step includes bouncing from the boundaries .        to implement the motion step we used two two - dimensional arrays holding the system state immediately before and after translation of mobile particles . during this step ,",
    "particles from the first array were propagated to the appropriate neighboring nodes in the second array , according to their velocities .",
    "since the fhp is defined on a triangular lattice , we mapped its nodes into a rectangular lattice , see fig .",
    "[ fig : lattice_mem ] .",
    "this lattice was then mapped into a two - dimensional computer array .     ]",
    "as soon as all particles have been propagated , the arrays are swapped and the collision step is performed .",
    "collision in each node is a local operation that does not involve neighboring nodes .",
    "we implemented it using a look - up table , exploiting the fact that an 8-bit word can be regarded as an integer in the range of @xmath10 .",
    "collisions with the boundaries are defined through the the same look - up table as used for inter - particle collisions @xcite .",
    "we imposed reflecting ( no - slip ) boundary conditions on the top and bottom of the system and periodic boundary condition in the horizontal direction .",
    "periodic boundary condition were implemented by extending the system by two columns , one on each side , each mirroring the column on the opposite edge of the system , see  fig .",
    "[ fig : bc ] .        in each step",
    "the first column is copied to the additional column on the right side , and similarly the last one is copied to the extra column on the left .",
    "to enforce fluid flow , we imposed an external constant force acting horizontally on the particles . to this end , whenever the bits in a node fitted the pattern ( .. 1 .. 0 .. ) , where `` . ''",
    "denotes 0 or 1 , with some probability @xmath11 we exchanged the bits on positions 2 and 5 to form a pattern ( .. 0 .. 1 .. ) .",
    "this corresponds to reversing the velocity of a some of particle moving horizontally and results in the momentum transfer , which , in turn , is equivalent to the action of an external driving a force .",
    "on the coarse - grained level the cpu implementation was parallelized using the posix threads library .",
    "the grid was divided into @xmath12 disjoint rectangular regions , where @xmath12 is the number o active threads , see fig .",
    "[ fig : posix_div ] .        at each time",
    "step the threads must be synchronized to prevent them doing the motion and scattering steps at the same time . to this end",
    "each thread performs the motion step in its region , processing the rows from top to bottom and writing the results to the auxiliary array .",
    "synchronization is achieved by two barriers , one just before the last row in the region is processed and the other one between the motion and scattering steps .",
    "no data exchange between different threads is required .",
    "implementation of the motion step performed by individual threads was optimized with avx to exploit the fact that 256-bit avx registers allow to load and store the data as well as execute instructions for @xmath13 nodes concurrently .",
    "the details are shown in listing [ code : avx ] .",
    "first , the data from 32 subsequent nodes are load into an avx register .",
    "next , for @xmath14 the implementation verifies whether the @xmath15-th bit at a given node is set and if so , sets the @xmath15-th bit in the appropriate neighboring node .",
    "these tasks are achieved with boolean and and or operations performed in avx registers , taking into account that positions of neighbors of a given node depend on whether this node belongs to an even or odd row , see fig .",
    "[ fig : lattice_mem]b . finally , positions of the particles at rest must also be updated .",
    "note that thanks to the avx , all these actions are performed simultaneously on 32 lattice nodes .    .... # define pos(i , j )   i*width + j //loop over lattice nodes assigned for //the current thread for(j = start;j <",
    "end;j++ ) {    for(i=1 ; i <",
    "w-1;i+=32 )    {      //read data      valv = ( _ _ m256i*)(lattice0+pos(i , j ) ) ;      _ _ m256i br = _",
    "mm256_loadu_si256(valv ) ;        //distribute data over neighboring nodes",
    "for(k=0;k<=6;k++ )      {        maskv = _ mm256_set1_epi8(mask1[k ] ) ;        ar     = ( _ _ m256i)_mm256_and_pd((__m256d)br,\\                ( _ _ m256d)maskv ) ;          //determine neighbor positions        e1 = i+e[k][j&1][0 ] ;        e2 = j+e[k][j&1][1 ] ;          valp = ( _ _ m256i*)(lattice1+pos(e1,e2 ) ) ;        _ _ m256i cr = _",
    "mm256_loadu_si256(valp ) ;        ar = ( _ _ m256i)_mm256_or_pd((__m256d)cr,\\             ( _ _ m256d)ar ) ;          //store data in destination nodes        _ mm256_storeu_si256(valp , ar ) ;      }      //update rest particles      br = ( _ _ m256i)_mm256_and_pd((__m256d)br,\\           ( _ _ m256d)maskv2 ) ;        _ mm256_storeu_si256(valv , br ) ;    } } ....    the sse implementation is very similar to the avx one .",
    "the main difference is that sse uses 128-bit registers , so that only 16 fhp nodes can be processed at the same time by an sse unit .",
    "c for cuda is a programming language from nvidia corporation for programming their graphics cards .",
    "it is a minimal extension to the standard c language that enables to run and synchronize thousands of gpu threads running in parallel . in this programming model ,",
    "a gpu device is a coprocessor running kernels asynchronously with the host cpu .",
    "the main task of the cpu is to transfer data to the gpu , launch gpu computational kernels in a given order , and read the results from the gpu .",
    "the main difference in programming gpus and cpus is that the gpu exposes to the programmer its hierarchical memory system .",
    "thus , it is the programmer s responsibility to manage data allocation in appropriate gpu memory pools , to manage transfers of the data within the same or between different memory pools , to synchronize thread execution and their accesses to the memory , and to avoid race conditions or deadlocks .",
    "this can be a quite nontrivial task , as different memory pools , such as registers , shared memory , caches , read - only buffers , and the global memory differ significantly in their size , speed and connectivity to gpu resources .",
    "it is in sharp contrast to the standard cpu programming model , where the memory is assumed to be linear and uniform , and the computational performance on the instruction level is managed in hardware .",
    "gpu threads are arranged into blocks .",
    "threads within a block can communicate with each other via fast , on - chip shared memory and can be synchronized .",
    "however , as the order in which blocks are launched is undefined , it is not possible to synchronize threads in different blocks . therefore perhaps the single most important step in gpu programming partitioning of the computational kernel into blocks of threads , assignment of work to individual threads and management of inter - thread communication .",
    "the simplest approach consists in dividing the fhp lattice into disjoint rectangles , as shown in fig .",
    "[ fig : podzial1 ] , and assigning a node to a single thread .",
    "this approach works well in the scattering step , because each node can be processed independently of each other by applying the collision rules defined in the look - up table and no communication between threads or blocks of threads is required .",
    "there are also no memory conflicts , as the read and write operations to and from the global memory are executed only once per a node .",
    "however , such definition of computational blocks will not work well for the move step , as propagation of particles would require communication and synchronization between different blocks .",
    "as this is impossible , the only solution would be to us the global memory to store the data that would have to be communicated to neighboring blocks of threads and use it in another kernel to complete the move step .",
    "such a solution would be , however , complicated and inefficient .",
    "this problem can be solved by overlapping blocks , as depicted in fig .",
    "[ fig : podzial2 ] .    , scaledwidth=40.0% ]    as illustrated in fig .",
    "[ fig : abc ] , a block of threads defines three rectangles , @xmath16 , @xmath17 and @xmath18 .",
    "rectangles marked as @xmath17 divide the lattice into disjoint parts , like in fig .",
    "[ fig : podzial1 ] .",
    "they are embraced by rectangles @xmath16 corresponding to the blocks of threads .",
    "rectangles @xmath16 , in turn , are embraced by rectangles @xmath18 corresponding to array elements in the shared memory .",
    "note that within this approach each fhp node is updated exactly once ( rectangle @xmath17 ) , states of some nodes are read by 2 , 3 , or even 4 different blocks ( rectangle @xmath16 ) , and the size of the array in the shared memory is larger than the block size ( rectangle @xmath18 ) .",
    "just as in the cpu implementation , a race condition is using different arrays for reading and writing the data .",
    "is used as a buffer to capture the particles moving out of a. rectangle @xmath19 denotes the nodes whose updated states will be saved back to the main memory .",
    "colors correspond to those in fig .",
    "[ fig : podzial2 ] .",
    ", scaledwidth=40.0% ]",
    "the avx implementation was tested on intel i7  960 and two server - class intel xeon e3 and e5 processors .",
    "the cuda implementation was tested on server - class nvidia tesla m2075 computing devices and on a high - end consumer graphics card , nvidia geforce gtx  480 .",
    "since xeon e5 was tested in a 4-processor configuration , we also investigated a system with two gpus connected by a pci - express switch . also , we tested gpus in two modes : one with error control and correction ( ecc ) turned on and the other with ecc off .",
    "the latter mode is expected to yield @xmath20 12% faster access to the gpu memory .",
    "the operating system was a 64-bit linux and the cuda version was 4.2 .",
    "the fhp lattice sizes used in simulations were restricted by the size of available memory and amounted to @xmath21 ( @xmath22 nodes ) and @xmath23 ( @xmath24 nodes ) for the gpu and cpu versions , respectively .",
    "the computational efficiency of each implementation was measured in million lattice site updates per second ( mups ) .",
    "we also investigated the economic aspects of the simulations , calculating the hardware purchase cost and electric power usage per mups .",
    "the cost of hardware components ( in usd ) was taken as a market price in july 2012 .",
    "for the gpus the cost includes the cost of purchasing or running corresponding cpus .",
    "the power consumption was taken as the nominal values declared by the producers .",
    "the main results are shown in table [ tab : tabelka ] . in subsequent columns",
    "it contains the information on the algorithm used , processor , number of cpu cores used , number of cpu threads ( which is twice the number of cores if the intel hyperthreading technology is used ) , computational efficiency in mups , economic efficiency in usd / mups and watt / mups .",
    "one thing that strikes in these results is that the extent to which the computational efficiency depends on the parallelization method . even if only one core is used , the program parallelized with sse or avx can run 3 times faster than its purely sequential counterpart .",
    "using all available cores usually gives even better acceleration , and the best results are obtained when all parallelization methods are used .",
    "particularly interesting conclusions can be derived from the results for the xeon e3 processor .",
    "while avx can accelerate the sequential code by 3 times , posix threads on 4 cores and 8 threads accelerate the sequential code by 5.3 times , implying a superlinear dependency on the number of cores .",
    "interestingly , a similar superlinear behavior is observed for i7 , for which hyperthreading was turned off .",
    "when combining threads with avx , the efficiency increases by 3.4 times relative to threads - accelerated code and 18,2 times relative to the sequential code .",
    "interestingly , in all cases avx overtakes its predecessor , sse , by only @xmath25 .",
    "note also that in all cases failing to use sse or avx results in underutilization of the computer resources by a factor of about 2 to 3 .",
    "an interesting aspect of the multi - gpu system its practically linear scaling with the number of gpus .",
    "this indicates that the fhp model can be efficiently simulated on larger gpu clusters .",
    ".main results .",
    "[ cols=\"^,^ , > , > , > , > , > \" , ]     the highest computational efficiency was found for a high - end gaming gpu , gtx480 .",
    "this is related to the fact that it is equipped with the fastest memory , which is the key factor in the fhp modeling , since fhp is a memory - bound algorithm .",
    "however , the difference between gtx480 and xeon e5 is only 20% , and the latter platform turns out even faster than the server - class tesla m2075 . however , one should take into account that xeon e5 is an 8-core processor and we tested it on 2- and 4-processor systems .",
    "a processor - for - processor comparison reveals superiority of gpus , with a single m2075 being about 2 times faster than a single xeon e5 .",
    "this value is in accord with other reports on the acceleration a gpu can deliver over well - tuned cpu code @xcite .",
    "figure [ fig : histogram2 ] shows the acceleration obtained on various processors using different parallelization techniques .     ,",
    "scaledwidth=40.0% ]    the highest value , almost 50 , is found for the gtx  480 graphics card .",
    "note however , that a well - optimized code on the same cpu platform is almost 20 times faster than the sequential code , and the acceleration on the e5 reaches 40 times .",
    "thus , it is not the architecture of the gpus that results in reports of it being tens , hundreds or thousands of times faster than the cpus , but the fact that this architecture enforces from the very beginning a very high level of parallelization on all levels . in a code",
    "utilizing all ways of cpu parallelization , the gpu over cpu speedup drops below 10 , in accordance with the hardware capabilities of the devices under comparison .",
    "results for the economic aspects of running fhp simulations on different platforms are shown in fig .",
    "[ fig : histogram1 ] .",
    "it turns out that the most cost and power efficient processor is e3 , but only if the program running on it was parallelized with the sse or avx technology .     ,",
    "we investigated several methods of fine - grained parallelization of the fhp cellular automata model .",
    "we found that using sse or avx vector instructions in the cpu code can accelerate a single - thread program by a factor of about 3 , and combining this technique with posix threads yields acceleration from 12 to 18 times .    while the most computationally efficient solution was found to run the simulation on gpus , which turned out up to about 2 times faster than the most efficient single - processor cpu",
    ", cpus turned out cheaper to buy and cheaper to run , but only if they exploited the sse or avx technology .",
    "however , our results are based on some _ ad hoc _ assumptions , so that they can not be used to decide which architecture is superior for cellular automata simulations . first , it is possible that each of our implementations could be further improved .",
    "second , calculation of the electric power efficiency for the gpus includes the power drawn by the cpu and one could argue that this overestimates real costs , as only one cpu core is occupied by the gpu , and up to 8 gpus can be attached to a single cpu using pci - express switches .",
    "third , while our tests included one of the newest intel processors , xeon e5 , the gpus used in this study belong to a relatively old fermi architecture and one can expect that new gpu processors , especially tesla k10 , should reduce the power consumption by at least a factor of 2 .    in spite of these difficulties we can conclude that as far as cellular automata simulations are concerned : ( a ) using avx or sse is necessary to fully utilize the potential of modern cpus ; ( b ) cpus and gpus are comparable in terms of computational and economic efficiency ; and ( c ) avx does not offer any substantial improvement relative to sse .",
    "ss prepared this publication as part of the prace 2ip project receiving funding from the eu s seventh framework programme ( fp7/2007 - 2013 ) .",
    "zk acknowledges support from polish ministry of science and higher education grant no .",
    "n n519 437939 .",
    "calculations have been carried out in wroclaw centre for networking and supercomputing ( http://www.wcss.wroc.pl ) ."
  ],
  "abstract_text": [
    "<S> we investigated various methods of parallelization of the frish - hasslacher - pomeau ( fhp ) cellular automata algorithm for modeling fluid flow . </S>",
    "<S> these methods include sse , avx , and posix threads for central processing units ( cpus ) and cuda for graphics processing units ( gpus ) . </S>",
    "<S> we present implementation details of the fhp algorithm based on avx / sse and cuda technologies . </S>",
    "<S> we found that ( a ) using avx or sse is necessary to fully utilize the potential of modern cpus ; ( b ) cpus and gpus are comparable in terms of computational and economic efficiency only if the cpu code uses avx or sse instructions ; ( c ) avx does not offer any substantial improvement relative to sse . </S>"
  ]
}