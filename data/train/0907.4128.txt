{
  "article_text": [
    "we study variants of relativized hyperequivalence that are relevant for the development and analysis of disjunctive logic programs with modular structure .",
    "our main results concern the complexity of deciding relativized hyperequivalence for the three major semantics of logic programs given by stable , supported and supported minimal models .",
    "_ logic programming _ with the semantics of stable models , nowadays often referred to as _ answer - set programming _",
    ", is a computational paradigm for knowledge representation , as well as modeling and solving constraint problems @xcite . in recent years , it has been steadily attracting more attention .",
    "one reason is that answer - set programming is truly declarative . unlike in , say , prolog ,",
    "the order of rules in programs and the order of literals in rules have no effect on the meaning of the program .",
    "secondly , the efficiency of the latest tools for processing programs , especially solvers , reached the level that makes it feasible to use them for problems of practical importance @xcite .",
    "it is broadly recognized in software engineering that modular programs are easier to design , analyze and implement .",
    "hence , essentially all programming languages and environments support the development of modular programs .",
    "accordingly , there has been much work recently to establish foundations of _ modular _ answer - set programming .",
    "one line of investigations has focused on the notion of an answer - set program _ module _ @xcite .",
    "this work builds on ideas for compositional semantics of logic programs proposed by and encompasses earlier results on stratification and _ program splitting _",
    "@xcite .",
    "the other main line of research , to which our paper belongs , has centered on program equivalence and , especially , on the concept of equivalence for substitution .",
    "programs @xmath0 and @xmath1 are _ equivalent for substitution _ with respect to a class @xmath2 of programs called _ contexts _ , if for every context @xmath3 , @xmath4 and @xmath5 have the same stable models .",
    "thus , if a logic program is the union of programs @xmath0 and @xmath6 , where @xmath7 , then @xmath0 can be replaced with @xmath1 , with the guarantee that the semantics is preserved no matter what @xmath6 is ( as long as it is in @xmath2 ) precisely when @xmath0 and @xmath1 are equivalent for substitution with respect to @xmath2 . if @xmath2 contains the empty program ( which is typically the case and , in particular , is the case for the families of programs we consider in the paper ) , the equivalence for substitution with respect to @xmath2 implies the standard equivalence under the stable - model semantics . _",
    "the converse is not true_. we refer to these stronger forms of equivalence collectively as _",
    "hyperequivalence_.    hyperequivalence with respect to the class of _ all _ programs , known more commonly as _",
    "strong equivalence _ , was proposed and studied by . that work prompted extensive investigations of the concept that resulted in new characterizations @xcite and connections to certain non - standard logics @xcite .",
    "hyperequivalence with respect to contexts consisting of facts was studied by .",
    "this version of hyperequivalence , known as _ uniform equivalence _ , appeared first in the database area in the setting of datalog and query equivalence  @xcite .",
    "hyperequivalence with respect to contexts restricted to a given alphabet , or _",
    "relativized _ hyperequivalence , was proposed by and .",
    "both uniform equivalence and relativized hyperequivalence were analyzed in depth by , and later generalized by woltran  @xcite to allow contexts that use ( possibly ) different alphabets for the heads and bodies of rules .",
    "that approach offers a unifying framework for strong and uniform equivalence .",
    "hyperequivalence , in which one compares projections of answer sets on some designated sets of atoms rather than entire answer sets has also received some attention @xcite .",
    "all those results concern the stable - model semantics of programs .",
    "there has been little work on other semantics , with the work by long being a notable single exception . recently however",
    ", introduced and investigated relativized hyperequivalence of programs under the semantics of supported models @xcite and supported minimal models , two other major semantics of logic programs . characterized these variants of hyperequivalence and established the complexity of some associated decision problems .    in this paper , we continue research of relativized hyperequivalence under all three major semantics of logic programs . as in earlier works @xcite , we focus on contexts of the form @xmath8 , where @xmath8 stands for the set of all programs that use atoms from @xmath9 in the heads and atoms from @xmath10 in the bodies of rules .",
    "our main goal is to establish the complexity of deciding whether two programs are hyperequivalent ( relative to a specified semantics ) with respect to @xmath8 .",
    "we consider the cases when @xmath9 and @xmath10 are either specified directly or in terms of their complement . as we point out in the following section ,",
    "such contexts arise naturally when we design modular logic programs .",
    "we postpone technical preliminaries to the following section . for the sake of the present section it is enough to say that we focus our study on finite propositional programs over a fixed countable infinite set @xmath11 of atoms .",
    "it is also necessary to introduce one piece of notation : @xmath12 .    to argue that contexts specified in terms of the complement of a finite set are of interest ,",
    "let us consider the following scenario .",
    "a logic program is _ @xmath9-defining _ if it specifies the definitions of atoms in @xmath9 .",
    "the definitions may be recursive , they may involve _ interface _ atoms , that is , atoms defined in other modules ( such atoms facilitate importing information form other modules , hence the term `` interface '' ) , as well as atoms used locally to represent some needed auxiliary concepts .",
    "let @xmath0 be a particular @xmath9-defining program with @xmath13 as the set of its local atoms .",
    "for @xmath0 to behave properly when combined with other programs , these `` context '' programs must not have any occurrences of atoms from @xmath13 and must have no atoms from @xmath9 in the heads of their rules . in our terminology , these are precisely programs in @xmath14.-defining programs were introduced by .",
    "however , that work considered more restricted classes of programs with which @xmath9-defining programs could be combined . ]",
    "the definitions of atoms in @xmath9 can in general be captured by several different @xmath9-defining programs . a key question concerning such programs",
    "is whether they are equivalent .",
    "clearly , two @xmath9-defining programs @xmath0 and @xmath1 , both using atoms from @xmath13 to represent local auxiliary concepts , should be regarded as equivalent if they behave in the same way in the context of any program from @xmath14 . in other words , the notion of equivalence appropriate in our setting is that of hyperequivalence with respect to @xmath14 under a selected semantics ( stable , supported or supported - minimal ) .",
    "let us assume that @xmath15 and that @xmath16 and @xmath17 are interface atoms ( atoms defined elsewhere ) .",
    "we need a module that works as follows :    1 .",
    "if @xmath16 and @xmath17 are both true , exactly one of @xmath18 and @xmath19 must be true 2 .",
    "if @xmath16 is true and @xmath17 is false , only @xmath18 must be true 3 .",
    "if @xmath17 is true and @xmath16 is false , only @xmath19 must be true 4 .",
    "if @xmath16 and @xmath17 are both false , @xmath18 and @xmath19 must be false .",
    "we point out that @xmath16 and @xmath17 may depend on @xmath18 and @xmath19 and so , in some cases the overall program may have no models of a particular type ( to be concrete , for a time being we fix attention to stable models ) .    one way to express the conditions ( 1 ) - ( 4 ) is by means of the following @xmath20-defining program @xmath0 ( in this example we assume that @xmath20-defining programs do not use local atoms , that is , @xmath21 ) : @xmath22 + @xmath23 .",
    "combining @xmath0 with programs that specify facts : @xmath24 , @xmath25 , @xmath26 and @xmath27 , it is easy to see that @xmath0 behaves as required .",
    "for instance , @xmath28 has exactly one stable model @xmath29 .",
    "however , @xmath0 may also be combined with more complex programs .",
    "for instance , let us consider the program @xmath30 . here , @xmath17 can only be true if @xmath18 is true and @xmath16 is false , which is impossible given the way @xmath18 is defined .",
    "thus , @xmath17 must be false and @xmath16 must be true . according to the specifications",
    ", there should be exactly one stable model for @xmath4 in this case : @xmath31 .",
    "it is easy to verify that it is indeed the case .",
    "the specifications for @xmath18 and @xmath19 can also be expressed by other @xmath20-defining programs , in particular , by the following program @xmath1 : @xmath32 + @xmath33 + @xmath34 + @xmath35 .",
    "the question arises whether @xmath1 behaves in the same way as @xmath0 relative to programs from @xmath36 . for all contexts considered earlier ,",
    "it is the case .",
    "however , in general , it is not so .",
    "for instance , if @xmath37 then , @xmath31 is a stable model of @xmath4 , while @xmath5 has no stable models .",
    "thus , @xmath0 and @xmath1 can not be viewed as equivalent @xmath20-defining programs .",
    "a similar scenario gives rise to a different class of contexts .",
    "we call a program @xmath0 _ @xmath9-completing _ if it completes partial and non - recursive definitions of atoms in @xmath9 given by other modules which , for instance , might specify the base conditions for a recursive definition of atoms in @xmath9 .",
    "any program with all atoms in the heads of rules in @xmath9 can be regarded as an @xmath9-completing program . assuming that @xmath0 is an @xmath9-completing program ( again with @xmath13 as a set of local atoms ) , @xmath0 can be combined with any program @xmath6 that has no occurrences of atoms from @xmath13 and no occurrences of atoms from @xmath9 in the bodies of its rules .",
    "however , atoms from @xmath9 may occur in the heads of rules from @xmath6 , which constitute a partial , non - recursive part of the definition of @xmath9 , `` completed '' by @xmath0 . such programs @xmath6 form precisely the class @xmath38 .",
    "finally , let us consider a situation where we are to express partial problem specifications as a logic program .",
    "in that program , we need to use concepts represented by atoms from some set @xmath9 that are defined elsewhere in terms of concepts described by atoms from some set @xmath10 . here",
    "two programs @xmath0 and @xmath1 expressing these partial specifications can serve as each other s substitute precisely when they are hyperequivalent with respect to the class of programs @xmath8 .",
    "these examples demonstrate that hyperequivalence with respect to context classes @xmath8 , where @xmath9 and @xmath10 are either specified directly or in terms of their complement is of interest .",
    "our goal is to study the complexity of deciding whether two programs are hyperequivalent relative to such classes of contexts .",
    "* basic logic programming notation and definitions . * we recall that we consider a fixed countable infinite set of propositional atoms @xmath11 .",
    "_ disjunctive logic programs _ ( programs , for short ) are finite sets of ( program ) _ rules _  expressions of the form @xmath39 where @xmath40 , @xmath41 and @xmath42 are atoms in @xmath11 , ` @xmath43 ' stands for the disjunction , ` , ' stands for the conjunction , and @xmath44 is the _ default _ negation . if @xmath45 , the rule is a _",
    "constraint_. if @xmath46 , the rule is _",
    "normal_. programs consisting of normal rules are called _",
    "normal_. we often write the rule ( [ eqa ] ) as @xmath47 , where @xmath48 , @xmath49 and @xmath50 .",
    "we call @xmath51 the _ head _ of the rule , and the conjunction @xmath52 , the _ body _ of the rule . the sets @xmath53 and @xmath54 form the positive and negative body of the rule . given a rule @xmath55 , we write @xmath56 , @xmath57 , @xmath58 and @xmath59 to denote the head , the body , the positive body and the negative body of @xmath55 , respectively . for a program @xmath0 , we set @xmath60 , @xmath61 , and @xmath62 .    for an interpretation @xmath63 and a rule @xmath55 ,",
    "we define entailments @xmath64 , @xmath65 and @xmath66 in the standard way .",
    "that is , @xmath64 , if jointly @xmath67 and @xmath68 ; @xmath65 , if @xmath69 ; and @xmath66 , if @xmath64 implies @xmath65 .",
    "an interpretation @xmath63 is a _ model _ of a program @xmath0 ( @xmath70 ) , if @xmath66 for every @xmath71 .",
    "the _ reduct _ of a disjunctive logic program @xmath0 with respect to a set @xmath72 of atoms , denoted by @xmath73 , is the program @xmath74 .",
    "a set @xmath72 of atoms is a _ stable model _ of @xmath0 if @xmath72 is a minimal model ( with respect to inclusion ) of @xmath73 .",
    "if a set @xmath72 of atoms is a minimal hitting set of @xmath75 , then @xmath72 is called a _ supported model _ of @xmath0 @xcite .",
    "is a _ hitting _ set for a family @xmath76 of sets if for every @xmath77 , @xmath78 . ] in addition , @xmath72 is called a _ supported minimal model _ of @xmath0 if it is a supported model of @xmath0 and a minimal model of @xmath0 .",
    "one can check that supported models of @xmath0 are indeed models of @xmath0 .",
    "a stable model of a program is a supported model of the program and a minimal model of the program .",
    "thus , a stable model of a program is a supported minimal model of the program .",
    "however , the converse does not hold in general . supported models of a _",
    "normal _ logic program @xmath0 have a useful characterization in terms of the ( partial ) one - step provability operator @xmath79 , defined as follows . for @xmath80 , if there is a constraint @xmath71 such that @xmath81 ( that is , @xmath82 ) , then @xmath83 is undefined .",
    "otherwise , @xmath84 whenever we use @xmath83 in a relation such as ( proper ) inclusion , equality or inequality , we always implicitly assume that @xmath83 is defined .",
    "it is well known that @xmath72 is a model of @xmath0 if and only if @xmath85 ( which , according to our convention , is an abbreviation for : @xmath79 is defined for @xmath72 and @xmath86 ) .",
    "similarly , @xmath72 is a _ supported _ model of @xmath0 if @xmath87 @xcite ( that is , if @xmath79 is defined for @xmath72 and @xmath88 ) .    for a rule @xmath89 , where @xmath90 , a _ shift _ of @xmath55 is a normal program rule of the form @xmath91 where @xmath92 .",
    "if @xmath55 is normal , the only _ shift _ of @xmath55 is @xmath55 itself .",
    "a program consisting of all shifts of rules in a program @xmath0 is the _ shift _ of @xmath0 .",
    "we denote it by @xmath93 .",
    "it is evident that a set @xmath72 of atoms is a ( minimal ) model of @xmath0 if and only if @xmath72 is a ( minimal ) model of @xmath93 .",
    "it is easy to check that @xmath72 is a supported ( minimal ) model of @xmath0 if and only if it is a supported ( minimal ) model of @xmath93 .",
    "moreover , @xmath72 is a supported model of @xmath0 if and only if @xmath94 .",
    "* characterizations of hyperequivalence of programs .",
    "* let @xmath2 be a class of ( disjunctive ) logic programs .",
    "programs @xmath0 and @xmath1 are _ supp - equivalent _ ( _ suppmin - equivalent _ , _ stable - equivalent _ , respectively ) relative to @xmath2 if for every program @xmath95 , @xmath4 and @xmath5 have the same supported ( supported minimal , stable , respectively ) models .    in this paper , we are interested in equivalence of all three types relative to classes of programs defined by the _ head _ and _ body alphabets_. let @xmath96 . by @xmath8",
    "we denote the class of all programs @xmath0 such that @xmath97 and @xmath98 .",
    "clearly , @xmath99 holds , for arbitrary @xmath100 .",
    "thus , as we noted in the introduction , for each of the semantics and every sets @xmath9 and @xmath10 , the corresponding hyperequivalence implies the standard equivalence with respect to that semantics .",
    "when studying supp- and suppmin - equivalence we will restrict ourselves to the case of normal programs . indeed , disjunctive programs @xmath0 and @xmath1 are supp - equivalent ( suppmin - equivalent , respectively ) with respect to @xmath8 if and only if normal programs @xmath93 and @xmath101 are supp - equivalent ( suppmin - equivalent , respectively ) with respect to @xmath8 @xcite .",
    "thus , from now on whenever we consider supp- and suppmin - equivalence , we implicitly assume that programs under comparison are normal .",
    "in particular , we use that convention in the definition below and the subsequent theorem .    for supp - equivalence and suppmin - equivalence ,",
    "we need the set @xmath102 , defined by . given a program @xmath0 , and a set @xmath103 , @xmath104 explain that elements of @xmath102 can be viewed as _ candidates _ for becoming supported models of an extension of @xmath0 by some program @xmath105 .",
    "indeed , each such candidate interpretation @xmath106 has to be a classical model of @xmath0 , as otherwise it can not be a supported model , no matter how @xmath0 is extended .",
    "moreover , the elements from @xmath107 have to be contained in @xmath9 , as otherwise programs from @xmath8 can not close this gap .",
    "the set @xmath102 is the key to the characterization of supp - equivalence .",
    "[ nlp1 ] let @xmath0 and @xmath1 be programs , @xmath108 , and @xmath109 a class of programs such that @xmath110 .",
    "then , @xmath0 and @xmath1 are supp - equivalent relative to @xmath2 if and only if @xmath111 and for every @xmath112 , @xmath113 .",
    "to characterize suppmin - equivalence , we use the set @xmath114 @xcite , which consists of all pairs @xmath115 such that    1 .",
    "@xmath112 2 .",
    "@xmath116 3 .   for each @xmath117",
    "such that @xmath118 , @xmath119 4 .   for each @xmath117",
    "such that @xmath120 and @xmath121 , @xmath119 5 .   if @xmath122 , then @xmath123 .",
    "[ thm : general ] let @xmath100 and let @xmath124 be programs .",
    "then , @xmath0 and @xmath1 are suppmin - equivalent relative to @xmath8 if and only if @xmath125 and for every @xmath126 , @xmath127 .",
    "relativized stable - equivalence of programs was characterized by .",
    "we define @xmath128 to consist of all pairs @xmath115 , where @xmath129 , such that :    1 .",
    "@xmath130 2 .",
    "@xmath131 , or jointly @xmath116 and @xmath132 3 .   for each @xmath117 such that @xmath133 , @xmath134 4 .   for each @xmath117 such that @xmath135 and @xmath136 , or @xmath137 and @xmath138 , @xmath134 5",
    "there is @xmath139 such that @xmath140 and @xmath141 .",
    "[ thm : stable ] let @xmath100 and let @xmath124 be programs",
    ". then , @xmath0 and @xmath1 are stable - equivalent relative to @xmath8 if and only if @xmath142 .",
    "* decision problems .",
    "* we are interested in problems of deciding hyperequivalence relative to classes of programs of the form @xmath143 , where @xmath144 and @xmath145 stand either for finite sets or for complements of finite sets . in the former case , the set is given _",
    "directly_. in the latter , it is specified by means of its finite _",
    "complement_. thus , we obtain the classes of _ direct - direct _ , _ direct - complement _ , _ complement - direct _ and _ complement - complement _ decision problems .",
    "we denote them using strings of the form @xmath146 , where    1 .",
    "@xmath147 stands for @xmath148 , @xmath149 or @xmath150 and identifies the semantics relative to which we define hyperequivalence ; 2 .",
    "@xmath151 and @xmath152 stand for @xmath17 or @xmath16 ( direct and complement , respectively ) , and specify one of the four classes of problems mentioned above ; 3 .",
    "@xmath153 is either @xmath154 or @xmath9 , where @xmath103 is finite . if @xmath155 , then @xmath153 specifies a _ fixed _",
    "alphabet for the heads of rules in context programs : either @xmath9 or the complement @xmath156 of @xmath9 , depending on whether @xmath157 or @xmath16 .",
    "the parameter @xmath9 does not belong to and does not vary with input . if @xmath158 , then the specification @xmath9 of the head alphabet is part of the input and defines it as @xmath9 or @xmath156 , again according to @xmath151 ; 4 .",
    "@xmath159 is either @xmath154 or @xmath10 , where @xmath160 is finite .",
    "it obeys the same conventions as @xmath153 but defines the body alphabet according to the value of @xmath152 .",
    "for instance , @xmath161 , where @xmath103 is finite , stands for the following problem : given programs @xmath0 and @xmath1 , and a set @xmath10 , decide whether @xmath0 and @xmath1 are suppmin - equivalent with respect to @xmath162 .",
    "similarly , @xmath163 denotes the following problem : given programs @xmath0 and @xmath1 , and sets @xmath9 and @xmath10 , decide whether @xmath0 and @xmath1 are stable - equivalent with respect to @xmath164 . with some abuse of notation ,",
    "we often talk about `` the problem @xmath165 '' as a shorthand for `` an arbitrary problem of the form @xmath165 with fixed finite sets @xmath9 and @xmath10 '' ; likewise we do so for @xmath166 and @xmath167 .",
    "as we noted , for supp- and suppmin - equivalence , there is no essential difference between normal and disjunctive programs .",
    "for stable - equivalence , allowing disjunctions in the heads of rules affects the complexity .",
    "thus , in the case of stable - equivalence , we distinguish versions of the problems @xmath168 , where the input programs are normal .",
    "we denote these problems by @xmath169 .",
    "direct - direct problems for the semantics of supported and supported minimal models were considered earlier @xcite , and their complexity was fully determined there .",
    "the complexity of problems @xmath170 , was also established before @xcite .",
    "problems similar to @xmath171 were already studied by . in this paper , we complete the results on the complexity of problems @xmath146 for all three semantics . in particular , we establish the complexity of the problems with at least one of @xmath151 and @xmath152 being equal to @xmath16 .",
    "the complexity of problems involving the complement of @xmath9 or @xmath10 is not a straightforward consequence of the results on direct - direct problems . in the direct - direct problems ,",
    "the class of context programs is essentially finite , as the head and body alphabets for rules are finite .",
    "it is no longer the case for the three remaining problems , where at least one of the alphabets is infinite and so , the class of contexts is infinite , as well .",
    "we note that when we change @xmath9 or @xmath10 to @xmath154 in the problem specification , the resulting problem is at least as hard as the original one .",
    "indeed for each such pair of problems , there are straightforward polynomial - time reductions from one to the other .",
    "we illustrate these relationships in figure  [ fig1 ] .",
    "each arrow indicates that the `` arrowtail '' problem can be reduced in polynomial time to the `` arrowhead '' one .",
    "consequently , if there is a path from a problem @xmath172 to the problem @xmath173 in the diagram , @xmath173 is at least as hard as @xmath172 and @xmath172 is at most as hard as @xmath173 .",
    "we use this observation in proofs of all complexity results .",
    "finally , we note that throughout the paper , we write @xmath174 instead of the more common p to denote the class of all problems that can be solved by deterministic polynomial - time algorithms .",
    "as decision problems we consider typically refer to a program @xmath0 , we want to avoid the ambiguity of using the same symbol in two different meanings .",
    "as the alphabet for the bodies of context programs plays no role in supp - equivalence ( cf .  theorem  [ nlp1 ] ) ,",
    "the problems @xmath175 and @xmath176 coincide with the problems @xmath177 and @xmath178 , respectively , whose complexity was shown to be conp - complete @xcite .",
    "for the same reason , problems @xmath179 and @xmath180 coincide with @xmath181 and @xmath182 .",
    "thus , to complete the complexity picture for problems @xmath183 , it suffices to focus on @xmath179 and @xmath180 .",
    "first , we prove an upper bound on the complexity of the problem @xmath184 .",
    "the proof depends on two lemmas .",
    "[ newlemma1 ] let @xmath0 be a program and @xmath9 and @xmath106 sets of atoms .",
    "then , @xmath185 if and only if @xmath186 , where @xmath187 .",
    "first , we note that atoms that do not occur in @xmath0 have no effect on whether an interpretation satisfies the body of a rule in @xmath0 .",
    "thus , @xmath188 . if @xmath189 , then @xmath130 and @xmath190 .",
    "the former property implies that @xmath191 ( as before , atoms that do not occur in @xmath0 have no effect on whether an interpretation is a model of @xmath0 or not ) . since @xmath192",
    ", the latter one implies that @xmath193 .",
    "thus , @xmath194 .    conversely , let @xmath194 .",
    "then @xmath191 and , consequently , @xmath130 ( by the comment made above ) .",
    "moreover , we also have @xmath195 .",
    "let @xmath196 . if @xmath197 then , as @xmath198 and @xmath187 , @xmath199 , that is , @xmath200 . if @xmath201 , then @xmath202 ( we recall that @xmath188 ) . hence , @xmath200 in this case , too .",
    "it follows that @xmath190 and so , @xmath189 .",
    "[ newlemma2 ] let @xmath0 and @xmath1 be programs and @xmath9 a set of atoms . then , @xmath203 or , for some @xmath189 , @xmath204 if and only if there is @xmath205 such that @xmath206 belongs to exactly one of @xmath207 and @xmath208 , or @xmath206 belongs to both @xmath207 and @xmath208 and @xmath209 .",
    "clearly , we only need to prove the `` only - if '' implication . to this end",
    ", we note that if @xmath210 , then by lemma [ newlemma1 ] , there is @xmath211 with that property .",
    "thus , let us assume that @xmath212 .",
    "if for some @xmath189 , @xmath204 then again by the argument given above , @xmath213 belongs to both @xmath207 and @xmath208 , and @xmath214 .",
    "[ m - revsupp ] the problem @xmath184 is in the class conp .    _",
    "proof _ + it is sufficient to show that @xmath215 is in conp , since @xmath216 is a yes instance of @xmath215 if and only if @xmath217 is a yes instance of @xmath184 ( cf .",
    "theorem  [ nlp1 ] ) .",
    "thus , we will now focus on proving that @xmath215 is in conp .",
    "theorem [ nlp1 ] and lemma [ newlemma2 ] imply the correctness of the following algorithm to decide the complementary problem to @xmath215 for an instance @xmath216 :    1 .",
    "nondeterministically guess @xmath218 , and 2 .",
    "verify that @xmath106 belongs to exactly one of @xmath207 and @xmath208 , or that @xmath106 belongs to @xmath207 and @xmath208 , and that @xmath204 .",
    "checking @xmath130 and @xmath219 can be done in polynomial time ( in the size of the input , which is given by @xmath220 ) .",
    "similarly , for @xmath221 or @xmath1 , @xmath222 if and only if @xmath223 .",
    "thus , checking @xmath224 can be done in polynomial time , too , and so the algorithm runs in polynomial time .",
    "hence , the complementary problem to @xmath215 is in np .",
    "it follows that the problem @xmath215 is in conp and so , the assertion follows .    for the lower",
    "bound we use the problem @xmath225 .",
    "let us comment that the reduction , from the satisfiability problem to @xmath225 , used in the following hardness proof , is indeed computable in polynomial time .",
    "the same is true for the reductions used in all other places in the paper . in each case , the polynomial - time computability of the reductions is evident , and we do not state it explicitly in the proofs .",
    "[ h - revsupp ] the problem @xmath225 is conp - hard .",
    "let us consider a cnf formula @xmath226 , let @xmath106 be the set of atoms in @xmath226 , and let @xmath227 be a set of new atoms .",
    "we define @xmath228 where , for each clause @xmath229 , say @xmath230 , @xmath231 denotes the the sequence @xmath232 . to simplify the notation",
    ", we write @xmath0 for @xmath233 .",
    "one can check that @xmath226 has a model if and only if @xmath0 has a model .",
    "moreover , for every model @xmath72 of @xmath0 such that @xmath234 , @xmath72 is a _ supported _ model of @xmath0 and , consequently , satisfies @xmath235 .",
    "next , let @xmath1 consist of @xmath236 and @xmath237 .",
    "as @xmath1 has no models , theorem [ nlp1 ] implies that @xmath1 is supp - equivalent to @xmath0 relative to @xmath238 if and only if @xmath239 .",
    "if @xmath240 , then there is @xmath241 such that @xmath242 . since every model @xmath243 of @xmath0 such that @xmath244 satisfies @xmath245 , it follows that @xmath246 if and only if @xmath0 has no models .",
    "thus , @xmath226 is unsatisfiable if and only if @xmath1 is supp - equivalent to @xmath0 relative to @xmath238 , and the assertion follows .",
    "the observations made at the beginning of this section , theorems [ m - revsupp ] and [ h - revsupp ] , and the relations depicted in figure [ fig1 ] imply the following corollary .",
    "[ cor : supp ] the problem @xmath247 is conp - complete , for any combination of @xmath248 , @xmath249 , @xmath250 .",
    "in this section , we establish the complexity for direct - complement , complement - direct and complement - complement problems of deciding suppmin - equivalence . the complexity of direct - direct problems is already known @xcite .",
    "the argument consists of a series of auxiliary results .",
    "the first two lemmas are concerned with the basic problem of deciding whether @xmath251 , where @xmath144 and @xmath145 stand for @xmath9 or @xmath156 and @xmath10 or @xmath252 , respectively .",
    "[ lem : memb1 ] the following problems are in the class conp : given a program @xmath0 , and sets @xmath253 , @xmath106 , @xmath9 , and @xmath10 , decide whether    1 .",
    "@xmath254 ; 2 .",
    "@xmath255 ; 3 .",
    "@xmath256 .",
    "+ we first show that the complementary problem , this is , to decide whether @xmath257 , is in np . to this end",
    ", we observe that @xmath257 if and only if at least one of the following conditions holds :    1 .",
    "@xmath258 , 2 .",
    "@xmath259 , 3 .",
    "there is @xmath260 such that @xmath261 and @xmath262 , 4 .",
    "there is @xmath260 such that @xmath263 , @xmath264 and @xmath262 , 5 .",
    "@xmath122 and @xmath265 .",
    "we note that verifying any condition involving @xmath156 can be reformulated in terms of @xmath9 .",
    "for instance , for every set @xmath266 , we have @xmath267 , and @xmath268 if and only if @xmath269 .",
    "thus , the conditions ( 1 ) , ( 2 ) and ( 5 ) can be decided in polynomial time .",
    "conditions ( 3 ) and ( 4 ) can be decided by a nondeterministic polynomial time algorithm .",
    "indeed , once we nondeterministically guess @xmath270 , all other tests can be decided in polynomial time .",
    "the proofs for the remaining two claims use the same ideas and differ only in technical details depending on which of @xmath9 and @xmath10 is subject to the complement operation .",
    "[ lem : memb2 ] for every finite set @xmath160 , the following problems are in the class @xmath174 : given a program @xmath0 , and sets @xmath253 , @xmath106 , and @xmath9 , decide whether    1 .",
    "@xmath256 ; 2 .",
    "@xmath255 .    in each case",
    ", the argument follows the same lines as that for lemma [ lem : memb1 ] .",
    "the difference is in the case of the conditions ( 3 ) and ( 4 ) . under the assumptions of this lemma",
    ", they can be decided in _",
    "polynomial time .",
    "indeed , let us note that there are no more than @xmath271 sets @xmath270 such that @xmath272 ( or , for the second problem , such that @xmath273 ) .",
    "since @xmath10 is finite , fixed , and not a part of the input , the condition ( 3 ) can be checked in polynomial time by a simple enumeration of all possible sets @xmath270 such that @xmath260 and @xmath272 and checking for each of them whether @xmath262 .",
    "for the condition ( 4 ) , the argument is similar .",
    "since @xmath270 is constrained by @xmath274 , there are no more than @xmath271 possible candidate sets @xmath270 to consider in this case , too .",
    "the role of the next lemma is to show that @xmath275 implies constraints on @xmath253 and @xmath106 .",
    "[ in0 ] let @xmath0 be a program and @xmath96 .",
    "if @xmath276 then @xmath277 .",
    "we have @xmath112 .",
    "thus , @xmath278 and , consequently , @xmath279 .",
    "we also have @xmath280 .",
    "[ thm : memb1a ] the problem @xmath281 is in the class @xmath282 .",
    "the problem @xmath283 is in the class conp .",
    "we start with an argument for the problem @xmath281 . by theorem",
    "[ thm : general ] , @xmath0 and @xmath1 are not suppmin - equivalent relative to @xmath284 if and only if there is @xmath285 , or there is @xmath286 and @xmath287 . thus , by lemma [ in0 ] , to decide that @xmath0 and @xmath1 are not suppmin - equivalent relative to @xmath284 , one can guess @xmath253 and @xmath106 such that @xmath288 and verify that @xmath289 , or that @xmath286 and @xmath290 . by lemma [ lem : memb1](ii ) , deciding the membership of @xmath115 in @xmath291 and @xmath292",
    "can be accomplished by means of two calls to a conp oracle .",
    "deciding @xmath290 can be accomplished in polynomial time ( we note that @xmath293 and @xmath294 ) . the argument for the second part of the assertion is essentially the same .",
    "the only difference is that we use lemma [ lem : memb2](ii ) instead of lemma [ lem : memb1](ii ) to obtain a stronger bound .",
    "lemma [ in0 ] is too weak for the membership results for complement - direct and complement - complement problems .",
    "indeed , for these two types of problems , it only limits @xmath106 to subsets of @xmath295 , which is infinite . to handle these two classes of problems we use results that provide stronger limits on @xmath106 and",
    "can be used in proofs of the membership results .",
    "the proofs are quite technical . to preserve the overall flow of the argument , we present them in the appendix .    [",
    "lem : new ] let @xmath124 be programs and @xmath96 .    1 .   if @xmath296 then there is @xmath297 such that @xmath205 .",
    "2 .   if @xmath298 and @xmath299 , then there is @xmath300 such that @xmath301 and @xmath205 .",
    "[ thm : memb1b ] the problems @xmath302 and @xmath303 are contained in the class @xmath282 .",
    "the problem @xmath304 is in the class conp .",
    "the argument is similar to that of theorem [ thm : memb1a ] .",
    "first , we will consider the problem @xmath302 . by theorem [ thm : general ] ,",
    "@xmath0 and @xmath1 are not suppmin - equivalent relative to @xmath238 if and only if there is @xmath305 , or @xmath298 and @xmath299 . by lemma [ lem :",
    "new ] , @xmath0 and @xmath1 are not suppmin - equivalent relative to @xmath238 if and only if there is @xmath115 such that @xmath306 and @xmath307 , or @xmath298 and @xmath308 .",
    "thus , to decide the complementary problem , it suffices to guess @xmath309 and check that @xmath310 , or that @xmath254 and @xmath311 .",
    "the first task can be decided by np oracles ( lemma [ lem : memb1](i ) ) , and testing @xmath311 can be accomplished in polynomial time .",
    "the remaining arguments are similar . to avoid repetitions",
    ", we only list essential differences . in the case of @xmath303",
    ", we use lemma [ lem : memb1](iii ) . to obtain a stronger upper bound for @xmath304 , we use lemma  [ lem : memb2](i ) instead of lemma [ lem : memb1](iii ) .",
    "when @xmath9 is fixed to @xmath27 , that is , we have @xmath312 , which means there is no restriction on atoms in the heads of rules , a stronger bound on the complexity of the complement - complement and complement - direct problems can be derived .",
    "we first state a key lemma ( the proof is in the appendix ) .    [",
    "cor : usuppmin:2 ] let @xmath124 be programs and @xmath313 .",
    "if @xmath314 , then there is @xmath315 such that @xmath106 is a model of exactly one of @xmath0 and @xmath1 , or there is @xmath316 such that @xmath317 belongs to exactly one of @xmath318 and @xmath319 .",
    "[ thm : memb1 ] the problems @xmath320 and @xmath321 are in the class conp .",
    "the case of @xmath321 was settled before by ( they denoted the problem by @xmath322 ) .",
    "thus , we consider only the problem @xmath320 .",
    "we will show that the following nondeterministic algorithm verifies , given programs @xmath0 , @xmath1 and a set @xmath160 , that @xmath0 and @xmath1 are not suppmin - equivalent relative to @xmath323 .",
    "we guess a pair @xmath324 , where @xmath325 , and @xmath326 such that ( a ) @xmath106 is a model of exactly one of @xmath0 and @xmath1 ; or ( b ) @xmath316 and @xmath317 belongs to exactly one of @xmath327 and @xmath328 ; or ( c ) @xmath106 is model of @xmath0 and @xmath329 .",
    "such a pair exists if and only if @xmath0 and @xmath1 are not suppmin - equivalent relative to @xmath323 . indeed , let us assume that such a pair @xmath324 exists .",
    "if ( a ) holds for @xmath324 , say @xmath106 is a model of @xmath0 but not of @xmath1 , then @xmath330 ( easy to verify from the definition of @xmath331 ) .",
    "thus , @xmath332 and , by theorem [ thm : general ] , @xmath0 and @xmath1 are not suppmin - equivalent relative to @xmath323 .",
    "if ( b ) holds for @xmath324 , @xmath314 again , and we are done , as above , by theorem [ thm : general ] . finally , if ( c ) holds , @xmath333 ( as @xmath130 ) and @xmath334 .",
    "thus , one more time by theorem [ thm : general ] , @xmath0 and @xmath1 are not suppmin - equivalent relative to @xmath323 .",
    "conversely , if @xmath0 and @xmath1 are not suppmin - equivalent relative to @xmath323 , then @xmath332 , or there is @xmath335 such that @xmath336 . by lemma [ cor : usuppmin:2 ] , if @xmath332 then there is @xmath324 such that @xmath325 and @xmath324 satisfies ( a ) or ( b ) .",
    "thus , let us assume that there is @xmath335 such that @xmath336 .",
    "then , @xmath130 and @xmath336 or , equivalently , @xmath337 .",
    "let @xmath338 .",
    "clearly , @xmath191 , @xmath188 , and @xmath339 .",
    "thus , @xmath340 . picking any @xmath326 ( since @xmath0 and @xmath1 are not suppmin - equivalent relative to @xmath323 , @xmath341 ) yields a pair @xmath342 , with @xmath343 , for which ( c ) holds .",
    "it follows that the algorithm is correct .",
    "moreover , checking whether @xmath130 and @xmath344 can clearly be done in polynomial time in the total size of @xmath0 , @xmath1 , and @xmath10 ; the same holds for checking @xmath337 .",
    "finally , testing @xmath345 and @xmath346 are polynomial - time tasks ( with respect to the size of the input ) , too . the conditions ( 1 ) - ( 3 ) and ( 5 ) are evident . to verify the condition ( 4 ) , we need to verify that @xmath119 for just one set @xmath270 , namely @xmath347 .",
    "thus , the algorithm runs in polynomial time .",
    "it follows that the complement of our problem is in the class np .",
    "we start with direct - complement problems .",
    "[ thm : suppbac1 ] the problem @xmath161 is @xmath282-hard .",
    "+ let @xmath348 be a qbf , where @xmath349 is a cnf formula over @xmath350 .",
    "we can assume that @xmath351 ( if not , variables in @xmath253 can be renamed ) .",
    "next , we can assume that @xmath352 ( if not , one can add to @xmath226 `` dummy '' clauses @xmath353 , for @xmath198 ) .",
    "we will construct programs @xmath354 and @xmath355 , and a set @xmath10 , so that @xmath356 is true if and only if @xmath233 and @xmath357 are suppmin - equivalent relative to @xmath162 .",
    "since the problem to decide whether a given qbf @xmath348 is true is @xmath282-complete , the assertion will follow .",
    "for every atom @xmath358 , we introduce a fresh atom @xmath359 ( in particular , in such a way that @xmath360 ) .",
    "given a set of `` non - primed '' atoms @xmath270 , we define @xmath361 .",
    "thus , we have @xmath362 . we use @xmath231 as in the proof of theorem  [ h - revsupp ] and define the following programs : @xmath363 to simplify notation , from now on we write @xmath0 for @xmath233 and @xmath1 for @xmath357 .",
    "we also define @xmath364 .",
    "we observe that @xmath365 .",
    "one can check that the models of @xmath1 contained in @xmath10 are sets of type    1 .",
    "@xmath366 , where @xmath367 , @xmath368 and @xmath369 .",
    "each model of @xmath1 is also a model of @xmath0 but @xmath0 has additional models contained in @xmath10 , viz .    1 .",
    "@xmath370 , for _ each _ @xmath368 .",
    "clearly , for each model @xmath72 of @xmath1 such that @xmath371 , @xmath372 .",
    "similarly , for each model @xmath72 of @xmath0 such that @xmath371 , @xmath87 .",
    "hence , each such model @xmath72 is also supported for both @xmath0 and @xmath1 .    from these comments",
    ", it follows that for every model @xmath72 of @xmath1 ( @xmath0 , respectively ) , @xmath373 ( @xmath374 , respectively ) .",
    "thus , for every model @xmath72 of both @xmath0 and @xmath1 , @xmath375 .",
    "it follows that @xmath0 and @xmath1 are suppmin - equivalent with respect to @xmath284 if and only if @xmath376 ( indeed , we recall that if @xmath377 then @xmath72 is a model of @xmath6 ) .",
    "let us assume that @xmath348 is false .",
    "hence , there exists an assignment @xmath368 to atoms @xmath106 such that for every @xmath367 , @xmath378 .",
    "let @xmath379 .",
    "we will show that @xmath380 .    since @xmath381 is a supported model of @xmath0 , @xmath382 . the requirement",
    "( 2 ) for @xmath380 is evident .",
    "the requirement ( 5 ) holds , since @xmath383 . by the property of @xmath384",
    ", @xmath381 is a minimal model of @xmath0 .",
    "thus , the requirements ( 3 ) and ( 4 ) hold , too .",
    "it follows that @xmath380 , as claimed . since @xmath381 is not a model of @xmath1 , @xmath385 .",
    "let us assume that @xmath348 is true .",
    "first , observe that @xmath386 . indeed , let @xmath387 .",
    "it follows that @xmath381 is a model of @xmath1 and , consequently , of @xmath0 . from our earlier comments",
    ", it follows that @xmath388 . since @xmath389 , @xmath390 .",
    "thus , @xmath382 . moreover , if @xmath391 then @xmath392 and , consequently , @xmath393 . thus , the requirement ( 5 ) for @xmath394 holds .",
    "the condition @xmath395 is evident ( it holds as @xmath396 ) . since @xmath381 is a model of @xmath1 , @xmath397 , where @xmath398 is a model of type 1 and @xmath399 .",
    "thus , every model @xmath400 of @xmath0 is also a model of @xmath1 .",
    "it implies that the requirements ( 3 ) and ( 4 ) for @xmath394 hold .",
    "hence , @xmath394 and , consequently , @xmath401 .",
    "we will now use the assumption that @xmath348 is true to prove the converse inclusion , i.e. , @xmath402 . to this end , let us consider @xmath403 . if @xmath397 , where @xmath398 is of type 1 and @xmath399 , then arguing as above , one can show that @xmath387 .",
    "therefore , let us assume that @xmath397 , where @xmath398 is of type 2 and @xmath399 .",
    "more specifically , let @xmath404 , for some @xmath368 . by our assumption ,",
    "there is @xmath367 such that @xmath405 .",
    "it follows that @xmath406 is a model of @xmath0 .",
    "clearly , @xmath400 .",
    "moreover , since @xmath407 , we have @xmath408 . since @xmath394 , the requirement ( 3 ) implies that @xmath270 is not a model of @xmath0 , a contradiction .",
    "hence , the latter case is impossible and @xmath409 follows .",
    "we proved that @xmath348 is true if and only if @xmath410 .",
    "this completes the proof of the assertion .",
    "[ thm : suppbac2 ] the problem @xmath411 is conp - hard .",
    "let us consider a cnf formula @xmath226 over a set of atoms @xmath106 .",
    "without loss of generality we can assume that @xmath412 .",
    "for each atom @xmath198 , we introduce a fresh atom @xmath413 .",
    "thus , in particular , @xmath414 . finally , we consider programs @xmath233 and @xmath415 from the proof of theorem  [ h - revsupp ] . in the remainder of the proof , we write @xmath0 for @xmath233 .    from the proof of theorem  [ h - revsupp ] , we know that @xmath0 has a model if and only if @xmath226 has a model ( is satisfiable ) .",
    "we will now show that @xmath416 if and only if @xmath226 is satisfiable .",
    "it is easy to check that @xmath417 .",
    "thus , the assertion will follow by theorem [ thm : general ] .",
    "let us assume that @xmath0 has a model .",
    "then @xmath0 has a model , say @xmath72 , such that @xmath418 .",
    "we show that @xmath419 . indeed , since @xmath87 , @xmath420 .",
    "also , since @xmath421 , @xmath422 and so , @xmath423 .",
    "lastly , @xmath424 .",
    "thus , the conditions ( 1 ) , ( 2 ) and ( 5 ) for @xmath425 hold .",
    "since @xmath426 and @xmath427 , there is no @xmath428 such that @xmath429 or @xmath430 .",
    "thus , also the conditions ( 3 ) and ( 4 ) hold , and @xmath431 follows . conversely , let @xmath431 and let @xmath432 .",
    "then @xmath420 and , in particular , @xmath72 is a model of @xmath0 .",
    "combining theorems [ thm : suppbac1 ] and [ thm : suppbac2 ] with theorem [ thm : memb1a ] yields the following result that fully determines the complexity of direct - complement problems .",
    "[ cor : suppmindc ] the problems @xmath161 and @xmath281 are @xmath282-complete",
    ". the problems @xmath411 and @xmath283 are conp - complete .",
    "before we move on to complement - direct and complement - complement problems , we present a construction that will be of use in both cases .",
    "let @xmath348 be a qbf , where @xmath349 is a cnf formula over @xmath350 .",
    "without loss of generality we can assume that @xmath253 and @xmath106 are non - empty .",
    "we define @xmath433 , @xmath206 and @xmath231 , for each clause @xmath16 of @xmath226 , as before .",
    "next , let @xmath96 be such that : @xmath434 , @xmath435 , and let @xmath436 .",
    "we define @xmath437 and observe that @xmath438 and @xmath439 .",
    "finally , we select an arbitrary element @xmath440 from @xmath253 and define the programs @xmath354 and @xmath355 as follows : @xmath441    [ last ] under the notation introduced above , @xmath356 is true if and only if @xmath233 and @xmath357 are suppmin - equivalent relative to @xmath442 .    as usual , to simplify notation we write @xmath0 for @xmath233 and @xmath1 for @xmath357 .",
    "we observe that @xmath443 .",
    "we observe that both @xmath0 and @xmath1 have the following models that are contained in @xmath444 : + moreover , @xmath0 has also additional models contained in @xmath444 : +    for each model @xmath72 of the type [ eq : top ] , @xmath445 , thanks to the rules @xmath446 , where @xmath447 .",
    "thus , for each model @xmath72 of type [ eq : top ] , we have @xmath448 and @xmath449 .",
    "let @xmath72 be a model of @xmath0 of one of the other two types .",
    "then , we have @xmath450 . moreover , since @xmath451 and @xmath439 , @xmath452 . thus @xmath453 . similarly , if @xmath72 is a model of @xmath1 of type 2 , @xmath454 .",
    "for the same reasons as above , @xmath455 .",
    "hence , @xmath456 , and both @xmath207 and @xmath208 consist of interpretations @xmath381 of the form @xmath457 , where @xmath398 is a set of the type [ eq : top ] and @xmath458 .",
    "clearly , for each such set @xmath381 , @xmath459 .",
    "thus @xmath460 holds for each @xmath461 ( as @xmath461 implies @xmath462 ) . by theorem  [ thm : general ] , it follows that @xmath0 and @xmath1 are suppmin - equivalent relative to @xmath442 if and only if @xmath463 .",
    "thus , to complete the proof , it suffices to show that @xmath356 is true if and only if @xmath463 .",
    "let us assume that @xmath348 is false .",
    "hence , there exists an assignment @xmath368 to atoms @xmath106 such that for every @xmath367 , @xmath378 .",
    "let @xmath464 .",
    "we will show that @xmath465 . since @xmath381 is of the type [ eq : top ] , @xmath466 . the requirement",
    "( 2 ) for @xmath465 is evident , as @xmath467 .",
    "the requirement ( 5 ) holds , since @xmath468 . by the property of @xmath384",
    ", @xmath381 is a minimal model of @xmath1 .",
    "thus , the requirements ( 3 ) and ( 4 ) hold , too .",
    "it follows that @xmath469 , as claimed . on the other hand @xmath470 .",
    "indeed , let @xmath471",
    ". then @xmath70 ( it is of the type 3 ) .",
    "we now observe that @xmath472 , @xmath473 ( as @xmath414 ) , and @xmath474 ( as @xmath475 , due to the fact that @xmath439 ) .",
    "it follows that @xmath476 violates the condition ( 4 ) for @xmath477 .",
    "conversely , let us assume that @xmath348 is true .",
    "we first observe that @xmath478 . indeed , let @xmath479 .",
    "then , @xmath462 and , consequently , @xmath466 . moreover , if @xmath480 , then @xmath481 and , as @xmath482 , @xmath483 .",
    "next , as @xmath479 , @xmath484 .",
    "thus , the requirements ( 1 ) , ( 5 ) and ( 2 ) for @xmath485 hold .",
    "since every model of @xmath1 is a model of @xmath0 , it follows that the conditions ( 3 ) and ( 4 ) hold , too .",
    "we will now use the assumption that @xmath348 is true to prove the converse inclusion @xmath486 . to this end , let us consider @xmath487 .",
    "reasoning as above , we can show that the conditions ( 1 ) , ( 5 ) and ( 2 ) for @xmath479 hold .    by our earlier comments , @xmath397 , where @xmath398 is of the form [ eq : top ] and @xmath488 .",
    "more specifically , @xmath489 , for some @xmath490 .",
    "let us consider @xmath400 such that @xmath491 . since @xmath492 , @xmath493 .",
    "it follows that @xmath494 is not of the type 3 .",
    "thus , since @xmath495 , @xmath119 .",
    "consequently , the condition ( 3 ) for @xmath496 holds .",
    "so , let us consider @xmath400 such that @xmath497 and @xmath498 .",
    "let us assume that @xmath262 . since @xmath499 , @xmath500 , where @xmath501 is a set of the type 3 and @xmath502 .",
    "since @xmath503 , @xmath504 , and so , @xmath505 .    since @xmath348 is true , there is @xmath367 such that @xmath405 .",
    "it follows that @xmath506 is a model of both @xmath0 and @xmath1 ( of the type 2 ) . since @xmath507",
    ", it follows that @xmath508 . since @xmath509 , @xmath510",
    "moreover , @xmath511 . since @xmath512 , @xmath513 , a contradiction",
    "thus , @xmath119 and , consequently , the condition ( 4 ) for @xmath514 holds .",
    "this completes the proof of @xmath515 and of the lemma .",
    "we now apply this lemma to complement - direct problems .",
    "we have the following result .",
    "[ thm:136 ] the problem @xmath516 , where @xmath517 , is @xmath282-hard .",
    "let @xmath348 be a qbf , where @xmath349 is a cnf formula over @xmath350 such that @xmath253 and @xmath106 are nonempty .",
    "we can assume that @xmath518 ( if not , variables in the qbf can be renamed ) .",
    "we define @xmath433 and @xmath206 as in other places .",
    "thus , @xmath519 . finally , we pick @xmath436 , and define @xmath233 and @xmath357 as above . by lemma [ last ] ,",
    "@xmath348 is true if and only if @xmath233 and @xmath357 are suppmin - equivalent with respect to @xmath238 .",
    "thus , the assertion follows .",
    "( we note that since @xmath10 is fixed , we can not assume @xmath520 or @xmath521 here ; however , lemma  [ last ] takes care of both cases ) .",
    "we are now in a position to establish exactly the complexity of complement - direct problems .",
    "[ cor : suppmincd ] the problems @xmath522 and @xmath302 are @xmath282-complete . for @xmath434 ,",
    "the problems @xmath516 , and @xmath523 , are also @xmath282-complete .",
    "the problems @xmath524 and @xmath321 are conp - complete .    for problems @xmath516 ( where @xmath525 ) , @xmath522 , @xmath523 ( where @xmath525 ) , and @xmath302 , the upper bound follows from theorem [ thm : memb1b ] , and the lower bound from theorem [ thm:136 ] .",
    "the problems @xmath524 and @xmath321 were proved to be conp - complete by ( in fact , they denoted these problems by @xmath526 and @xmath322 , respectively ) .",
    "we will now apply lemma [ last ] to complement - complement problems .",
    "[ sppmcclb2 ] the problem @xmath527 , where @xmath525 , is @xmath282-hard .",
    "let @xmath348 be a qbf , where @xmath349 is a cnf formula over @xmath350 .",
    "we select @xmath436 , and define @xmath433 and @xmath206 as usual . without loss of generality we can assume that @xmath528 . in particular , @xmath529 .",
    "we set @xmath530 and so , @xmath531 .",
    "finally , we set @xmath532 and define programs @xmath0 and @xmath1 as we did in preparation for lemma [ last ] . by lemma",
    "[ last ] , @xmath348 is true if and only if @xmath0 and @xmath1 are suppmin - equivalent with respect to @xmath533 .",
    "thus , the assertion follows .",
    "next , we determine the lower bound for the problem @xmath534 .",
    "[ sppmcclb3 ] the problem @xmath534 is conp - hard .",
    "the problem @xmath535 is conp - complete @xcite ( in the paper proving that fact , the problem was denoted by @xmath536 ) .",
    "we will show that it can be reduced to @xmath534 ( for any finite @xmath96 ) .",
    "thus , let us fix @xmath9 and @xmath10 as two finite subsets of @xmath11 , and let @xmath0 and @xmath1 be normal logic programs .",
    "we define @xmath537 and @xmath538 to be programs obtained by replacing consistently atoms in @xmath0 and @xmath1 that belong to @xmath539 with atoms that do not belong to @xmath540",
    ". clearly , @xmath0 and @xmath1 are suppmin - equivalent relative to @xmath541 if and only if @xmath537 and @xmath538 are suppmin - equivalent relative to @xmath541 .",
    "moreover , it is clear that suppmin - equivalence relative to @xmath541 between @xmath537 and @xmath538 implies suppmin - equivalence relative to @xmath533 between @xmath537 and @xmath538 .",
    "we will now show the converse implication . to this end , let @xmath6 be an arbitrary program from @xmath541 . by @xmath542",
    "we denote the program obtained by replacing consistently atoms in @xmath6 that belong to @xmath539 with atoms that do not belong to @xmath543 . since @xmath537 and @xmath538 are suppmin - equivalent relative to @xmath533 , @xmath544 and @xmath545 have the same suppmin models .",
    "now , we note that because @xmath546 , @xmath544 and @xmath545 have the same suppmin models if and only if @xmath547 and @xmath548 have the same suppmin models .",
    "thus , @xmath547 and @xmath548 have the same suppmin models and , consequently , @xmath537 and @xmath538 are suppmin - equivalent relative to @xmath541 .",
    "it follows that @xmath0 and @xmath1 are suppmin - equivalent relative to @xmath541 .    by this discussion @xmath0 and @xmath1",
    "are suppmin - equivalent relative to @xmath541 if and only if @xmath537 and @xmath538 are suppmin - equivalent relative to @xmath533 .",
    "conp - hardness of @xmath534 thus follows from the conp - hardness of @xmath535 .",
    "taking into account theorems [ thm : memb1b ] and [ thm : memb1 ] , theorems [ sppmcclb2 ] and [ sppmcclb3 ] yield the following result .",
    "[ cor : suppmincc ] the problems @xmath527 , with @xmath525 , and @xmath303 are @xmath282-complete . the problems @xmath534 , @xmath304 , and @xmath320 are conp - complete .",
    "in this section , we establish the complexity for direct - complement , complement - direct and complement - complement problems of deciding stable - equivalence .",
    "we will again make use of the relations depicted in figure [ fig1 ] to obtain our results .",
    "thus , for instance , when we derive an upper bound for a problem @xmath549 and a matching lower bound for @xmath550 , we obtain the exact complexity result for all problems between @xmath550 and @xmath549 ( inclusively ) .",
    "as we will show , for stable equivalence those bounds match in all cases other than @xmath551 .",
    "we also mention that for the upper bounds for relativized hyperequivalence with respect to the stable - model semantics , some relevant results were established before .",
    "specifically , the direct - direct problem @xmath170 is known to be in the class @xmath282 and , under the restriction to normal logic programs , in conp @xcite . however , for the sake of completeness we treat the direct - direct problems here in full detail as , in the case of fixed alphabets , they were not considered before .",
    "the following lemmas mirror the corresponding results from the previous section but show some interesting differences .",
    "for instance , as the following result shows , the problem of model checking is slightly harder now compared to lemma  [ lem : memb1 ] .",
    "namely , it is located in the class d@xmath552 .",
    "( we recall that the class d@xmath552 consists of all problems expressible as the conjunction of a problem in np and a problem in conp . )",
    "however , this increase in complexity compared to lemma  [ lem : memb1 ] does not influence the subsequent @xmath282-membership results , since a call to a d@xmath552-oracle amounts to two np - oracle calls .",
    "[ lem : smemb1 ] the following problems are in the class d@xmath552 : given a program @xmath0 , and sets @xmath253 , @xmath106 , @xmath9 , and @xmath10 , decide whether @xmath553 , where @xmath144 stands for one of @xmath9 and @xmath156 , and @xmath145 stands for one of @xmath10 and @xmath252 ,    we use similar arguments as in the proof of lemma  [ lem : memb1 ] , but we need now both an np and a conp test .",
    "we recall that verifying any condition involving @xmath156 can be reformulated in terms of @xmath9 .",
    "for instance , for every set @xmath266 , we have @xmath554 , and @xmath268 if and only if @xmath555 . the same holds for @xmath252 .",
    "let @xmath556 and @xmath557 .",
    "we will use the observation above to establish upper bounds on the complexity of deciding each of the conditions ( 1 ) - ( 5 ) for @xmath553 .",
    "the condition ( 1 ) can clearly be decided in polynomial time .",
    "the same holds for the condition ( 2 ) .",
    "it is evident once we note that @xmath558 is equivalent to @xmath559 , @xmath560 , @xmath561 , and @xmath562 , depending on the form of @xmath144 and @xmath145 .",
    "it is also easy to show that each of the conditions ( 3 ) and ( 4 ) can be decided by means of a single conp test , and that the condition ( 5 ) can be decided by means of one np test .",
    "for all instantiations of @xmath144 and @xmath145 , the arguments are similar .",
    "we present the details for one case only .",
    "for example , if @xmath144 stands for @xmath9 and @xmath145 stands for @xmath252 , to decide whether @xmath115 violates the condition ( 4 ) , we guess a set @xmath563 and verify that ( a ) @xmath564 ( by checking that @xmath565 ) ; ( b ) @xmath566 ; ( c ) one of the two inclusions is proper ; and ( d ) @xmath567 .",
    "all these tasks can be accomplished in polynomial time , and so deciding that the condition ( 4 ) does not hold amounts to an np test .",
    "consequently , deciding that the condition ( 4 ) holds can be accomplished by a conp test .",
    "when we fix @xmath9 and @xmath10 ( they are no longer components of the input ) , the complexity of testing whether @xmath568 is lower  the problem is in the class @xmath174 . comparing with lemma  [ lem : memb2 ] , the lower complexity holds only for @xmath569 and @xmath570 .",
    "moreover , _ both _ @xmath9 and @xmath10 must be fixed .",
    "[ lem : smemb2 ] for every finite sets @xmath96 the following problem is in the class @xmath174 : given a program @xmath0 , and sets @xmath253 , @xmath106 , decide whether @xmath571 .",
    "as we noted , testing the conditions ( 1 ) and ( 2 ) for @xmath572 can be done in polynomial time .",
    "for the condition ( 3 ) we check all candidate sets @xmath270 . since @xmath573",
    "all elements of @xmath270 are determined by @xmath106 except possibly for those that are also in @xmath9 .",
    "thus , there are at most @xmath574 possible sets @xmath270 to consider .",
    "since @xmath9 is fixed ( not a part of the input ) , checking for all these sets @xmath270 whether @xmath567 and @xmath260 can be done in polynomial time .    for the condition ( 4 )",
    ", the argument is similar .",
    "we note that @xmath270 is , in particular , restricted by @xmath564 and @xmath575 .",
    "the two conditions imply that @xmath576 .",
    "thus , all elements of @xmath270 are determined except possibly for those that are also in @xmath539 .",
    "it follows that there are at most @xmath577 possibilities for @xmath270 to consider .",
    "clearly , for each of them , we can check whether it satisfies or fails the premises and the consequent of ( 4 ) in polynomial time .",
    "thus , checking the condition ( 4 ) is a polynomial - time task .    the same ( essentially ) argument works also for the condition ( 5 ) . since @xmath578 , all elements of @xmath270 are determined except possibly for those that are also in @xmath579 .",
    "thus , there are at most @xmath580 possible sets @xmath270 to consider . given that @xmath9 and @xmath10 are fixed , checking all those sets @xmath270 for @xmath567 and @xmath260 can be done in polynomial time .",
    "the reduct of a _ normal _",
    "program is a horn program . that property allows us to obtain stronger upper bounds for the case of normal logic programs .",
    "[ lem : smemb1:normal ] the following problems are in the class @xmath174 . given a normal program @xmath0 , and",
    "sets @xmath253 , @xmath106 , @xmath9 , and @xmath10 , decide whether @xmath553 , where @xmath144 stands for @xmath9 or @xmath156 , and @xmath145 stands for @xmath10 or @xmath252 .",
    "as we noted , deciding the conditions ( 1 ) and ( 2 ) can be accomplished in polynomial time ( even without the assumption of normality ) .    to show that the condition ( 3 ) can be decided in polynomial time ,",
    "we show that the complement of ( 3 ) can be decided in polynomial time .",
    "the complement of ( 3 ) has the form : there is @xmath260 such that @xmath581 and @xmath567 . let us consider the horn program @xmath582 . since @xmath0 , @xmath106 and @xmath9",
    "are given , @xmath537 can be constructed in polynomial time ( for instance , if @xmath583 , @xmath584 ) .",
    "we will show that the complement of the condition ( 3 ) holds if and only if @xmath537 is consistent and its least model , say @xmath13 , satisfies @xmath585 and @xmath586 .",
    "first , we observe that if the complement of ( 3 ) holds , then @xmath537 has a model @xmath270 such that @xmath260 and @xmath581 .",
    "it follows that @xmath537 is consistent and its least model , say @xmath13 , satisfies @xmath587 .",
    "thus , @xmath588 and @xmath589 .",
    "moreover , since @xmath590 , @xmath591 . thus , @xmath592 .",
    "therefore , we have @xmath588 and @xmath586 as needed .",
    "the converse implication is trivial .",
    "since @xmath537 can be constructed in polynomial time and @xmath13 can be computed in polynomial time ( @xmath537 is horn ) , deciding the complement of the condition ( 3 ) can be accomplished in polynomial time , too .    to settle the condition ( 4 ) , we again demonstrate that the complement of the condition ( 4 ) can be decided in polynomial time . to this end , we observe that the complement of ( 4 ) holds if and only if one of the following two conditions holds : +    one can check that ( 4@xmath593 ) holds if and only if @xmath594 is consistent and its least model , say @xmath13 , satisfies @xmath588 and @xmath595 .",
    "similarly , ( 4@xmath596 ) holds if and only if there is @xmath597 such that @xmath598 is consistent and its least model , say @xmath13 , satisfies @xmath588 and @xmath599 . thus , the conditions ( 4@xmath593 ) and ( 4@xmath596 ) can be checked in polynomial time .",
    "the argument for the condition ( 5 ) is similar to that for the complement of the condition ( 3 ) .",
    "the difference is that instead of @xmath537 we use the horn program @xmath600 .",
    "reusing the argument for ( 3 ) with the arbitrary containment of @xmath270 in @xmath106 ( rather than a proper one ) shows that the complement of ( 5 ) can be decided in polynomial time .",
    "the next lemma plays a key role in establishing an upper bound on the complexity of the problems @xmath549 .",
    "its proof is technical and we present it in the appendix .",
    "[ stin1e ] let @xmath124 be programs and @xmath96 .",
    "if @xmath601 , then there are sets @xmath602 , such that at least one of the following conditions holds :    1 .",
    "@xmath603 2 .",
    "@xmath604 and for every @xmath605 , @xmath606    we now use similar arguments to those in the previous section to obtain the following collection of membership results .",
    "[ thm : memb3 ] the problem @xmath549 , is contained in the class @xmath282 , for any @xmath248 ; @xmath607 is contained in the class conp . the problem @xmath608 , is contained in the class conp for any @xmath248 .    given finite programs",
    "@xmath0 and @xmath1 , and finite subsets @xmath609 of @xmath11 the following algorithm decides the complementary problem to @xmath549 . if @xmath157 and @xmath610 , the algorithm guesses two sets @xmath611 . it verifies whether @xmath612 and if so , returns yes .",
    "otherwise , the algorithm guesses two sets @xmath611 .",
    "if @xmath157 , it selects two elements @xmath605 or , if @xmath613 , it selects two elements @xmath614 .",
    "the algorithm verifies whether @xmath615 ( where @xmath616 if @xmath617 and @xmath569 if @xmath613 ) and if so , returns yes . otherwise , the algorithm verifies whether @xmath618 ( where @xmath616 if @xmath617 and @xmath569 if @xmath613 ) and if so , returns yes .",
    "the correctness of the algorithm follows by lemma [ stin1e ] .",
    "since the sizes of @xmath253 and @xmath106 are polynomial in the size of @xmath619 , the membership of the complementary problem in the class @xmath620 follows by lemma [ lem : smemb1 ] .",
    "the remaining claims of the assertion follow in the same way by lemmas [ lem : smemb2 ] and [ lem : smemb1:normal ] , respectively .",
    "we start with the case of normal programs .",
    "[ thm : norm ] the problem @xmath621 is conp - hard for any @xmath248 .    let us fix @xmath151 and @xmath152 , and let @xmath144 and @xmath145 be sets of atoms defined by the combinations @xmath9 and @xmath151 , and @xmath10 and @xmath152 .",
    "we will show that unsat can be reduced to @xmath621 .",
    "let @xmath349 be a cnf over of set of atoms @xmath106 .",
    "we define @xmath354 and @xmath1 as in the proof of theorem  [ h - revsupp ] .",
    "we note that both programs are normal . as before ,",
    "we write @xmath0 instead of @xmath233 in order to simplify the notation .    to prove the assertion it suffices to show that @xmath349 is unsatisfiable if and only if @xmath0 and @xmath1 are stable - equivalent with respect to @xmath143 . to this end , we will show that @xmath349 is unsatisfiable if and only if @xmath622 ( cf .",
    "theorem [ thm : stable ] ) .    since @xmath1 has no models , @xmath623 .",
    "moreover , @xmath624 if and only if @xmath0 has no models ( indeed , if @xmath553 , then @xmath106 is a model of @xmath0 ; if @xmath106 is a model of @xmath0 , then @xmath625 ) .",
    "it follows that @xmath622 if and only if @xmath0 has no models .    in the proof of theorem  [ h - revsupp ] , we noted that @xmath0 has models if and only if @xmath349 has models .",
    "thus , @xmath626 if and only if @xmath349 is unsatisfiable .    together with the matching conp - membership results for @xmath608 from theorem  [ thm : memb3 ] we obtain the following result .    [ cor74 ]",
    "the following problems are conp - complete for any @xmath248 : @xmath608 , @xmath627 , @xmath628 and @xmath621 .",
    "we now turn to the case of disjunctive programs .",
    "it turns out that the problems @xmath629 , @xmath630 and @xmath631 are @xmath632-hard .",
    "the situation is different for @xmath607 . by theorems [ thm : memb3 ] and corollary [ cor74 ]",
    ", the problem is conp - complete .",
    "however , the two immediate successors of that problem , @xmath633 and @xmath634 ( cf .",
    "figure [ fig1 ] ) are @xmath632-hard .",
    "we will now show these results .    to start with",
    "we provide some technical results concerning the structure of the set @xmath635 when @xmath636 and @xmath637 .",
    "it will be applicable to programs we construct below .",
    "[ lemma : ue ] let @xmath0 be a program and @xmath100 . if @xmath636 and @xmath638 , then @xmath639 if and only if there are @xmath640 and @xmath641 such that one of the following conditions holds :    1 .",
    "@xmath642 , @xmath643 , and @xmath644 2 .",
    "@xmath642 , @xmath645 and @xmath646 , for some @xmath647 3 .",
    "@xmath642 , @xmath645 and @xmath648 , for some @xmath649 such that @xmath650 and @xmath651 .",
    "the proof of this result is technical and we give it in the appendix .",
    "this lemma points to the crucial role played by those pairs @xmath652 that satisfy @xmath653 . in particular , as noted in the next result , it allows to narrow down the class of pairs @xmath115 that need to be tested for the membership in @xmath635 and @xmath654 when considering stable - equivalence of @xmath0 and @xmath1 with respect to @xmath8 .",
    "[ lemma : ue : a ] let @xmath0 and @xmath1 be programs , and @xmath609 subsets of @xmath11 such that @xmath655 and @xmath656",
    ". then , @xmath0 and @xmath1 are stable - equivalent with respect to @xmath8 if and only if for every @xmath657 such that @xmath315 , @xmath658 if and only if @xmath659 .    without loss of generality",
    ", we can assume that @xmath660 .",
    "indeed , let @xmath661 and @xmath662 .",
    "it is easy to see that @xmath0 and @xmath537 ( @xmath1 and @xmath538 , respectively ) are stable - equivalent with respect to @xmath8 .",
    "thus , in particular , @xmath663 and @xmath664 .",
    "moreover , @xmath665 . therefore , @xmath666 if and only if @xmath667 , and @xmath668 if and",
    "only if @xmath656 .    thus , let us assume that @xmath660 .",
    "only the `` if '' part of the claim requires a proof , the other implication being evident . let us assume that @xmath639 .",
    "by lemma [ lemma : ue ] , there are @xmath669 and @xmath641 such that one of the conditions ( a ) - ( c ) holds .",
    "if ( a ) holds , @xmath670 and so , @xmath671 . if ( b ) or ( c ) holds , @xmath672 and so , @xmath673 , as well .",
    "finally , we note that under the assumptions of lemma [ lemma : ue ] , if @xmath674 , then the conditions for @xmath639 simplify .",
    "[ lemma : ue : b ] let @xmath0 be a program and @xmath100 . if @xmath636 , @xmath638 and @xmath653 , then @xmath652 if and only if @xmath130 , @xmath675 , @xmath676 , and for every @xmath260 such that @xmath677 , @xmath134 .    under the assumptions of the lemma , the four conditions are equivalent to the conditions ( 1 ) , ( 2 ) , ( 5 ) and ( 4 ) for @xmath639 , respectively , and the condition ( 3 ) is vacuously true .    our first @xmath282-hardness result for stable equivalence results concerns the problem @xmath629 .",
    "[ thm : disj : cd ] the problem @xmath629 is hard for the class @xmath282 .    according to our notational convention , we have to show that @xmath629 is @xmath282-hard , for every finite @xmath100 .",
    "let @xmath348 be a qbf , where @xmath349 is a cnf formula over @xmath350 .",
    "without loss of generality we can assume that every clause in @xmath349 contains at least one literal @xmath678 or @xmath679 , for some @xmath680 .",
    "furthermore , we can also assume that @xmath681 and @xmath682 ( if not , variables in @xmath226 can be renamed ) .",
    "we select the primed ( fresh ) variables so that @xmath683 and @xmath684 , as well .",
    "we will construct programs @xmath354 and @xmath355 so that @xmath356 is true if and only if @xmath233 and @xmath357 are stable - equivalent relative to @xmath238 .",
    "since the problem to decide whether a given qbf @xmath348 is true is @xmath282-complete , the assertion will follow .    to construct @xmath233 and @xmath357 we select an additional atom @xmath685 , and use @xmath231 , as defined in some of the arguments earlier in the paper .",
    "we set @xmath686 and define @xmath687 to simplify notation , from now on we write @xmath0 for @xmath233 and @xmath1 or @xmath357 .",
    "we note that @xmath660 , @xmath688 , @xmath689 , @xmath638 , and @xmath690 .",
    "thus , to determine whether @xmath0 and @xmath1 are stable - equivalent with respect to @xmath238 , we will focus only on pairs @xmath691 and @xmath692 that satisfy @xmath693 ( cf .",
    "lemma [ lemma : ue : a ] ) . by lemma [ lemma :",
    "ue : b ] , to identify such pairs , we need to consider models ( contained in @xmath660 ) of the two programs , and models ( again contained in @xmath660 ) of the reducts of the two programs with respect to their models . from now on in the proof , whenever we use the term `` model '' ( of a program or the reduct of a program ) we assume that it is a subset of @xmath660 .    first , one can check that the models of @xmath0 and @xmath1 coincide and are of the form : +    next , we look at models of the reducts of @xmath0 and @xmath1 with respect to their models , that is , sets of the form ( 1 ) .",
    "let @xmath72 be such a set . since @xmath694 , then every model of @xmath0 is a model of @xmath73 , and the same holds for @xmath1 .",
    "however , @xmath73 and @xmath695 have additional models .",
    "first , each reduct has as its models sets of the form + furthermore , @xmath695 has additional models , namely , sets of the form + indeed , it is easy to check that @xmath696 satisfies all rules of @xmath695 ( in the case of the rules @xmath697 , we use the fact that every sequence @xmath231 contains an atom @xmath678 or @xmath698 for some @xmath680 ) .    we will now show that @xmath348 is true if and only if @xmath0 and @xmath1 are stable - equivalent relative to @xmath238 . to this end , we will show that @xmath348 is true if and only if @xmath699 .",
    "we recall that since @xmath700 and @xmath701 , we can use lemmas [ lemma : ue : a ] and [ lemma : ue : b ] .",
    "thus , if @xmath234 , @xmath702 if and only if @xmath72 is a set of type ( 1 ) , that is , @xmath703 , for some @xmath368 , and either @xmath704 or @xmath381 is a set of type ( 2 ) , that is , @xmath705 , for some @xmath367 such that @xmath706 .",
    "the same pairs @xmath707 belong to @xmath708 ( still under the assumption that @xmath709 ) .",
    "however , @xmath708 contains also pairs @xmath707 where @xmath72 is a set of type ( 1 ) , @xmath710 _ and _ for every @xmath367 , @xmath711 ( given that the only models of @xmath695 that are proper _ supersets _ of @xmath381 and proper _ subsets _ of @xmath72 are models of type ( 2 ) , that is precisely what is needed to ensure that for every @xmath270 , @xmath712 implies @xmath713 ) .",
    "let us assume that @xmath348 is false .",
    "then , there exists @xmath368 such that for every @xmath367 , @xmath714 .",
    "let @xmath715 and @xmath716 . from our discussion",
    ", it is clear that @xmath717 but @xmath718 .",
    "thus , @xmath719 .",
    "conversely , if @xmath348 is true , then for every @xmath720 there is @xmath367 such that @xmath721 .",
    "this implies that there are no pairs @xmath717 of the last kind .",
    "thus , in that case , if @xmath234=@xmath722 , then @xmath723 if and only if @xmath724 . by lemma [ lemma : ue : a ] , @xmath725 .    combining theorem [ thm : disj : cd ] with theorem [ thm : memb3 ] yields the following result .",
    "[ cor : stbcd ] the problems @xmath629 , @xmath726 , @xmath727 and @xmath728 , are @xmath282-complete .",
    "next , we consider the problems @xmath631 , and @xmath630 .",
    "we have the following simple result .",
    "[ lemma : dc1 ] let @xmath0 and @xmath1 be programs and @xmath609 subsets of @xmath11 such that @xmath729",
    ". then , @xmath0 and @xmath1 are stable - equivalent with respect to @xmath8 if and only if @xmath0 and @xmath1 have the same stable models .",
    "let @xmath105 .",
    "since @xmath730 , we can apply the splitting theorem  @xcite to @xmath4 .",
    "it follows that @xmath72 is a stable model of @xmath4 if and only if @xmath731 , where @xmath243 is a stable model of @xmath0 and @xmath732 is a stable model of @xmath733 .",
    "similarly , @xmath72 is a stable model of @xmath5 if and only if @xmath731 , where @xmath243 is a stable model of @xmath1 and @xmath732 is a stable model of @xmath733 .",
    "thus , the assertion follows .",
    "we now use this result to determine the lower bounds on the complexity of problems @xmath631 and @xmath630 .",
    "[ thm : disj : dc ] the problems @xmath631 and @xmath630 are hard for the class @xmath282 .",
    "to be precise , we have to show that @xmath631 and @xmath630 are @xmath282-hard , for every finite @xmath96 .",
    "it is well known that the problem to decide whether a logic program @xmath0 has a stable model is @xmath620-complete @xcite .",
    "we will reduce this problem to the complement of @xmath631 ( @xmath630 , respectively ) . that will complete the proof .",
    "thus , let @xmath0 be a logic program .",
    "without loss of generality , we can assume that @xmath734 ( if not , we can rename atoms in @xmath0 , without affecting the existence of stable models ) .",
    "let @xmath236 be an atom not in @xmath9 . and define @xmath735 . clearly , @xmath736 .",
    "moreover , @xmath0 and @xmath1 do not have the same stable models if and only if @xmath0 has stable models . by lemma [ lemma : dc1 ] , @xmath0 has stable models if and only if @xmath0 and @xmath1 are not stable - equivalent relative to @xmath284 . similarly ( as @xmath10 is immaterial for the stable - equivalence in that case ) , @xmath0 has stable models if and only if @xmath0 and @xmath1 are not stable - equivalent relative to @xmath8 .",
    "we now explicitly list all cases , where we are able to give completeness results ( membership results are from theorem  [ thm : memb3 ] ) .",
    "[ cor : stbdd ] the problems @xmath630 , @xmath737 , @xmath738 and @xmath170 , are @xmath282-complete .",
    "[ cor : stbdc ] the problems @xmath631 , @xmath739 , @xmath740 and @xmath741 , are @xmath282-complete .    finally , we show @xmath632-hardness of problems @xmath633 and @xmath634 .    [ thm : disj : cc ] the problems @xmath633 and @xmath634 . are @xmath282-hard .",
    "we first show that the problem @xmath633 is @xmath282-hard , for every finite @xmath742 .",
    "let @xmath348 be a qbf , where @xmath349 is a cnf formula over @xmath350 .",
    "as in the proof of theorem [ thm : disj : cd ] , without loss of generality we can assume that every clause in @xmath349 contains a literal @xmath678 or @xmath679 , for some @xmath680 , and that @xmath743 ( if not , variables in @xmath349 can be renamed ) .",
    "let @xmath354 and @xmath357 be the programs used in the proof of theorem  [ thm : disj : cd ] , where we choose primed variables so that @xmath744 .",
    "we define @xmath745 .",
    "we have that @xmath688 and @xmath746 .",
    "we recall that the argument used in the proof of theorem [ thm : disj : cd ] to show that @xmath348 is true if and only if @xmath233 and @xmath357 are stable - equivalent with respect to @xmath238 does not depend on the finiteness of @xmath10 but only on the fact that @xmath747 .",
    "thus , the same argument shows that @xmath348 is true if and only if @xmath233 and @xmath357 are stable - equivalent with respect to @xmath533 .",
    "it follows that @xmath633 is @xmath632-hard .",
    "next , we show that the problem @xmath634 is @xmath282-hard , for every finite @xmath313",
    ". we reason as in the proof of theorem  [ thm : disj : dc ] .",
    "that is , we construct a reduction from the problem to decide whether a logic program has no stable models .",
    "specifically , let @xmath0 be a logic program .",
    "we define @xmath748 . clearly , we have @xmath749 .",
    "we recall the argument used in theorem  [ thm : disj : dc ] to show that @xmath0 has stable models if and only if @xmath0 and @xmath750 are not stable - equivalent with respect to @xmath8 does not depend on the finiteness of @xmath9 nor on @xmath10 .",
    "thus , it follows that @xmath0 has stable models if and only if @xmath0 and @xmath751 are not stable - equivalent with respect to @xmath533 and the @xmath632-hardness of @xmath634 follows .",
    "we put the things together using theorem  [ thm : norm ] for the conp - hardness and theorem  [ thm : disj : cc ] for the @xmath282-hardness .",
    "the matching upper bounds are from theorem  [ thm : memb3 ] .",
    "[ cor : stbcc ] the problem @xmath607 is conp - complete",
    ". the problems @xmath634 , @xmath633 and @xmath163 , are @xmath282-complete .",
    "we studied the complexity of deciding relativized hyperequivalence of programs under the semantics of stable , supported and supported minimal models .",
    "we focused on problems @xmath752 , where at least one of @xmath151 and @xmath753 equals @xmath16 , that is , at least one of the alphabets for the context problems is determined as the complement of the corresponding set @xmath9 or @xmath10 . as we noted , such problems arise naturally in the context of modular design of logic programs , yet they have received essentially no attention so far .    [ tab1 ]    .complexity of @xmath146 ; all entries are completeness results . [ cols=\"^,^,^,^,^,^,^,^\",options=\"header \" , ]     table [ tab1 ] summarizes the results ( for the sake of completeness we also include the complexity of direct - direct problems ) .",
    "it shows that the problems concerning supp - equivalence ( no normality restriction ) , and stable - equivalence for normal programs are all conp - complete ( cf .",
    "corollaries  [ cor : supp ] and  [ cor74 ] , respectively ) . the situation is more diversified for suppmin - equivalence and stable - equivalence ( no normality restriction ) with some problems being conp- and others @xmath282-complete . for suppmin - equivalence",
    "lower complexity requires that @xmath10 be a part of problem specification , or that @xmath9 be a part of problem specification and be set to @xmath27 .",
    "the results for direct - direct problems were known earlier @xcite , the results for the direct - complement problems are by corollary  [ cor : suppmindc ] , for the complement - complement problems results are by corollary  [ cor : suppmincc ] , and for the complement - direct problems results are by corollary  [ cor : suppmincd ] . for stable - equivalence ,",
    "the lower complexity only holds for the complement - complement problem with both @xmath9 and @xmath10 fixed as part of the problem specification .",
    "the results for direct - direct ( direct - complement , complement - complement , complement - direct , respectively ) problems are by corollary  [ cor : stbdd ] ( [ cor : stbdc ] , [ cor : stbcc ] , [ cor : stbcd ] , respectively ) in this paper",
    ". we also note that the complexity of problems for stable - equivalence is always at least that for suppmin - equivalence .",
    "our research opens questions worthy of further investigations .",
    "first , we believe that results presented here may turn out important for building `` intelligent '' programming environments supporting development of logic programs . for instance , a programmer might want to know the effect of changes she just made to a program ( perhaps already developed earlier ) that represents a module of a larger project .",
    "one way to formalize that effect is to define it as the maximal class of contexts of the form @xmath143 with respect to which the original and the revised versions of the program are equivalent ( say under the stable - model semantics ) .",
    "the sets @xmath144 and @xmath145 appearing in the specification of such a class of contexts will be of the form @xmath754 and @xmath755 , for some finite sets @xmath9 and @xmath10 .",
    "finding the appropriate sets @xmath9 and @xmath10 would provide useful information to the programmer .",
    "our results on the complexity of the complement - complement version of the hyperequivalence problem and their proofs may yield insights into the complexity of finding such sets @xmath9 and @xmath10 , and suggest algorithms .",
    "second , there are other versions of hyperequivalence that need to be investigated . for instance , while stable - equivalence when only parts of models are compared ( projections on a prespecified set of atoms ) was studied @xcite , no similar results are available for supp- and suppmin - equivalence . also the complexity of the corresponding complement - direct , direct - complement and complement - complement problems for the three semantics in that setting has yet to be established .",
    "this work was partially supported by the nsf grant iis-0325063 , the ksef grant ksef-1036-rde-008 , and by the austrian science fund  ( fwf ) under grants p18019 and p20704 .",
    "we present here proofs of some technical results we needed in the paper .",
    "we first prove lemma [ lem : new ] .",
    "we start with two auxiliary results .",
    "( @xmath760 ) since @xmath189 , @xmath130 and @xmath761 .",
    "we have @xmath762 .",
    "thus , @xmath763 and @xmath764 . since @xmath765 , @xmath766 .",
    "it follows that @xmath767 .",
    "thus , the condition ( 1 ) for @xmath759 holds .",
    "the condition ( 2 ) for @xmath759 is evident .",
    "let @xmath768 be such that @xmath769 .",
    "let @xmath770 .",
    "we have @xmath756 and so , @xmath198 . hence , @xmath771 . since @xmath199 , @xmath200 .",
    "thus , @xmath772 .",
    "it follows that @xmath773 and , consequently , @xmath119 ( as @xmath762 ) .",
    "thus , the condition ( 3 ) for @xmath759 holds .",
    "next , let @xmath768 be such that @xmath774 and @xmath775",
    ". as before , let @xmath770 .",
    "since @xmath756 and @xmath198 ( see above ) , @xmath771 , @xmath776 and @xmath777 .",
    "thus , @xmath778 . since @xmath779 , @xmath119 and the condition ( 4 ) for @xmath759 holds .",
    "finally , let @xmath780 .",
    "clearly , it follows that @xmath781 .",
    "thus , @xmath123 . since @xmath779 , @xmath782 .",
    "it follows that @xmath783 .",
    "consequently , the condition ( 5 ) for @xmath784 @xmath785 is satisfied , as well .",
    "( @xmath786 ) by the assumption , we have @xmath787 .",
    "thus , @xmath767 and , consequently , @xmath788 is a model of @xmath0 .",
    "since @xmath779 , @xmath106 is a model of @xmath0 .",
    "we also have @xmath789 . since @xmath779 , @xmath790 .",
    "thus , as @xmath200 , @xmath190 .",
    "that is , the condition ( 1 ) for @xmath298 holds .",
    "the condition ( 2 ) follows from @xmath200 and @xmath791 .",
    "let @xmath260 be such that @xmath261 .",
    "it follows that @xmath792 ( we recall that @xmath793 and @xmath200 )",
    ". let @xmath794 .",
    "we have @xmath795 and @xmath796 .",
    "thus , @xmath778 and , consequently , @xmath797 .",
    "it follows that the condition ( 3 ) for @xmath798 holds .",
    "let @xmath260 be such that @xmath799 and @xmath800 .",
    "since @xmath756 and @xmath200 , @xmath792 .",
    "let @xmath801 .",
    "it follows that @xmath795 , @xmath802 , and @xmath803 .",
    "hence , @xmath778 and so , @xmath797 .",
    "in other words , the condition ( 4 ) for @xmath798 , holds .",
    "( @xmath760 ) the arguments for the conditions ( 1 ) , ( 2 ) and ( 3 ) for @xmath811 are essentially the same as in lemma [ in1 ] ( although the argument for the condition ( 2 ) requires also the assumption that @xmath812 ) .      finally , @xmath815 ; the condition ( 5 ) for @xmath816 is thus trivially true .",
    "( @xmath786 ) as above , the arguments for the conditions ( 1 ) , ( 2 ) and ( 3 ) for @xmath298 are the same as in lemma [ in1 ] .",
    "let @xmath260 be such that @xmath813 and @xmath817 . since @xmath808 , @xmath818 .",
    "thus , @xmath819 and so , @xmath119 .",
    "that is , the condition ( 4 ) for @xmath298 , holds .",
    "finally , since @xmath820 , the condition ( 5 ) for @xmath298 , holds , as well .          if @xmath825 , then @xmath826 .",
    "thus , @xmath827 .",
    "thus , let us consider the other possibility that @xmath828 ( indeed , as @xmath829 , there are no other possibilities ) .",
    "let @xmath830 be such that @xmath831 .",
    "by lemma [ in3 ] , @xmath832 . by repeating this process",
    ", we arrive at a pair @xmath297 such that for every @xmath833 , @xmath834 . since @xmath835 , @xmath836 .",
    "@xmath205 . to this end , let us assume that there is @xmath201 such that @xmath841 . since @xmath842 , @xmath837 .",
    "thus , @xmath843 .",
    "it follows that @xmath834 and @xmath844 . since @xmath845 and @xmath300 , @xmath846 . on the other hand , @xmath191 and , since @xmath779 , @xmath847 , a contradiction .",
    "\\(2 ) it is easy to see that if we apply the construction described in ( 1 ) to @xmath115 we obtain @xmath848 such that @xmath849 and @xmath850 . indeed , in every step of the construction , we eliminate an element @xmath851 such that @xmath852 , which has no effect on the values of @xmath79 and @xmath853 .",
    "_ lemma [ cor : usuppmin:2 ] _",
    "+ _ let @xmath124 be programs and @xmath313 .",
    "if @xmath314 , then there is @xmath315 such that @xmath106 is a model of exactly one of @xmath0 and @xmath1 , or there is @xmath316 such that @xmath317 belongs to exactly one of @xmath318 and @xmath319 .",
    "_    let us assume that @xmath0 and @xmath1 have the same models ( otherwise , there is @xmath315 that is a model of exactly one of @xmath0 and @xmath1 , and the assertion follows ) . without loss of generality",
    "we can assume that there is @xmath854 .",
    "moreover , by lemma [ lem : new ] , we can assume that @xmath315 ( recall @xmath855 ) .",
    "it follows that @xmath115 satisfies the conditions ( 1)-(5 ) for @xmath856 .",
    "since @xmath0 and @xmath1 have the same models , @xmath115 satisfies the conditions ( 1)-(4 ) for @xmath857 .",
    "hence , @xmath115 violates the condition ( 5 ) for @xmath857 , that is , @xmath122 and @xmath858 hold .",
    "in particular , there is @xmath859 .",
    "we will show that @xmath860 and @xmath861 .",
    "further , let @xmath260 be such that @xmath865 and @xmath866 . then @xmath867",
    "we have @xmath868 , @xmath316 , and @xmath869 .",
    "thus , @xmath870 .",
    "it follows that @xmath871 and @xmath872 . since @xmath873 and @xmath874 , @xmath875 ,",
    "that is , @xmath119 .",
    "thus , the condition ( 4 ) for @xmath860 holds .    since @xmath870 , @xmath876",
    "thus , we also have to verify the condition ( 5 ) .",
    "we have @xmath123 ( we recall that @xmath868 ) and so , @xmath877 .",
    "consequently , @xmath878 .",
    "hence , the condition ( 5 ) holds and @xmath860 . on the other hand , @xmath879 and @xmath880",
    "thus , the condition ( 5 ) for @xmath881 does not hold and so , @xmath882 .",
    "next , we present proofs of the technical results needed in section [ stabeq ] : lemmas [ stin1e ] and [ lemma : ue ] .",
    "first , we establish some auxiliary results .",
    "we start with conditions providing conditions restricting @xmath253 and @xmath106 given that @xmath883 .",
    "let @xmath884 .",
    "the inclusion @xmath885 follows from the condition ( 2 ) . to prove @xmath886 ,",
    "let us assume to the contrary that @xmath887 .",
    "let @xmath888 .",
    "we have @xmath130 and thus @xmath889 .",
    "since @xmath762 , @xmath890 .",
    "thus , @xmath891 . since @xmath199 , taking @xmath892 shows that @xmath115 violates the condition ( 3 ) for @xmath884 , a contradiction .",
    "the case of the condition ( 1 ) is clear . since @xmath779 , @xmath130 if and only if @xmath763 .",
    "it is also evident that @xmath131 if and only if @xmath899 , @xmath116 if and only if @xmath900 , and @xmath132 if and only if @xmath901 .",
    "thus , the corresponding conditions ( 2 ) are also equivalent .",
    "let us assume the condition ( 3 ) for @xmath896 .",
    "let @xmath902 be such that @xmath903 .",
    ". then @xmath771 and @xmath905 ( as @xmath198 ) .",
    "by the condition ( 3 ) for @xmath896 , @xmath906 .",
    "since @xmath779 , @xmath907 , and so , the condition ( 3 ) for @xmath898 follows .",
    "conversely , let us assume the condition ( 3 ) for @xmath908 and let @xmath260 be such that @xmath909 .",
    "it follows that @xmath792 .",
    "we set @xmath794 .",
    "clearly , @xmath910 and @xmath911 .",
    "thus , @xmath912 .",
    "as @xmath779 , @xmath134 and , so , the condition ( 3 ) for @xmath896 follows .",
    "next , let us assume the condition ( 4 ) for @xmath896 .",
    "let @xmath913 be such that @xmath914 and @xmath915 , or @xmath916 and @xmath917 .",
    "let @xmath770 .",
    "we have @xmath771 .",
    "moreover , it is evident that @xmath918 and @xmath919 , or @xmath920 and @xmath921 .",
    "thus , @xmath906 and so , @xmath907 .",
    "similarly , let the condition ( 4 ) for @xmath908 hold .",
    "let @xmath260 be such that @xmath922 and @xmath923 , or @xmath924 and @xmath925 .",
    "since @xmath756 and @xmath895 , @xmath792 .",
    "we define @xmath926 and note that @xmath795 . moreover , as @xmath756 and @xmath198 , @xmath927 and @xmath928 , or @xmath929 and @xmath930 .",
    "thus , @xmath912 and so , @xmath134 .",
    "finally , a similar argument works also for the condition ( 5 ) .",
    "let the condition ( 5 ) for @xmath896 hold .",
    "thus , there is @xmath931 such that @xmath140 and @xmath567 .",
    "let @xmath794 . since @xmath756 and @xmath895 , @xmath792 .",
    "thus , @xmath932 and @xmath933 .",
    "moreover , since @xmath567 , @xmath934 . conversely , let the condition ( 5 ) for @xmath908 hold .",
    "then , there is @xmath935 such that @xmath936 and @xmath937 .",
    "let @xmath770 .",
    "then @xmath938 , @xmath939 and @xmath940 .",
    "the case of the condition ( 1 ) is evident . by our assumptions , neither @xmath131 nor @xmath947 .",
    "moreover , @xmath116 if and only if @xmath948 and @xmath132 if and only if @xmath949 ( since @xmath950 and @xmath951 ) . thus , the corresponding versions of the condition ( 2 ) are also equivalent .",
    "the case of the condition ( 3 ) can be argued in the same way as it was in lemma [ stin1a ] .",
    "let us assume the condition ( 4 ) for @xmath896 .",
    "let @xmath913 be such that @xmath922 and @xmath923 , or @xmath924 and @xmath925 . clearly ,",
    ". consequently , by the condition ( 4 ) for @xmath896 , @xmath134 and so , @xmath907 .",
    "thus the condition ( 4 ) for @xmath952 holds .",
    "conversely , let the condition ( 4 ) for @xmath952 hold .",
    "let @xmath260 be such that @xmath922 and @xmath923 , or @xmath924 and @xmath925 .",
    "if @xmath913 , then @xmath907 ( as the condition ( 4 ) for @xmath952 holds ) .",
    "thus , @xmath134 . otherwise , i.e.  for @xmath953 , we have @xmath954 . let @xmath955 .",
    "it follows that @xmath910 and @xmath921 ( the former , as @xmath956 ; the later , as @xmath957 ) .",
    "thus , @xmath910 , @xmath920 and @xmath958 .",
    "consequently , @xmath912 ( again , as the condition ( 4 ) for @xmath952 holds ) .",
    "thus , also in that case , @xmath134 .",
    "it follows that the condition ( 4 ) for @xmath959 holds .",
    "finally , for the condition ( 5 ) we reason as follows .",
    "let the condition ( 5 ) for @xmath896 hold .",
    "thus , there is @xmath931 such that @xmath140 and @xmath567 .",
    "clearly , @xmath960 ( as @xmath812 and @xmath895 ) .",
    "thus , @xmath961 and so @xmath567 follows .",
    "conversely , let the condition ( 5 ) for @xmath952 hold .",
    "then , there is @xmath962 such that @xmath963 and @xmath567 .",
    "clearly , we also have @xmath139 and so , the condition ( 5 ) for @xmath896 follows .                by applying repeatedly lemma [ stin1a ] and then lemma [ stin1b ] , we can construct sets @xmath974 and @xmath975 such that + if @xmath976 , ( i ) follows ( with @xmath977 ) .",
    "otherwise , ( ii ) follows ( by lemma [ stin1c ] ) .",
    "( @xmath786 ) if ( i ) holds , then @xmath639 follows from lemma [ stin1a ] .",
    "thus , let us assume that ( ii ) or ( iii ) holds . then @xmath978 and so , @xmath979 ( respectively , @xmath980 ) . moreover , @xmath981 .",
    "thus , since @xmath982 , the condition ( 2 ) for @xmath639 holds .",
    "next , it is evident that the condition ( 3 ) is vacuously true .",
    "the condition ( 4 ) is also vacuously true . to see it ,",
    "let us consider @xmath260 such that @xmath922 and @xmath923 , or @xmath924 and @xmath925 . since @xmath983 , @xmath984 .",
    "thus , @xmath985 , and so @xmath922 is impossible .",
    "consequently , @xmath986 and @xmath925 .",
    "the latter implies @xmath677 .",
    "we also have @xmath260 .",
    "thus , @xmath987 , contradicting ( ii ) .",
    "it follows that ( iii ) holds . consequently , @xmath988 . since @xmath924 , @xmath989 , a contradiction .",
    "thus , let us assume that @xmath997 .",
    "next , let us assume that @xmath998 and let @xmath999 . clearly , @xmath1000 , @xmath1001 and @xmath1002 . by the condition ( 4 ) for @xmath644 , @xmath1003 . on the other hand , by the condition ( 1 ) for @xmath644 , @xmath191 .",
    "consequently , @xmath1004 .",
    "it follows that @xmath1005 , a contradiction .",
    "it follows that @xmath1006 . if there are @xmath1007 such that @xmath1008 and @xmath1009 , then let us define @xmath1010 .",
    "it is easy to verify that @xmath270 contradicts the condition ( 4 ) .",
    "if @xmath1011 , then ( ii ) follows ( with the only element of @xmath1012 as @xmath851 ) . otherwise , @xmath1013 and @xmath1014 . in this case , ( iii ) follows ( with @xmath1015 ) .          , odintsov , s. , pearce , d. , and valverde , a. 2006 . analysing and extending well - founded and partial stable semantics using partial equilibrium logic . in _ proceedings of the 22nd international conference ( iclp 2006 )",
    ", s.  etalle and m.  truszczyski , eds .",
    "lncs , vol .",
    "springer , berlin , new york , 346360 .        \\2003 .",
    "uniform equivalence of logic programs under the stable model semantics . in _ proceedings of the 19th international conference on logic programming ( iclp 2003 ) _ , c.  palamidessi , ed .",
    "lncs , vol .",
    "springer , berlin , new york , 224238 .        , tompits , h. , and woltran , s. 2005 . on solution correspondences in answer - set programming . in _ proceedings of the 19th international joint conference on artificial intelligence ( ijcai 2005 ) _ , l.  p. kaelbling and a.  saffiotti , eds .",
    "professional book center , 97102 .",
    "definitions in answer set programming : ( extended abstract ) . in _ proceedings of the 7th international conference on logic programming and nonmonotonic reasoning ( lpnmr 2004 ) _",
    ", v.  lifschitz and i.  niemel , eds .",
    "lncs , vol .",
    "springer , berlin , new york , 483484 .      ,",
    "liu , l. , namasivayam , g. , neumann , a. , schaub , t. , and truszczyski , m. 2007 . the first answer set programming system competition . in _ proceedings of the 9th international conference on logic programming and nonmonotonic reasoning ( lpnmr 2007 ) _ , c.  baral , g.  brewka , and j.  schlipf , eds .",
    "lncs , vol .",
    "springer , berlin , new york , 317 .",
    "\\2002 . representing knowledge in a - prolog . in _ computational logic : logic programming and beyond , essays in honour of robert a. kowalski , part ii _ ,",
    "a.  kakas and f.  sadri , eds .",
    "lncs , vol .",
    "springer , berlin , new york , 413451 .",
    "equivalence of logic programs under updates . in _ proceedings of the 9th european conference on logics in artificial intelligence ( jelia 2004 ) _ , j.  alferes and j.  leite , eds .",
    "lncs , vol .",
    "springer , berlin , new york , 174186 .",
    ", oikarinen , e. , tompits , h. , and woltran , s. 2007 .",
    "modularity aspects of disjunctive stable models . in _ proceedings of the 9th international conference on logic programming and nonmonotonic reasoning ( lpnmr 2007 ) _",
    ", c.  baral , g.  brewka , and j.  schlipf , eds .",
    "lnai , vol .",
    "springer , berlin , new york , 175187 .",
    "\\2002 . reducing strong equivalence of logic programs to entailment in classical propositional logic . in _ proceedings of the 8th international conference on principles of knowledge representation and reasoning ( kr 2002 ) _ , d.  fensel , d.  mcguinness , and m .- a .",
    "williams , eds .",
    "morgan kaufmann , 170176 .",
    "stable models and an alternative logic programming paradigm .",
    "in _ the logic programming paradigm : a 25-year perspective _ , k.  apt , w.  marek , m.  truszczyski , and d.  warren , eds .",
    "springer , berlin , new york , 375398 .      , tompits , h. , and woltran , s. 2007 .",
    "facts do not cease to exist because they are ignored : relativised uniform equivalence with answer - set projection . in _ proceedings of the 22nd national conference on artificial intelligence ( aaai 2007)_. aaai press , 458464 .",
    "modular equivalence for normal logic programs . in",
    "_ proceedings of the 17th european conference on artificial intelligence ( ecai 2006 ) _ , g.  brewka , s.  coradeschi , a.  perini , and p.  traverso , eds .",
    "ios press , amsterdam , 412416 .",
    "characterizations for relativized notions of equivalence in answer set programming . in _ proceedings of the 9th european conference on logics in artificial intelligence ( jelia 2004 ) _ , j.  alferes and j.  leite , eds .",
    "lncs , vol .",
    "springer , berlin , new york , 161173 ."
  ],
  "abstract_text": [
    "<S> a recent framework of relativized hyperequivalence of programs offers a unifying generalization of strong and uniform equivalence . </S>",
    "<S> it seems to be especially well suited for applications in program optimization and modular programming due to its flexibility that allows us to restrict , independently of each other , the head and body alphabets in context programs . </S>",
    "<S> we study relativized hyperequivalence for the three semantics of logic programs given by stable , supported and supported minimal models . for each semantics , we identify four types of contexts , depending on whether the head and body alphabets are given directly or as the _ complement _ of a given set . </S>",
    "<S> hyperequivalence relative to contexts where the head and body alphabets are specified directly has been studied before . in this paper , we establish the complexity of deciding relativized hyperequivalence with respect to the three other types of context programs .    </S>",
    "<S> [ firstpage ]    # 1    answer - set programming , strong equivalence , uniform equivalence , relativized equivalence , stable models , supported models , minimal models , complexity </S>"
  ]
}