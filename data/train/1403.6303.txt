{
  "article_text": [
    "_ timed automata _ were introduced by alur and dill  @xcite , and have since then become a popular standard formalism to model real - time systems .",
    "an undeniable reason for the success of timed automata is the @xmath0 decidability of the _ language emptiness problem _  @xcite .",
    "a major drawback of timed automata is the undecidability  @xcite of the _ language inclusion problem _ : given two timed automata @xmath1 and @xmath2 , does @xmath3 hold ?",
    "the undecidability of this problem prohibits the usage of automated verification algorithms for analysing timed automata , where @xmath2 can be seen as the specification that is supposed to be satisfied by the system modelled by @xmath1 .",
    "however , if @xmath2 is restricted to have at most one clock , then the language inclusion problem over finite timed words is decidable ( albeit with non - primitive recursive complexity )  @xcite . as other important milestones in the success story of timed automata",
    "we would like to mention the decidability of bisimulation  @xcite , the decidability of the _ model checking problem _ for timed automata and a timed extension of ctl  @xcite , and , more recently , the decidability of the model checking problem for timed automata and metric temporal logic ( mtl , for short ) over finite timed words  @xcite .    timed automata can express many interesting time - related properties , and even with the restriction to a single clock , they allow one to model a large class of systems , including , for example , the internet protocol tcp  @xcite . if we want to reason about real - time programs with procedure calls , or about the number of events occurring in computations of real - time systems , we have to extend the model of timed automata with unbounded discrete data structures . in 1994 , bouajjani et al .",
    "@xcite extended timed automata with discrete counters and a pushdown stack , and proved that the satisfiability of reachability properties for several subclasses of this model is decidable .",
    "nine years later , it was shown that the binary reachability relation for _ timed pushdown systems _ is decidable  @xcite .",
    "decidability of the reachability problem was also proved for several classes of _ timed counter systems _",
    "@xcite , mainly by simple extensions of the classical region - graph construction  @xcite .",
    "the language inclusion problem , however , is to the best of our knowledge only considered in  @xcite for the class of timed pushdown systems . in",
    "@xcite it is stated that the language inclusion problem is decidable if @xmath1 is a timed pushdown automaton , and @xmath2 is a one - clock timed automaton .",
    "the proof is based on an extension of the proof for the decidability of the language inclusion problem for the case that @xmath1 is a timed automaton without pushdown stack  @xcite . unfortunately , and as is well known , the proof in  @xcite is not correct .    in this paper , we prove that different to what is claimed in  @xcite , the language inclusion problem for the case that @xmath1 is a pushdown timed automaton and @xmath2 is a one - clock timed automaton is undecidable .",
    "this is even the case if @xmath1 is a deterministic instance of a very restricted subclass of timed pushdown automata called _ timed visibly one - counter nets_. on the other hand , we prove that the language inclusion problem is decidable if @xmath1 is a timed automaton and @xmath2 is a timed automaton extended with a finite set of counters that can be incremented and decremented , and which we call _ timed counter nets_. as a special case , we obtain the decidability of the _ universality problem _ for timed counter nets : given a timed automaton @xmath2 with input alphabet @xmath4 , does @xmath5 accept the set of all timed words over @xmath4 ?",
    "finally , we give the precise decidability border for the universality problem by proving that the universality problem is undecidable for the class of _ timed visibly one - counter automata_. we remark that all results apply to extensions of timed automata over _ finite _ timed words .",
    "we use @xmath6 , @xmath7 and @xmath8 to denote the integers , the non - negative integers and the non - negative reals , respectively .",
    "we use @xmath4 to denote a finite alphabet . a _ timed word _ over @xmath4 is a non - empty finite sequence @xmath9 such that the sequence @xmath10 of timestamps is non - decreasing .",
    "we say that a timed word is _ strictly monotonic _ if @xmath11 for every @xmath12 .",
    "we use @xmath13 to denote the set of finite timed words over @xmath4 .",
    "a set @xmath14 is called a _ timed language_.    let @xmath15 be a finite set of _ clock variables _ ranging over @xmath8 .",
    "we define _ clock constraints _ @xmath16 over @xmath15 to be conjunctions of formulas of the form @xmath17 , where @xmath18 , @xmath19 , and @xmath20 .",
    "we may use @xmath21 as abbreviation for @xmath22 .",
    "we use @xmath23 to denote the set of all clock constraints over @xmath15 . for the case that @xmath15 is the empty set",
    ", we set @xmath24 . a _ clock valuation _ is a mapping from @xmath15 to @xmath8 .",
    "a clock valuation @xmath25 satisfies a clock constraint @xmath16 , written @xmath26 , if @xmath16 evaluates to true according to the values given by @xmath25 . for @xmath27 and @xmath28 , we define @xmath29 to be @xmath30 for each @xmath18 , and we define @xmath31 $ ] by @xmath32)(x)=0 $ ] if @xmath33 , and @xmath32)(x)=\\nu(x)$ ] otherwise .",
    "let @xmath34 be a finite stack alphabet .",
    "we use @xmath35 to denote the set of finite words over @xmath34 , including the empty word denoted by @xmath36 .",
    "we define a finite set @xmath37 of _ stack operations _ by @xmath38 .",
    "a _ timed pushdown automaton _ is a tuple @xmath39 , where    * @xmath40 is a finite set of _ locations _ , * @xmath41 is the set of initial locations , * @xmath42 is the set of accepting locations , * @xmath43 is a finite set of edges .",
    "a _ state _ of @xmath1 is a triple @xmath44 , where @xmath45 is the current location , the clock valuation @xmath25 represents the current values of the clocks , and @xmath46 represents the current stack content , where the top - most symbol of the stack is the left - most symbol in the word @xmath47 , and the empty word @xmath36 represents the empty stack .",
    "we use @xmath48 to denote the set of all states of @xmath1 .",
    "a timed pushdown automaton @xmath1 induces a transition relation @xmath49 on @xmath50 as follows : @xmath51 , if , and only if , there exists some edge @xmath52 such that @xmath53 , @xmath54 $ ] , and ( i ) if @xmath55 for some @xmath56 , then @xmath57 ; ( ii ) if @xmath58 for some @xmath56 , then @xmath59 ; ( iii ) if @xmath60 , then @xmath61 ; ( iv ) if @xmath62 , then @xmath63 . a _ run _ of @xmath1 is a finite sequence @xmath64 such that @xmath65 for every @xmath66 .",
    "a run is called _ successful _ if @xmath67 , @xmath68 for every @xmath69 , @xmath70 , and @xmath71 . with a run we associate the timed word @xmath72 . the language accepted by the timed pushdown automaton @xmath1 , denoted by @xmath73 ,",
    "is defined to be the set of timed words @xmath74 for which there exists a successful run of @xmath1 that @xmath75 is associated with .",
    "next we define some subclasses of timed pushdown automata ; see figure 1 for a graphical overview .",
    "we start with timed extensions of _ one - counter automata _",
    "@xcite and _ one - counter nets _  @xcite .",
    "a _ timed one - counter automaton _ is a timed pushdown automaton where the stack alphabet is a singleton . by writing @xmath76 and @xmath77 we mean that we increment and decrement the counter , respectively , whereas @xmath78 corresponds to a zero test .",
    "a _ timed one - counter net _ is a timed one - counter automaton without zero tests , _ i.e. _ , the @xmath78 operation is not allowed .",
    "we remark that for both classes , the execution of an edge of the form @xmath79 is _ blocked _ if the stack is empty .",
    "next , we consider the timed extension of an interesting subclass of pushdown automata called _ visibly pushdown automata _  @xcite .",
    "a _ timed visibly pushdown automaton _ is a timed pushdown automaton for which the input alphabet @xmath4 can be partitioned into three pairwise disjoint sets @xmath80 of _ internal _ , _ call _ , and _ return _ input symbols , respectively , and such that for every edge @xmath81 the following conditions are satisfied :    * @xmath82 if , and only if , @xmath62 , * @xmath83 , if , and only if , @xmath84 for some @xmath85 , * @xmath86 if , and only if , @xmath60 or @xmath87 for some @xmath85 .    a _ timed visibly one - counter automaton _",
    "( timed visibly one - counter net , respectively ) is a timed one - counter automaton ( timed one - counter net , respectively ) that is also a timed visibly pushdown automaton .",
    "we say that a timed visibly one - counter net with no clocks is _ deterministic _ if for all @xmath88 , @xmath89 with @xmath90 we have either @xmath91 and @xmath92 , or @xmath93 and @xmath94 .",
    "finally , we define the class of _ timed counter nets _ , which generalizes timed one - counter nets , but is not a subclass of timed pushdown automata .",
    "a timed counter net of dimension @xmath95 is a tuple @xmath96 , where @xmath97 are the sets of locations , initial locations and accepting locations , respectively , and @xmath98 is a finite set of edges .",
    "a state of a timed counter net is a triple @xmath99 , where @xmath45 , @xmath25 is a clock valuation , and @xmath100 is a vector representing the current values of the counters . we define @xmath101 if , and only if , there exists some edge @xmath102 such that @xmath53 , @xmath54 $ ] , and @xmath103 , where vector addition is defined pointwise .",
    "note that , similar to pop operations on an empty stack , transitions which result in the negative value of one of the counters are _",
    "blocked_. the notions of _ runs _ , _ successful runs _ , _ associated timed words _ and _ the language accepted by @xmath1 _ , are defined analogously to the corresponding definitions for timed pushdown automata .",
    "( 123,52)(0,-52 )    ( n0)(68.0,-9.0 ) ( 52,-8)one - clock timed ( 51,-12)pushdown automata    ( n1)(18.0,-9 )    ( -2,-8)one - clock timed visibly ( 1,-12)pushdown automata    ( n2)(18.0,-26.0 ) ( -2,-25)one - clock timed visibly ( -.5,-29)one - counter automata    ( n3)(68.0,-26.0 ) ( 53,-25)one - clock timed ( 49.5,-29)one - counter automata    ( n4)(18.0,-43.0 ) ( -2,-42)one - clock timed visibly ( 3,-46)one - counter nets    ( n5)(68.0,-43.0 ) ( 53,-42)one - clock timed ( 53,-46)one - counter nets    ( n6)(113.0,-43.0 ) ( 100,-42)one - clock timed ( 103,-46)counter nets    ( nets)(61,-43 ) ( onecounter)(41,-35 ) ( visibly)(18,-28 )    ( n4,n2 )    ( n2,n1 )    ( n1,n0 )    ( n3,n0 )    ( n5,n3 )    ( n4,n5 )    ( n2,n3 )    ( n5,n6 )    ( o)(4,-63.5)a ( p)(11,-63.5)b ( o , p )",
    "in this section , we present the main results of the paper .",
    "we are interested in the language inclusion problem @xmath3 , where @xmath1 and @xmath2 are extensions of timed automata with discrete data structures .",
    "recall that according to standard notation in the field of verification , in this problem formulation @xmath2 is seen as the _ specification _ , and @xmath1 is the system that should satisfy this specification , _",
    "i.e. _ , @xmath1 should be a _ model _ of @xmath2 .",
    "as a special case of this problem , we consider the universality problem , _ i.e. _ , the question whether @xmath104 for a given automaton @xmath2 . in general ,",
    "the two problems are undecidable for timed pushdown automata .",
    "this follows on the one hand from the undecidability of the universality problem for timed automata  @xcite , and on the other hand from the undecidability of the universality problem for pushdown automata .",
    "in fact , it is long known that the universality problem is undecidable already for non - deterministic one - counter automata  @xcite",
    ".    however , there are interesting decidability results for subclasses of timed pushdown automata : the language inclusion problem is decidable if @xmath1 is a timed automaton , and @xmath2 is a timed automaton with at most one clock  @xcite . as a special case ,",
    "the universality problem for timed automata is decidable if only one clock is used .",
    "the language inclusion problem is also decidable if @xmath1 is a one - counter net and @xmath2 is a finite automaton , and if @xmath1 is a finite automaton and @xmath2 is a one - counter net  @xcite .",
    "the universality problem for non - deterministic one - counter nets has recently been proved to have non - primitive recursive complexity  @xcite .",
    "further we know that the universality and language inclusion problems are decidable if @xmath1 and @xmath2 are visibly pushdown automata  @xcite .    hence it is interesting to consider the two problems for the corresponding subclasses of timed pushdown automata .",
    "it turns out that the decidability status changes depending on whether the _ model _ uses a stack ( or , more detailed : a counter ) or not . as a first main result we present :    [ theorem_main_lang_inc ]",
    "the language inclusion problem is undecidable if @xmath1 is a timed visibly one - counter net and @xmath2 is a timed automaton , even if @xmath1 is deterministic and has no clocks , and @xmath2 uses at most one clock .",
    "we remark that this result corrects theorem 2 in  @xcite , in which it is claimed that the language inclusion problem for the case that @xmath1 is a timed pushdown automaton and @xmath2 is a one - clock timed automaton is decidable .",
    "the incorrectness of the proof of theorem 2 in  @xcite , respectively that of theorem 1 , which the proof for theorem 2 builds upon , was already asserted in  @xcite . since then the problem of whether language inclusion is decidable or not has been open .",
    "in contrast to theorem [ theorem_main_lang_inc ] , we have decidability for the following classes :    [ theorem_main_dec ] the language inclusion problem is decidable with non - primitive recursive complexity if @xmath1 is a timed automaton and @xmath2 is a one - clock timed counter net .    as a special case of this result ( and with the lower bound implied by the corresponding result for one - clock timed automata  @xcite ) , we obtain :    [ corollary_univ_dec ] the universality problem for one - clock timed counter nets is decidable with non - primitive recursive complexity .",
    "the next two sections are devoted to the proofs of theorems [ theorem_main_lang_inc ] and [ theorem_main_dec ] .",
    "we will also give some interesting consequences of these results and their proofs .",
    "amongst others , we prove the undecidability of the model checking problem for timed visibly one - counter nets and mtl over finite timed words ,  the decidability of the same problem for timed automata  @xcite .",
    "after this , in sect . 5 , we will prove the following theorem :    [ theorem_univ_undec ] the universality problem for one - clock timed visibly one - counter automata is undecidable .",
    "this is in contrast to the decidability of the universality problem for the two underlying models of one - clock timed automata  @xcite and visibly one - counter automata , which form a subclass of visibly pushdown automata  @xcite .",
    "we also want to point out that this result is stronger than a previous result on the undecidability of the universality problem for one - clock timed visibly pushdown automata ( theorem 3 in  @xcite ) , and our proof closes a gap in the proof of theorem 3 in  @xcite .",
    "further , we can infer from corollary [ corollary_univ_dec ] and theorem [ theorem_univ_undec ] the exact decidability border for the universality problem of timed pushdown automata , which lies between timed visibly one - counter nets and timed visibly one - counter automata .",
    "in this section , we prove theorem [ theorem_main_lang_inc ] . the proof is a reduction of an undecidable problem for _ channel machines_.      let @xmath105 be a finite alphabet .",
    "we define the order @xmath106 over the set of finite words over @xmath105 by @xmath107 if there exists a strictly increasing function @xmath108 such that @xmath109 for every @xmath110 .    a _ channel machine _ consists of a finite - state automaton acting on an unbounded fifo channel .",
    "formally , a channel machine is a tuple @xmath111 , where    * @xmath112 is a finite set of _ control states _ , * @xmath113 is the initial control state , * @xmath114 is a finite set of _ messages _ , * @xmath115 is the transition relation over the label set @xmath116 .    here , @xmath117 corresponds to a @xmath118 operation , @xmath119 corresponds to a @xmath120 operation , and @xmath78 is a test which returns @xmath21 if and only if the channel is empty . without loss of generality , we assume that @xmath121 does not have any incoming transitions , _",
    "i.e. _ , @xmath122 implies @xmath123 .",
    "further , we assume that @xmath124 implies @xmath125 .",
    "a _ configuration _ of @xmath126 is a pair @xmath127 , where @xmath128 is the control state and @xmath129 represents the contents of the channel .",
    "we use @xmath130 to denote the set of all configurations of @xmath126 . the rules in @xmath131",
    "induce a transition relation @xmath132 on @xmath133 as follows :    * @xmath134 if , and only if , there exists some transition @xmath135 and @xmath136 , _ i.e. _ , @xmath137 is added to the tail of the channel . *",
    "@xmath138 if , and only if , there exists some transition @xmath139 and @xmath140 , _",
    "i.e. _ , @xmath137 is removed from the head of the channel . *",
    "@xmath141 if , and only if , there exists some transition @xmath142 and @xmath143 , _ i.e. _ , the channel is empty , and @xmath144 .    we may write @xmath145 whenever @xmath146 . next , we define a second transition relation @xmath147 on @xmath133 . the relation @xmath147 is a superset of @xmath148 .",
    "it contains some additional transitions which result from _ insertion errors_. we define @xmath149 , if , and only if , there exist @xmath150 such that @xmath151 , @xmath152 , and @xmath153 . we may also write @xmath154 whenever @xmath155 .",
    "a _ computation _ of @xmath126 is a finite sequence @xmath156 such that @xmath157 for every @xmath158 .",
    "we say that a computation is _ error - free _",
    "if for all @xmath158 we have @xmath159 . otherwise , we say that the computation is _",
    "faulty_.    the proof of theorem [ theorem_main_lang_inc ] is a reduction from the following undecidable  @xcite control state reachability problem : given a channel machine @xmath126 with control states @xmath112 and @xmath160 , does there exist an error - free computation of @xmath126 from @xmath161 to @xmath162 for some @xmath129 ?",
    "we remark that the analogous problem for faulty computations is decidable with non - primitive recursive complexity  @xcite : both the lower and upper bound can be proved using corresponding results for _ lossy channel machines _",
    "@xcite .",
    "[ example_encoding ] define a channel machine @xmath163 by @xmath164 , @xmath165 , and @xmath166 .",
    "the computation @xmath167 is faulty due to the last but one transition , where the symbol @xmath168 is an insertion error .",
    "it is easy to see that there exists no error - free computation from @xmath161 to @xmath162 for some @xmath169 .",
    "the idea of our reduction is as follows : given a channel machine @xmath126 , we define a timed language @xmath170 consisting of all timed words that encode potentially faulty computations of @xmath126 that start in @xmath161 and end in @xmath162 for some @xmath129 .",
    "then we define a timed visibly one - counter net @xmath1 such that @xmath171 contains exactly _ error - free _ encodings of such computations . in other words , we use @xmath1 to exclude the encodings of faulty computations from @xmath170 , obtaining undecidability of the non - emptiness problem for @xmath171 .",
    "finally , we define a one - clock timed automaton @xmath2 that accepts the complement of @xmath170 ; hence the problem of deciding whether @xmath172 is undecidable .      for the remainder of section 4 , consider a channel machine @xmath111 and let @xmath160 .",
    "define @xmath173 , @xmath174 , and @xmath175 , where @xmath176 and @xmath177 are fresh symbols that do not occur in @xmath178 .",
    "the symbols @xmath176 are called _",
    "wildcard symbols_. we define a timed language @xmath170 over @xmath80 that consists of all timed words that encode computations of @xmath126 from @xmath161 to @xmath162 for some @xmath129 .",
    "the definition of @xmath170 follows the ideas presented in  @xcite , in which ( a dual variant of ) the control state reachability problem for channel machines is reduced to the satisfiability problem for mtl over timed words .    in general , the idea is to encode a configuration of @xmath126 of the form @xmath179 by a timed word of duration one .",
    "this timed word starts with the symbol @xmath180 at some time @xmath181 .",
    "if the content of the channel @xmath169 is of the form @xmath182 , then @xmath180 is followed by the symbols @xmath183 in this order .",
    "the timestamps of these symbols must be strictly monotonic and in the interval @xmath184 .",
    "due to the denseness of the time domain , one can indeed store the channel content in one time unit without any upper bound on @xmath185 .    the initial configuration @xmath186 is encoded by a single - letter timed word , for instance by @xmath187 .",
    "the configuration @xmath188 may be encoded by the timed word @xmath189 .",
    "the choice of the timestamps is arbitrary as long as the timestamps of the message symbols are in the unit interval determined by the timestamp of the preceding control state .    to encode a computation of a channel machine , we concatenate the encodings of each of the participating configurations in the following way .",
    "encodings of consecutive configuration have a time distance of exactly two time units .",
    "one time unit before the encoding of the next configuration we store the label of the transition .",
    "further , each message symbol in the encoding of the current configuration has a matching copy in the encoding of the next configuration , after exactly two time units , and in accordance with the following rules : if the next transition is sending a new message symbol @xmath137 to the tail of the channel , we add @xmath137 to the tail of the encoding of the next configuration .",
    "if the next transition is reading @xmath137 from the head of the channel , we test whether the first symbol after the control state in the encoding of the current configuration equals @xmath137 , and if so , we remove it from the encoding of the next configuration .",
    "the transition @xmath190 may be encoded by @xmath191 the symbol @xmath192 at time @xmath193 has a matching copy exactly two time units later ; the symbol @xmath194 at @xmath195 does not , because it is removed from the channel by the transition .",
    "this idea of encoding computations of channel machines was used for proving lower complexity bounds for the satisfiability problem of mtl  @xcite and the universality problem for one - clock timed automata  @xcite .",
    "these problems , however , are decidable  @xcite , whereas here we want to use the encoding to show undecidability of a problem .",
    "the crucial point is that the encoding explained above does not exclude timed words that are encoding _ faulty _ computations of a channel machine : for excluding encodings of faulty computations , we need to require that every message symbol has not only a matching copy _ after _ two time units , but also a matching copy two time units _",
    "before_. in other words , it should not be possible that message symbols appear `` all of a sudden '' , _",
    "i.e. _ , without a corresponding error - free transition .",
    "the faulty transition @xmath196 may be encoded by @xmath197 as in the previous example , the symbol @xmath192 at time @xmath193 has a matching copy exactly two time units later ; the symbol @xmath194 at @xmath195 does not , because it is removed from the channel by the encoded transition .",
    "however , the symbol @xmath168 at time @xmath198 appears all of a sudden , _",
    "i.e. _ , without any matching copy two time units before .",
    "this corresponds to an insertion error in the computation , see example [ example_encoding ] .",
    "the above described _ backward - looking conditions _",
    ", however , can not be expressed by neither mtl formulas , nor by one - clock timed automata . due to this failure",
    ", it is only the control state reachability problem _ for faulty computations _ that can be reduced to the satisfiability problem for mtl respectively the universality problem for one - clock timed automata . as mentioned before , the control state reachability problem for faulty computations is _ decidable _  @xcite .",
    "for our undecidability proof to work , we have to exclude encodings of faulty computations .",
    "in other words , we have to exclude timed words in which message symbols occur without any matching copy two time units before .",
    "this will be carried out by the counter of the visibly timed one - counter net @xmath1 .",
    "for this to work , we have to change the encoding in some details , as explained in the following .",
    "assume we want to encode a given error - free computation of @xmath126 .",
    "let @xmath95 be the maximum length of the channel content during this computation .",
    "let us assume for a moment that @xmath126 does not start its computation with the empty channel , but the channel contains the word @xmath199 , _",
    "i.e. _ , @xmath95 occurrences of the wildcard symbol @xmath200 .",
    "the semantics of @xmath126 is changed in the following way : if a message @xmath137 is sent , then , instead of adding @xmath137 to the tail of the channel , the first @xmath200 occurring in the channel is _ replaced _ by @xmath137 .",
    "if a message @xmath137 is read , then , it is tested whether the first symbol in the channel is @xmath137 .",
    "if this the case , it is removed from the channel and additionally a new wildcard symbol @xmath200 is added to the tail of the channel . a test for emptiness of the channel",
    "is replaced by testing whether the channel only contains the wildcard symbol @xmath200 .",
    "let @xmath201 be a computation of @xmath126 , and let @xmath202 . with the new wildcard semantics this computation is of the form @xmath203",
    "observe that the length of the channel content is constantly @xmath95 .",
    "we will later exploit this fact .",
    "the encoding of computations of channel machines is now changed with this wildcard semantics in mind .",
    "the initial configuration is encoded by a timed word that starts with the symbol @xmath121 at some time @xmath181 , and then is followed by @xmath95 occurrences of @xmath200 , all of which have monotonically increasing timestamps in the interval @xmath184 .",
    "the rules for the transitions change accordingly : if the next transition is sending a message @xmath137 to the channel , we _ replace _ in the encoding of the next configuration the first occurrence of @xmath200 by @xmath137 .",
    "if the next transition is reading a message @xmath137 from the head of the channel , we test whether the first symbol after the control state is @xmath137 , and if so , we remove it from the encoding of the next configuration .",
    "we further add a new @xmath200 to the end of the encoding of the next configuration .",
    "the encoding of the computation of the previous example may be of the form @xmath204",
    "@xmath205    observe that the length of the encoding of every configuration is constantly @xmath206 .",
    "this is due to the fact that none of the encoding rules changes the number of symbols in a configuration .",
    "however , due to the lack of backward - looking conditions , it may still happen that some symbols appear `` all of a sudden '' , _",
    "i.e. _ , without a matching copy two time units before . in this case ,",
    "the length of the encoding of the configuration increases . by the encoding conditions above",
    ", the increasing effect will be carried over to the encodings of the following configurations .",
    "hence , in order to find out whether insertion errors occurred , it suffices to compare the length of the encoding of the initial configuration ( which is equal to @xmath206 ) to the length of the encoding of the last configuration : if it is still @xmath206 , then we know that no insertion error has occurred ; otherwise , some insertion error has occurred .",
    "the test will be done by the counter of the timed visibly one - counter net @xmath1 . during a run of @xmath1 on the encoding of a computation , the counter is incremented while the symbols of the encoding of the first configuration are read , and it is decremented while the symbols of the encoding of the last configuration are read . in between , the counter is not touched . by the fact that a one - counter net can not decrement the counter",
    "more often than it was incremented ( @xmath1 is blocked as soon as the counter would become negative ) , we can exclude timed words which are encoding potential insertion errors .    by definition of timed _ visibly _ one - counter nets , @xmath1 is restricted to use @xmath121 and the wildcard symbol @xmath207 whenever the counter should be incremented , and it can only use the wildcard symbol @xmath208 and @xmath177 whenever the counter should be decremented .",
    "this requires some extra effort in the encoding , namely that the encoding of the first configuration only uses the wildcard symbol @xmath207 , and the encoding of the last configuration only uses the wildcard symbol @xmath208 .",
    "before we give the formal definition of the language @xmath170 , we show a complete encoding of the faulty computation of example [ example_encoding ] for @xmath209 .",
    "[ example_thewholeenc ] @xmath210",
    "@xmath211 @xmath212    for every @xmath213 , we define a timed language @xmath214 as follows : the timed language @xmath215 consists of all timed words @xmath75 over @xmath4 that satisfy the following conditions :    1 .",
    "@xmath75 must be strictly monotonic .",
    "the untiming of @xmath75 must be of the form given by the following regular expression : @xmath216 3 .   for every @xmath128 ,",
    "if @xmath180 is followed by @xmath217 after one time unit , and @xmath180 is followed by @xmath218 after two time units , then @xmath122 .",
    "4 .   for every @xmath128 with @xmath219 ,",
    "there exists @xmath220 after exactly one time unit .",
    "5 .   for every @xmath128 with @xmath219 ,",
    "there exists @xmath221 after exactly two time units .",
    "after @xmath222 the symbol @xmath177 occurs after two time units .",
    "further , for every infix of @xmath75 of the form @xmath223 with @xmath224 , @xmath225 , @xmath27 , @xmath226 , there exists a strictly increasing function @xmath227 such that the following conditions are satisfied :    1 .   if @xmath125 , then 1 .   @xmath228 and @xmath229 for all @xmath158",
    "( the channel is empty ) , and 2 .",
    "@xmath230 for every @xmath158 ( there are matching copies after two time units ) .",
    "2 .   if @xmath231 for some @xmath232 , then 1 .",
    "there exists @xmath158 such that @xmath233 ( there is some wildcard symbol in the encoding of the current configuration ) , 2 .",
    "@xmath234 and @xmath235 for @xmath236 ( the first wildcard symbol is replaced by @xmath137 two time units later ) , 3 .",
    "@xmath237 and @xmath238 for all @xmath239 ( there are matching copies for the remaining symbols ) .",
    "3 .   if @xmath240 for some @xmath232 , then 1 .",
    "@xmath241 ( the first symbol is equal to @xmath137 ) , 2 .",
    "@xmath242 , @xmath243 , and @xmath244 ( a new wildcard symbol is added at the end of the encoding ) , and 3 .",
    "@xmath245 and @xmath246 for all @xmath247 ( there are matching copies for all other symbols except for the first one , which is removed from the encoding ) .",
    "for an infix like above but with @xmath248 and @xmath249 , we add conditions ( 7 ) , ( 8 ) and ( 9 ) that differ from 7 , 8 , and 9 , respectively , in that all message or wildcard symbols to be copied or added to the encoding of the next configuration are replaced by the wildcard symbol @xmath208 .",
    "a simple observation that we will later use is that by these conditions the length of the encodings of two consecutive configurations can not decrease .",
    "indeed , the conditions for representing transitions between two configurations of the channel machine do not change the number of symbols in the encoding of the respective configurations . by the lack of backward - looking conditions",
    "it may however happen that some symbols appear all of a sudden , _",
    "i.e. _ , without a matching copy two time units before .",
    "we point out that such insertion errors _ may _ occur , but they are not required by any of the conditions .",
    "we define a timed visibly one - counter net @xmath1 over @xmath4 such that for every @xmath213 the intersection @xmath250 consists of all timed words that encode _ error - free _ computations of @xmath126 from @xmath161 to @xmath162 for some @xmath129 .",
    "the timed visibly one - counter net @xmath1 is shown in figure [ figure_a ] .",
    "after incrementing the counter while reading the initial letter @xmath121 , it non - deterministically guesses a number @xmath251 of symbols @xmath207 and increments the counter each time it reads the symbol @xmath207 .",
    "when @xmath1 leaves @xmath252 , the value of the counter is @xmath206 .",
    "after that , the counter value is not changed until the state symbol @xmath222 is read .",
    "then , while reading symbols in @xmath253 , the counter value is decremented .",
    "note that @xmath1 can reach the final location @xmath254 only if the number of the occurrences of symbol @xmath208 between @xmath222 and @xmath177 is _ at most _",
    "@xmath95 : otherwise the counter value would become negative , and thus the edges going out from @xmath255 would be blocked . note that @xmath1 does not use any clock , and it is deterministic .",
    "( 107,14)(0,-14 ) ( n0)(5.0,-11.0)@xmath256 ( n1)(27.0,-11)@xmath252 ( n2)(50.0,-11)@xmath257 ( n0,n1 ) ( n1 ) ( n1,n2 ) ( n2 ) ( n3)(76.0,-11)@xmath255 ( n4)(100.0,-11)@xmath254 ( n2,n3 ) ( n3 ) ( n3,n4 )    the timed word presented in example [ example_thewholeenc ] can not be accepted by the timed visibly one - counter net @xmath1 in figure [ figure_b ] : the run of @xmath1 on the prefix is of the form @xmath258 here , in @xmath259 , @xmath260 stands for the current location , and @xmath261 stands for the current value of the counter .",
    "the counter value stays constant until we finally read the first @xmath208 : @xmath262 now @xmath1 is blocked : all outgoing edges of @xmath255 require the counter to be decremented , which is not possible if the counter has value zero .",
    "this is indeed what we want : the timed word in example [ example_encoding ] is encoding a faulty computation , and should be excluded .",
    "[ lemma_intersection ] @xmath126 has an error - free computation from @xmath161 to @xmath162 for some @xmath129 , if , and only if , there exists @xmath251 such that @xmath263 .    for the direction from left to right ,",
    "let @xmath264 be an error - free computation of @xmath126 from @xmath161 to @xmath162 for some @xmath129 .",
    "let @xmath95 be the maximum length of the channel content during @xmath264 .",
    "let @xmath75 be a timed word in @xmath215 in which no message or wildcard symbols occur `` all of a sudden '' , _",
    "i.e. _ , without a matching copy two time units before .",
    "note that such a timed word exists , because @xmath264 is error - free , and hence there is no need to encode insertion errors into @xmath75 .",
    "this implies that the length of the encodings of all , and in particular , the first and the last configuration in @xmath75 is @xmath206 .",
    "this implies @xmath265 .",
    "hence @xmath266 .    for the direction from right to left ,",
    "let @xmath267 for some @xmath213 .",
    "by definition of @xmath215 , the length of the encoding of the initial configuration is @xmath206 . by the observation above",
    ", the length of the encoding of the last configuration is thus at least @xmath206 , too .",
    "however , by definition of @xmath1 , the length of the encoding of the last configuration can not be greater than @xmath206 , because otherwise the edge to @xmath254 can not be taken due to the decrement operation . by the observation above",
    ", the length of encodings of consecutive configurations do not decrease , and thus the length of the encodings of all configurations is @xmath206 .",
    "hence we can conclude that there are no insertion errors necessary to encode the execution of a transition .",
    "this implies that there exists some error - free computation @xmath264 of @xmath126 from @xmath161 to @xmath162 for some @xmath129 .",
    "we finally define @xmath268 .",
    "[ corollary_cap ] there exists some error - free computation of @xmath126 from @xmath161 to @xmath162 for some @xmath129 if , and only if , @xmath269 .",
    "finally , we define a one - clock timed automaton @xmath2 such that @xmath270 .",
    "the construction of @xmath2 follows the same ideas as , , in  @xcite : @xmath2 is the union of several one - clock timed automata , each of them violating some condition of the definition of @xmath170 , as described in the following .",
    "the timed automaton in figure a accepts timed words that are not strictly monotonic , thus violating condition ( 1 ) . for accepting timed words violating condition ( 2 ) , we can construct a finite automaton that recognizes the complement of the given regular expression .",
    "define for every @xmath271 the sets @xmath272 and @xmath273 , and @xmath274 and @xmath275 .",
    "then for every @xmath180 the corresponding timed automaton in figure b accepts timed words that contain the encoding of a transition @xmath276 , thus violating condition ( 3 ) . violations of the forward - looking conditions in ( 4 ) , ( 5 ) , and ( 6 ) can be accepted by the timed automaton in figure c with , respectively , ( 4 ) @xmath277 , @xmath278 , and @xmath279 , ( 5 ) @xmath277 , @xmath280 , and @xmath281 , and ( 6 ) @xmath282 , @xmath283 , and @xmath279 .",
    "p5cmp1cmp5 cm + & &    ( 50,22)(0,-22 ) ( n0)(5.0,-13.0 ) ( n1)(21.0,-13 ) ( n2)(45.0,-13 )    ( n0,n1 ) ( n0 )    ( n2 ) ( n1,n2 ) ( n1,n2 )     + figure a : condition ( 1 ) & & figure b : condition ( 3 )    p8 cm +   + figure c : conditions ( 4 ) , ( 5 ) , and ( 6 ) +   +    timed words violating condition ( 7a ) can be accepted by the timed automaton in figure d. in figure e we show a timed automaton that accepts timed words violating condition ( 7b ) .",
    "p4.1cmp10 cm &    ( 95,20)(0,-20 ) ( n0)(5.0,-13.0 ) ( n1)(30.0,-13 ) ( n3)(55.0,-13 ) ( n2)(90.0,-13 ) ( n0 ) ( n2 ) ( n1 ) ( n0,n1 ) ( n1,n3 )    ( n3 )    ( n3,n2 ) ( n3,n2 )     + figure d : condition ( 7a ) & figure e : condition ( 7b ) +   +    the timed automaton in figure f accepts all timed words for which the last symbol before @xmath117 is different from @xmath200 .",
    "this , together with the structure of @xmath75 ensured by condition ( 2 ) , implies that condition ( 8a ) is violated .",
    "the timed automaton in figure g accepts timed words violating condition ( 8b ) . for condition ( 8c ) ,",
    "we can use a timed automaton similar to that in figure e. by constructing for every @xmath232 the corresponding automata , we can thus accept all timed words violating the conditions stated in ( 8) .",
    "p2.9cmp5mmp8.5 cm & &    ( 83,19)(0,-19 )    ( n0)(5.0,-13.0 ) ( n1)(18.0,-13 ) ( n2)(34.0,-13 ) ( n3)(45.0,-13 ) ( n4)(54.0,-13 ) ( n5)(78.0,-13 )    ( n0 ) ( n0,n1 ) ( n1,n2 ) ( n2 ) ( n2,n3 ) ( n3,n4 )    ( n4,n5 ) ( n4,n5 ) ( n5 )     + figure f : condition ( 8a ) & & figure g : condition ( 8b ) +   +    last but not least we present timed automata that accept timed words violating condition ( 9 ) . for all @xmath232 , we define timed automata shown in figure h und i , respectively , that accept timed words violating condition ( 9a ) and ( 9b ) , respectively . for ( 9c ) we construct a timed automaton very similar to that in figure e.    p5cmp8 cm + &    ( 80,19)(0,-19 ) ( n0)(5.0,-13.0 ) ( n1)(28.0,-13 ) ( n2)(40.0,-13 ) ( n3)(60.0,-13 ) ( n4)(75.0,-13 )    ( n0 )    ( n0,n1 )    ( n1,n2 ) ( n2 )    ( n2,n3 ) ( n2,n4 )    ( n3 ) ( n3,n4 ) ( n4 )     + figure h : condition ( 9a ) & figure i : condition ( 9b ) +   +    so let @xmath2 the union of all these timed automata .",
    "one can easily see that for every timed word @xmath74 we have @xmath284 if , and only if , @xmath285 . by corollary [ corollary_cap ]",
    ", there exists some error - free computation of @xmath126 from @xmath161 to @xmath162 for some @xmath129 if , and only if , @xmath269 .",
    "the latter is equivalent to @xmath172 .",
    "hence , the language inclusion problem is undecidable .",
    "the proof idea of theorem [ theorem_main_lang_inc ] can be used to show the undecidability of the following model checking problem : given a timed visibly one - counter net @xmath1 , and an mtl formula @xmath286 , does every @xmath265 satisfy @xmath286 ? recall that this problem is decidable for the class of timed automata  @xcite .",
    "we prove that adding a visibly counter without zero test already makes the problem undecidable . but first , let us recall the syntax and semantics of mtl .",
    "let @xmath4 be a finite alphabet .",
    "the set of mtl formulae is built up from @xmath4 by boolean connectives and a time constraining version of the _ until _ modality : @xmath287 where @xmath288 and @xmath289 is an open , closed , or half - open interval with endpoints in @xmath290 .",
    "we interpret mtl formulae in the _ pointwise semantics _ , _",
    "i.e. _ , over finite timed words over @xmath4 .",
    "let @xmath291 be a timed word , and let @xmath66 .",
    "we define the _ satisfaction relation for mtl _ , denoted by @xmath292 , inductively as follows :    ( w , i ) a & a_i = a + ( w , i ) & ( w , i ) , + ( w , i ) _ 1_2 & ( w , i)_1 ( w , i)_2 , + ( w , i)_1_i_2 & j. i < jn : ( w , j)_2 t_j - t_i i , + & k.i < k",
    "< j:(w , k)_1 .",
    "we say that a timed word @xmath74 satisfies an mtl formula @xmath286 , written @xmath293 , if @xmath294 .",
    "note that mtl only allows to express restrictions on time , and it does not allow for any restrictions on the values of the counters .",
    "in fact , it is proved that as soon as we add to mtl the capability for expressing restrictions on the values of a counter that can be incremented and decremented , model checking is undecidable  @xcite .",
    "the proof of the following theorem is based on the fact that mtl can encode computations of channel machines with insertion errors  @xcite .    [ theorem_model_checking ] the model checking problem for timed visibly one - counter nets and",
    "mtl is undecidable , even if the timed visibly one - counter net does not use any clocks and is deterministic .    the definition of an mtl formula @xmath286 such that @xmath295 is straightforward , see , ,  @xcite .",
    "by corollary [ corollary_cap ] , there exists some error - free computation of @xmath126 from @xmath161 to @xmath162 for some @xmath129 if , and only if , @xmath296 .",
    "the latter , however , is equivalent to saying that there exists some timed word @xmath265 such that @xmath297 .",
    "hence the model checking problem is undecidable .",
    "we would like to remark that the proof of theorem [ theorem_model_checking ] shares some similarities with the proof of the undecidability of model checking one - counter machines ( _ i.e. _ , one - counter automata without input alphabet ) and freeze ltl with one register ( ltl@xmath298 , for short )  @xcite . in  @xcite , it is proved that ltl@xmath298 can encode computations of _ counter automata with incrementing errors_. similar to the situation for mtl and channel machines , @xmath299 can however not encode _ error - free _ computations of counter automata . in  @xcite , a one - counter machine is used to repair this incapability , resulting in the undecidability of the model checking problem .",
    "the one - counter machine in  @xcite does not use zero tests ; however , we point out that in contrast to our visibly timed one - counter net the one - counter machine in  @xcite is _ non - deterministic_. indeed , model checking _ deterministic _ one - counter machines and ltl@xmath298 is decidable  @xcite .",
    "we further remark that using a similar proof , we can show that the model checking problem for _ parametric timed automata _ and mtl is undecidable , even if the automaton only uses one parametric clock , one parameter and is deterministic  @xcite .",
    "next we will consider an interesting extension of _ lower - bound energy problems on weighted timed automata _",
    ", introduced in  @xcite , which gained attention in the last years , see , ,  @xcite . in lower - bound energy problems ,",
    "one is interested whether in a given automaton with some weight variable whose value can be increased and decreased , there exists a successful run in which all accumulated weight values are never below zero .",
    "similar problems have also been considered for untimed settings , ,  @xcite .",
    "a _ timed automaton with discrete weights _ ( dwta , for short ) is syntactically the same as a timed one - counter net . in the semantical graph induced by a dwta",
    ", however , we allow the value of the counter ( or , the _ weight variable _ ) to become negative .",
    "hence the value of the weight variable does not influence the behaviour of the dwta , because , different to timed one - counter nets , transitions that result in negative values are not blocked .",
    "we remark that for the simple reasons that ( 1 ) the value of the weight variable does not influence the behaviour of dwta , and ( 2 ) mtl does not restrict the values of the weight variable , the model checking problem for dwta and mtl is decidable , using the same algorithm as for timed automata  @xcite .",
    "we define the _ model checking energy problem _ for dwta and mtl as follows : given a dwta @xmath1 and an mtl formula @xmath286 , does there exist some accepting run @xmath300 of @xmath1 such that the value of the weight variable is always non - negative , and the timed word @xmath75 associated with @xmath300 satisfies @xmath286 ?",
    "for the special case @xmath301 , the problem is decidable in polynomial time for one - clock dwta  @xcite .",
    "[ theorem_energy ] the model checking energy problem for dwta and mtl is undecidable , even if the dwta uses no clocks .    for the proof ,",
    "we reduce the model checking problem for timed one - counter nets and mtl to the energy problem .",
    "note that timed one - counter nets are a generalization of timed visibly one - counter nets , and thus by theorem [ theorem_model_checking ] the model checking problem is undecidable .",
    "let @xmath1 be a timed one - counter net , and let @xmath286 be an mtl formula .",
    "define @xmath302 to be the dwta that is syntactically equal to @xmath1 .",
    "one can easily prove that @xmath303 is a negative instance of the model checking problem if , and only if , @xmath304 is a positive instance of the energy problem .",
    "in the preceding section , we showed that one can not automatically verify timed automata extended with unbounded discrete data structures against real - time specifications expressed by timed automata or mtl - formulas . in this section , we prove that in contrast to this , we can use one - clock timed counter nets as specification for model checking timed automata : the language inclusion problem @xmath3 is decidable with non - primitive recursive complexity if @xmath1 is a timed automaton and @xmath2 is a one - clock timed counter net ( theorem [ theorem_main_dec ] )",
    ". we will first give the formal proof of theorem [ theorem_main_dec ] .",
    "after that , we will argue that this result extends known facilities for the verification of timed automata .      for the case that @xmath1 is",
    "a timed automaton and @xmath2 is a one - clock timed automaton , the language inclusion problem @xmath3 is decidable  @xcite with non - primitive recursive complexity  @xcite .",
    "the lower bound hence follows , and the decidability proof is an adaptation of the decidability proof in  @xcite .    the proof is based on the theory of well - quasi - orders , and we start with defining some useful notions .",
    "let @xmath305 be two sets , and let @xmath306 be a binary relation on @xmath105 .",
    "then @xmath306 is a _ quasi - order _ on @xmath105 if @xmath306 is reflexive and transitive .",
    "@xmath306 is a _",
    "well - quasi - order _ on @xmath105 if it is a quasi - order and for every infinite sequence @xmath307 in @xmath105 there exist indices @xmath308 such that @xmath309 .",
    "a standard example for a well - quasi - order is the pointwise order @xmath310 on the set @xmath311 of vectors of @xmath312 natural numbers ( dickson s lemma , @xcite ) .",
    "let @xmath306 be a quasi - order on @xmath105 , and let @xmath313 be a quasi - order on @xmath314 .",
    "we define the _ product _ of @xmath306 and @xmath313 on @xmath315 by @xmath316 , if and only if , @xmath317 and @xmath318 .",
    "we define the _ monotone domination order _ @xmath319 on @xmath320 by @xmath321 if and only if there exists a strictly increasing function @xmath322 such that for all @xmath110 we have @xmath323 .",
    "we define the _ subset order _",
    "@xmath324 on the set @xmath325 of finite subsets of @xmath105 by @xmath326 if and only if there is an injective mapping @xmath327 such that for all @xmath328 we have @xmath329 .",
    "[ lemma_higman ]    1 .   if @xmath306 and @xmath313 are well - quasi - orders on @xmath105 and @xmath314 , respectively , then the product of @xmath306 and @xmath313 is a well - quasi - order on @xmath315 .",
    "if @xmath306 is a well - quasi - order on @xmath105 , then the monotone domination order @xmath319 is a well - quasi - order on @xmath320 .",
    "if @xmath306 is a well - quasi - order on @xmath105 , then the subset order @xmath324 is a well - quasi - order on @xmath325 .",
    "let @xmath330 be a timed automaton with clock variables @xmath331 , and let @xmath332 be a timed counter net of dimension @xmath333 with a single clock variable @xmath169 . without loss of generality , we may assume that @xmath334 .",
    "note that a state @xmath335 of @xmath1 is an element in @xmath336 , and a state @xmath337 of @xmath2 is an element in @xmath338 .",
    "joint configuration of @xmath1 and @xmath2 _ is a pair @xmath339 , where @xmath340 is a state of @xmath1 , and @xmath264 is a set of states of @xmath2 .",
    "we use @xmath341 to denote the set of all joint configurations of @xmath1 and @xmath2 .",
    "we say that a joint configuration @xmath339 is _ initial _ if @xmath342 and @xmath343 ( with @xmath344 we denote the vector of dimension @xmath333 containing only @xmath345 ) .",
    "we say that a joint configuration @xmath339 is _ bad _ if @xmath346 for some @xmath347 , and for all states @xmath348 we have @xmath349 .",
    "the _ joint behaviour of @xmath1 and @xmath2 _ is defined as follows : for a state @xmath335 of @xmath1 , @xmath27 and @xmath288 , we define @xmath350 . for a set @xmath264 of states of @xmath2 , we define @xmath351 .",
    "note that @xmath352 is a set of states of @xmath2 , and it may be empty . finally , we define the transition relation @xmath353 on @xmath354 by @xmath355 if there exists some @xmath27 such that @xmath356 and @xmath357 .    next , we encode joint configurations of @xmath1 and @xmath2 by finite untimed words over the set @xmath358 of finite subsets of @xmath359 . here , @xmath360 , where @xmath361 is an integer greater than the maximal constant occurring in clock constraints in both @xmath1 and @xmath2 , and @xmath362 is a symbol representing all values greater than @xmath361 .",
    "let @xmath363 be a joint configuration . to simplify the definition , we write @xmath364 as a set @xmath365 partition @xmath364 into a sequence of subsets @xmath366 , such that @xmath367 , and if @xmath368 , then for all @xmath369 , @xmath370 , we have @xmath371 if , and only if , @xmath308 , and @xmath372 if , and only if , @xmath373 .",
    "here , @xmath374 denotes the fractional part of a real number @xmath375 . in this way , @xmath376 and @xmath377 are in the same subset @xmath378 if , and only if , @xmath379 and @xmath380 are both smaller than or equal to @xmath361 and have the same fractional part .",
    "in addition , we require that @xmath381 if , and only if , the fractional part of @xmath379 is zero , and @xmath382 for all @xmath383 .",
    "we define the encoding @xmath384 of @xmath364 to be the finite word @xmath385 , where @xmath386 with @xmath387 if @xmath388 , and @xmath389 otherwise ( @xmath390 denotes the integer part of a real number @xmath375 ) .",
    "we define a transition relation @xmath391 on the set of encodings of joint configurations and @xmath4 as follows : @xmath392 if there exists @xmath393 and @xmath394 such that @xmath395 .",
    "we further define the equivalence relation @xmath396 by @xmath397 if , and only if , @xmath398 .",
    "let @xmath1 be a timed automaton with a single clock @xmath399 , and let @xmath2 be a timed one - counter net of dimension @xmath400 and with a single clock @xmath169 .",
    "assume @xmath401 .",
    "let @xmath402 be a joint configuration of @xmath1 and @xmath2 .",
    "the encoding of @xmath403 equals @xmath404 the joint configuration @xmath405 has the same encoding , and thus @xmath406 .",
    "note that for @xmath406 to hold , the configurations must agree on the counter values .    in the next lemma ,",
    "we prove that @xmath396 is a time - abstract bisimulation over joint configurations . the proof can be done like the proof of prop . 11 in  @xcite .",
    "[ lemma_bisim ] for all joint configurations @xmath407 , and @xmath288 , if @xmath408 , then    * for all @xmath409 such that @xmath410 , there exists @xmath411 such that @xmath412 and @xmath413 , * for all @xmath411 such that @xmath414 , there exists @xmath409 such that @xmath415 and @xmath413 .",
    "next , we define a quasi - order @xmath313 on the set of encodings of joint configurations and prove that @xmath313 is a well - quasi - order .",
    "first , define @xmath306 on @xmath416 by @xmath417 if , and only if , @xmath418 , @xmath419 , @xmath420 , and @xmath421 . by lemma [ lemma_higman].1 and the fact that @xmath422 on the finite set @xmath423 and @xmath424 on @xmath425 are well - quasi - orders , @xmath306 is a well - quasi - order , too . by lemma [ lemma_higman].3 ,",
    "the subset order @xmath324 is a well - quasi - order .",
    "finally , we define @xmath313 to be the monotone domination order on @xmath324 , and then by lemma [ lemma_higman].2 , @xmath313 is a well - quasi - order .    let @xmath426",
    ". then @xmath427 , where @xmath428 from the previous example .",
    "note that the counter values in @xmath429 may be smaller than the associated counter values in @xmath430 , as it is here the case with the counter values for @xmath252 .",
    "the next lemma states that @xmath391 is downward - compatible with respect to @xmath313 .",
    "[ lemma_dc ] if @xmath431 and @xmath432 , then there exists @xmath433 such that @xmath434 and @xmath435 .",
    "the proof is similar to the proof of lemma 15 in  @xcite .",
    "let @xmath436 be such that @xmath431 and @xmath437 .",
    "further let @xmath438 , @xmath439 , and @xmath440 be such that @xmath441 .",
    "this implies that there exists @xmath27 with @xmath442 and @xmath443 .    since @xmath431 , we know that there exists a set @xmath444 of states in @xmath2 such that @xmath445 ( @xmath177 ) : @xmath444 is obtained from choosing a suitable set @xmath446 such that the encoding of @xmath447 differs from the encoding of @xmath448 only in that the vectors representing the counter values occurring in @xmath449 may be greater ( with respect to @xmath424 ) than the corresponding vectors in @xmath450 .",
    "@xmath444 is then the result from subtracting suitable values from the vectors in @xmath449 so that the encoding is equal .",
    "now let @xmath451 .",
    "then @xmath452 ( @xmath453 ) .",
    "note that we can add suitable values to the vectors in @xmath454 to obtain @xmath455 ( @xmath456 ) .    from @xmath457 and @xmath458 it follows by lemma [ lemma_bisim ] that there exists @xmath459 such that @xmath415 and @xmath460 . from the former",
    "it follows that @xmath461 , where @xmath462 . from the second and @xmath463",
    "it follows that @xmath434 .",
    "intuitively , comparing the situation for timed counter nets with the situation for pure timed automata like in lemma 15 in  @xcite , there may now be transitions that can be executed from configurations encoded by @xmath430 , but that are blocked from configurations encoded by @xmath429 due to the fact that counter values are too small .",
    "this , however , does not cause any trouble , because it results in smaller sets of successor configurations , and thus leading to @xmath434 .",
    "note that lemma [ lemma_dc ] does not hold if the counters in @xmath2 can be tested for zero .",
    "for instance , consider @xmath429 and @xmath430 from the previous example .",
    "assume that in @xmath2 there are no edges with source location @xmath257 and @xmath255 , and the only suitable @xmath464-labelled edge with source location @xmath252 does a zero test on the second counter and leaves all other components unchanged .",
    "this yields @xmath465 and @xmath466 , where @xmath467 is the set of states of @xmath2 in some configuration @xmath378 with @xmath468 for @xmath469 .",
    "assume there is an @xmath464-labelled edge in @xmath1 with source location @xmath260 and leaving all components unchanged .",
    "then we have @xmath470 with @xmath471 , @xmath461 with @xmath472 .",
    "note that @xmath434 does _ not _ hold .",
    "indeed , the universality problem of ( even untimed ) one - counter automata is undecidable  @xcite . in section 6",
    ", we prove that this is also the case for timed visibly pushdown one - counter automata .",
    "this gives us the precise decidability border for the universality problem .",
    "finally , we describe the algorithm to decide @xmath3 . like in  @xcite",
    ", we solve the language inclusion problem by solving the following reachability problem : in the implicit graph of the encoding of joint configurations and the transition relation @xmath391 , is there a path from the encoding of one of the finitely many initial joint configuration to the encoding of a bad joint configuration ?",
    "note that we have @xmath3 if , and only if , there is no such path . for solving the reachability problem ,",
    "we compute the unfolding of the graph , starting the computation with the encoding of an initial joint configuration .",
    "if for the current node labelled by @xmath75 , there is along the branch already a node labelled with @xmath473 and @xmath474 , then by lemma [ lemma_dc ] we can prune the tree after the current node : assume that from @xmath75 we can reach a word @xmath429 that represents a bad configuration , then by lemma [ lemma_dc ] we can reach a word @xmath433 from @xmath473 such that @xmath475 , and hence , @xmath433 is representing a bad configuration , too . by the facts",
    "that the unfolding is finitely branching , @xmath313 is a well - quasi - order and by knig s lemma , we know that the computation will finally terminate .",
    "theorem [ theorem_main_dec ] generalizes a result by ouaknine and worrell on the decidability of the language inclusion problem @xmath3 for @xmath2 being a one - clock timed automaton without counters  @xcite . clearly ,",
    "timed counter nets are more expressive than timed automata ; for instance , the timed language accepted by the timed one - counter net on the left hand side of figure [ tocn_l_2 ] can not be accepted by any timed automaton , because its projection on @xmath476 equals @xmath477 , _ i.e. _ , a non - regular language .",
    "( 100,25)(0,-25 ) ( n0)(5.0,-16.0 ) ( n1)(27.0,-16 ) ( n0,n1 ) ( n0 ) ( n1 )    ( m0)(50.0,-16.0)@xmath256 ( m1)(67.0,-16)@xmath252 ( m3)(84,-6)@xmath255 ( m2)(101,-16)@xmath257    ( m1,m3 ) ( m3 ) ( m3,m2 )    ( m1,m2 ) ( m0,m2 ) ( m2 ) ( m0 ) ( 50,-7 ) ( 54,-12 ) ( 52,-18 )    ( 0,1)(0.4,2)(2,2.5)(3,2)(3.5,1 )    however , the result in  @xcite was also generalized to another extension of timed automata called _ alternating _ one - clock timed automata  @xcite .",
    "an alternating one - clock timed automaton allows for two modes of branching , namely existential branching and universal branching , represented by disjunction and conjunction , respectively .",
    "for example , the alternating one - clock timed automaton on the right hand side of figure [ tocn_l_2 ] has a universal branching transition in @xmath256 for the input letter @xmath464 , formally expressed by @xmath478 ; and it has an existential branching transition in @xmath252 for the input letter @xmath479 , formally @xmath480 ( see  @xcite for more details ) .",
    "this alternating one - clock timed automaton accepts the timed language consisting of a sequence of @xmath464 s followed by a sequence of @xmath479 s such that the time sequence belonging to the @xmath464-sequence is strictly monotonic , and every @xmath464 is followed by some @xmath479 after exactly one time unit .",
    "note that the projection on @xmath476 thus equals @xmath481 .",
    "we prove that timed one - counter nets with one clock and alternating one - clock timed automata are incomparable in expressive power .",
    "timed one - counter one - clock nets and alternating one - clock timed automata are incomparable in expressiveness .    on the hand , due to the lack of zero tests ,",
    "the timed language accepted by the alternating one - clock timed automaton on the right hand side of figure [ tocn_l_2 ] can not be accepted by any timed one - counter net . on the other hand , we prove that the timed language @xmath482 accepted by the timed counter net on the left side of figure [ tocn_l_2 ] can not be accepted by any alternating one - clock timed automaton , as we will prove in the following .",
    "we start with some simple facts about deterministic finite automata .",
    "let @xmath2 be a deterministic finite automaton over the singleton alphabet @xmath483 and with a set of states denoted by @xmath484 .",
    "for every @xmath213 , we define a function @xmath485 such that @xmath486 means that if @xmath2 starts in state @xmath340 to read the word @xmath487 , then @xmath2 ends in @xmath488 .",
    "clearly , there exist natural numbers @xmath489 such that @xmath490 . by determinism of @xmath2 we further have @xmath491 for every @xmath492 .",
    "now let @xmath493 be a finite set of deterministic finite automata .",
    "for every @xmath66 , let @xmath494 and @xmath495 be such that @xmath496 .",
    "set @xmath497 , and let @xmath137 be the least common multiple of @xmath498 .",
    "one can easily prove that for every @xmath66 we have @xmath499 , and , again by determinism , @xmath500 for every @xmath501 .",
    "assume by contradiction that @xmath482 is accepted by an alternating one - clock timed automaton @xmath1 .",
    "assume @xmath1 has @xmath95 locations .",
    "let @xmath314 be the set of all deterministic finite automata over @xmath483 with at most @xmath502 states .",
    "note that @xmath314 is finite up to equivalent behaviour .",
    "now choose @xmath489 as explained above and such that @xmath503 for every @xmath504 and @xmath505 .",
    "define @xmath506 .",
    "define @xmath507 and define @xmath508 , where @xmath509 with @xmath510 for every @xmath511 , and , similarly , @xmath512 with @xmath513 for every @xmath514 .",
    "note that @xmath515 and @xmath516 .",
    "further note that @xmath517 and @xmath518 for all @xmath519 .",
    "we prove that @xmath520 if , and only if , @xmath521 , _ i.e. _ , @xmath1 can not distinguish between @xmath429 and @xmath430 .",
    "first assume that @xmath520 .",
    "let @xmath264 be the configuration that @xmath1 is in after reading @xmath522 .",
    "clearly , all states @xmath523 in @xmath264 satisfy @xmath524 .",
    "let @xmath300 be the run of @xmath1 that starts from @xmath264 on the suffix of @xmath429 that contains the @xmath525 many @xmath479 s .",
    "all clock constraints occurring in transitions of @xmath300 are of the form @xmath526 for some @xmath19 , and by the choice of @xmath527 , the only clock constraints that are relevant for the acceptance of @xmath429 are those with @xmath261 equal to @xmath345",
    ". the satisfaction of constraints of the form @xmath528 may depend on preceding resets of the clock @xmath169 ; however , even with clock resets occurring in @xmath300 , the clock constraint @xmath529 can not be satisfied anywhere in @xmath300 because the time delays between the @xmath479 s are always greater than @xmath345 . in other words",
    ", @xmath1 behaves on the ( untimed ) word @xmath530 like an alternating automaton without a clock , but with an additional flag telling whether there was a reset on the clock or not .",
    "this , however , is equivalent to the behaviour of a deterministic finite automaton with @xmath502 states on the ( untimed ) word @xmath530 .",
    "but then , by the choice of @xmath312 and @xmath137 , we know that starting from @xmath264 , @xmath1 also accepts @xmath531 , and thus @xmath521 .",
    "the proof for the other direction is analogous .",
    "we prove that allowing zero tests in a one - clock timed visibly one - counter net results in the undecidability of the universality problem .",
    "the undecidability of the universality problem for the more general class of one - clock visibly pushdown automata was already stated in theorem 3 in  @xcite .",
    "the proof in  @xcite is a reduction of the halting problem for two - counter machines .",
    "given a two - counter machine @xmath532 , one can define a timed language @xmath533 that consists of all timed words encoding a halting computation of @xmath532 .",
    "then a timed visibly pushdown automaton @xmath1 is defined that accepts the complement of @xmath533 .",
    "altogether , @xmath534 if , and only if , @xmath532 does not have a halting computation .",
    "the definition of @xmath533 is similar to the definition of @xmath170 in the proof of theorem [ theorem_main_lang_inc ] .",
    "recall that in the definition of @xmath170 we did not include a condition that requires every symbol to have a matching symbol two time units _ before _ , and , as we mentioned , this is the reason for @xmath170 to contain timed words encoding _ faulty _ computations of @xmath126 .",
    "however , in the definition of @xmath533 in  @xcite , such a `` backward - looking '' condition is used . in the proof in  @xcite , it is unfortunately not clear how the one - clock timed visibly pushdown automaton @xmath1 can detect violations of this condition and @xmath535 mentioned on p. 10 in  @xcite . recall that in the proof for undecidability of the universality problem for timed automata with two or more clocks , it is exactly this backward - looking condition that requires _ two _ clocks  @xcite . ] .    here , we give a complete proof for the subclass of timed visibly one - counter automata . like the proof of theorem [ theorem_main_lang_inc ] , the proof is a reduction of the control state reachability problem for channel machines .",
    "we however remark that one can similarly use a reduction of the halting problem for two - counter machines .",
    "* proof of theorem [ theorem_univ_undec ] * let @xmath111 be a channel machine , and let @xmath160 .",
    "define @xmath4 in the same way as in the proof of theorem [ theorem_main_lang_inc ] . for every @xmath213",
    ", we define a timed language @xmath536 that consists of all timed words over @xmath4 that encode computations of @xmath126 from @xmath161 to @xmath162 for some @xmath129 .",
    "but in contrast to the proof of theorem [ theorem_main_lang_inc ] , @xmath215 will only contain encodings of _ error - free _ computations of @xmath126 .",
    "formally , @xmath536 is defined using the same conditions as the ones for @xmath215 in the proof of theorem [ theorem_main_lang_inc ] plus an additional condition that requires the number of wildcard symbols in the enoding of the last configuration to be equal to @xmath95 :    1 .   between @xmath222 and @xmath177 , the wildcard symbol @xmath208 occurs exactly @xmath95 times .",
    "recall that the conditions ( 1 ) to ( 9 ) guaranteed that the length of consecutive encodings can not decrease , _",
    "i.e. _ , the length of every encoding is at least @xmath206 .",
    "however , insertion errors may occur , leading to an increase of the length of the encoding and all consecutive encodings . but by the new condition ( 10 )",
    ", we can exclude the occurrence of such insertion errors .",
    "we thus have for @xmath537 :    [ lemma_univ_automata ] there exists some error - free computation of @xmath126 from @xmath161 to @xmath162 for some @xmath129 , if , and only if , @xmath538 .",
    "next , we define a timed visibly one - counter automaton with a single clock such that @xmath539 . hence , by the preceding lemma , @xmath540 if , and only if , there exists some error - free computation of @xmath126 from @xmath161 to @xmath162 for some @xmath129 .",
    "@xmath1 is the union of @xmath2 defined in the proof of theorem [ theorem_main_lang_inc ] and the visibly one - counter automaton shown in figure [ figure_visibly_one_counter_automaton ] .",
    "the latter accepts timed words violating the new condition ( 10 ) : the automaton non - deterministically guesses the maximum number @xmath95 of occurrences of the symbol @xmath207 .",
    "when leaving @xmath252 , the value of the counter is @xmath206 .",
    "the final location @xmath254 , however , can only be reached while reading @xmath208 or @xmath177 if the value of the counter is zero .",
    "this means that the encoding of the last configuration contains at least one symbol more than the encoding of the initial configuration .",
    "( 107,14)(0,-14 ) ( n0)(5.0,-11.0)@xmath256 ( n1)(27.0,-11)@xmath252 ( n2)(50.0,-11)@xmath257 ( n0,n1 ) ( n1 ) ( n1,n2 ) ( n2 ) ( n3)(76.0,-11)@xmath255 ( n4)(100.0,-11)@xmath254 ( n2,n3 ) ( n3 ) ( n3,n4 ) ( n4 )",
    "the main conclusion of this paper is that even for very weak extensions of timed automata with counters it is impossible to automatically verify whether a given specification is satisfied . on the other hand",
    ", we may use one - clock timed counter nets as specifications to verify timed automata .",
    "the results on the expressive power of timed counter nets in sect .",
    "5.2 show that this increases so far known possibilities for the verification of timed automata .",
    "we remark that all our results hold for automata defined over _ finite _ timed words .",
    "we can not expect the decidability of , , the universality problem for one - clock timed counter nets over infinite timed words , as the same problem is already undecidable for the subclass of one - clock timed automata  @xcite .",
    "i would like to thank michael emmi and rupak majumdar for helpful discussions on their work on timed pushdown automata .",
    "i further would like to thank james worrell very much for pointing me to mtl s capability of encoding faulty computations of channel machines .",
    "parosh  aziz abdulla and krlis erns .",
    "simulation is decidable for one - counter nets ( extended abstract ) . in davide sangiorgi and",
    "robert de  simone , editors , _ concur _ , volume 1466 of _ lncs _ , pages 253268 .",
    "springer , 1998 .",
    "sara adams , jol ouaknine , and james worrell .",
    "undecidability of universality for timed automata with minimal resources . in jean - franois raskin and p.  s. thiagarajan , editors , _ formats",
    "_ , volume 4763 of _ lncs _ , pages 2537 .",
    "springer , 2007 .",
    "ahmed bouajjani , rachid echahed , and riadh robbana . on the automatic verification of systems with continuous variables and unbounded discrete data structures . in panos",
    "j. antsaklis , wolf kohn , anil nerode , and shankar sastry , editors , _ hybrid systems _ ,",
    "volume 999 of _ lncs _ , pages 6485 .",
    "springer , 1994 .",
    "patricia bouyer , uli fahrenberg , kim  g. larsen , and nicolas markey . timed automata with observers under energy constraints . in karl  henrik johansson and wang yi , editors , _ hscc _ , pages 6170 .",
    "acm , 2010 .",
    "patricia bouyer , ulrich fahrenberg , kim  guldstrand larsen , nicolas markey , and jir srba .",
    "infinite runs in weighted timed automata with energy constraints . in franck cassez and claude jard , editors , _ formats _ , volume 5215 of _ lncs _ , pages 3347 .",
    "springer , 2008 .",
    "toms brzdil , petr janar , and antonn kucera .",
    "reachability games on extended vector addition systems with states . in samson abramsky ,",
    "cyril gavoille , claude kirchner , friedhelm meyer auf der heide , and paul  g. spirakis , editors , _ icalp ( 2 ) _ , volume 6199 of _ lncs _ , pages 478489 .",
    "springer , 2010 .",
    "rohit chadha and mahesh viswanathan .",
    "decidability results for well - structured transition systems with auxiliary storage . in lus caires and vasco thudichum vasconcelos , editors ,",
    "_ concur _ , volume 4703 of _ lncs _ , pages 136150 , springer , 2007 .",
    "zoltn sik , uli fahrenberg , axel legay , and karin quaas .",
    "kleene algebras and semimodules for energy problems . in dang",
    "van hung and mizuhito ogawa , editors , _ atva _ , volume 8172 of _ lncs _ , pages 102117 .",
    "springer , 2013 .",
    "uli fahrenberg , line juhl , kim  g. larsen , and jir srba .",
    "energy games in multiweighted automata . in antonio cerone and pekka pihlajasaari , editors ,",
    "_ ictac _ , volume 6916 of _ lncs _ , pages 95115 .",
    "springer , 2011 .",
    "piotr hofman , slawomir lasota , richard mayr , and patrick totzke .",
    "simulation over one - counter nets is pspace - complete . in anil seth and nisheeth  k. vishnoi , editors ,",
    "_ fsttcs _ , volume  24 of _ lipics _ , pages 515526 .",
    "schloss dagstuhl - leibniz - zentrum fuer informatik , 2013 .",
    "piotr hofman and patrick totzke .",
    "trace inclusion for one - counter nets revisited . in jol ouaknine and igor potapov and james worrell , editors , _ rp _ , volume 8762 of _ lncs _ , pages 151162 .",
    "springer , 2014 .",
    "line juhl , kim  guldstrand larsen , and jean - franois raskin .",
    "optimal bounds for multiweighted and parametrised energy games . in zhiming liu , jim woodcock , and huibiao zhu , editors , _ theories of programming and formal methods _ ,",
    "volume 8051 of _ lncs _ , pages 244255 .",
    "springer , 2013 .",
    "karin quaas . on the interval - bound problem for weighted timed automata .",
    "in adrian  horia dediu , shunsuke inenaga , and carlos martn - vide , editors , _ lata _ , volume 6638 of _ lncs _ , pages 452464 .",
    "springer , 2011 .",
    "karin quaas .",
    "model checking metric temporal logic over automata with one counter . in adrian",
    "horia dediu , carlos martn - vide , and bianca truthe , editors , _ lata _ , volume 7810 of _ lncs _ , pages 468479 .",
    "springer , 2013 ."
  ],
  "abstract_text": [
    "<S> we study decidability of verification problems for timed automata extended with unbounded discrete data structures . more detailed , we extend timed automata with a pushdown stack . in this way </S>",
    "<S> , we obtain a strong model that may for instance be used to model real - time programs with procedure calls . </S>",
    "<S> it is long known that the reachability problem for this model is decidable . </S>",
    "<S> the goal of this paper is to identify subclasses of timed pushdown automata for which the language inclusion problem and related problems are decidable . </S>"
  ]
}