{
  "article_text": [
    "the notion of _ queues _ has been used extensively as a powerful abstraction in studying dynamic resource allocation systems , where one aims to match _ demands _ that arrive over time with available _ resources _ , and a queue is used to store currently unprocessed demands .",
    "two important ingredients often make the design and analysis of a queueing system difficult : the demands and resources can be both _ variable _ and _ unpredictable_. _ variability _ refers to the fact that the arrivals of demands or the availability of resources can be highly volatile and nonuniformly distributed across the time horizon . _",
    "unpredictability _ means that such nonuniformity `` tomorrow '' is unknown to the decision maker `` today , '' and she is obliged to make allocation decisions only based on the state of the system at the moment , and some statistical estimates of the future .",
    "while the world will remain volatile as we know it , in many cases , the amount of unpredictability about the future may be reduced thanks to _ forecasting _ technologies and the increasing accessibility of data .",
    "for instance :    advance booking in the hotel and textile industries allows for accurate forecasting of demands ahead of time @xcite ;    the availability of monitoring data enables traffic controllers to predict the traffic pattern around potential bottlenecks @xcite ;    advance scheduling for elective surgeries could inform care providers several weeks before the intended appointment @xcite .    in all of these examples ,",
    "future demands remain _ exogenous _ and variable , yet the decision maker is revealed with ( some of ) their realizations .    _ is there significant performance gain to be harnessed by _ `` _ _ looking into the future _ _ ? '' in this paper we provide a largely affirmative answer , in the context of a class of admissions control problems .",
    "we begin by informally describing our problem .",
    "consider a single queue equipped with a server that runs at rate @xmath0 jobs per unit time , where @xmath2 is a fixed constant in @xmath8 , as depicted in figure  [ figdelill ] .",
    "the queue receives a stream of incoming jobs , arriving at rate @xmath9 . if @xmath10 , the arrival rate is greater than the server s processing rate , and some form of _ admissions control _ is necessary in order to keep the system stable .",
    "in particular , upon its arrival to the system , a job will either be _ admitted _ to the queue , or _",
    "redirected_. in the latter case , the job does not join the queue , and , from the perspective of the queue , disappears from the system entirely .",
    "the goal of the decision maker is to minimize the average delay experienced by the admitted jobs , while obeying the constraint that the average rate at which jobs are redirected _ does not exceeded @xmath2_. , the minimum rate of admitted jobs , @xmath11 , approaches the server s capacity @xmath0 , and hence we will refer to the system s behavior when @xmath6 as the _ heavy - traffic regime_. ]    one can think of our problem as that of _ resource allocation _ , where a decision maker tries to match incoming demands with two types of processing resources : a  _ slow local resource _ that corresponds to the server and a _ fast external resource _ that can process any job redirected to it almost instantaneously .",
    "both types of resources are _ constrained _ , in the sense that their capacities ( @xmath0 and @xmath2 , resp . )",
    "can not change over time , by physical or contractual predispositions .",
    "the processing time of a job at the fast resource is _",
    "negligible compared to that at the slow resource _ , as long as the rate of redirection to the fast resource stays below @xmath2 in the long run . under this interpretation , minimizing the average delay across _ all _ jobs is equivalent to minimizing the average delay across just the _ admitted _ jobs , since the jobs redirected to the fast resource can be thought of being processed immediately and experiencing no delay at all .    for a more concrete example , consider a web service company that enters a long - term contract with an external cloud computing provider for a fixed amount of computation resources ( e.g. , virtual machine instance time ) over the contract period . during the contract period , any incoming request can be either served by the in - house server ( slow resource ) , or be redirected to the cloud ( fast resource ) , and in the latter case , the job does not experience congestion delay since the scalability of cloud allows for multiple vm instance to be running in parallel ( and potentially on different physical machines ) .",
    "the decision maker s constraint is that the total amount of redirected jobs to the cloud must stay below the amount prescribed by the contract , which , in our case , translates into a maximum redirection rate over the contract period .",
    "similar scenarios can also arise in other domains , where the slow versus fast resources could , for instance , take on the forms of :    an in - house manufacturing facility versus an external contractor ;    a slow toll booth on the freeway versus a special lane that lets a car pass without paying the toll ;    hospital bed resources within a single department versus a cross - departmental central bed pool .    in a recent work @xcite ,",
    "a mathematical model was proposed to study the benefits of resource pooling in large scale queueing systems , which is also closely connected to our problem .",
    "they consider a multi - server system where a fraction @xmath0 of a total of @xmath12 units of processing resources ( e.g. , cpus ) is distributed among a set of @xmath12 local servers , each running at rate @xmath0 , while the remaining fraction of @xmath2 is being allocated in a centralized fashion , in the form of a central server that operates at rate @xmath13 ( figure  [ figpooling ] ) .",
    "it is not difficult to see , when @xmath12 is large , the central server operates at a significantly faster speed than the local servers , so that a job processed at the central server experiences little or no delay .",
    "in fact , the admissions control problem studied in this paper is essentially the problem faced by one of the local servers , in the regime where @xmath12 is large ( figure  [ figpoolingcqueue ] ) .",
    "this connection is explored in greater detail in appendix  [ secresourcepooling ] , where we discuss what the implications of our results in context of resource pooling systems .",
    "we preview some of the main results in this section .",
    "the formal statements will be given in section  [ secresults ] .",
    "we consider a continuous - time admissions control problem , depicted in figure  [ figdelill ] .",
    "the problem is characterized by three parameters : @xmath14 and @xmath15 :    jobs arrive to the system at a rate of @xmath16 jobs per unit time , with @xmath9 .",
    "the server operates at a rate of @xmath0 jobs per unit time , with @xmath17 .",
    "the decision maker is allowed to decide whether an arriving job is admitted to the queue , or redirected away , with the goal of minimizing the time - average queue length , . ] and subject to the constraint that the time - average rate of redirection does not exceed @xmath2 jobs per unit time .",
    "the decision maker has access to _ information about the future _ , which takes the form of a _ lookahead window _ of length @xmath18 . in particular , at any time @xmath19 , the times of arrivals and service availability within the interval @xmath20 $ ] are revealed to the decision maker .",
    "we will consider the following cases of @xmath15 :    a.   @xmath21 , the _ online problem _",
    ", where no future information is available .",
    "b.   @xmath22 , the _ offline problem _",
    ", where entire the future has been revealed . c.   @xmath23 , where future is revealed only up to a finite lookahead window .    throughout",
    ", we will fix @xmath17 , and be primarily interested in the system s behavior in the _ heavy - traffic regime _ of @xmath24 .",
    "our main contribution is to demonstrate that the performance of a redirection policy is highly sensitive to the amount of future information available , measured by the value of @xmath15 .",
    "fix @xmath17 , and let the arrival and service processes be poisson . for the online problem ( @xmath21 ) , we show the optimal time - average queue length , @xmath25 , approaches infinity in the heavy - traffic regime , at the rate @xmath26 in sharp contrast , the optimal average queue length among offline policies , @xmath27 , converges to a _ constant _ , @xmath28 and this limit is achieved by a so - called no - job - left - behind policy . figure  [ figdelayscale ] illustrates this difference in delay performance for a particular value of @xmath2 .     and @xmath6 . the value @xmath29 is the resulting average queue length as a function of @xmath2 , @xmath16 and a policy @xmath30 . ]",
    "finally , we show that the no - job - left - behind policy for the offline problem can be modified , so that the _ same _ optimal heavy - traffic limit of @xmath31 is achieved even with a _ finite _ lookahead window , @xmath32 , where @xmath33 this is of practical importance because in any realistic application , only a finite amount of future information can be obtained .    on the methodological end",
    ", we use a sample path - based framework to analyze the performance of the offline and finite lookahead policies , borrowing tools from renewal theory and the theory of random walks .",
    "we believe that our techniques could be substantially generalized to incorporate general arrival and service processes , diffusion approximations as well as observational noises .",
    "see section  [ secconclusions ] for a more elaborate discussion .",
    "there is an extensive body of work devoted to various markov ( or _ online _ ) admissions control problems ; the reader is referred to the survey of @xcite and references therein .",
    "typically , the problem is formulated as an of a markov decision problem ( mdp ) , where the decision maker , by or rejecting incoming jobs , seeks to maximize a long - term average objective of rewards ( e.g. , throughput ) minus costs ( e.g. , waiting time experienced by a customer ) .",
    "the case where the maximization is performed subject to a constraint on some average cost has also been studied , and it has been shown , for a family of reward and cost functions , that an optimal policy assumes a `` threshold - like '' form , where the decision maker redirects the next job only if the current queue length is great or equal to @xmath34 , with possible randomization if at level @xmath35 , and always admits the job if below @xmath35 ; cf .",
    "indeed , our problem , where one tries to minimize average queue length ( delay ) subject to a lower - bound on the throughput ( i.e. , a maximum redirection rate ) , can be shown to belong to this category , and the online heavy - traffic scaling result is a straightforward extension following the mdp framework , albeit dealing with technicalities in extending the threshold characterization to an infinite state space , since we are interested in the regime of @xmath24 .    however , the resource allocation interpretation of our admissions control problem as that of matching jobs with fast and slow resources , and , in particular , its connections to resource pooling in the many - server limit , seems to be largely unexplored .",
    "the difference in motivation perhaps explains why the optimal online heavy - traffic delay scaling of @xmath36 that emerges by fixing @xmath2 and taking @xmath6 has not appeared in the literature , to the best our knowledge .",
    "there is also an extensive literature on _ competitive analysis _ , which focuses on the _ worst - case _ performance of an online algorithms compared to that of an optimal offline version ( i.e. , knowing the entire input sequence ) .",
    "the reader is referred to  @xcite for a comprehensive survey , and the references therein on packing - type problems , such as load balancing and machine scheduling @xcite , and call admission and routing @xcite , which are more related to our problem . while our optimality result for the policy with a finite lookahead window is stated in terms of the _ average _ performance given stochastic inputs , we believe that the analysis can be extended to yield worst - case competitive ratios under certain input regularity conditions .    in sharp contrast to our knowledge of the online problems , significantly less is known for settings in which information about the future is taken into consideration . in @xcite , the author considers a variant of the flow control problem where the decision maker knows the job size of the arriving customer , as well as the arrival and time and job size of the next customer , with the goal of maximizing certain discounted or average reward .",
    "a characterization of an optimal stationary policy is derived under a standard semi - markov decision problem framework , since the lookahead is limited to the next arriving job . in @xcite ,",
    "the authors consider a scheduling problem with one server and @xmath37 parallel queues , motivated by applications in satellite systems where the link qualities between the server and the queues vary over time .",
    "the authors compare the throughput performance between several online policies with that of an offline policy , which has access to all future instances of link qualities .",
    "however , the offline policy takes the form of a viterbi - like dynamic program , which , while being throughput - optimal by definition , provides limited qualitative insight .",
    "one challenge that arises as one tries to move beyond the online setting is that policies with lookahead typically do not admit a clean markov description , and hence common techniques for analyzing markov decision problems do not easily apply . to circumvent the obstacle",
    ", we will first relax our problem to be fully offline , which turns out to be surprisingly amenable to analysis .",
    "we then use the insights from the optimal offline policy to construct an optimal policy with a finite look - ahead window , in a rather straightforward manner .    in other application domains , the idea of exploiting future information or predictions to improve",
    "decision making has been explored .",
    "advance reservations ( a  form of future information ) have been studied in lossy networks @xcite and , more recently , in revenue management @xcite . using simulations",
    ", @xcite demonstrates that the use of a one - week and two - week advance scheduling window for elective surgeries can improve the efficiency at the associated intensive care unit ( icu ) .",
    "the benefits of advanced booking program for supply chains have been shown in @xcite in the form of reduced demand uncertainties . while similar in spirit , the motivations and dynamics in these models are very different from ours .",
    "finally , our formulation of the slow an fast resources had been in part inspired by the literature of resource pooling systems , where one improves overall system performance by ( partially ) sharing individual resources in collective manner .",
    "the connection of our problem to a specific multi - server model proposed by @xcite is discussed in appendix  [ secresourcepooling ] . for the general topic of resource pooling , interested readers",
    "are referred to @xcite and the references therein .",
    "the rest of the paper is organized as follows . the mathematical model for our problem",
    "is described in section  [ secmodel ] .",
    "section  [ secresults ] contains the statements of our main results , and introduces the no - job - leftb - behind policy ( @xmath38 ) , which will be a central object of study for this paper .",
    "section  [ secinterpret ] presents two alternative descriptions of the no - job - left - behind policy that have important structural , as well as algorithmic , implications .",
    "sections  [ secoptonline][secfinitelookahead ] are devoted to the proofs for the results concerning the online , offline and finite - lookahead policies , respectively .",
    "finally , section  [ secconclusions ] contains some concluding remarks and future directions .",
    "we will denote by @xmath39 , @xmath40 and @xmath41 , the set of natural numbers , nonnegative integers and nonnegative reals , respectively .",
    "let @xmath42 be two functions .",
    "we will use the following asymptotic notation throughout : @xmath43 if @xmath44 , @xmath45 if @xmath46 ; @xmath47 if @xmath48 and @xmath49 if @xmath50 .",
    "an illustration of the system setup is given in figure  [ figdelill ] .",
    "the system consists of a single - server queue running in continuous time ( @xmath51 , with an unbounded buffer that stores all unprocessed jobs .",
    "the queue is assumed to be empty at @xmath52 .",
    "jobs arrive to the system according to a poisson process with rate @xmath16 , @xmath53 , so that the intervals between two adjacent arrivals are independent and exponentially distributed with mean @xmath54 .",
    "we will denote by @xmath55 the cumulative arrival process , where @xmath56 is the total number of arrivals to the system by time @xmath19 .",
    "the processing of jobs by the server is modeled by a poisson process of rate @xmath0 .",
    "when the service process receives a jump at time @xmath19 , we say that a service token is generated .",
    "if the queue is not empty at time @xmath19 , exactly one job `` consumes '' the service token and leaves the system immediately .",
    "otherwise , the service token is `` wasted '' and has no impact on the future evolution of the system.[multiblock footnote omitted ] we will denote by @xmath57 the cumulative token generation process , where @xmath58 is the total number of service tokens generated by time @xmath19 .",
    "when @xmath59 , in order to maintain the stability of the queue , a decision maker has the option of `` redirecting '' a job _ at the moment of its arrival_. once redirected , a job effectively `` disappears , '' and for this reason , we will use the word _",
    "deletion _ as a synonymous term for redirection throughout the rest of the paper , because it is more intuitive to think of deleting a job in our subsequent sample - path analysis .",
    "finally , the decision maker is allowed to delete up to a time - average rate of @xmath2 .",
    "let @xmath60 be the continuous - time queue length process , where @xmath61 is the queue length at time @xmath19 if _ no deletion _ is applied at any time .",
    "we say that an _ event _ occurs at time @xmath19 if there is either an arrival , or a generation of service token , at time @xmath19 .",
    "let @xmath62 , @xmath63 , be the time of the @xmath64th event in the system .",
    "denote by @xmath65\\dvtx n\\in\\mathbb{z}_{+ } \\ } $ ] the embedded discrete - time process of @xmath66 , where @xmath67 $ ] is the length of the queue sampled immediately after the @xmath64th event , denotes the right - limit of @xmath68 at @xmath69 : @xmath70 .",
    "in this particular context , the values of @xmath71 $ ] are well defined , since the sample paths of poisson processes are right - continuous - with - left - limits ( rcll ) almost surely . ]",
    "@xmath72= q^{0 } ( t_{n}- ) , \\qquad n\\in \\mathbb{n}\\ ] ] with the initial condition @xmath73=0 $ ] .",
    "it is well known that @xmath74 is a random walk on  @xmath40 , such that for all @xmath75 and @xmath76 , @xmath77=x_2 { |}q^0[n]=x_1 \\bigr ) = \\cases { \\displaystyle\\frac{\\lambda}{\\lambda+1-p } , & \\quad$x_2-x_1=1 $ , \\vspace*{5pt}\\cr \\displaystyle\\frac{1-p}{\\lambda+1-p } , & \\quad$x_2-x_1=-1 $ , \\vspace*{5pt}\\cr 0 , & \\quad otherwise , } \\label{eqq0trans1}\\ ] ] if @xmath78 and @xmath79=x_2 { |}q^0[n]=x_1 \\bigr ) = \\cases { \\displaystyle\\frac{\\lambda}{\\lambda+1-p } , & \\quad$x_2-x_1=1 $ , \\vspace*{5pt}\\cr \\displaystyle\\frac{1-p}{\\lambda+1-p } , & \\quad$ x_2-x_1=0 $ , \\vspace*{5pt}\\cr 0 , & \\quad otherwise,}\\label{eqq0trans2}\\ ] ] if @xmath80 .",
    "note that , when @xmath59 , the random walk @xmath74 is transient .",
    "the process @xmath74 contains _ all relevant information _ in the arrival and service processes , and will be the main object of study of this paper .",
    "we will refer to @xmath74 as the _ initial sample path _ throughout the paper , to distinguish it from sample paths obtained after deletions have been made .",
    "since a deletion can only take place when there is an arrival , it suffices to define the locations of deletions with respect to the discrete - time process @xmath81\\dvtx n\\in\\mathbb{z}_{+ } \\}$ ] , and throughout , our analysis will focus on discrete - time queue length processes unless otherwise specified .",
    "let @xmath82 be the locations of all arrivals in a discrete - time queue length process @xmath83 , that is , @xmath84>q [ n-1 ] \\bigr\\}\\ ] ] and for any @xmath85 , define the counting process @xmath86 associated with @xmath37 as denotes the cardinality of @xmath87 . ]",
    "@xmath88    [ deffeasibledel ] the sequence @xmath89",
    "is said to be a feasible deletion sequence with respect to a discrete - time queue length process , @xmath90 , if all of the following hold :    all elements in @xmath37 are unique , so that at most one deletion occurs at any slot .",
    "@xmath91 , so that a deletion occurs only when there is an arrival .",
    "@xmath92    so that the time - average deletion rate is at most @xmath2 .    in general",
    ", @xmath37 is also allowed to be a finite set .",
    "the denominator @xmath93 in equation  ( [ eqrateconstr ] ) is due to the fact that the total rate of events in the system is @xmath93 . and @xmath94 .",
    "] analogously , the deletion rate in continuous time is defined by @xmath95    the impact of a deletion sequence to the evolution of the queue length process is formalized in the following definition .",
    "[ defdelmap ] fix an initial queue length process @xmath96\\dvtx\\break",
    "n\\in\\mathbb{n } \\}$ ] and a corresponding feasible deletion sequence @xmath97 .",
    "the _ point - wise deletion map _",
    "@xmath98 outputs the resulting process after a deletion is made to @xmath90 in slot @xmath99 .",
    "let @xmath100 . then @xmath101=\\cases { q^{0 } [ n ] -1 , & \\quad$n\\geq m$ and $ q^0[t]>0\\ \\forall t\\in\\{m,\\ldots , n \\}$ ; \\vspace*{5pt}\\cr q^{0 } [ n ] , & \\quad otherwise,}\\label{eqxitr}\\ ] ]    the _ multi - point deletion map _",
    "@xmath102 outputs the resulting process after all deletions in the set @xmath37 are made to @xmath90 .",
    "define @xmath103 recursively as @xmath104 , @xmath105 .",
    "then @xmath106 is defined as the point - wise limit @xmath107=\\lim_{i\\rightarrow\\min\\{|m|,\\infty\\ } } q^{i}[n]\\qquad\\forall n \\in\\mathbb{z}_{+}. \\label{eqqinft}\\ ] ]    the definition of the point - wise deletion map reflects the earlier assumption that the service time of a job only depends on the speed of the server at the moment and is independent of the job s identity ; see section  [ secmodel ] . note also that the value of @xmath108 $ ] depends only on the total number of deletions before @xmath64 [ equation  ( [ eqxitr ] ) ] , which is at most @xmath64 , and the limit in equation  ( [ eqqinft ] ) is justified .",
    "moreover , it is not difficult to see that the order in which the deletions are made has no impact on the resulting sample path , as stated in the lemma below .",
    "the proof is omitted .",
    "[ lemlocindp ] fix an initial sample path @xmath74 , and let @xmath37 and @xmath109 be two feasible deletion sequences that contain the same elements . then @xmath110 .",
    "we next define the notion of a deletion policy that outputs a deletion sequence based on the ( limited ) knowledge of an initial sample path @xmath74 .",
    "informally , a deletion policy is said to be @xmath15-lookahead if it makes its deletion decisions based on the knowledge of @xmath74 up to @xmath15 units of time into the future ( in continuous time ) .",
    "[ defw - pred ] fix @xmath111 .",
    "let @xmath112 be the natural filtration induced by @xmath113 and @xmath114 .",
    "a @xmath15-predictive deletion policy is a mapping , @xmath115 , such that :    @xmath116 is a feasible deletion sequence a.s . ;    @xmath117 is @xmath118 measurable , for all @xmath63 .",
    "we will denote by @xmath119 the family of all @xmath15-lookahead deletion policies .",
    "the parameter @xmath15 in definition  [ defw - pred ] captures the amount of information that the deletion policy has about the future :    when @xmath21 , all deletion decisions are made solely based on the knowledge of the system up to the current time frame .",
    "we will refer to @xmath120 as _ online policies_.    when @xmath22 , the entire sample path of @xmath74 is revealed to the decision maker at @xmath52 .",
    "we will refer to @xmath121 as _ offline policies_.    we will refer to @xmath122 , as policies with a _",
    "lookahead window of size @xmath15_.      given a discrete - time queue length process @xmath83 and @xmath63 , denote by @xmath123 the partial sum @xmath124.\\label{eqpartials}\\ ] ]    let @xmath90 be an initial queue length process .",
    "define @xmath125 as the expected average queue length after applying a deletion policy @xmath30 , @xmath126 where @xmath127 , and the expectation is taken over all realizations of  @xmath90 and the randomness used by @xmath30 internally , if any .    by little s law ,",
    "the long - term average waiting time of a typical customer in the queue is equal to the long - term average queue length divided by the arrival rate ( independent of the service discipline of the server ) .",
    "therefore , if our goal is to minimize the average waiting time of the jobs that remain after deletions , it suffices to use @xmath29 as a performance metric in order to judge the effectiveness of a deletion policy @xmath30 . in particular , denote by @xmath128 the time - average queueing delay experienced by all jobs , where deleted jobs are assumed to have a delay of zero , then @xmath129 , and hence the average queue length and delay coincide in the heavy - traffic regime , as @xmath4 . with an identical argument , it is easy to see that the average delay among _ admitted _ jobs , @xmath130 , satisfies @xmath131 , where @xmath132 is the continuous - time deletion rate under @xmath30",
    ". therefore , we may use the terms `` delay '' and `` average queue length '' interchangeably in the rest of the paper , with the understanding that they represent essentially the same quantity up to a constant .",
    "finally , we define the notion of an optimal delay within a family of policies .",
    "fix @xmath18 .",
    "we call @xmath133 the optimal delay in @xmath119 , where @xmath134",
    "we state the main results of this paper in this section , whose proofs will be presented in sections  [ secoptonline][secfinitelookahead ] .",
    "we say that @xmath135 is an @xmath34-threshold policy , if a job arriving at time @xmath19 is deleted if and only if the queue length at time @xmath19 is greater or equal to @xmath34 .",
    "the following theorem shows that the class of threshold policies achieves the optimal heavy - traffic delay scaling in @xmath136 .",
    "[ teoonline ] fix @xmath17 , and let @xmath137 then :    @xmath138 is feasible for all @xmath139 .",
    "@xmath138 is asymptotically optimal in @xmath120 as @xmath6 , @xmath140    see section  [ secoptonline ] .",
    "given the sample path of a random walk @xmath83 , let @xmath141 the number of slots till @xmath83 reaches the level @xmath142 - 1 $ ] after slot @xmath64 : @xmath143=q[n]-1 \\bigr\\}.\\ ] ]    [ defnob ] given an initial sample path @xmath90 , the no - job - left - behind policy , denoted by @xmath144 , deletes all arrivals in the set @xmath145 , where @xmath146 we will refer to the deletion sequence generated by @xmath38 as @xmath147 , where @xmath148 .",
    "in other words , @xmath38 would delete a job arriving at time @xmath19 if and only if the initial queue length process never returns to below the current level in the future , which also implies that @xmath149 \\geq q^0 \\bigl[m^\\psi_i \\bigr]\\qquad\\forall i\\in\\mathbb{n } , n\\geq m^\\psi_i . \\label{eqmiinc}\\ ] ] examples of the @xmath38 policy being applied to a particular sample path are given in figures  [ figwater1 ] and  [ figwater2 ] ( illustration ) , as well as in figure  [ figsamplepaths ] ( simulation ) .     to an initial sample path , @xmath74 , where the deletions are marked by bold red arrows . ]    , after applying @xmath38 to @xmath74 . ]     and those obtained after applying @xmath138 and @xmath38 to @xmath74 , with @xmath150 and @xmath151 . ]",
    "it turns out that the delay performance of @xmath38 is about as good as we can hope for in heavy traffic , as is formalized in the next theorem .",
    "[ teooffline ] fix @xmath152 .",
    "@xmath38 is feasible for all @xmath153 and is not a very efficient deletion policy for relatively small values of @xmath16 .",
    "in fact , @xmath154 is a _ decreasing _ function of @xmath16 .",
    "this problem can be fixed by injecting into the arrival process an poisson process of `` dummy jobs '' of rate @xmath155 , so that the total rate of arrival is @xmath156 , where @xmath157 .",
    "this reasoning implies that @xmath5 is a uniform upper - bound of @xmath158 for all @xmath9 . ]",
    "@xmath159    @xmath38 is asymptotically optimal in @xmath121 as @xmath6 , @xmath160    see section  [ secoffline ] .",
    "it is perhaps surprising to observe that the heavy - traffic scaling essentially `` collapses '' under @xmath38 : the average queue length converges to a finite value , @xmath31 , as @xmath6 , which is in sharp contrast  with the optimal scaling of @xmath161 for the online policies , given by theorem  [ teoonline ] ; see figure  [ figdelayscale ] for an illustration of this difference .",
    "a `` stack '' interpretation of the no - job - left - behind policy ( section  [ secinterpantireac ] ) will help us understand intuitively why such a drastic discrepancy exists between the online and offline heavy - traffic scaling behaviors .",
    "also , as a by - product of theorem  [ teooffline ] , observe that the heavy - traffic limit scales , in @xmath2 , as @xmath162 this is consistent with an intuitive notion of `` flexibility '' : delay should degenerate as the system s ability to redirect away jobs diminishes .",
    "let @xmath163 satisfy @xmath164 .",
    "consider a galton ",
    "watson birth process in which each node has @xmath165 children , where @xmath165 is poisson with mean @xmath166 .",
    "conditioning on the finiteness of the process gives a galton  watson process where @xmath165 is poisson with mean @xmath167 .",
    "this occurs in the classical analysis of the erds ",
    "rnyi random graph @xmath168 with @xmath169 .",
    "there will be a giant component and the deletion of that component gives a random graph @xmath170 with @xmath171 . as a rough analogy , @xmath38 deletes those nodes that would be in the giant component .      in practice , infinite prediction into the future is certainly too much to ask for . in this section ,",
    "we show that a natural modification of @xmath38 allows for the _ same delay _ to be achieved , using only a _",
    "finite _ lookahead window , whose length , @xmath32 , increases to infinity as @xmath6 . leads to a deletion rate of @xmath172 , and there is an additional @xmath173=1-\\lambda$ ] unused deletion rate that can be exploited . ]    denote by @xmath18 the size of the lookahead window in continuous time , and @xmath174 the window size in the discrete - time embedded process @xmath74 , starting from slot @xmath64 .",
    "letting @xmath175 be the time of the @xmath64th event in the system , then @xmath176    for @xmath177 , define the set of indices @xmath178=q[n]-1 \\bigr\\}.\\ ] ]    given an initial sample path @xmath90 and @xmath179 , the @xmath15-no - job - left - behind policy , denoted by @xmath180 , deletes all arrivals in the set @xmath181 , where @xmath182    it is easy to see that @xmath183 is simply @xmath38 applied within the confinement of a finite window : a job at @xmath19 is deleted if and only if the initial queue length process does not return to below the current level _ within the next @xmath15 units of time _ , assuming no further deletions are made .",
    "since the window is finite , it is clear that @xmath184 for any @xmath185 , and hence @xmath186 for all @xmath187 .",
    "the only issue now becomes that of feasibility : by making decision only based on a finite lookahead window , we may end up deleting at a rate greater than @xmath2 .",
    "the following theorem summarizes the above observations and gives an upper bound on the appropriate window size , @xmath15 , as a function of @xmath16 . implies theorem  [ teooffline ] and is hence stronger . ]",
    "[ teolookahead ] fix @xmath188 .",
    "there exists @xmath189 , such that if @xmath190 then @xmath191 is feasible and @xmath192 since @xmath193 and @xmath194 , we also have that @xmath195    see section  [ secpfthmlookahead ] .",
    "theorem  [ teolookahead ] says that one can attain the same heavy - traffic delay performance as the optimal offline algorithm if the size of the lookahead window scales as @xmath196 .",
    "is this the minimum amount of future information necessary to achieve the same ( or comparable ) heavy - traffic delay limit as the optimal offline policy ?",
    "we conjecture that this is the case , in the sense that there exists a matching lower bound , as follows.=-1    .",
    "results presented in this paper are illustrated in the solid lines and circles , and the gray dotted line depicts our conjecture of the unknown regime of @xmath197 . ]    [ conjinfolowerbound ] fix @xmath17 . if @xmath198 as @xmath6 , then @xmath199 in other words , `` delay collapse '' can occur only if @xmath200 .",
    "if the conjecture is proven , it would imply a _ sharp transition _ in the system s heavy - traffic delay scaling behavior , around the critical `` threshold '' of @xmath201 .",
    "it would also imply the existence of a symmetric dual relationship between _ future information _ and _ queueing delay _ :",
    "@xmath202 amount of information is required to achieve a finite delay limit , and one has to suffer @xmath202 in delay , if only finite amount of future information is available .",
    "figure  [ figcollapse ] summarizes the main results of this paper from the angle of the delay - information duality .",
    "the dotted line segment marks the unknown regime and the sharp transition at its right endpoint reflects the view of conjecture  [ conjinfolowerbound ] .",
    "we present two equivalent ways of describing the no - job - left - behind policy @xmath38 .",
    "the _ stack interpretation _ helps us derive asymptotic deletion rate of @xmath38 in a simple manner , and illustrates the superiority of @xmath38 compared to an online policy .",
    "another description of @xmath38 using time - reversal shows us that the set of deletions made by @xmath38 can be calculated efficiently in linear time ( with respect to the length of the time horizon ) .",
    "suppose that the service discipline adopted by the server is that of last - in - first - out ( lifo ) , where the it always fetches a task that has arrived the latest .",
    "in other words , the queue works as a _",
    "stack_. suppose that we first simulate the stack without any deletion .",
    "it is easy to see that , when the arrival rate @xmath16 is greater than the service rate @xmath0 , there will be a growing set of jobs at the bottom of the stack that will _ never _ be processed .",
    "label all such jobs as `` left - behind . '' for example , figure  [ figwater1 ] shows the evolution of the queue over time , where all `` left - behind '' jobs are colored with a blue shade .",
    "one can then verify that the policy @xmath144 given in definition  [ defnob ] is equivalent to deleting all jobs that are labeled `` left - behind , '' hence the namesake `` no job left behind . ''",
    "figure  [ figwater2 ] illustrates applying @xmath144 to a sample path of @xmath74 , where the @xmath203th job to be deleted is precisely the @xmath203th job among all jobs that would have never been processed by the server under a lifo policy .",
    "one advantage of the stack interpretation is that it makes obvious the fact that the deletion rate induced by @xmath38 is equal to @xmath204 , as illustrated in the following lemma .    for all @xmath59 ,",
    "the following statements hold : [ lemnobbasic ]    with probability one , there exists @xmath205 , such that every service token generated after time @xmath206 is matched with some job . in other words ,",
    "the server never idles after some finite time .",
    "let @xmath207 .",
    "we have @xmath208 which implies that @xmath38 is feasible for all @xmath17 and @xmath1 .",
    "see appendix  [ applemnobbasic ] .",
    "some geometric intuition from the stack interpretation shows that the power of @xmath38 essentially stems from being highly _ anticipatory_. looking at figure  [ figwater1 ] , one sees that the jobs that are `` left behind '' at the bottom of the stack correspond to those who arrive during the intervals where the initial sample path @xmath74 is taking a consecutive `` upward hike . ''",
    "in other words , @xmath38 begins to delete jobs when it anticipates that the arrivals are _ just about to _ get intense .",
    "similarly , a job in the stack will be `` served '' if @xmath74 curves down eventually in the future , which corresponds @xmath38 s stopping deleting jobs as soon as it anticipates that the next few arrivals can be handled by the server alone . in sharp contrast",
    "is the nature of the optimal online policy , @xmath138 , which is by definition `` reactionary '' and begins to delete only when the current queue length has already reached a high level .",
    "the differences in the resulting sample paths are illustrated via simulations in figure  [ figsamplepaths ] .",
    "for example , as @xmath74 continues to increase during the first 1000 time slots , @xmath38 begins deleting immediately after @xmath52 , while no deletion is made by @xmath209 during this period.=1    as a rough analogy , the offline policy starts to delete _ before _ the arrivals get busy , but the online policy can only delete _ after _ the burst in arrival traffic has been realized , by which point it is already `` too late '' to fully contain the delay .",
    "this explains , to certain extend , why @xmath38 is capable of achieving `` delay collapse '' in the heavy - traffic regime ( i.e. , a finite limit of delay as @xmath6 , theorem  [ teooffline ] ) , while the delay under even the best online policy diverges to infinity as @xmath6 ( theorem  [ teoonline ] ) .      while the offline deletion problem serves as a nice abstraction , it is impossible to actually store information about the _ infinite _ future in practice , even if such information is available .",
    "a natural finite - horizon version of the offline deletion problem can be posed as follows : given the values of @xmath74 over the first @xmath12 slots , where @xmath12 finite , one would like to compute the set of deletions made by @xmath38 , @xmath210 assuming that @xmath211 > q^0[n]$ ] for all @xmath212 . note that this problem also arises in computing the sites of deletions for the @xmath180 policy , where one would replace @xmath12 with the length of the lookahead window , @xmath15 .",
    "we have the following algorithm , which identifies all slots on which a new `` minimum '' ( denoted by the variable @xmath213 ) is achieved in @xmath74 , when viewed in the _ reverse _ order of time .",
    "it is easy to see that the running time of the above algorithm scales linearly with respect to the length of the time horizon , @xmath12 .",
    "note that this is not the unique linear - time algorithm .",
    "in fact , one can verify that the simulation procedure used in describing the stack interpretation of @xmath38 ( section  [ secinterpret ] ) , which keeps track of which jobs would eventually be served , is itself a linear - time algorithm .",
    "however , the time - reverse version given here is arguably more intuitive and simpler to describe .    ' '' ''    ' '' ''    @xmath214 $ ] and @xmath215 @xmath216 @xmath217 $ ] @xmath218 @xmath219    ' '' ''",
    "starting from this section and through section  [ secfinitelookahead ] , we present the proofs of the results stated in section  [ secresults ] .",
    "we begin with showing theorem  [ teoonline ] , by formulating the online problem as a markov decision problem ( mdp ) with an average cost constraint , which then enables us to use existing results to characterize the form of optimal policies .",
    "once the family of threshold policies has been shown to achieve the optimal delay scaling in @xmath220 under heavy traffic , the exact form of the scaling can be obtained in a fairly straightforward manner from the steady - state distribution of a truncated birth  death process .",
    "since both the arrival and service processes are poisson , we can formulate the problem of finding an optimal policy in @xmath136 as a continuous - time markov decision problem with an average - cost constraint , as follows .",
    "let @xmath221 be the resulting continuous - time queue length process after applying some policy in @xmath136 to @xmath74 .",
    "let @xmath222 be the @xmath223th upward jump in @xmath83 and @xmath224 the length of the @xmath223th inter - jump interval , @xmath225 .",
    "the task of a deletion policy , @xmath226 , amounts to choosing , for each of the inter - jump intervals , a _ deletion action _ , @xmath227 $ ] , where the value of @xmath228 corresponds to the probability that the next arrival during the current inter - jump interval will be deleted .",
    "define @xmath229 and @xmath230 to be the _ reward _ and _ cost _ functions of an inter - jump interval , respectively , @xmath231 where @xmath232 .",
    "the corresponding mdp seeks to maximize the time - average reward @xmath233 while obeying the average - cost constraint @xmath234 to see why this mdp solves our deletion problem , observe that @xmath235 is the negative of the time - average queue length , and @xmath236 is the time - average deletion rate .",
    "it is well known that the type of constrained mdp described above admits an optimal policy that is stationary @xcite , which means that the action @xmath228 depends solely on the current state , @xmath237 , and is independent of the time index @xmath223 .",
    "therefore , it suffices to describe @xmath30 using a sequence , @xmath238 , such that @xmath239 whenever @xmath240 .",
    "moreover , when the state space is finite , . ]",
    "stronger characterizations of the @xmath241 s have been obtained for a family of reward and cost functions under certain regularity assumptions ( hypotheses 2.7 , 3.1 and 4.1 in @xcite ) , which ours do satisfy [ equations  ( [ eqreward ] ) and ( [ eqcost ] ) ] .",
    "theorem  [ teoonline ] will be proved using the next - known result ( adapted from theorem 4.4 in @xcite ) :    [ lemquasithresh ] fix @xmath2 and @xmath16 , and let the buffer size @xmath242 be finite .",
    "there exists an optimal stationary policy , @xmath243 , of the form @xmath244 for some @xmath245 and @xmath246 $ ] .      in words",
    ", lemma  [ lemquasithresh ] states that the optimal policy admits a `` quasi - threshold '' form : it deletes the next arrival when @xmath247 , admits when @xmath248 , and admits with probability @xmath249 when @xmath250 .",
    "suppose , for the moment , that the statements of lemma [ lemquasithresh ] also hold when the buffer size is infinite , an assumption to be justified by the end of the proof .",
    "denoting by @xmath251 the stationary optimal policy associated with @xmath252 , when the constraint on the average of deletion is @xmath2 [ equation  ( [ eqavgcost ] ) ] .",
    "the evolution of @xmath253 under @xmath251 is that of a birth ",
    "death process truncated at state @xmath254 , with the transition rates given in figure  [ figbdchain ] , and the time - average queue length is equal to the expected queue length in steady state . using standard calculations involving the steady - state distribution of the induced markov process , it is not difficult to verify that @xmath255 where @xmath254 is defined as in lemma  [ lemquasithresh ] , and @xmath29 is the time - average queue length under policy @xmath256 , defined in equation  ( [ eqc ] ) .    .",
    "]    denote by @xmath257 the steady - state probability of the queue length being equal to @xmath203 , under a threshold policy @xmath135 .",
    "assuming @xmath258 , standard calculations using the balancing equations yield @xmath259 and @xmath260 for all @xmath261 .",
    "the time - average queue length is given by @xmath262 \\\\[-8pt ] & = & \\frac{\\theta } { ( \\theta-1 ) ( \\theta^{l+1}-1 ) } \\cdot\\bigl[1-\\theta^l+l\\theta^l ( \\theta-1 ) \\bigr ] , \\nonumber\\end{aligned}\\ ] ] where @xmath263 .",
    "note that when @xmath59 , @xmath264 is decreasing with respect to @xmath34 for all @xmath265 [ equation  ( [ eqmui ] ) ] , which implies that the time - average queue length is monotonically increasing in @xmath34 , that is , @xmath266 it is also easy to see that , fixing @xmath2 , since we have that @xmath267 for all @xmath16 sufficiently close to @xmath268 , where @xmath269 is a fixed constant , we have @xmath270    since deletions only occur when @xmath253 is in state @xmath34 , from equation  ( [ eqmui ] ) , the average rate of deletions in continuous time under @xmath135 is given by @xmath271 define @xmath272 that is , @xmath273 is the smallest @xmath34 for which @xmath135 remains feasible , given a deletion rate constraint of @xmath69 . using equations  ( [ eqrdthr ] ) and ( [ eqllamp ] ) to solve for @xmath274 , we obtain , after some algebra , @xmath275 and , by combining equation  ( [ eqllamp2 ] ) and equation  ( [ eqcthresh ] ) with @xmath276 , we have @xmath277    by equations  ( [ eqcmonl ] ) and ( [ eqllamp ] ) , we know that @xmath278 achieves the minimum average queue length among all feasible threshold policies . by equation  ( [ eqccc1 ] ) , we must have that @xmath279    since lemma  [ lemquasithresh ] only applies when @xmath280 , equation  ( [ eqccc2 ] ) holds whenever the buffer size , @xmath242 , is greater than @xmath274 , but finite .",
    "we next extend equation  ( [ eqccc2 ] ) to the case of @xmath281 .",
    "denote by @xmath282 a stationary optimal policy , when @xmath281 and the constraint on average deletion rate is equal to @xmath2 [ equation  ( [ eqavgcost ] ) ] .",
    "the upper bound on @xmath283 in equation  ( [ eqccc2 ] ) automatically holds for @xmath284 , since @xmath285 is still feasible when @xmath281 .",
    "it remains to show a lower bound of the form @xmath286 when @xmath281 , which , together with the upper bound , will have implied that the scaling of @xmath287 [ equation ( [ eqcthropt ] ) ] carries over to @xmath288 , @xmath289 thus proving theorem  [ teoonline ] .    to show equation  ( [ eqclower ] )",
    ", we will use a straightforward truncation argument that relates the performance of an optimal policy under @xmath281 to the case of @xmath280 .",
    "denote by @xmath252 the deletion probabilities of a stationary optimal policy , @xmath282 , and by @xmath290 the deletion probabilities for a truncated version , @xmath291 , with @xmath292 for all @xmath293 . since @xmath282 is optimal and yields the minimum average queue length , it is without loss of generality to assume that the markov process for @xmath253 induced by @xmath282 is positive recurrent .",
    "denoting by @xmath294 and @xmath295 the steady - state probability of queue length being equal to @xmath203 under @xmath282 and @xmath291 , respectively , it follows from the positive recurrence of @xmath253 under @xmath296 and some algebra , that @xmath297 for all @xmath298 and @xmath299 by equation ( [ eqptwmucon ] ) and the fact that @xmath300 for all @xmath301 , we have that could be greater than @xmath2 , for any finite @xmath302 . ]",
    "it is not difficult to verify , from the definition of @xmath274 [ equation  ( [ eqllamp ] ) ] , that @xmath304 for all @xmath305 . for all @xmath306 , choose @xmath302 to be sufficiently large , so that @xmath307    let @xmath308 . since @xmath309 for all @xmath310 , by equation  ( [ eqrdeps ] ) we have @xmath311 where @xmath312 is the optimal stationary policy given in lemma  [ lemquasithresh ] under any the finite buffer size @xmath313 .",
    "we have @xmath314 where the inequalities ( a ) through ( d ) follow from equations  ( [ eqctocb ] ) , ( [ eqbinftobfin ] ) , ( [ eqccc2 ] ) and ( [ eqrdeps ] ) , respectively .",
    "since equation  ( [ eqclower2 ] ) holds for all @xmath306 , we have proven equation  ( [ eqclower ] ) .",
    "this completes the proof of theorem  [ teoonline ] .",
    "we prove theorem  [ teooffline ] in this section , which is completed in two parts . in the first part ( section  [ secperformoffline ] ) , we give a full characterization of the sample path resulted by applying @xmath38 ( proposition  [ propqrw ] ) , which turns out to be a _ recurrent _ random walk .",
    "this allows us to obtain the steady - state distribution of the queue length under @xmath38 in closed - form . from this , the expected queue length , which is equal to the time - average queue length , @xmath315 , can be easily derived and is shown to be @xmath316 .",
    "several side results we obtain along this path will also be used in subsequent sections .",
    "the second part of the proof ( section  [ secoptmalityofflineproof ] ) focuses on showing the heavy - traffic optimality of @xmath38 among the class of all feasible offline policies , namely , that @xmath317 , which , together with the first part , proves theorem  [ teooffline ] ( section  [ secpfthmoffline ] ) .",
    "the optimality result is proved using a sample - path - based analysis , by relating the resulting queue length sample path of @xmath38 to that of a greedy deletion rule , which has an optimal deletion performance over a _",
    "finite _ time horizon , @xmath318 , given any initial sample path .",
    "we then show that the discrepancy between @xmath144 and the greedy policy , in terms of the resulting time - average queue length after deletion , diminishes almost surely as @xmath319 and @xmath6 ( with the two limits taken in this order ) .",
    "this establishes the heavy - traffic optimality of @xmath38 .",
    "define @xmath320 as the resulting queue length process after applying @xmath38 @xmath321 and @xmath83 as the shifted version of @xmath320 , so that @xmath83 starts from the first deletion in  @xmath320,=-1 @xmath322 = \\widetilde{q}\\bigl[n + m^\\psi_1\\bigr],\\qquad n \\in \\mathbb{z}_{+}.\\vadjust{\\goodbreak}\\]]=0    we say that @xmath323 is a _ busy period _ of @xmath83 if @xmath324=q[u]=0\\quad\\mbox{and}\\quad q[n]>0\\qquad\\mbox{for all } n\\in\\{l,\\ldots , u-1 \\}.",
    "\\label{eqbusydef}\\ ] ] we may write @xmath325 to mean the @xmath326th busy period of @xmath83 .",
    "an example of a busy period is illustrated in figure  [ figwater2 ] .",
    "finally , we will refer to the set of slots between two adjacent deletions in @xmath83 ( note the offset of @xmath327 ) , @xmath328 as the @xmath203th _ deletion epoch_.      for simplicity of notation , throughout this section , we will denote by @xmath329 the deletion sequence generated by applying @xmath38 to @xmath74 , when there is no ambiguity ( as opposed to using @xmath330 and @xmath331 ) .",
    "the following lemma summarizes some important properties of @xmath83 which will be used repeatedly .",
    "[ lemqmi0 ] suppose @xmath332 .",
    "the following hold with probability one :    for all @xmath63 , we have @xmath142 = q^0[n+m_1 ] - i(m , n+m_1)$ ] .    for all @xmath333 , we have @xmath334 , if and only if @xmath322=q[n-1]=0\\ ] ] with the convention that @xmath335= 0 $ ] . in other words ,",
    "the appearance of two consecutive zeros in @xmath83 is equivalent to having a deletion on the second zero .",
    "@xmath142\\in\\mathbb{z}_{+}$ ] for all @xmath76 .",
    "see appendix  [ applemqmi0 ]    the next proposition is the main result of this subsection .",
    "it specifies the probability law that governs the evolution of @xmath83 .",
    "[ propqrw ] @xmath336\\dvtx n\\in\\mathbb{z}_{+ } \\}$ ] is a random walk on @xmath40 , with @xmath337=0 $ ] , and , for all @xmath63 and @xmath338 , @xmath339=x_2 { |}q[n]=x_2 \\bigr ) = \\cases { \\displaystyle\\frac{1-p}{\\lambda+1-p } , & \\quad$x_2-x_1=1 $ , \\vspace*{5pt}\\cr \\displaystyle\\frac{\\lambda}{\\lambda+1-p } , & \\quad$x_2-x_1=-1 $ , \\vspace*{5pt}\\cr 0 , & \\quad otherwise,}\\ ] ] if @xmath78 and @xmath339=x_2 { |}q[n]=x_1 \\bigr ) = \\cases { \\displaystyle\\frac{1-p}{\\lambda+1-p } , & \\quad$x_2-x_1=1 $ , \\vspace*{5pt}\\cr \\displaystyle\\frac{\\lambda}{\\lambda+1-p } , & \\quad$x_2-x_1=0 $ , \\vspace*{5pt}\\cr 0 , & \\quad otherwise,}\\ ] ] if @xmath80 .    for a sequence @xmath340\\dvtx n\\in\\mathbb{n } \\}$ ] and @xmath341 , @xmath342",
    ", we will use the shorthand @xmath343,\\ldots , x[t ] \\bigr\\}.\\ ] ] fix @xmath344 , and a sequence @xmath345 .",
    "we have @xmath346=q[n ] | q_1^{n-1}=q_1^{n-1 } \\bigr)\\nonumber \\\\ & & \\qquad = \\sum_{k=1}^{n } \\mathop{\\sum_{t_1,\\ldots , t_k,}}_{t_k\\leq n-1+t_1 } \\mathbb{p } \\bigl(q[n]=q[n ] | q_1^{n-1}=q_1^{n-1 } , m_{1}^k = t_1^k , m_{k+1}\\geq n + t_1 \\bigr)\\hspace*{-20pt } \\\\ & & \\hspace*{88pt}{}\\times \\mathbb{p } \\bigl(m_{1}^k = t_1^k , m_{k+1}\\geq n + t_1 | q_1^{n-1}=q_1^{n-1 } \\bigr )",
    ". \\nonumber\\end{aligned}\\ ] ]    restricting to the values of @xmath347 s and @xmath348 $ ] s under which the summand is nonzero , the first factor in the summand can be written as @xmath349=q[n ] | q_1^{n-1}=q_1^{n-1 } , m_{1}^k = t_1^k , m_{k+1}\\geq n+t_1 \\bigr ) \\nonumber \\\\ & & \\qquad = \\mathbb{p } \\bigl(\\widetilde{q}[n+m_1]=q[n ] | { \\widetilde{q } } _ { m_1 + 1}^{m_1+n-1 } = q_1^{n-1 } , m_{1}^k = t_1^k , m_{k+1}\\geq n+t_1 \\bigr)\\nonumber \\\\ & & \\qquad \\stackrel{\\mathrm{(a ) } } { = }   \\mathbb{p } \\bigl(q^0[n+t_1]=q[n]+k    \\}_{i=1}^k , s+t_1 \\bigr ) , \\nonumber\\\\[-8pt]\\\\[-8pt ] & & \\hspace*{153pt}\\forall1\\leq s \\leq n-1 \\mbox { and } \\min_{r\\geq n+t_1 } q^0[r ] \\geq k \\bigr ) \\nonumber \\\\ & & \\qquad \\stackrel{\\mathrm{(b ) } } { = }   \\mathbb{p } \\bigl(q^0[n+t_1]=q[n]+k    \\\\ & & \\hspace*{190.5pt } \\mbox{and } \\min_{r\\geq n+t_1 } q^0[r ] \\geq k \\bigr ) , \\nonumber\\end{aligned}\\ ] ] where @xmath320 was defined in equation  ( [ eqqtil ] ) .",
    "step  ( a ) follows from lemma  [ lemqmi0 ] and the fact that @xmath350 , and ( b ) from the markov property of @xmath74 and the fact that the events @xmath351 \\geq k \\}$ ] , @xmath352=q[n]+k \\}$ ] and their intersection , depend only on the values of @xmath353\\dvtx s\\geq n+t_1 \\}$ ] , and are hence independent of @xmath353\\dvtx 1\\leq s \\leq n-2+t_1 \\}$ ] conditional on the value of @xmath354 $ ] .",
    "since the process @xmath83 lives in @xmath40 ( lemma  [ lemqmi0 ] ) , it suffices to consider the case of @xmath355=q[n-1]+1 $ ] , and show that @xmath356=q[n-1]+1+k | q^0[n-1+t_1]=q[n-1]+k \\nonumber \\\\ & & \\hspace*{192pt } \\mbox{and } \\min _ { r\\geq n+t_1 } q^0[r ] \\geq k \\bigr ) \\\\ & & \\qquad = \\frac{1-p}{\\lambda+1-p}\\nonumber\\end{aligned}\\ ] ] for all @xmath357\\in\\mathbb{z}_{+}$ ] . since @xmath358=q[m_i-1-m_1]=0 $ ] for all @xmath203 ( lemma  [ lemqmi0 ] ) , the fact that @xmath355=q[n-1]+1>0 $ ] implies that @xmath359 moreover , since @xmath360=k$ ] and @xmath361 , we have that @xmath362>0\\qquad\\mbox{implies } q^0[t]=k\\qquad\\mbox{for some } t\\geq n+1+m_1 . \\label{eqacondition}\\ ] ] we consider two cases , depending on the value of @xmath357 $ ] .",
    "using the same argument that led to equation  ( [ eqacondition ] ) , we have that @xmath363>0\\qquad\\mbox{implies } q^0[t]=k\\qquad\\mbox{for some } t\\geq n + m_1 . \\label{eqn2}\\ ] ] it is important to note that , despite the similarity of their conclusions , equations  ( [ eqacondition ] ) and ( [ eqn2 ] ) are different in their assumptions ( i.e. , @xmath355 $ ] versus @xmath357 $ ] ) .",
    "we have @xmath364=q[n-1]+1+k | q^0[n-1+t_1]=q[n-1]+k\\nonumber \\\\ & & \\hspace*{193pt}\\mbox{and } \\min _ { r\\geq n+t_1 } q^0[r ] \\geq k \\bigr)\\nonumber \\\\ & & \\qquad \\stackrel{\\mathrm{(a ) } } { = } \\mathbb{p } \\bigl(q^0[n+t_1]=q[n-1]+1+k    \\nonumber\\\\[-8pt]\\\\[-8pt ] & & \\hspace*{227pt}\\mbox{and } \\min _ { r\\geq n+t_1 } q^0[r ] = k \\bigr)\\nonumber \\\\ & & \\qquad \\stackrel{\\mathrm{(b ) } } { = } \\mathbb{p } \\bigl(q^0[2]=q[n-1]+1 | q^0[1]=q[n-1]\\mbox { and } \\min_{r\\geq2}q^0[r ] = 0 \\bigr)\\nonumber \\\\ & & \\qquad \\stackrel{\\mathrm{(c ) } } { = }   \\frac{1-p}{\\lambda+1-p } , \\nonumber\\end{aligned}\\ ] ] where ( a ) follows from equation  ( [ eqn2 ] ) , ( b ) from the stationary and space - homogeneity of the markov chain @xmath74 and ( c ) from the following well - known property of a transient random walk conditional to returning to zero :    [ lemdualrw ] let @xmath340\\dvtx n\\in\\mathbb{n } \\}$ ] be a random walk on @xmath40 , such that for all @xmath338 and @xmath63 , @xmath365=x_2 { |}x[n]=x_2 \\bigr ) = \\cases { q , & \\quad$x_2-x_1=1 $ , \\vspace*{5pt}\\cr 1-q , & \\quad$x_2-x_1=-1 $ , \\vspace*{5pt}\\cr 0 , & \\quad otherwise,}\\ ] ] if @xmath78 and @xmath365=x_2 { |}x[n]=x_1 \\bigr ) = \\cases { q , & \\quad$x_2-x_1=1 $ , \\vspace*{5pt}\\cr 1-q , & \\quad$x_2-x_1=0 $ , \\vspace*{5pt}\\cr 0 , & \\quad otherwise,}\\ ] ] if @xmath80 , where @xmath366 . then for all @xmath338 and @xmath63 , @xmath367=x_2 | x[n]=x_1 , \\min _ { r \\geq n+1 } x[r ] = 0 \\bigr ) = \\cases { 1-q , & \\quad$x_2-x_1=1 $ , \\vspace*{5pt}\\cr q , & \\quad$x_2-x_1=-1 $ , \\vspace*{5pt}\\cr 0 , & \\quad otherwise,}\\ ] ] if @xmath78 and @xmath367=x_2 | x[n]=x_1 , \\min _ { r \\geq n+1 } x[r ] = 0 \\bigr ) = \\cases { 1-q , & \\quad$x_2-x_1=1 $ , \\vspace*{5pt}\\cr q , & \\quad$x_2-x_1=0 $ , \\vspace*{5pt}\\cr 0 , & \\quad otherwise,}\\ ] ] if @xmath80 . in other words , conditional on the eventual return to @xmath368 and before it happens , a transient random walk obeys the same probability law as a random walk with the reversed one - step transition probability",
    ".    see appendix  [ applemdualrw ] .",
    "we have @xmath369=q[n-1]+1+k | q^0[n-1+t_1]=q[n-1]+k\\nonumber \\\\ & & \\hspace*{190pt } \\mbox { and } \\min _ { r\\geq n+t_1 } q^0[r ] \\geq k \\bigr)\\nonumber \\\\ & & \\qquad \\stackrel{\\mathrm{(a ) } } { = } \\mathbb{p } \\bigl(q^0[n+t_1]=1+k\\nonumber \\mbox { and } \\min_{r > n+t_1 } q^0[r ] = k | q^0[n-1+t_1]=k \\nonumber\\\\[-8pt]\\\\[-8pt ] & & \\hspace*{220pt } \\mbox { and } \\min_{r\\geq n+t_1 } q^0[r ] \\geq k \\bigr)\\nonumber \\\\ & & \\qquad \\stackrel{\\mathrm{(b ) } } { = } \\mathbb{p } \\bigl(q^0[2]=2 \\mbox { and } \\min _ { r>2 } q^0[r ] = 1 | q^0[1]=1 \\mbox { and } \\min_{r\\geq2 } q^0[r ] \\geq1 \\bigr ) , \\nonumber \\\\ & & \\qquad \\stackrel{\\triangle } { = } x , \\nonumber\\end{aligned}\\ ] ] where ( a ) follows from equation  ( [ eqacondition ] ) [ note its difference with equation  ( [ eqn2 ] ) ] , and ( b ) from the stationarity and space - homogeneity of @xmath74 , and the assumption that @xmath370 [ equation  ( [ eqqcond0 ] ) ] .    since equations  ( [ eqqcond2 ] ) and ( [ eqqcond3 ] ) hold for all @xmath371 and @xmath372 , by equation  ( [ eqqcond0 ] )",
    ", we have that @xmath373=q[n ] | q_1^{n-1}=q_1^{n-1 } \\bigr ) \\nonumber\\\\[18pt]\\\\[-30pt ] & & \\qquad = \\cases{\\displaystyle\\frac{1-p}{\\lambda+1-p } , & \\quad$q[n]-q[n-1]=1 $ , \\vspace*{5pt}\\cr \\displaystyle\\frac{\\lambda}{\\lambda+1-p } , & \\quad$q[n]-q[n-1]=-1 $ , \\vspace*{5pt}\\cr 0 , & \\quad otherwise,}\\nonumber\\end{aligned}\\ ] ] if @xmath357>0 $ ] and @xmath374=q[n ] | q_1^{n-1}=q_1^{n-1 } \\bigr ) = \\cases{x , & \\quad$q[n]-q[n-1]=1 $ , \\vspace*{5pt}\\cr 1-x , & \\quad$q[n]-q[n-1]=0 $ , \\vspace*{5pt}\\cr 0 , & \\quad otherwise,}\\label{eqtransit2}\\end{aligned}\\ ] ] if @xmath357=0 $ ] , where @xmath69 represents the value of the probability in equation  ( [ eqqcond3 ] )",
    ". clearly , @xmath337=q^0[m_1]=0 $ ] .",
    "we next show that @xmath69 is indeed equal to @xmath375 , which will have proven proposition  [ propqrw ] .",
    "one can in principle obtain the value of @xmath69 by directly computing the probability in line ( b ) of equation  ( [ eqqcond3 ] ) , which can be quite difficult to do .",
    "instead , we will use an indirect approach that turns out to be computationally much simpler : we will relate @xmath69 to the rate of deletion of @xmath38 using renewal theory , and then solve for @xmath69 . as a by - product of this approach , we will also get a better understanding of an important regenerative structure of @xmath38 [ equation  ( [ eqlimfrac1 ] ) ] , which will be useful for the analysis in subsequent sections .    by equations",
    "( [ eqtransit1 ] ) and ( [ eqtransit2 ] ) , @xmath83 is a positive recurrent markov chain , and @xmath142 $ ] converges to a well - defined steady - state distribution , @xmath376 $ ] , as @xmath377 . letting @xmath378=i ) $ ] ,",
    "it is easy to verify via the balancing equations that @xmath379 and since @xmath380 , we obtain @xmath381 since the chain @xmath83 is also irreducible , the limiting fraction of time that @xmath83 spends in state 0 is therefore equal to @xmath382 , @xmath383=0 \\bigr ) = \\pi_0= \\frac{1}{1+x\\cdot(\\lambda+1-p)/(\\lambda-(1-p))}. \\label{eqlimzero}\\ ] ]    next , we would like to know many of these visits to state 0 correspond to a deletion . recall the notion of a busy period and deletion epoch , defined in equations  ( [ eqbusydef ] ) and ( [ eqejdef ] ) , respectively . by lemma  [ lemqmi0 ] , @xmath64 corresponds to a deletion if any only if @xmath142=q[n-1]=0 $ ] . consider a deletion in slot @xmath384 .",
    "if @xmath385=0 $ ] , then @xmath386 also corresponds to a deletion , that is , @xmath387 . if instead @xmath385=1 $ ] , which happens with probability @xmath69 , the fact that @xmath388=0 $ ] implies that there exists at least one busy period , @xmath389 , between @xmath384 and @xmath390 , with @xmath391 and @xmath392 .",
    "at the end of this period , a new busy period starts with probability @xmath69 and so on . in summary ,",
    "a deletion epoch @xmath393 consists of the slot @xmath394 , plus @xmath395 busy periods , where the @xmath395 are i.i.d .",
    ", with denotes a geometric random variable with mean @xmath396 . ] @xmath397 and hence @xmath398 where @xmath399 are i.i.d .",
    "random variables , and @xmath400 corresponds to the length of the @xmath326th busy period in the @xmath203th epoch .    define @xmath401 = ( q[t],q[t+1 ] ) $ ] , @xmath402 . since @xmath83 is markov , @xmath401 $ ] is also a markov chain , taking values in @xmath403 . since",
    "a deletion occurs in slot @xmath19 if and only if @xmath404=q[t-1]=0 $ ] ( lemma  [ lemqmi0 ] ) , @xmath405 corresponds to excursion times between two adjacent visits of @xmath406 to the state @xmath407 , and hence are i.i.d . using the elementary renewal theorem",
    ", we have @xmath408 and by viewing each visit of @xmath406 to @xmath407 as a renewal event and using the fact that exactly one deletion occurs within a deletion epoch . denoting by @xmath409 the number of visits to the state 0 within @xmath393 ,",
    "we have that @xmath410 . treating @xmath409 as the reward associated with the renewal interval @xmath393 , we have , by the time - average of a renewal reward process ( cf .",
    "theorem 6 , chapter  3 , @xcite ) , that @xmath411=0 \\bigr ) = \\frac{\\mathbb{e } ( r_1 ) } { \\mathbb { e } ( |e_1| ) } = \\frac{\\mathbb{e } ( n_1 ) + 1}{\\mathbb{e } ( |e_1| ) } \\qquad\\mbox{a.s . } \\label{eqlimfrac2}\\ ] ] by treating each visit of @xmath83 to @xmath407 as a renewal event . from equations ( [ eqlimfrac1 ] )  and  ( [ eqlimfrac2 ] )",
    ", we have @xmath412=0 ) } = \\frac{1}{\\mathbb{e}(n_1 ) } = 1-x .",
    "\\label{eqlimfrac}\\ ] ] combining equations  ( [ eqimnlim ] ) , ( [ eqlimzero ] ) and ( [ eqlimfrac ] ) , and the fact that @xmath413 , we have @xmath414= 1-x,\\ ] ] which yields @xmath415    this completes the proof of proposition  [ propqrw ] .",
    "we summarize some of the key consequences of proposition  [ propqrw ] below , most of which are easy to derive using renewal theory and well - known properties of positive - recurrent random walks .",
    "[ proppnobperf ] suppose that @xmath332 , and denote by @xmath376 $ ] the steady - state distribution of @xmath83 .    for all @xmath298 , @xmath416=i \\bigr ) = \\biggl(1-\\frac{1-p}{\\lambda }",
    "\\biggr)\\cdot \\biggl(\\frac{1-p}{\\lambda } \\biggr)^i.\\ ] ]    almost surely , we have that @xmath417 = \\mathbb{e } \\bigl(q [ \\infty ] \\bigr ) = \\frac{1-p}{\\lambda- ( 1-p ) } . \\label{eqqavg}\\ ] ]    let @xmath418 .",
    "then the @xmath405 are i.i.d .",
    ", with @xmath419 and there exists @xmath420 such that for all @xmath421 @xmath422    almost surely , we have that @xmath423 as @xmath424 .",
    "claim @xmath268 follows from the well - known steady - state distribution of a random walk , or equivalently , the fact that @xmath425 $ ] has the same distribution as the steady - state number of jobs in an @xmath426 queue with traffic intensity @xmath427 . for claim @xmath428 ,",
    "since @xmath83 is an irreducible markov chain that is positive recurrent , it follows that its time - average coincides with @xmath429 ) $ ] almost surely .",
    "the fact that @xmath393 s are i.i.d .",
    "was shown in the discussion preceding equation  ( [ eqlimfrac1 ] ) in the proof of proposition  [ propqrw ] .",
    "the value of @xmath430 follows by combining equations  ( [ eqimnlim ] ) and ( [ eqlimfrac1 ] ) .",
    "let @xmath400 be the length of the @xmath326th busy period [ defined in equation  ( [ eqbusydef ] ) ] in @xmath393 . by definition , @xmath431 is distributed as the time till the random walk @xmath83 reaches state @xmath368 , starting from state @xmath268 .",
    "we have @xmath432 where the @xmath433 s are i.i.d . , with @xmath434 and @xmath435 , which , by the chernoff bound , implies an exponential tail bound for@xmath436 , and in particular , @xmath437 by equation  ( [ eqeidecomp ] ) , the moment generating function for @xmath438 is given by @xmath439\\\\[-8pt ] & \\stackrel{\\mathrm{(a ) } } { = } & \\mathbb{e } \\bigl(e^\\varepsilon\\bigr)\\cdot\\mathbb{e } \\bigl(\\exp\\bigl({n_1}\\cdot g_{b_{1,1}}(\\varepsilon ) \\bigr ) \\bigr ) \\nonumber \\\\ & = & \\mathbb{e } \\bigl(e^\\varepsilon\\bigr)\\cdot g_{n_1 } \\bigl(\\ln \\bigl(g_{b_{1,1}}(\\varepsilon ) \\bigr ) \\bigr),\\nonumber\\end{aligned}\\ ] ] where ( a ) follows from the fact that @xmath440 are mutually independent , and @xmath441 .",
    "since @xmath442,@xmath443 , and by equation  ( [ eqgblim ] ) , we have that @xmath444 , which implies equation  ( [ eqeiexp ] ) .",
    "finally , equation  ( [ eqmilim ] ) follows from the third claim and the elementary renewal theorem .",
    "this section is devoted to proving the optimality of @xmath38 as @xmath6 , stated in the second claim of theorem  [ teooffline ] , which we isolate here in the form of the following proposition .",
    "[ propnobopt ] fix @xmath17 .",
    "we have that @xmath445    the proof is given at the end of this section , and we do so by showing the following :    over a finite horizon @xmath12 and given a fixed number of deletions to be made , a  greedy deletion rule is optimal in minimizing the post - deletion area under @xmath83 over @xmath318 .",
    "any point of deletion chosen by @xmath38 will also be chosen by the greedy policy , as @xmath319 .",
    "the fraction of points chosen by the greedy policy but not by @xmath38 diminishes as @xmath6 , and hence the delay produced by @xmath38 is the best possible , as @xmath6 .",
    "fix @xmath446 .",
    "let @xmath447 be the partial sum @xmath448 $ ] .",
    "for any sample path @xmath83 , denote by @xmath449 the marginal decrease of area under @xmath83 over the horizon @xmath450 by applying a deletion at slot @xmath64 , that is , @xmath451 and , analogously , @xmath452 where @xmath453 is a deletion sequence .",
    "we next define the notion of a greedy deletion rule , which constructs a deletion sequence by recursively adding the slot that leads to the maximum marginal decrease in @xmath454 .",
    "[ defgdrule ] fix an initial sample path @xmath90 and @xmath455 .",
    "the _ greedy deletion rule _ is a mapping , @xmath456 , which outputs a finite deletion sequence @xmath457 , given by @xmath458 where @xmath459 is the set of all locations in @xmath83 in the first @xmath12  slots that can be deleted , and @xmath460 .",
    "note that we will allow @xmath461 , if there is no more entry to delete [ i.e. , @xmath462 .",
    "we now state a key lemma that will be used in proving theorem  [ teooffline ] .",
    "it shows that over a finite horizon and for a finite number of deletions , the greedy deletion rule yields the maximum reduction in the area under the sample path .",
    "[ lemgddom ] fix an initial sample path @xmath90 , horizon @xmath463 and number of deletions @xmath464 .",
    "let @xmath453 be any deletion sequence with @xmath465 .",
    "then @xmath466 where @xmath467 is the deletion sequence generated by the greedy policy .    by lemma  [ lemlocindp ]",
    ", it suffices to show that , for any sample path @xmath336\\in\\mathbb{z}_{+}\\dvtx n\\in\\mathbb { n } \\}$ ] with @xmath468-q[n]|=1 $ ] if @xmath142>0 $ ] and @xmath468-q[n]|\\in \\{0,1 \\}$ ] if @xmath142=0 $ ] , we have @xmath469\\\\[-8pt ] & & \\qquad \\geq\\delta_p \\bigl(q , n , m_{1}^{g } \\bigr)+\\mathop{\\min_{{\\vert}\\widetilde{m}{\\vert}=k-1,}}_{\\widetilde{m}\\subset\\phi(d ( q , m_{1}^{g } ) , n ) } s\\bigl(d \\bigl(q_{m^g}^{1},\\widetilde{m } \\bigr),n \\bigr).\\nonumber\\end{aligned}\\ ] ] by induction , this would imply that we should use the greedy rule at every step of deletion up to @xmath230 .",
    "the following lemma states a simple monotonicity property .",
    "the proof is elementary , and is omitted .",
    "[ lemmonotonicity - in - deletions ] let @xmath83 and @xmath470 be two sample paths such that @xmath471\\leq q ' [ n ] \\qquad\\forall n\\in\\ { 1,\\ldots , n \\}.\\ ] ] then , for any @xmath472 , @xmath473 and , for any finite deletion sequence @xmath474 , @xmath475    recall the definition of a busy period in equation  ( [ eqbusydef ] ) . let @xmath476 be the total number of busy periods in @xmath336\\dvtx 1\\leq n\\leq n \\}$ ] , with the additional convention @xmath477\\stackrel { \\triangle}{=}0 $ ] so that the last busy period always ends on @xmath12 .",
    "let @xmath478 be the @xmath326th busy period .",
    "it can be verified that a deletion in location @xmath64 leads to a decrease in the value of @xmath454 that is no more than the width of the busy period to which @xmath64 belongs ; cf . figure  [ figwater2 ] .",
    "therefore , by definition , a greedy policy always seeks to delete in each step the first arriving job during a longest busy period in the current sample path , and hence @xmath479    let @xmath480 we consider the following cases , depending on whether @xmath453 chooses to delete any job in the busy periods in @xmath481 .",
    "if @xmath482 for some @xmath483 , by equation  ( [ eqbubble1 ] ) , we can set @xmath484 to @xmath485 .",
    "since @xmath486 and the order of deletions does not impact the final resulting delay ( lemma  [ lemlocindp ] ) , we have that equation  ( [ eqgrrec ] ) holds , and we are done .",
    "otherwise , choose @xmath487 for some @xmath483 , and we have @xmath488 .",
    "let @xmath489 since @xmath490>0 $ ] , @xmath491 , we have @xmath492=q [ n ] -1\\leq q'[n]$ ] , @xmath491 and @xmath493=q[n]=\\widehat{q}[n]$ ] , @xmath494 , which implies that @xmath495\\leq q ' [ n ] \\qquad\\forall n\\in\\{1,\\ldots , n \\}.\\label{eqcase1dom}\\ ] ] equation  ( [ eqgrrec ] ) holds by combining equation  ( [ eqcase1dom ] ) and equation  ( [ eqmondel1 ] ) in lemma  [ lemmonotonicity - in - deletions ] , with @xmath496 .",
    "let @xmath497 be any element in @xmath453 and @xmath498 .",
    "clearly , @xmath490\\geq q ' [ n ] $ ] for all @xmath499 , and by equation  ( [ eqmondel2 ] ) in lemma [ lemmonotonicity - in - deletions ] , we have that and @xmath242 , @xmath500 . ]",
    "@xmath501 since * @xmath502 * , we have that @xmath503 let @xmath504 , and we have that @xmath505 where ( a ) and ( b ) follow from equations  ( [ eqcase2-diff - dom ] ) and ( [ eqcase2-step - dom ] ) , respectively , which shows that equation  ( [ eqgrrec ] ) holds ( and in this case the inequality there is strict ) .",
    "cases 1  and  2 together complete the proof of lemma  [ lemgddom ] .",
    "we are now ready to prove proposition  [ propnobopt ] .",
    "proof of proposition  [ propnobopt ] lemma  [ lemgddom ] shows that , for any fixed number of deletions over a finite horizon @xmath12 , the greedy deletion policy ( definition  [ defgdrule ] ) yields the smallest area under the resulting sample path , @xmath83 , over @xmath506 .",
    "the main idea of proof is to show that the area under @xmath83 after applying @xmath38 is asymptotically the same as that of the greedy policy , as @xmath319 and @xmath6 ( in this particular order of limits ) . in some sense",
    ", this means that the jobs in @xmath330 account for almost all of the delays in the system , as @xmath6 .",
    "the following technical lemma is useful .",
    "[ lemtopk ] for a finite set @xmath507 and @xmath508 , define @xmath509 let @xmath510 be i.i.d .",
    "random variables taking values in @xmath40 , where . then for any sequence of random variables @xmath511 , with a.s . as @xmath512 for some @xmath513 , we have @xmath514 where @xmath515",
    ".    see appendix  [ applemtopk ] .",
    "fix an initial sample path @xmath74 .",
    "we will denote by @xmath516 the deletion sequence generated by @xmath38 on @xmath74 .",
    "define @xmath517 where @xmath393 is the @xmath203th deletion epoch of @xmath330 , defined in equation  ( [ eqejdef ] ) . since @xmath211\\geq q^0[m_i]$ ] for all @xmath518 , it is easy to check that @xmath519 for all @xmath333 .",
    "the function @xmath520 was defined so that the first @xmath521 deletions made by a greedy rule over the horizon @xmath522 are exactly @xmath523 .",
    "more formally , we have the following lemma .    [ lemgdoverlap ]",
    "fix @xmath63 , and let @xmath524 .",
    "then @xmath525 , for all @xmath526 .",
    "fix @xmath464 , and an arbitrary feasible deletion sequence , @xmath109 , generated by a policy in @xmath527 .",
    "we can write @xmath528 where @xmath529 we have the following characterization of @xmath530 .    [ lemhk ] @xmath531 , as @xmath532 , a.s .    see appendix  [ applemhk ] .",
    "let @xmath533 where the greedy deletion map @xmath534 was defined in definition  [ defgdrule ] . by lemma  [ lemgdoverlap ] and the definition of @xmath535",
    ", we have that @xmath536 therefore , we can write @xmath537 where @xmath538 . since @xmath539 by definition , by equation  ( [ eqiineq ] ) , @xmath540    we have @xmath541 where ( a ) is based on the dominance of the greedy policy over any finite horizon ( lemma  [ lemgddom ] ) , and ( b ) follows from equation  ( [ eqmgoverline ] ) .    finally , we claim that there exists @xmath542 , with @xmath543 as @xmath544 , such that @xmath545 equations  ( [ eqsdiff ] ) and ( [ eqdeltadim ] ) combined imply that @xmath546 which shows that @xmath547 since @xmath548 as @xmath6 , this proves proposition [ propnobopt ] .    to show equation  ( [ eqdeltadim ] ) , denote by @xmath83 the sample path after applying @xmath38 , @xmath549 and by @xmath550 the area under @xmath83 within @xmath393 , @xmath551.\\ ] ] an example of @xmath550 is illustrated as the area of the shaded region in figure  [ figwater2 ] . by proposition  [ propqrw ]",
    ", @xmath83 is a markov chain , and so is the process @xmath552= ( q[n ] , q[n+1 ] )",
    "$ ] . by lemma  [ lemqmi0 ]",
    ", @xmath393 corresponds to the indices between two adjacent returns of the chain @xmath406 to state @xmath407 .",
    "since the @xmath203th return of a markov chain to a particular state is a stopping time , it can be shown , using the strong markov property of @xmath406 , that the segments of @xmath83 , @xmath336\\dvtx n\\in e_i \\}$ ] , are mutually independent and identically distributed among different values of @xmath203 .",
    "therefore , the @xmath550 s are i.i.d .",
    "furthermore , @xmath553 where ( a ) follows from the fact that @xmath468-q[n]|\\leq1 $ ] for all @xmath64 , and hence @xmath554 for any sample path of @xmath74 , and ( b ) from the exponential tail bound on @xmath555 , given in equation  ( [ eqeiexp ] ) .",
    "since the value of @xmath83 on the two ends of @xmath393 , @xmath331 and @xmath556 , are both zero , each additional deletion within @xmath393 can not produce a marginal decrease of area under @xmath83 of more than @xmath550 ; cf .",
    "figure  [ figwater2 ] .",
    "therefore , the value of  @xmath557 can be no greater than the sum of the @xmath558 largest @xmath550 s over the horizon @xmath559 .",
    "we have @xmath560\\\\[-8pt ] & & \\qquad \\stackrel{\\mathrm{(a ) } } { = }   \\limsup_{k \\to\\infty } f \\bigl ( \\{v_i\\dvtx   1\\leq i \\leq k \\},h(k ) \\bigr ) \\cdot\\frac{\\lambda+1-p}{\\lambda -(1-q ) } \\nonumber \\\\ & & \\qquad \\stackrel{\\mathrm{(b ) } } { = }   \\mathbb{e } \\biggl(v_1\\cdot\\mathbb{i } \\biggl(x_1\\geq{\\overline}{f}{}^ { -1}_{v_1 } \\biggl ( \\frac{1-\\lambda}{\\lambda -(1-p ) } \\biggr ) \\biggr ) \\biggr ) \\cdot\\frac{\\lambda+1-p}{\\lambda-(1-q)},\\nonumber\\end{aligned}\\ ] ] where ( a ) follows from equation  ( [ eqmilim ] ) , and ( b ) from lemmas  [ lemtopk ] and  [ lemhk ] . since @xmath561 , and @xmath562 as @xmath563",
    ", it follows that @xmath564 as @xmath6 .",
    "equation  ( [ eqdeltadim ] ) is proved by setting @xmath565 this completes the proof of proposition  [ propnobopt ] .",
    "the proof of proposition  [ propnobopt ] relies on a sample - path - wise coupling to the performance of a greedy deletion rule .",
    "it is then only natural to ask : since the time horizon is indeed finite in all practical applications , why do not we simply use the greedy rule as the preferred offline policy , as opposed to @xmath38 ?    there are at least two reasons for focusing on @xmath38 instead of the greedy rule .",
    "first , the structure of the greedy rule is highly global , in the sense that each deletion decision uses information of the entire sample path over the horizon . as a result ,",
    "the greedy rule tells us little on how to design a good policy with a _ fixed _ lookahead window ( e.g. , theorem  [ teolookahead ] ) .",
    "in contrast , the performance analysis of @xmath38 in section  [ secperformoffline ] reveals a highly _ regenerative _ structure : the deletions made by @xmath38 essentially depend only on the dynamics of @xmath74 in the same deletion epoch ( the @xmath393 s ) , and what happens beyond the current epoch becomes irrelevant .",
    "this is the key intuition that led to our construction of the finite - lookahead policy in theorem  [ teolookahead ] .",
    "a second ( and perhaps minor ) reason is that of computational complexity . by a small sacrifice in performance",
    ", @xmath38 can be efficiently implemented using a linear - time algorithm ( section  [ seclinearalgo ] ) , while it is easy to see that a naive implementation of the greedy rule would require super - linear complexity with respect to the length of the horizon .",
    "the fact that @xmath38 is feasible follows from equation  ( [ eqimnlim ] ) in lemma  [ lemnobbasic ] , that is , @xmath566    let @xmath567\\dvtx n\\in\\mathbb{z}_{+ } \\}$ ] be the resulting sample path after applying @xmath38 to the initial sample path @xmath81\\dvtx n\\in\\mathbb{z}_{+ } \\}$ ] , and let @xmath322=\\widetilde{q } \\bigl[n+m^\\psi_1 \\bigr]\\qquad\\forall n \\in\\mathbb{n},\\ ] ] where @xmath568 is the index of the first deletion made by @xmath38 . since @xmath59 , the random walk @xmath74 is transient , and hence @xmath569 almost surely .",
    "we have that , almost surely , @xmath570 \\nonumber \\\\ & = & \\lim_{n\\to\\infty}\\frac{1}{n}\\sum _ { i=1}^{m^\\psi_1 } \\widetilde{q}[i ] + \\lim _ { n\\to\\infty}\\frac{1}{n}\\sum_{i=1}^n q[i ] \\\\",
    "& = & \\frac{1-p}{\\lambda-(1-p ) } , \\nonumber\\end{aligned}\\ ] ] where the last equality follows from equation  ( [ eqqavg ] ) in proposition  [ proppnobperf ] , and the fact that @xmath571 almost surely . letting @xmath6 in equation  ( [ eqcplam ] )",
    "yields the finite limit of delay under heavy traffic , @xmath572    finally , the delay optimality of @xmath38 in heavy traffic was proved in proposition  [ propnobopt ] , that is , that @xmath573 this completes the proof of theorem  [ teooffline ] .",
    "[ secfinitelookahead ]      as pointed out in the discussion preceding theorem  [ teolookahead ] , for any initial sample path and @xmath185 , an arrival that is deleted under the @xmath144 policy will also be deleted under @xmath574 .",
    "therefore , the delay guarantee for @xmath38 ( theorem  [ teooffline ] ) carries over to @xmath191 , and for the rest of the proof , we will be focusing on showing that @xmath191 is feasible under an appropriate scaling of @xmath32 .",
    "we begin by stating an exponential tail bound on the distribution of the discrete - time predictive window , @xmath575 , defined in equation  ( [ eqwdiscrete ] ) , @xmath576 it is easy to see that @xmath577 are i.i.d . , with @xmath578 distributed as a poisson random variable with mean @xmath579 . since @xmath580 where the @xmath581 are i.i.d .",
    "poisson random variables with mean @xmath582 , applying the chernoff bound , we have that , there exist @xmath583 such that @xmath584 for all @xmath585 .",
    "we now analyze the deletion rate resulted by the @xmath586 policy . for the pure purpose of analysis ( as opposed to practical efficiency ) , we will consider a new deletion policy , denoted by @xmath587 , which can be viewed as a relaxation of @xmath588 .",
    "fix @xmath18 .",
    "the deletion policy @xmath589 is defined such that for each deletion epoch @xmath393 , @xmath333 :    if @xmath590 , then only the first arrival of this epoch , namely , the arrival in slot @xmath331 , is deleted ;    otherwise , all arrivals within this epoch are deleted .",
    "it is easy to verify that @xmath591 can be implemented with @xmath15 units of look - ahead , and the set of deletions made by @xmath587 is a strict superset of @xmath191 almost surely .",
    "hence , the feasibility of @xmath592 will imply that of @xmath191 .",
    "denote by @xmath593 the number of deletions made by @xmath592 in the epoch @xmath393 . by the construction of the policy , the @xmath593 are i.i.d . , and depend only on the length of @xmath393 and the number of arrivals within .",
    "we have is always an integer .",
    "this does not change the scaling behavior of @xmath32 . ]",
    "@xmath594 \\nonumber \\\\ & \\leq & 1 + \\mathbb{e } \\biggl[|e_i|\\cdot\\mathbb{i } \\biggl(|e_i| \\geq\\frac{\\lambda+1-p}{2}\\cdot w(\\lambda ) \\biggr ) \\biggr ] \\nonumber \\\\ & & { } + \\mathbb{e } \\bigl(|e_i| \\bigr)\\cdot\\mathbb{p } \\biggl ( w \\bigl ( \\lambda , m^\\psi_i \\bigr ) \\leq\\frac{\\lambda+1-p}{2}\\cdot w ( \\lambda ) \\biggr ) \\nonumber\\\\[-8pt]\\\\[-8pt ] & \\leq & 1 + \\biggl(\\sum_{k = ( ( \\lambda+1-p)/2)\\cdot w(\\lambda ) } ^{\\infty } k \\cdot a \\cdot\\exp(-b\\cdot k ) \\biggr)\\nonumber \\\\ & & { } + \\frac{\\lambda}{\\lambda-(1-p)}\\cdot c\\cdot\\exp\\bigl(-d\\cdot w ( \\lambda)\\bigr)\\nonumber \\\\ & \\stackrel{\\mathrm{(a ) } } { \\leq } &   1 + h \\cdot w(\\lambda ) \\cdot\\exp\\bigl(-l\\cdot w(\\lambda)\\bigr)\\nonumber\\end{aligned}\\ ] ] for some @xmath595 , where ( a ) follows from the fact that @xmath596 as @xmath377 .    since the @xmath593 are i.i.d .",
    ", using basic renewal theory , it is not difficult to show that the average rate of deletion in discrete time under the policy @xmath592 is equal to @xmath597 . in order for the policy to be feasible",
    ", one must have that @xmath598 by equations  ( [ eqed1 ] ) and ( [ eqdelrate1 ] ) , we want to ensure that @xmath599 which yields , after taking the logarithm on both sides , @xmath600\\cdot h\\cdot w(\\lambda)}{1-p } \\biggr).\\ ] ] it is not difficult to verify that for all @xmath17 there exists a constant @xmath601 such that the above inequality holds for all @xmath602 , by letting @xmath603 .",
    "this proves the feasibility of @xmath592 , which implies that @xmath191 is also feasible .",
    "this completes the proof of theorem  [ teolookahead ] .",
    "[ secconclusions ]    the main objective of this paper is to study the impact of future information on the performance of a class of admissions control problems , with a constraint on the time - average rate of redirection . our model is motivated as a study of a dynamic resource allocation problem between slow ( congestion - prone ) and fast ( congestion - free ) processing resources .",
    "it could also serve as a simple canonical model for analyzing delays in large server farms or cloud clusters with resource pooling @xcite ; cf .",
    "appendix  [ secresourcepooling ] .",
    "our main results show that the availability of future information can dramatically reduce the delay experienced by admitted customer : the delay converges to a finite constant even as the traffic load approaches the system capacity ( `` heavy - traffic delay collapse '' ) , if the decision maker is allowed for a sufficiently large lookahead window ( theorem  [ teolookahead ] ) .",
    "there are several interesting directions for future exploration . on the theoretical end",
    ", a main open question is whether a matching lower - bound on the amount of future information required to achieve the heavy - traffic delay collapse can be proved ( conjecture  [ conjinfolowerbound ] ) , which , together with the upper bound given in theorem  [ teolookahead ] , would imply a duality between delay and the length of lookahead into the future .",
    "second , we believe that our results can be generalized to the cases where the arrival and service processes are non - poisson .",
    "we note that the @xmath38 policy is indeed feasible for a wide range of non - poisson arrival and service processes ( e.g. , renewal processes ) , as long as they satisfy a form of strong law of large number , with appropriate time - average rates ( lemma  [ lemnobbasic ] ) .",
    "it seems more challenging to generalize results on the optimality of @xmath144 and the performance guarantees .",
    "however , it may be possible to establish a generalization of the delay optimality result using limiting theorems ( e.g. , diffusion approximations ) .",
    "for instance , with sufficiently well - behaved arrival and service processes , we expect that one can establish a result similar to proposition  [ propqrw ] by characterizing the resulting queue length process from @xmath38 as a reflected brownian motion in @xmath604 , in the limit of @xmath6 and @xmath605 , with appropriate scaling .",
    "another interesting variation of our problem is the setting where each job comes with a prescribed _ size _ , or _ workload _ , and the decision maker is able to observe both the arrival times and workloads of jobs up to a finite lookahead window .",
    "it is conceivable that many analogous results can be established for this setting , by studying the associated workload ( as opposed to queue length ) process , while the analysis may be less clean due to the lack of a simple random - walk - based description of the system dynamics .",
    "moreover , the _ server _ could potentially exploit additional information of the jobs workloads in making scheduling decisions , and it is unclear what the performance and fairness implications are for the design of admissions control policies .",
    "there are other issues that need to be addressed if our offline policies ( or policies with a finite lookahead ) are to be applied in practice",
    ". a most important question can be the impact of _ observational noise _ to performance , since in reality the future seen in the lookahead window can not be expected to match the actual realization exactly .",
    "we conjecture , based on the analysis of @xmath144 , that the performance of both @xmath38 , and its finite - lookahead version , is robust to small noises or perturbations ( e.g. , if the actual sample path is at most @xmath606 away from the predicted one ) , while it remains to thoroughly verify and quantify the extend of the impact , either empirically or through theory .",
    "also , it is unclear what the best practices should be when the lookahead window is very small relative to the traffic intensity @xmath16 ( @xmath607 ) , and this regime is not covered by the results in this paper ( as illustrated in figure  [ figcollapse ] ) .",
    "since @xmath10 , with probability one , there exists @xmath205 such that the continuous - time queue length process without deletion satisfies @xmath608 for all @xmath609",
    ". therefore , without any deletion , all service tokens are matched with some job after time @xmath206 . by the stack interpretation , @xmath38 only deletes jobs that would not have been served , and hence does not change the original matching of service tokens to jobs .",
    "this proves the first claim .    by the first claim , since all subsequent service tokens are matched with a job after some time @xmath206",
    ", there exists some @xmath610 , such that @xmath611 = \\widetilde{q}[n ] + \\bigl(a[n]-a[n ] \\bigr)- \\bigl(s[n]-s[n ] \\bigr ) -",
    "i \\bigl(m^\\psi , n \\bigr ) \\label{eqqevolv}\\ ] ] for all @xmath612 , where @xmath613 $ ] and @xmath614 $ ] are the cumulative numbers of arrival and service tokens by slot @xmath64 , respectively .",
    "the second claim follows by multiplying both sides of equation  ( [ eqqevolv ] ) by @xmath615 , and using the fact that @xmath616=\\frac{\\lambda}{\\lambda+1-p}$ ] and @xmath617=\\frac{1-p}{\\lambda+1-p}$ ] a.s .",
    ", @xmath618\\geq0 $ ] for all @xmath64 and @xmath619<\\infty$ ] a.s .",
    "[ applemqmi0 ]    ( 1 )  recall the point - wise deletion map , @xmath620 , defined in definition  [ defdelmap ] . for any initial sample path @xmath74 , let @xmath621 for some @xmath622 .",
    "it is easy to see that , for all @xmath623 , @xmath624 = q^0[n]-1 $ ] , if and only if @xmath625\\geq1 $ ] for all @xmath626 . repeating this argument @xmath627 times",
    ", we have that @xmath322 = \\widetilde{q}[n+m_1 ] = q^0[n+m_1 ] - i ( m , n+m_1 ) , \\label{eqqnevol1}\\ ] ] if and only if for all @xmath628 , @xmath629 \\geq k\\qquad\\mbox{for all $ s\\in\\{m_k+1,\\ldots , n+m_1 \\}$}. \\label{eqqmi0}\\ ] ] note that equation  ( [ eqqmi0 ] ) is implied by ( and in fact , equivalent to ) the definition of the @xmath630 s ( definition  [ defnob ] ) , namely , that for all @xmath508 , @xmath625\\geq k$ ] for all @xmath631 .",
    "this proves the first claim .",
    "( 2 )  suppose @xmath142=q[n-1]=0 $ ] .",
    "since @xmath632 \\neq q^0[t-1 ] { |}q^0[t-1]>0 ) = 1 $ ] for all @xmath633 [ cf .",
    "equation  ( [ eqq0trans1 ] ) ] at least one deletion occurs on the slots @xmath634 .",
    "if the deletion occurs on @xmath635 , we are done .",
    "suppose a deletion occurs on @xmath636 .",
    "then @xmath637\\geq q^0[n-1+m_1]$ ] , and hence @xmath638= q^0[n-1+m_1]+1,\\ ] ] which implies that a deletion must also occur on @xmath635 , for otherwise @xmath142=q[n-1]+1 = 1 \\neq0 $ ] .",
    "this shows that @xmath334 for some @xmath518 .    now , suppose that @xmath334 for some @xmath333 .",
    "let @xmath639=k\\mbox { and } q^0[t]\\geq k,\\ \\forall t\\geq n \\bigr\\}.\\ ] ] since the random walk @xmath74 is transient , and the magnitude of its step size is at most  @xmath268 , it follows that @xmath640 for all @xmath641 a.s . , and that @xmath642 , @xmath643 .",
    "we have @xmath644 & \\stackrel{\\mathrm{(a ) } } { = } & q^0 [ n+m_1]-i ( m , n+m_1 ) \\nonumber \\\\ & = & q^0[m_i ] - i ( m , m_i ) \\nonumber\\\\[-8pt]\\\\[-8pt ] & \\stackrel{\\mathrm{(b ) } } { = } & q^0[n_i ] - i\\nonumber \\\\ & = & 0,\\nonumber\\end{aligned}\\ ] ] where ( a ) follows from equation  ( [ eqqnevol1 ] ) and ( b ) from the fact that @xmath645 . to show that @xmath646=0 $ ] , note that since @xmath334 , an arrival must have occurred in @xmath74 on slot @xmath384 , and hence @xmath647=q^0[n+m_1]-1 $ ] .",
    "therefore , by the definition of @xmath384 , @xmath648 -q^0[n-1+m_1]= \\bigl(q^0[t]-q^0[n+m_1 ] \\bigr)+1 \\geq0\\qquad\\forall t\\geq n+m_1,\\ ] ] which implies that @xmath649 , and hence @xmath646=0 $ ] , in light of equation  ( [ eqqnevol2 ] ) .",
    "this proves the claim .",
    "( 3 )  for all @xmath76 , we have @xmath650 & = & q [ m_{i ( m , n+m_1 ) } -m_1 ] + \\bigl(q[n]-q [ m_{i ( m , n+m_1 ) } -m_1 ] \\bigr ) \\nonumber \\\\ & \\stackrel{\\mathrm{(a ) } } { = } & q[n]-q [ m_{i ( m , n+m_1 ) } -m_1 ] \\nonumber\\\\[-8pt]\\\\[-8pt ] & \\stackrel{\\mathrm{(b ) } } { = } & q^0[n+m_1]-q^0 [ m_{i ( m , n+m_1 ) } ] \\nonumber \\\\ & \\stackrel{\\mathrm{(c ) } } { = } & 0,\\nonumber\\end{aligned}\\ ] ] where ( a ) follows from the second claim [ cf .",
    "equation  ( [ eqqnevol2 ] ) ] , ( b ) from the fact that there is no deletion on any slot in @xmath651 and ( c ) from the fact that @xmath652 and equation  ( [ eqmiinc ] ) .      since the random walk @xmath87 lives in @xmath40 and can take jumps of size at most @xmath268 , it suffices to verify that @xmath367=x_1 + 1 | x[n]=x_1 , \\min _ { r \\geq n+1 } x[r ] = 0 \\bigr ) = 1-q\\vadjust{\\goodbreak}\\ ] ] for all @xmath653 .",
    "we have @xmath654=x_1 + 1 | x[n]=x_1 , \\min _ { r \\geq n+1 } x[r ] = 0 \\bigr ) \\nonumber \\\\ & & \\qquad = \\mathbb{p } \\bigl(x[n+1]=x_1 + 1 , \\min_{r \\geq n+1 } x[r ] = 0    \\\\ & & \\quad\\qquad { } \\bigm/ \\mathbb{p } \\bigl(\\min_{r \\geq n+1 } x[r ] = 0 | x[n]=x_1 \\bigr ) \\nonumber \\\\ & & \\qquad \\stackrel{\\mathrm{(a ) } } { = } \\bigl(\\mathbb{p } \\bigl(x[n+1]=x_1 + 1 | x[n]=x_1 \\bigr ) \\\\ & & \\hspace*{36pt}{}\\times \\mathbb{p } \\bigl(\\min_{r \\geq n+1 } x[r ] = 0    \\\\ & & \\quad\\qquad{}\\bigm / \\mathbb{p } \\bigl(\\min_{r \\geq n+1}x[r ] = 0 | x[n]=x_1 \\bigr)\\nonumber \\\\ & & \\qquad \\stackrel{\\mathrm{(b ) } } { = } q\\cdot\\frac{h(x_1 + 1)}{h(x_1)},\\nonumber\\end{aligned}\\ ] ] where @xmath655 = 0 | x[1]=x \\bigr)\\ ] ] and steps ( a ) and ( b ) follow from the markov property and stationarity of @xmath87 , respectively .",
    "the values of @xmath656 satisfy the set of harmonic equations @xmath657 with the boundary condition @xmath658 solving equations  ( [ eqharm1 ] ) and ( [ eqharm2 ] ) , we obtain the unique solution @xmath659 for all @xmath660 . by equation  ( [ eqxcond1 ] ) , this implies that @xmath367=x_1 + 1 | x[n]=x_1 , \\min _ { r \\geq n+1 } x[r ] = 0 \\bigr ) = q\\cdot\\frac{1-q}{q}=1-q,\\ ] ] which proves the claim .",
    "[ applemtopk ] by the definition of @xmath661 and the strong law of large numbers ( slln ) , we have @xmath662 denote by @xmath663 set of top @xmath223 elements in @xmath664 . by equation  ( [ eqslln1 ] ) and",
    "the fact that @xmath665 a.s .",
    ", there exists @xmath666 such that @xmath667 which implies that @xmath668 where the last equality follows from the slln .",
    "this proves our claim .",
    "we begin by stating the following fact :    [ lemmaxexpo ] let @xmath669 be i.i.d .",
    "random variables taking values in @xmath604 , such that for some @xmath420 , @xmath670 for all @xmath671 .",
    "then @xmath672 as @xmath377 .",
    "@xmath673\\\\[-8pt ] & = & \\lim_{n\\to\\infty } \\biggl(1-\\frac{a}{n^2 } \\biggr)^n \\nonumber \\\\ & = & 1.\\nonumber\\end{aligned}\\ ] ]    in other words , @xmath674 a.s . as @xmath377 , which proves the claim .    since the @xmath405 s are i.i.d .",
    "with @xmath675 ( proposition  [ proppnobperf ] ) , we have that , almost surely , @xmath676 by the strong law of large numbers . by lemma  [ lemmaxexpo ] and equations  ( [ eqeiexp ] ) ,",
    "we have @xmath677 as @xmath678 . by equation  ( [ eqesmallk ] ) and the fact that @xmath679 , we have @xmath680\\\\[-8pt ] & = & \\max_{1\\leq i \\leq k}|e_i| \\nonumber \\\\ & = & o ( k ) \\qquad\\mbox{a.s.}\\nonumber\\end{aligned}\\ ] ] as @xmath678 , where ( a ) follows from the fact that at most one deletion can occur in a single slot , and hence @xmath681 for all @xmath682 . since @xmath109 is feasible , @xmath683 as @xmath377",
    ". we have @xmath684 as @xmath685 , where ( a ) follows from equations  ( [ eqmnbkasymp1 ] ) and ( [ eqtilmratio ] ) , ( b ) from equations  ( [ eqmnbkasymp1 ] ) and ( [ eqsmallok1 ] ) , which completes the proof .",
    "we discuss in this section some of the implications of our results in the context of a multi - server model for resource pooling @xcite , illustrated in figure  [ figpooling ] , which has partially motivated our initial inquiry .",
    "we briefly review the model in @xcite below , and the reader is referred to the original paper for a more rigorous description . fix a coefficient @xmath686 $ ] .",
    "the system consists of @xmath12 stations , each of which receives an arrival stream of jobs at rate @xmath9 and has one queue to store the unprocessed jobs .",
    "the system has a total amount of processing capacity of @xmath12 jobs per unit time and is divided between two types of servers .",
    "each queue is equipped with a _ local server _ of rate @xmath0 , which is capable of serving only the jobs directed to the respective station .",
    "all stations share a _",
    "central server _ of rate @xmath13 , which always fetches a job from the most loaded station , following a longest - queue - first ( lqf ) scheduling policy . in other words , a fraction @xmath2 of the total processing resources is being _ pooled _ in a centralized fashion , while the remainder is distributed across individual stations .",
    "all arrival and service token generation processes are assumed to be poisson and independent from one another ( similarly to section  [ secmodel ] ) .",
    "a main result of @xcite is that even a small amount of resource pooling ( small but positive @xmath2 ) can have significant benefits over a fully distributed system ( @xmath687 ) .",
    "in particular , for any @xmath688 , and in the limit as the system size @xmath689 , the average delay across the whole system scales as @xmath690 , as @xmath6 ; note that this is the same scaling as in theorem  [ teoonline ] .",
    "this is an exponential improvement over the scaling of @xmath691 when no resource pooling is implemented ; that is , @xmath687 .",
    "we next explain how our problem is connected to the resource pooling model described above , and how the current paper suggests that the results in @xcite can be extended in several directions .",
    "consider a similar @xmath12-station system as in @xcite , with the only difference being that instead of the central server fetching jobs from the local stations , the central server simply fetches jobs from a `` central queue , '' which stores jobs redirected from the local stations ( see figure  [ figpoolingcqueue ] ) .",
    "denote by @xmath692 , @xmath693 , the counting process where @xmath694 is the cumulative number of jobs redirected to the central queue from station @xmath203 by time @xmath19 .",
    "assume that @xmath695 almost surely for all @xmath696 , for some @xmath697 . , the rate of @xmath694 can not exceed @xmath2 , assuming it is the same across all @xmath203 . ]    from the perspective of the central queue , it receives an arrival stream @xmath698 , created by merging @xmath12 redirection streams , @xmath699 .",
    "the process @xmath698 is of rate @xmath700 , and it is served by a service token generation process of rate @xmath13 .",
    "the traffic intensity of the of central queue ( arrival rate divided by service rate ) is therefore @xmath701 .",
    "denote by @xmath702 the length of the central queue in steady - state .",
    "suppose that it can be shown that [ and that @xmath16 is sufficiently close to @xmath268 so that@xmath703 .",
    "then @xmath694 is a poisson process , and by the merging property of poisson processes , so is @xmath704 .",
    "this implies that the central queue is essentially an @xmath426 queue with traffic intensity @xmath705 , and we have that @xmath706 for all @xmath12 . ]",
    "@xmath707 a key consequence of equation  ( [ eqcentralfinite ] ) is that , for large values of @xmath12 , @xmath708 becomes negligible in the calculation of the system s average queue length : the average queue length across the whole system coincides with the average queue length among the _ local _ stations , as @xmath319 . in particular , this implies that , in the limit of @xmath319 , the task of scheduling for the resource pooling system could alternatively be implemented by running a separate admissions control mechanism , with the rate of redirection equal to @xmath709 , where all redirected jobs are sent to the central queue , granted that the streams of redirected jobs ( @xmath694 ) are sufficiently well behaved so that equation  ( [ eqcentralfinite ] ) holds .",
    "this is essentially the justification for the equivalence between the resource pooling and admissions control problems , discussed at the beginning of this paper ( section  [ secintroadminresourcepool ] ) .    with this connection in mind , several implications",
    "follow readily from the results in the current paper , two of which are given below :    the original longest - queue - first scheduling policy employed by the central server in @xcite is _ centralized _ : each fetching decision of the central server the full knowledge of the queue lengths at all local stations .",
    "however , theorem  [ teoonline ] suggests that the same system - wide delay scaling in the resource pooling scenario could also be achieved by a _ distributed _ implementation : each server simply runs the same threshold policy , @xmath710 , and routes all deleted jobs to the central queue . to prove this rigorously",
    ", one needs to establish the validity of equation  ( [ eqcentralfinite ] ) , which we will leave as future work .    a fairly tedious stochastic coupling argument",
    "was employed in @xcite to establish a matching lower bound for the @xmath711 delay scaling , by showing that the performance of the lqf policy is no worse than any other online policy . instead of using stochastic coupling",
    ", the lower bound in theorem  [ teoonline ] immediately implies a lower bound for the resource pooling problem in the limit of @xmath319 , if one assumes that the central server adopts a _ symmetric _ scheduling policy , where the it does not distinguish between two local stations beyond their queue lengths . to see this , note that the rate of @xmath694 are identical under any symmetric scheduling policy , which implies that it must be less than @xmath2 for all @xmath203 .",
    "therefore , the lower bound derived for the admissions control problem on a _ single queue _ with a redirection rate of @xmath2 automatically carries over to the resource pooling problem .",
    "note that , unlike the previous item , this lower bound does not rely on the validity of equation  ( [ eqcentralfinite ] ) .",
    "both observations above exploit the equivalence of the two problems in the regime of @xmath319 . with the same insight",
    ", one could also potentially generalize the delay scaling results in @xcite to scenarios where the arrival rates to the local stations are nonuniform , or where future information is available .",
    "both extensions seem difficult to accomplish using the original framework of @xcite , which is based on a fluid model that heavily exploits the symmetry in the system . on the downside , however , the results in this paper tell us very little when system size @xmath12 is _ small _ , in which case it is highly conceivable that a centralized scheduling rule , such as the longest - queue - first policy , can out - perform a collection of decentralized admissions control rules .",
    "the authors are grateful for the anonymous reviewer s feedback ."
  ],
  "abstract_text": [
    "<S> we study an admissions control problem , where a queue with service rate @xmath0 receives incoming jobs at rate @xmath1 , and the decision maker is allowed to redirect away jobs up to a rate of @xmath2 , with the objective of minimizing the time - average queue length . </S>",
    "<S> we show that the amount of _ information about the future _ has a significant impact on system performance , in the heavy - traffic regime </S>",
    "<S> . when the future is unknown , the optimal average queue length diverges at rate @xmath3 , as @xmath4 . in sharp contrast , </S>",
    "<S> when all future arrival and service times are revealed beforehand , the optimal average queue length converges to a finite constant , @xmath5 , as @xmath6 . </S>",
    "<S> we further show that the finite limit of @xmath5 can be achieved using only a _ </S>",
    "<S> finite _ lookahead window starting from the current time frame , whose length scales as @xmath7 , as @xmath6 . </S>",
    "<S> this leads to the conjecture of an interesting duality between queuing delay and the amount of information about the future .    , </S>"
  ]
}