{
  "article_text": [
    "understanding basic surface growth models is an important task of statistical physics @xcite .",
    "the exploration of universal scaling behavior and pattern formation is a recent challenge as fabrication of nanostructures via self - organized bottom - up technology is getting widespread @xcite .",
    "simulation methods are very useful tools , since the solution of coupled differential equations is very difficult in general @xcite .",
    "mapping of simple surface growth models onto binary lattice gases has proved to be a very useful tool to understand basic phenomena via nonequilibrium reaction - diffusion system @xcite .",
    "recently it has been shown that such mapping can be extended to higher dimensions @xcite and more complex reactions , like surface diffusion ... etc .",
    "can also be treated in this way @xcite .",
    "the research of nonequilibrium lattice gases even in @xmath1 dimensions is of current interest ( for a review see @xcite ) .",
    "some of them are exactly solvable , providing a framework to extend thermodynamical description to nonequilibrium systems ( for a review see @xcite ) . disorder , which is present in almost all real systems has been investigated in these systems and found to be a relevant in many cases @xcite .    by coupling one - dimensional lattice gases one can create the simplest models of multi - lane traffic @xcite , or describe the cooperative behavior of molecular motors @xcite .",
    "these are proteins capable to carry different cargoes from one part of the cell to the other @xcite .",
    "several versions of such multi - lane system have been investigated recently , we concentrate on the numerical simulation of a model , in which the motion of particles in the lanes is opposite and they can jump in between the lanes randomly @xcite .    the computational complexity of the simulation algorithms is high enough to consider an implementation on modern graphics processing units ( gpus ) since the performance of the gpus is much higher than that of normal cpus for the same cost and power supply .",
    "furthermore our application has communication / computing ratio , that fits gpus better than a cluster of cpus . to gain this performance",
    "the problem must fit to the architecture of gpus , i.e. the following factors must be fulfilled :    1 .",
    "the problem can be divided into sub - problems which can be computed independently ( parallelization ) using parallel threads . 2 .",
    "the parallel threads of the algorithm do not need to communicate directly .",
    "data exchange can be performed using the memory ( smp approach ) .",
    "3 .   the amount of memory needed for the computation inside each parallel thread is limited .",
    "the first of the three points is obviously essential to create a parallel algorithm .",
    "the second point follows from the architecture of gpus , where no bus system exists between processing elements .",
    "the third point is necessary for the performance of the algorithm only .",
    "many articles in the field of statistical physics have already shown that there is a wide variety of simulation algorithms , which can benefit from gpu implementations @xcite .",
    "today s gpus are mainly produced by two manufacturers : nvidia and ati .",
    "the architecture differs slightly @xcite , but the main concepts are the same : a gpu device consists of a number of multiprocessors ( nvidia fermi : 14 , ati hemlock : 40 ) , each equipped with several processing elements ( nvidia fermi : 32 , ati hemlock : 16 ) , an instruction block , shared memory and caches ( see table [ table1 ] for a summary ) .",
    "each processing element ( pe ) , which is also called _",
    "cuda core _ ( nvidia ) or _ stream core _ ( ati ) is a simple entity , containing arithmetic logic units , floating point and integer units , flow control and registers .",
    "the performance of pes is limited , but due to parallelism the peak performance of the entire gpu is much higher than that of a multi - core cpu .    for the programmer a gpu is a device , which executes _ kernels _ in parallel as a set of threads .",
    "there are vendor specific language extensions like nvidia s cuda or platform independent ones like opencl @xcite , which moreover can be used to program other types of processors ( dsps , cpus ) .",
    "the speedup , which can be achieved using one gpu ( compared to running the simulation on a single cpu - core ) is already remarkably high , but the run - time can still be long enough to consider multi - gpu simulations . on many systems it is possible to plug in more than one gpu card , but if more than , for example , four cards are to be used it is necessary to parallelize the program over a network using methods like message passing ( mpi ) .",
    "some early results from a first gpu version have already been published before @xcite . in this article",
    "we will discuss implementations on different gpus ( nvidia and ati ) using cuda and opencl for single - gpu versions and mpi for the multi - gpu code .",
    ".key facts of the gpu cards from nvidia @xcite and ati @xcite.[table1 ] [ cols= \" < , > , > , > \" , ]",
    "surface growth in statistical mechanics has been investigated by simple models , atomistic ones or continuum theories @xcite .",
    "understanding of several fundamental questions is still not complete .",
    "the kardar - parisi - zhang ( kpz ) equation @xcite , motivated by experimentally observed kinetic roughening has been the subject of large number of theoretical studies @xcite .",
    "later it was found to model other important physical phenomena such as randomly stirred fluid @xcite , dissipative transport @xcite , directed polymers @xcite and the magnetic flux lines in superconductors @xcite .",
    "it is a non - linear stochastic differential equation , which describes the dynamics of growth processes in the thermodynamic limit specified by the height function @xmath2 @xmath3 here @xmath4 and @xmath5 are the amplitudes of the mean and local growth velocity , @xmath6 is a smoothing surface tension coefficient and @xmath7 roughens the surface by a zero - average gaussian noise field exhibiting the variance @xmath8 here @xmath9 is used for the dimension of the surface , @xmath10 for the noise amplitude and @xmath11 denotes average over the noise distribution .",
    "the solution of kpz in @xmath1 dimensions is known exactly for different initial conditions @xcite , but in higher dimensions only approximations are available ( see @xcite ) . in @xmath12 spatial dimensions due to the competition of roughening and smoothing terms , models described by the kpz equation exhibit a roughening phase transition between a weak - coupling regime ( @xmath13 ) , governed by @xmath14 edwards - wilkinson ( ew ) fixed point @xcite , and a strong coupling phase .",
    "mapping of surface growth onto reaction - diffusion system allows effective numerical simulations @xcite . in one dimension",
    "a discrete , restricted solid on solid between neighbouring sites is finite ] realization of the kpz growth @xcite is equivalent to the asymmetric simple exclusion process ( asep ) of particles @xcite ( see fig .  [ kpzasep](a ) ) .",
    "@xmath15 \\epsfxsize=2.5 in \\epsffile{model1d.eps } &          \\epsfxsize=1.5 in          \\epsffile{pasepfig.eps } \\\\ [ 0.4 cm ] \\mbox{\\bf ( a ) } & \\mbox{\\bf ( b ) } \\end{array}$ ]    in this discrete so - called roof - top or single - step model the heights are quantized and the local derivatives can take the values @xmath16 . if we associate the up slopes with particles and down slopes with holes of the base lattice ( see fig .",
    "[ kpzasep](b ) ) , the adsorption / desorption corresponds to asep .",
    "this is a binary lattice gas @xcite , where particles can hop on adjacent sites , with asymmetric rates , in case of vacancy .",
    "the behavior of asep is rather well known , and variations of asep ( disorder , interactions ... etc . )",
    "can be related to variations of @xmath1 dimensional kpz growth models . when left / right symmetry in the hopping rates holds , we have the so called symmetric simple exclusion process ( ssep ) , which corresponds to the ew growth model with the scaling exponents : @xmath17 , @xmath18 ( i.e. logarithmic growth ) .",
    "usually the numerical solution of partial differential equations depends on the discretization scheme , however we used a mapping here onto binary variables , where such discretization is not feasible .",
    "all gradients are approximated by @xmath19 slopes and we exploited the spatial scale invariance of the system , which is due to the diverging correlation length of these models .",
    "for cuda we used coalesced memory access , which is optimal for smaller system sizes that fit into the shared memory .",
    "we have programmed the one dimensional asep model by cuda within the framework of fx 5800 ( or tesla c1060 ) gpu cards as follows . to achieve maximum performance we limited the maximum system size to @xmath20 , hence using bit - coding technique one can store a ring ( periodic boundary condition ) within the shared memories of multiprocessors ( in the fx5800 graphics cards there are @xmath21 kbyte shared memory / block ) .",
    "therefore one multiprocessor block , containing @xmath22 pes , follows the evolution of a single chain and does not interact with the other @xmath23 multiprocessors of the graphics card .",
    "thus we have fast inter - pe communication during the simulations , and we need access of the slower card memory only at the beginning and at the end of a time loop .",
    "each multiprocessor block performs a statistically independent run , with completely different random number sequence .",
    "this is achieved by the intelligent striding method of _ gpu - rng _ , the pseudo - random number generator of gnu developed for cuda .",
    "this is in fact the parallel version of _",
    "drand48 _ , a standard linear congruential generator with @xmath24-bit integer artihmetics @xcite .",
    "this generator has sufficiently long cycle ( @xmath25 ) and the main program pre - shifts the seeds of the individual gpu kernel parts such that they do not overlap with each other .",
    "starting from periodic , alternating @xmath26 distribution , which corresponds to a flat initial surface , we update the particle model by the rules defined in the previous section .",
    "the difference between the standard asep and the cuda realization is that we use parallel , two - sub - lattice updates instead of the random sequential one , which fits serial computers . to allow simultaneous , multiple pe updates without particle collisions we divide the asep chain ( with binary state variables @xmath27 ) into even and odd blocks ( see fig.[parasep ] ) .",
    "since there are less processors than sites , a single sweep of the lattice update is done via the sequence shown on fig .",
    "[ parasep ] .",
    "first we update the even sub - lattice with forward or backward jumps of @xmath28-s with probabilities @xmath29 or @xmath30 ( @xmath31 ) respectively .",
    "these are distributed among independent threads of the kernel function .",
    "the best performance was obtained when the number of threads was @xmath32 ( for fx 5800 ) .",
    "then we update the odd sub - lattice sites ( @xmath33 ) similarly .",
    "finally we close the ring by jumping @xmath28-s between the first and the last sites . naturally in the totally anisotropic asep ( tasep ) case the @xmath34 steps are omitted , and if there is no disorder @xmath35 for all sites .",
    "when all sites are updated once the time ( @xmath36 ) is incremented by one monte carlo step ( mcs ) and we repeat these sweeps until @xmath37 . for the stochastic cellular automaton ( sca )",
    "updates we need random numbers generated locally , by each exchange using _ gpu - rng _ in each thread .",
    "the equivalence of asep with sca dynamics and random sequential updates ( rsu ) is not evident , therefore first we compared our results with the known results for rsu . at certain time steps",
    "we calculate the @xmath38 heights from the height differences @xmath39 .",
    "the morphology of a growing surface is usually characterized by its width @xmath40^{1/2 } \\ .\\ ] ] in the absence of any characteristic length , growth processes are expected to show power - law behavior of the correlation functions in space and height and the surface is described by the family - vicsek scaling  @xcite @xmath41 here @xmath42 is the roughness exponent and characterizes the deviation from a flat surface in the stationary regime ( @xmath43 ) , in which the correlation length ( @xmath44 ) has exceeded the linear system size @xmath45 ; and @xmath46 is the surface growth exponent , which describes the time evolution for earlier ( non - microscopic @xmath47 ) times .",
    "the dynamical exponent @xmath48 , describing the space - time anisotropy , can be expressed by the ratio @xmath49    the maximum simulation time ( @xmath50 ) of runs depends on the time needed to achieve the steady state ( saturation ) , hence on the system size @xmath45 .",
    "we have checked this by inspecting the results on the log .- linear scale . due to the parallelization among multiprocessor blocks we obtain @xmath23 independent realizations of the @xmath51 data at once and",
    "there is an external statistical loop in the cpu code to multiply this further . at the end of the program",
    "the @xmath52 data of each sample are averaged out by the cpu .",
    "we have also tested the effect of the @xmath53 value . in the rsu case",
    "one can find the best kpz scaling for @xmath54 , but here we have to choose @xmath55 , in order to introduce some randomness .",
    "otherwise particles would just flip back and forth .",
    "a larger @xmath53 helps to reach the saturation earlier , but compresses the dynamical scaling region .",
    "we have compared simulations with @xmath56 and @xmath57 and found the same scaling exponents . for the time being we fixed @xmath57 as a compromise between speed and dynamical scaling region size .",
    "we have represented the state of an asep site ( @xmath58 ) by the first bit of a character variable ( @xmath59 ) , while we used other bits of @xmath59 to store other , site dependent information . as we will see",
    "later in case of multi - lane asep , with quenched disorder this allows an effective cuda algorithm and memory allocation .    in case of extremely long simulation times @xmath60 , which is necessary to achieve the steady state of larger systems we allowed to pass first and last elements of @xmath58 between the multiprocessor blocks and",
    "close the chain by the ends of the pes of a gpu card . in this case",
    "we simulate a single system by one card .",
    "the communication loss , which is due to reading and writing of these characters to the device memory has been found to be small due to the fact that such events occur only once by every lattice sweep , i.e. with the frequency @xmath61 .",
    "we have run dynamical simulations of the asep model with parallel sca updates on rings of @xmath62 sizes . can also be simulated , but with a lower efficiency ] each run was started from the alternating sequence of @xmath63-s and @xmath28-s , corresponding to the most flat surface .",
    "the probabilities of forward / backward jumps of @xmath28-s was @xmath57 and @xmath64 respectively .",
    "this so - called totally asymmetric simple exclusion process ( tasep ) is known to exhibit kpz scaling in the thermodynamic limit .",
    "we sampled the evolution by exponentially increasing time gaps : @xmath65 and calculated @xmath66 at these times .",
    "for the longest run , by @xmath20 the saturation was reached at @xmath67 mcs and we followed the simulations up to @xmath68 in the steady state .",
    "this means @xmath69 data sampling events , according to ( [ sampling ] ) , which requires negligible time compared to the length of the calculations ( @xmath70 minutes ) .",
    "this ensures that the serial sampling part does not alter the efficiency of the parallel cuda code .    by the scaling analysis we have subtracted the leading order correction to scaling from the width data ,",
    "i.e the constant value @xmath71 , corresponding to the intrinsic width of the initial zig - zag state .",
    "as one can see on fig .",
    "[ kpztest ] excellent data collapse could be achieved for different sizes with the @xmath1 dimensional kpz exponents : @xmath72 and @xmath73 @xcite .",
    "scaling collapse of the @xmath1 dimensional parallel update kpz ( asep ) by cuda simulation results for sizes @xmath74.,height=283 ]    the parallel cuda code run on quadro fx 5800 card @xmath75 ghz was compared with the same algorithm run on a cpu core ( intel i5 750 @xmath76 ghz ) and the speedup : @xmath77 was observed .",
    "this is near to the physical limit , taking into account that the graphics card has @xmath78 pe - s with twice slower clock rate .",
    "this is the consequence of independent threads , i. e. the run - time data are packed in the fast shared or constant memories .",
    "the time needed to run @xmath23 realizations of a @xmath79 sized system up to @xmath80 mcs on a quadro fx 5800 card is only @xmath81 seconds .",
    "having confirmed the validity of kpz scaling for the sca cuda algorithm we introduced quenched , site - wise disorder in the hopping rates , with the bimodal distribution : @xmath82 i.e. we reduced the probability of exchange by a factor @xmath83 at random sites selected with probability @xmath84 ( here @xmath85 denotes the kronecker delta function ) . when we allow backward jumps as well we use the same distribution for @xmath86 .",
    "the sites with reduced hopping rates were tagged by the second/(third ) bits of the @xmath59 variable corresponding to site @xmath87 .    the tasep particle model with quenched , site - wise disorder ( q - tasep ) corresponds to kpz growth with columnar disorder ( qckpz ) : @xmath88 i.e. the noise field @xmath89 is constant in time and independent of height .",
    "the q - tasep model was investigated by scaling arguments in @xcite and emphasized that `` numerical confirmations for the coarsening dynamics in case of site - wise disorder would be most welcome '' .",
    "we have done this by monte carlo simulations of the parallel update sca version of q - tasep .    as fig .",
    "[ q - kpz](a ) shows we followed the evolution of @xmath90 beyond saturation for sizes : @xmath91 .",
    "the number realizations , with independent disorder distribution was @xmath92 for each size .",
    "the speedup compared to the serial code on the reference cpu was about @xmath93 , depending on the parameters slightly . on fig .",
    "[ q - kpz](b ) we can see the same data rescaled by the exponents @xmath94 , @xmath95 according to eqs .",
    "( [ fv - b ] ) and ( [ fv - a ] ) .",
    "the data collapse is reasonable if we take granted logarithmic corrections to scaling    @xmath15 \\epsfxsize=2.1 in \\epsffile{q - kpz.eps } & \\epsfxsize=2.1 in \\epsffile{q - kpz - col.eps } \\\\ [ 0.5 cm ] \\mbox{\\bf ( a ) } & \\mbox{\\bf ( b ) } \\end{array}$ ]    and we can confirm the results of @xcite indeed .",
    "more detailed analysis will be published elsewhere @xcite .    to realize ssep with disorder ( q - ssep ) it is important to have both forward and backward jumps of @xmath28-s , otherwise the left - right symmetry is broken and we find normal scaling instead of an activated one . as fig .",
    "[ q - ssep](a ) shows an extremely slow convergence to saturation emerges for @xmath96 .",
    "the evolution of @xmath90 can not be described by ( [ fv - b ] ) , but it follows the activated scaling law @xmath97 as shown on fig .",
    "[ q - ssep](b ) .",
    "this behavior is expected , when the so - called strong disorder fixed point dominates in the renormalization group sense @xcite . in this case",
    "the dynamics slows down and the relaxation time is characterized by @xmath98 finite size scaling results in a good data collapse with the exponents @xmath94 , @xmath99 and @xmath100 .",
    "@xmath15 \\epsfxsize=2.1 in \\epsffile{q - pasep.eps } & \\epsfxsize=2.1 in \\epsffile{q - pasep - col3.eps } \\\\ [ 0.5 cm ] \\mbox{\\bf ( a ) } & \\mbox{\\bf ( b ) } \\end{array}$ ]    further results of the data analysis will be discussed elsewhere @xcite .",
    "our intention was to find out whether different gpu architectures have significant impact on the run - time of simulations and to create a multi - card program . to achieve this we favored opencl over other vendor - dependent apis .",
    "opencl is a high - level language , compared to nvidia s cuda or amd s cal , which are optimal when one develops a program for a specific gpu flavor .",
    "however creating two implementations of the same algorithm , tuning both of them with vendor specific tricks is very time consuming , therefore we have chosen opencl and wrote an algorithm that relies solely on the general aspects of gpu programming within the framework of programs that execute across heterogeneous platforms consisting of cpus , gpus , and other processors @xcite and let the compilers to do the optimizations .    the algorithm used in this program is similar to that of the previously explained cuda code , however the implementation differs at many points .",
    "it is similar , since it uses bit level coding of the chain , however the state of lattices sites and the reduced probability locations are stored separately .",
    "they are not inside the same array of characters , but each of them is stored in an array of its own ( see fig .",
    "[ clmap ] ) .",
    "this saves space from the shared memory in case of asep , allowing one to simulate longer chains , if needed .",
    "furthermore , it has a second collateral benefit , which ultimately abolishes the need to use shared memory , lifting the limit imposed by the size of the shared memory of a compute unit .",
    "this provides a limitation on @xmath45 only by the total vram size accessible to a gpu .",
    "as we saw earlier , updating lattice sites is completely independent at odd and even time - steps , hence we can organize our data , that allows processing the chain by vector operations .",
    "this optimization was used to utilize amd gpu capabilities , namely the advantage coming from the fact that stream cores located in amd gpus are 4 unit wide vector - processors ( with a fifth special function unit , inaccessible directly ) .",
    "this will not hinder nvidia cards , they have to deal with vector and matrix operations , unrolled to scalar ones either by the driver ( in case of directx applications ) , or by the compiler ( in the case of opencl applications ) .",
    "the second change in the implementation is related to another optimization .",
    "it is a general gpgpu practice , that one tries to avoid flow control whenever possible . when there is no actual difference of the program flow in two branches of a control statement , besides the value of a single variable predication should be used .",
    "one should keep in mind that predication does not save computation required for the evaluation .",
    "it only removes the need of branching , which program flow to enter , hence it decreases the idle alu time .",
    "this might seems to be an over - optimization , but practice shows that flow control throws back the performance and should be avoided whenever possible .",
    "although less important in long simulations , if the sampling is done at rare time steps ( [ sampling ] ) , the output @xmath101 is computed in a parallel manner on the gpu device .",
    "it is possible to add second moments of the height distribution with the proper correction , explained in @xcite .",
    "the method implemented is a mixture of the two - pass algorithm and the pairwise method .",
    "this is useful if multiple , long chains are calculated , when it takes longer to collect data .    as it has been stated before the limitation imposed by the size of the shared memory can be lifted if we avoid its usage .",
    "this is both a benefit and a drawback of high - level implementations , like opencl , that the explicit program behavior is masked from the programmer .",
    "early implementations showed , that the program ran well , when more shared memory was allocated , than what was available to the card .",
    "this is due to the fact that even if excess data are stored in the vram , it is still within the shared memory name - space and the compiler does not notify the programmer about the excessive memory usage .",
    "benchmarks with this implementation showed that run - time did not increase , when some of the data was read from device memory .",
    "the two diagrams on fig .",
    "[ latency ] help us to understand why reorganizing data removes the advantage of shared memory usage .",
    "the diagrams show how a pe hides read latencies by thread scheduling inside a work - group .",
    "dark red parts show useful work , beige parts show idle threads waiting for execution and crossed parts show idle thread time due to a memory read . when a thread requires data outside of its registers , the execution stalls until data arrives .",
    "if a stall occurs , the execution is given to another thread in the work - group , until it reaches a read command .",
    "if data are fetched in too small portions compared to the amount of time required to process it , scheduling wo nt be able to hide read latencies , the useful ( red ) work time will be too short to make up for the time needed to read .",
    "if lattice states are stored in vectors of integers , one vector read operation requires @xmath102 lattice points to be updated ( see fig .  [ latency ]",
    "( a ) ) . in comparison ,",
    "if every lattice point is stored in a separate character , a read command is imposed in between lattice updates ( see fig .  [ latency](b ) ) .",
    "@xmath15 \\epsfxsize=2.1 in \\epsffile{latency_hiding_1.eps } & \\epsfxsize=2.1 in \\epsffile{latency_hiding_2.eps } \\\\ [ 0.5 cm ] \\mbox{\\bf ( a ) } & \\mbox{\\bf ( b ) } \\end{array}$ ]    the main reason for the opencl implementation was to investigate if this kind of problem fits clusters of gpus . solving the problem on a cluster",
    "can be approached in multiple ways .",
    "using multiple gpus one can simply increase the number of chains simulated in parallel to reduce statistical errors .",
    "multi - cards can also be used to simulate larger chains , spanning over more than one gpus .",
    "implementing the latter idea would be an effort in vain for the following reasons .",
    "the algorithm should copy ( a few bits ) at every lattice sweeps . in order to optimize the work - time / data - fetch ratio by the vectorization ,",
    "the ratio of inter - lattice communication and lattice sweep time is fixed .",
    "even inside shader codes , the most expensive operations are synchronization ( sync ) commands . one sync command takes roughly 2 magnitudes higher execution time , than regular add and mul commands .",
    "sync commands outside a gpu , but inside the computer are yet again roughly 2 magnitudes more costly , while synchronizing over a network takes even more time .",
    "when one sweep of a lattice points can be done very quickly , the efficiency of the implemented algorithm would depend on the amount of sync and copy commands .",
    "for this reason the opencl implementation avoids shared memory usage and one can consider large chains ( typically @xmath103 ) .",
    "the multiple card processing capacity is exploited just to increase statistics , which is very useful , because a large number of independent disorder realization is necessary in these problems .",
    "on the other hand in higher dimensions we will need more memory than what is accessible by a single gpu , so the other approach must be followed .",
    "opencl does not have such a long history as cuda does , compilers are still evolving and not all functionality of the standard are supported by them .",
    "this leads to slight modifications in the code to make it cross - vendor ready .",
    "furthermore , different architectural capabilities require to create an implementation , which uses the greatest common denominator of capabilities , so to say .",
    "note , that the cuda and opencl implementations use different random number generators .",
    "the cuda code uses gpu - rng , while the opencl utilizes a mersenne - twister type of generator , slightly modified to fit to the problem .",
    "the difference in the performances due to these generators were not inspected .",
    "we compared the codes by simulating tasep chains without disorder .",
    "the performance of the opencl implementation on nvidia cards is inferior to that of the cuda implementation , ( at least for @xmath104 ) due to reasons encountered previously .",
    "however , higher dimensional simulations will most likely have to use the opencl like data structure , due to the very limited size of the shared memory .",
    "@xmath15 \\epsfxsize=2.1 in \\epsffile{plot1.eps } & \\epsfxsize=2.1 in \\epsffile{plot2.eps } \\\\ [ 0.5 cm ] \\mbox{\\bf ( a ) } & \\mbox{\\bf ( b ) } \\end{array}$ ]    the performance scaling of the algorithm is nearly optimal , as one can expect it , taking into account that different threads run independently from each other .",
    "intimacies between the mpi and gpu drivers cause that ideal scaling can not be achieved .",
    "the opencl implementation was tested on nvidia c1060 and c2070 cards , on ati hemlock cards and also on conventional cluster nodes with 4 amd opteron quad - core cpus .",
    "the cuda implementation was tested on the nvidia cards .",
    "the common task to be done was running the simulations up to @xmath105 mcs for @xmath106 realizations .",
    "although the the architecture of tesla c1060 gpu is considerably different from that of tesla c2070 we could use the same algorithms .",
    "opencl is responsible for rearranging memory stores / loads and alu instructions to fit the architecture best .",
    "differences between c1060/c2070 , such as the l2 cache remain unexposed to the user , are not accessible directly .",
    "the compiler and the hw decide how to use them . in case of cuda",
    "we used different thread numbers for c1060/c2070 to achieve the best performance for a each .",
    "the algorithms could be optimized further , if the development time was unlimited , but our code is far from being a first - approach , exploits both basic and nontrivial aspects of gpu programming @xcite .    as one",
    "can see on fig .",
    "[ per](a ) the run - time ( @xmath107(seconds ) ) initially does not change in the case of opencl ran on gpus as @xmath45 is increased .",
    "this is because gpus are not fully utilized on short chains and cuda cores are idle due to the lack of work .",
    "run - times begin to increase as all pe - s start to work .",
    "the constant time region is longer for the fermi based teslas , due to the higher number of cuda cores inside a compute unit .",
    "the opencl version , running on 16 cpu cores does not have the constant part for smaller chain lengths , but the scaling is quite similar to that of the gpus .",
    "the cuda implementation on the fermi cards runs significantly faster , especially for smaller chain lengths .",
    "the run - times grow almost linearly ( @xmath108 ) for all sizes : @xmath109 , that can be simulated due to the shared memory limitation .",
    "@xmath15 \\epsfxsize=2.1 in \\epsffile{plot3.eps } & \\epsfxsize=2.1 in \\epsffile{plot4.eps } \\\\ [ 0.5 cm ] \\mbox{\\bf ( a ) } & \\mbox{\\bf ( b ) } \\end{array}$ ]    multi - gpu run - time comparison was done on a limited number of nvidia gpus , since only 4 c2070 and 8 c1060 nvidia cards have been available for us .",
    "[ per](b ) shows the scaling on the 8 teslas ( c1060 ) ; while fig .  [ per2](a ) displays the same for the 4 fermi cards ( c2070 ) .",
    "as one can see these are nearly optimal , the curves go parallel for all tested chain lengths and the speedup grows almost linearly with the number of cards .",
    "this is far from trivial in case of parallel algorithms running on multiple cards",
    ". the opencl frame will be very useful for further applications of this type . in fig .",
    "[ per2](b ) one can see that the efficiency , defined as the speedup per node , of the multi - gpu implementations depends on the number of cards , as well as on @xmath45 in a non - monotonic way .",
    "this enables one to optimize simulations with limited resources .",
    "next we turn to the numerical study of a two - lane model , with opposite , unidirectional motion in the lanes and with quenched , random inter - lane crossing probabilities @xcite .",
    "this arrangement can be thought of a simplified model of cars or motors moving along two oppositely oriented roads or filament tracks .",
    "the motion of a single particle in this environment has been found to exhibit enhanced diffusion coefficient compared to that of the symmetric random walk @xcite .",
    "this type of active diffusion can be realized experimentally and also present _ in vivo _",
    "theoretical studies have concluded that , the steady - state behavior is richer than that of the one - lane asep , furthermore interesting phenomena take place in such systems , like synchronization or localization of density shocks .",
    "the bidirectional , two - lane model is built up from two tasep rings , in which particles move forward in both lanes deterministically , to the right in @xmath110 and to the left in @xmath111 ( see fig .",
    "[ bifig ] ) , and random lane - crossing probabilities : @xmath112 , @xmath113 .",
    "these are quenched , random variables with bimodal distribution ( [ bimodal ] ) .",
    "we have been interested in the dynamical behavior of this model by determining the exponent @xmath48 via finite size scaling . in the steady - state the total current of particles ( @xmath114 ) vanishes due to the left / right symmetry and its fluctuation @xmath115 is expected to grow linearly in time @xcite .",
    "first we realized and tested the sca version of this model on a cpu , second we implemented it by a cuda program . in order to convert the originally random sequential updates to sca , as in case of the asep",
    ", we decreased the in - lane hopping probabilities to @xmath56 .",
    "one sweep ( mcs ) of the system consists of the parts executed in the following sequence :    1 .",
    "even sub - lattice updates of the lanes @xmath110 and @xmath111 , with probabilities @xmath56 , 2 .",
    "@xmath116 lane - changes , with probabilities @xmath112 , 3 .",
    "odd sub - lattice updates of the lanes @xmath110 and @xmath111 , with probabilities @xmath56 , 4 .",
    "closing boundaries of @xmath110 and @xmath111 , with probabilities @xmath56 , 5 .",
    "@xmath117 lane - changes , with probabilities @xmath113 .",
    "all local data are packed in the shared memories , in the vector of characters @xmath59 ( see fig .  [ bitek ] ) .",
    "the first bits of this vector contain lane-@xmath110 states , the second bits lane-@xmath111 , the third and fourth bits ( @xmath118 ) mark the sites , where the crossing probability is reduced from @xmath119 to @xmath120 .",
    "these are filled at the at the beginning of time loops by @xmath63-s and @xmath28-s randomly , with probability @xmath121 .",
    "the updates are done by bit - masking and using standard , bit - wise ( and , xor , ... ) operations in parallel and independently by the threads .",
    "we increased / decreased a variable ( @xmath122 ) , measuring the current , by each hopping event along the lanes @xmath110 and @xmath111 respectively .",
    "the simulations were started from half filled , random initial conditions of system with linear sizes : @xmath123 , @xmath124 , @xmath125 , @xmath126 .",
    "sampling of the current density : @xmath127 was done in the same way as in case of asep simulations ( [ sampling ] ) . at the end of a time loop we calculated the total current density fluctuations of the system @xmath115 ( the mean value is zero due to the left / right symmetry ) .",
    "averaging was done for @xmath128 samples for each size .    as we can see on fig .",
    "[ charge ] ( a ) , following an initial transient time the shape of each curve changes .",
    "the dynamical behavior crosses over to a different regime , the steady state , where we can find linear growth due to the diffusion like behavior of particles .",
    "@xmath15 \\epsfxsize=2.1 in \\epsffile{charge.eps } &          \\epsfxsize=2.1 in          \\epsffile{charge - col.eps } \\\\ [ 0.5 cm ] \\mbox{\\bf ( a ) } & \\mbox{\\bf ( b ) } \\end{array}$ ]    indeed if we divide @xmath115 by the time , a level - off to constant value can be observed . to determine the dynamical exponents we performed finite size scaling",
    "( see fig .",
    "[ charge ] ( b ) ) . the best collapse could be achieved by assuming the dynamical exponent @xmath17 , but strong corrections can also be observed .",
    "a more detailed analysis will be provided in @xcite .",
    "the speed - up of the code on the fx5800 card compared to the reference cpu was about @xmath129 .",
    "if we allow particles to travel among multiprocessor blocks ( via the vram ) we can simulate much larger sizes , i. e. one sample / gpu . in this case",
    "we could reach a speed - up @xmath130 .",
    "we have realized efficient @xmath131 lattice - gas simulation algorithms for gpus for the first time .",
    "this allows us to investigate @xmath1d surface growth or transport phenomena with extremely long relaxation times .",
    "this is typical in case of system with quenched random reaction rates .",
    "furthermore in these system averaging must be carried out over a large number of disorder realizations , thus this problem fits the advantages of parallel processors .",
    "we have confirmed that the sca version of asep is equivalent to the random sequential one , hence it can be well adapted for simulations with massively parallel gpu cores .",
    "we used two - sub - lattice updates , which can be generalized to checker - board lattice decomposition in two dimensions .",
    "our preliminary results for asep with quenched disorder are in agreement with some previous expectations , detailed discussion is in preparation @xcite .    by coupling two asep chains with lane crossing probabilities",
    "we have made the first step towards two dimensional simulations @xcite , as well as we found interesting results for a traffic problem .",
    "we used bit coding to allow efficient memory management , which is critical if the fast shared memory of gpus to be used .",
    "two similar code realizations have been compered in detail on different gpu hardwares .",
    "the cuda code is faster for smaller system sizes , than the opencl one , but has limitations due to the size of the shared memory and the architecture . in particular for the simple asep problem we could achieve a speedup of @xmath132 as compared to a traditional , present day single cpu",
    "this is near the physical limits of the gpu card .",
    "the multi - gpu ( mpi ) opencl code has been proved to be portable not only among gpus of different vendors , but runs on clusters of cpus as well .",
    "we have provided detailed scaling analysis of these codes and pointed out implementation specific questions .",
    "these results warrant for further interesting applications of gpus in statistical physics and materials science @xcite .",
    "we thank r. juhsz , i. borsos , k .- h .",
    "heinig , j. kelling and n. schmeisser for the useful discussions .",
    "support from the hungarian research fund otka ( grant no .",
    "t77629 ) , and the bilateral german - hungarian exchange program daad - mb ( grant nos . 50450744 , p - mb/854 ) is acknowledged .",
    "the authors thank nvidia for supporting the project with high - performance graphics cards within the framework of professor partnership .",
    "h. schulz , g. dor , j. kelling , k .- h .",
    "heinig , b. liedke , n. schmeisser , _ computing the kpz equation using gpu acceleration _ , 3rd international workshop _ innovation in information technologies - theory and practice _ , dresden ( 2010 ) ."
  ],
  "abstract_text": [
    "<S> restricted solid on solid surface growth models can be mapped onto binary lattice gases . </S>",
    "<S> we show that efficient simulation algorithms can be realized on gpus either by cuda or by opencl programming . </S>",
    "<S> we consider a deposition / evaporation model following kardar - parisi - zhang growth in 1 + 1 dimensions related to the asymmetric simple exclusion process and show that for sizes , that fit into the shared memory of gpus one can achieve the maximum parallelization speedup ( @xmath0 for a quadro fx 5800 graphics card with respect to a single cpu of 2.67 ghz ) . </S>",
    "<S> this permits us to study the effect of quenched columnar disorder , requiring extremely long simulation times . </S>",
    "<S> we compare the cuda realization with an opencl implementation designed for processor clusters via mpi . </S>",
    "<S> a two - lane traffic model with randomized turning points is also realized and the dynamical behavior has been investigated .    </S>"
  ]
}