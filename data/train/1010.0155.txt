{
  "article_text": [
    "within the area of multi - agent systems there has recently been a development towards making the organization of such systems explicit @xcite .",
    "however , while @xcite lists some drawbacks of classical ( agent - centered ) multi - agent systems , the actual advantages of making the organization explicit has not been thoroughly investigated .",
    "this paper summarizes our work with such investigation of the organization of multi - agent systems .",
    "the investigation was conducted by implementing two systems : a classical ( agent - centered ) ( acmas ) and an organization - centered ( ocmas ) .    in classical multi - agent systems",
    "the agent is in focus .",
    "the programmer developing the agents is able to decide what the agents can do and _ how _ the choose to do it . in an ocmas",
    "we are more concerned with the organization ; i.e. the structure of the multi - agent system .",
    "naturally all multi - agent systems have a structure , but it is most often implicitly defined by the agents and their relations .    by explicitly defining the organization it is possible to focus on _ what _ the agents should do without at the same time deciding _ how _ they should do so .",
    "in other words , the organization makes it possible to create the structure of the system without specifying details about the implementation .",
    "the two types of systems have been compared using a team - based version of the well - known game bomberman .",
    "however , the nature of an implementation of intelligent agents does not guarantee a certain quality and a comparison based on the overall performance of a team of agents may not be adequate ; the results may merely be caused by better or worse strategies .",
    "since the two approaches are quite different in many ways , it seems more natural to employ other measures of comparison .",
    "the comparison of acmas and ocmas is therefore based on the following measures :    * structure of the source code * development speed * performance * error handling * debugging * complexity of the scenario * number of intelligent agents    the original bomberman game consists of five key elements : bombs , boxes , solid obstacles , exitways and power - up panels . whereas boxes are destructible , solid obstacles are not .",
    "this means that bomberman will always be able to take cover behind solid obstacles .",
    "most boxes must be destroyed since they hide both power - ups and exitways .",
    "exitways are what bomberman must find to be able to complete a level .",
    "a power - up can be used to enhance bomberman s abilities and bombs . in the beginning ,",
    "his bombs are weak , but by using power - ups he will be able to drop several stronger bombs at a time .    in a multi - agent context , the enemies could be considered a team of agents ( i.e. a multi - agent system ) with the general purpose of stopping bomberman from escaping and by implementing the enemies using each of the approaches we could perform the comparison .",
    "however , to be able to experiment with the cooperative aspects of intelligent agents we instead propose an altered version of bomberman in which two teams attempt to eliminate each other :    [ def - scenario ] the multi - agent system is similar to bomberman .",
    "it consists of two teams fighting against each other .",
    "each team consists of at least two `` bombermen '' ( or agents ) .",
    "the teams are situated in a maze - like environment consisting of solid obstacles and boxes .",
    "an agent can place bombs which at some point will explode .",
    "an agent dies when he is hit by an explosion .",
    "explosions will also destroy boxes .",
    "a team wins when all players from the other team have been eliminated .",
    "this version of bomberman consists of some of the same key elements as the original game : a maze , destructible and indestructible obstacles , and bombs .",
    "this should allow the agents to employ the strategies intended for the game , while at the same time competing in teams .",
    "this fact creates a new aspect of the game , since a group of agents potentially is able to trap enemies by placing bombs strategically .",
    "the concepts of exitways and power - ups have been excluded in this version .",
    "exitways have been removed , since the overall goal of `` getting to the surface '' is no longer relevant ( as the goal instead is to eliminate the other team ) .",
    "power - ups are not included to avoid making the overall system too complex since the intention is not to make a perfect implementation of bomberman ; rather is it to compare and discuss two different approaches to implementing multi - agent systems . in this case",
    "we believe a simple , yet strategically challenging system will be adequate",
    ".      the implementation of the acmas is done using * _ jason _ * , _ _ `` a java - based interpreter for an extended version of agentspeak''__. we provide an overview of the interpreter by introducing how to program multi - agent system using it , however we will not go into details with all parts of the system . the overview should give a foundation for building simple systems using * _ jason_*. a thorough description of * _ jason _ *  is found in @xcite .    the language of * _ jason _ * , agentspeak , is a prolog - like logic programming language .",
    "agentspeak allows the developer to create a _ plan library _ for the agent .",
    "a plan in agentspeak is basically of the form @xmath0    roughly speaking , if an event matches a trigger , the context is matched with the current state of the agent .",
    "if the context matches the current state , the body is executed ; otherwise the engine continues to match contexts of plans with the same trigger .",
    "if no plan is applicable , the event fails .",
    "the fact that agentspeak is a logic programming language allows one to easily transfer specifications written in logic formulas of a multi - agent system to an implementation written in * _",
    "jason_*. for instance , part of a plan for a vacuum cleaner agent @xcite is shown below : @xmath1    the plan is triggered by the goal ` ! cleaning ` ,",
    "so if the vacuum cleaner is in a `` cleaning state '' , this triggering event would be applicable .",
    "the context specifies that this plan is relevant if the agent currently is somewhere in the environment which is dirty .",
    "if the context can be unified with data from the database of the agent , it will perform the body , which in this case means that it will perform the action ` do(suck ) ` .",
    "however , as mentioned it is possible to have several plans for the same triggering event if those plans have different contexts : @xmath2    this plan will then be applicable if the agent has perceived dirt in an area to the right of its current area . in that case",
    ", it will perform the action ` do(right ) ` .",
    "the implementation of the ocmas is based on the @xmath3  organizational model , in which it is possible to create a structural , functional and deontic specification of an organization .",
    "the organizational model has been combined with * _ jason _ *  in the middleware called @xmath4-@xmath3 .",
    "@xmath3  is an organizational model for multi - agent systems which makes it possible to specify the organization in a mas structurally , functionally and deontically .",
    "the model takes an organizations - centered approach , meaning that an organization will exist _ a priori _ ( created at design - time ) and the agents ought to follow it @xcite .    [ [ structural - specification ] ] structural specification : + + + + + + + + + + + + + + + + + + + + + + + + +    @xmath3  uses the concepts of roles , role relations and groups in the structural specification of an organization .",
    "each agent plays one or more roles .",
    "the roles are related by links , which specify how agents are acquainted and can communicate . in order to further structure the organization , the agents can join different groups depending on the roles they play .",
    "[ [ functional - specification ] ] functional specification : + + + + + + + + + + + + + + + + + + + + + + + + +    the functional specification consists of a _ goal decomposition tree _ , known as a social scheme ( sch ) , where the root is the goal of the sch and each node is a sub - goal that can be delegated to different agents . in @xcite",
    "three operators are defined for decomposing a goal into sub - goals : sequence , choice and parallelism .",
    "these operators allow us to create complex schemes in which the agents can commit to advanced missions .",
    "[ [ deontic - specification ] ] deontic specification : + + + + + + + + + + + + + + + + + + + + + +    the relation between the structural and functional specification is made explicit by the deontic specification . using it , we can constrain the agents further by specifying what missions an agent _ ought _ to follow and what missions an agent _ is allowed _ to follow when playing certain roles .",
    "we write @xmath5 when agents playing role @xmath6 are obliged to complete mission @xmath7 under the time constraint @xmath8 .",
    "analogously we write @xmath9 for permissions .",
    "the @xmath3  organizational model gives a foundation for defining and using an organizational model for multi - agent systems  in other words to create an ocmas .",
    "however , the model itself is not directly associated with any multi - agent framework and the intention is that it should be usable for all kinds of frameworks for multi - agent systems .",
    "the software implementation called @xmath4-@xmath3  is an implementation of @xmath3  which should enable multi - agent systems implemented in * _ jason _ *  to follow an organizational structure @xcite .      0.4",
    "the team - based bomberman introduced above has been implemented in both an acmas and ocmas version .",
    "the following describes some of the implementational details of these systems .",
    "both systems are built for the same environment , and a lot of their abilities will be similar ( if not identical ) .",
    "the differences are mostly _ how _ the systems make use of their knowledge and actions , and not as much _ what _ abilities they have .",
    "this ensures a somewhat identical setup for both systems .",
    "it is the intention that some cooperation is implicitly present .",
    "when two agents pursue the goal of killing the same enemy , they should at least be able to avoid putting bombs at the same spots , and instead attempt to trap the enemy .",
    "this will generally be possible because of the autonomy of the agents ; they should choose paths and bomb locations which seems reasonable , i.e. not place bombs which will potentially hit allies or go through a path in which a bomb may explode soon .",
    "some cooperation can , however , not be done implicitly .",
    "consider the situation in figure [ fig - acmas - agent - stuck ] .",
    "agent `` 26 '' is stuck between a number of boxes without the possibility of placing a bomb to destroy them ; it would kill the agent as well .",
    "in such situation the agent has two options : ( 1 ) wait for another agent to autonomously choose to help the agent or ( 2 ) ask for help .",
    "option ( 1 ) may be possible but it seems irrational to wait for another agent to detect the situation by himself .",
    "the agent being stuck should therefore always ask for help .",
    "this is done using the contract net protocol @xcite .",
    "+   + the agents uses the well - known a*-algorithm @xcite for pathfinding .",
    "in addition to the heuristics used by the algorithm , we use a _ punishment _",
    "value for every location in the environment .",
    "the main difference of this algorithm compared to a * is that included in the tentative value of a neighbor of the current location is a _ punishment _ value depending on the objects on the location of that neighbor .",
    "this will make the algorithm consider other , perhaps longer , paths , which however may prove to be safer .",
    "for instance , by specifying a punishment of 5 on a field containing a box , the algorithm will consider paths , that avoids going through that box , which are up to 5 steps longer .",
    "this may not seem as a big improvement , but it means that if a single box is blocking a path , the agent will consider a path which is a little longer . compared to a situation where he blows up the box and continues ,",
    "this is usually more efficient , since he will have to wait for the bomb to explode and the explosion to disappear .",
    "however , consider the situation depicted in figure [ fig - acmas - long - deroute - a ] .",
    "the agent wants to move from the current position , @xmath10 , to the _ target _ , @xmath11 , so it will be highly inefficient to compute a path avoiding the boxes .",
    "a much more efficient path would be to compute a path , in which a box must be destroyed . to do this",
    "we introduce the notion of an _",
    "intermediate target_. an intermediate target is a target in which a bomb should be placed in order to clear the way to the `` real '' target . in figure [ fig - acmas - long - deroute - b ]",
    "we have an intermediate target , @xmath12 .",
    "this path is clearly preferred over the other .",
    "the fact that agentspeak is prolog - like makes it possible to specify a model for the plans in a way that is easily transferable to * _ jason_*. the agent needs the following predicates from its knowledge base :    * @xmath13 : the current position of the agent . *",
    "@xmath14 : a final target . *",
    "@xmath15 : a possible intermediate target . * @xmath16 : an intermediate target is clear , meaning that the targeted box has been removed , creating a passage . *",
    "@xmath17 : the number of bombs currently available . as a shorthand",
    "we write @xmath18 for @xmath19 .",
    "we now present a model for agent @xmath20 describing the situation above . note that in a scenario of bomberman , there will generally be an enormous amount of epistemic states , since there will be a state for each possible position , and an agent will have different knowledge every time he is in a state , yielding even more states .",
    "therefore , we consider a more abstract and general model with three possible locations : @xmath21 , @xmath22 and @xmath23 , corresponding to the agent s location , his target and intermediate target , respectively . these will be referred to as @xmath10 , @xmath11 and @xmath12 .",
    "we write @xmath24 to match any value of that predicate ( i.e. only in the fact that the predicate exists in the knowledge base is of interest ) .    for each of the three possible locations ,",
    "a number of possible states exist . in epistemic logic",
    "indistinguishable states are typically states the agent can not distinguish because of lack of knowledge . in the following we also refer to states as indistinguishable if they , even though they are somewhat different in terms of knowledge , will result in the agent performing the same action .",
    "this simplifies the model greatly and can be considered as a model created from another agent s point of view .    .",
    "]    figure [ fig - acmas - model - pathfinding ] shows the model for the path - finding problem .",
    "the predicates in a state are the predicates which the agent knows ( or believes ) to be true at that state .",
    "that is , if the agent is at the final target , @xmath11 , and the intermediate target is clear , he will be in the lower right state of the figure .",
    "we use this model to create a plan for how to decide which path to choose .",
    "notice the two possible outcomes of moving towards @xmath12 when the agent is at @xmath10 and has no bombs ( with the intermediate target being blocked ) .",
    "this is because of the fact that during the move towards @xmath12 , a bomb may become available , meaning that the agent will be in a state where @xmath25 rather than @xmath26 .",
    "[ [ committing - to - a - mission - in - mathcalj - mathcalmtextscoise ] ] committing to a mission in @xmath4-@xmath3 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when the agents commit to a mission in a scheme the @xmath4-@xmath3  engine will generate goal achievement events for the goals that are currently available . for instance , when an commits itself to the mission of exploration , it will automatically generate the goal achievement event of finding an unexplored area . whenever a goal is completed , an event for the next goal of the plan is generated . in this case",
    "the next available goal will be to move to the unexplored area . in this way , it is very easy to follow the plan of a mission , since the goals are automatically generated when they have been specified in the organization .    basically , the has the following plans : +    + !",
    "exploremap[scheme(sch ) ] < - jmoise.set_goal_state(sch , exploremap , satisfied ) .    + ! findunexploredarea[scheme(sch ) ] : < context > < - < plan to find unexplored area > ; jmoise.set_goal_state(sch , findunexploredarea , satisfied ) .",
    "movetounexploredarea : < context > < - < plan to move to unexplored area>.    + near ( _ , _ ) < - ?",
    "scheme(exploration , sch ) ; jmoise.set_goal_state(sch , movetounexploredarea , satisfied ) .",
    "notice that since the organizational specification shows exactly how to explore the map , it is only necessary to create plans for each goal event . when the plan is successfully executed , the agent informs @xmath4-@xmath3  that the goal has been satisfied .",
    "it is then the responsibility of @xmath4-@xmath3  to generate the next goal event .",
    "note that moving to an unexplored area is a bit different since it uses the path - finding algorithm described in the previous chapter .",
    "therefore , the goal is satisfied only when the agent is near the unexplored area .",
    "we now present the main results gained during the work with * _ jason _ *  and @xmath4-@xmath3 .",
    "the acmas , along with its structure , is built form the ground .",
    "having to build everything from the ground gives a lot of freedom with regards to the structure of the implementation ; there are no constraints as to where specific details must be implemented . this has lead to a solution where plans for achieving sub - goals and reacting to percepts can be implemented concisely , while still doing as intended .",
    "the resulting agents are therefore reacting quite fast to changes in the environment ; with short code and only few precisely defined responsibilities , the agents are easily able to prioritize during a game , if it , for instance , is necessary to take cover from a bomb .",
    "but the freedom one has with regards to structure has also been the biggest issue during the implementation .",
    "ensuring successful transition between goals has caused some trouble during the implementation .",
    "the debugging functionality can be quite tricky to master , and the only way to test the transition from one goal to another is by executing the system .",
    "this can render the process quite slow .",
    "overall though , we are quite satisfied with the resulting system ; it satisfies the proposed strategy and even though the agents may be quite simple , they are able to cooperate to complete their tasks and use their knowledge to decide how to move through the environment .      building an ocmas is a more well - structured process than that of building an acmas , since it consists of two parts , ( 1 ) specifying organization and ( 2 ) implementing the details of the organization where the latter depends on the completion of the first .",
    "while this does not automatically result in a more structured program , it does force the user to think more about _ what _ , _ why _ and _ how_. when specifying the organization the focus is on _ what _ the overall goals are .",
    "this leads to considering _",
    "why _ these are the goals and in that way it allows us to justify the choices made , even before they are implemented . finally , when the plans are implemented the focus is on _ how _ the agents are supposed to complete their goals .",
    "generally , since only sub - goals , and not their relations , need to be implemented , the code tends to be quite clear .",
    "however , without being able to study the specification of the organization , it is not possible to see the relation between the goals ( as it is handled automatically ) .",
    "furthermore , as required by @xmath4-@xmath3 , the code is often quite verbose , because of the statements required to setup and manage the organizational structure ( ` jmoise.create_group ( ... ) ` etc . ) and the extensive use of annotations ( ` + !",
    "goal[scheme(sch ) ] ` etc . ) .",
    "while this in general makes the code quite clear , it also can result in situations where one need to include a plan for a goal event in which the goal is simply set to be satisfied .",
    "consider the example below :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ .... + !",
    "available when subgoal is satisfied    < - jmoise.set_goal_state(goal , satisfied ) .",
    "subgoal    < - < complete subgoal > ;       jmoise.set_goal_state(subgoal,satisfied ) .",
    ".... _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    in this case , even though the primary goal is completed , when the subgoal is completed , one has to explicitly state that the goal is satisfied even though nothing else happens .",
    "this is not a serious problem , but in large scenarios with complicated schemes , it may result in many `` empty '' plans .",
    "since the agents are part of an organization , they are required to do whatever their obligations tells them to do . to be able to do so , they need access to the specification of the organization .",
    "as described , this access is provided through a special agent .",
    "this means that when an agent has satisfied a goal , this information is sent to the @xmath4-@xmath3  agent which then determines what the next goals are and informs the agent .",
    "this can decrease performance in very active environments if the agent has no goals to pursue while waiting for new information .",
    "this can be seen quite clearly in the implementation of the of the ocmas team .",
    "when the ` exploremap ` goal is available , it is immediately satisfied .",
    "when this happens , the scheme for exploring is finished and a new scheme must be created in order to continue the exploration . compared to the of the acmas , the performance differences are quite clear ; in the acmas , the agent immediately chooses a new spot to move to , while in the ocmas , the agent waits for the generation of an appropriate goal events .",
    "the resulting implementation fulfills the proposed strategy , however the road towards this result has been more bumpy than when working with the acmas .",
    "this will be discussed below .      *",
    "_ jason _ *  uses agentspeak which is an agent - oriented programming language .",
    "such a programming language is perfect for implementing goal - directed and reactive behavior since one builds a set of plans for how to react to such events .",
    "agentspeak is very similar to the logic programming language prolog , and both the language of agentspeak and the general features of * _ jason _ *  have been quite extensively documented in @xcite .",
    "this makes it possible to quite easily understand and exploit the features of the interpreter .",
    "the debugging feature of * _ jason _ *  has lead to a few issues during the implementation .",
    "often when attempting to debug , the entire system pauses and then when attempting to perform a stepwise operation through the system , nothing happens .",
    "this has lead to much trial and error and has overall slowed the development process .",
    "generally though , the system provides descriptive error messages and the more acquainted one gets with the system , the easier errors are spotted .    * the @xmath4-@xmath3  extension * is built on * _ jason _ *  and uses the @xmath3  model , so in general the same things apply to this .",
    "however , since it is an extension , it allows for more actions and there are a few more things one needs to be aware of .",
    "as mentioned , having an organization often leads to a very well structured result since the user is required to really think about what the agents are supposed to do .",
    "this is even more the case in @xmath4-@xmath3  since goal events are automatically generated , meaning that the user need not consider the transition between the goals .",
    "furthermore , the schemes that can be specified in the functional specification of @xmath3  makes coordination of tasks very easy . simply by specifying the cardinality of a goal in a scheme ,",
    "the user specifies how many agents must complete this goal before it is completed within the scheme .",
    "for instance , a goal event can be synchronized by having a sub - goal that all agents must satisfy before the actual goal event is created .",
    "the @xmath3  organizational model has been quite extensively described in @xcite along with a tutorial of the details of how to use it in @xcite .",
    "this makes it very easy to understand how the different concepts are related and should be used .",
    "[ [ organizational - knowledge ] ] organizational knowledge + + + + + + + + + + + + + + + + + + + + + + + +    when a group or scheme is created , the agents will perceive certain events so that they are able to react accordingly . in order to be able to distinguish between similar events",
    ", annotations are added that among other things include which agent created the organizational object .",
    "this can be used to let an agent decide not to join a group if a specific agent has created it , or only committing to a mission it is permitted to commit to , if it is related to a specific group .",
    "this is a great use of the * _ jason _ *  annotations , as it is perfectly clear how to use them .",
    "furthermore , because it is annotations they will not be shown if the programmer chooses not to use them .",
    "what @xmath3  is lacking in term of organizational knowledge is the ability for an agent to know whether it is allowed to join a group _ before _ it attempts to join it .",
    "the reason for this is that if it is not permitted to join a group or play a role , an error event is created .",
    "this should be okay , but it is not possible for the agent to reason about the error in details so it will not know why it could not join the group .",
    "overall , both tools are quite pleasant to work with once acquainted with them .",
    "the work with the two approaches has lead to a discussion of the implementation of each team as well as the two tools used for building the implementations . generally speaking ,",
    "one approach is not better than the other but given the results above it is clear that there are situations more suited for one approach than the other .",
    "figure [ fig - results - overview ] gives an overview of the main results of the comparison .",
    "the figure uses two parameters as basis : the number of agents in the system and the structural complexity",
    ". when the system has a high structural complexity , there are greater advantages of dividing the implementation into two distinct parts : _ what _ and _ how_. this means that while an organization can be applied to simple systems , they will in most cases not benefit much from this .",
    "notice that the two approaches overlap .",
    "the reason is that there will always be situations where it is not clear whether one system is an advantage over the other .",
    "the team - based bomberman is an example of such system .",
    "while the results show a bias towards the in this case , it is partly due to the communication overhead in @xmath4-@xmath3 .",
    "if this problem is solved , the could be performing just as well as the .",
    "[ [ personal - software - assistant ] ] personal software assistant : + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a personal software assistant is a simple agent resposible for assisting an end - user with certain tasks that can be automated . for such purpose",
    "it seems an organization will be inappropriate .",
    "the primary reason for this is that the system will generally consist of very few agents ( in many cases only one ) and the complexity will be low . in such cases",
    "there is not much sense in creating an organization , since the system will not benefit from the os .",
    "it will probably consist of a single group with few roles that the agents can play .",
    "building an entire organization for very few agents can in most cases not be justified .",
    "[ [ distributed - calculations ] ] distributed calculations : + + + + + + + + + + + + + + + + + + + + + + + + +    consider a system of intelligent agents , which have one or more sensors .",
    "this could for instance be the `` distributed sensing '' scenario described in @xcite . here",
    "an agent has a clear responsibility of sensing the environment and using its calculations in some well - defined way .",
    "the role of an agent is defined by the sensors it can use , i.e.  it has a static role .",
    "at all time the information it is computing will be used for the same purpose .    in such cases",
    "there is no need to build an organization since the missions are very simple and there is no explicit need of coordination .",
    "furthermore , being in a group would not change the behavior of an agent in the system since its role and responsibilities remains .    in other words",
    ": even though the system can contain many agents , the structural complexity remains low .",
    "therefore the agents will not benefit much from making the organization explicit .",
    "[ [ paper - review - process ] ] paper review process : + + + + + + + + + + + + + + + + + + + + +    in @xcite an example of the `` reviewing process '' of papers in a conference is considered .",
    "in this example we have a group for submission of papers and one for evaluation .",
    "being in a certain group then gives an agent certain responsibilities , such as evaluating the papers that are being submitted .",
    "this is a very specific example of the use of an organization but it can easily be generalized to situations where certain agents are depending on results from other agents . by grouping such agents and creating schemes they can commit to",
    ", the general structure of the dependence - relation is immediate and the implementation is easily constructed using it .    while the number of agents may vary",
    "it is clear that the structural complexity is higher than in the previous examples .",
    "an explicit organization will definitely make the implementation much easier since responsibilities and acquaintances are well - structured .",
    "[ [ games ] ] games : + + + + + +    games can be quite different and naturally there is no definite answer to whether using or would be better . in such situations",
    "it is important to realize how complex the game is .",
    "if the game consists of one well - defined type of controllable character , an organization is probably not a good choice .",
    "however , if the game consists of several different characters , all with different possibilities , it may be reasonable at least to consider whether an organization could be useful .",
    "this seems to indicate that using an organization for a bomberman game may not be the best choice . in this specific case",
    "the solution is better than the ; the agents react faster , can more easily adapt to changes and is in general more robust .",
    "an organization can be justified in a game such as bomberman if we include features from the original game that would make the game more complex ( e.g.  power - ups ) .",
    "an will benefit in this case , since it is possible to specify advanced roles and missions in the os that would otherwise be difficult to implement .",
    "[ [ multi - agent - programming - contest ] ] multi - agent programming contest : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the area of multi - agent systems is quite active , which for instance can be seen by the annual multi - agent programming contest . the primary aim of the competition is to `` stimulate research in the area of multi - agent system development and programming ''  @xcite .",
    "this is achieved by developing a scenario of a dynamic environment in which cooperation is the key to success .",
    "different multi - agent systems are competing in the scenario in a set of games to determine their performance .",
    "as illustrated in figure [ fig - results - overview ] the complexity and number of agents in the contest has increased over the years . therefore , while the implementations would not benefit much from an explicit organization in the first scenarios ( where only a few agents where required to solve simple tasks ) , the increased complexity has made this approach a reasonable choice ( in scenarios where more than 10 agents are required to cooperate in order to succeed ) .",
    "the overall complexity of the scenarios in the competition has increased , meaning that it may be easier to implement a better strategy using simply because the complexity is easier handled when the structure of the solution has been made explicit .",
    "by taking both the _ agent - centered _ and _ organization - centered _ approach for implementing the same strategy we have gained insights about both the advantages and disadvantages of each approach .",
    "the focus has been on a single scenario , which means that not all corners of the approaches have been investigated .",
    "even so , the results have made several differences of the approaches clear , differences that in some situations makes one approach highly advantageous compared to the other .",
    "the focus has been on differences between different types of multi - agent systems and in particular the use of two specific tools .",
    "however , it was shown that both types of systems are useful in different situations and that there is no definitive answer to when one system is a better choice than another .",
    "the main reason is the many factors the programmer must consider when choosing between the agent- and organization - oriented approaches .",
    "these factors include the quality of the implementation , the actual tools used and the strategy to be implemented .",
    "while we have been able to discuss the differences and make suggestions for which system is most suitable in different situations , it would be interesting to be able to create systems of both types which exhibit the same behavior in most situations .",
    "this would make it possible to compare the actual performance difference between the systems .",
    "however , since this requires specialized systems , there is a chance that the results would not apply to real - world applications .",
    "the area of multi - agent systems is still somewhat new and is continuously growing . with the addition of the organizational aspects it has been made possible to create even more sophisticated and advanced systems .",
    "this comparison has shown that both approaches have advantages and disadvantages and are well - suited for different situations .    in the end , it is hard to say which approach is better and a decision should be justified by doing some research on the application at hand and the possible tools for creating the system .",
    "there is still much work to be done in the area of organizational multi - agent systems , specifically in the @xmath3  organizational model , but also the principles of ocmas in general .",
    "the tools available makes it possible to implement advanced systems ( both acmas and ocmas ) which are very useful in both research and practical applications and there is no doubt that the area will continue to develop even more efficient and intelligent solutions to research problems and real - world applications .",
    "10    tristan  m. behrens , jrgen dix , jomi hbner , and michael kster . .",
    "http://www.multiagentcontest.org/ , october 2010 .",
    "rafael  h. bordini , jomi  fred hbner , and michael wooldridge . .",
    "john wiley & sons ltd , 2007 .",
    "jacques ferber , olivier gutknecht , and fabien michel . .",
    ", pages 214230 , 2004 .",
    "mahdi hannoun , olivier boissier , jaime  simo sichman , and claudette sayettat . . ,",
    "jomi  fred hbner , jaime  simo sichman , and olivier boissier . .",
    ", 2002 .",
    "jomi  fred hbner , jaime  simo sichman , and olivier boissier . .",
    ", 2005 .",
    "jomi  fred hbner , jaime  simo sichman , and olivier boissier . .",
    ", 2007 .",
    "jomi  fred hbner , jaime  simo sichman , and olivier boissier . .",
    ", 2008 .",
    "stuart russell and peter norvig . .",
    "prentice - hall , 2nd edition , 2003 .",
    "michael wooldridge . .",
    "john wiley & sons ltd , 2nd edition , 2009 .",
    "i thank associate professor jrgen villadsen , dtu informatics , denmark ."
  ],
  "abstract_text": [
    "<S> whereas classical multi - agent systems have the _ agent _ in center , there have recently been a development towards focusing more on the _ organization _ of the system . </S>",
    "<S> this allows the designer to focus on _ what _ the system goals are , without considering _ how _ the goals should be fulfilled . </S>",
    "<S> this paper investigates whether taking this approach has any clear advantages to the classical way of implementing multi - agent systems . </S>",
    "<S> the investigation is done by implementing each type of system in the same environment in order to realize what advantages and disadvantages each approach has . </S>"
  ]
}