{
  "article_text": [
    "domain - specific languages ( dsls ) are languages tailored to specific application domain @xcite .",
    "they offer substantial gains regarding expressiveness and ease of use compared with general - purpose languages ( gpls ) within their domain of application @xcite .",
    "however , dsls are more amenable to changes @xcite since stakeholders requirements frequently change . in order to design and implement dsls more easily ,",
    "we need to develop fully modular , extensible , and reusable language descriptions , whilst some of the descriptions could even be inferred from dsl programs @xcite .",
    "the language designer wants to include new language features incrementally as the programming language evolves .",
    "ideally , a language designer would like to build a language simply by reusing different language definition modules ( language components ) , such as modules for expressions , declarations , etc .",
    ", as well as to extend previous language specifications .",
    "in the case of general software development the use of object - oriented techniques and concepts like encapsulation and inheritance , greatly improves incremental software development , whilst reusability is even further enhanced using aspect - oriented techniques @xcite .",
    "the object - oriented , as well as the aspect - oriented techniques and concepts , have also been integrated into programming language specifications @xcite making new features more easily implemented .",
    "one of such tools , where object - oriented and aspect - oriented concepts have been incorporated , is the lisa tool @xcite .",
    "this paper shows how lisa is used within the incremental development of easytime dsl , which has been developed recently for measuring time at different sports competitions ( e.g. , triathlon , cycling ) @xcite .",
    "easytime dsl has already proved to be successful when used at real sport events ( e.g. , world championship in the double ultra triathlon in 2009 , national ( slovenian ) championship in the time - trials for cycles in 2010 ) , so the requirements are changing quickly .",
    "recent extensions to easytime have included the possibility of classifying competitors into different categories , where the number of laps is different for each category , and the inclusion of competitions where the number of laps can be dynamically determined during a competition ( e.g. , biathlon , where the number of extra laps depends on missed shots ) .",
    "the objective of this paper is to introduce easytime++ dsl , which supports these new extensions , as well as to show how such an extension can be incrementally developed using the introduced lisa tool .",
    "the structure of this paper is as follows : in section  [ sectionrelatedwork ] an overview of the language composition is presented .",
    "section  [ sectioneasytime ] briefly introduces easytime dsl , whilst the core of this paper is section  [ sectionextensions ] , which describes how the extensions in easytime++ have been specified and implemented .",
    "some examples are presented in section  [ sectionexamples ] .",
    "the paper is concluded with section  [ sectionconclusion ] , where a brief overview and word about future work is described .",
    "several kinds of language composition have been identified in the literature @xcite . in their recent paper @xcite ,",
    "erdweg et al . , point out that language composition has obtained little attention , that it is still insufficiently understood , and that the terminology is confusing thus indicating that the research is inadequate , as yet .",
    "erdweg et al .",
    "identified the language composeability not as a property of languages themselves , but as a property of language definition ( e.g. , how language specifications can be composed together ) .",
    "the following types of language composition have been distinguished in @xcite : language extension ( which subsumes also language restriction ) , language unification , self - extension , and extension composition . in * language extension * the specifications of base language @xmath0 are extended with a new language specification fragment @xmath1 , which typically makes little sense when regarded independently from the base language @xmath0 . hence , language @xmath0 is a dominant language , which can be a dsl or a gpl , and serves as a base for other languages",
    ". language extension , as a kind of language composition , is denoted as @xmath2 indicating that the base language @xmath0 has been extended with the language @xmath1 .",
    "the lisa tool supports language extensions when single attribute grammar inheritance @xcite is employed . as is shown in section  [ sectionextensions ] , easytime++ is a language extension over the base language easytime ( easytime @xmath3 easytime++ ) . in * language unification",
    "* the composition of language specifications is not based on the dominance of one language , but is based on equal terms",
    ". the dominance of one language over another does not exist and both language specifications are complete and standalone ( note that in the case of language extension the language specifications for the extended part makes little sense alone ) .",
    "language unification , as a kind of language composition , is denoted as @xmath4 , describing the language composition of languages @xmath5 and @xmath6 using a glue code @xmath7 .",
    "since lisa supports multiple attribute grammar inheritance @xcite , language unification is easily achieved by inheriting both language specifications ( from @xmath5 and @xmath6 ) , where the glue code is specified as a new language specification fragment . in * self - extension",
    "* the language specifications do not change .",
    "the language itself is powerful enough for new extensions to be implemented using macros , function composition , and libraries that provide domain - specific constructs .",
    "this form of language composition is called pure language embedding @xcite .",
    "functional languages are these languages particularly suitable for self - extension .",
    "self - extension , as a kind of language composition , is denoted as @xmath8 indicating that the host language @xmath9 has been self - extended with the embedded language @xmath1 .",
    "the last form of language composition is * extension composition * , which describes how language specifications also support the combination of various language compositions .",
    "that is showing how different compositions can work together .",
    "this kind of language composition can also be described as high - order language composition .",
    "language unification allows for such higher - order composition per se ( e.g. , @xmath10 ) . whilst some other useful examples of higher - order language composition like @xmath11 , and",
    "@xmath12 can not always be easily achieved .",
    "extension compositions involving language extension and language unification can also be easily achieved in the lisa tool .",
    "in addition to lisa , which has been in existence since 1999 , there are also other similar tools ( e.g. , phobos  @xcite , jastadd  @xcite , silver  @xcite , xmf  @xcite , tatoo  @xcite , monticore  @xcite , jayco  @xcite , uuag @xcite ) that enable various language compositions .",
    "note , that the most well - known tools for syntax and the semantic specification of programming languages , lex and yacc @xcite , do nt support language composition per se . for example , language extension is possible by manually changing base language specifications @xmath0 by invasively adding the specification for extended language @xmath1 .",
    "hence , change is done in a non - disciplined manner , thus prohibiting further reuse of specifications . on the other hand",
    ", language composition can be done on top of lex and yacc ( e.g. , @xcite ) . here , it is desirable to briefly mention jastadd @xcite and silver @xcite , since both are based on attribute grammars , as in the lisa case .",
    "jastadd @xcite is centered around object - oriented representation of the abstract syntax tree ( ast ) .",
    "non - terminals act as abstract super classes and productions act as specialized concrete subclasses that specify the syntactic structure , attributes , and semantic rules .",
    "all these elements can be inherited , specialized , and overridden within subclasses .",
    "the idea of aspect - orientation in jastadd is to define each aspect of the language in a separate class and then weave them together at appropriate places .",
    "the jastadd system is a class weaver : it reads all the jastadd modules and weaves the fields and methods into the appropriate classes during the generation of the ast classes .",
    "developers have the possibility of combining various language specifications following the separation of different language aspects amongst different classes .",
    "silver @xcite uses a concept called forwarding to achieve modular language extensions , where the extension construct is translated into semantically equivalent constructs within the host language .",
    "hence , forwarding only allows those new constructs that can be expressed as a combination of existing language constructs .",
    "additional silver features like : with - clause , auto - copying of inherited attributes , collection attributes , pattern matching , and type - safe polymorphic lists , allow for the host language to be extended in a more flexible manner , although still restrictive .",
    "easytime was developed for measuring time during double ultra triathlon in 2009 . at that time",
    ", the organizers of this competition were confronted with the problem of how to measure the times of competitors within three disciplines using a limited number of measuring devices .",
    "besides this limitation , measures needed to be reliable and accurate , especially , because of its long duration . although the measuring time for the triathlon was our first specific task , the goal was to develop a dsl for measuring time for any competition .",
    "a domain analysis was performed @xcite using feature diagrams @xcite with the aim of identifying common and variable concepts , their relations , and structure of particular concepts . in the case of easytime ,",
    "the concept race consists of sub - concepts : events ( e.g. , swimming , cycling , and running ) , control points ( starting and finishing lines , the number of laps ) , the measuring time ( updating time and decrementing laps ) , optional transition area ( difference between the finish and start times ) , and agents ( automatic or manual ) . in the next step , these concepts were mapped to the context - free grammar non - terminals of easytime .",
    "finally , its whole syntax and semantics were developed @xcite .    in order to illustrate the power of easytime ,",
    "lets describe the ironman triathlon , as presented in figure  [ pic : triathlon ] .",
    "this triathlon consists of : 3.8 km swim , 180 km cycling , and a 42 km run .",
    "these disciplines run one after another with two interruptions : in the first , those competitors who have finished with swimming prepare themselves for the cycling , whilst in the second , those competitors who have finished the cycling prepare themselves for running .",
    "both interruptions occur within so - called transition areas .",
    "their times spent within these areas are added to their swimming , cycling , and running times , in order to obtain the total times of specific competitors .",
    "typically , the organizers divide those courses on which they run particular disciplines into laps because of easier management .",
    "as can be seen in figure  [ pic : triathlon ] , competitors need to accomplish 4 laps of swimming , 4 laps of cycling , and 8 laps of running .",
    "these laps represent another demand for the measuring time in such competitions because , besides the intermediate times of each lap , decrementing also needs to be performed . in order to reduce the number of measuring devices , a measuring point ( mp in figure  [ pic : triathlon ] ) at which the intermediate time is measured and the number of laps is decremented , can be incorporated . in other words ,",
    "when the number of laps is zero the last intermediate time becomes the final time of a specific discipline .",
    "this characteristic of the triathlon is put to profitable use by easytime .",
    "in fact , easytime is a dsl that enables the organizers of sporting competitions to adapt measuring systems for various kinds of competitions , reduce the number of measuring devices , and achieve accuracy and reliability .",
    "the easytime program runs on a measuring system and employs a set of agents that control the measuring devices . for measuring time during inronman , as illustrated in figure  [ pic : triathlon ] , the easytime program presented in program  [ alg : prog ]",
    "is used .    1 manual `` man.dat '' ;  //",
    "definition of manual agent 2 auto 192.168.225.100 ;  // definition of automatic agent //",
    "definition of variables var round1 : = 4 ; var inter1 : = 0 ; var swim : = 0 ; var trans1 : = 0 ; var round2 : = 4 ; var inter2 : = 0 ; var bike : = 0 ; var trans2 : = 0 ; var round3 : = 8 ; var inter3 : = 0 ; var run : = 0 ; // definition of measuring place 1 mp[1 ] @xmath13 agnt[1 ] \\",
    "{  ( true ) @xmath13 upd inter1 ;  ( true ) @xmath13 dec round1 ;  ( round1 = = 0 ) @xmath13 upd swim ; } // definition of measuring place 2 mp[2 ] @xmath13 agnt[1 ] \\ {  ( true ) @xmath13 upd trans1 ; } // definition of measuring place 3 mp[3 ] @xmath13 agnt[2 ] \\ {  ( true ) @xmath13 upd inter2 ;  ( true ) @xmath13 dec round2 ;  ( round2 = = 0 ) @xmath13 upd bike ; } // definition of measuring place 4 mp[4 ] @xmath13 agnt[2 ] \\",
    "{  ( true ) @xmath13 upd inter3 ;  ( round3 = = 8) @xmath13 upd trans2 ;  ( true ) @xmath13 dec round3 ;  ( round3 = = 0 ) @xmath13 upd run ; }    at the start of program  [ alg : prog ] , two agents are defined : the former describes a measuring device on which manual measuring time is performed on a portable computer by an operator , whilst the latter denotes a measuring device that automatically tracks an event caused when a competitor crossing the measuring place , based on rfid technology  @xcite .",
    "typically , the automatic measuring place is implemented as a mat that acts as an antenna having two functions : firstly , the antenna induces a passive tag that is born by competitor .",
    "secondly , this induced tag acts as a transmitter that transmits its identification code to a measuring device . the transmitted code is detected by the measuring device as an event .",
    "this event is transmitted to the measuring system and recorded into a database by an agent .",
    "after the agents definition in program  [ alg : prog ] , a declaration of variables follows . for each measuring place ,",
    "two variables are defined in general : an intermediate time interx and a laps counter roundx .",
    "the final achievements of a competitor for specific disciplines are saved within variables swim , bike , and run .    the easytime program is completed by definitions of measuring places mp[@xmath14 , where @xmath15 represents its identification number that must be defined uniquely .",
    "the measuring place represents a physical device that is connected to a measuring device .",
    "the measuring device can support more measuring places simultaneously .",
    "conversely to a measuring place , a control point ( cp in figure  [ pic : triathlon ] ) represents an event from a logical point of view and denotes the specific location on the course , where the referees need to track the time information about competitors . as a matter of fact",
    ", the control points in easytime are directly mapped into variables .",
    "the identification numbers of each agent responsible for transmitting the events is assigned to each measuring place .",
    "for example , manual agent agnt[@xmath16 in line 16 of program  [ alg : prog ] controls the first measuring place .    before recording the event into a database ,",
    "a sequence of statements in curly brackets are interpreted on an abstract machine ( am ) .",
    "these statements are in forms of ( * predicate * ) @xmath13 * operation * , where * operation * denotes a sequence of instructions that are executed when the value of * predicate * returns value _",
    "true_. typically , two instructions are employed in easytime++ : * upd * and * dec*. the former update the value of variable in the database , whilst the latter decrements its value .",
    "although , dsls can be implemented in vastly possible ways @xcite , an appropriate implementation when the end - users are not also the programmers is , a compiler / interpreter approach @xcite .",
    "hence , easytime was implemented using a compiler generator tool called lisa @xcite .",
    "the lisa specifications include lexical , syntax and semantic specifications . whilst classical regular expressions and bnf are used for the first two specifications , the third specifications are based on attribute grammars @xcite .",
    "one of the distinguishing features of a lisa compiler generator is that specifications ( lexical , syntax , and semantics ) can be easily reused and extended .",
    "an overall view of lisa specifications is given in listing  [ tab : lisa - spec ] .",
    ".overall view of lisa specifications [ cols= \" < \" , ]     the first small change was done within the semantic domain * runners * , which represents a database of competitors ( listing  [ tab : semantic - domains ] ) .",
    "the additional components are now * gender * and * category*. along with @xmath17 , @xmath18 , @xmath19 , and @xmath20 , the @xmath21 and @xmath22 regarding competitors have added to the semantic domain * runners*. the second , and the most important change within the semantic domains is how the * state * , which is the mapping from variables to values , has been modelled ( listing  [ tab : semantic - domains ] ) . within easytime ,",
    "the * state * was a simple mapping : * * state**=**var**@xmath13*integer * , however in easytime++ an initial value of an attribute depends on categories , and a variable , called dynamicvar , can also be initialized during a run - time . hence , the * state * is now modelled as : @xmath23    let us describe the * state * using a simple excerpt from easytime++ declarations .",
    "three variables were declared within an easytime++ program ( program  [ alg : alg3a ] ) .",
    "the first variable , @xmath24 specifies that all competitors need to complete 50 laps , hence in a database of competitors the attribute @xmath24 is set at @xmath25 for all competitors .",
    "the second variable , @xmath26 , specifies that , in a case where a competitor belongs to @xmath27 , he / she needs to complete @xmath28 laps , whilst a competitor within @xmath29 only needs @xmath30 laps . in the database of competitors ,",
    "the attribute @xmath26 is initialized according to the category .",
    "for all competitors in the first category this attribute will be initialized to @xmath28 , and for all competitors in the second category to @xmath30 .",
    "the third variable , @xmath31 , is a dynamic variable and its initial value for each competitor will be set during the run - time .",
    "var round1 : = 50 ; var round2 : = \\ { ( category==1 ) @xmath13 20 ,  ( category==2 ) @xmath13 10 } ; dynamicvar penalty ;  // definition of dynamic var .",
    "the * state * in easytime++ is mapping which maps variable names ( e.g. , @xmath24 , @xmath26 , @xmath31 ) into two components .",
    "the first component is itself a mapping from * category * to * integer * ( e.g. , 1@xmath1320 , 2@xmath1310 ) , whilst the second component indicates whether a variable is dynamic or not . to cope with this new model for variables in easytime++ , the following lisa methods are needed ( note that the mapping from * category * to * integer * can be implemented using a hashtable @xcite , see program  [ alg : alg2a ] ) .",
    "since all changes in easytime++ are done in a declaration part the semantic function @xmath32 ( for full description of easytime semantic functions please see @xcite ) , which describes the meanings of the declarations needs to be changed accordingly ( listing  [ tab : meaning - dec ] ) .",
    "method m_var \\ {  class var \\ {  string name ;  hashtable values ;  boolean isdynamic ;  var ( string name , hashtable values ,  boolean isdynamic ) \\ {  this.name = name ;  this.values = values ;  this.isdynamic = isdynamic ;  }  //",
    "java methods are omitted  ...  } } method varenvironment \\ {  import java.util . * ;  public hashtable put ( hashtable env , var avar ) \\ {  env = ( hashtable)env.clone ( ) ;  env.put(avar.getname ( ) , avar ) ;  return env ;  } // java method } //",
    "lisa method    semantic function @xmath32 maps the syntactic construct * dec * , representing the declarations , into its meaning @xmath33 @xmath34 , which is a mapping from * state * to * state*. note , how the first component of * state * is defined in a case where the categories are unspecified ( first equation in listing  [ tab : meaning - dec ] ) , and in a case of dynamic variables ( third equation in listing  [ tab : meaning - dec ] ) .",
    "in the first equation , it is stated that variable @xmath35 is mapped to value @xmath36 regardless of category .",
    "the mapping function @xmath37 is a constant function .",
    "the second equation states that variable @xmath35 is mapped to different values ( e.g. , @xmath38 , @xmath39 ) according to different categories ( e.g. , @xmath40 , @xmath41 ) , whilst in the third equation , the variable @xmath35 is mapped to undefined value @xmath42 regardless of category . in the case of dynamic variables",
    "the second component of @xmath43 is true , otherwise it is false .",
    "the aforementioned changes in formal specifications of easytime++ also require changes in the implementation part .",
    "note that changes are required in the lexical part ( new keywords category and dynamicvar , new separator ) , syntax part ( new syntax rules for declarations ) , as well as in the semantic part ( new semantics for declarations ) .",
    "all the other parts of easytime ( e.g. , agents , measuring places , statements ) @xcite are intact and hence can be completely reused . since easytime is implemented in lisa , which supports attribute grammar inheritance @xcite , and where lexical , syntax and semantic specifications can be inherited , it was natural to extend easytime specifications written in lisa for implementing easytime++ , thus achieving incremental language development .",
    "program  [ alg : alg1a ] shows the lisa specification of easytime++ .",
    "note , how all easytime specifications have been reused ( language easytime++ extends easytime ) . in the inherited specifications it was necessary to override rule @xmath44 , which contained syntactic and semantic specifications for declarations , add some new grammar productions and their semantics ( rule @xmath45 ) , as well as add new attribute @xmath46 of type @xmath47 , which were attached to the non - terminal @xmath48 , and extend regular definitions for @xmath49 and @xmath50 .",
    "overall less than 70 lines of lisa specifications have been newly written to obtain the complete compiler for easytime++ .",
    "note that this is an example of language extension where language specifications fragment ( program  [ alg : alg1a ] ) alone does not make any sense and can not exist without base - language specifications ( for complete easytime specifications in lisa see @xcite ) .",
    "hence , this kind of language composition can be denoted as easytime @xmath3 easytime++ .",
    "language easytime++ extends easytime \\",
    "{ lexicon \\",
    "{  extends separator   ,  extends keyword category | dynamicvar } attributes hashtable * .varvalues ;  rule extends start \\",
    "{  compute \\ { } } rule overrides dec \\",
    "{ +  dec : : = var # i d : = # int ; compute \\ { +  //",
    "category is not specified ; isdynamic = false  dec.outstate = put(dec.instate ,  new var(#id.value ( ) ,  put(new hashtable ( ) , `` 0 '' ,  integer.valueof(#int.value()).intvalue ( ) ) , false ) ) ;  } ;  dec : : = dynamicvar # i d ; compute \\ {  // category can not be specified ; isdynamic = true  dec.outstate = put(dec.instate ,  new var(#id.value ( ) , null , true ) ) ;  } ;  dec : : = var # i d : = \\ { ctgrs } ; compute \\ {  // categories are specified and ca nt be dynamic  dec.outstate = put(dec.instate ,  new var(#id.value ( ) , ctgrs.varvalues , false ) ) ;  } ; } rule categories \\ {  ctgrs : : = ( category = = # int ) @xmath13 # int , ctgrs  compute \\ {   ctgrs[0].varvalues = put(ctgrs[1].varvalues ,  # int[0].value ( ) ,  integer.valueof(#int[1].value()).intvalue ( ) ) ;  } ;  ctgrs : : = ( category = = # int ) @xmath13 # int compute \\ {  ctgrs.varvalues = put(new hashtable ( ) ,  # int[0].value ( ) ,  integer.valueof(#int[1].value()).intvalue ( ) ) ;  } ; }  ...  // lisa methods }",
    "in order to test easytime++ dsl two case - studies were performed :    * cyclo - cross grand - prix , and * biathlon .",
    "the former was experienced in practice , whilst the latter could be taken as proof of concept . in the rest of this section ,",
    "both case - studies are discussed in detail .",
    "this case - study tested the introduction of categories in easytime++ .",
    "cyclo - cross is a relatively new sport that typically takes place in winter and is dedicated to cycle road - riders who are preparing for the new season .",
    "races usually consist of several laps of a short course featuring pavements , wooded trails , grass , steep hills , and obstacles .    in this case - study ,",
    "one lap of 2.5 km was used ( figure  [ pic : cyclo ] ) . according to the number of laps ,",
    "the competitors were divided into three categories , as follows :    * 4 laps : junior men and women up to 15 years old ( u-15 ) , * 6 laps : junior men and women up to 19 years old ( u-19 ) , and * 9 laps : absolute categories ( u-23 , elite , masters ) .    in order to make the competition more interesting",
    ", the organizers allowed all the competitors onto the course simultaneously .",
    "only one measuring device with two measuring places was needed for measuring this competition because the course passed at one location . here ,",
    "the intermediate times of laps were measured and , thereby , decremented the laps counters of specific competitors .",
    "when the laps counter reached zero the finish time of the competitor was reported .",
    "however , how many laps to go depended on the category to which the specific competitor belonged .        the easytime++ program for measuring time in this competition can be seen by program  [ alg : cyclo ] . note that here both measuring places , i.e. , mats , were laid so that the whole length of the finish line was captured . in line with this ,",
    "a competitor can cross either of both mats . as a result ,",
    "the programs for both measuring devices are the same , and work in parallel .    2 auto 192.168.225.100 ;  // definition of agent var bike : = 0 ; var round1 : = \\ { ( category==1 ) @xmath13 4 ,  ( category==2 ) @xmath13 6 , ( category==3 ) @xmath13 9 } ; // definition of measuring place 1 mp[1 ] @xmath13 agnt[2 ] \\ {  ( true ) @xmath13 dec round1 ;  ( round1 = = 0 ) @xmath13 upd bike ; } // definition of measuring place 2 mp[2 ] @xmath13 agnt[2 ] \\ {  ( true ) @xmath13 dec round1 ;  ( round1 = = 0 ) @xmath13 upd bike ; }    in summary , measuring time in cyclo - cross performed well with easytime++ .",
    "although the organizers prepared three different lengths of courses , six different lists of results were obtained according to gender .",
    "fortunately , in our case the gender could be handled by a database system , whilst the easytime++ program was unaware of it .",
    "a biathlon was the second case - study for easytime++ .",
    "biathlon refers specifically to the winter sport that combines cross - country skiing and rifle shooting .",
    "as can be seen from figure  [ pic : biathlon ] , competitors start with skiing .",
    "skiing is interrupted by rifle shooting .",
    "typically , biathlon consists of 4 laps of skiing .",
    "the shooting appears close to the end of a lap .",
    "two positions for competitors are allowed when shooting , i.e. , prone and standing .",
    "interestingly , the number of missed shoots is penalized by the additional number of penalty laps .",
    "note that the time spent within the penalty laps are added to the total time of the competitor .",
    "the time of the penalty lap is typically taken to be between 20 - 30 seconds .",
    "the easytime++ program for measuring time in biathlon can be seen by program  [ alg : biathlon ] .",
    "three measuring devices are needed to cover this competition .",
    "each measuring device realizes one measuring place .",
    "moreover , each measuring place also represents a control point .",
    "in contrast to ironman , in a biathlon time spent in penalty loops is of no interest in the preferred race . here",
    ", only the total time of competitor is important .        1 auto 192.168.225.110 ;  // definition of agent 1 2 auto 192.168.225.100 ;  // definition of agent 2 var round : = 4 ; var run : = 0 ; dynamicvar penalty ;  // definition of dynam.variable // definition of measuring place 1 mp[1 ] @xmath13 agnt[1 ] \\ {  ( true ) @xmath13 upd penalty ; } // definition of measuring place 2 mp[2 ] @xmath13 agnt[2 ] \\ {  ( true ) @xmath13 dec penalty ; } // definition of measuring place 3 mp[3 ] @xmath13 agnt[2 ] \\ {  ( true ) @xmath13 dec round ;  ( round = = 0 ) @xmath13 upd run ; }    in summary , the first device represents the special measuring device for counting hits .",
    "the agent assigned to this device puts the number of missed hits into the database variable penalty , dynamically .",
    "note that this device is treated in easytime like an ordinary measuring device .",
    "the second measuring device is dealt with by counting the penalty laps , whilst the third device measures the final time .",
    "easy language composition is still an open - issue within programming language research . in particular ,",
    "a new young field of software language engineering is of interest regarding engineering principles when constructing new languages , whether general - purpose or domain - specific .",
    "a language designer would like to build a new language simply by composing different components and/or extending previous components .",
    "this paper has presented easytime++ dsl as a language extension of easytime , where the base language specifications written in the lisa compiler generator have been extended with new features , thus enabling the introduction of categories into competitions , and those new competitions where the number of laps is dynamically determined .",
    "the implemented multiple attribute grammar inheritance in lisa enables easy language composition since lexical , syntax , and semantic specifications can be reused and extended .",
    "in such a manner , an incremental language development using lisa has been demonstrated .",
    "the suitability of easytime++ was shown in two case studies : cyclo - cross grand - prix and a biathlon . more extensive experimental work , which would include other types of language compositions and more dsls ,",
    "is also planned in the future .",
    "* t. kosar , n. oliveira , m. mernik , m. j. varanda pereira , m. repinek , d. da cruz , p. r. henriques . * comparing general - purpose and domain - specific languages : an empirical study .",
    "_ computer science and information systems _ , 2010 , 7(2 ) , 247264 .    * t. kosar , m. mernik , j. c. carver .",
    "* program comprehension of domain - specific and general - purpose languages : comparison using a family of experiments .",
    "_ empirical software engineering _ , 2012 , 17(3 ) , 276304 .",
    "* s. erdweg , p. g. giarrusso , t. rendel . * language composition untangled . _ in : proceedings of workshop on language descriptions , tools and applications ( ldta12)_. _ published online at http://www.informatik.uni-marburg.de/@xmath51seba/publications/languagecomposition .",
    "pdf _ , 2012 .              * h. krahn , b. rumpe , s. voelkel . * monticore : modular development of textual domain specific languages . _ in : proceedings of the 30th international conference on software engineering ( sle 2008 ) _ , 2008 , 925926 .",
    "* m. viera , s. d. swierstra , a. middelkoop .",
    "* uuag meets aspectag : how to make attribute grammars first - class .",
    "_ in : proceedings of workshop on language descriptions , tools and applications ( ldta12)_. _ published online at http://www.cs.uu.nl/research/techreps/repo/cs-2011/2011-029.pdf_ , 2012 .",
    "* t. kosar , p. e. martnez lpez , p. a. barrientos , m. mernik . * a preliminary study on various implementation approaches of domain - specific language . _ information and software technology _ , 2008 , 50(5 ) , 390405 ."
  ],
  "abstract_text": [
    "<S> easytime is a domain - specific language ( dsl ) for measuring time during sports competitions . </S>",
    "<S> a distinguishing feature of dsls is that they are much more amenable to change , and easytime is no exception in this regard . </S>",
    "<S> this paper introduces two new easytime features : classifications of competitors into categories , and the inclusion of competitions where the number of laps must be dynamically determined . </S>",
    "<S> it shows how such extensions can be incrementally added into the base - language reusing most of the language specifications . </S>",
    "<S> two case studies are presented showing the suitability of this approach .    _ to cite paper as follows : i. jr . </S>",
    "<S> fister , t. kosar , i. fister , m. mernik , easytime++ : a case study of incremental domain - specific language development . </S>",
    "<S> information technology and control , 42(1 ) , 7785 , 2013 . </S>"
  ]
}