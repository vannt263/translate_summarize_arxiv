{
  "article_text": [
    "facility location problems have been widely studied in the operations research and computer science communities ( see , e.g. ,  @xcite and the survey  @xcite ) , and have a wide range of applications . in its simplest version , _ uncapacitated facility location _ ( ) , we are given a set of facilities or service - providers with opening costs , and a set of clients that require service , and we want to open some facilities and assign clients to open facilities so as to minimize the sum of the facility - opening and client - assignment costs .",
    "an oft - cited prototypical example is that of a company wanting to decide where to locate its warehouses / distribution centers so as to serve its customers in a cost - effective manner .",
    "we consider facility - location problems that abstract settings where facilities are mobile and may be relocated to destinations near the clients in order to serve them more efficiently by reducing the client - assignment costs .",
    "more precisely , we consider the _ mobile facility location _",
    "( ) problem introduced by  @xcite , which generalizes the classical @xmath4-median problem ( see below ) .",
    "we are given a complete graph @xmath8 with costs @xmath9 on the edges , a set @xmath10 of clients with each client @xmath11 having @xmath12 units of demand , and a set @xmath13 of @xmath4 initial facility locations .",
    "we use the term facility @xmath6 to denote the facility whose initial location is @xmath14 .",
    "a solution @xmath15 to moves each facility @xmath6 to a final location @xmath16 ( which could be the same as @xmath6 ) , incurring a _ movement cost _ @xmath17 , and assigns each client @xmath11 to a final location @xmath18 , incurring _ assignment cost _ @xmath19 .",
    "the total cost of @xmath15 is the sum of all the movement costs and assignment costs .",
    "more formally , noting that each client will be assigned to the location nearest to it in @xmath15 , we can express the cost of @xmath15 as @xmath20 where @xmath21 ( for any node @xmath22 ) gives the location in @xmath15 nearest to @xmath22 ( breaking ties arbitrarily ) .",
    "we assume throughout that the edge costs form a metric .",
    "we use the terms nodes and locations interchangeably .",
    "mobile facility location falls into the genre of _ movement problems _ introduced by demaine et al .",
    "@xcite . in these problems , we are given an initial configuration in a weighted graph specified by placing `` pebbles '' on the nodes and/or edges ; the goal is to move the pebbles so as to obtain a desired final configuration while minimizing the maximum , or total , pebble movement .",
    "was introduced by demaine et al . as the movement problem where facility- and client- pebbles are placed respectively at the initial locations of the facilities and clients , and in the final configuration",
    "every client - pebble should be co - located    [ [ our - results . ] ] our results .",
    "+ + + + + + + + + + + +    we give the first _ local - search based _ approximation algorithm for this problem and achieve the best - known approximation guarantee .",
    "our main result is a @xmath2-approximation for this problem for any constant @xmath3 using a simple local - search algorithm .",
    "this improves upon the previous best 8-approximation guarantee for due to friggstad and salavatipour  @xcite , which is based on lp - rounding and is not combinatorial .",
    "the local - search algorithm we consider is quite natural and simple .",
    "observe that given the final locations of the facilities , we can find the minimum - cost way of moving facilities from their initial locations to the final locations by solving a minimum - cost perfect - matching problem ( and the client assignments are determined by the function @xmath23 defined above ) .",
    "thus , we concentrate on determining a good set of final locations . in our local - search algorithm , at each step , we are allowed to swap in and swap out a fixed number ( say @xmath24 ) of locations .",
    "clearly , for any fixed @xmath24 , we can find the best local move efficiently ( since the cost of a set of final locations can be computed in polytime ) .",
    "note that we do not impose any constraints on how the matching between the initial and final locations may change due to a local move , and a local move might entail moving all facilities .",
    "it is important to allow this flexibility , as it is known  @xcite that the local - search procedure that moves , at each step , a constant number of facilities to chosen destinations has an unbounded approximation ratio .",
    "our main contribution is a tight analysis of this local - search algorithm ( section  [ 3apx ] ) . our guarantee _ matches _ ( up to @xmath5 terms ) the best - known approximation guarantee for the @xmath4-median problem .",
    "since there is an approximation - preserving reduction from the @xmath4-median problem to  @xcite  choose arbitrary initial facility locations and give each client a huge demand @xmath25any improvement of our result would imply an analogous improvement for the @xmath4-median problem .",
    "( in this respect , our result is a noteworthy exception to the prevalent state of affairs for various other generalizations of and @xmath4-median  e.g .",
    ", the data placement problem  @xcite , \\{matroid- , red - blue- } median  @xcite , @xmath4-facility - location  @xcite  where the best approximation ratio for the problem is worse by a noticeable factor ( compared to or @xmath4-median ) ; @xcite is another exception . )",
    "furthermore , _ our analysis is tight _ ( up to @xmath5 factors ) because by suitably setting @xmath25 in the reduction of  @xcite , we can ensure that our local - search algorithm for coincides with the local - search algorithm for @xmath4-median in  @xcite which has a tight approximation ratio of 3 .    we also consider a weighted generalization of the problem ( section  [ extn ] ) , wherein each facility @xmath6 has a weight @xmath7 indicating the cost incurred per - unit distance moved and the cost for moving @xmath6 to @xmath26 is @xmath27 .",
    "( this can be used to model , for example , the setting where different facilities move at different speeds . )",
    "our analysis is versatile and extends to this weighted generalization to yield the same performance guarantee . for the further generalization of the problem , where the facility - movement costs may be arbitrary and unrelated to the client - assignment costs ( for which a 9-approximation can be obtained via lp - rounding ; see `` related work '' ) , we show that local search based on multiple swaps has a bad approximation ratio ( section  [ locgap ] ) .",
    "the analysis leading to the approximation ratio of 3 ( as also the simpler analysis in section  [ 5apx ] yielding a 5-approximation ) crucially exploits the fact that we may swap multiple locations in a local - search move .",
    "it is natural to wonder then if one can prove any performance guarantees for the local - search algorithm where we may only swap in and swap out a single location in a local move .",
    "( naturally , the single - swap algorithm is easier to implement and thus may be more practical ) . in section  [ oneswap ]",
    ", we analyze this single - swap algorithm and prove that it also has a constant approximation ratio .",
    "[ [ our - techniques . ] ] our techniques .",
    "+ + + + + + + + + + + + + + +    the analysis of our local - search procedure requires various novel ideas . as is common in the analysis of local - search algorithms",
    ", we identify a set of test swaps and use local optimality to generate suitable inequalities from these test swaps , which when combined yield the stated performance guarantee .",
    "one of the difficulties involved in adapting standard local - search ideas to is the following artifact : in , the cost of `` opening '' a set @xmath15 of locations is the cost of the min - cost perfect matching of @xmath28 to @xmath15 , which , unlike other facility - location problems , is a highly non - additive function of @xmath15 ( and as mentioned above , we need to allow for the matching from @xmath28 to @xmath15 to change in non - local ways ) . in most facility - location problems with opening costs",
    "for which local search is known to work , we may always swap in a facility used by the global optimum ( by possibly swapping out another facility ) and easily bound the resulting change in _ facility cost _ , and the main consideration is to decide how to reassign clients following the swap in a cost - effective way ; in we do not have this flexibility and need to carefully choose how to swap facilities so as to ensure that there is a good matching of the facilities to their new destinations after a swap _ and _ there is a frugal reassignment of clients .",
    "this leads us to consider long relocation paths to re - match facilities to their new destinations after a swap , which are of the form @xmath29 , where @xmath26 and @xmath30 are the locations that facility @xmath6 is moved to in the local and global optimum , @xmath15 and @xmath31 , respectively , and @xmath32 is the @xmath15-location closest to @xmath30 . by considering a swap move involving the start and end locations of such a path @xmath33 ,",
    "we can obtain a bound on the movement cost of all facilities @xmath34 where @xmath26 is the start of the path or @xmath30 serves a large number of clients . to account for the remaining facilities , we break up @xmath33 into suitable intervals , each containing a constant number of unaccounted locations which then participate in a multi - location swap .",
    "this _ interval - swap _ move does not at first appear to be useful since we can only bound the cost - change due to this move in terms of a significant multiple of ( a portion of ) the cost of the local optimum !",
    "one of the novelties of our analysis is to show how we can _ amortize _ the cost of such expensive terms and make their contribution negligible by considering multiple different ways of covering @xmath33 with intervals and averaging the inequalities obtained for these interval swaps .",
    "these ideas lead to the proof of an approximation ratio of 5 for the local - search algorithm ( section  [ 5apx ] ) .    the tighter analysis leading to the 3-approximation guarantee ( section  [ 3apx ] ) features another noteworthy idea , namely that of using `` recursion '' ( up to bounded depth ) to identify a suitable collection of test swaps .",
    "we consider the tree - like structure created by the paths used in the 5-approximation analysis , and ( loosely speaking ) view this as a recursion tree , using which we spawn off interval - swap moves by exploring this tree to a constant depth . to our knowledge",
    ", we do not know of any analysis of a local - search algorithm that employs the idea of recursion to generate the set of test local moves ( used to generate the inequalities that yield the desired performance guarantee ) .",
    "we believe that this technique is a notable contribution to the analysis of local - search algorithms that is of independent interest and will find further application .    [ [ related - work . ] ] related work .",
    "+ + + + + + + + + + + + +    as mentioned earlier , was introduced by demaine et al .",
    "@xcite in the context of movement problems .",
    "friggstad and salavatipour  @xcite designed the first approximation algorithm for .",
    "they gave an 8-approximation algorithm based on lp rounding by building upon the lp - rounding algorithm of charikar et al .",
    "@xcite for the @xmath4-median problem ; this algorithm works only however for the unweighted case .",
    "they also observed that there is an approximation - preserving reduction from @xmath4-median to .",
    "we recently learned that halper  @xcite proposed the same local - search algorithm that we analyze .",
    "his work focuses on experimental results and leaves open the question of obtaining theoretical guarantees about the performance of local search .",
    "chakrabarty and swamy  @xcite observed that , even with arbitrary movement costs is a special case of the matroid median problem  @xcite .",
    "thus , the approximation algorithms devised for matroid median independently by  @xcite and  @xcite yield an 8-approximation algorithm for with arbitrary movement costs .",
    "there is a wealth of literature on approximation algorithms for ( metric ) uncapacitated and capacitated facility location ( and ) , the @xmath4-median problem , and their variants ; see  @xcite for a survey on . whereas constant - factor approximation algorithms for and @xmath4-median can be obtained via a variety of techniques such as lp - rounding  @xcite , primal - dual methods  @xcite , local search  @xcite , all known @xmath35-approximation algorithms for ( in its full generality ) are based on local search  @xcite .",
    "we now briefly survey the work on local - search algorithms for facility - location problems .    starting with the work of  @xcite ,",
    "local - search techniques have been utilized to devise @xmath35-approximation algorithms for various facility - location problems .",
    "korupolu , plaxton , and rajaraman  @xcite devised @xmath35-approximation for , and with uniform capacities , and @xmath4-median ( with a blow - up in @xmath4 ) .",
    "charikar and guha  @xcite , and arya et al .",
    "@xcite both obtained a @xmath36-approximation for .",
    "the first constant - factor approximation for was obtained by pl , tardos , and wexler  @xcite , and after some improvements , the current - best approximation ratio now stands at @xmath37  @xcite . for the special case of uniform capacities ,",
    "the analysis in  @xcite was refined by  @xcite , and aggarwal et al .",
    "@xcite obtain the current - best 3-approximation .",
    "arya et al .",
    "@xcite devised a @xmath38-approximation algorithm for @xmath4-median , which was also the first constant - factor approximation algorithm for this problem based on local search .",
    "gupta and tangwongsan  @xcite ( among other results ) simplified the analysis in  @xcite .",
    "we build upon some of their ideas in our analysis .",
    "local - search algorithms with constant approximation ratios have also been devised for various variants of the above three canonical problems .",
    "mahdian and pl  @xcite , and svitkina and tardos  @xcite consider settings where the opening cost of a facility is a function of the set of clients served by it . in  @xcite",
    ", this cost is a non - decreasing function of the number of clients , and in  @xcite this cost arises from a certain tree defined on the client set .",
    "devanur et al .",
    "@xcite and  @xcite consider @xmath4-facility location , which is similar to @xmath4-median except that facilities also have opening costs .",
    "hajiaghayi et al .",
    "@xcite consider a special case of the matroid median problem that they call the red - blue median problem .",
    "most recently , @xcite considered a problem that they call the @xmath4-median forest problem , which generalizes @xmath4-median , and obtained a @xmath38-approximation algorithm .",
    "as mentioned earlier , to compute a solution to , we only need to determine the set of final locations of the facilities , since we can then efficiently compute the best movement of facilities from their initial to final locations , and the client assignments .",
    "this motivates the following local - search operation .",
    "given a current set @xmath15 of @xmath39 locations , we can move to any other set @xmath40 of @xmath4 locations such that @xmath41 , where @xmath24 is some fixed value .",
    "we denote this move by @xmath42 .",
    "the local - search algorithm starts with an arbitrary set of @xmath4 final locations . at each iteration",
    ", we choose the local - search move that yields the largest reduction in total cost and update our final - location set accordingly ; if no cost - improving move exists , then we terminate .",
    "( to obtain polynomial running time , as is standard , we modify the above procedure so that we choose a local - search move only if the cost - reduction is at least @xmath43 . )",
    "[ sec:5appx ] we now analyze the above local - search algorithm and show that it is a @xmath44-approximation algorithm . for notational simplicity , we assume that the local - search algorithm terminates at a local optimum ; the modification to ensure polynomial running time degrades the approximation by at most a @xmath45-factor ( see also remark  [ polyremk ] ) .",
    "[ 5apxthm ] let @xmath46 and @xmath47 denote respectively the movement and assignment cost of an optimal solution .",
    "the total cost of any local optimum using at most @xmath24 swaps is at most @xmath48 .",
    "although this is not the tightest guarantee that we obtain , we present this analysis first since it introduces many of the ideas that we build upon in section  [ 3apx ] to prove a tight approximation guarantee of @xmath49 for the local - search algorithm . for notational simplicity , we assume that all @xmath12s are 1 .",
    "all our analyses carry over trivially to the case of non - unit ( integer ) demands since we can think of a client @xmath11 having @xmath12 demand as @xmath12 co - located unit - demand clients .    [ [ notation - and - preliminaries . ] ] notation and preliminaries .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + +    we use @xmath50 to denote the local optimum , where facility @xmath6 is moved to final location @xmath51 .",
    "we use @xmath52 to denote the ( globally ) optimal solution , where again facility @xmath6 is moved to @xmath30 . throughout",
    ", we use @xmath53 to index locations in @xmath15 , and @xmath54 to index locations in @xmath31 . recall that , for a node @xmath22",
    ", @xmath55 is the location in @xmath15 nearest to @xmath22 .",
    "similarly , we define @xmath56 to be the location in @xmath31 nearest to @xmath22 . for notational similarity with facility location problems , we denote @xmath17 by @xmath57 , and @xmath58 by @xmath59 .",
    "( thus , @xmath57 and @xmath59 are the movement costs of @xmath6 in @xmath15 and @xmath31 respectively . ) also , we abbreviate @xmath60 to @xmath61 , and @xmath62 to @xmath63 .",
    "thus , @xmath61 and @xmath63 are the assignment costs of @xmath11 in the local and global optimum respectively .",
    "( so @xmath64 . )",
    "let @xmath65 be the set of clients assigned to the location @xmath18 , and @xmath66 .",
    "for a set @xmath67 , we define @xmath68 ; we define @xmath69 for @xmath70 similarly .",
    "define @xmath71 .",
    "we say that @xmath53 _ captures _ all the locations in @xmath72 .",
    "the following basic lemma will be used repeatedly .",
    "[ reasgn ] for any client @xmath11 , we have @xmath73 .",
    "let @xmath74 .",
    "the lemma clearly holds if @xmath75 .",
    "otherwise , @xmath76 where the second inequality follows since @xmath77 is the closest location to @xmath54 in @xmath15 .    to prove the approximation ratio",
    ", we will specify a set of local - search moves for the local optimum , and use the fact that none of these moves improve the cost to obtain some inequalities , which will together yield a bound on the cost of the local optimum .",
    "we describe these moves by using the following digraph .",
    "consider the digraph @xmath78 .",
    "we decompose @xmath79 into a collection of node - disjoint ( simple ) paths @xmath80 and cycles @xmath81 as follows .",
    "repeatedly , while there is a cycle @xmath82 in our current digraph , we add @xmath82 to @xmath81 , remove all the nodes of @xmath82 and recurse on the remaining digraph . after this step , a node @xmath22 in the remaining digraph , which is acyclic , has : exactly one outgoing arc if @xmath83 ; exactly one incoming and one outgoing arc if @xmath84 ; and exactly one incoming , and at most one outgoing arc if @xmath85 .",
    "now we repeatedly choose a node @xmath83 with no incoming arcs , include the maximal path @xmath86 starting at @xmath22 in @xmath80 , remove all nodes of @xmath86 and recurse on the remaining digraph .",
    "thus , each triple @xmath87 is on a unique path or cycle in @xmath88 .",
    "define @xmath89 to be @xmath90 such that @xmath91 is an arc in @xmath88 ; if @xmath53 has no incoming arc in @xmath88 , then let @xmath92 .    we will use @xmath80 and @xmath81 to define our swaps . for a path @xmath93 ,",
    "define @xmath94 to be @xmath95 and @xmath96 to be @xmath97 .",
    "notice that @xmath98 . for",
    "each @xmath18 , let @xmath99 , @xmath100 , and @xmath101 .",
    "note that latexmath:[$| { \\ensuremath{\\mathcal p}}_c(s ) | =    @xmath18 with @xmath103 . for a set @xmath67 ,",
    "define @xmath104 .",
    "a basic building block in our analysis , involves a _ shift _ along an @xmath105 sub - path @xmath33 of some path or cycle in @xmath88 .",
    "this means that we swap out @xmath53 and swap in @xmath54 .",
    "we bound the cost of the matching between @xmath28 and @xmath106 by moving each initial location @xmath107 to @xmath108 and moving @xmath109 to @xmath110 .",
    "thus , we obtain the following simple bound on the increase in movement cost due to this operation : @xmath111 the last inequality uses the fact that @xmath112 for all @xmath6 . for a path @xmath113",
    ", we use @xmath114 as a shorthand for @xmath115 .",
    "we now describe the local moves used in the analysis .",
    "we define a set of swaps such that each @xmath90 is swapped in to an extent of at least one , and at most two .",
    "we classify each location in @xmath15 as one of three types .",
    "define @xmath116 .",
    "we assume that @xmath117 .",
    "@xmath118=0.5ex = 0ex    @xmath119 : locations @xmath120 with @xmath121 .",
    "@xmath122 : locations @xmath123 with @xmath124 or @xmath125 .",
    "@xmath126 : locations @xmath120 with @xmath127 and @xmath128 .    also define @xmath129 ( so @xmath130 iff @xmath131 and @xmath132 ) .    to gain some intuition , notice that it is easy to generate a suitable inequality for a location @xmath133",
    ": we can `` delete '' @xmath53 ( i.e. , if @xmath134 , then do @xmath135 ) and reassign each @xmath136 to @xmath137 ( i.e. , the location in @xmath15 closest to the location serving @xmath11 in @xmath31 ) .",
    "the cost increase due to this reassignment is at most @xmath138 , and so this yields the inequality @xmath139 .",
    "( we do not actually do this since we take care of the @xmath119-locations along with the @xmath122-locations . )",
    "we can also generate a suitable inequality for a location @xmath140 ( see lemma  [ s2lem ] ) since we can swap in @xmath72 and swap out @xmath141 .",
    "the cost increase by this move can be bounded by @xmath142 and @xmath143 , and the latter quantity can be charged to @xmath144 ; our definition of @xmath126 is tailored precisely so as to enable this latter charging argument . generating inequalities for the @xmath122-locations is more involved , and requires another building block that we call an interval swap ( this will also take care of the @xmath119-locations ) , which we define after proving lemma  [ s2lem ] .",
    "we start out by proving a simple bound that one can obtain using a cycle in @xmath81 .",
    "[ cycleswap ] for any cycle @xmath145 , we have @xmath146 .",
    "consider the following matching of @xmath147 to @xmath148 : we match @xmath6 to @xmath149 .",
    "the cost of the resulting new matching is @xmath150 which should at least @xmath151 since the latter is the min - cost way of matching @xmath28 to @xmath15 .",
    "so we obtain @xmath152 .",
    "[ s2lem ] let @xmath140 and @xmath153 , and consider @xmath154 .",
    "we have @xmath155    we can view this multi - location swap as doing @xmath156 for each @xmath157 and @xmath158 simultaneously .",
    "( notice that no path @xmath157 contains @xmath53 , since @xmath159 . ) for each @xmath156 the movement - cost increase is bounded by @xmath160 .",
    "for @xmath158 we move the facility @xmath6 , where @xmath134 , to @xmath54 , so the increase in movement cost is at most @xmath161 for every @xmath162 .",
    "so since @xmath163 , we have @xmath164 .",
    "thus , the increase in total movement cost is at most    we upper bound the change in assignment cost by reassigning the clients in @xmath165 as follows .",
    "we reassign each @xmath166 to @xmath54 .",
    "each @xmath167 is assigned to @xmath168 , if @xmath169 , and otherwise to @xmath170 .",
    "note that @xmath171 : @xmath172 since @xmath173 , and @xmath174 since @xmath175 .",
    "the change in assignment cost for each such client @xmath11 is at most @xmath176 by lemma  [ reasgn ] .",
    "thus the change in total assignment cost is at most @xmath177 .",
    "combining this with the bound on the movement - cost change proves the lemma .",
    "we now define a key ingredient of our analysis , called an _ interval - swap _ operation , that is used to bound the movement cost of the @xmath122- and @xmath119-locations and the assignment cost of the clients they serve .",
    "( we build upon this in section  [ 3apx ] to give a tighter analysis proving a 3-approximation . )",
    "let @xmath178 be a subset of at most @xmath179 locations on a path or cycle @xmath33 in @xmath180 , where @xmath181 is the next location in @xmath182 after @xmath183 .",
    "let @xmath184 where @xmath185 for @xmath186 and @xmath187 is an arbitrary location that appears after @xmath188 ( and before @xmath189 ) on the corresponding path or cycle .",
    "consider each @xmath183 .",
    "if @xmath190 , choose a _ random _ path @xmath191 with probability @xmath192 , and set @xmath193 and @xmath194 .",
    "if @xmath195 , set @xmath196 , and @xmath197 . set @xmath198 and @xmath199 .",
    "note that @xmath200 since @xmath201 for every @xmath202 .",
    "notice that @xmath203 is a random set , but @xmath204 is deterministic . to avoid cumbersome notation",
    ", we use @xmath205 to refer to the distribution of swap - moves that results by the random choices above , and call this the _ interval swap corresponding to @xmath40 and @xmath206_. we bound the expected change in cost due to this move below . let @xmath207 be the indicator function that is 1 if @xmath130 and 0 otherwise .",
    "[ s1lem ] let @xmath208 and @xmath206 be as given above .",
    "let @xmath209 , where @xmath210 and @xmath211 if @xmath212 .",
    "consider the interval swap @xmath213 corresponding to @xmath40 and @xmath206 , as defined above .",
    "we have @xmath214}}\\ \\leq\\ \\sum_{q=1}^{r } { \\ensuremath{\\mathsf{shift}}}(s'_q , o'_q)+\\sum_{{p\\in{\\ensuremath{\\mathcal p}}_c(s ' ) , i\\in p}}2f^*_i   + \\sum_{j\\in d^*(o ' ) } ( c^*_j - c_j ) \\hspace*{-4ex } \\\\",
    "& + \\sum_{j\\in d\\left(t(s'\\cap s_3)\\cup ( s'\\cap s_3)\\right ) } 2c^*_j + \\sum_{j\\in d\\left(t(s'{\\ensuremath{\\setminus}}s_3)\\right ) } \\tfrac{2c^*_j}{t } + { \\ensuremath{\\mathbf{1}}}(s'_1)\\sum_{j\\in d^*(o'_0 ) } ( f^*_{{\\ensuremath{\\hat i}}}+f_{{\\ensuremath{\\hat i}}}+c^*_j ) .",
    "\\end{split } \\label{t3}\\ ] ]    let @xmath33 be the path in @xmath80 or cycle in @xmath81 such that @xmath215 .",
    "we first bound the increase in movement cost .",
    "the interval swap can be viewed as a collection of simultaneous @xmath216 moves .",
    "if @xmath193 for a random path @xmath217 , the movement - cost increase can be broken into two parts .",
    "we do a shift along @xmath86 , but move the last initial location on @xmath86 to @xmath183 , and then do shift on @xmath33 from @xmath183 to @xmath218 .",
    "so the expected movement - cost change is at most @xmath219 which is at most @xmath220 .",
    "similarly , if @xmath195 , we can break the movement - cost increase into @xmath160 for all @xmath191 and @xmath221 .",
    "thus , the total increase in movement cost is at most @xmath222    next , we bound the change in assignment cost by reassigning clients in @xmath223 as follows .",
    "we assign each client @xmath224 to @xmath168 . if @xmath225 , then @xmath226 . for every client @xmath227 , observe that either @xmath169 or @xmath228 . to see this ,",
    "let @xmath229 and @xmath230 .",
    "if @xmath231 then @xmath232 ; also @xmath233 , and so @xmath234 . so we assign @xmath11 to @xmath168 if @xmath169 and to @xmath137 otherwise ; the change in assignment cost of @xmath11 is at most @xmath176 ( lemma  [ reasgn ] ) .",
    "now suppose @xmath235 , so @xmath236 .",
    "for each @xmath237 ,",
    "we again have @xmath169 or @xmath228 , and we assign @xmath11 to @xmath168 if @xmath169 and to @xmath137 otherwise . we assign every @xmath238 to @xmath239 ( recall that @xmath240 ) , and overestimate the resulting change in assignment cost by @xmath241 . finally , note that we reassign a client @xmath242 with probability at most @xmath243 ( since @xmath244 with probability at most @xmath243 ) .",
    "so taking into account all cases , we can bound the change in total assignment cost by @xmath245 in , we are double - counting clients in @xmath246 .",
    "we are also overestimating the change in assignment cost of a client @xmath247 since we include both the @xmath248 term , and the @xmath176 or @xmath249 terms . adding and yields the lemma .    notice that lemma  [ s2lem ] immediately translates to a bound on the assignment cost of the clients in @xmath250 for @xmath140 .",
    "in contrast , it is quite unclear how lemma  [ s1lem ] may be useful , since the expression @xmath251 in the rhs of may be as large as @xmath252 ( but no more since @xmath253 if @xmath254 ) and it is unclear how to cancel the contribution of @xmath255 on the rhs .",
    "one of the novelties of our analysis is that we show how to _ amortize _ such expensive terms and make their contribution negligible by considering multiple interval swaps .",
    "we cover each path or cycle @xmath33 in @xmath179 different ways using intervals comprising consecutive locations from @xmath256 .",
    "we then argue that averaging , over these @xmath179 covering ways , the inequalities obtained from the corresponding interval swaps yields ( among other things ) a good bound on the movement - cost of the @xmath257-locations on @xmath33 and the assignment cost of the clients they serve .",
    "[ corbigi ] let @xmath258 , @xmath259 , where @xmath181 is the next @xmath122-location on @xmath33 after @xmath183 , and @xmath260 .",
    "let @xmath261 if @xmath262 and @xmath263 otherwise . for @xmath264 , @xmath265",
    "we first define formally an interval of ( at most ) @xmath179 consecutive @xmath257 locations along @xmath33 . as before , let @xmath266 for @xmath202 . for a path @xmath33 ,",
    "define @xmath267 for @xmath268 and @xmath269 for @xmath270 . also define @xmath271 for @xmath268 and @xmath272 for @xmath273 .",
    "if @xmath33 is a cycle , we let our indices wrap around and be @xmath274 , i.e. , @xmath275 for all @xmath276 ( so @xmath277 ) .    for @xmath278 ,",
    "define @xmath279 to be an interval of length at most @xmath179 on @xmath33 .",
    "define @xmath280 .",
    "note that we have @xmath281 if @xmath33 is a path , and @xmath282 if @xmath33 is a cycle .",
    "consider the collection of intervals , @xmath283 .",
    "for each @xmath284 , where @xmath285 , we consider the interval swap @xmath286 corresponding to @xmath284 .",
    "we add the inequalities @xmath287 for all such @xmath288 .",
    "since each @xmath289 participates in exactly @xmath179 such inequalities , and each @xmath290 is the start of only the interval @xmath291 , we obtain the following .",
    "@xmath292    notice that the @xmath15-locations other than @xmath183 on the @xmath293 sub - paths of @xmath33 lie in @xmath126 , and for each @xmath6 such that @xmath294 , we have @xmath295 .",
    "thus , using , we have @xmath296 since @xmath297 means that @xmath298 , and so @xmath299 , we have @xmath300    incorporating and in , and simplifying yields the desired inequality .    for a path or cycle @xmath33 where @xmath301",
    ", we obtain an inequality similar to .",
    "since we can now cover @xmath33 with a single interval , we never have a client @xmath11 such that none of @xmath302 are in our new set of final locations .",
    "so the resulting inequality does not have any @xmath303 terms .",
    "[ corsmalli ] let @xmath258 , @xmath259 , where @xmath181 is the next @xmath122-location on @xmath33 after @xmath183 , and @xmath260 .",
    "let @xmath261 if @xmath262 and @xmath263 otherwise . for @xmath304 , @xmath305",
    "the proof is similar to that of lemma  [ corbigi ] , except that since we can cover @xmath33 with a single interval , we only need to consider a single ( multi - location ) swap .",
    "we consider two cases for clarity .    .",
    "= 0.5ex = 0.5ex    * @xmath33 is a path , or @xmath306 . * as before ,",
    "let @xmath266 for @xmath202 .",
    "if @xmath33 is a path , define @xmath307 .",
    "if @xmath33 is a cycle , we again set @xmath275 for all @xmath276 .",
    "consider the interval swap @xmath308 corresponding to @xmath309 .",
    "the inequality generated by this is similar to except that we do not have any @xmath310 terms since for client @xmath311 , we always have that either @xmath169 or @xmath228 .",
    "thus , translates to the following .",
    "@xmath312 substituting @xmath313 as in yields the stated inequality .",
    "* @xmath33 is a cycle with @xmath314 . * here , lemma  [ cycleswap ] yields @xmath315 ( which is the special case of the earlier inequality with @xmath316 ) .",
    "theorem  [ 5apxthm ] we consider the following set of swaps .    a. = 0ex = 0.5ex    for every @xmath140 , the move @xmath317 .    for every path or cycle @xmath33 with @xmath318 , the @xmath319-weighted interval swaps as defined in lemma  [ corbigi ] .",
    "for every path or cycle @xmath33 with @xmath320 , the interval swap defined in lemma  [ corsmalli ] .",
    "notice that every location @xmath90 is swapped in to an extent of at least 1 and at most 2 .",
    "( by `` extent '' we mean the total weight of the inequalities involving @xmath54 . ) to see this , suppose first @xmath321 for some path @xmath33 , then @xmath54 is involved to an extent of 1 in the interval swaps for @xmath33 in a2 or a3 . in this case",
    ", we say that the interval swap for @xmath33 is _ responsible _ for @xmath54 . additionally , if @xmath322 , then @xmath54 belongs to the multi - swap for @xmath53 in a1 , else if @xmath130 then @xmath54 is part of the interval swap for the path / cycle containing @xmath53 in a2 or a3 .",
    "now suppose @xmath153 .",
    "if @xmath140 , then @xmath54 is included in the multi - swap for @xmath53 in a1 .",
    "we say that this multi - swap is responsible for @xmath54 .",
    "if @xmath323 , then @xmath54 is included in the interval swap for the path / cycle containing @xmath53 in a2 or a3 , and we say that this interval swap is responsible for @xmath54 .",
    "consider the compound inequality obtained by summing , , and corresponding to the moves considered in a1 , a2 , and a3 respectively .",
    "the lhs of this inequality is 0 .",
    "we now need to do some bookkeeping to bound the coefficients of the @xmath324 terms on the rhs .",
    "we ignore @xmath5 coefficients like @xmath325 in this bookkeeping , since for a given @xmath326 term , such coefficients appear in only a constant number of inequalities , so they have an @xmath5 effect overall .",
    "let @xmath327 and @xmath82 denote respectively the movement- and assignment- cost of the local optimum .",
    "* contribution from the @xmath63 and @xmath61 terms .",
    "* first , observe that for each @xmath90 , we have labeled exactly one move involving @xmath54 as being responsible for it .",
    "consider a client @xmath328 .",
    "observe that @xmath63 or @xmath61 terms appear ( with a @xmath329-coefficient ) in an inequality generated by a move if ( i ) @xmath11 is reassigned because the move is responsible for @xmath54 ; or ( ii ) @xmath53 is swapped out ( to an extent of 1 ) by the move ( so this excludes the case where @xmath330 and the move is the interval swap for the path containing @xmath77 ) .",
    "if ( i ) applies , then the inequality generates the term @xmath331 .",
    "if ( ii ) applies then the term @xmath176 appears in the inequality .",
    "finally , note that there are at most two inequalities for which ( ii ) applies :    ",
    "= 0ex = 0ex    if @xmath332 , then ( ii ) applies for the interval - swap move for @xmath33 .",
    "if @xmath333 , then ( ii ) again applies , for the multi - swap move for @xmath77 if @xmath334 , or for the interval swap for the path containing @xmath77 if @xmath335 .",
    "if @xmath336 , then ( ii ) applies for the interval swap for the path containing @xmath53 .    if @xmath140 , then ( ii ) applies for the multi - swap move for @xmath53 .",
    "so overall , we get a @xmath337 contribution to the rhs , the bottleneck being the two inequalities for which ( ii ) applies when @xmath338 and @xmath339 .",
    "* contribution from the @xmath59 and @xmath57 terms . * for every @xmath14 , the expression @xmath340 is counted once in the rhs of the inequality or for the unique path or cycle @xmath33 containing @xmath6 .",
    "the total contribution of all these terms is therefore , @xmath341 .",
    "the remaining contribution comes from expressions of the form @xmath342 on the rhs of , , and .",
    "the paths @xmath86 involved in these expressions come from @xmath343 .",
    "therefore , the total contribution of these terms is at most @xmath344 .",
    "thus , we obtain the compound inequality @xmath345 where the @xmath5 terms are @xmath346 .",
    "this shows that @xmath347 .",
    "[ polyremk ] a subtle point to note is that in the above analysis : ( 1 ) we consider only a polynomial number of swap moves ( since there are at most @xmath348 swap moves available at any point ) , and ( 2 ) we place a constant weight ( of at most 1 ) on the inequality obtained from any given swap move ( when we take the weighted sum of the inequalities obtained from the various swap moves ) .",
    "this is relevant because we can only ensure in polynomial time that we terminate at an approximate local optimum .",
    "more precisely , for any polynomial @xmath349 and an @xmath350 , we obtain in polynomial time a solution with cost @xmath351 such that the change in cost due to any local move is at least @xmath352 ( instead of 0 ) . but",
    "this means that the lhs of is now @xmath353 , where @xmath354 is the total weight placed on the inequalities generated from the various swap moves whose suitable linear combination yields .",
    "therefore , since @xmath355 , this only results in a @xmath45-loss in approximation factor .",
    "in this section , we improve the analysis from section [ sec:5appx ] . specifically , we prove the following theorem .",
    "[ thm:3appx ] the cost of a locally - optimal solution using @xmath24 swaps is at most @xmath356 times the optimum solution cost .    to gain some intuition behind this tighter analysis , note",
    "that the _ only _ reason we lost a factor of 5 in the previous analysis was because there could be locations @xmath332 that are swapped out to an extent of 2 ; hence , there could be clients @xmath136 for which we `` pay '' @xmath176 each time @xmath53 is swapped out , and also pay an additional @xmath357 term when @xmath168 is swapped in . to improve the analysis , we will consider a set of test swaps that swap out each location in @xmath15 to an extent of @xmath358 .",
    "the aforementioned bad case happens only when @xmath333 , because when we close ( i.e. , swap out ) @xmath77 as part of an interval swap or a multi - swap , we open ( i.e. , swap in ) all the locations in @xmath359 , and we achieve this via path swaps ( i.e. , @xmath360 moves ) along paths in @xmath361 that swap out locations in @xmath362 ( for a second time ) . the main idea behind our refined analysis is to not perform such path swaps , but instead to `` recursively '' start an interval swap on each path in @xmath361 . of course , we can not carry out this recursion to arbitrary depth ( since we can only swap a bounded number of locations ) , so we terminate the recursion at a depth of @xmath179 .",
    "so , whereas an interval swap included at most @xmath179 @xmath122-locations on the main path or cycle @xmath33 , we now consider a `` subtree '' swap obtained by aggregating interval swaps on the paths in @xmath363 .",
    "a subtree swap can be viewed as a bounded - depth recursion tree where each leaf to root path encounters at most @xmath179 locations in @xmath122 . because we no longer initiate path swaps for @xmath364-locations , a leaf location @xmath365 in this recursion tree will not have any locations in @xmath366 opened .",
    "but we will slightly redefine the @xmath367 sets to ensure that @xmath368 , and use the same trick that we did with interval swaps in section  [ 5apx ] : we _ average _ over different sets of subtree swaps ( like we did with interval swaps in section  [ 5apx ] ) to ensure that @xmath369 is a leaf location with probability at most @xmath319 .",
    "this ensures that we incur , to an extent of at most @xmath243 , the cost @xmath370 , where @xmath371 , for moving @xmath11 with @xmath372 from @xmath369 to @xmath26 .",
    "[ [ notation . ] ] notation .",
    "+ + + + + + + + +    let @xmath373 be an integer such that @xmath374 .",
    "we prove that the local - search algorithm has approximation ratio @xmath375 .",
    "we redefine @xmath376 and @xmath364 as follows .",
    "@xmath118=0.5ex = 0ex    @xmath377 .",
    "@xmath378 .",
    "@xmath379 .",
    "@xmath380 .",
    "clearly , @xmath381 .",
    "we also redefine @xmath89 to be the location in @xmath72 _ closest to @xmath53_.    [ s2dist ] let @xmath140 and @xmath153 . then @xmath382 .",
    "we have @xmath383 for any @xmath384 , and @xmath385 for any @xmath386 .",
    "therefore , @xmath387 for any @xmath388 , and the claim follows since @xmath389 as @xmath140 .",
    "[ fig : hgraph ]    it will be more convenient to work with the digraph @xmath390 obtained from @xmath79 by contracting each triple @xmath391 of nodes associated with a facility @xmath6 into a single node that we also denote by @xmath6 . thus , @xmath392 is an arc in @xmath393 if @xmath394 ( it may be that @xmath395 ) . note that @xmath396 may have self loops , and each node in @xmath396 has outdegree exactly 1 ( counting self - loops ) so each component of @xmath396 looks like a tree with all edges oriented toward the root , except the root is in fact a directed cycle ( possibly a self - loop ) .",
    "the figure above illustrates this graph and some of the subgraphs and structures discussed below .    for brevity",
    ", we say that an edge @xmath392 in @xmath396 is a _ center _",
    "edge if @xmath397 . in the arc set @xmath398 ,",
    "each node has indegree and outdegree at most 1 , so @xmath399 consists of a collection node - disjoint paths @xmath80 and cycles @xmath81 . for a facility @xmath400 ,",
    "let @xmath401 denote the unique path in @xmath80 containing @xmath6 .",
    "let @xmath402 and @xmath403 denote the start and end facilities of @xmath401 respectively",
    ". for distinct facilities @xmath404 with @xmath405 , the paths @xmath401 and @xmath406 are clearly vertex disjoint .",
    "now define @xmath407 ; that is , @xmath408 is the subgraph of @xmath396 with node - set @xmath28 and edges @xmath392 of @xmath393 where @xmath392 is a center edge or @xmath409 . call a node @xmath6 of @xmath408 a _ root _",
    "if @xmath6 has no outgoing arc or @xmath6 lies on a directed cycle in @xmath408 .",
    "we consider an integer @xmath410 and describe a set of swaps for each index @xmath411 .",
    "the inequalities for the swaps for different @xmath411 will be averaged in the final analysis .",
    "we obtain @xmath412 by deleting the edges @xmath392 of @xmath408 where : @xmath6 is not on a cycle , @xmath413 , and the number of facilities @xmath414 with @xmath415 on the path between @xmath109 and the root of its component in @xmath408 ( both included ) is @xmath416 .",
    "we define a _ subtree _ of @xmath412 to be an acyclic component of @xmath412 , or a component that results by deleting the edges of the cycle contained in a component of @xmath412 .    for a facility @xmath6 ,",
    "define @xmath417 .",
    "note that @xmath418 .",
    "the reason we define @xmath419 is that we will sometimes perform a shift along some path @xmath420 to reassign the facilities on @xmath33 but we will not want this to interfere with the operations in the subtree of @xmath412 containing @xmath6 . for a facility @xmath6 with @xmath421 ,",
    "let @xmath422 be the facility obtained as follows .",
    "follow the unique walk from @xmath6 in @xmath396 using only center edges until the walk reaches a node @xmath109 with either no outgoing center edge , or the unique @xmath423 center edge satisfies @xmath415 ; we set @xmath424 .",
    "[ subtreesize ] the number of facilities @xmath6 with @xmath425 in any subtree of @xmath412 is at most @xmath426 .",
    "the facilities @xmath6 in such a subtree that are in @xmath126 have indegree and outdegree at most 1 . shortcutting past these facilities",
    "yields a tree with depth at most @xmath179 and branching factor at most @xmath373 .",
    "[ [ the - test - swaps . ] ] the test swaps .",
    "+ + + + + + + + + + + + + + +    for a subtree @xmath427 of @xmath412 , we describe a set of nodes @xmath428 to be swapped out and a set of nodes @xmath429 to be swapped in with @xmath430 .",
    "we do not actually perform these swaps yet to generate the inequalities since we will have to combine some of these swaps for various components .",
    "for each @xmath431 with @xmath432 , we add the following location in @xmath15 to @xmath428 : if @xmath433 we add @xmath26 to @xmath428 ; otherwise ( so @xmath434 ) , we choose any single @xmath435 uniformly at random and add @xmath436 to @xmath428 .",
    "we also add @xmath437 to @xmath429 .",
    "when we say perform @xmath438 , we specifically mean the following reassignment of facilities .",
    "for @xmath439 with @xmath433 , we perform @xmath440 . for @xmath439 with @xmath441 ,",
    "say @xmath109 is the facility in @xmath419 for which @xmath436 was added to @xmath428 .",
    "then we perform @xmath442 , move facility @xmath109 from @xmath110 to @xmath26 , and finally perform @xmath440 . as always ,",
    "each client is then assigned to its nearest final location .",
    "lemma  [ lem : disjoint ] implies that these shift operations charge different portions of the local and global optimum .",
    "[ lem : disjoint ] for a subtree @xmath427 , all of the shift operations described for @xmath443 have their associated paths being vertex disjoint .    for any subtree @xmath427 ,",
    "the paths between @xmath26 and @xmath437 for the facilities @xmath444 with @xmath425 are vertex - disjoint by definition of @xmath422 . also , for any two distinct @xmath445 , and any @xmath446 , we have @xmath447 , and so their associated paths @xmath401 and @xmath406 are also vertex - disjoint",
    ".    finally , consider any @xmath444 with @xmath432 , and @xmath448 ( @xmath414 could be @xmath6 ) with @xmath449 .",
    "consider the paths involved in @xmath450 and @xmath451 , where @xmath452 .",
    "note that both of these paths consist of only center edges .",
    "therefore , since each facility has at most one incoming and one outgoing center edge , and @xmath453 , if these paths are not vertex - disjoint , then it must be that the path involved in @xmath450 is a subpath of the path involved in @xmath454 .",
    "this means that @xmath6 and @xmath109 , and hence , @xmath455 , are all in the same component of @xmath408 . also , the edge @xmath423 is not in @xmath408 so @xmath109 is the root of its component in @xmath408 .",
    "but then there is a path from @xmath414 to @xmath109 , which contradicts that @xmath456 .",
    "we need to coordinate the swaps for the various subtrees of @xmath412 .",
    "consider a component @xmath33 in @xmath408 .",
    "let @xmath457 if @xmath33 is rooted at a node , otherwise let @xmath82 be its cycle of root nodes .",
    "let @xmath458 be the facilities on @xmath82 with @xmath459 , indexed by order of appearance on @xmath82 starting from an arbitrary facility @xmath460 on @xmath82 ( @xmath461 if @xmath457 ) .",
    "we consider four kinds of swaps .    * type . *",
    "= 0.5ex = 0ex = 0ex =    if @xmath462 , simultaneously do @xmath443 for all subtrees @xmath427 rooted at some @xmath463 with @xmath464 .",
    "otherwise , if @xmath465 , define @xmath466 for all @xmath467 ( where the indices are @xmath468 ) . simultaneously perform @xmath469 for each subtree @xmath427 rooted at a facility in @xmath470 . reasoning similarly as in lemma [ lem : disjoint ] and noting that the subtrees involved in a single type-1 or type-2 swap are all disjoint , we can see that all shift paths involved in a single type-1 or type-2 swap are vertex - disjoint .    for each @xmath6 with @xmath471 , simultaneously perform @xmath443 for all subtrees @xmath427 rooted at some @xmath109 with @xmath472 .",
    "at the same time , we also swap out @xmath26 and swap in @xmath473 for a total of at most @xmath474 swaps",
    ". it may be that some ( at most one ) shift path in this swap includes @xmath26 , but then we just move @xmath414 to @xmath475 instead of @xmath26 , and then move @xmath6 according to the shift operation .    finally , for every other subtree @xmath427 of @xmath412 that was not swapped in the previous cases , perform @xmath443 on its own .",
    "[ [ analysis . ] ] analysis .",
    "+ + + + + + + + +    we first bound the net client - assignment cost increase for any single one of these test swaps .",
    "so , fix one such swap , let @xmath476 be the set of subtrees involved in the swap , and let @xmath477 denote the set of facilities @xmath6 such that @xmath478 and @xmath479 is closed during the swap while @xmath30 is not opened .",
    "so @xmath477 consists of facilities with a center edge to some leaf of some subtree @xmath480 or , if the swap is of type 2 , to the start of an interval @xmath470 . for this swap ,",
    "let @xmath481 , @xmath482 , and @xmath483 .",
    "[ lem : clientbound ] the expected change in client - assignment cost for a test swap is at most @xmath484 . here",
    ", the expectation is over the random choices involved in selecting facilities from the appropriate @xmath485 sets .",
    "after the swap , we move every @xmath486 from @xmath487 to @xmath488 for a cost change of @xmath489 .",
    "every client in @xmath490 for which @xmath487 is closed is moved initially to @xmath491 for a cost increase of at most @xmath176 .",
    "suppose @xmath6 is such that @xmath492 and @xmath493 .",
    "it may be that @xmath479 is still not open which means that @xmath494 .",
    "note that either @xmath26 or @xmath30 is opened after the shift and we move every client that was moved to @xmath479 to @xmath26 or @xmath30 ( whichever is open ) .",
    "this extra distance moved is at most @xmath495 .",
    "note that @xmath496 implies that @xmath497 , otherwise @xmath149 would not have been closed down in the swap .",
    "so @xmath498 , by definition of @xmath364 , and at most @xmath373 clients will be moved to either @xmath26 or @xmath30 in this manner .",
    "finally , we note that while @xmath499 may have @xmath487 being closed , this only happens with probability at most @xmath500 .",
    "now , we consider the following weightings of the swaps .",
    "first , for a particular index @xmath410 we perform all type 1 , 3 , and 4 swaps . for a component of @xmath412 containing a cycle @xmath82",
    ", we perform all type-2 swaps for the various intervals @xmath470 for @xmath82 and weight the client and facility cost change by @xmath319 .",
    "finally , these weighted bounds on the client and facility cost change are averaged over all @xmath410 .",
    "[ lem : client ] the expected change in client - assignment cost under the weighting described above , is at most @xmath501 .    for a fixed @xmath411 , every client @xmath11 is in @xmath502 as in lemma [ lem : clientbound ] to an extent of 1 ; either once in a type 1 , 3 , or 4 swap or exactly @xmath179 times among the type-2 swaps , each of which is counted with weight @xmath319 .",
    "similarly , every client @xmath11 is in @xmath503 to an extent of at most 1 and is in @xmath504 to an extent of at most 1 over all swaps for this fixed @xmath411 .",
    "finally , we note each facility @xmath6 on a cycle in @xmath408 lies in the set @xmath477 for at most one offset @xmath505 for that cycle , so its contribution @xmath506 to the bound is only counted with weight @xmath319 for this fixed @xmath411 .",
    "lastly , every facility @xmath6 not on a cycle in @xmath408 lies in @xmath477 for at most one index @xmath507 and , then , in only one swap for that particular @xmath411 .",
    "since we average the bound over all indices @xmath411 between 1 and @xmath179 , the contribution @xmath508 of such @xmath6 is counted with weight only @xmath319 .",
    "next we bound the expected facility movement cost change .",
    "let @xmath509 be the set of facilities @xmath6 that do not lie on a cycle in @xmath408 consisting solely of facilities @xmath109 with @xmath510 .",
    "[ lem : fac ] the expected change in movement cost ( under the weighting described above ) is at most @xmath511 .",
    "we consider two cases for a facility @xmath6 .",
    "first , suppose @xmath425 .",
    "then when @xmath26 is swapped out in a subtree during the shift from @xmath26 to @xmath437 , @xmath6 is moved to either @xmath30 , if @xmath512 , or to @xmath479 , if @xmath513 .",
    "the latter case implies that @xmath514 .",
    "the total movement change is at most @xmath515 if @xmath6 is moved to @xmath30 and is at most @xmath516 if @xmath6 is moved to @xmath479 . since @xmath517 and @xmath493",
    ", by claim  [ s2dist ] we have that @xmath518 .",
    "the only other time @xmath6 is moved is when @xmath403 is randomly chosen from @xmath519 for some facility @xmath109 . but",
    "this happens with probability at most @xmath500 . in this case",
    ", @xmath6 is shifted from @xmath26 to @xmath479 .",
    "we do not necessarily have @xmath520 in this case , but we can use the bound @xmath521 to bound the expected movement - cost change for @xmath6 in this case to be at most @xmath522 .",
    "overall , the expected movement - cost change for @xmath6 is at most @xmath523    next , we consider the case @xmath471 .",
    "let @xmath524 .",
    "when the swap consisting of @xmath6 and all subtrees rooted at @xmath525 is performed , @xmath6 is moved from @xmath26 to @xmath110 unless @xmath6 lies on a shift path during that swap , in which case it is moved like in the shift . since @xmath471",
    ", we have @xmath526 .",
    "unless @xmath6 lies on a cycle with no @xmath122-locations , that is , @xmath527 , @xmath6 lies between @xmath414 and @xmath528 for exactly one @xmath414 , and @xmath529 is performed to an extent of 1 ; this holds even if @xmath26 lies on a shift path during the corresponding type-3 swap involving @xmath6 .",
    "all other times @xmath6 when is moved , it is due to the same reasons as in the previous case , so the total change in movement cost for facility @xmath6 is at most @xmath530    adding up the appropriate expression for each facility accounts for the expected change in total movement cost .",
    "theorem [ thm:3appx ] by local optimality , the change in total cost for every test swap ( counting every random choice ) is nonnegative . by averaging over the various swaps ,",
    "the expected change in total cost is nonnegative , so the sum of the expressions in lemmas  [ lem : client ] and  [ lem : fac ] is nonnegative . to generate an inequality involving a @xmath531 term for facilities @xmath527",
    ", we sum the bound given by lemma  [ cycleswap ] here over all cycles of @xmath408 involving only facilities @xmath6 with @xmath532 .",
    "this yields @xmath533 , and we can bound @xmath534 by @xmath535 . adding this to the inequality that the expected change in total cost is nonnegative gives @xmath536 .",
    "the analysis in section  [ 3apx ] ( as also the proof of the 5 approximation ) extends easily to the weighted generalization , wherein each facility @xmath6 has a weight @xmath537 and the cost of moving @xmath6 to @xmath53 is given by @xmath538 , to yield the same @xmath49-approximation guarantee . with the exception of one small difference in the analysis , this requires only minor changes in the arguments .",
    "we discuss these briefly in this section .",
    "unless otherwise stated , the same notation from section [ 3apx ] is used in this section .",
    "we emphasize that @xmath59 and @xmath57 now refer to the weighted movement cost of facility @xmath6 in the global or local optimum , respectively .",
    "so , @xmath539 and @xmath540 .",
    "one difference in notation is that the definition of @xmath122 is slightly revised to this weighted setting : @xmath464 if @xmath541 , or @xmath542 and @xmath543 , where @xmath109 is such that @xmath544 ( equivalently , @xmath545 is a center edge in @xmath396 ) .",
    "if all facility weights are 1 , then this definition of @xmath122 agrees with the definition in section [ 3apx ] .",
    "similarly , we say @xmath471 if @xmath546 and @xmath547 . under these definitions ,",
    "similar to claim  [ s2dist ] , we now have that @xmath548 ( since @xmath549 for any @xmath550 as before , and @xmath551 ) .",
    "we consider the same set of test swaps and the same averaging of the inequalities generated by these swaps .",
    "when a test swap is performed , we consider the same shift and reassignment of facilities to generate the inequalities . in most cases",
    ", we also move the clients in the same way as before with the exception that if a client @xmath11 has all of @xmath552 and @xmath491 being closed , then we do not necessarily send it to @xmath553 where @xmath6 is such that @xmath554 .",
    "this is discussed in lemma  [ lem : w_clientbound ] .    as in the discussion before lemma  [ lem",
    ": clientbound ] , we consider a swap involving subtrees @xmath555 .",
    "let @xmath477 be as before , and let @xmath556 be the set of facilities @xmath6 such that @xmath6 is a leaf in some @xmath480 or , if the swap is a type-2 swap , that @xmath6 is the first facility in @xmath470 .",
    "note that @xmath496 if and only if the unique @xmath392 arc in @xmath408 is a center arc with @xmath557 .",
    "we let @xmath558 , and @xmath504 also be defined as in section [ 3apx ] .",
    "[ lem : w_clientbound ] the expected change in client assignment cost for a test swap is at most @xmath559    consider one particular swap .",
    "as in the proof of lemma  [ lem : clientbound ] , we move @xmath560 to @xmath488 and @xmath561 to @xmath491 and bound their assignment cost change in the same way . as before , it may be that for some of these clients @xmath561 we have that @xmath491 was closed in the swap .",
    "for such clients , we do the following slight variant of the reassignment that was done in the proof of lemma [ lem : clientbound ] .",
    "suppose @xmath392 is the center edge such that @xmath562 for a client @xmath561 , and @xmath32 is not open .",
    "if @xmath563 , then we send @xmath11 to either @xmath553 or @xmath564 . as in the proof of lemma  [ lem : clientbound ] , one of these must be open and the total cost of moving @xmath11 from @xmath32 to either @xmath553 or @xmath564 is at most @xmath565 .",
    "otherwise , if @xmath566 then we send @xmath11 to either @xmath110 or @xmath567 ( one of them must be open ) .",
    "the distance from @xmath32 to either @xmath110 or @xmath567 is bounded by @xmath568 .",
    "we conclude by noting that each facility @xmath569 has at most @xmath570 clients sent to either @xmath239 or @xmath571 from @xmath572 in the manner just described , because @xmath573 must be in @xmath364 . similarly , each @xmath574 has at most @xmath570 clients sent to either @xmath571 or @xmath572 from @xmath239 in the manner described above , since @xmath575 .",
    "so , the total client movement charged to @xmath576 this way is at most @xmath577 .    using the same weighting of the swaps as in section [ 3apx ] we get the following bound on the contribution of",
    "the client movement cost changes over these swaps .",
    "the proof is nearly identical , except we notice that a facility @xmath109 lies in the @xmath556-set for various swaps to an extent of at most @xmath319 ( under this weighting ) , since the facility @xmath6 such that @xmath392 is a center edge lies in some @xmath477-set to an extent of at most @xmath319 .",
    "[ lem : w_client ] the expected total client assignment cost change , weighted in the described manner , is at most @xmath501 .",
    "the contribution of the facility movement costs is bounded in essentially the same way as in lemma [ lem : fac ] .",
    "we just provide the details on how to account for the weights of the facilities .",
    "as before , let @xmath509 be the set of facilities @xmath6 that do not lie on a cycle in @xmath408 consisting solely of facilities @xmath109 with @xmath510 .",
    "[ lem : w_fac ]    when @xmath578 is performed , we move facilities @xmath6 from @xmath26 to @xmath579 . if this shift was performed during a path swap , then the movement - cost change for a facility @xmath6 moved in this shift is at most @xmath580 so the same bound used before applies .",
    "if such a shift was performed along a path in a subtree , then we did not want to bound @xmath534 by @xmath581 because we do not want to cancel the contribution of @xmath582 to the bound .",
    "however , this only happened when @xmath583 so we can use the fact that @xmath584 is large and that @xmath549 for any @xmath585 . in our setting , as noted earlier , the movement cost @xmath586 can be bounded by @xmath587 , which is the same upper bound we used in the unweighted case .",
    "finally , the only other time we moved a facility was from some @xmath471 to @xmath588 .",
    "the cost of this move is now @xmath589 which can also be bounded by @xmath590 using the same argument as in the previous paragraph .",
    "so , all bounds for the unweighted facility movement cost increase averaged over the swaps also hold in the weighted case .",
    "finally , we remark that the same bound for the facility movement cost for facilities on a cycle with only @xmath126 facilities holds for the weighted case , again using arguments like in the proof of lemma [ lem : w_fac ] to bound @xmath586 .",
    "thus , the proof of theorem [ thm:3appx ] is adapted to prove the following result for the weighted case .",
    "the cost of a locally - optimal solution using @xmath24 swaps is at most @xmath591 times the optimum solution cost in weighted instances of mobile facility location .",
    "we show in this section that the local - search algorithm has a constant approximation guarantee also when @xmath592 ( which corresponds to @xmath593 in section  [ 5apx ] ) , even in the weighted setting .",
    "this requires a different analysis than in section  [ 5apx ] since we now no longer have the luxury of amortizing the `` expensive '' terms in an interval swap via multi - location swaps .",
    "the approximation factor we obtain in the analysis below is large , but we emphasize that we have not sought to optimize this constant . also , we remark that the analysis can be significantly simplified and improved in the unweighted setting .",
    "recall that @xmath594 and @xmath595 .",
    "we use much of the same notation as in section  [ 5apx ] . the digraph @xmath79 , its decomposition into paths @xmath80 and cycles @xmath81 , and the definition of @xmath89 are as in section  [ 5apx ] .",
    "thus , for a path @xmath113 , we have @xmath596 . define @xmath597 .",
    "let @xmath598 with @xmath599 .",
    "we place @xmath26 in @xmath122 if @xmath600 or @xmath601 ; otherwise we place @xmath26 in @xmath126 . also define @xmath602 .",
    "let @xmath603 for @xmath90 .",
    "[ 1sws2lem ] let @xmath532 and @xmath604 , and consider @xmath605 .",
    "we have @xmath606    we reassign clients in @xmath607 to @xmath54 , and each client @xmath11 in @xmath608 to @xmath137 incurring a total assignment - cost change of @xmath609 .",
    "the change in movement cost is at most @xmath610 where the last inequality follows since @xmath532 . adding this to the expression for the change in assignment cost yields the lemma .    in lemmas  [ pclem][cyclem ] ,",
    "we generate inequalities that will allow us to bound the total movement cost , and the total assignment cost of clients in @xmath256 .",
    "we use the following notation for this sequence of lemmas .",
    "given a path or cycle @xmath258 , let @xmath611 , where @xmath181 is the next @xmath122-location on @xmath33 after @xmath183 .",
    "let @xmath185 for @xmath202 , and @xmath612 .",
    "let @xmath613 and @xmath614 for @xmath615 ( see fig .  [ labeling ] ) .",
    "let @xmath616 denote the @xmath293 subpath of @xmath33 .",
    "consider an @xmath617 subpath of @xmath33 .",
    "let @xmath618 consist of all such @xmath32 where @xmath619 and @xmath620 .",
    "let @xmath621 consist of all such @xmath32 where @xmath619 and @xmath622 .",
    "note that if @xmath623 then @xmath624 and @xmath625 .",
    "let @xmath626 consist of all such @xmath32 where @xmath620 .",
    "clearly , @xmath627 and @xmath628 .",
    "when @xmath33 is clear from the context ( as in lemmas  [ pclem][cyclem ] ) , we drop the subscript @xmath33 from @xmath629 .",
    "[ pclem ] let @xmath258 be such that @xmath630 .",
    "then , @xmath631{0.88in}{if $ z\\in{\\ensuremath{\\mathcal p}}$ with \\\\ $ s'_0={\\ensuremath{\\mathsf{start}}}(z)$ \\\\ $ o'_r={\\ensuremath{\\mathsf{end}}}(z)$ } }   & \\ & 0\\ & \\leq\\ \\sum_{i\\in z}(f^*_i - f_i ) + \\sum_{j\\in d^*((z\\cap o){\\ensuremath{\\setminus}}\\{o'_r\\})}\\negthickspace\\negthickspace\\negthickspace \\tfrac{2}{3}(c_j+c^*_j )   + \\sum_{j\\in d^*(o'_r)}\\negthickspace ( c^*_j - c_j ) + \\sum_{j\\in d^*(s'_0)}\\negthickspace 2c^*_j .   \\label{pcineq1 } \\\\[1ex ] \\text{\\parbox{0.88in}{if $ z\\in{\\ensuremath{\\mathcal{c}}}$ } } & \\ & 0\\ & \\leq\\ \\sum_{i\\in z}(f^*_i - f_i ) + \\sum_{j\\in d^*(z\\cap o)}\\tfrac{2}{3}(c_j+c^*_j ) .",
    "\\label{pcineq2}\\end{aligned}\\ ] ]    first , suppose @xmath33 is a path . for every @xmath632 ,",
    "we have that @xmath517 , and so we have @xmath633 .",
    "thus , the move @xmath634 yields the following inequality , which implies .",
    "@xmath635 for a cycle @xmath33 , analogous to lemma  [ cycleswap ] , we have @xmath636 , and this coupled with the above bound on @xmath637 for @xmath34 yields .",
    "[ pathlem1 ] let @xmath262 ( with @xmath638 as defined above ) .",
    "let @xmath307 , and @xmath639 .",
    "suppose there is no @xmath276 such that @xmath640 .",
    "then , @xmath641    we derive by taking a weighted combination of inequalities generated from various swap moves .",
    "we assume @xmath306 ( otherwise implies ) . for a predicate @xmath642 ,",
    "let @xmath643 be the indicator function that is 1 if @xmath642 is true and 0 otherwise . to keep notation simple",
    ", we follow the convention that a non - existent object ( like @xmath644 ) is @xmath645 , and @xmath646 for every set @xmath427 ( e.g. , @xmath647 for every @xmath427 . ) also , @xmath648 , and @xmath649 .    * ) * =    the first swap move is @xmath634 , but we bound the change in cost slightly differently .",
    "we only reassign clients in @xmath650 , obtaining the inequality @xmath651 define @xmath652 .",
    "note that @xmath653 $ ] if @xmath654 .",
    "consider each edge @xmath655 . if @xmath656 and @xmath657 , we simply bound @xmath637 by @xmath658 . otherwise ,",
    "if @xmath659 , we use the bound @xmath660 which is valid since @xmath661 .",
    "if @xmath662 and @xmath663 , then @xmath622 and we bound @xmath637 by @xmath664 .",
    "incorporating these bounds in , we obtain the following inequality .",
    "@xmath665    for every @xmath615 such that @xmath666 ,",
    "we consider the move @xmath667 .",
    "we move each facility @xmath668 to @xmath149 if @xmath669 and to @xmath218 otherwise .",
    "note that for every facility @xmath6 such that @xmath670 , we have @xmath517 , and so @xmath633 . we reassign all clients in @xmath671 to @xmath218 , and reassign each client @xmath11 in @xmath672 to @xmath137 .",
    "the resulting change in assignment cost is at most @xmath673 . if @xmath674 , we reassign all clients in @xmath675 to @xmath676 and bound the resulting change in assignment cost by @xmath677 . therefore , if @xmath666 , we obtain the inequality @xmath678    for every @xmath276 such that @xmath679 , we again consider @xmath667 .",
    "we move facilities on @xmath616 and reassign clients in @xmath680 as in case 2 ) .",
    "we reassign clients in @xmath681 to @xmath682 if @xmath683 , and to @xmath684 otherwise .",
    "the assignment - cost change due to this latter reassignment is at most @xmath685 if @xmath683 , and @xmath686 otherwise , where to obtain the latter inequality we use the fact that @xmath687 since @xmath688 and @xmath689 for all @xmath690 .",
    "we obtain the inequality @xmath691    for every @xmath276 such that @xmath692 , we pick some arbitrary @xmath191 and consider @xmath693 . we analyze this by viewing this as a combination of : ( i ) a shift along @xmath86 , ( ii ) moving @xmath6 from @xmath30 to @xmath183 , where @xmath694 , and ( iii ) a shift along the appropriate subpath of @xmath33 . the resulting inequality we obtain",
    "is therefore closely related to , .",
    "we incur an additional @xmath695 term for the change in movement cost due to ( i ) and",
    "( ii ) , and @xmath696 for reassigning clients in @xmath697 .",
    "also , since @xmath183 is no longer swapped out , we do not incur any terms that correspond to reassigning clients in @xmath698 .",
    "thus , we obtain the following inequality : @xmath699    we are finally ready to derive . an inequality subscripted with an index , like @xmath700 , denotes that inequality for that particular index",
    ". it will be useful to define [ segineq ]",
    "@xmath701 we take the following linear combination .",
    "@xmath702 the lhs of is 0 .",
    "we analyze the contribution from the @xmath324 terms to the rhs .",
    "facilities @xmath703 contribute at most @xmath704 .",
    "consider @xmath34 .",
    "if @xmath705 , we pick up @xmath706 from parts 1 and 2 , and we may pick up an additional @xmath707 from part 2 if @xmath708 .",
    "so overall , we obtain a contribution of at most @xmath709 .",
    "next suppose @xmath108 .",
    "if @xmath710 and @xmath657 , we gather @xmath711 from part 1 and @xmath712 from part 2 , so the total contribution is @xmath713 .",
    "suppose @xmath714 .",
    "notice then that @xmath657 , otherwise if @xmath715 , then @xmath716 , which contradicts our assumptions .",
    "recall that @xmath652 .",
    "we gather @xmath717 from part 1 , and @xmath718\\leq   6.25f^*_i-2.5f_i\\bigl(1-\\frac{n^*_{o_i}}{w_i}\\bigr)$ ] from part 2 . thus , we gather at most @xmath719 . if @xmath710 and @xmath663 , then note that actually @xmath720 .",
    "we gather @xmath721 from part 1 , and @xmath722 $ ] from part 2 , so the total contribution is at most @xmath709 .",
    "we now bound the @xmath723-contribution .",
    "part of this is @xmath724 .",
    "we proceed to analyze the remaining contribution .",
    "the clients whose remaining contribution is non - zero are of two types : ( i ) clients in @xmath725 , which are reassigned when a location in @xmath726 is swapped in or a location in @xmath727 is swapped out ; and ( ii ) clients in @xmath728 , where @xmath729 , which are charged when we bound the cost @xmath637 or when @xmath663 is swapped out .",
    "consider a client @xmath730 .",
    "let @xmath731 .",
    "its ( remaining ) part-1 contribution is @xmath732 if @xmath714 or @xmath663 , and 0 otherwise .",
    "the part-2 contribution is at most @xmath733 ( this happens when @xmath714 ) ; so the total ( remaining ) contribution is at most @xmath734 . for @xmath735 , where @xmath736 , we know that @xmath737 , and so we have already accounted for its contribution of at most @xmath738 above . finally , consider @xmath739 , where @xmath740 .",
    "note that @xmath517 .",
    "we gather @xmath732 from part 1 if @xmath663 and 0 otherwise , and @xmath741 from part 2 if @xmath663 and @xmath742 otherwise ; so in total we gather at most @xmath743 .    putting everything together ,",
    "leads to inequality .",
    "[ pathlem2 ] let @xmath262 , @xmath307 and @xmath261 .",
    "we have @xmath744    we focus on the case where there exists an index @xmath276 such that @xmath745 , @xmath679 , and @xmath746 as otherwise , immediately implies .",
    "this case is significantly more involved , in part because when @xmath747 and @xmath683 , we accrue both the term @xmath748 in when @xmath183 is swapped out , and the term @xmath749 in when @xmath181 is swapped out .",
    "hence , there is no way of combining  to get a compound inequality having both @xmath750 and @xmath751 on the rhs . in order to achieve this",
    ", we define a structure called a _ block _ , comprising multiple @xmath616 segments , using which we define additional moves that swap in @xmath218 but swap out neither @xmath183 nor @xmath181 , so that the extent to which @xmath218 is swapped in exceeds the extent to which @xmath183 or @xmath181 are swapped out .",
    "we call a set @xmath752 of consecutive @xmath40-locations a _ block _ , denoted by @xmath753 , if ( i ) @xmath754 and @xmath755 for all @xmath756 , ( ii ) @xmath757 ( recall that if @xmath758 is non - existent , then this condition is not satisfied ) , and ( iii ) @xmath759 or @xmath760 .",
    "note that by definition , any two blocks correspond to disjoint subpaths of @xmath33 .",
    "we say that @xmath761 are _ siblings _ , denoted by @xmath762 , if @xmath763 and they belong to a common block ; note that this means that neither @xmath53 nor @xmath77 is at the start of a block .",
    "we use @xmath764 to denote that @xmath53 and @xmath77 are not siblings .",
    "let @xmath765 .    before defining the additional swap moves for each block ,",
    "we first reconsider @xmath634 and account for the change in cost due to this move differently to come up with a slightly different inequality than .",
    "we again start with , and bound @xmath637 in different ways for an @xmath766 edge of @xmath33 .",
    "we use @xmath767 incorporating this in yields the following inequality .",
    "@xmath768    for every block @xmath753 , we consider the swap moves @xmath769 for all @xmath770 .",
    "for each such @xmath771 , we obtain the inequality @xmath772 where we bound @xmath773 by @xmath774 . also consider @xmath775 if @xmath776 or @xmath777 if @xmath692 , where @xmath86 is some arbitrary path in @xmath778 .",
    "note that if @xmath679 , then @xmath779 .",
    "this yields the inequality @xmath780    we now derive by taking the following linear combination of  : @xmath781 as before , the lhs of is 0 , and we analyze the contribution from the @xmath324 terms to the rhs .",
    "many of the terms are similar to those that appear in , so we state these without much elaboration .",
    "facilities @xmath703 contribute at most @xmath782 .",
    "consider @xmath34 .",
    "if @xmath783 , then note that @xmath188 does not belong to a block , and we gather at most @xmath784 from parts 1 and 2 .",
    "suppose @xmath108 .",
    "if @xmath785 , we gather @xmath786 from part 1 . let @xmath787 .",
    "if @xmath183 does not belong to any block then we pick up @xmath788 from part 2 .",
    "otherwise , note that @xmath183 must be the start of a block , therefore , we pick up @xmath789 from parts 3 and 4 .",
    "so the overall contribution is at most @xmath790 .",
    "next , suppose @xmath791 .",
    "let @xmath792 .",
    "we pick up @xmath786 from part 1 , @xmath793 $ ] from part 3 , and @xmath794 $ ] from part 4 .",
    "this amounts to at most @xmath795 total contribution .",
    "suppose @xmath714 .",
    "we gather @xmath796 from part 1 . if @xmath657 , we gather @xmath797 $ ] from parts 2 , 3 , and 4 . if @xmath663 , then @xmath798 is the end of some block , and we gather @xmath799 + 9(f^*_i - f_i)$ ] from parts 2 , 3 , and 4 .",
    "so the total contribution in both cases is at most @xmath800 . if @xmath801 and @xmath663 , then @xmath798 is the end of some block .",
    "we gather @xmath802 from part 1 , and @xmath803 + 9(f^*_i - f_i)$ ] from parts 3 and 4 , which amounts to at most @xmath804 total contribution .",
    "finally , if @xmath720 , @xmath663 and @xmath805 , we gather @xmath806 from part 1 . if @xmath26 does not belong to a block , we gather @xmath807 $ ] from part 2 . if @xmath26 belongs to a block , then notice that it can only be the start @xmath183 of the block .",
    "so @xmath517 and we gather @xmath808 from parts 3 and 4 . accounting for both cases , we gather at most @xmath809 .",
    "now consider the @xmath723-contribution .",
    "this includes the terms @xmath810 and @xmath811 .",
    "we bound the remaining contribution . consider a client @xmath730 .",
    "let @xmath731 .",
    "its ( remaining ) part-1 contribution is @xmath812 if @xmath714 or @xmath813 , and 0 otherwise .",
    "if @xmath183 is not in any block , we pick up at most @xmath814 from part 2 .",
    "if @xmath183 is the start of a block , we pick up @xmath815 from part 3 , and note that @xmath816 . if @xmath183 is an intermediate @xmath40-location of a block , then @xmath715 and @xmath791 .",
    "we pick up @xmath815 from part 3 , and @xmath817 from part 4 .",
    "so the total ( remaining ) contribution is at most @xmath818 in all cases . now consider",
    "@xmath739 , where @xmath740 .",
    "we have @xmath517 .",
    "let @xmath819 .",
    "we accrue @xmath820 from part 1 if @xmath663 and 0 otherwise .",
    "if @xmath183 does not belong to a block , we gather at most @xmath821 from part 2 ; if @xmath183 belongs to a block , it must be the start of the block , and we gather at most @xmath822 from part 3 .",
    "so in total , we accrue at most @xmath823 .",
    "thus , leads to inequality .",
    "[ cyclem ] let @xmath145 and @xmath824 .",
    "define @xmath275 for all @xmath276 .",
    "then , @xmath825    the arguments are almost identical to those in the proofs of lemmas  [ pathlem1 ] and  [ pathlem2 ] .",
    "the only change is that we no longer have inequality or .",
    "instead , we start with the inequality @xmath636 , and we bound @xmath637 suitably , as in lemma  [ pathlem1 ] or lemma  [ pathlem2 ] , to obtain and that are analogous to and respectively .",
    "@xmath826 & \\begin{split } 0\\ \\leq\\ &   \\sum_{\\substack{i\\in z : s_i{\\ensuremath{\\approx}}{\\ensuremath{\\sigma}}(o_i ) \\text { or } \\\\ { \\ensuremath{\\sigma}}(o_i)\\in z{\\ensuremath{\\setminus}}a , s_i\\notin b } }    \\negthickspace\\negthickspace 2f^*_i + \\sum_{\\substack{i\\in z : { \\ensuremath{\\sigma}}(o_i)\\in a\\text { or } \\\\ { \\ensuremath{\\sigma}}(o_i)\\in c{\\ensuremath{\\setminus}}a , s_i\\in b } } \\negthickspace\\negthickspace\\bigl(2f^*_i-(1-{\\ensuremath{\\alpha}}_i)f_i\\bigr ) + \\sum_{\\substack{i\\in z : { \\ensuremath{\\sigma}}(o_i)\\in z{\\ensuremath{\\setminus}}c \\\\ s_i\\in b , s_i{\\ensuremath{\\not\\approx}}{\\ensuremath{\\sigma}}(o_i ) } } \\negthickspace\\negthickspace(f^*_i - f_i ) \\\\ & + \\sum_{\\substack{i\\in z : { \\ensuremath{\\sigma}}(o_i)\\in a\\text { or } \\\\",
    "s_i\\in b , s_i{\\ensuremath{\\not\\approx}}{\\ensuremath{\\sigma}}(o_i ) } } \\sum_{j\\in d^*(o_i)}\\tfrac{2}{3}(c_j+c^*_j ) .",
    "\\end{split } \\label{cineq2}\\end{aligned}\\ ] ] the rest of the proof proceeds as in lemmas  [ pathlem1 ] and  [ pathlem2 ] : we substitute for in the proof of lemma  [ pathlem1 ] , and substitute for in the proof of lemma  [ pathlem2 ] .",
    "it is not hard to see then that we obtain inequality .",
    "[ 1swthm ] the cost of a local optimum using 1-swaps is at most @xmath35 times the optimum solution cost .",
    "let @xmath327 and @xmath82 denote respectively the total movement- and assignment- cost of the local optimum .",
    "for a set @xmath67 , let @xmath827 denote @xmath828 .",
    "summing for all @xmath140 and simplifying , we obtain that @xmath829 summing for every path @xmath262 , and or for every cycle @xmath145 , yields the following .",
    "@xmath830 adding @xmath831 to , we get that @xmath832",
    "in this section , we present an example that shows that if the facility - movement costs and the client - assignment costs come from different ( unrelated ) metrics then the @xmath24-swap local - search algorithm has an unbounded locality gap ; that is , the cost of a local optimum may be arbitrarily large compared to optimal cost .",
    "we first show a simple example for a single swap case , which we will later generalize for @xmath24 swaps .",
    "suppose we have two clients @xmath833 and two facilities @xmath834 .",
    "some distances between these clients and facilities are shown in the fig .",
    "[ fig : locgap](a ) ; all other distances are obtained by taking the metric completion . note that in this example , in order to have a bounded movement cost for facilities , the only option is to have one of @xmath835 as a final location of facility @xmath836 and one of @xmath837 as a final location of facility @xmath460 .    as can be seen from the figure ,",
    "the solution @xmath838 has total cost @xmath839 ( the movement cost is @xmath840 and the client - assignment cost is @xmath839 ) . now consider the solution @xmath841 which has a total cost of @xmath842 ( the movement cost is @xmath842 and the client - assignment cost is @xmath840 ) .",
    "this is a local optimum since if we swap out @xmath843 , then we have to swap in @xmath460 to have a bounded movement cost , which leads @xmath843 having assignment cost of @xmath844 . by symmetry , there is no improving move for solution @xmath15 , and the locality gap is @xmath25 .",
    "now consider the example shown in fig .",
    "[ fig : locgap](b ) for local - search with @xmath24 simultaneous swaps .",
    "suppose we have facility set @xmath845 and client set @xmath846 .",
    "the global optimum @xmath847 has total cost @xmath848 ( facility movement cost is @xmath840 and client - assignment cost is @xmath849 ) while @xmath850 is a local optimum whose total cost is @xmath851 ( facility movement cost is @xmath851 and client - assignment cost is @xmath840 ) .",
    "consider any move @xmath852 .",
    "note that @xmath853 iff @xmath854 ( where indices are @xmath855 ) to ensure bounded movement cost .",
    "let @xmath4 be such that @xmath853 and @xmath856 .",
    "then , @xmath857 has an assignment cost of @xmath844 in the solution @xmath858 .",
    "hence , @xmath15 is a local optimum ."
  ],
  "abstract_text": [
    "<S> we consider the _ mobile facility location _ </S>",
    "<S> ( ) problem . </S>",
    "<S> we are given a set of facilities and clients located in a common metric space @xmath0 . </S>",
    "<S> the goal is to move each facility from its initial location to a destination ( in @xmath1 ) and assign each client to the destination of some facility so as to minimize the sum of the movement - costs of the facilities and the client - assignment costs . </S>",
    "<S> this abstracts facility - location settings where one has the flexibility of moving facilities from their current locations to other destinations so as to serve clients more efficiently by reducing their assignment costs .    </S>",
    "<S> we give the first _ local - search based _ approximation algorithm for this problem and achieve the best - known approximation guarantee . </S>",
    "<S> our main result is @xmath2-approximation for this problem for any constant @xmath3 using local search . </S>",
    "<S> the previous best guarantee for was an 8-approximation algorithm due to  @xcite based on lp - rounding . </S>",
    "<S> our guarantee _ matches _ the best - known approximation guarantee for the @xmath4-median problem . </S>",
    "<S> since there is an approximation - preserving reduction from the @xmath4-median problem to , any improvement of our result would imply an analogous improvement for the @xmath4-median problem . </S>",
    "<S> furthermore , _ our analysis is tight _ ( up to @xmath5 factors ) since the tight example for the local - search based 3-approximation algorithm for @xmath4-median can be easily adapted to show that our local - search algorithm has a tight approximation ratio of 3 . </S>",
    "<S> one of the chief novelties of the analysis is that in order to generate a suitable collection of local - search moves whose resulting inequalities yield the desired bound on the cost of a local - optimum , we define a tree - like structure that ( loosely speaking ) functions as a `` recursion tree '' , using which we spawn off local - search moves by exploring this tree to a constant depth . </S>",
    "<S> our results extend to the weighted generalization wherein each facility @xmath6 has a non - negative weight @xmath7 and the movement cost for @xmath6 is @xmath7 times the distance traveled by @xmath6 . </S>"
  ]
}