{
  "article_text": [
    "in this report , we are extending the basic typing concepts of traditional software component systems with means for specifying possible behavior of components . as with traditional types , like primitive datatypes and their composition",
    ", our _ behavioral types _ can be used for eliminating possible sources of errors at development time of software systems .",
    "this is analog to classical static type checks performed by a compiler .",
    "furthermore , we can use behavioral types for eliminating possible sources of errors at runtime .",
    "this is analog to dynamic type checks performed when accessing pointers that reference data with types that can not be statically determined in some classical programming languages .",
    "behavioral types also provide additional information about components which can be used for tool based operations that allow the discovery of components and the dynamic reconfiguration of systems .",
    "we are focusing on the osgi component framework @xcite .",
    "the following topics are covered and have been partially @xcite published before :    * a discussion on behavioral types in general , including different usages . * our eclipse based implementation work on behavioral types that is manifested in the beht framework .",
    "the implementation work covers : editors , means for comparing types at development and runtime , a tool connection to resolve incompatibilities , and an aspectj based infrastructure to ensure behavioral type correctness at runtime of a system .",
    "furthermore , the implementation comprises various auxiliary operations .",
    "* we present some evaluation work based on examples .",
    "we present some core concepts on behavioral types to support a development process of component based systems . in our opinion",
    "( behavioral ) types should provide a number of core concepts @xcite to justify their classification as a _ type system _ :    abstraction : : :    behavioral types represent aspects of ( models of ) programs ,    components , or systems , providing an _ abstraction from details    concerning the interaction with their environment as well as their    internal structure_. type conformance : : :    as  in model - based development ",
    "behavioral types are abstractions of    components , models , or other entities .",
    "type conformance is used to    _ correctly relate a component to its behavioral type_. type refinement : : :    for supporting stepwise refinement , behavioral types should provide    the concept of refinement to _ ensure the correct implementation of    abstract specifications by concrete components_. type compatibility : : :    for supporting the combination of components , behavioral types should    provide the concept of type compatibility to _ help ensure the useful    composition of components to systems . _",
    "type inference : : :    furthermore , for the same reason , behavioral types should provide the    concept of type inference to _ allow to infer the type of a composed    system from the types of its constituents .",
    "_    to be useful in a development process , of course , a suitable type conformance notion has to be selected with respect to type refinement : for a pair of models conforming to a pair of types with the second model implementing the first , the second type should be a refinement of the first .",
    "furthermore , type refinement , type compatibility and type inference should agree : if a type compatible to a given type is refined by another , the later type should be compatible to the given one ; similarly , if in a composed type one type is replaced by a more refined type , the inferred type of the first composition should be a refinement of the second composition . also , for practical application in a development process , a behavioral type should not only be explicitly provided for a component by the user and checked for conformance , but ( automatically ) constructed for this component .",
    "this is especially desirable in a seamless model - based development process .",
    "finally , as type checking of expressive behavioral types is in general undecidable , an adequate level of expressiveness is needed making type checking feasible without over - restricting the expressiveness of the behavioral types .      using the above concepts",
    ", behavioral types can be helpful for different aspects of in the development process @xcite of a component based system . here",
    ", we present a general motivation for the concept without speaking about our implemented system .            [",
    "[ correctness - of - implementation ] ] correctness of implementation + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    behavioral types can be used to relate specifications and code , e.g. , as products of different stages in a development process , to ensure a certain aspect of behavior is preserved .",
    "figure  [ fig : scenrefine ] illustrates this for a model based development process with models of different degrees of abstraction  state - machines and source code  representing the same system . explicitly providing or automatically constructing corresponding conforming types , correctness of refinement can be checked by using these types , ensure the correctness of the implementation with respect to the abstraction implied by the type system .",
    "furthermore , refinement checking is also used in structural refinement when implementing a component by a collection of subcomponents .",
    "as shown in figure [ fig : compounds ] , the refinement relation is checked between the types of the composed components and the type of the collection of sub - components .",
    "the type of the composed component can also be derived from the respective behavioral types of the sub - components .",
    "[ [ compositionality - and - interfaces ] ] compositionality and interfaces + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    behavioral types could furthermore be used to check whether components to be composed are compatible with each other , as shown in figure  [ fig : scencomprefine ] . additionally , using type coercion  i.e.",
    ", the inference of the least abstract types refining the investigated pairs and being compatible  basically incompatible components can be composed .",
    "this generally involves an adaption of the corresponding models  by providing `` glue code '' similar to automatic type casts for , e.g. , integers of different length  to make the two components interact with each other .",
    "[ [ runtime - verification ] ] runtime verification + + + + + + + + + + + + + + + + + + + +    finally , behavioral types can be used for runtime - verifying systems , supplying a monitor being executed in parallel with a system implementation .",
    "the monitor  corresponding to a behavioral type and checking all behavioral constraints specified via the type  observes the system behavior , reporting violations .",
    "monitors may be generated from behavioral types automatically .",
    "figure  [ fig : scenrv ] shows a usage scenario for behavioral types in runtime verification . using an explicitly provided type or inferring it from the specification ( a more abstract model in the model based development process shown ) , this type serves as the basis for generating a runtime monitor which is then deployed with the compiled model as a runtime - verified system . this aspect is not treated in our current implementation .    [",
    "[ additional - benefits ] ] additional benefits + + + + + + + + + + + + + + + + + + +    additional benefits comprise the dynamic reconfiguration of systems based on type information and the discovery of components in a soa like setting .",
    "figure  [ fig : sscpic ] shows a state - machine ",
    "speed control  as part of an adaptive cruise control system in a car , using the graphical model of the eclipse - based papyrus uml tool @xcite .",
    "it is taken from @xcite .",
    "this state - machine provides an abstract component specification created during requirements specification in the development process .",
    "it specifies that this component shall be able to perform acceleration and braking .",
    "it can be compared with other types for uml diagrams that specify some aspects of the behavior of `` speed control '' .",
    "this comparison can be used during the abstract and detailed design and  not covered in this paper  in a later implementation , supporting a stepwise refinement .",
    "for example in the next phase the active state can be specified in a more detailed way supporting several modes as shown in figure  [ fig : ascpic ] .",
    "the standard , eco and sport mode may show different acceleration and braking behavior thereby supporting , e.g. , more fuel - efficient driving in the eco mode .",
    "however , when abstracting from possible transition guards ( mode switch ) , other behavioral functionality and other events  these may limit the order of possible executions ",
    "the original behavior specification still applies : each mode supports braking and acceleration .",
    "we can now extract a behavioral type of this more refined model and compare it with the first one . on this abstraction level",
    " regarding only brake and acceleration guards  both specifications have the same set of execution traces .    as an ultimate goal",
    ", the development environment should support the extraction and checking of behavior automatically and provide a means of informing the developer about any behavioral incompatibilities , i.e. , understandable behavioral type errors .",
    "we present an overview on osgi following our description in @xcite and refer to our semantics report @xcite for our approach to cover the semantics of osgi ( parts of this has also been published in @xcite ) .",
    "the osgi framework is a component and service platform for java .",
    "it allows the aggregation of java packages and classes into bundles ( cf .",
    "figure  [ fig : osgiexample ] ) and comes with additional deployment information .",
    "the deployment information triggers the registration of services for the osgi framework .",
    "bundles provide means for dynamically configuring services , their dependencies and usages .",
    "osgi bundles are used as the basis for eclipse plugins but also for embedded applications including solutions for the automotive domain , home automation and industrial automation .",
    "bundles can be installed and uninstalled during the runtime .",
    "for example , they can be replaced by newer versions .",
    "hence , possible interactions between bundles can in general not be determined statically .",
    "bundles are deployed as .jar files containing extra osgi information .",
    "this extra information is stored in a special file inside the .jar file .",
    "bundles generally contain a class implementing an osgi interface that contains code for managing the bundle , e.g. , code that is executed upon activation and stopping of the bundle . upon activation",
    ", a bundle can register its services to the osgi framework and make it available for use by other bundles .",
    "services are implemented in java .",
    "the bundle may itself start to use existing services .",
    "services can be found using dictionary - like mechanisms provided by the osgi framework .",
    "typically one can search for a service which is provided using an object with a specified java interface .    in the context of this report",
    ", we use the term osgi component as a subordinate concept for bundles , objects and services provided by bundles .",
    "the osgi standard only specifies the framework including the syntactical format specifying what bundles should contain .",
    "different implementations exist for different application domains like equinox for eclipse , apache felix or knopflerfish .",
    "if bundles do not depend on implementation specific features , osgi bundles can run on different implementations of the osgi framework .",
    "section  [ sec : beht ] discusses and presents a general work on behavioral types .",
    "the use of behavioral types an the development of osgi components is described in section  [ sec : osgidevproc ] .",
    "beht , our tool is discussed in section  [ sec : tool ] together with related implementation questions .",
    "an evaluation is described in section  [ sec : eval ] .",
    "related work is discussed in section  [ sec : rw ] and a conclusion featured in section  [ sec : concl ] .",
    "here , we present and discuss a general implementation independent concept of behavioral types .",
    "our behavioral types essentially support finite automata and regular expressions as the main specification format .",
    "finite automata and regular expressions can easily be transformed in one another .",
    "finite automata are used for specifying expected incoming , potential outgoing method calls , the creation and deletion of components during a time span and other events that may occur in the lifetime of a system .",
    "a component s behavior can be specified by one or multiple automata each one describing a behavioral aspect .",
    "formally , we have an alphabet of labels @xmath0 , a set of locations @xmath1 , an initial location @xmath2 and a set of transition edges @xmath3 where each transition is a tuple @xmath4 with @xmath5 and @xmath6 .",
    "these are aggregated into a tuple to form a behavioral specification :    @xmath7    this view abstracts from the specifications given in section  [ sec : osgi ] .",
    "our intention is to define interaction protocols or some aspects of them like the expected order of incoming and outgoing method calls for a component .",
    "specifications for different components are independent of each other as long as there is no method call ( e.g. , indicated by the same label name ) in the specifications .",
    "[ [ example - two - components - interacting ] ] example : two components interacting + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    specifications can be used for different behavioral aspects .",
    "figure  [ fig : oldnewprot ] shows two excerpts of automata for outgoing and expected method calls from two different component specifications :    @xmath8 + and + @xmath9    here , the first component can do two different method calls in its initial state : newprtcl , oldprtcl .",
    "the second component expects one method call newprtcl in its initial state .        in this case",
    "both components may interact with each other , if both components use the newprtcl .",
    "[ [ interaction - protocols - for - bundles - and - objects ] ] interaction protocols for bundles and objects + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    objects and bundles can register a service protocol  describing , e.g. , incoming method calls  that they expect . this can be done by using :    * _ regular expressions .",
    "_ thereby bundles and objects can indicate expected events .",
    "events can be incoming or outgoing method calls .",
    "thus , the regular expression specifies their order .",
    "regular expressions are terms over an alphabet of events using the @xmath10 for alternatives , the @xmath11 for concatenation and the @xmath12 as the star operator . *",
    "_ finite automata .",
    "_ regular expression can be described by an equivalent finite automaton , too .",
    "we define our finite automata as a set of locations , an initial location and a transition relation comprising a predecessor and a successor location labeled with an event .    while in our applications the event is typically a method call or a set of method calls , other possibilities like timing events , or creation and deletion of objects and bundles are also possible .        for example",
    "the protocol given in figure  [ fig : osgiservicefile2 ] can be described as a regular expression as follows :    ( ( inc : lock)@xmath11(inc : read @xmath10 inc : write)@xmath12@xmath11(inc : unlock))@xmath12    the expression describes a sequence that can be repeated .",
    "it starts with a lock and ends with an unlock . between lock and",
    "unlock an arbitrary number of read and write operations can occur .",
    "the inc denotes expected incoming method call .    the actions from figure  [ fig : osgiservicefile2 ]",
    "describe outgoing method calls .",
    "this can be written using our regular expressions as :    ( out : lockf1)@xmath11(out : lockf2)@xmath11 + ( ( out : readf1 ) @xmath10 ( out : readf2 ) @xmath10 ( out : writef1 ) @xmath10 ( out : writef2))@xmath12@xmath11 + ( out : unlockf2)@xmath11(out : unlockf1 )    and    ( out : lockf2)@xmath11(out",
    ": lockf1)@xmath11 + ( ( out : readf1 ) @xmath10 ( out : readf2 ) @xmath10 ( out : writef1 ) @xmath10 ( out : writef2))@xmath12@xmath11 + ( out : unlockf1)@xmath11(out : unlockf2 )    one can now use these protocol specifications , e.g. , for checking :    * _ compatibility _ this addresses the question if the operations that one object expects to be called are called by another object . furthermore , the correct order of calls is of interest . *",
    "_ additional properties _ properties that relate distinct semantical aspects of bundles and objects are of interest . in the given example",
    ", the question arises whether a deadlock can occur or not .    in order to perform these checks and",
    "analysis one has to match elements of a specification for one component with elements of a specification from another component . in the given example",
    "the protocol comparison has to deal with two instances of a file component and has  for example  to relate the ( out : lockf1 ) and ( out : lockf2 ) with instances of ( inc : lock ) .    [",
    "[ parameterized - specifications ] ] parameterized specifications + + + + + + + + + + + + + + + + + + + + + + + + + + + +    for facilitating the relation of specifications we define parameterized specifications .",
    "these comprise :    * _ parameterized regular expressions . _ here , each event used in a regular expression can be augmented with a parameter . for our example",
    "file component specification this results in the following expression , parameterized with @xmath13 .",
    "+ ( ( inc : lock@xmath13)@xmath11(inc : read@xmath13 @xmath10 inc : write@xmath13)@xmath12@xmath11(inc : unlock@xmath13))@xmath12 * _ parameterized automata . _ similar to regular expressions , locations and events in transitions of automata can be augmented with parameters .",
    "instantiation is done , by substituting concrete values for the parameter .",
    "instantiation of parameters is dependent on concrete application scenarios .",
    "[ [ example - instantiations - of - parameterized - specifications ] ] example instantiations of parameterized specifications + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we regard two kinds of instantiations as particularly useful for describing a protocol of expected incoming method calls .",
    "consider the refined version of figure  [ fig : osgiservicefile2 ] in figure  [ fig : instparamspec ] for locking and unlocking a resource .",
    "the lock state as well as the method calls that lead to the lock state are parameterized .        *",
    "a first instantiation is shown in figure  [ fig : instparam ] . here",
    ", the parameter is instantiated by instances @xmath14 .",
    "each of them gets its own lock state and its own method call that lead to this lock state .",
    "+    * in case only one lock state is wanted , one can still deal with different parameterized method calls and use the instantiation shown in figure  [ fig : instparamex ] +",
    "a potential major advantage by using behavioral types is the support of a seamless integration of behavioral specification throughout the development phase and the life cycle of a system .",
    "our behavioral types can be used for different purposes ( we proposed them partially in @xcite ) at development and runtime .",
    "the main idea of using behavioral types at development time is to derive them from requirements as shown in figure  [ fig : devchain ] and use them for    * refinement checking of different forms of specification for the same entity that are supposed to have some semantical meaning in common .",
    "for example , the abstract specification , source code and compiled code of the same component represent different abstraction levels and should fulfill the same behavioral type .",
    "checking this could be done by using static analysis at development time .    at the end",
    ", a developed osgi bundle is deployed including the behavioral type files .",
    "these can now be used for additional ( dynamic ) operations in the running system .",
    "a feature that can be performed at compile and at runtime is    * the compatibility checking for the composition of software components and the generation of glue code  for behavioral type coercion  to overcome possible incompatibilities    at runtime of a system this feature can help dynamic reconfiguration .",
    "figure  [ fig : behtrt ] shows two operations which can be carried out at runtime of a system :    * the registration and discovery of components using the osgi framework , * the compatibility , e.g. , deadlock checking of bundle interaction protocols .",
    "furthermore , another operation that could be invoked at runtime is    * the adaptation of a component to act according to a required protocol .",
    "this can be a solution for dynamic type coercion .",
    "behavioral runtime monitors ( figure  [ fig : behtrvmon ] ) as featured in this paper comprise    * the generation of the behavioral runtime monitor and its connection using aspects at development time and * the actual monitoring at runtime .",
    "this section presents our implementation work on beht : the eclipse based framework for behavioral types of osgi components .",
    "some parts are already published in @xcite .",
    "our behavioral types provide an abstract description of a components behavior and thus provide a way of formalizing specifications associated with the component .",
    "they can be used as a basis for checking the compatibility of components  for composing components into new ones , and interaction of different components  and for providing ways to make components compatible using coercion .",
    "type conformance can be enforced at compile time ( e.g. , like primitive datatypes int and float in a traditional typing system )  if decidable and feasible  or at runtime of a system  e.g. , like whether a pointer is assigned to an object of a desired type at runtime in a traditional typing system .    in our work behavioral types",
    "are realized as files that contain a description of ( parts of the ) behavior of an osgi component .",
    "typically , there should be one file per bundle , or class definition .",
    "but different aspects of behavior may also be realized using different files . in eclipse",
    "the files are associated with an osgi bundle by putting them in the same project folder in the eclipse workspace .    here , behavioral types are formally defined using the following ingredients .",
    "[ [ behavioral - type - automaton ] ] behavioral type automaton + + + + + + + + + + + + + + + + + + + + + + + + +    a behavioral type automaton is a finite automaton represented as a tuple @xmath7 comprising an alphabet of labels @xmath0 , a set of locations @xmath1 , an initial location @xmath2 and a set of transition edges @xmath3 where each transition is a tuple @xmath4 with @xmath5 and @xmath6 .",
    "a consistency condition on our types is that all @xmath6 appear in some transition in @xmath3 .    in this paper , since we are interested in method calls , @xmath3 is the set of method names of components .",
    "the definition presented here can be used for specifying the behavior of single objects , all objects from a classes , bundles and their interactions .",
    "it can be used for monitoring incoming method calls , outgoing method calls , or both .",
    "[ [ maximal - execution - time - table ] ] maximal execution time table + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in addition to the protocol defined by the behavioral type automaton , we define the maximal execution time of methods as a mapping @xmath15 from the set of method names @xmath0 to their maximal execution time in milliseconds . the specification of a maximal execution time is optional , thus , the @xmath16 entry indicates that no maximal execution time is set .",
    "[ [ behavioral - types ] ] behavioral types + + + + + + + + + + + + + + + +    a behavioral type in our framework may comprise a behavioral type automaton and a maximal execution table .",
    "in addition to this , it may comprise parameterized specifications , ltl formula , regular expressions and information on what is specified . here",
    ", indications on the nature of events and textual descriptions are available .",
    "we have implemented a behavioral runtime monitor generator as described in section  [ sec : osgidevproc ] for beht following the outline of figure  [ fig : behtrvmon ] .",
    "regardless of what we intend to monitor , the monitor generation from a specification is the same .",
    "it is done automatically from a behavioral type file and generates a single java file that defines a single monitor class .",
    "figure  [ fig : genmonex ] shows a generated monitor .",
    "monitors are generated as classes bearing a name derived from the original behavioral type .",
    "they comprise a map maxtimes that maps method names to their maximal execution time in milliseconds .",
    "this entry is optional .",
    "if present , this map is initialized by the constructor     public clientinstance_out_realistic_simple_mon ( )    in the example  of the monitor with the values specified for methods in the behavioral type file .",
    "generated from an automaton from the behavioral type our behavioral runtime monitors comprise a static enumeration type with the location names of the automaton . in the automaton ,",
    "the locations locs0 , locs1 are present . using this type a state transition function generated from the transition relation",
    "is generated .",
    "the state transition function takes a string encoding a method name ",
    "event name  and updates a state field protected location state of the method .",
    "this field is initialized on object creation with the name of the initial state : locs0 in the example .",
    "the generated monitors are connected to the component that shall be observed using aspectj aspects .",
    "aspectj is an extension of java that features aspect oriented programming .",
    "aspects are specified in separate files and feature pointcuts that allow the specification of locations where java code specified in the aspect shall be added to existing java code .",
    "this weaving of aspect code into existing java code is done on bytecode level .",
    "monitors are created and called from aspects .",
    "all extra code needed to integrate the monitors is defined in the aspectj files or in libraries accessed through the aspectj files .",
    "there is no need to touch the source code of a component .",
    "this independence of source code and specification is a design goal of our framework .",
    "we distinguish different kinds of monitor deployment .",
    "each kind requires its own aspect and especially its adaptation .",
    "[ [ singleton - monitors ] ] singleton monitors + + + + + + + + + + + + + + + + + +    in some cases it is sufficient to use a singleton instance of a monitor .",
    "this is the case when monitoring all the method calls that occur in a bundle , within all objects of a class , or within a singleton object . for monitoring method call orders , we use a before pointcut in aspectj .",
    "figure  [ fig : exaspect ] shows an example aspect : here , before the calls to methods  specified in the execution pattern after the `` : '' in the pointcut  of all objects of class middlewareproc an update on the state transition function  the com.nextstate  is inserted .",
    "we extract the name of the called method using reflection and a helper method ajmonhelpers.getmethodname and pass it to the state transition function .",
    "in addition to updating the state field in the monitor we get a boolean value indicating whether the monitored property is still fulfilled . in case of a deviation the behavioraltypeviolationexception",
    " a runtime exception is thrown .",
    "the implementation of the middlewareproc class may or may not catch this exception and react to it .",
    "[ [ multiple - monitor - instances ] ] multiple monitor instances + + + + + + + + + + + + + + + + + + + + + + + + + +    in same cases we want to monitor each object of a class with an independent monitor . here",
    ", we create on call of the object s constructor an individual monitor for the object .",
    "it is added to a ( hash)map ( object @xmath17 monitor ) . since the aspectj pointcuts are defined with respect to the static control flow information specified in the source code of a class , on each call of a method belonging to the class to be monitored , we use the same code in each object and chose the monitor for the particular object by looking it up from the map and advance the respective monitor state .    [ [ monitoring - of - time ] ] monitoring of time + + + + + + + + + + + + + + + + + +    monitoring time is done using java timers within the java code associated with the pointcuts . on call of a method",
    "we create a timer that is scheduled to throw an exception after the specified maximal execution time . using the after pointcut",
    ", the timer is canceled if the method s execution finishes on time and thus , no exception is thrown in this case .",
    "the adaptation of an aspect for monitoring a particular component is simple .",
    "one has to take the appropriate aspectj .aj file and adapt it , by inserting the names of the classes and packages that shall be monitored and the correct monitor names .",
    "weaving of the aspects is done automatically on java bytecode level and no additional configuration needs to be done .",
    "we have developed and implemented different operations for handling and comparing behavioral types , for deciding compatibility and for deadlock freedom .",
    "simple comparison for equality of types and comparison for refinement between two automata based specifications involves the following steps .    * a basis for the comparison of two types is the establishment of a set of semantical artifacts ( e.g.",
    ", method calls ) that shall be considered .",
    "the default is to use the union of all semantical artifacts that are used in the two types .",
    "comparison for refinement is achieved by eliminating certain semantical artifacts from this set . for consistency",
    "this also requires eliminating associated transitions from the types or , depending on the desired semantics , replacing an edge with an empty or @xmath18 label .",
    "* it is convenient to complete specifications for further comparison : specification writer may only have specified method calls or other semantical artifacts that trigger a state change . here , we automatically add an error location .",
    "we collect possible labels and for locations that do not have an edge for a label leading to another location indicating a possible semantical artifact , we add edges with the missing label to the error location . * in case of specifications which have been completed and that have no locations with two outgoing edges with the same labels , we perform a minimization of automata based specifications .",
    "this way , we merge locations and get rid of unnecessary complexity automatically . *",
    "normalization of automata based specifications .",
    "this , involves the ordering of edges and in some cases locations with respect to the lexicographic order of their labels / location names .",
    "* checking for equality involves the checking of equality of the labels on edges .",
    "optionally , one can also consider the equality of location names of an automaton . location names may imply some semantics but in our standard settings they only serve as ids .",
    "when location names serve only as ids , we construct a mapping between location names of the two automata involved in the comparison operation .",
    "these operations have been implemented in java .",
    "they do not need additional tools or non - standard plugins .",
    "in addition to the operations described in section  [ sec : deccomp ] we have adapted a sat and game - based tool ",
    "vissbip presented in @xcite  to serve as a compatibility and deadlock checker for our behavioral types for osgi .",
    "our framework uses vissbip to support the checking of the following properties :    * deadlocks checking : deadlocks resulting from potential sequences of method calls can be detected . *",
    "compatibility : a component anticipating a certain behavior of incoming method calls matches potential behavior of outgoing method calls by other components .    vissbip uses a simplified version of the bip semantics @xcite . a system comprises concurrent automata with labeled edges .",
    "the automata synchronize with each other by performing edges with the same labels in parallel . otherwise , the default case is that automata do not synchronize with each other . for comparing method call based behavioral specifications we use vissbip on specifications that comprise expected incoming and outgoing method calls of components . in osgi synchronization between components happens only when one component calls a method of the other component as indicated in the behavioral specification and the osgi semantics . on the vissbip side",
    "this corresponds to same labels in the automata that represent the behavior .",
    "in addition to the label compatibility checking , vissbip is able to perform the introduction of priorities .      one way of runtime adaption is the reaction to potential deadlocks or incompatibilities .",
    "recall figure  [ fig : oldnewprot ] : it shows behavioral specifications of two components which intend to communicate with each other .",
    "possible outgoing method calls of one component and expected incoming method calls of the other component are shown .",
    "it can be seen that the first component is able to communicate using two different protocols : one starts by calling an initialization method newprtcl , the other one starts by calling an initialization method oldprtcl .",
    "the other component expects the newprtcl call .",
    "when we give these two specifications to vissbip , it will return a list of priorities where the newprtcl edge is favored over the oldprtcl edge in the first specification . in a java",
    "implementation the first component can use this to dynamically decide at runtime which protocol to use .",
    "* first , the component loads its own behavioral specification and the specification of the expected method calls of the second component .",
    "technically , we support loading files and the registration of models as properties / attributes of bundles as provided by the osgi framework . *",
    "next , we invoke vissbip or another checking routine . passing the behavioral specifications as parameters . *",
    "the checking routine gives us a list of priorities .",
    "in the java code we have a switch statement as a starting point for handling the different protocols .",
    "we check the priorities and go to the case for the appropriate protocol .",
    "thus , in addition to deadlock detection , we can use behavioral specifications for coping with different versions of components and desired interacting protocols .",
    "a central feature of our behavioral descriptions for osgi components is registering them to a central osgi instance . in order to inform other components of the existence of a bundle with behavioral offers and needs ,",
    "we register its behavioral properties using the osgi service registry belonging to a bundlecontext which is accessible for all bundles in the osgi system :    ....    registerservice(java.lang.string [ ] clazzes ,       java.lang.object service ,       java.util.dictionary<java.lang.string , ?",
    "> properties ) ....    here , we register a collection of behavioral objects as properties for a service representing a bundle under a string based key . in our framework",
    ", we register a collection of behavioral models as `` behavior '' .",
    "the behavioral models are loaded from xml files that are integrated into the bundle .",
    "the behavioral models come with meta information which identify the parts of the behavior of a bundle which they describe .",
    "the service itself is represented as an object .",
    "additional interface information is passed using the clazzes argument .",
    "our evaluation features a booking system ( @xcite ) as an example .",
    "it is evaluated with respect to different aspects of behavioral types including behavioral runtime monitoring .",
    "we present the use of behavioral types to highlight some features and usages of our work on an example : a flight booking system .",
    "figure  [ fig : fbcomps ] shows the main ingredients of our flight booking system .",
    "clients are served by middleware processes which are created and managed by a coordination process .",
    "middleware processes use concurrently a flight database and a payment system .",
    "the described system is an example inspired by realistic systems where the middleware is implemented using java / osgi .",
    "in addition to the middleware components we describe databases and parts of the frontend using our behavioral types to make checks of these parts possible .",
    "the following means of behavioral interaction can be distinguished :    * * component calls between methods / communication protocol * in our flight booking system , a client can call a coordination process and middleware processes .",
    "middleware processes can call methods providing access to the flight database and the payment subsystem .",
    "the method calls need to respect a distinct protocol which can be encoded using our behavioral types . * * creation and deletion of new components * the coordination process creates and removes middleware process such that there is one process per client . providing support for analysis of such dynamic aspects is a long term goal for our behavioral types but not in the scope of this work . * * concurrent access to shared resources * middleware processes perform reservations , cancellations , rebookings , seat reservations and related operations on the flight database .",
    "these operations do require the locking of parts of the data while an operation is performed .",
    "for example , during a seat reservation a certain amount of the available seats in an aircraft is locked so that a customer can chose one without having to fear that another customer will chose the same seat at the very same time . in the current state",
    "we are able to provide some behavioral types support here .",
    "[ [ example - specification - of - outgoing - method - calls - of - a - middleware - process ] ] example : specification of outgoing method calls of a middleware process + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    specifications of possible expected incoming and potential outgoing method calls give information about a communication protocol that is to be preserved .",
    "typically different interaction sequences are possible , especially since we are dealing with abstractions of behavior . in the booking system ,",
    "a middleware process communicates with a flightdatabase ( db ) and the payment system ( pay ) .",
    "the expected order of method calls for a flight booking to these systems is shown in figure  [ fig : commprot1 ] .",
    "the figure shows only an excerpt of the possible states and transitions .",
    "in addition to this , the initial state allows the start of a seat reservation process and a cancellation process .",
    "moreover , figure  [ fig : commprot1 ] shows only the state changing method calls of the behavioral specification of the booking process .",
    "our real behavioral specification completely lists all possible method calls in each state .",
    "this way , we can further analyze compatibility issues for example with database systems that do not support all possible method calls of a middleware process .    in comparison to the outgoing method",
    "calls of a middleware process , the incoming method call specification is much simpler : a constructor call is performed by the coordination process upon initialization .",
    "after that , the communication with the client is done using a webserver interface  comprising method calls that send raw request data to the middleware process and return raw response data that trigger , e.g. , displaying selected flights by the client  where no states in the communication process can be distinguished .",
    "[ [ example - specification - of - database - elements ] ] example : specification of database elements + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    access to our database is done using method calls to a database process and is formalized using our automata based specification formalisms .",
    "the method calls result in locking and unlocking database elements .",
    "seat reservation in a flight requires that a certain partition of the available seats is blocked during the selection process so that a client can make a choice .",
    "figure  [ fig : seatres ] shows our behavioral model of seat reservation for a single flight .",
    "different loads are distinguished : low means that many seats are still available , while high means that only a few seats are available .",
    "the full state indicates that no additional seat reservations can be made , only cancellations are possible .",
    "the model is an abstraction of the reality since instead of treating each seat  potentially hundreds of available seats ",
    "independently we only distinguish their partitioning into four equivalence classes : low , medium , high and full .",
    "[ [ example - database - elements - and - deadlocks ] ] example : database elements and deadlocks + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    access to the flight database can result in deadlocks . the model from figure  [ fig : seatres ] can serve as a basis for deadlock analysis .",
    "consider the scenario shown in figure  [ fig : concseatres ] :        for each flight a different instance of the seat reservation model exists .",
    "given three airports a , b and c : suppose two people  person 1 and person 2  want to fly from a to c via b. seats for two flights need to be reserved : from a to b and from b to c. it is not desirable to reserve a seat from b to c if no seat is available for the flight to a to b. otherwise , it might not be desirable to fly from a to b if no seat is available for the flight from b to c.    during the seat reservation a deadlock may occur : if person 1 reserves the last seat for the a to b flight before doing reservations for the b to c flight and person 2 reserves the last seat for the b to c flight before a seat reservation for the a to b flight a deadlock may occur , which may result in the cancellation of both journeys although one person could have taken the journey .",
    "if it is known before to the seat reservation system that person 1 and person 2 will fly from a to c  which is a reasonable assumption given the fact that they have entered their desired start and end destination into the system  we are able to detect such deadlocks",
    ". they can occur if both behavioral models of the seat reservation system are already in the high state  given that no other participants are doing reservations at this time we may also take compensating actions .",
    "different scenarios for the use and deployment of behavioral types have been tested by us .",
    "one example scenario is the flight booking system .",
    "osgi components and their interactions are shown .",
    "the entire system could be deployed as an osgi based middleware that offers its services to the external world using webservices .",
    "clients are represented as proxy components in the system and served by middleware processes which are created and managed by a coordination process .",
    "middleware processes use concurrently a flight database and a payment system which are represented by proxy osgi components .",
    "we have investigated the communication structure between the components and investigated deployment of monitors .",
    "this comprises the following cases :    * the use of multiple monitors running in parallel and being created at runtime for different objects which are created dynamically . in the example system this is the case for the middleware processes , where processes are created as separate objects on demand and are monitored independently of each other . * the monitoring of all objects of a single class using a single monitor and the monitoring of singleton objects and the monitoring of bundle behavior",
    "this is , e.g. , the case in the payment subsystem .",
    "different aspects as described in section  [ sec : aspects ] were adapted for this .",
    "monitors together with an implementation of the system that realized the communication between the components was deployed using the osgi equinox implementation .",
    "furthermore , we have investigated the monitoring of maximal execution time of methods . in the example system",
    "this is the case in the payment subsystem and access to the flight database .",
    "we did not find any major problems in our approach .",
    "[ [ behavioral - runtime - monitors - and - osgi ] ] behavioral runtime monitors and osgi + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    as described in section  [ sec : beht ] our behavioral type efforts are particularly aimed towards osgi .",
    "while features that are not subject to the contribution of this paper like component discovery using behavioral types are only feasible in an osgi like component framework , we did find no principal issues that prevent the use of our types for behavioral runtime monitoring in other java contexts .",
    "technically , the osgi framework gives us with bundles yet another structuring layer for software components , which we use in the specification of our types and we believe has a good granularity for the communication protocol specifications that we primarily regard .",
    "the generation of entire classes for each monitor instead of integrating the complete monitor inside of aspects like in @xcite is also justified on this granularity .",
    "the editors and generation mechanism depend on eclipse which is realized on - top of osgi .",
    "the behavioral monitor connection using aspects depends on aspectj , some technical issues are mentioned above .",
    "interface automata @xcite are one form of behavioral types . like in this work ,",
    "component descriptions are based on automata .",
    "the focus is on communication protocols between components which is one aspect that we also address in this paper .",
    "while the used formalism for expressing behavior in interface automata is more powerful ( timed automata vs. automata vs. timing annotation per method ) , interface automata do not target the main focus of this paper : checking the behavior at runtime of a component by using some form of monitoring .",
    "they are especially aimed at compatibility checks of different components interacting at compile time of a system .",
    "the term behavioral types is used in the ptolemy framework @xcite . here , the focus is on real - time systems .",
    "specification and contract languages for component based systems have been studied in the context of web services . a process algebra like language and deductive techniques",
    "are studied in @xcite .",
    "another process algebra based contract language for web services is studied in @xcite .",
    "emphasize in the formalism is put on compliance , a correctness guaranty for properties like deadlock and livelock freedom .",
    "another algebraic approach to service composition is featured in @xcite .",
    "jml @xcite provides assertions , pre- and postconditions for java programs .",
    "it can be used to specify aspects of behavior for java methods .",
    "assertion like behavioral specifications have also been studied in the context of access permissions  @xcite .",
    "behavioral types as means for behavioral checks at runtime for component based systems have been investigated in  @xcite . in this work ,",
    "the focus is rather put on the definition of a suitable formal representation to express types and investigate their methodical application in the context of a model - based development process .    a language for behavioral specification of components , in particular of object oriented systems  but not osgi ",
    ", is introduced in  @xcite .",
    "compared to the requirement - based descriptions proposed in our paper , the specifications used in @xcite are still relatively close to an implementation .",
    "recent work regarding refinement of automata based specifications is , e.g. , studied in @xcite .",
    "the runtime verification community has developed frameworks which can be used for similar purpose as our behavioral type based monitors .",
    "the mop framework @xcite allows the integration of specifications into java source code files and generates aspectj aspects which encapsulate monitors .",
    "compared to this work , the intended goals are different . while we keep the specification and implementation part separate , in order to be able to use the specification for different purposes at development , compile and runtime , a close integration of specification and code",
    "is often desired and realized in the runtime verification frameworks .",
    "a framework taking advantage of the trade - off between checking specifications at runtime and at development time has been studied in @xcite .",
    "a framework that generates independent java monitors leaving the instrumentation aspect to the implementation is described in @xcite .",
    "other topics explored in this context comprise , e.g. , the efficiency and expressiveness of monitoring @xcite but are less focused on software engineering aspects compared to this paper .",
    "monitoring of performance and availability attributes of osgi systems has been studied in @xcite . here , a focus is on the dynamic reconfiguration ability of osgi .",
    "another work using the .net framework for runtime monitor integration is described in @xcite .",
    "runtime monitors for interface specifications of web - service in the context of a concrete e - commerce service have been studied in  @xcite .",
    "behavioral conformance of web - services and corresponding runtime verification has also been investigated in  @xcite .",
    "runtime monitoring for web - services where runtime monitors are derived from uml diagrams is studied in  @xcite .",
    "runtime enforcement of safety properties was initiated with security automata  @xcite that are able to halt the underlying program upon a deviation from the expected behaviors . in our behavioral types framework , the enforcement of specifications is in parts left to the system developer , who may or may not take potential java exceptions resulting from behavioral type violations into account .",
    "our behavioral types represent an abstract view on the semantics of osgi .",
    "we have summarized our work on the osgi semantics in a report @xcite .",
    "other work does describe osgi and its semantics only at a very high level . a specification based on process algebras",
    "is featured in @xcite .",
    "means for ensuring osgi compatibility of bundles realized by using an advanced versioning system for osgi bundles based on their type information is studied in @xcite .",
    "some investigations on the relation between osgi and some more formal component models have been done in @xcite .",
    "aspects on formal security models for osgi have been studied in @xcite .",
    "we presented our beht framework for behavioral types for osgi systems , a development process for osgi applications and some motivation and evaluation .",
    "so far , we are concentrating on eclipse / osgi systems .",
    "other application areas for the future comprise 1 ) work towards behavioral types for distributed software services 2 ) work towards real - time embedded systems .",
    "this might require leaving the java / osgi setting , since these applications typically involve c code which communicates directly with  if at all  an operating system .",
    "there is , however , work on extensions for real - time applications of osgi using real - time java ( e.g. , @xcite ) .",
    "additional specification formalisms and the integration of new checking techniques are another challenge .",
    "j. c. amrico , w. rudametkin , and d. donsez . managing the dynamism of the osgi service platform in real - time java applications .",
    "proceedings of the 27th annual acm symposium on applied computing , acm , 2012 .",
    "h. barringer , y. falcone , k. havelund , g. reger , d. rydeheard .",
    "quantified event automata : towards expressive and efficient runtime monitors .",
    "18th international ssmposium on formal methods , vol .",
    "7436 of lncs , springer - verlag , 2012 .",
    "( fm12 )            j. o. blech . towards a framework for behavioral specifications of osgi components .",
    "10th international workshop on formal engineering approaches to software components and architectures .",
    "electronic proceedings in theoretical computer science , 2013 .",
    "j. o. blech , y. falcone , h. rue , b. schtz .",
    "behavioral specification based runtime monitors for osgi services . leveraging applications of formal methods , verification and validation ( isola ) , vol .",
    "7609 of lncs , springer - verlag , 2012 .",
    "j. o. blech and b. schtz .",
    "towards a formal foundation of behavioral types for uml state - machines .",
    "5th international workshop uml and formal methods .",
    "paris , france , acm sigsoft software engineering notes , august 2012 .",
    "n. catao and i ahmed .",
    "lightweight verification of a multi - task threaded server : a case study with the plural tool .",
    "proceeding of formal methods for industrial critical systems ( fmics ) , vol 6959 of lncs , springer , 2011 .",
    "p. chalin , j.r .",
    "kiniry , g.t . leavens , e. poll . beyond assertions : advanced specification and verification with jml and esc / java2 .",
    "formal methods for components and objects , fmco , vol .",
    "4111 of lncs , springer 2005 .    c. cheng , h. rue , a. knoll , c. buckl .",
    "synthesis of fault - tolerant embedded systems using games : from theory to practice .",
    "verification , model checking , and abstract interpretation , vol 6538 of lncs , springer 2011 .",
    "o. gadyatskaya , f. massacci , a. philippov . security - by - contract for the osgi platform .",
    "information security and privacy conference , ifip advances in information and communication technology , vol .",
    "376 , 2012 .",
    "y. gan , m. chechik , s. nejati , j. bennett , b. ofarrell , j. waterhouse .",
    "runtime monitoring of web service conversations .",
    "proceedings of the 2007 conference of the center for advanced studies on collaborative research , acm 2007 .        e. b. johnsen and r. hhnle and j. schfer and rudolf schlatte and martin steffen .",
    "abs : a core language for abstract behavioral specification .",
    "post conf .",
    "proceedings 9th intl .",
    "symposium on formal methods for components and objects 2010 .",
    "springer - verlag 2010 .",
    "p. oneil meredith , d. jin , d. griffith , f. chen , g. rou .",
    "an overview of the mop runtime verification framework .",
    "international journal on software techniques for technology transfer , springer - verlag , 2011 .",
    "c. prehofer . behavioral refinement and compatibility of statechart extensions . formal engineering approaches to software components and architectures .",
    "electronic notes in theoretical computer science , 2012 .",
    "f. souza , d. lopes , k. gama , n. rosa , r. lima .",
    "dynamic event - based monitoring in a soa environment . on the move to meaningful internet systems ,",
    "7045 of lncs , springer - verlag , 2011 .",
    "tchinda , n. stouls , j. ponge .",
    "spcification et substitution de services osgi . technical report ,",
    "inria ( 2011 ) http://hal.inria.fr/inria-00619233 ."
  ],
  "abstract_text": [
    "<S> this report presents our work on behavioral types for osgi component systems . </S>",
    "<S> it extends previously published work @xcite and presents features and details that have not yet been published . </S>",
    "<S> in particular , we cover a discussion on behavioral types in general , and eclipse based implementation work on behavioral types . </S>",
    "<S> the implementation work covers : editors , means for comparing types at development and runtime , a tool connection to resolve incompatibilities , and an aspectj based infrastructure to ensure behavioral type correctness at runtime of a system . </S>",
    "<S> furthermore , the implementation comprises various auxiliary operations . </S>",
    "<S> we present some evaluation work based on examples . </S>"
  ]
}