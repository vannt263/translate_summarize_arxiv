{
  "article_text": [
    "minimization of a deterministic finite automaton ( dfa ) is a classic problem in computer science .",
    "let @xmath2 be the number of states , @xmath3 the number of transitions and @xmath4 the size of the alphabet of the dfa .",
    "hopcroft made a breakthrough in 1970 by presenting an algorithm that runs in @xmath7 time , treating @xmath4 as a constant  @xcite .",
    "gries made the dependence of the running time of the algorithm on @xmath4 explicit , obtaining @xmath5  @xcite .",
    "( complexity is reported using the ram machine model under the uniform cost criterion  @xcite . )",
    "our starting point was the paper by knuutila in 2001 , where he presented yet another @xmath5 algorithm , and remarked that some versions which have been believed to run within this time bound actually fail to do so  @xcite .",
    "hopcroft s algorithm is based on using only the `` smaller '' half of some set ( known as _ block _ ) that has been split .",
    "knuutila demonstrated with an example that although the most well - known notion of `` smaller '' automatically leads to @xmath8 , two other notions that have been used may yield @xmath9 when @xmath10 .",
    "he also showed that this can be avoided by maintaining , for each symbol , the set of those states in the block that have input transitions labelled by that symbol . according to  @xcite",
    ", hopcroft s original algorithm did so .",
    "some later authors have dropped this complication as unnecessary , although it is necessary when the alternative notions of `` smaller '' are used .",
    "knuutila mentioned as future work whether his approach can be used to develop an @xmath0 algorithm for dfas whose transition functions are not necessarily total .",
    "for brevity , we call them pt - dfas . with an ordinary dfa , @xmath0 is the same as @xmath8 as @xmath11 , but with a pt - dfa it may be much better .",
    "we present such an algorithm in this paper .",
    "we refined knuutila s method of maintaining sets of states with relevant input transitions into a full - fledged data structure for maintaining refinable partitions . instead of maintaining those sets of states ,",
    "our algorithm maintains the corresponding sets of transitions .",
    "another instance of the structure maintains the blocks .",
    "knuutila seems to claim that such a pt - dfa algorithm arises from the results in  @xcite , where an @xmath0 algorithm was described for refining a partition against a relation .",
    "however , there @xmath12 , so the solved problem is not an immediate generalisation of ours .",
    "extending the algorithm to @xmath13 is not trivial , as can be appreciated from the extension in  @xcite .",
    "it discusses @xmath0 without openly promising it .",
    "indeed , its analysis treats @xmath4 as a constant .",
    "it seems to us that its running time does have an @xmath14 term . in section  [ abstr_algo ]",
    "we present an abstract minimization algorithm that , unlike  @xcite , has been adapted to pt - dfas and avoids scanning the blocks and the alphabet in nested loops .",
    "the latter is crucial for converting @xmath14 into @xmath3 in the complexity .",
    "the question of what blocks are needed in further splitting , has led to lengthy and sometimes unconvincing discussions in earlier literature .",
    "our correctness proof deals with this issue using the `` loop invariant '' paradigm advocated in  @xcite .",
    "our loop invariant `` knows '' what blocks are needed .",
    "section  [ ref_part ] presents an implementation of the refinable partition data structure .",
    "its performance relies on a carefully chosen combination of simple low - level programming details .",
    "the implementation of the main part of the abstract algorithm is the topic of section  [ block - splitt ] .",
    "the analysis of its time consumption is based on proving of two lines of the code that , whenever the line is executed again for the same transition , the end state of the transition resides in a block whose size is at most half the size in the previous time .",
    "the numbers of times the remaining lines are executed are then related to these lines .    with a time bound as tight as ours , the order in which the transitions are presented in the input becomes significant , since the @xmath15 time that typical good sorting algorithms tend to take does not necessarily fit @xmath0 .",
    "we discuss this problem in section  [ sort_trans ] , and present a solution that runs in @xmath16 time but may use more memory , namely @xmath17 .",
    "some measurements made with our implementations of knuutila s and our algorithm are shown in section  [ meacon ] .",
    "a _ pt - dfa _ is a 5-tuple @xmath18 such that @xmath19 and @xmath20 are finite sets , @xmath21 , @xmath22 and @xmath23 is explained below .",
    "the elements of @xmath19 are called _ states _ , @xmath24 is the _ initial state _ , and @xmath25 is the set of _ final states_. the set @xmath20 is the _",
    "alphabet_. we have @xmath26 , and @xmath23 satisfies the condition that if @xmath27 and @xmath28 , then @xmath29 .",
    "the elements of @xmath23 are _ transitions_. in essence , @xmath23 is a partial function from @xmath30 to @xmath19 .",
    "therefore , if @xmath31 , we write @xmath32 . if @xmath33 and @xmath34 but there is no @xmath35 such that @xmath36 , we write @xmath37 , where @xmath38 is some symbol satisfying @xmath39 .",
    "we will use @xmath40 as the number of transitions , and this number may be much smaller than @xmath41 , which is the number of transitions if @xmath23 is a full function .    by @xmath42",
    "we denote that there is a path from state @xmath43 to state @xmath35 such that the labels along the path constitute the word @xmath44 .",
    "that is , @xmath45 holds for every @xmath33 , and @xmath46 holds if and only if there is some @xmath47 such that @xmath48 and @xmath49 .",
    "the _ language _ accepted by @xmath50 is the set of words labelling the paths from the initial state to final states , that is , @xmath51 .",
    "we will also talk about the languages of individual states , that is , @xmath52",
    "@xmath53 @xmath54 .",
    "obviously @xmath55 .",
    "we say that a state is _ relevant _ , if and only if either it is the initial state , or it is reachable from the initial state and some final state is reachable from it .",
    "more precisely , @xmath56 .",
    "it is obvious that irrelevant states and their adjacent transitions may be removed from a pt - dfa without affecting its language .",
    "the initial state can not be removed , because otherwise the result would violate the condition @xmath21 in the definition of a dfa .",
    "the removal yields the pt - dfa @xmath57 , where @xmath58 and @xmath59 .",
    "if no final state is reachable from the initial state , then @xmath60 .",
    "this is handled as a special case in our algorithm , because otherwise the result might contain unnecessary transitions from the initial state to itself .",
    "for this purpose , let empty_dfa@xmath61 be @xmath62 , where @xmath63 is just any element .",
    "obviously empty_dfa@xmath61 is the smallest pt - dfa with the alphabet @xmath20 that accepts the empty language .    &",
    "@xmath64 : = remove irrelevant states and transitions from @xmath64     +  &    * if * @xmath65 * then * * return * empty_dfa(@xmath20 )     +  &    * else *     +  &    * if * @xmath66 * then * @xmath67 : = @xmath68 * else * @xmath67 : = @xmath69     +  &    @xmath70 : = @xmath71     +  &    * while * @xmath72 * do *     +  &    @xmath73 : = any_element_of@xmath74 ;  @xmath70 : = @xmath75     +  &    * for * @xmath76 such that @xmath77 * do *     +  &    @xmath78 : = @xmath79 ;   @xmath80 : = @xmath81     +  &    * if * @xmath82 * then *     +  &    @xmath83 ;   @xmath67 : = @xmath84     +  &    * if * @xmath85 * then * @xmath86 : = 1 ; @xmath87 : = 2 * else * @xmath86 : = 2 ; @xmath87 : = 1     +  &    @xmath70 : = @xmath88     +  &    @xmath70 : = @xmath89     +  &    @xmath70 : = @xmath90     +  &    @xmath91 : = @xmath67 ;  @xmath92 : = @xmath93 ;   @xmath94 : = @xmath95 ;  @xmath96 : = @xmath93     +  &    * for * @xmath97 * do *     +  &    @xmath43 : = any_element_of@xmath98     +  &    * if * @xmath99 * then * @xmath96 : = @xmath100     +  &    * for * @xmath34 such that @xmath101 * do * @xmath92 : = @xmath102     +  &    * return * @xmath103    the abstract minimization algorithm is shown in figure  [ abstr - algo ] . in it , @xmath67 denotes a _ partition _ on @xmath19 .",
    "that is , @xmath67 is a collection @xmath104 of nonempty subsets of @xmath19 such that @xmath105 , and @xmath106 whenever @xmath107 .",
    "the elements of @xmath67 are called _ blocks_. by checking all statements that modify the contents of @xmath67 , it is easy to verify that after its initialization on line  , @xmath67 is a partition on @xmath19 throughout the execution of the algorithm , except temporarily in the middle of line  .",
    "by @xmath108 we denote the block to which state @xmath43 belongs .",
    "therefore , if @xmath33 , then @xmath109 . for convenience",
    ", we define @xmath110 .",
    "if @xmath111 ever starts to hold , then it stays valid up to the end of the execution of the algorithm .",
    "elements of @xmath112 are called _",
    "splitters_. let @xmath113 .",
    "we say that splitter @xmath73 is _ nonempty _ , if and only if @xmath114 . the set @xmath70 contains those nonempty splitters that are currently `` unprocessed '' .",
    "it is obvious from line  that empty splitters would have no effect .",
    "the main loop of the algorithm ( lines  ) starts with all nonempty splitters as unprocessed , and ends when no nonempty splitter is unprocessed .",
    "the classic algorithm uses either only @xmath25 or only @xmath115 for constructing the initial splitters , but this does not work with a partial @xmath23 .",
    "the goal of the main loop is to split blocks until they are consistent with @xmath23 , without splitting too much .",
    "we will now prove in two steps that this is achieved .",
    "[ ei - liikaa - lemma ] for every @xmath116 and @xmath117 , if @xmath111 at any time of the execution of the algorithm in figure  [ abstr - algo ] , then @xmath118 .",
    "if the algorithm puts states @xmath119 and @xmath120 into different blocks on line , then either @xmath121 or @xmath122 .",
    "otherwise , it does so on line  . then there are @xmath123 , @xmath124 , @xmath125 and @xmath126 such that @xmath127 , @xmath128 and @xmath129 .",
    "let @xmath130 .    if @xmath131 , then let @xmath132 .",
    "we have @xmath133 .",
    "because the algorithm has already put @xmath134 and @xmath135 into different blocks ( they were in different blocks on line  9 ) , there is some @xmath136 such that either @xmath137 or vice versa . as a consequence ,",
    "@xmath138 is in @xmath139 or in @xmath140 , but not in both .    assume now that @xmath141 . because of lines  and , @xmath142 for every @xmath33 .",
    "there is thus some @xmath136 such that @xmath143 .",
    "we have @xmath144 .",
    "clearly @xmath145 .",
    "at this point it is worth noticing that line  is important for the correctness of the algorithm . without it ,",
    "there could be two reachable states @xmath119 and @xmath120 that accept the same language , and @xmath126 such that @xmath146 while @xmath147 is a state that accepts the empty language .",
    "the algorithm would eventually put @xmath119 and @xmath120 into different blocks .",
    "we have shown that the main loop does not split blocks when it should not .",
    "we now prove that it splits all the blocks that it should .",
    "[ tarpeeksi - lemma ] at the end of the algorithm in figure  [ abstr - algo ] , for every @xmath116 , @xmath117 and @xmath34 , if @xmath148 , then @xmath149 .",
    "to improve readability , let @xmath150 and @xmath151 . in the proof , @xmath152 , @xmath153 and @xmath154",
    "are always evaluated with the current @xmath67 , so their contents change .",
    "the proof is based on the following loop invariant :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ on line  , for every @xmath116 , @xmath117 and @xmath34 , if @xmath148 , then @xmath155 or @xmath156 or @xmath157 .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    consider the situation immediately after line  .",
    "if @xmath158 , then @xmath156 . if @xmath159 , then @xmath157 . if @xmath160 , then @xmath155 .",
    "thus the invariant holds initially .",
    "consider any @xmath119 , @xmath120 , @xmath126 and instance of executing line  such that the invariant holds .",
    "our task is to show that the invariant holds for them also when line  is executed for the next time .",
    "the case that the invariant holds because @xmath111 is simple .",
    "blocks are never merged , so @xmath111 is valid also the next time .",
    "consider the case @xmath148 , @xmath161 and @xmath162 , where @xmath163 or @xmath164 .",
    "let @xmath165 . if @xmath166 is the @xmath73 of line  , then , when @xmath167 is the @xmath168 of the * for*-loop , @xmath169 goes to @xmath78 and @xmath170 goes to @xmath80 .",
    "so @xmath148 ceases to hold , rescuing the invariant .",
    "if @xmath166 is not the @xmath73 of line  , then , whenever @xmath171 is split , lines  and  take care that both halves end up in @xmath70 . thus @xmath172 stays true keeping the invariant valid , although @xmath171 and @xmath70 may change .",
    "let now @xmath148 and @xmath155 .",
    "to invalidate the invariant , @xmath153 or @xmath154 must be changed so that @xmath173 ceases to hold .",
    "when this happens , line  puts @xmath166 into @xmath70 , where @xmath174 or @xmath164 . like",
    "above , lines  and  keep @xmath166 in @xmath70 although @xmath171 may change until line  is entered again .",
    "we have completed the proof that the invariant stays valid .    when line  is entered , @xmath175 .",
    "the invariant now yields that if @xmath148 , then @xmath176 .",
    "it is not difficult to check that lines   yield a pt - dfa , that is , @xmath91 and @xmath20 are finite sets and so on",
    ". in particular , the construction gives @xmath177 a value at most once .",
    "we now show that the result is the right pt - dfa .",
    "let @xmath178 be the result of the algorithm in figure  [ abstr - algo ] .",
    "we have @xmath179 . furthermore",
    ", every pt - dfa that accepts @xmath180 has at least as many states and transitions as @xmath181 .",
    "if it has the same number of states , it is either isomorphic with @xmath181 ( ignoring @xmath20 in the comparison ) , or it is of the form @xmath182 with @xmath183 .",
    "the case where the algorithm exits on line  is trivial and has been discussed , so from now on we discuss the case where the algorithm goes through the main part .",
    "let @xmath33 and @xmath34 .",
    "lemma  [ tarpeeksi - lemma ] implies that @xmath184 for every @xmath185 . from this line  yields @xmath186 . by induction , if @xmath136 , @xmath187 and @xmath188 in @xmath50 then @xmath189 in @xmath181 , and if @xmath190 in @xmath181 then there is @xmath187 such that @xmath191 and @xmath188 in @xmath50 .",
    "similarly , lines  and  guarantee that @xmath192 if and only if @xmath193 .",
    "together these yield @xmath194 and , in particular , @xmath195 .",
    "let @xmath196 be any pt - dfa that accepts the same language as @xmath181 .",
    "let @xmath197 . because the algorithm executed the main part , there are some @xmath198 and @xmath199 such that @xmath200 and @xmath201 .",
    "so @xmath202 , and also @xmath203 contains a state @xmath204 such that @xmath205 and @xmath206 .",
    "as @xmath207 may vary , there may be many @xmath204 with @xmath208 .",
    "we arbitrarily choose one of them and denote it with @xmath209 .",
    "lemma  [ ei - liikaa - lemma ] implies that if @xmath210 , then @xmath211 , yielding @xmath212 .",
    "so @xmath213 . if @xmath214 , then some @xmath215 , so @xmath216 . as a consequence , @xmath217 .",
    "if @xmath218 , then @xmath219 is an isomorphism .",
    "the proof has the consequence that after the end of the main loop , @xmath220 @xmath221 @xmath222 if and only if @xmath223 .",
    "let us consider the number of times a transition @xmath224 can be used on line  .",
    "it is used whenever such a @xmath73 is taken from @xmath70 that @xmath225 , that is , @xmath226 .",
    "so , shortly before using @xmath224 , @xmath227 held but ceased to hold ( line  ) . to use it again ,",
    "@xmath227 must be made to hold again . to make @xmath227 to hold again",
    ", line  or  must be executed such that @xmath228 is in the role of @xmath229 or @xmath230 , and @xmath126 is in the role of @xmath231 . but",
    "line  tests that @xmath232 , so it can not make @xmath227 to hold if it did not hold already on line  9 , although it can keep @xmath227 valid .",
    "so only line  can make @xmath227 to hold again .",
    "an important detail of the algorithm is that line  puts the _ smaller _ half of @xmath168 ( paired with @xmath126 ) into @xmath70 .",
    "therefore , each time @xmath227 starts to hold again , @xmath35 resides in a block whose size is at most half of the size in the previous time . as a consequence",
    ", @xmath224 can be used for splitting at most @xmath233 times .",
    "the refinable partition data structure maintains a partition of the set @xmath234 .",
    "our algorithm uses one instance of it with @xmath235 for the blocks and another with @xmath236 for the splitters . each set in the partition",
    "has an index in the range @xmath237 , where @xmath238 is the current number of sets .",
    "the structure supports the following operations .",
    "@xmath239 : :    returns the number of elements in the set with index @xmath240 .",
    "@xmath241 : :    returns the index of the set that element @xmath242 belongs to . @xmath243 and",
    "@xmath244 : :    the elements of the set @xmath240 can be scanned by executing    first @xmath242  : =  @xmath243 and then    * while * @xmath245 * do * @xmath242 : =    @xmath244",
    ". each element will be returned    exactly once , but the ordering in which they are returned is    unspecified . while scanning a set , @xmath246 and    @xmath247 must not be executed .",
    "@xmath248 : :    marks the element @xmath242 for splitting of a set .",
    "@xmath249 : :    if either none or all elements of set @xmath240 have been    marked , returns @xmath250 . otherwise removes the marked elements    from the set , makes a new set of the marked elements , and returns its    index . in both cases , unmarks all the elements in the set or sets . @xmath251",
    ": :    returns @xmath252 if and only if none of the    elements of @xmath240 is marked .",
    "the implementation uses the following @xmath253-element arrays .",
    "@xmath254 : :    contains @xmath255 in such an order that    elements that belong to the same set are next to each other .",
    "@xmath256 : :    tells the location of each element in    @xmath254 , that is ,    @xmath257 =    e$ ] .",
    "@xmath258 : :    the index of the set that @xmath242 belongs to is    @xmath259 $ ] .",
    "@xmath260 and @xmath261 : :    the elements of set @xmath240 are    @xmath262 $ ] ,    @xmath263 $ ] ,  ,",
    "@xmath264 $ ] , where    @xmath265 $ ] and    @xmath266 - 1 $ ] .",
    "@xmath267 : :    let @xmath219 and @xmath268 be as above , and let    @xmath269 $ ] .",
    "the marked elements are    @xmath262 $ ] ,  ,    @xmath270 $ ] , and the unmarked are    @xmath271 $ ] ,  ,    @xmath264 $ ] .",
    "initially @xmath272 , @xmath273 = { { \\mathit{mid}}}[1 ] = 1 $ ] , @xmath274 = { \\mathit{max}}+1 $ ] , and @xmath275 = { { \\mathit{loc}}}[e ] = e$ ] and @xmath259 = 1 $ ] for @xmath276 .",
    "initialization takes @xmath277 time and @xmath278 additional memory .",
    "the implementation of the operations is shown in figure  [ ref - part - ds ] .",
    "each operation runs in constant time , except @xmath247 , whose worst - case time consumption is linear in the number @xmath279 of marked elements .",
    "however , also @xmath247 can be treated as constant - time in the analysis of our algorithm , because it is amortized constant time . when calling @xmath247 ,",
    "there had been @xmath279 calls of @xmath246 .",
    "they are unique to this call of @xmath247 , because @xmath247 unmarks the elements in question .",
    "the total time consumption of these calls of @xmath246 and @xmath247 is @xmath280 , but the same result is obtained even if @xmath247 is treated as constant - time .    &",
    "@xmath281 +  & * return * @xmath282 - { { \\mathit{first}}}[s]$ ]   +  &    ' '' ''    @xmath283 +  & * return * @xmath259 $ ]   +  &    ' '' ''    @xmath284 +  & * return * @xmath285 $ ]   +  &    ' '' ''    @xmath286 +  & * if * @xmath287 + 1 \\geq { { \\mathit{end}}}[{{\\mathit{sidx}}}[e]]$ ] * then * * return * @xmath250 +  & * else * * return * @xmath288 + 1]$ ]   +  &    ' '' ''    @xmath289 +  & @xmath240 : = @xmath259 $ ] ;  @xmath268 : = @xmath287 $ ] ;  @xmath3 : = @xmath290 $ ] +  & * if * @xmath291 * then * +  & @xmath264 $ ] : = @xmath271 $ ] ;  @xmath292 $ ] : = @xmath268 +  & @xmath271 $ ] : = @xmath242 ;  @xmath287 $ ] : = @xmath3 ;  @xmath290 $ ] : = @xmath293   +  &    ' '' ''    @xmath294 +  & * if * @xmath290 = { { \\mathit{end}}}[s]$ ] * then * @xmath290 : = { { \\mathit{first}}}[s]$ ] +  & * if * @xmath290 = { { \\mathit{first}}}[s]$ ] * then * * return * @xmath250 +  & * else * +  & @xmath238 : = @xmath295 +  & @xmath296 $ ] : = @xmath297 $ ] ;  @xmath298 $ ] : = @xmath297 $ ] ;   @xmath299 $ ] : = @xmath290 $ ] +  & @xmath297 $ ] : = @xmath290 $ ] +  & * for * @xmath268 : = @xmath296 $ ] * to * @xmath299 - 1 $ ] * do * @xmath300 $ ] : = @xmath238 +  & * return * @xmath238   +  &    ' '' ''    @xmath301 +  & * if * @xmath290 = { { \\mathit{first}}}[s]$ ] * then * * return * @xmath252 +  & * else * * return *",
    "@xmath302    -0.3 cm",
    "in this section we show how lines    of the abstract algorithm can be implemented in @xmath303 time and @xmath304 ) .",
    "the implementation relies on the following data structures .",
    "the `` simple sets '' among them are all initially empty .",
    "they have only three operations , all @xmath278 time : the set is empty if and only if @xmath305 returns @xmath252 , @xmath306 adds number @xmath123 to the set without checking if it already is there , and @xmath307 removes any number from the set and returns the removed number .",
    "the implementation may choose freely the element that @xmath307 removes and returns .",
    "one possible efficient implementation of a simple set consists of an array that is used as a stack .",
    "@xmath308 , @xmath309 and @xmath310 : :    the transitions have the indices @xmath311 ,  ,",
    "@xmath40 . if @xmath312 is the index of the    transition @xmath224 , then    @xmath313 = q$ ] ,    @xmath314 = a$ ] , and    @xmath315 = q'$ ] .",
    "@xmath316 : :    this stores the indices of the input transitions of state    @xmath43 .",
    "the ordering of the transitions does not matter .",
    "this    is easy to implement efficiently .",
    "for instance , one may use an array    @xmath254 of size @xmath40 ,    together with arrays @xmath260 and    @xmath261 of size @xmath317 , so that the    indices of the input transitions of @xmath43 are    @xmath318 $ ] ,    @xmath319 + 1]$ ] ,  ,    @xmath320 - 1]$ ] .",
    "the array can    be initialized in @xmath321 time with counting    sort , using @xmath315 $ ] as the key .",
    "@xmath322 : :    this is a refinable partition data structure on    @xmath323 .",
    "it represents    @xmath67 , that is , the blocks .",
    "the index of the set    in @xmath322 is used as the index of the block    also elsewhere in the algorithm .",
    "initially    @xmath322 consists of one set that contains the    indices of the states .",
    "@xmath324 : :    this is a refinable partition data structure on    @xmath325 .",
    "each of the sets in it consists    of the indices of the input transitions of some nonempty splitter    @xmath73 .",
    "that is , @xmath324 stores    @xmath326 .",
    "the index of    @xmath327 in @xmath324 is used    as the index of @xmath73 also elsewhere in the algorithm .    for this reason",
    ", we will occasionally use the word `` splitter '' also    of the sets in @xmath324 .",
    "initially    @xmath324 consists of    @xmath328 , that is , two transitions are in    the same set if and only if they have the same label .",
    "this can be    established as follows :    +    & * for * @xmath34 such that    @xmath329 * do * +    & * for * @xmath330 * do *    @xmath331 +    & @xmath332    +    if transitions are pre - sorted such that transitions with the same    label are next to each other , then this runs in    @xmath333 time and @xmath278 additional    memory .",
    "@xmath334 : :    this is a simple set of numbers in the range @xmath311 ,  ,    @xmath40 .",
    "it stores the indices of the unprocessed    nonempty splitters .",
    "that is , it implements the    @xmath70 of the abstract algorithm . because each    nonempty splitter has at least one incoming transition and splitters    do not share transitions , @xmath40 suffices for the    range .",
    "@xmath335 : :    this is a simple set of numbers in the range @xmath311 ,  ,",
    "it contains the indices of the blocks    @xmath168 that were met when backwards - traversing the incoming    transitions of the current splitter on abstract line  8 .",
    "it is always    empty on line  19 .",
    "@xmath336 : :    this is a simple set of numbers in the range @xmath311 ,  ,",
    "it contains the indices of the splitters that    were affected when scanning the incoming transitions of the smaller of    the new blocks that resulted from a split .",
    "it is empty on line  4 .",
    "&     +  &    @xmath337 : = @xmath338     +  &    * if * @xmath339 * then *     +  &    * if * @xmath340 * then * @xmath337 : = @xmath231     +  &    @xmath43 : = @xmath341     +  &    * while * @xmath342 * do *     +  &    * for * @xmath343",
    "$ ] * do *     +  &    @xmath344 : = @xmath345     +  &    * if * @xmath346 * then * @xmath347     +  &    @xmath331     +  &    @xmath43 : = @xmath348     +  &    * while * @xmath349 * do *     +  &    @xmath344 : = @xmath350     +  &    @xmath351 : = @xmath352     +  &    * if * @xmath353 * then * @xmath354 + &     +  &    initialize @xmath324 to @xmath355     +  &    * for * @xmath344 : = @xmath311 * to * @xmath356 * do * @xmath357     +  &    * for * @xmath99 * do * @xmath358     +  &    @xmath359     +  &    * while * @xmath360 * do *     +  &    @xmath344 : = @xmath361     +  &    @xmath312 : = @xmath362     +  &    * while * @xmath363 * do *     +  &    @xmath43 : = @xmath313 $ ] ;  @xmath337 : = @xmath364     +  &    * if * @xmath365 * then * @xmath366     +  &    @xmath358     +  &    @xmath312 : = @xmath367     +  &    * while * @xmath368 * do *     +  &    @xmath231 : = @xmath369     +  &    @xmath370    the block - splitting stage is shown in figure  [ concr - algo ] .",
    "we explain its operation in the proof of the following theorem .",
    "given a pt - dfa all whose states are relevant and that has at least one final state , the algorithm in figure  [ concr - algo ] computes the same @xmath67 ( represented by @xmath322 ) as lines  4  15 of figure  [ abstr - algo ] .",
    "let us first investigate the operation of @xmath371 .",
    "as was told earlier , @xmath322 models @xmath67 , @xmath324 models the set of all nonempty splitters ( or the sets of their input transitions ) , and @xmath334 models @xmath70 .",
    "the task of @xmath371 is to update these three variables according to the splitting of a block @xmath168 . before calling @xmath371 ,",
    "the states @xmath43 that should go to one of the halves have been marked by calling @xmath358 for each of them .    line  1 unmarks all states of @xmath168 and either splits @xmath168 in @xmath322 updating @xmath67 , or detects that one of the halves would be empty , so @xmath168 should not be split . in the latter case ,",
    "line  2 exits the procedure .",
    "the total effect of the call and its preceding calls of @xmath372 is zero ( except that the ordering of the states in @xmath322 may have changed ) .    from now on assume that both halves of @xmath168 are nonempty .",
    "line  3 makes @xmath231 the index of the bigger half @xmath125 and @xmath337 the index of the smaller half @xmath373 . because @xmath168 is no more a block , for each @xmath34 ,",
    "the pairs @xmath374 are no more splitters , and must be replaced by @xmath73 and @xmath375 , to the extent that they are nonempty . for this purpose , lines  4 , 5 and  10 scan @xmath373 and line  6 scans the incoming transitions of the currently scanned state of @xmath373 .",
    "line  9 marks , for each @xmath34 , the transitions that correspond to @xmath375 .",
    "line  7 finds the index of @xmath374 in @xmath324 , and line  8 adds it to @xmath336 , unless it is there already . after all input transitions of @xmath373 have been scanned , lines  11 and  12 discharge the set of affected splitters @xmath374 .",
    "line  13 updates @xmath374 to those of @xmath73 and @xmath375 that are nonempty .",
    "line  14 corresponds to the updating of @xmath70 .",
    "if both @xmath73 and @xmath375 are nonempty splitters , then the index of @xmath375 is added to @xmath334 , that is , @xmath375 is added to @xmath70 . in this case , @xmath73 inherits the index of @xmath374 and thus also the presence or absence in @xmath70 .",
    "if @xmath73 is empty , then @xmath375 inherits the index and @xmath70-status of @xmath374 .",
    "if @xmath375 is empty , then @xmath374 does not enter @xmath336 in the first place . to summarize ,",
    "if @xmath376 , then all of its nonempty heirs enter @xmath70 ; otherwise only the smaller heir enters @xmath70 , and only if it is nonempty .",
    "this is equivalent to abstract lines 13  14 .",
    "regarding abstract line 15 , @xmath374 disappears automatically from @xmath70 because its index is re - used .",
    "lines  15  18 implement the total effect of abstract lines  4  5 .",
    "the initial value of @xmath322 corresponds to @xmath377 .",
    "line  15 makes @xmath324 contain the sets of input transitions of all nonempty splitters @xmath378 ( where @xmath34 ) , and line  16 puts them all to @xmath70 .",
    "if @xmath66 , then lines  17 and  18 have no effect .",
    "otherwise , they update @xmath67 to @xmath379 , update @xmath324 accordingly , and update @xmath334 to contain all current nonempty splitters .",
    "lines  19 and  20 match trivially abstract lines  6 and  7 .",
    "they choose some nonempty splitter @xmath73 for processing .",
    "lines  21  26 can be thought of as being executed between abstract lines  7 and  8 .",
    "they mark the states in @xmath78 for every @xmath168 that is scanned by abstract line  8 , and collect the indices of those @xmath168 into @xmath335 .",
    "lines  27 and  28 correspond to abstract line  8 , and abstract lines  9  15 are implemented by the call @xmath370 .",
    "lines  1 and  2 have the same effect as abstract lines  9  11 .",
    "line  3 implements abstract line  12 . the description of line  14 presented above matches abstract lines  13  15 .    given a pt - dfa all whose states are relevant and that has at least one final state , and assuming that the transitions that have the same label are given successively in the input , the algorithm in figure  [ concr - algo ] runs in @xmath303 time and @xmath333 memory .",
    "the data structures have been listed in this section and they all consume @xmath380 or @xmath333 memory .",
    "their initialization takes @xmath381 time . because all states are relevant ,",
    "we have @xmath382 , so @xmath380 terms are also @xmath333 .",
    "we have already seen that each individual operation in the algorithm runs in amortized constant time , except for line  15 , which takes @xmath333 time .",
    "we also saw towards the end of section  [ abstr_algo ] that each transition is used at most @xmath383 times on line  9 of the abstract algorithm .",
    "this implies that line  25 , and thus lines  23  26 , are executed at most @xmath384 times .",
    "the same holds for lines  28 and  29 , because the number of @xmath385-operations on @xmath335 is obviously the same as @xmath307-operations .",
    "because @xmath324-sets are never empty , lines  20 and  21 are not executed more often than line  25 , and lines  22 and  27 are executed at most twice as many times as line  25 .",
    "line  19 is executed once more than line  20 , and lines  15  18 are executed once . line  16 runs in @xmath333 and line  17 in @xmath380 time .",
    "lines  1  4 are executed at most once more than line  29 .",
    "if @xmath386 on line  3 , then each of the states scanned by lines  5 and  10 was marked on line  17 or  25 . otherwise the number of scanned states is smaller than the number of marked states .",
    "therefore , line  10 is executed at most as many times as lines  17 and  25 , and line  5 at most twice as many times .",
    "whenever lines  7  9 are executed anew ( or for the first time ) for some transition , the end state of the transition belongs to a block whose size is at most half of the size in the previous time ( or originally ) , because the block was split on line  1 and the smaller half was chosen on line  3 .",
    "therefore , lines  7  9 are executed at most @xmath387 times .",
    "line  6 is executed as many times as lines  7 and  10 together .",
    "the executions of lines  12  14 are determined by line  8 , and of line  11 by lines  4 and  8 .    -0.3",
    "in @xmath324 , transitions are sorted such that those with the same label are next to each other .",
    "transitions are not necessarily in such an order in the input .",
    "therefore , we must take the resources needed for sorting into account in our analysis .",
    "transitions can of course be sorted according to their labels with heapsort in @xmath388 time and @xmath333 memory .",
    "this is inferior to the time consumption of the rest of the algorithm .",
    "because the labels need not be in alphabetical order , a suitable ordering can also be found by putting the transitions into a hash table using their labels as the keys . then nonempty hash lists are sorted and concatenated .",
    "this takes @xmath333 time on the average , and @xmath333 memory .",
    "however , the worst - case time consumption is still @xmath389 .",
    "a third possibility runs in @xmath333 time even in the worst case , but it uses @xmath390 additional memory . that its time consumption may be smaller than memory consumption arises from the fact that it uses an array @xmath391 of size @xmath392 that need not be initialized at all , not even to all zeros .",
    "it is based on counting the occurrences of each label as in exercise 2.12 of  @xcite , and then continuing like counting sort .",
    "the pseudocode is in figure  [ sort - trans ] .    &",
    "@xmath356 : = @xmath250 +  & * for * @xmath393 * do * +  & @xmath126 : = @xmath314 $ ] ;  @xmath123 : = @xmath394 $ ] +  & * if * @xmath395 \\neq a$ ] * then * +  & @xmath123 : = @xmath396 ;  @xmath356 : = @xmath123 +  & @xmath394 $ ] : = @xmath123 ;  @xmath397 $ ] : = @xmath126 ;  @xmath398 $ ] : = @xmath311 +  & * else * @xmath398 $ ] : = @xmath398 + 1 $ ] +  & @xmath399 $ ] : = @xmath311 ;  @xmath400 $ ] : = @xmath400 + 1 $ ] ;  @xmath401 $ ] : = @xmath400 $ ] +  & * for * @xmath123 : = @xmath402 * to * @xmath356 * do * +  & @xmath403 $ ] : = @xmath404 $ ] +  & @xmath398 $ ] : = @xmath403 + { { \\mathit{trp}}}.{{\\mathit{end}}}[i]$ ] ;   @xmath397 $ ] : = @xmath398 $ ] +  & * for * @xmath393 * do * +  & @xmath123 : = @xmath405 $ ] ;  @xmath268 : = @xmath397 - 1 $ ] ;   @xmath397 $ ] : = @xmath268 +  & @xmath406 $ ] : = @xmath312 ;   @xmath407 $ ] : = @xmath268 ;  @xmath408 $ ] : = @xmath123    -0.3 cm",
    "table  [ meas ] shows some measurements made with our test implementations of knuutila s and our algorithm .",
    "they were written in c++ and executed on a pc with linux and 1 gigabyte of memory .",
    "no attempt was made to optimise either implementation to the extreme .",
    "the implementation of knuutila s algorithm completes the transition function to a full function with a well - known construction .",
    "namely , it adds a `` sink '' state to which all originally absent transitions and all transitions starting from itself are directed .",
    "the input dfas were generated at random . because of the difficulty of generating a precise number of transitions according to the uniform distribution , sometimes the generated number of transitions was slightly smaller than the desired number .",
    "furthermore , the dfas may have unreachable states and/or reachable irrelevant states that are processed separately by one or both of the algorithms . running time depends also on the size of the minimized dfa : the smaller the result , the less splitting of blocks . we know that the joint effects of these phenomena were small , because , in all cases , the numbers of states and transitions of the minimized dfas were @xmath409 99.4% of @xmath317 and @xmath40 in the table",
    "therefore , instead of trying to avoid the imperfections by fine - tuning the input ( which would be difficult ) , we always used the first input dfa that our generator gave for the given parameters .    .running time measurements .",
    "@xmath410 , where @xmath344 is given as @xmath411.a : @xmath412 and @xmath413 .",
    "b : @xmath412 and @xmath414.c : @xmath415 and @xmath413 .",
    "d : @xmath415 and @xmath414 . [ cols=\"<,<,>,>,>,>,>,>\",options=\"header \" , ]     the times given are the fastest and slowest of three measurements , made with @xmath416 , where @xmath417 .",
    "they are given in seconds .",
    "the number of transitions @xmath40 varies between @xmath418 and @xmath419 of @xmath41 .",
    "the times contain the special processing of unreachable and irrelevant states , but they do not contain the reading of the input dfa from and writing the result to a file . with @xmath420 ,",
    "knuutila s algorithm ran out of memory , while our algorithm spent about 15  s when @xmath421 and 32  s when @xmath422 .",
    "the superiority of our algorithm when @xmath344 is small is clear .",
    "that our algorithm loses when @xmath344 is big may be because it uses both @xmath25 and @xmath115 in the initial splitters , whereas knuutila s algorithm uses only one of them .",
    "also knuutila s algorithm speeds up as @xmath344 becomes smaller .",
    "perhaps the reason is that when @xmath344 is , say , @xmath418 , the block that contains the sink state has an unproportioned number of input transitions , causing blocks to split to a small and big half roughly in the ratio of @xmath418 to @xmath423 .",
    "thus small blocks are introduced quickly . as a consequence , the average size of the splitters that the algorithm uses during the execution is smaller than when @xmath424 .",
    "the same phenomenon also affects indirectly our algorithm , probably explaining why its running time is not linear in @xmath344 .    of the three notions of `` smaller '' mentioned in the introduction",
    ", our analysis does not apply to the other two .",
    "it seems that they would require making @xmath371 somewhat more complicated .",
    "this is a possible but probably unimportant topic for further work ."
  ],
  "abstract_text": [
    "<S> let _ pt - dfa _ mean a deterministic finite automaton whose transition relation is a partial function . </S>",
    "<S> we present an algorithm for minimizing a pt - dfa in @xmath0 time and @xmath1 memory , where @xmath2 is the number of states , @xmath3 is the number of _ defined _ transitions , and @xmath4 is the size of the alphabet . </S>",
    "<S> time consumption does not depend on @xmath4 , because the @xmath4 term arises from an array that is accessed at random and never initialized . </S>",
    "<S> it is not needed , if transitions are in a suitable order in the input . </S>",
    "<S> the algorithm uses two instances of an array - based data structure for maintaining a refinable partition . </S>",
    "<S> its operations are all amortized constant time . </S>",
    "<S> one instance represents the classical blocks and the other a partition of transitions . </S>",
    "<S> our measurements demonstrate the speed advantage of our algorithm on pt - dfas over an @xmath5 time , @xmath6 memory algorithm .    </S>",
    "<S> antti valmari        petri lehtinen    -0.3 </S>"
  ]
}