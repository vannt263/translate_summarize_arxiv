{
  "article_text": [
    "the _ maximum internal spanning tree problem _ ( mist for short ) requires the computation of a spanning tree @xmath1 in a given graph @xmath0 such that the number of internal vertices in @xmath1 is maximized .",
    "mist has possible applications in the design of cost - efficient communication networks @xcite and water supply networks @xcite .",
    "unfortunately , mist is clearly np - hard because the problem of finding a hamiltonian path in a given graph is np - hard @xcite and can be easily reduced to mist .",
    "mist is in fact apx - hard @xcite and hence does not admit a polynomial - time approximation scheme .",
    "since mist is apx - hard , it is of interest to design polynomial - time approximation algorithms for it that achieve a constant ratio as close to  1 as possible .",
    "indeed , prieto and sliper @xcite presented a polynomial - time approximation algorithm for mist achieving a ratio of @xmath4 .",
    "their algorithm is based on local search . by slightly modifying prieto and sliper s algorithm , salamon and",
    "wiener @xcite then obtained a faster ( linear - time ) approximation algorithm achieving the same ratio .",
    "salamon and wiener @xcite also considered two special cases of misp .",
    "more specifically , they @xcite designed a polynomial - time approximation algorithm for the special case of mist restricted to claw - free graphs that achieves a ratio of @xmath5 , and also designed a polynomial - time approximation algorithm for the special case of mist restricted to cubic graphs that achieves a ratio of @xmath6 .",
    "salamon @xcite later proved that the approximation algorithm in @xcite indeed achieves a performance ratio of @xmath7 for the special case of mist restricted to @xmath8-regular graphs .",
    "based on local optimization , salamon @xcite further came up with an @xmath9-time approximation algorithm for the special of mist restricted to graphs without leaves that achieves a ratio of @xmath10 .",
    "the algorithm in @xcite was subsequently simplified and re - analyzed by knauer and spoerhase @xcite so that it runs faster ( in cubic time ) and achieves a better ratio ( namely , @xmath11 ) for ( the general ) mist .",
    "@xcite even went further by showing that a deeper local search than those in @xcite and @xcite can achieve a ratio of @xmath5 for mist .",
    "recently , li and zhu  @xcite came up with a polynomial - time approximation algorithm for mist that achieves a ratio of @xmath2 . unlike the other previously known approximation algorithms for mist ,",
    "the algorithm in @xcite is based on a simple but crucial observation that the maximum number of internal vertices in a spanning tree of a graph @xmath0 can be bounded from above by the maximum number of edges in a triangle - free path - cycle cover of @xmath0 .    in the weighted version of mist ( wmist for short ) ,",
    "each vertex of the given graph @xmath0 has a nonnegative weight and the objective is to find a spanning tree @xmath1 of @xmath0 such that the total weight of internal vertices in @xmath1 is maximized .",
    "salamon @xcite designed an @xmath9-time approximation for wmist that achieves a ratio of @xmath12 , where @xmath13 is the maximum degree of a vertex in the input graph .",
    "salamon @xcite also considered the special case of wmist restricted to claw - free graphs without leaves , and designed an @xmath9-time approximation algorithm for the special case that achieves a ratio of @xmath4 .",
    "subsequently , knauer and spoerhase @xcite proposed a polynomial - time approximation algorithm for ( the general ) wmist that achieves a ratio of @xmath14 for any constant @xmath15 .    in the parameterized version of mist ( pmist for short ) ,",
    "we are asked to decide whether a given graph @xmath0 has a spanning tree with at least a given number @xmath16 of internal vertices .",
    "pmist and its special cases and variants have also been extensively studied in the literature @xcite .",
    "the best known kernel for pmist is of size @xmath17 and it leads to the fastest known algorithm for pmist with running time @xmath18 @xcite .    in this paper",
    ", we first give a new approximation algorithm for mist that is simpler than the one in @xcite but achieves the same approximation ratio and time complexity . in more details ,",
    "the time complexity is dominated by that of computing a maximum triangle - free path - cycle cover in a graph .",
    "we then show that the algorithm can be refined into a new approximation algorithm for mist that has the same time complexity as the algorithm in  @xcite but achieves a better ratio ( namely , @xmath3 ) . to obtain our algorithm",
    ", we use three new main ideas .",
    "the first main idea is to bound the maximum number of internal vertices in a spanning tree of a graph @xmath0 by the maximum number of edges in a _ special _ ( rather than general ) triangle - free path - cycle cover of @xmath0 . roughly speaking",
    ", we can figure out that certain vertices in @xmath0 must be leaves in an optimal spanning tree of @xmath0 , and hence we can require that the degrees of these vertices be at most  1 when computing a maximum triangle - free path - cycle cover @xmath19 of @xmath0 . in this sense , @xmath19 is special and can have significantly fewer edges than a maximum ( general ) triangle - free path - cycle cover of @xmath0 , and hence gives us a tighter upper bound .",
    "the second idea is to carefully modify @xmath19 into a spanning tree @xmath1 by local improvement .",
    "unfortunately , we can not always guarantee that the number of internal vertices in @xmath1 is at least @xmath3 times the number of edges in @xmath19 .",
    "our third idea is to show that if this unfortunate case occurs , then an optimal spanning tree of @xmath0 can not have so many internal vertices .",
    "these ideas may be used to design even better approximation or parameterized algorithms for mist in the future .",
    "the remainder of this paper is organized as follows .",
    "section  [ sec : def ] gives basic definitions that will be used in the remainder of the paper .",
    "section  [ sec : simple ] presents a simple approximation algorithm for mist that achieves a ratio of @xmath2 .",
    "the subsequent sections are devoted to refining the algorithm so that it achieves a better ratio .",
    "throughout this chapter , a graph means a simple undirected graph ( i.e. , it has neither parallel edges nor self - loops ) .",
    "let @xmath0 be a graph .",
    "we denote the vertex set of @xmath0 by @xmath20 , and denote the edge set of @xmath0 by @xmath21 . for a subset @xmath22 of @xmath20",
    ", @xmath23 denotes the graph obtained from @xmath0 by removing the vertices in @xmath22 ( together with the edges incident to them ) , while @xmath24 $ ] denotes @xmath25 .",
    "we call @xmath24 $ ] the _ subgraph of @xmath0 induced by @xmath22_. for a subset @xmath26 of @xmath21 , @xmath27 denotes the graph obtained from @xmath0 by removing the edges in @xmath26 .",
    "an edge @xmath28 of @xmath0 is a _ bridge _ of @xmath0",
    "if @xmath29 has more connected components than @xmath0 , and is a _ non - bridge _ otherwise .",
    "a vertex @xmath30 of @xmath0 is a _ cut - point _ if @xmath31 has more connected components than @xmath0 .",
    "let @xmath30 be a vertex of @xmath0 .",
    "the _ neighborhood _ of @xmath30 in @xmath0 , denoted by @xmath32 , is @xmath33 .",
    "the _ degree _ of @xmath30 in @xmath0 , denoted by @xmath34 , is @xmath35 .",
    "if @xmath36 , then @xmath30 is an _ isolated _ vertex of @xmath0 .",
    "if @xmath37 , then @xmath30 is a _ leaf _ of @xmath0 ; otherwise , @xmath30 is a _ non - leaf _ of @xmath0 .",
    "we use @xmath38 to denote the set of leaves in @xmath0 .",
    "let @xmath39 be a subgraph of @xmath0 .",
    "@xmath40 denotes @xmath41 .",
    "a _ port _ of @xmath39 is a @xmath42 with @xmath43 .",
    "when @xmath39 is a path , @xmath39 is _ dead _ if neither endpoint of @xmath39 is a port of @xmath39 , while @xmath39 is _ alive _ otherwise .",
    "@xmath39 and another subgraph @xmath44 of @xmath0 are _ adjacent _ in @xmath0 if @xmath45 but @xmath46 ( or equivalently , @xmath47 ) .",
    "a _ cycle _ in @xmath0 is a connected subgraph of @xmath0 in which each vertex is of degree  2 .",
    "a _ path _ in @xmath0 is either a single vertex of @xmath0 or a connected subgraph of @xmath0 in which exactly two vertices are of degree  1 and the others are of degree  2 .",
    "a vertex @xmath30 of a path @xmath48 in @xmath0 is an _ endpoint _ of @xmath48 if @xmath49 , and is an _",
    "internal vertex _ of @xmath48 if @xmath50 . the _ length _ of a cycle or path",
    "@xmath51 is the number of edges in @xmath51 and is denoted by @xmath52 .",
    "@xmath16-cycle _ is a cycle of length  @xmath16 , while a _ @xmath16-path _ is a path of length @xmath16 .",
    "( respectively , _ cycle _ ) _ component _ of @xmath0 is a connected component of @xmath0 that is a tree ( respectively , cycle ) . in particular ,",
    "if a tree component @xmath1 of @xmath0 is indeed a path ( respectively , @xmath16-path ) , then we call @xmath1 a _ path _",
    "( respectively , _ @xmath16-path _ ) _ component _ of @xmath0 .",
    "a _ tree - cycle cover _",
    "( tcc for short ) of @xmath0 is a subgraph @xmath39 of @xmath0 such that @xmath53 and each connected component of @xmath39 is a tree or cycle .",
    "let @xmath39 be a tcc of @xmath0 .",
    "@xmath39 is a",
    "_ hamiltonian path _",
    "( respectively , _ cycle _ ) of @xmath0 if @xmath39 is a path ( respectively , cycle ) , and is a _ spanning tree _ of @xmath0 if @xmath39 is a tree .",
    "@xmath39 is a _ path - cycle cover _",
    "( pcc for short ) of @xmath0 if each tree component of @xmath39 is a path .",
    "@xmath39 is a _ path cover _ of @xmath0 if @xmath39 has only path components . a _ triangle - free _",
    "tcc ( tftcc for short ) of @xmath0 is a tcc without 3-cycles .",
    "similarly , a _ triangle - free _ pcc ( tfpcc for short ) of @xmath0 is a pcc without 3-cycles .",
    "a tfpcc of @xmath0 is _ maximum _ if its number of edges is maximized over all tfpccs of @xmath0 . for convenience ,",
    "let @xmath54 denote the time complexity of computing a maximum tfpcc in a graph with @xmath55 vertices and @xmath56 edges .",
    "it is known that @xmath57  @xcite .",
    "suppose that @xmath0 is connected .",
    "the _ weight _ of a spanning tree @xmath1 of @xmath0 , denoted by @xmath58 , is the number of non - leaves in @xmath1 .",
    "we use @xmath59 to denote the maximum weight of a spanning tree of @xmath0",
    ". an _ optimal spanning tree _",
    "( ost for short ) of @xmath0 is a spanning tree @xmath1 of @xmath0 with @xmath60 .",
    "throughout the remainder of this paper , @xmath0 means a connected graph for which we want to find an ost .",
    "moreover , @xmath1 denotes an ost of @xmath0 . for convenience ,",
    "let @xmath61 and @xmath62 .",
    "we want to make @xmath0 smaller ( say , by deleting one or more vertices or edges from @xmath0 ) without decreasing @xmath59 . for this purpose , we define two _ strongly safe _ operations on @xmath0 below . here , an operation on @xmath0 is _ strongly safe _ if performing it on @xmath0 does not change @xmath59 .",
    "operation 1 .",
    ": :    if @xmath63 and @xmath21 contains two edges    @xmath64 and @xmath65 such that both    @xmath66 and @xmath67 are leaves of @xmath0 ,    then delete @xmath67 .",
    "operation 2 .",
    ": :    if for a non - bridge @xmath68 of @xmath0 ,    @xmath69 has a connected component @xmath70    with @xmath71 for each    @xmath72 , then delete @xmath28 .",
    "( _ comment : _    when @xmath73 , li and zhu  @xcite showed    that operation  2 is strongly safe . )        [ lem : op1]@xcite operation 1 is strongly safe .    [ lem : op2 ] operation 2 is strongly safe .",
    "if @xmath74 , we are done .",
    "so , assume that @xmath75 .",
    "obviously , at least one vertex @xmath76 of @xmath77 is adjacent to @xmath66 in @xmath1 because @xmath1 is connected .",
    "so , @xmath78 .",
    "similarly , @xmath79 for some vertex @xmath80 of @xmath81 .",
    "moreover , since @xmath28 is a non - bridge of @xmath0 , @xmath82 has a connected component @xmath83 ( other than @xmath77 and @xmath81 ) with @xmath84 .",
    "since @xmath1 is connected , @xmath66 or @xmath67 is adjacent to a vertex @xmath85 of @xmath83 in @xmath1 .",
    "we assume that @xmath86 ; the other case is similar .",
    "then , after deleting @xmath28 from @xmath1 , only @xmath67 may become a new leaf .",
    "if @xmath67 becomes a leaf in @xmath87 , then all vertices of @xmath83 must belong to the component tree of @xmath87 containing @xmath66 and hence adding an arbitrary edge @xmath88 of @xmath0 with @xmath89 to @xmath87 yields a new ost of @xmath0 .",
    "so , we may assume that @xmath67 does not become a leaf in @xmath87 .",
    "then , since @xmath28 is a non - bridge of @xmath0 , @xmath0 must have an edge @xmath90 such that for each @xmath91 , @xmath92 belongs to the component tree of @xmath87 containing @xmath93 .",
    "now , adding the edge @xmath90 to @xmath87 yields a new ost of @xmath0 .    an operation on @xmath0 is _ weakly safe _ if performing it on @xmath0 yields one or more graphs @xmath94 , ",
    ", @xmath95 such that ( 1 )  @xmath96 , @xmath97 , and @xmath98 , ( 2 )  @xmath99 for some nonnegative integer @xmath100 , and ( 3 )  given a spanning tree @xmath101 for each @xmath102 , a spanning tree @xmath1 of @xmath0 with @xmath103 can be computed in linear time .",
    "note that the last two conditions in the definition imply that @xmath104 .",
    "operation 3 .",
    ": :    if @xmath0 has a bridge @xmath68 such    that for each @xmath72 , @xmath93 is a    cut - point in the connected component @xmath102 of    @xmath105 with @xmath106 , then obtain    @xmath94 and @xmath107 as the connected components of    @xmath105 .",
    "operation 4 .",
    ": :    if @xmath0 has a cut - point @xmath30 such that one    connected component @xmath108 of @xmath31 has at    least two but at most 8 vertices , then obtain @xmath94 from    @xmath109 by adding a new vertex @xmath110 and a    new edge @xmath111 .",
    "the number 8 in the definition of operation  4 is not essential .",
    "it can be chosen at one s discretion as long as it is a constant .",
    "we here choose the number 8 , because it will be the smallest number for the proofs of several lemmas in this paper to go through .",
    "[ lem : op7 ] operation 3 is weakly safe .",
    "first , we want to show that @xmath112 .",
    "consider an @xmath91 . since @xmath93 is a cut - point in @xmath102 , @xmath113 .",
    "thus , the degree of @xmath93 in @xmath87 is at least  2 .",
    "so , one component tree of @xmath87 is a spanning tree of @xmath94 , the other is a spanning tree of @xmath107 , and their total weights equals @xmath58 .",
    "thus , @xmath112 .    next",
    ", suppose that for each @xmath72 , @xmath101 is a spanning tree of @xmath102 . since @xmath93 is a cut - point in @xmath102 , @xmath114 .",
    "so , using @xmath28 to connect @xmath115 and @xmath116 into a single tree yields a spanning tree of @xmath0 whose weight is @xmath117 .    [",
    "lem : op8 ] operation 4 is weakly safe .",
    "let @xmath118 be the graph obtained from @xmath119 $ ] by adding a new vertex @xmath120 and a new edge @xmath121 .",
    "let @xmath122 .",
    "first , we want to show that @xmath123 . since @xmath30 is a cut - point of @xmath0 , @xmath124 .",
    "let @xmath115 be the spanning tree of @xmath94 obtained from @xmath125 by adding @xmath110 and the edge @xmath111 .",
    "further let @xmath126 be the spanning tree of @xmath118 obtained from @xmath127 $ ] by adding @xmath120 and edge @xmath121",
    ". clearly , @xmath128 .",
    "thus , @xmath123 .    next ,",
    "suppose that @xmath115 is a spanning tree of @xmath94 .",
    "let @xmath126 be an ost of @xmath118 .",
    "we can obtain a spanning tree @xmath129 of @xmath0 from @xmath115 by first deleting @xmath110 , next adding @xmath130 $ ] , and further adding new edges to connect @xmath30 to those vertices of @xmath131 that are adjacent to @xmath30 in @xmath126 .",
    "obviously , @xmath132 , @xmath133 , @xmath134 , @xmath135 , the degree of each vertex @xmath136 of @xmath115 other than @xmath30 and @xmath110 in @xmath129 is @xmath137 , and the degree of each vertex @xmath138 of @xmath126 other than @xmath30 and @xmath120 in @xmath129 is @xmath139 .",
    "thus , @xmath140 .",
    "an operation on @xmath0 is _ safe _ if it is strongly or weakly safe on @xmath0 .      as in @xcite ,",
    "the algorithm is based on a lemma which says that @xmath0 has a path cover @xmath141 such that @xmath59 is bounded from above by the number of edges in @xmath141 .",
    "we next state the lemma in a stronger form and give an extremely simple proof .",
    "[ lem : lzw ] given a spanning tree @xmath129 of @xmath0 , we can construct a path cover @xmath141 of @xmath0 such that @xmath142 and @xmath143 for each leaf @xmath30 of @xmath129 .",
    "we simply construct @xmath141 from @xmath129 by first rooting @xmath129 at an arbitrary non - leaf and then for each non - leaf @xmath110 of @xmath129 , deleting all but one edge between @xmath110 and its children .",
    "now , the outline of the algorithm is as follows .    1 .",
    "[ step : ssafe ] whenever there is an @xmath72 such that operation  @xmath144 can be performed on @xmath0 , then perform operation @xmath144 on @xmath0 .",
    "[ step : wsafe ] whenever there is an @xmath145 such that operation  @xmath144 can be performed on @xmath0 , then perform the following steps : 1 .",
    "perform operation @xmath144 on @xmath0 .",
    "let @xmath94 ,  , @xmath95 be the resulting graphs . 2 .",
    "[ substep : recur ] for each @xmath146 , compute a spanning tree @xmath147 of @xmath148 recursively .",
    "3 .   combine @xmath115 , ",
    ", @xmath149 into a spanning tree @xmath129 of @xmath0 such that @xmath150 .",
    "4 .   return @xmath129 .",
    "[ step : small ] if @xmath151 , then compute and return an ost of @xmath0 in @xmath152 time .",
    "[ step : mtfpc ] compute a maximum tfpcc @xmath19 of @xmath0 .",
    "( _ comment : _ by lemma  [ lem : lzw ] , @xmath153 ) .",
    "[ step : prep ] perform a preprocessing on @xmath19 without decreasing @xmath154 .",
    "[ step : trans ] transform @xmath19 into a spanning tree @xmath129 of @xmath0 such that @xmath155 .",
    "return @xmath129 .    only steps  [ step : prep ] and",
    "[ step : trans ] are unclear .",
    "so , we detail them below .",
    "first , step  [ step : prep ] is done by performing the next three operations until none of them is applicable .",
    "operation 5 .",
    ": :    if @xmath19 has a dead path component @xmath48    such that @xmath156 and @xmath157 $ ] has    an alive hamiltonian path @xmath158 , then replace    @xmath48 by @xmath158 .",
    "operation 6 .",
    ": :    if an endpoint @xmath110 of a path component @xmath48 of    @xmath19 is adjacent to a vertex @xmath30 of a    cycle @xmath51 of @xmath19 in @xmath0 ,    then combine @xmath48 and @xmath51 into a single path by    replacing one edge incident to @xmath30 in @xmath51 with    the edge @xmath159 .",
    "operation 7 .",
    ": :    if an endpoint @xmath66 of a path component @xmath160    of @xmath19 is adjacent to an internal vertex    @xmath67 of another path component @xmath161 in    @xmath0 such that one edge @xmath162 incident to    @xmath67 in @xmath161 satisfies that combining    @xmath160 and @xmath161 by replacing @xmath162    with the edge @xmath163 yields two paths    @xmath164 and @xmath165 with    @xmath166 , then replace @xmath160 and    @xmath161 by @xmath164 and @xmath165 .",
    "( _ comment : _ for each @xmath167 ,    operation  @xmath144 does not change the maximality of    @xmath19 .",
    "so , due to the maximality of    @xmath19 , no endpoint of a path component    @xmath160 of @xmath19 is adjacent to an endpoint    of another path component @xmath161 in @xmath0 . )",
    "[ lem : prep0 ] immediately after step  [ step : prep ] , the following statements hold :    1 .",
    "[ stat : q1 ] @xmath19 is a maximum tfpcc of @xmath0 and hence has at least @xmath59 edges . 2 .",
    "[ stat : q3 ] if a path component @xmath48 of @xmath19 is of length at most  3 , then @xmath48 is alive .",
    "[ stat : q5 ] if an endpoint @xmath30 of a path component @xmath48 of @xmath19 is a port of @xmath48 , then each vertex in @xmath168 is an internal vertex of a path component @xmath158 of @xmath19 with @xmath169 .",
    "we prove the statements separately as follows .",
    "_ statement  [ stat : q1 ] : _ immediately before step  [ step : prep ] , @xmath19 has is a maximum tfpcc of @xmath0 . since operations  5 through  7 keep @xmath19 being a tfpcc without changing the number of edges in @xmath19 , statement  [ stat : p1 ] holds .",
    "_ statement  [ stat : q3 ] : _ let @xmath48 be a path component of @xmath19 with @xmath170 . if @xmath171 , then @xmath48 is alive because otherwise @xmath0 would be disconnected .",
    "so , @xmath172 or 3 .",
    "let @xmath66 and @xmath67 be the endpoints of @xmath48 . for",
    "a contradiction , assume that @xmath48 is dead .",
    "then , since @xmath0 is connected , @xmath48 has at least one internal vertex @xmath136 adjacent to a vertex @xmath173 in @xmath0 .",
    "if @xmath174 , then @xmath157 $ ] has a hamiltonian path @xmath158 in which @xmath136 is an endpoint , contradicting the fact that operation  5 can not be performed on @xmath19 .",
    "so , we assume that @xmath175 .",
    "now , if @xmath172 , then operation  1 can be performed on @xmath0 , a contradiction .",
    "thus , we further assume that @xmath176 .",
    "then , since operation  4 can not be performed on @xmath0 , the other internal vertex @xmath138 ( than @xmath136 ) of @xmath48 is adjacent to a vertex @xmath177 in @xmath0 .",
    "now , if @xmath157 $ ] is not @xmath48 itself , then operation  5 can be performed on @xmath19 , a contradiction ; otherwise , operation  2 or  3 can be performed on @xmath0 , a contradiction .",
    "note that it does not matter whether @xmath178 or not .",
    "_ statement  [ stat : q5 ] : _ suppose that an endpoint @xmath30 of a path component @xmath48 of @xmath19 is a port . consider an arbitrary @xmath179 . since operation  6 is not applicable on @xmath19 , @xmath110 appears in a path component @xmath158 of @xmath19 .",
    "then , by the comment on operation  7 , @xmath110 is an internal vertex of @xmath158 .",
    "let @xmath66 and @xmath67 be the endpoints of @xmath158 . for each @xmath72 ,",
    "let @xmath180 be the path from @xmath110 to @xmath93 in @xmath48 .",
    "then , @xmath181 .",
    "moreover , since operation  7 can not be applied on @xmath19 , @xmath182 for each @xmath72 .",
    "thus , @xmath183 .",
    "we next detail step  [ step : trans ] .",
    "first , for each path component @xmath48 of @xmath19 with @xmath184 , we select one edge @xmath185 connecting an endpoint of @xmath48 to a vertex not in @xmath48 , and add @xmath186 to an initially empty set @xmath187 .",
    "such @xmath186 exists by statement  [ stat : q3 ] in lemma  [ lem : prep0 ] .",
    "moreover , by statement  [ stat : q5 ] in lemma  [ lem : prep0 ] , the endpoint of @xmath186 not in @xmath48 appears in a path component @xmath158 of @xmath19 with @xmath188 .",
    "so , for two path components @xmath160 and",
    "@xmath161 in @xmath19 , @xmath189 . consider the graph @xmath39 obtained from @xmath19 by adding the edges in @xmath187 .",
    "each connected component of @xmath39 is a cycle of length at least  4 or a tree .",
    "suppose that we modify @xmath39 by performing the following three steps in turn :    * whenever @xmath39 has two cycles @xmath190 and @xmath191 such that some edge @xmath192 satisfies @xmath193 and @xmath194 , delete one edge of @xmath190 incident to @xmath66 from @xmath39 , delete one edge of @xmath191 incident to @xmath67 from @xmath39 , and add @xmath28 to @xmath39 .",
    "* whenever @xmath39 has a cycle @xmath51 , choose an edge @xmath195 with @xmath196 and @xmath197 , delete one edge of @xmath51 incident to @xmath110 from @xmath39 , and add @xmath28 to @xmath39 .",
    "* whenever @xmath39 has two connected components @xmath190 and @xmath191 such that some edge @xmath192 satisfies @xmath193 and @xmath194 , add @xmath28 to @xmath39 .",
    "step  [ step : trans ] is done by obtaining @xmath129 as the final modified @xmath39 .",
    "obviously , for each cycle @xmath51 of @xmath19 , at least @xmath198 vertices of @xmath51 are internal vertices of @xmath129 . moreover , for each path component @xmath48 of @xmath19 with @xmath199",
    ", at least @xmath200 vertices of @xmath48 are internal vertices of @xmath129 .",
    "furthermore , for each path component @xmath48 of @xmath19 with @xmath201 , at least @xmath202 vertices of @xmath48 are internal vertices of @xmath129 .",
    "so , @xmath129 has at least @xmath203 internal vertices .",
    "obviously , all steps of the algorithm excluding steps  [ substep : recur ] and  [ step : mtfpc ] can be done in @xmath204 time .",
    "now , we have the following theorem :    [ th : main0 ] the algorithm achieves an approximation ratio of @xmath2 and runs in @xmath205 time .    in the sequel",
    ", we consider how to improve the algorithm .",
    "the first idea is to introduce more safe reduction rules ( cf .",
    "section  [ sec : reduce ] ) .",
    "the second idea is to compute a better upper bound on @xmath59 than that given by a maximum tfpcc ( cf .",
    "section  [ sec : tfpcc ] ) .",
    "the third idea is to perform a more sophisticated preprocessing on @xmath19 ( cf .",
    "section  [ sec : prep ] ) .",
    "the last idea is to transform @xmath19 into a spanning tree of @xmath0 more carefully ( cf . section  [ sec : trans ] ) .",
    "in addition to the four safe reduction rules in section  [ subsec : rule ] , we further introduce the following rules .",
    "operation 8 . : :    if for four vertices @xmath66 , ",
    ", @xmath206 ,    @xmath207 ,    @xmath208 has a connected component @xmath108    with @xmath209 , then delete the edge    @xmath210 .",
    "operation 9 .",
    ": :    if for five vertices @xmath66 ,  , @xmath211 ,    @xmath212 , then delete the edge @xmath210 .",
    "operation 10 .",
    ": :    if for two vertices @xmath110 and @xmath30 of    @xmath0 , @xmath213 has a connected component    @xmath108 with @xmath214 such that    @xmath215 and    @xmath216 $ ] has a hamiltonian path    @xmath48 from @xmath110 to @xmath30 , then delete    all edges of @xmath216 $ ] that do not appear in    @xmath48 .",
    "operation 11 .",
    ": :    if @xmath0 has an edge @xmath68 with    @xmath217 , then obtain @xmath94    from @xmath0 by merging @xmath66 and    @xmath67 into a single vertex @xmath218 .",
    "[ lem : op3 ] operation 8 is strongly safe .",
    "if @xmath74 , we are done .",
    "so , assume that @xmath75 .",
    "obviously , at least one vertex @xmath30 of @xmath108 is adjacent to @xmath67 in @xmath1 because @xmath1 is connected .",
    "so , @xmath219 . for each @xmath220 ,",
    "let @xmath101 be the component tree of @xmath87 in which @xmath93 appears .",
    "if @xmath221 , then @xmath206 is a leaf of @xmath1 and hence adding the edge @xmath222 to @xmath87 clearly yields a spanning tree @xmath129 of @xmath0 with @xmath223 , then @xmath206 is a leaf of @xmath1 and hence adding the edge @xmath224 to @xmath87 clearly yields a spanning tree @xmath129 of @xmath0 with @xmath225 . otherwise , @xmath226 is a leaf of @xmath1 and hence adding the edge @xmath227 to @xmath87 clearly yields a spanning tree @xmath129 of @xmath0 with @xmath225 .",
    "[ lem : op4 ] operation 9 is strongly safe .",
    "if @xmath74 , we are done .",
    "so , assume that @xmath75 .",
    "obviously , @xmath228",
    ". moreover , if for some @xmath229 , @xmath230 and @xmath231 , then the proof of lemma  [ lem : op3 ] shows that @xmath1 can be transformed into a spanning tree @xmath129 such that @xmath232 and @xmath233 .",
    "thus , we may assume that @xmath234 , @xmath235 , and @xmath236 . obviously , either @xmath237 or @xmath238 .",
    "in the latter case , adding the edge @xmath239 to @xmath87 clearly yields a spanning tree @xmath129 of @xmath0 , and @xmath225 holds for @xmath234 .",
    "so , we assume the former case .",
    "let @xmath240 . then , adding the edges @xmath227 and @xmath239 to @xmath241 clearly yields a spanning tree @xmath129 of @xmath0 with @xmath225 .",
    "[ lem : op5 ] operation 10 is strongly safe .",
    "operation 10 is clearly strongly safe if @xmath242 .",
    "so , we assume that @xmath243 .",
    "since @xmath108 is a connected component , the degree of each vertex @xmath244 in @xmath125 is @xmath245 unless @xmath246 .",
    "let @xmath247 be the path between @xmath110 and @xmath30 in @xmath1 .",
    "let @xmath248 be the set of internal vertices of @xmath247 . since @xmath108 is a connected component of @xmath213 , either @xmath249 or @xmath250 .",
    "obviously , we are done if @xmath251 .",
    "so , we assume that @xmath252 is either empty or contains at least one but not all vertices of @xmath108 .",
    "then , @xmath253 has one or more component trees in which at least one vertex of @xmath108 appears .",
    "let @xmath115 ,  , @xmath254 be such component trees .",
    "for each @xmath255 , @xmath256 because @xmath108 is a connected component of @xmath213 . moreover , if @xmath257 , then @xmath258 . since @xmath257 for at least one @xmath255 , @xmath259 . furthermore ,",
    "if @xmath249 , then @xmath260 .",
    "_ case 1 : _",
    "@xmath248 is a nonempty proper subset of @xmath131 .",
    "then , modifying @xmath125 by adding the edges of @xmath48 yields a new spanning tree @xmath129 of @xmath0 .",
    "clearly , @xmath261 .",
    "moreover , since @xmath215 , it is impossible that @xmath262 .",
    "so , @xmath263 .",
    "consequently , @xmath232 because @xmath259 .",
    "_ case 2 : _",
    "@xmath249 . then , both @xmath110 and @xmath30 are of degree at least  1 in @xmath125 .",
    "we assume that the degree of @xmath110 in @xmath125 is at least as large as that of @xmath30 in @xmath125 ; the other case is similar .",
    "let @xmath138 be the neighbor of @xmath110 in @xmath247 .",
    "it is possible that @xmath264 . obviously , modifying @xmath125 by adding the edges of @xmath48 and deleting the edge @xmath265 yields a new spanning tree @xmath129 of @xmath0 .",
    "clearly , @xmath266 .",
    "thus , if @xmath267 , then @xmath232 because @xmath259 . moreover , if @xmath268 , then @xmath269 and in turn @xmath232 .",
    "so , we may assume that @xmath270 and @xmath271 .",
    "then , the degree of @xmath110 in @xmath125 is  1 and in turn so is @xmath30 .",
    "now , since @xmath272 and @xmath273 , @xmath30 is adjacent to no vertex of @xmath108 in @xmath1 and hence @xmath30 is a leaf of @xmath1 . therefore , no matter whether @xmath264 or not , @xmath232 because @xmath259 .",
    "[ lem : op6 ] operation 11 is weakly safe .    for each @xmath72 ,",
    "let @xmath274 be the vertex in @xmath275 .",
    "possibly , @xmath276 . if @xmath277 , then @xmath278 ; otherwise , @xmath279 .",
    "first , we want to show that @xmath280 .",
    "if @xmath74 , then @xmath1 contains both @xmath281 and @xmath282 and we can modify @xmath1 ( without decreasing @xmath283 ) by replacing the edge @xmath282 with @xmath28 .",
    "so , we can assume that @xmath75 .",
    "then , it is clear that modifying @xmath1 by merging @xmath66 and @xmath67 into a single vertex @xmath218 yields a spanning tree of @xmath94 whose weight is @xmath284 .",
    "thus , @xmath280 .    next ,",
    "suppose that @xmath115 is a spanning tree of @xmath94 .",
    "if @xmath276 , then @xmath218 is a leaf of @xmath115 and its neighbor in @xmath115 is @xmath285 , and hence modifying @xmath115 by deleting the vertex @xmath218 and adding the two edges @xmath163 , @xmath286 yields a spanning tree of @xmath0 whose weight is @xmath287 .",
    "so , we assume that @xmath288 .",
    "clearly , at least one of @xmath289 and @xmath290 is an edge of @xmath115 . if for exactly one @xmath72 , @xmath291 , then modifying @xmath115 by deleting the vertex @xmath218 and adding the two edges @xmath28 , @xmath292 yields a spanning tree of @xmath0 whose weight is @xmath287 .",
    "otherwise , modifying @xmath115 by deleting the vertex @xmath218 and adding the three edges @xmath281 , @xmath28 , @xmath286 yields a spanning tree of @xmath0 whose weight is @xmath287 .",
    "accordingly , we need to modify step  [ step : ssafe ] of the algorithm by choosing @xmath144 from @xmath293 and also modify step  [ step : wsafe ] by choosing @xmath144 from @xmath294 .",
    "obviously , after the modification , steps  [ step : ssafe ] and  [ step : wsafe ] can be done in @xmath295 time .",
    "in this section , we consider how to refine step  [ step : mtfpc ] . because of steps  [ step : ssafe ] and  [ step : small ] , we hereafter assume that @xmath296 and there is no @xmath297 such that operation  @xmath144 can be performed on @xmath0",
    ". then , we can prove the next lemma :    [ lem : cycle ] suppose that @xmath51 is a cycle of @xmath0 with @xmath298 .",
    "let @xmath299 be the set of ports of @xmath51 .",
    "then , the following statements hold .    1 .",
    "[ stat:2 + ] @xmath300 .",
    "[ stat:=2 ] if @xmath301 , then the two vertices in @xmath299 are not adjacent in @xmath51 and @xmath302 .",
    "[ stat:2and4 ] if @xmath301 and @xmath303 , then @xmath304 $ ] and @xmath51 are the same graph .",
    "we prove the statements separately as follows .",
    "_ statement  [ stat:2 + ] : _ since @xmath0 is connected and @xmath305 , @xmath306 .",
    "moreover , since operation  4 can not be performed on @xmath0 , @xmath300 .",
    "_ statement  [ stat:=2 ] : _ suppose that @xmath307 . then , the two vertices in @xmath299 can not be adjacent in @xmath51 , because otherwise operation  10 could be performed on @xmath0 . for",
    "a contradiction , assume that @xmath308 .",
    "suppose that @xmath66 ,  , @xmath211 are the vertices of a 5-cycle of @xmath51 and appear in @xmath51 clockwise in this order .",
    "since the two vertices in @xmath299 are not adjacent in @xmath51 , we may assume that @xmath309 .",
    "if @xmath310 or @xmath311 , then operation  10 can be performed on @xmath0 , a contradiction .",
    "so , we assume that @xmath312 and @xmath313 .",
    "if @xmath314 or @xmath315 , then operation  10 can be performed on @xmath0 , a contradiction .",
    "thus , we may further assume that @xmath316 and @xmath317 .",
    "now , @xmath318 , @xmath319 , and @xmath320 .",
    "hence , operation  11 can be performed on @xmath0 , a contradiction .    _",
    "statement  [ stat:2and4 ] : _ suppose that @xmath301 and @xmath321 .",
    "the two vertices in @xmath299 are not adjacent in @xmath51 by statement  [ stat:=2 ] , and hence @xmath304 $ ] and @xmath51 are the same graph because otherwise operation  10 could be performed on @xmath0 .    to refine step  [ step : mtfpc ] , our idea is to compute @xmath19 as a",
    "_ preferred _ tfpcc of @xmath0 . before defining what the word `` preferred '' means here , we need to prove a lemma .",
    "for ease of explanation , we assume , with loss of generality , that there is a linear order ( denoted by @xmath322 ) on the vertices of @xmath0 .",
    "[ lem : exclude ] suppose that @xmath66 and @xmath226 are two vertices of @xmath0 such that @xmath323 and condition  c1 below holds .",
    "then , @xmath0 has an ost in which @xmath66 or @xmath226 is a leaf .",
    "consequently , @xmath0 has an ost in which @xmath66 is a leaf .",
    "* for two vertices @xmath67 and @xmath206 in @xmath324 , @xmath325 .",
    "if @xmath66 is a leaf of @xmath1 , then we are done .",
    "so , assume that @xmath66 is not a leaf of @xmath1 .",
    "since condition  c1 holds , @xmath226 is clearly a leaf of @xmath1 and we can modify @xmath1 ( without decreasing @xmath58 ) by switching @xmath66 and @xmath226 so that @xmath66 becomes a leaf in @xmath1 .",
    "if condition  c1 in lemma  [ lem : exclude ] holds for @xmath66 and @xmath226 , we refer to @xmath67 and @xmath206 as the _ boundary points _ of the pair @xmath326 , and refer to the edges incident to @xmath66 or @xmath226 as the _ supports _ of @xmath327 .",
    "let @xmath328 be the set of pairs @xmath329 of vertices in @xmath0 satisfying condition  c1 .",
    "it is worth pointing out that for each @xmath330 and each boundary point @xmath110 of @xmath327 , @xmath331 because otherwise operation  4 could be performed on @xmath0 .",
    "[ lem : ind ] no two pairs in @xmath328 share a support .",
    "obviously , for two pairs in @xmath328 to share a support , they have to share their boundary points .",
    "however , no two pairs in @xmath328 can share their boundary points , because otherwise operation  9 could be performed on @xmath0 .",
    "so , no two pairs in @xmath328 share a support .",
    "[ lem : excludeall ] @xmath0 has an ost in which @xmath66 is a leaf for each @xmath332 .",
    "by lemma  [ lem : exclude ] , we can assume that for every @xmath333 , @xmath334 .",
    "in a nutshell , the proof of lemma  [ lem : exclude ] shows that even if @xmath1 is an ost with @xmath335 , we can modify @xmath1 without decreasing @xmath58 so that @xmath334 .",
    "indeed , the modification only uses the supports of @xmath327 .",
    "now , by lemma  [ lem : ind ] , a similar modification can be done independently for each other @xmath336 .",
    "therefore , the lemma holds .",
    "now , we are ready to make two definitions .",
    "let @xmath19 be a tfpcc of @xmath0 .",
    "@xmath19 is _ special _ if for every pair @xmath332 , @xmath337 .",
    "@xmath19 is _ preferred _ if @xmath19 is special and @xmath154 is maximized over all special tfpccs of @xmath0 .",
    "[ lem : up ] if @xmath19 is a preferred tfpcc of @xmath0 , then @xmath153 .    by lemma  [ lem : excludeall ]",
    ", @xmath0 has an ost @xmath129 such that for each @xmath338 , @xmath339 .",
    "so , by lemma  [ lem : lzw ] , we can construct a path cover @xmath141 of @xmath0 with @xmath142 such that @xmath340 for every @xmath332 .",
    "thus , @xmath141 is a special tfpcc of @xmath0 .",
    "consequently , if @xmath19 is a preferred tfpcc of @xmath0 , then @xmath341 .",
    "[ lem : prefer ] we can compute a preferred tfpcc @xmath19 of @xmath0 in @xmath342 time .",
    "we construct a new graph @xmath343 from @xmath0 by adding a new vertex @xmath344 and the edge @xmath345 for each pair @xmath333 . obviously , if @xmath346 is a preferred tfpcc of @xmath0 , then adding the edges @xmath347 with @xmath348 to @xmath346 yields a tfpcc @xmath349 of @xmath343 with @xmath350 .",
    "we then compute a maximum tfpcc @xmath349 of @xmath343 in @xmath351 time . by the discussion in the last paragraph , @xmath352 .",
    "if for some @xmath333 , @xmath353 , then by the maximality of @xmath354 , @xmath355 and we can modify @xmath349 by replacing one of the edges incident to @xmath66 in @xmath349 with the edge @xmath347 . clearly , @xmath349 is still a maximum tfpcc of @xmath343 after the modification .",
    "so , we can repeatedly modify @xmath349 in this way until @xmath356 for every @xmath348 .",
    "@xmath349 is now a maximum tfpcc of @xmath343 such that for every @xmath348 , @xmath356 .",
    "finally , we obtain @xmath19 from @xmath349 by deleting the edge @xmath347 for each @xmath333 . clearly , @xmath357 .",
    "therefore , @xmath19 is a preferred tfpcc of @xmath0 . since @xmath358 and @xmath359 , the lemma holds .",
    "recall that @xmath360",
    "so , lemma  [ lem : prefer ] ensures that after modifying step  [ step : mtfpc ] by computing @xmath19 as a preferred tfpcc of @xmath0 , step  [ step : mtfpc ] can still be done in @xmath54 time .",
    "in this section , we consider how to refine step  [ step : prep ] .",
    "so , suppose that we have computed a preferred tfpcc @xmath19 of @xmath0 as in lemma  [ lem : prefer ] . to refine step  [ step : prep ]",
    ", we repeatedly perform not only operations  5 through  7 but also the following three operations on @xmath19 until none of the six is applicable .",
    "operation 12 .",
    ": :    if a cycle @xmath190 of @xmath19 has an edge    @xmath361 and another cycle or path component    @xmath191 of @xmath19 has an edge    @xmath362 such that    @xmath192 and    @xmath363 , then combine    @xmath190 and @xmath191 into a single cycle or path by    replacing @xmath364 and @xmath365 with @xmath28    and @xmath162 .",
    "operation 13 .",
    ": :    if an endpoint @xmath66 of a path component @xmath160    of @xmath19 is adjacent to an endpoint @xmath67    of another path component @xmath161 of @xmath19    in @xmath0 , then combine @xmath160 and    @xmath161 into a single path by adding the edge    @xmath163 .",
    "operation 14 .",
    ": :    if @xmath366 is an edge of a path component of    @xmath19 such that for some isolated vertex    @xmath136 of @xmath19 ,    @xmath367 and @xmath368 , then    replace @xmath28 by the edges @xmath369 and    @xmath370 .",
    "[ lem : prep ] immediately after the refined preprocessing step , the following statements hold :    1 .",
    "[ stat : p1 ] @xmath19 is a tfpcc of @xmath0 and has at least @xmath59 edges . 2 .",
    "[ stat : p3 ] if a path component @xmath48 of @xmath19 is of length at most  3 , then @xmath48 is alive .",
    "[ stat : p5 ] if an endpoint @xmath30 of a path component @xmath48 of @xmath19 is a port of @xmath48 , then each vertex in @xmath168 is an internal vertex of a path component @xmath158 of @xmath19 with @xmath169 .",
    "[ stat : p2 ] no pair @xmath332 satisfies that @xmath66 appears in a cycle of @xmath19 .",
    "[ stat : p4 ] if a dead path component @xmath48 of @xmath19 is of length  4 , then both endpoints of @xmath48 are leaves in @xmath0 .",
    "[ stat : p6 ] each 4-cycle @xmath51 of @xmath19 has at least three ports .",
    "a _ short _ cycle is a cycle of length at most  7 .",
    "we prove the statements separately as follows .",
    "_ statement  [ stat : p1 ] : _ before the refined preprocessing , @xmath19 has at least @xmath59 edges by lemma  [ lem : up ] and is a tfpcc of @xmath0 . since operation  @xmath144 does not decrease the number of edges in @xmath19 or creates a new short cycle or a vertex of degree larger than  2 in @xmath19 for each @xmath371 , statement  [ stat : p1 ] holds .",
    "_ statement  [ stat : p3 ] : _ same as that of statement  [ stat : q3 ] in lemma  [ lem : prep0 ] .",
    "_ statement  [ stat : p5 ] : _ suppose that an endpoint @xmath30 of a path component @xmath48 of @xmath19 is a port .",
    "consider an arbitrary @xmath179 . since neither operation  6 nor operation  13 can be performed on @xmath19",
    ", @xmath110 is an internal vertex of a path component @xmath158 of @xmath19 .",
    "let @xmath66 and @xmath67 be the endpoints of @xmath158 . for each @xmath72 ,",
    "let @xmath180 be the path from @xmath110 to @xmath93 in @xmath48 .",
    "then , @xmath181 .",
    "moreover , since operation  7 can not be applied on @xmath19 , @xmath182 for each @xmath72 .",
    "thus , @xmath183 .",
    "_ statement  [ stat : p2 ] : _ before the refined preprocessing , no pair @xmath332 satisfies that @xmath66 appears in a cycle of @xmath19 because @xmath19 is a preferred tfpcc of @xmath0 .",
    "moreover , if operation  @xmath144 creates a new cycle @xmath51 in @xmath19 for some @xmath372 , then @xmath373 and @xmath51 is obtained by merging two shorter cycles in @xmath19 .",
    "thus , statement  [ stat : p2 ] holds .    _ statement  [ stat : p4 ] : _ let @xmath48 be a dead path component of @xmath19 with @xmath374 .",
    "suppose that @xmath66 ,  , @xmath211 are the vertices of @xmath48 and they appear in @xmath48 in this order .",
    "if all internal vertices of @xmath48 are ports , then both @xmath66 and @xmath211 are leaves of @xmath0 ( and we are done ) , because otherwise operation  5 could be performed on @xmath19 . moreover , if at most one internal vertex of @xmath48 is a port , then @xmath0 would be disconnected or operation  4 could be performed on @xmath0 , a contradiction .",
    "so , we assume that exactly two internal vertices of @xmath48 are ports .",
    "now , if @xmath375 , then @xmath376 , @xmath377 , and @xmath378 ( because otherwise operation  5 could be performed on @xmath19 ) , and in turn both @xmath66 and @xmath211 are leaves of @xmath0 ( and we are done ) because otherwise operation  8 or  9 could be performed on @xmath0 .",
    "thus , we may assume that @xmath379 and @xmath380 .",
    "then , since operation  5 can not be performed on @xmath19 , @xmath66 is a leaf of @xmath0 and @xmath381 .",
    "for the same reason , @xmath317 or @xmath312 .",
    "indeed , @xmath310 because otherwise the edge @xmath382 would be deleted by operation  2 or  3 , therefore , @xmath317 and in turn @xmath211 is also a leaf of @xmath0 .    _ statement  [ stat : p6 ] : _ let @xmath51 be a 4-cycle in @xmath19 , and @xmath299 be the set of ports of @xmath51 . further let @xmath66 ,  , @xmath206 be the vertices of @xmath51 and assume that they appear in @xmath51 clockwise in this order . by lemma  [ lem :",
    "cycle ] , @xmath383 . for",
    "a contradiction , assume that @xmath307 .",
    "then , by statement  [ stat:2and4 ] in lemma  [ lem : cycle ] , @xmath309 or @xmath384",
    ". we may assume that @xmath384 and @xmath385 .",
    "then , @xmath325 by statement  3 in lemma  [ lem : cycle ] , and in turn @xmath332 .",
    "since the refined preprocessing of @xmath19 does not introduce a new short cycle , @xmath51 is a cycle in @xmath19 even before the refined preprocessing .",
    "however , this contradicts the fact that @xmath19 is a preferred tfpcc of @xmath0 before the refined preprocessing .",
    "obviously , the refined preprocessing ( i.e. , step  [ step : prep ] ) can be done in @xmath386 time .",
    "in this section , we consider how to refine step  [ step : trans ] .",
    "so , suppose that we have just performed the refined preprocessing on @xmath19 as in section  [ sec : prep ] .",
    "let @xmath387 be the set of ( ordered ) pairs @xmath388 of path components of @xmath19 such that @xmath389 and some endpoint @xmath30 of @xmath48 is adjacent to a vertex @xmath110 of @xmath158 in @xmath0 .",
    "note that @xmath390 and @xmath183 by statement  [ stat : p5 ] in lemma  [ lem : prep ] .",
    "suppose that we obtain a subset @xmath391 of @xmath387 from @xmath387 as follows .",
    "* for each path component @xmath48 of @xmath19 such that there are two or more path components @xmath158 of @xmath19 with @xmath392 , delete all but one pair @xmath388 from @xmath387 .",
    "now , consider an auxiliary digraph @xmath393 such that the vertices of @xmath393 one - to - one correspond to the path components @xmath48 of @xmath19 with @xmath394 and the arcs of @xmath393 one - to - one correspond to the pairs in @xmath391 . by statement",
    "[ stat : p5 ] in lemma  [ lem : prep ] , @xmath393 is a rooted forest ( in which each leaf is of in - degree  0 , each root is of out - degree  0 , and each vertex is of out - degree at most  1 ) .    to transform @xmath19 into a spanning tree of @xmath0 , the idea is to modify @xmath19 in three stages .",
    "@xmath19 is initially a tfpcc of @xmath0 and we will always keep @xmath19 being a tftcc of @xmath0 . for each @xmath395 , we use @xmath396 to denote the @xmath19 immediately after the @xmath144-th stage . for convenience",
    ", we use @xmath397 to denote the @xmath19 immediately before the first stage .",
    "moreover , for each @xmath398 and each connected component @xmath51 of @xmath396 , we use @xmath399 to denote the number of edges @xmath400 such that @xmath401 .    in the first stage , we modify @xmath19 by performing the following step :    1 .   [ step : conpath ] for each pair @xmath402 , add an arbitrary @xmath403 to @xmath19 such that @xmath110 is an endpoint of @xmath48 and @xmath30 appears in @xmath158 .",
    "[ lem : type1 ] each connected component of @xmath404 that is not a path or cycle is a tree @xmath405 satisfying condition c2 below :    * @xmath406 , @xmath407 , and @xmath408 .",
    "let @xmath405 be a connected component of @xmath404 that is not a path or cycle .",
    "obviously , @xmath405 can be obtained from a tree component @xmath409 of @xmath393 by replacing each vertex of @xmath409 with the corresponding path component of @xmath19 and replacing each arc of @xmath409 corresponding to a pair @xmath402 with an edge @xmath410 such that @xmath30 is an endpoint of @xmath48 and @xmath110 appears in @xmath158 .",
    "thus , @xmath405 is clearly a tree .",
    "we next prove that @xmath405 satisfies condition  c2 by induction on the number of arcs in @xmath409 .",
    "clearly , @xmath409 has at least one edge . in the base case",
    ", @xmath409 has only one arc .",
    "let @xmath388 be the pair in @xmath391 corresponding to the arc .",
    "@xmath405 is obtained from @xmath48 and @xmath158 by connecting them with an edge @xmath411 such that @xmath30 is an endpoint of @xmath48 and @xmath110 appears in @xmath158 .",
    "thus , @xmath412 , @xmath413 , and @xmath414 .",
    "hence , by statement  [ stat : p5 ] in lemma  [ lem : prep ] , @xmath415 .",
    "therefore , @xmath407 and @xmath416 .",
    "this shows that @xmath405 satisfies condition  c2 in the base case .    now , assume that @xmath409 has at least two arcs .",
    "consider an arbitrary @xmath402 such that the vertex @xmath417 of @xmath393 corresponding to @xmath48 is a leaf of @xmath409 .",
    "let @xmath418 be obtained from @xmath409 by deleting @xmath417 , and @xmath419 be obtained from @xmath405 by deleting the vertices of @xmath48 .",
    "since @xmath418 has one fewer arc than @xmath409 , the inductive hypothesis implies that @xmath420 , @xmath421 , and @xmath422 . obviously , @xmath423 , @xmath424 , and @xmath425 . since @xmath389 , it is now easy to verify that @xmath405 satisfies condition  c2 .    hereafter , a connected component of @xmath19 is _ good _ if it is a tree @xmath405 satisfying condition  c2 in lemma  [ lem : type1 ] or condition  c3 below , while it is _ bad _ otherwise .    * @xmath426 and @xmath413 .",
    "[ lem : type2 ] suppose that @xmath51 is a bad connected component of @xmath404 .",
    "then , @xmath51 is a cycle of length at least  4 , a 0-path , or a 4-path whose endpoints are leaves of @xmath0 .",
    "moreover , if @xmath51 is a 0-path , then the unique vertex @xmath196 satisfies that each @xmath427 is an internal vertex of a tree component of @xmath404 and no two vertices in @xmath428 are adjacent in @xmath404 .",
    "since @xmath51 is bad , lemma  [ lem : type1 ] ensures that @xmath51 is a path or cycle and in turn is a connected component of @xmath397 .",
    "indeed , @xmath51 can not be a path of length at least  5 , because otherwise @xmath51 would satisfy condition  c2 .",
    "now , by lemma  [ lem : prep ] , @xmath51 is a cycle of length at least  4 , a 0-path , or a 4-path whose endpoints are leaves of @xmath0 .",
    "suppose that @xmath51 is a 0-path .",
    "then , @xmath51 is also 0-path in @xmath397 .",
    "let @xmath110 be the unique vertex in @xmath51 .",
    "consider an arbitrary @xmath429 . since operation  13 can not be performed on @xmath397",
    ", @xmath30 is not a leaf of a tree component of @xmath404 .",
    "moreover , since operation  6 can not be performed on @xmath397 , @xmath30 does not appear in a cycle of @xmath404 .",
    "furthermore , since operation  14 can not be performed on @xmath397 , no two vertices in @xmath428 are adjacent in @xmath404 .",
    "we next want to define several operations on @xmath19 none of which will produce a new cycle or a new bad connected component in @xmath19 .",
    "an operation on @xmath19 is _ good _ if it either just connects two or more connected components of @xmath19 into a single good connected component , or modify a good connected component of @xmath19 so that it has more internal vertices ( and hence remains good ) .    in the second stage",
    ", we modify @xmath19 by repeatedly performing the following operations on @xmath19 until none of them is applicable .",
    "operation 15 .",
    ": :    if @xmath19 has two cycles @xmath190 and    @xmath191 such that @xmath430 and    some edge @xmath431 of @xmath0 satisfies    @xmath432 and @xmath433 , then    connect @xmath190 and @xmath191 into a single path    @xmath1 by deleting one edge incident to @xmath76 in    @xmath190 , deleting one edge incident to @xmath80 in    @xmath191 , and adding the edge @xmath28",
    ". operation 16 .",
    ": :    if @xmath19 has a cycle @xmath190 of length at    least  5 and a good connected component @xmath191 such that    some edge @xmath434 of @xmath0 satisfies    @xmath435 and @xmath436 , then connect    @xmath190 and @xmath191 into a single tree    @xmath1 by deleting one edge incident to @xmath30 in    @xmath190 and adding the edge @xmath28 .",
    "operation 17 .",
    ": :    if @xmath19 has a cycle @xmath51 of length at    least  6 and a 4-path component @xmath48 such that some edge    @xmath434 of @xmath0 satisfies    @xmath437 and @xmath438 , then connect    @xmath51 and @xmath48 into a single tree @xmath1    by deleting one edge incident to @xmath30 in @xmath51    and adding the edge @xmath28 .",
    "operation 18 .",
    ": :    if @xmath19 has a 0-path component @xmath48 whose    unique vertex @xmath110 has two neighbors @xmath76 and    @xmath80 in @xmath0 such that @xmath76 and    @xmath80 fall into different connected components    @xmath190 and @xmath191 of @xmath19 ,    then connect @xmath48 , @xmath190 , and @xmath191    into a single connected component @xmath1 by adding the edges    @xmath439 and @xmath440 . operation 19 .",
    ": :    if @xmath19 has a good connected component    @xmath190 and another connected component @xmath191    such that some leaf @xmath110 of @xmath190 is adjacent    to a vertex @xmath30 of @xmath191 in @xmath0 ,    then connect @xmath190 and @xmath191 into a single    tree component @xmath1 by deleting one edge incident to    @xmath30 in @xmath191 if @xmath191 is a cycle ,    and further adding the edge @xmath159 .",
    "operation 20 .",
    ": :    if a cycle @xmath51 of @xmath19 has an edge    @xmath431 such that some @xmath441 and some    @xmath442 fall into different    connected components @xmath190 and @xmath191 of    @xmath19 other than @xmath51 , then connect    @xmath51 , @xmath190 , and @xmath191 into a    single tree component @xmath1 by deleting @xmath28 ,    deleting one edge incident to @xmath66 if @xmath190    is a cycle , deleting one edge incident to @xmath67 if    @xmath191 is a cycle , and adding the edges    @xmath443 and @xmath444 .",
    "operation 21 .",
    ": :    if a good connected components @xmath51 of    @xmath19 is not a hamiltonian path of @xmath0    but is a dead path whose endpoints are adjacent in @xmath0 ,    then choose an arbitrary port @xmath110 of @xmath51 ,    modify @xmath51 by adding the edge of @xmath0 between    the endpoints of @xmath51 and deleting one edge incident to    @xmath110 in @xmath51 , and further perform operation  19 .",
    "operation 22 .",
    ": :    if a good connected component @xmath51 of    @xmath19 is not a path but has two leaves    @xmath110 and @xmath30 with    @xmath403 , then modify @xmath51 by first    finding an arbitrary vertex @xmath136 on the path    @xmath48 between @xmath110 and @xmath30 in    @xmath51 with @xmath445 , then deleting one    edge incident to @xmath136 in @xmath48 , and further    adding the edge @xmath159 .",
    "operation 23 .",
    ": :    if @xmath19 has a 0-path component @xmath190 , a    4-path component @xmath48 , and a connected component    @xmath191 other than @xmath190 and @xmath48    such that the center vertex @xmath226 of @xmath48 is    adjacent to a vertex @xmath136 of @xmath191 in    @xmath0 and the unique vertex @xmath30 of    @xmath190 is adjacent to the other two internal vertices    @xmath67 and @xmath206 of @xmath48 ( than    @xmath226 ) in @xmath0 , then connect @xmath190 ,    @xmath48 , and @xmath191 into a single connected    component @xmath1 by deleting the edge    @xmath382 , deleting one edge incident to    @xmath136 if @xmath191 is a cycle , and adding the edges    @xmath446 , @xmath447 ,    @xmath448 .        in the following proofs of lemmas  [ lem :",
    "op15 ] through  [ lem : op23 ] , @xmath405 denotes the new connected component of @xmath19 created by the corresponding operation .",
    "[ lem : op15 ] operation 15 is good .    obviously , @xmath449 , @xmath450 , and @xmath451 .",
    "thus , @xmath405 is good .",
    "[ lem : op16 ] operation 16 is good .    obviously , @xmath452 , @xmath453 , and @xmath454 .",
    "thus , @xmath405 is good .",
    "[ lem : op17 ] operation 17 is good .    obviously , @xmath455 , @xmath456 , and @xmath413 .",
    "thus , @xmath405 is good .",
    "[ lem : op18 ] operation 18 is good .",
    "since operation  6 can not be applied on @xmath397 , neither @xmath190 nor @xmath191 is a cycle .",
    "hence , both @xmath190 and @xmath191 are trees and in turn @xmath405 is a tree . to show that @xmath405 is good , we distinguish three cases as follows .    _ case 1 : _ both @xmath190 and @xmath191 are good . in this case ,",
    "@xmath457 , @xmath458 , and @xmath459 .",
    "thus , @xmath405 is clearly good .",
    "_ case 2 : _ one of @xmath190 and @xmath191 is good . w.l.o.g . , we assume that @xmath190 is good and @xmath191 is bad . then , by lemma  [ lem : type2 ] , @xmath191 is either a 0-path or a 4-path whose endpoints are leaves of @xmath0 .",
    "the former case is impossible , because operation  13 can not be performed on @xmath397 . in the latter case , @xmath460 , @xmath461 , and @xmath462 , implying that @xmath405 is good .",
    "_ case 3 : _ both @xmath190 and @xmath191 are bad . in this case , both @xmath190 and @xmath191 are 4-paths whose endpoints are leaves of @xmath0 , because operation  13 can not be performed on @xmath397 .",
    "so , @xmath463 , @xmath464 , and @xmath465 , implying that @xmath405 is good .",
    "[ lem : op19 ] operation 19 is good .    @xmath405 is clearly a tree . to show that @xmath405 is good , we distinguish three cases as follows .    _ case 1 : _",
    "@xmath191 is a cycle . in this case ,",
    "@xmath466 , @xmath467 , and @xmath468 .",
    "so , @xmath405 is clearly good .",
    "_ case 2 : _",
    "@xmath191 is good . in this case ,",
    "@xmath469 , @xmath458 , and @xmath470 .",
    "so , @xmath405 is clearly good .",
    "_ case 3 : _",
    "@xmath191 is bad but not a cycle . in this case , lemma  [ lem : type2 ] ensures that @xmath191 is either a 0-path or a 4-path whose endpoints are leaves of @xmath0 . in the latter case , @xmath460 , @xmath461 , and latexmath:[$|l(\\hat{t})| =     we assume the former case . if @xmath190 satisfies condition  c2 , then @xmath472 , @xmath473 , and @xmath468 , implying that @xmath405 is good",
    "otherwise , @xmath474 , @xmath475 , and @xmath468 , implying that @xmath405 is good .",
    "[ lem : op20 ] operation 20 is good .",
    "@xmath405 is clearly a tree . to show that @xmath405 is good , we distinguish three cases as follows .    _ case 1 : _ both @xmath190 and @xmath191 are cycles . in this case ,",
    "@xmath476 , @xmath477 , and @xmath451 .",
    "thus , @xmath405 is clearly good .",
    "_ case 2 : _ one of @xmath190 and @xmath191 is a cycle . w.l.o.g .",
    ", we assume that @xmath191 is a cycle . if @xmath190 is good , then @xmath478 , @xmath479 , and @xmath480 , implying that @xmath405 is good .",
    "so , assume that @xmath190 is bad . then",
    ", by lemma  [ lem : type2 ] , @xmath190 is a 0-path or 4-path whose endpoints are leaves of @xmath0 .",
    "indeed , @xmath190 is not a 0-path , because operation  13 can not be performed on @xmath397 .",
    "thus , @xmath481 , @xmath482 , and @xmath413 .",
    "hence , @xmath405 is good .",
    "_ case 3 : _ neither @xmath190 nor @xmath191 is a cycle .",
    "if both @xmath190 and @xmath191 are good , then @xmath483 , @xmath484 , and @xmath485 , implying that @xmath405 is good",
    ". similarly , if both @xmath190 and @xmath191 are bad , then both of them are 4-paths whose endpoints are leaves of @xmath0 and in turn latexmath:[$w(\\hat{t } ) =     @xmath465 , implying that @xmath405 is good .",
    "so , we may assume that @xmath190 is good but @xmath191 is bad .",
    "then , @xmath191 is a 4-path whose endpoints are leaves of @xmath0 .",
    "hence , @xmath487 , and @xmath462 .",
    "therefore , @xmath405 is good .",
    "[ lem : op21 ] operation 21 is good .    by lemma  [ lem : op19 ] , operation  21 is clearly good .",
    "[ lem : op22 ] operation 22 is good .",
    "the operation clearly decreases the number of leaves in @xmath51 by  1 , and is hence good .",
    "[ lem : op23 ] operation 23 is good .",
    "@xmath405 is clearly a tree . to show that @xmath405 is good , we distinguish three cases as follows .    _ case 1 : _ @xmath191 is a cycle . in this case ,",
    "@xmath488 , @xmath489 , and @xmath413 .",
    "so , @xmath405 is clearly good .",
    "_ case 2 : _",
    "@xmath191 is good . in this case ,",
    "@xmath490 , @xmath491 , and @xmath492 .",
    "so , @xmath405 is clearly good .",
    "_ case 3 : _",
    "@xmath191 is bad . in this case , @xmath191 is either a 0-path or a 4-path whose endpoints are leaves of @xmath0 . in the former case , @xmath493 , @xmath494 , and @xmath413 , implying that @xmath405 is clearly good . in the latter case , @xmath463 , @xmath495 , and @xmath465 , implying that @xmath405 is clearly good .    we next show that the above operations lead to a number of useful properties of @xmath496 .",
    "[ lem:4-cycle1 ] each 4-cycle of @xmath496 is adjacent to at most one other connected component of @xmath496 in @xmath0 .",
    "let @xmath51 be a 4-cycle in @xmath496 .",
    "further let @xmath76 ,  , @xmath497 be the vertices of @xmath51 and assume that they appear in @xmath51 clockwise in this order .",
    "by statement  [ stat : p6 ] in lemma  [ lem : prep ] , @xmath51 has at least three ports . without loss of generality , we may assume that @xmath76 through @xmath85 are ports of @xmath51 .",
    "since operation  20 can not be performed on @xmath496 , there is a unique connected component @xmath498 in @xmath496 such that @xmath499 is a nonempty subset of @xmath500 .",
    "for the same reason , @xmath501 is a nonempty subset of @xmath500 .",
    "moreover , if @xmath497 is also a port of @xmath51 , then for the same reason , @xmath502 is a nonempty subset of @xmath500 .",
    "in any case , @xmath503 and hence @xmath51 is adjacent to only @xmath498 in @xmath0 .    [ lem:4-cycle4-cycle ] no two 4-cycles of @xmath496 are adjacent in @xmath0 .",
    "for a contradiction , assume that two 4-cycles @xmath190 and @xmath191 of @xmath496 are adjacent in @xmath0 .",
    "then , by lemma  [ lem:4-cycle1 ] , @xmath504 $ ] is a connected component of @xmath0 . however , this is impossible because @xmath0 is connected and @xmath296 .",
    "[ lem:4-cycle4-path ] no 4-cycle @xmath51 of @xmath496 is adjacent to a 4-path component of @xmath496 in @xmath0 .    for",
    "a contradiction , assume that a 4-cycle @xmath51 of @xmath496 is adjacent to a 4-path component @xmath48 of @xmath496 in @xmath0 .",
    "let @xmath76 ,  , @xmath497 be the vertices of @xmath51 and assume that they appear in @xmath51 clockwise in this order .",
    "let @xmath505 be the set of all @xmath506 such that for some @xmath507 , @xmath508 .",
    "since operation  4 can not be performed on @xmath0 , @xmath509 . moreover , by lemma  [ lem:4-cycle1 ] , @xmath510 .",
    "let @xmath66 ,  , @xmath211 be the vertices of @xmath48 and assume that they appear in @xmath48 in this order .",
    "then , @xmath48 is a dead 4-path component of @xmath397 .",
    "so , by statement  [ stat : p4 ] in lemma  [ lem : prep ] , both @xmath66 and @xmath211 are leaves of @xmath0 .",
    "thus , @xmath511 . since @xmath321 and @xmath51 has at least three ports ( by statement  [ stat : p6 ] in lemma  [ lem : prep ] )",
    ", there are two consecutive edges in @xmath51 whose endpoints all are ports of @xmath51 . without loss of generality , we assume that @xmath76 through @xmath85 are ports of @xmath51 .    _ case 1 : _ @xmath512 .",
    "in this case , since both @xmath76 and @xmath85 are ports of @xmath51 and operation  12 can not be performed on @xmath397 , @xmath513 and @xmath514 , and in turn @xmath515 as well .",
    "now , since @xmath509 , @xmath0 has an edge @xmath516 with @xmath517 .",
    "however , we can now see that operation  12 can be performed on @xmath397 , a contradiction .    _ case 2 : _",
    "@xmath518 . in this case , since @xmath80 is a port of @xmath51 , @xmath519 or @xmath520 .",
    "so , @xmath521 and @xmath522 , because operation  12 can not be performed on @xmath397 .",
    "thus , @xmath523 is either @xmath222 or @xmath524 for some @xmath525 . in the latter case , since @xmath509 , @xmath526 or @xmath527 , and hence operation  10 or  12",
    "can be performed , a contradiction . in the former case ,",
    "if @xmath526 , then operation  12 can be performed on @xmath397 , a contradiction ; otherwise , @xmath528 and in turn operation  10 can be performed on @xmath0 , a contradiction .",
    "[ lem:4-cycle5-cycle ] no 4-cycle of @xmath496 is adjacent to a 5-cycle of @xmath496 in @xmath0 .    for",
    "a contradiction , assume that a 4-cycle @xmath190 of @xmath496 is adjacent to a 5-cycle @xmath191 of @xmath496 in @xmath0 . for each @xmath91 , let @xmath529 , ",
    ", @xmath530 be the vertices of @xmath531 and assume that they appear in @xmath531 clockwise in this order . by statement",
    "[ stat : p6 ] in lemma  [ lem : prep ] , @xmath190 has at least three ports , and in turn three ports of @xmath190 appear in @xmath190 consecutively because @xmath532 . without loss of generality , we assume that @xmath533 , @xmath534 , and @xmath535 are ports of @xmath190 .    by lemma  [ lem:4-cycle1 ] , @xmath536 . since @xmath537 and operation  4 can not be performed on @xmath0 , @xmath538 , where @xmath539 is the set of vertices @xmath540 with @xmath541 .",
    "we distinguish two cases as follows .    _ case 1 : _ @xmath539 has two vertices adjacent in @xmath191 . without loss of generality ,",
    "we assume that @xmath542 . then , since operation  20 can not be performed on @xmath496 , @xmath543 .",
    "so , operation  4 can be performed on @xmath0 , a contradiction .    _ case 2 : _ no two vertices of @xmath539 are adjacent in @xmath191 . in this case , since @xmath544 , @xmath545 . without loss of generality ,",
    "we assume that @xmath546 . then , since operation  20 can not be performed on @xmath496 , @xmath547 .",
    "indeed , since operation  4 can not be performed on @xmath496 , @xmath548 .",
    "so , @xmath549 and @xmath550 because operation  10 can not be performed on @xmath0 .",
    "thus , @xmath551 because @xmath552 .",
    "now , since @xmath553 , @xmath554 and in turn operation  10 can be performed on @xmath0 , a contradiction .",
    "based on the above lemmas in this section , we are now ready to prove the next lemma :    [ lem : stage2 ] suppose that @xmath51 is a connected component of @xmath496 . then , @xmath51 is a 4-cycle , 5-cycle , 0-path , 4-path , or good connected component .",
    "moreover , the following statements hold :    1 .",
    "[ stat : final1 ] if @xmath51 is a 0-path , then its unique vertex @xmath110 satisfies that for a single tree component @xmath498 of @xmath496 , each @xmath429 is an internal vertex of @xmath498 , and @xmath110 is a leaf of @xmath0 if @xmath498 is bad .",
    "[ stat : final2 ] if @xmath51 is a 4-path component of @xmath496 , then its endpoints are leaves of @xmath0 and each internal vertex @xmath110 of @xmath51 satisfies that each neighbor of @xmath110 in @xmath0 is a leaf of @xmath0 , a vertex of a 5-cycle of @xmath496 , or an internal vertex of a 4-path component or a good connected component of @xmath19 .",
    "[ stat : final3 ] if @xmath51 is a 4-cycle of @xmath496 , then each vertex @xmath110 of @xmath51 satisfies that each neighbor of @xmath110 in @xmath0 is an internal vertex of a good connected component of @xmath496 .",
    "[ stat : final4 ] if @xmath51 is a 5-cycle of @xmath496 , then each vertex @xmath110 of @xmath51 satisfies that each neighbor of @xmath110 in @xmath0 is an internal vertex of a 4-path component of @xmath496 .",
    "[ stat : final5 ] if @xmath51 is a good connected component but not a hamiltonian path of @xmath0 , then each leaf @xmath110 of @xmath51 satisfies that each neighbor of @xmath110 in @xmath0 is an internal vertex of @xmath51 .    by lemmas  [ lem : type2 ] through [ lem :",
    "op23 ] , @xmath51 is a cycle of length at least  4 , 0-path , 4-path , or good connected component .",
    "indeed , @xmath51 can not be a cycle of length  6 or more , because otherwise operation  6 could be performed on @xmath404 or operation  @xmath144 could be performed on @xmath496 for some @xmath555 .",
    "we next prove the statements separately as follows .",
    "_ statement  [ stat : final1 ] : _ suppose that @xmath51 is a 0-path . let @xmath110 be the unique vertex in @xmath51 . since operation  18 can not be performed on @xmath496 , @xmath556 for some connected component @xmath498 of @xmath496 .",
    "if @xmath498 is not a connected component of @xmath404 , then by lemmas  [ lem : op15 ] through  [ lem : op23 ] , @xmath498 is a good connected component of @xmath496 and in turn each @xmath429 is an internal vertex of @xmath498 ( because otherwise operation  19 could be performed on @xmath496 ) .",
    "so , we may assume that @xmath498 is also a connected component of @xmath404 .",
    "then , by lemma  [ lem : type2 ] , @xmath498 is a tree component and each @xmath429 is an internal vertex of @xmath498 . for a contradiction , assume that @xmath498 is bad but",
    "@xmath110 is not a leaf of @xmath0 .",
    "since @xmath498 is a bad tree component of @xmath404 with internal vertices , lemma  [ lem : type2 ] ensures that @xmath498 is a 4-path .",
    "let @xmath66 ,  , @xmath211 be the vertices of @xmath498 and assume that they appear in @xmath498 in this order .",
    "since @xmath110 is not a leaf of @xmath0 , lemma  [ lem : type2 ] ensures that @xmath557 .",
    "now , operation  8 or  23 can be performed on @xmath0 , a contradiction .    _",
    "statement  [ stat : final2 ] : _ suppose that @xmath51 is a 4-path component of @xmath496 .",
    "then , @xmath51 is also a 4-path component of @xmath404 , because operation  @xmath144 does not produce a new bad connected component in @xmath19 for each @xmath558 .",
    "so , by lemma  [ lem : type2 ] , each endpoint of @xmath51 is a leaf of @xmath0 .",
    "consider an arbitrary internal vertex @xmath110 of @xmath51 and an arbitrary neighbor @xmath30 of @xmath110 in @xmath0 . since operation  19 can not be performed on @xmath496",
    ", @xmath30 is not a leaf of a good connected component of @xmath496 .",
    "so , if @xmath30 appears in a good connected component @xmath498 of @xmath496 , @xmath30 must be an internal vertex of @xmath498 .",
    "moreover , by lemma  [ lem:4-cycle4-path ] , @xmath30 can not appear in a 4-cycle of @xmath496 .",
    "thus , to finish the proof , we may assume that @xmath30 appears in a bad tree component @xmath559 of @xmath496 .",
    "now , if @xmath30 appears in a 0-path component of @xmath496 , then @xmath30 is a leaf of @xmath0 by statement  [ stat : final1 ] in this lemma ; otherwise , @xmath30 can not be an endpoint of another 4-path component of @xmath496 because each endpoint of a 4-path component of @xmath496 is a leaf of @xmath0 .",
    "_ statement  [ stat : final3 ] : _ let @xmath51 be a 4-cycle of @xmath496 .",
    "@xmath51 can not be adjacent to a 0-path component of @xmath496 in @xmath0 , because operation  6 can not be performed on @xmath397 and neither stage  2 nor stage  3 produces a new cycle or a new 0-path component in @xmath19 .",
    "so , by lemmas  [ lem:4-cycle4-cycle ] through  [ lem:4-cycle5-cycle ] , each @xmath560 appears in a good connected component @xmath498 of @xmath496 .",
    "indeed , @xmath30 must be an internal vertex of @xmath498 , because operation  19 can not be performed on @xmath496 .",
    "_ statement  [ stat : final4 ] : _ let @xmath51 be a 5-cycle of @xmath496 .",
    "@xmath51 can not be adjacent to a 0-path component of @xmath496 in @xmath0 , because operation  6 can not be performed on @xmath397 and neither stage  2 nor stage  3 produces a new cycle or a new 0-path component in @xmath19 . moreover , since neither operation  15 nor operation  16 can be performed on @xmath496 , @xmath51 can not be adjacent to a 5-cycle or a good connected component of @xmath496 in @xmath0 .",
    "so , by lemma  [ lem:4-cycle5-cycle ] , each @xmath560 appears in a 4-path component @xmath498 of @xmath496 .",
    "indeed , @xmath30 must be an internal vertex of @xmath498 , because each endpoint of @xmath498 is a leaf of @xmath0 .",
    "_ statement  [ stat : final5 ] : _ supppose that @xmath51 is a good connected component of @xmath496 but not a hamiltonian path of @xmath0 .",
    "let @xmath110 be a leaf of @xmath51 .",
    "since operation  @xmath144 can not be performed on @xmath496 for each @xmath561 , each @xmath429 is an internal vertex of @xmath51 .    finally ,",
    "in the third stage , we complete the transformation of @xmath19 into a spanning tree of @xmath0 by further modifying @xmath19 by performing the following steps :    1 .",
    "for each cycle @xmath51 of @xmath19 , first select an arbitrary edge @xmath562 such that @xmath196 and @xmath563 , then delete one edge incident to @xmath110 in @xmath51 , and further add @xmath28 .",
    "( _ comment : _ since no two cycles in @xmath496 are adjacent in @xmath0 , @xmath30 appears in a tree component of @xmath19 .",
    "moreover , after this step , @xmath19 has only tree components . ) 2 .",
    "arbitrarily connect the connected components of @xmath19 into a tree by adding some edges of @xmath0 .",
    "it is easy to see that for each @xmath558 , step  @xmath144 can be done in @xmath564 time .",
    "so , the second stage takes @xmath386 time .",
    "since the other two stages can be easily done in @xmath564 time , the refined step  [ step : trans ] can be done @xmath386 time .",
    "let @xmath565 ( respectively , @xmath566 ) be the number of internal vertices in connected components of @xmath496 satisfying condition  c2 ( respectively , c3 ) , @xmath567 ( respectively , @xmath568 ) be the total number of edges in @xmath397 whose endpoints appear in the same connected components of @xmath496 satisfying condition  c2 ( respectively , c3 ) , @xmath569 ( respectively , @xmath570 ) be the number of 4-cycles ( respectively , 5-cycles ) in @xmath496 , and @xmath571 be the number of 4-path components in @xmath496 .",
    "_ statement  [ stat : opt2 ] _ : for convenience , let @xmath126 be obtained from @xmath1 by rooting @xmath1 at an internal vertex , and @xmath577 be obtained from @xmath126 by removing those edges @xmath578 such that some 4-cycle of @xmath496 contains both @xmath110 and @xmath30 . further let @xmath579 ( respectively , @xmath580 ) be the set of vertices in @xmath126 ( respectively , @xmath577 ) that have at least one child in @xmath126 ( respectively , @xmath577 ) . also let @xmath581 . clearly , @xmath582 .",
    "moreover , for each 4-cycle @xmath51 of @xmath496 , @xmath126 can contain at most three edges between the vertices of @xmath51 .",
    "so , @xmath583 .",
    "furthermore , lemma  [ lem : stage2 ] ensures that each vertex of @xmath579 other than    * the vertices in @xmath584 , * the @xmath585 internal vertices of 4-path components of @xmath496 , * the @xmath586 vertices of 5-cycles , and * the @xmath587 internal vertices of good connected components of @xmath496        let @xmath572 be as in lemma  [ lem : apx ] , and @xmath590 .",
    "by lemma  [ lem : apx ] , @xmath591 , where @xmath592 and @xmath593 . note that @xmath594 and @xmath595 , where @xmath596 and @xmath597 .",
    "so , it suffices to show that @xmath598 .",
    "this is done if @xmath599 .",
    "thus , we assume that @xmath600 .",
    "then , @xmath601 .",
    "hence , @xmath602 .",
    "now , since @xmath603 , @xmath604 .",
    "moreover , since @xmath605 , @xmath606 . therefore , @xmath607 .",
    "the running is clearly as claimed ."
  ],
  "abstract_text": [
    "<S> given a graph @xmath0 , the _ maximum internal spanning tree problem _ </S>",
    "<S> ( mist for short ) asks for computing a spanning tree @xmath1 of @xmath0 such that the number of internal vertices in @xmath1 is maximized . </S>",
    "<S> mist has possible applications in the design of cost - efficient communication networks and water supply networks and hence has been extensively studied in the literature . </S>",
    "<S> mist is np - hard and hence a number of polynomial - time approximation algorithms have been designed for mist in the literature . </S>",
    "<S> the previously best polynomial - time approximation algorithm for mist achieves a ratio of @xmath2 . in this paper , we first design a simpler algorithm that achieves the same ratio and the same time complexity as the previous best . </S>",
    "<S> we then refine the algorithm into a new approximation algorithm that achieves a better ratio ( namely , @xmath3 ) with the same time complexity . </S>",
    "<S> our new algorithm explores much deeper structure of the problem than the previous best . </S>",
    "<S> the discovered structure may be used to design even better approximation or parameterized algorithms for the problem in the future .    </S>",
    "<S> * keywords : * approximation algorithms , spanning trees , path - cycle covers . </S>"
  ]
}