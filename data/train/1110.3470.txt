{
  "article_text": [
    "evolution of large software can only stay manageable when the rippling effect of change is to some degree constrained .",
    "one way of achieving this is to program in terms of modules that communicate through interfaces  @xcite . a change to an interface",
    "may still cause a rippling effect , but implementation details that are abstracted over ( that are hidden behind the interface ) may change without such a global impact .",
    "in object technology , classes act as modules , and interfaces are made of methods .",
    "however , because methods are encapsulated in objects , interfaces in object systems do not allow abstraction over _ where _ a particular method is implemented .",
    "this implies that every time a change is made to the implementation structure of an application , i.e.  anytime a method is moved , a rippling effect may occur .    some movements of methods , however , do not fundamentally alter the implementation structure , and it may be desirable to make such changes without incurring a rippling effect .",
    "in particular , we are thinking of scenarios where methods are moved from the class of its receiving parameter to the class of any of its other parameters . as any practitioner can vouch , the choice of which class to assign responsibility for a method ( especially one with multiple object parameters ) may sometimes lie in the eye of the beholder .",
    "hence it may be subject to change , either because of evolving insight into the design trade - offs , or simply for pragmatic reasons .",
    "a common way of side - stepping rippling change when a method implementation needs to move from one class to another is to write proxy - code to forward the method invocation to its new destination .",
    "presence of proxy code may act as evidence that the flexibility of moving methods is desirable .",
    "such proxy code frequently occurs in recently emerging application fields such as ubiquitous computing and service - oriented computing .",
    "in fact , it was our experience in designing a programming language for these fields  @xcite that prompted our interest in this kind of malleability .",
    "hence , one may assume that malleability of this kind will gain in importance together with further development of these application fields .",
    "as an example , consider a method that registers a transaction between a _ shop _",
    ", an _ item _ and a _ customer_. this method may be defined in the class that models shops . a client that invokes this method would therefore write something along the lines    ....",
    "shop.transaction(item,customer ) ....    if it were later to be decided that this is not the optimal place for the method implementation to reside , and it was moved to the class representing items , then this client would break .",
    "adding a proxy - method to the _ shop _ class , although common , is not entirely desirable .",
    "the main issue lies with having to manually add and maintain the code , but more subtly , proxy code also essentially takes the form of double dispatch invocation and therefore has slightly different dispatch semantics from the original .    to tackle this issue",
    ", we propose a scheme where methods are written in symmetric form and may be defined in the class of any of its parameters . with methods in symmetric form , we mean methods that list their receiving parameter explicitly , thereby treating all their parameters uniformly . despite not giving any parameter special treatment , symmetric methods",
    "are encapsulated in the class in which they are defined . in other words , they have unrestricted access to the bowels of that class , and depend on the access model of the language for access to the other parameters .",
    "under such a scheme , the above _ transaction _ method may be defined in either the shop , item , or customer class .",
    "for example , it may be defined in the _ item _ class as below , while not breaking a client that assumes the method being defined in the _ shop _ class .    ....",
    "class item {      void transaction(shop s , item i , customer c ) {        ... }    } ....    a main feature of object - orientation is its modular extensibility : method behaviour can be extended for derived classes ( subtypes ) without changing the original class . to achieve this , a subclass may define a method with the same signature that overloads the original method name with new behaviour .",
    "the discretely specified method bodies together make up the method and are called its branches .",
    "what method body is executed is decided at run - time based on the type of the receiving parameter .",
    "we would like to generalize this ability to discretely specify method behaviour to our setting with encapsulated symmetric methods .",
    "for example , consider a _ charity shop _ class that is a subclass of the _ shop _ class .",
    "we would like to be able to define an extension of the _ transaction _ method that deals specifically with charity shops in the _ charity shop _ class , and have it invoked whenever the argument to the method is a charity shop .    ....",
    "class charityshop extends shop {      void transaction(charityshop cs , item i , customer c ) {        ... }    } ....    to achieve this -while avoiding ad - hoc invocation semantics for different method call sites- we need to resort to multiple dynamic dispatch , also known as multi - methods . with multi - methods methods",
    "may be discretely specified , and branch selection is based on the dynamic type of all parameters .",
    "it is this characteristic that makes that branches may specialize any of the parameter types , and still be taken into account during selection .",
    "note how the above method specializes a method that is not defined in its superclass , but in the unrelated _ item _ class .",
    "this brings us to a model with encapsulated symmetric multi - methods , in which the location of method implementations is partially abstracted over , and methods may be discretely specified along the hierarchies of the different argument classes .",
    "clients , while still receiving the same level of feedback as before from static typing , can write code that is to a degree independent of where methods are implemented , and therefore may remain unchanged when the implementations are adapted or extended . the net effect of employing this scheme over standard object technology",
    "is that there is an increase in malleability of software , with the well - known software engineering benefits as a result .    in the next sections ,",
    "we incorporate the ideas above into a core object - oriented calculus ( featherweight java ) .",
    "we start by discussing the merits of doing so , and then present the adapted formal semantics ( sect .",
    "[ sec : syntax]-[sec : typing ] ) , including new notions of method lookup and selection ( sect .",
    "[ sec : lookup ] ) , and constraints on branches of overloaded methods ( sect .",
    "[ sec : typing ] ) .",
    "soundness of the extension is tackled in sect .",
    "[ sec : soundness ] .",
    "we discuss some observations about dispatching strategies in sect .",
    "[ sec : observations ] related work follows in sect .",
    "[ sec : related ] , and finally we present our conclusions in sect .",
    "[ sec : conclusions ] .",
    "the appendices contain an overview of the different formal definitions .",
    "we illustrate our ideas by extending featherweight java ( fj )  @xcite with symmetric encapsulated multi - methods , the result we call symmetric featherweight multi - java ( sfmj ) .",
    "in particular , @xmath0 we change the syntax for method definition and invocation to make all parameters explicit , @xmath1 we allow methods to be defined in the class of any of its parameters , and @xmath2 we introduce multiple dispatch .",
    "we use fj as a paradigmatic core calculus for mainstream class - based object - oriented languages .",
    "our results are more generally applicable than to java only .",
    "however , fj proved to be useful vehicle for our explorations , because despite its simplicity it models method invocation in enough detail that we can adapt it for our purposes with little increase in complexity .",
    "in fact , the changes to the calculus are localized to method definition , invocation , and selection . as a result we may even establish soundness of sfmj by a proof that is a limited extension to the one of fj .",
    "an in - depth discussion of fj is beyond the merit of this article .",
    "we refer the reader to  @xcite , from which we also borrow the syntactic conventions without further comment .",
    "the structure of our exposition also mirrors the original one .",
    "an overview of the entire specification of sfmj can be found in fig .",
    "[ fig : reduction ] and fig .",
    "[ fig : typing ] . to facilitate comparison with fj",
    ", we also list the parts of the specification that have been altered in fig .",
    "[ fig : fj ] .      like fj ,",
    "an sfmj program is a tuple @xmath3 of a _ class table _ and an expression .",
    "a class table is a mapping from class names to class declarations .",
    "the class table is assumed to be fixed , and implicitly accessible to all the semantic rules .",
    "class declarations list the ancestor of the class ( single inheritance ) , and in the body the fields , constructor and methods .",
    "there can only be a single constructor , and it takes a stylized form .",
    "methods may have any number of parameters ( note the bar notation to indicate sequences ) , all with explicitly declared type , and a single return type .",
    "method body consists of a single expression , which denotes the value returned on method invocation .",
    "the expressions consist of variables ( which may be used to denote fields or arguments ) , field access , method invocation , object creation and casting .",
    "there is only one kind of values ( expressions in normal form ) : objects , which are object creation expressions with their arguments fully evaluated .",
    "note how objects carry their type , making it available at run - time .",
    "the syntax of sfmj can be found in fig .",
    "[ fig : syntax ] below .",
    "note that the sole difference in syntax between fj and sfmj lies in method invocation : the original asymmetric syntax @xmath4 has been changed to a function - like @xmath5 that treats all parameters uniformly .",
    "syntax for method definition , and the fact that methods may now be defined in more places can already be accommodated by existing syntax .",
    "the operational semantics of sfmj is specified as a rewriting semantics .",
    "reduction reduces expressions to values by successive applications of reduction rules .",
    "there is just one kind of values ( object ) , as primitive values are not modelled .",
    "the full specification of the reduction relation can be found in fig .",
    "[ fig : reduction ] . only reduction of method invocation expressions are of interest here .",
    "the uniform treatment of parameters yields a single congruence rule rc - invk ( compare with rc - invk - recv and rc - invk - arg in fig .",
    "[ fig : fj ] ) .",
    "the computation rule for method invocation expressions states simply that for fully evaluated method arguments , the expression reduces to the substitution of these arguments into the body of the method retrieved by method lookup .",
    "method lookup is specified in terms the composition of a _ lookup _ function that locates potentially applicable methods , and a _ selection _ function that chooses one of these .",
    "to support multiple dispatch , the lookup function is dependent on the ( run - time ) types of the actual parameters ) inherently carry their run - time type . ] .",
    "definitions of these functions can be found in sect .",
    "[ sec : lookup ] below .",
    "note how the rule retains the basic structure of the original .",
    "in fact , with appropriate definitions for _ lookup _ and _ select _ , we may achieve the original semantics .",
    "such a definition can be found in fig .",
    "[ fig : fjlookup ] .",
    "the method lookup function yields the set of all methods that are applicable to the arguments provided .",
    "method lookup in sfmj must consider that definition of methods may reside in the classes of any of their arguments .",
    "also , because of overloading , a method name alone does not identify applicable methods .",
    "the lookup strategy consists of two parts .",
    "the top - level predicate _",
    "lookup _ takes a method name and a sequence of classes and returns the sequence of methods returned from successive applications of a support predicate @xmath6 to each of the classes in the sequence .",
    "the @xmath6 recursively inspects a class and all its superclasses for methods that satisfy a given signature .",
    "method selection chooses from the set of applicable methods the _ most appropriate _ one .",
    "this is the method with the signature that most closely matches the types of the arguments provided . in other words , it is the most specific method that is applicable to the given arguments .",
    "the predicate is defined as follows :    the existence of a single most applicable method does not come for free , it must be asserted by adequate typing restriction , as we will discuss in section  [ sec : typing ] .",
    "the bulk of the changes lie in the typing .",
    "this is unsurprising , as we allow methods to be defined in the class of any of its parameters , which induces changes to class and method typing .",
    "additionally , the introduction of multiple dispatch requires the introduction of ( global ) constraints to avoid ambiguity between method branches .",
    "method invocation expressions are well - typed when the argument expressions are well - typed , and a method can be found whose whose formal argument types are supertypes of the actual argument types .",
    "the rule is very similar to the original fj rule , except for the uniform treatment of parameters and the reliance on the previously defined lookup function .",
    "note that the types passed to the lookup are the static ( declared ) types of the arguments .",
    "the run - time types of the actual arguments will be subtypes of these types .",
    "hence , this check establishes that there will be at least one method applicable for this method invocation , although more methods may be taken into consideration during evaluation .",
    "a method definition is well - typed when @xmath0 the method body is well - typed assuming the types declared for the formal parameters , @xmath1 the method body expression is assigned a type that is a subtype of the declared return type , and @xmath2 the method is defined in the class of one of the parameters .",
    "it differs from the typing judgment in fj , in its uniform treatment of the parameters ( a pseudo - variable ` this ` need not adding to the typing context in which @xmath7 is typed ) , and in the absence of the invariance restriction on overloading that was imposed by the original .",
    "because of support for multiple dispatch we have to move the equivalent of such a restriction to the program - level ( see below ) .      in order to make a system with overloaded methods type safe and void of ambiguity problems , the set of branch definitions need to be subject to some restrictions .",
    "it must be noted that in our system , this set may not be obtained by looking only at the class in which a method is defined and the classes it references .",
    "this means that we loose separate compilation for sfmj . to see this ,",
    "consider the classes @xmath8 with @xmath9 and @xmath10 .",
    "the following method definitions are legal :    ....    class a {      void m(a a , b b ) { ... }    }    class b { ... }    class a1 extends a {      void m(a1 a , b b ) { ... }    }    class b1 extends b {      void m(a a , b1 b ) { ... }    } ....    the branch definitions in @xmath11 and @xmath12 give rise to an ambiguity when @xmath13 is invoked with instances of @xmath11 and @xmath12 as arguments .",
    "however , when inspecting the classes referenced by @xmath11 , we do not encounter method branches defined in @xmath12 and vice versa .",
    "so , we need to look at all classes to make sure we do not miss any conflicting branch definitions .",
    "note that the introduction of only multi - methods ( and not symmetric methods ) into fj would not suffer from this , as all extensions of @xmath13 would be specified along one hierarchy , and therefore all ( non - separate ) branches would be visible from the leaf classes . the complication -but also the flexibility- of sfmj derives from the fact that different hierarchies are involved , each of which may be independently extended .",
    "we define the following support function to denote all the branches of an overloaded method , based on the observation that two method definitions are branches of the same overloaded method if there exist a method that they both specialize .",
    "let @xmath14 be the set of all methods defined in a program @xmath3 , and @xmath13 be a member of that set .",
    "then @xmath15 denotes the subset of @xmath14 that contains all the branches of the overloaded method of which @xmath13 is a member .",
    "castagna  @xcite has established the minimal constraints branches of an overloaded method must obey .",
    "let @xmath17 be a set of methods that are branches of an overloaded method .",
    "for every two methods @xmath18 and @xmath19 , with respective argument types @xmath20 , and return types @xmath21 it must hold that :    1 .",
    "@xmath22 maximal in @xmath23 a method @xmath13 with argument type @xmath22 must be in @xmath17 2 .",
    "@xmath24    the second constraint states that the value returned by a method that specializes another method should not violate the static return type of the method that is being specialized .",
    "the first constraint avoids ambiguity of method selection by guaranteeing that for any two branches there is always a branch that is most specific ( be it possibly one of the two ) .    we may elaborate a bit on the first constraint in our context to give an intuition on how this constraint makes that the lookup and selection functions defined in section  [ sec : lookup ] always yield a single method .",
    "argument types are sequences of classes .",
    "the maximal lower bound of a sequence is the sequence of the maximal lower bounds , if they all exist .",
    "because of single inheritance , a maximal lower bound of two classes may only exist if one class is a subclass of the other , and it is hence unique ( if it exists ) .",
    "this means that @xmath22 is unique , if it exists , and that it is a sequence of classes that are mentioned in @xmath25 and @xmath26 .",
    "the lookup method defined above yields the subset of all branches that are applicable to the given arguments .",
    "the first constraint explicitly states that for any two methods that lookup returns , there exists a most specific one in the entire set of branches . because this most specific branch has argument types that are mentioned in the argument types of the branches returned by lookup , and because methods are defined in the classes of their parameters , we know that lookup must also have returned this most specific branch . hence _",
    "lookup _ and _ select _ always yield a single method .",
    "so , to make sure that the set of branches is subject to the above constraints , we introduce the following type judgment for programs .",
    "a set of branches _ wellformed _ if they obey the above constraints .",
    "the soundness property that is established for fj carries over entirely for sfmj : if a term is well typed and it reduces to a normal form then it is either a value of a subtype of the original term s type , or an expression that gets stuck at a downcast . formally :    . if @xmath27 and @xmath28 with @xmath29 a normal form , then @xmath29 is either a value @xmath30 with @xmath31 and @xmath32 , or an expression containing @xmath33 where @xmath34 .",
    "having gone through the above exposition , the fact that this property carries over must not come as a surprise .",
    "we have kept the semantics of most constructs constant . the exception",
    "being method invocation , for which we provide similar guarantees as the original .    the original proof ( cf .",
    "@xcite sect .",
    "2.4 , and appendix @xmath35 ) has two parts , first establishing _ subject reduction _ and then _ progress_. we can carry through the soundness proof for sfmj using the original strategy .",
    "in fact , most of the proof needs no change .",
    "we will follow the original structure of the proof , comment on what can stay untouched , and only write out those bits that need changing .",
    "( subject reduction ) . if @xmath36 and @xmath37 , then @xmath38 for some @xmath39 .",
    "the proof for this theorem relies on three support lemmas .    if @xmath40 , then for any @xmath41 @xmath42 with @xmath43 and @xmath44 .",
    "this lemma establishes that method lookup return a more specific method when given more specific argument types .",
    "we proceed by induction on the _ number of positions _ in which the input types ( @xmath45 ) differ .",
    "subtype relation on input types : for the base case , we prove that the lemma holds for identical input types , while for the induction step , we prove the lemma holds for an input type that is specific in exactly one position . then we ` step up ' from one input type , to an input type that is more specific in exactly one position .    * the base case : the input types differ in @xmath46 positions , so @xmath47 .",
    "_ select _ returns the same method , so @xmath48 . *",
    "the induction step considers the case whereby the input types are in @xmath49 places more specific , assuming the lemma holds branches that are in @xmath50 places more specific .",
    "in particular , consider an input type @xmath51 that is in one place more specific than another input type @xmath52 : @xmath53 , with @xmath54 .",
    "+ it is trivial to see that when invoked with @xmath51 , the _ lookup _ predicate returns a superset of the methods that it returns for @xmath52 : it returns ( applicable ) branches declared in @xmath55 ( and supertypes that are smaller than @xmath56 ) , _ in addition _ to the ones declared in @xmath52 , and supertypes .",
    "+ from this set , by definition , _ selects _ retains the minimal elements .",
    "given the well - formedness condition induced by t - prog , we know that for all possible input types there is single most specific method branch , let us call it @xmath57 .",
    "we also know that because method branches are encapsulated , this most specific method branch is in the set returned by _",
    "lookup_. + hence we know that @xmath58 , and because of induction hypothesis , @xmath43 .",
    "if @xmath59 , and @xmath60 where @xmath61 , then @xmath62e : c$ ] for some @xmath34 .    the lemma keeps its original form and proof method .",
    "the only case that changes is t - invk , and only because of its reliance on lemma 1 and the symmetric form of methods ; the original reasoning for proving the case applies entirely .",
    "the proof works by induction on the derivation of @xmath59 .    *",
    "_ case t - invk : _ when the last step in the derivation is t - invk , we have : + because of induction hypothesis , we have + from lemma 1 , we know that + with @xmath43 and @xmath44 . using t - invk on this , we may derive + and hence    . if @xmath36 , then @xmath63 .",
    "original proof holds by relying on the modified lemmas",
    ".    we can now give the proof for the subject reduction theorem .",
    "the proof proceeds by induction on the reduction derivation , with case analysis on the reduction rule used . the cases for r - field , r - cast , rc - field , rc - new - arg , and rc - cast remain unchanged .",
    "the case for rc - invk is a simple appeal to the induction hypothesis .",
    "this leaves only the case for r - invk .    *",
    "_ case r - invk _ : we assume that + [ cols= \" < , < \" , ]    + considering that we assume that methods are well - typed , we know from t - method that @xmath64 because of the weakening lemma , we may derive @xmath65 using the substitution lemma and @xmath66 , we obtain @xmath67e_0 : a_0 } } \\text {    with } a_0 < : e_0\\ ] ] transitivity of @xmath68 gives us the desired result .",
    "( progress ) .",
    "suppose @xmath69 is a well - typed expression .    1 .",
    "if @xmath69 includes @xmath70 as a subexpression , then fields(@xmath71)=@xmath72 and @xmath73 for some @xmath74 and @xmath75 .",
    "if @xmath69 includes @xmath76 as a subexpression , then select(lookup(@xmath77 ) ) = @xmath78 , and @xmath79 for some method @xmath78 .    only second case is altered .",
    "the definition of _ lookup _ guarantees that @xmath79 for every method it returns .",
    "the constraints on branch definition guarantee that _ select _ will return a single method .",
    "the proof of type soundness follows immediately from the subject reduction and progress theorems .",
    "generic methods in languages like clos  @xcite provide similar abstraction over application structure as we propose here , and their software engineering benefits are well understood in the community . however generic methods are globally visible and not encapsulated , and therefore introduce state visibility issues ( for a discussion see e.g.  @xcite ) .",
    "the combination of encapsulation and the flexibility of changing application structure has been the aim of some research in the aspect - oriented community . in particular , there has been work on combining different class hierarchies without changing the classes being merged  @xcite . however , the language extensions and tools proposed by such research goes significantly beyond what we propose here , both in terms of flexibility and complexity .",
    "the fortress programming language  @xcite , like sfmj , uses symmetric encapsulated multi - methods .",
    "however , where we incorporate them in a class - only context , they propose a dedicated model based on components , traits and objects . also , we provide a formal semantics and proof of soundness for our scheme .",
    "as noted before , symmetric methods may be employed with single dispatch . however , using multiple dispatch enriches the facility greatly .",
    "multiple dispatch in the context of class - based programming languages has been extensively studied , both in terms of theoretical treatments  @xcite , and as practical extensions to mainstream languages to a.o .",
    "c++  @xcite , smalltalk  @xcite , and even ml ( with added object - oriented features )  @xcite .",
    "two extensions to java are of particular note .",
    "boyland et al .",
    "propose _ parasitic methods _",
    "parasitic methods may dynamically overload other methods .",
    "definition of parasitic methods is constrained to preserve modularity and separate compilation .",
    "the extension supports both covariant and contravariant specialization of methods .",
    "some of the overloading strategies it supports , however , seem somewhat complex for programmers to confidently predict branch selection .",
    "multijava  @xcite is an extension of java to support symmetric multiple dispatch .",
    "its emphasis lies on modularity and backward - compatibility .",
    "multijava also offers _ open classes _ : classes to which methods can be added without changing the original class definition .",
    "multijava does not support symmetric methods or the definition of methods outside the class of the receiving argument .",
    "open classes can only be extended by adding methods to the class ; methods may not be moved to another class like our design allows",
    ".    there has been significant research focusing on the modularity issues associated with multi - methods .",
    "millstein and chambers  @xcite propose a number of different ( language independent ) constraints that yield different trade - offs between flexibility and modularity .",
    "based on these ideas , they propose relaxed multijava  @xcite . finally , techniques from predicate dispatch -a generalization of type - based dispatch- have been brought to bear on the problem by frost et al .",
    "in this article , we have argued that interfaces in mainstream object - oriented languages , by leaking _ where _ methods are implemented , unduly restrict some useful forms of program evolution .",
    "we have proposed a simple scheme that mitigates this problem to some degree .",
    "the scheme consists of making it possible to define methods in the classes of any of its parameters .",
    "this means that a method may be moved to another of its parameter classes ( but not any other classes ) without breaking client code . to maintain object - oriented extensibility",
    "this implies the use of dynamic dispatch on all parameters . in the presence of multiple dispatch ,",
    "a subclass of one of the parameter classes may define a method that overloads a method defined not in its superclass , but in another parameter class , and , for appropriate arguments , it would be this method that would be invoked .",
    "to illustrate the idea as clearly as possible , and to address any doubts as to whether the above scheme is sound , we have defined our proposal as an extension of featherweight java .",
    "it turns out that the extension can be kept very simple , and that we may limit the changes to fj to method definition , invocation , and lookup .",
    "also , soundness may be established in a similar fashion to fj and does not pose significant challenges .",
    "defining the scheme in terms of a core calculus has the disadvantage that only very basic object - oriented features are modelled . to come to a more interesting language , as further research",
    ", we would like to add more features .",
    "some features may be added orthogonally .",
    "for example , there seems no indication that addition of imperative features is complicated by our scheme .",
    "other features would be very easy to add , such as a null value .",
    "however , some features may pose a more significant challenge .",
    "for example adding support for abstract classes and interfaces may be difficult because of the presence of multiple dispatch .",
    "abstract classes would introduce the _ coverage _",
    "problem for overloaded methods . in our scheme ,",
    "we were always guaranteed to have an implementation of the most general branch of an overloaded method . with a naive integration with abstract classes",
    "this would not necessarily be always be the case .",
    "interfaces would additionally incur the problem of multiple inheritance : spurious branches may have to be defined to avoid ambiguity problems .",
    "however , solutions to these problems have been proposed in different contexts , and we would like to investigate how these could be applied to our setting . in similar vein , while our scheme is modular , it does not allow for separate compilation of classes , as we need global knowledge of method definitions to make sure we do not miss conflicting method branch definitions .",
    "we would like to investigate how the research on modular multiple dispatch may be applied to lift this requirement .",
    "clarke , s. , harrison , w. , ossher , h. , tarr , p. : subject - oriented design : towards improved alignment of requirements , design , and code . in : oopsla 99 : proceedings of the 14th acm sigplan conference on object - oriented programming , systems , languages , and applications , new york , ny , usa , acm ( 1999 ) 325339    allen , e. , hallett , j.j . , luchangco , v. , ryu , s. , guy l.  steele , j. : modular multiple dispatch with multiple inheritance . in : sac 07 : proceedings of the 2007 acm symposium on applied computing , new york , ny , usa , acm ( 2007 ) 11171121        pirkelbauer , p. , solodkyy , y. , stroustrup , b. : open multi - methods for c++ .",
    "in : gpce 07 : proceedings of the 6th international conference on generative programming and component engineering , new york , ny , usa , acm ( 2007 ) 123134      bourdoncle , f. , merz , s. : type checking higher - order polymorphic multi - methods . in : popl 97 : proceedings of the 24th acm sigplan - sigact symposium on principles of programming languages , new york , ny , usa , acm ( 1997 ) 302315    boyland , j. , castagna , g. : parasitic methods : an implementation of multi - methods for java . in : oopsla 97 : proceedings of the 12th acm sigplan conference on object - oriented programming , systems , languages , and applications , new york , ny , usa , acm ( 1997 ) 6676      millstein , t.d . ,",
    "chambers , c. : modular statically typed multimethods . in : ecoop 99 : proceedings of the 13th european conference on object - oriented programming , london , uk , springer - verlag ( 1999 ) 279303    millstein , t. , reay , m. , chambers , c. : relaxed multijava : balancing extensibility and modular typechecking . in : oopsla 03 : proceedings of the 18th annual acm sigplan conference on object - oriented programing , systems , languages , and applications , new york , ny , usa , acm ( 2003 ) 224240    frost , c. , millstein , t. : modularly typesafe interface dispatch in jpred . in : the 2006 international workshop on foundations and developments of object - oriented languages ( fool / wood 06 ) .",
    "( january 2006 )"
  ],
  "abstract_text": [
    "<S> in object systems , classes take the role of modules , and interfaces consist of methods . </S>",
    "<S> because methods are encapsulated in objects , interfaces in object systems do not allow abstracting over _ where _ methods are implemented . </S>",
    "<S> this implies that any change to the implementation structure may cause a rippling effect . </S>",
    "<S> sometimes this unduly restricts the scope of software evolution , in particular for methods with multiple parameters where there is no clear owner . </S>",
    "<S> we propose a simple scheme where symmetric methods may be defined in the classes of any of their parameters . </S>",
    "<S> this allows client code to be oblivious of what class contains a method implementation , and therefore immune against it changing . </S>",
    "<S> when combined with multiple dynamic dispatch , this scheme allows for modular extensibility where a method defined in one class is overridden by a method defined in a class that is not its subtype . in this paper </S>",
    "<S> , we illustrate the scheme by extending a core calculus of class - based languages with these symmetric encapsulated multi - methods , and prove the result sound . </S>"
  ]
}