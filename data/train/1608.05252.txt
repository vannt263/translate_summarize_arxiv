{
  "article_text": [
    "concurrent constraint programming ( ccp ) @xcite ( see a survey in @xcite ) combines concurrency primitives with the ability to deal with constraints , and hence , with partial information .",
    "the notion of concurrency is based upon the shared - variables communication model .",
    "ccp is intended for reasoning , modeling and programming concurrent agents ( or processes ) that interact with each other and their environment by posting and asking information in a medium , a so - called store .",
    "agents in ccp can be seen as both computing processes ( behavioral style ) and as logic formulae ( declarative style ) . hence ccp can exploit reasoning techniques from both process calculi and logic .",
    "ccp is a very flexible model and then , it has been applied to an increasing number of different fields such as probabilistic and stochastic @xcite , timed @xcite and mobile @xcite systems .",
    "more recently ,  languages have been proposed for the specification of spatial and epistemic behaviors as in social networks and cloud computing systems @xcite .",
    "one crucial problem when working with a concurrent language is being able to provide tools to debug programs .",
    "this is particularly useful for a language in which a program can generate a large number of parallel running agents . in order to tame this complexity",
    ", abstract interpretation techniques have been considered ( e.g. in @xcite ) as well as ( abstract ) declarative debuggers following the seminal work of shapiro @xcite .",
    "however , these techniques are approximated ( case of abstract interpretation ) or can be of difficult application when dealing with complex programs ( case of declarative debugging ) .",
    "it would be useful to have a semi automatic tool able to interact with the user and filter , in a given computation , the information which is relevant to a particular observation or result .",
    "in other words , the programmer could mark the outcome that she is interested to check in a particular computation that she suspects to be wrong .",
    "then , a corresponding depurated partial computation is obtained automatically , where only the information relevant to the marked parts is present .",
    "slicing was introduced in some pioneer works by mark weiser @xcite .",
    "it was originally defined as a static technique , not depending on a particular input .",
    "then , the technique was extended by introducing the so called dynamic program slicing @xcite .",
    "this technique is useful for simplifying the debugging process , by selecting a portion of the program containing the faulty code .",
    "dynamic program slicing has been applied to several programming paradigms , for instance to imperative programming @xcite , functional programming @xcite , term rewriting @xcite , and functional logic programming @xcite . for a survey of the techniques defined in the impressive literature on program slicing and a comparison between them you may see @xcite .",
    "dynamic program slicing for ccp allows us to propose a technique and a tool for helping the programmer to debug her program , in cases where she could not find the bugs by using other debuggers . in this paper",
    "we present the first formal framework for ccp dynamic slicing and show , by some working examples and a prototypical tool , the main features of this approach .    the dynamic slicing technique we propose follows three main steps . in the first step , we extend the standard operational semantics to a `` collecting semantics '' that adds the needed information for the slicer . in the second step ,",
    "we propose several analyses of the faulty situation based on error symptoms , including causality , variable dependencies , unexpected behaviors and store inconsistencies . in step 3 ,",
    "based on the first two ones , we define a marking algorithm of the redundant items and define a trace slice . our algorithm is flexible and it can deal with different variants of ccp . in particular , we show how to apply it to timed extensions of  @xcite . to the best of our knowledge",
    "this is the first framework for dynamic slicing of concurrent constraint programs .",
    ". _ section [ sectionccp ] describes ccp and its operational semantics . in section [ sectionslicing ]",
    "we introduce a slicing technique for ccp and extend it for timed ccp in section [ sectionapplications ] .",
    "we also present a working prototypical implementation of the slicer , together with some experiments .",
    "finally , section [ sectionconclusions ] discusses some hints for future work and concludes .",
    "processes in  _ interact _ with each other by _ telling _ and _ asking _ constraints ( pieces of information ) in a common store of partial information . the type of constraints is not fixed but parametric in a constraint system ( cs ) . intuitively , a cs provides a signature from which constraints can be built from basic tokens ( e.g. , predicate symbols ) , and two basic operations : conjunction ( @xmath0 ) and variable hiding ( @xmath1 ) .",
    "the cs defines also an _ entailment _ relation ( @xmath2 ) specifying inter - dependencies between constraints : @xmath3 means that the information @xmath4 can be deduced from the information @xmath5 .",
    "such systems can be formalized as a scott information system as in @xcite , as cylindric algebras @xcite , or they can be built upon a suitable fragment of logic , as in @xcite .",
    "here we follow @xcite , since the other definitions can be seen as an instance of this definition .",
    "[ def : cs ] a cylindric constraint system is a structure @xmath6 s.t .",
    "+ - @xmath7 is a lattice with @xmath0 the @xmath8 operation ( representing the logical _ and _ ) .",
    "elements in @xmath9 are called _ constraints _ with typical elements @xmath10 , and @xmath11 , @xmath12 the least and the greatest elements .",
    "if @xmath13 , we say that @xmath4 entails @xmath5 and we write @xmath14 .",
    "if @xmath13 and @xmath15 we write @xmath16 .",
    "+ -@xmath17 is a denumerable set of variables and for each @xmath18 the function @xmath19 is a cylindrification operator satisfying : ( 1 ) @xmath20 .",
    "( 2 ) if @xmath13 then @xmath21 . ( 3 ) @xmath22 . ( 4 ) @xmath23 . ( 5 ) for an increasing chain @xmath24 , @xmath25 . + - for each @xmath26 , the constraint @xmath27 is a _ diagonal element _ and it satisfies : ( 1 ) @xmath28 .",
    "( 2 ) if @xmath29 is different from @xmath30 then @xmath31 . ( 3 ) if @xmath32 is different from @xmath33 then @xmath34 .",
    "the cylindrification operators model a sort of existential quantification for hiding information . as usual",
    ", @xmath35 binds @xmath32 in @xmath5 .",
    "we use @xmath36 ( resp .",
    "@xmath37 ) to denote the set of free ( resp .",
    "bound ) variables in @xmath5 .",
    "the diagonal element @xmath38 can be thought of as the equality @xmath39 , useful to define substitutions of the form @xmath40 $ ] ( see the details , e.g. , in @xcite ) .    as an example , consider the finite domain constraint system ( fd ) @xcite .",
    "this system assumes variables to range over finite domains and , in addition to equality , one may have predicates that restrict the possible values of a variable as in @xmath41 .      in the spirit of process calculi",
    ", the language of processes in   is given by a small number of primitive operators or combinators as described below .",
    "[ def : syntax - lcc ] processes in   are built from constraints in the underlying cs and the syntax : @xmath42    the process @xmath43 represents inaction .",
    "the process @xmath44 adds @xmath5 to the current store @xmath4 producing the new store @xmath45 .",
    "given a non - empty finite set of indexes @xmath46 , the process @xmath47 non - deterministically chooses @xmath48 for execution if the store entails @xmath49 . the chosen alternative , if any , precludes the others .",
    "this provides a powerful synchronization mechanism based on constraint entailment .",
    "when @xmath46 is a singleton , we shall omit the `` @xmath50 '' and we simply write @xmath51 .",
    "the process @xmath52 represents the parallel ( interleaved ) execution of @xmath53 and @xmath54 .",
    "the process @xmath55 behaves as @xmath53 and binds the variable @xmath32 to be local to it .",
    "we use @xmath56 ( resp .",
    "@xmath57 ) to denote the set of free ( resp .",
    "bound ) variables in @xmath53 .    given a process definition @xmath58 , where all free variables of @xmath53 are in the set of pairwise distinct variables @xmath59 , the process @xmath60 evolves into @xmath61 $ ] .",
    "a  program takes the form @xmath62 where @xmath63 is a set of process definitions and @xmath53 is a process .",
    "the structural operational semantics ( sos ) of  is given by the transition relation @xmath64 satisfying the rules in figure [ fig : sos ] .",
    "here we follow the formulation in @xcite where the local variables created by the program appear explicitly in the transition system and parallel composition of agents is identified to a multiset of agents . more precisely , a _ configuration _",
    "@xmath65 is a triple of the form @xmath66 , where @xmath5 is a constraint representing the store , @xmath67 is a multiset of processes , and @xmath68 is a set of hidden ( local ) variables of @xmath5 and @xmath67 .",
    "the multiset @xmath69 represents the process @xmath70 .",
    "we shall indistinguishably use both notations to denote parallel composition .",
    "moreover , processes are quotiented by a structural congruence relation @xmath71 satisfying : ( str1 ) @xmath72 if they differ only by a renaming of bound variables ( alpha conversion ) ; ( str2 ) @xmath73 ; ( str3 ) @xmath74 ; ( str4 ) @xmath75 .",
    "the rules in figure [ fig : sos ] formalize the operational semantics of the language whose intuitive meaning had given above : a tell agent @xmath44 adds @xmath5 to the current store @xmath4 ( rule @xmath76 ) ; the process @xmath47 executes @xmath48 if its corresponding guard @xmath49 can be entailed from the store ( rule @xmath77 ) ; a local process @xmath78 adds @xmath32 to the set of hidden variable @xmath68 when no clashes of variables occur ( rule @xmath79 ) .",
    "observe that rule @xmath80 can be used to do alpha conversion if the premise of @xmath79 can not be satisfied ; the call @xmath81 executes the body of the process definition ( rule @xmath82 ) .",
    "[ def : obs ] let @xmath83 denote the reflexive and transitive closure of @xmath84 .",
    "if @xmath85 and @xmath86 we write @xmath87 .",
    "if @xmath88 and @xmath89 we simply write @xmath90 .",
    "intuitively , if @xmath53 is a process then @xmath91 says that @xmath53 can reach a store @xmath4 strong enough to entail @xmath5 , , @xmath5 is an output of @xmath53 .",
    "note that the variables in @xmath92 above are hidden from @xmath93 since the information about them is not observable .",
    "dynamic slicing is a technique that helps the user to debug her program by simplifying a partial execution trace , thus depurating it from parts which are irrelevant to find the bug .",
    "it can also help to highlight parts of the programs which have been wrongly ignored by the execution of a wrong piece of code .",
    "our analysis consists of three main steps :    1 .   _",
    "generating a ( finite ) trace _ of the program .",
    "for that , we propose a _ collecting semantics _ that generates the information needed for the slicer .",
    "2 .   _ marking the final store _ , to choose some of the constraints that , according to the symptoms detected , should or should not be in the final store . 3 .   _ computing the trace slice _ , to select the processes that were relevant to produce the ( marked ) final store .",
    "the rules of the sos allow us to build a trace of a program .",
    "however , for the slicer , we need to extract more information from the execution of the processes .",
    "in particular , ( 1 ) in each operational step @xmath95 , we need to highlight the process that was reduced ; and ( 2 ) the constraints accumulated in the store must reflect , exactly , the contribution of each process to the store .    in order to solve ( 1 ) and ( 2 ) , we propose a collecting semantics that captures the extra information needed for the slicer .",
    "the rules are in figure [ fig : colsem ] and explained below .",
    "we identify the parallel composition @xmath70 with the _ sequence _ of processes @xmath96 .",
    "we shall use @xmath97 to denote an empty sequence of processes .",
    "the context @xmath98 represents the fact that @xmath53 is preceded and followed , respectively , by the ( possibly empty ) sequences of processes @xmath67 and @xmath99 . in such context , a transition of @xmath53 is labelled with @xmath100 where : @xmath101 indicates the position of @xmath53 in the sequence and @xmath102 can be either @xmath103 ( undefined ) or a natural number indicating the branch chosen in a non - deterministic choice ( rule @xmath104 ) . for the sake of readability ,",
    "we shall write @xmath105 $ ] instead of @xmath105_\\bot$ ] .    _ stores and configurations .",
    "_ the solution for ( 2 ) amounts to consider the store , in a configuration , as a set of constraints and not as a constraint .",
    "then , the store @xmath106 represents the constraint @xmath107 .    consider the process @xmath44 and let @xmath108 .",
    "the rule @xmath109 first decomposes the constraint @xmath5 in its atoms . for that , assume that the bound variables in @xmath5 are all distinct and not in @xmath110 ( otherwise , by alpha conversion , we can find @xmath111 satisfying such condition ) .",
    "we define @xmath112 where @xmath113 observe that in rule @xmath109 , the parameter @xmath110 of @xmath114 is the set of free variables occurring in the context , i.e. , @xmath115 in figure [ fig : colsem ] .",
    "this is needed to perform alpha conversion of @xmath5 ( which is left implicit in the definition of @xmath116 ) to satisfy the above condition on bound names .",
    "rule @xmath104 signals the number of the branch @xmath102 chosen for execution .",
    "rule @xmath117 chooses a fresh variable @xmath118 , i.e. , a variable not in the set of free variables of the configuration ( @xmath115 ) .",
    "hence , we execute the process @xmath119 $ ] and add @xmath118 to the set @xmath68 of local variables .",
    "rule @xmath120 is self - explanatory .",
    "it is worth noticing that we do not consider a rule for structural congruence in the collecting semantics .",
    "such rule , in the system of figure [ fig : sos ] , played different roles .",
    "axioms str2 and str3 provide agents with a structure of multiset ( commutative and associative ) .",
    "as mentioned above , we consider in the collecting semantics sequences of processes to highlight the process that was reduced in a transition .",
    "the sequence @xmath67 in figure [ fig : colsem ] can be of arbitrary length and then , any of the enabled processes in the sequence can be picked for execution .",
    "axiom str1 allowed us to perform alpha - conversion on processes .",
    "this is needed in @xmath79 to avoid clash of variables .",
    "note that the new rule @xmath117 internalizes such procedure by picking a fresh variable @xmath118 . finally , axiom str4 can be used to simplify @xmath43 processes that can be introduced , e.g. , by a @xmath76 transition .",
    "observe that the collecting semantics does not add any @xmath43 into the configuration ( see rule @xmath109 ) .",
    "[ ex : cs ] consider the following toy example .",
    "let @xmath121 contain the process definition @xmath122 and @xmath123 be a program where    @xmath124    the following is a possible trace generated by the collecting semantics .",
    "+ @xmath125    now we introduce the notion of observables for the collecting semantics and we show that it coincides with that of definition [ def : obs ] for the operational semantics .    [ def : obs ] we write @xmath126 whenever @xmath127 . moreover , if @xmath128 , then we write @xmath129 .",
    "if @xmath130 , we simply write @xmath131 .    for any process @xmath53 and constraint @xmath5 , @xmath91 iff @xmath132    ( _ sketch _ ) ( @xmath133 )",
    "the proof proceeds by induction on the length of the derivation needed to perform the output @xmath5 in @xmath91 and using the following results .    given a set of variables",
    "@xmath110 , a constraint @xmath4 and a set of constraints @xmath134 , let us use @xmath135 to denote the tuple @xmath136 and @xmath137 to denote the constraint @xmath138 .",
    "assume that @xmath139 . from the definition of _ atoms _ , it is easy to show that @xmath140 .",
    "let @xmath67 ( resp .",
    "@xmath141 ) be a multiset ( resp .",
    "sequence ) of processes .",
    "let us use @xmath142 to denote any sequence built from the processes in @xmath67 and @xmath143 to denote the multiset built from the elements in @xmath141 .",
    "consider now the transition @xmath144 .",
    "let @xmath139 where @xmath145 . by choosing the same process reduced in @xmath65",
    ", we can show that there exist @xmath146 s.t .",
    "the collecting semantics mimics the same transition as @xmath147 where @xmath148 and @xmath149 .",
    "the ( @xmath150 ) side follows from similar arguments .      from the final store",
    "the user must indicate the symptoms that are relevant to the slice that she wants to recompute .",
    "for that , she must select a set of constraints that considers relevant to identify a bug .",
    "normally , these are constraints at the end of a partial computation , and there are several strategies that one can follow to identify them .",
    "let us suppose that the final configuration in a partial computation is @xmath152 .",
    "the symptoms that something is wrong in the program ( in the sense that the user identifies some unexpected configuration ) may be ( and not limited to ) the following :    1 .   _",
    "causality : _ the user identifies , according to her knowledge , a subset @xmath153 that needs to be explained ( i.e. , we need to identify the processes that produced @xmath154 ) .",
    "variable dependencies : _ the user may identify a set of variables @xmath155 whose constraints need to be explored . then",
    ", one would be interested in marking the following set of constraints @xmath156 3 .",
    "_ unexpected behaviors _ : there is a constraint @xmath5 entailed from the final store that is not expected from the intended behavior of the program .",
    "then , one would be interested in marking the following set of constraints : @xmath157 where `` @xmath154 is set minimal '' means that for any @xmath158 , @xmath159 .",
    "inconsistent output _ : the final store should be consistent with respect to a given specification ( constraint ) @xmath5 , i.e. , @xmath134 in conjunction with @xmath5 must not be inconsistent . in this case , the set of constraints to be marked is : @xmath160 where `` @xmath154 is set minimal '' means that for any @xmath158 , @xmath161 .",
    "we note that `` set minimality '' could be expensive to compute .",
    "however , we believe that in most of practical cases this should not be so heavy . in any case , we can always use supersets of the minimal ones which are easier to compute but less precise for eliminating useless information .",
    "starting from the set @xmath163 above we can define a backward slicing step .",
    "we shall identify , by means of a backward evaluation , the set of transitions ( in the original computation ) which are necessary for introducing the elements in @xmath163 . by doing that",
    ", we will eliminate information not related to @xmath163 .",
    "we shall use the fresh constant symbol @xmath164 to denote an `` irrelevant '' constraint or process .",
    "then , for instance , `` @xmath165 '' results from a constraint @xmath45 where @xmath4 is irrelevant .",
    "similarly , @xmath166 results from a process of the form @xmath167 where @xmath54 and the summands in @xmath168 are irrelevant .",
    "we also assume that a sequence @xmath169 with any number ( @xmath170 ) of occurrences of @xmath164 is equivalent to a single occurrence .",
    "we shall use @xmath171 to denote a set of replacements , i.e. , a set of pairs of the shape @xmath172 $ ] representing that the syntactic object @xmath173 ( that can be a constraint or a process ) is replaced by @xmath164 .",
    "we will call these sets of replacements as `` replacing substitutions '' .",
    "we assume that the replaced syntactic object @xmath173 does not appear nested inside a bigger term .",
    "so , if @xmath174 $ ] , @xmath175 and @xmath176 .",
    "the composition of replacing substitutions @xmath177 and @xmath178 is given by the set union of the replacing pairs in @xmath177 and @xmath178 , and is denoted as @xmath179 .",
    "algorithm [ alg : slicer ] computes the slicing .",
    "the last configuration in the sliced trace is @xmath180 .",
    "this means that we only observe the local variables of interest , i.e. , those in @xmath181 .",
    "moreover , note that the processes in the last configuration were not executed and then , they are irrelevant ( and abstracted with @xmath164 ) . finally , the only relevant constraints are those in @xmath134 .",
    "the algorithm backwardly computes the slicing by accumulating replacing pairs in @xmath171 .",
    "the new replacing substitutions are computed by the function @xmath182 in algorithm [ alg : proc ] .",
    "suppose that @xmath183 .",
    "we consider each kind of process .",
    "consider the @xmath109 transition    @xmath184 .",
    "we note that @xmath185 and @xmath186 .",
    "we replace the constraint @xmath5 with its sliced version @xmath187 computed by the function @xmath188 . in that function , we compute the contribution of @xmath44 to the store , i.e. , @xmath189 . then , any atom @xmath190 not in the relevant set of constraints @xmath134 is replaced by @xmath164 . by joining together the resulting atoms , and existentially quantifying the variables in @xmath191 ( if any )",
    ", we obtain the sliced constraint @xmath187 . in order to further simplify the trace , if @xmath187 is @xmath164 or @xmath192 then we substitute @xmath44 with @xmath164 ( thus avoiding the `` irrelevant '' process @xmath193 ) .    in a non - deterministic choice ,",
    "all the precluded choices are discarded ( `` @xmath194 '' ) . moreover ,",
    "if the chosen alternative @xmath48 does not contribute to the final store ( i.e. , @xmath195 ) , then the whole process @xmath196 becomes @xmath164 .",
    "the cases for local processes and procedure calls can be explained similarly .",
    "[ ex : trace ] let @xmath197 be constraints without any entailment and consider the following process : @xmath198 in any execution of this process , the final store is @xmath199 .",
    "if the user selects only @xmath200 as slicing criterium , our implementation ( see section [ sec : imp ] ) returns the following output ( that can be further simplified by collapsing the trailing list of `` * '' ) :    .... [ 0 ; * || ask(e , tell(f ) || * ) || * || * || * ; * ] [ 2 ] -- >   [ 0 ; * || tell(f ) || * || * || * || * ; * ] [ 2 ] -- >   [ 0 ; * || * || * || * || * || * ; f,*][3 ] -- >   [ 0 ; * || * || * || * || * || * ; f,*][1 ] -- > stop ....",
    "note that only the relevant part of the process @xmath201 is highlighted as well as the process @xmath202 that introduced @xmath200 in the final store .    in the previous example , note that the process @xmath203 is not selected in the trace since @xmath204 is not part of the marked store . however , one may be interested in marking this process to discover the _ causality _ relation between this process and the process @xmath205 .",
    "namely , @xmath53 adds @xmath204 to the store , needed in @xmath54 to produce @xmath200 .",
    "it turns out that we can easily adapt algorithm [ alg : proc ] to capture such causality relations as follows .",
    "assume that @xmath182 returns both , a replacement @xmath171 and a constraint @xmath5 , i.e. , a tuple of the shape @xmath206 . in the case of @xmath196 , if @xmath207 , we return the pair @xmath208 ,   c_j\\rangle$ ] . in all the other cases , we return @xmath209 where @xmath171 is as in algorithm [ alg : proc ] . intuitively , the second component of the tuple represents the guard that was entailed in a `` relevant '' application of the rule @xmath104 .",
    "therefore , in algorithm [ alg : slicer ] , besides accumulating @xmath171 , we add the returned guard to the set of relevant constraints @xmath134 .",
    "this is done by replacing the line 5 in algorithm [ alg : slicer ] with the following code : + @xmath210 * in *    @xmath211    @xmath212   + where @xmath213 , otherwise , @xmath214 and `` @xmath154 is set minimal '' means that for any @xmath158 , @xmath159 .",
    "hence , we add to @xmath134 the minimal set of constraints in @xmath215 that `` explains '' the guard @xmath5 .    using this modified version of the algorithm , the first configuration ( i.e. , the first line of the output ) would be :    .... [ 0 ; ask(c , tell(e ) ) || ask(e , tell(f ) || * )",
    "|| * || tell(c ) || * ; * ] [ 3 ]   ....    where the process @xmath44 is also selected since the execution of @xmath216 depends on this process .",
    "reactive systems @xcite are those that react continuously with their environment at a rate controlled by the environment . for example , a controller or a signal - processing system , receives a stimulus ( input ) from the environment , computes an output and then waits for the next interaction with the environment .",
    "timed   ( ) @xcite is an extension of  tailoring ideas from synchronous languages @xcite . more precisely , time in  is conceptually divided into _ time intervals _ ( or _ time - units _ ) . in a particular time interval",
    ", a  process @xmath53 gets an input @xmath5 from the environment , it executes with this input as the initial _ store _ , and when it reaches its resting point , it _",
    "outputs _ the resulting store @xmath4 to the environment .",
    "the resting point determines also a residual process @xmath54 that is then executed in the next time - unit .",
    "the resulting store @xmath4 is not automatically transferred to the next time - unit . this way ,",
    "outputs of two different time - units are not supposed to be related .",
    "[ tcc : syntax ] the syntax of  is obtained by adding to definition [ def : syntax - lcc ] the processes @xmath217 .",
    "the process @xmath218 delays the execution of @xmath53 to the next time interval .",
    "we shall use @xmath219 to denote @xmath53 preceded with @xmath220 copies of `` @xmath221 '' and @xmath222 .",
    "the _ time - out _ @xmath223 is also a unit - delay , but @xmath224 is executed in the next time - unit only if @xmath225 is not entailed by the final store at the current time interval .",
    "the replication @xmath226 means @xmath227 , i.e. , unboundedly many copies of @xmath224 but one at a time .",
    "we note that in , recursive calls must be guarded by a * next * operator to avoid infinite computations during a time - unit .",
    "then , recursive definitions can be encoded via the @xmath228 operator @xcite .",
    "the operational semantics of  considers _ internal _ and _ observable _ transitions .",
    "the internal transitions correspond to the operational steps that take place during a time - unit .",
    "the rules are the same as in figure [ fig : colsem ] plus : +   + the @xmath229 is precluded from execution if its guard can be entailed from the current store .",
    "the process @xmath226 creates a copy of @xmath53 in the current time - unit and it is executed in the next time - unit . the seemingly missing rule for the @xmath230 operator",
    "is clarified below .",
    "the _ observable transition _",
    "@xmath231 should be read as `` @xmath224 on input @xmath225 , reduces in one _ time - unit _ to @xmath232 and outputs @xmath233 '' .",
    "the observable transitions are obtained from finite sequences of internal ones , i.e. , @xmath234{\\gamma \\rede{(c,\\exists x. c ' ) }   \\localp{x } f(\\gamma ' )   } { ( \\emptyset ; \\gamma ; c ) \\redi^ * ( x ; \\gamma ' ; c')\\not\\redi}\\ ] ]    the process @xmath235 ( the continuation of @xmath99 ) is obtained as follow :    @xmath236 the function @xmath237 ( the future of @xmath238 ) returns the processes that must be executed in the next time - unit .",
    "more precisely , it unfolds _ next _ and @xmath239 expressions .",
    "notice that an _ ask _ process reduces to @xmath43 if its guard was not entailed by the final store .",
    "notice also that @xmath240 is not defined for @xmath44 , @xmath241 , @xmath78 or @xmath81 processes since all of them give rise to an internal transition .",
    "hence these processes can only appear in the continuation if they occur within a @xmath230 or @xmath229 expression .      from the execution point of view , only the observable transition is relevant since it describes the input - output behavior of processes .",
    "however , when a  program is debugged , we have to consider also the internal transitions .",
    "this makes the task of debugging even harder when compared to .",
    "we implemented in maude ( http://maude.cs.illinois.edu ) a prototypical version of a slicer for  ( and then for ) that can be found at http://subsell.logic.at / slicer/.    the slicing technique for the internal transition is based on the algorithm [ alg : slicer ] by adding the following cases to algorithm [ alg : proc ] :    note that if an * unless * process evolves during a time - unit , then it is irrelevant . in the case of @xmath226 , we check whether @xmath53 is relevant in the current time - unit ( @xmath242 ) or in the following one ( @xmath243 ) .",
    "if this is not the case , then @xmath226 is irrelevant . recall that * next * processes do not exhibit any transition during a time - unit and then , we do not consider this case in the extended version of algorithm [ alg : proc ] .    for the observable transition we proceed as follows . consider a trace of @xmath244 observable steps @xmath245 and a set @xmath246 of relevant constraints to be observed in the last configuration @xmath247 .",
    "let @xmath248 be the replacement computed during the slicing process of the ( internal ) trace generated from @xmath247 .",
    "we propagate the replacements in @xmath248 to the configuration @xmath249 as follows :    1 .",
    "in @xmath249 we set @xmath250 .",
    "note that the unique store of interest for the user is the one in @xmath247 .",
    "recall also that the final store in  is not transferred to the next time - unit .",
    "then , only the processes ( and not the constraints ) in @xmath249 are responsible for the final store in @xmath247 .",
    "2 .   let @xmath251 be the last internal configuration in @xmath249 , i.e. , @xmath252 and @xmath253 .",
    "we propagate the replacements in @xmath248 to @xmath251 before running the slicer on the trace starting from @xmath249 . for that",
    ", we compute a replacement @xmath254 that must be applied to @xmath251 as follows : * if there is a process @xmath255 in @xmath251 , then @xmath254 includes the substitution @xmath256 $ ] .",
    "for instance , if @xmath257 and @xmath44 was irrelevant in @xmath247 ( i.e. , @xmath258 $ ] is in @xmath248 ) , we apply the substitution @xmath259 $ ] in @xmath251 .",
    "the case for @xmath260 is similar . *",
    "if there is a process @xmath261 in @xmath251 ( which is irrelevant since it was not executed ) , we add to @xmath254 the replacement @xmath262 $ ] .",
    "3 .   starting from @xmath263 , we compute the slicing on @xmath249 ( algorithm [ alg : slicer ] ) 4 .",
    "this procedure continues until the first configuration @xmath264 .    in the following example",
    "we show some experiments that can be found at tool s web page .",
    "consider the following process definitions : @xmath265 this is a simple model of a multimedia system that , every 2 ( resp .",
    "4 ) time - units , produce the constraint @xmath266 ( resp .",
    "@xmath267 ) . then ,",
    "every 4 time - units , the system produces both @xmath266 and @xmath267 . if we compute 5 time - units and choose @xmath268 we obtain :    .... { 1 / 5 > [ system ; * ] -- >   [ beat4 ; * ] -- > [ next^4(beat4 ) ; * ] } = = >   { 2 / 5 > [ next^3(beat4 ) ; * ] } = = >   { 3 / 5 > [ next^2(beat4 ) ; * ] } = = >   { 4 / 5 > [ next(beat4 ) ; * ] } = = >   { 5 / 5 > [ beat4 ; * ] -- > [ tell(b4 ) || * ; * ] -- > [ * ; * , b4 ] } ....    note that all the executions of @xmath269 in time - units 1 , 3 and 5 are hidden since they do not contribute to the observed output @xmath267 . more interestingly , the execution of @xmath270 in time - unit 1 , as well as the recursive call of @xmath271 ( @xmath272 ) in time - unit 5 , are also hidden .",
    "now assume that we compute an even number of time - units .",
    "then , no constraint is produced in that time - unit and the whole execution of @xmath273 is hidden :    .... { 1/4 > [ * ; * ] } = = > { 2/4 > [ * ; * ] } = = >   { 3/4 > [ * ; * ] } = = > { 4/4 > [ * ; * ] } ....    as a more compelling example , consider the following process definitions : @xmath274 where @xmath275 , @xmath276 and @xmath277 stands for parallel composition .",
    "this process represents a rhythmic pattern where groups of `` @xmath278''-unit elements separate groups of `` @xmath279''-unit elements , e.g. , @xmath280 .",
    "such pattern appears in repertoires of central african republic music @xcite and were programmed in  in @xcite .",
    "this pattern can be represented in a circle with @xmath281 divisions , where `` @xmath278 '' and `` @xmath279''-unit elements are placed .",
    "the `` @xmath279''-unit intervals are displayed in red in figure [ fig : circ ] .",
    "the important property is _ asymmetry _ , i.e. , if one attempts to break the circle into two parts , it is not possible to have two equals parts . to be more precise ,",
    "the @xmath282 and @xmath283 constraints divide the circle in two halves ( see process start ) and it is always the case that the constraint @xmath284 does not coincide in a time - unit with the constraint @xmath283 .",
    "for instance , in figure [ fig : circles ] ( a ) ( resp .",
    "( b ) ) , the circle is divided in time - units 1 start to 13 stop ( resp .",
    "4 start to 16 stop ) .",
    "the signal @xmath284 does not coincide with a @xmath283 : in figure [ fig : circles ] ( a ) ( resp .",
    "( b ) ) , the @xmath284 is added in time - unit 12 ( resp .",
    "if we generate the slice for the time - unit 13 with @xmath285 , we only observe as relevant process @xmath286 ( since no @xmath284 is produced in that time - unit ) :    .... { 1 / 13 > [ system ; * ] -- > [ check ; * ] -- > [ !",
    "ask(start , next^12(tell(stop ) ) ; * ]             -- > [ ask(start , next^12(tell(stop ) ) ; * ] -- > [ next^12(tell(stop ) ; * ] } = = >   .... = = > ... { 11 / 13 > [ next(next(tell(stop ) ) ) ; * ] } = = >   { 12 / 13 > [ next(tell(stop ) ) || * ; * ] } = = >   { 13 / 13 > [ tell(stop ) ; * ] -- > [ * ; stop][0 ] } ....    more interesting , assume that we wrongly write a process @xmath286 that is not `` well synchronized '' with the process @xmath287 .",
    "for instance , if @xmath288 , then the @xmath282 signal does not coincide with a @xmath284 .",
    "then , in time - unit 15 , we ( wrongly ) observe both @xmath284 and @xmath283 .",
    "the trace of that program ( that can be found in tool s web page ) is quite long and difficult to understand . on the contrary ,",
    "the sliced one is rather simple :    .... { 1 / 15 > [ system ; * ] -- > [ beat || check ; * ] -- >             [ next^14(tell(beat ) || next ( !",
    "ask(start , next^12(tell(stop ) ) ; * ] } = = >   { 2 / 15 > [ next^13(tell(beat))|| !",
    "ask(start , next^12(tell(stop ) ) ) ; * ] } = = >   { 3 / 15 > [ next^12(tell(beat)))|| ! ask(start , next^12(tell(stop ) ) ; * ] } = = >   { 4 / 15 > [ next^11(tell(beat))|| next^11(tell(stop)|| * ; * ] -- > stop } = = >   ... { 14 / 15 > [ next(tell(beat ) ) || next(tell(stop ) ) || * ; * ] -- > stop } = = >   { 15 / 15 > [ tell(beat ) || tell(stop ) || * ; * ] -- > [ tell(stop ) || * ; beat ] -- >              [ * ; beat , stop ] } ....",
    "something interesting in this trace is that the * ask * in @xmath286 is hidden from the time - unit 4 on ( since it is not `` needed '' any more ) .",
    "moreover , the only @xmath289 process ( from @xmath287 definition ) displayed is the one that is executed in time - unit 15 ( i.e. , @xmath290 ) . from this trace ,",
    "it is not difficult to note that the @xmath291 process begins its execution on time - unit 3 ( the process @xmath292 first appears on time - unit @xmath293 ) .",
    "this can tell the user that the process @xmath291 begins its execution in a wrong time - unit . in order to confirm this",
    ", the user may compute the sliced trace up to time - unit 3 with @xmath294 and notice that , in that time - unit , @xmath282 is produced but @xmath284 is not part of the store .    [ cols=\"^,^ \" , ]",
    "in this paper we introduced the first framework for slicing concurrent constraint based languages , and showed its applicability for ccp and timed ccp .",
    "our framework is a good basis for dealing with other variants of such as linear  @xcite , spatial and epistemic @xcite as well as with other temporal extensions of it @xcite , which we are currently investigating .",
    "we implemented an initial prototype of the slicer in maude and showed its use in debugging a program specifying a multimedia interacting system .",
    "as future work we are considering another kind of symptom that we can identify in a bugged program .",
    "this happens when a constraint @xmath5 should be part of the final store @xmath134 but @xmath134 does not entail it . note that this case does not fit into the schemes proposed in section [ sec : step2 ] . to cover this analysis ,",
    "we are currently working on a new feature of our tool that marks the processes that may produce @xmath5 or a constraint entailing @xmath5 and were not executed .",
    "+   + _ * acknowledgements*_. we thank the anonymous reviewers for their detailed comments and suggestions which helped us to improve our paper .",
    "the work of olarte was funded by cnpq ( brazil ) .",
    "sophia knight , c.  palamidessi , p.  panangaden , and f.  d. valencia .",
    "spatial and epistemic modalities in constraint - based process calculi . in m.",
    "koutny and i.  ulidowski , editors , _ concur _ , volume 7454 of _ lncs _ , pages 317332 .",
    "springer , 2012 .            c.  olarte , c.  rueda , g.  sarria , m.  toro , and f.  d. valencia .",
    "concurrent constraints models of music interaction . in g.",
    "assayag and c.  truchet , editors , _ constraint programming in music _ , pages 133153 .",
    "wiley , 2011 ."
  ],
  "abstract_text": [
    "<S> concurrent constraint programming ( ) is a declarative model for concurrency where agents interact by telling and asking constraints ( pieces of information ) in a shared store . </S>",
    "<S> some previous works have developed ( approximated ) declarative debuggers for ccp languages . </S>",
    "<S> however , the task of debugging concurrent programs remains difficult . in this paper </S>",
    "<S> we define a dynamic slicer for  and we show it to be a useful companion tool for the existing debugging techniques . </S>",
    "<S> our technique starts by considering a partial computation ( a trace ) that shows the presence of bugs . </S>",
    "<S> often , the quantity of information in such a trace is overwhelming , and the user gets easily lost , since she can not focus on the sources of the bugs . </S>",
    "<S> our slicer allows for marking part of the state of the computation and assists the user to eliminate most of the redundant information in order to highlight the errors . </S>",
    "<S> we show that this technique can be tailored to timed variants of ccp . </S>",
    "<S> we also develop a prototypical implementation freely available for making experiments .    </S>",
    "<S> # 1    concurrent constraint programming , program slicing , debugging . </S>"
  ]
}