{
  "article_text": [
    "in many signal processing applications an array of sensors , or antennas , need to be combined together such that the entire system can be used as a single entity .",
    "this is the process of beamforming , where the signals from each element arriving at different times are aligned in time / phase so that they can add coherently .    in an array with @xmath1 elements a radiation wavefront originating from a particular direction",
    "will reach element @xmath2 at time @xmath3 . squaring and adding the signals of all the elements together",
    "is the process of incoherent beamforming .",
    "the maximum amplitude is achieved when the signals originate from a source perpendicular to the array , where they are highly correlated and add constructively . alternatively ,",
    "if the signals originate from a non - perpendicular direction they will arrive at different times , will be less correlated and result in a lower output amplitude .",
    "coherent beamforming relies on the fact that for a given array configuration the relative delays between arrival times @xmath4 are a function of the direction of propagation of the incident wave .",
    "artificial delays or phase shifts , in the time and frequency domain respectively , can be applied to the received signals from each antenna , causing them to add constructively when element signals are summed .    after summing to form a beam towards the incident radiation with wavevector @xmath5 the response @xmath6 of the beam to radiation with other wavevector directions @xmath7",
    "is given by summing the signal contributions from individual antennas .",
    "if each individual antenna in an array has a response to radiation given by @xmath8 , this is given by @xmath9 where @xmath10 is the position vector of antenna @xmath2 .",
    "this is equivalent to the fourier transform of the contributions from receiving elements weighted by their individual antenna responses . in cases where the antennas have very similar response functions equation [ beamresponseequation ]",
    "reduces to the fourier transform of the antenna distribution modified by the response pattern of each antenna .",
    "this technique was implemented for the best-2 array by @xcite . in this case , the field - of - view ( fov ) of the synthesised beam is approximately given by , where @xmath11 is the maximum separation of the antennas used to form the beam .    since prior to beamforming each individual antenna in an array sees a portion of the sky determined by its response function @xmath8 , it is possible to form useful beams in any direction where @xmath12 is significantly non - zero .",
    "it is also possible to generate multiple beams by making copies of the input antenna signals and adding them with different phase weightings , thereby increasing the coverage of an array s full fov .",
    "choosing the number of beams to form amounts to balancing the fov observed by an array ( which increases linearly with each beam added ) with the amount of signal processing .",
    "each beam can be treated as if it is a signal from a single antenna with response equal to the beam response , and so can be fed directly to backend detectors and used for time - domain observations , such as cosmic transient event observations , space debris detectors and transient surveys .",
    "the latter generally require a wide fov and high sensitivity , however achieving this for larger telescopes can be prohibitively expensive in signal processing cost , especially for discrete fourier transform ( dft ) beamforming , since the number of required beams goes as @xmath13 , where @xmath14 is the physical extent of the array and @xmath15 is the size of an individual element .",
    "alternative strategies include sacrificing sensitivity to achieve maximal fov using incoherent beamforming , or partitioning the array into multiple phased arrays and processing them independently .",
    "@xcite describe these strategies with respect to transient searching for ska@xmath16 .",
    "signal processing cost can also be alleviated by using the regular layout of a telescope to remove redundancy in the beamforming process , for example as described by @xcite .",
    "this has been implemented in the digital backend deployed at the best-2 array @xcite , however will not be further investigated in this paper .    in this paper",
    "we investigate the applicability of graphics processing units ( gpus ) for accelerating beamforming .",
    "we present an optimised implementation of a coherent beamformer in section [ beamformingsection ] , which is appropriately analysed and benchmarked .",
    "we also present a direct comparison with an optimsed central processing unit ( cpu)-version of the same algorithm . in section [ best2section ]",
    "we present a beamforming system deployed at the best-2 array in medicina , italy , whilst in section [ transientsection ] we discuss the integration of this system with the the real - time transient detection system developed by @xcite .",
    "the basic element for ska training ii ( best-2 ) @xcite is a subset of the northern cross cylindrical array at the medicina observatory near bologna , italy .",
    "the array is composed of eight east - west oriented cylinderical concentrators , each with 64 dipole receivers spaced such that the cylindrical focal line is critically sampled at 408 mhz .",
    "signals from 64 dipoles are combined in groups of 16 using analogue circuitry , resulting in four analogue channels per cylinder .",
    "this results in a total of 32 effective receiving elements positioned regularly on a 4 x 8 grid .",
    "the digital backend , developed and deployed by @xcite , is based on three roach processing boards and a number of software - based processing nodes .",
    "the three roach boards are referred to as the :    * ` f'-engine * for frequency transform , which is responsible for digitisation , channelisation of the processed 20 mhz bandwidth into 1024 frequency subbands , and transmission of coarsely quantised antenna signals to downstream processing nodes using a custom 64adcx64 - 12 board .",
    "a 4-tap hann - windowed polyphase filter bank is used for channelisation .    * ` s'-engine * for spatial transform , which is responsible for formation of electric - field and total power beams on the sky by spatial fourier transform and spead packetisation for 10 gbe streaming to the time domain processing server .",
    "the current implementation allows for the arbitrary selection of 8 beams from the generated 128-beam grid for output as 16-bit complex - valued words .    * ` x'-engine * for cross - multiplication , which performs cross multiplication and accumulation of antenna signals as well as spead packetisation of the generated visibility matrices and streaming to the visibility storage server for offline imaging .",
    "this is also used to calibrate the s - engine , such that f - engine streams are equalised and gain calibrated .",
    "downstream processing of time - domain beam data is accomplished by using a linux - based server which hosts 2 nvidia gpus running the transient detection pipeline developed by @xcite .",
    "the gpu beamforming kernel described in this paper aims to replace the s - engine by forming the beams within the transient detection pipeline , as described in sections [ best2section ] and [ transientsection ] .",
    "real - time beamforming systems pose several challenges . first of all the digitised antenna voltage streams need to be transported to backend processors , which have to cope with the generally high data rates .",
    "network links and devices can achieve very high transfer rates , however in order to offload processing to a gpu all this data needs to be transferred through peripheral component interconnect express ( pcie ) links , which have limited peak bandwidth .",
    "this can create an upper bound on the number of beams which can be generated and transferred to cpu memory . also , depending on the beam representation scheme , the amount of gpu memory might limit the level of parallelism achievable .",
    "these factors need to be taken into consideration when a beamforming kernel is deployed within a real - time pipeline , and will be discussed in further detail shortly .",
    "ignoring the phase - shift calculation method employed to point each beam , the computational complexity for a generic coherent multi - beam beamformer is @xmath17 where @xmath18 is the bandwidth , @xmath19 is the number of synthesised beams and @xmath20 is the number of antennas .",
    "the required computation rate per input data sample is @xmath21 , suggesting that many beams need to be formed to maximise gpu utilisation and efficiency .",
    "additionally , there is a fixed upper limit on the data rate into and out of the gpu , such that pcie transfers are rate - limiting .",
    "however , if @xmath22 the data rate off the gpu is greater than the rate onto it .",
    "thus , the applicability of a gpu beamformer can be determined by @xmath20 , @xmath19 and the type of processing which occurs after beamforming .",
    "for example , transient detection and pulsar observations require several compute - intensive processing steps , so for such observations a gpu beamformer would be useful for large @xmath20 arrays with only a few beams , while space debris observations require limited post - processing after beamforming , with data being reduced within the gpu itself , such that gpus can be used for a wider variety of arrays .",
    "the beamforming process is essentially a matrix - vector multiplication , which involves multiplying a vector of @xmath20 antennas by an @xmath23 matrix of coefficients to form @xmath19 beams , per frequency channel . to this end",
    ", standard cuda libraries can be used to perform these operations . however , the implemented beamformer has to include additional functionality inside the kernel which would either have to be performed before and/or after the matrix multiply , or by customising existing implementations .",
    "these include data unpacking ( and re - packing if required ) , absolute power computation , value conversion and so on .",
    "these extra steps will be discussed shortly . using a separate kernel for",
    "these operations would cancel any speed - up gained by using readily available libraries due to extra transfer from and to gpu memory .",
    "the work required to customise existing libraries was deemed to be comparable to a custom implementation , and the latter approach was chosen .",
    "coherent beamforming is trivially paralellisable across the frequency , time and beam dimensions .",
    "a simple implementation would have a single gpu thread combine all the antennas , applying appropriate weights , for a single @xmath24 triplet .",
    "this would require @xmath25 global memory requests for every thread , since @xmath20 antenna values and @xmath20 complex weights are needed , with an instruction count of @xmath26 , resulting in a flop to data request ratio of 4 .",
    "due to the large global memory latencies , such a ratio would make this implementation bandwidth limited within the gpu , and thus data reuse schemes need to be employed to increase performance . by making the assumption that beam coefficients do not need to change within small time frames ,",
    "it is possible to reuse the same weights for all the time bins residing in a gpu buffer .",
    "this is especially true for wide beams , since it takes astronomical objects a relatively long time to pass through the beam , however does not hold when very narrow beams are required , or when tracking non - astrophysical objects such as satellites .",
    "this drastically reduces the number of coefficients which need to be generated and read from global memory within a thread block .",
    "we use this assumption to partition beam generation , where a 3d grid is mapped to the output space , with time bins varying in the x - dimension , frequency channels along the y - dimension and beam subset along the z - dimension .",
    "thus each thread block generates a subset of the beams for a number of time bins , for a single frequency channel . within each thread block ,",
    "local beam accumulators are declared and stored in registers , one per beam , to which weighted antenna values are added .",
    "the antenna coefficients are loaded once per antenna group and stored in shared memory .",
    "this antenna partitioning is required as otherwise too much shared memory would be utilised , especially for large arrays , resulting in a decrease in occupancy and gpu compute resource utilisation .",
    "our kernel was originally implemented to match best-2 backend specifications , most notably the output data format of the f - engine , which sends out antenna signals as 4-bit , two s complement , complex voltages .",
    "this format enables the packaging of each antenna value as a single byte , and groups of 4 antennas can in turn be packaged as 32-bit words .",
    "this is beneficial for the gpu kernel as each group can be loaded with a single memory request , which can be coalesced if they are accessed contiguously by a thread warp . for this reason ,",
    "antennas are processed in groups of 4 in the beamformer , and complex coefficients are loaded in groups of the same size . in the inner - most loop , where these antennas are accumulated to form beams ,",
    "this also has the effect of increasing instruction level parallelism , thus decreasing execution time .",
    "breaking down antennas into groups of 4 has the additional benefit of making the kernel extensible to larger arrays without affecting performance .",
    "declare @xmath27 shared memory    declare local beam accumulators @xmath28 $ ]    load antenna group from global memory cooperatively load coefficients subset and store in @xmath27 synchronise threads    update local beam accumulator    store generated beam to global memory    [ beamformingalgorithm ]      algorithm [ beamformingalgorithm ] provides a detailed breakdown of our implementation .",
    "the outer time loop is included to handle cases where the number of input time bins is not exactly divisible by the total number of threads , such that threads will process at most 2 time bins .",
    "greater emphasis was put on making the beamforming kernel optimised for nvidia kepler gpus , making the implementation future proof and capable of fully utilising current top - range , high performance gpus .",
    "these gpus have a higher number of registers allocated per thread block , however the core clock speed is lower than in fermi gpus .",
    "this means that more data can be kept in fast memory , however care must be taken to better hide access latencies and make sure that a high level of instruction - level parallelism is achieved .",
    "no kepler - specific instruction were utilised , and memory coalescing is handled directly by the kernel without the assumption of a gpu cache , such that the kernel is able to run efficiently on any gpu architecture by optimally tweaking configuration parameters.our implementation requires two configuration parameters to be defined and consequently optimised upon :    * number of accumulators * defines the number of beams each thread will generate .",
    "these are stored in registers and thus are limited by the number of registers available to a thread block",
    ". a lower number of accumulators will decrease weight values reuse and increase global memory bandwidth requirements , while a high number will reduce gpu occupancy and in the worst case can be spilled to local memory , significantly reducing performance .",
    "+    * threads per block * determines the number of time samples a single thread block will process ( one per thread ) .",
    "a low number will reduce the number of active warps in a smx , leading to diminished parallelism , while a higher number will increase shared memory and register requirements , reducing occupancy .        in order to find the optimal configuration for the above parameters a series of benchmark tests were conducted on an nvidia tesla k20 card for a range of parameter combinations .",
    "figure [ gpubeamconfig ] shows the optimal values on the test device , where 16 accumulators and 128 threads per block provide the best performance . for these tests a 420 ms simulated buffer containing 32 4-bit complex sampled antenna voltage streams with a 20 mhz bandwidth channelised into 1024 frequency channels was generated and processed 10 times for each combination .",
    "the resulting mean was used as a measure of configuration performance . for these and subsequent tests we used compute unified device architecture ( cuda ) 6.0 ( cuda compilation tools release 5.5 , v5.5.0 ) .",
    "an in - depth analysis of the algorithm s performance was also performed , a summary of which is presented in table [ gpuperformancetable ] .",
    "these value were generated by the nvidia cuda profiler , for which the highest performing configuration for best-2 parameters was used .",
    "the beamformer s compute and memory utilisation is balanced , with @xmath080% of compute and @xmath060% of l1/shared memory being utilised .",
    "the kernel is compute - bound , relying heavily on the use of shared memory to cache beamforming weights , achieving a shared memory bandwidth of 1.3 tb / s with a shared memory efficiency of 50% .",
    "a high level of instruction level parallelism was also achieved , at 4.5 instructions per cycle .",
    "the flop rate achieved for the highest performance configuration ( 16 accumulators per threads and 128 threads per block ) is 1.3 tflops , approximately 38% of the peak theoretical performance of the tesla k20 .",
    "the number of flops achieved is calculated by counting the number of floating point operations required for each complex multiply , which in this case of 8@xmath20 per beam / channel / timestep .",
    "r l   + kernel compute utilisation & @xmath080% + warp efficiency & 100% + shared memory throughput & 1,289 gb / s + major issue stall & execution dependency ( 50% ) + issued instructions per cycle & 4.489 + shared memory efficiency & 50.1% + flops & 1.3 tflops +    a scalability analysis of the algorithm was also performed , where a 420 ms data buffer containing voltage data from 32 single polarisation antennas with a 20 mhz band channelised into 1024 frequency channels was used to generate an increasing number of synthesised beams in one gpu iteration .",
    "figure [ beamformerparameter ] shows that performance scales linearly with increasing number of beams and that execution time is a fraction of real - time for best-2 parameters . the maximum number of output beams which can be optimally synthesised",
    "is determined by the amount of global memory available on the gpu .",
    "the gpu spends 50% of its time waiting for raw voltage data to be copied from host to gpu memory , thus indicating that the implementation is bandwidth limited over the pcie link . when excluding the time required to copy the generated beams out of gpu memory the total execution time is evenly split between kernel execution and transferring antenna voltages to gpu memory .",
    "this data overhead can essentially be masked by using two cuda streams if the pipeline is capable of overlapping kernel execution and data transfer for the following iteration , however this would also require additional global memory .",
    "the situation is worse when the generated beams are post - processed externally to the gpu on which they were generated , as in this case the pipeline will be dominated by pcie transfer overheads .",
    "this can also be alleviated somewhat by increasing the number of streams on gpus with dual copy - engines , in which case the total execution time per iteration is the duration of the slowest stage ( pcie links are full - duplex , so the pcie transfer time is the time required to transfer the largest buffer to or from gpu memory ) .",
    "this poses several challenges for gpu - based beamforming pipelines and raises doubts on whether gpus are a viable platform for large - n aperture array telescopes .",
    "processing the generated beams on the gpu itself increases the compute - to - copy ratio .",
    "additional processing can take the form of correlation , accumulation for image generation or transient detection .",
    "the latter alternative will be discussed in further detail in section [ transientsection ] .          in order to measure the performance speed - up gained by using gpus",
    ", we also implemented a cpu version of the same algorithm , with each antenna voltage sample packed into a single byte ( 4-bits per complex component ) .",
    "the code was compiled with the intel icc compiler version 14.0.3 .",
    "the cpu beamformer was implemented with simd functionality in mind , making sure that the compiler can perform optimised auto - vectorisation where required .",
    "appropriate benchmarks were also performed .",
    "these were run on a system with two intel xeon e5 - 2640 cpus running at 2.5 ghz ( can be turbo - boosted to 3.0 ghz ) with hyper - threading disabled , resulting in a total of 12 physical cores .",
    "openmp was used to parallelise the implementation across multiple cores .",
    "the host operating system was ubuntu 14.04 with linux kernel 3.13 .",
    "the peak theoretical performance of a cpu can be computed using @xmath29 , where @xmath30 is the number of floating point operations per clock cycle , @xmath31 is the number of physical cpu cores and @xmath32 is the maximum processor frequency . for the xeon e5 - 2640 , this results in a peak performance of 120 gflops ( six cores at 2.5 ghz and 8 flops per cycle ) .    on this test system",
    "the cpu implementation achieves 0.45 cycles per instruction , where the xeon e5 - 2640 can issue up to four instructions per cycle , with a theoretical peak of 0.25 , suggesting that a high level of instruction level parallelism and simd functionality was achieved .",
    "figure [ beamformercpuparameter ] shows the result of these benchmarks , where a range of beams were synthesised using varying number of threads for best-2 parameters .",
    "performance increases linearly when using up to 10 threads , in which case up to 16 beams can be generated in real - time . with this configuration",
    ", each cpu ( 6 threads ) achieves the equivalent performance of 90 gflops ( assuming 8 flops per complex multiplication ) , suggesting that 75% of the cpu is being utilised .",
    "figure [ beamformerspeedup ] shows the speed - up gained when using the gpu beamformer compared with the cpu beamformer .",
    "when the number of antennas is small and a large number of beams are required , speed - up is minimal , whilst speed - up is maximised for large - arrays and a small number of synthesised beams . for best-2 parameters ,",
    "the overall speed - up is of an order of magnitude ( @xmath33 ) .",
    "gpu - based beamforming is a relatively unexplored area in radio astronomy , possibly due to the assumption that any such system will be severely limited by the pcie bandwidth required to transfer data to the gpu .",
    "@xcite presented two implementations for digital beamforming using cuda and benchmarked on an nvidia geforce 8800 .",
    "they state that gpus are a suitable platform for high - performance beamforming .",
    "@xcite have implemented a gpu - based version of the blue gene / p beamformer within the lofar pipeline , and state that they achieve a 45 - 50 times speed up , at 642 gflops when using cuda , on an nvidia gtx 580 ( using 40% of the peak theoretical performance ) , with a power efficiency improvement of 2 - 8 times .",
    "this algorithm was developed and benchmarked on fermi - architecture gpus , so directly comparing it with our implementation , which is optimised for the kepler architecture , does not provide an adequate comparative metric .",
    "both implementations achieve about 40% of peak performance , however our kernel can sustain this utilisation rate over a wide parameter range , whilst the one presented by @xcite is optimal for particular values . on the other hand ,",
    "if an odd number of beams or antennas is required , our implementation will suffer a degradation in performance .",
    "both implementations are targeted for a specific use case ( lofar and best-2 ) , and their applicability to other instruments has to be investigated .    @xcite discuss the possibility of generating all ska1-low station beams and performing first stage channelisation on gpus , however the required pcie bandwidth ends up being a severe bottleneck for a gpu - based architecture , resulting in approximately 16 gpus per station .",
    "the beamforming kernel was implemented and optimised to process the coarsely channelised , complex data output by the f - engine deployed at the best-2 array .",
    "this data is streamed out as user datagram protocol ( udp ) packets , with udp headers encapsulating groups of 128 time samples from 32 antennas , for each frequency channel , thus resulting in 4 kb packets with an additional 64-bit header containing the timestamp of the first time bin in the packet as well as the frequency channel index .",
    "the total output data rate can be calculated using @xmath34 , where @xmath35 is the number of frequency channels , @xmath36 is the number of samples per second , @xmath37 is the number of array elements and @xmath38 is the word length . in our case ,",
    "@xmath35 = 1024 , @xmath36 = 19531.25 , @xmath37 = 32 and @xmath38 = 8-bits ( 4-bits for each complex component ) , resulting in a total output bandwidth of 5.12 gbps , excluding packet headers .",
    "therefore a single 10 gige link is sufficient for data transfer between the f - engine and gpu server . at the receiving end ,",
    "the packet receiver used for @xcite was updated to be compatible with this format .",
    "groups of 128 time samples are considered as spead heaps , and thus heap functionality is still applicable .",
    "an additional lookup table is required to match the antenna order sent by the f - engine to the element ordering within the array and antenna configuration file , and is performed in the buffering thread .",
    "the kernel was integrated with two software pipelines .",
    "a beamforming pipeline was implemented and deployed at the best-2 array , using the beamforming kernel described in section [ implementationsection ] .",
    "this pipeline is currently being used for space debris detection prototyping and test observations @xcite .",
    "a future paper will discuss the full implementation of this system .",
    "several test observations were conducted during deployment . for these tests",
    ", additional functionality was included into the pipeline , including the ability to generate an arbitrary number of stationary ( within the primary field of view ) and tracking ( fixed on a celestial object ) beams , as well as sub - arraying .",
    "the latter uses an antenna mask in the kernel to only include voltages for the required antennas .",
    "additionally , a conversion mechanism was included to change the sample representation mechanism employed by the digital back - end to one which better suits the gpu .",
    "the kernel performance impact of these additional computations features since they are not performed in the inner most loop , and conversions use a lookup table stored in constant memory .",
    "figure [ beampattern ] shows a simulated beam pattern of the best-2 array .",
    "this was performed by generating the beamforming coefficients for a range of target ras and decs and computing the power of the beam at each point .",
    "about 32 beams are required to tile the entire primary beam with synthesised beams .",
    "the number of gpus required to perform all the processing depends on the what processing stages are required after beamforming . for examples ,",
    "a bi - static space debris detection system can run on a single gpu for 32 beams , while a transient detection pipeline will require considerably more gpus .",
    "figure [ pulsarfigure ] shows the result of a single beam test observation of pulsar psr b0329 + 54 .",
    "the beamformed data was stored to disk , with dedispersion and folding performed offline . in this case , the profile was folded 200 times .",
    "a tracking beam was used , fixed to the pulsar s ra and dec , and the data used for generating the profile coincides with the pulsar being in the center of the primary beam .",
    "figure [ casafigure ] shows the result of a multi - beam observation of cassiopeia a , with stationary beams pointed at an hour angle of 0 and each having an offset which is a multiple of 0.5 decs from the source s dec .",
    "the @xmath034 minute window of the observation is plotted , coinciding with the source transiting across the primary beam .",
    "we have also integrated the gpu beamforming kernel into the gpu - based transient detection pipeline described in @xcite .",
    "this section provides general design considerations for creating a transient detection pipeline with beamforming capabilities , assuming that a single gpu is capable of running the transient detection processing stages for at least one synthesised beam .",
    "the total number of gpus required will depend on the surveying and beamforming requirements for the telescope and science case on which the pipeline is deployed .",
    "the beamforming kernel has to be executed before the rfi excision and dedispersion stage , after which each beam is then processed by a separate gpu instance .",
    "the main challenge lies in determining the most efficient way to generate these beams , minimising data movement between the host and gpus , as well as amongst gpus .",
    "three schemes can be employed .",
    "the simplest scheme , implementation wise , would be to have each gpu processing thread generate its own coherent beam .",
    "this would require the input data buffer to be copied to each gpu instance , thus replicating this buffer multiple times within a gpu , greatly reducing the number of time spectra which would fit in global memory , as well as resulting in a degradation in performance due to the time spent transferring data over pcie links .",
    "also , the beamforming kernel is optimised for generating multiple beams in parallel , and this scheme would not be fully utilising the kernel s performance capabilities    at the other extreme , a single gpu can generate all the beams required by all the processing threads and then copy each beam to its destination , which could be on a separate gpu .",
    "only one host to gpu transfer is required , and kernel execution time is minimised when compared to the first scheme where multiple kernel launches are required , each generating one beam , which is clearly inefficient . however , a copy per generated beam is required , some of which can be across gpus for multi - gpu systems .",
    "this scheme also introduces heterogeneity across gpus in the pipeline , where one gpu acts as a producer which provides consumers with data to work on .",
    "an alternative approach is to combine both schemes , where beams are generated in the same kernel launch on the gpu on which further processing will be performed .",
    "the input antenna voltages need to be copied once to every gpu , where a master thread launches the beamforming kernel , generating all the required beams . upon completion",
    "each processing thread is provided with a pointer to its input beam , and processing advances as per standard transient detection .",
    "the latter scheme provides a good balance between input data replication , data transfer over pcie links and beamforming kernel efficiency , and is the scheme we adopted for the transient pipeline .",
    "the resulting design is illustrated in figure [ beamformerpipeline ] .",
    "the buffered antenna voltages are copied to an input buffer allocated on every attached gpu .",
    "these transfers occur in parallel over different hardware pcie links .",
    "a cpu thread per beam is created , which is responsible for all gpu - related processing of its associated beam .",
    "since multiple beams can reside on the same gpu , one of the cpu threads is initialised as the master thread associated with the gpu ( belonging to the first allocated beam ) .",
    "this is responsible for generating all the gpu buffers and launching the beamforming kernel .",
    "it will generate all the beams in a shared output buffer on the gpu , which can be accessed directly from other cpu threads mapped on the same gpu , thus not requiring a copy per generated beam .",
    "the transient detection pipeline is then launched for each synthesised beam , keeping the beamformed data in gpu memory . the output of the transient detection pipeline",
    "is then processed on the cpu , as described in @xcite .",
    "the main shortcoming of this design is that the slave processing threads have to wait for the beamforming kernel in the master thread to finish before they can start processing data , thus wasting valuable clock cycles .",
    "this duration is relatively short when compared to dedispersion . in the current implementation",
    ", the slave threads are blocked in a barrier synchroniser .",
    "the beamforming coefficients are computed by the pipeline manager whilst waiting for the processing threads to finish working on the previous iteration s input buffer .",
    "this allows beam pointings to change dynamically during pipeline execution , which is useful for tracking observations or online follow - up of interesting transient events , provided appropriate feedback mechanisms exist within the pipeline itself .",
    "the beamforming weight computation overhead is negligible relative to the execution time of a single pipeline iteration .",
    "the array configuration is stored in an xml file containing relative antenna locations .",
    "this pipeline was benchmarked using best-2 parameters as a reference telescope .",
    "a 2.52s buffer containing voltage data from 32 20 mhz single polarisation antennas centered at 408 mhz , split into 1024 frequency channels , was generated and processed in a single pipeline iteration .",
    "one nvidia k20 card was used for this test .",
    "four beams were synthesised from this buffer , each of which was then dedispersed over a range of 864 dispersion measure ( dm ) trials with a maximum dm of 86.4 pc @xmath39 .",
    "table [ timingtable ] lists the execution time of each stage .",
    "the cpu to gpu transfer of antenna voltages and the beamforming kernel launch are performed by the master processing thread , and the input data buffer is limited by the amount of global memory available .",
    "this table shows that , for a 32 element array , the beamforming cost is negligible when compared to the total execution time for the entire pipeline , and amounts to approximately 3% .",
    "this hints to the possibility of deploying a fully gpu - based beamforming and transient detection system for small , low - bandwidth arrays .",
    "analogue signal reception , digitisation and equilisation still need to be performed prior to beamforming , and these operations are more suitable to an fpga - based system , such as the f - engine deployed at the best-2 array .",
    "p3.5 cm l   + beamforming & 74.98 ms + bandpass fitting & 80.16 ms + rfi thresholding & 36.44 ms + dedispersion & 1780.60 ms + median filtering & 70.96 ms + detrending & 44.16 ms +   +   +",
    "we have presented a cuda - based gpu implementation of a coherent beamformer specifically designed and optimised for deployment at the best-2 array , connected to the digital backend developed by @xcite .",
    "this beamformer can generate an arbitrary number of synthesized beams for a wide range of parameters . with optimal kernel parametrisation",
    ", the kernel achieves 1.3 tflops on an nvidia tesla k20 , using @xmath080% of available gpu compute resources . comparing this implementation with a similarly optimised cpu version of the same algorithm",
    "run on a dual intel e5 - 2640 system shows an overall performance gain of an order of magnitude ( @xmath010x ) .",
    "we have integrated this kernel with two real - time software pipelines at the best-2 array , a standalone beamforming pipeline and the transient detection pipeline developed by @xcite , and show that when the beamformer is used in conjunction with other processing kernels , and as long as the generated beams stay in gpu memory , beam generation overhead is minimal when compared to processes such as dedispersion .",
    "this can alleviate the pcie data movement bottleneck for specialised pipelines .",
    "the croce del nord radio telescope is a facility of the university of bologna operated under agreement by the inaf istituto di radioastronomia .",
    "we would like to thank stelio montebugnoli , jader monari , germano bianchi , andrea mattana , giovanni naldi and all the staff at the medicina radio observatory for their invaluable help on - site during deployment and observing sessions .",
    "we would also like to thank the system designers for the digital backend , especially griffin foster , for their help in designing the interfacing protocol between the digital backend and host system , as well as for hours of support ."
  ],
  "abstract_text": [
    "<S> gpu - based beamforming is a relatively unexplored area in radio astronomy , possibly due to the assumption that any such system will be severely limited by the pcie bandwidth required to transfer data to the gpu . </S>",
    "<S> we have developed a cuda - based gpu implementation of a coherent beamformer , specifically designed and optimised for deployment at the best-2 array which can generate an arbitrary number of synthesized beams for a wide range of parameters . </S>",
    "<S> it achieves @xmath01.3 tflops on an nvidia tesla k20 , approximately 10x faster than an optimised , multithreaded cpu implementation . </S>",
    "<S> this kernel has been integrated into two real - time , gpu - based time - domain software pipelines deployed at the best-2 array in medicina : a standalone beamforming pipeline and a transient detection pipeline . </S>",
    "<S> we present performance benchmarks for the beamforming kernel as well as the transient detection pipeline with beamforming capabilities as well as results of test observation .    </S>",
    "<S> ; ; ; </S>"
  ]
}