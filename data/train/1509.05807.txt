{
  "article_text": [
    "* gray codes . *",
    "the problem of exhaustively listing the objects of a given class is important for several fields of science such as computer science , hardware and software , biology and ( bio)chemistry .",
    "the idea of so - called _ gray codes _ ( or _ combinatorial gray codes _ ) is to list the objects in such a way that two successive objects differ in some pre - specified small way ; in addition , if the last and first objects in the list differ in the same small way , then the gray code is called cyclic . in @xcite a general definition",
    "is given , where a gray code is defined as ` an infinite set of word - lists with unbounded word - length such that the hamming distance between any two successive words is bounded independently of the word - length ' ( the hamming distance is the number of positions in which the words differ ) .",
    "originally , a gray code was used in a telegraph demonstrated by french engineer mile baudot in 1878 . however , these days we normally say `` the gray code '' to refer to the _ reflected binary code _ introduced by frank gray in 1947 to list all binary words of length @xmath1 .",
    "much has been discovered and written about the gray code ( see for example @xcite or @xcite for surveys ) and it was used , for example , in _ error corrections in digital communication _ and in solving puzzles as _ tower of hanoi puzzle_. on the other hand , the area of combinatorial gray codes was popularized by herbert wilf in 1988 - 89 and since then such codes were found for many combinatorial structures , e.g. for _ involutions _ and _ fixed - point free involutions _ , _ derangements _ and certain classes of _ pattern - avoiding permutations _ ( see @xcite and references therein ) .",
    "existence of a ( resp . ,",
    "cyclic ) gray code is often established via finding a _ hamiltonian path _",
    "( resp . , _ hamiltonian cycle _ ) in a certain graph corresponding to objects in question .",
    "in such a graph two vertices are connected by an edge if and only if the respective objects can follow each other in a gray code . a hamiltonian path ( resp . , hamiltonian cycle ) in a graph is a path ( resp . ,",
    "cycle ) in the graph that goes through each vertex exactly once . + * planar maps . *",
    "a _ planar map _ is a connected graph embedded in the plane with no edge - crossings , considered up to continuous deformations .",
    "a map has _",
    "vertices _ , _ edges _ , and _",
    "faces_. the maps we consider shall be _ rooted _ , meaning that a directed edge has been distinguished as the root . without loss of generality , we assume that the root is always on the outer - face , called _ root face _ , and it is oriented counterclockwise . a planar map in which each vertex is of degree 3 is _ cubic _ ; it is _ bicubic _ if , in addition , it is bipartite , that is , if its vertices can be colored using two colors , say , black and white , so that adjacent vertices are assigned different colors .",
    "a map is _ @xmath2-connected _ if there does not exist a set of @xmath3 vertices whose removal disconnects the map .",
    "@xmath4-connected maps are also known as _ non - separable maps_.    for brevity , we omit the word `` planar '' in the classes of planar maps considered in this paper .    tutte ( * ? ? ?",
    "* chapter 10 ) founded the enumerative theory of planar maps in a series of papers in the 1960s ( see  @xcite and the references in  @xcite ) .",
    "in particular , the number of bicubic maps and cubic non - separable maps on @xmath5 vertices are , respectively , @xmath6     + * @xmath7-trees and planar maps . * a _ valuated tree _ is a rooted plane tree with non - negative integer labels on its vertices .",
    "a _ description tree _ introduced by cori et al . in  @xcite",
    "is a valuated tree such that the label of each vertex @xmath8 belongs to a set of values that depends only on the labels of @xmath8 s sons according to a given rule .",
    "description trees give a framework for recursively decomposing several families of planar maps .",
    "@xmath0-description trees , introduced next , are of interest in this paper .",
    "[ betaab - tree ] a @xmath7-tree is a rooted plane tree whose vertices are labeled with non - negative integers such that    1 .",
    "leaves have label @xmath9 ; 2 .",
    "the label of the root is the sum of its children s labels ; 3 .",
    "the label of any other vertex is at least @xmath9 and at most @xmath10 plus the sum of its children s labels .",
    "it was shown in  @xcite that the following objects are in one - to - one correspondence :    * @xmath11-trees and bicubic maps ; * @xmath12-trees and 3-connected cubic maps ; * @xmath13-trees and cubic non - separable maps ; and * @xmath14-trees and non - separable maps .",
    "also , it is straightforward to see that @xmath15-maps are in one - to - one correspondence with rooted planar trees , since one can erase the labels in this case as all of them are 0 . + * the main results in this paper .",
    "* one can ask the following question : is it possible to gray code a given class of maps ?",
    "to our best knowledge , no results are known in this direction possibly due to a rather complicated nature of ( planar ) maps .",
    "thus , one needs to encode the class of maps by words , and then to try to list these words using specified criteria on the number of positions in which the words can differ .",
    "our approach is in encoding the @xmath0-description trees in question , which are in a bijective correspondence with the maps of interest , on @xmath1 vertices by tuples of length @xmath16 ; the first @xmath17 elements of the tuple encode the shape of a tree ( using so - called _ dyck words _ ) , and the remaining elements are used to encode its labels . in either case , for convenience of presentation , we will consider gray coding shapes of trees separately , which will be given by a known result , while a real challenge will be lying in ( cyclicly ) gray coding @xmath0-description trees having the same shape .",
    "we note that @xmath0-description trees have already been used to obtain non - trivial equidistribution results on planar maps , e.g. bicubic maps  @xcite , and these trees are a key object in this paper .",
    "we will present our results on @xmath11-trees , which will give a gray code for bicubic maps , and then discuss a straightforward extension of that to @xmath7-trees with @xmath18 .",
    "the later will give at once gray codes for cubic non - separable maps and 3-connected cubic maps .",
    "thus , our focus will be on @xmath11-trees .",
    "in particular , the only bijective correspondence we will explain in this paper is that between @xmath11-trees  and bicubic maps , to give an idea on how bijections between maps and @xmath0-description trees corresponding to them could look like ; we refer to @xcite for bijections between @xmath12-trees ( resp .",
    ", @xmath13-trees ) and 3-connected cubic maps ( resp . , cubic non - separable maps ) .",
    "this paper is organized as follows . in section  [ sec :",
    "btrees ] we discuss @xmath11-trees  and bicubic maps , in particular sketching a bijection between these sets of objects . in section",
    "[ btrees - same - underlying ] we discuss a key component in this paper , namely , gray coding @xmath11-trees  having the same shape .",
    "cyclic gray coding @xmath11-trees  having the same shape is discussed in section  [ btrees - same - underlying - cyclic ] . even though gray coding cyclicly is what we are actually interested in , we first present a gray code for @xmath11-trees  having the same shape without the cyclic requirement to prepare the reader for the more involved arguments in the cyclic case .",
    "the main results are presented in section  [ main ] along with a definition of dyck words and necessary results about them .",
    "finally , in section  [ final - sec ] we provide several directions for further research .",
    "letting @xmath19 and @xmath20 in definition  [ betaab - tree ] we will obtain a definition of a @xmath11-tree . note that the label of the root of a @xmath11-tree  is defined uniquely from the labels of its children , which allows us to modify this definition to suit better to our purposes . in this paper",
    ", we will consider two modifications of the definition .",
    "first , we will re - define the root label to be one more than the sum of its children ( as was done in @xcite for a better description of statistics preserved under the bijection with bicubic maps to be described below ) , and then we will let the root label be @xmath21 ( to allow two @xmath11-trees  having the same shape to differ just in one label ) . thus ,",
    "no matter which definition we use , we still have a class of trees in one - to - one correspondence with the originally defined @xmath11-trees , and slightly abusing the notation , which will not cause any confusion , we will refer to all of the `` modified @xmath11-trees '' as @xmath11-trees .",
    "we continue with stating a slightly modified definition of @xmath11-trees , which are particular instances of @xmath7-trees introduced in definition [ betaab - tree ] .",
    "[ beta01-tree ] a @xmath11-tree  is a rooted plane tree whose vertices are labeled with nonnegative integers such that    1 .",
    "leaves have label @xmath22 ; 2 .",
    "the label of the root is one more than the sum of its children s labels ; 3 .",
    "the label of any other vertex exceeds the sum of its children s labels by at most 1 .    the unique @xmath11-tree  with exactly one vertex ( and no edges )",
    "is called _ trivial _ ; the root of the trivial tree has label @xmath22 .",
    "any other @xmath11-tree  is called _ nontrivial_. in figure  [ beta01 ] , appearing in  @xcite , we have listed all @xmath11-trees  on 4 vertices .",
    "@xmath23      {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;      \\node [ sml ] ( a ) at ( 0,0 ) { } ;      \\node [ sml ] ( b ) at ( 0,1 ) { } ;      \\node [ sml ] ( c ) at ( 0,2 ) { } ;      \\node [ sml ] ( d ) at ( 0,3 ) { } ;      \\draw         ( a ) node[right=2pt ] { 0 } --        ( b ) node[right=2pt ] { 0 } --        ( c ) node[right=2pt ] { 0 } --        ( d ) node[right=2pt ] { 1 } ;    \\end{tikzpicture } } \\qquad    {    \\begin{tikzpicture}[scale={0.5 } , semithick , baseline=(d ) ]      {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;      \\node [ sml ] ( a ) at ( 0,0 ) { } ;      \\node [ sml ] ( b ) at ( 0,1 ) { } ;      \\node [ sml ] ( c ) at ( 0,2 ) { } ;      \\node [ sml ] ( d ) at ( 0,3 ) { } ;      \\draw         ( a ) node[right=2pt ] { 0 } --        ( b ) node[right=2pt ] { 0 } --        ( c ) node[right=2pt ] { 1 } --        ( d ) node[right=2pt ] { 2 } ;    \\end{tikzpicture } } \\qquad    {    \\begin{tikzpicture}[scale={0.5 } , semithick , baseline=(d ) ]      {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;      \\node [ sml ] ( a ) at ( 0,0 ) { } ;      \\node [ sml ] ( b ) at ( 0,1 ) { } ;      \\node [ sml ] ( c ) at ( 0,2 ) { } ;      \\node [ sml ] ( d ) at ( 0,3 ) { } ;      \\draw         ( a ) node[right=2pt ] { 0 } --        ( b ) node[right=2pt ] { 1 } --        ( c ) node[right=2pt ] { 0 } --        ( d ) node[right=2pt ] { 1 } ;    \\end{tikzpicture } } \\qquad    {    \\begin{tikzpicture}[scale={0.5 } , semithick , baseline=(d ) ]      {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;      \\node [ sml ] ( a ) at ( 0,0 ) { } ;      \\node [ sml ] ( b ) at ( 0,1 ) { } ;      \\node [ sml ] ( c ) at ( 0,2 ) { } ;      \\node [ sml ] ( d ) at ( 0,3 ) { } ;      \\draw         ( a ) node[right=2pt ] { 0 } --        ( b ) node[right=2pt ] { 1 } --        ( c ) node[right=2pt ] { 1 } --        ( d ) node[right=2pt ] { 2 } ;    \\end{tikzpicture } } \\qquad    {    \\begin{tikzpicture}[scale={0.5 } , semithick , baseline=(d ) ]      {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;      \\node [ sml ] ( a ) at ( 0,0 ) { } ;      \\node [ sml ] ( b ) at ( 0,1 ) { } ;      \\node [ sml ] ( c ) at ( 0,2 ) { } ;      \\node [ sml ] ( d ) at ( 0,3 ) { } ;      \\draw         ( a ) node[right=2pt ] { 0 } --        ( b ) node[right=2pt ] { 1 } --        ( c ) node[right=2pt ] { 2 } --        ( d ) node[right=2pt ] { 3 } ;    \\end{tikzpicture } } \\qquad    {    \\begin{tikzpicture}[scale={0.5 } , semithick , baseline=(d ) ]      {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;      \\node [ sml ] ( a ) at ( -0.65,0 ) { } ;      \\node [ sml ] ( b ) at ( 0.65,0 ) { } ;      \\node [ sml ] ( c ) at ( 0,1 ) { } ;      \\node [ sml ] ( d ) at ( 0,2 ) { } ;      \\draw ( a ) node[below=2pt ] { 0 } -- ( c ) ;      \\draw ( b ) node[below=2pt ] { 0 } -- ( c ) ;      \\draw ( c ) node[right=2pt ] { 0 } -- ( d ) node[right=2pt ] { 1 } ;    \\end{tikzpicture } } \\qquad    {    \\begin{tikzpicture}[scale={0.5 } , semithick , baseline=(d ) ]      {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;      \\node [ sml ] ( a ) at ( -0.65,0 ) { } ;      \\node [ sml ] ( b ) at ( 0.65,0 ) { } ;      \\node [ sml ] ( c ) at ( 0,1 ) { } ;      \\node [ sml ] ( d ) at ( 0,2 ) { } ;      \\draw ( a ) node[below=2pt ] { 0 } -- ( c ) ;      \\draw ( b ) node[below=2pt ] { 0 } -- ( c ) ;      \\draw ( c ) node[right=2pt ] { 1 } -- ( d ) node[right=2pt ] { 2 } ;    \\end{tikzpicture } } \\ ] ] @xmath23      {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;      \\node [ sml ] ( a ) at ( -0.65,0 ) { } ;      \\node [ sml ] ( b ) at ( -0.65,1 ) { } ;      \\node [ sml ] ( c ) at ( 0.65,1 ) { } ;      \\node [ sml ] ( d ) at (    0,2 ) { } ;      \\draw ( a ) node[left=2pt ] { 0 } -- ( b ) ;      \\draw ( b ) node[left=2pt ] { 0 } -- ( d ) ;      \\draw ( c ) node[below=1pt ] { 0 } -- ( d ) node[right=2pt ] { 1 } ;    \\end{tikzpicture } } \\qquad    {    \\begin{tikzpicture}[scale={0.5 } , semithick , baseline=(d ) ]      {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;      \\node [ sml ] ( a ) at ( -0.65,0 ) { } ;      \\node [ sml ] ( b ) at ( -0.65,1 ) { } ;      \\node [ sml ] ( c ) at ( 0.65,1 ) { } ;      \\node [ sml ] ( d ) at (    0,2 ) { } ;      \\draw ( a ) node[left=2pt ] { 0 } -- ( b ) ;      \\draw ( b ) node[left=2pt ] { 1 } -- ( d ) ;      \\draw ( c ) node[below=1pt ] { 0 } -- ( d ) node[right=2pt ] { 2 } ;    \\end{tikzpicture } } \\qquad    {    \\begin{tikzpicture}[scale={0.5 } , semithick , baseline=(d ) ]      {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;      \\node [ sml ] ( a ) at ( 0.65,0 ) { } ;      \\node [ sml ] ( b ) at ( 0.65,1 ) { } ;      \\node [ sml ] ( c ) at ( -0.65,1 ) { } ;      \\node [ sml ] ( d ) at (    0,2 ) { } ;      \\draw ( a ) node[right=2pt ] { 0 } -- ( b ) ;      \\draw ( b ) node[right=2pt ] { 0 } -- ( d ) ;      \\draw ( c ) node[below=1pt ] { 0 } -- ( d ) node[right=2pt ] { 1 } ;    \\end{tikzpicture } } \\qquad    {    \\begin{tikzpicture}[scale={0.5 } , semithick , baseline=(d ) ]      {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;      \\node [ sml ] ( a ) at ( 0.65,0 ) { } ;      \\node [ sml ] ( b ) at ( 0.65,1 ) { } ;      \\node [ sml ] ( c ) at ( -0.65,1 ) { } ;      \\node [ sml ] ( d ) at (    0,2 ) { } ;      \\draw ( a ) node[right=2pt ] { 0 } -- ( b ) ;      \\draw ( b ) node[right=2pt ] { 1 } -- ( d ) ;      \\draw ( c ) node[below=1pt ] { 0 } -- ( d ) node[right=2pt ] { 2 } ;    \\end{tikzpicture } } \\qquad    {    \\begin{tikzpicture}[scale={0.5 } , semithick , baseline=(d ) ]      {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;      \\node [ sml ] ( a ) at ( -1,0 ) { } ;      \\node [ sml ] ( b ) at ( 0,0 ) { } ;      \\node [ sml ] ( c ) at ( 1,0 ) { } ;      \\node [ sml ] ( d ) at ( 0,1 ) { } ;      \\draw ( a ) node[below=1pt ] { 0 } -- ( d ) ;      \\draw ( b ) node[below=1pt ] { 0 } -- ( d ) ;      \\draw ( c ) node[below=1pt ] { 0 } -- ( d ) node[right=2pt , yshift=2pt ] { 1 } ;    \\end{tikzpicture } } \\ ] ]    let @xmath24 denote the root label of @xmath25 , and let @xmath26 denote the number of children of the root .",
    "we say that a @xmath11-tree  @xmath25 is _ reducible _ if @xmath27 , and _",
    "irreducible _ otherwise",
    ". any reducible tree can be written as a sum of irreducible ones , where the sum @xmath28 of two trees @xmath29 and @xmath30 is defined as the tree obtained by identifying the roots of @xmath29 and @xmath30 into a new root with label @xmath31 .",
    "see figure  [ fig : tree ] , taken from  @xcite , for an example .",
    "= [ font= ] ; = [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; ; ( r ) at ( 0,6 ) ; ( r1 ) at ( -3,5 ) ; ( r2 ) at ( -1,5 ) ; ( r3 ) at ( 1,5 ) ; ( r31 ) at ( 1,4 ) ; ( r4 ) at ( 3,5 ) ; ( r41 ) at ( 3,4 ) ; ( r411 ) at ( 3,3 ) ; ( r4111 ) at ( 2,2 ) ; ( r41111 ) at ( 2,1 ) ; ( r411111 ) at ( 2,0 ) ; ( r4112 ) at ( 4,2 ) ; ( r ) node[above=2pt ] 4  ( r1 ) node[below left=-1pt ] 0 ( r ) ",
    "( r2 ) node[below left=-1pt ] 0 ( r )  ( r3 )",
    "node[left=2pt , yshift=-2pt ] 1 ( r )  ( r4 ) node[right=2pt ] 2 ( r3 )  ( r31 ) node[left=2pt ] 0 ( r4 )  ( r41 ) node[right=2pt ] 1 ( r41 )  ( r411 ) node[right=2pt ] 3 ( r411 )  ( r4111 ) node[left=2pt ] 2 ( r4111 )  ( r41111 ) node[left=2pt ] 1 ( r41111 )  ( r411111 ) node[left=2pt ] 0 ( r411 )  ( r4112 ) node[right=2pt ] 0 ;    =     = [ font= ] ; = [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; ; ( r ) at ( 0,1 ) ; ( r1 ) at ( 0,0 ) ; ( r ) node[above=2pt ] 1  ( r1 ) node[below=2pt ] 0 ;    @xmath32     = [ font= ] ; = [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; ; ( r ) at ( 0,1 ) ; ( r1 ) at ( 0,0 ) ; ( r ) node[above=2pt ] 1  ( r1 ) node[below=2pt ] 0 ;    @xmath32     = [ font= ] ; = [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; ; ( r ) at ( 0,2 ) ; ( r3 ) at ( 0,1 ) ; ( r31 ) at ( 0,0 ) ; ( r ) node[above=2pt ] 2  ( r3 ) node[right=1pt ] 1  ( r31 ) node[below=2pt ] 0 ;    @xmath33     = [ font= ] ; = [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; ; ( r ) at ( 3,6 ) ; ( r4 ) at ( 3,5 ) ; ( r41 ) at ( 3,4 ) ; ( r411 ) at ( 3,3 ) ; ( r4111 ) at ( 2,2 ) ; ( r41111 ) at ( 2,1 ) ; ( r411111 ) at ( 2,0 ) ; ( r4112 ) at ( 4,2 ) ; ( r ) node[above=2pt ] 3 ( r )  ( r4 ) node[right=2pt ] 2 ( r4 )  ( r41 ) node[right=2pt ] 1 ( r41 )  ( r411 ) node[right=2pt ] 3 ( r411 )  ( r4111 ) node[left=2pt ] 2 ( r4111 ) ",
    "( r41111 ) node[left=2pt ] 1 ( r41111 )  ( r411111 ) node[left=2pt ] 0 ( r411 )  ( r4112 ) node[right=2pt ] 0 ;    note also that any irreducible tree with at least one edge is of the form @xmath34 , where @xmath35 and @xmath34 is obtained from @xmath25 by joining a new root via an edge to the old root ; the old root is given the label @xmath36 , and the new root is given the label @xmath37 .",
    "for instance , @xmath38    {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;    \\node [ sml ] ( r )   at ( 0,2 ) { } ;    \\node [ sml ] ( r1 ) at ( -1,1 ) { } ;    \\node [ sml ] ( r2 ) at ( 1,1 ) { } ;    \\node [ sml ] ( r21 ) at ( 1,0 ) { } ;    \\draw ( r ) node[above=2pt ] { 2 } -- ( r1 ) node[below=2pt ] { 0 }          ( r )                      -- ( r2 ) node[right=1pt ] { 1 } -- ( r21 ) node[below=2pt ] { 0 } ; \\end{tikzpicture } \\text{then}\\quad \\newcommand{\\lambdat}[2 ] { \\begin{tikzpicture}[xscale=0.37 , yscale=0.5 , semithick , baseline=(r ' ) ]    {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;    \\node [ sml ] ( r ' ) at ( 0,3 ) { } ;    \\node [ sml ] ( r )   at ( 0,2 ) { } ;    \\node [ sml ] ( r1 ) at ( -1,1 ) { } ;    \\node [ sml ] ( r2 ) at ( 1,1 ) { } ;    \\node [ sml ] ( r21 ) at ( 1,0 ) { } ;    \\draw ( r ' ) node[above=2pt ] { # 2 } -- ( r ) ;    \\draw ( r )   node[right=2pt ] { # 1 } -- ( r1 ) node[below=2pt ] { 0 }          ( r )                        -- ( r2 ) node[right=1pt ] { 1 } -- ( r21 ) node[below=2pt ] { 0 } ; \\end{tikzpicture } } \\lambda_0(t ) = \\!\\!\\!\\!\\lambdat{0}{1}\\hspace{-3.5ex},\\quad \\lambda_1(t ) = \\!\\!\\!\\!\\lambdat{1}{2}\\hspace{-3.5ex},\\quad \\text{and } \\ ;",
    "\\lambda_2(t ) = \\!\\!\\!\\!\\lambdat{2}{3}\\hspace{-3.5ex}.\\quad\\ ] ]    the smallest bicubic map has two vertices and three edges joining them .",
    "it is well - known that the faces of a bicubic map can be colored using three colors so that adjacent faces have distinct colors , say , colors 1 , 2 and 3 , in a counterclockwise order around white vertices .",
    "we will assume that the root vertex is black and the root face has color 3 .",
    "there are exactly three different bicubic maps with 6 edges and they are given in figure  [ bicubic ] appearing in  @xcite .",
    "= [ font= ] ; = [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; ; ( a ) at ( 0,0 ) ; ( b ) at ( 1,0 ) ; ( c ) at ( 2,0 ) ; ( d ) at ( 3,0 ) ; ( n1 ) at ( 1.5,-0.8 ) 1 ; ( n2 ) at ( 1.5 , 0 ) 3 ; ( n3 ) at ( 1.5 , 0.8 ) 2 ; ( n4 ) at ( 2.85 , 1.15 ) 3 ; ( a ) edge[bend right , looseness=1.3 ] ( d ) ; ( d ) edge[bend right , looseness=1.3 , shorten > = 0.15pt , - > ] ( a ) ; ( b ) edge[bend right , looseness=1.2 ] ( c ) ; ( c ) edge[bend right , looseness=1.2 ] ( b ) ; ( a ) edge ( b ) ( c ) edge ( d ) ;     = [ font= ] ; = [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; ; ( a ) at ( 0,0 ) ; ( b ) at ( 1,0 ) ; ( c ) at ( 0,1 ) ; ( d ) at ( 1,1 ) ; ( n1 ) at ( 0.5,-0.25 ) 2 ; ( n2 ) at ( 0.5 , 0.50 ) 1 ; ( n3 ) at ( 0.5 , 1.25 ) 2 ; ( n4 ) at ( 1.3 , 0.50 ) 3 ; ( a ) edge ( b ) ( b ) edge ( d ) ( d ) edge ( c ) ( c ) edge ( a ) ; ( a ) edge[bend right , looseness=1.6 ] ( b ) ; ( d ) edge[bend right , looseness=1.6 , shorten > = 0.15pt , - > ] ( c ) ;     = [ font= ] ; = [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; ; ( a ) at ( 0,0 ) ; ( b ) at ( 1,0 ) ; ( c ) at ( 0,1 ) ; ( d ) at ( 1,1 ) ; ( n1 ) at ( 0.5,-0.25 ) 1 ; ( n2 ) at ( 0.5 , 0.50 ) 2 ; ( n3 ) at ( 0.5 , 1.25 ) 1 ; ( n4 ) at ( 1.3 , 0.50 ) 3 ; ( a ) edge ( b ) ( b ) edge ( d ) ( d ) edge ( c ) ( c ) edge[shorten > = 0.15pt , - > ] ( a ) ; ( a ) edge[bend right , looseness=1.6 ] ( b ) ; ( d ) edge[bend right , looseness=1.6 ] ( c ) ;    following @xcite we will now describe a bijection between bicubic maps and @xmath11-trees .",
    "for any bicubic map @xmath39 and @xmath40 , let @xmath41 be the set of @xmath36-colored faces of @xmath39 .",
    "let @xmath42 , @xmath43 , and @xmath44 be the three faces around the root vertex ; in particular , @xmath45 is the root face .",
    "in addition , let @xmath46 be the @xmath47-colored face that meets the vertex that the root edge points at : @xmath48    {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;    \\node [ blk ] ( r ) at ( 0,0 ) { } ;    \\node [ wht ] ( s ) at ( 1,0 ) { } ;    \\path ( -1,0 ) edge ( r ) edge[- > ] ( s ) edge ( 2,0 ) ;    \\path ( r ) edge ( 0,1 ) ;    \\path ( s ) edge ( 1,1 ) ;    \\node [ wht ] ( s ) at ( 1,0 ) { } ;    \\node at ( -0.5 , 0.5 ) { $ r_1 $ } ;    \\node at ( 0.5 , 0.5 ) { $ r_2 $ } ;    \\node at ( 1.5 , 0.5 ) { $ s_1 $ } ;    \\node at ( 0.5,-0.5 ) { $ r_3 $ } ; \\end{tikzpicture}\\ ] ] let us say that a face touches another face @xmath2 times if there are @xmath2 different edges each belonging to the boundaries of both faces . define the following two statistics : @xmath49 we say that @xmath39 is _ irreducible _ if @xmath50 , or , in other words , if @xmath51 touches @xmath45 exactly once ; we say that @xmath39 is _ reducible _ otherwise .",
    "we shall introduce operations on bicubic maps that correspond to @xmath52 and @xmath32 of @xmath11-trees .",
    "this will induce the desired bijection @xmath53 between bicubic maps and @xmath11-trees .    to construct an irreducible bicubic map based on @xmath39 , and having two more vertices than @xmath39",
    ", we proceed in one of two ways .",
    "the first way ( 1 ) corresponds to @xmath34 when @xmath54 ; the second way ( 2 ) corresponds to @xmath34 when @xmath55 .",
    "* we create a new @xmath47-colored face touching the root face exactly once , so @xmath56 , by removing the root edge from @xmath39 and adding a digon that we connect to the map as in the picture below .",
    "@xmath57 +   = [ font= ] ; = [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; ; ; ( 240:1 ) arc ( 240:291:1 ) ; ( r ) at ( 240:1 ) ; ( s ) at ( 300:1 ) ; at ( -1.4,0 ) ; + m = +   = [ font= ] ; = [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; ; ; ( 240:1 ) arc ( 240:300:1 ) ; ( 240:1 )  + ( 0,-1 ) coordinate ( a ) ; ( 240:1 )  + ( 0,-0.84 ) ; ( 300:1 )  + ( 0,-1 ) coordinate ( b ) ; ( a ) edge[bend right , looseness=1.5 ] ( b ) ; ( a ) edge[bend left , looseness=1.5 ] ( b ) ; at ( a ) ; at ( b ) ; ( r ) at ( 240:1 ) ; ( s ) at ( 300:1 ) ; at ( @xmath58 ) ; at ( @xmath59 ) ; at ( 1.4,0 ) ; + @xmath57 * assuming that @xmath60 ; that is , @xmath39 has @xmath2 ( different ) @xmath47-colored faces touching the root face , we can create an irreducible map @xmath61 such that @xmath62 , where @xmath63 . to this end",
    ", we remove the root edge from @xmath39 .",
    "starting at the root vertex and counting in _ clockwise direction _ , we also remove the first edge of the @xmath36th @xmath47-colored face that touches the root face . in the picture below we schematically illustrate the case @xmath64 .",
    "next we add two more vertices and respective edges , and assign a new root as shown in the figure .",
    "@xmath65      {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk }",
    "=      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;      \\path      coordinate ( p0 ) at ( 0 * 45:\\radius ) { }      coordinate ( p1 ) at ( 1 * 45:\\radius ) { }      coordinate ( p2 ) at ( 2 * 45:\\radius ) { }      coordinate ( p3 ) at ( 3 * 45:\\radius ) { }      coordinate ( p4 ) at ( 4 * 45:\\radius ) { }      coordinate ( p5 ) at ( 5 * 45:\\radius ) { }      coordinate ( p6 ) at ( 6 * 45:\\radius ) { }      coordinate ( p7 ) at ( 7 * 45:\\radius ) { } ;      \\filldraw[fill = blue!6,draw = black!50 ] ( 0,0 ) circle ( \\radius ) ;      \\node[font=\\small ] at ( 0,0 ) { $ m$ } ;      \\path ( p1 ) edge[bend left , looseness=1.5 ] ( p2 ) ;      \\path ( p3 ) edge[bend left , looseness=1.5 ] ( p4 ) ;      \\path ( p5 ) edge[bend left , looseness=1.5 ] ( p6 ) ;      \\path ( p7 ) edge[bend left , looseness=1.5 ] ( p0 ) ;      \\draw [ - > ] ( p6 ) arc ( 6 * 45:7 * 45 - 5:\\radius ) ;      \\node at ( -2,0 ) { \\tiny{3 } } ;      \\node at ( 1.5 * 45:\\radiux ) { \\tiny{1 } } ;      \\node at ( 3.5 * 45:\\radiux ) { \\tiny{1 } } ;      \\node at ( 5.5 * 45:\\radiux ) { \\tiny{1 } } ;      \\node at ( 7.5 * 45:\\radiux ) { \\tiny{1 } } ;      \\node [ blk ] at ( p0 ) { } ;      \\node [ wht ] at ( p1 ) { } ;      \\node [ blk ] at ( p2 ) { } ;      \\node [ wht ] at ( p3 ) { } ;      \\node [ blk ] at ( p4 ) { } ;      \\node [ wht ] at ( p5 ) { } ;      \\node [ blk ] at ( p6 ) { } ;      \\node [ wht ] at ( p7 ) { } ;    \\end{tikzpicture }    \\quad \\longmapsto \\quad m ' \\,=\\!\\ !    \\begin{tikzpicture}[semithick , scale=0.65 , bend angle=45 , rotate=0 ,   baseline=-0.6ex ]      {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;      \\path      coordinate ( a )   at ( 0 * 45:2*\\radius ) { }      coordinate ( b )   at ( 0 * 45:2.5*\\radius ) { }      coordinate ( q )   at ( 1.7 * 45:\\radius ) { }      coordinate ( p0 ) at ( 0 * 45:\\radius ) { }      coordinate ( p1 ) at ( 1 * 45:\\radius ) { }      coordinate ( p2 ) at ( 2 * 45:\\radius ) { }      coordinate ( p3 ) at ( 3 * 45:\\radius ) { }      coordinate ( p4 ) at ( 4 * 45:\\radius ) { }      coordinate ( p5 ) at ( 5 * 45:\\radius ) { }      coordinate ( p6 ) at ( 6 * 45:\\radius ) { }      coordinate ( p7 ) at ( 7 * 45:\\radius ) { } ;      \\filldraw[fill = blue!6,draw = black!50 ] ( 0,0 ) circle ( \\radius ) ;      \\node[font=\\small ] at ( 0,0 ) { $ m$ } ;      \\path ( p6 ) edge[- > , bend right , shorten > = 2pt ] ( b ) ;      \\path ( p7 ) edge[bend right ] ( a ) ;      \\path ( b ) edge[bend angle=90 , bend right , looseness=1 ] ( p2 ) ;      \\path ( a ) edge[bend angle=90 , bend right , looseness=1 ] ( q ) ;      \\path ( a ) edge ( b ) ;      \\path ( p1 ) edge[bend left , looseness=1.5 ] ( p2 ) ;      \\path ( p3 ) edge[bend left , looseness=1.5 ] ( p4 ) ;      \\path ( p5 ) edge[bend left , looseness=1.5 ] ( p6 ) ;      \\path ( p7 ) edge[bend left , looseness=1.5 ] ( p0 ) ;      \\draw[very thick , white ] ( q ) arc ( 1.7 * 45:2 * 45:\\radius ) ;      \\draw[very thick , white ] ( p6 ) arc ( 6 * 45:7 * 45:\\radius ) ;      \\node at ( 4.5 * 45:1.9 ) { \\tiny{3 } } ;      \\node at ( 0.5 * 45:1.9 ) { \\tiny{3 } } ;      \\node at ( 7.0 * 44.3:1.9 ) { \\tiny{2 } } ;      \\node at ( 0.5 * 45:3.17 ) { \\tiny{1 } } ;      \\node at ( 3.5 * 45:\\radiux ) { \\tiny{1 } } ;      \\node at ( 5.5 * 45:\\radiux ) { \\tiny{1 } } ;      \\node at ( 7.5 * 45:\\radiux ) { \\tiny{1 } } ;      \\node [ blk ] at ( a )   { } ;      \\node [ wht ] at ( b )   { } ;      \\node [ blk ] at ( p0 ) { } ;      \\node [ wht ] at ( p1 ) { } ;      \\node [ blk ] at ( p2 ) { } ;      \\node [ wht ] at ( p3 ) { } ;      \\node [ blk ] at ( p4 ) { } ;      \\node [ wht ] at ( p5 ) { } ;      \\node [ blk ] at ( p6 ) { } ;      \\node [ wht ] at ( p7 ) { } ;      \\node [ circle , fill = white , draw = black , minimum size=2.5pt , inner sep=0pt ] at ( q ) { } ;    \\end{tikzpicture}\\ ] ]    any irreducible bicubic map on @xmath66 vertices can be constructed from some bicubic map on @xmath1 vertices by applying operation ( 1 ) or ( 2 ) above .",
    "we shall now describe how to create a reducible map based on irreducible maps @xmath67 , @xmath68 ,  , @xmath69 .",
    "an illustration for @xmath70 can be found below .",
    "this corresponds to the @xmath32-operation on @xmath11-trees .    *",
    "we begin by lining up the maps @xmath67 , @xmath68 ,  , @xmath69 .",
    "next , in each map @xmath71 , we remove the first edge ( in _ counter - clockwise direction _ ) from the root edge on the root face .",
    "then we connect the maps as shown in the figure , and define the root edge of the obtained map to be the root edge of @xmath69 .",
    "@xmath57     = [ font= ] ; = [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; ; ( 180:1 ) arc ( 180:231:1 ) ; ( 240:1 ) arc ( 240:300:1 ) ; ( r1 ) at ( 180:1 ) ; ( s1 ) at ( 240:1 ) ; ( t1 ) at ( 300:1 ) ; ( s1 ) edge[bend left , looseness=1.5 ] ( t1 ) ; at ( @xmath72 ) ; at ( 0,0 ) @xmath67 ; at ( -1.2,0.7 ) ;    ( 180:1 ) arc ( 180:231:1 ) ; ( 240:1 ) arc ( 240:300:1 ) ; ( r2 ) at ( 180:1 ) ; ( s2 ) at ( 240:1 ) ; ( t2 ) at ( 300:1 ) ; ( s2 ) edge[bend left , looseness=1.5 ] ( t2 ) ; at ( @xmath73 ) ; at ( 0,0 ) @xmath68 ; at ( -1.2,0.7 ) ;    ( 180:1 ) arc ( 180:231:1 ) ; ( 240:1 ) arc ( 240:300:1 ) ; ( r3 ) at ( 180:1 ) ; ( s3 ) at ( 240:1 ) ; ( t3 ) at ( 300:1 ) ; ( s3 ) edge[bend left , looseness=1.5 ] ( t3 ) ; at ( @xmath74 ) ; at ( 0,0 ) @xmath75 ; at ( -1.2,0.7 ) ;    m =     = [ font= ] ; = [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; ; ( 180:1 ) arc ( 180:231:1 ) ; ( 240:1 ) arc ( 240:300:1 ) ; ( r1 ) at ( 180:1 ) ; ( s1 ) at ( 240:1 ) ; ( t1 ) at ( 300:1 ) ; ( s1 ) edge[bend left , looseness=1.5 ] ( t1 ) ; at ( 0,0 ) @xmath75 ;    ( 180:1 ) arc ( 180:231:1 ) ; ( 240:1 ) arc ( 240:300:1 ) ; ( r2 ) at ( 180:1 ) ; ( s2 ) at ( 240:1 ) ; ( t2 ) at ( 300:1 ) ; ( s2 ) edge[bend left , looseness=1.5 ] ( t2 ) ; at ( 0,0 ) @xmath68 ; at ( 0,-1.4 ) ;    ( 180:1 ) arc ( 180:231:1 ) ; ( 240:1 ) arc ( 240:300:1 ) ; ( r3 ) at ( 180:1 ) ; ( s3 ) at ( 240:1 ) ; ( t3 ) at ( 300:1 ) ; ( s3 ) edge[bend left , looseness=1.5 ] ( t3 ) ; at ( 0,0 ) @xmath67 ;    ( t1 ) edge[bend right=30 ] ( s2 ) ( t2 ) edge[bend right=30 ] ( s3 ) ( s1 ) edge[bend right=50 , looseness=0.6 ] ( t3 ) ; at ( 1.35,0.8 ) ;    @xmath57 any reducible bicubic map on @xmath1 vertices can be constructed by applying the above operation ( 3 ) to some ordered list of irreducible bicubic maps whose total number of vertices is @xmath1 .    by defining operations on bicubic maps corresponding to the operations @xmath52 and @xmath32 we have now completed the definition of the bijection @xmath53 between bicubic maps and @xmath11-trees .",
    "see @xcite for examples of non - trivial applications of the bijection .",
    "in this section , after introducing some notations , we will define a gray code for @xmath11-trees  with the same underlying tree and extend it to a cyclic gray code for @xmath11-trees  with arbitrary underlying trees .",
    "this will induce a cyclic gray code for bicubic maps .",
    "then we will see that our construction can be easily extended to a wider class of @xmath0-description trees inducing cyclic gray codes for the corresponding to them planar maps .",
    "a list @xmath76 for a set of length @xmath1 tuples is a _ gray code _ if @xmath76 lists , with no repetitions nor omissions , the tuples in the set so that the hamming distance between two successive tuples in @xmath76 ( i.e. , the number of positions in which they differ ) is bounded by a constant , independent of @xmath1 . and",
    "when we want to explicitely refer to this constant , say @xmath2 , we call such a list a _ @xmath2-gray code_. in addition , if the last and first tuple in @xmath76 differ in the same way , then the gray code is _",
    "cyclic_.    if @xmath76 is a list , then @xmath77 is the list obtained by reversing @xmath76 , and if @xmath78 is another list , then @xmath79 is the concatenation of the two lists . if @xmath80 is a tuple , then @xmath81 ( resp . , @xmath82 ) is the list obtained by appending ( resp . , postpending )",
    "@xmath80 to each tuple of @xmath76 , and @xmath83 is the tuple obtained by concatening @xmath2 copies of @xmath80 .",
    "often we refer to a list by enumerating its elements , e.g. @xmath84 .",
    "given a family @xmath85 of @xmath86 lists , each @xmath87 , @xmath88 , being a @xmath89-gray code for a set @xmath90 of same length tuples , we define another family of lists @xmath91 as follows : @xmath92 is simply the list @xmath93 , and for @xmath94 ,    @xmath95 where @xmath96 is the list @xmath97 , and the last term of the concatenation defining @xmath98 is either @xmath99 or @xmath100 , depending on @xmath101 being odd or even .",
    "it is routine to prove the following proposition that we will use later .    with the notations above",
    ", @xmath102 is a @xmath2-gray code for the product set @xmath103 , where @xmath104 .",
    "[ product_set ]      recall that by definitions , the label of the root of a @xmath11-tree  is uniquely determined by the labels of its children . in",
    "what follows , for convenience , we assume that the root of any @xmath11-tree  is labeled by @xmath21 .",
    "that is , we amend ( 2 ) in definition  [ beta01-tree ] , obtaining a class of trees , still called @xmath11-trees  by us , which are in one - to - one correspondence with @xmath11-trees  defined either in definition  [ betaab - tree ] or definition  [ beta01-tree ] .",
    "the rationale for ( again ! ) updating slightly our previous definitions is in allowing @xmath11-trees  to be on distance 1 from each other in the sense specified in definition  [ distance - same - underlying ] below .",
    "we are also interested in the following class of labeled trees , which are essentially @xmath11-trees , but where the root is treated as any other internal vertex .",
    "[ beta01-tree ] a @xmath105-tree is a rooted plane tree whose vertices are labeled with nonnegative integers such that    1 .",
    "leaves have label @xmath22 ; 2 .",
    "the label of any other vertex exceeds the sum of its children s labels by at most 1 .",
    "note that any @xmath11-tree  discussed in definition  [ beta01-tree ] is a @xmath105-tree .",
    "[ def - underl ] let @xmath25 be a @xmath11-tree  or a @xmath105-tree .",
    "then @xmath106 denotes the underlying rooted tree , that is , the tree obtained by removing all labels in @xmath25 . in other words , @xmath106 gives the shape of @xmath25 .",
    "for example , if @xmath25 is the rightmost @xmath11-tree  in the top row in figure  [ beta01 ] , then @xmath106 is given by @xmath23      {    {    \\tikzstyle{every node } = [ font=\\footnotesize ] ; } {    \\tikzstyle{blk } =      [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{wht } =      [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ;    \\tikzstyle{sml } =      [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; } } ;      \\node [ sml ] ( a ) at ( -0.65,0 ) { } ;      \\node [ sml ] ( b ) at ( 0.65,0 ) { } ;      \\node [ sml ] ( c ) at ( 0,1 ) { } ;      \\node [ sml ] ( d ) at ( 0,2 ) { } ;      \\draw ( a ) node[below=2pt ] { } -- ( c ) ;      \\draw ( b ) node[below=2pt ] { } -- ( c ) ;      \\draw ( c ) node[right=2pt ] { } -- ( d ) node[right=2pt ] { } ;    \\end{tikzpicture } } \\ ] ]    let @xmath25 be a @xmath11-tree  or a @xmath105-tree with @xmath1 vertices .",
    "we let @xmath107 denote the @xmath1-tuple of @xmath25 s labels obtained by traversing @xmath25 by depth first algorithm using the leftmost option and reading each label exactly once .    for example , for the tree @xmath25 in figure",
    "[ fig : tree ] , @xmath108 ; see also table [ co_example ] where the roots are labeled by * .",
    "thus , @xmath107 is an encoding of a given @xmath11-tree @xmath25 in the form of a tuple .",
    "note that this encoding disregards the shape of the tree .",
    "[ distance - same - underlying ] for @xmath11-trees  ( with the root labeled by * ) , or @xmath105-trees , @xmath109 and @xmath110 such that @xmath111 , the _ distance _ @xmath112 between the trees is the number of positions in which @xmath113 and @xmath114 differ ( or equivalently , the hamming distance between @xmath113 and @xmath114 ) .",
    "for example , keeping in mind that we label the root of a @xmath11-tree  by @xmath21 , the distance between the first and the forth trees in the top row in figure  [ beta01 ] is 2 , while the distance between the first and the second trees in the bottom row in that figure is 1 .",
    "[ def - l - t ] for a @xmath105-tree @xmath25 , we let @xmath115 denote the set of encodings of all @xmath105-trees obtained by labeling properly @xmath106 .",
    "[ lem1 ] for any @xmath105-tree @xmath25 there is a @xmath47-gray code for @xmath115 .    before giving a formal proof of lemma  [ lem1 ]",
    ", we explain its general idea , which is presented graphically in figure  [ two_figures](a ) . assuming the existence of a @xmath47-gray code for smaller trees",
    ", we can extend such a code to trees obtained by adding the new root .",
    "more precisely , each vertex in figure  [ two_figures](a ) corresponds to a @xmath105-tree having a fixed shape ( that is , underlying tree ) .",
    "vertices on the same vertical line correspond to @xmath105-trees that differ only in the root label : the higher vertex is , the larger root label it corresponds to .",
    "note that each vertical line must contain at least the vertices corresponding to root labels  @xmath22 and  @xmath47 , but it may or may not contain other vertices .",
    "further , @xmath116 , @xmath117 , etc . in this figure form a hamiltonian path corresponding to the 1-gray code for the trees with root label equal  @xmath22 , whose existence we assumed . also , @xmath118 , @xmath119 , etc . is such a path for the trees with root label equal  @xmath47 .",
    "thus , the trees corresponding to @xmath120 and @xmath121 differ only in the root label .",
    "the desired hamiltonian path through all the @xmath105-trees ( corresponding to the 1-gray code for @xmath115 ) presented schematically in figure  [ two_figures](a ) begins at @xmath116 and goes in the direction of the arrow .",
    "+ _ proof of lemma [ lem1 ] .",
    "_ we proceed by induction on the number @xmath8 of vertices in @xmath25 .",
    "the base cases , @xmath122 ( the single vertex @xmath105-tree ) and @xmath123 ( two single edge @xmath105-trees , which are on distance 1 from each other ) obviously hold .",
    "suppose now that @xmath124 , and the children of the root are the roots of subtrees @xmath125 from left to right , where @xmath126 .",
    "each @xmath127 is a @xmath105-tree and by induction hypothesis , @xmath128 has a @xmath47-gray code .",
    "but then , by proposition  [ product_set ] , @xmath129 also has a @xmath47-gray code , and it can be extended to a @xmath47-gray code of @xmath115 obtained by adding the new leftmost coordinate corresponding to @xmath25 s root to each entry of @xmath130 as explained below .",
    "for an integer @xmath131 we define two lists of @xmath47-tuples :    * @xmath132 , and * @xmath133 .",
    "in particular , @xmath134 and @xmath135 are the lists @xmath136 and @xmath137 , respectively .",
    "let @xmath138 be the @xmath47-gray code list for @xmath130 , so that each @xmath139 is the concatenation of @xmath2 tuples corresponding to the labels of the vertices of the trees @xmath125 , and let @xmath140 be the sum of the labels of the roots of these trees plus one . in other words , @xmath140 is the maximal value of @xmath141 , such that @xmath142 is a proper labeling of @xmath25 .",
    "thus @xmath143 and @xmath144 if and only if the root of each @xmath127 is labeled by @xmath22 .",
    "finally , let @xmath145 be the list defined as    @xmath146 with @xmath147    clearly , the underlying set of @xmath145 is @xmath115 .",
    "in addition @xmath145 is a @xmath47-gray code : throughout each list @xmath148 successive tuples differ in the first position , and the last element of @xmath148 differ from the first element of @xmath149 as @xmath139 differ from @xmath150 , that is in a single position .",
    "thus , @xmath115 has a @xmath47-gray code and the statement is proved by induction .",
    "@xmath151    [ z(t)-hamilt - path ] there exists a @xmath47-gray code for @xmath11-trees  having the same underlying tree .",
    "suppose that the root of a @xmath11-tree  @xmath25 , labeled by @xmath21 , has subtrees @xmath152 , where @xmath126 .",
    "each @xmath127 is a @xmath105-tree , and thus , by lemma  [ lem1 ] , there is a @xmath47-gray code for each @xmath128 .",
    "but then , by proposition [ product_set ] , there is also a @xmath47-gray code for @xmath130 leading to the fact that @xmath153 has a @xmath47-gray code , as desired .    [",
    "cols=\"^,^ \" , ]     in what follows , the hamming distance between tuples is denoted by @xmath154 , and the next definition extends it to trees .",
    "[ distance - beta01-trees1 ] for @xmath11-trees  @xmath109 and @xmath110 on the same number of vertices , the _ distance _ @xmath112 between the trees is defined as @xmath155    [ thm - main ] there exists a cyclic @xmath156-gray code for @xmath11-trees  ( with the root labeled by * ) on @xmath1 vertices , @xmath157 , with respect to the distance given in definition  [ distance - beta01-trees1 ] .",
    "any @xmath11-tree  @xmath25 on @xmath1 vertices can be encoded by a @xmath158-tuple , which is obtained by merging the @xmath159-tuples @xmath160 and the @xmath1-tuples @xmath107 . let @xmath161 be the list where @xmath162 is the @xmath36th tuple in the list @xmath163 defined in relation ( [ g_dy ] ) , @xmath164 is the tree encoded by @xmath162 , and @xmath165 the list assumed by corollary [ one_corr ] for the @xmath11-trees  having the shape @xmath164 .",
    "it is easy to see that in the list defined in relation ( [ list_gen ] ) two successive tuples are at distance at most 3 .",
    "indeed ,    * for a fixed @xmath162 , successive tuples in @xmath166 differ in one position , and * for two successive tuples @xmath162 and @xmath167 in @xmath163 ( including the last and the first ones ) , the last tuple in @xmath166 and the first one in @xmath168 differ in three positions .    note that the gray code stated in theorem [ thm - main ] for @xmath11-trees is minimal , in the sense that , in general there are not cyclic @xmath4-gray codes for @xmath11-trees .",
    "see table  [ co_example ] for an example when @xmath11-trees , encoded by ( 1,1,0,0,*,0,0 ) , ( 1,1,0,0,*,1,0 ) and ( 1,0,1,0,*,0,0 ) , can not be listed cyclically so that the distance between successive trees is at most 2 .",
    "also , the gray code defined in ( [ list_gen ] ) is `` shape partitioned '' , that is , same shape @xmath11-trees are successive in it .         = [",
    "font= ] ; = [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; ; ( a ) at ( 0,0 ) ; ( b ) at ( 0,1 ) ; ( c ) at ( 0,2 ) ; ( a ) node[right=2pt ] 0  ( b ) node[right=2pt ] 0  ( d ) node[right=2pt ] * ;    &     = [ font= ] ; = [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; ; ( a ) at ( 0,0 ) ; ( b ) at ( 0,1 ) ; ( c ) at ( 0,2 ) ; ( a ) node[right=2pt ] 0  ( b ) node[right=2pt ] 1  ( d ) node[right=2pt ] * ;    &     = [ font= ] ; = [ circle , fill = black , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = white , draw = black , minimum size=3.7pt , inner sep=0pt ] ; = [ circle , fill = black , draw = black , minimum size=3pt , inner sep=0pt ] ; ; ( a ) at ( -0.65,0 ) ; ( b ) at ( 0.65,0 ) ; ( c ) at ( 0,1 ) ; ( a ) node[below=2pt ] 0  ( c ) ; ( b ) node[below=2pt ] 0  ( c ) node[right=2pt ] * ;    @xmath107 & ( * , 0,0 ) & ( * , 1,0 ) & ( * , 0,0)@xmath160 & ( 1,1,0,0 ) & ( 1,1,0,0)&(1,0,1,0 )    our way to gray code bicubic maps can be applied to any class of planar maps that can be described in terms of @xmath7-trees with @xmath18 .",
    "namely , generalizing the notion of @xmath105-trees to that of @xmath169-trees ( by removing the condition on the root in definition  [ betaab - tree ] ) , we can essentially copy / paste all our arguments for @xmath105-trees . indeed , for such a @xmath169-tree @xmath25 , the levels corresponding to the root s label @xmath9 and @xmath170 will be isomorphic , so that induction can be used in the way we used it for @xmath105-trees .",
    "thus , in particular , we can gray code @xmath156-connected cubic planar maps and cubic non - separable planar maps corresponding to @xmath12-trees and @xmath13-trees , respectively @xcite .",
    "finally , note that having @xmath171 would simplify some of our arguments .",
    "in particular , in this case there is no need to prove the existence of the edge @xmath172 in lemma  [ lem1-gen ] , since we will have at least three isomorphic levels of vertices corresponding to the root labels @xmath9 , @xmath170 and @xmath173 , so that existence of an edge with the right properties will be given to us automatically ( in fact , each edge from the hamiltonian path on level @xmath173 will have the right properties ) .",
    "in this paper we have shown that classes of planar maps corresponding to @xmath7-trees with @xmath18 have cyclic 3-gray codes , and these codes are minimal in the sense of hamming distance .",
    "we leave it as an open problem to determine whether there exist ( cyclic ) @xmath2-gray codes , for some @xmath126 , for @xmath174-trees , where @xmath175 . in the case",
    "@xmath176 such a code would induce a gray code on non - separable planar maps via the respective bijection @xcite .",
    "it would also be interesting to gray code so - called @xmath80-description trees ( see @xcite for the definition ) that would induce gray coding of _ planar maps _ and _ eulerian planar maps _ @xcite .",
    "the first and the third authors were supported by grant nsh-1939.2014.1 of president of russia for leading scientific schools . the second author is grateful to london mathematical society and to the university of bourgogne for supporting his work on this paper .                    .",
    "generating binary trees by transpositions , _ journal of algorithms _ * 11 * ( 1990 ) 6884 .",
    "f. ruskey .",
    "combinatorial gseneration , book in preparation .",
    "c. savage . a survey of combinatorial gray codes , _ siam rev .",
    "_ * 39(4 ) * ( 2006 ) 605629 ."
  ],
  "abstract_text": [
    "<S> the idea of ( combinatorial ) gray codes is to list objects in question in such a way that two successive objects differ in some pre - specified small way . in this paper , we utilize @xmath0-description trees to cyclicly gray code three classes of cubic planar maps , namely , bicubic planar maps , 3-connected cubic planar maps , and cubic non - separable planar maps . </S>"
  ]
}