{
  "article_text": [
    "a multi - party contract signing ( mpcs ) protocol is a communication protocol that allows a number of parties to sign a digital contract .",
    "the need for mpcs protocols arises , for instance , in the context of service level agreements ( slas ) and in supply chain contracting . in these domains ( electronic ) contract negotiations and signing",
    "are still mainly bilateral . instead of negotiating and signing one multi - party contract , in practice ,",
    "multiple bilateral negotiations are conducted in parallel  @xcite .",
    "because negotiations can fail , parties may end up with just a subset of the pursued bilateral contracts .",
    "if a party is missing contracts with providers or subcontractors , it faces an _ overcommitment _ problem .",
    "if contracts with customers are missing , it has an _ overpurchasing _",
    "problem  @xcite .",
    "both problems can be prevented by using fair multi - party contract signing protocols .",
    "existing optimistic mpcs protocols come in two flavors .",
    "_ linear _ mpcs protocols require that at any point in time at most one signer has enough information to proceed in his role by sending messages to other signers .",
    "_ broadcast _ mpcs protocols specify a number of communication rounds in each of which all signers send or broadcast messages to each other . however , neither of the two kinds of protocols is suitable for slas or supply chain contracting .",
    "the reason is that in both domains , the set of contractors typically has a hierarchical structure , consisting of main contractors and levels of subcontractors .",
    "it is undesirable ( and perhaps even infeasible ) for the main contracting partners and their subcontractors to directly communicate with another partner s subcontractors .",
    "this restriction immediately excludes broadcast protocols as potential solutions and forces linear protocols to be impractically large .    in this paper",
    "we introduce mpcs protocol specifications that support arbitrary combinations of linear and parallel actions , even within a protocol role .",
    "the message flow of such protocols can be specified as a directed acyclic graph ( dag ) and we therefore refer to them as _ dag _ mpcs protocols .    a central requirement for mpcs protocols is _",
    "fairness_. this means that either all honest signers get all signatures on the negotiated contract or nobody gets the honest signers signatures .",
    "it is well known that in asynchronous communication networks , a deterministic mpcs protocol requires a trusted third party ( ttp ) to achieve fairness  @xcite . in order to prevent the ttp from becoming a bottleneck ,",
    "protocols have been designed in which the ttp is only involved to resolve conflicts .",
    "a conflict may occur if a message gets lost , if an external adversary interferes with the protocol , or if signers do not behave according to the protocol specification .",
    "if no conflicts occur , the ttp does not even have to be aware of the execution of the protocol .",
    "such protocols are called _ optimistic _",
    "we focus on optimistic protocols in this paper .",
    "dag mpcs protocols not only allow for better solutions to the subcontracting problem , but also have further advantages over linear and broadcast mpcs protocols and we design three novel mpcs protocols that demonstrate this .",
    "one such advantage concerns communication complexity .",
    "linear protocols can reach the minimal number of messages necessary to be exchanged in fair mpcs protocols at the cost of a high number of protocol `` rounds '' .",
    "we call this the _ parallel complexity _ , which is a generalization of the round complexity measure for broadcast protocols , and define it in section  [ sec : complexity ] .",
    "conversely , broadcast protocols can attain the minimal number of protocol rounds necessary for fair mpcs , but at the cost of a high message complexity .",
    "we demonstrate that dag mpcs protocols can simultaneously attain best possible order of magnitude for both complexity measures .",
    "as discussed in our related work section , the design of fair mpcs protocols has proven to be non - trivial and error - prone .",
    "we therefore not only prove our three novel dag mpcs protocols to be fair , but we also derive necessary and sufficient conditions for fairness of any optimistic dag mpcs protocol .",
    "these conditions can be implemented and verified automatically , but they are still non - trivial . therefore , for a slightly restricted class of dag protocols , we additionally derive a fairness criterion that is easy to verify .",
    "* contributions . *",
    "our main contributions are ( i ) the definition of a syntax and interleaving semantics of dag mpcs protocols ( section  [ sec : spec_exec_model ] ) ; ( ii ) the definition of the message complexity and parallel complexity of such protocols ( section  [ sec : complexity ] ) ; ( iii ) a method to derive a full mpcs specification from a _ skeletal graph _ , including the ttp logic ( section  [ sec : mpcs ] ) ; ( iv ) necessary and sufficient conditions for fairness of dag mpcs protocols ( section  [ sec : fairness ] ) ; ( v ) minimal complexity bounds for dag mpcs protocols ( section  [ sec : minimal_complexity ] ) ; ( vi ) novel fair mpcs protocols ( section  [ sec : constructions ] ) ; ( vii ) a software tool that verifies whether a given mpcs protocol is fair ( described in appendix  [ s : tool ] ) .",
    "we build on the body of work that has been published in the field of fair optimistic mpcs protocols in asynchronous networks .",
    "the first such protocols were proposed by baum - waidner and waidner  @xcite , viz .  a round - based broadcast protocol and a related round - based linear protocol .",
    "they showed subsequently  @xcite that these protocols are round - optimal .",
    "this is a complexity measure that is related to , but less general than , parallel complexity defined in the present paper .",
    "garay et al .  @xcite introduced the notion of _ abuse - free _ contract signing .",
    "they developed the technique of _ private contract signature _ and used it to create abuse - free two - party and three - party contract signing protocols .",
    "garay and mackenzie  @xcite proposed mpcs protocols which were later shown to be unfair using the model checker mocha and improved by chadha et al .",
    "mukhamedov and ryan  @xcite developed the notion of _ abort chaining attacks _ and used such attacks to show that chadha et al.s improved version does not satisfy fairness in cases where there are more than five signers .",
    "they introduced a new optimistic mpcs protocol and proved fairness for their protocol by hand and used the nusmv model checker to verify the case of five signers .",
    "zhang et al .",
    "@xcite have used mocha to analyze the protocols of mukhamedov and ryan and of mauw et al .  @xcite .",
    "mauw et al .",
    "@xcite used the notion of abort chaining to establish a lower bound on the message complexity of linear fair mpcs protocols .",
    "this complexity measure is generalized in the present paper to dag mpcs protocols .",
    "kordy and radomirovi  @xcite have shown an explicit construction for fair linear mpcs protocols .",
    "the construction covers in particular the protocols proposed by mukhamedov and ryan  @xcite and the linear protocol of baum - waidner and waidner  @xcite , but not the broadcast protocols .",
    "the dag mpcs protocol model and fairness results developed in the present paper encompass both types of protocols .",
    "they allow for arbitrary combinations of linear and parallel behaviour ( i.e.  partial parallelism ) , and in addition allow for parallelism within signer roles .",
    "mpcs protocols combining linear and parallel behaviour have not been studied yet .    apart from new theoretical insights to be gained from designing and studying dag mpcs protocols , we anticipate interesting application domains in which multiple parties establish a number of related contracts , such as slas .",
    "emerging business models like software as a service require a negotiation to balance a customer s requirements against a service provider s capabilities .",
    "the result of such a negotiation is often complicated by the dependencies between several contracts  @xcite and multi - party protocols may serve to mitigate this problem .",
    "karaenke and kirn  @xcite propose a multi - tier negotiation protocol to mitigate the problems of overcommitment and overpurchasing .",
    "they formally verify that the protocol solves the two observed problems , but do not consider the fairness problem .",
    "slas and negotiation protocols have also been studied in the multi - agent community .",
    "an example is the work of kraus  @xcite who defines a multi - party negotiation protocol in which agreement is reached if all agents accept an offer . if the offer is rejected by at least one agent , a new offer will be negotiated .",
    "another interesting application area concerns _ supply chain contracting _  @xcite .",
    "a supply chain consists of a series of firms involved in the production of a product or service with potentially complex contractual relationships .",
    "most literature in this area focuses on economic aspects , like pricing strategies .",
    "an exception is the recent work of pavlov and katok  @xcite in which fairness is studied from a game - theoretic point of view .",
    "the study of multi - party signing protocols and multi - contract protocols has only recently been identified as an interesting research topic in this application area  @xcite .",
    "the purpose of a multi - party contract signing protocol is to allow a number of parties to sign a digital contract in a fair way . in this section",
    "we recall the basic notions pertaining to mpcs protocols .",
    "we use @xmath0 to denote the set of signers involved in a protocol , @xmath1 to denote the contract , and @xmath2 to denote the ttp .",
    "a signer is considered _ honest _",
    "( cf.definition  [ def : honestsigner ] ) if it faithfully executes the protocol specification .",
    "an mpcs protocol is said to be _",
    "optimistic _ if its execution in absence of adversarial behaviour and failures and with all honest signers results in signed contracts for all participants without any involvement of @xmath2 .",
    "optimistic mpcs protocols consist of two subprotocols : the _ main _ protocol that specifies the exchange of _ promises _ and _ signatures _ by the signers , and the _ resolve _ protocol that describes the interaction between the agents and @xmath2 in case of a failure in the main protocol .",
    "a promise made by a signer indicates the intent to sign @xmath1 .",
    "a promise @xmath3 can only be generated by signer @xmath4 .",
    "the content @xmath5 can be extracted from the promise and the promise can be verified by signer @xmath6 and by @xmath2 .",
    "a signature @xmath7 can only be generated by @xmath8 and by @xmath2 , if @xmath2 has a promise @xmath3 .",
    "the content @xmath9 can be extracted and the signature can be verified by anybody .",
    "cryptographic schemes that allow for the above properties are digital signature schemes and private contract signatures  @xcite .",
    "mpcs protocols must satisfy at least two security requirements , namely _ fairness _ and _ timeliness_. an optimistic mpcs protocol for contract @xmath1 is said to be _",
    "fair _ for an honest signer @xmath8 if whenever some signer @xmath10 obtains a signature on @xmath1 from @xmath8 , then @xmath8 can obtain a signature on @xmath1 from all signers participating in the protocol .",
    "an optimistic mpcs protocol is said to satisfy _ timeliness _ , if each signer has a recourse to stop endless waiting for expected messages .",
    "the fairness requirement will be the guiding principle for our investigations and timeliness will be implied by the communication model together with the behaviour of the ttp .",
    "a formal definition of fairness is given in section  [ sec : fairness ] .",
    "a further desirable property for mpcs protocols is abuse - freeness which was introduced in  @xcite .",
    "an optimistic mpcs protocol is said to be _ abuse - free _ , if it is impossible for any set of signers at any point in the protocol to be able to prove to an outside party that they have the power to terminate or successfully complete the contract signing .",
    "abuse - freeness is outside the scope of this paper .",
    "let @xmath11 with @xmath12 be a directed acyclic graph .",
    "let @xmath13 be vertices .",
    "we say that @xmath14 _ causally precedes _",
    "@xmath15 , denoted @xmath16 , if there is a directed path from @xmath14 to @xmath15 in the graph .",
    "we write @xmath17 for @xmath18 .",
    "we extend _ causal precedence _ to the set @xmath19 as follows . given two edges @xmath20 , we say that @xmath21 _ causally precedes _",
    "@xmath22 and write @xmath23 , if @xmath24",
    ". similarly , we write @xmath25 if @xmath26 and @xmath27 if @xmath24 .",
    "let @xmath28 .",
    "if @xmath29 causally precedes @xmath30 we also say that @xmath30 _ causally follows _",
    "we say that a set @xmath31 is _ causally closed _",
    "if it contains all causally preceding vertices and edges of its elements , i.e. , @xmath32 .",
    "by @xmath33 we denote the set of edges incoming to @xmath14 and by @xmath34 the set of edges outgoing from @xmath14 .",
    "formally , we have @xmath35 and @xmath36 .",
    "the communication between signers is asynchronous and messages can get lost or be delayed arbitrary long .",
    "the communication channels between signers and the ttp @xmath2 are assumed to be _ resilient_.",
    "this means that the messages sent over these channels are guaranteed to be delivered eventually . in order to simplify our reasoning",
    ", we assume that the channels between protocol participants are confidential and authentic .",
    "we consider the problem of delivering confidential and authentic messages in a dolev - yao intruder model to be orthogonal to the present problem setting .",
    "we assume that @xmath1 contains the contract text along with fresh values ( contributed by every signer ) which prevent different protocol executions from generating interchangeable protocol messages .",
    "furthermore we assume that @xmath1 contains all information that @xmath2 needs in order to reach a decision regarding the contract in case it is contacted by a signer .",
    "this information contains the protocol specification , an identifier for @xmath2 , identifiers for the signers involved in the protocol , and the assignment of signers to protocol roles in the protocol specification .",
    "we assume the existence of a designated resolution process per signer which coordinates the various resolution requests of the signer s parallel threads .",
    "it will ensure that @xmath2 is contacted at most once by the signer .",
    "after having received the first request from one of the signer s threads , this resolution process will contact @xmath2 on behalf of the signer and store @xmath2 s reply .",
    "this reply will be forwarded to all of the signer s threads whenever they request resolution .",
    "our dag protocol model is a multi - party protocol model in an asynchronous network with a ttp and an adversary that controls a subset of parties .",
    "a _ dag protocol specification _ ( or simply , a _ protocol specification _ ) is a directed acyclic graph in which the vertices represent the state of a signer and the edges represent either a causal dependency between two states ( an @xmath37-edge ) or the sending of a message .",
    "a vertex outgoing edges can be executed in parallel .",
    "edges labeled with @xmath38 denote that a signer contacts @xmath39 .",
    "[ def : parallel_prot_spec ] let @xmath40 be a set of roles such that @xmath41 and @xmath42 a set of messages .",
    "let @xmath37 and @xmath38 be two symbols , such that @xmath43 . by @xmath44 and @xmath45",
    "we denote the sets @xmath46 and @xmath47 , respectively .",
    "a _ dag protocol specification _ is a labeled directed acyclic graph @xmath48 , where    1 .",
    "@xmath49 is a directed acyclic graph ; 2 .",
    "@xmath50 is a labeling function assigning roles to vertices ; 3 .",
    "@xmath51 is an edge - labeling function that satisfies 1 .",
    "@xmath52 , 2 .",
    "@xmath53 ; 4 .",
    "@xmath54 is a function associated with @xmath38-labeled edges .",
    "a message edge @xmath55 specifies that @xmath56 is to be sent from role @xmath57 to role @xmath58 .",
    "an @xmath37-edge @xmath55 represents internal progress of role @xmath59 and allows to specify a causal order in the role s events .",
    "an exit edge denotes that a role can contact the ttp .",
    "the ttp then uses the function @xmath60 to determine a reply to the requesting role , based on the sequence of messages that it has received . in section",
    "[ sec : mpcs ] exit messages and the @xmath60 function are used to model the resolve protocol of the ttp .",
    "we give three examples of dag protocols in figure  [ fig : examples ] , represented as message sequence charts ( mscs ) .",
    "the dots denote the vertices , which we group vertically below their corresponding role names .",
    "vertical lines in the mscs correspond to @xmath37-edges and horizontal or diagonal edges represent message edges .",
    "we mark edges labeled with signing messages with an `` s '' and we leave out the edge labels of promise messages .",
    "we do not display exit edges , they are implied by the mpcs protocol specification .",
    "a box represents the splitting of a role into two parallel threads , which join again at the end of the box .",
    "we revert to a traditional representation of labeled dags if it is more convenient ( see , e.g. , figure  [ fig : exampledag ] ) .",
    "the first protocol in figure  [ fig : examples ] is a classical linear 2-party contract signing protocol .",
    "it consists of one round of promises followed by a round of exchanging signatures .",
    "the second protocol is the classical broadcast protocol for two signers .",
    "it consists of two rounds of promises , followed by one round of signatures .",
    "the third protocol is a novel dag protocol , showing the power of in - role parallelism .",
    "it is derived from the broadcasting protocol by observing that its fairness does not depend on the causal order of the first two vertices of each of the roles .",
    "let @xmath48 be a protocol specification .",
    "the _ restriction _ of @xmath61 to role @xmath8 , denoted by @xmath62 , is the protocol specification @xmath63 , where @xmath64    the execution state of a protocol consists of the set of events , connected to vertices or edges , that have been executed .",
    "let @xmath48 be a protocol specification .",
    "a _ state _ of @xmath61 is a set @xmath65 .",
    "the set of states of @xmath61 is denoted by @xmath66 . the _ initial state _ of @xmath61 is defined as @xmath67 .    in order to give dag protocols a semantics ,",
    "we first define the _ transition relation _ between states of a protocol .",
    "[ def : transition ] let @xmath48 be a protocol specification , @xmath68 @xmath69 the set of transition labels , and @xmath70 the states of @xmath61 .",
    "we say that @xmath61 transitions with label @xmath71 from state @xmath72 into @xmath73 , denoted by @xmath74 , iff @xmath75 and one of the following conditions holds    1 .",
    "@xmath76 and @xmath77 , such that @xmath78 and @xmath79 , 2 .",
    "@xmath80 and @xmath81 , such that @xmath82 , and @xmath83 , 3 .",
    "@xmath84 and @xmath85 , such that @xmath86 , @xmath87 and @xmath83 , 4 .",
    "@xmath88 and @xmath89 , such that @xmath90 and @xmath83 .    in definition  [ def : transition ] , receive events are represented by vertices , all other events by edges . by the first condition , a receive event can only occur if all events assigned to the incoming edges have occurred .",
    "in contrast , the sending of messages ( second condition ) can take place at any time .",
    "the third condition states that an @xmath37-edge can be executed if the event on which it causally depends has been executed .",
    "finally , like send events , an exit event can occur at any time .",
    "every event may occur at most once , however .",
    "this is ensured by the condition @xmath91 .",
    "the transitions model all possible behavior of the system",
    ". the behavior of honest agents in the system will be restricted as detailed in the following subsection .",
    "we denote sequences by @xmath92 $ ] and the concatenation of two sequences @xmath93 , @xmath94 by @xmath95 .",
    "[ def : prot_sem ] let @xmath48 be a protocol specification and @xmath96 @xmath69 a set of labels .",
    "the _ semantics _ of @xmath61 is the labeled transition system @xmath97 , which is a graph consisting of vertices @xmath66 and edges @xmath98 with start state @xmath99 .",
    "execution _ of @xmath61 is a finite sequence @xmath100 $ ] , @xmath101 , such that @xmath102 .",
    "the set of all executions of @xmath61 is denoted by @xmath103 .",
    "if @xmath104 $ ] is an execution of @xmath61 and @xmath62 is the restriction to role @xmath8 , then the _ restricted _ execution @xmath105 is obtained inductively as follows .    1 .   @xmath106_{p}=",
    "[ { \\mathit{s}}\\cap ( v_{p}\\cup e_{p})]$ ] for a state @xmath72 .",
    "2 .   @xmath107\\cdot \\sigma)_{p}= \\begin{cases } [ { \\mathit{s}}]_{p}\\cdot \\sigma_{p } & \\text { if } [ { \\mathit{s}}]_{p}= [ { \\mathit{s}}']_{p}\\\\ [ { \\mathit{s}}]_{p}\\cdot[\\alpha]\\cdot ( [ { \\mathit{s}}']\\cdot \\sigma)_{p } & \\text { else . }",
    "\\end{cases}$ ]    commutativity of restriction and execution is asserted by the following lemma .",
    "let @xmath61 be a protocol specification and @xmath62 the restriction to role @xmath8 .",
    "then every restricted execution @xmath105 is an execution of @xmath62 .",
    "an honest agent executes the protocol specification faithfully .",
    "the following definition specifies what this entails for a dag protocol : the agent waits for the reception of all causally preceding messages before sending causally following messages , does not execute an @xmath38 edge attached to a vertex @xmath14 if all messages at @xmath14 have been received and never executes more than one @xmath38 edge ( which in the context of mpcs protocols corresponds to contacting the ttp at most once ) , and does not send any messages which causally follow a vertex from which the @xmath38 edge was executed .",
    "[ def : honestsigner ]",
    "let @xmath61 be a dag protocol specification .",
    "an agent @xmath8 is _ honest _ in an execution @xmath108 of @xmath61 , if all states @xmath72 of the restricted execution @xmath105 satisfy the following conditions :    1 .",
    "@xmath72 contains at most one exit edge .",
    "2 .   if @xmath72 contains no exit edge , then @xmath72 is causally closed .",
    "if @xmath72 contains an exit edge @xmath109 , @xmath90 , then @xmath110 and @xmath111 is causally closed .    a dishonest agent is only limited by the execution model .",
    "thus a dishonest agent can send its messages at any time and in any order , regardless of the causal precedence given in the protocol specification .",
    "a dishonest agent can execute multiple @xmath38 edges and may send and receive messages causally following an exit edge .",
    "dishonest agents are controlled by a single adversary , their knowledge is shared with the adversary . the adversary can delay or block messages sent from one agent to another , but the adversary can not prevent messages between agents and the ttp from being delivered eventually .",
    "all communication channels are authentic and confidential .      to define measures for expressing the communication complexity of dag protocols , we introduce the notion of _ closed executions_. a closed execution is a complete execution of the protocol by honest agents .",
    "[ def : exe - closed ] let @xmath48 be a protocol specification and @xmath97 be the semantics for @xmath61 .",
    "given @xmath100\\in \\operatorname{\\operatorname{exe}({\\mathcal{p}})}$ ] , we say that @xmath108 is _ closed _ if the following three conditions are satisfied    1 .",
    "@xmath112 is causally closed , for every @xmath113 , 2 .",
    "@xmath114 , for every @xmath115 , 3 .",
    "@xmath116\\in\\operatorname{\\operatorname{exe}({\\mathcal{p}})}$ ] .",
    "the set of all closed executions of @xmath61 is denoted by @xmath117 .",
    "let @xmath100 $ ] be an execution of a protocol @xmath61 . by @xmath118",
    "we denote the number of labels @xmath119 , for @xmath115 , such that @xmath120 .",
    "[ lem : snd - count ] for any two closed executions @xmath108 and",
    "@xmath121 of a protocol @xmath61 we have @xmath122 .    the proof is given in the appendix",
    "the first measure expressing the complexity of a protocol @xmath61 is called _ message complexity_. it counts the overall number of messages that have been sent in a closed execution of a protocol @xmath61 .",
    "let @xmath61 be a protocol specification and let @xmath123 .",
    "the _ message complexity _ of @xmath61 , denoted by @xmath124 , is defined as @xmath125 .",
    "lemma  [ lem : snd - count ] guarantees that the message complexity of a protocol is well defined .",
    "the second complexity measure is called _",
    "parallel complexity_. it represents the minimal time of a closed execution assuming that all events which can be executed in parallel are executed in parallel",
    ". the parallel complexity of a protocol is defined as the length of a maximal chain of causally related send edges .",
    "the _ parallel complexity _ of a protocol @xmath61 , denoted by @xmath126 , is defined as @xmath127 \\in { \\ensuremath{e}}^ { * } } : \\\\",
    "\\forall_{1\\leq i \\leq n } : { \\mu}(e_{i } ) = { \\mathit{send}}\\wedge \\forall_{1\\leq i < n } : e_{i}\\prec e_{i+1}\\text{.}\\ ] ]    the message complexity of the first protocol in figure  [ fig : examples ] is 4 , which is known to be optimal for two signers  @xcite .",
    "its parallel complexity is 4 , too .",
    "the message complexity of the other two protocols is 6 , but their parallel complexity is 3 , which is optimal for broadcasting protocols with two signers  @xcite .",
    "we now define a class of optimistic mpcs protocols in the dag protocol model .",
    "the key requirements we want our dag mpcs protocol specification to satisfy , stated formally in definition  [ def : parallelmpcsspec ] , are as follows .",
    "the messages exchanged between signers in the protocol are of two types , promises , denoted by @xmath128 , and signatures , denoted by @xmath129 .",
    "every promise contains information about the vertex from which it is sent .",
    "this is done by concatenating the contract @xmath1 with the vertex @xmath14 the promise originates from and is denoted by @xmath130 .",
    "the signers can contact the ttp at any time .",
    "this is modeled with exit edges : every vertex @xmath131 such that @xmath132 ( the set of all signers ) is adjacent to a unique vertex @xmath133 , @xmath134 .",
    "the communication with @xmath2 is represented by @xmath60 .",
    "the set of vertices with outgoing signature messages is denoted by @xmath135 .",
    "[ def : parallelmpcsspec ] let @xmath48 be a protocol specification , @xmath136 be a finite set of signers , @xmath1 be a contract , and @xmath137 .",
    "@xmath61 is called a _",
    "dag mpcs protocol specification for @xmath1 , _ if   for unique existential quantification . ]    1 .",
    "[ cond : ttp ] @xmath138 , 2 .",
    "[ cond : transitivity ] @xmath139 , 3 .",
    "[ cond : elabel ] @xmath140 @xmath141 4 .",
    "@xmath142 , where @xmath143 denotes a list of signatures on @xmath1 , one by each signer .",
    "we write @xmath144 for the largest subset of @xmath135 which satisfies @xmath145 the set @xmath144 is called the _",
    "signing set_.    we represent dag mpcs protocols as _ skeletal _ graphs as shown in figure  [ fig : skeletal ] .",
    "the full graph , shown in figure  [ fig : full ] , is obtained from the skeletal graph by adding all edges required by condition  [ cond : transitivity ] of definition  [ def : parallelmpcsspec ] and extending @xmath146 according to condition  [ cond : elabel ] .",
    "the @xmath37 edges are dashed in the graphs .",
    "the shaded vertices in the graphs indicate the vertices that are in the signing set .",
    "+    we define the _ knowledge _ @xmath147 of a vertex @xmath14 to be the set of message edges causally preceding @xmath14 , and incoming to a vertex of the same role .",
    "the knowledge of a vertex represents the state right after its receive event .",
    "we define the _ pre - knowledge _ @xmath149 of a vertex @xmath14 to be @xmath150 .",
    "the pre - knowledge represents the state just _ before _ the vertex receive event has taken place .",
    "we extend both definitions to sets @xmath151 : @xmath152 we define the _ initial set _ of @xmath61 , denoted @xmath153 to be the set of vertices of the protocol specification for which the pre - knowledge of the same role does not contain an incoming edge by every other role .",
    "formally , @xmath154 the _ end set _ of @xmath61 , denoted @xmath155 , is the set of vertices of the protocol specification at which the corresponding signer possesses all signatures .",
    "let @xmath48 be a dag mpcs protocol specification .",
    "the resolve protocol is a two - message protocol between a signer and the ttp @xmath2 , initiated by the signer .",
    "the communication channels for this protocol are assumed to be resilient , confidential , and authentic .",
    "@xmath2 is assumed to respond immediately to the signer .",
    "this is modeled in @xmath61 via an exit edge from a vertex @xmath157 to the unique vertex @xmath133 .",
    "@xmath2 s response is given by the @xmath60 function , @xmath158 .",
    "if @xmath159 is the sequence of messages sent by the signers to @xmath2 , then @xmath160 is @xmath2 s response for the last signer in the sequence .",
    "the function will be stated formally in definition  [ def : ttpfun ] .",
    "we denote the resolve protocol in the following by @xmath161 .",
    "the signer initiating @xmath161 is @xmath162 .",
    "he sends the list of messages assigned to the vertices in his pre - knowledge @xmath149 , prepended by @xmath163 , to @xmath2 .",
    "this demonstrates that @xmath162 has executed all receive events causally preceding @xmath14 .",
    "we denote @xmath162 s message for @xmath2 by @xmath164 : @xmath165 the promise @xmath163 , which is the first element of @xmath164 , is used by @xmath2 to extract the contract @xmath1 , to learn at which step in the protocol @xmath162 claims to be , and to create a signature on behalf of @xmath162 when necessary .",
    "all messages received from the signers are stored .",
    "@xmath2 performs a deterministic decision procedure , shown in algorithm  [ algo : resolve ] , on the received message and existing stored messages and _ immediately _ sends back @xmath166 or the list of signatures @xmath143 .",
    "our decision procedure is based on  @xcite .",
    "the input to the algorithm consists of a message @xmath9 received by the @xmath2 from a signer and state information which is maintained by @xmath2 .",
    "@xmath2 extracts the contract and the dag mpcs protocol specification from @xmath9 . for each contract @xmath1",
    ", @xmath2 maintains the following state information .",
    "a list @xmath167 of all messages received from signers , a set @xmath168 of vertices the signers contacted @xmath2 from , a set @xmath169 of signers considered to be dishonest , and the last decision made @xmath170 .",
    "if @xmath2 has not been contacted by any signer regarding contract @xmath1 , then @xmath171 .",
    "else , @xmath170 is equal to @xmath166 or the list @xmath172 of signatures on @xmath1 , one by each signer .",
    "@xmath2 verifies that the request is legitimate in that the received message @xmath9 is valid and the requesting signer @xmath8 is not already considered to be dishonest .",
    "if these preliminary checks pass , the message is appended to @xmath167 .",
    "this is described in algorithm  [ algo : resolve ] in lines  [ line : rfirst ] through  [ line : evidence ] .",
    "the main part of the algorithm , starting at line  [ line : forcedabort ] , concerns the detection of signers who have continued the main protocol execution after executing the resolve protocol .",
    "if @xmath8 has not received a promise from every other signer in the protocol ( i.e.  the if clause in line  [ line : forcedabort ] is not satisfied ) , then @xmath2 sends back the last decision made ( line  [ line : retdecision ] ) .",
    "this decision is an token unless @xmath2 has been contacted before and decided to send back a signed contract .",
    "if @xmath8 has received a promise from every other signer , @xmath2 computes the set of dishonest signers ( lines  [ line : caughtrepeat1 ] through  [ line : caughtrepeat3 ] ) by adding to it every signer which has carried out the resolve protocol , but can be seen to have continued the protocol execution ( line  [ line : caughtrepeat2 ] ) based on the evidence the ttp has collected . if @xmath8 is the only honest signer that has contacted @xmath2 until this point in time , the decision is made to henceforth return a signed contract .",
    "@xmath173 @xmath174 @xmath175    [ def : ttpfun ]",
    "let @xmath48 be a dag mpcs protocol specification and @xmath176 the ttp decision procedure from algorithm  [ algo : resolve ] .",
    "then @xmath177 is defined for @xmath178 by @xmath179 where @xmath180 is the projection to the first coordinate and @xmath181 is defined inductively by @xmath182    thus the @xmath60 function represents the response of the ttp in the @xmath161 protocol for all executions of @xmath61 .",
    "we say that a dag mpcs protocol execution is fair for signer @xmath8 if one of the following three conditions is true : ( i ) no signer has received a signature of @xmath8 ; ( ii ) @xmath8 has received signatures of all other signers ; ( iii ) @xmath8 has not received an @xmath166 token from the ttp .",
    "the last condition allows an execution to be fair as long as there is a possibility for the signer to receive signatures of all other signers .",
    "the key problem in formalizing these conditions is to capture under which circumstances the ttp responds with an @xmath166 token to a request by a signer .",
    "the ttp s response is dependent on the decision procedure which in turn depends on the order in which the ttp is contacted by the signers .",
    "since the decision procedure is deterministic , it follows that the @xmath60 function can be determined for every execution @xmath183 $ ] by considering the pre - knowledge of the vertices from which the @xmath38 transitions are taken . abusing notation , we will write @xmath184 instead of @xmath185 where @xmath186 are the messages sent to the ttp at the @xmath187-th @xmath38 transition in the execution .",
    "[ def : fair - execution ] let @xmath2 be the ttp .",
    "an execution @xmath188 $ ] of @xmath61 is _ fair _ for signer @xmath8 if one of the following conditions is satisfied :    1 .",
    "@xmath8 has not sent a signature and no signer has received signatures from @xmath2 .",
    "@xmath189 2 .",
    "@xmath8 has received signatures from all other signers .",
    "@xmath190 3 .",
    "@xmath8 has not received an @xmath166 token from @xmath2 .",
    "@xmath191)\\neq{\\text{``abort''}}\\ ] ]    if none of these conditions are satisfied , the execution is unfair for @xmath8 .",
    "[ def : fairness ] an mpcs protocol specification @xmath61 is said to be fair , if every execution @xmath108 of @xmath61 is fair for all signers that are honest in @xmath108 .      by the ttp decision procedure",
    ", @xmath2 returns an token if contacted from a vertex @xmath192 .",
    "thus a necessary condition for fairness is that an honest signer executes all steps of the initial set causally before all steps of the signing set that are not in the end set : @xmath193 if @xmath8 contacts @xmath2 from a vertex @xmath194 , then @xmath2 responds with an token if it has already issued an token to another signer who is not in the set @xmath169 .",
    "this condition can be exploited by a group of dishonest signers in an _ abort chaining attack _",
    "the following definition states the requirements for a successful abort chaining attack .",
    "for ease of reading , we define the predicate @xmath195 .",
    "the predicate is true if there is no evidence ( pre - knowledge ) at the vertices in @xmath196 that the signer @xmath162 has sent a message at or causally after @xmath14 : @xmath197 this is precisely the criterion used by @xmath2 to verify honesty in algorithm  [ algo : resolve ] , line  [ line : caughtrepeat2 ] .",
    "[ def : pacseq ]",
    "let @xmath1 be a contract and @xmath198 .",
    "a sequence @xmath199 over @xmath200 is called an abort - chaining sequence ( ac sequence ) for @xmath61 if the following conditions hold :    1 .",
    "[ paccond : forcedabort ] signer @xmath201 receives an abort token : @xmath202 2 .   [ paccondition1 ] no signer contacts @xmath2 more than once : @xmath203 3 .",
    "[ paccondition4 ] the present and previous signer to contact @xmath2 are considered honest by @xmath2 : @xmath204 4 .",
    "[ pacconditionnew ] the last signer to contact @xmath2 has not previously received all signatures : @xmath205 5 .",
    "[ paccondition3 ] the last signer to contact @xmath2 has sent a signature before contacting @xmath2 or in a parallel thread : @xmath206    the ac sequence represents the order in which signers execute the resolve protocol with @xmath2 .",
    "a vertex @xmath207 in the sequence implies an exit transition via the edge @xmath208 in the protocol execution .",
    "an abort chaining attack must start at a step in which @xmath2 has no choice but to respond with an abort token due to lack of information .",
    "condition  [ paccond : forcedabort ] covers this .",
    "each signer may run the resolve protocol at most once .",
    "this is covered by condition  [ paccondition1 ] . to ensure that @xmath2 continues to issue tokens , condition  [ paccondition4 ]",
    "requires that there must always be a signer which according to @xmath2 s evidence has not continued protocol execution after contacting @xmath2 .",
    "to complete an abort chaining attack , there needs to be a signer which has issued a signature ( condition  [ paccondition3 ] ) , but has not received a signature ( conditions  [ pacconditionnew ] and  [ paccondition3 ] ) and will not receive a signed contract from @xmath2 because there is an honest signer ( by condition  [ paccondition4 ] ) which has received an @xmath166 token .",
    "it is not surprising ( but nevertheless proven in the appendix ) that a protocol with an ac sequence is unfair .",
    "however , the converse is true , too .",
    "[ th : fairness ] let @xmath61 be a dag mpcs protocol .",
    "then @xmath61 is fair if and only if it has no ac sequences .    the proof of this and the following theorems is given in the appendix .",
    "theorem  [ th : fairness ] reduces the verification of fairness from analyzing all executions to verifying that there is no ac - sequence ( definition  [ def : pacseq ] ) .",
    "this , however , is still difficult to verify in general .",
    "the following two results are tools to quickly assess fairness of dag mpcs protocols .",
    "the first is an unfairness criterion and the second is a fairness criterion for a large class of dag mpcs protocols .",
    "the following theorem states that in a fair dag mpcs protocol , the union of paths from the initial set to every vertex @xmath209 must contain all permutations of all signers ( other than @xmath162 ) as subsequences . in the class of linear mpcs protocols , considered in  @xcite ,",
    "this criterion was both necessary and sufficient .",
    "we show in example  [ ex : insufficient ] below that this criterion is not sufficient for fairness of dag mpcs protocols .    for @xmath210 , @xmath131 ,",
    "we denote by @xmath211 the set of all directed paths from a vertex in @xmath196 to @xmath14 .",
    "if @xmath212 is a sequence of vertices , we denote by @xmath213 the corresponding sequence of signers .",
    "the sequences of signers corresponding to the paths from @xmath196 to @xmath14 is denoted by @xmath214 .",
    "[ thm : unfairness ] let @xmath215 .",
    "let @xmath61 be an optimistic fair dag mpcs protocol , @xmath216 if @xmath209 , then for every permutation @xmath217 of signers in @xmath218 , there exists a sequence in @xmath219 which contains @xmath217 as a ( not necessarily consecutive ) subsequence .",
    "the converse of the theorem is not true as the following example shows . in particular",
    ", this example demonstrates that the addition of a vertex to a fair dag mpcs protocol does not necessarily preserve fairness .",
    "+   +    [ ex : insufficient ] the protocol in figure  [ fig : classical3top ] is fair by the results of  @xcite . by theorem  [ thm :",
    "unfairness ] , for every vertex @xmath209 every permutation of signers in @xmath220 occurs as a subsequence of a path in @xmath219 .",
    "the protocol in figure  [ fig : classical3withb ] is obtained by adding the vertex @xmath221 as a parallel thread of signer @xmath222 .",
    "thus the permutation property on the set of paths is preserved , yet the protocol is not fair : an ac sequence is @xmath223 .",
    "the vertex @xmath221 is in @xmath153 , the evidence presented to the ttp at @xmath224 includes the vertices causally preceding @xmath225 , thus @xmath222 is considered to be honest .",
    "the evidence presented by signer @xmath226 at @xmath227 are the vertices causally preceding @xmath228 proving that @xmath222 is dishonest , but @xmath229 is honest .",
    "thus @xmath226 has sent a signature at @xmath228 but will not receive signatures from @xmath222 and @xmath229 .",
    "if a protocol has no in - role parallelism , then the converse of theorem  [ thm : unfairness ] is true .",
    "thus we have a simple criterion for the fairness of such protocols .",
    "[ thm : fairness - causal ] let @xmath61 be an optimistic dag mpcs protocol without in - role parallelism .",
    "let @xmath216 if all paths from @xmath196 to @xmath209 contain all permutations of @xmath218 then @xmath61 is fair for @xmath162 .    by adding a causal edge between vertex @xmath221 and vertex @xmath230 of the protocol in figure  [ fig : classical3withb ] , as shown in figure  [ fig : classical3withbcausal ] , we obtain again a fair protocol .",
    "in this section we illustrate the theory and results obtained in the preceding sections by proving optimality results and constructing a variety of protocols .",
    "we prove lower bounds for the two complexity measures defined in our model , viz .",
    "parallel and message complexity .     a minimal 4-party fair broadcasting protocol .",
    "]    the minimal parallel complexity for an optimistic fair dag mpcs protocol is @xmath231 , where @xmath232 is the number of signers in the protocol .    by theorem  [ thm : unfairness ] , every permutation of signers in the protocol must occur as a subsequence in the set of paths from a causally last vertex in the initial set to a vertex in the signing set .",
    "since a last vertex @xmath14 in the initial set must have a non - empty knowledge @xmath147 , there must be a message edge causally preceding @xmath14 .",
    "there are at least @xmath233 edges in the path between the vertices associated with the @xmath232 signers in a permutation and there is at least one message edge outgoing from a vertex in the signing set .",
    "thus a minimal length path for such a protocol must contain @xmath231 edges .    the minimal parallel complexity is attained by the broadcast protocols of baum - waidner and waidner  @xcite .",
    "an example is shown in figure  [ fig : butterfly ] .",
    "[ thm : minimal_message_complexity ] the minimal message complexity for an optimistic fair dag mpcs protocol is @xmath234 , where @xmath232 is the number of signers in the protocol and @xmath235 is the length of the shortest sequence which contains all permutations of elements of an @xmath232-element set as subsequences .",
    "the minimal message complexities for @xmath236 are @xmath237 .",
    "the minimal message complexities for @xmath238 are smaller or equal to @xmath239 .",
    "note that while broadcasting protocols have a linear parallel complexity , they have a cubic message complexity , since in each of the @xmath231 rounds each of the @xmath232 signers sends a message to every other signer .",
    "linear protocols on the other hand have quadratic minimal message and parallel complexities . in the following",
    "we demonstrate that there are dag protocols which attain a linear parallel complexity while maintaining a quadratic message complexity .",
    "[ [ single - contractor - multiple - subcontractors . ] ] single contractor , multiple subcontractors .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a motivation for fair mpcs protocols given in  @xcite is a scenario where a single entity , here referred to as a contractor , would like to sign @xmath240 contracts with @xmath240 independent companies , in the following referred to as subcontractors .",
    "the contractor has an interest in either having all contracts signed or to not be bound by any of the contracts .",
    "the subcontractors have no contractual obligations towards each other .",
    "it would therefore be advantageous if there is no need for the subcontractors to directly communicate with each other .",
    "the solutions proposed in  @xcite are linear protocols .",
    "their message and parallel complexities are thus quadratic .",
    "linear protocols can satisfy the requirement that subcontractors do not directly communicate with each other only by greatly increasing the message and parallel complexities .",
    "the protocol we propose here is a dag , its message complexity is @xmath241 and its parallel complexity is @xmath242 for @xmath232 signers .",
    "it therefore combines the low parallel complexity typically attained by broadcasting protocols with the low message complexity of linear protocols .",
    "additionally , the protocol proposed does not require any direct communication between subcontractors .",
    "figure  [ fig : contractor ] shows a single contractor with three subcontractors .",
    "the protocol can be subdivided into five rounds , one round consisting of the subcontractors sending a message to the contractor followed by the contractor sending a message to the subcontractors . in the first four rounds promises",
    "are sent , in the final round signatures are sent .",
    "the protocol can be easily generalized to more than three subcontractors .",
    "for every subcontractor added , one extra round of promises needs to be included in the protocol specification .",
    "the protocol is fair by theorem  [ thm : fairness - causal ] .",
    "the msc shown in figure  [ fig : contractor ] resembles the skeletal graph from which it was built .",
    "the message contents can be derived by computing the full graph according to condition  [ cond : transitivity ] of definition  [ def : parallelmpcsspec ] .",
    "the result is as follows . in each round of the protocol ,",
    "each of the subcontractors sends to the contractor a promise for the contractor and for each of the other subcontractors .",
    "the contractor then sends to each of the subcontractors all of the promises received and his own promise .",
    "the final round is performed in the same manner , except that promises are replaced by signatures .",
    "[ [ two - contractors - with - joint - subcontractors . ] ] two contractors with joint subcontractors .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    figure  [ fig : two - twojoint ] shows a protocol where two contractors want to sign a contract involving two subcontractors .",
    "the subcontractors are independent of each other .",
    "after the initial step , where all signers send a promise to the first contractor @xmath226 , there are three protocol rounds , one round consisting of the contractor @xmath226 sending promises to the two subcontractors @xmath243 and @xmath244 in parallel which in turn send promises to the second contractor @xmath222 .",
    "a new round is started with the second contractor sending the promises received with his own promise to contractor @xmath226 .",
    "this protocol , too , can be generalized to several independent subcontractors . for every subcontractor",
    "added , one extra protocol round needs to be included in the protocol specification and each protocol step of the subcontractors executed analogously .     in - role parallelism . ]",
    "[ [ parallelism - within - a - role . ] ] parallelism within a role .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + +    figure  [ fig : subthree - crossed ] shows an example of a subcontracting protocol with in - role parallelism for the contractor role .",
    "the contractor initiates the protocol . in the indicated parallel phase",
    ", the contractor may immediately forward a promise by one of the subcontractors along with his own promise to the other subcontractor without waiting for the latter subcontractor s promise .",
    "the same is true in the signing phase .",
    "the fairness property for this protocol has been verified with a tool ( described in appendix  [ s : tool ] ) which tested fairness for each signer in all possible executions .",
    "we have identified fair subcontracting as a challenging new problem in the area of multi - party contract signing .",
    "we have made first steps towards solving this problem by introducing dag mpcs protocols and extending existing fairness results from linear protocols to dag protocols .",
    "for three typical subcontracting configurations we propose novel dag mpcs protocols that perform well in terms of message complexity and parallel complexity .",
    "fairness of our protocol schemes follows directly from our theoretical results and we have verified it for concrete protocols with our automatic tool .",
    "there are a number of open research questions related to fair subcontracting that we havent addressed .",
    "we mention two .",
    "the first concerns the implementation of multi - contracts . in our current approach",
    "we consider a single abstract contract shared by all parties .",
    "however , in practice such a contract may consist of a number of subcontracts that are accessible to the relevant signers only . how to cryptographically construct such contracts and what information these contracts should share is not evident .",
    "second , a step needs to be made towards putting our results into practice .",
    "given the application domains identified in this paper , we must identify the relevant signing scenarios and topical boundary conditions in order to develop dedicated protocols for each application area .",
    "we thank barbara kordy for her many helpful comments on this paper .",
    "10    n.  asokan . .",
    "thesis , univ . of waterloo , 1998 .",
    "b.  baum - waidner and m.  waidner .",
    "optimistic asynchronous multi - party contract signing .",
    "research report rz 3078 ( # 93124 ) , ibm zurich research laboratory , zurich , switzerland , november 1998 .",
    "b.  baum - waidner and m.  waidner .",
    "round - optimal and abuse free optimistic multi - party contract signing . in _",
    "automata , languages and programming  icalp 2000 _ , volume 1853 of _ lncs _ , pages 524535 .",
    "springer , july 2000 .",
    "r.  chadha , s.  kremer , and a.  scedrov .",
    "formal analysis of multi - party contract signing . in _ csfw04 _",
    ", page 266 , washington , dc , usa , 2004 .",
    "ieee .    s.  even and y.  yacobi .",
    "relations among public key signature systems .",
    "technical report 175 , computer science dept . ,",
    "technion , haifa , isreal , march 1980 .",
    "j.  garay , m.  jakobsson , and p.  mackenzie .",
    "abuse - free optimistic contract signing . in _ crypto99 _ ,",
    "volume 1666 of _ lncs _ , pages 449466 .",
    "springer , aug .",
    "j.  a. garay and p.  d. mackenzie .",
    "abuse - free multi - party contract signing . in",
    "_ 13th int .",
    "computing _ , volume 1693 of _ lncs _ , pages 151165 .",
    "springer , 1999 .",
    "p.  karaenke and s.  kirn . towards model checking & simulation of a multi - tier negotiation protocol for service chains . in _",
    "aamas 2010 _ , pages 15591560 .",
    "int . found . for autonomous agents and multiagent systems , 2010 .",
    "e.  katok and v.  pavlov .",
    "fairness in supply chain contracts : a laboratory study .",
    ", 31:129137 , 2013 .",
    "b.  kordy and s.  radomirovi .",
    "constructing optimistic multi - party contract signing protocols . in _",
    "csf 2012 _ , pages 215229 .",
    "ieee computer society , 2012 .",
    "s.  kraus .",
    "automated negotiation and decision making in multi - agent environments . in _",
    "acm multi - agent systems and applications _ , pages 150172 , 2001 .    h.  krishnan and r.  winter .",
    "the economic foundations of supply chain contracting . , 5(3 - 4):147309 , 2012 .",
    "k.  lu , r.  yahyapour , e.  yaqub , and c.  kotsokalis .",
    "structural optimisation of reduced ordered binary decision diagrams for sla negotiation in iaas of cloud computing . in _",
    "icsoc 2012 _ , volume 7636 of _ lncs _ , pages 268282 .",
    "springer , 2012 .",
    "s.  mauw and s.  radomirovi . .",
    "post 2015 _ , 2015 .",
    "s.  mauw , s.  radomirovi , and m.  t. dashti . minimal message complexity of asynchronous multi - party contract signing . in _",
    "csf09 _ , pages 1325 .",
    "ieee , 2009 .",
    "a.  mukhamedov and m.  ryan .",
    "improved multi - party contract signing . in",
    "financial cryptography _ ,",
    "volume 4886 of _ lncs _ , pages 179191 .",
    "springer , 2007 .",
    "a.  mukhamedov and m.  d. ryan .",
    "fair multi - party contract signing using private contract signatures .",
    ", 206(2 - 4):272290 , 2008 .",
    "s.  radomirovi . a construction of short sequences containing all permutations of a set as subsequences . ,",
    "19(4):paper 31 , 11 pp . , 2012 .",
    "m.  schunter . .",
    "phd thesis , universitt des saarlandes , 2000 .",
    "r.  seifert , r.  zequiera , and s.  liao .",
    "a three - echelon supply chain with price - only contracts and sub - supply chain coordination .",
    ", 138:345353 , 2012 .",
    "e.  yaqub , p.  wieder , c.  kotsokalis , v.  mazza , l.  pasquale , j.  rueda , s.g.gmez , and a.  chimeno . a generic platform for conducting sla negotiations .",
    "in _ service level agreements for cloud computing _ , pages 187206 .",
    "springer , 2011 .",
    "y.  zhang , c.  zhang , j.  pang , and s.  mauw .",
    "game - based verification of contract signing protocols with minimal messages .",
    ", 8(2):111124 , 2012 .",
    "we have developed a prototype tool in python 2 that model checks a skeletal protocol graph for the fairness property ( definition  [ def : fair - execution ] ) in the execution model defined in section  [ sec : spec_exec_model ] .",
    "the tool , along with specifications for the protocols presented in this paper , is available at http://people.inf.ethz.ch/rsasa/mpcs .    the tool s verification procedure works directly on the execution model and the ttp decision procedure ( algorithm  [ algo : resolve ] ) .",
    "it therefore provides evidence for the correctness of the protocols shown in section  [ sec : protocols ] , independent of the fairness proofs given in this paper .",
    "the verification is performed as follows .",
    "for each specified signer , the tool analyzes a set of executions in which the signer is honest and all other signers dishonest .",
    "the tool does not analyze all possible executions .",
    "it starts the analysis from the state where all promises of dishonest signers have been sent , but no protocol step has been performed by the honest signer . by analyzing this type of executions only , we do not miss any attacks , because the honest signers fairness is not invalidated until he has sent a signature . in this reduced set of executions ,",
    "the dishonest signers retain the possibility to contact the ttp from any of their vertices and all these possibilities are explored by the tool .",
    "we note that the same type of verification could be achieved with an off - the - shelf model checker and we would expect better performance in such a case",
    ". however , the code complexity and room for error when encoding a given protocol and ttp decision procedure in a model checker s input language is comparable to the code complexity of this self - contained tool .",
    "the mpcs protocols designed in this work allow for parallelism during the execution of the protocol .",
    "the specification language allows even for parallel threads to occur within a signer role .",
    "this allows us to model the case where a signer role represents multiple branches of the same entity .",
    "a signature issued by any branch represents the signature of the entire entity .",
    "we expect that the signing processes across branches are not easily synchronizeable with each other .",
    "such parallelism can be implemented in multiple ways .",
    "we discuss the various options and explain the choices made for this paper .    the first decision to be made",
    "is whether parallel threads of a signer role should be assumed to have shared knowledge . in this paper",
    ", we choose the weaker assumption : memory for a signer s parallel threads is local to the threads .",
    "this is in accordance with our expectation that parallel - threads are not easily synchronizeable and allows us , for instance , to specify and analyze protocols in which representatives of a signing entity can independently carry out parallel protocol steps without the need to communicate and synchronize their combined knowledge .",
    "causal dependence between two actions of a signer is explicitly indicated in the protocol specification .      1",
    ".   all threads of a signer immediately synchronize and stop executing whenever any of the threads intends to issue a resolve request to the ttp . a designated resolution process per signer",
    "will be required to continuously schedule all threads and take care of the interaction with the ttp .",
    "2 .   threads of a signer contact the signer s designated resolution process only when they intend to issue a resolve request .",
    "the resolution process will take of contacting the ttp ( only once per signer ) and distributing the ttp s reply upon request of the threads .",
    "3 .   threads of a signer are considered fully independent . a signer s threads are not orchestrated .",
    "the ttp may take into account that two requests can originate from the same signer , but from different ( causally not related ) threads .    in this paper",
    "we adopt the second option , which keeps the middle between the fully synchronized and fully desynchronized model .",
    "this will on the one hand allow for independent parallel execution of the threads and on the other hand minimize the impact of the signer s threading on the ttp s logic . from an abstract point of view",
    ", one could even argue that the second and third option are equivalent if we consider the signer s designated resolution processes just as part of a distributed ttp .",
    "we assume that the communication between a thread and the designated resolution process is resilient .",
    "the class of dag mpcs protocols defined in section  [ sec : mpcs ] is restricted by condition  [ cond : transitivity ] of definition  [ def : parallelmpcsspec ] .",
    "it requires that every signer @xmath8 sends a message to all subsequent , causally following signers occurring before signer @xmath8 s next step .",
    "while there are fair dag mpcs protocols which do not belong to this restricted class , such protocols are not going to have a lower communication complexity .",
    "the reason for this is that each message received by a signer serves as evidence for the ttp that the sender has executed the protocol up to a certain step .",
    "skipping such a message thus lengthens the protocol , because the evidence is available only at a later vertex .",
    "furthermore , the restriction simplifies the reasoning about fairness in that causal precedence @xmath16 between vertices @xmath245 is enough to guarantee that there is a message sent from signer @xmath162 to signer @xmath246 at some point between the execution of @xmath14 and the execution of @xmath15 .",
    "finally , it also permits one to design , characterize , and represent protocols using skeletal graphs rather than full graphs as displayed in figure  [ fig : exampledag ] .",
    "the set @xmath247 is the set of vertices in @xmath248 which do not have any causally following vertices in @xmath248 and we will refer to it as the set of _ maximal vertices _ of @xmath248 . similarly , @xmath249 is the set of vertices in @xmath248 which do not have any causally preceding vertices in @xmath248 and will be referred to as the set of _ minimal vertices _ of @xmath248 .",
    "conditions  [ paccond : forcedabort ] through  [ paccondition4 ] imply that the ttp decision procedure leads to an token for the last signer to contact the ttp .",
    "the remaining two conditions imply that the last signer has sent a signature , but not received a signature .    to complete the proof , we need to construct an execution in which the exit transitions occur in the order indicated by the ac sequence and signer @xmath250 is honest .",
    "let @xmath251 be an ac sequence . for each vertex @xmath207 in the ac sequence ,",
    "let @xmath252 be the causal closure of @xmath253 in @xmath19 .",
    "note that the union of causally closed sets is causally closed .",
    "let @xmath254 be the sequence of transitions @xmath255 without exit transitions and such that all states are causally closed .    for @xmath115 and",
    "@xmath256 $ ] , let @xmath257 @xmath258 $ ] .",
    "that is , @xmath259 is equal to @xmath254 , except for an additional exit transition @xmath260 and additional exit edges in all states which stem from exit transitions added to @xmath261 . finally , for @xmath262 $ ] , let @xmath263 $ ] .",
    "then @xmath264 is an execution in which signer @xmath250 is honest , since the restricted execution is by construction causally closed in all states before the last state and the single exit transition occurs in the last transition .",
    "let @xmath100 $ ] be an execution of @xmath61 .",
    "it is sufficient to show that if @xmath108 is closed , it contains all send events exactly once . according to definition  [ def : transition ] , we know that for every @xmath265 we have @xmath266",
    "this implies that , in any execution , each step of the protocol ( in particular every send event ) can be executed at most once .",
    "furthermore , if @xmath108 is closed , the third condition from definition  [ def : exe - closed ] implies that , every send event has already occurred in @xmath108 .",
    "otherwise , there exists @xmath267 such that @xmath268 and @xmath108 can be extended to @xmath269\\in\\operatorname{\\operatorname{exe}({\\mathcal{p}})}$ ] , which contradicts the closedness of @xmath108 .",
    "suppose there exists a permutation @xmath217 of signers in @xmath218 which is not a subsequence of any sequence in @xmath278 .",
    "we construct an ac sequence as follows .",
    "let @xmath279 be the set of all vertices of @xmath280 in @xmath196 . for @xmath281",
    ", let @xmath282 be the minset of all vertices of @xmath283 which causally follow a vertex of @xmath284 , i.e. @xmath285 . since for every signer there exists a vertex which causally follows @xmath272 , it follows that for some @xmath286 , there exists a vertex @xmath287 with @xmath288 .",
    "( else we have contradiction to the assumption that @xmath217 is a missing permutation in @xmath278 . )",
    "thus we obtain a sequence @xmath289 , where @xmath290 , @xmath291 , which is an ac sequence .",
    "it suffices to verify the statement for a subset of all vertices in @xmath144 by the following two facts : * fact 1 : * let @xmath209 be a causally earliest vertex of a signer from which a signature is sent , i.e. @xmath292 . if @xmath219 contains all permutations of signers in @xmath218 , then @xmath293 contains all such permutations of signers for all @xmath294 with @xmath291 .",
    "* fact 2 : * if @xmath209 such that for every signer @xmath295 there is a vertex @xmath296 for which @xmath293 contains all permutations of signers in @xmath297 , then @xmath219 contains all permutations of signers in @xmath218 .",
    "since @xmath14 is a causally earliest vertex of a signer from which a signature is sent , it follows by the fact that the protocol is optimistic that for every signer other than @xmath162 there exists a vertex which causally follows @xmath14 or that there exists another vertex @xmath272 of signer @xmath162 from which a signature is sent such that @xmath299 and @xmath300 .",
    "we consider these two cases separately .    1 .   for every signer other than @xmath162 , there exists a vertex which causally follows @xmath14 .",
    "+ we split this case into two separate subcases depending on whether there exists a vertex @xmath273 of signer @xmath162 which causally follows @xmath14 .",
    "1 .   @xmath301 .",
    "let @xmath217 be a permutation of signers in @xmath218 and suppose towards a contradiction that the permutation does not appear as a subsequence of any sequence in @xmath219 .",
    "we construct an ac sequence as follows .",
    "let @xmath279 be the set of all vertices of @xmath280 in @xmath196 .",
    "for @xmath281 , let @xmath282 be the minset of all vertices of @xmath283 which causally follow a vertex of @xmath284 , i.e. @xmath302 . + since for every signer there exists a vertex which causally follows @xmath14 , it follows that for some @xmath286 there exists a vertex @xmath287 with @xmath303 , else we have contradiction to the assumption that the permutation @xmath217 is not a subsequence of any sequence in @xmath219 .",
    "+ by construction , there exists a vertex in @xmath304 which causally precedes @xmath305 and thus we obtain a sequence @xmath306 which is an ac sequence .",
    "2 .   @xmath307 .",
    "+ since the protocol is optimistic , there exists a vertex assigned to signer @xmath162 such that @xmath308 . since @xmath309",
    ", it follows that @xmath273 is not causally related to @xmath14 . by the remark preceding lemma  [ l : commonancestorperm ] , there exists a common ancestor @xmath272 or @xmath14 and @xmath273 and @xmath270 satisfy the hypothesis of the lemma .",
    "thus there exists a vertex @xmath15 causally preceding @xmath14 such that @xmath293 contains all permutations of signers in @xmath218 and therefore @xmath219 contains all such permutations .",
    "there are causally unrelated vertices of signer @xmath162 from which signatures are sent .",
    "+ let @xmath310 be such a vertex . by equation   in section  [ sec :",
    "suffnec ] , there is a vertex @xmath15 assigned to signer @xmath162 which causally precedes all vertices of @xmath162 which are in @xmath144 .",
    "let @xmath272 be a maximal such vertex , i.e. for any vertex @xmath311 assigned to signer @xmath162 , there exists a vertex in @xmath144 of signer @xmath162 which does not causally follow @xmath272 .",
    "+ since the protocol is optimistic , for every signer @xmath8 in the protocol , there exists a vertex @xmath312 , @xmath313 which causally follows @xmath272 .",
    "+ then the vertices @xmath270 satisfy the hypothesis of lemma  [ l : commonancestorperm ] , thus there exists a vertex @xmath15 causally preceding @xmath14 such that @xmath293 contains all permutations of signers in @xmath218 and therefore @xmath219 contains all such permutations .",
    "suppose that the protocol is not fair .",
    "consider a shortest ac sequence , @xmath314 , @xmath315 . since the sequence is a shortest sequence , we have that @xmath316 , else @xmath317 would be a shorter ac sequence .",
    "consider the permutation of signers @xmath318 corresponding to the ac sequence , i.e. @xmath319 .",
    "let @xmath320 be the unique vertex in @xmath321 existence of a vertex in the set follows from the fact that the protocol is optimistic , uniqueness follows from the fact that there is no in - role parallelism , i.e.  the vertices assigned to a particular signer are totally ordered . by hypothesis , the set of paths from @xmath196 to @xmath320 contains all permutations of signers @xmath218 .",
    "let @xmath322 be the vertices associated with one such permutation .",
    "note that either @xmath323 or we can find @xmath324 , @xmath325 and @xmath326 .",
    "thus we may assume @xmath323 .",
    "we have @xmath327 .",
    "we also have @xmath328 , else condition  [ paccondition4 ] for @xmath314 being an ac sequence ( definition  [ def : pacseq ] ) would be violated .",
    "thus we have @xmath329 .",
    "this forms the basis for the inductively constructed sequence @xmath330 : given @xmath331 , satisfying @xmath332 , let @xmath333 be the unique vertex in @xmath334 .",
    "existence of a vertex in the set follows from @xmath335 and uniqueness follows from the lack of in - role parallelism . by construction , @xmath336 .",
    "if @xmath281 , then we also have @xmath337 , else condition  [ paccondition4 ] for @xmath314 being an ac sequence ( definition  [ def : pacseq ] ) would be violated .",
    "[ l : singlecomponent ] let @xmath342 be the dag of a fair optimistic dag mpcs protocol for two or more signers .",
    "let @xmath343 , where @xmath344 and @xmath345 , be the dag obtained by removing the ttp vertex and corresponding edges . then @xmath346 is a single connected component .",
    "* @xmath291 .",
    "then @xmath348 is an ac sequence . *",
    "let @xmath273 be a vertex such that @xmath350 and @xmath351 .",
    "such a vertex exists , because the protocol is optimistic , thus there must be a vertex of signer @xmath162 receiving a signature .",
    "but such a vertex can not precede @xmath14 , because @xmath14 is a causally earliest vertex from which a signature is sent .",
    "+ consider two cases : * * @xmath352 : then @xmath353 is an ac sequence . *",
    "* @xmath354 : then @xmath15 and @xmath273 are in the same connected component and @xmath14 is in another connected component . if @xmath355 , then let @xmath356 be such that @xmath357 and @xmath358",
    ". else let @xmath359 .",
    "+ then @xmath360 is an ac sequence .",
    "the minimal message complexity has been derived for optimistic fair linear protocols in  @xcite .",
    "since these protocols are a subset of dag mpcs protocols we see that the same message complexity can be attained .",
    "we need to show that there are no optimistic dag mpcs protocols with lower message complexity . by theorem  [ thm :",
    "unfairness ] , every permutation of signers in the protocol must occur as a subsequence in the set of paths from a maximal vertex of the set of vertices of a signer in the initial set to a vertex in the signing set .",
    "consider any fair optimistic dag mpcs protocol @xmath361 .",
    "construct a linear dag @xmath362 by choosing any topologically sorted list @xmath363 of the vertices in @xmath364 and setting @xmath365 . since all permutations of signers occur along the paths in the dag @xmath364 under the labelling @xmath366 , they also occur in the topologically sorted list @xmath363 under the same labelling . since the dag is a single connected component by lemma  [ l : singlecomponent ] , the number of edges in @xmath367 is smaller or equal to the number of edges in @xmath368 .",
    "thus the message complexity of @xmath61 is greater than or equal to the message complexity of a protocol based on the linear dag @xmath362 ."
  ],
  "abstract_text": [
    "<S> multi - party contract signing ( mpcs ) protocols allow a group of signers to exchange signatures on a predefined contract . </S>",
    "<S> previous approaches considered either completely linear protocols or fully parallel broadcasting protocols . </S>",
    "<S> we introduce the new class of dag mpcs protocols which combines parallel and linear execution and allows for parallelism even within a signer role . </S>",
    "<S> this generalization is useful in practical applications where the set of signers has a hierarchical structure , such as chaining of service level agreements and subcontracting .    </S>",
    "<S> our novel dag mpcs protocols are represented by directed acyclic graphs and equipped with a labeled transition system semantics . </S>",
    "<S> we define the notion of _ abort - chaining sequences _ and prove that a dag mpcs protocol satisfies fairness if and only if it does not have an abort - chaining sequence . </S>",
    "<S> we exhibit several examples of optimistic fair dag mpcs protocols . </S>",
    "<S> the fairness of these protocols follows from our theory and has additionally been verified with our automated tool .    </S>",
    "<S> we define two complexity measures for dag mpcs protocols , related to execution time and total number of messages exchanged . </S>",
    "<S> we prove lower bounds for fair dag mpcs protocols in terms of these measures . </S>"
  ]
}