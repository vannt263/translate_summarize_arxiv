{
  "article_text": [
    "a quantum computer is a physical machine that can accept input states which represent a coherent superposition of many different possible inputs and subsequently evolve them into a corresponding superposition of outputs .",
    "computation , _",
    "i.e. _ a sequence of unitary transformations , affects simultaneously each element of the superposition , generating a massive parallel data processing albeit within one piece of quantum hardware  @xcite . this way quantum computers",
    "can efficiently solve some problems which are believed to be intractable on any classical computer  @xcite .",
    "apart from changing the complexity classes , the quantum theory of computation reveals the fundamental connections between the laws of physics and the nature of computation and mathematics  @xcite .    for the purpose of this paper",
    "a quantum computer will be viewed as a quantum network ( or a family of quantum networks ) composed of quantum logic gates ; each gate performing an elementary unitary operation on one , two or more two  state quantum systems called _ qubits _  @xcite .",
    "each qubit represents an elementary unit of information ; it has a chosen `` computational '' basis @xmath0 corresponding to the classical bit values @xmath1 and @xmath2",
    ". boolean operations which map sequences of 0 s and 1 s into another sequences of 0 s and 1 s are defined with respect to this computational basis .",
    "any unitary operation is reversible that is why quantum networks effecting elementary arithmetic operations such as addition , multiplication and exponentiation can not be directly deduced from their classical boolean counterparts ( classical logic gates such as and or or are clearly irreversible : reading @xmath2 at the output of the or gate does not provide enough information to determine the input which could be either @xmath3 or @xmath4 or @xmath5 ) .",
    "quantum arithmetic must be built from reversible logical components .",
    "it has been shown that reversible networks ( a prerequisite for quantum computation ) require some additional memory for storing intermediate results  @xcite .",
    "hence the art of building quantum networks is often reduced to minimising this auxiliary memory or to optimising the trade  off between the auxiliary memory and a number of computational steps required to complete a given operation in a reversible way .    in this paper",
    "we provide an explicit construction of several elementary quantum networks .",
    "we focus on the space complexity _",
    "i.e. _ on the optimal use of the auxiliary memory . in our constructions",
    ", we save memory by reversing some computations with different computations ( rather than with the same computation but run backwards  @xcite ) .",
    "the networks are presented in the ascending order of complication .",
    "we start from a simple quantum addition , and end up with a modular exponentiation @xmath6 where @xmath7 and @xmath8 are predetermined and known parameters .",
    "this particular operation plays an important role in shor s quantum factoring algorithm  @xcite and seems to be its most demanding part .",
    "the structure of the paper is as follows : in section  [ tools ] we define some basic terms and describe methods of reversing some types computation , in section  [ networks ] we provide a detailed description of the selected quantum networks and in section  [ complex ] we discuss their complexity .",
    "for completeness let us start with some basic definitions .",
    "a quantum network is a quantum computing device consisting of quantum logic gates whose computational steps are synchronised in time .",
    "the outputs of some of the gates are connected by wires to the inputs of others .",
    "the size of the network is its number of gates .",
    "the size of the input of the network is its number of input qubits _",
    "i.e. _ the qubits that are prepared appropriately at the beginning of each computation performed by the network .",
    "inputs are encoded in binary form in the computational basis of selected qubits often called a _ quantum register _ , or simply a _",
    "register_. for instance , the binary form of number @xmath9 is @xmath10 and loading a quantum register with this value is done by preparing three qubits in state @xmath11 stands for the direct product @xmath12 which denotes a quantum register prepared with the value @xmath13 .",
    "computation is defined as a unitary evolution of the network which takes its initial state `` input '' into some final state `` output '' .",
    "both the input and the output can be encoded in several registers . even when @xmath14 is a one  to ",
    "one map between the input @xmath15 and the output @xmath16 and the operation can be formally written as a unitary operator @xmath17 @xmath18 we may still need an auxiliary register to store the intermediate data .",
    "when @xmath14 is not a bijection we have to use an additional register in order to guarantee the unitarity of computation . in this case",
    "the computation must be viewed as a unitary transformation @xmath17 of ( at least ) two registers @xmath19 where the second register is of appropriate size to accommodate @xmath16 .    as an example , consider a function @xmath20 . a quantum network that effects",
    "this computation takes the value @xmath15 from a register and multiplies it by a parameter @xmath7 modulo another parameter @xmath8 .",
    "if @xmath7 and @xmath8 are coprime , the function is bijective in the interval @xmath21 , and it is possible to construct a network that writes the answer into the same register which initially contained the input @xmath15 ( as in the equation ( [ bij ] ) ) .",
    "this can be achieved by introducing an auxiliary register and performing @xmath22 then we can precompute @xmath23 , the inverse of @xmath7 modulo @xmath8 ( this can be done classically in an efficient way using euclid s algorithm  @xcite ) , and , by exchanging the two registers and applying @xmath24 to the resulting state , we obtain @xmath25 where @xmath26 is a unitary operation that exchanges the states of the two registers .",
    "thus , @xmath27 where the second register is treated as an internal part of the network ( temporary register ) .",
    "quantum networks for basic arithmetic operations can be constructed in a number of different ways .",
    "although almost any non - trivial quantum gate operating on two or more qubits can be used as an elementary building block of the networks  @xcite we have decided to use the three gates described in fig .",
    "[ basicgates ] , hereafter refered to as _",
    "elementary gates_. none of these gates is universal for quantum computation , however , they suffice to build any boolean functions as the toffoli gate alone suffices to support any _ classical _ reversible computation . the not and the control  not gates are added for convenience ( they can be easily obtained from the toffoli gates ) .",
    "the addition of two registers @xmath28 and @xmath29 is probably the most basic operation , in the simplest form it can be written as @xmath30 here we will focus on a slightly more complicated ( but more useful ) operation that rewrites the result of the computation into the one of the input registers , _",
    "i.e. _ @xmath31 as one can reconstruct the input @xmath32 out of the output @xmath33 , there is no loss of information , and the calculation can be implemented reversibly . to prevent overflows , the second register ( initially loaded in state @xmath29 )",
    "should be sufficiently large , _",
    "i.e. _ if both @xmath7 and @xmath34 are encoded on @xmath35 qubits , the second register should be of size @xmath36 .",
    "in addition , the network described here also requires a temporary register of size @xmath37 , initially in state @xmath38 , to which the carries of the addition are provisionally written ( the last carry is the most significant bit of the result and is written in the last qubit of the second register ) .",
    "the operation of the full addition network is illustrated in fig .",
    "[ plainadder ] and can be understood as follows :    * we compute the most significant bit of the result @xmath39 .",
    "this step requires computing all the carries @xmath40 through the relation @xmath41 and @xmath42 and @xmath43 , where @xmath44 , @xmath42 and @xmath40 represent the @xmath45th qubit of the first , second and temporary ( carry ) register respectively .",
    "[ carrysum]i ) illustrates the sub  network that effects the carry calculation .",
    "* subsequently we reverse all these operations ( except for the last one which computed the leading bit of the result ) in order to restore every qubit of the temporary register to its initial state @xmath38 .",
    "this enables us to reuse the same temporary register , should the problem , for example , require repeated additions . during the resetting process",
    "the other @xmath35 qubits of the result are computed through the relation @xmath46 xor @xmath42 xor @xmath43 and stored in the second register .",
    "this operation effectively computes the @xmath35 first digits of the sum ( the basic network that performs the summation of three qubits modulo @xmath47 is depicted in fig .",
    "[ carrysum]ii ) . )",
    "if we reverse the action of the above network ( _ i.e. _ if we apply each gate of the network in the reversed order ) with the input @xmath32 , the output will produce @xmath48 when @xmath49 .",
    "when @xmath50 , the output is @xmath51 , where @xmath36 is the size of the second register . in this case",
    "the most significant qubit of the second register will always contain @xmath2 . by checking this `` overflow bit '' it is therefore possible to compare the two numbers @xmath7 and @xmath34 ; we will use this operation in the network for modular addition .",
    "a slight complication occurs when one attempts to build a network that effects @xmath52 where @xmath53 . as in the case of the plain adder",
    ", there is no a priori violation of unitarity since the input @xmath32 can be reconstructed from the output @xmath54 , when @xmath55 ( as it will always be the case ) .",
    "our approach is based on taking the output of the plain adder network , and subtracting @xmath8 , depending on whether the value @xmath39 is bigger or smaller than @xmath8 .",
    "the method , however , must also accomodate a superposition of states for which some values @xmath39 are bigger than @xmath8 and some smaller than @xmath8 .",
    "[ addmodn ] illustrates the various steps needed to implement modular addition .",
    "the first adder performs a plain addition on the state @xmath56 returning @xmath57 ; the first register is then swapped with a temporary register formerly loaded with @xmath8 , and a subtractor ( _ i.e. _ an adder whose network is run backwards ) is used to obtain the state @xmath58 . at this stage the most significant bit of the second register indicates whether or not an overflow occurred in the subtraction , _",
    "i.e. _ whether @xmath39 is smaller than @xmath8 or not .",
    "this information is `` copied '' into a temporary qubit @xmath59 ( initially prepared in state @xmath38 ) through the control  not gate .",
    "conditionally on the value of this last qubit @xmath59 , @xmath8 is added back to the second register , leaving it with the value @xmath60 .",
    "this is done by either leaving the first register with the value @xmath8 ( in case of overflow ) , or resetting it to @xmath1 ( if there is no overflow ) and then using a plain adder .",
    "after this operation , the value of the first register can be reset to its original value and the first and the temporary register can be swapped back , leaving the first two registers in state @xmath61 and the temporary one in state @xmath38 . at this point",
    "the modular addition has been computed , but some information is left in the temporary qubit @xmath59 that recorded the overflow of the subtraction .",
    "this temporary qubit can not be reused in a subsequent modular addition , unless it is coherently reset to zero .",
    "the last two blocks of the network take care of this resetting : first the value in the first register ( @xmath62 ) is subtracted from the value in the second ( @xmath63 ) yielding a total state @xmath64 . as before , the most significant bit of the second register contains the information about the overflow in the subtraction , indicating whether or not the value @xmath8 was subtracted after the third network . this bit",
    "is then used to reset the temporary bit @xmath59 to @xmath38 through a second control  not gate .",
    "finally the last subtraction is undone , returning the two registers to the state @xmath65 .",
    "function @xmath66 can be implemented by repeated conditional additions ( modulo @xmath8 ) : @xmath67 .",
    "starting from a register initially in the state @xmath38 , the network consists simply of @xmath35 stages in which the value @xmath68 is added conditionally , depending on the state of the qubit @xmath69 .",
    "[ controlmult ] shows the corresponding network ; it is slightly complicated by the fact that we want the multiplication to be effected conditionally upon the value of some external qubit @xmath70 , namely , we want to implement @xmath71 to account for this fact at the @xmath45th modular addition stage the first register is loaded with the value @xmath68 if @xmath72 and with value @xmath1 otherwise .",
    "this is done by applying the toffoli gate to the control qubits @xmath70 and @xmath69 and the appropriate target qubit in the register ; the gate is applied each time value",
    "`` @xmath2 '' appears in the binary form of the number @xmath73 .",
    "resetting the register to its initial state is done by applying the same sequence of the toffoli gates again ( the order of the gates is irrelevant as they act on different target qubits ) .",
    "if @xmath74 only @xmath1 values are added at each of the @xmath35 stages to the result register giving state @xmath75 . since we want",
    "the state to be @xmath76 we copy the content of the input register to the result register if @xmath74 .",
    "this last operation is performed by the rightmost elements of the network of fig .",
    "[ controlmult ] .",
    "the conditional copy is implemented using an array of toffoli gates .",
    "a reversible network that computes the function @xmath77 can now be designed using the previous constructions .",
    "notice first that @xmath78 can be written as @xmath79 , thus modular exponentiation can be computed by setting initially the result register to @xmath80 , and successively effecting @xmath35 multiplications by @xmath81 ( modulo @xmath8 ) depending on the value of the qubit @xmath69 ; if @xmath82 , we want the operation @xmath83 to be performed , otherwise , when @xmath84 we just require @xmath85 note that in both cases the result can be written as @xmath86 . to avoid an accumulation of intermediate data in the memory of the quantum computer , a particular care should be taken to erase the partial information generated .",
    "this is done , as explained in sect .",
    "[ tools ] , by running backwards a controlled multiplication network with the value @xmath87 .",
    "this quantity can be efficiently precomputed in a classical way  @xcite .",
    "[ modexp ] shows the network for a complete modular exponentiation .",
    "it is made out of @xmath88 stages ; each stage performs the following sequence of operations : @xmath89",
    "the size of the described networks depends on the size of their input @xmath35 .",
    "the number of elementary gates in the plain adder , the modular addition and the controlled ",
    "modular addition network scales linearly with @xmath35 .",
    "the controlled modular multiplication contains @xmath35 controlled modular additions , and thus requires of the order of @xmath90 elementary operations .",
    "similarly the network for exponentiation contains of the order of @xmath35 controlled modular multiplications and the total number of elementary operations is of the order of @xmath91 .",
    "the multiplicative overhead factor in front depends very much on what is considered to be an elementary gate .",
    "for example , if we choose the control  not to be our basic unit then the toffoli gate can be simulated by @xmath9 control  not gates  @xcite .",
    "let us have a closer look at the memory requirements for the modular exponentiation ; this can help to asses the difficulty of quantum factorisation .",
    "we set @xmath35 to be the number of bits needed to encode the parameter @xmath8 of eq .",
    "( [ unitary ] ) . in shor",
    "s algorithm , @xmath15 can be as big as @xmath92 , and therefore the register needed to encode it requires up to @xmath93 qubits .",
    "not counting the two input registers and an additional bit to store the most significant digit of the result , the plain adder network requires an extra @xmath94qubit temporary register for storing temporary ( carry ) qubits .",
    "this register is reset to its initial value , @xmath38 , after each operation of the network and can be reused later .",
    "the modular addition network , in addition to the temporary qubit needed to store overflows in subtractions , requires another @xmath35qubit temporary register ; in total this makes two @xmath35qubit temporary registers for modular addition . controlled modular multiplication is done by repeated modular additions , and requires three temporary @xmath35qubit registers : one for its own operation and two for the modular addition ( controlled modular multiplication also requires a temporary qubit used by the modular addition network ) .",
    "finally , the network for exponentiation needs four temporary @xmath35qubit registers , one for its own operation and three for the controlled modular multiplication ( plus an additional qubit used by the modular addition ) . altogether",
    "the total number of qubits required to perform the first part of the factorisation algorithm is @xmath95 , where @xmath96 qubits are used to store @xmath15 , @xmath35 qubits store the result @xmath97 and @xmath98 qubits are used as temporary qubits .",
    "the networks presented in this paper are by no means the only or the most optimal ones .",
    "there are many ways to construct operation such as @xmath99 , given parameters @xmath7 and @xmath8 .",
    "usually a dedicated network composed of several sub  units does not have to be a simple sum of the sub  units . in the modular exponentiation , for example",
    ", it is relatively easy to reduce the memory _",
    "i.e. _ the constant overhead factor ( @xmath100 in our case ) by noting that the first register in the plain adder network always stores specific classical values : either @xmath1 and @xmath8 .",
    "the same holds for the temporary register in the adder modulo @xmath8 which always stores either @xmath1 and @xmath101 .",
    "there is no need to use a full quantum register for this : a classical register plus a single qubit ( that keeps track of the entanglement ) are sufficient .",
    "this reduces the number of qubits to @xmath102 .",
    "one further register can be removed by using the addition network that does not require a temporary register  @xcite ; the trick is to use the @xmath35bit toffoli gates to add @xmath35bit numbers .",
    "if the difficulty of the practical implementations of the @xmath35bit toffoli gates is comparable to that of the regular toffoli gate , then this can be a good way of saving memory .",
    "all together the number of qubits can be reduced from @xmath95 to @xmath103 .",
    "this means that apart from the register storing @xmath15 and another one storing @xmath97 we need additional @xmath104 temporary qubits to perform quantum modular exponentiation in shor s algorithm .",
    "the required memory grows only as a linear function of the size of @xmath8 .",
    "in this paper we have explicitly constructed quantum networks performing elementary arithmetic operations including the modular exponentiation which dominates the overall time and memory complexity in shor s quantum factorisation algorithm .",
    "our network for the modular exponentiation achieves only a linear growth of auxiliary memory by exploiting the fact that @xmath66 is a bijection ( when @xmath7 and @xmath8 are coprime ) and can be made reversible by simple auxiliary computations . in more practical terms",
    "our results indicate that with the `` trapped ions computer ''  @xcite about @xmath105 ions suffice ( at least in principle ) to factor @xmath106 .",
    "needless to say , the form of the actual network that will be used in the first quantum computer will greatly depend on the type of technology employed ; the notion of an optimal network is architecture dependent and any further optimisation has to await future experimental progress .",
    "v.  v. thanks the royal society for the vacation scholarship which enabled him to undertake the research project on the subject of the paper .",
    "a.  b. acknowledges the financial support of the berrows fund at lincoln college , oxford .",
    "d.  deutsch and r.  jozsa , proc .",
    "a * 439 * , 553 ( 1992 ) ; e.  bernstein and u.  vazirani , in _ proc .",
    "25th acm symposium on the theory of computation _ , 11 ( 1993 ) ; d.s .",
    "simon , _ proceedings of the 35th annual symposium on the foundations of computer science _ , edited by s.  goldwasser ( ieee computer society press , los alamitos , ca ) , 16 ( 1994 ) ;                a.  barenco , proc .",
    "a , * 449 * , 679 ( 1995 ) ; t.  sleator and h.  weinfurter , phys .",
    "lett . * 74 * 4087 ( 1995 ) ; d.  deutsch , a.  barenco and a.  ekert , proc .",
    "a * 449 * 669 ( 1995 ) ; s.  lloyd , phys .",
    "lett . * 75 * , 346 ( 1995 ) ."
  ],
  "abstract_text": [
    "<S> quantum computers require quantum arithmetic . we provide an explicit construction of quantum networks effecting basic arithmetic operations : from addition to modular exponentiation . </S>",
    "<S> quantum modular exponentiation seems to be the most difficult ( time and space consuming ) part of shor s quantum factorising algorithm . </S>",
    "<S> we show that the auxiliary memory required to perform this operation in a reversible way grows linearly with the size of the number to be factorised . </S>"
  ]
}