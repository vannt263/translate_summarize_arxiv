{
  "article_text": [
    "[ [ what - is - the - borowsky - gafni - bg - simulation - and - why - is - it - important ] ] what is the borowsky - gafni ( bg ) simulation and why is it important ?",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    considering an asynchronous system where processes can crash , the @xmath5-set agreement problem is a basic distributed decision task defined as follows  @xcite .",
    "each of the @xmath2 processes proposes a value , and every process that does not crash has to decide a value ( termination ) , such that a decided value is a proposed value ( validity ) and at most @xmath6 different values are decided ( agreement ) .",
    "the consensus problem corresponds to the particular case @xmath7 .",
    "the @xmath5-set agreement is fundamental because it captures the essence of fault - tolerant distributed computability issues .",
    "a central question related to asynchronous distributed computability is the following : _ `` can we use a solution to the @xmath5-set agreement problem as a subroutine to solve the @xmath8-set agreement problem , when at most @xmath9 processes may crash ? '' _ ( `` is @xmath8-set agreement reducible to @xmath5-set agreement ? '' . ) the bg simulation ( initially sketched in  @xcite and then formalized in a journal version  @xcite , where , in addition , a formal definition of `` reducibility '' is given ) answers this fundamental question .",
    "it states that the answer is `` yes '' if @xmath10 and `` no '' if @xmath11 .",
    "as we can see , the answer `` yes '' does not depend on the number of processes .    to this end",
    ", the algorithm described in  @xcite allows @xmath0 processes to simulate a large number @xmath4 of asynchronous processes that communicate through read / write registers , and collectively solve a decision task , in the presence of at most @xmath1 crashes .",
    "each of the @xmath0 simulator processes simulates all the @xmath4 processes .",
    "these @xmath0 simulator processes cooperate through underlying objects that allow them to agree on a single output for each of the non - deterministic statements issued by every simulated process .",
    "( these underlying objects , called safe agreement objects , can be built of top of read / write atomic registers . )",
    "let bg(rw , c ) denote the basic bg simulation algorithm  @xcite ( rw stands for `` read / write communication '' , and c stands for `` crash failures '' ) .",
    "bg(rw , c ) is `` symmetric '' in the sense that each of the @xmath4 processes is simulated by every simulator , and the @xmath0 simulators are `` equal '' with respect to each simulated process , namely , ( 1 ) every simulator fairly simulates all the processes , and ( 2 ) the crash of a simulator entails the crash of at most one simulated process .",
    "this symmetry allows bg(rw , c ) to be suited to colorless tasks ( i.e. , distributed computing problems where the value decided by a process can be decided by any process  @xcite ) .",
    "bg(rw , c ) has then been extended to colored tasks ( i.e. , tasks such as renaming  @xcite , where a process can not systematically borrow its output from another process ) .",
    "extended bg simulation is addressed in  @xcite .",
    "algorithmic pedagogical presentations of the bg simulation can be found in  @xcite .",
    "a topological view on distributed computability issues in byzantine asynchronous message - passing systems has been recently presented in  @xcite .",
    "a pedagogical topology - based presentation of the bg - simulation is given in chapter 7 of  @xcite .",
    "[ [ what - is - learned - from - the - bg - simulation ] ] what is learned from the bg simulation + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the important lesson learned from the bg simulation is that , in a failure - prone context , what is important is not the number of processes but the maximal number of possible failures and the actual number of values that are proposed to a decision task .",
    "an interesting consequence of the bg simulation ( among several of its applications @xcite ) is the proof that there is no @xmath1-resilient @xmath5-set agreement algorithm for @xmath12 .",
    "this is obtained as follows .",
    "as ( 1 ) the bg simulation allows reducing the @xmath13-set agreement problem to the @xmath5-set agreement problem in a system with up to @xmath6 failures , and ( 2 ) the @xmath13-set agreement problem is known to be impossible in presence of @xmath6 failures @xcite , it follows that there is no @xmath6-resilient @xmath5-set agreement algorithm .",
    "[ [ content - of - the - paper - on - the - bg - simulation - side ] ] content of the paper : on the bg - simulation side + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    as already indicated , the bg simulation has been explored in asynchronous systems where processes ( 1 ) communicate through atomic read / write registers  @xcite , and ( 2 ) may commit only crash failures .",
    "this paper extends it in two directions .",
    "the first is the communication model , namely , it considers that processes cooperate by sending and receiving messages via asynchronous reliable channels .",
    "the second dimension is related to the type of failures ; more precisely , it considers two types of failures : process crash failures , and the more severe process byzantine failures .",
    "the paper presents the following contributions .",
    "a first is an algorithm , denoted bg(mp , c ) , which simulates the execution of a colorless task running in an asynchronous message - passing system of @xmath4 processes , where up to @xmath1 may crash , on top of an asynchronous message - passing system of @xmath2 processes where up to @xmath1 may crash .",
    "this simulation requires @xmath14 ( which is a necessary and sufficient condition to simulate read / write registers in asynchronous message - passing systems of @xmath2 processes  @xcite ) . while the number of simulated processes @xmath4 can be any integer , for the simulation to be non - trivial we consider that @xmath15 .",
    "a second contribution is an algorithm , denoted bg(mp , b ) , which simulates the execution of a colorless task running in an asynchronous message - passing system of @xmath4 processes , where up to @xmath1 may crash , on top of an asynchronous message - passing system of @xmath2 processes where up to @xmath1 may be byzantine  @xcite .",
    "this simulation requires @xmath16 ( according to the task which is simulated , additional constraint on @xmath1 may be needed , see  @xcite ; see also section  [ sec : conclusion ] ) . as in the case of bg(mp , c ) , and for the same reason , we consider that @xmath15 .",
    "this algorithm has two noteworthy features : it is the first bg simulation algorithm that considers byzantine failures , and it allows to run a crash - tolerant algorithm solving a colorless task on top of an asynchronous system prone to byzantine failures .",
    "both the algorithms bg(mp , c ) and bg(mp , b ) are _ genuine _ in the sense they do not rely on the simulation of an underlying shared memory .    while the full - information algorithm presented in  @xcite can be used to decide when there is a simulation between two models , the present paper is the first ( to our knowledge ) that allows the direct execution in the presence of byzantine failures of any crash - tolerant algorithm that solves a colorless task .",
    "bg(mp , b ) provides an algorithmic approach which complements the topology - based simulation framework of  @xcite , and may also be of practical interest .",
    "it has the interesting property that the simulation of a message only requires a polynomial number of messages in the base system , and the increase in size of these messages , when compared to the size of the simulated message , is also polynomial . additionally , differently from early works on byzantine failures like  @xcite",
    ", it does not use any cryptography - based mechanism .    [",
    "[ content - of - the - paper - on - the - safe - agreement - objects - side ] ] content of the paper : on the safe agreement objects side + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the core of the previous algorithms lies in new underlying safe agreement objects , which allow the @xmath2 simulators to agree on the next operation executed by each of the @xmath4 simulated processes .",
    "such a safe agreement object ensures that all the simulators produce the very same simulation . at the operational level",
    ", a safe agreement object provides processes with two operations , denoted @xmath17 and @xmath18 , which are invoked in this order by each correct process . the termination property associated with a safe agreement object",
    "@xmath19 is the following : if no simulator commits a failure while executing @xmath20 , then any invocation of @xmath21 by a non - faulty simulator terminates .",
    "moreover , no two correct processes decide differently .    on the algorithmic side ,",
    "a novelty of the paper lies in the algorithms implementing these new safe agreement objects . differently from their",
    "read / write memory counterparts , they are not based on underlying snapshot objects  @xcite .",
    "they instead rely heavily on message communication patterns inspired from the reliable broadcast algorithms introduced in  @xcite .",
    "a last and noteworthy contribution of the paper lies in the second algorithm ( which implements safe agreement in a byzantine message - passing system ) .",
    "this object is the core of a simulation when one wants to execute asynchronous read / write crash - tolerant algorithms on top of asynchronous message - passing systems prone to byzantine failures .    [ [ existing - simulations - considering - byzantine - failures ] ] existing simulations considering byzantine failures + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    simulations of crash failures in a byzantine system have been addressed in the context of synchronous systems  @xcite .",
    "the only articles we are aware of concerning such a simulation in asynchronous systems are  @xcite .",
    "as noticed in  @xcite , @xcite considers a restricted class of round - based deterministic algorithms .",
    "the simulation presented in  @xcite executes a full - information asynchronous crash - tolerant algorithm in an asynchronous byzantine failure - prone system .",
    "the article  @xcite considers an agent / host model and focuses mainly on reliable broadcast .",
    "[ [ roadmap ] ] roadmap + + + + + + +    the paper is composed of  [ sec : conclusion ] sections . section  [ sec : model ] presents both the crash - prone and the byzantine asynchronous message - passing models , and the notion of a task .",
    "section  [ sec : simu - structure ] presents the structure of the simulation algorithms .",
    "section  [ sec : bg - crash - model ] presents the simulation algorithm bg(mp , c ) , while section  [ sec : bg - byzantine - model ] presents the simulation algorithm bg(mp , b ) .",
    "finally , section  [ sec : conclusion ] addresses the computability implications of the byzantine - tolerant simulation and its underlying safe agreement object .",
    "[ [ computing - entities ] ] computing entities + + + + + + + + + + + + + + + + + +    the system is made up of a set @xmath22 of @xmath2 sequential processes , denoted @xmath23 , @xmath24 , ... , @xmath25 . these processes are asynchronous in the sense that each process progresses at its own speed , which can be arbitrary and remains always unknown to the other processes .    during an execution , processes may deviate from their specification . in that case",
    ", the corresponding processes are said to be _ faulty_. a process that does not deviate from its specification is _ correct _ ( or _ non - faulty _ ) .",
    "the model parameter @xmath1 denotes the maximal number of processes that can be faulty in a given execution .",
    "two failure types are considered below .",
    "[ [ communication - model ] ] communication model + + + + + + + + + + + + + + + + + + +    the processes cooperate by sending and receiving messages through bi - directional channels .",
    "the communication network is a complete network , which means that each process @xmath26 can directly send a message to any process @xmath27 ( including itself ) .",
    "each channel is reliable ( no loss , corruption , or creation of messages ) , not necessarily first - in / first - out , and asynchronous ( while the transit time of each message is finite , there is no upper bound on message transit times ) .",
    "the macro - operation `` @xmath28 type@xmath29 '' , where type is a message type and @xmath30 is its content , is a shortcut for the following statement : `` @xmath31 type@xmath29 to each process ( including itself ) '' .",
    "[ [ the - process - crash - failure - model ] ] the process crash failure model + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in the crash failure model , a process may prematurely stop its execution .",
    "a process executes correctly its algorithm until it possibly crashes . once crashed , a process remains crashed forever .",
    "it is assumed that at most @xmath1 processes may crash .",
    "if there is no specific constraint on @xmath1 , the corresponding model is denoted @xmath32 $ ] . when it is assumed that at most @xmath14 processes may crash ,",
    "the corresponding model is denoted @xmath33 $ ] .",
    "[ [ the - byzantine - failure - model ] ] the byzantine failure model + + + + + + + + + + + + + + + + + + + + + + + + + + +    a byzantine process is a process that behaves arbitrarily : it may crash , fail to send or receive messages , send arbitrary messages , start in an arbitrary state , perform arbitrary state transitions , etc .",
    "hence , a byzantine process , which is assumed to send the same message @xmath30 to all the processes , can send a message @xmath34 to some processes , a different message @xmath35 to another subset of processes , and no message at all to the other processes .",
    "moreover , byzantine processes can collude to `` pollute '' the computation .",
    "it is assumed that byzantine processes can not control the network , hence , when a process receives a message , it can unambiguously identify its sender . as previously , @xmath1 denotes the upper bound on the number of processes that may commit byzantine failures .",
    "if there is no constraint on @xmath1 , the corresponding model is denoted @xmath36 $ ] . when it is assumed that at most @xmath16 processes may be faulty ,",
    "the corresponding model is denoted @xmath37 $ ] .",
    "[ [ decision - tasks ] ] decision tasks + + + + + + + + + + + + + +    the problems we are interested in are called _ decision tasks _ ( the reader interested in a more formal presentation of decision tasks can consult the literature , e.g. , @xcite ) . in every run ,",
    "each process proposes a value and the proposed values define an input vector @xmath38 , where @xmath39 $ ] is the value proposed by process @xmath27 .",
    "let @xmath40 denote the set of allowed input vectors .",
    "each process has to decide a value .",
    "the decided values define an output vector @xmath41 , such that @xmath42 $ ] is the value decided by @xmath27 .",
    "let @xmath43 be the set of the output vectors .",
    "a decision task is a binary relation @xmath44 from @xmath40 into @xmath43 .",
    "a task is _ colorless _",
    "if , when a value @xmath45 is proposed by a process @xmath27 ( i.e. , @xmath39=v$ ] ) , then @xmath45 can be proposed by any number of processes and , when a value @xmath46 is decided by a process @xmath27 ( i.e. , @xmath42=v'$ ] ) , then @xmath46 can be decided by any number of processes .",
    "consensus , and more generally @xmath6-set agreement , are colorless tasks .",
    "otherwise the task is _ colored_. symmetry breaking and renaming are colored tasks  @xcite .",
    "[ [ algorithm - solving - a - task ] ] algorithm solving a task + + + + + + + + + + + + + + + + + + + + + + + +    an algorithm solves a task in a @xmath1-resilient environment if , given any @xmath47 , ( 1 ) each correct process @xmath27 decides a value @xmath48 , and ( 2 ) there is an output vector @xmath41 such that @xmath49 where @xmath41 is defined as follows . if @xmath27 decides @xmath48 , then @xmath50=o_j$ ] .",
    "if @xmath27 does not decide , @xmath42 $ ] is set to any value @xmath46 that preserves the relation @xmath49 .    considering a system of @xmath2 processes ,",
    "a task is @xmath1-resiliently solvable if there is an algorithm that solves it in the presence of at most @xmath1 faulty processes . as an example , consensus is not @xmath51-resiliently solvable in asynchronous crash - prone systems , be the communication medium a set of read / write registers  @xcite , or a message - passing system  @xcite .",
    "differently , renaming with @xmath52 new names is @xmath53-resiliently solvable in asynchronous read / write crash - prone systems  @xcite , and is @xmath1-resiliently solvable in asynchronous crash - prone message - passing systems for @xmath14  @xcite .",
    "[ [ aim ] ] aim + + +    let @xmath54 be an algorithm that solves a colorless decision task among @xmath4 processes in the system model @xmath55 $ ] .",
    "the aim is to design an algorithm that simulates @xmath54 in the system model @xmath33 $ ] ( resp . , @xmath37 $ ] ) .",
    "as already indicated , the corresponding simulation algorithm is denoted bg(mp , c ) in the first case , and bg(mp , b ) in the second case .",
    "[ [ notation ] ] notation + + + + + + + +    a simulated process is denoted @xmath27 , where @xmath56 .",
    "similarly , a simulator process ( `` simulator '' in short ) is denoted @xmath57 , where @xmath58 .",
    "the set @xmath22 denote the set of the simulator indexes , i.e. , @xmath59 .",
    "the safe agreement objects , build in the simulation and used by the simulators , are identified with upper case letters , e.g. , @xmath19 .",
    "the variables local to simulator @xmath60 is identified with lower case letters , and the resulting identifiers are subscripted with @xmath61 .",
    "[ [ behavior - of - a - simulator - q_i ] ] behavior of a simulator @xmath57 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    each simulator is given the code of all the simulated processes @xmath23 , ... , @xmath62 .",
    "it manages @xmath4 threads , one associated with each simulated process , and executes them in a fair way .",
    "the code of a simulated process @xmath27 contains local statements , send statements , and receive statements .",
    "it is assumed that the behavior of a simulated process @xmath27 is deterministic in the sense it is entirely defined from its local input ( as defined by the task instance ) , and the order in which @xmath27 receives messages .",
    "the simulation has to ensure that ( 1 ) all simulators simulate the same behavior of the set of simulated processes , and ( 2 ) a faulty simulator entails the failure of at most one simulated process .",
    "the way this is realized depends , of course , on the failure model that is considered .",
    "this section presents the algorithm bg(mp , c ) .",
    "as previously indicated , this algorithm simulates , in the model @xmath33 $ ] , an algorithm @xmath54 solving a task in @xmath55 $ ] .",
    "it is made up of two parts : an algorithm implementing a safe agreement object , and the simulation itself , which uses several of these objects to allow the simulators to cooperate .",
    "this object type ( or variants of it ) , briefly sketched in the introduction , is at the core of both the bg simulation  @xcite , and the liveness guarantees of concurrent objects  @xcite .",
    "it is a one - shot object that solves consensus in failure - free scenarios , and allows processes to agree with a weak termination guarantee in the presence of failures .",
    "a safe agreement object provides each simulator @xmath57 , @xmath63 , with two operations denoted @xmath17 and @xmath18 , that @xmath57 can invoke at most once , and in this order ; @xmath17 allows @xmath57 to propose a value , while @xmath18 allows it to decide a value . considering the crash failure model ,",
    "the properties associated with this object are the following ones .    *",
    "a decided value is a proposed value . *",
    "no two simulators decide distinct values . *",
    "propose - termination .",
    "an invocation of @xmath17 by a correct simulator terminates . * decide - termination .",
    "if no simulator crashes while executing @xmath17 , then any invocation of @xmath18 by a correct simulator terminates .",
    "it is easy to see that a safe agreement object is a consensus object whose termination condition is failure - dependent .",
    "algorithms implementing safe agreement objects ( or variants of it ) can be found in  @xcite .",
    "an algorithm implementing a safe agreement object in @xmath33 $ ] is described in figure  [ algo - sa - msg - passing - crash ] .",
    "[ [ local - data - structures ] ] local data structures + + + + + + + + + + + + + + + + + + + + +    each simulator @xmath57 , @xmath64 , manages three local data structures , namely , the arrays @xmath65 $ ] , @xmath66 $ ] , @xmath67 $ ] , all initialized to @xmath68 $ ] , where @xmath69 denotes a default value that can not be proposed to the safe agreement object by the simulators .    *",
    "the aim of @xmath70 $ ] is to contain , as currently known by @xmath57 , the value proposed to the safe agreement object by the simulator @xmath71 . *",
    "the aim of @xmath72 $ ] is to contain , as known by @xmath57 , the value proposed to the safe agreement object by the simulator @xmath71 , as witnessed by strictly more than @xmath73 distinct simulators ( i.e. , at least a correct process ) .",
    "* the aim of @xmath74 $ ] is to contain what to @xmath57 s knows about the view seen by @xmath71 .",
    "[ [ algorithm - the - operation - sf - propose ] ] algorithm : the operation @xmath17 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the algorithm implementing the operation @xmath17 invoked by a simulator @xmath57 is described at lines  c[sa - c-01]-c[sa - c-14 ] ( client side ) and lines  c[sa - c-20]-c[sa - c-22 ] ( server side ) .",
    "this algorithm is made up of three parts .",
    "+ first part . a simulator @xmath57 first broadcasts the message value @xmath75 , where @xmath76 is the value it proposes to the safe agreement object ( line  c[sa - c-01 ] ) .",
    "then , it waits until it knows that strictly more than @xmath73 simulators know its value ( line  c[sa - c-02 ] ) . on its `` server '' side ,",
    "when @xmath57 receives for the first time the message value @xmath77 , it first saves @xmath45 in @xmath70 $ ] ; then it forwards the received message to cope with the ( possible ) crash of @xmath71 ( this witnesses the fact that @xmath57 knows the value proposed by @xmath78 , line  c[sa - c-20 ] ) and  c[sa - c-20 ] implement a reliable broadcast of the message value @xmath75 .",
    "similarly , the lines  c[sa - c-12 ] and  c[sa - c-22 ] implement a reliable broadcast of the message view @xmath79 .",
    "it is easy to see that the cost of such a reliable broadcast is @xmath80 messages . ] ) .",
    "* operation * @xmath81 ( @xmath76 ) * is * + [ sa - c-01 ]  = @xmath82 value @xmath75 ; + [ sa - c-02 ] ( value @xmath75 @xmath83 from strictly more than @xmath73 different simulators ) ; + [ sa - c-03 ] @xmath84 $ ] * do * @xmath82 read @xmath85 * end for * ; + [ sa - c-04 ] @xmath84 $ ] * do * + [ sa - c-05 ] ( readanswer @xmath86 @xmath83 from strictly more than @xmath73 different simulators + [ sa - c-06 ] @xmath87 @xmath88 @xmath87 @xmath89 value @xmath90 @xmath83 from strictly more than @xmath73 different simulators ) ; + [ sa - c-07 ] ( predicate of line  c[sa - c-06 ] satisfied ) + [ sa - c-08 ] = @xmath72 \\gets w$ ] + [ sa - c-09 ] @xmath72 \\gets \\bot$ ] + [ sa - c-10 ] + [ sa - c-11 ] ; + [ sa - c-12 ] @xmath82 view @xmath79 ; + [ sa - c-13 ] ( view @xmath79 @xmath83 from strictly more than @xmath73 different simulators ) ; + [ sa - c-14 ] @xmath91 .",
    "+   + * operation * @xmath92 ( ) * is * + [ sa - c-15 ] ( @xmath93 a non - empty set @xmath94 : + [ sa - c-16 ]  @xmath95\\neq\\bot ) ~\\wedge~   \\big(\\forall~z\\in \\pi:~(all\\_views_i[y][z]\\neq\\bot )                                 \\rightarrow(z\\in \\sigma)\\big)\\big]$ ] ; + [ sa - c-17 ] @xmath96 * be * the set @xmath97 of smallest size ; + [ sa - c-18 ] @xmath98 * be * @xmath99 ~:~ y\\in min\\_\\sigma_i\\})$ ] ; + [ sa - c-19 ] @xmath100 .",
    "+   + % -",
    "+ * when the message * value @xmath77 * is * @xmath83 * for the first time * : + % `` for the first time '' is with respect to each pair of values @xmath77 % + [ sa - c-20 ] @xmath70 \\leftarrow v;$ ] @xmath82 value @xmath77 . +   + * when the message * read @xmath101 * is * @xmath83 * for the first time * : + [ sa - c-21 ] @xmath102 readanswer @xmath103)$ ] @xmath104 .",
    "+   + * when the message * view @xmath105 * is * @xmath83 * for the first time * : + [ sa - c-22 ] @xmath74 \\leftarrow view$ ] ; @xmath82 view @xmath105 .",
    "second part . in this part",
    ", @xmath57 builds a local view of the values proposed by the @xmath2 simulators . to this end , it first broadcasts messages read @xmath85 , @xmath106 , to learn the value proposed by each simulator @xmath71 ( line  c[sa - c-03 ] ) . on its server side ,",
    "when @xmath57 receives such a message , it broadcasts by return its current knowledge of the value proposed by @xmath71 ( line  c[sa - c-21 ] ) .",
    "then , the simulator @xmath57 builds its local view of the values that have been proposed . for each simulator @xmath71",
    ", @xmath57 waits until it has received from strictly more than @xmath73 distinct simulators the very same message , namely , either the message readanswer @xmath86 , or the message value @xmath90 ( lines  c[sa - c-05]-c[sa - c-06 ] ) . in the first case",
    ", @xmath57 considers that @xmath71 has not yet proposed a value , while in the second case it considers that @xmath71 proposed the value @xmath107 ( let us observe that , while @xmath57 can receive both readanswer @xmath86 and messages value @xmath90 , it stops waiting as soon as it received strictly more than @xmath73 of one of them ) ( lines  c[sa - c-07]-c[sa - c-10 ] ) .",
    "third part .",
    "finally , the simulator @xmath57 informs the other simulators on its local view @xmath66 $ ] . to this end , it broadcasts the message view @xmath79 .",
    "when it has received the corresponding `` acknowledgments '' , @xmath57 returns from its invocation of the operation @xmath17 ( line  c[sa - c-12]-c[sa - c-14 ] ) .",
    "( the behavior of @xmath57 when it receives a message view @xmath105 is similar to the one when it receives a message value @xmath77 .",
    "the only difference is that @xmath70 $ ] is now replaced by @xmath108 $ ] , line  c[sa - c-22 ] . )",
    "[ [ algorithm - the - operation - sf - decide ] ] algorithm : the operation @xmath18 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the algorithm implementing the operation @xmath18 is described at lines  c[sa - c-15]-c[sa - c-19 ] .",
    "it consists in a `` closure '' computation . a simulator @xmath57 waits until it knows a non - empty set of simulators @xmath97 such that ( a ) it knows their views , and ( b ) this set is closed under the relation `` has in its published view the value of '' which means that the processes whose values appear in a view of a process of @xmath97 are also in @xmath97 ( lines  c[sa - c-15]-c[sa - c-16 ] ) .",
    "let us observe that it is possible that , locally , several sets satisfy this property .",
    "if it is the case , @xmath57 selects the smallest of them .",
    "let @xmath96 be this set of simulators ( lines  c[sa - c-17 ] ) .",
    "the value that is returned by @xmath57 is then the smallest value among the the values proposed by the simulators in @xmath96 ( lines  c[sa - c-18]-c[sa - c-19 ] ) .",
    "this section proves that the algorithm presented in figure  [ algo - sa - msg - passing - crash ] implements a safe agreement object , i.e. , any of its runs in @xmath33 $ ] satisfies the validity , agreement , and termination properties , which define it .",
    "[ lemma : safe - agr - term - propose ] an invocation of @xmath17 by a simulator that does not crash during this invocation , terminates .",
    "let us consider a simulator @xmath57 that does not crash during its invocation of @xmath17 .",
    "hence , @xmath57 broadcast the message value @xmath75 at line  c[sa - c-01 ] .",
    "this message is received by strictly more than @xmath73 correct simulators , and each of them broadcasts this message when it receives it .",
    "it follows that @xmath57 can not block forever at line  c[sa - c-02 ] .",
    "let us now consider the wait statement at lines  c[sa - c-05]-c[sa - c-06 ] .",
    "there are two cases .",
    "let read  @xmath85 be a message broadcast by the simulator @xmath57 at line  c[sa - c-03 ] .",
    "* case 1 : no correct simulator ever receives a message value  @xmath109 . in this case ,",
    "each correct simulator @xmath110 is such that @xmath111 $ ] remains always equal to @xmath69 .",
    "it follows that , when @xmath110 receives the message read  @xmath85 , it sends back to @xmath57 the message readanswer  @xmath86 ( line  c[sa - c-21 ] ) .",
    "as there are strictly more than @xmath73 correct simulators , @xmath57 eventually receives the message readanswer  @xmath86 from strictly more than @xmath73 different simulators , and the predicate of line  c[sa - c-05 ] is then satisfied . * case 2 : at least one correct simulator @xmath110 receives a message value  @xmath77 . in this case ,",
    "@xmath110 broadcasts the message value  @xmath77 when it receives it ( line  c[sa - c-20 ] ) .",
    "it follows from the broadcasts issued at this line that @xmath57 eventually receives value  @xmath77 from strictly more than @xmath73 different simulators .",
    "when this occurs , the predicate of line  c[sa - c-06 ] is satisfied , and @xmath57 exits the wait statement .",
    "as this is true for any message read  @xmath85 broadcast by the simulator @xmath57 at line  c[sa - c-03 ] , it follows that @xmath57 can not remain block forever at lines  c[sa - c-05]-c[sa - c-06 ] .",
    "let us finally consider the lines  c[sa - c-12]-c[sa - c-13 ] .",
    "as the message view @xmath79 broadcast by @xmath57 at line  c[sa - c-12 ] is received by at least all the correct processes , and each of them broadcast it when it receives it for the first time , it follows that @xmath57 receives the message view @xmath79 from strictly more than @xmath73 distinct processes , and stops waiting at line  c[sa - c-13 ] , which concludes the proof of the lemma .",
    "[ lemma : safe - agr - validity ] the value returned by an invocation of @xmath17 is a value that was proposed by a simulator .",
    "let us observe that ( due to its definition ) the set @xmath112 is non - empty , and ( due the first predicate of line  c[sa - c-06 ] ) the simulator indexes @xmath113 it contains are such that @xmath114\\neq\\bot$ ] .",
    "as , for any of those @xmath113 , @xmath114 $ ] is set to a non-@xmath69 value ( only once ) at line  c[sa - c-20 ] , it follows that @xmath57 received a message value @xmath115 .",
    "hence , the values in the variables @xmath114 $ ] are values proposed by the corresponding simulators @xmath110 .",
    "it follows that the value computed at line  c[sa - c-18 ] is a value that was proposed by a simulator , which concludes the proof of the lemma .",
    "[ lemma : safe - agr - agreement ] no two invocations of @xmath18 return different values .",
    "let us first observe that , due to the reliable broadcast of the messages value  ( ) ( lines  c[sa - c-01 ] and  c[sa - c-20 ] ) and view  ( ) ( lines  c[sa - c-12 ] and  c[sa - c-22 ] ) , and the fact that a simulator broadcast a single message value  @xmath116 , we have :    * @xmath117\\neq \\bot ) ~\\wedge~(values_j[x]\\neq \\bot )        ~\\rightarrow~(values_i[x]=values_j[x])$ ] .",
    "* @xmath118\\neq \\bot ) ~\\wedge~(all\\_view_j[x]\\neq \\bot )        ~\\rightarrow~(all\\_views_i[x]=all\\_view_j[x])$ ] .",
    "let us assume , by contradiction , that two simulators @xmath57 and @xmath60 decide different values .",
    "this means that the sets @xmath96 @xmath119 computed at line  c[sa - c-17 ] by @xmath57 and @xmath60 , respectively , are different .",
    "since @xmath96 and @xmath119 are different , let us consider @xmath120 ( if @xmath121 , swap @xmath122 and @xmath61 ) . according to the closure predicate used at line  c[sa - c-16 ] , as @xmath123",
    ", we have @xmath124[z]=\\bot$ ] .",
    "it follows that any simulator @xmath110 such that @xmath125 does not fulfill the condition of line  c[sa - c-07 ] for @xmath126 .",
    "consequently , @xmath110 received at line  c[sa - c-05 ] a message readanswer(@xmath127 ) from a set of simulators @xmath128 of size strictly greater than @xmath73 .",
    "consequently when @xmath110 executed line  c[sa - c-03 ] for @xmath126 , all the simulators @xmath129 of @xmath128 verified @xmath130=\\bot$ ] .    when the simulator @xmath131 stops waiting at line  c[sa - c-02",
    "] , it received messages value(@xmath132,@xmath133 ) ( where @xmath133 is the value sent by @xmath131 at line  c[sa - c-01 ] ) from a set @xmath134 of strictly more than @xmath73 simulators .",
    "it follows that @xmath135 , consequently there is a simulator @xmath129 that sent a message readanswer(@xmath127 ) to @xmath110 and a message value(@xmath132,@xmath133 ) to @xmath131 . since @xmath136 $ ]",
    "is never reset to @xmath69 after being assigned , the simulator @xmath110 necessarily executed line  c[sa - c-03 ] for @xmath126 strictly before @xmath131 stops waiting at line  c[sa - c-02 ] .",
    "consequently @xmath110 stopped waiting at line  c[sa - c-02 ] before @xmath131 executes line  c[sa - c-03 ] for @xmath137 .",
    "it does so after receiving messages value(@xmath113,@xmath138 ) ( where @xmath138 is the value sent by @xmath110 at line  c[sa - c-01 ] ) from a set @xmath139 of strictly more than @xmath73 simulators @xmath129 , and each of these simulators then verifies @xmath140 .",
    "these simulators do not send readanswer(@xmath141 ) messages when they receive the read(@xmath142 ) message sent by @xmath131 .",
    "thus , it is impossible that @xmath131 receives these messages from strictly more than @xmath73 processes , it consequently can not verify the predicate of line  c[sa - c-05 ] .",
    "it follows that @xmath131 executes line  c[sa - c-12 ] with @xmath143=v_y\\neq\\bot$ ] and this entails that @xmath144\\neq\\bot \\rightarrow all\\_views_k[z][y]\\neq\\bot$ ] .    since @xmath145 , @xmath146\\neq\\bot$ ] , @xmath146[y]\\neq\\bot$ ] . according to the predicate of line  c[sa - c-16 ] , this entails that @xmath147 , and since the previous reasoning holds for any @xmath125 , it shows that @xmath148 .",
    "it follows that , when @xmath57 executes line  c[sa - c-17 ] , @xmath149\\neq\\bot$ ] and , consequently , @xmath149=all\\_views_j[y]$ ] .",
    "it entails that if @xmath150 , then @xmath119 would have been chosen by @xmath57 at line  c[sa - c-17 ] , which proves that @xmath151 and contradicts the fact that @xmath57 and @xmath60 decide differently .",
    "[ lemma : safe - agr - term - decide ] if no simulator crashes while executing @xmath17 , then any invocation of @xmath18 by a correct simulator terminates .",
    "if no simulator crashes while executing @xmath17 , it follows from lemma  [ lemma : safe - agr - term - propose ] that every simulator @xmath57 that invokes @xmath17 broadcasts a message value @xmath75 at line  c[sa - c-01 ] and a message view @xmath152 at line  c[sa - c-12 ] .    assuming no simulator crashes",
    "while executing @xmath17 , let @xmath153 be the set of simulators that invoke @xmath17 , and suppose that one of them , @xmath57 , invoke @xmath18 and never terminates .",
    "this can only happen if @xmath57 waits forever for the condition of lines  c[sa - c-15]-c[sa - c-16 ] to be fulfilled .",
    "since eventually the messages broadcast by the simulators of @xmath153 are all delivered to @xmath57 , after some finite time @xmath154\\neq\\bot$ ] . moreover , since the views broadcast by the simulators of @xmath153 are built at line  c[sa - c-08 ] from the messages value  ( @xmath155,@xmath155 ) they receive , it follows that these views can contain non-@xmath69 values only for the entries corresponding to the simulators of @xmath153 ( the simulators that are not in @xmath153 do not sent messages value(@xmath155,@xmath155 ) ) .",
    "consequently , @xmath26 eventually verifies @xmath156\\neq\\bot ) \\land ( \\{z\\in\\pi~:~all\\_views_i[y][z]\\neq\\bot\\}\\subseteq p)$ ] .",
    "it follows that the property of lines  c[sa - c-15]-c[sa - c-16 ] is eventually true for @xmath157 , which contradicts the fact that @xmath57 never terminates its @xmath18 operation .",
    "[ theorem - safe - agreement ] the algorithm in figure  _ [ algo - sa - msg - passing - crash ] _ implements a safe agreement object in @xmath33 $ ] .",
    "the proof follows from lemma  [ lemma : safe - agr - term - propose ] ( propose - termination ) , lemma  [ lemma : safe - agr - validity ] ( validity ) , lemma  [ lemma : safe - agr - agreement ] ( agreement ) , and lemma  [ lemma : safe - agr - term - decide ] ( decide - termination ) .",
    "the simulation algorithm takes as input a distributed algorithm @xmath158 solving a ( colorless ) task in the system model @xmath55 $ ] , and simulates it in @xmath33 $ ] .",
    "each simulator @xmath57 , @xmath63 , is given a copy of the @xmath4 processes of @xmath158 , and a private input vector @xmath159 $ ] , with one input per simulated processes @xmath27 .",
    "the simulation consists in a fair simulation by each of the @xmath2 simulators @xmath57 of the @xmath4 simulated processes @xmath27 . to that end",
    ", each simulator manages @xmath4 threads ( each simulating a process @xmath27 ) , and the @xmath2 threads associated with the simulation of a process @xmath27 cooperate through safe agreement objects .",
    "[ [ objects - shared - by - the - simulators ] ] objects shared by the simulators + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    to produce a consistent simulation , for each simulated process @xmath27 , the @xmath2 simulators have to agree on the same sequence of the messages received by @xmath27 .",
    "to that end , they use an array of safe agreement objects , denoted @xmath160 $ ] , such that @xmath161 $ ] allows them to agree on the @xmath162-th message received by the @xmath4 threads simulating @xmath27 at each simulator @xmath57 .",
    "[ [ objects - managed - by - each - simulator - q_i ] ] objects managed by each simulator @xmath57 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    each simulator manages the following data structures , with respect to each simulated process @xmath27 .    *",
    "@xmath163 $ ] contains the input of the simulated process @xmath27 , proposed by the simulator @xmath57 .",
    "( simulators are allowed to propose different input vectors for the simulated processes ) .",
    "* @xmath164 $ ] is the sequence number ( from the simulation point of view ) of the next message received by the simulated process @xmath27 . *",
    "@xmath165 $ ] is a sequence containing messages sent by the simulated processes to the simulated process @xmath27 .",
    "it is assumed that the @xmath4 threads of @xmath57 access @xmath165 $ ] in mutual exclusion ( when they add messages to or withdraw messages from this sequence ) .",
    "the symbol @xmath166 is used to add messages at the end of a sequence . sometimes @xmath165 $ ] is used as a set . *",
    "@xmath167 $ ] is a set containing the messages received by the simulated process @xmath27 ( init .",
    "@xmath168 ) . *",
    "@xmath169 $ ] contains the current local state of the simulated process @xmath27 .",
    "@xmath163 $ ] is a part of @xmath169 $ ] .",
    "+ it is assumed that the behavior of each simulated process @xmath27 is described by a deterministic transition function @xmath170 , such that @xmath171,msg)$ ] ( a ) simulates @xmath27 until its next message reception , and ( b ) returns a pair .",
    "this pair is made up of the new local state of @xmath27 plus an array @xmath172 $ ] where @xmath173 $ ] contains messages sent by @xmath27 to the simulated process @xmath78 .",
    "in addition to the previous local data , each simulator @xmath57 uses a starvation - free mutual exclusion lock , whose operations are denoted @xmath174 and @xmath175 .",
    "this lock is used to ensure that , at any time , at most one of the @xmath4 threads of @xmath57 access a safe agreement object .",
    "this is to guarantee that the crash of a simulator @xmath57 entails the crash of _ at most one _ simulated process @xmath27 ( line  [ simu - c-09 ] ) .",
    "more precisely , if @xmath57 crashes while executing @xmath161.{\\sf propose}.()$ ] , it can block forever only the invocations of @xmath161.{\\sf decide}.()$ ] , issued by the other simulators , thereby preventing the simulation of @xmath27 from terminating .",
    "[ simu - c-01 ] @xmath176.{\\sf propose}.(input_i[j ] ) ;      { \\sf mutex\\_out}_i();$ ] + [ simu - c-02 ] @xmath163 \\leftarrow { \\mathit{sa}}[j,0].{\\sf decide}()$ ] ; + [ simu - c-03 ] @xmath177 , msgs[1 .. n']\\rangle \\leftarrow                 \\delta_j(state_i[j ] , \\emptyset)$ ] ; + [ simu - c-04 ] @xmath178 * do * @xmath179 \\leftarrow sent_i[x ] ~\\oplus~ msgs[x]$ ] * end for * ; + [ simu - c-05 ] @xmath164 \\leftarrow 0 $ ] ; + [ simu - c-06 ] + [ simu - c-07 ] @xmath164 \\leftarrow sn_i[j ] + 1 $ ] ; + [ simu - c-08 ] @xmath180\\setminus received_i[j])\\neq \\emptyset\\big)$ ] ; + [ simu - c-09 ] @xmath181\\setminus received_i[j ] $ ] ; + [ simu - c-10 ] @xmath174 ; @xmath182.{\\sf propose}.(msg);$ ] @xmath175 ; + [ simu - c-11 ] @xmath183.{\\sf decide}();$ ] + [ simu - c-12 ] @xmath167 \\leftarrow received_i[j ] \\cup \\{rec\\_msg\\}$ ] ; + [ simu - c-13 ] @xmath177 , msgs[1 .. n']\\rangle \\leftarrow                 \\delta_j(state_i[j ] , rec\\_msg)$ ] ; + [ simu - c-14 ] @xmath178 * do * @xmath179 \\leftarrow sent_i[x ] ~\\oplus~ msgs[x]$ ] * end for * ; + [ simu - c-15 ] ( no value yet decided by @xmath27 @xmath184   @xmath185 $ ] allows @xmath27 to decide a value @xmath45 ) + [ simu - c-16 ] the simulated process @xmath27 decides @xmath45 + [ simu - c-17 ] + [ simu - c-18 ] .",
    "[ [ the - simulation - algorithm ] ] the simulation algorithm + + + + + + + + + + + + + + + + + + + + + + + +    the algorithm describing the simulation of a process @xmath27 by the associated thread of the simulator @xmath57 is presented in figure  [ algo : simulation - crash ] .    the simulators have first to agree on the same input for process @xmath27 . to this end",
    ", they use the safe agreement object @xmath186 $ ] ( lines  [ simu - c-01]-[simu - c-02 ] ) .",
    "moreover , when considering all the simulated processes , it follows from the mutual exclusion lock that , whatever the number of simulated processes , a simulator @xmath57 is engaged in at most one invocation of @xmath17 at a time .",
    "then , according to the decided input of @xmath27 , @xmath57 locally simulate @xmath27 until it invokes a message reception ( lines  [ simu - c-03]-[simu - c-04 ] ) .",
    "after this initialization , each simulator @xmath57 enters a loop whose aim is to locally simulate @xmath27 . to this end , @xmath57 first determines the message that @xmath27 will receive ; this message is saved in @xmath187 and added to @xmath167 $ ] ( lines  [ simu - c-07]-[simu - c-12 ] ) .",
    "when this message has been determined , @xmath57 simulates the behavior of @xmath27 until its next message reception ( lines  [ simu - c-13]-[simu - c-14 ] ) .",
    "finally , if @xmath169 $ ] allows @xmath27 to decide a value with respect to the simulated decision task , this value is decided ( lines  [ simu - c-15]-[simu - c-17 ] ) .",
    "the reader interested in a formal definition of the term _ simulation _",
    "as used here will consult  @xcite .",
    "[ lemma : at - most - one - crash ] the crash of a simulator @xmath57 entails the crash of at most one simulated process @xmath27 .",
    "the only places where a simulator @xmath57 can block is during the invocation of the safe agreement operation @xmath18 .",
    "such invocations appear at line  [ simu - c-02 ] , and line  [ simu - c-11 ] .",
    "it follows from the termination property of the safe agreement objects that such an invocation can block forever the invoking process only if a simulator crashes during the invocation of the operation @xmath17 on the same object .",
    "but , due to the mutual exclusion lock used at line  [ simu - c-01 ] and line  [ simu - c-10 ] , a simulator can be engaged in at most one invocation of propose at a time .",
    "it follows that the crash of a simulation @xmath57 can entail the definitive halting ( crash ) of at most one simulated process @xmath27 .",
    "[ lemma : same - seq - of - messages ] the simulation of the reception of the @xmath6-th message received by a simulated process @xmath27 , returns the same message at all simulators .",
    "the simulation of the message receptions for a simulated process @xmath27 , are executed at each simulator @xmath57 at lines  [ simu - c-08]-[simu - c-11 ] , and all the simulators use the same sequence of sequence numbers ( line  [ simu - c-07 ] ) .",
    "it then follows from the agreement property of the safe agreement object @xmath161 $ ] , that no two simulators obtain different messages when they invoke @xmath161.{\\sf decide}()$ ] , and the lemma follows .",
    "[ lemma : one - dec - value ] for every simulated processes @xmath27 , no two simulators return different values .",
    "the only non - deterministic elements of the simulation are the input vectors @xmath159 $ ] at each simulator @xmath57 , and the reception of the simulated messages .    the lines  [ simu - c-01]-[simu - c-02 ] of the simulation force the simulators to agree on the same input value for each simulated process @xmath27 , @xmath188 .",
    "similarly , as shown by lemma  [ lemma : same - seq - of - messages ] , for each simulated process @xmath27 , the lines  [ simu - c-07]-[simu - c-11 ] direct the simulators to agree on the very same sequence of messages received by @xmath27 .",
    "it follows from the fact that the function @xmath170 is deterministic , that any two simulators @xmath57 and @xmath129 , that execute lines  [ simu - c-15]-[simu - c-16 ] during the same `` round number '' @xmath164=sn_k[j]$ ] , are such that @xmath169=state_k[j]$ ] , from which the lemma follows .",
    "[ lemma : correct - simulation ] the sequences of message receptions simulated by each simulator @xmath57 on behalf of each simulated process @xmath27 , define a correct execution of the simulated algorithm .    to prove the correctness of the simulation , we have to show that    1 .",
    "[ item1 ] every message that was sent by a simulated process to another simulated process ( whose simulation is not blocked either ) , is received , and 2 .",
    "[ item2 ] the simulated messages respect a simulated physical order ( i.e. , no message is `` received '' before being `` sent '' ) .",
    "item  [ item1 ] is satisfied because the messages sent by the simulated process @xmath27 to the simulated process @xmath189 are received ( lines  [ simu - c-09]-[simu - c-11 ] ) in their sending order ( as defined at line  [ simu - c-04 ] and line  [ simu - c-14 ] ) .",
    "hence , if @xmath189 is not blocked ( due to the crash of a simulator ) it obtains the messages from @xmath27 in their sending order .    for item  [ item2 ] ,",
    "let us define a ( simulated ) physical order as follows .",
    "for each simulated message @xmath30 , let us consider the first time at which the reception of @xmath30 was simulated ( i.e. , this occurs when for the first time a simulator terminates the invocation of @xmath190.{\\sf decide}()$ ] that returns @xmath30 ) .",
    "a message that is decided has been proposed by a simulator to a safe agreement object before being decided ( validity property).the sending time of a simulated message is defined as the first time at which @xmath190.{\\sf propose}(m)$ ] is invoked by a simulator .",
    "it follows that any simulated message is sent before being received , which concludes the lemma .",
    "[ lemma : nb - simulated - proc ] each correct simulator @xmath57 computes the decision value of at least @xmath191 simulated processes .    due to lemma",
    "[ lemma : at - most - one - crash ] , and the fact that at most @xmath1 simulators may crash , it follows that at most @xmath1 simulated processes may be prevented from progressing . as ( a ) by assumption the simulated algorithm @xmath54",
    "is @xmath1-resilient , and ( b ) due to lemma  [ lemma : correct - simulation ] the simulation produces a correct simulation of @xmath54 , it follows that at least @xmath191 simulated processes decide a value .",
    "[ theorem : main - simulation ] let @xmath158 be an algorithm solving a decision task in @xmath55 $ ] .",
    "the algorithm described in figure  [ algo : simulation - crash ] is a correct simulation of @xmath158 in  @xmath33 $ ] .",
    "the theorem follows from lemma  [ lemma : correct - simulation ] and lemma  [ lemma : nb - simulated - proc ] .",
    "this section presents an algorithm , denoted bg(mp , b ) , which implements the bg simulation in the byzantine asynchronous message - passing model @xmath37 $ ] . to this end",
    ", an appropriate safe agreement object is first built , and then used by the simulation algorithm .",
    "the idea is to extend the algorithm of figure  [ algo - sa - msg - passing - crash ] to obtain an algorithm that copes with byzantine simulators .",
    "the main issues that have to be solved are the following .    *",
    "the simulators need a mechanism to control the validity of the inputs to the safe agreement objects .",
    "( see below for the notion of a valid value . )",
    "* the simulators must be able to check if a given simulator @xmath57 is participating in more than one operation @xmath17 at the same time ( on the same or several safe agreement objects ) .",
    "if it is the case , @xmath57 is faulty and its definitive stop can block forever several simulated processes .",
    "hence , such a faulty simulator has to be ignored .    to solve these issues , each safe agreement object",
    "may no longer be considered as a separate abstraction : each new instance depends on the previous ones .",
    "this is captured in the following specification customized to the byzantine model , and , at the operational level , in the predicate @xmath192 used in the algorithm implementing the operation @xmath17 .      to cope with the previous observations , the fact that a faulty process may decide an arbitrary value , and the fact that the safe agreement objects are used to solve specific problems ( a simulation in our case ) , the specification of the safe agreement object is reshaped as follows .",
    "a value proposed by a process to a safe agreement object must be _",
    "valid_. at each correct simulator @xmath57 , the validity of a value is captured by a predicate denoted @xmath193 where @xmath45 is the value and @xmath60 the simulator that proposed it .",
    "this predicate is made up of two parts ( defined in section  [ sec : is - valid ] and section  [ sec : simulation - byzantine ] , respectively ) .",
    "if @xmath60 is correct , the predicate @xmath193 eventually returns @xmath194 at @xmath26 .",
    "if @xmath60 is faulty , @xmath193 returns @xmath194 at @xmath26 only if ( a ) the value @xmath45 could have been proposed by a correct simulator and ( b ) to @xmath57 s knowledge , @xmath60 does not participate concurrently in several invocations of @xmath17 .    * validity .",
    "if a correct simulator @xmath57 decides the value @xmath45 , there is a correct simulator @xmath60 such that @xmath195 .",
    "( @xmath45 was validated by a correct simulator . ) * agreement .",
    "no two correct simulators decide distinct values . *",
    "propose - termination .",
    "any invocation of @xmath17 by a correct simulator terminates .",
    "* decide - termination .",
    "the invocations by all the correct simulators of @xmath196 on all the safe agreement objects terminate , except for at most @xmath1 safe agreement objects .",
    "the local variables @xmath65 $ ] , @xmath66 $ ] , @xmath67 $ ] , and the algorithm implementing the operation @xmath18 are the same as in figure  [ algo - sa - msg - passing - crash ] ( lines  c[sa - c-15]-c[sa - c-19 ] ) .",
    "the new algorithm implementing the operation @xmath197 , and the processing of the associated messages , are described in figure  [ algo - sa - msg - passing - byzantine - propose ] and figure  [ algo - sa - msg - passing - byzantine - answers ] .",
    "this implementation uses an additional local array @xmath198[1 .. n][1 ..",
    "n]$ ] , all entries of which are initialized to `` ? '' .",
    "the meaning of `` @xmath199[j][x]=v$ ] '' ( where @xmath45 is a proposed value or @xmath69 ) is the following : to the knowledge of @xmath57 , the simulator @xmath129 answered value @xmath45 when it received the message read@xmath101 sent by @xmath60 .",
    "( a simulator @xmath60 broadcasts such a message when it needs to know the value proposed by the simulator @xmath71 ; @xmath69 means that @xmath129 does not know this value yet . )",
    "this means that , from @xmath57 s point of view , the value proposed by @xmath71 , as known by @xmath129 when it received the request by @xmath60 , is @xmath45 .",
    "[ lemma : quorum - intersection ] any two sets of simulators @xmath200 and @xmath201 of more than @xmath202 elements have at least one correct simulator in their intersection .    as we consider integers ,",
    "`` strictly more than @xmath202 '' is equivalent to `` at least @xmath203 '' .",
    "* @xmath204 .",
    "hence , @xmath205 .",
    "* @xmath206 .",
    "hence , @xmath207 .",
    "it follows that @xmath208 contains at least one correct simulator .",
    "the fact that , despite byzantine processes , the intersection of any two simulator sets of size greater than @xmath202 have at least one correct simulator in common , is used in many places in the algorithm .",
    "this property will be used in the proof to show that the local views of the correct processes are mutually consistent .",
    "[ [ the - operation - sf - propose ] ] the operation @xmath17 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the client side of the algorithm implementing the operation @xmath17 is described in figure  [ algo - sa - msg - passing - byzantine - propose ] ; its server side is described in figure  [ algo - sa - msg - passing - byzantine - answers ] .",
    "the client side algorithm is very close to the one of the crash failure case ( figure  [ algo - sa - msg - passing - crash ] ) .",
    "they differ in two points .    *",
    "the message tags value and view ( used at lines  c[sa - b-02 ] ,  c[sa - b-06 ] , and  c[sa - b-13 ] in figure  [ algo - sa - msg - passing - crash ] ) are replaced in figure  [ algo - sa - msg - passing - byzantine - propose ] by the tags valueack and viewack , respectively .",
    "the role of these message tags is explained below . *",
    "the predicate of line  b[sa - b-05 ] is replaced by the predicate @xmath209[i][x]=\\bot\\}|>\\frac{n+t}{2}$ ] .",
    "this predicate states that more than @xmath202 simulators answered @xmath69 to the request message read@xmath85 broadcast by @xmath57 , ( i.e. , they did not know the value proposed by @xmath71 when they received the read request ) .",
    "* operation * @xmath81 ( @xmath76 ) * is * + [ sa - b-01 ]   = @xmath82 value @xmath75 ; + [ sa - b-02 ] ( valueack @xmath75 @xmath83 from @xmath210 different simulators ) ; + [ sa - b-03 ] @xmath211 $ ] * do * @xmath82 read @xmath85 * end for * ; + [ sa - b-04 ] @xmath84 $ ] * do * + [ sa - b-05 ] ( ( @xmath209[i][x]=\\bot\\}|>\\frac{n+t}{2}$ ] ) @xmath212 + [ sa - b-06 ] ( @xmath213 valueack @xmath90 @xmath83 from @xmath210 different simulators ) ) ; + [ sa - b-07 ] ( predicate of line  b[sa - b-06 ] satisfied ) + [ sa - b-08 ] = @xmath72 \\gets w$ ] + [ sa - b-09 ] @xmath72 \\gets \\bot$ ] + [ sa - b-10 ] + [ sa - b-11 ] ; + [ sa - b-12 ] @xmath82 view @xmath79 ; + [ sa - b-13 ] ( viewack @xmath79 @xmath83 from @xmath210 different simulators ) ; + [ sa - b-14 ] @xmath91 . +   + * operation * @xmath92 ( ) * is * + ( c[sa - c-15 ] ) ( @xmath93 a non - empty set @xmath94 : + ( c[sa - c-16 ] )  @xmath95\\neq\\bot ) ~\\wedge~   \\big(\\forall~z\\in \\pi:~(all\\_views_i[y][z]\\neq\\bot )                                 \\rightarrow(z\\in \\sigma)\\big)\\big]$ ] ; + ( c[sa - c-17 ] ) @xmath96 * be * the set @xmath97 of smallest size ; + ( c[sa - c-18 ] ) @xmath98 * be * @xmath99 ~:~ y\\in min\\_\\sigma_i\\})$ ] ; + ( c[sa - c-19 ] ) @xmath100 .    * when the message * value @xmath214 * is * @xmath215 * for the first time * : + [ sa - b-15 ] * wait * ( @xmath216 ( @xmath217 ) ) ; @xmath82 valuevalid @xmath214 . +   + * when the message * valuevalid @xmath214 * is * @xmath83 : + [ sa - b-16 ] = ( ( valuevalid @xmath214 @xmath83 from @xmath210 different simulators ) @xmath218 ( valuewitness @xmath219 never broadcast ) ) + [ sa - b-17 ] @xmath82 valuewitness @xmath214 * end if*. +   + * when the message * valuewitness @xmath214 * is * @xmath83 : + [ sa - b-18 ] = ( ( valuewitness @xmath214 @xmath83 from @xmath220 different simulators ) @xmath218 ( valuewitness @xmath214 never broadcast ) ) + [ sa - b-19 ] @xmath82 valuewitness @xmath214 + [ sa - b-20 ] ; + [ sa - b-21 ] ( valuewitness @xmath214 @xmath83 from @xmath210 different simulators ) + [ sa - b-22 ] = @xmath221\\gets v$ ] ; @xmath82 valueack @xmath214 + [ sa - b-23 ] . +   +  + * when the message * read @xmath101 * is * @xmath222 * for the first time * : + [ sa - b-24 ] ( valueack @xmath214 @xmath83 from @xmath210 different simulators ) ; + [ sa - b-25 ] @xmath221\\gets v$ ] ; @xmath82 valueack @xmath214 ; + [ sa - b-26 ] @xmath82 readanswer @xmath103)$ ] .",
    "+   + * when the message * readanswer @xmath223 * is * @xmath224 * for the first time * : + [ sa - b-27 ] ( readanswerwitness @xmath225 never broadcast ) * then * @xmath82 readanswerwitness @xmath226 * end if*. +   + * when the message * readanswerwitness @xmath226 * is * @xmath83 : + [ sa - b-28 ] = ( ( readanswerwitness @xmath226 @xmath83 from @xmath220 different simulators ) + [ sa - b-29 ] @xmath227 ( readanswerwitness @xmath226 never broadcast ) ) + [ sa - b-30 ] @xmath82 readanswerwitness @xmath226 + [ sa - b-31 ] ; + [ sa - b-32 ] ( readanswerwitness @xmath226 @xmath83 from @xmath210 different simulators ) + [ sa - b-33 ] @xmath199[j][x]\\gets v$ ] + [ sa - b-34 ] . +   +  +",
    "* when the message * view @xmath228 * is * @xmath229 * for the first time * : + [ sa - b-35 ] = ( ( viewwitness @xmath230 never broadcast ) @xmath218 ( @xmath231\\neq\\bot$ ] ) ) + [ sa - b-36 ] * for * = @xmath232 $ ] * do * + [ sa - b-37 ] ( @xmath233\\neq\\bot$ ] ) + [ sa - b-38 ] * wait * ( valueack @xmath234)$ ] @xmath83 from @xmath210 different simulators ) + [ sa - b-39 ] ( @xmath209[j][x]=\\bot\\}|>\\frac{n+t}{2}$ ] ) + [ sa - b-40 ] + [ sa - b-41 ] ; + [ sa - b-42 ] @xmath82 viewwitness @xmath235 + [ sa - b-43 ] . +   + * when the message * viewwitness @xmath235 * is * @xmath83 : + [ sa - b-44 ] = ( ( viewwitness @xmath235 @xmath83 from @xmath220 different simulators ) @xmath227 ( viewwitness @xmath235 never broadcast ) ) + [ sa - b-45 ] @xmath82 viewwitness @xmath235 + [ sa - b-46 ] ; + [ sa - b-47 ] ( viewwitness @xmath235 @xmath83 from @xmath210 different simulators ) + [ sa - b-48 ] = @xmath236\\gets view$ ] ; @xmath102 viewack @xmath228 @xmath104 + [ sa - b-49 ] .    [ [ messages - value - valuevalid - valuewitness - and - valueack ] ] messages value@xmath116 , valuevalid@xmath116 , valuewitness@xmath116 and valueack@xmath116 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    when a simulator @xmath57 invokes the operation @xmath237 , it first broadcasts the message value @xmath75 , and waits for @xmath202 acknowledgments ( messages valueack@xmath75 , lines  b[sa - b-01]-b[sa - b-02 ] ) .",
    "then , as in the crash failure case ( figure  [ algo - sa - msg - passing - crash ] ) , it builds its local view of the values proposed to the safe agreement object ( lines  b[sa - b-03]-b[sa - b-11 ] ) .",
    "finally , it sends its local view to all other simulators ( lines  b[sa - b-12]-b[sa - b-13 ] ) .    on its server side , when a simulator @xmath57 receives a message value @xmath214 , it first checks if this message is valid ( line  b[sa - b-15 ] ) . if the message is valid , @xmath57 broadcasts ( echoes ) the message valuevalid @xmath214 to inform the other simulators that it agrees to take into account the pair @xmath214 ( line  b[sa - b-15 ] ) .",
    "when the simulator @xmath26 has received the message valuevalid @xmath214 from more than @xmath202 simulators , it broadcasts the message valuewitness @xmath214 to inform the other processes that at least @xmath238 correct simulators , have validated the pair @xmath214 .    when @xmath57 has received the message valuewitness @xmath214 from @xmath0 simulators ( i.e. , from at least one correct simulator ) it broadcasts this message , if not yet done ( lines  b[sa - b-18]-b[sa - b-20 ] ) .",
    "this is to prevent invocations of @xmath17 from blocking forever ( while waiting valueack @xmath214 messages at line  b[sa - b-02 ] , b[sa - b-06 ] , b[sa - b-24 ] or b[sa - b-38 ] ) , because not enough valuewitness @xmath214 messages have been broadcast .",
    "then , if @xmath57 has received the message valuewitness @xmath214 from more than @xmath202 simulators , it takes @xmath45 into account ( writes it into @xmath221 $ ] ) and sends an acknowledgment to @xmath60 ( lines  b[sa - b-21]-b[sa - b-23 ] ) . the corresponding message valueack @xmath214 broadcast by @xmath57",
    "will also inform the other simulators that @xmath57 took into account the value @xmath45 proposed by @xmath60 .",
    "hence , this message will help @xmath60 progress at line  b[sa - b-02 ] , and all correct simulators progress at line  b[sa - b-06 ] .",
    "[ [ sec : def - is - valid ] ] first part of the predicate @xmath239 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    as already indicated , the aim of this predicate is to help a simulator @xmath57 detect if the value @xmath45 proposed by the simulator @xmath60 is valid .",
    "it is always satisfied when @xmath60 is correct , and it can return @xmath240 or @xmath241 when @xmath60 is faulty .",
    "it is made up of two sub - predicates @xmath242 and @xmath243 .",
    "* the first sub - predicate @xmath242 checks if , for the messages value @xmath219 ( from @xmath60 ) and valuevalid @xmath219 ( from more than @xmath220 different simulators ) that @xmath57 has received for other safe agreement objects , @xmath57 has also received the associated messages viewwitness  @xmath219 from at least @xmath244 different simulators .",
    "this allows @xmath57 to check if the simulator @xmath60 is not simultaneously participating in other invocations of @xmath245 on other safe agreement objects . *",
    "the aim of the second sub - predicate @xmath243 ( defined in section  [ sec : simulation - byzantine ] and used in the simulation ) is to allow the simulators to check that the simulation is consistent . as the present section considers safe agreement objects independently from its use in the simulation , we consider , for now , that @xmath243 is always satisfied .",
    "if the full predicate @xmath239 is never satisfied , @xmath57 will , collectively with the other correct simulators , prevent the faulty simulator @xmath60 from progressing with respect to the corresponding safe agreement object .    [ [ messages - read - readanswer - and - readanswerwitness ] ] messages read@xmath116 , readanswer@xmath116 and readanswerwitness@xmath116 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    after the value @xmath76 it proposes to the safe agreement object has been taken into account by @xmath246 simulators , @xmath57 builds a local view of all the values proposed ( array @xmath247 $ ] ) . to this end , as in the crash failure model , @xmath57 sends to each simulator @xmath71 the customized message read  @xmath85 ( line  b[sa - b-03 ] ) .",
    "its behavior is then similar to the one of the crash failure model ( line  b[sa - b-04]-b[sa - b-11 ] ) , where the new predicate @xmath209[i][x]=\\bot\\}|>\\frac{n+t}{2}$ ] is now used at line  b[sa - b-05 ] .",
    "when @xmath57 receives the message read  @xmath101 from the simulator @xmath60 , it first waits until it knows that the value proposed by @xmath60 is known by more than @xmath202 simulators ( line  b[sa - b-24 ] ) .",
    "this is to check that @xmath60 broadcast its proposed value before reading the other simulator values used to build its own view",
    ". when this occurs , @xmath57 answers the message read  @xmath101 by broadcasting the message readanswser  @xmath103)$ ] to inform all the simulators on what it currently knows on the value proposed by @xmath71 ( line  b[sa - b-26 ] ) .",
    "( let us remind that , in the crash failure model , @xmath57 was sending this message only to @xmath60 . )    when it receives the message readanswer  @xmath223 from a simulator @xmath129 , if not yet done , @xmath57 broadcasts the message readanswserwitness  @xmath226 .",
    "the lines  b[sa - b-27]-b[sa - b-31 ] implement a reliable broadcast @xcite , i.e. , the message readanswserwitness  @xmath226 is received by all correct processes or none of them , and is always received if the sender is correct . the reliable reception of this message entails the assignment of @xmath248 $ ] to @xmath45 ( line  b[sa - b-33 ] ) .",
    "[ [ messages - view - viewwitness - and - viewack ] ] messages view@xmath116 , viewwitness@xmath116 and viewack@xmath116 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    finally , as in figure  [ algo - sa - msg - passing - crash ] , the simulator @xmath57 broadcasts its local view of proposed values to all simulators , waits until more than @xmath202 of them sent back an acknowledgment , and returns from the invocation of @xmath17 ( lines  b[sa - b-12]-b[sa - b-14 ] ) .",
    "when @xmath57 receives for the first time the message view  @xmath228 , it realizes an enriched reliable broadcast whose aim is to assign @xmath249 to @xmath250 $ ] .",
    "let us first observe that if @xmath231=\\bot$ ] , then @xmath60 is byzantine .",
    "if it has not yet broadcast viewwitness  @xmath228 and if @xmath231\\neq\\bot$ ] ( line  b[sa - b-35 ] ) , @xmath57 first checks if all the values in @xmath251 $ ] are consistent . from its point of view",
    ", this means that , for each simulator @xmath71 , ( a ) if @xmath233=v$ ] , it must receive messages valueack  @xmath77 from more than @xmath202 simulators , and ( b ) if @xmath233=\\bot$ ] , the same predicate as in line  b[sa - b-05 ] must become satisfied .",
    "this consistency check is realized by the lines  b[sa - b-36]-b[sa - b-41 ] .",
    "finally , when @xmath57 receives a message viewwitness  @xmath228 , it does the following .",
    "first , if it has received this message from at least one correct simulator , and has not yet broadcast it , @xmath57 does it ( lines  b[sa - b-44]-b[sa - b-46 ] ) .",
    "this part of the reliable broadcast is to prevent the correct simulators from blocking forever .",
    "then , if it has received viewwitness  @xmath228 from more than @xmath202 simulators and has not yet assigned a value to @xmath250 $ ] , @xmath57 does it and sends to @xmath60 the acknowledgment message viewack  @xmath228 to inform @xmath60 that it knows its view ( lines  b[sa - b-47]-b[sa - b-49 ] ) .      when considering the algorithm of figure  [ algo - sa - msg - passing - byzantine - answers ] , it appears that the processing of the messages valuewitness  @xmath116 ( lines  b[sa - b-18]-b[sa - b-23 ] ) , readanswerwitness  @xmath116 ( lines  b[sa - b-28]-b[sa - b-34 ] ) , and viewwitness  @xmath116 ( lines  b[sa - b-44]-b[sa - b-49 ] ) , follow the same generic pattern .",
    "this pattern , inspired from  @xcite and where witness is used as message tag , is described in figure  [ algo : generic - pattern ] .",
    "[ theo - generic - pattern ] _",
    "( i ) _ if a correct simulator executes action @xmath158 , all correct simulators do it . + _",
    "( ii ) _ if @xmath0 correct simulators execute @xmath28 witness@xmath29 , all correct simulators execute action @xmath158 .    proof of ( i ) .",
    "let @xmath26 be a correct process that executes @xmath158 .",
    "it follows from line gp[gp-05 ] that it has received the message witness @xmath29 from more than @xmath202 different simulators . as @xmath252 , @xmath253",
    ", @xmath26 received the message witness @xmath29 from at least @xmath0 correct simulators .",
    "it then follows from lines  gp[gp-01]-gp[gp-02 ] that all correct simulators broadcast witness @xmath29 and , consequently , each correct simulator receives witness @xmath29 from at least @xmath244 simulators .",
    "the proof follows from @xmath254 .",
    "proof of ( ii ) .",
    "if @xmath0 correct simulators broadcast witness @xmath29 , the predicate of line  gp[gp-01 ] is eventually satisfied at every correct simulator . as as @xmath255 , it follows that the predicate of line  gp[gp-05 ] will also be satisfied at each correct simulator , which concludes the proof .",
    "this section proves that the algorithm presented in figures  [ algo - sa - msg - passing - byzantine - propose ] and  [ algo - sa - msg - passing - byzantine - answers ] implements a safe agreement object in the presence of byzantine simulators , i.e. , any of its runs in @xmath37 $ ] satisfies the validity , agreement , and termination properties that define this object .    [",
    "[ propose - termination ] ] propose - termination + + + + + + + + + + + + + + + + + + +    [ lemma - termination - if - valid ] let @xmath57 be a correct simulator . if the predicate @xmath256 eventually becomes satisfied at the correct simulators @xmath60 , then the invocation of @xmath237 by @xmath57 terminates .",
    "a correct simulator @xmath57 can be blocked forever in a @xmath257 statement ( 1 ) at line b[sa - b-02 ] , ( 2 ) at lines b[sa - b-05]-b[sa - b-06 ] , or ( 3 ) at line b[sa - b-13 ] .",
    "we show that , if the predicate @xmath256 is eventually satisfied at the correct simulators @xmath60 , @xmath26 can not block forever in the invocation of @xmath237 .",
    "* @xmath257 instruction at line b[sa - b-02 ] .",
    "+ simulator @xmath57 first broadcasts the message value@xmath75 ( line b[sa - b-01 ] ) , then waits for valueack messages from more than @xmath202 different simulators . when a correct simulator @xmath60 receives value@xmath75 for the first time , it waits until @xmath256 becomes satisfied . by assumption , this happens .",
    "simulator @xmath60 then broadcasts valuevalid@xmath75 .",
    "it follows that each of the at least @xmath244 correct simulators broadcasts the message valuevalid@xmath75 . + as @xmath258 , it follows that each correct simulator @xmath60 receives the message valuevalid@xmath75 from more than @xmath202 simulators and broadcasts the message valuewitness@xmath75 .",
    "+ according to theorem  [ theo - generic - pattern ] , @xmath60 updates @xmath259 $ ] with @xmath76 , and broadcasts valueack@xmath75 ( lines  b[sa - b-21]-b[sa - b-23 ] ) .",
    "the correct simulator @xmath57 will then receive the message valueack@xmath75 from at least @xmath254 simulators .",
    "hence , it can not block forever at line b[sa - b-02 ] . * @xmath257 instruction at lines b[sa - b-05]-b[sa - b-06 ] .",
    "+ in this waiting statement , @xmath57 waits until either @xmath209[i][j]=\\bot\\}|>\\frac{n+t}{2}$ ] becomes true , or until it receives valueack@xmath260 from more than @xmath202 different simulators .",
    "* * if @xmath60 is a correct simulator that invoked @xmath261 , the reasoning is the same as above .",
    "consequently , @xmath57 will receive valueack@xmath260 from at least @xmath258 different simulators . * * if @xmath60 is faulty or never invokes @xmath261 , @xmath57 may never receive valueack@xmath260 from more than @xmath202 different simulators .",
    "we will show that , in this case , the wait predicate @xmath209[i][j]=\\bot\\}|>\\frac{n+t}{2}$ ] eventually becomes true .",
    "+ we first show that , if a correct simulator receives valueack@xmath260 from more than @xmath202 different simulators , then all correct simulators do receive valueack@xmath260 from more than @xmath202 different simulators . if a correct simulator receives valueack@xmath260 from more than @xmath202 different simulators , at least @xmath0 correct simulators broadcast it .",
    "every correct simulator will then receive the message valueack@xmath260 from at least @xmath0 different simulators and , if not already done , broadcasts it ( lines  b[sa - b-24]-b[sa - b-25 ] ) . all correct simulators",
    "will then receive the message valueack@xmath260 from at least @xmath258 different simulators .",
    "+ according to the previous observation , let us consider the case in which no correct simulator ever receives the message valueack@xmath260 from more than @xmath202different simulators .",
    "a correct simulator @xmath129 assigns a non-@xmath69 value to @xmath262 $ ] only if it receives valuewitness@xmath260 from more than @xmath202 different simulators ( line  b[sa - b-22 ] ) , or if it receives valueack@xmath260 from more than @xmath202 different simulators ( line  b[sa - b-25 ] ) .",
    "if a correct simulator receives valuewitness@xmath260 from more than @xmath202 different simulators , according to theorem  [ theo - generic - pattern ] , all correct simulators receive valuewitness@xmath260 from more than @xmath202 different simulators , and broadcast the message valueack@xmath260 .",
    "because no correct simulator ever receives valueack@xmath263 messages from more than @xmath202 different simulators , no correct simulator @xmath129 will ever assign a non-@xmath69 value to @xmath262 $ ] ( line  b[sa - b-22 ] ) .",
    "+ when a correct simulator receives a read@xmath264 message from @xmath57 , it waits until it has received valueack@xmath75 messages from more than @xmath202 different simulators ( line  b[sa - b-24 ] ) .",
    "the reasoning above ( first item ) shows that this will eventually become true .",
    "+ every correct simulator @xmath129 will then broadcast readanswer@xmath265 .",
    "this will cause all correct simulators to broadcast mess sages readanswerwitness@xmath266 , which will be received by the simulator @xmath57 .",
    "this will then assign @xmath69 to @xmath199[i][j]$ ] for at least @xmath254 different values of @xmath6 .",
    "consequently , it will not remain blocked at lines  b[sa - b-05]-b[sa - b-06 ] . * @xmath257 instruction at line b[sa - b-13 ] . + as simulator @xmath57 broadcasts its view with a message view@xmath267 ( line  b[sa - b-12 ] ) , every correct simulator checks if this view is consistent when it receives it ( lines  b[sa - b-36]-b[sa - b-41 ] ) .",
    "let us first consider the entries @xmath231 $ ] such that @xmath231=w\\neq\\bot$ ] .",
    "this means that @xmath57 has received valueack@xmath260 from more than @xmath202 different simulators .",
    "all the correct simulators then receive the same message from a sufficient number of different simulators and do not remain blocked at line  b[sa - b-38 ] ( theorem  [ theo - generic - pattern ] ) .",
    "+ let us now consider the entries @xmath231 $ ] such that @xmath231=\\bot$ ] .",
    "simulator @xmath57 assigned @xmath69 to @xmath231 $ ] because it received readanswerwitness@xmath266 from more than @xmath202 different simulators ( lines  b[sa - b-32]-[sa - b-33 ] ) . according to theorem  [ theo - generic - pattern ]",
    ", all the correct simulators @xmath71 will also receive readanswerwitness@xmath266 from more than @xmath202 different simulators , and will assign @xmath69 to @xmath268[i][j]$ ] .",
    "they will thus not remain blocked at line  b[sa - b-39 ] .",
    "+ all the correct simulators will then broadcast the message viewwitness@xmath267 ( line  b[sa - b-42 ] ) . by theorem  [ theo - generic - pattern ] , they will all send viewack@xmath267 to @xmath57 .",
    "this will allow @xmath57 to terminate its invocation of @xmath269 , which concludes the proof of the lemma .",
    "[ lemma - valid - if - correct ] let @xmath270 be the values proposed by a correct simulator @xmath57 to a sequence of safe agreement objects .",
    "if @xmath57 does not invoke @xmath17 operations concurrently and @xmath271 is eventually satisfied at every correct simulator @xmath60 , then @xmath272 is also eventually satisfied at @xmath60 .",
    "we consider here that the sub - predicate @xmath243 is always satisfied , and thus consider only the sub - predicate @xmath242 .",
    "let us recall that @xmath242 states that , for every message value@xmath273 that @xmath60 received from @xmath57 , and for every message valuevalid@xmath273 that @xmath60 received from at least @xmath220 different simulators , it has also received the corresponding messages viewwitness@xmath273 .    by hypothesis ,",
    "@xmath271 is eventually satisfied at the correct simulator @xmath60 .",
    "once @xmath57 broadcasts the message value@xmath274 , @xmath60 only needs to receive the corresponding viewwitness@xmath267 for @xmath242 to be satisfied . by lemma [ lemma - termination - if - valid ]",
    ", @xmath57 terminates its invocation of @xmath275 , from which we conclude that it received viewack@xmath267 from more than @xmath202 different simulators ( line  b[sa - b-13 ] ) .",
    "a correct simulator sends such a message only if it has received viewwitness@xmath267 from more than @xmath202 different simulators ( lines  b[sa - b-47]-b[sa - b-48 ] ) .",
    "according to theorem  [ theo - generic - pattern ] , all the correct simulators also broadcast it ( lines  b[sa - b-44]-b[sa - b-45 ] ) .",
    "the correct simulator @xmath60 then receives them from more than @xmath202 different simulators .",
    "the predicate @xmath272 is then eventually satisfied at @xmath60 .",
    "[ [ decide - termination ] ] decide - termination + + + + + + + + + + + + + + + + + +    [ lemma : one - decides - all - decide ] if a correct simulator terminates its invocation of @xmath18 , then all correct simulators terminate their invocation of @xmath18 .",
    "suppose , by way of contradiction , that the invocation of @xmath18 by a correct simulator @xmath57 terminates , and that the invocation of @xmath18 by another correct simulator @xmath60 does not .",
    "the invocation of @xmath18 by @xmath57 can terminate only if the predicate at lines  c[sa - c-15]-c[sa - c-16 ] is satisfied .",
    "let @xmath129 be any simulator in the set @xmath97 defined at line  c[sa - c-15 ] .",
    "we show that @xmath276 = view$ ] implies that we eventually have @xmath277 = view$ ] , and thus that @xmath60 must decide .",
    "simulator @xmath57 assigns @xmath249 to @xmath276 $ ] at line  b[sa - b-48 ] .",
    "this can happen only because @xmath57 received viewwitness@xmath278 messages from more than @xmath202 different simulators . according to theorem  [ theo - generic - pattern ]",
    ", @xmath60 eventually receives enough viewwitness@xmath278 messages and also assigns @xmath249 to @xmath277 $ ] .",
    "simulator @xmath60 will then also have to decide .",
    "[ lemma : at - most - one - blocked - byz ] the invocations of @xmath196 by all the correct simulators on all the safe agreement objects terminate , except for at most @xmath1 safe agreement objects .",
    "suppose , by way of contradiction , that there are @xmath220 safe agreement objects such that at least one correct simulator never terminates its invocation of @xmath18 .",
    "by lemma [ lemma : one - decides - all - decide ] , there must be @xmath0 different safe agreement objects in which no correct simulator terminates its invocations of @xmath18 .",
    "the invocation of the @xmath18 operation by a correct simulator @xmath57 on a safe agreement object can only be blocked at lines  c[sa - c-15]-c[sa - c-16 ] , if the corresponding predicate is never satisfied .",
    "this can happen if ( 1 ) there is no simulator @xmath60 such that @xmath236 \\neq \\bot$ ] or , ( 2 ) for every non - empty set of simulators @xmath97 , there are two simulators @xmath279 and @xmath131 such that @xmath280[z ] \\neq \\bot \\wedge all\\_views_i[z ] = \\bot$ ] . because a correct simulator @xmath57 invokes @xmath17 before invoking @xmath18 , case ( 1 ) can not happen ; we always have @xmath281 \\neq \\bot$ ] .",
    "we then consider case ( 2 ) .",
    "case ( 2 ) can happen if @xmath131 starts an invocation of @xmath17 and communicates its proposed value to other processes , but does not terminate its invocation by communicating its view . because there are at most @xmath1 faulty simulators , by the pigeonhole principle , there must be a faulty simulator @xmath131 that prevents @xmath57 from deciding on two different safe agreement objects .",
    "a correct simulator @xmath129 broadcasts a valuevalid@xmath282 after receiving a value@xmath282 message only if the predicate @xmath283 is satisfied ( line  b[sa - b-15 ] ) . due to the predicate @xmath284 ,",
    "this is true only if @xmath129 received viewwitness@xmath282 messages from at least @xmath244 different simulators , each of these messages corresponding to the all the value@xmath282 and valuevalid@xmath282 messages that it has previously received ( see the definition of the predicate @xmath242 of @xmath283 ) .",
    "let @xmath285 be the invocation of @xmath17 by @xmath131 on the first safe agreement object on which @xmath57 is blocked , and @xmath286 the one on the second safe agreement object on which @xmath57 is blocked .",
    "because there is a simulator @xmath279 such that @xmath280 \\neq \\bot$ ] in the two invocations of @xmath18 by @xmath57 , in both cases , more than @xmath202 different simulators have broadcast a viewwitness@xmath287 message ( line  b[sa - b-48 ] ) .",
    "both sets include correct simulators .",
    "they must then have received valueack@xmath288 and valueack@xmath289 from more than @xmath202 different simulators ( line  b[sa - b-38 ] ) .",
    "again , both sets include correct simulators that must have received valuewitness@xmath288 and valuewitness@xmath289 from more than @xmath202 different simulators ( line  b[sa - b-21 ] ) .    in order to broadcast a valuewitness@xmath282 message ,",
    "a correct simulator must either ( a ) receive valuewitness@xmath282 messages from at least @xmath220 different simulators ( line  b[sa - b-18 ] ) , or ( b ) receive valuevalid@xmath282 messages from more than @xmath202 different simulators ( line  b[sa - b-16 ] ) .",
    "the first correct simulator that broadcasts a valuewitness@xmath282 message must then have received valuevalid@xmath282 messages from more than @xmath202 different simulators .    according to lemma [ lemma : quorum - intersection ] , there is a least one correct simulator @xmath290 that broadcasts both valuevalid@xmath282 messages ( line  b[sa - b-15 ] ) . in order to do so",
    ", the predicate @xmath291 must have been verified at the time that @xmath290 broadcast the valuevalid@xmath289 message .",
    "it must then have received the viewwitness@xmath292 messages that correspond to @xmath293 from more than @xmath202 different simulators . according to theorem  [ theo - generic - pattern ] , @xmath57",
    "must then also have received these messages from more than @xmath202 different simulators and assigned @xmath249 to @xmath146 $ ] ( line  b[sa - b-48 ] ) in the instance that corresponds to the invocation of @xmath285 by @xmath131 , a contradiction that concludes the proof of the lemma .",
    "[ [ agreement ] ] agreement + + + + + + + + +    for any simulator @xmath71 and any correct simulator @xmath57 , if @xmath57 assigns a non-@xmath69 value @xmath45 to @xmath70 $ ] , then @xmath294 no value @xmath295 is ever assigned to @xmath296 $ ] by a correct simulator @xmath60 and @xmath297 each such correct simulator @xmath60 eventually assigns @xmath45 to @xmath296 $ ] .",
    "[ lemma - byz - uniform ]    let @xmath129 be the first simulator that assigns @xmath45 to @xmath298 $ ] . since @xmath129 executes line  b[sa - b-22 ] , it received strictly more than @xmath202 valuewitness  @xmath77 messages from different simulators .",
    "at least @xmath220 correct simulators consequently sent this message to all processes at line  b[sa - b-17 ] or at line  b[sa - b-19 ] . by theorem  [ theo - generic - pattern ] , every correct simulator @xmath60 consequently eventually receives such a message from each correct simulator and assigns @xmath45 to @xmath296 $ ] .",
    "suppose that there exists a value @xmath299 such that there is a correct simulator @xmath290 that assigns @xmath46 to @xmath300 $ ] .",
    "suppose that @xmath290 is the first process to do so .",
    "it follows that @xmath290 received valuewitness  @xmath301 messages from strictly more than @xmath202 different processes ( line  b[sa - b-21 ] or line  b[sa - b-24 ] ) .",
    "consider the first correct simulator that broadcasts a valuewitness  @xmath301 message . in order to do so",
    ", it must have received valuevalid",
    "@xmath301 messages from strictly more than @xmath202 different processes ( lines  b[sa - b-16]-b[sa - b-17 ] ) .",
    "however , the first correct simulator that broadcasts a valuewitness  @xmath77 message must also have received valuevalid",
    "@xmath77 messages from strictly more than @xmath202 different processes .",
    "there must then be a correct simulator that sent both valuevalid",
    "@xmath109 messages .",
    "the only place a correct simulator can send a valuevalid  @xmath109 message is at line  [ sa - b-15 ] and it does so only once for each simulator @xmath71 , a contradiction which concludes the proof of the lemma .    for any simulators @xmath302 and any correct simulator @xmath57 , if @xmath57 assigns a non-@xmath69 value @xmath45 to @xmath303[k][x]$ ] , then @xmath294 no value @xmath299 is ever assigned to @xmath304[k][x]$ ] by a correct simulator @xmath60 and @xmath297 each such correct simulator @xmath60 eventually assigns @xmath45 to @xmath304[k][x]$ ] .",
    "[ lemma - byz - uniform - reads ]    the proof is the same as for lemma  [ lemma - byz - uniform ] .    for any simulator @xmath71 and any correct simulator @xmath57 ,",
    "if @xmath57 assigns a non-@xmath69 value @xmath249 to @xmath74 $ ] , then ( 1 ) no value @xmath305 is ever assigned to @xmath306 $ ] by a correct simulator @xmath60 and ( 2 ) each such correct simulator @xmath60 eventually assigns @xmath249 to @xmath306 $ ] .",
    "[ lemma - byz - uniform - view ]    the proof is the same as for lemma  [ lemma - byz - uniform ] .",
    "[ lemma : safe - byz - agreement ] no two invocations of @xmath18 return different values .",
    "let us recall that the algorithm implementing the operation @xmath307 is described at lines  c[sa - c-15]-c[sa - c-19 ] .",
    "let @xmath57 and @xmath60 be two correct simulators .",
    "according to lemmas  [ lemma - byz - uniform]-[lemma - byz - uniform - view ] , we have :    * @xmath117\\neq \\bot ) ~\\wedge~(values_j[x]\\neq \\bot )        ~\\rightarrow~(values_i[x]=values_j[x])$ ] . * @xmath308[k][x]\\neq?\\land answers_j[\\ell][k][x]\\neq ? )        \\rightarrow(answers_i[\\ell][k][x]=answers_j[\\ell][k][x])$ ] . * @xmath118\\neq \\bot ~\\wedge~ all\\_view_j[x]\\neq \\bot )        ~\\rightarrow~(all\\_views_i[x]=all\\_view_j[x])$ ] .",
    "let us assume , by contradiction , that @xmath57 and @xmath60 decide different values .",
    "this means that the sets @xmath96 and @xmath119 computed at line  c[sa - c-17 ] by @xmath57 and @xmath60 , respectively , are different .",
    "since @xmath96 and @xmath119 are different , let us consider @xmath120 ( if @xmath121 , swap @xmath122 and @xmath61 ) . according to the closure predicate used at line  c[sa - c-16 ] , as @xmath123",
    ", we have @xmath124[z]=\\bot$ ] .",
    "it follows that @xmath60 received viewwitness ( @xmath309 $ ] ) messages ( with @xmath310[z]=\\bot$ ] ) from a set of simulators @xmath311 of size strictly larger than @xmath202 ( the subscript @xmath312 stands for `` view witness '' ) .",
    "the correct simulators of @xmath311 sent these messages after checking at line  b[sa - b-39 ] that a set @xmath313 of strictly more than @xmath202 reliably broadcast ( thanks to the mechanism of lines  b[sa - b-26 ] to b[sa - b-33 ] ) a readanswer ( @xmath127 ) message .",
    "the correct simulators of @xmath313 sent these messages at line  b[sa - b-26 ] after they received valueack ( @xmath314 ) messages from a set @xmath139 of strictly more than @xmath202 simulators ( the subscript @xmath107 stands for `` witness '' ) .",
    "each correct simulator @xmath129 of @xmath139 had @xmath315=v_y$ ] when it sent this message and it happens strictly before the first correct simulator sends a readanswer ( @xmath127 ) message .    since @xmath145",
    ", the correct simulator @xmath57 received viewwitness ( @xmath316 $ ] ) messages from a set @xmath317 of strictly more than @xmath202 simulators .",
    "the correct simulators of @xmath317 sent these messages after the check of the values at lines  b[sa - b-38]-b[sa - b-39 ] .",
    "suppose that some of them verified the predicate of line  b[sa - b-39 ] for @xmath137 .",
    "it entails that a set @xmath318 of strictly more than @xmath202 simulators reliably broadcast a readanswer ( @xmath141 ) .",
    "the correct simulators of @xmath318 sent this message after receiving at line  b[sa - b-24 ] valueack ( @xmath319 ) messages from a set @xmath134 of strictly more than @xmath202 simulators .",
    "this happens strictly before the first readanswer ( @xmath141 ) message is sent by a correct simulator .",
    "since @xmath320 , @xmath321 contains at least a correct simulator @xmath189 .",
    "simulator @xmath189 thus broadcast a readanswer ( @xmath127 ) message and a readanswer ( @xmath141 ) message ( line b[sa - b-26 ] ) .",
    "it then had @xmath322 = \\bot$ ] before broadcasting the readanswer ( @xmath127 ) message and @xmath323 = \\bot$ ] before broadcasting the readanswer ( @xmath141 ) .",
    "because of the first instruction of line  b[sa - b-25 ] this is impossible , and thus each correct process that sends a viewwitness ( @xmath324 $ ] ) message ended the wait instruction of lines  b[sa - b-38]-b[sa - b-39 ] by verifying the predicate of line  b[sa - b-38 ] .",
    "this entails that @xmath325\\neq\\bot \\rightarrow all\\_views_x[z][y]\\neq\\bot$ ] .",
    "consequently , @xmath146[y]\\neq\\bot$ ] .    since @xmath145 , @xmath146\\neq\\bot$ ] and thus @xmath146[y]\\neq\\bot$ ] .",
    "according to the predicate of line  c[sa - c-16 ] , this entails that @xmath147 , and since the previous reasoning holds for any @xmath125 , it shows that @xmath148 .",
    "it follows that , when @xmath57 executes line  c[sa - c-17 ] , @xmath149\\neq\\bot$ ] and , consequently , @xmath149=all\\_views_j[y]$ ] .",
    "it entails that if @xmath150 , then @xmath119 would have been chosen by @xmath57 at line  c[sa - c-17 ] , which proves that @xmath151 and contradicts the fact that @xmath57 and @xmath60 decide differently .",
    "[ [ correct - values - are - valid ] ] correct values are valid + + + + + + + + + + + + + + + + + + + + + + + +    [ lemma - correct - is - valid ] if a correct simulator @xmath57 decides the value @xmath45 , there is a correct simulator @xmath60 such that @xmath195 .",
    "let @xmath45 be the value decided by a correct simulator @xmath57 .",
    "value @xmath45 has then be proposed by a simulator @xmath60 such that @xmath236\\neq \\bot$ ] ( definition of @xmath97 at lines  [ sa - c-15]-c[sa - c-16 ] and choice of value at line  c[sa - c-18 ] ) . in order to assign a non-@xmath69 value to @xmath236 $ ]",
    ", @xmath57 must have received viewwitness@xmath219 messages from more than @xmath202 different simulators ( lines  b[sa - b-47]-b[sa - b-48 ] ) , and consequently from at least one correct simulator .",
    "consider the first correct simulator @xmath71 that has broadcast a viewwitness@xmath219 message . before sending it",
    ", it must have assigned a non-@xmath69 value to @xmath326 $ ] ( lines b[sa - b-35]-b[sa - b-42 ] ) .",
    "it then has received either ( a ) valuewitness@xmath219 messages from more than @xmath202 different simulators or ( b ) valueack@xmath219 messages from more than @xmath202 different simulators .    in case ( a ) ,",
    "consider the first correct simulator @xmath129 that has broadcast a valuewitness@xmath219 message . in order to do so",
    ", it must have received valuevalid@xmath219 messages from more than @xmath202 different simulators ( lines  b[sa - b-16]-[sa - b-17 ] ) .",
    "the predicate @xmath327 must have been satisfied at the simulators that broadcast these messages(line  b[sa - b-15 ] ) . in case",
    "( b ) , the first correct simulator that has broadcast a valueack@xmath219 message must first have received valuewitness@xmath219 messages from more than @xmath202 different simulators ( lines b[sa - b-21]-b[sa - b-23 ] ) .",
    "the situation is then similar to case ( a ) .",
    "[ theorem - sa - object - is - correct ] the algorithms described in figure  _ [ algo - sa - msg - passing - byzantine - propose ] _ and figure  _ [ algo - sa - msg - passing - byzantine - answers ] _ implement a safe - agreement object in @xmath37 $ ] .",
    "the proof follows from the previous lemmas .",
    "[ [ simulation - algorithm-1 ] ] simulation algorithm + + + + + + + + + + + + + + + + + + + +    when we consider the simulation algorithm described in figure  [ algo : simulation - crash ] , we observe that the @xmath2 simulators communicate only through safe agreement objects .",
    "it follows that the same algorithm works in @xmath37 $ ] , when the crash - tolerant safe agreement objects are replaced by byzantine - tolerant safe agreement objects previously described .",
    "two things remain to be done : define the specific sub - predicate @xmath243 of the predicate @xmath192 , and do a specific proof of this algorithm ( i.e. , a proof based on the specification of the byzantine - tolerant safe agreement objects defined in section  [ sec : spec - byzantine - sa ] ) .",
    "[ [ sub - predicate - p2 ] ] sub - predicate @xmath243 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    as far as @xmath243 is concerned we have the following .",
    "let us consider the simulator @xmath57 that invokes @xmath193 , with respect to the simulation of a process @xmath78 . in the simulation algorithm ,",
    "the parameter @xmath45 is the message @xmath328 that @xmath60 proposes to a safe agreement object from which will be decided the next message to be received by the simulated process @xmath78 ( lines  [ simu - c-08]-[simu - c-09 ] of figure  [ algo : simulation - crash ] ) .",
    "@xmath243 checks , from @xmath57 s local point of view , that , if the message @xmath45 has been sent in the simulation , then it has not yet been consumed , i.e. , @xmath329)~\\rightarrow~(v \\notin received_i[x])$ ] .    [ [ proof - of - the - simulation - algorithm - in - cal - bamp_nttn3 ] ] proof of the simulation algorithm in @xmath37 $ ] + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    [ lemma : at - most - one - crash - byz ] the simulation of at most @xmath1 simulated processes can be blocked .",
    "the only places where a correct simulator @xmath57 can block is during the invocation of the safe agreement operation @xmath18 .",
    "such invocations appear at line  [ simu - c-02 ] , and line  [ simu - c-11 ] .    because the invocations by all the correct simulators of @xmath196 on all the safe agreement objects terminate , except for at most @xmath1 safe agreement objects ( lemma [ lemma : at - most - one - blocked - byz ] ) , the simulation of at most @xmath1 simulated processes can be blocked .",
    "[ lemma : same - seq - of - messages - byz ] the simulation of the reception of the @xmath6-th message received by a simulated process @xmath27 , returns the same message at all correct simulators .",
    "the simulation of the message receptions for a simulated process @xmath27 , are executed at each correct simulator @xmath57 at lines  [ simu - c-08]-[simu - c-11 ] , and all the correct simulators use the same sequence of sequence numbers ( line  [ simu - c-07 ] ) .",
    "it then follows from the agreement property of the safe agreement object @xmath161 $ ] , that no two correct simulators obtain different messages when they invoke @xmath161.{\\sf decide}()$ ] , and the lemma follows .",
    "[ lemma : one - dec - value - byz ] for every simulated processes @xmath27 , no two correct simulators return different values .",
    "the only non - deterministic elements of the simulation are the input vectors @xmath159 $ ] at each simulator @xmath57 , and the reception of the simulated messages .    the lines  [ simu - c-01]-[simu - c-02 ] of the simulation force the correct simulators to agree on the same input value for each simulated process @xmath27 , @xmath188 .",
    "similarly , as shown by lemma  [ lemma : same - seq - of - messages - byz ] , for each simulated process @xmath27 , the lines  [ simu - c-07]-[simu - c-11 ] direct the simulators to agree on the very same sequence of messages received by @xmath27 .",
    "it follows from the fact that the function @xmath170 is deterministic , that any two correct simulators @xmath57 and @xmath129 , that execute lines  [ simu - c-15]-[simu - c-16 ] during the same `` round number '' @xmath164=sn_k[j]$ ] , are such that @xmath169=state_k[j]$ ] , from which the lemma follows .",
    "[ lemma : correct - simulation - byz ] the sequences of message receptions simulated by each simulator @xmath57 on behalf of each simulated process @xmath27 , define a correct execution of the simulated algorithm .",
    "to prove the correctness of the simulation , we have to show that    1 .",
    "[ item0-byz ] every message that was received by a simulated process was sent by another simulated process , 2 .",
    "[ item1-byz ] every message that was sent by a simulated process to another simulated process ( whose simulation is not blocked either ) , is received , and 3 .",
    "[ item2-byz ] the simulated messages respect a simulated physical order ( i.e. , no message is `` received '' before being `` sent '' ) .",
    "item  [ item0-byz ] follows from lemma [ lemma - correct - is - valid ] and from the definition of @xmath243 .",
    "item  [ item1-byz ] is satisfied because the messages sent by the simulated process @xmath27 to the simulated process @xmath189 are received ( lines  [ simu - c-09]-[simu - c-11 ] ) in their sending order ( as defined at line  [ simu - c-04 ] and line  [ simu - c-14 ] ) .",
    "hence , if @xmath189 is not blocked ( due to a faulty simulator ) it obtains the messages from @xmath27 in their sending order .    for item  [ item2-byz ] ,",
    "let us define a ( simulated ) physical order as follows .",
    "for each simulated message @xmath30 , let us consider the first time at which the reception of @xmath30 was simulated ( i.e. , this occurs when for the first time a simulator terminates the invocation of @xmath190.{\\sf decide}()$ ] that returns @xmath30 ) .",
    "a message that is decided has been proposed by a simulator to a safe agreement object before being decided ( validity property).the sending time of a simulated message is then the first time at which @xmath190.{\\sf propose}(m)$ ] is invoked by a simulator .",
    "it follows that any simulated message is sent before being received , which concludes the lemma .",
    "[ lemma : nb - simulated - proc - byz ] each correct simulator @xmath57 computes the decision value of at least @xmath191 simulated processes .    due to lemma  [ lemma",
    ": at - most - one - crash - byz ] , and the fact that at most @xmath1 simulators may be byzantine , it follows that at most @xmath1 simulated processes may be prevented from progressing . as ( a ) by assumption",
    "the simulated algorithm @xmath54 is @xmath1-resilient , and ( b ) due to lemma  [ lemma : correct - simulation - byz ] the simulation produces a correct simulation of @xmath54 , it follows that at least @xmath191 simulated processes decide a value .",
    "[ theorem : main - simulation - byz ] let @xmath158 be an algorithm solving a decision task in @xmath55 $ ] .",
    "the algorithm described in figure  [ algo : simulation - crash ] , in which byzantine - tolerant safe agreement objects are used , is a correct simulation of @xmath158 in  @xmath37 $ ] .",
    "the theorem follows from lemma  [ lemma : correct - simulation - byz ] and lemma  [ lemma : nb - simulated - proc - byz ] .",
    "additionally , the reader can easily check that the simulation of a message only requires a polynomial number of messages in the base system , and the increase in size of these messages , when compared to the size of the simulated message , is also polynomial .",
    "[ [ bg - simulation - in - byzantine - message - passing - systems ] ] bg - simulation in byzantine message - passing systems + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a main result of this paper is a signature - free distributed algorithm that solves bg - simulation in byzantine asynchronous message - passing systems .",
    "in addition to being the first algorithm that solves bg - simulation in such a severe failure context , the proposed simulation algorithm has noteworthy applications as shown below .",
    "[ [ from - byzantine - failures - to - crash - failures - in - message - passing - systems ] ] from byzantine - failures to crash failures in message - passing systems + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the simulation presented here allows the execution of a @xmath1-resilient crash - tolerant algorithm in an asynchronous message - passing system where up to @xmath1 processes may be byzantine .",
    "a feature that is sometimes required from a byzantine - tolerant algorithm solving a task ( not usually considered in the crash failure case ) is that the value decided by any correct process should be based only on inputs of correct processes .",
    "this prevents byzantine processes from `` polluting '' the computation with their inputs .",
    "a way to guarantee that an input has been proposed by a correct process is to check that it has been proposed by at least @xmath0 different processes . assuming that in any execution at most @xmath30 values are proposed , this constraint translates as @xmath330  @xcite .    in the case of the simulation presented in section  [ sec : bg - byzantine - model ] , this requirement can easily be satisfied by adding a first step of computation before the start of the simulation .",
    "simulators first broadcast their input .",
    "they then echo every value that they receive from more than @xmath220 different simulators , and consider these values ( and only these values ) as valid inputs .",
    "an input considered valid by a correct simulator is then eventually considered valid by all correct simulators , and the only inputs allowed in the simulation are inputs of correct simulators .",
    "because we consider colorless tasks , the choice of output is done in the same way as in the original bg - simulation : a simulator can adopt the output of any simulated process that has decided a value .",
    "the possible byzantine behaviors are restrained by the underlying byzantine - tolerant safe agreement objects used in the simulation .",
    "surprisingly , this shows that , from the point of view of the computability of colorless tasks and assuming @xmath331 ( this requirement always implies @xmath252 when at least two different values can be proposed ) , byzantine failures are equivalent to crash - failures .",
    "this provides us with a new understanding of byzantine failures and shows that their impact can be restricted to the much simpler crash - failure case .",
    "[ [ from - wait - free - shared - memory - to - message - passing ] ] from wait - free shared memory to message - passing + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the proposed simulation can be combined with previous works to further extend the scope of the result .",
    "consider an algorithm @xmath332 that solves a colorless task , where @xmath333 , in a wait - free read / write memory system of @xmath220 processes , denoted @xmath334 $ ] . using the basic bg - simulation  @xcite , this algorithm can be transformed into an algorithm @xmath335 that works in the @xmath1-resilient read / write memory system of @xmath336 processes , in which at most @xmath1 can crash .",
    "this model is denoted @xmath337 $ ] .",
    "using an implementation of a read / write memory in a crash - prone message - passing system in which a majority of processes are correct  @xcite , we obtain an algorithm @xmath338 which work in @xmath339 $ ] ( message - passing system system of @xmath336 processes , in which at most @xmath1 can crash ; notice that @xmath340 ) . finally , using the simulation presented in this paper , we obtain byzantine - tolerant algorithm @xmath341 which works in @xmath342 $ ] ( message - passing system of @xmath336 processes , of which at most @xmath1 can be byzantine ; notice that @xmath343 ) .",
    "these transformations show that , as far as the computability of colorless tasks that admit up to @xmath333 different input values is concerned , an @xmath2-process byzantine - prone message - passing system , in which up to @xmath344 processes can be byzantine , is equivalent to a wait - free shared memory system of @xmath220 processes , which at most commit crash failures . when considering colorless tasks with @xmath333 , a figure relating these transformations is depicted in figure  [ figure - stacking ] .",
    "differently from the full - information algorithm presented in  @xcite , the simulation presented in the present paper ( along with  @xcite and  @xcite ) allows a _ direct _ transformation of any wait - free shared - memory algorithm that solves a colorless task into a message - passing byzantine - tolerant algorithm .",
    "[ figure - stacking ]",
    "this work has been partially supported by the franco - german dfg - anr project 40300781 .",
    "this project ( named discmat ) is devoted to mathematical methods in distributed computing .",
    "the authors would like to thank sergio rajsbaum for discussions on the bg simulation ."
  ],
  "abstract_text": [
    "<S> the bg - simulation is a powerful reduction algorithm designed for asynchronous read / write crash - prone systems . </S>",
    "<S> it allows a set of @xmath0 asynchronous sequential processes to wait - free simulate ( i.e. , despite the crash of up to @xmath1 of them ) an arbitrary number @xmath2 of processes under the assumption that at most @xmath1 of them may crash . </S>",
    "<S> the bg simulation shows that , in read / write systems , the crucial parameter is not the number @xmath2 of processes , but the upper bound @xmath1 on the number of process crashes .    </S>",
    "<S> the paper extends the concept of bg simulation to asynchronous message - passing systems prone to byzantine failures . </S>",
    "<S> byzantine failures are the most general type of failure : a faulty process can exhibit any arbitrary behavior . because of this , they are also the most difficult to analyze and to handle algorithmically . </S>",
    "<S> the main contribution of the paper is a signature - free reduction of byzantine failures to crash failures . assuming @xmath3 </S>",
    "<S> , the paper presents an algorithm that simulates a system of @xmath4 processes where up to @xmath1 may crash , on top of a basic system of @xmath2 processes where up to @xmath1 may be byzantine . </S>",
    "<S> while topological techniques have been used to relate the computability of byzantine failure - prone systems to that of crash failure - prone ones , this simulation is the first , to our knowledge , that establishes this relation directly , in an algorithmic way .    </S>",
    "<S> in addition to extending the basic bg simulation to message - passing systems and failures more severe than process crashes , being modular and direct , this simulation provides us with a deeper insight in the nature and understanding of crash and byzantine failures in the context of asynchronous message - passing systems . </S>",
    "<S> moreover , it also allows crash - tolerant algorithms , designed for asynchronous read / write systems , to be executed on top of asynchronous message - passing systems prone to byzantine failures . + </S>",
    "<S> * keywords : * asynchronous processes , bg simulation , byzantine process , distributed computability , fault - tolerance , message - passing system , process crash , read / write shared memory system , reduction algorithm , @xmath1-resilience , system model , wait - freedom . </S>"
  ]
}