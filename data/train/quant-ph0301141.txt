{
  "article_text": [
    "in 1994 peter shor presented two efficient quantum algorithms @xcite for computational problems for which no polynomial time classical algorithms are known .",
    "one problem is to decompose a ( large ) integer into its prime factors .",
    "the other problem , which we consider here , is finding discrete logarithms over finite groups .",
    "the classical complexity of this problem seems to depend strongly on the underlying group . a case for which ( known ) classical algorithms",
    "are particularly inefficient are elliptic curve groups defined over finite fields .",
    "actually most public key cryptography in use today relies either on the presumed hardness of integer factoring ( rsa ) or that of discrete logarithms over finite fields or elliptic curves .",
    "elliptic curve cryptography ( ecc ) is sometimes preferred because it allows shorter key sizes than rsa .",
    "this is because the best classical integer factoring algorithms ( the number field sieve , see e.g. @xcite ) , although superpolynomial , have less than exponential complexities .",
    "very roughly the complexity is @xmath2 , where @xmath3 is the integer to be factored . on the other hand , for discrete logarithms over elliptic curves , nothing better than `` generic '' algorithms",
    "are known , thus algorithms which work for any group .",
    "these algorithms , e.g. the pollard @xmath4 algorithm @xcite , have truly exponential complexity .",
    "shor s quantum algorithms for integer factoring and discrete logarithms have about equal complexity , namely typically @xmath5 .",
    "thus there is a larger complexity gap between classical and quantum for discrete logarithms than for factoring .",
    "proposals have been made @xcite for optimised implementations of the quantum factoring algorithm , in particular for minimising the number of qubits needed .",
    "the best current result by s.beauregard @xcite is that about @xmath6 qubits are enough .",
    "we attempt here a similar optimisation for discrete logarithms over elliptic curves .",
    "the implementation is more difficult , but we still get an algorithm that uses less qubits and time to solve a problem of similar classical difficulty when compared to factoring . for problems that can now barely be solved , the number of qubits is not much less than for factoring , but in the future , with more powerful classical computers , the gap will increase .",
    "elliptic curves used in cryptography @xcite are defined either over the field of arithmetic modulo a prime , thus @xmath7 , or over @xmath8 . for our implementation we need to do arithmetic operations in these fields , in particular we must compute multiplicative inverses . for @xmath7 , this is done with euclid s algorithm for computing the greatest common divisor ( gcd ) , or rather the extended version of this algorithm .",
    "this algorithm can be adapted to the case of any finite field @xmath9 , but for @xmath10 there is the added concern of deciding how the elements of the field will be represented .",
    "so in this paper we only consider elliptic curves over @xmath7 .",
    "still , the implementation of the extended euclidean algorithm is the main technical difficulty we encounter .",
    "fortunately , the algorithm can be made piecewise reversible , so that not too much `` garbage '' has to be accumulated . as for the factoring algorithm , it is possible to run the whole algorithm with @xmath11 qubits . for our implementation of euclid s algorithm to achieve the classical time complexity of @xmath12 , it is necessary to terminate the steps in the algorithm at different points , depending on the input .",
    "this is difficult to achieve with acyclic circuits ( which are necessary for computations in `` quantum parallelism '' ) .",
    "we will relegate some of the more cumbersome technical aspects of our solution to an appendix , and will also discuss possible other approaches .",
    "in trying to optimise our implementation , we were guided by practical considerations , although to do this , one would really have to know how an actual quantum computer will look .",
    "we put most emphasis on minimising the number of qubits , but also on the total number of gates .",
    "we assume that whatever can be computed classically , should be done classically as long as it does nt take an unreasonable amount of computation .",
    "basically we are trying to optimise a quantum circuit where a gate can act on any pair of qubits , but it turns out that most gates are between neighbours like in a cellular automaton .",
    "in contrast to the earlier papers @xcite optimising the quantum factoring algorithm , we have not thought about parallelising the algorithm , although this may well be of interest for actual implementations .",
    "let @xmath13 be a finite cyclic group and let @xmath14 be a generator of @xmath13 .",
    "the discrete logarithm problem over @xmath13 to the base @xmath14 is defined as given an element @xmath15 determine the unique @xmath16 $ ] such that @xmath17 .",
    "the integer @xmath18 is denoted by @xmath19 .",
    "note that while @xmath13 may be a subgroup of a non - abelian group , @xmath13 being cyclic is always an abelian group .",
    "usually it is assumed that the order of @xmath13 is known .",
    "there are two general types of algorithms for solving dlps . the first type , called generic algorithms , work for any group , as long as we have a ( unique ) representation of group elements and we know how to carry out the group operation .",
    "the best known classical generic algorithms have complexity equal to about the square root of the order of the group .",
    "thus they are exponential in the number of bits necessary to describe the problem .",
    "the second type of algorithms are the algorithms which rely on specific properties of the group or its representation .",
    "as shown in the examples below , some groups have group specific algorithms which can solve the dlp in subexponential or even polynomial time .",
    "let @xmath22 be a positive integer and consider the case when @xmath23 the additive group of integers modulo @xmath22 . here",
    "the generators of the group are precisely the @xmath24 such that @xmath25 and the equation @xmath26 can be solved by finding the multiplicative inverse of @xmath14 modulo @xmath22 with the extended euclidean algorithm .",
    "thus for this group the dlp can be solved in polynomial time ( @xmath27 ) .",
    "there are however groups for which the dlp is not so easy .",
    "suppose that @xmath28 the multiplicative group modulo @xmath0 , which is cyclic , and that @xmath14 is a generator of @xmath13 .",
    "then the dlp is equivalent to solving the equation @xmath29 .",
    "there are no known classical algorithms which can solve this problem in polynomial time .",
    "still , like for integer factoring , the best algorithms have a subexponential complexity .",
    "note that if @xmath13 is a finite cyclic group of order @xmath22 then @xmath13 is isomorphic to @xmath20 in which the dlp is easy .",
    "thus it is not the structure of a group , but its representation , which can make its dlp difficult .",
    "elliptic curves over @xmath9 are finite abelian groups . given a point @xmath14 on an elliptic curve we can consider the difficulty of solving the dlp in the cyclic subgroup generated by @xmath14 . for general elliptic curves ( trace not equal to zero or one ) the dlp seems to be computationally quite hard .",
    "in particular for these curves it is not known how to exploit the representation of the group to help solve the dlp .",
    "thus the best known classical algorithms for the dlp on these elliptic curves are the generic algorithms whose running times are exponential in the number of bits necessary to describe the problem .",
    "this presumed classical hardness makes the groups useful for cryptography and has led to systems based on these group being included in ansi , ieee and fips standards @xcite .",
    "both of shor s algorithms have later been understood as special cases of a more general framework , namely the abelian hidden subgroup problem ( see e.g. @xcite ) .",
    "while in the factoring algorithm we are looking at subgroups of the group of integers , @xmath30 , in the discrete logarithm case , subgroups of @xmath31 play a role .",
    "in particular we are looking at sublattices of the lattice @xmath31 , thus elements which can be written as integer linear combinations of two ( linearly independent ) vectors in @xmath31 . thus in a way the discrete logarithm algorithm can be viewed as a 2 dimensional version of the factoring algorithm .",
    "the basis of the integer factoring algorithm is really an order finding algorithm , which we briefly review here .",
    "we are given an element @xmath14 in a ( finite ) group @xmath13 and want to find its order .",
    "that is , the smallest non - negative integer @xmath32 with @xmath33 , where @xmath34 is the neutral element . to do this",
    ", we prepare a ( large ) superposition of @xmath22 `` computational '' basis states @xmath35 and compute @xmath36 in `` quantum parallelism '' : @xmath37 where @xmath22 is much larger than any order @xmath32 that we expect .",
    "now imagine that we measure the second register and get @xmath38 ( the measurement is not actually necessary ) .",
    "then the first register will be left in a superposition of the form @xmath39 where @xmath40 is a random number between @xmath41 and @xmath42 .",
    "now a quantum fourier transform ( of size @xmath22 ) will leave this register in a superposition dominated by basis states that are close to multiples of @xmath43 .",
    "thus a measurement will yield such a state with high probability .",
    "if @xmath22 is chosen larger than the square of any expected order @xmath32 , it is possible to calculate @xmath32 from the observed state with high probability .",
    "also @xmath22 is chosen to be a power of 2 , as this gives the simplest `` quantum fast fourier transform '' ( qfft ) .",
    "first let us justify a simplifying assumption that we make .",
    "we assume that the order of the base @xmath14 of the elliptic curve discrete logarithm is prime and that we know this prime .",
    "this is true for the cases standardised for cryptographic use @xcite .",
    "also , if we do nt know the order of @xmath14 , we can find it with the above order finding algorithm and also decompose it into its prime factors with the integer factoring algorithm .",
    "then there is a standard way to reduce the dlp in a group with composite order , @xmath22 , into several dlps with orders equal to the prime factors of @xmath22 ( see @xcite ) .",
    "thus our simplifying assumption is really without loss of generality .",
    "so we have @xmath44 , with @xmath45 prime and @xmath46 where @xmath18 is unknown and between @xmath41 and @xmath47 .",
    "consider the function @xmath48 for integers @xmath49 and @xmath50 .",
    "this function has two independent `` periods '' in the plane @xmath31 , namely @xmath51 thus all @xmath52 with @xmath53 define a sublattice of @xmath31 .",
    "the 2 dimensional fourier transform then leads to the dual lattice from which @xmath18 can be determined .",
    "note that @xmath54 can be thought of as being defined over @xmath55 as @xmath56 .    for didactic purposes",
    "let us first imagine that we knew a way to carry out the quantum fast fourier transform of order @xmath45 ( qfft@xmath57 ) , as then the algorithm would be particularly nice .",
    "( actually it has been shown how to do this approximatively @xcite , but we wo nt use these constructions . )",
    "then we start with the following state of two quantum registers , and compute @xmath58 in `` quantum parallelism '' : @xmath59 again , imagine that we now measure the last register ( although this is again not necessary ) .",
    "then we will obtain a random element @xmath38 of the group generated by @xmath14 , where @xmath40 is between @xmath41 and @xmath47 .",
    "we will then find the first two registers in a superposition of all @xmath52 with @xmath60 because the order of @xmath14 is @xmath45 , this is equivalent to @xmath61 or equivalently @xmath62 .",
    "thus for each @xmath50 there is exactly one solution , and so the state of the first two registers is : @xmath63 now we fourier transform each of the two registers with our ( hypothetical ) quantum fourier transform of order @xmath45 , which acts on basis states as @xmath64 we obtain @xmath65 the sum over @xmath50 is easy to calculate .",
    "it gives @xmath66 if @xmath67 and vanishes otherwise .",
    "thus we get : @xmath68 we now see that the probability of measuring a basis state is independent of @xmath40 , thus it does nt matter which @xmath40 we measured above . by measuring",
    ", we obtain a pair @xmath69 from which we can calculate @xmath70 as long as @xmath71 .",
    "( the only disadvantage of allowing the order @xmath45 not to be a prime , would be that we would require @xmath72 . )      in practise we will want to replace each of the two qfft@xmath57 s with a quantum fast fourier transform of order @xmath1 ( qfft@xmath73 ) , because this is easy to implement . for the qfft@xmath57 above we will always obtain a pair @xmath69 with @xmath74 in the final measurement .",
    "however , for the qfft@xmath73 we will get a high probability of measuring a pair @xmath69 if @xmath75 for @xmath76 we have a good ( constant ) probability of getting the right values in @xmath55 by rounding . in appendix",
    "[ ft a ] we make this analysis in detail and show that by investing a reasonable amount of classical post - processing we can with probability close to 1 obtain the discrete logarithm with a single run of the quantum algorithm .",
    "( of course this is on a perfect , noise free , quantum computer ... ) more classical post - processing increases the chances of success because now we can try out several values in the vicinity of the values @xmath69 which we measured .",
    "also there is a tradeoff between @xmath3 , thus the number of qubits , and the success probability .",
    "for @xmath3 increasing beyond @xmath77 the probability of failure decreases exponentially .",
    "as mentioned earlier , elliptic curves over finite fields form abelian groups",
    ". we will now present a brief introduction to elliptic curves over fields of characteristic not equal to @xmath78 or @xmath79 ( i.e. @xmath80 and @xmath81 ) . for a more in depth introduction to elliptic curves and their use in cryptography see  @xcite .",
    "let @xmath82 be a field of characteristic not equal to @xmath78 or @xmath79 .",
    "an elliptic curve over @xmath82 is the set of solutions @xmath83 to the equation @xmath84 where @xmath85 are constants such that @xmath86 , together with the point at infinity , which is denoted @xmath87 .",
    "the solutions to equation [ eqnec1 ] are called the finite points on the curve and together with @xmath87 are called the points on the curve .",
    "we will use @xmath88 to denote the set of points on an elliptic curve .",
    "the group operation on the points is written additively and is defined as follows . if @xmath89 then @xmath90 . if @xmath91 then @xmath92 where @xmath93 , @xmath94 , @xmath95 and all operations are performed over the field @xmath82 .",
    "it is not hard to check that if @xmath96 and @xmath97 are on the curve , then so is @xmath98 and thus the above operation is closed on @xmath88 . while not immediately clear , the points on the curve together with the above operation form an abelian group ( for a proof see @xcite ) .",
    "it is clear from the definition of the group operation that @xmath87 is the identity element . if @xmath99 it following directly from equation [ eqnec1 ] that @xmath100 is also a point on the curve .",
    "thus if @xmath101 then the inverse of @xmath102 is @xmath103 .",
    "note that the elliptic curve group operation is defined differently over fields of characteristic @xmath78 or @xmath79 .    a famous theorem by hasse states that if @xmath88 is an elliptic curve defined over @xmath7 then the number of points on @xmath88 , denoted @xmath104 , is @xmath105 where @xmath106 .",
    "this implies that the maximum bit size of the order of a point is approximately the bit size of @xmath0 .    a particular elliptic curve , @xmath88 ,",
    "is specified by giving the base field , @xmath82 , and the constants @xmath85 from equation @xmath107 . for our purposes",
    "the base field @xmath82 will always be @xmath7 for some prime @xmath108 . in practice @xmath109 and @xmath110",
    "are selected such that the order of the group contains a large prime factor , @xmath45 , as this is necessary to make the discrete logarithm problem hard . for simplicity we shall assume that @xmath0 and @xmath45 are approximately the same bit size .",
    "suppose we are given an elliptic curve , @xmath111 , over the field @xmath7 for some prime @xmath108 . in order for a quantum computer to calculate discrete logarithms over @xmath88 we like to have a unique representation of the points on @xmath88 .    if @xmath102 is a finite point on @xmath88 then @xmath101 , where @xmath49 and @xmath50 are integers modulo @xmath0 .",
    "thus any finite point can be represented by a unique ordered pair @xmath112 with @xmath113 .",
    "now all that remains is to determine how @xmath87 will be represented . as will be discussed in section [ allow_err ] , our implementation we will not actually require a representation of @xmath87 .",
    "however , if a representation was required we could simply pick an ordered pair @xmath112 which is not on the curve .",
    "for example , @xmath114 could be used to represent @xmath87 for any curve , while @xmath115 could be used for any curve with @xmath116 .",
    "we consider an elliptic curve , @xmath88 , over @xmath7 , where @xmath0 is a large prime .",
    "the base of the logarithm is a point @xmath89 whose order is another ( large ) prime @xmath45 , thus @xmath117 .",
    "we want to compute the discrete logarithm , @xmath18 , of another point @xmath118 , thus @xmath119 .",
    "( remember that we use additive notation for the group operation , thus instead of a power of the base element , we have an integer multiple . )",
    "as discussed in section [ dlog ] , we need to apply the following transformation @xmath120 thus we need a method of computing ( large ) integer multiples of group elements .",
    "this can be done by the standard `` double and add technique '' .",
    "this is the same technique used for the modular exponentiation in the factoring algorithm , although there the group is written multiplicatively so it s called the square and multiply technique . to compute @xmath121 , first we repeatedly double the group elements @xmath102 and @xmath122 , thus getting the multiples @xmath123 and @xmath124 .",
    "we then add together the @xmath125 and @xmath126 for which the corresponding bits of @xmath49 and @xmath50 are 1 , thus @xmath127 where @xmath128 , @xmath129 , @xmath130 and @xmath131 .",
    "the multiples @xmath125 and @xmath126 can fortunately be precomputed classically . then to perform the above transformation , start with the state @xmath132 .",
    "the third register is called the `` accumulator '' register and is initialised with the neutral element @xmath133 .",
    "then we add the @xmath125 and @xmath126 to this register , conditioned on the corresponding bits of @xmath49 and @xmath50 .      here",
    "we show that the input registers , @xmath134 , can actually be shrunk to a single qubit , thus saving much space .",
    "this is accomplished by using the semiclassical quantum fourier transform and is completely analogous to what has been proposed for the factoring algorithm @xcite ( see also e.g. @xcite ) .",
    "griffiths and niu @xcite have observed that the qfft followed by a measurement can be simplified .",
    "actually it can be described as simply measuring each qubit in an appropriate basis , whereby the basis depends on the previous measurement results .",
    "( in accordance with quantum computing orthodoxy , we can also say that before measuring the qubit in the standard basis , we apply a unitary transformation which depends on the previous measurement results . )",
    "note that in the initial state @xmath135 the qubits in the @xmath49- and @xmath50-registers are actually unentangled .",
    "each qubits is in the state @xmath136 .",
    "now we can see how these two registers can be eliminated : we do @xmath3 steps . in step number @xmath137 we first prepare a qubit in the state @xmath136 , then use it to control the addition of @xmath125 ( or @xmath126 ) and finally we measure the control qubit according to the semiclassical qfft . in this",
    "qfft the qubits have to be measured in reversed order , thus from highest significance to lowest .",
    "thus we will need to proceed from the @xmath138 step down to the @xmath139 step , but this is no problem .    in summary",
    ", we really only need the accumulator register .",
    "we are left being required to carry out a number of steps whereby we add a fixed ( classically known ) point @xmath125 ( or @xmath126 ) to a superposition of points .",
    "we are working in the cyclic group generated by @xmath102 , thus the effect of a fixed addition is to `` shift '' the discrete logarithm of each element in the superposition by the same amount .",
    "for this reason we shall refer to these additions of fixed classical points as `` group shifts '' .",
    "( that the group shifts are conditional on a qubit makes it only insignificantly more difficult , as we will point out later . )",
    "thus we need unitary transformations @xmath140 and @xmath141 which acts on any basis state @xmath142 representing a point on the elliptic curve , as : @xmath143 as explained in section [ dlog ] and appendix [ ft a ] , it is sufficient to do @xmath3 of these steps for @xmath102 and @xmath3 for @xmath122 , thus a total of @xmath6 , where @xmath144 .",
    "so we have already managed to decompose the discrete logarithm quantum algorithm into a sequence of group shifts by constant classically known elements .",
    "that is @xmath145 we propose to only use the addition formula for the `` generic '' case ( i.e. for @xmath146 where @xmath147 and @xmath148 ) for the group operation , although it would nt be very costly to properly distinguish the various cases .",
    "still , it s not necessary .",
    "first note that the constant group shifts @xmath149 and @xmath150 are not equal to the neutral element @xmath133 , because @xmath102 and @xmath122 have order a large prime .",
    "( if a group shift was @xmath133 , we would of course simply do nothing . ) still , we are left with three problems .",
    "first , that a basis state in the superposition may be the inverse of the group shift .",
    "second , that a basis state in the superposition may equal the group shift .",
    "lastly , that a basis state in the superposition may be @xmath87 .",
    "we argue that with a small modification these will only happen to a small fraction of the superposition and thus the fidelity lost is negligible .",
    "to ensure a uniformly small fidelity loss , we propose the following modification at the beginning of the dlp algorithm : choose ( uniformly ) at random an element @xmath151 in the group generated by @xmath102 .",
    "then we initialise the accumulator register in the state @xmath152 , instead of @xmath153 .",
    "this overall group shift is irrelevant , as after the final qfft it only affects the phases of the basis states . now on average in each group shift step we `` loose '' only a fraction of @xmath154 of the superposition by not properly adding inverses of points and an equal amount for not correctly doubling points .",
    "thus the total expected loss of fidelity from this error during the @xmath155 group shifts is @xmath156 and is thus an exponentially small amount .",
    "as the accumulator no longer begins in the state @xmath157 , the superposition @xmath142 to which @xmath158 will be applied can only contain @xmath157 if an inverse was ( correctly ) added in the previous addition .",
    "thus @xmath87 being a basis state in the superposition will not cause any further loss of fidelity .",
    "the group shift is clearly reversible . a standard procedure might be to do @xmath159 where in the last step we would uncompute @xmath160 by running the addition of @xmath161 to @xmath162 backwards .",
    "fortunately we can do better than this generic technique . in terms of the coordinates of the points ,",
    "the group shift is : @xmath163 recall that @xmath164 if and only if @xmath165 and that this portion of the superposition can be lost ( see section [ allow_err ] ) . thus we use the following group operation formulas ( see eq .",
    "[ ecop ] ) : @xmath166 the second expression for @xmath167 is not difficult to obtain .",
    "it will allow us to later uncompute @xmath167 in terms of @xmath69 . actually , when computing @xmath167 from @xmath52 we can directly uncompute @xmath50 , and similarly we can get @xmath168 when uncomputing @xmath167 : @xmath169 where a double - sided arrow ( @xmath170 ) indicates that we need to do these operations reversibly , thus in each step we need also to know how to go backward . note that the decomposition of one large reversible step into several smaller individually reversible ones , is nice because it saves space , as any `` garbage '' can be uncomputed in each small step . in more detail",
    "the sequence of operations is : @xmath171 where all the operations are done over @xmath7 .",
    "the second line is essentially doing the operations of the first line in reverse .",
    "the first and last steps are just modular additions of the constants @xmath172 .",
    "they clearly need much less time ( and also less qubits ) than the multiplications and divisions ( see @xcite ) , so we will ignore them when calculating the running times .",
    "the operation in the middle essentially involves adding the square of @xmath167 to the first register .",
    "this operation , too , is relatively harmless .",
    "it uses less `` work '' qubits than other operations and thus does nt determine the total number of qubits needed for the algorithm .",
    "still , for time complexity we have to count it as a modular multiplication ( more about this below ) .",
    "so a group shift requires two divisions , a multiplication and a few additions / subtractions .",
    "the remaining two operations are a division and multiplication where one of the operands is uncomputed in the process .",
    "the division is of the form @xmath174 , where @xmath175 .",
    "( different @xmath49 and @xmath50 than the last section ! ) .",
    "the multiplication in ( [ eqngs ] ) is simply the division run in the reverse direction .",
    "we further decompose the division into four reversible steps : @xmath176 where the letters over the arrows are @xmath177 for `` multiplication '' and @xmath88 for `` euclid s algorithm '' for computing the multiplicative inverse modulo @xmath0 .",
    "the second @xmath177 is really a multiplication run backwards to uncompute @xmath50 .",
    "before concentrating on euclid s algorithm , let s look at the modular multiplications of the form @xmath178 .",
    "in the quantum factoring algorithm the modular exponentiation is decomposed into modular multiplications .",
    "but there one factor is a fixed `` classical '' number .",
    "still , the situation when we want to act on superpositions of both factors , is not much worse .",
    "so we want to do ( explicitly writing mod @xmath0 for clarity ) : @xmath179 we now decompose this into a sequence of modular additions and modular doublings : @xmath180 so we do a series of the following operations on the third register : @xmath181      the modular doubling is a standard doubling ( a left shift by one bit ) followed by a reduction mod @xmath0 .",
    "thereby we either subtract @xmath0 or do nt do anything .",
    "whether we subtract @xmath0 has to be controlled by a control qubit . at the end",
    "this control qubit can be uncomputed simply by checking whether @xmath182 mod @xmath0 is even or odd ( because @xmath0 is odd ) . for the addition or subtraction of a fixed number like @xmath0 we need @xmath3 carry qubits ,",
    "which have to be uncomputed by essentially running the addition backwards ( but not undoing everything ! ) . to do the reduction mod @xmath0 we will now in any case subtract @xmath0 , check whether the result is negative , and depending on that , either only uncompute the carry bits or undo the whole subtraction . in the end",
    "the operation is only slightly more complicated than the addition of a fixed number .",
    "the second step is a modular addition of the form @xmath183 .",
    "again we first make a regular addition .",
    "this is only slightly more complicated than the addition of a fixed number ( see e.g. @xcite pp .",
    "then , again , we either subtract @xmath0 or not . to later uncompute the control bit which controlled this , we have to compare @xmath49 and @xmath184 , which essentially amounts to another addition .",
    "thus overall we have two additions .",
    "so all together for the modular multiplication we have to do @xmath3 steps , each roughly consisting of 3 additions .",
    "so one multiplication involves some @xmath185 additions .",
    "suppose @xmath186 and @xmath187 are two positive integers .",
    "the well known euclidean algorithm can be used to find the greatest common divisor of @xmath186 and @xmath187 , denoted @xmath188 .",
    "the basis of the algorithm is the simple fact that if @xmath45 is any integer then @xmath189 .",
    "this implies the gcd does nt change if we subtract a multiple of the smaller number from the larger number .",
    "thus the larger number can be replaced by its value modulo the smaller number without affecting the gcd . given @xmath186 and @xmath187 with @xmath190 this replacement can be accomplished by calculating @xmath191 and replacing @xmath186 by @xmath192 , where @xmath193 is the largest integer less than or equal to @xmath49 .",
    "the standard euclidean algorithm repeats this replacement until one of the two numbers becomes zero at which point the other number is @xmath188 .",
    "the table below illustrates the euclidean algorithm .",
    "[ cols=\"^,<,^,^ , < \" , ]      + where @xmath194 and @xmath195 are as in section [ sec : num : bits ] with @xmath196 .",
    "the time for the quantum algorithms is listed in units of `` 1-qubit additions '' , thus the number of quantum gates in an addition network per length of the registers involved .",
    "this number is about 9 quantum gates , 3 of which are the ( harder to implement ) toffoli gates ( see e.g. @xcite ) .",
    "also it seems very probable that for large scale quantum computation error correction or full fault tolerant quantum computation techniques are necessary .",
    "then each of our `` logical '' qubits has to be encoded into several physical qubits ( possibly dozens ) and the `` logical '' quantum gates will consist of many physical ones . of course this is true for both quantum algorithms and so should nt affect the above comparison .",
    "the same is true for residual noise ( on the logical qubits ) which will decrease the success probability of the algorithms .",
    "the quantum factoring algorithm may have one advantage , namely that it seems to be easier to parallelise .",
    "is supported by cse ( communications security establishment ) and mitacs ( mathematics of information technology and complex systems ) , both from canada .",
    "here we analyse in some detail the success probability of the discrete logarithm quantum algorithm when we use the usual quantum fourier transform of size @xmath197 , as opposed to the ideal case which would have prime size .",
    "the result is , that the algorithm has a probability close to 1 of giving the right answer .",
    "thus when looking at the runtime we will assume that a single run is enough .",
    "we first consider the case of the order finding algorithm ( section [ order ] ) which is the basis of the factoring algorithm .",
    "the discrete logarithm case is then simply a 2 dimensional version of this . here",
    "we will use the eigenvalue estimation viewpoint introduced by kitaev @xcite ( see also @xcite ) .",
    "the advantage of this viewpoint is , that the ( mixed ) state of the register which we ultimately measure is explicitly written as a mixture of isolated `` peaks '' ( thanks to mike mosca for pointing this out ) . in the usual picture , which we used in section [ order ] ,",
    "we have the diagonalised form of the mixed state ( or , equivalently , we use the schmidt normal form between the entangled registers ) .",
    "but there we have to worry about destructive interference between different peaks , which makes the analysis a bit less nice .",
    "so we want to find the order @xmath32 of a group element @xmath14 .",
    "again we do : @xmath198 where @xmath34 is the neutral element and @xmath199 is multiplication by @xmath14 , thus @xmath200 .",
    "( eigenvalue estimation refers to the eigenvalues of @xmath199 . )",
    "now we write @xmath201 in terms of eigenstates of @xmath199 .",
    "these @xmath32 eigenstates are easy to find : @xmath202 it is also easy to see that @xmath201 is simply a uniform superposition of these states : @xmath203",
    "so the state of the quantum computer can be written as @xmath204 now we apply the qfft@xmath205 to the first register to obtain : @xmath206 because the @xmath207 are orthogonal , the state of the first register alone can be viewed as a mixture of @xmath32 pure states , one for each @xmath208 .",
    "the probabilities associated with each of these pure states are equal , namely @xmath209 , as can be seen from the previous equation . by summing the geometrical series in the sum over @xmath49 we get for these ( normalised ) pure states : @xmath210 where @xmath211 is some ( irrelevant ) phase .",
    "we see that each of these states is dominated by basis states @xmath212 with @xmath213    thus each of the pure states corresponds to one `` smeared out '' peak centered at @xmath214 .",
    "note that the argument of the sine in the denominator is small .",
    "so the shape of the peak is approximately given by the function @xmath215 sampled at values for @xmath49 which are integers plus some constant fractional offset , as plotted in figure [ sinc ] .",
    "we are interested in the probability of observing a basis state no farther away from the center @xmath214 of the peak than , say @xmath216 .",
    "how spread out the peak is , depends on the fractional offset . if there is no offset",
    ", then we simply observe the central value with probability 1 .",
    "the largest spread occurs for offset @xmath217 .",
    "( then the probabilities of the two closest basis states are each @xmath218 . )",
    "the chance of obtaining a state at distance @xmath219 decreases as @xmath220 .",
    "so the probability of being away more than @xmath216 on either side is at most about @xmath221 .",
    "because the total probability is normalised to 1 , this tells us what the chance is of coming within @xmath219 of the central value .      the discrete logarithm case is analogous ,",
    "actually it can be viewed as a two dimensional version of the order finding algorithm .",
    "we have @xmath222 by applying a fourier transform of size @xmath22 to each of the first two registers we get @xmath223 again we get a peak for each @xmath208 , and each with the same probability .",
    "the @xmath224 and @xmath168 values are independently distributed , each as in the above 1-dimensional case . for @xmath224",
    "the `` central value '' is @xmath225 and for @xmath168 it is @xmath226 . to obtain the values @xmath208 and @xmath227 which we want , we multiply the observed @xmath69 with @xmath228 and round . thus ,",
    "if we chose @xmath22 ( @xmath229 ) sufficiently larger than @xmath45 , we are virtually guaranteed to obtain the correct values , even if @xmath224 and @xmath168 are a bit off .",
    "alternatively , we can try out various integer values in the vicinity of our candidate @xmath208 and @xmath227 , thus investing more classical post - processing to make the success probability approach 1 .",
    "it was shown in section [ secnumsteps ] that the number of cycles required to complete the euclidean algorithm on inputs @xmath0 and @xmath49 is @xmath230 where @xmath231 are the quotients in the euclidean algorithm .",
    "* proof : * assume by way of contradiction that there exist integers @xmath235 for which the lemma does not hold .",
    "let @xmath235 be an input for which the number of euclidean iterations , @xmath32 , is minimal subject to the condition that the lemma does not hold ( i.e. @xmath236 , @xmath237 , @xmath232 and @xmath238 ) .",
    "let @xmath239 be the quotients when the euclidean algorithm is run on @xmath235 .",
    "we will now obtain a contradiction as follows .",
    "first , we show that if @xmath236 then the euclidean algorithm with input @xmath235 will require at least three iterations ( i.e. @xmath240 ) .",
    "next , we show that if @xmath236 and the euclidean algorithm run for two iterations on input @xmath235 returns the pair @xmath241 then @xmath241 also contradict the lemma .",
    "since @xmath241 would contradict the lemma with fewer iterations than @xmath235 this contradicts the existence on @xmath235 .",
    "it is easily verified that the lemma holds provided @xmath242 ( simply calculate @xmath243 for each of the possibilities ) .",
    "we can thus assume that @xmath244 .",
    "recall that the euclidean algorithm takes as input two integers @xmath245 and terminates when one of @xmath109 and @xmath110 is set to zero , at which point the other integer will be @xmath246 .",
    "an iteration of the euclidean algorithm on @xmath245 , with @xmath247 , returns @xmath248 , where @xmath249 .",
    "note that since @xmath238 on this input the algorithm will terminate with either @xmath250 or @xmath251 .",
    "let us first prove that the euclidean algorithm with input @xmath235 will require at least three iterations . since neither @xmath0 nor @xmath49 is zero we know that @xmath252 .",
    "suppose that @xmath253 .",
    "then the single iteration of the algorithm transforms @xmath235 to @xmath254 .",
    "this implies that @xmath255 and @xmath256 .",
    "thus @xmath257 which implies that @xmath258 .",
    "suppose that @xmath259 .",
    "then the two iterations of the algorithm would transform @xmath260 this implies that @xmath261 and @xmath262 .",
    "thus @xmath263 , which implies that @xmath264 .",
    "therefore @xmath265 and we have that @xmath240 .",
    "note that we now know @xmath266 , @xmath267 and @xmath268 since any of these would imply @xmath269 .",
    "we shall now establish that @xmath270 .",
    "after the first iteration of the euclidean algorithm the problem is reduced to running the algorithm on @xmath271 , for which the quotients will be @xmath272 . since @xmath273 we have that @xmath274 .",
    "therefore @xmath275 thus if @xmath276 then @xmath277 , @xmath278 and @xmath279 , but this would contradict the minimality of @xmath32 . therefore @xmath270 .",
    "after two iterations of the euclidean algorithm on @xmath235 the problem has been reduced to running the algorithm on @xmath280 .",
    "we will now show that the lemma does not hold for @xmath280 .",
    "this will contradict the minimality of @xmath32 and thus the existence of @xmath235 . to do this",
    ", we must first show that @xmath281 and that @xmath282 ( so that the lemma applies ) . as discussed above , since @xmath283 we know that @xmath284 and that @xmath282 , thus we need only show that @xmath285 .",
    "suppose that @xmath286 . since @xmath270 either @xmath287 or @xmath288 .",
    "since @xmath238 this implies that @xmath49 is odd and that the euclidean algorithm will proceed as follows @xmath289 thus @xmath290 , @xmath291 , @xmath292 and @xmath293 where the last line follows by checking the values for @xmath270 and @xmath294 and noting that @xmath295 when @xmath296 .",
    "this would contradict the fact that the lemma does nt hold for @xmath235 , thus @xmath285 .    now to complete the proof we need only show that @xmath297 .",
    "let @xmath298 , so @xmath299 with @xmath300 . by the euclidean algorithm",
    "we know that @xmath301 and thus @xmath302 therefore @xmath303 , which implies @xmath304 .",
    "this in turn implies that @xmath305 .",
    "hence @xmath306 where @xmath307 .",
    "thus @xmath314 and we have that @xmath321 .",
    "this contradict the minimality of @xmath32 and thus the existence of @xmath235 .",
    "therefore the lemma holds.@xmath322 + note that @xmath323 and thus the bound is tight .",
    "it is also worth noting that @xmath324 which is why the requirement @xmath237 was included in the lemma ."
  ],
  "abstract_text": [
    "<S> we show in some detail how to implement shor s efficient quantum algorithm for discrete logarithms for the particular case of elliptic curve groups . </S>",
    "<S> it turns out that for this problem a smaller quantum computer can solve problems further beyond current computing than for integer factorisation . </S>",
    "<S> a 160 bit elliptic curve cryptographic key could be broken on a quantum computer using around 1000 qubits while factoring the security - wise equivalent 1024 bit rsa modulus would require about 2000 qubits . in this paper </S>",
    "<S> we only consider elliptic curves over gf(@xmath0 ) and not yet the equally important ones over gf(@xmath1 ) or other finite fields . </S>",
    "<S> the main technical difficulty is to implement euclid s gcd algorithm to compute multiplicative inverses modulo @xmath0 . </S>",
    "<S> as the runtime of euclid s algorithm depends on the input , one difficulty encountered is the `` quantum halting problem '' . </S>"
  ]
}