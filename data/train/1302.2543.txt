{
  "article_text": [
    "this paper addresses _ byzantine vector consensus _ ( bvc ) , wherein the input at each process is a @xmath1-dimensional vector of reals , and each process is expected to decide on a _ decision vector _ that is in the _ convex hull _ of the input vectors at the non - faulty processes .",
    "the system consists of @xmath0 processes in @xmath5 .",
    "we assume @xmath6 , since consensus is trivial for @xmath7 . at most @xmath2 processes",
    "may be byzantine faulty , and may behave arbitrarily @xcite .",
    "all processes can communicate with each other directly on _ reliable _ _ fifo _",
    "( first - in first - out ) channels .",
    "thus , the communication network is a _",
    "complete graph_. the input _ vector _ at each process may also be viewed as a _ point _ in the @xmath1-dimensional euclidean space @xmath8 , where @xmath9 is a finite integer . due to this correspondence",
    ", we use the terms _ point _ and _ vector _ interchangeably .",
    "similarly , we interchangeably refer to the @xmath1 _ elements _ of a vector as _",
    "coordinates_. we consider two versions of the byzantine vector consensus ( bvc ) problem , _ exact bvc _ and _ approximate bvc_.    [ [ exact - bvc ] ] * exact bvc : * + + + + + + + + + + + +    exact byzantine vector consensus must satisfy the following three conditions .    *",
    "_ agreement _ : the decision ( or output ) vector at all the non - faulty processes must be identical . * _ validity _ : the decision vector at each non - faulty process must be in the convex hull of the input vectors at the non - faulty processes . * _ termination _ : each non - faulty process must terminate after a finite amount of time .    the traditional consensus problem @xcite is obtained when @xmath10 ; we refer to this as _ scalar _ consensus .",
    "@xmath11 is known to be necessary and sufficient for achieving byzantine _",
    "scalar _ consensus in complete graphs @xcite .",
    "we observe that simply performing _ scalar _ consensus on each dimension of the input vectors independently does not solve the _ vector _ consensus problem . in particular , even if validity condition for _ scalar consensus _ is satisfied for each dimension of the vector separately , the above _ validity _ condition of vector consensus may not necessarily be satisfied .",
    "for instance , suppose that there are four processes , with one faulty process .",
    "processes @xmath12 and @xmath13 are non - faulty , and have the following 3-dimensional input vectors , respectively : @xmath14 $ ] , @xmath15 $ ] , @xmath16 $ ] .",
    "process @xmath17 is faulty .",
    "if we perform byzantine _ scalar _ consensus on each dimension of the vector separately , then the processes may possibly agree on the decision vector @xmath18 $ ] , each element of which satisfies _ scalar _ validity condition _ along each dimension _ separately ; however , this decision vector _ does not _ satisfy the validity condition for bvc because it is _ not _ in the convex hull of input vectors of non - faulty processes . in this example , since every non - faulty process has a probability vector as its input vector , bvc validity condition requires that the decision vector should also be a probability vector . in general , for many optimization problems @xcite , the set of feasible solutions is a convex set in euclidean space . assuming that every non - faulty process proposes a feasible solution , bvc guarantees that the vector decided is also a feasible solution .",
    "using scalar consensus along each dimension is not sufficient to provide this guarantee .    [",
    "[ approximate - bvc ] ] * approximate bvc : * + + + + + + + + + + + + + + + + + +    in an _ asynchronous _ system , processes may take steps at arbitrary relative speeds , and there is no fixed upper bound on message delays .",
    "fischer , lynch and paterson @xcite proved that exact consensus is impossible in asynchronous systems in the presence of even a single crash failure . as a way to circumvent this impossibility result , dolev et al .",
    "@xcite introduced the notion of _ approximate _ consensus , and proved the correctness of an algorithm for approximate byzantine _",
    "scalar _ consensus in asynchronous systems when @xmath19 .",
    "subsequently , abraham , amit and dolev @xcite established that approximate byzantine _",
    "scalar _ consensus is possible in asynchronous systems if @xmath11 .",
    "other algorithms for approximate consensus have also been proposed ( e.g. , @xcite ) .",
    "we extend the notion of approximate consensus to _ vector _ consensus .",
    "_ approximate bvc _ must satisfy the following conditions :    * _ @xmath20-agreement _ : for @xmath21 , the @xmath22-th elements of the decision vectors at any two non - faulty processes must be within @xmath20 of each other , where @xmath23 is a pre - defined constant . *",
    "_ validity _ : the decision vector at each non - faulty process must be in the convex hull of the input vectors at the non - faulty processes . * _ termination _ : each non - faulty process must terminate after a finite amount of time .",
    "the main contribution of this paper is to establish the following bounds for _ complete graphs_.    * in a synchronous system , @xmath24 is necessary and sufficient for _ exact bvc _ in presence of up to @xmath2 byzantine faulty processes .",
    "( theorems [ t_exact_nec ] and [ t_exact_suff ] ) . * in an asynchronous system , @xmath4 is necessary and sufficient for _ approximate bvc _ in presence of up to @xmath2 byzantine faulty processes .",
    "( theorems [ t_approx_nec ] and [ t_approx_suff ] ) .",
    "observe that the two bounds above are different when @xmath25 , unlike the case of @xmath10 ( i.e. , scalar consensus ) .",
    "when @xmath10 , in a complete graph , @xmath26 processes are sufficient for exact consensus in synchronous systems , as well as approximate consensus in asynchronous systems @xcite .",
    "for @xmath25 , the lower bound for asynchronous systems is larger by @xmath2 compared to the bound for synchronous systems .    in prior literature",
    ", the term _ vector consensus _ has also been used to refer to another form of consensus , wherein the input at each process is a _ scalar _ , but the agreement is on a vector containing these scalars @xcite .",
    "thus , our results are for a different notion of consensus .      in prior literature",
    ", iterative algorithms with very simple structure have been proposed to achieve _ approximate _ consensus , including asynchronous approximate byzantine scalar consensus @xcite in _ complete _ graphs , and synchronous as well as asynchronous approximate byzantine consensus in _ incomplete _ graphs @xcite .",
    "section [ s_simple ] extends these simple structures to vector consensus in complete graphs , and obtains the following tight bounds : ( i ) @xmath4 for synchronous systems , and ( ii ) @xmath27 for asynchronous systems .",
    "observe that the bound for the simple iterative algorithms in asynchronous systems is larger by @xmath28 when compared to the bound stated earlier : this is the cost of restricting the algorithm structure .",
    "this @xmath28 gap is analogous to that between the sufficient condition of @xmath11 for asynchronous scalar consensus proved by abraham , amit and dolev @xcite , the sufficient condition of @xmath19 demonstrated by dolev et al .",
    "@xcite using a simpler algorithm .",
    "many notations introduced throughout the paper are also summarized in appendix [ a_notations ] .",
    "we use operator @xmath29 to obtain the size of a _ multiset _ or a _",
    "set_. we use operator @xmath30 to obtain the absolute value of a scalar .",
    "in this section , we derive necessary and sufficient conditions for exact bvc in a synchronous system with up to @xmath2 faulty processes .",
    "the discussion in the rest of this paper assumes that the network is a _ complete graph _",
    ", even if this is not stated explicitly in all the results .",
    "[ t_exact_nec ] @xmath24 is necessary for exact bvc in a synchronous system .    from @xcite , we know that , for @xmath10 ( i.e. , scalar consensus ) , @xmath11 is a necessary condition for achieving exact byzantine consensus in presence of up to @xmath2 faults . if we were to restrict the @xmath1-dimensional input vectors to have identical @xmath1 elements , then the problem of vector consensus reduces to scalar consensus .",
    "therefore , @xmath11 is also a necessary condition for _ exact bvc _ for arbitrary @xmath1 .",
    "now we prove that @xmath31 is also a necessary condition .",
    "first consider the case when @xmath32 , i.e. , at most one process may be faulty . since none of the non - faulty processes know which process",
    ", if any , is faulty , as elaborated in appendix [ a_sync ] , the decision vector must be in the convex hull of each multiset containing the input vectors of @xmath33 of the processes ( there are @xmath0 such multisets ) .",
    "elaborates on the notion of multisets . ]",
    "thus , this intersection must be non - empty , for all possible input vectors at the @xmath0 processes .",
    "( appendix [ a_sync ] provides further clarification . )",
    "we now show that the intersection may be empty when @xmath34 ; thus , @xmath34 is not sufficient for @xmath32 .",
    "suppose that @xmath34 .",
    "consider the following set of input vectors .",
    "the input vector of process @xmath35 , where @xmath36 , is a vector whose @xmath37-th element is @xmath38 , and the remaining elements are 0 . the input vector at process @xmath39 is the all-0 vector ( i.e. , the vector with all elements 0 ) .",
    "note that the @xmath1 input vectors at @xmath40 form the standard basis for the @xmath1-dimensional vector space . also , none of the @xmath41 input vectors can be represented as a convex combination of the remaining @xmath1 input vectors .",
    "for @xmath42 , let @xmath43 denote the convex hull of the inputs at the @xmath44 processes in @xmath45 .",
    "we now argue that @xmath46 is empty .    for @xmath36 , observe that for all the points in @xmath43 , the @xmath37-th coordinate is 0 .",
    "thus , any point that belongs to the intersection @xmath47 must have all its coordinates 0 .",
    "that is , only the all-0 vector belongs to @xmath47 .",
    "now consider @xmath48 , which is the convex hull of the inputs at the first @xmath1 processes . due to the choice of the inputs at the first @xmath1 processes ,",
    "the origin ( i.e. , the all-0 vector ) does not belong to @xmath48 .",
    "from the earlier observation on @xmath47 , it then follows that @xmath49 .",
    "therefore , the _ exact bvc _ problem for @xmath32 can not be solved with @xmath34 .",
    "thus , @xmath34 is not sufficient",
    ". it should be easy to see that @xmath50 is also not sufficient .",
    "thus , @xmath51 is a necessary condition for @xmath32 .",
    "now consider the case of @xmath52 .",
    "using the commonly used simulation approach @xcite , we can prove that @xmath53 processes are not sufficient . in this approach ,",
    "@xmath2 _ simulated processes _ are implemented by a single process .",
    "if a correct algorithm were to exist for tolerating @xmath2 faults among @xmath53 processes , then we can obtain a correct algorithm to tolerate a single failure among @xmath41 processes , contradicting our result above .",
    "thus , @xmath31 is necessary for @xmath54 .",
    "( for @xmath55 , the necessary condition holds trivially . )",
    "we now present an algorithm for exact bvc in a synchronous system , and prove its correctness in a complete graph with @xmath24 .",
    "the algorithm uses function @xmath56 defined below , where @xmath57 is a multiset of points .",
    "@xmath58 denotes the convex hull of a multiset @xmath59 . @xmath60",
    "the intersection above is over the convex hulls of all subsets of @xmath57 of size @xmath61 .    ' '' ''    for @xmath62 :    ' '' ''    ' '' ''    1 .",
    "each process uses a scalar _ byzantine broadcast _ algorithm ( such as @xcite ) to broadcast each element of its input vector to all the other processes ( each element is a scalar ) .",
    "the _ byzantine broadcast _ algorithm allows a designated sender to broadcast a scalar value to the other processes , while satisfying the following properties when @xmath11 : ( i ) all the non - faulty processes decide on an identical scalar value , and ( ii ) if the sender is non - faulty , then the value decided by the non - faulty processes is the sender s proposed ( scalar ) value .",
    "thus , non - faulty processes can agree on the @xmath1 elements of the input vector at each of the @xmath0 processes . at the end of the this step",
    ", each non - faulty process would have received an _ identical _",
    "multiset @xmath63 containing @xmath0 vectors , such that the vector corresponding to each non - faulty process is identical to the input vector at that process .",
    "2 .   each process chooses as its _ decision _ vector a point in @xmath64 ; all non - faulty processes choose the point identically using a deterministic function .",
    "we will soon show that @xmath64 is non - empty .    ' '' ''    we now prove that the above algorithm is correct .",
    "later , we show how the _ decision vector _ can be found in step 2 using linear programming .",
    "the proof of correctness of the above algorithm uses the following celebrated theorem by tverberg @xcite :    [ tverberg s theorem @xcite ] [ t_tverberg ] for any integer @xmath65 , and for every multiset @xmath57 containing at least @xmath66 points in @xmath8 , there exists a partition @xmath67 of @xmath57 into @xmath68 non - empty multisets such that @xmath69 .",
    "the points in multiset @xmath57 above are not necessarily distinct @xcite ; thus , the same point may occur multiple times in @xmath57 .",
    "( appendix [ a_multisets ] elaborates on the notion of multisets , and multiset partition . ) the partition in theorem [ t_tverberg ] is called a _ tverberg partition _ , and the points in @xmath70 in theorem [ t_tverberg ] are called _",
    "tverberg points_. appendix [ a_tverberg ] provides an illustration of a tverberg partition for points in 2-dimensional space .",
    "the lemma below is used to prove the correctness of the above algorithm , as well as the algorithm presented later in section [ s_async ] .    for any multiset @xmath57 containing at least @xmath66 points in @xmath8 , @xmath71 .",
    "[ lem : tversuper ]    consider a tverberg partition of @xmath57 into @xmath68 non - empty subsets @xmath72 , such that the set of tverberg points @xmath73 . since @xmath74 , by theorem [ t_tverberg ] , such a partition exists . by ( [ e_i ] )",
    "we have @xmath75 consider any @xmath59 in ( [ e_i_2 ] ) .",
    "since @xmath76 and there are @xmath68 subsets in the tverberg partition of @xmath57 , @xmath59 excludes elements from at most @xmath2 of these subsets .",
    "thus , @xmath59 contains at least one subset from the partition . therefore , for * each * @xmath59 , @xmath77 .",
    "hence , from ( [ e_i_2 ] ) , it follows that @xmath78 . also , because @xmath79 , it now follows that @xmath71 .",
    "we can now prove the correctness of our exact bvc algorithm .",
    "[ t_exact_suff ] @xmath24 is sufficient for achieving exact bvc in a synchronous system .",
    "we prove that the above _ exact bvc _",
    "algorithm is correct when @xmath24 .",
    "the _ termination _",
    "condition holds because the _ byzantine broadcast _ algorithm used in step 1 terminates in finite time . since @xmath80 , by lemma [ lem : tversuper ] , @xmath81 . by ( [ e_i ] )",
    "we have @xmath82 at least one of the multisets @xmath59 in ( [ e_s_2 ] ) , say @xmath83 , must contain the inputs of _ only _ non - faulty processes , because @xmath84 , and there are at most @xmath2 faulty processes . by definition of @xmath64 , @xmath85 .",
    "then , from the definition of @xmath83 , and the fact that the decision vector is chosen from @xmath64 , the _ validity _ condition follows",
    ".    _ agreement _ condition holds because all the non - faulty processes have identical @xmath63 , and pick as their decision vector a point in @xmath86 using a deterministic function in step 2 .",
    "we now show how step 2 of the exact bvc algorithm can be implemented using linear programming .",
    "the input to the linear program is @xmath87 , a multiset of @xmath1-dimensional vectors .",
    "our goal is to find a vector @xmath88 ; or equivalently , find a vector @xmath89 that can be expressed as a convex combination of vectors in @xmath59 for all choices @xmath90 such that @xmath91 .",
    "the linear program uses the following @xmath92 variables .",
    "* @xmath93 : variables for @xmath1 elements of vector @xmath89 . *",
    "@xmath94 : coefficients such that @xmath89 can be written as convex combination of vectors in @xmath59 .",
    "we include here only those @xmath95 indices @xmath37 for which @xmath96 .    for every @xmath59 ,",
    "the linear constraints are as follows .",
    "* @xmath97  ( @xmath89 is a linear combination of @xmath96 ) * @xmath98  ( the sum of all coefficients for a particular @xmath59 is @xmath38 ) * @xmath99 for all @xmath96 .    for every @xmath59 , we get @xmath100 linear constraints , yielding a total of @xmath101 constraints in @xmath102 variables . hence , for any _ fixed _ @xmath2 , a point in @xmath64 can be found in polynomial time by solving a linear program with the number of variables and constraints that are polynomial in @xmath0 and @xmath1 ( but not in @xmath2 ) .",
    "however , when @xmath2 grows with @xmath0 , the computational complexity is high .",
    "we note here that the above exact bvc algorithm remains correct if the non - faulty processes identically choose _ any point _ in @xmath64 as the decision vector .",
    "in particular , as seen in the proof of lemma [ lem : tversuper ] , all the tverberg points are contained in @xmath64 , therefore , one of the tverberg points for multiset @xmath63 may be chosen as the decision vector .",
    "it turns out that , for arbitrary @xmath1 , currently there is no known algorithm with polynomial complexity to compute a tverberg point for a given multiset @xcite .",
    "however , in some restricted cases , efficient algorithms are known ( e.g. , @xcite ) .",
    "we develop a tight necessary and sufficient condition for _ approximate _ asynchronous bvc .",
    "[ t_approx_nec ] @xmath4 is necessary for approximate bvc in an asynchronous system .",
    "we first consider the case of @xmath32 .",
    "suppose that a correct algorithm exists for @xmath103 .",
    "denote by @xmath104 the input vector at each process @xmath105 . now consider a process @xmath35 , where @xmath42 .",
    "since a correct algorithm must tolerate one failure , process @xmath35 must terminate in all executions in which process @xmath106 does not take any steps .",
    "suppose that all the processes are non - faulty , but process @xmath106 does not take any steps until all the other processes terminate . at the time when process @xmath35 terminates ( @xmath42 ) , it can not distinguish between the following @xmath41 scenarios :    * process @xmath106 has crashed : in this case , to satisfy the _",
    "condition , the decision of process @xmath35 must be in the convex hull of the inputs of processes @xmath107 .",
    "that is , the decision vector must be in the convex hull of @xmath108 defined below .",
    "@xmath110 is not included above , because until process @xmath35 terminates , @xmath106 does not take any steps ( so @xmath35 can not learn any information about @xmath110 ) . *",
    "process @xmath111 ( @xmath112 , @xmath113 ) is faulty , and process @xmath106 is slow , and hence @xmath106 has not taken any steps yet : recall that we are considering @xmath35 at the time when it terminates .",
    "since process @xmath106 has not taken any steps yet , process @xmath35 can not have any information about the input at @xmath106 .",
    "also , in this scenario @xmath111 may be faulty , therefore , process @xmath35 can not trust the correctness of the input at @xmath111 .",
    "thus , to satisfy the validity condition , the decision of process @xmath35 must be in the convex hull of @xmath114 defined below .",
    "@xmath115    the decision vector of process @xmath35 must be valid independent of which of the above @xmath41 scenarios actually occurred .",
    "therefore , observing that @xmath116 , where @xmath112 , we conclude that the decision vector must be in @xmath117 recall that @xmath23 is the parameter of the @xmath20-agreement condition in section [ s_intro ] . for @xmath36 ,",
    "suppose that the @xmath37-th element of input vector @xmath118 is @xmath119 , and the remaining @xmath120 elements are 0 .",
    "also suppose that @xmath121 and @xmath110 are both equal to the all-0 vector .",
    "let us consider process @xmath39 .",
    "in this case , @xmath122 for @xmath123 only contains vectors whose @xmath124-th element is 0 .",
    "thus , the intersection of all the convex hulls in ( [ e_valid ] ) only contains the all-0 vector , which , in fact , equals @xmath121 .",
    "thus , the decision vector of process @xmath39 must be equal to @xmath121 .",
    "we can similarly show that for each @xmath35 , @xmath42 , the intersection in ( [ e_valid ] ) only contains vector @xmath118 , and therefore , the decision vector of process @xmath35 must be equal to its input @xmath118 .",
    "the input vectors at each pair of processes in @xmath125 differ by @xmath119 in at least one element .",
    "this implies that the @xmath20-agreement condition is not satisfied .",
    "therefore , @xmath103 is not sufficient for @xmath32",
    ". it should be easy to see that @xmath126 is also not sufficient .    for the case",
    "when @xmath52 , by using a _ simulation _ similar to the proof of theorem [ t_exact_nec ] , we can now show that @xmath127 is not sufficient .",
    "thus , @xmath4 is necessary for @xmath54 .",
    "( for @xmath55 , the necessary condition holds trivially . )",
    "we will prove that @xmath4 is sufficient by proving the correctness of an algorithm presented in this section .",
    "the proposed algorithm executes in asynchronous rounds .",
    "each process @xmath35 maintains a local state @xmath128 , which is a @xmath1-dimensional vector .",
    "we will refer to the value of @xmath128 at the _ end _ of the @xmath129-th round performed by process @xmath35 as @xmath130 $ ] .",
    "thus , @xmath131 $ ] is the value of @xmath128 at the _ start _ of the @xmath129-th round of process @xmath35 .",
    "the initial value of @xmath128 , namely @xmath132 $ ] , is equal to @xmath35 s _ input _ vector , denoted as @xmath118 .",
    "the messages sent by each process anytime during its @xmath129-th round are tagged by the round number @xmath129 .",
    "this allows a process @xmath35 in its round @xmath129 to determine , despite the asynchrony , whether a message received from another process @xmath111 was sent by @xmath111 in @xmath111 s round @xmath129 .",
    "the proposed algorithm is obtained by suitably modifying a _ scalar _ consensus algorithm presented by abraham , amit and dolev @xcite to achieve asynchronous approximate byzantine scalar consensus among @xmath26 processes .",
    "we will refer to the algorithm in @xcite as the aad algorithm .",
    "we first present a brief overview of the aad algorithm , and describe its properties .",
    "we adopt our notation above when describing the aad algorithm ( the notation differs from @xcite ) .",
    "one key difference is that , in our proposed algorithm @xmath130 $ ] is a vector , whereas in aad description below , it is considered a scalar .",
    "the aad algorithm may be viewed as consisting of three components :    1 .",
    "_ aad component # 1 : _ in each round @xmath129 , the aad algorithm requires each process to communicate its state @xmath131 $ ] to other processes using a mechanism that achieves the properties described next .",
    "aad ensures that each non - faulty process @xmath35 in its round @xmath129 obtains a set @xmath133 $ ] containing at least @xmath95 tuples of the form @xmath134 , such that the following properties hold : * ( property 1 )   for any two non - faulty processes @xmath35 and @xmath111 : latexmath:[\\ ] ]    this proves ( [ e_convergence ] ) .",
    "property 1 of _ component # 1 _ of aad described in section [ ss_async_suff ] is a consequence of a stronger property satisfied by the aad algorithm .    in aad , each process @xmath105 sends out notifications to others each time it adds a new tuple to its @xmath278 $ ] ; the notifications are sent over the fifo links .",
    "aad defines a process @xmath105 to be a `` witness '' for process @xmath35 provided that ( i ) @xmath105 is known to have added at least @xmath95 tuples to @xmath278 $ ] , and ( ii ) all the tuples that @xmath105 claims to have added to @xmath278 $ ] are also in @xmath133 $ ] .",
    "aad also ensures that each non - faulty process has at least @xmath95 witnesses , ensuring that any two non - faulty processes have at least @xmath227 witnesses in common , where @xmath279 .",
    "thus , any two non - faulty processes @xmath35 and @xmath111 have at least one non - faulty witness in common , say @xmath105 . this , in turn , ensures ( due to the manner in which the advertisements above are sent ) that @xmath133\\cap b_j[t]$ ] contains at least the first @xmath95 tuples advertised by @xmath105 .",
    "each process can keep track of the order in which the tuples advertised by each process are received .",
    "then , in step 2 of the asynchronous approximate bvc algorithm , instead of enumerating all the @xmath95-size subsets @xmath166 of @xmath133 $ ] , it suffices to only consider those subsets of @xmath133 $ ] that correspond to the first @xmath95 tuples advertised by each witness of @xmath35 . since there can be no more than @xmath0 witnesses , at most @xmath0 sets @xmath166 need to be considered .",
    "thus , in this case @xmath280 .    since each pair of non - faulty processes @xmath35 and @xmath111 shares a non - faulty witness , despite considering only @xmath281 subsets in step 2 , @xmath155 and @xmath192 computed by @xmath35 and @xmath111 contain at least one identical point , say , @xmath199 .",
    "our proof of correctness of the algorithm relied on the existence of such a point ."
  ],
  "abstract_text": [
    "<S> consider a network of @xmath0 processes each of which has a @xmath1-dimensional vector of reals as its _ </S>",
    "<S> input_. each process can communicate directly with all the processes in the system ; thus the communication network is a _ </S>",
    "<S> complete graph_. all the communication channels are reliable and fifo ( first - in - first - out ) . </S>",
    "<S> the problem of _ byzantine vector consensus _ ( bvc ) requires agreement on a @xmath1-dimensional vector that is in the _ convex hull _ of the @xmath1-dimensional input vectors at the non - faulty processes . </S>",
    "<S> we obtain the following results for byzantine vector consensus in _ complete graphs _ while tolerating up to @xmath2 byzantine failures :    * we prove that in a synchronous system , @xmath3 is necessary and sufficient for achieving byzantine vector consensus . * in an asynchronous system , it is known that _ exact _ </S>",
    "<S> consensus is impossible in presence of faulty processes . for an asynchronous system </S>",
    "<S> , we prove that @xmath4 is necessary and sufficient to achieve _ approximate _ byzantine vector consensus .    </S>",
    "<S> our sufficiency proofs are constructive . we show sufficiency by providing explicit algorithms that solve exact bvc in synchronous systems , and approximate bvc in asynchronous systems .    </S>",
    "<S> we also obtain tight bounds on the number of processes for achieving bvc using algorithms that are restricted to a simpler communication pattern . </S>"
  ]
}