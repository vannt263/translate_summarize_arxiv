{
  "article_text": [
    "the bottleneck ( capacity ) of a path is the minimum capacity of all edges on the path .",
    "thus the bottleneck is the maximum flow that can be pushed through this path .",
    "the bottleneck ( capacity ) of a pair of vertices @xmath6 is the maximum of all bottleneck values of all paths from @xmath7 to @xmath8 .",
    "the bottleneck paths problems are important in various areas , such as logistics and computer networks . in this paper",
    "we consider two extensions to this well known problem on directed unweighted graphs with positive real edge capacities .",
    "the bottleneck of the ( entire ) network is the minimum bottleneck out of all bottlenecks for all pairs @xmath6 . in this paper",
    "we introduce a simple algorithm based on binary search to show that we can compute the bottleneck of the network faster than computing the all pairs bottleneck paths .",
    "the method is based on the transitive closure of a boolean matrix and the time complexity of the algorithm is @xmath0 where @xmath9 @xcite .",
    "this algorithm is simple but effective , and provides a good starting point for this paper .    consider the shortest path from vertex @xmath10 to vertex @xmath11 that can push a flow of amount up to @xmath12 .",
    "if the flow demand from @xmath10 to @xmath11 is less than @xmath12 , however , there may be a shorter route , which is useful if one wishes to minimize the distance for a given amount of flow .",
    "thus we compute the shortest path for each possible bottleneck value .",
    "we call this problem shortest paths for all flows ( sp - af )",
    ". we present a non - trivial @xmath3 algorithm to solve the single source shortest paths for all flows ( sssp - af ) problem , that is , computing the shortest path for all flows from one source vertex to all other vertices in the graph .",
    "naturally , we move onto the all pairs shortest paths for all flows ( apsp - af ) problem , where we compute the shortest distances for all flows for all pairs of vertices in the graph .",
    "note that this new problem is different from the all pairs bottleneck shortest paths ( apbsp ) problem @xcite , which is to compute the bottlenecks for all pairs shortest paths .",
    "applying our algorithm for sssp - af @xmath2 times gives us @xmath13 .",
    "if the graph is dense , however , @xmath14 , and the time complexity becomes @xmath15 .",
    "we can utilize faster matrix multiplication over ring to achieve a sub - quartic time bound for dense graphs .",
    "we present an algorithm that runs in @xmath16 time .",
    "if the edge capacities are integers bounded by @xmath17 , the time complexity of our algorithm becomes @xmath18 , and if we introduce the parameter @xmath5 as the number of distinct edge capacities , we have @xmath4 .",
    "the algorithms are presented in the order of increasing complexity .",
    "section [ sec : bpen ] details the algorithm for solving the bottleneck of the network . in section",
    "[ sec : ssspaf ] and section [ sec : apspaf ] we present the algorithms for solving sssp - af and apsp - af , respectively . in section [ sec : distinct ] we further analyze our new algorithm for apsp - af .",
    "finally we describe some real life applications of the sp - af problems in section [ sec : real ] before concluding the paper .",
    "let @xmath19 be a directed unweighted graph with edge capacities of positive real numbers .",
    "let @xmath20 and @xmath21 .",
    "vertices ( or nodes ) are given by integers such that @xmath22 .",
    "let @xmath23 denote the edge from vertex @xmath7 to vertex @xmath8 .",
    "let @xmath24 denote the capacity of the edge @xmath25 .",
    "we call @xmath26 , where @xmath27 represents a capacity from @xmath7 to @xmath8 , a capacity matrix .",
    "let @xmath28 be the maximum bottleneck for all paths of lengths up to @xmath29 from @xmath7 to @xmath8 .",
    "clearly @xmath30 if @xmath23 , and 0 otherwise . let @xmath31 be the maximum bottleneck for all paths from @xmath7 to @xmath8 .",
    "we call @xmath32 the closure of @xmath33 and also refer to it as the bottleneck matrix",
    ". the problem of computing @xmath34 is formally known as the all pairs bottleneck paths ( apbp ) problem . for graphs with unit edge costs ,",
    "the apbp problem is well studied in @xcite and @xcite .",
    "the complexities of algorithms given by the two papers are @xmath35 and @xmath36 , respectively .",
    "let @xmath37 denote the @xmath38-product of capacity matrices @xmath39 and @xmath40 , where @xmath41 is given by :    @xmath42    note that if all elements in @xmath39 and @xmath40 are either 0 or 1 , this becomes boolean matrix multiplication .",
    "if we interpret `` max '' as addition and `` min '' as multiplication , the set of non - negative numbers forms a closed semi - ring .",
    "similarly , the set of matrices where the product is defined as the @xmath38-product and the sum is defined as a component - wise `` max '' operation also forms a closed semi - ring .",
    "then the bottleneck matrix is given by the closure of the capacity matrix , where the closure of matrix @xmath39 is defined by :    @xmath43    and @xmath44 is the identity matrix with diagonal elements of @xmath45 and non - diagonal elements of 0 .",
    "although @xmath46 is defined by an infinite series we can stop at @xmath47 .",
    "the computational complexity of computing @xmath46 is asymptotically equal to that of the matrix product in the more general setting of closed semi - ring @xcite .",
    "similarly to the capacity matrix , we can define the distance matrix , where each element represents the distance from @xmath7 to @xmath8 .",
    "the problem of computing the closure of the distance matrix is formally known as the all pairs shortest paths ( apsp ) problem .",
    "zwick achieved @xmath48 time for solving apsp on directed graphs with unit edge costs @xcite , which has recently been improved to @xmath49 thanks to le gall s new algorithm for rectangular matrix multiplication @xcite .",
    "let @xmath50 denote the @xmath51-product , or the distance product , of distance matrices @xmath39 and @xmath40 , where @xmath41 is given by :    @xmath52",
    "let @xmath53 be the bottleneck value of the entire network .",
    "see example [ eg : bottleneck ] for an illustration .",
    "let the capacity matrix c be defined by @xmath54 .",
    "one straightforward method to compute @xmath53 would be to compute @xmath55 for all pairs @xmath6 and find the minimum among them .",
    "we can solve the problem more efficiently by a simple but effective binary search as shown in algorithm [ alg : bpen ] .",
    "we begin by assuming that the edge capacities are integers bounded by @xmath17 .",
    "let the threshold value @xmath11 be initialized to @xmath56 .",
    "let @xmath57 be a boolean matrix such that @xmath58 if @xmath59 , and 0 otherwise .",
    "let us compute the transitive closure , @xmath60 , of @xmath40 .",
    "then , from the equation :    @xmath61    we observe that @xmath62 if and only if @xmath63 , @xmath64 , ... , @xmath65 for some path . from this",
    "we derive that @xmath66 _ iff _",
    "@xmath67 for all pairs @xmath6 .",
    "we repeatedly halve the possible range @xmath68 $ ] for @xmath53 by adjusting the threshold , @xmath11 , through binary search .",
    "obviously the iteration over the while loop is performed @xmath69 times .",
    "thus the total time becomes @xmath70 , where @xmath71 is the time for multiplying two @xmath2-by-@xmath2 boolean matrices .",
    "if @xmath17 is large , say @xmath72 , the algorithm is not very efficient , taking @xmath73 halvings of the possible ranges of @xmath53 . in this case",
    ", we sort edges in ascending order .",
    "since there are at most @xmath74 possible values of capacities , doing binary search over the sorted edges gives us @xmath75 .",
    "obviously this method also works for edge capacities of real numbers .",
    "we note that the actual bottleneck path can be obtained using the witness technique in @xcite with an extra polylog factor .",
    "[ eg : bottleneck ] the @xmath53 of the graph in figure [ fig : graph ] is 9 , which is the capacity of edges @xmath76 and @xmath77 .",
    "this example illustrates that the @xmath53 of an entire network , even for simple graphs , may not be immediately obvious .",
    "from a source vertex @xmath10 to all other vertices @xmath78 , we want to find the shortest paths for each flow value .",
    "the shortest path from @xmath10 to @xmath79 for a given flow value @xmath80 allows us to push flows up to @xmath80 as quickly as possible . for some @xmath81 ,",
    "however , there may be a shorter path .",
    "thus if we find the shortest path for all possible flows , we can respond to queries of flow demands from @xmath10 to @xmath79 with the quickest paths that can accommodate the flows .",
    "we observe that there can be up to @xmath74 different values of @xmath80 , which we refer to as the maximal flows from @xmath10 to @xmath79 .",
    "a straightforward method of solving sssp - af is solving sssp for each maximal flow @xmath80 , that is , we repeatedly solve sssp using only @xmath82 such that @xmath83 , for all @xmath80 .",
    "sssp can be solved by a simple breadth - first - search ( bfs ) on graphs with unit edge costs , hence this approach takes @xmath84 time .",
    "each bfs will result in a shortest path spanning tree ( spt ) with @xmath10 as the root .",
    "explicit paths can be retrieved by traversing up the spts .",
    "one may be led to think that sssp - af can be solved with a simple decremental algorithm , that is , repeatedly removing edges in decreasing order of capacity , and checking for connectivity of vertices .",
    "this method , however , gives incorrect results because edges with larger capacities may later be required to provide shorter paths for smaller flows .",
    "the sp - af problem requires solving the shortest paths problem and the bottleneck paths problem at the same time .",
    "this is not a trivial matter , as operations required to solve the two problems generally take us in opposite directions ; maximizing bottlenecks comes at the cost of increased distances and minimizing distances comes at the expense of decreased bottlenecks .",
    "we have achieved @xmath3 worst case time for solving sssp - af by fully exploiting the fact that all edges have unit costs .",
    "the resulting algorithm was surprisingly simple , as shown in algorithm [ alg : ssspaf ] .",
    "/ * @xmath85 is for @xmath86 , initially only root @xmath10 * / / * @xmath79 to be processed later * / / * @xmath87 $ ] increased * / / * @xmath79 to be processed later * /    let @xmath87 $ ] be the bottleneck of a path from @xmath10 to vertex @xmath79 , @xmath88 $ ] be the possible length of the path from @xmath10 to @xmath79 , and let @xmath85 represent the spt .",
    "@xmath85 is a kind of persistent data structure , that is , we do not compute @xmath85 from scratch for each maximal flow .",
    "let @xmath89 $ ] be a set of vertices that may be added to @xmath85 at distance @xmath7 , such that @xmath90 , i.e. one set for each possible path length from @xmath10 .",
    "we iterate through each maximal flow @xmath80 in increasing order . at each iteration , all @xmath78 such that @xmath87 < f$ ] is cut from @xmath85 and added to @xmath91 + 1]$ ] .",
    "the key observation here is that when @xmath79 gets cut from @xmath85 , it is only possible for @xmath79 to be re - added to @xmath85 at a greater distance from @xmath10 than the previous distance . for all vertices that have been cut , we attempt to add each back to @xmath85 at the minimum possible path length from @xmath10 for current @xmath80 by emptying @xmath92 from @xmath93 $ ] to @xmath94 $ ] .",
    "if there are many potential parent nodes at a given path length , we choose the parent that gives us the maximum bottleneck .",
    "@xmath85 is organized as a linked structure with detailed operations being omitted . at each iteration",
    "we are effectively solving sssp for the given value of @xmath80 by performing incremental updates to the spt .",
    "therefore at the end of each iteration @xmath95 $ ] contains the shortest distances for all destination vertices for maximal flow @xmath80 , and the path can be retrieved by traversing up the spt .",
    "we perform lifetime analysis of vertices in the data structure @xmath96 $ ] for the worst case time complexity of algorithm [ alg : ssspaf ] .",
    "each vertex @xmath79 can be cut from @xmath85 and be re - added to @xmath85 @xmath73 times , once per each possible path length from @xmath10 . cutting / adding @xmath79 from / to @xmath85 takes @xmath97 time , achieved by setting the parent of @xmath79 to either _ null _ or @xmath98 , respectively . therefore the total time complexity of all operations involving @xmath85 is @xmath99 .",
    "before each vertex @xmath79 is added to @xmath85 all incoming edges @xmath100 are inspected .",
    "this results in @xmath101 edges being inspected in total for the entire duration of the algorithm for each possible path length from @xmath10 .",
    "since there are @xmath73 possible path lengths , the total time taken for edge inspection is @xmath3 .",
    "even though we iterate up to @xmath101 times , we are bounded by the fact that each vertex can only be observed at each possible path length exactly once .",
    "therefore the total time complexity of the algorithm is @xmath3 .",
    "obviously apsp - af can be solved in @xmath13 by running this algorithm @xmath2 times .    .",
    "]    figure [ fig : spt ] shows algorithm [ alg : ssspaf ] being applied on the graph in figure [ fig : graph ] with @xmath102 . initially @xmath85 is created with all edges . at iteration @xmath103 , @xmath104 is cut , causing vertex 7 to be reattached to @xmath85 under vertex 6 .",
    "@xmath105 $ ] is increased from 2 to 3 and @xmath106 $ ] is increased from 2 to 8 .",
    "vertices in @xmath85 will never reoccupy the shaded region , which will grow larger to the right as @xmath80 increases .",
    "for each pair of vertices @xmath6 for each maximal flow , we want to compute the shortest path .",
    "thus our aim here is to obtain tuples of pairs @xmath107 for all @xmath6 , where @xmath80 is the maximum flow that can be pushed through a shortest path whose length is @xmath108 .",
    "we can assume that the values of @xmath29 are all distinct .",
    "let @xmath33 be the capacity matrix and let @xmath109 be the approximate distance matrix for paths that can accommodate flows up to @xmath80 .",
    "a more detailed description of @xmath109 follows shortly in the main description of our algorithm .",
    "let @xmath85 be a matrix such that @xmath110 is a tuple of pairs @xmath107 as described above .",
    "let both @xmath107 and @xmath111 be in @xmath110 such that @xmath112 .",
    "we keep @xmath111 _ iff _ @xmath113 i.e. a longer path is only relevant if it can accommodate a greater flow .",
    "each @xmath110 has at most @xmath47 pairs of @xmath114 .",
    "we assume the pairs are sorted in ascending order of @xmath29 .",
    "we make an interesting observation here that the set of first pairs for all @xmath110 is the solution to apbsp , and the set of last pairs for @xmath110 is the solution to apbp . for apsp - af , all pairs @xmath107 for all @xmath110 are computed .",
    "solving apsp - af on the graph given in figure [ fig : graph ] results in a tuple of four pairs of @xmath114 from vertex 4 to vertex 7 , that is , @xmath115 .",
    "/ * @xmath116 is empty * /    / * append @xmath107 to @xmath110 * / [ line : iterate ] / * append @xmath114 to @xmath110 * /    algorithm [ alg : apspaf ] is largely based on the method given by alon , galil and margalit in @xcite , which is commonly used to solve various all pairs path problems @xcite .",
    "this method has been reviewed in @xcite and we use the same set of terminologies as the review .",
    "the algorithm consists of two phases ; the _ acceleration _ phase and the _ cruising _ phase .",
    "simply speaking , we run the algorithm by alon _",
    "_ for all @xmath80 in parallel with a modified acceleration phase .",
    "we compute the @xmath38-products in the acceleration phase , multiplying the capacity matrix @xmath33 one by one .",
    "the @xmath117 iteration of the acceleration phase , therefore , finds the maximum bottleneck for all paths of lengths up to @xmath29 . after the acceleration phase we initialize distance matrices",
    "@xmath109 from @xmath85 , one matrix for each maximal flow @xmath80 , in preparation for the cruising phase . at this stage , @xmath118 is the length of the shortest path that can push flow @xmath80 , if the path length is @xmath119 or less . in the cruising phase ,",
    "we perform repeated squaring on the distance matrices with the help of the bridging set @xmath120 . at the end of the cruising phase we thus have the shortest paths for all flows for all @xmath6 . retrieving tuples of @xmath107 from the resulting matrix @xmath109",
    "is a reverse process of the initialization for the cruising phase .",
    "now we analyze the worst case time complexity of algorithm [ alg : apspaf ] . for the acceleration phase we use the the current best known algorithm given by duan and pettie @xcite to compute the @xmath38-product in each iteration , giving us @xmath121 . the time complexity for the cruising phase",
    "is @xmath122 .",
    "this is because @xmath123 is @xmath124 as proven in @xcite , and no logarithmic factor is required for repeated squaring because the path length @xmath29 increases by a factor of @xmath125 in each iteration and hence the first squaring dominates the complexity .",
    "the time complexity for the initialization for the cruising phase and the finalization is @xmath126 , which is absorbed by @xmath122 since @xmath127 .",
    "we balance the time complexities of the two phases by setting @xmath128 , which gives us the total time complexity of @xmath129 .",
    "if capacities are integers bounded by @xmath17 , we only have to iterate @xmath17 times in line [ line : iterate ] , giving us @xmath130 .",
    "as noted earlier there can be up to @xmath47 @xmath107 pairs for each vertex pair @xmath6 .",
    "since the lengths of each path can be @xmath73 , explicitly listing all paths could take @xmath131 time .",
    "we get around this by extending the pair @xmath107 to the triplet @xmath132 , where @xmath98 is the successor node . in the acceleration phase witnesses",
    "can be retrieved with an extra polylog factor @xcite , and the successor nodes can be computed from the witnesses at each iteration in @xmath99 time @xcite . in the cruising phase retrieving @xmath98",
    "is a trivial exercise since ordinary matrix multiplication is performed .",
    "we can generate explicit paths in time linear to the path length by using @xmath29 as the index for looking up subsequent successor nodes .",
    "that is , we can still retrieve each successor node in @xmath97 time even with @xmath73 triplets @xmath132 for all pairs @xmath6 because we know that the path length decrements by 1 as we step through each successor node .",
    "so far we have been assuming that the number of distinct edge capacities , @xmath5 , is bounded by the number of edges , @xmath74 , and used only @xmath74 and @xmath2 as complexity parameters .",
    "hence the worst case time complexity of algorithm [ alg : apspaf ] was given to be @xmath129 .",
    "if we compare this with @xmath13 given by algorithm [ alg : ssspaf ] , and @xmath133 given by simply staying in the acceleration phase of algorithm [ alg : apspaf ] until @xmath134 , then we observe that for dense graphs algorithm [ alg : apspaf ] is faster than @xmath13 , and for sparse graphs algorithm [ alg : apspaf ] is faster than @xmath133 .",
    "as we will discuss further in section [ sec : real ] , @xmath5 may not be related to @xmath74 , especially for dense graphs where @xmath14 .",
    "therefore we incorporate @xmath5 directly into the time complexity of algorithm [ alg : apspaf ] to give @xmath135 and the merit of algorithm [ alg : apspaf ] emerges with dense graphs having relatively small number of maximal flows",
    ". another straightforward method of solving apsp - af on graphs with @xmath5 distinct edge capacities is to compute the @xmath51-closure @xmath5 times .",
    "using zwick s algorithm in @xcite , the time complexity of this method is @xmath136 .",
    "clearly , for most values of @xmath5 , algorithm [ alg : apspaf ] is faster .",
    "it is well known that algorithms that utilize faster matrix multiplication over ring is not practical to be used on modern day computers @xcite and are mostly of theoretical importance .",
    "we therefore highlight that algorithm [ alg : apspaf ] can be easily turned into a practical algorithm by computing @xmath38-product in the acceleration phase using the naive approach .",
    "this results in the time complexity of @xmath137 , which is still very much useful for dense graphs alongside our combinatorial algorithm of @xmath13 that is better suited for sparse graphs .",
    "computer networks can be accurately modeled by unweighted directed graphs with edge capacities , by representing each hop ( e.g. router ) as a vertex , each network link as an edge , and the bandwidth of each link as edge capacities . however",
    ", routing protocols that are commonly used today are based on less accurate models . for example , the routing information protocol ( rip ) computes routes based solely on the hop counts , while the open shortest path first ( ospf ) protocol , by default , computes routes based solely on the bandwidths .    in today",
    "s computer networks each router is autonomous , and therefore each router computes sssp . rip is often implemented with bellman - ford algorithm @xcite and ospf is often implemented with dijkstra s algorithm @xcite .",
    "we present sssp - af as a better solution that uses both the hop count and the bandwidth at the same time .",
    "advanced routers are able to gather information such as the current flow amount from one ip subnet to another . with sssp - af ,",
    "a router can make a better routing decision for a given flow based on the flow amount by choosing a route that minimizes the latency without causing congestion .",
    "furthermore , we introduce apsp - af as a potential routing algorithm for software defined networking ( sdn ) @xcite .",
    "sdn is a new paradigm in computer networking where routers are no longer autonomous and the whole network can be controlled at a centralized location .",
    "the central controller has in - depth knowledge of the network and as a result sdn can benefit from more sophisticated routing algorithms . by solving apsp - af for the whole network , the fastest routes can be determined for all flow requirements for all sources and destinations . as noted in section [ sec : distinct ] , algorithm [ alg : apspaf ] can be easily turned into a practical @xmath138 algorithm .",
    "this is very much relevant in real life computer networks where distinct bandwidth values are defined ( e.g. 100mbps , 1gbps ) .",
    "we have extended the well known bottleneck paths problems , introducing new problems that have real life applications .",
    "we provided non - trivial algorithms to solve the problems more efficiently than straightforward methods .",
    "this paper only considered directed unweighted graphs . in enterprise computer networks ,",
    "most links are bi - directional , meaning undirected graphs are adequate for modeling those networks . also for",
    "computer networks involving low latency switches and long cables with repeaters , introducing edge costs may enable more accurate modeling of the networks . hence solving the sp - af problem on other types of graphs",
    "would not only be a natural extension to this paper , but also have relevance in real life .",
    "trivial lower bounds of @xmath139 and @xmath140 exist for sssp - af and apsp - af , respectively .",
    "most current researches in all pairs paths problems focus on breaking the cubic barrier of @xmath141 to get closer to the trivial lower bound of @xmath139 . with the apsp - af problem",
    "we have effectively shifted the focus in time complexities from `` cubic - to - quadratic '' to `` quartic - to - cubic '' .",
    "we have thus opened up a new area of research , where we hope many new contributions would occur in the future ."
  ],
  "abstract_text": [
    "<S> we extend the well known bottleneck paths problem in two directions for directed unweighted ( unit edge cost ) graphs with positive real edge capacities . </S>",
    "<S> firstly we narrow the problem domain and compute the bottleneck of the entire network in @xmath0 time , where @xmath1 is the time taken to multiply two @xmath2-by-@xmath2 matrices over ring . </S>",
    "<S> secondly we enlarge the domain and compute the shortest paths for all possible flow amounts . </S>",
    "<S> we present a combinatorial algorithm to solve the single source shortest paths for all flows ( sssp - af ) problem in @xmath3 worst case time , followed by an algorithm to solve the all pairs shortest paths for all flows ( apsp - af ) problem in @xmath4 time , where @xmath5 is the number of distinct edge capacities . </S>",
    "<S> we also discuss real life applications for these new problems . </S>"
  ]
}