{
  "article_text": [
    "deep learning has achieved remarkable successes in object and voice recognition , machine translation , reinforcement learning and other tasks @xcite . from a practical standpoint",
    "the problem of supervised learning is well - understood and has largely been solved  at least in the regime where both labeled data and computational power are abundant .",
    "the workhorse underlying most deep learning algorithms is error backpropagation @xcite , which is simply gradient descent distributed across a neural network via the chain rule .",
    "gradient descent and its variants are well - understood when applied to convex or nearly convex objectives @xcite .",
    "in particular , they have strong performance guarantees in the stochastic and adversarial settings @xcite .",
    "the reasons for the success of gradient descent in non - convex settings are less clear , although recent work has provided evidence that most local minima are good enough @xcite ; that modern convolutional networks are close enough to convex for many results on rates of convergence apply @xcite ; and that the rate of convergence of gradient - descent can control generalization performance , even in nonconvex settings @xcite .",
    "taking a step back , gradient - based optimization provides a well - established set of computational primitives @xcite , with theoretical backing in simple cases and empirical backing in others .",
    "first - order optimization thus falls in broadly the same category as computing an eigenvector or inverting a matrix : given sufficient data and computational resources , we have algorithms that reliably find good enough solutions for a wide range of problems .",
    "this essay proposes to abstract out the optimization algorithms used for weight updates and focus on how the components of deep learning algorithms interact . treating optimization as a computational primitive encourages a shift from low - level algorithm design to higher - level mechanism design : we can shift attention to designing architectures that are guaranteed to learn distributed representations suited to specific objectives .",
    "the goal is to introduce a language at a level of abstraction where designers can focus on formal specifications ( grammars ) that specify how plug - and - play optimization modules combine into larger learning systems .",
    "let us recall how representation learning is commonly understood .",
    "et al _ describe representation learning as `` learning transformations of the data that make it easier to extract useful information when building classifiers or other predictors '' @xcite .",
    "more specifically , `` a deep learning algorithm is a particular kind of representation learning procedure that discovers multiple levels of representation , with higher - level features representing more abstract aspects of the data '' @xcite . finally , lecun _ et al _ state that multiple levels of representations are obtained `` by composing simple but non - linear modules that each transform the representation at one level ( starting with the raw input ) into a representation at a higher , slightly more abstract level . with the composition of enough such transformations , very complex functions can be learned . for classification tasks , higher layers of representation",
    "amplify aspects of the input that are important for discrimination and suppress irrelevant variations '' @xcite .",
    "the quotes describe the operation of a successful deep learning algorithm .",
    "what is lacking is a characterization of what makes a deep learning algorithm work in the first place",
    ". what properties must an algorithm have to learn layered representations ?",
    "what does it mean for the representation learned by one layer to be useful to another ?",
    "what , exactly , is a representation ?    in practice ,",
    "almost all deep learning algorithms rely on error backpropagation to `` align '' the representations learned by different layers of a network .",
    "this suggests that the answers to the above questions are tightly bound up in first - order ( that is , gradient - based ) optimization methods .",
    "it is therefore unsurprisingly that the bulk of the paper is concerned with tracking the flow of first - order information .",
    "the framework is intended to facilitate the design of more general first - order algorithms than backpropagation .    * * to get started , we need a theory of the meaning or semantics encoded in neural networks . since there is nothing special about neural networks , the approach taken is inclusive and minimalistic . definition  [ d : meaning ] states that the meaning of _ any _ function is how it implicitly categorizes inputs by assigning them to outputs .",
    "the next step is to characterize those functions whose semantics encode knowledge , and for this we turn to optimization @xcite .    * * nemirovski and yudin developed the black - box computational model to analyze the computational complexity of first - order optimization methods @xcite .",
    "the black - box model is a more abstract view on optimization than the turing machine model : it specifies a _ communication protocol _ that tracks how often an algorithm makes _",
    "queries _ about the objective .",
    "it is useful to refine nemirovski and yudin s terminology by distinguishing between black - boxes , which _ respond _ with zeroth - order information ( the value of a function at the query - point ) , and gray - boxes , which respond with zeroth- and first - order information ( the gradient or subgradient ) .    with these preliminaries in hand",
    ", definition  [ d : foo ] proposes that a _ representation _ is a function that is a _ local _ solution to an optimization problem . since we do not restrict to convex problems , finding global solutions is not feasible .",
    "indeed , recent experience shows that global solutions are often not necessary practice @xcite .",
    "the local solution has similar semantics to  that is , it represents  the ideal solution .",
    "the ideal solution usually can not be found : due to computational limitations , since the problem is nonconvex , because we only have access to a finite sample from an unknown distribution , etc .    to see how definition  [ d : foo ] connects with representation learning as commonly understood , it is necessary to take a detour through distributed optimization and game theory .",
    "game theory provides tools for analyzing distributed optimization problems where a set of players aim to minimizes losses that depend not only on their actions , but also the actions of all other players in the game @xcite .",
    "game theory has traditionally focused on convex losses since they are more theoretically amenable . here",
    ", the only restriction imposed on losses is that they are differentiable almost everywhere .    allowing nonconvex losses",
    "means that error - backpropagation can be reformulated as a game .",
    "interestingly , there is enormous freedom in choosing the players .",
    "they can correspond to individual units , layers , entire neural networks , and a variety of other , intermediate choices .",
    "an advantage of the game - theoretic formulation is thus that it applies at many different scales .",
    "nonconvex losses and local optima are essential to developing a _ scale - free _ formalism . even when it turns out that particular units or a particular layer of a neural network are solving a convex problem , convexity is destroyed as soon as those units or layers are combined to form larger learning systems .",
    "convexity is not a property that is preserved in general when units are combined into layers or layers into networks .",
    "it is therefore convenient to introduce the computational primitive @xmath0 to denote the output of a first - order optimization procedure , see definition  [ d : foo ] .    *",
    "* a potential criticism is that the formulation is too broad .",
    "very little can be said about nonconvex optimization in general ; introducing games where many players jointly optimize a set of arbitary nonconvex functions only compounds the problem .",
    "additional structure is required .",
    "a successful case study can be found in @xcite , which presents a detailed game - theoretic analysis of rectifier neural networks .",
    "the key to the analysis is that rectifier units are almost convex .",
    "the main result is that the rate of convergence of a neural network to a local optimum is controlled by the ( waking-)regret of the algorithms applied to compute weight updates in the network .    whereas @xcite relied heavily on specific properties of rectifer nonlinearities",
    ", this paper considers a wide - range of deep learning architectures . nevertheless , it is possible to carve out an interesting subclass of nonconvex games by identifying the composition of simple functions as an essential feature common to deep learning architectures .",
    "compositionality is formalized via distributed communication protocols and grammars .    * * neural networks are constructed by composing a series of elementary operations . the resulting feedforward computation is captured via as a computation graph @xcite .",
    "backpropagation traverses the graph in reverse and recursively computes the gradient with respect to the parameters at each node .",
    "section  [ sec : comp ] maps the feedforward and feedback computations onto the queries and responses that arise in nemirovski and yudin s model of optimization .",
    "however , queries and responses are now highly structured . in the query phase , players feed parameters into a computation graph ( the query graph @xmath1 ) that performs the feedforward sweep . in the response phase , oracles reveal first - order information that is fed into a second computation graph ( the response graph @xmath2 ) .    in most cases",
    "the response graph simply implements backpropagation",
    ". however , there are examples where it does not .",
    "three are highlighted here , see section  [ sec : advers ] , and especially sections  [ sec : pg ] and [ sec : kb ] .",
    "other algorithms where the response graphs do not simply implement backprop include difference target propagation @xcite and feedback alignment @xcite ( both discussed briefly in section  [ sec : kb ] ) and truncated backpropagation through time @xcite , where a choice is made about where to cut backprop short .",
    "examples where the query and response graph differ are of particular interest , since they point towards more general classes of deep learning algorithms .",
    "a _ distributed communication protocol _ is a game with additional structure : the query and response graphs , see definition  [ d : dcp ] .",
    "the graphs capture the compositional structure of the functions learned by a neural network and the compositional structure of the learning procedure respectively .",
    "it is important for our purposes that ( i ) the feedforward and feedback sweeps correspond to two distinct graphs and ( ii ) the communication protocol is kept distinct from the optimization procedure .",
    "that is , the communication protocol specifies how information flows through the networks without specifying how players make use of it .",
    "players can be treated as plug - and - play rational agents that are provided with carefully constructed and coordinated first - order information to optimize as they see fit @xcite .    finally , a _ grammar _ is a distributed communication protocol equipped with a guarantee that the response graph encodes sufficient information for the players to jointly find a local optimum of an objective function .",
    "the paradigmatic example of a grammar is backpropagation . a grammar is a thus a game designed to perform a task . a representation learned by one ( p)layer is useful to another if the game is guaranteed to converge on a local solution to an objective  that is , if the players interact though a grammar .",
    "it follows that the players build representations that jointly encode knowledge about the task .",
    "* * what follows is provisional .",
    "the definitions are a first attempt to capture an interesting , and perhaps useful , perspective on deep learning .",
    "the essay contains no new theorems , algorithms or experiments , see @xcite for `` real work '' based on the ideas presented here .",
    "the essay is not intended to be comprehensive .",
    "many details are left out and many important aspects are not covered : most notably , probabilistic and bayesian formulations , and various methods for unsupervised pre - training .    * * in line with its provisional nature , much of the essay is spent applying the framework to worked examples : error backpropagation as a supervised model @xcite ; variational autoencoders @xcite and generative adversarial networks @xcite for unsupervised learning ; the deviator - actor - critic ( dac ) model for deep reinforcement learning @xcite ; and kickback , a biologically plausible variant of backpropagation @xcite .",
    "the examples were chosen , in part , to maximize variety and , in part , based on familiarity .",
    "the discussions are short ; the interested reader is encouraged to consult the original papers to fill in the gaps .",
    "the last two examples are particularly interesting since their response graphs differ substantially from backpropagation .",
    "the dac model constructs a zeroth - order black - box to estimate gradients rather than querying a first - order gray - box .",
    "kickback prunes backprop s response graph by replacing most of its gray - boxes with black - boxes and approximating the chain rule with ( primarily ) local computations .",
    "bottou and gallinari proposed to decompose neural networks into cooperating modules @xcite .",
    "decomposing more general algorithms or models into collections of interacting agents dates back to the shrieking demons that comprised selfridge s pandemonium @xcite and a long line of related work @xcite .",
    "the focus on components of neural networks as players , or rational agents , in their own right developed here derives from work aimed at modeling biological neurons game - theoretically , see @xcite .",
    "a related approach to semantics based on general value functions can be found in sutton _ et al _ @xcite , see remark  [ rem : sutton ] .",
    "computation graphs as applied to backprop are the basis of the python library theano @xcite and provide the backbone for automatic / algorithmic differentiation @xcite .",
    "grammars are a technical term in the theory of formal languages relating to the chomsky hierarchy @xcite .",
    "there is no apparent relation between that notion of grammar and the one presented here , aside from both relating to structural rules governing composition .",
    "formal languages and deep learning are sufficiently disparate fields that there is little risk of terminological confusion . similarly , the notion of semantics introduced here is distinct from semantics in the theory of programming languages .",
    "although game theory was originally developed to model human interactions @xcite , it has been pointed out that it may be more directly applicable to interacting populations of algorithms , so - called _ machina economicus _ @xcite .",
    "this paper goes one step further to propose that games played over first - order communication protocols are a key component of the foundations of deep learning .",
    "a source of inspiration for the essay is bayesian networks and markov random fields .",
    "probabilistic graphical models and factor graphs provide simple , powerful ways to encode a multivariate distribution s independencies into a diagram @xcite .",
    "they have greatly facilitated the design and analysis of probabilistic algorithms .",
    "however , there is no comparable framework for distributed optimization and deep learning .",
    "the essay is intended as a first step in this direction .",
    "this section defines semantics and representations . in short , the semantics of a function is how it categorizes its inputs ; a function is a representation if it is selected to optimize an objective .",
    "the connection between the definition of representation below and `` representation learning '' is clarified in section  [ sec : ebp ] .",
    "possible world semantics was introduced by lewis to formalize the meaning of sentences in terms of counterfactuals @xcite .",
    "let @xmath3 be a proposition about the world .",
    "its truth depends on its content and the state of the world . rather than allowing the state of the world to vary",
    ", it is convenient to introduce the set @xmath4 of all possible worlds",
    ".    let us denote proposition @xmath3 applied in world @xmath5 by @xmath6 .",
    "the meaning of @xmath3 is then the mapping @xmath7 which assigns 1 or 0 to each @xmath5 according to whether or not proposition @xmath6 is true .",
    "equivalently , the meaning of the proposition is the ordered pair consisting of : all worlds , and the subset of worlds where it is true : @xmath8 for example , the meaning of @xmath9``__that _ _ is blue '' is the subset @xmath10 of possible worlds where i am pointing at a blue object .",
    "the concept of blue is rendered explicit in an exhaustive list of possible examples .",
    "a simple extension of possible world semantics from propositions to arbitrary functions is as follows @xcite :    [ d : meaning]@xmath11 +   given function @xmath12 , the * semantics * or * meaning * of output @xmath13 is the ordered pair of sets @xmath14 functions implicitly categorize inputs by assigning outputs to them ; the meaning of an output is the category .",
    "whereas propositions are true or false , the output of a function is neither . however",
    ", if two functions both optimize a criterion , then one can refer to how _",
    "accurately _ one function _ represents _ the other . before we can define representations",
    "we therefore need to take a quick detour through optimization :    [ d : opt]@xmath11 +   an * optimization problem * is a pair @xmath15 consisting in parameter - space @xmath16 and objective @xmath17 that is differentiable almost everywhere .",
    "the * solution * to the global optimization problem is @xmath18 which is either a maximum or minimum according to the nature of the objective .",
    "the solution may not be unique ; it also may not exist unless further restrictions are imposed .",
    "such details are ignored here .",
    "next recall the black - box optimization framework introduced by nemirovski and yudin @xcite .",
    "[ d : protocol]@xmath11 +   a * communication protocol * for optimizing an unknown objective @xmath17 consists in a user ( or player ) and an oracle . on each round",
    ", user presents a * query * @xmath19 .",
    "oracle can * respond * in one of two ways , depending on the nature of the protocol :    * _ black - box ( zeroth - order ) protocol . _ + oracle responds with the value @xmath20 .",
    "+ + at ( 0,0 ) ( player ) * player * ; at ( 3,0 ) ( block ) @xmath21 ; ( player ) edge node[above ] @xmath22 ( block ) ; at ( 8,0 ) ( player_a ) * player * ; at ( 11,0 ) ( oracle ) @xmath21 ; ( oracle ) edge node[above ] @xmath20 ( player_a ) ; +   + * _ gray - box ( first - order ) protocol . _",
    "+ oracle responds with either the gradient @xmath23 or with the gradient together with the value .",
    "+ + at ( 0,0 ) ( player ) * player * ; at ( 3,0 ) ( block ) @xmath21 ; ( player ) edge node[above ] @xmath22 ( block ) ; at ( 8,0 ) ( player_a ) * player * ; at ( 11,0 ) ( oracle ) * oracle@xmath24 * ; ( oracle ) edge node[above ] @xmath25 ( player_a ) ;    the protocol specifies how player and oracle interact without specifying the algorithm used by player to decide which points to query .",
    "the next section introduces _ distributed communication protocols _ as a general framework that includes a variety of deep learning architectures as special cases  again without specifying the precise algorithms used to perform weight updates .    unlike @xcite we do not restrict to convex problems . finding a global optimum",
    "is not always feasible , and in practice often unnecessary .",
    "[ d : foo]@xmath11 +   let @xmath26 be a function space and @xmath27 be a map from parameter - space to functions .",
    "further suppose that objective function @xmath28 is given .",
    "a * representation * is a local solution to the optimization problem @xmath29 corresponding to a _",
    "local _ maximum or minimum according to whether the objective is minimized or maximized .",
    "intuitively , the objective quantifies the extent to which functions in @xmath30 categorize their inputs similarly .",
    "the operation @xmath0 applies a first - order method to find a function whose semantics resembles the optimal solution @xmath31 where @xmath32 .    in short , representations are functions with useful semantics , where usefulness is quantifed using a specific objective : the lower the loss or higher the reward associated with a function , the more useful it is .",
    "the relation between definition  [ d : foo ] and representations as commonly understood in the deep learning literature is discussed in section  [ sec : ebp ] below .",
    "[ rem : sutton]@xmath11 +   in related work , sutton _",
    "et al _ @xcite proposed that semantics ",
    "i.e. knowledge about the world  can be encoded in general value functions that provide answers to specific questions about expected rewards .",
    "definition  [ d : meaning ] is more general than their approach since it associates a semantics to _ any _ function .",
    "however , the function must arise from optimizing an objective for its semantics to accurately represent a phenomenon of interest .",
    "the main example of a representation arises under supervised learning .",
    "[ rep : sup]@xmath11 +   let @xmath33 and @xmath34 be an input space and a set of labels and @xmath35 be a loss function .",
    "suppose that @xmath36 is a parametrized family of functions .",
    "* _ nature _ which samples labeled pairs @xmath37 i.i.d . from distribution",
    "@xmath38 , singly or in batches . *",
    "_ predictor _ chooses parameters @xmath19 . *",
    "_ objective _ is @xmath39.\\ ] ]    the query and responses phases can be depicted graphically as +    at ( 0,0 ) ( player ) * predictor * ; at ( 5,0 ) ( block ) @xmath40}$ ] ; ( player ) edge node[above ] @xmath22 ( block ) ; at ( 10,0 ) ( player_a ) * predictor * ; at ( 15,0 ) ( oracle ) * oracle@xmath24 * ; ( oracle ) edge node[above ] @xmath25 ( player_a ) ;     + the predictor @xmath41 is then a representation of the optimal predictor @xmath42 .",
    "a commonly used mapping from parameters to functions is @xmath43 where a feature map @xmath44 is fixed .",
    "the setup admits a variety of complications in practice .",
    "firstly , it is typically infeasible even to find a local optimum .",
    "instead , a solution that is within some small @xmath45 of the local optimum suffices .",
    "secondly , the distribution @xmath38 is unknown , so the expectation is replaced by a sum over a finite sample .",
    "the quality of the resulting representation has been extensively studied in statistical learning theory @xcite .",
    "finally , it is often convenient to modify the objective , for example by incorporating a regularizer .",
    "thus , a more detailed presentation would conclude that @xmath46 yields a representation @xmath47 of the solution to @xmath48 $ ] . to keep the discussion and notation simple",
    ", we do not consider any of these important details .",
    "it is instructive to unpack the protocol , by observing that the objective @xmath21 is a composite function involving @xmath49 , @xmath50 and @xmath51 $ ] : +    at ( 0,0 ) ( glabel ) * query * ; at ( 4.5,0 ) ( unknown_in ) * nature * ; at ( 0,-2 ) ( player ) * predictor * ; at ( 3,-2 ) ( block1 ) @xmath52 ; at ( 6,-2 ) ( block2 ) @xmath53 ; ( unknown_in ) edge node[left ] @xmath54 ( block1 ) ; ( player ) edge node[above ] @xmath22 ( block1 ) ; ( block1 ) edge node[left ] @xmath55 ( block2 ) ; ( unknown_in ) edge node[right ] @xmath56 ( block2 ) ;    at ( 9,0 ) ( glabel ) * response * ; at ( 9,-2 ) ( player_out ) * predictor * ; at ( 15,-2 ) ( oracle_l ) * oracle@xmath57 * ; at ( 12,0 ) ( oracle_f ) * oracle@xmath58 * ; at ( 12,-2 ) ( block ) @xmath59 ;    ( oracle_l ) edge node[above ] @xmath60 ( block ) ; ( oracle_f ) edge node[right ] @xmath61 ( block ) ; ( block ) edge node[below ] @xmath62 ( player_out ) ; ( block ) edge node[above ] @xmath63 ( player_out ) ;    the notation @xmath63 is borrowed from backpropagation .",
    "it is shorthand for the derivative of the objective with respect to parameters @xmath22 .",
    "nature is not a deterministic black - box since it is not queried directly : nature produces @xmath37 pairs stochastically , rather than in response to specific inputs .",
    "our notion of black - box can be extended to stochastic black - boxes , see e.g. @xcite . however , once again we prefer to keep the exposition as simple as possible .",
    "the second example concerns fitting a probabilistic or generative model to data .",
    "a natural approach is to find the distribution under which the observed data is most likely :    @xmath11 +   let @xmath33 be a data space .",
    "* _ nature _ samples points from distribution @xmath64 . * _ estimator _ chooses parameters @xmath19 . *",
    "_ operator _",
    "@xmath65 computes a probability density on @xmath33 that depends on parameter @xmath66 . *",
    "_ operator _",
    "@xmath67 acts as a loss .",
    "the objective is to mimimize @xmath68.\\ ] ]    at ( 0,0 ) ( player ) * estimator * ; at ( 5,0 ) ( block ) @xmath69}$ ] ; ( player ) edge node[above ] @xmath22 ( block ) ; at ( 10,0 ) ( player_a ) * estimator * ; at ( 15,0 ) ( oracle ) * oracle@xmath24 * ; ( oracle ) edge node[above ] @xmath25 ( player_a ) ;     +    the estimate @xmath70 , where @xmath71 , is a representation of the optimal solution , and can also be considered a representation of @xmath64 .",
    "the setup extends easily to maximum _ a posteriori _ estimation .",
    "as for supervised learning , the protocol can be unpacked by observing that the objective has a compositional structure : +    at ( 0,0 ) ( glabel ) * query * ; at ( 3,0 ) ( unknown_in ) * nature * ; at ( 0,-2 ) ( player ) * estimator * ; at ( 3,-2 ) ( block1 ) @xmath72 ; at ( 6,-2 ) ( block2 ) @xmath73 ; ( unknown_in ) edge node[left ] @xmath54 ( block1 ) ; ( player ) edge node[above ] @xmath66 ( block1 ) ; ( block1 ) edge node[left ] @xmath55 ( block2 ) ;    at ( 9,0 ) ( glabel ) * response * ; at ( 9,-2 ) ( player_out ) * estimator * ; at ( 15,-2 ) ( oracle_l ) * oracle@xmath74 * ; at ( 12,0 ) ( oracle_f ) * oracle@xmath75 * ; at ( 12,-2 ) ( block ) @xmath59 ;    ( oracle_l ) edge node[above ] @xmath76 ( block ) ; ( oracle_l ) edge node[below ] @xmath77 ( block ) ; ( oracle_f ) edge node[left ] @xmath78 ( block ) ; ( block ) edge node[below ] @xmath79 ( player_out ) ; ( block ) edge node[above ] @xmath80 ( player_out ) ;      the third example is taken from reinforcement learning @xcite .",
    "we will return to reinforcement learning in section  [ sec : pg ] , so the example is presented in some detail . in reinforcement learning , an agent interacts with its environment , which is often modeled as a markov decision process consisting of state space @xmath81 , action space @xmath82 , initial distribution @xmath83 on states , stationary transition distribution @xmath84 and reward function @xmath85 .",
    "the agent chooses actions based on a _ policy _ : a function @xmath86 from states to actions .",
    "the goal is to find the optimal policy .",
    "actor - critic methods break up the problem into two pieces @xcite .",
    "the critic estimates the expected value of state - action pairs given the current policy , and the actor attempts to find the optimal policy using the estimates provided by the critic .",
    "the critic is typically trained via temporal difference methods @xcite .",
    "let @xmath87 denote the distribution on states @xmath88 at time @xmath89 given policy @xmath90 and initial state @xmath91 at @xmath92 and let @xmath93 .",
    "let @xmath94 be the discounted future reward .",
    "define the value of a state - action pair as @xmath95.\\ ] ] unfortunately , the value - function @xmath96 can not be queried . instead",
    ", temporal difference methods take a bootstrapped approach by minimizing the bellman error : @xmath97\\ ] ] where @xmath88 is the state subsequent to @xmath91 .",
    "@xmath11 +   critic interacts with black - boxes actor and nature .    *",
    "_ critic _ plays parameters @xmath98 .",
    "* _ operator _ @xmath99 and @xmath100 estimates the value function and compute the bellman error . in practice , it turns out to _ clone _ the value - estimate periodically and compute a slightly modified bellman error : @xmath101\\ ] ] where @xmath102 is the cloned estimate .",
    "cloning improves the stability of td - learning @xcite . a nice conceptual side - effect of cloning is that td - learning reduces to gradient descent .",
    "+ + at ( 0,0 ) ( glabel ) * query * ; at ( 6,0 ) ( unknown_in ) * nature * ; at ( 3,0 ) ( actor ) * actor * ; at ( 0,-2 ) ( player ) * critic * ; at ( 3,-2 ) ( block1 ) @xmath103 ; at ( 6,-2 ) ( block2 ) @xmath104 ; ( unknown_in ) edge node[left ] @xmath91 ( block1 ) ; ( player ) edge node[above ] @xmath105 ( block1 ) ; ( block1 ) edge node[left ] @xmath55 ( block2 ) ; ( unknown_in ) edge node[right ] @xmath106 ( block2 ) ; ( actor ) edge node[left ] @xmath107 ( block1 ) ; + at ( 9,0 ) ( glabel ) * response * ; at ( 9,-2 ) ( player_out ) * critic * ; at ( 15,-2 ) ( oracle_l ) * oracle@xmath108 * ; at ( 12,0 ) ( oracle_f ) * oracle@xmath109 * ; at ( 12,-2 ) ( block ) @xmath59 ; + ( oracle_l ) edge node[above ] @xmath110 ( block ) ; ( oracle_f ) edge node[right ] @xmath111 ( block ) ; ( block ) edge node[above ] @xmath112 ( player_out ) ; +   +    the estimate is a representation of the true value function .",
    "@xmath11 +   temporal difference learning is not strictly speaking a gradient - based method @xcite .",
    "the residual gradient method performs gradient descent on the bellman error , but suffers from double sampling @xcite .",
    "projected fixpoint methods minimize the _ projected _ bellman error via gradient descent and have nice convergence properties @xcite .",
    "an interesting recent proposal is implicit td learning @xcite , which is based on implicit gradient descent @xcite .",
    "section  [ sec : pg ] presents the deviator - actor - critic model which simultaneously learns a value - function estimate and a locally optimal policy .",
    "it is often useful to decompose complex problems into simpler subtasks that can handled by specialized modules .",
    "examples include variational autoencoders , generative adversarial networks and actor - critic models .",
    "neural networks are particularly well - adapted to modular designs , since units , layers and even entire networks can easily be combined analogously to bricks of lego @xcite",
    ".    however , not all configurations are viable models .",
    "a methodology is required to distinguish good designs from bad .",
    "this section provides a basic language to describe how bricks are glued together that may be a useful design tool .",
    "the idea is to extend the definitions of optimization problems , protocols and representations from section  [ sec : reps ] from single to multi - player optimization problems .",
    "[ d : game]@xmath11 +   a * distributed optimization problem * or * game * @xmath113,\\theta , { \\ensuremath{\\boldsymbol\\ell}})$ ] is a set @xmath114=\\{1,\\ldots n\\}$ ] of players , a parameter space @xmath115 , and loss vector @xmath116 .",
    "player @xmath117 picks moves from @xmath118 and incurs loss determined by @xmath119 .",
    "the goal of each player is to minimize its loss , which depends on the moves of the other players .",
    "the classic example is a _ finite game _",
    "@xcite , where player @xmath117 has a menu of @xmath120-actions and chooses a distribution over actions , @xmath121 on each round .",
    "losses are specified for individual actions , and extended linearly to distributions over actions .",
    "a natural generalization of finite games is _ convex games _ where the parameter spaces are compact convex sets and each loss @xmath122 is a convex function in its @xmath123-argument @xcite . it has been shown that players implementing no - regret algorithms are guaranteed to converge to a correlated equilibrium in convex games @xcite .          computation graphs are a useful tool for calculating derivatives @xcite . for simplicity , we restrict to deterministic computation graphs .",
    "more general stochastic computation graphs are studied in @xcite .        * _ query phase .",
    "_ players provide inputs to the query graph _ ( @xmath1 ) _ that operators transform into outputs .",
    "* _ response phase . _ operators in @xmath1 act as oracles in the response graph _ ( @xmath2 ) _ : they input subgradients that are transformed and communicated to the players .",
    "the protocol specifies how players and oracles communicate without specifying the optimization algorithms used by the players .",
    "the addition of a response graph allows more general computations than simply backpropagating the gradients of the query phase .",
    "the additional flexibility allows the design of new algorithms , see sections  [ sec : pg ] and [ sec : kb ] below .",
    "it is also sometimes necessary for computational reasons .",
    "for example , backpropagation through time on recurrent networks typically runs over a truncated response graph @xcite .",
    "suppose that we wish to optimize an objective function @xmath124 that depends on all the moves of all the players .",
    "finding a global optimum is clearly not feasible .",
    "however , we may be able to construct a protocol such that the players are jointly able to find local optima of the objective . in such cases ,",
    "we refer to the protocol as a grammar :    [ d : grammar]@xmath11 +   a * grammar * for objective @xmath124 is a distributed communication protocol where the response graph provides _ sufficient _ first - order information to find a local optimum of @xmath125 .",
    "the guarantee ensures that the representations constructed by players in a grammar can be combined into a coherent distributed representation .",
    "that is , it ensures that the representations constructed by the players transform data in a way that is useful for optimizing the shared objective @xmath21 .",
    "the players losses need not be explicitly computed .",
    "all that is necessary is that the response phase communicate the gradient information needed for players to locally minimize their losses  and that doing so yields a local optimum of the objective .    *",
    "* functions can be inserted into grammars as lego - like building blocks via function composition during queries and the chain rule during responses .",
    "let @xmath126 be a function that takes inputs @xmath22 and @xmath127 , provided by a player and by upstream computations respectively .",
    "the output of @xmath128 is communicated downstream in the query phase : +    at ( 0,0 ) ( glabel ) * query * ; at ( 0,-2 ) ( unknown_in ) @xmath55 ; at ( 6,-2 ) ( unknown_out ) @xmath55 ; at ( 3,0 ) ( player ) * player * ; at ( 0,-4 ) ( unknown_x ) @xmath55 ; at ( 3,-2 ) ( block ) @xmath129 ; ( unknown_in ) edge node[above ] @xmath127 ( block ) ; ( player ) edge node[left ] @xmath22 ( block ) ; ( block ) edge node[above ] @xmath128 ( unknown_out ) ;    at ( 0,0 ) ( glabel ) * response * ; at ( 0,-2 ) ( unknown_in ) @xmath55 ; at ( 6,-2 ) ( unknown_out ) @xmath55 ; at ( 3,0 ) ( player ) * player * ; at ( 3,-2 ) ( block ) @xmath59 ; at ( 3,-4 ) ( oracle ) * oracle@xmath130 * ; ( block ) edge node[left ] @xmath131 ( player ) ; ( block ) edge node[right ] @xmath132 ( player ) ; ( block ) edge node[above ] @xmath133 ( unknown_in ) ; ( block ) edge node[below ] @xmath134 ( unknown_in ) ; ( unknown_out ) edge node[above ] @xmath135 ( block ) ; ( oracle ) edge node[right ] @xmath136 ( block ) ;     + the chain rule is implemented in the response phase as follows .",
    "oracle@xmath137 reports the gradient @xmath138 in the response phase .",
    "operator `` @xmath139 '' computes the products @xmath140 via matrix multiplication .",
    "the projection of the product onto the first and second components '' produce two outputs , the entire vector can be reported in both direction with the irrelevant components ignored . ]",
    "are reported to player and upstream respectively .      1 .",
    "_ exact gradients . _",
    "+ under error backpropagation the response graph implements the chain rule , which guarantees that players receive the gradients of their loss functions ; see section  [ sec : ebp ] .",
    "surrogate objectives . _ + the variational autoencoder uses a surrogate objective : the variational lower bound . maximizing the surrogate",
    "is guaranteed to also maximize the true objective , which is computational intractable ; see section  [ sec : vae ] .",
    "learned objectives . _",
    "+ in the case of generative adversarial network and the dac - model , some of the players learn a loss that is guaranteed to align with the true objective , which is unknown ; see sections  [ sec : advers ] and [ sec : pg ] .",
    "4 .   _ estimated gradient . _",
    "+ in the dac - model and kickback , gradient estimates are substituted for the true gradient ; see sections  [ sec : pg ] and [ sec : kb ] .",
    "guarantees are provided on the estimates .",
    "@xmath11 +   there is considerable freedom regarding the choice of players . in the examples below ,",
    "players are typically chosen to be layers or entire neural networks to keep the diagrams simple .",
    "it is worth noting that zooming in , such that players correspond to individual units , has proven to be a useful tool when analyzing neural networks @xcite .",
    "the game - theoretic formulation is thus scale - free and can be coarse- or fine - grained as required .",
    "a mathematical language for tracking the structure of hierarchical systems at different scales is provided by operads , see @xcite and the references therein , which are the natural setting to study the composition of operators that receive multiple inputs .",
    "the main example of a grammar is a neural network using error backpropagation to perform supervised learning .",
    "layers in the network can be modeled as players in a game . setting each ( p)layer s objective as the network s loss , which it minimizes using gradient ascent , yields backpropagation .",
    "[ c : chain_rule]@xmath11 +   an @xmath141-layer neural network can be reformulated as a game played between @xmath142 players , corresponding to _ nature _ and the _ layers _ of the network .",
    "the query graph for a 3-layer network is : +    * _ nature _ plays samples datapoints @xmath37 i.i.d . from @xmath143 and acts as the zeroth player . *",
    "_ layer@xmath144 _ plays weight matrices @xmath145 . * _ operators _ compute @xmath146 for each layer , along with loss @xmath147 .",
    "the protocol can be extended to convolutional networks by replacing the matrix multiplications performed by each operator , @xmath148 , with convolutions and adding parameterless max - pooling operators @xcite .      *",
    "* we are now in a position to relate the notion of representation in definition  [ d : foo ] with the standard notion of representation learning in neural networks . in the terminology of section  [ sec :",
    "reps ] , each player learns a representation .",
    "the representations learned by the different players form a coherent distributed representation because they jointly optimize a single objective function .",
    "if we set @xmath153 then the function @xmath154 fits the definition of representation above .",
    "moreover , the compositional structure of the network implies that @xmath155 is composed of subrepresentations corresponding to the optimizations performed by the different players in the grammar : each function @xmath156 is a local optimum  where @xmath157 is optimized to transform its inputs into a form that is useful to network as a whole .    *",
    "* little can be said in general about the rate of converge of the layers in a neural network since the loss is not convex .",
    "however , neural networks can be decomposed further by treating the individual units as players . when the units are linear or rectilinear , it turns out that the network is a _",
    "circadian game_. the circadian structure provides a way to convert results about the convergence of convex optimization methods into results about the global convergence a rectifier network to a local optimum , see @xcite .",
    "the next example extends the unsupervised setting described in section  [ sec : unsupervised ] .",
    "suppose that observations @xmath158 are sampled i.i.d .",
    "from a two - step stochastic process : a latent value @xmath159 is sampled from @xmath160 , after which @xmath161 is sampled from @xmath162 .",
    "the goal is to ( i ) find the maximum likelihood estimator for the observed data and ( ii ) estimate the posterior distribution on @xmath163 conditioned on an observation @xmath164 .",
    "a straightforward approach is to maximize the marginal likelihood @xmath165 and then compute the posterior @xmath166 however , the integral in eq .",
    "is typically untractable , so a more roundabout tactic is required .",
    "the approach proposed in @xcite is to construct two neural networks , a decoder @xmath167 that learns a generative model approximating @xmath168 , and an encoder @xmath169 that learns a recognition model or posterior approximating @xmath170 .",
    "it turns out to be useful to replace the encoder with a deterministic function , @xmath171 , and a noise source , @xmath172 that are compatible .",
    "here , compatible means that sampling @xmath173 is equivalent to sampling @xmath174 and computing @xmath175 .",
    "* _ environment _ plays i.i.d .",
    "samples from @xmath176 * _ noise _ plays i.i.d .",
    "samples from @xmath172 .",
    "it also communicates its density function @xmath172 , which is analogous to a gradient  and the reason that _ noise _ is gray rather than black - box . *",
    "_ encoder _ and _ decoder _ play parameters @xmath177 and @xmath22 respectively . * _",
    "@xmath178 is a neural network that encodes samples into latent variables . *",
    "_ operator _",
    "@xmath179 is a neural network that estimates the probability of @xmath164 conditioned on @xmath163 . *",
    "the remaining operators compute the ( negative ) variational lower bound @xmath180}_{{{\\mathcal l}}_2}.\\ ] ]      at ( 0,0 ) ( glabel ) * response * ; at ( 2,-2 ) ( oracle1 ) * oracle@xmath130 * ; at ( 13,-2 ) ( oracle2)*oracle@xmath181 * ; at ( 2,-4 ) ( oracle4 ) * oracle@xmath182 * ; at ( 13,-4 ) ( oracle3 ) * oracle@xmath183 * ; at ( 7,-4 ) ( oracle5 ) * oracle@xmath184 * ; at ( 5,-2 ) ( block1 ) @xmath185 ; at ( 9,-2 ) ( block2 ) @xmath186 ; at ( 5,-4 ) ( block3 ) @xmath186 ; at ( 9,-4 ) ( block4 ) @xmath186 ; at ( 2,0 ) ( block5 ) @xmath186 ; at ( 5,0 ) ( player1 ) * encoder * ; at ( 9,0 ) ( player2 ) * decoder * ;    ( oracle1 ) edge node[left ] @xmath187 ( block5 ) ; ( oracle2 ) edge node[above ] @xmath188 ( block2 ) ; ( block4 ) edge node[right ] @xmath189 ( block2 ) ; ( oracle3 ) edge node[above ] @xmath190 ( block4 ) ; ( oracle4 ) edge node[above ] @xmath191 ( block3 ) ; ( oracle5 ) edge node[above ] @xmath192 ( block3 ) ; ( oracle5 ) edge node[above ] @xmath192 ( block4 ) ; ( block1 ) edge node[below ] @xmath135 ( block5 ) ; ( block2 ) edge node[above ] @xmath193 ( block1 ) ; ( block3 ) edge node[left ] @xmath191 ( block1 ) ; ( block5 ) edge node[above ] @xmath194 ( player1 ) ; ( block2 ) edge node[left ] @xmath195 ( player2 ) ; ( block2 ) edge node[right ] @xmath63 ( player2 ) ;      1 .   maximizing the variational lower bound yields ( i ) a maximum likelihood estimator and ( ii ) an estimate of the posterior on the latent variable @xcite .",
    "the chain rule ensures that the correct gradients are communicated to encoder and decoder .",
    "a recent approach to designing generative models is to construct an adversarial game between forger and curator @xcite .",
    "forger generates samples ; curator aims to discriminate the samples produced by forger from those produced by nature .",
    "forger aims to create samples realistic enough to fool curator .",
    "if forger plays parameters @xmath22 and curator plays @xmath177 then the game is described succinctly via @xmath196      + \\operatorname*{\\mathbb e}_{{\\ensuremath{\\boldsymbol\\epsilon}}\\sim{{\\mathbb p}}_{noise}({\\ensuremath{\\boldsymbol\\epsilon}})}\\big[\\log ( 1 - d_{{{\\ensuremath{\\boldsymbol{\\phi}}}}}(g_{{{\\ensuremath{\\boldsymbol{\\theta}}}}}({\\ensuremath{\\boldsymbol\\epsilon}})))\\big ]      \\right],\\ ] ] where @xmath197 is a neural network that converts noise in samples and @xmath198 classifies samples as fake or not .",
    "* _ environment _ samples images i.i.d . from @xmath176 . *",
    "_ noise _ samples i.i.d . from @xmath199 .",
    "* _ forger _ and _ curator _ play parameters @xmath22 and @xmath177 respectively . * _ operator",
    "_ @xmath197 is a neural network that produces fake image @xmath200 .",
    "* _ operator _",
    "@xmath201 is a neural network that estimates the probability that an image is fake .",
    "* the remaining operators compute a loss that _ curator _ minimizes and _ forger _",
    "maximizes @xmath202}_{{\\ensuremath{\\boldsymbol\\ell}}_{disc } }               + \\underbrace{\\operatorname*{\\mathbb e}_{{\\ensuremath{\\boldsymbol\\epsilon}}\\sim { { \\mathbb p}}({\\ensuremath{\\boldsymbol\\epsilon}})}\\big[\\log\\big(1-d_{{\\ensuremath{\\boldsymbol{\\phi}}}}(g_{{\\ensuremath{\\boldsymbol{\\theta}}}}({\\ensuremath{\\boldsymbol\\epsilon}}))\\big)\\big]}_{{\\ensuremath{\\boldsymbol\\ell}}_{gen}}\\ ] ]    note there are two copies of operator @xmath203 in the query graph .",
    "the response graph implements the chain rule , with a tweak that multiplies the gradient communicated to _ forger _ by @xmath204 to ensure that _ forger _ maximizes the loss that _ curator _ is minimizing .",
    "+    at ( 0,0 ) ( glabel ) * response * ; at ( 0,-3 ) ( player1 ) * forger * ; at ( 4,0 ) ( player2 ) * curator * ; at ( 4,-3 ) ( block1 ) @xmath186 ; at ( 8,-3 ) ( block2 ) @xmath186 ; at ( 12,-3 ) ( block3 ) @xmath186 ; at ( 12,-1 ) ( block4 ) @xmath186 ; at ( 8,-1 ) ( block4a ) @xmath186 ; at ( 4,-1 ) ( block5 ) @xmath185 ; at ( 12,-4 ) ( oracle3 ) * oracle@xmath205 * ; at ( 12,0 ) ( oracle4 ) * oracle@xmath206 * ; at ( 12,-2 ) ( oracle5 ) * oracle@xmath184 * ; at ( 4,-4 ) ( oracle1 ) * oracle@xmath130 * ; at ( 8,-4 ) ( oracle2 ) * oracle@xmath207 * ; at ( 8,0 ) ( oracle2a ) * oracle@xmath207 * ;    ( block1 ) edge node[below ] @xmath131 ( player1 ) ; ( block1 ) edge node[above ] @xmath63 ( player1 ) ; ( block2 ) edge node[right ] @xmath208 ( block5 ) ; ( oracle4 ) edge node[right ] @xmath209 ( block4 ) ; ( block2 ) edge node[above ] @xmath135 ( block1 ) ; ( block2 ) edge node[below ] @xmath210 ( block1 ) ; ( oracle2 ) edge node[right ] @xmath211 ( block2 ) ; ( oracle2a ) edge node[right ] @xmath212 ( block4a ) ; ( oracle1 ) edge node[left ] @xmath213 ( block1 ) ; ( oracle3 ) edge node[right ] @xmath214 ( block3 ) ; ( oracle5 ) edge node[right ] @xmath192 ( block3 ) ; ( oracle5 ) edge node[right ] @xmath192 ( block4 ) ; ( block4 ) edge node[above ] @xmath215 ( block4a ) ; ( block4a ) edge node[above ] @xmath216 ( block5 ) ; ( block4 ) edge node[below ] @xmath217 ( block4a ) ; ( block3 ) edge node[above ] @xmath218 ( block2 ) ; ( block3 ) edge node[below ] @xmath214 ( block2 ) ; ( block5 ) edge node[left ] @xmath219 ( player2 ) ;          the generative - adversarial network is the first example where the response graph does not simply backpropagate gradients : the arrow labeled @xmath223 is computed as @xmath224 , whereas backpropagation would use @xmath225 .",
    "the minus sign arises due to the adversarial relationship between forger and curator ",
    "they do not optimize the same objective .      as discussed in section  [ sec : valprox ] , actor - critic algorithms decompose the reinforcement learning problem into two components : the critic , which learns an approximate value function that predicts the total discounted future reward associated with state - action pairs , and the actor , which searches for a policy that maximizes the value appoximation provided by the critic .",
    "when the action - space is continuous , a natural approach is to follow the gradient @xcite . in @xcite , it was shown how to compute the policy gradient given the true value function .",
    "furthermore , sufficient conditions were provided for an approximate value function learned by the critic to yield an unbiased estimator of the policy gradient .",
    "more recently @xcite provided analogous results for deterministic policies .",
    "the next example of a grammar is taken from @xcite , which builds on the above work by introducing a third algorithm , deviator , that directly estimates the gradient of the value function estimated by critic .      at ( 0,-1.5 ) ( glabel ) * query * ; at ( 0,0 ) ( actor ) * actor * ; at ( 0,-3 ) ( deviator ) * deviator * ; at ( 14,0 ) ( critic ) * critic * ; at ( 14,-3 ) ( noise ) * noise * ; at ( 6.5,-1.5 ) ( env ) * nature * ; at ( 3,0 ) ( block1 ) @xmath90 ; at ( 3,-3 ) ( block2 ) @xmath226 ; at ( 10,0 ) ( block3 ) @xmath103 ; at ( 10,-3 ) ( block4 ) @xmath53 ; ( actor ) edge node[above ] @xmath22 ( block1 ) ; ( deviator ) edge node[above ] @xmath105 ( block2 ) ; ( critic ) edge node[above ] @xmath227 ( block3 ) ; ( noise ) edge node[above ] @xmath228 ( block4 ) ; ( block1 )  ( block2 ) ; ( block1 )  ( block3 ) ; ( block2 )  ( block4 ) ; ( block3 )  ( block4 ) ; ( env ) edge node[above ] @xmath91 ( block1 ) ; ( env ) edge node[above ] @xmath91 ( block2 ) ; ( env ) edge node[above ] @xmath91 ( block3 ) ; ( env ) edge node[above ] @xmath106 ( block4 ) ;    * _ nature _ samples states from @xmath84 and announces rewards @xmath229 that are a function of the prior state and action ; _ noise _ samples @xmath230 . * _ actor _ , _ critic _ and _ deviator _ play parameters @xmath22 , @xmath227 and @xmath105 respectively . *",
    "_ operator _",
    "@xmath90 is a neural network that computes actions @xmath231 . *",
    "_ operator _",
    "@xmath232 is a neural network that estimates the value of state - action pairs . *",
    "_ operator _",
    "@xmath233 is a neural network that estimates the gradient of the value function . *",
    "the remaining _ operator _ computes the bellman gradient error ( bge ) which _ critic _ and _ deviator _ minimize @xmath234      at ( 0,-1.5 ) ( glabel ) * response * ; at ( 0,0 ) ( actor ) * actor * ; at ( 0,-3 ) ( deviator ) * deviator * ; at ( 14,0 ) ( critic ) * critic * ; at ( 5.5,0 ) ( oracle1 ) * oracle@xmath236 * ; at ( 5.5,-1.5 ) ( oracle2)*oracle@xmath237 * ; at ( 3,-1.5 ) ( op2 ) @xmath238 ; at ( 7.5,0 ) ( oracle3 ) * oracle@xmath239 * ; at ( 10,-3 ) ( oracle4 ) * oracle@xmath57 * ; at ( 3,0 ) ( block1 ) @xmath59 ; at ( 5.5,-3 ) ( block2 ) @xmath59 ; at ( 10,0 ) ( block3 ) @xmath59 ;    ( block1 ) edge node[below ] @xmath240 ( actor ) ; ( block1 ) edge node[above ] @xmath241 ( actor ) ; ( block2 ) edge node[below ] @xmath242 ( deviator ) ; ( block2 ) edge node[above ] @xmath112 ( deviator ) ; ( block3 ) edge node[below ] @xmath243 ( critic ) ; ( block3 ) edge node[above ] @xmath244 ( critic ) ; ( oracle1 ) edge node[below ] @xmath245 ( block1 ) ; ( oracle4 ) edge node[below ] @xmath246 ( block2 ) ; ( oracle4 ) edge node[above ] @xmath247 ( block2 ) ; ( oracle4 ) edge node[right ] @xmath248 ( block3 ) ; ( oracle4 ) edge node[left ] @xmath249 ( block3 ) ; ( oracle2 ) edge node[left ] @xmath250 ( block2 ) ; ( op2 ) edge node[right ] @xmath226 ( block1 ) ; ( op2 ) edge node[left ] @xmath251 ( block1 ) ; ( oracle3 ) edge node[below ] @xmath252 ( block3 ) ;    note that instead of backpropagating first - order information in the form of gradient @xmath253 , the response graph instead backpropagates zeroth - order information in the form of _ gradient - estimate _",
    "@xmath226 , which is computed by the query graph during the feedforward sweep .",
    "we therefore write @xmath251 and @xmath254 ( instead of @xmath255 and @xmath256 to emphasize that the gradients communicated to actor are estimates .        1 .",
    "_ critic _ estimates the value function via td - learning @xcite with cloning for improved stability @xcite .",
    "deviator _ estimates the value gradient via td - learning and the gradient perturbation trick @xcite .",
    "_ actor _ follows the correct gradient by the policy gradient theorem @xcite .",
    "the internal workings of each neural network are guaranteed correct by the chain rule .",
    "two appealing features of the algorithm are that ( i ) actor is insulated from critic , and only interacts with deviator and ( ii ) critic and deviator learn different features adapted to representing the value function and its gradient respectively .",
    "previous work used the derivative of the value - function estimate , which is not guaranteed to have compatible function approximation , and can lead to problems when the value - function is estimated using functions such as rectifiers that are not smooth @xcite .",
    "finally we consider kickback , a biologically - motivated variant of backprop with reduced communication requirements @xcite .",
    "the problem that kickback solves is that backprop requires two distinct kinds of signals to be communicated between units ",
    "feedforward and feedback  whereas only one signal type  spikes  are produced by cortical neurons .",
    "kickback computes an estimate of the backpropagated gradient using the signals generated during the feedforward sweep .",
    "kickback also requires the gradient of the loss with respect to the ( one - dimensional ) output to be broadcast to all units , which is analogous to the role played by diffuse chemical neuromodulators @xcite .      at ( 0,0 ) ( glabel ) * query * ; at ( 0,-2 ) ( player_env1 ) * nature * ; at ( 4,0 ) ( player1 ) * layer@xmath258 * ; at ( 8,0 ) ( player2 ) * layer@xmath259 * ; at ( 12,0 ) ( player3 ) * layer@xmath260 * ; at ( 16,0 ) ( player_env2 ) * nature * ; at ( 2.5,-3 ) ( out1 ) @xmath55 ; at ( 6.5,-3 ) ( out2 ) @xmath55 ; at ( 10.5,-3 ) ( out3 ) @xmath55 ; at ( 4,-2 ) ( block1 ) @xmath261 ; at ( 8,-2 ) ( block2 ) @xmath262 ; at ( 12,-2 ) ( block3 ) @xmath263 ; at ( 16,-2 ) ( block4 ) @xmath53 ; ( player_env1 )  ( block1 ) ; ( player1 ) edge node[left ] @xmath264 ( block1 ) ; ( player2 ) edge node[left ] @xmath265 ( block2 ) ; ( player3 ) edge node[left ] @xmath266 ( block3 ) ; ( player_env2 ) edge node[left ] @xmath56 ( block4 ) ; ( block1 ) edge node[above ] @xmath267 ( block2 ) ; ( player_env1 ) edge node[above ] @xmath54 ( block1 ) ; ( block2 ) edge node[above ] @xmath268 ( block3 ) ; ( block3 ) edge node[above ] @xmath269 ( block4 ) ; ( block1 ) edge node[right ] @xmath270 ( out1 ) ; ( block2 ) edge node[right ] @xmath271 ( out2 ) ; ( block3 ) edge node[right ] @xmath272 ( out3 ) ; ( block1 ) edge node[left ] @xmath273 ( out1 ) ; ( block2 ) edge node[left ] @xmath274 ( out2 ) ; ( block3 ) edge node[left ] @xmath275 ( out3 ) ;    * _ nature _ samples labeled data @xmath37 from @xmath143 . *",
    "_ layers _ by weight matrices @xmath145 .",
    "the output of the neural network is required to be one - dimensional * _ operators _ for each layer compute two outputs : @xmath276 _ and _ @xmath277 where @xmath278 and 0 otherwise .",
    "* the task is regression or binary classification with loss given by the mean - squared or logistic error .",
    "it follows that the derivative of the loss with respect to the network s output @xmath279 is a _",
    "scalar_.    the response graph contains a single oracle that broadcasts the gradient of the loss with respect to the network s output ( which is a scalar ) .",
    "estimates _ for each _ layer _ are computed using a mixture of oracle and local zeroth - order information referred to as _ kicks _ : +    at ( 2,0 ) ( glabel ) * response * ; at ( 4,-2 ) ( oracle1 ) * kick@xmath280 * ; at ( 8,-2 ) ( oracle2 ) * kick@xmath281 * ; at ( 12,-2 ) ( oracle3 ) * kick@xmath282 * ; at ( 10,-4 ) ( oracle_env2 ) * oracle@xmath57 * ; at ( 6,-2 ) ( block1 ) @xmath186 ; at ( 10,-2 ) ( block2)@xmath186 ; at ( 14,-2 ) ( block3 ) @xmath186 ;        ( oracle_env2 ) edge node[left ] @xmath284 ( block2 ) ; ( oracle_env2 ) edge node[left ] @xmath285 ( block1 ) ; ( block1 ) edge node[right]@xmath286 ( player1 ) ; ( block2 ) edge node[right]@xmath287 ( player2 ) ; ( block3 ) edge node[right]@xmath288 ( player3 ) ; ( oracle1 )  ( block1 ) ; ( oracle2 )  ( block2 ) ; ( oracle3 )  ( block3 ) ;          ( s1 ) edge node[above]@xmath295 ( block1 ) ; ( s2 ) edge node[above]@xmath296 ( block2 ) ; ( s3 ) edge node[above]@xmath297 ( block2 ) ; ( s3 ) edge node[below]@xmath298 ( block2 ) ; ( block1 )  ( zero ) ; ( block2 )  ( block1 ) ;     + where @xmath299 is coordinatewise multiplication and @xmath300 is the outer product . if @xmath301 then _ nature _ is substituted for @xmath295 . if @xmath302 then @xmath303 is replaced with the scalar value @xmath192 .",
    "the loss functions for the layers are not computed in the query graph .",
    "nevertheless , the gradients communicated to the layers by the response graph are exact with respect to the layers losses , see @xcite . for our purposes",
    "it is more convenient to focus on the global objective of the neural network and treat the gradients communicated to the layers as _ estimates _ of the gradient of the global objective with respect to the layers weights .",
    "the guarantee for kickback is that , if the network is coherent , then the gradient estimate @xmath306 computed using the zeroth - order kicks has the same sign as the backpropagated error @xmath307 computed using gradients , see @xcite for details . as a result ,",
    "smalls steps in the direction of the gradient estimates are guaranteed to decrease the network s loss .",
    "@xmath11 +   kickback uses a single oracle , analogous to a neuromodulatory signal , in contrast to backprop which requires an oracle per layer .",
    "the rest of the oracles are replaced by kicks  zeroth - order information from which gradient - estimates are constructed .",
    "importantly , the kick computation for layer @xmath117 only requires locally available information produced by its neighboring layers @xmath308 and @xmath309 during the feedforward sweep .",
    "the feedback signals @xmath297 are analogous to the signals transmitted by nmda synapses .",
    "two recent alternatives to backprop that also do not rely on backpropagating exact gradients are target propagation @xcite and feedback alignment @xcite .",
    "target propagation makes do without gradients by implementing autoencoders at each layer .",
    "unfortunately , optimization problems force the authors to introduce a correction term involving _ differences _ of targets . as a consequence , and in contrast to kickback , the information required by layers in difference target propagation can not be computed locally but instead requires recursively backpropagating differences from the output layer .",
    "feedback alignment solves a different problem : that feedback and forward weights are required to be equal in backprop ( and also in kickback ) .",
    "the authors observe that using random feedback weights can suffice . unfortunately ,",
    "as for difference target propagation , feedback alignment still requires separate feedforward and recursively backpropagated training signals , so weight updates are not local .",
    "unfortunately , at a conceptual level kickback , target propagation and feedback alignment all tackle the wrong problem .",
    "the cortex performs reinforcement learning : mammals are not provided with labels , and there is no clearly defined output layer from which signals could backpropagate .",
    "a biologically - plausible deep learning algorithm should take advantage of the particularities of the reinforcement learning setting .",
    "hinton g , deng l , yu d , dahl ge , mohamed a , jaitly n , senior a , vanhoucke v , nguyen p , sainath tn , kingsbury b : * deep neural networks for acoustic modeling in speech recognition*. _ ieee signal processing magazine _ 2012 , * 29*:8297 .",
    "mnih v , kavukcuoglu k , silver d , rusu aa , veness j , bellemare mg , graves a , riedmiller m , fidjeland ak , ostrovski g , petersen s , beattie c , sadik a , antonoglou i , king h , kumaran d , wierstra d , legg s , hassabis d : * human - level control through deep reinforcement learning*. _ nature _ 2015 , * 518*(7540):529533 .",
    "bergstra j , breuleux o , bastien f , lamblin p , pascanu r , desjardins g , turian j , warde - farley d , bengio y : * theano : a cpu and gpu math expression compiler*. in _ proc .",
    "python for scientific comp .",
    "( scipy ) _ 2010 .",
    "bastien f , lamblin p , pascanu r , bergstra j , goodfellow i , bergeron a , bouchard n , bengio y : * theano : new features and speed improvements*. in _ nips workshop : deep learning and unsupervised feature learning _ 2012 .",
    "williams rj , zipser d : * gradient - based learning algorithms for recurrent networks and their computational complexity*. in _ backpropagation : theory , architectures , and applications_. edited by chauvin y , rumelhart d , lawrence erlbaum associates 1995 .",
    "von bartheld cs , wang x , butowt r : * anterograde axonal transport , transcytosis , and recycling of neurotrophic factors : the concept of trophic currencies in neural networks*. _ molecular neurobiology _ 2001 , * 24*.                  sutton r , modayil j , delp m , degris t , pilarski pm , white a , precup d : * horde : a scalable real - time architecture for learning knowledge from unsupervised motor interaction*. in _ proc .",
    "10th int . conf . on aut agents and multiagent systems ( aamas ) _ 2011 .",
    "balduzzi d : * falsification and future performance*. in _ algorithmic probability and friends : bayesian prediction and artificial intelligence _ , _ volume 7070 of _",
    "lnai__. edited by dowe d , springer 2013:6578 .",
    "sutton r , szepesvri c , maei hr : * a convergent @xmath310 algorithm for off - policy temporal - difference learning with linear function approximation*. in _ adv in neural information processing systems ( nips ) _ 2009 ."
  ],
  "abstract_text": [
    "<S> deep learning is currently the subject of intensive study . </S>",
    "<S> however , fundamental concepts such as representations are not formally defined  </S>",
    "<S> researchers `` know them when they see them ''  and there is no common language for describing and analyzing algorithms . </S>",
    "<S> this essay proposes an abstract framework that identifies the essential features of current practice and may provide a foundation for future developments .    </S>",
    "<S> the backbone of almost all deep learning algorithms is backpropagation , which is simply a gradient computation distributed over a neural network . </S>",
    "<S> the main ingredients of the framework are thus , unsurprisingly : ( i ) game theory , to formalize distributed optimization ; and ( ii ) communication protocols , to track the flow of zeroth and first - order information . </S>",
    "<S> the framework allows natural definitions of semantics ( as the meaning encoded in functions ) , representations ( as functions whose semantics is chosen to optimized a criterion ) and grammars ( as communication protocols equipped with first - order convergence guarantees ) .    </S>",
    "<S> much of the essay is spent discussing examples taken from the literature . </S>",
    "<S> the ultimate aim is to develop a graphical language for describing the structure of deep learning algorithms that backgrounds the details of the optimization procedure and foregrounds how the components interact . </S>",
    "<S> inspiration is taken from probabilistic graphical models and factor graphs , which capture the essential structural features of multivariate distributions . </S>"
  ]
}