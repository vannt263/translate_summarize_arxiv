{
  "article_text": [
    "_ patience sorting _ @xcite and _ the longest increasing ( lis ) sequence _ are well - studied topics in combinatorics .",
    "the analysis of the expected length of the lis of a random permutation is a classical problem displaying interesting connections with the theory of interacting particle systems @xcite and that of combinatorial hopf algebras @xcite .",
    "recursive versions of patience sorting are involved ( under the name of _ schensted procedure _",
    "@xcite ) in the theory of young tableaux . a wonderful recent reference for the rich theory of the longest increasing sequences ( and substantially more ) is @xcite .",
    "recently mitzenmacher et al .",
    "@xcite introduced , under the name of _ heapable sequence _ , an interesting variation on the concept of increasing sequences .",
    "informally , a sequence of integers is heapable if it can be successively inserted into a ( not necessarily complete ) binary tree satisfying the heap property without having to resort to node rearrangements .",
    "mitzenmacher et al .",
    "showed that the longest heapable subsequence in a random permutation grows linearly ( rather than asymptotically equal to @xmath1 as does lis ) and raised as an open question the issue of extending the rich theory of lis to the case of heapable sequences .",
    "in this paper we partly answer this open question : we define a family @xmath2 of measures ( based on decomposing the sequence into subsequences heapable into a min - heap of arity at most @xmath3 ) and show that a variant of patience sorting correctly computes the values of these parameters .",
    "we show that this family of measures forms an infinite hierarchy , and investigate the expected value of parameter @xmath4 $ ] , where @xmath5 is a random permutation of order @xmath6 . unlike the case @xmath7 where @xmath8=e[lds[\\pi]]\\sim 2\\sqrt{n}$ ] , we argue that in the case @xmath9 the correct scaling is logarithmic , bringing experimental evidence that the precise scaling is @xmath10\\sim \\phi\\ln{n}$ ] , where @xmath11 is the golden ratio .",
    "the analysis exploits the connection with a new , multiset extension of the hammersley - aldous - diaconis process @xcite , an extension that may be of independent interest .",
    "finally , we introduce a heap - based generalization of young tableaux .",
    "we prove ( theorem  [ unif ] below ) a hook inequality related to the hook formula for young tableaux @xcite and knuth s hook formula for heap - ordered trees @xcite , and ( theorem  [ rs - heap ] ) an extension of the robinson - schensted ( r - s ) correspondence .",
    "for @xmath12 define alphabet @xmath13 . define as well @xmath14 . given words",
    "@xmath15 over @xmath16 we will denote by @xmath17 the fact that @xmath18 is a prefix of @xmath19 .",
    "the set of ( non - strict ) prefixes of @xmath18 will be denoted by @xmath20 .",
    "given words @xmath21 define the _ prefix partial order _",
    "@xmath22 as follows : if @xmath17 then @xmath22 . if @xmath23 , @xmath24 , @xmath25 and @xmath26 then @xmath22 .",
    "@xmath27 is the transitive closure of these two constraints .",
    "similarly , the _ lexicographic partial order _",
    "@xmath28 is defined as follows : if @xmath29 then @xmath30 . if @xmath23 , @xmath24 , @xmath25 and @xmath26 then @xmath30 .",
    "@xmath28 is the transitive closure of these two constraints .",
    "a _ @xmath3-ary tree _ is a finite , @xmath27-closed set @xmath31 of words over alphabet @xmath13 .",
    "that is , we impose the condition that positions on the same level in a tree are filled preferentially from left to right .",
    "the _ position @xmath32 of node @xmath18 in a @xmath3-ary tree _ is the string over alphabet @xmath33 encoding the path from the root to the node ( e.g. the root has position @xmath34 , its children have positions @xmath35 , and so on ) .",
    "@xmath3-ary ( min)-heap _ is a function @xmath36 monotone with respect to @xmath37 , i.e. @xmath38 \\rightarrow [ f(x)\\leq f(y)].$ ]    a _ ( binary min-)heap _ is a binary tree , not necessarily complete , such that @xmath39\\leq a[x]$ ] for every non - root node @xmath18 .",
    "if instead of binary we require the tree to be @xmath3-ary we get the concept of @xmath3-ary min - heap .",
    "a sequence @xmath40 is _",
    "@xmath3-heapable _ if there exists some @xmath3-ary tree @xmath31 whose nodes are labeled with ( exactly one of ) the elements of @xmath41 , such that for every non - root node @xmath42 and parent @xmath43 , @xmath44 and @xmath45 .",
    "in particular a 2-heapable sequence will simply be called _ heapable _",
    "given sequence of integer numbers @xmath41 , denote by @xmath2 _ the smallest number of heapable ( not necessarily contiguous ) subsequences _ one can decompose @xmath41 into .",
    "@xmath46 is equal @xcite to the _ shuffled up - sequences ( sus ) _ measure in the theory of presortedness .",
    "let @xmath47 $ ] . via patience sorting @xmath48 @xmath49 .",
    "@xmath50 , since subsequnces @xmath51 $ ] and @xmath52 $ ] are 2-heapable . on the other hand , for every @xmath53 , @xmath54)=k$ ] .    analyzing",
    "the behavior of lis relies on the correspondence between longest increasing sequences and an interactive particle system @xcite called the _ hammersley - aldous - diaconis ( shortly , hammersley or had ) process_. we give it the multiset generalization displayed in figure  [ ham : k ] .",
    "technically , to recover the usual definition of hammersley s process one should take @xmath55 ( rather than @xmath56 ) .",
    "this small difference arises since we want to capture @xmath57 , which generalizes @xmath58 , rather than @xmath59 ( captured by hammersley s process ) .",
    "this slight difference is , of course , inconsequential : our definition is simply the `` flipped around the midpoint of segment [ 0,1 ] '' version of such a generalization , and has similar behaviour ) .    *",
    "a number of individuals appear ( at integer times @xmath60 ) as random numbers @xmath42 , uniformly distributed in the interval @xmath61 $ ] . *",
    "each individual is initially endowed with @xmath3 `` lifelines '' . *",
    "the appearance of a new individual @xmath62 subtracts a life from the largest individual @xmath56 ( if any ) still alive at moment @xmath63 .",
    "first we show that one can combine patience sorting and the greedy approach in @xcite to obtain an algorithm for computing @xmath2 . to do so , we must adapt to our purposes some notation in that paper .",
    "a binary tree with @xmath6 nodes has @xmath65 positions ( that will be called _ slots _ ) where one can add a new number .",
    "we will identify a slot with the minimal value of a number that can be added to that location . for heap - ordered trees",
    "it is the value of the parent node .",
    "slots easily generalize to forests .",
    "the number of slots of a forest with @xmath66 trees and @xmath6 nodes is @xmath67 .",
    "given a binary heap forest @xmath31 , the _ signature of @xmath31 _ denoted @xmath68 , is the vector of the ( values of ) free slots in @xmath31 , in sorted ( non - decreasing ) order .",
    "given two binary heap forests @xmath69 , _",
    "@xmath70 dominates @xmath71 _ if @xmath72 and inequality @xmath73\\leq sig_{t_{2}}[i]$ ] holds for all @xmath74 .    for every fixed @xmath53",
    "there is a polynomial time algorithm that , given sequence @xmath75 as input , computes @xmath2 .",
    "we use the greedy approach of algorithm  [ fig : greedy ] . proving correctness of the algorithm",
    "employs the following    greedyw w=(w_1,w_2 , ",
    ", w_n ) + t=. + i + x_i + x_i : + x_i [ fig : greedy ]    let @xmath69 be two heap forests such that @xmath70 dominates @xmath71 . insert a new element @xmath18 in both @xmath70 and @xmath71 : greedily in @xmath70 ( i.e. at the largest slot with value less or equal to @xmath18 , or as the root of a new tree , if no such slot exists ) and arbitrarily in @xmath71 , obtaining forests @xmath76 , respectively",
    ". then @xmath77 dominates @xmath78 .",
    "[ dom ]    first note that , by domination , if no slot of @xmath70 can accomodate @xmath18 ( which , thus , starts a new tree ) then a similar property is true in @xmath71 ( and thus @xmath18 starts a new tree in @xmath71 as well ) .",
    "let @xmath79 and @xmath80 be the two signatures . , and similarly let @xmath81 and @xmath82 be the two resulting signatures .",
    "the process of inserting @xmath18 can be described as adding two copies of @xmath18 to the signature of @xmath83 and ( perhaps ) removing a label @xmath84 from the two signatures .",
    "the removed label is @xmath85 , the largest label @xmath84 , in the case of greedy insertion into @xmath70 .",
    "let @xmath86 be the largest value ( or possibly none ) in @xmath71 less or equal to @xmath87 some @xmath88 less or equal to @xmath86 is replaced by two copies of @xmath18 in @xmath89 the following are true :    * the length of @xmath90 is at most that of @xmath91 . * the element @xmath88 ( if any ) deleted by @xmath18 from @xmath71 satisfies @xmath92 .",
    "its index in @xmath93 is less or equal to @xmath94 . *",
    "the two @xmath18 s are inserted to the left of the deleted ( if any ) positions in both @xmath70 and @xmath71 .",
    "consider some position @xmath95 in @xmath90 .",
    "our goal is to show that @xmath96 .",
    "several cases are possible :    * @xmath97 . then @xmath98 and @xmath99 .",
    ". then @xmath98 and @xmath101 .",
    ". then @xmath103 and @xmath104 .",
    ". then @xmath106 and @xmath107 .",
    "@xmath108    let @xmath41 be a sequence of integers , opt be an optimal partition of @xmath41 into @xmath3-heapable sequences and @xmath109 be the solution produced by greedy .",
    "applying lemma  [ dom ] repeatedly we infer that whenever greedy adds a new heap the same thing happens in opt .",
    "thus the number of heaps created by greedy is optimal , which means that the algorithm computes @xmath2 .",
    "trivially @xmath110 . on the other hand    [ ineq ]",
    "the following statements ( proved in the appendix ) are true for every @xmath9 : ( a ) .",
    "there exists a sequence @xmath41 such that @xmath111 @xmath112 ; ( b ) .",
    "@xmath113 = \\infty$ ] .",
    "denote by @xmath114 the random variable denoting _ the number of times @xmath94 in the evolution of process @xmath115 up to time @xmath6 when the newly inserted particle @xmath42 has lower value than all the existing particles at time @xmath94 . _",
    "the observation from @xcite generalizes to :    for every fixed @xmath116 @xmath117=e[minhad_{k}(n)]$ ] .",
    "all @xmath42 s are different .",
    "we will thus ignore in the sequel the opposite alternative .",
    "informally minima correspond to new heaps and live particles to slots in these heaps ( cf . also lemma  [ dom ] ) .",
    "the asymptotic behavior of @xmath8 $ ] where @xmath5 is a random permutation in @xmath118 is a classical problem in probability theory : results in @xcite , @xcite , @xcite , @xcite show that it is asymptotically equal to @xmath1 .",
    "a simple lower bound valid for all values of @xmath53 is    for every fixed @xmath116 @xmath119\\geq h_{n}\\mbox { , the } n\\mbox{'th harmonic number .     } \\ ] ]    for @xmath120 the set of its _ minima _ is defined as @xmath121 : \\pi[j]<\\pi[i]\\mbox { for all } 1\\leq i < j\\}$ ] ( and similarly for maxima ) .",
    "it is easy to see that @xmath122\\geq |min[\\pi]|$ ] .",
    "indeed , every minimum of @xmath5 must determine the starting of a new heap , no matter what @xmath3 is .",
    "now we use the well - known formula @xmath123|]=e_{\\pi\\in s_{n}}[|max[\\pi]|]=h_{n}$ ] @xcite .",
    "on the other hand    we have @xmath124}{\\ln(n)}\\leq 2.\\ ] ] [ upper ]    a coupling argument .",
    "consider the following random process @xmath125 : random numbers @xmath126 are generated uniformly at random in the interval @xmath61 $ ] .",
    "each @xmath127 comes with two lives . at every moment",
    "@xmath63 , once @xmath127 is inserted , _ the smallest value among those still existing is removed _ ( unless , of course , @xmath127 is the smallest live element )    in the natural coupling of @xmath125 and @xmath128 ( obtained by identifying sequences @xmath129 and @xmath130 ) minimal values in had are less or equal to minimal value in min ( by systematically removing minima in process min , their values increase ) .",
    "thus a minimum in @xmath128 at moment @xmath63 is a minimum in @xmath131 at the same moment .",
    "this shows that @xmath132 $ ] , the expected number of minima in the process @xmath128 at moment @xmath63 , is at most @xmath133 $ ] .    to gain insight in the behavior of process @xmath128",
    "we note that , rather than giving the precise values of @xmath134 $ ] , an equivalent random model inserts @xmath135 uniformly at random in any of the @xmath136 possible positions determined by @xmath137 .",
    "this model translates into the following equivalent combinatorial description of @xmath115 : word @xmath138 over the alphabet @xmath139 describes the state of the process at time @xmath63 .",
    "each @xmath138 conventionally starts with a @xmath140 and continues with a sequence of @xmath141 , @xmath142 s and @xmath143 s , informally the `` number of lifelines '' of particles at time @xmath63 .",
    "for instance @xmath144 , @xmath145 , @xmath146 is either @xmath147 or @xmath148 , depending on @xmath149 , and so on . at each time @xmath63 a random letter of @xmath138 is chosen ( corresponding to a position for @xmath135 ) and we apply one of the following transformations , the appropriate one for the chosen position :    * _ replacing @xmath150 by @xmath151 : _ this is the case when @xmath135 is the smallest particle still alive , and to its right there are @xmath152 dead particles . * _ replacing @xmath153 by @xmath154 : _ suppose that @xmath155 is the largest live label less or equal to @xmath156 , that the corresponding particle @xmath155 has one lifetime at time @xmath63 , and that there are @xmath157 dead particles between @xmath155 and @xmath135 . adding @xmath135 ( with multiplicity two ) decreases multiplicity of @xmath155 to 0 . * _ replacing @xmath158 by @xmath159 : _ suppose that @xmath155 is the largest label less or equal to @xmath156 , its multiplicity is two , and there are @xmath152 dead particles between @xmath155 and @xmath135 .",
    "adding @xmath135 removes one lifeline from particle @xmath155 .    simulating",
    "the ( combinatorial version of the ) hammersley process with two lifelines confirms the fact that @xmath160 $ ] grows significantly slower than @xmath161 $ ] : the @xmath18-axis in the figure is logarithmic .",
    "the scaling is clearly different , and is consistent ( see inset ) with logarithmic growth ( displayed as a straight line on a plot with log - scaling on the @xmath18-axis ) .",
    "experimental results ( see the inset / caption of fig .  [ k:5 ] ) suggest the following bold    [ main ] we have @xmath162}{\\ln(n)}=\\phi$ ] , with @xmath11 the golden ratio .",
    "more generally , for an arbitrary @xmath9 the relevant scaling is @xmath163}{\\ln(n)}=   \\frac{1}{\\phi_{k } } , \\label{general : k}\\ ] ] where @xmath164 is the unique root in @xmath165 of equation @xmath166 .",
    "$ ] for @xmath167 .",
    "the inset shows @xmath10 $ ] ( red ) versus @xmath168 ( blue ) .",
    "the fit is strikingly accurate.,width=377,height=226 ]    we plan to present the experimental evidence for the truth of equation  ( [ general : k ] ) and a nonrigorous , `` physics - like '' justification , together with further insights on the so - called _ hydrodynamic behavior _",
    "@xcite of the @xmath115 process in subsequent work @xcite .",
    "for now we limit ourselves to showing that one can ( rigorously ) perform a first step in the analysis of the @xmath128 process : we prove convergence of ( some of ) its structural characteristics .",
    "this will likely be useful in a full rigorous proof of conjecture  [ main ] .",
    "our proof proceeds by analyzing the multiset hammersley process :    denote by @xmath169 the number of digits 1 + 2 , and by @xmath170 the number of ones in @xmath138 .",
    "let @xmath171 $ ] , @xmath172 $ ] .",
    "@xmath173 always belong to @xmath61 $ ] .",
    "there exist constants @xmath174 $ ] such that @xmath175 , @xmath176 .",
    "[ limit ]    we use a standard tool , _ subadditivity _ : if sequence @xmath177 satisfies @xmath178 for all @xmath179 then ( by fekete s lemma ( @xcite pp . 3 , @xcite ) @xmath180 exists .",
    "we show in the appendix that this is the case for two independent linear combinations of @xmath181 and @xmath182    experimentally ( and nonrigorously ) @xmath183 and @xmath184 .",
    "`` physics - like '' nonrigorous arguments then imply the desired scaling .",
    "an additional ingredient is that digits 0/1/2 are uniformly distributed ( conditional on their density ) in a large @xmath138 .",
    "this is intuitively true since for large @xmath63 the behavior of the @xmath115 process is described by a compound poisson process .",
    "we defer more complete explanations to @xcite .",
    "finally , we present an extension of young diagrams to heap - based ta- + bleaux .",
    "all proofs are given in the appendix .",
    "a _ ( @xmath3-)heap tableau @xmath31 _ is @xmath3-ary min - heap of integer vectors , so that for every @xmath185 , the vector @xmath186 at address @xmath157 is nondecreasing .",
    "we formally represent the tableau as a function @xmath187 such that ( a ) .",
    "@xmath31 has _ finite support : _ the set @xmath188 of nonempty positions is finite .",
    "@xmath31 is _ @xmath189-nondecreasing _ : if @xmath190 and @xmath191 then @xmath192 and @xmath193 .",
    "in other words , @xmath194 is a min - heap .",
    "@xmath31 is _ columnwise increasing _ : if @xmath190 and @xmath195 then @xmath196 and @xmath197 .",
    "that is , each column @xmath198 is increasing .",
    "the _ shape of @xmath31 _ is the heap @xmath199 where node with address @xmath157 holds value @xmath200 .",
    "a tableau is _ standard _ if ( e ) . for all @xmath201 , @xmath202 and ( f ) . if @xmath203 and @xmath204 then @xmath205 .",
    "i.e. , labels in the first heap @xmath206 are increasing from left to right and top to bottom .",
    "a heap tableau @xmath70 with 9 elements is presented in fig .",
    "[ forest - young ] ( a ) and as a young - like diagram in fig .",
    "[ forest - young ] ( b ) .",
    "note that : ( i ) .",
    "columns correspond to _ rows _ of @xmath70 ( ii ) .",
    "their labels are in @xmath207 , rather than * n*. ( iii ) .",
    "cells may contain @xmath208 .",
    "rows need not be increasing , only _",
    "min - heap ordered_.    one important drawback of our notion of heap tableaux above is that they do not reflect the evolution of the process @xmath115 the way ordinary young tableaux do ( on their first line ) for process @xmath209 via the schensted procedure @xcite : a generalization with this feature would seem to require that each cell contains not an integer but a _ multiset _ of integers .",
    "obtaining such a notion of tableau is part of ongoing research .",
    "however , we can motivate our definition of heap tableau by the first application below , a hook inequality for such tableaux .",
    "to explain it , note that heap tableaux generalize both heap - ordered trees and young tableaux .",
    "in both cases there exist hook formulas that count the number of ways to fill in a structure with @xmath6 cells by numbers from @xmath142 to @xmath6 : @xcite for young tableaux and @xcite ( sec.5.1.4 , ex.20 ) for heap - ordered trees .",
    "it is natural to wonder whether there exists a hook formula for heap tableaux that provides a common generalization of both these results .",
    "theorem  [ unif ] gives a partial answer : not a formula but a _ lower bound .",
    "_ to state it , given @xmath210 , define the _ hook length @xmath211 _ to be the cardinal of set @xmath212 \\or [ ( j\\geq i ) \\and ( \\alpha = \\beta)]\\}$ ] .",
    "for example , fig .",
    "[ forest - young](c ) .",
    "displays the hook lengths of cells in @xmath70 .    given @xmath9 and a @xmath3-shape @xmath213 with @xmath6 free cells , the number of ways to create a heap tableau @xmath31 with shape @xmath213 by filling its cells with numbers @xmath214 is _ at least _",
    "@xmath215 the bound is tight for young tableaux @xcite , heap - ordered trees @xcite , and infinitely many other examples , but is also * not * tight for infinitely many ( counter)examples . [ unif ]",
    "we leave open the issue whether one can tighten up the lower bound above to a formula by modifying the definition of the hook length @xmath211 .",
    "\\(a ) at ( 3.5,0 ) ( 2;4;8:<[3 ] > ) ; ( b ) at ( 2,-1 ) ( 11;<12>;<13>:<[3 ] > ) ; ( c ) at ( 5,-1 ) ( < 6>;<14>:<[2 ] > ) ; ( d ) at ( 4,-2 ) ( < 10>:<[1 ] > ) ; ( a.south )  ( b.north ) ; ( a.south )  ( c.north ) ; ( c.south )  ( d.north ) ;    @xmath216    we can create @xmath3-heap tableaux from integer sequences by a version of the schensted procedure @xcite . algorithm schensted - heap@xmath217 below performs _ column insertions _ and gives to any bumped element @xmath3 choices for insertion / bumping , the children of vector @xmath218 with addresses @xmath219 .",
    "the result of applying the schensted - heap@xmath217 procedure to an arbitrary permutation @xmath41 is indeed a @xmath3-ary heap tableau .",
    "[ sch - heap ]    suppose we start with @xmath70 from fig .",
    "[ forest - young](a ) . then ( fig .",
    "[ insert ] ) 9 is appended to vector @xmath220 .",
    "7 arrives , bumping 8 , which in turn bumps 11 .",
    "finally 11 starts a new vector at position 00 .",
    "modified cells are grayed .",
    "procedure schensted - heap@xmath217 does * not * help in computing the longest heapable subsequence : the complexity of computing this parameter is open @xcite , and we make no progress on this issue .",
    "on the other hand , we can give a @xmath9 version of the r - s correspondence :    \\(a ) at ( 2,1 ) ( 2;4;8!!<9 > ) ; ( b ) at ( 0,0 ) ( 11;<12>;<13 > ) ; ( c ) at ( 4,0 ) ( < 6>;<14 > ) ; ( d ) at ( 3,-1 ) ( < 10 > ) ; ( a.south ) ",
    "( b.north ) ; ( a.south )  ( c.north ) ; ( c.south )  ( d.north ) ;    \\(a ) at ( 4,1 ) ( 2;4!!<7>!!<9 > ) ; ( b ) at ( 2,0 ) ( ! !",
    "< 8>!!;<12>;<13 > ) ; ( c ) at ( 6,0 ) ( < 6>;<14 > ) ; ( d ) at ( 5,-1 ) ( < 10 > ) ; ( e ) at ( 1,-1 ) ( ! ! ;",
    "< 11 > ) ; ( a.south )  ( b.north ) ; ( a.south )  ( c.north ) ; ( c.south )  ( d.north ) ; ( b.south )  ( e.north ) ;    for every @xmath9 there exists a bijection between permutations @xmath120 and pairs @xmath221 of @xmath3-heap tableaux with @xmath6 elements and identical shape , where @xmath222 is a standard tableau .",
    "[ rs - heap ]    condition `` @xmath222 is standard '' is specific to case @xmath9 : heaps simply have `` too many degrees of freedom '' between siblings .",
    "schensted - heap@xmath217 solves this problem by starting new vectors from left to right and top to bottom .",
    "schensted - heap@xmath223x = x_0 ,  , x_n-1 i(n ) : bump(x_i , ) +   + ( x , s ) :  # s _ is a set of adresses_. + x v_r , r s + r v_r + v_r , r s ) : + b_x > x , + b_x + y = min\\{b_x}r + yxv_r + bump(y , r_k )  # _ bump @xmath19 into some child of @xmath157 _ [ sg ]",
    "our paper raises a large number of open issues . we briefly list a few : rigorously justify conjecture  [ main ] .",
    "study process @xmath115 and its variants @xcite .",
    "reconnect the theory to the analysis of _ secretary problems _",
    "find the distribution of @xmath122 $ ] . obtain a hook formula .",
    "define a version of young tableaux related to process @xmath115 .",
    "we plan to address some of these in subsequent work .",
    "the most important open problem , however , is _ the complexity of computing lhs . _",
    "this research has been supported by cncs idei grant pn - ii - id - pce-2011 - 3 - 0981 `` structure and computational difficulty in combinatorial optimization : an interdisciplinary approach '' .",
    "d.  aldous and p.  diaconis .",
    "hammersley s interacting particle process and longest increasing subsequences .",
    ", 103(2):199213 , 1995 .",
    "d.  aldous and p.  diaconis .",
    "longest increasing subsequences : from patience sorting to the baik - deift - johansson theorem .",
    ", 36(4):413432 , 1999 .",
    "m.  archibald and c.  martnez .",
    "the hiring problem and permutations .",
    ", ( 01):6376 , 2009 .",
    "j.  byers , b.  heeringa , m.  mitzenmacher , and g.  zervas .",
    "heapable sequences and subseqeuences . in _ proceedings of analco _ , pages 3344 , 2011 .",
    "a.  broder , a.  kirsch , r.  kumar , m.  mitzenmacher , e.  upfal , and s.  vassilvitskii .",
    "the hiring problem and lake wobegon strategies .",
    ", 39(4):12331255 , 2009 .",
    "e.  cator and p.  groeneboom .",
    "annals of probability ( 2005 ) : 879 - 903 .",
    "j.s .  frame and g.",
    "robinson , and r.m .  thrall .",
    "j. math 6.316 ( 1954 ) : c324 .",
    "c.  greene and a.  nijenhuis and h.s.wilf .",
    "advances in mathematics 31.1 ( 1979 ) : 104 - 109 .",
    "maxime crochemore and ely porat . fast computation of a longest increasing subsequence and application .",
    ", 208(9):10541059 , 2010 .",
    "michael  l fredman . on computing the length of longest increasing subsequences .",
    ", 11(1):2935 , 1975 .",
    "j.  m. hammersley .",
    "a few seedlings of research . in _ proceedings of the sixth berkeley symposium on mathematical statistics and probability , volume 1 :",
    "theory of statistics _ , 1972 .",
    "f.  hivert .",
    "an introduction to combinatorial hopf algebras , ios press , 2007 .",
    "p.  groenenboom .",
    "hydrodynamical models for analyzing longest increasing sequences . , 142 ( 2002 ) , 83105 .",
    "g.  istrate and c.  bonchi .",
    "( manuscript in preparation , 2015 )    d.  knuth .",
    "the art of computer programming .",
    "volume 3 : sorting and searching .",
    "addison wesley , 1998 .",
    "c.  levcopoulos and o.  petersson .",
    "sorting shuffled monotone sequences .",
    ", 112(1):3750 , 1994 .",
    "logan and l.a .",
    "shepp . a variational problem for random young tableaux .",
    ", 26(2):206222 , 1977 .",
    "patience sorting . , 5(4 ) , 375376 , 1963 .",
    "l.  cuellr montoya .",
    "stochastic processes and their applications 67.1 ( 1997 ) : 69 - 99 .",
    "d.  romik . .",
    "cambridge university press , 2014 .    c.  schensted .",
    "j. math 13.2 ( 1961 ) : 179 - 191 .",
    "w. szpankowski .",
    "wiley , 2001 .",
    "j.m .  steele . .",
    ", 1997 .",
    "a.  vershik and s.  kerov .",
    "asymptotics of plancherel measure of symmetric group and limit form of young tables . , 233(6):10241027,1977 .",
    "* for @xmath224 consider the sequence @xmath225 $ ] . + we have @xmath226",
    "+ applying the greedy algorithm we obtain the following heap decompositions : * * @xmath227 @xmath228 $ ] , @xmath229 $ ] , @xmath230 $ ] ,  , @xmath231 $ ] .",
    "* * @xmath232 @xmath233 $ ] , @xmath234 $ ] , @xmath235 $ ] ,  , @xmath236 $ ] .",
    "+ @xmath237 * * @xmath238 @xmath239 $ ] , @xmath240 $ ] , @xmath241 $ ] ,  , @xmath242 $ ] .",
    "+ @xmath237 * * @xmath243 @xmath244.$ ] * let @xmath245 .",
    "define sequence @xmath246\\\\\\end{aligned}\\ ] ] in other words @xmath247,$ ] where for each @xmath248 the subsequence @xmath135 is @xmath249 $ ] .",
    "@xmath135 has @xmath250 many elements .",
    "+ we can see that this sequence is @xmath3-heapable , thus @xmath251 : @xmath252 and every number in @xmath135 is larger than every number in @xmath253 .",
    "thus we can arrange the @xmath135 s on ( incomplete ) heap levels , with every node in @xmath135 a child of some node in @xmath253 .",
    "+ we have @xmath254 + we apply the greedy algorithm . after sequence @xmath255",
    "two @xmath256-heaps are created .",
    "@xmath206 has two full levels , @xmath257 contains only the root 2 .",
    "sequence @xmath258 has length @xmath259 .",
    "@xmath260 elements go on the third level of @xmath206 .",
    "@xmath261 elements go on the second level of @xmath258 .",
    "the remaining @xmath262 element starts a new heap @xmath263 .",
    "+ by induction we easily prove the following + for every @xmath264 , the @xmath265 elements of @xmath135 go via greedy as follows : * * @xmath266 of them go on level @xmath63 of @xmath206 , * * @xmath267 of them go on level @xmath268 of @xmath257 , * * @xmath269 * * @xmath261 of them go on the first level of @xmath270 .",
    "+ the remaining @xmath271 element starts a new heap @xmath272 .      * first sequence : *",
    "define @xmath177 to be the expected cardinality of the multiset of * slots * ( particles lifelines in process @xmath128 ) ) at moment @xmath6 .",
    "clearly @xmath273 .",
    "also , given @xmath274 a finite trajectory in [ 0,1 ] * and an initial set of slots @xmath31 * , denote by @xmath275 the multiset of * particles ( slots ) added during @xmath276 * that are still alive at the end of the trajectory @xmath276 , if * at time @xmath277 the process started with the slots in @xmath31 * ( omitting the second argument if @xmath278 ) , and @xmath279 .",
    "finally denote by @xmath280 the submultiset of @xmath275 consisting of elements with multiplicity two , and by @xmath281 .",
    "subadditivity of @xmath177 will follow from the fact that the property holds _ on each trajectory _ : if @xmath75 and @xmath282 then in fact we can show that @xmath283 clearly @xmath284 $ ] so  ( [ ineq ] ) implies that @xmath177 is subadditive .",
    "it turns out that , together with  ( [ ineq3 ] ) , we will need to simultaneously prove that @xmath285 we prove  ( [ ineq3 ] ) and  ( [ ineq2 ] ) by induction on @xmath286 . clearly the inclusion is true if @xmath287 .",
    "let @xmath288 and @xmath289 , with @xmath290 , @xmath291 .",
    "@xmath292 modifies @xmath293 by adding two copies of @xmath294 to @xmath295 and , perhaps , erasing some @xmath296 , the largest element ( if any ) in @xmath293 smaller or equal to @xmath294 .",
    "thus @xmath297 .",
    "similarly , @xmath298 modifies @xmath299 by adding two copies of @xmath294 and , perhaps , erasing some @xmath300 , the largest element ( if any ) * in @xmath299 * smaller or equal to @xmath294 .",
    "thus @xmath301 .    all that remains in order to prove that @xmath302 ( and thus establish inequality  ( [ ineq ] ) inductively for @xmath303 as well ) is that @xmath304 this follows easily from inductive hypothesis  ( [ ineq2 ] ) for @xmath305 : if @xmath306 then some element in @xmath299 is less or equal to @xmath294 .",
    "the same must be true for @xmath307 and hence for @xmath293 as well ( noting , though , that @xmath296 may well be an element of @xmath41 ) .",
    "now we have to show that  ( [ ineq2 ] ) also remains true : clearly the newly added element , @xmath294 , has multiplicity two in both @xmath298 and @xmath308 .",
    "suppose we erase some element @xmath300 from @xmath299 .",
    "then @xmath300 belongs to @xmath307 , has multiplicity at least one there , and is _ the largest element smaller or equal to @xmath294 in @xmath309_. thus , when going from @xmath307 to @xmath308 we either erase one copy of @xmath296 or do not erase nothing ( perhaps we erased some element in @xmath310 , which is not , however , in @xmath307 ) suppose , on the other hand that no element in @xmath299 is smaller or equal to @xmath294 .",
    "there may be such an erased element @xmath296 in @xmath307 , but _ it certainly did not belong to @xmath299_. in both cases we infer that relation @xmath311 is true .",
    "* second sequence : * note that @xmath312 is the expected length of the multiset of live particles .",
    "this multiset starts by being empty and grows by two every time the new particle is a minimum and by one every other time .",
    "we infer that @xmath313 .",
    "we infer that @xmath314 , where @xmath315 is the limit of @xmath316 and the limit is zero , but we wo nt be using this value in the sequel ] .    on the other hand",
    "the total number of distinct particles ( including the dead ones , without multiplicity ) is @xmath63 , as it starts with zero and it increases by one at each moment .",
    "consider a trajectory @xmath41 of length @xmath63 and let @xmath317 the number of events of type @xmath318 , @xmath319 and finally of type @xmath320 * not followed by a corresponding @xmath319 * @xmath321=d(t)\\ ] ] @xmath322=c(t)\\ ] ] ( as such particles end up with degree one ) . finally @xmath323 ( as every particle that dies must have been subject to two steps , one which reduces its lifelines to 1 , and the final one .",
    "dividing by @xmath63 and taking limits we infer that @xmath324    the proof is very similar to the first one : define , in a setting similar to that of the first sequence , @xmath325 to be the cardinality of the submultiset of @xmath326 of elements with multiplicity two . define @xmath177 to be the expected number of elements with multiplicity two at stage @xmath6 .",
    "that is , @xmath327=l(n)-c(n)$ ] .",
    "we will prove by induction on @xmath303 that if @xmath75 and @xmath282 then @xmath328    the result is clear for @xmath287 .",
    "in the general case , @xmath329 , @xmath330 modifies @xmath331 by adding @xmath294 and , perhaps , erasing some @xmath296 , the largest element ( if any ) in @xmath293 smaller or equal to @xmath294 if this element is in @xmath331 .",
    "thus @xmath332 .",
    "similarly , @xmath333 modifies @xmath334 by adding @xmath294 and , perhaps , erasing some @xmath300 , the largest element ( if any ) * in @xmath299 * , if this element is smaller or equal to @xmath294 .",
    "thus @xmath335 .    if @xmath336 then clearly @xmath337 .",
    "the only problematic case may be when @xmath338 , @xmath339 , @xmath340 .",
    "but this means that @xmath300 exists ( and is erased from @xmath341 ) . since @xmath342 , @xmath300 must be erased from @xmath307 .",
    "in other words , the bad case above can not occur .",
    "we use essentially the classical proof based on the _ hook walk _ from @xcite , slightly adapted to our framework : define for a heap table @xmath31 with @xmath6 elements @xmath343 and @xmath344 , the set of _ corners of @xmath31 _ , to be the set of cells @xmath345 of @xmath31 with @xmath346 .",
    "given @xmath347 define @xmath348 .",
    "we want to prove that @xmath349 ( of course , for @xmath7 we can actually prove equality in formula  [ fin ] above ) .",
    "this will ensure ( by induction upon table size ) the truth of our lower bound .",
    "* choose ( uniformly at random ) a cell @xmath355 of @xmath31 .",
    "* let @xmath356 .",
    "* while ( ( @xmath357 is not a corner of @xmath31 ) : * choose @xmath358 uniformly at random from @xmath359 .",
    "* let @xmath360 . * return corner @xmath361 .",
    "* choose @xmath355 uniformly at random from @xmath31 ( i.e. with probability 1/n ) .",
    "* terms @xmath362 in the first product whose contribution is @xmath363 correspond to cells where the walk makes `` hook moves '' towards @xmath315 . * terms @xmath362 in the second product whose contribution is @xmath363 correspond to cells where the walk makes `` vector moves '' towards @xmath315 .      just as in @xcite ,",
    "given set of words @xmath367 , with @xmath368 and @xmath369 and set of integers @xmath370 with @xmath371 and @xmath372 , the probability @xmath373 that the hook walk has the hook(vector ) projections @xmath374 ( thus starting at @xmath375 ) is @xmath376 indeed , as in @xcite @xmath377\\leq \\nonumber\\\\                   & \\leq \\frac{1}{h_{\\alpha_{1},i_{1}}-1 } [ ( h_{\\alpha_{1},i_{r}}-1)+ ( h_{\\alpha_{m},i_{1}}-1)]\\cdot ( rhs ) \\label{eq - p}\\end{aligned}\\ ] ] where @xmath378 is the right - hand side product in equation  ( [ eq - pi ] ) , and in the second row we used the inductive hypothesis .      to justify inequality  ( [ just - ineq ] ) , note that , by property ( b ) of heap tableaux , since @xmath381 , @xmath382 on the other hand @xmath383 this is true by monotonicity property ( c ) of heap tableaux : every path present in the heap @xmath384 rooted at @xmath385 is also present in the heap @xmath206 rooted at @xmath355 .",
    "heap @xmath384 is empty below node @xmath386 , but @xmath206 contains the subheap rooted at @xmath385 ( of size @xmath387 _ any maybe some other subheaps , _ rooted at nodes @xmath388 whose correspondent in @xmath384 has no descendents .",
    "summing up equations  ( [ eq - vec ] ) and  ( [ eq - heap ] ) we get our desired inequality  ( [ just - ineq ] ) .",
    "example in figure  [ youngcontraexemplu ] shows that inequality  ( [ just - ineq ] ) can be strict : the hook length of @xmath389 but @xmath390 and @xmath391 .",
    "the reason is that the grayed cells are not counted in the hook of @xmath392 , but they belong to the hook of @xmath393 .      finally , adding up suitable inequalities  ( [ eq - pi ] ) we infer that @xmath395 , the probability that the walk ends up at @xmath315 , equal to @xmath396 ( the sum being over all suitable sets @xmath397 ) is less or equal than the expansion  ( [ hw ] ) of @xmath398 .",
    "since the sum of probabilities adds up to 1 , inequality  ( [ fin ] ) follows .",
    "\\(a ) at ( 4,1.5 ) ( ; 8;2 ) ; ( b ) at ( 3,0.5 ) ( ; 2;1 ) ; ( c ) at ( 5,0.5 ) ( ; 5 ) ; ( d ) at ( 5.5,-0.5 ) ( ; 4 ) ; ( e ) at ( 6,-1.5 ) ( ; 3 ) ; ( f ) at ( 6.5,-2.5 ) ( ; 2 ) ; ( g ) at ( 7,-3.5 ) ( ; 1 ) ; ( a.west )  ( b.north ) ; ( a.east )  ( c.west ) ; ( c.south )  ( d.west ) ; ( d.south ) ",
    "( e.west ) ; ( e.south )  ( f.west ) ; ( f.south )  ( g.west ) ;      first we present a set of arbitrarily large heap tableaux , different from both heap - ordered trees and young tableaux , for which the hook inequality is tight : for @xmath399 consider heap table @xmath400 ( fig .  [ hookex](a ) ) to have @xmath401 nodes , distributed in a complete @xmath3-ary tree @xmath206 with @xmath157 levels @xmath402 and @xmath403 nodes , and then @xmath261 one - element heaps @xmath404 .",
    "we employ notation @xmath405 the number of ways to fill up such a heap tableau is @xmath406 , where @xmath407 is the number of ways to fill up a complete @xmath3-ary tree with @xmath157 levels .",
    "@xmath408 this happens because for every subset @xmath409 of @xmath410 of cardinality @xmath261 , element 1 together with those not in @xmath409 can be distributed in @xmath206 in @xmath407 ways .",
    "now for the counterexamples : consider heap tableaux @xmath415 ( fig .",
    "[ hookex](b ) , identical to the heap tableau in fig .",
    "[ youngcontraexemplu ] ) defined as follows : @xmath415 consists of two heaps , @xmath206 with cells with addresses @xmath416 , @xmath417 @xmath418 , and @xmath257 with cells with addresses @xmath419 .",
    "@xmath415 has @xmath420 nodes .",
    "hook values of cells in @xmath206 are @xmath421 .",
    "hook values of cells in @xmath257 are @xmath422 , respectively .",
    "thus the hook formula predicts @xmath423 ways to fill up the table .",
    "if @xmath157 is even then the number above is * not * an integer , so the hook formula can not be exact for these tableaux .",
    "we prove that inserting a single integer element @xmath18 into a heap tableau @xmath31 results in another heap tableau @xmath424 . therefore inserting a permutation @xmath41 will result in a heap tableau .    by construction ,",
    "when an element is appended to a vector , the vector remains increasing . also , if an element @xmath19 bumps another element @xmath425 from a vector @xmath426 ( presumed nondecreasing ) then @xmath425 is the smallest such element in @xmath426 greater than @xmath19 .",
    "thus , replacing @xmath425 by @xmath19 preserves the nondecreasing nature of the vector @xmath426 .",
    "the case when @xmath18 is appended to @xmath427 is clear : since invariant ( b ) was true before inserting @xmath18 for every address @xmath157 we have @xmath428 see the example above when we append @xmath429 thus what we are doing , in effect , by appending @xmath18 to @xmath427 is start a new heap .",
    "suppose instead that inserting @xmath18 bumps element @xmath430 from @xmath427 .",
    "necessarily @xmath431 .",
    "suppose @xmath94 is the position of @xmath430 in @xmath427 , that is @xmath430 was the root of heap @xmath432 . by reducing the value of the root ,",
    "the heap @xmath432 still verifies the min - heap invariant .",
    "now suppose @xmath430 bumps element @xmath433 .",
    "we claim that @xmath433 has rank at most @xmath94 in its vector .",
    "indeed , the element with rank @xmath94 in the vector of @xmath433 was larger than @xmath430 ( by the min - heap property of @xmath432 ) .",
    "so @xmath433 must have had rank at most @xmath94 .",
    "let @xmath434 be this rank .",
    "\\(a ) at ( 4,2 ) ( : : : : : < x>::::,;;;;<>!!<x_1>!!;<>;,:::::<i > : : : : ) ; ( b ) at ( 2,0 ) ( : : : < x_1>:::,;;<>!!<x_2>!!;<>;;,:::<j>::<i > : : ) ; ( c ) at ( 6,0.4 ) ( :) ; ( d ) at ( 1,-1.3 ) ( :) ; ( e ) at ( 3,-1.5 ) ( : : , : : ) ; ( f ) at ( 2,-3 ) ( : : : < x_n>:::,;;<>!!<x_n>,:::<s > ) ; ( g ) at ( 4,-2.5 ) ( :) ;      since @xmath435 , by replacing @xmath433 by @xmath430 the min - heap property is satisfied `` below @xmath436 '' . it is satisfied `` above @xmath433 '' as well , since the parent of @xmath433 either was ( and still is ) the root of @xmath437 , a number less or equal to @xmath430 ( in case @xmath45 ) or is @xmath18 ( in case the rank of @xmath433 is exactly @xmath94 ) .",
    "indeed , @xmath439 is larger than the first @xmath445 elements of @xmath446 . by the min - heap property",
    ", it is also larger than the initial @xmath445 elements of @xmath447 as well .",
    "so its index in @xmath440 before getting bumped could not have been less than @xmath443 .",
    "that means that appending @xmath448 does not violate the min - heap invariant ( b ) .",
    "heap property ( b ) .",
    "is easy to verify : if element @xmath18 is inserted into a free slot of heap @xmath452 the slot value is at most @xmath18 .",
    "hence , by inserting @xmath18 the heap property continues to hold .",
    "alternatively , if @xmath18 bumps some element @xmath19 , the bumped element was larger than @xmath18 ( and so were its children ) , but sat in a slot of value @xmath84 . therefore replacing it by @xmath18 preserves heap property .",
    "the argument extends to ( elements inserted in or bumped from ) heaps @xmath384 , @xmath453 .",
    "suppose @xmath18 bumps element @xmath19 in heap @xmath206",
    ". then @xmath454 .",
    "@xmath18 is now at the head of its vector list , and since the list was increasing before ( with @xmath19 as its first element ) , it is increasing now .",
    "suppose now , recursively , that some element @xmath455 bumps element @xmath456 with address @xmath457 in heap @xmath458 , @xmath459 .",
    "we have to show that @xmath456 s insertion ( or bumping of another element ) preserves the increasing nature of the list .      in the first case",
    "the place where @xmath456 gets inserted was free in the vector list .",
    "the element @xmath425 to the left of this place was a forefather of @xmath456 before this latter element being bumped by @xmath455 . by the heap property @xmath463",
    ", so insertion creates an increasing list .",
    "suppose instead @xmath456 bumps another element @xmath462 . by the algorithm schensted - heap and the induction assumption , when it does so @xmath456 will sit immediately to the right of an element @xmath464 that used to be an ancestor of @xmath456 in @xmath384 .",
    "therefore the row of @xmath465 is increasing up to the inserted element @xmath456 . on the other hand @xmath466 , so the row of @xmath456 is now monotonically increasing after @xmath456 as well .",
    "let @xmath472 and consider the permutation @xmath473 the two corresponding heap tableaux are constructed below . for drawing convenience , during the insertion process",
    "they are not displayed in the heap - like form , but rather in the more compact young - table equivalent format .",
    "the resulting heap - tableaux are displayed in figure  [ rs - result ] .",
    "* for every permutation @xmath474 , @xmath469 is a heap tableau of the same shape as heap tableau @xmath468 . moreover , + @xmath469 is a heap tableau in standard form . * one can uniquely identify permutation @xmath474 from the pair @xmath475 .",
    "* the fact that the shape is the same is easy : whenever number @xmath470 is inserted into @xmath468 , this table changes by exactly one ( filled ) position .",
    "when @xmath94 is inserted into @xmath469 , the position on which it is inserted is the unique position that was added to @xmath468 : the position of the final insertion after a ( perhaps empty ) sequence of bumps .",
    "therefore the two heap tableaux have the same shape throughout the process , and at the end of it .",
    "+ let us show now that @xmath469 is a heap tableau .",
    "we will show that invariants ( b),(c ) .",
    "remain true throughout the insertion process .",
    "+ they are , indeed , true at the beginning when @xmath476 $ ] . proving the heap invariant ( b ) .",
    "is easy : numbers are inserted into @xmath469 in the order @xmath477 .",
    "each number is , therefore , larger than any number that is an ancestor in its heap . as each number @xmath94",
    "is inserted as a leaf in its corresponding heap , all heap conditions are still true after its insertion . + the vector invariant ( c ) .",
    "is equally easy : number @xmath94 is appended to an old vector or starts a new one .",
    "the second case is trivial . in the first one",
    "@xmath94 is the largest number inserted so far into @xmath469 , therefore the largest in its vector .",
    "+ finally , the fact that @xmath469 is a standard tableau follows from the algorithm : schensted - heap@xmath217 starts a new vector from the leftmost position available .",
    "therefore when it starts a new vector , its siblings to the left have acquired a smaller number , as they were already created before that point .",
    "also , when it starts a new vector , all the vectors on the level immediately above have been created ( otherwise schensted - heap@xmath217 would have started a new vector there ) and have , thus , acquired a smaller number .",
    "* this is essentially the same proof ideea as that of the robinson- + schensted correspondence for ordinary young tableaux : given heap tableaux @xmath478 with the same shape we will recover the pairs @xmath479 , @xmath480 , @xmath481 in this backwards order by reversing the sequences of bumps .",
    "we will work in the more general setting when @xmath471 contains @xmath6 distinct numbers , not necessarily those from @xmath142 to @xmath6 . on the other hand , since @xmath222 is standard , @xmath222 will contain these numbers , each of them exactly once .",
    "+ the result is easily seen to be true for @xmath482 . from now on we will assume that @xmath483 and reason inductively .",
    "+ suppose @xmath6 is in vector @xmath427 of @xmath469 .",
    "then the insertion of @xmath484 into @xmath468 did not provoke any bumps .",
    "@xmath484 is the integer in vector @xmath427 of @xmath468 sitting in the same position as @xmath6 does in @xmath469 .",
    "suppose , on the other hand , that @xmath6 is in a different vector of @xmath469 . then @xmath6 is the outcome of a series of bumps , caused by the insertion of @xmath484 .",
    "+ let @xmath18 be the integer in @xmath468 sitting at the same position as @xmath6 in @xmath469 .",
    "then @xmath18 must have been bumped from the parent vector in the heap - table by some @xmath19 .",
    "@xmath19 is uniquely identified , as the largest element smaller than @xmath18 in that vector .",
    "there must exist a smaller element in that vector by the heap invariant , so @xmath19 is well - defined . now @xmath19 must have been in turn bumped by some @xmath425 in the parent vector .",
    "we identify @xmath425 going upwards , until we reach vector @xmath427 , identifying element @xmath484 .",
    "+ consider , for example the case of @xmath485 in figure  [ rs - result ] .",
    "element @xmath143 in @xmath468 ( sitting in the corresponding position ) must have been bumped by 1 in the top row .",
    "therefore @xmath486 .",
    "+ now we delete @xmath487 from the two heap tableaux and proceed inductively , until we are left with two tables with one element , identifying permutation @xmath474 this way .",
    "+ what allows us to employ the induction hypothesis is the following + removing the largest element @xmath6 from a standard heap tableau @xmath31 yields another standard heap tableau .",
    "[ red ] + suppose @xmath6 is in a vector of length at least two . clearly , by removing @xmath6 all the vectors in the heap",
    "remain the same , so the resulting table is standard .",
    "+ suppose , therefore , that @xmath6 is the only element in a vector @xmath442 of @xmath31 , @xmath488 , @xmath489 .",
    "since @xmath31 was standard , all the left sibling vectors @xmath490 of @xmath426 ( @xmath491 ) are nonempty , and all the vectors on previous levels of @xmath31 are nonempty .",
    "+ removing @xmath426 preserves these properties ( its leftmost sibling becomes the last vector , or the level disappears completely ) .",
    "+ completing the proof of lemma  [ red ] also completes the proof of theorem  [ rs - heap ] ."
  ],
  "abstract_text": [
    "<S> we investigate partitioning of integer sequences into heapable subsequences ( previously defined and established by mitzenmacher et al . </S>",
    "<S> + @xcite ) . we show that an extension of patience sorting computes the decomposition into a minimal number of heapable subsequences ( mhs ) . </S>",
    "<S> we connect this parameter to an interactive particle system , a multiset extension of hammersley s process , and investigate its expected value on a random permutation . </S>",
    "<S> in contrast with the ( well studied ) case of the longest increasing subsequence , we bring experimental evidence that the correct asymptotic scaling is @xmath0 . finally we give a heap - based extension of young tableaux , prove a hook inequality and an extension of the robinson - schensted correspondence . </S>"
  ]
}