{
  "article_text": [
    "inductive coupling is a technique by which energy from one circuit is transferred to another without wires .",
    "simultaneously , the energy transfer can be used as a vehicle for information transmission .",
    "this is a fundamental technology for near - field passive radio frequency identification ( rfid ) applications as well as lightweight sensor applications .    in the passive rfid application , a _ reader _ , containing or attached to a power source , controls and powers a communication session with a _ tag _",
    "; a device without a separate power source . the purpose of the communication session may be , for examples , object identification , access control , or acquisition of sensor data .    several standards exist that specify lower layer coding for rfid protocols .",
    "however , it seems that most standards employ codes that have been shown to be useful in general - purpose communication settings .",
    "although this is justifiable from a pragmatic point of view , we observe that a thorough _ information - theoretic approach _ may reveal alternate coding schemes that , in general , can provide benefits in terms of reliability , efficiency , synchronization , simplicity , or security .",
    "operating range of a reader - tag pair is determined by communications requirements as well as power transfer requirements . to meet the communications requirements , the reader - to - tag and the tag - to - reader communication channels satisfy specified demands on communication transfer rate and reliability . to meet the power transfer requirements , the received power at the tag",
    "must be sufficiently large as to provide operating power at the tag .    according to @xcite , with current technology it is the power transfer requirements that present the bottleneck with respect to operating range for a two - way reader - tag communication session",
    "nevertheless , there is a value in determining the information - theoretic aspects , such as tradeoffs between reliability and transmission rate , of this communication : first , because future technologies may shift the relation between communication and power transfer requirements , and second , because present cheap tag technologies impose challenges on communication which are not directly related merely to received signal power .    wireless information and",
    "power transfer has been considered in different contexts previously , for instance , for multiuser orthogonal frequency division multiplexing systems @xcite and cellular networks @xcite .",
    "see also @xcite and references therein . in @xcite ,",
    "wireless information and power transfer across a noisy inductively coupled channel was considered from a different perspective than we do in this paper , i.e. , it was not considered from the perspective of code design , but from a _ circuit _ perspective . for details ,",
    "we refer the interested reader to @xcite . in @xcite , a coding - based secure communication protocol for inductively coupled communication , inspired by quantum key distribution ,",
    "was recently proposed .    in this paper , however , we address issues related to lower layer coding of information on inductively coupled channels , with emphasis on _ coding for error control _ for the _ reader - to - tag _ channel . the remainder of the paper is organized as follows . in section  [ sec : model ] , we describe the characteristics of the reader - to - tag channel and discuss power issues and processing capabilities .",
    "a discretized gaussian shift channel as a model for the reader - to - tag channel for passive near - field rfid is proposed in section  [ sec : channelmodels ] .",
    "this model is relevant if the receiver resynchronizes its internal clock each time a bit is detected , and is different from the recently proposed bit - shift channel model in @xcite . in section",
    "[ sec : capacity ] , we numerically consider its capacity , and , in section  [ sec : coding ] , we present several new and very simple codes for this channel model , as well as their encoding / decoding techniques .",
    "simulation results are presented in section  [ sec : sim ] , and we draw some conclusions in section  [ sec : conclusion ] .",
    "in this paper , we will be concerned with data transfer from a reader to a tag .",
    "an _ information source _ generates an information _ frame _ of @xmath0 bits @xmath1 .",
    "the information frame is passed through an encoder to produce an encoded frame @xmath2 .",
    "the encoded frame is interpreted as a waveform that modulates a carrier wave , as shown in fig .",
    "[ fig : circuit ] , @xcite .",
    "please observe that the concept of a frame in this context refers to a collection of bits that belong together , for some semantic reason related to the application layer .",
    "the actual encoder may work at a different length .",
    "due to the strictly limited computing power of the tag , the actual encoder may work on a bit - by - bit basis , as in most of the examples later in this paper .",
    "the encoded frame length @xmath3 may be fixed , depending only on @xmath0 , or variable , depending on @xmath0 and also on the information frame , but in general @xmath4 .        meanwhile , back at fig .",
    "[ fig : circuit ] , the demodulator in the tag samples the physical waveform at time intervals determined by the tag s timing device , and converts it into an estimate @xmath5 of the transmitted frame , where in general @xmath6 . ideally , @xmath7 should be identical to @xmath8 , but additive noise , interference , timing inaccuracies , and waveform degradation due to limited bandwidth may contribute to corrupt the received frame @xmath7 .",
    "we will discuss some of these signal corruptions later in this paper .",
    "a decoder at the tag subsequently attempts to recover an information frame @xmath9 from @xmath7 .",
    "correct decoding is achieved if @xmath10 .",
    "the tag in fig .",
    "[ fig : circuit ] has no internal power source .",
    "rather , it collects the power derived from the carrier .",
    "after some initial transient delay , the tag s power circuitry will be charged sufficiently to provide operating power for the tag .",
    "commonly , amplitude modulation , or more precisely _ on - off keying ( ook ) _ is employed . in ook ,",
    "a `` @xmath11 '' ( resp .",
    "`` @xmath12 '' ) is transmitted by the presence ( resp .",
    "absence , or alternatively a low amplitude ) of the carrier for the duration specified for transmitting that particular bit .",
    "the transmitted power is limited by regulation @xcite .",
    "however , the amount of transferred power can still be influenced by the encoding scheme used .",
    "although the tag has no traditional battery or other means of accumulating energy over an extended period , it is possible to `` ephemerally '' store energy over a short time ( say , a few bit periods ) in the power circuitry .",
    "thus , it makes sense to impose constraints on power content in the transmitted signal @xcite , for example , by demanding that @xmath13 out of every @xmath14 consecutive transmitted bits are @xmath11 s .",
    "thus , a high power content ( i.e. , the ratio @xmath15 is large ) is an advantage .",
    "the precise manifestation of this advantage depends on technology and is difficult to measure .",
    "therefore , we will consider different measures of power ( to be defined below ) as a figure of merit for a given coding scheme .",
    "formally , we will define the _ power content _ of a binary vector @xmath16 , denoted by @xmath17 , as the rational number @xmath18 , where @xmath19 denotes the hamming weight of its binary argument .",
    "let @xmath20 denote a block code or a variable - length code , i.e. , a collection or set of codewords .",
    "furthermore , let @xmath21}$ ] be the set of sequences of length @xmath22 over @xmath20 , i.e. , the set of @xmath23 consecutive codewords .",
    "the _ average power _ of @xmath20 is defined as the average power content of the sequences in @xmath21}$ ] as @xmath24 . for block codes , this average does not depend on @xmath23 , and the average power of a block code @xmath20 is @xmath25 .",
    "however , for variable - length codes , the average depends on @xmath23 , and we need to consider the limit as @xmath24 . in general , the average power of a code @xmath20 can be computed from @xcite @xmath26 where @xmath27 and @xmath28 denote the hamming weight and length of the @xmath29th codeword in @xmath20 , respectively .",
    "the _ minimum sustainable power _ of a block or variable - length code @xmath20 is defined as @xmath30 .",
    "we remark that for codes defined by a state diagram , the various notions of power can refer to any cycle in the state diagram .",
    "thus , @xmath31 refers to the minimum average cycle weight of a cycle in the state diagram . as a final figure of merit",
    ", we will consider the _",
    "local minimum power _ of a code @xmath20 as the minimum positive value of the ratio @xmath15 over all possible sequences in @xmath21}$ ] , for any finite value of @xmath23 , where @xmath32 are arbitrary positive integers .      due to the limited tag power",
    ", processing capability is severely limited in a tag .",
    "this applies to any processing involved in whatever service the tag is supposed to provide , but also signal processing involved in receiving information .      for many communication channels studied in the literature , approaching",
    "channel capacity ( or even achieving a significant coding gain over naive implementations ) relies on error correction codes .",
    "however , although classes of codes are known for which the decoder can be efficiently implemented , the decoding process may still require a significant amount of processing .",
    "we will argue below that for channels for which the error probabilities depend on the transmitted data , reliability can be increased by using a code enforcing an appropriate set of modulation constraints .",
    "such _ error avoiding _ codes can typically be decoded by a simple table , mapping received sequences into information estimates .",
    "in this section , we will discuss a new channel model for the reader - to - tag channel , which is slightly different from the bit - shift model ( for inductive coupling ) recently introduced in @xcite .",
    "if the receiver resynchronizes its internal clock each time a bit is detected , the bit - shift model from @xcite needs to be modified .",
    "we will first introduce the _ gaussian shift channel_.    suppose the reader transmits a run of @xmath33 consecutive equal symbols .",
    "this corresponds to an amplitude modulated signal of duration @xmath33 . at the tag , we will assume that this is detected ( according to the tag s internal clock ) as having duration @xmath34 , where @xmath35 and @xmath36 is a random variable . in this paper , @xmath36 follows a gaussian distribution @xmath37 with mean @xmath38 and variance @xmath39 .",
    "consecutive samplings of @xmath36 are assumed to be independent .",
    "if @xmath40 , it means that the tag has a systematic drift , which may affect the tag s ability to function at all .",
    "thus , we will focus on the case @xmath41 . with this assumption",
    ", the input to the demodulator will be a sequence of alternating runs of high and low amplitude values ; the detected duration @xmath42 of each run being a _ real - valued _ number .",
    "we might attempt decoding directly at the gaussian shift channel , but the computational complexity may be high for the tag receiver . as a simplification , and to deal with the fact that @xmath34 may become negative ( @xmath36 has a normal distribution ) , which of course does not have any physical interpretation , we propose to discretize the timing and truncate @xmath36 . the optimal choice for the quantization thresholds , i.e. , the thresholds when mapping the real - valued numbers @xmath42 to _ positive _ integers , will depend on the code under consideration .",
    "however , an optimal _ local _ threshold can be computed as shown in the following proposition .",
    "[ prop:1 ] let @xmath43 and @xmath44 be positive integers with @xmath45 , representing the only two legal runlengths in a given constrained code .",
    "then , there is a single threshold @xmath46 , and its optimum value from a _ local _ perspective to determine if runlength @xmath43 or runlength @xmath44 was transmitted is @xmath47 the corresponding decision error with one such decision is @xmath48 where @xmath49 is the probability that a sample of the standard normal distribution has a value larger than @xmath50 standard deviations above the mean , i.e. , @xmath51 where @xmath52 denotes the complementary error function .",
    "assuming @xmath43 is transmitted , then the probability that @xmath44 is received ( with @xmath53 as the quantization threshold ) is @xmath54 . likewise ,",
    "if @xmath44 is transmitted , then the probability that @xmath43 is received is @xmath55 .",
    "this follows directly from the fact that @xmath36 has a gaussian distribution with mean @xmath11 and variance @xmath39 .",
    "now , since @xmath56 is a monotonically decreasing function , @xmath54 is monotonically decreasing and @xmath55 is monotonically increasing in @xmath53 ( within the range @xmath57 $ ] ) .",
    "thus , the optimal threshold @xmath53 corresponds to the intersection of @xmath54 and @xmath55 .",
    "thus , @xmath58 . solving this equation , we get @xmath59 .",
    "the expression for the decision error in ( [ eq : decision_error ] ) follows by substituting the expression for the optimal threshold @xmath53 into either @xmath54 or @xmath55 , and the final inequality ( in ( [ eq : decision_error ] ) ) follows from the fact that @xmath60 is smaller than @xmath11 .",
    "note that when @xmath61 , @xmath62 will approach @xmath63 as @xmath44 goes to infinity .",
    "we remark that we do not allow the mapping of a real - valued number ( from the output of the gaussian shift channel ) to zero ( or a negative integer ) , which means that the channel can not make a runlength disappear .",
    "this appears to be consistent with properties of practical inductively coupled channels .    in general , let @xmath64 denote a quantization scheme with quantization values @xmath65 , where @xmath66 , and @xmath67 is some positive integer ( that later will be used as a _ runlength _ ) , and quantization thresholds @xmath68 , where @xmath69 , @xmath70 .",
    "the quantization scheme works in the following way .",
    "map a received real - valued number to an integer in @xmath71 using quantization thresholds in @xmath72 , i.e. , if the received real - valued number is in the range @xmath73 , @xmath74 , map it to @xmath75 , if it is in the range @xmath76 , map it to @xmath77 , and , otherwise , map it to @xmath78 .",
    "now , we define the discretized gaussian shift channel with quantization scheme @xmath64 as the cascade of the gaussian shift channel and the quantization scheme @xmath64 , where the quantization scheme @xmath64 is applied to the real - valued sequence at the output of the gaussian shift channel .    as an example",
    ", we can define a discretized gaussian shift channel , where the quantization thresholds are chosen such that the integer sequence is obtained from the real - valued sequence by rounding its values to the nearest positive integer value .",
    "this particular quantization scheme will be denoted by @xmath79 . as a further modification",
    ", we may introduce a parameter @xmath80 , to truncate the maximum observed length , into the quantization scheme @xmath79 , and in this way get a family of discretized gaussian shift channels .",
    "the resulting quantization scheme works in the following way .",
    "if the reader has transmitted a run of @xmath67 symbols , the tag will detect it as having length @xmath81 where @xmath82 is a truncation integer parameter and @xmath83 . with @xmath84 ,",
    "we denote the channel as the discretized gaussian single - shift channel . with @xmath85 , the channel",
    "is called the discretized gaussian double - shift channel , and so on . now ,",
    "if we want to express the discretized gaussian single - shift channel in terms of runlengths with additive error terms @xmath86 ( as in ( * ? ?",
    "* eq .  ( 4 ) ) ) , ( * ? ? ? * eq .",
    "( 4 ) ) is modified by ( [ eq : runlformat1 ] ) and discretization to @xmath87 where @xmath88 and @xmath89 .    as another example",
    ", we can define a quantization scheme @xmath90 , where the quantization threshold @xmath91 , @xmath92 . in a similar manner , as for @xmath79",
    ", we can express the discretized gaussian single - shift channel ( now with quantization scheme @xmath93 ) in terms of runlengths with additive error terms @xmath86 as in ( [ eq : model ] ) , but with transition probabilities @xmath94 where @xmath95 and where @xmath96 ( resp .",
    "@xmath97 ) is the closest value to @xmath33 allowed by the quantization scheme that is also strictly smaller ( resp .",
    "larger ) than @xmath33 .",
    "as will become clear later , this quantization scheme outperforms the general rounding scheme defined above .",
    "however , note that when @xmath98 and @xmath77 is large , the performance approaches the performance of the discretized gaussian shift channel with quantization scheme @xmath79 for low values of @xmath99 .",
    "we can make the following remarks in connection with the gaussian shift channel .",
    "a.   as can be seen from fig .",
    "[ fig : qx ] , when considering the `` likely error patterns '' , we need to be concerned mainly about the longest runs of equal symbols .",
    "the exception to this pragmatic rule occurs when , for some codes , it is possible to correct all shifts ( up to some order , where a single shift is a shift of order one , a double shift is a shift of order two , and so on ) corresponding to maximum - length runs .",
    "+ ) versus @xmath99 for runlengths @xmath11 , @xmath100 , @xmath101 , and @xmath102.,width=302 ] b.   for _ many simple codes _ used on the discretized gaussian shift channel the frame error rate ( fer ) , denoted by @xmath103 , can be simplified to , respectively , + @xmath104 + and @xmath105 with quantization schemes @xmath79 and @xmath93 , where @xmath106 , and @xmath107 is some constant ( representing a count of different error events ) depending on the code and on the specific decoder , assuming that the most likely error event when using the code is connected with the confusion of runlengths of length @xmath67 with some other run of length @xmath108 .",
    "we omit the details , but will show examples later ( see theorems  [ thm : rll ] and [ thm : rllnew ] ) . c.   error avoidance versus",
    "error control : suppose we can design an error correction encoder that admits runlengths of length at most 2 ; that has a decoder that can correct all error events involving a single shift of a _ single _ run of length 2 , but that will make a mistake if two or more such event occurs .",
    "such a decoder should have a fer on the order of @xmath109 ( with quantization scheme @xmath79 ) for small @xmath99 . observe from fig .",
    "[ fig : qx ] that @xmath110 .",
    "can we design a code with a simple decoder that behaves as @xmath111 ?",
    "yes , we can ; see sections  [ sec:13:13 ] , [ sec:1:13 ] , and [ sec : relatedconstraints ] .",
    "d.   observe that the discretized gaussian single - shift channel is a _ special form of an insertion - deletion channel _ , which randomly may extend or shorten the runs of transmitted identical symbols , but where the statistics of this random process depend on the length of the runs .",
    "codes for insertion - deletion channels have been studied , but to a moderate extent , and some of the best known codes , such as the varshamov - tenengolz codes @xcite and the codes in @xcite , are apparently too complex for the application in question and also do not possess the appropriate modulation constraints , to be discussed below .",
    "e.   an intelligent receiver tag should realize that any received run longer than the maximum run must be the result of an insertion .",
    "thus , such insertions can trivially be corrected . in consequence , _ for some codes _ , the discretized gaussian shift channel is approximately simply a special deletion channel that applies only to runs of maximum length .",
    "f.   in general , for any code and channel , a receiver may use a forward error correction scheme ( fec ) , or an automatic - repeat - request ( arq ) scheme asking for retransmissions if an error is detected .",
    "obviously , error detection is computationally simpler than error correction .",
    "indeed , arq is typically used in standard protocols for passive rfid , utilizing a standard embedded cyclic redundancy check code . + for the binary symmetric channel it is further well - known that the fer associated with fec is typically much higher than the probability of undetected error corresponding to arq .",
    "counter - intuitively , this property does not necessarily apply with the discretized gaussian shift channel .",
    "in this section , we will consider the channel capacity of the discretized gaussian shift channel .",
    "since a sequence of transmitted consecutive bits can not disappear ( the quantization schemes quantize each real - valued received number to a positive integer ) and consecutive samplings of @xmath36 are independent , the discretized gaussian shift channel ( with any quantization scheme ) is really a discrete memoryless channel operating on runlengths with the positive integer values as input and output alphabet , and with channel transition probabilities that depend on @xmath99 and the quantization scheme .",
    "now , we define a truncated version of the channel , denoted by @xmath112 , with input alphabet @xmath113 , output alphabet @xmath114 , where @xmath67 and @xmath115 are integers greater than one , and channel transition probabilities @xmath116 .",
    "the parameter @xmath115 is the smallest integer output of the discretized gaussian shift channel ( with a given quantization scheme ) such that the probability of observing @xmath115 for any given input @xmath117 is smaller than some small threshold probability @xmath118 .",
    "the normalized mutual information between the channel input @xmath119 and channel output @xmath120 , denoted by @xmath121 and measured in bits per input symbol , can be expressed by ( * ? ? ?",
    "* eq .  ( 3 ) )    @xmath122 } = \\frac{\\sum_{y \\in \\mathcal{y } } \\sum_{x \\in \\mathcal{x } } f_x(x ) f_{y|x}(y|x ) \\log_2 \\left ( \\frac{f_{y|x}(y|x)}{\\sum_{j \\in \\mathcal{x } } f_x(j)f_{y|x}(y|j ) } \\right)}{\\sum_{j \\in \\mathcal{x } } j \\cdot f_x(j ) } \\ ] ] @xmath123 } \\\\ & = \\frac{\\sum_{y \\in \\mathcal{y } } \\sum_{x \\in \\mathcal{x } } f_x(x ) f_{y|x}(y|x ) \\log_2 \\left ( \\frac{f_{y|x}(y|x)}{\\sum_{j \\in \\mathcal{x } } f_x(j)f_{y|x}(y|j ) } \\right)}{\\sum_{j \\in \\mathcal{x } } j \\cdot f_x(j ) } \\end{split}\\ ] ] where @xmath124 denotes the mutual information between @xmath119 and @xmath120 and @xmath125 $ ] the expectation of @xmath119 with respect to the input probability distribution @xmath126 .",
    "now , the capacity of @xmath112 ( in bits per symbol ) can be obtained by maximizing the fraction in ( [ 34:eq : i ] ) over all input probability distributions @xmath126 .",
    "note that since the channel is memoryless , it is sufficient to consider only a single use of the channel , i.e. , not sequences of length @xmath23 as in ( * ? ? ?",
    "* eq .  ( 3 ) ) .",
    "we remark that if the channel could in fact remove runlengths , then the channel would resemble a deletion channel with substitution errors operating on runlengths . from an information - theoretic perspective , such a channel is much harder to analyze , since there is no finite - letter expression for the channel capacity @xcite .    from @xcite , we know that the numerator of ( [ 34:eq : i ] ) , i.e. , the mutual information between @xmath119 and @xmath120 , is a continuous and concave function of @xmath126 .",
    "thus , the maximization of the _ un - normalized _ mutual information ( i.e. , the maximization of the numerator of ( [ 34:eq : i ] ) over the set of all input probability distributions @xmath126 ) can be done using , for instance , a gradient ascent algorithm , or the iterative blahut - arimoto algorithm @xcite .    the normalized mutual information @xmath121 in ( [ 34:eq : i ] ) is quasiconcave in @xmath126 .",
    "since @xmath125 $ ] is a linear function on @xmath126 , it is obviously a convex function on @xmath126 .",
    "furthermore , since @xmath125 $ ] is strictly positive , then @xmath127 $ ] is also a convex function on @xmath126 .",
    "since @xmath124 is continuous and concave ( from @xcite ) , it follows that the fraction in ( [ 34:eq : i ] ) is a product of a convex and a concave function .",
    "now , @xmath127 $ ] is actually both quasiconvex and quasiconcave because the upper and lower countoursets are always convex sets , since the level sets are linear varieties ( they are linear for @xmath125 $ ] , and hence they are also linear for @xmath127 $ ] , since they have the same level sets ) .",
    "every concave function is quasiconcave , hence @xmath124 is quasiconcave .",
    "thus , the normalized mutual information in ( [ 34:eq : i ] ) is the product of two quasiconcave and nonnegative functions , which again is quasiconcave .",
    "the function in ( [ 34:eq : i ] ) is continuous in @xmath126 ( the denominator is strictly positive and continuous , and the numerator is continuous ) , which is not a general property of being quasiconcave .",
    "furthermore , any _ strong _ local maximum is a global maximum for any quasiconcave function @xcite ( the result is formulated for quasiconvex functions in lemma  1 in @xcite ) .",
    "thus , a gradient ascent algorithm can be used to find the global maximum of any continuous differentiable quasiconcave function by checking for strict maximality .    for illustration purposes , in fig .",
    "[ 34:fig:1 ] , the normalized mutual information from ( [ 34:eq : i ] ) is plotted as a function of @xmath128 and @xmath129 when @xmath130 , for @xmath131 .",
    "the threshold probability is @xmath132 and the quantization scheme @xmath79 has been used .",
    "normalized mutual information as a function of @xmath128 and @xmath129 when @xmath130 ( @xmath133 ) , for @xmath131 .",
    "the threshold probability is @xmath132 and the quantization scheme @xmath79 has been used . ]",
    "normalized mutual information as a function of @xmath128 and @xmath129 when @xmath130 ( @xmath133 ) , for @xmath131 .",
    "the threshold probability is @xmath132 and the quantization scheme @xmath79 has been used . ]    due to the constraint @xmath134 , the normalized mutual information in ( [ 34:eq : i ] ) is really a function of @xmath108 variables @xmath126 , @xmath135 .",
    "thus , we may substitute @xmath136 into ( [ 34:eq : i ] ) and then compute the partial derivatives with respect to @xmath126 , @xmath135 .",
    "[ 34:lem:2 ] the partial derivative of the normalized mutual information @xmath121 in ( [ 34:eq : i ] ) with respect to @xmath126 , @xmath135 , is @xmath137 where @xmath138 @xmath139    this follows from straightforward calculus .    in summary : recall that the capacity of the channel @xmath112 is equal to @xmath140 , and that proposition 2 shows that @xmath121 is quasiconcave in @xmath126 .",
    "thus , in order to numerically determine the capacity of the channel @xmath112 , we have implemented a steepest ascent method using proposition  [ 34:lem:2 ] for the expression of the gradient .",
    "in addition , we need to check if the located stationary point of @xmath121 , i.e. , a point for which the partial derivatives @xmath141 are zero for every @xmath126 , indeed corresponds to a strict maximum of @xmath121 . if not , another random starting point for the steepest ascent method is chosen , and the procedure is repeated until a strict maximum of @xmath121 is located .       the capacity of the channel @xmath112 for different values of @xmath67 as a function of @xmath99 .",
    "the threshold probability is @xmath132 and the quantization scheme @xmath79 has been used . ]",
    "the capacity of the channel @xmath112 for different values of @xmath67 as a function of @xmath99 .",
    "the threshold probability is @xmath132 and the quantization scheme @xmath79 has been used . ]",
    "the capacity of the channel @xmath112 for different values of @xmath67 as a function of @xmath99 with both quantization schemes @xmath79 and @xmath142 .",
    "the threshold probability is @xmath132 . ]",
    "the capacity of the channel @xmath112 for different values of @xmath67 as a function of @xmath99 with both quantization schemes @xmath79 and @xmath142 .",
    "the threshold probability is @xmath132 . ]    in fig .",
    "[ 34:fig:2 ] , we have plotted the capacity of the channel @xmath112 as a function of @xmath99 for various values of the input alphabet size @xmath67 .",
    "the threshold probability is @xmath132 and the quantization scheme @xmath79 has been used .",
    "the curves in fig .",
    "[ 34:fig:2 ] are computed using a gradient ascent algorithm using the gradient from proposition  [ 34:lem:2 ] .",
    "we observe that there is almost no difference between the curves for @xmath143 and @xmath144 , which indicates convergence .",
    "thus , the curve for @xmath144 should be very close to the _ exact _ capacity of the discretized gaussian shift channel with quantization scheme @xmath79 .    in fig .",
    "[ 34:fig:3 ] , we have plotted the capacity of the channel @xmath112 as a function of @xmath99 for various values of the input alphabet size @xmath67 and with both quantization schemes @xmath79 and @xmath142 .",
    "the threshold probability is @xmath132 .",
    "we observe that the quantization scheme @xmath79 gives the best performance for intermediate - to - large values of @xmath99 , while the quantization scheme @xmath93 performs better when @xmath99 decreases .",
    "note that by looking at the optimal input distributions @xmath126 we observe that the shortest runlengths ( i.e. , the smallest values of @xmath50 ) have the highest probabilities .",
    "thus , an error control code for this channel should be designed to give coded sequences in which small runlengths occur more frequently than longer runlengths .",
    "this is the topic of the next section .",
    "among the encoding schemes in use in communication standards for rfid applications , one can find several codes that are popular in general communication protocols , such as nrz , manchester , unipolar rz , and miller coding @xcite . here",
    ", we will study the effect of some new encoding schemes for the reader - to - tag channel , considering power constraints ( see section  [ sec : power ] ) and the communication channel described in section  [ sec : channelmodels ] , i.e. , the gaussian shift channel . as a reference",
    ", we will provide the manchester code ( described in section  [ sec : manchester ] ) , and two variable - length codes presented in @xcite ( and described in sections  [ sec:10_011 ] and [ sec:101_01101 ] , respectively ) and designed for the bit - shift channel from @xcite .    before describing the specific code constructions",
    ", we will briefly explain the concept of constrained coding .",
    "we may desire and enforce that an encoded sequence satisfies certain constraints specified by a _ constraint graph _ @xcite .",
    "these constraints may , for example , be the power constraints described in section  [ sec : power ] , or runlength limitations , or a combination of these constraints .",
    "for the purpose of this paper , we shall denote a particular binary runlength limitation as @xmath145 , where @xmath146 is the set of admissible runlengths of binary symbol @xmath44 . in the following",
    ", @xmath147 refers to the _ big o notation _ for describing the limiting behavior of functions .",
    "[ thm : rll ] if a code satisfying the @xmath148,[1,l])$ ] limitation , where @xmath149 = \\{1,2,\\ldots , l\\}$ ] , is used on the discretized gaussian shift channel with quantization scheme @xmath79 and with an ml decoder , then the fer behaves as @xmath150 for small @xmath99 .    by looking at the transition probabilities in ( [ eq : tran_prob_rounding ] )",
    ", we observe that the dominating error event ( in terms of error probability ) is when a length-@xmath67 runlength ( the largest allowed by the code ) is received as a length-@xmath151 runlength .",
    "this is the case since @xmath152 is an increasing function of its argument . from ( [ eq : tran_prob_rounding ] ) , it follows that the fer behaves as @xmath150 for small @xmath99 , and the result follows .",
    "[ thm : rllnew ] if a code satisfying the @xmath148,[1,l])$ ] limitation is used on the discretized gaussian shift channel with quantization scheme @xmath153)$ ] and with an ml decoder , then the fer behaves as @xmath154 for small @xmath99 .    by looking at the transition probabilities in ( [ eq : tran_prob_q ] ) , we observe that the dominating error event ( in terms of error probability ) is when a length-@xmath67 runlength ( the largest allowed by the code ) is received as a length-@xmath151 runlength .",
    "again , this is , as noted in the proof of theorem  [ thm : rll ] , the case since @xmath152 is an increasing function of its argument . from ( [ eq : tran_prob_q ] ) , it follows that the fer behaves as @xmath155 for small @xmath99 , where ( from ( [ eq : alphabeta ] ) ) @xmath156 and the result follows .",
    "the maximum rate of a constrained code is determined by the _ capacity _ of the constraint , which can readily be calculated from the constraint graph @xcite . there",
    "exist several techniques @xcite for designing an encoder ( of code rate upper - bounded by the capacity ) , and we refer the interested reader to these works for further details .",
    "the manchester code is a very simple block code that maps @xmath12 into @xmath157 , and @xmath11 into @xmath158 .",
    "the code is popular in many communication protocols , but one can observe that it also satisfies several of the criteria we can derive for a coding scheme to be used on a reader - to - tag discretized gaussian shift channel : the maximum runlength is two ; the average power is @xmath159 ; the minimum sustainable power is @xmath159 ; the local minimum power is @xmath160 ; the minimum hamming distance is two , and the code is simple to decode . the performance of this code on the discretized gaussian shift channel will be presented in section  [ sec : sim ] .      the variable - length code @xmath161 is single bit - shift error correcting , i.e. , it corrects any single bit - shift on the bit - shift model from @xcite , and has minimum sustainable power @xmath159 , local minimum power @xmath162 , and average power @xmath163 .",
    "the rate of the code is @xmath164 , the minimum runlength is @xmath11 , and the maximum runlength is @xmath101 .",
    "the performance of this code on the discretized gaussian shift channel will be presented in section  [ sec : sim ] .",
    "the variable - length code @xmath165 is single bit - shift error detecting , i.e. , it detects any single bit - shift on the bit - shift channel from @xcite , and has minimum sustainable power @xmath163 , local minimum power @xmath162 , and average power @xmath166 .",
    "the rate of the code is @xmath160 , the minimum runlength is @xmath11 , and the maximum runlength is @xmath100 .",
    "the performance of this code on the discretized gaussian shift channel will be presented in section  [ sec : sim ] .",
    "the capacity of the constraint @xmath167 is @xmath168 .",
    "furthermore , it follows from theorems  [ thm : rll ] and [ thm : rllnew ] that , similar to the manchester code , any code with this runlength limitation has a fer on the order of @xmath169 and @xmath170 , for small @xmath99 , on the discretized gaussian shift channel with quantization schemes @xmath79 and @xmath171)$ ] , respectively .",
    "[ ex:1 ] a two - state , rate-@xmath172 encoder for a @xmath173-constrained code is given in @xcite .",
    "the encoder can be transformed into a four - state encoder for a @xmath167-constrained code by a simple differential mapping . the encoder is shown in fig .",
    "[ fig:(01)a ] , while a very simple decoder / demapper is provided in table  [ tab:1 ] .",
    "the code has minimum sustainable power @xmath162 , local minimum power @xmath174 , and average power @xmath159 .",
    "-constrained code.,width=340 ]    -1.5ex    c|c|c + [ -2.0ex ] current word & next bits & decode to +   + [ -2.0ex ] + [ -2.0ex]@xmath175    ' '' ''    ' '' ''    & not possible & detect insertion + @xmath176    ' '' ''    & @xmath177 , @xmath176 & @xmath178 +    ' '' ''    & @xmath11 , @xmath179 & @xmath157 + @xmath177    ' '' ''    & @xmath12 , @xmath180 & @xmath181 +    ' '' ''    & @xmath182 , @xmath183 & @xmath158 + @xmath179    ' '' ''    & @xmath12 & @xmath178 +    ' '' ''    & ( @xmath11 means insertion ) & + @xmath180    ' '' ''    & @xmath11 & @xmath157 +    ' '' ''    & ( @xmath12 means insertion ) & + @xmath183    ' '' ''    & @xmath177 , @xmath176 & @xmath181 +    ' '' ''    & @xmath11 , @xmath179 & @xmath158 + @xmath182    ' '' ''    & @xmath12 , @xmath180 & @xmath178 +    ' '' ''",
    "& @xmath182 , @xmath183 & @xmath157 + @xmath184    ' '' ''    ' '' ''    & not possible & detect insertion +    a code with a very simple encoding and decoding can be obtained by using bit - stuffing .",
    "the resulting code is a variable - length code .",
    "the encoder keeps the information symbols @xmath185 , @xmath186 , unmodified , but inserts an extra inverted symbol @xmath187 if @xmath188 .",
    "the decoder destuffs the extra inserted symbols in a similar way .",
    "the encoder has rate @xmath172 , minimum sustainable power @xmath162 , local minimum power @xmath174 , average power @xmath159 , and maximum runlength @xmath100 .",
    "the capacity of the constraint @xmath189 is @xmath190 .",
    "thus , a practical rate is no higher than @xmath164 .",
    "however , the fer on the discretized gaussian shift channel behaves ( for small @xmath99 ) as @xmath169 and @xmath170 with quantization schemes @xmath79 and @xmath171)$ ] , respectively .",
    "the only advantage over the @xmath167 limitation is a higher power content .",
    "the capacity of the constraint @xmath191 is @xmath192 .",
    "[ thm : rll1 ] the fer on the discretized gaussian shift channel with quantization scheme @xmath79 for @xmath191-constrained codes is on the order of @xmath193 for small @xmath99 .",
    "the decoder works in the following way .",
    "every received run of length @xmath11 ( on the discretized gaussian shift channel with quantization scheme @xmath79 ) is kept as is , and every received run of length @xmath194 is assumed to be a run of length @xmath101 .",
    "this decoder makes an error if a run of length @xmath11 is extended by the gaussian shift channel to length more than @xmath195 ( this happens with probability @xmath111 ) , or if a run of length @xmath101 is shortened to less than @xmath195 ( this happens with probability @xmath196 ) .",
    "we remark that on the discretized gaussian shift channel with quantization scheme @xmath197 , the error probability is of the same order for small @xmath99 , i.e. , it behaves as @xmath198 .",
    "[ ex:2 ] a three - state , rate-@xmath159 encoder for a @xmath191-constrained code is depicted in fig .",
    "[ fig:(13)a ] , while a very simple decoder / demapper is provided in table  [ tab:2 ] .",
    "the code has minimum sustainable power @xmath160 , local minimum power @xmath199 , and average power @xmath200 .",
    "-constrained code.,width=566 ]    -constrained code.,width=453 ]    -1.5ex    c|c|c + [ -2.0ex ] current word & next bit pair & decode to +   + [ -2.0ex ] + [ -2.0ex ]    @xmath178    ' '' ''    ' '' ''",
    "& whatever & @xmath12 + @xmath157    ' '' ''    ' '' ''    & not possible & detect error + @xmath158    ' '' ''    & @xmath178 or @xmath181 & @xmath12 +    ' '' ''    & @xmath158 & @xmath11 + @xmath181    ' '' ''    ' '' ''    & whatever & @xmath11 +    a code with a very simple encoding and decoding can be obtained by using bit - stuffing .",
    "the resulting code is a variable - length code .",
    "the encoder keeps the information symbols @xmath185 , @xmath186 , unmodified , but inserts a pair of extra symbols @xmath201 if @xmath188 .",
    "the decoder destuffs the extra inserted symbols in a similar way .",
    "the encoder has rate @xmath159 , minimum sustainable power @xmath160 , local minimum power @xmath199 , average power @xmath159 , and allowed runlengths @xmath11 and @xmath101 .",
    "the capacity of the constraint @xmath202 is @xmath203 .",
    "furthermore , there is no difference in the asymptotic fer ( i.e. , the fer for small values of @xmath99 ) with respect to @xmath191-limited codes ( the proof of theorem  [ thm : rll1 ] holds in this case as well ) .",
    "thus , the only advantage over the @xmath191 limitation is a higher power content .",
    "[ ex:3 ] the variable - length @xmath202-constrained code with codewords @xmath204 has rate @xmath162 , minimum sustainable power @xmath159 , local minimum power @xmath162 , and average power @xmath172 .",
    "codes satisfying the constraints @xmath206 @xmath207 have capacities @xmath208 , @xmath209 , and @xmath210 , respectively . the latter constraint may be attractive from a power transfer point of view ; the two former constraints admit code rates of @xmath211 and @xmath212 , respectively , but may be hard to implement . for the @xmath213 constraint , a rate-@xmath159 , @xmath214-state encoder can be designed using the state - splitting algorithm from @xcite . finally , we remark that the fer on the discretized gaussian shift channel is on the order of @xmath169 and @xmath170 with the quantization schemes @xmath79 and @xmath215 , respectively , for small values of @xmath99 for these codes .",
    "any @xmath216-limited code , for any positive integer @xmath67 , has a fer of the order of @xmath193 ( with both quantization schemes @xmath79 and @xmath217 ) for small @xmath99 .",
    "this can be shown with a similar argument to that used to prove theorem  [ thm : rll1 ] .",
    "we remark here that the @xmath193 performance guarantee under the quantization scheme @xmath79 assumes that the decoder deals with nonadmissible ( with respect to the code ) observed runlengths in the appropriate way .",
    "notice that the capacity seems to approach a limit at about @xmath218 as @xmath67 increases .",
    "thus , there seems to be no immediate practical advantage on extending these ideas further .",
    "for different codes . ]     for different codes . ]    ) on the discretized gaussian shift channel with two different quantization schemes and with analytical expressions for the asymptotic performance , for the manchester code and the variable - length code @xmath204 . ]    ) on the discretized gaussian shift channel with two different quantization schemes and with analytical expressions for the asymptotic performance , for the manchester code and the variable - length code @xmath204 . ]    in this section , we provide some simulation results of some of the above - mentioned codes on the discretized gaussian shift channel . in particular , we consider the manchester code from section  [ sec : manchester ] , the @xmath161 code from section  [ sec:10_011 ] , and the @xmath165 code from section  [ sec:101_01101 ] , in addition to the newly designed codes from examples  [ ex:1 ] , [ ex:2 ] , and [ ex:3 ] . for convenience ,",
    "the information block length @xmath0 is chosen to be @xmath219 bits ; this allows a simple processing , while the block length is already long enough for the issues addressed in our analytical approach to be valid .",
    "the simulation was carried out with software implemented in c++ , and the simulation was terminated ( for each simulation point ) after the transmission of @xmath220 frames or when at least @xmath221 frame errors were recorded .",
    "this should give sufficient statistical significance , as can also be seen from the figures ( all simulation curves are smooth ) , and hence no error bars are included .    in fig .",
    "[ fig : fer ] , we have plotted the fer performance of these codes as function of @xmath99 on the discretized gaussian shift channel with quantization scheme @xmath171)$ ] for the manchester code , for the @xmath165 code from section  [ sec:101_01101 ] , and for the code from example  [ ex:1 ] , with quantization scheme @xmath222)$ ] for the @xmath161 code from section  [ sec:10_011 ] , and with quantization scheme @xmath197 for the remaining codes . as can be observed from the figure , the @xmath223)-constrained code from example  [ ex:2 ] and the @xmath224)-constrained code from example  [ ex:3 ] have the best error rate performance , while the variable - length code @xmath161 designed in @xcite for the traditional bit - shift channel has the worst performance among the simulated codes .",
    "however , this is not surprising , since this code has not been designed for the discretized gaussian shift channel .    in fig .",
    "[ fig : fer_compare ] , we have compared the performance of two different codes , namely the @xmath225)-constrained manchester code and the @xmath224)-constrained code @xmath204 from example  [ ex:3 ] with two different quantization schemes .",
    "we have used the quantization schemes simulated in fig .",
    "[ fig : fer ] and the quantization scheme @xmath79 .",
    "note that the curve for the @xmath224)-constrained code @xmath204 from example  [ ex:3 ] with quantization scheme @xmath197 is not explicitly shown , since there is no noticeable performance difference between the two quantization schemes for this code ( as also shown by proposition  [ prop : code01_0111 ] below ) . on the other hand",
    ", there is a significant performance difference for the other code .",
    "this is consistent with our earlier discussion in section  [ sec : coding ] . in the figure",
    ", we also show analytical expressions for the asymptotic performance which depend on both the quantization scheme used and the particular decoding algorithm .",
    "these expressions are given by the propositions below and match perfectly with the simulation results .",
    "[ prop : code01_0111 ] for the @xmath202-constrained code from example  [ ex:3 ] , the fer ( with both quantization schemes @xmath197 and @xmath79 ) on an information block of length @xmath0 is approximately @xmath226 as @xmath99 becomes smaller .",
    "the @xmath152-part of the expression follows from theorem  [ thm : rll1 ] ( or more precisely , the proof of theorem  [ thm : rll1 ] , since the proof holds for both @xmath202-constrained and @xmath191-constrained codes ) .",
    "the factor @xmath0 in front follows from the fact that the decoder needs to make exactly one decision for each information symbol .    for the manchester code on an information block of length @xmath0 , the fer is approximately @xmath227 and @xmath228 for large @xmath0 , with quantization schemes @xmath171)$ ] and @xmath79 , respectively , as @xmath99 becomes smaller .",
    "the @xmath152-parts of the expressions follow from theorems  [ thm : rllnew ] and [ thm : rll ] , respectively . the factor in front ( for quantization scheme @xmath171)$ ] ) follows from the fact that all runlengths are equally critical , i.e. , the probability of a length-@xmath11 runlength ( of zeros or ones ) being received as a length-@xmath100 runlength and vice versa is the same .",
    "thus , the multiplicity in front of the @xmath152-part will be the average number of runlengths in a codeword , which is exactly @xmath229 .    with the second quantization scheme ( @xmath79 ) , only length-@xmath100 runlengths are critical , but not all of them , as can be seen from the operation of the decoder .",
    "in particular , the decoder works as shown in table  [ tab : manch ] .",
    "observe a window of two consecutive bits of the received sequence ( second column of table  [ tab : manch ] ) .",
    "then , based on the previously decoded bit ( first column of table  [ tab : manch ] ) , decode the observed bits as indicated in the third column of table  [ tab : manch ] , and advance a number of bits ( as indicated in the fourth column ) for the new window .",
    "-1.5ex    c|c|c|c + [ -2.0ex ] previously decoded bit & next bit pair & decode to & advance +   + [ -2.0ex ] + [ -2.0ex ]    @xmath11    ' '' ''    ' '' ''    & @xmath158 & @xmath11 & @xmath100 + @xmath11    ' '' ''    ' '' ''    & @xmath157 & @xmath12 & @xmath100 + @xmath11    ' '' ''    ' '' ''    & @xmath181 & @xmath12 & @xmath11 + @xmath11    ' '' ''    ' '' ''    & @xmath178 & whatever & @xmath101 + @xmath12    ' '' ''    ' '' ''    & @xmath157 & @xmath12 & @xmath100 + @xmath12    ' '' ''    ' '' ''    & @xmath158 & @xmath11 & @xmath100 + @xmath12    ' '' ''    ' '' ''    & @xmath178 & @xmath11 & @xmath11 + @xmath12    ' '' ''    ' '' ''    & @xmath181 & whatever & @xmath101 +    now , for instance , the sequence @xmath230 is critical , since it can be received as @xmath231 ( the third bit is deleted ) , and the decoder from table  [ tab : manch ] is not able to recover it without errors . on the other hand , the sequence @xmath232 is _ not _ critical , since the corresponding received sequence @xmath233 ( again the third bit is deleted ) is decoded correctly by the decoder of table  [ tab : manch ] . in summary , from table  [",
    "tab : manch ] , the critical sequences are in fact exactly those that have a length-@xmath100 runlength followed by a length-@xmath11 runlength .",
    "assuming equally likely transmitted information symbols , with probability @xmath160 , a critical pattern occurs in the transmitted sequence for each information symbol , and the expression ( valid for large @xmath0 ) follows .",
    "we have also simulated the case where the communication takes place on the discretized gaussian shift channel with simultaneous additive white gaussian noise ( awgn ) , and where the gaussian noise is added ( at the bit level ) at the output of the discretized gaussian shift channel .",
    "the results , shown in fig .  [ fig : shftandawgn ] , are for the manchester code with @xmath171)$ ] and hard - decisions as a function of both @xmath99 and the signal - to - noise ratio ( snr ) , defined as @xmath234 , where @xmath235 is the standard deviation of the awgn , @xmath236 is the code rate , and @xmath237 ( resp .",
    "@xmath238 ) is the amplitude level of a one ( resp .",
    "zero ) . for the other simulated codes , we have observed a similarly shaped performance behavior with simultaneous awgn ( results not included here ) .",
    "we remark that in the normal mode of rfid reader - to - tag operation , the snr can be expected to be high .     and the snr ( in db ) for the manchester code with @xmath171)$ ] . ]     and the snr ( in db ) for the manchester code with @xmath171)$ ] .",
    "]    finally , we remark that we have used look - up table decoding in all simulations .",
    "for instance , for the codes from examples  [ ex:1 ] and [ ex:2 ] , we have used tables  [ tab:1 ] and [ tab:2 ] , respectively , in the decoding . for the manchester code , we have used table  [ tab : manch ] . further , note that all the codes used in the simulation are local and even a ( hard - decision ) ml decoder is limited in performance by the issues discussed in our analysis . a soft - decision ml decoder",
    "may improve on this , but will complicate the implementation , something which is undesirable with current technology .",
    "a key point of the proposed codes is that they are designed for _ error avoidence _ , and consequently coding gain is achieved with a very simple decoding procedure .",
    "in this work , we have discussed a new channel model and code design for near - field passive rfid communication using inductive coupling as a power transfer mechanism .",
    "the ( discretized ) gaussian shift channel was proposed as a channel model for the reader - to - tag channel when the receiver resynchronizes its internal clock each time a bit is detected .",
    "furthermore , the capacity of this channel was considered , and some new simple codes for error avoidance were presented .",
    "their performance were also compared to the manchester code and two previously proposed codes for the bit - shift channel model .",
    "error avoidance allows a quantification of the coding gain of a runlength - limited code , and we believe that this quantification adds a new perspective of constrained codes .",
    "the authors would like to thank the anonymous reviewers for their valuable comments and suggestions to improve the presentation of the paper .",
    "p.  v. nikitin and k.  v.  s. rao , `` performance limitations of passive uhf rfid systems , '' in _ proc .",
    "ieee antennas and propagation society international symposium _ , albuquerque , nm , jul .",
    "2006 , pp . 10111014 .",
    "g.  horler , `` inductively coupled telemetry , '' in _",
    "sensors for environment , health and security _ , ser .",
    "nato science for peace and security series c : environmental security , m .-",
    "baraton , ed.1em plus 0.5em minus 0.4emspringer netherlands , 2009 , pp .",
    "239252 .      .",
    "i. barbero , g.  d. horler , e.  rosnes , and  .",
    "ytrehus , `` modulation codes for reader - tag communication on inductively coupled channels , '' in _ proc .",
    "inf . theory and its appl .",
    "( isita ) _ , auckland , new zealand , dec .",
    "2008 , pp . 578583 .",
    "b.  h. marcus , r.  m. roth , and p.  h. siegel , _ constrained systems and coding for recording channels _ , ser .",
    "handbook of coding theory.1em plus 0.5em minus 0.4emelsevier , north - holland , 1998 , pp . 16351764 .",
    "r.  l. adler , d.  coppersmith , and m.  hassner , `` algorithms for sliding block codes  an application of symbolic dynamics to information theory , '' _ ieee trans .",
    "theory _ , vol .",
    "it-29 , no .  1 ,",
    "522 , jan . 1983 ."
  ],
  "abstract_text": [
    "<S> this paper discusses a new channel model and code design for the _ reader - to - tag _ channel in near - field passive radio frequency identification ( rfid ) systems using inductive coupling as a power transfer mechanism . </S>",
    "<S> if the receiver resynchronizes its internal clock each time a bit is detected , the bit - shift channel used previously in the literature to model the reader - to - tag channel needs to be modified . </S>",
    "<S> in particular , we propose a discretized gaussian shift channel as a new channel model in this scenario . </S>",
    "<S> we introduce the concept of quantifiable _ error avoidance _ , which is much simpler than error correction . </S>",
    "<S> the capacity is computed numerically , and we also design some new simple codes for error avoidance on this channel model based on insights gained from the capacity calculations . finally , some simulation results are presented to compare the proposed codes to the manchester code and two previously proposed codes for the bit - shift channel model .    </S>",
    "<S> bit - shift channel , channel capacity , code design , coding for error avoidance , constrained coding , discretized gaussian shift channel , inductive coupling , radio frequency identification ( rfid ) , reader - to - tag channel , synchronization errors . </S>"
  ]
}