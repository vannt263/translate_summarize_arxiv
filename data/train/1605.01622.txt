{
  "article_text": [
    "the abcdsat solver submitted to the sat competition 2016 is the improved version of abcdsat 2015 @xcite , which are built on the top of glucose 2.3 @xcite . here",
    "we provide three versions of abcdsat : _ drup _ , _ inc _ and _ lim _ , which are submitted to main ( agile ) track , incremental library track and no - limit track , respectively .",
    "the main techniques use by the three versions include at - least - one recently used strategy , learnt clause database approximation reduction , recursive splitting solving , decision variable selection based on blocked clause decomposition @xcite , bit - encoding phase selection @xcite , simplification such as lifting , probing , distillation , elimination , hyper binary resolution etc .",
    "of course , all the simplification techniques used here are the existing techniques , so we will omit the description on them .",
    "in the search process of cdcl ( conflict driven , clause learning ) solvers , the learnt clause database is required to be maintained . based on our experimental observation ,",
    "the clause database maintenance is actually similar to cache replacement in cpu cache management or page replacement in a computer operating system .",
    "there are many cache ( page ) replacement algorithms .",
    "for example , least recently used ( lru ) , most recently used ( mru ) , pseudo - lru ( plru ) , least - frequently used ( lfu ) , second chance fifo , random replacement ( rr ) , not recently used ( nru ) @xcite etc .",
    "our at - least - one recently used ( aloru ) algorithm is similar to nru page replacement algorithm , but different from the clause freezing mechanism proposed by audemard et al @xcite .",
    "aloru favours keeping learnt clauses in database that have been recently used at least one time .",
    "if a learnt clause has not so far involved in any conflict analysis since it was generated , it will be discarded first .",
    "implementing aloru is very simple . when a conflict clause ( called also learnt clause ) is generated , its lbd ( literal block distance , for its definition , see @xcite ) is usually set to the number of different decision levels involved in it .",
    "however , aloru sets the initial lbd of a conflict clause to @xmath0 , not actual current lbd . in details , in the * search * procedure , aloru replaces ",
    "* setlbd(nblevels ) * \" with",
    " * setlbd(0x3fffffff ) * \" . since any lbd in real instances that can be solved never exceeds 0x3fffffff",
    ", we denote @xmath0 with 0x3fffffff .",
    "if a learnt clause involves in a conflict analysis , the procedure for conflict analysis sets its lbd to the actual value .",
    "the target of learnt clause database reduction is two fold : remove useless clauses and avoid the expansion of database . almost all the existing reduction algorithms in cdcl solvers are to sort learnt clauses according to the score ( e.g. lbd ) of clauses , then remove a given number of clauses in the sorted order .",
    "this can be viewed as exact reduction .",
    "our approximation reduction is different from the exact reduction .",
    "it has no sorting , and replaces sorting with selection . in details ,",
    "our approximation reduction finds firstly the clause with the @xmath1-th smallest ( or largest ) score , where @xmath1 is the number of clauses to be removed .",
    "secondly , it removes @xmath1 clauses with the score less than or equal to the @xmath1-th smallest score .",
    "notice , the clauses with the score equal to that of the @xmath1-th clause are not often unique . and the clauses with the score less than to the @xmath1-th smallest score are not necessarily removed .",
    "therefore , the parameter @xmath1 is an approximation value or estimate , not exact . due to this reason , we call reduction implemented by finding the @xmath1-th item approximation reduction . here",
    "we choose quickselect or hoare s find algorithm @xcite to find the @xmath1-th item .",
    "if all database reductions are done in this approximation way , solving is not the most efficient .",
    "therefore , we apply the approximation reduction when the number of conflicts is larger than 300000 for special cnf instances . in the other cases ,",
    "we apply still the exact approximation .",
    "like swdia5by @xcite , glue_alt classifies also learnt clauses into two categories : core and local . however , the classification of swdia5by is static , while our classification is dynamic . in swdia5by , the maximum lbd of core learnt clauses",
    "is fixed to a constant 5 . however , in abcdsat , the maximum lbd of core learnt clauses is not fixed .",
    "abcdsat divides the whole search process two stages .",
    "when the number of conflicts is less than @xmath2 , it is considered as the first stage . otherwise , it is considered as the second stage . in the first stage ,",
    "the maximum lbd of core learnt clauses is limited to 2 . at this stage ,",
    "core learnt clauses are kept indefinitely , unless eliminated when they are satisfied . in the second stage ,",
    "the maximum lbd of core learnt clauses is limited to 5 .",
    "this stage does not ensure that core learnt clauses are kept indefinitely .",
    "when local learnt clause database is reduced , we move 5000 core learnt clauses with lbd larger than or equal to 3 to local learnt clause database .",
    "whether the first or second stage , the number of local learnt clauses is maintained roughly between 9000 and 24000 .",
    "that is , once the number of local learnt clauses reaches a upper bound , say 18000 , abcdsat will halve the number of the clauses . and the clauses with the smallest activity scores are removed first .",
    "the computation of clause activity scores here is consistent with minisat .",
    "any cnf formula @xmath3 can be split into two subproblems @xmath4 and @xmath5 , where @xmath6 is a variable in @xmath3 .",
    "we can obtain the solution the original problem by solving each subproblem .",
    "solving subproblem in the same way results in a recursive solving algorithm .",
    "in general , we limit recursive depth to 10 .",
    "here is the pseudo - code of this recursive solving framework .",
    "* algorithm * splitsolve(@xmath3 , @xmath7 ) + @xmath8 * then return * abcdsat(@xmath3 , @xmath9 ) + @xmath10 @xmath11 abcdsat(@xmath3 , 500 ) + @xmath12 sat or unsat * then return * @xmath13 + @xmath6 @xmath11 getbranchvariable(@xmath14 ) + splitsolve(@xmath15 , @xmath16 ) + splitsolve(@xmath17 , @xmath16 ) +    the 2nd parameter of abcdsat in the above algorithm denotes the limit of the number of conflicts .",
    "abcdsat(@xmath3 , 500 ) means that it searches a solution of @xmath3 until the number of conflicts reaches 500 .",
    "procedure getbranchvariable selects a branch variable according to the rule given in @xcite .",
    "this solving framework is suitable for small formulas .",
    "because each solver participating in the main track is required to provide a drup proof in unsat case , we add a drup patch in the original abcdsat .",
    "in addition to this patch , abcdsat _ drug _ adds learnt clause database approximation reduction , at - least - one recently used strategy , but excludes xor and cardinality constraint simplification .",
    "in particular , xor simplification is difficult to provide a drup proof .",
    "the splitting and merging technique used in the original abcdsat can not provide a drup proof .",
    "so abcdsat _ drug _ simplifies it into recursive splitting solving technique given in previous section .",
    "the solver submitted to the incremental library track is called abcdsat _ inc_. this version has no drup patch . the main difference between abcdsat _ inc _ and abcdsat _ drug _ is that abcdsat _ inc _",
    "adopts dynamic core and local learnt clause management policy , while abcdsat _",
    "drug _ adopts glucose - style learnt clause management policy .",
    "this is the version submitted to the no - limit track .",
    "lim _ not only includes various techniques given above , but also xor and cardinality constraint simplification .",
    "with respect to learnt clause management , what abcdsat _ lim _ adopts is glucose - style learnt clause management policy . for a few special instances , abcdsat _ lim _",
    "switches to lingeling 587f @xcite to solve them . when the average lbd score of an instance to be solved is small , say less than 16 , this version uses splitting and merging ( reconstructing ) strategy described in @xcite , rather than recursive splitting solving strategy mentioned above ."
  ],
  "abstract_text": [
    "<S> we improve further the 2015 version of abcdsat by various heuristics such as at - least - one recently used strategy , learnt clause database approximation reduction etc . based on the requirement of different tracks at the sat competition 2016 , </S>",
    "<S> we develop three versions of abcdsat : _ drup _ , _ inc _ and _ lim _ , which participate in the competition of main ( agile ) , incremental library and no - limit track , respectively . </S>"
  ]
}