{
  "article_text": [
    "types play an important role in programming .",
    "they make programs easier to understand and help detect errors .",
    "there has been much research into types in logic programming .",
    "a type checker requires the programmer to declare types for each predicate in the program and verifies if the program is consistent with the declared types  @xcite .",
    "a type analysis derives types for the predicates or literals in the program from the text of the program  @xcite .",
    "this paper presents a new type analysis that infers types with _ a priori _ type definitions which determine possible types and their meanings .",
    "types are formed from type constructors from a fixed alphabet .",
    "this is in contrast to those type analyses that generate type definitions during analysis .",
    "both kinds of type analysis are useful .",
    "an analysis that generates type definitions may be favored in compile - time optimizations and program transformations whilst an analysis with _ a priori _ type definitions may be preferred in interactive programming tools such as debuggers because inferred types are easier for the programmer to understand .",
    "a number of factors compromise the precision of previous type analyses with _ a priori _ type definitions .",
    "firstly , they only allow deterministic type definitions .",
    "a function symbol can not occur more than once in the definition of the same type .",
    "a type then denotes a tree language recognized by a deterministic top - down tree automaton  @xcite and hence called a deterministic type .",
    "the restriction to deterministic type definitions allows fast propagation of type information .",
    "however , it causes loss of precision because of the limited power of deterministic types .",
    "the same restriction also prevents many natural typings .",
    "for instance , these two type rules @xmath0 and @xmath1 violate the restriction .",
    "some previous work even disallows function overloading  @xcite , which makes it hard to support built - in types .",
    "for instance , prolog has built - in type @xmath2 that denotes the set of atoms . without function overloading",
    ", atoms such as @xmath3 $ ] can not be a member of another type , say @xmath4 .",
    "secondly , the type languages in previous type analyses with _ a priori _ type definitions do not include set union as a type constructor . the denotation of the join of two types can be larger than the set union of their denotations .",
    "for instance , the join of @xmath5 and @xmath6 is @xmath7 .",
    "let @xmath8 be a type constructor that is interpreted as set union .",
    "then @xmath7 is a super - type of @xmath9 since the list [ 1 , 2.5 ] belongs to the former but not the latter .",
    "should non - deterministic type definitions be allowed , there is also a need to use set intersection as a type constructor as explained in section  [ sec : mot ] .",
    "finally , previous type analyses with _ a priori _ type definitions describe a set of substitutions by a single variable typing which maps variables of interest into types .",
    "the least upper bound of two variable typings is performed point - wise , effectively severing type dependency between variables .",
    "our type analysis aims to improve precision by eliminating the above mentioned factors .",
    "it supports non - deterministic type definitions , uses a type language that includes set union and intersection as type constructors and describes a set of substitutions by a set of variable typings . all these help improve analysis precision . on the other hand , they all incur performance penalty .",
    "however , experimental results with a prototype implementation show that tabling  @xcite reduces the time increase to a small fraction on a suite of benchmark programs .",
    "our type analysis is presented as an abstract domain together with a few primitive operations on the domain .",
    "the domain is presented for an abstract semantics that is nilsson s abstract semantics  @xcite extended to deal with negation and built - in predicates .",
    "the primitive operations on the domain can be easily adapted to work with other abstract semantics such as  @xcite .",
    "the remainder of the paper is organized as follows .",
    "section  [ sec : mot ] provides motivation behind our work with some examples and section  [ sec : pre ] briefly presents the abstract semantics along with basic concepts and notations used in the remainder of the paper .",
    "section  [ sec : typ ] is devoted to types  their definitions and denotations .",
    "section  [ sec : dom ] presents the abstract domain and section  [ sec : ops ] the abstract operations . in section  [ sec : imp ] , we present a prototype implementation of our type analysis and some experimental results .",
    "section  [ sec : related ] compares our type analysis with others and section  [ sec : con ] concludes .",
    "an appendix contains proofs .",
    "this section provides motivation behind our type analysis via examples .",
    "the primary operations for propagating type information are informally illustrated ; and the need for using set union and intersection as type constructors is highlighted .",
    "[ ex : one ] this example demonstrates the use of set union as a type constructor .",
    "consider the following program and type rules .",
    "@xmath10 the two type rules define lists .",
    "they state that a term is of type @xmath11 iff it is either @xmath12 or of the form @xmath13 such that @xmath14 is of type @xmath15 and @xmath16 of type @xmath11 .",
    "type rules are formally introduced in section  [ sec : typ ] .",
    "the program has been annotated with circled numbers to identify relevant program points for the purpose of exposition",
    ".    the type analysis can be thought of as an abstract execution that mimics the concrete ( normal ) execution of the program . a program state in the concrete execution",
    "is replaced with an abstract one that describes the concrete state .",
    "the abstract states are type constraints .",
    "suppose that no type information is given at program point @xmath17  the start point of the execution .",
    "this is described by the type constraint @xmath18 .",
    "the execution reaches program point @xmath19 with the abstract state @xmath20 .",
    "the abstract state at program point @xmath21 is @xmath22 which states that @xmath14 is of type @xmath23 .",
    "the abstract state at program point @xmath24 is @xmath25 .",
    "the abstract execution of @xmath26 in @xmath27 obtains the abstract state @xmath28 at program point @xmath29 .",
    "the computation of @xmath28 needs some explanation .",
    "the two terms that are unified have the same type after the unification .",
    "since @xmath27 does not constrain @xmath30 , there is no type information propagated from @xmath30 to either @xmath14 or @xmath16 .",
    "the type for @xmath30 in @xmath28 equals the type of @xmath31 in @xmath27 which is computed in a bottom - up manner . to compute the type for @xmath12",
    ", we apply the type rule for @xmath32 .",
    "the type rule states that @xmath12 is of type @xmath11 for any @xmath15 .",
    "thus , the most precise type for @xmath12 is @xmath33 where the type @xmath34 denotes the empty set of terms .",
    "we omit the process of computing the type @xmath35 for @xmath36 in @xmath27 since it is similar to the following . to compute the type for @xmath37 , we apply the type rule for @xmath38 .",
    "the right hand side of the type rule is @xmath39 .",
    "we first find the smallest value for @xmath15 such that @xmath15 is greater than or equal to @xmath23  the type for @xmath14 in @xmath27 and the smallest value for @xmath15 such that @xmath11 is greater than or equal to @xmath35  the type for @xmath36 in @xmath27 .",
    "those two values are respectively @xmath23 and @xmath40 and their least upper bound is @xmath41 . replacing @xmath15 with @xmath41 in the left hand side of the type rule gives the most precise type @xmath42 for @xmath31 in @xmath27 .",
    "conjoining @xmath43 with @xmath27 results in @xmath44 .",
    "the abstract state at program point @xmath45 is @xmath46 which is obtained from @xmath28 by projecting out type constraints on @xmath14 and @xmath16 .",
    "the existence of the type constructor @xmath8 helps avoid approximations . without it , the least upper bound of @xmath23 and @xmath40 is @xmath47 which denotes the set of all terms .",
    "note that the collection of type rules is fixed during analysis .",
    "when two or more type rules are associated with a single function symbol , there is also a need to use set intersection as a type constructor .",
    "the following example illustrates this point .",
    "suppose that types are defined by the following four type rules .",
    "@xmath48 consider the problem of computing the type for @xmath49 in the abstract state @xmath50 .",
    "there are two type rules for @xmath32 .",
    "the type rule @xmath51 states that @xmath12 belongs to @xmath11 for any @xmath15 .",
    "the most precise type for @xmath12 that can be inferred from this rule is @xmath33 .",
    "similarly , the most precise type for @xmath12 that can be inferred from the type rule @xmath52 is @xmath53 .",
    "thus , the most precise type for @xmath12 is @xmath54 where @xmath55 is a type constructor that denotes set intersection .    to compute the type for @xmath56",
    ", we apply the type rule for @xmath38 .",
    "its right hand side is @xmath39 .",
    "we first find the smallest value for @xmath15 such that @xmath15 is greater than or equal to @xmath57  the type for @xmath14 in @xmath58 .",
    "the value is @xmath57 .",
    "we then find the smallest value for @xmath15 such that @xmath11 is greater than or equal to @xmath54  the type for @xmath12 in @xmath58 .",
    "this is done by matching @xmath11 with @xmath33 and with @xmath53 and intersecting values for @xmath15 obtained from these two matches .",
    "the first match results in @xmath34 .",
    "the second match is unsuccessful and produces @xmath47 since we are computing an upper approximation .",
    "the intersection of these two types is @xmath59 which is equivalent to @xmath34 .",
    "the join of the two smallest values @xmath57 and @xmath34 for @xmath15 is @xmath60 which is equivalent to @xmath61 .",
    "finally , the type @xmath62 for @xmath49 is obtained by substituting @xmath57 for @xmath15 in the left hand side of the type rule .",
    "without @xmath55 in the type language , a choice must be made between @xmath33 and @xmath53 as the type for @xmath12 .",
    "though these types are equivalent to @xmath54 , the choice made could complicate the ensuing computation .",
    "should @xmath53 be chosen , we would need to find the smallest value for @xmath15 such that @xmath11 is greater than or equal to @xmath53 .",
    "this could only be solved by applying an algorithm for solving type inclusion constraints .",
    "the presence of @xmath55 allows us to avoid that .    for the purpose of improving the precision of analysis",
    ", there is also a need for disjunction at the level of abstract states .",
    "the following example illustrates this point .",
    "consider the following program @xmath63 when the execution reaches program point , x and y are both of type _ integer _ or they are both of type _",
    "atom_. this is described by a type constraint @xmath64 . without disjunction at the level of abstract states , we would have to replace the type constraint with a less precise one : @xmath65 .",
    "the reader is assumed to be familiar with the terminology of logic programming @xcite and that of abstract interpretation  @xcite .",
    "we consider a subset of prolog which contains definite logic programs extended with negation as failure and some built - in predicates .",
    "we sometimes use church s lambda notation for functions , so that a function @xmath66 defined @xmath67 will be denoted @xmath68 .",
    "let @xmath69 and @xmath70 be sets . then @xmath71 is the set of total functions from @xmath69 to @xmath70 and @xmath72 is the set of partial functions from @xmath69 to @xmath70 . the function composition @xmath73 is defined @xmath74 .",
    "let @xmath75 be a set .",
    "a sequence over @xmath75 is either @xmath76 or @xmath77 where @xmath78 and @xmath79 is a sequence over @xmath75 .",
    "the infix operator @xmath80 associates to the right and prepends an element to a sequence to form a longer sequence .",
    "the set of all sequences over @xmath75 is denoted @xmath81 .",
    "let @xmath82 .",
    "we will sometimes write @xmath79 as @xmath83 .",
    "the dimension @xmath84 of @xmath79 is @xmath85 .",
    "let @xmath86 and @xmath87 . the set extension of @xmath80 is defined as @xmath88 .      a semantics of a program",
    "is given by an interpretation @xmath89 where @xmath90 is a complete lattice and @xmath91 is a monotone function on @xmath92 .",
    "the semantics is defined as the least fixed point @xmath93 of @xmath91 .",
    "the concrete semantics of the program is given by the concrete interpretation @xmath94 while an abstract semantics is given by an abstract interpretation @xmath95 .",
    "the correspondence between the concrete and the abstract domains is formalized by a galois connection @xmath96 between @xmath90 and @xmath97 .",
    "a galois connection between @xmath69 and @xmath98 is a pair of monotone functions @xmath99 and @xmath100 satisfying @xmath101 and @xmath102 .",
    "the function @xmath103 is called an abstraction function and the function @xmath104 a concretization function . a sufficient condition for @xmath105 to be a safe abstraction of @xmath106",
    "is @xmath107 or equivalently @xmath108 , according to propositions 24 and 25 in  @xcite .",
    "the abstraction and concretization functions in a galois connection uniquely determine each other ; and a complete meet - morphism @xmath100 induces a galois connection @xmath96 with @xmath109 .",
    "a function @xmath100 is a complete meet - morphism iff @xmath110 for any @xmath111 .",
    "thus , an analysis can be formalized as a tuple @xmath112 such that @xmath113 and @xmath95 are interpretations , @xmath104 is a complete meet - morphism from @xmath114 to @xmath115 , and @xmath108 .",
    "let @xmath116 be a set of function symbols , @xmath117 a set of predicate symbols and @xmath118 a denumerable set of variables .",
    "each function or predicate symbol has an arity which is a non - negative integer .",
    "we write @xmath119 for an @xmath85-ary function symbol @xmath66 in @xmath116 and @xmath120 for an @xmath85-ary predicate symbol @xmath121 in @xmath117 .",
    "let @xmath122 .",
    "the set of all terms over @xmath116 and @xmath123 , denoted @xmath124 , is the smallest set satisfying : ( i ) @xmath125 ; and ( ii ) if @xmath126 and @xmath119 then @xmath127 .",
    "the set of all atoms that can be constructed from @xmath117 and @xmath124 is denoted @xmath128 ; @xmath129 .",
    "let @xmath130 and @xmath131 for abbreviation .",
    "the set @xmath132 contains all terms and the set @xmath133 all atoms .",
    "the negation of an atom @xmath134 is written @xmath135 .",
    "a literal is either an atom or the negation of an atom .",
    "the set of all literals is denoted @xmath136 .",
    "let @xmath137 denote the set of calls to built - in predicates .",
    "note that @xmath138 .",
    "a clause @xmath98 is a formula of the form @xmath139 where @xmath140 and @xmath141 for @xmath142 .",
    "@xmath143 is called the head of the clause and @xmath144 the body of the clause .",
    "note that @xmath145 denotes the empty head and @xmath146 denotes the empty body .",
    "a query is a clause whose head is @xmath145 .",
    "a program is a set of clauses of which one is a query .",
    "the query initiates the execution of the program .",
    "program states which exist during the execution of a logic program are called substitutions .",
    "a substitution @xmath147 is a mapping from @xmath118 to @xmath132 such that @xmath148 is finite .",
    "the set @xmath149 is called the domain of @xmath147 .",
    ". then @xmath147 is written as @xmath151 .",
    "a substitution @xmath147 is idempotent if @xmath152 . the set of idempotent substitutions",
    "is denoted @xmath153 ; and the identity substitution is denoted @xmath76 .",
    "let @xmath154 and extend @xmath73 by @xmath155 and @xmath156 for any @xmath157 .",
    "substitutions are not distinguished from their homomorphic extensions to various syntactic categories .",
    "an equation is a formula of the form @xmath158 where either @xmath159 or @xmath160 .",
    "the set of all equations is denoted @xmath161 .",
    "for a set of equations @xmath162 , @xmath163 returns either a most general unifier for @xmath162 if @xmath162 is unifiable or @xmath164 otherwise .",
    "let @xmath165 stand for @xmath166 .",
    "define @xmath167 for @xmath168 and @xmath169 .",
    "the set of variables in a syntactic object @xmath170 is denoted @xmath171 .",
    "a renaming substitution @xmath172 is a substitution such that @xmath173 is a permutation of @xmath118 .",
    "the set of all renaming substitutions is denoted @xmath174 .",
    "define @xmath175 .",
    "we assume that there is a function @xmath176 that models the behavior of built - in predicates .",
    "the set @xmath177 consists of all those substitutions @xmath178 such that @xmath179 is a computed answer to @xmath180 .",
    "let @xmath181 be the set of variables in the program and @xmath182 .",
    "define @xmath183 by @xmath184 the operation @xmath185 models both procedure - call and procedure - exit operations . in a procedure - call operation ,",
    "@xmath186 and @xmath147 are the call and the program state before the call , @xmath187 is the head of the clause that is used to resolve with the call and @xmath188 the identity substitution @xmath76 . in a procedure - exit operation ,",
    "@xmath187 and @xmath188 are the call and the program state before the call , @xmath186 is the head of the clause that was used to resolve with the call and @xmath147 is the program state after the execution of the body of the clause . a renaming is applied to the call in a procedure - call operation whilst in a procedure - exit operation it is the head of the clause that is renamed .",
    "the new type analysis is presented as an abstract domain with four abstract operations .",
    "the domain and the operations are designed for an abstract semantics in  @xcite extended with supports for negation - as - failure and built - in predicates .",
    "the extended abstract semantics is a special case of an abstract semantics in  @xcite where a formal presentation can be found .",
    "the adaptation of the analysis to other abstract semantics such as  @xcite is straightforward since they require abstract operations with similar functionalities .",
    "the abstract semantics is parameterized by an abstract domain @xmath189 .",
    "the elements in @xmath190 are called abstract substitutions since they are properties of substitutions .",
    "the abstract domain is related to the collecting domain @xmath191 via a concretization function @xmath192 .",
    "we say that an abstract substitution @xmath193 describes a set of substitutions @xmath194 iff @xmath195 . as usual",
    ", the abstract domain and the concretization function are required to satisfy the following conditions .",
    "* @xmath196 is a complete lattice with least upper bound operation @xmath197 ; * @xmath198 is a moore family where @xmath199 .",
    "we informally present the abstract semantics using the following program as a running example .",
    "@xmath200 ) & \\leftarrow&~{{\\mbox{$\\bigcirc$\\hspace{-1em }        \\raisebox{0.2ex}{$\\scriptstyle 7$}\\hspace{.4ex}}}}\\\\   \\texttt{member}(x,[h|l ] ) & \\leftarrow & ~{{\\mbox{$\\bigcirc$\\hspace{-1em }        \\raisebox{0.2ex}{$\\scriptstyle 8$}\\hspace{.4ex}}}}~\\texttt{member}(x , l)~{{\\mbox{$\\bigcirc$\\hspace{-1em }        \\raisebox{0.2ex}{$\\scriptstyle",
    "9$}\\hspace{.4ex}}}}\\\\   & \\leftarrow & ~{{\\mbox{$\\bigcirc$\\hspace{-1em }        \\raisebox{0.2ex}{$\\scriptstyle { \\hspace{-.5ex}10}$}\\hspace{.4ex}}}}~y=[a , b]~~{{\\mbox{$\\bigcirc$\\hspace{-1em }        \\raisebox{0.2ex}{$\\scriptstyle { \\hspace{-.5ex}11}$}\\hspace{.4ex}}}}~z=[1,2 ] ~{{\\mbox{$\\bigcirc$\\hspace{-1em }        \\raisebox{0.2ex}{$\\scriptstyle { \\hspace{-.5ex}12}$}\\hspace{.4ex}}}}~ \\texttt{diff}(x , y , z)~{{\\mbox{$\\bigcirc$\\hspace{-1em }        \\raisebox{0.2ex}{$\\scriptstyle { \\hspace{-.5ex}13}$}\\hspace{.4ex } } } }     \\end{array}\\ ] ] the intended interpretation for @xmath201 is that @xmath14 is a member of list @xmath202 .",
    "the intended interpretation for @xmath203 is that @xmath14 is in @xmath202 or @xmath204 but not in both . for brevity of exposition ,",
    "let @xmath205 ; @xmath206 ; @xmath207)$ ] ; @xmath208)$ ] ; @xmath209 and @xmath210 . the atom in the literal to the right of a program point @xmath121 is denoted @xmath211 . for instance , @xmath212 .",
    "let @xmath213 denote the head of the clause with which @xmath121 is associated . for instance , @xmath214 .",
    "let @xmath215 be the point to the left of @xmath121 if @xmath215 exists .",
    "for instance , @xmath216 whilst @xmath217 is undefined .",
    "the abstract semantics associates each textual program point with an abstract substitution .",
    "the abstract substitution describes all the substitutions that may be obtained when the execution reaches the program point .",
    "the abstract semantics is the least solution to a system of data flow equations - one for each program point .",
    "the system is derived from the control flow graph of the program whose vertices are the textual program points .",
    "let @xmath218 be the set of the textual program points .",
    "an edge from vertex @xmath121 to vertex @xmath219 in the graph is denoted @xmath220 ; and it indicates that the execution may reach @xmath219 immediately after it reaches @xmath121 .",
    "consider the example program .",
    "we have @xmath221 .",
    "the program point @xmath222 is called the initial program point since it is where the execution of the program is initiated .",
    "the abstract substitution at @xmath222 is an analysis input , denoted @xmath223 , and it does not change during analysis .",
    "thus , the data flow equation for program point @xmath224 is @xmath225 where @xmath226 is a mapping from program points to abstract substitutions .",
    "the data flow equations for other program points are derived by considering four kinds of control flow that may arise during program execution .",
    "the first kind models the execution of built - in calls .",
    "for instance , the control may flow from program point @xmath224 to program point @xmath227 by executing @xmath228 $ ] .",
    "the data flow equation for program point @xmath227 is @xmath229,\\fbigx(10))$ ] where the transfer function @xmath230 emulates the execution of a built - in call .",
    "let @xmath231 be the set of all the program points that follow the built - in calls in the program .",
    "we have @xmath232 for the example program .",
    "another kind of control flow models negation - as - failure .",
    "the transfer function for this kind of control flow is the identity function .",
    "for instance , the control may flow from program point @xmath233 to program point @xmath234 since ` member`(x , k ) may fail , which yields this data flow equation @xmath235 .",
    "denote by @xmath236 the set of all the program points that follow negative literals .",
    "we have @xmath237 for the example program .",
    "the third kind of control flow arises when a procedure - call is performed .",
    "for instance , the control may flow from program point @xmath238 to program point @xmath239 .",
    "the description of data that flow from program point @xmath238 to program point @xmath239 is expressed as @xmath240 where @xmath241 is an abstract substitution that describes @xmath242 .",
    "note that @xmath69 is the call and @xmath75 the head of the clause to which program point @xmath239 belongs .",
    "the control may also flow to program point @xmath239 from program points 4 , 8 , 2 and 5 .",
    "the control flows from program point @xmath243 to program point @xmath239 when the negated sub - goal ` member`(k , l ) is executed .",
    "the descriptions of data that flow to program point @xmath239 from those five source program points are merged together using the least upper bound operation @xmath197 on @xmath190 , yielding the following data flow equation .",
    "@xmath244 the transfer function @xmath245 approximates @xmath246 defined @xmath247 which is the set extension of @xmath248 .",
    "denote by @xmath249 the set of program points that are reached via procedure - calls .",
    "we have @xmath250 for the example program .",
    "the fourth kind of control flow arises when a procedure exits .",
    "for instance , the control may flow from program point @xmath234 to program point @xmath251 .",
    "the description of data that flow from program point @xmath234 to program point @xmath251 is expressed by @xmath252 where @xmath162 is the head of the clause to which program point @xmath234 belongs and @xmath253 the call that invoked the clause .",
    "the only other control flow to program point @xmath251 is from program point @xmath254 .",
    "thus , the data flow equation for program point @xmath251 is @xmath255 .",
    "let @xmath256 be the set of program points that are reached via procedure - exits .",
    "for the example program , we have @xmath257 .",
    "let @xmath258 where @xmath259 .",
    "note that @xmath260 is the set of control flows that sink in @xmath261 .",
    "the data flow equation has the following general form .",
    "@xmath262 where @xmath223 is the input abstract substitution .",
    "the least solution to the system of data flow equations is a correct analysis if , in addition to c1 and c2 , the following local safety requirements are met .    *",
    "[ scheme : c3 ] @xmath263 ; * @xmath264 for any @xmath265 with @xmath266 and @xmath267 ; and * @xmath268 for any @xmath269 , any @xmath270 .",
    "[ scheme : c4 ]    note that the condition c2 implies that @xmath197 safely abstracts @xmath271 with respect to @xmath104 .",
    "the operation @xmath272 is called abstract unification since it mimics the normal unification operation whilst @xmath273 is called abstract built - in execution operation .    the complete system of data flow equations for the example program is as follows .",
    "@xmath274,\\fbigx(10))\\\\ \\fbigx(12 ) & = & \\asys(z=[1,2],\\fbigx(11))\\\\ \\fbigx(13 ) & = & \\aunify(e,\\fbigx(3),f,\\fbigx(12 ) )                ~\\alub~ \\aunify(e,\\fbigx(6),f,\\fbigx(12))\\end{aligned}\\ ] ]    the remainder of the paper presents our type analysis as an abstract domain and four abstract operations as required by the above abstract semantics .",
    "we begin with the type language and type definitions .",
    "the type language in a type system decides which sets of terms are types .",
    "a type is syntactically a ground term constructed from a ranked alphabet @xmath275 and @xmath276 where @xmath55 and @xmath8 are binary and @xmath47 and @xmath34 are nullary . elements of @xmath277 are called type constructors .",
    "it is assumed that @xmath278 .",
    "the set of types is @xmath279 .",
    "the denotations of type constructors in @xmath275 are determined by type definitions whilst @xmath280 and @xmath34 have fixed denotations .",
    "types are defined by type rules .",
    "a type parameter is a variable from @xmath281 .",
    "a type scheme is either a type parameter or of the form @xmath282 where @xmath283 and @xmath284 are different parameters .",
    "let @xmath285 be the set of all type schemes .",
    "a type rule is of the form @xmath286 where @xmath283 , @xmath119 , @xmath287 are different type parameters , and @xmath288 is a type scheme with type parameters from @xmath289 .",
    "note that every type parameter in the right - hand side of a type rule must occur in the left - hand side .",
    "overloading of function symbols is permitted since a function symbol can appear in the right - hand sides of two or more type rules .",
    "let @xmath290 be the set of all type rules .",
    "we assume that each function symbol occurs in at least one type rule and that each type constructor occurs in at least one type rule .",
    "type rules are similar to type definitions used in typed logic programming languages mercury  @xcite and gdel  @xcite .",
    "[ ex1 ] let @xmath291,[~|~ ] , void , tr(,,)\\}$ ] and @xmath292 .",
    "the following set of type rules will be used in examples throughout the paper .",
    "@xmath293 , &                  \\tlist(\\beta ) \\tdef [ \\beta|\\tlist(\\beta ) ] \\\\",
    "\\ttree(\\beta ) \\tdef void , &                  \\ttree(\\beta ) \\tdef tr(\\beta,\\ttree(\\beta),\\ttree(\\beta ) )                    \\end{array }             \\right\\}\\ ] ] type rules in @xmath290 define natural numbers , even numbers , odd numbers , lists and trees .",
    "a ( ground ) type substitution is a member of @xmath294 .",
    "the application of a type substitution to a type scheme is defined as follows .",
    "@xmath295 and @xmath296 for any type scheme @xmath297 .",
    "let @xmath298 .",
    "define @xmath299 for each @xmath300 where @xmath301 is the domain of @xmath302 .",
    "then @xmath303 is obtained by replacing each @xmath15 in @xmath297 with @xmath304 .",
    "for instance , @xmath305 .",
    "[ def : sem ] the meaning of a type is defined by a function @xmath306\\!\\!]}_{\\rules}}:\\rtype\\mapsto\\wp(\\term)$ ] .",
    "@xmath307\\!\\!]}_{\\rules } } & { = } & \\term\\\\ { { [ \\!\\![\\tbot]\\!\\!]}_{\\rules } } & { = } & \\emptyset\\\\ { { [ \\!\\![\\tand(\\rt_1,\\rt_2)]\\!\\!]}_{\\rules } } & { = } & { { [ \\!\\![\\rt_1]\\!\\!]}_{\\rules}}\\cap{{[\\!\\![\\rt_2]\\!\\!]}_{\\rules}}\\\\ { { [ \\!\\![\\tor(\\rt_1,\\rt_2)]\\!\\!]}_{\\rules } } & { = } & { { [ \\!\\![\\rt_1]\\!\\!]}_{\\rules}}\\cup{{[\\!\\![\\rt_2]\\!\\!]}_{\\rules}}\\\\ { { [ \\!\\![c({{\\rt_1,\\cdots,\\rt_m}})]\\!\\!]}_{\\rules } } & { = } & \\\\ \\multicolumn{3}{r}{~\\hspace{2pc }       \\bigcup_{(c({{\\beta_1,\\cdots,\\beta_m}})\\tdef f({{\\tau_1,\\cdots,\\tau_n}}))\\in\\rules }       \\left(\\begin{array}{l }         let~\\bbbk=\\{\\beta_j{\\mapsto}\\rt_j~|~1\\leq{j}\\leq{m}\\}\\\\         in~\\\\         \\{f({{t_1,\\cdots , t_n}})\\mid \\forall 1\\leq{i}\\leq{n}.         t_{i}\\in { { [ \\!\\![\\bbbk(\\tau_{i})]\\!\\!]}_{\\rules } }         \\ }       \\end{array}\\right )       } \\end{array}\\ ] ]    the function @xmath306\\!\\!]}_{\\rules}}$ ] gives fixed denotations to @xmath280 and @xmath34 .",
    "type constructors @xmath55 and @xmath8 are interpreted as set intersection and set union respectively .",
    "the type constructor @xmath47 denotes @xmath132 and @xmath34 the empty set .",
    "we say that a term @xmath308 is in a type @xmath309 iff @xmath310\\!\\!]}_{\\rules}}$ ] . set inclusion and @xmath306\\!\\!]}_{\\rules}}$ ]",
    "induce a pre - order @xmath311 on types : @xmath312\\!\\!]}_{\\rules}}\\subseteq{{[\\!\\![\\rt_2]\\!\\!]}_{\\rules}})$ ] and an equivalence relation @xmath313 on types : @xmath314 .",
    "continuing with example  [ ex1 ] , we have @xmath315\\!\\!]}_{\\rules } } = \\{0,s(0),s(s(0)),\\cdots\\}\\ ] ] @xmath316\\!\\!]}_{\\rules } } = \\{[~]\\}\\ ] ] @xmath317\\!\\!]}_{\\rules } } = \\{[~],[x|[~]],\\cdots\\}\\ ] ] where @xmath318 .",
    "observe that since @xmath319\\in{{[\\!\\![\\tlist(\\tnat)]\\!\\!]}_{\\rules}}$ ] and @xmath319\\not\\in{{[\\!\\![\\tlist(\\teven)]\\!\\!]}_{\\rules}}$ ] and @xmath319\\not\\in{{[\\!\\![\\tlist(\\todd)]\\!\\!]}_{\\rules}}$ ] .",
    "the type constructors @xmath55 and @xmath8 will sometimes be written as infix operators , i.e. , @xmath320 is written as @xmath321 and @xmath322 as @xmath323 .",
    "a type is atomic if its main constructor is neither @xmath55 nor @xmath8 .",
    "a type is conjunctive if it is of the form @xmath324 where each @xmath325 is atomic . by an obvious analogy to propositional logic , for any type @xmath309 , there is a type of the form @xmath326 such that each @xmath327 is conjunctive and @xmath328 .",
    "we call @xmath326 a disjunctive normal form of @xmath309 .    a term in a type may contain variables .",
    "this lemma states that types are closed under instantiation .",
    "[ lm : closed ] let @xmath329 and @xmath330 .",
    "if @xmath310\\!\\!]}_{\\rules}}$ ] then @xmath331\\!\\!]}_{\\rules}}$ ] for any @xmath332 .",
    "type rules in @xmath290 are production rules for a context - free tree grammar  @xcite .",
    "the complement of the denotation of a type is not necessarily closed under instantiation . for an instance , let @xmath290 be defined as in example  [ ex1 ] , @xmath318 and @xmath333 . observe that @xmath334\\!\\!]}_{\\rules}}$ ] and @xmath335\\!\\!]}_{\\rules}}$ ] . since @xmath336\\!\\!]}_{\\rules}}$ ] and @xmath337\\!\\!]}_{\\rules}}$ ] , @xmath338\\!\\!]}_{\\rules}}$ ] is not closed under instantiation and can not be denoted by a type in @xmath339 .",
    "the example shows that the family of types is not closed under complement .",
    "this explains why set complement is not a type constructor .",
    "types have also been defined using tree automata  @xcite , regular term grammars  @xcite , and regular unary logic programs  @xcite . a type defined in such a formalism denotes a regular set of ground terms .",
    "the meaning function @xmath306\\!\\!]}_{\\rules}}$ ] interprets a type as a set of possible non - ground terms ; in particular , it interprets @xmath47 as the set of all terms .",
    "type rules are used to propagate type information during analysis .",
    "let @xmath340 be of type @xmath341 and @xmath342 of type @xmath343 .",
    "then the type rule @xmath344 $ ] is used to infer that @xmath345 $ ] is of type @xmath346 .",
    "the type parameter @xmath15 is not only used as a placeholder but also used in folding heterogeneous types precisely via non - discriminated union operator .      during propagation of type information , it is necessary to work with type sequences .",
    "a type sequence expression is an expression consisting of type sequences of the same dimension and constructors @xmath55 and @xmath8 .",
    "note that constructors @xmath55 and @xmath8 are overloaded .",
    "the dimension of the type sequence expression is defined to be that of a type sequence in it .",
    "let @xmath329 , @xmath347 and @xmath348 and @xmath349 be type sequence expressions .",
    "we extend @xmath306\\!\\!]}_{\\rules}}$ ] to type sequence expressions as follows .",
    "@xmath350\\!\\!]}_{\\rules } } & { = } & \\{\\epsilon\\}\\\\ { { [ \\!\\![\\rt\\bullet\\rtvec]\\!\\!]}_{\\rules } } & { = } & { { [ \\!\\![\\rt]\\!\\!]}_{\\rules}}\\bullet{{[\\!\\![\\rtvec]\\!\\!]}_{\\rules}}\\\\ { { [ \\!\\![\\fcal_1~\\tand~\\fcal_2]\\!\\!]}_{\\rules } } & { = } &                     { { [ \\!\\![\\fcal_1]\\!\\!]}_{\\rules}}\\cap{{[\\!\\![\\fcal_2]\\!\\!]}_{\\rules}}\\\\ { { [ \\!\\![\\fcal_1~\\tor~\\fcal_2]\\!\\!]}_{\\rules } } & { = } &                     { { [ \\!\\![\\fcal_1]\\!\\!]}_{\\rules}}\\cup{{[\\!\\![\\fcal_2]\\!\\!]}_{\\rules}}\\end{aligned}\\ ] ]    the relations @xmath311 and @xmath313 on types carry over naturally to type sequence expressions .",
    "an occurrence of @xmath351 ( respectively @xmath352 ) stands for the type sequence of @xmath34 s ( respectively @xmath47 s ) with a dimension appropriate for the occurrence .",
    "abstract substitutions in our type analysis are type constraints represented as a set of variable typings which are mappings from variables to types . a variable typing represents the conjunction of primitive type constraints of the form @xmath353 . for instance , the variable typing @xmath354 represents the type constraint @xmath355 .",
    "the restriction of a variable typing @xmath58 to a set @xmath123 of variables is defined as @xmath356 the denotation of a variable typing is given by @xmath357 defined @xmath358\\!\\!]}_{\\rules}})\\}\\ ] ] for instance , @xmath359\\!\\!]}_{\\rules}}\\land\\theta(y)\\in{{[\\!\\![\\tlist(\\tnat)]\\!\\!]}_{\\rules}}\\}$ ] .",
    "the denotation of a set of variable typings is the set union of the denotations of its elements .",
    "[ ex : scal ] for instance , letting @xmath360 , @xmath361 denotes @xmath362\\!\\!]}_{\\rules}}\\land\\theta(y)\\in{{[\\!\\![\\tlist(\\tnat)]\\!\\!]}_{\\rules}}\\ } \\cup\\{\\theta~|~\\theta(x)\\in{{[\\!\\![\\tlist(\\tnat)]\\!\\!]}_{\\rules}}\\land\\theta(y)\\in{{[\\!\\![\\tnat]\\!\\!]}_{\\rules}}\\}$ ]",
    ".    there may be many sets of variable typings that denote the same set of substitutions .",
    "firstly , two different type expressions in @xmath339 may denote the same set of terms .",
    "for instance , @xmath363\\!\\!]}_{\\rules}}={{[\\!\\![\\tbot]\\!\\!]}_{\\rules}}$ ] using @xmath290 in example  [ ex1 ] . secondly , an element of a set of variable typings may have a smaller denotation than another .",
    "for an example , let @xmath364 .",
    "then @xmath361 has the same denotation as one of its proper subset @xmath365 .",
    "those abstract elements that have the same denotation are identified .",
    "let @xmath366 on @xmath367 be defined as @xmath368 .",
    "it is a pre - order and induces an equivalence relation @xmath369 on @xmath367 : @xmath370 .",
    "the equivalence classes with respect to @xmath369 are abstract substitutions .",
    "thus , the abstract domain is @xmath371 where @xmath372 @xmath373 is a complete lattice . its join and meet",
    "operators are respectively @xmath374}_\\req \\rlub { [ \\scal_2]}_\\req = { [ \\scal_1\\cup\\scal_2]}_\\req $ ] and @xmath374}_\\req \\rglb { [ \\scal_2]}_\\req = { [ \\scal_1^{\\downarrow}\\cap\\scal_2^{\\downarrow}]}_\\req $ ] where @xmath375 . the infimum is @xmath376}_\\req$ ] and the supremum @xmath377}_\\req$ ] . the concretization function @xmath378 is defined @xmath379}_\\req){=}\\bigcup_{\\mu\\in\\scal}\\vtcon(\\mu)\\ ] ] the following lemma states that @xmath380 satisfies the safety requirement c2 .",
    "@xmath381 is a moore family .",
    "[ lm : a ]    the definition of @xmath382 is not constructive since the downward closure of a set of variable typings @xmath361 can be infinite . for instance , letting @xmath383 , @xmath384 is in @xmath385 for any @xmath386 . the following operator @xmath387 computes effectively the meet of abstract substitutions .",
    "@xmath388    if @xmath389 and @xmath390 are finite representatives of two abstract substitutions then @xmath391 is a finite representative of the meet of the abstract substitutions , which is stated in this lemma .",
    "[ lm : b ] @xmath392}_\\req ) = \\rcon({[\\scal_1]}_\\req\\rglb{[\\scal_2]}_\\req)$ ] .",
    "we will use a fixed renaming substitution @xmath393 such that @xmath394 and define @xmath395 .",
    "the relation @xmath369 , the functions @xmath396 and @xmath380 and the operator @xmath397 extend naturally to sets of variable typings over @xmath398 .",
    "let @xmath58 be a variable typing , @xmath361 a set of variable typings and @xmath147 a substitution .",
    "we say that @xmath147 satisfies @xmath58 if @xmath399 ; and we say that @xmath147 satisfies @xmath361 if @xmath400}_\\req)$ ] .",
    "the conditions c1 and c2 are satisfied .",
    "c1 holds because @xmath401 is a complete lattice .",
    "c2 is implied by lemma  [ lm : a ] .",
    "the design of our type analysis is completed with four abstract operations required by the abstract semantics given in section  [ sec : pre ] .",
    "one operation is @xmath197 which is the least upper bound on @xmath402 .",
    "let @xmath403}_\\req$ ] .",
    "the operation @xmath241 obviously satisfies the condition @xmath404 and thus safely abstracts @xmath242 with respect to @xmath380 . since abstract built - in execution operation @xmath273 makes use of ancillary operations for abstract unification operation @xmath272 , we present @xmath272 before @xmath273 .",
    "the abstract unification operator @xmath272 takes two atoms and two abstract substitutions and computes an abstract substitution .",
    "the computation is reduced to solving a constraint that consists of a set of equations in solved form @xmath162 and a set of variable typings @xmath405 .",
    "the solution to the constraint is a set of variable typings @xmath406 . in order to ensure that @xmath272 safely abstracts @xmath407",
    ", @xmath406 is required to describe the set of all those substitutions that satisfy both @xmath162 and @xmath405 .",
    "let @xmath408 .",
    "the set @xmath406 is computed in two steps . in the first step",
    ", type information about @xmath409 is used to derive more type information about the variables in @xmath410 .",
    "this is a downward propagation since type information is propagated from a term to its sub - terms .",
    "the second step propagates type information in the opposite direction .",
    "it derives more type information about @xmath409 from type information about the variables in @xmath410 .    for an illustration ,",
    "let @xmath411,y=[w]\\}$ ] and @xmath412 where @xmath413 .",
    "during the downward propagation step , more type information for @xmath414 is derived from type information for both @xmath340 and @xmath342 . since @xmath415 and",
    "@xmath416 $ ] , @xmath417 $ ] is of type @xmath418 .",
    "since there is only one type rule for @xmath419 $ ] : @xmath344 $ ] , we deduce that @xmath414 is of type @xmath420 .",
    "similarly , we deduce that @xmath414 is of type @xmath421 since @xmath422 and @xmath423 $ ] .",
    "so , @xmath414 is of type @xmath424 that is equivalent to @xmath2 .",
    "the derived type @xmath2 for @xmath414 is used to strengthen @xmath58 into @xmath425 . during the upward propagation step , more type information for",
    "both @xmath340 and @xmath342 is derived type information for @xmath414 .",
    "note that @xmath417 $ ] is an abbreviation for @xmath426 $ ] . by applying the type rule @xmath427 $ ]",
    ", we infer that @xmath3 $ ] is of type @xmath33 .",
    "since @xmath428 , we derive that @xmath417 $ ] is of type @xmath343 by applying the type rule @xmath344 $ ] .",
    "we deduce that both @xmath340 and @xmath342 are of type @xmath343 since @xmath416 $ ] and @xmath423 $ ] .",
    "the derived type @xmath343 for @xmath340 and @xmath342 is used to strengthen @xmath429 , resulting in this singleton set of variable typing @xmath430 .",
    "both the downward and upward propagation steps in the preceding example produce a single output variable typing from an input variable typing . in more general cases ,",
    "both steps may yield multiple output variable typings from an input variable typing .",
    "we now present in details these two steps .",
    "downward propagation requires propagating a type @xmath309 downwards ( the structure of ) a term @xmath431 .",
    "let @xmath432\\!\\!]}_{\\rules}}\\}$ ] .",
    "propagation of @xmath309 downwards @xmath308 calculates a set of variable typings @xmath361 ( computed as @xmath433 ) such that @xmath434}_\\req)$ ] , that is , @xmath361 describes the set of all those substitutions that instantiate @xmath308 to a term of type @xmath309 .",
    "this is done by a case analysis . if @xmath435 then @xmath436 since @xmath437 is in @xmath309 for any @xmath168 .",
    "put @xmath438 .",
    "then @xmath361 satisfies the condition that @xmath434}_\\req)$ ] . if @xmath439 then @xmath440 satisfies the condition that @xmath434}_\\req)$ ] .",
    "consider the case @xmath441 .",
    "we have @xmath442 where @xmath443\\!\\!]}_{\\rules}}\\}$ ] and @xmath444\\!\\!]}_{\\rules}}\\}$ ] .",
    "we propagate the types @xmath445 and @xmath446 downwards @xmath308 separately , obtaining two sets of variable typings @xmath389 and @xmath390 such that @xmath447}_\\req)$ ] and @xmath448}_\\req)$ ] .",
    "put @xmath449 .",
    "then the condition that @xmath434}_\\req)$ ] is satisfied . for the case",
    "@xmath450 , @xmath451 satisfies the condition that @xmath434}_\\req)$ ] where @xmath389 and @xmath390 are obtained as above .",
    "consider the remaining case @xmath452 and @xmath453 .",
    "assume that there are @xmath454 type rules @xmath455 for @xmath456 and @xmath457 and @xmath458 is @xmath459 . by the definition of @xmath306\\!\\!]}_{\\rules}}$ ] , @xmath460 where @xmath461\\!\\!]}_{\\rules } } \\}\\}\\\\ & = & \\{\\theta\\mid f(\\theta(t_1),\\cdots,\\theta(t_n))\\in \\{f(s_1,\\cdots , s_n)\\mid \\forall 1\\leq i\\leq n. ( s_i\\in{{[\\!\\![\\kappa^j(\\tau_i^j))]\\!\\!]}_{\\rules } } \\}\\}\\\\ & = & \\{\\theta\\mid \\forall 1\\leq i\\leq n. ( \\theta(t_i)\\in{{[\\!\\![\\kappa^j(\\tau_i^j))]\\!\\!]}_{\\rules } } \\\\ & = & \\theta_1^j\\cap\\theta_2^j\\cap\\cdots\\cap\\theta_n^j\\end{aligned}\\ ] ] and @xmath462 and @xmath463\\!\\!]}_{\\rules}}\\}$ ] .",
    "we obtain @xmath361 as follows .",
    "we first propagate type @xmath464 downwards term @xmath410 , obtaining a set of variable typings @xmath465 .",
    "we have that @xmath466}_\\req)$ ] .",
    "we then calculate @xmath467 for the type rule @xmath458 .",
    "the set @xmath468 satisfies the condition that @xmath469}_\\req)$ ] .",
    "finally , we compute @xmath470 . since @xmath471}_\\req)$ ] and @xmath472 , @xmath361 satisfies the condition that @xmath434}_\\req)$ ] . in summary , @xmath473 where @xmath474 is defined @xmath475 where @xmath476 , @xmath119 and @xmath477 .",
    "the first one applies when there are multiple applicable alternatives .",
    "the following lemma states that @xmath433 describes all the substitutions that instantiate @xmath308 to a term of type @xmath309 .",
    "[ lm : c ] for any @xmath329 and @xmath431 , @xmath478\\!\\!]}_{\\rules}}\\}\\subseteq\\rcon({[\\vts(\\rt , t)]}_\\req)$ ] .",
    "we now consider the overall downward propagation given a set of variable typings @xmath361 and a set of equations in solved form @xmath479 .",
    "each variable typing @xmath58 in @xmath361 is processed separately as follows .",
    "we first propagate the type @xmath480 downwards @xmath410 .",
    "this results in a set of variable typings @xmath481 which describes all the substitutions that instantiate @xmath410 to a term of type @xmath480 .",
    "we then calculate @xmath482 .",
    "the set @xmath483 describes all the substitutions that instantiate @xmath410 to a term of type @xmath480 for all @xmath484 .",
    "we finally conjoin @xmath483 with @xmath485 , obtaining @xmath486 which describes all the substitutions that satisfy both @xmath58 and @xmath162 . after each variable typing in @xmath361",
    "is processed , results from different variable typings are joined together using set union .",
    "the overall downward propagation function @xmath487 is defined    @xmath488    [ ex : mdown ] let @xmath489 , @xmath490 and @xmath290 be that in example  [ ex1 ] .",
    "we have @xmath491 ) = \\{\\{x{\\mapsto}\\tnat , y{\\mapsto}\\ttop\\}\\}$ ] and @xmath492)=\\emptyset$ ] .",
    "so , @xmath493 ) =   \\{\\{x{\\mapsto}\\tnat , y{\\mapsto}\\ttop\\}\\}\\ ] ] and @xmath494\\},\\scal)}\\\\ & = &   \\{\\ { x{\\mapsto}\\ttop , y{\\mapsto}(\\tlist(\\tnat)~\\tor~\\tnat)\\}\\}\\otimes   \\{\\{x{\\mapsto}\\tnat , y{\\mapsto}\\ttop\\}\\}\\\\ & = & \\{\\mu\\}\\end{aligned}\\ ] ] where @xmath495 .    the following lemma states the correctness of downward propagation .",
    "[ lm : g ] let @xmath496",
    ". then @xmath497}_\\req)$ ] for all @xmath400}_\\req)$ ] .",
    "we now consider upward propagation of type information . the key step in upward propagation is to compute a type for a term from those of its variables .",
    "we first consider how a type rule @xmath498 can be applied to compute a type of @xmath499 from types of its top - level sub - terms @xmath500 .",
    "let @xmath501 be the type of @xmath410 .",
    "a simplistic approach would compute a type substitution @xmath302 such that @xmath502 and then return @xmath303 as the type of @xmath308 .",
    "however , this leads to loss of precision . consider the term @xmath345 $ ] and the type rule @xmath503 $ ] .",
    "let the types of @xmath340 and @xmath342 be @xmath504 and @xmath33 .",
    "then the minimal type substitution @xmath302 such that @xmath505 is @xmath506 .",
    "we would obtain @xmath507 as a type of @xmath345 $ ]",
    ". a more precise type of @xmath345 $ ] is @xmath508 .",
    "we first compute a set of type substitutions @xmath509 such that @xmath510 and then return @xmath511 as a type of @xmath499 .",
    "continue with the above example .",
    "let @xmath512 . then @xmath513 .",
    "we obtain @xmath508 as a type of @xmath345 $ ] .",
    "let @xmath514 , @xmath515 , @xmath329 , @xmath516 and @xmath517 .",
    "we say that @xmath509 is a cover for @xmath309 and @xmath297 iff @xmath518 .",
    "we say that @xmath509 is a cover for @xmath519 and @xmath520 iff @xmath521 .",
    "calculating a cover for a type and a type scheme is a key task in upward propagation of type information . before defining a function that does the computation , we need some operations on type substitutions .",
    "we first introduce an operation for calculating an upper bound of two type substitutions .",
    "it is the point - wise extension of @xmath8 when both of its operands are mappings from type parameters to types .",
    "define @xmath522 as follows .",
    "@xmath523 an operation @xmath524 that calculates a lower bound of type substitutions is defined dually : @xmath525    the following lemma states that the operations @xmath526 and @xmath527 indeed compute upper and lower bounds of two type substitutions respectively .",
    "[ p:1 ] for any @xmath514 and any @xmath528 ,    * @xmath529 ; and * @xmath530 .",
    "while the type substitution operation is a meet homomorphism according to lemma  [ p:1].(b ) , it is not a join homomorphism .",
    "for an instance , let @xmath531 , @xmath532 and @xmath533 .",
    "then @xmath534 , @xmath535 , and @xmath536 .",
    "observe that @xmath537 since the term @xmath538 $ ] has type (  ( ) ) but it does not have type @xmath539 .",
    "let @xmath540 and @xmath541 be sets of type substitutions .",
    "we say that @xmath540 and @xmath541 are equivalent , denoted as @xmath542 , iff @xmath543 for any type scheme @xmath297 .",
    "define @xmath544 as the set extensions of @xmath526 and @xmath527 respectively :    @xmath545",
    "let @xmath546 and @xmath547 .",
    "since @xmath548 and @xmath549 , we have @xmath550 we also have @xmath551 since @xmath552 .    a cover for a type sequence and a type scheme sequence",
    "can be computed compositionally according to the following lemma .",
    "[ p:2 ] let @xmath553 , @xmath329 , @xmath514 , @xmath347 and @xmath554 such that @xmath555 .",
    "if @xmath556 and @xmath557 then @xmath558 .",
    "we now consider how to compute a cover @xmath509 for a type @xmath309 and a type scheme @xmath297 . in the case",
    "@xmath435 , @xmath559 is a cover since @xmath560 ; and @xmath561 is a cover in the case @xmath562 since @xmath563 .",
    "consider the case @xmath441 , a cover @xmath564 can be recursively computed for @xmath565 and @xmath297 for @xmath566 .",
    "we have that @xmath567 and hence that @xmath568 .",
    "so , the union of @xmath540 and @xmath541 is a cover for @xmath309 and @xmath297 .",
    "consider the case @xmath569 .",
    "a cover @xmath564 can be recursively computed for @xmath565 and @xmath297 for @xmath566 .",
    "let @xmath570 .",
    "then @xmath571 . by lemma  [ p:1].(b ) , @xmath572 and hence @xmath573",
    "so , @xmath574 is a cover for @xmath309 and @xmath297 . in the case",
    "@xmath309 is atomic and @xmath297 is a type parameter , @xmath575 is a cover for @xmath309 and @xmath297 . in the remaining case , @xmath576 and @xmath577 . if @xmath578 then @xmath579 is a cover .",
    "otherwise @xmath580 is a cover . in summary , the function that computes a cover is @xmath581 defined    @xmath582",
    "let @xmath275 be given in example  [ ex1 ] .",
    "then , @xmath583    the following lemma states that @xmath584 is a cover for @xmath309 and @xmath297 .",
    "[ lm : d ] let @xmath514 , @xmath329 and @xmath585",
    ". then @xmath586 .",
    "the type of a term @xmath308 is computed from those of its variables in a bottom - up manner .",
    "the types of the variables are given by a variable typing @xmath58 .",
    "for a compound term @xmath587 , a type @xmath501 is first computed from @xmath410 and @xmath58 for each @xmath588 . each type rule for @xmath457 is applied to compute a type of @xmath308 .",
    "types resulting from all type rules for @xmath457 are conjoined using @xmath55 .",
    "the result is a type of @xmath308 since conjunctions of two or more types of @xmath308 is also a type of @xmath308 . for a type rule @xmath589 , a cover @xmath590 for @xmath501 and @xmath591",
    "is computed for each @xmath588 . joining covers for @xmath592",
    "obtains a cover @xmath509 for @xmath593 and @xmath594 .",
    "the type that is computed from the type rule is @xmath595 .",
    "define @xmath596 by @xmath597    [ ex : mup:0 ] let @xmath495 , @xmath598 and @xmath599 . by the definition of @xmath600 , @xmath601 and @xmath602 . by the definition of @xmath603 , @xmath604 and @xmath605,\\mu)=\\tlist(\\tbot)$ ] .",
    "so , @xmath606,\\mu ) } = ( \\bbbk_1\\tvallub\\bbbk_2)(\\tlist(\\beta ) ) = \\tlist(\\tnat)$ ] .",
    "the following lemma says that @xmath607 is a type that contains all the instances of @xmath308 under the substitutions described by @xmath58 .",
    "[ lm : f ] let @xmath431 and @xmath608",
    ". then @xmath609\\!\\!]}_{\\rules}}$ ] for all @xmath399 .",
    "we are now ready to present the overall upward propagation . for a set @xmath361 of variable typings and a set @xmath162 of equations in solved form",
    ", upward propagation strengthens each variable typing @xmath58 in @xmath361 as follows . for each equation @xmath610 in @xmath162 , @xmath607 is a type of @xmath340 if variables occurring in @xmath308 satisfy @xmath58 .",
    "the overall upward propagation is performed by a function @xmath611 defined @xmath612    [ ex : mup ] continue with example  [ ex : mup:0 ] .",
    "we have @xmath613\\},\\{\\mu\\ } ) & = & \\{\\mu[y{\\mapsto}((\\tlist(\\tnat)~\\tor~\\tnat)~\\tand~\\tlist(\\tnat))]\\}\\\\    & \\req & \\{\\{x{\\mapsto}\\tnat , y{\\mapsto}\\tlist(\\tnat)\\}\\ } \\end{aligned}\\ ] ]    the correctness of upward propagation is ensured by this lemma .",
    "[ lm : h ] let @xmath614 and @xmath615 .",
    "then @xmath616}_\\req)$ ] for all @xmath400}_\\req)$ ] .",
    "algorithm  [ algo : aunify ] defines the abstract unification operation @xmath272 .",
    "given two atoms @xmath270 and two abstract substitutions @xmath617}_\\req,{[\\scal_{2}]}_\\req\\in\\rsub$ ] , it first applies the renaming substitution @xmath393 to @xmath186 and @xmath618 and computes @xmath619 . if @xmath620 , it returns @xmath376}_\\req$ ]  the smallest abstract substitution which describes the empty set of substitutions",
    "otherwise , it calculates @xmath621 where @xmath622 .",
    "a variable typing represents a conjunctive type constraint . if @xmath58 and @xmath429 have disjoint domains then @xmath623 represents the conjunction of @xmath58 and @xmath429 .",
    "the first operand of @xmath624 is a set of variable typings over @xmath625 and the second operand a set of variable typings over @xmath181 .",
    "the result of @xmath624 describes the set of all the substitutions that satisfy both of its two operands .",
    "thus @xmath626 describes the set of all the substitutions that satisfy both @xmath627 and @xmath628 .",
    "note that @xmath629 .",
    "the abstract unification operation then calls a function @xmath630 to perform downward and upward propagations .",
    "the result @xmath631 is @xmath632 which describes the set of all the substitutions that satisfy both @xmath633 and @xmath626 .",
    "finally , it calls a function @xmath634 to restrict each variable typing in @xmath631 to @xmath181 .",
    "the function @xmath636 removes those variable typings that denote the empty set of substitutions and projects the remaining variable typings onto @xmath181 .",
    "let @xmath637 , @xmath638 , @xmath639 , @xmath640)$ ] , @xmath641 , and @xmath642 . then @xmath643\\}$ ] and @xmath644 with @xmath361 being that in example  [ ex : mdown ] . by examples  [ ex : mdown ] and  [ ex :",
    "mup ] , @xmath645 with @xmath58 given in example  [ ex : mup ] .",
    "the following theorem states that @xmath646 safely abstracts @xmath407 with respect to @xmath380 .",
    "[ monosafeness ] [ lm : i ] for any @xmath617}_\\req,{[\\scal_{2}]}_\\req\\in    \\rsub$ ] and any @xmath270 , @xmath647}_\\req ) ,    a_2,\\rcon({[\\scal_{2}]}_\\req ) ) }   & \\subseteq & \\rcon    ( \\munify(a_1,{[\\scal_{1}]}_\\req , a_2,{[\\scal_{2}]}_\\req ) )    \\end{aligned}\\ ] ]      for each built - in , it is necessary to specify an operation that transforms an input abstract substitution to an output abstract substitution .",
    "these operations are given in table  [ table : builtin ] where abstract substitutions are displayed as sets of variable typings .",
    "the primitive types @xmath648 , @xmath649 , @xmath650 , @xmath651 , @xmath652 and @xmath653 have their usual denotations in prolog .",
    "observe that @xmath654 and @xmath655 .",
    "unification @xmath656 is modeled by @xmath657 .",
    "let @xmath147 be the program state before the execution of @xmath656 and assume that @xmath147 satisfies @xmath361 .",
    "the program state after the execution of @xmath656 is @xmath658 and satisfies @xmath659 .",
    "built - ins such as @xmath660 succeed only if their arguments satisfy certain type constraints .",
    "such type constraints are conjoined with the input abstract substitution to obtain the output abstract substitution .",
    "for instance , the execution of @xmath661 in an input program state @xmath147 succeeds only if @xmath147 instantiates both @xmath662 and @xmath663 to numbers .",
    "so , the abstract operation for @xmath664 is @xmath665 where @xmath666 defined in section  [ sec : down ] is extended to deal with built - in types .",
    "the extension is straightforward and omitted .",
    "for another instance , @xmath667 succeeds only if @xmath308 is an atom , or a list of character codes or a string in its input program state .",
    "the above type constraint is obtained as @xmath668 .",
    "the type @xmath5 describes lists of character codes since character codes are integers .",
    "the type checking built - ins such as @xmath669 are modeled in the same way .",
    "built - ins such as ` @</2 ` do not instantiate their arguments or check types of their arguments .",
    "they are modeled by the identity function @xmath670 .",
    "the built - in @xmath671 never succeeds and hence is modeled by the constant function that always returns @xmath672 .",
    "consider a built - in to which a call @xmath673 will definitely instantiate @xmath410 to a term of type @xmath501 upon success .",
    "the type @xmath501 can be propagated downwards @xmath410 , resulting in a set of variable typings .",
    "the input abstract substitution can be strengthened by this set of variable typings to give the output abstract substitution .",
    "for an instance , consider @xmath674 .",
    "upon success , @xmath662 is either an atom or an integer and @xmath663 is a string .",
    "so , @xmath674 is modeled by @xmath675 .",
    "the built - ins @xmath676 and @xmath677 fall into this category .",
    "consider the built - in @xmath678 .",
    "the execution of @xmath678 succeeds in a program state @xmath147 iff @xmath437 is a variable .",
    "all types that contains variables are equivalent to @xmath47 .",
    "thus , the built - in @xmath678 is modeled by @xmath679 .",
    "the output abstract substitution contains only those variable typings in which @xmath308 has no type smaller than @xmath47 .",
    "the built - in @xmath680 is modeled by the identity function @xmath670 since a term being a non - variable does not provide any information about its type unless non - freeness is defined as a type . so is the built - in @xmath681 since a term being ground says nothing about its type unless groundness is defined as a type .",
    "the operation for the built - in @xmath682 makes use of the property that a compound term is not atomic .",
    "it removes from the input abstract substitution any variable typing in which @xmath308 is atomic .",
    "@p2.5in|c _ predicate _ & _ operation _",
    "+ @xmath683 , @xmath684 , @xmath685 & @xmath686 + @xmath687 , @xmath688 , @xmath689 , @xmath690 , @xmath691 , @xmath692 , @xmath693 , @xmath694 , @xmath695 , @xmath696 , @xmath697 , @xmath698 , @xmath699 , @xmath700 , @xmath701 , @xmath702 , @xmath703 , @xmath704 , @xmath705 , @xmath706 & @xmath670 + @xmath682 & @xmath707 + @xmath708 & @xmath709 + @xmath710 & @xmath711 + @xmath712 & @xmath713 + @xmath714 , @xmath715 , @xmath716 & @xmath717 + @xmath718 & @xmath719 + @xmath720 & @xmath721 + @xmath722 & @xmath723 + @xmath678 & @xmath724 + @xmath656 , @xmath725 & @xmath657 +    @xmath667 , @xmath726 , @xmath727 & @xmath728 + @xmath729 , @xmath730 , @xmath731 , @xmath732 , @xmath733 , @xmath734 , @xmath735 & @xmath736 + @xmath676 & @xmath737 + @xmath677 & @xmath738 + @xmath674 & @xmath739 +",
    "we have implemented a prototype of our type analysis in swi - prolog .",
    "the prototype is a meta - interpreter using ground representations for program variables .",
    "the prototype supports the primitive types @xmath648 , @xmath649 , @xmath650 , @xmath651 , @xmath652 and @xmath653 with their usual denotations in prolog .",
    "[ ex : intersect ] the following is the intersect program that computes the intersection of two lists and its analysis result .",
    "lists are defined in example  [ ex1 ] .",
    "abstract substitutions are displayed as comments .",
    "the abstract substitution associated with the entry point of the query is an analysis input whilst all other abstract substitutions are analysis outputs .",
    "sets are displayed as lists .",
    "a binding @xmath740 is written as @xmath741 , @xmath8 as @xmath742 and @xmath55 as @xmath743 .",
    "the code for the predicate member/2 is omitted .    .... : -   % [ [ x / list(atom or float),y",
    "/ list(atom or integer ) ] ]    intersect(x , y , z ) .",
    "% [ [ x / list(atom or float),y",
    "/ list(atom or integer),z / list(atom ) ] ]    intersect([],l , [ ] ) .",
    "% [ [ l / list(atom or integer ) ] ] intersect([x|xs],ys,[x|zs ] ) : -      % [ [ x / atom , xs / list(atom or float),ys / list(atom or integer ) ] ,      % [ x / float , xs / list(atom or float),ys / list(atom or integer ) ] ]    member(x , ys ) ,      % [ [ x / atom , xs / list(atom or float),ys / list(atom or integer ) ] ]    intersect(xs , ys , zs ) .      % [ [ x / atom , xs / list(atom or float),ys",
    "/ list(atom or integer ) ,      %   zs / list(atom ) ] ] intersect([x|xs],ys , zs ) : -      % [ [ x / atom , xs / list(atom or float),ys / list(atom or integer ) ] ,      % [ x / float , xs / list(atom or float),ys / list(atom or integer ) ] ]    \\+ member(x , ys ) ,      % [ [ x / float , xs / list(atom or float),ys / list(atom or integer ) ] ,      % [ x / atom , xs / list(atom or float),ys / list(atom or integer ) ] ]    intersect(xs , ys , zs ) .      % [ [ x / float , xs / list(atom or float),ys / list(atom or integer ) ,      %   zs / list(atom ) ] ,      % [ x / atom , xs / list(atom or float),ys",
    "/ list(atom or integer ) ,      %   zs / list(atom ) ] ] ....    the result shows that the intersection of a list containing atoms and float numbers and another list containing atoms and integer numbers is a list of atoms .",
    "this is precise because the type @xmath744 is equivalent to the type @xmath652 . without the set operators @xmath55 and @xmath8 in their type languages , previous type analyses with",
    "_ a priori _ type definitions can not produce a result as precise as the above .",
    "the following is a program @xmath745 .",
    "the analysis result is displayed with the typing binding @xmath746 omitted for any variable @xmath340 .    .... p ( [ ] ) .",
    "% [ [ ] ]    p([x|y ] ) : -      % [ [ ] ]    integer(x ) ,      % [ [ x / integer ] ]    p(y ) .      % [ [ x / integer , y / list(or(atom , integer ) ) ] ]    p([x|y ] ) : -      % [ [ ] ]    atom(x ) ,      % [ [ x / atom ] ]    p(y ) .",
    "% [ [ x / atom , y / list(or(atom , integer ) ) ] ]    : -   % [ [ ] ]     p(u ) .",
    "% [ [ u / list(or(atom , integer ) ) ] ] ....    the result captures precisely type information in the success set of the program , that is , @xmath747 is a list consisting of integers and atoms upon success of p(u ) .    during analysis of a program ,",
    "the analyzer repeatedly checks if two sets of variable typings are equivalent and if a set of variable typings contains redundant elements .",
    "both of these decision problems are reduced to checking if a given type denotes the empty set of terms .",
    "type rules in @xmath290 are production rules for a context - free tree grammar in restricted form  @xcite . according to  @xcite ,",
    "if @xmath47 denotes the set of all ground terms instead of all terms then each type denotes a regular tree language .",
    "we now show how an algorithm in  @xcite can be used for checking the emptiness of types .",
    "we first extend the type language with the complement operator @xmath748 and define @xmath749 .",
    "observe that @xmath750 and that @xmath306\\!\\!]}_{\\rules}}$ ] is not defined for elements in @xmath751 .",
    "since the algorithm in  @xcite was developed for checking the emptiness of types that denote sets of ground terms , we need to justify its application by closing the gap between the two different semantics of types .",
    "this is achieved by extending the signature @xmath116 with an extra constant @xmath752 ( @xmath753 ) that is used to encode variables in terms .",
    "use of extended signatures in analysis of logic programs can be traced to  @xcite where extra constants are used to encode non - ground terms .",
    "in fact , by introducing an infinite set of extra constants one can obtain an isomorphism between the set of all terms in the original signature and the set of the ground terms in the extended signature .",
    "the meaning of a type in @xmath754 is given by a function @xmath755 .",
    "@xmath756    there are two differences between @xmath757 and @xmath306\\!\\!]}_{\\rules}}$ ] .",
    "firstly , @xmath748 is interpreted as set complement under @xmath757 whilst it has no denotation under @xmath306\\!\\!]}_{\\rules}}$ ] .",
    "type constructor @xmath748 can be interpreted as set complement by @xmath757 because @xmath758 is a regular tree language for any @xmath759  @xcite .",
    "it can not be interpreted as set complement by @xmath306\\!\\!]}_{\\rules}}$ ] because the complement of @xmath760\\!\\!]}_{\\rules}}$ ] is not closed under instantiation .",
    "secondly , the universal type @xmath47 denotes @xmath761 in @xmath306\\!\\!]}_{\\rules}}$ ] whilst it denotes @xmath762 in @xmath757 .",
    "an implication is that a type denotes a set of terms closed under instantiation under @xmath306\\!\\!]}_{\\rules}}$ ] whilst it denotes a set of ground terms under @xmath757 .",
    "let @xmath763 be defined @xmath764 for all @xmath318 and @xmath765 .",
    "the function @xmath766 transforms a term into a ground term by replacing all variables in the term with the same constant @xmath752 .",
    "the following theorem states that , given a term @xmath308 and a type @xmath309 , the membership of @xmath308 in @xmath760\\!\\!]}_{\\rules}}$ ] is equivalent to that of @xmath767 in @xmath758 .",
    "[ th : eq ] for any term @xmath308 in @xmath761 and any type @xmath309 in @xmath339 , @xmath310\\!\\!]}_{\\rules}}$ ] iff @xmath768 .    as a consequence , checking the emptiness of a type under @xmath306\\!\\!]}_{\\rules}}$ ] can be reduced to checking the emptiness of the type under @xmath757 , and vice versa . therefore",
    ", whether @xmath760\\!\\!]}_{\\rules}}=\\emptyset$ ] can be decided by employing the algorithm developed in  @xcite that checks if @xmath769 . the following corollary of the theorem allows us to reduce a type inclusion test under @xmath306\\!\\!]}_{\\rules}}$ ] to a type inclusion test under @xmath757 .",
    "[ co : eq ] for any @xmath770 , @xmath771\\!\\!]}_{\\rules}}\\subseteq{{[\\!\\![\\rt_2]\\!\\!]}_{\\rules}}$ ] iff @xmath772 .    in order to reduce the decision problems to the emptiness of types , we need to extend the syntax for type sequence expressions with the operator @xmath748 and @xmath757 to type sequences .",
    "the expression @xmath773 is a type sequence expression whenever @xmath774 is a type sequence expression .",
    "let @xmath309 be a type in @xmath754 , @xmath775 a type sequence in @xmath776 , @xmath348 and @xmath349 be type sequence expressions .",
    "define @xmath777 , @xmath778 , @xmath779 , @xmath780 and @xmath781 .",
    "it can be shown that both theorem  [ th : eq ] and corollary  [ co : eq ] carry over to type sequence expressions that do not contain @xmath748 .",
    "set inclusion and @xmath757 induces an equivalence between types and type sequence expressions . let @xmath782 iff @xmath783 and @xmath784 iff @xmath785 .",
    "the following function eliminates the complement operator @xmath748 over type sequence expressions . @xmath786",
    "it follows from de morgan s law and the definition of @xmath757 that @xmath787 .",
    "note that the complement operator @xmath748 does not apply to any type sequence expression in @xmath788 ; it only applies to type expressions .",
    "let @xmath759 and define @xmath789 .",
    "the formula @xmath790 is true iff @xmath791 is true . by theorem",
    "[ th : eq ] , if @xmath329 then @xmath790 is true iff @xmath792 is true .",
    "an indispensable operation in a static analyzer is to check if a fixpoint has been reached .",
    "this operation reduces to checking if two sets of variable typings denote the same set of concrete substitutions .",
    "this equivalence test is reduced to checking emptiness of types as follows .",
    "let @xmath793 and @xmath794 . by definition ,",
    "@xmath795 iff @xmath796 and @xmath797 .",
    "suppose @xmath798 and @xmath799 .",
    "we construct @xmath800 and @xmath801 as follows .",
    "@xmath802 and @xmath803 .",
    "then @xmath796 is true iff @xmath804 is true . by corollary  [ co : eq ] , @xmath805 is true iff @xmath806 is true .",
    "the latter can be reduced to emptiness of types as shown in  @xcite .",
    "[ ex : eq ] let @xmath290 be given as in example  [ ex1 ] , @xmath807 , @xmath808 and @xmath809 where @xmath810 the truth value of @xmath811 is decided by testing emptiness of types as follows .",
    "let @xmath812 then @xmath811 iff @xmath813 which , by replacing @xmath814 with @xmath815 and distributing @xmath816 over @xmath8 , is equivalent to the conjunction of the following formulas . @xmath817",
    "the first of the above holds iff either @xmath818 or @xmath819 , both of which are emptiness tests on types .",
    "since @xmath819 , the first formula is decided to be true .",
    "the other three can be decided to be true similarly .",
    "therefore , @xmath811 holds . in a similar way",
    ", we can show that @xmath820 holds .",
    "so , @xmath795 .      for the sake of an efficient implementation , an abstract substitution @xmath821}_\\req$ ] should be represented by a set of variable typings that does not contain redundancy .",
    "a set of variable typings can be redundant in two ways .",
    "firstly , a variable typing @xmath58 in @xmath361 may denote the empty set of substitutions i.e. , @xmath822 for some @xmath823 .",
    "secondly , a variable typing @xmath58 in @xmath361 can be subsumed by other variable typings in that @xmath824 . in both cases ,",
    "@xmath825 and @xmath361 denote the same set of substitutions and @xmath58 can be removed from @xmath361 .",
    "suppose @xmath793 .",
    "the detection of @xmath826 reduces to @xmath827 while the detection of @xmath824 can be reduced to checking emptiness of types as in section  [ sec : equiv ] .",
    "let @xmath290 be given example  [ ex1 ] , @xmath807 , @xmath828 where @xmath829 we now show how @xmath830 is decided to be redundant in @xmath361 .",
    "let @xmath831 then @xmath832 holds iff @xmath833 holds iff @xmath834 holds .",
    "the latter , after replacing @xmath835 and @xmath836 with @xmath837 and @xmath838 respectively and distributing @xmath816 over @xmath8 , is equivalent to the conjunction of the following formulas . @xmath839",
    "each of the above can be decided to be true by testing emptiness of types as in example  [ ex : eq ] .",
    "therefore , @xmath830 is redundant in @xmath361 . in a similar way",
    ", @xmath840 is decided to be redundant in @xmath841 .",
    "so , @xmath842 . that @xmath843 is not redundant in @xmath361 is decided similarly .",
    "the operations in our type analysis are complex because of non - deterministic type definitions and non - discriminative union at both the level of types and the level of abstract substitutions .",
    "the equality of two abstract substitutions in an analysis without these features can be done in linear time  @xcite .",
    "the same operation is exponential in our type analysis because deciding the emptiness of a type is exponential .",
    "this indicates that our type analysis could be much more time consuming .",
    "as shown later , there is a high degree of repetition in emptiness checks during the analysis of a program .",
    "making use of this observation , we have reduced time increase to 15% on average using a simple tabling technique .",
    "we memoize each call to @xmath844 and its success or failure by asserting a fact @xmath845 .",
    "the fact @xmath846 ( resp .",
    "@xmath847 ) indicates that @xmath844 has been called before and @xmath844 succeeded ( resp",
    ". failed ) .",
    "the tabled version of @xmath844 is @xmath848 .",
    "it first checks if a fact @xmath845 exists .",
    "if so , the call @xmath848 succeeds or fails immediately .",
    "otherwise , it calls @xmath844 and memoizes its success or failure .",
    "we now present some experimental results with the prototype analyzer .",
    "the experiments were done with a pentium ( r ) 4 cpu 2.26 ghz running gnu / linux and swi - prolog-5.2.13 .",
    "table  2 shows analysis time on a suite of benchmark programs .",
    "each row except the last one corresponds to a test case .",
    "the first three columns contain the name , the size of the program in terms of the number of program points and the top - level goal .",
    "the top abstract substitution which contains no type information is used as the input abstract substitution for each test case .",
    "these test cases will be used in subsequent tables where only the program names are given .",
    "the fourth column gives analysis time in milliseconds .",
    "the time is obtained by running the analyzer ten times on the test case and averaging analysis time from these runs .",
    "timing data in other tables are also obtained in this way .",
    "the table shows that the analyzer takes an average of 1.27 milliseconds per program point .",
    "browse&103&q&110 + cs_r&277&pgenconfig(c)&661 + disj_r&132&top(k)&171 + dnf&77&go&200 + kalah&228&play(g , r)&590 + life&100&life(mr , mc , lc , sfg)&89 + meta&89&interpret(g)&50 + neural&341&go&250 + nbody&375&go(m , g)&281 + press&318&test_press(x , y)&161 + serialize&37&go(s)&80 + zebra&43&zebra(e , s , j , u , n , z , w)&40 + & sum = 2120&&sum = 2683 +      table  3 shows that there is a high degree of repetition in emptiness checks during analysis .",
    "each test case corresponds to a row of the table .",
    "the first column of the row is the name of the program , the second is the total number of emptiness checks that occur during analysis .",
    "the third column gives the number of different types that are checked for emptiness .",
    "the fourth column gives the average repetition of emptiness checks , which is the ratio of the second and the third columns . while the total number of emptiness checks can be very large for a test case , the number of different emptiness checks is small , exhibiting a high degree of repetition in emptiness checks .",
    "the repetition of the emptiness checks ranges from 36.00 to 698.88 .",
    "the weighted repetition average is about 192.23 .",
    "this motivated the use of tabling to reduce the time spent on emptiness checks .",
    "& checks & checks & repetition + browse&3050&64&47.65 + cs_r&23846&53&449.92 + disj_r&4500&37&121.62 + dnf&6290&9&698.88 + kalah&31182&86&362.58 + life&3277&24&136.54 + meta&468&13&36.00 + neural&7985&131&60.95 + nbody&8567&39&219.66 + press&1734&23&75.39 + serialize&2019&37&54.56 + zebra&947&22&43.04 + & & & ave.=192.23 +      table  [ tab : tabling ] illustrates the effect of tabling .",
    "statistics are obtained by running the analyzer with and without tabling . for both experiments",
    ", we measured analysis time and time spent on emptiness checks .",
    "the table shows that tabling reduces analysis time to @xmath849 .",
    "the table also gives the proportion of analysis time that is spent on emptiness checks .",
    "an average of 53% of analysis time is spent on emptiness checks without tabling while only a negligible portion of analysis time is spent on emptiness checks with tabling .",
    "program & analysis & check & & analysis & check & + & time & time & proportion & time & time & proportion + browse&110&10&0.09&269&129&0.47 + cs_r&661&0&0&1700&891&0.52 + disj_r&171&0&0&359&157&0.43 + dnf&200&0&0&581&363&0.62 + kalah&590&0&0&1939&1124&0.57 + life&89&0&0&210&117&0.55 + meta&50&0&0&60&21&0.35 + neural&250&30&0.12&731&469&0.64 + nbody&281&0&0&620&314&0.50 + press&161&0&0&250&29&0.11 + serialize&80&0&0&179&82&0.45 + zebra&40&0&0&70&31&0.44 + & sum=2683 & & ave.=0.01&sum=6968 & & ave.=0.53 +     & analysis & analysis & ratio & ratio + & time & time & & + browse&100.00&110.00&0.90 & 0.74 + cs_r&589.00&661.00&0.89 & 0.77 + disj_r&151.00&171.00&0.88 & 0.73 + dnf&190.00&200.00&0.95 & 0.00 + kalah&420.00&590.00&0.71 & 0.49 + life&89.00&89.00&1.00 & 0.35 + meta&40.00&50.00&0.80 & 0.05 + neural&200.00&250.00&0.80 & 0.49 + nbody&231.00&281.00&0.82 & 0.23 + press&159.00&161.00&0.98 & 0.95 + serialize&80.00&80.00&1.00 & 0.83 + zebra&40.00&40.00&1.00 & 0.35 + & & & ave .",
    "= 0.85 & ave .",
    "= 0.54 +      the precision improvement features in our type analysis all incur some performance penalty . in order to evaluate the effect of these features",
    ", we also implemented a simplified type analysis .",
    "the simplified analysis is obtained by removing the precision improvement features from the full - fledged analysis . in the simplified analysis ,",
    "type expressions do not contain the constructors @xmath8 or @xmath55 ; an abstract substitution is simply a variable typing ; and non - deterministic type definitions are disallowed .",
    "function overloading is still allowed .",
    "abstract operations are simplified accordingly .",
    "for instance , since @xmath850 is not in the type language of the simplified analysis , the least upper bound of @xmath851 and @xmath852 is @xmath853 .",
    "the least upper bound operation on abstract substitutions is the point - wise extension of the least upper bound operation on types .",
    "table  [ tab : compare ] compares two type analyses .",
    "the two analyses are performed on each test case with the same input type information .",
    "the input abstract substitution for the full - fledged analysis is a singleton set of a variable typing .",
    "the corresponding abstract substitution for the simplified analysis is the variable typing . for each test case ,",
    "the table gives analysis times by the two analyzers and their ratio .",
    "the relative performance of the two analyzers varies with the test case . on average ,",
    "the simplified analysis takes 85 percent of the analysis time of the full - fledged type analysis .",
    "this illustrates that the precision improvement features does not substantially increase analysis time .    the fifth column in table  [ tab : compare ] gives information about the effect of the precision improvement features . for each program",
    ", it lists the ratio of the number of the program points at which the full - fledged analysis derives more precise type information than the simplified analysis over the number of all program points . whether or not these features improve analysis precision depends on the program that is analysed . for some programs like dnf and meta ,",
    "there is little or no improvement .",
    "for some other programs like press and serialize , there is a substantial improvement . on average ,",
    "the full - fledged analysis derives more precise type information at 54% of the program points in a program .",
    "this indicates that the precision improvement features is cost effective .",
    "the abstract domain of our type analysis contains chains of infinite length , which may lead to non - termination of the analysis of a program .",
    "[ ex : ter ] let the program consist of a single clause ` p(x ) : - \\circledast p([x ] ) ` where @xmath854 is a label of a program point .",
    "let the query be of the form ` : - p(u ) ` with @xmath855 being of type @xmath341 .",
    "then @xmath340 is a term of type @xmath856 at the @xmath857 time the execution reaches the program point @xmath854 .",
    "thus , the chain of the abstract substitutions at the program point @xmath854 is @xmath858 which is infinite .",
    "the program is an instance of polymorphic recursion  @xcite which is prohibited in ml .",
    "the analyzer uses a canonical representation of types and a depth abstraction to ensure termination .",
    "a conjunctive type is compact if it contains no duplicated type atoms .",
    "a type in disjunctive normal form is compact if it contains no duplicated conjuncts and all of its conjuncts are compact .",
    "a type is canonical if it is in disjunctive normal form , it is compact and all arguments of its type atoms are canonical . for every type @xmath309 , a canonical equivalent of @xmath309 ",
    "a canonical type @xmath859 such that @xmath860  can be obtained as follows . a disjunctive normal form @xmath861 of @xmath309 is first computed .",
    "each argument of each type atom in @xmath861 is then replaced with its canonical equivalent , resulting in a type @xmath862 .",
    "finally , @xmath859 is obtained by deleting duplicate type atoms in each conjunct of @xmath862 and then deleting duplicate conjuncts .",
    "let @xmath863 denote the canonical equivalent of @xmath309 obtained by the above procedure .",
    "for instance , @xmath864 .",
    "let @xmath309 be a type .",
    "an atomic sub - term @xmath865 of @xmath309 is both a sub - term of @xmath309 and a type atom .",
    "the depth of @xmath865 in @xmath309 is the number of the occurrences of type constructors in @xmath275 on the path from the root of @xmath309 to but excluding the root of @xmath865 .",
    "thus , the depth of the only occurrence of @xmath852 in @xmath866 is 3 and the depth of the only occurrence of @xmath867 in the same type is 2 . note that type constructors @xmath55 and @xmath8 are ignored in determining the depth of @xmath865 in @xmath309 .",
    "if the depth of @xmath865 in @xmath309 is @xmath454 then @xmath865 is called an atomic sub - term of @xmath309 at depth @xmath454 .",
    "the depth of @xmath309 is defined as the maximum of the depths of all its atomic sub - terms .",
    "let @xmath309 be a type and @xmath454 a positive integer .",
    "the depth @xmath454 abstraction of @xmath309 , denoted as @xmath868 , is the result of replacing each argument of any atomic sub - term of @xmath309 at depth @xmath454 by @xmath47 .",
    "for instance , @xmath869    during analysis , the abstract substitution for a program point is initialized to the empty set of variable typings .",
    "it is updated by adding new variable typings and removing redundant ones .",
    "the analyzer ensures termination as follows . for each program point",
    ", the analyzer determines a depth @xmath454 the first time a non - empty set of variable typings @xmath870 is added .",
    "the depth @xmath454 is the maximum of the depths of the types occurring in @xmath870 plus some fixed constant @xmath871 with @xmath872 .",
    "after that , each time a set of variable typings @xmath361 is added , each type @xmath309 occurring in @xmath361 is replaced by @xmath873 .",
    "the above abstraction preserves analysis correctness because @xmath874 and @xmath875 .",
    "the number of depth @xmath454 abstractions of the canonical types occurring in the abstract substitution is bounded and so is the number of variable typings in the abstract substitution .",
    "this ensures termination .",
    "continue example  [ ex : ter ] and let @xmath876 .",
    "we have @xmath877 and hence @xmath878 since the depth of the only type @xmath852 in @xmath870 is 1 .",
    "the chain of the abstract substitutions for the program point @xmath854 is @xmath879 the last in the chain is the final abstract substitution for the program point @xmath854 .",
    "there is a rich literature on type inference analysis for logic programs .",
    "type analyses in  @xcite are performed without _ a priori _ type definitions .",
    "they generate regular tree grammars , or type graphs  @xcite or set constraints  @xcite as type definitions .",
    "these different formalisms for expressing type definitions are equivalent .",
    "a type graph is equivalent to a regular tree grammar such that a production rule in the grammar corresponds to a subgraph that is composed of a node and its successors in the graph . for a system of set constraints",
    ", there is a regular tree grammar that generates the least solution to the system of set constraints , and vice versa  @xcite .",
    "the production rules in a regular tree grammar are similar to type rules used in our analysis but are not parameterized .",
    "this kind of analysis is useful for compiler - time optimizations and transformations but inferred type definitions can be difficult for the programmer to interpret . like those in  @xcite , our type analysis is performed with _ a priori _ type definitions .",
    "the type expressions it infers are formed of given type constructors . since the meaning of a type constructor",
    "is given by _",
    "a priori _ type definitions that are well understood to the programmer , the inferred types are easier for the programmer to interpret and thus they are more useful in an interactive programming environment .    the type analyses with _ a priori _ type definitions in  @xcite are based on top - down abstract interpretation frameworks .",
    "they are performed with a type description of possible queries as an input and are thus goal - dependent .",
    "they infer for each program point a type description of all the program states that might be obtained when the execution of the program reaches that program point .",
    "these are also characteristics of our analysis .",
    "however , these analyses do not support non - deterministic type definitions or non - discriminative union at the levels of types and abstract substitutions .",
    "the analysis in  @xcite traces non - discriminative union at the level of abstract substitutions but not at the level of types .",
    "in addition , it does not allow non - determinism in type definitions .",
    "the above mentioned top - down type analyses with _ a priori _ type definitions approximate non - discriminative union of two types by their least upper bound .",
    "the least upper bound may have a strictly larger denotation than the set union of the denotations of the two types since set union is not a type constructor .",
    "thus , our type analysis is strictly more precise than  @xcite .",
    "the type analyses with _ a priori _ type definitions in  @xcite are based on bottom - up abstract interpretaion frameworks .",
    "they infer a type description of the success set of the program .",
    "the inferred type description is a set of type atoms each of which is a predicate symbol applied to a tuple of types .",
    "some general remarks can be made about the differences between our analysis and these analyses .",
    "firstly , our analysis is goal - dependent while these analyses are goal - independent .",
    "secondly , our analysis allows non - deterministic type definitions that are disallowed by these analyses .",
    "consequently , more natual typings are allowed by our type analysis than by these analyses .",
    "however , non - deterministic type definitions also make abstract operations in our analysis more complex than in these analyses .",
    "thirdly , like our analysis , these analyses can express non - discriminative union at the level of predicates .",
    "for example , the two type atoms @xmath880 and @xmath881 express the same information as @xmath882 in our type analysis . however , these analyses except an informal proposal in  @xcite can not trace non - discriminative union at the level of arguments , which leads to imprecise analysis results .",
    "for instance , the inferred type for the concrete atom @xmath883)$ ] is @xmath884 according to  @xcite and the main proposal in  @xcite .",
    "the inferred type @xmath884 is less precise than @xmath885 which is inferred by our type analysis .",
    "lastly , as a minor note , set intersection is not used as a type constructor in these type analyses except  @xcite . the two type clauses @xmath886 and @xmath887 in an abstract substitution of  @xcite indicates that @xmath340 is both a list and a tree .",
    "some comparisons on other aspects between our type analysis and these bottom - up analyses are in order .",
    "barbuti and giacobazzi   infer polymorphic types of horn clause logic programs using a bottom - up abstract interpretation framework  @xcite .",
    "the type description of the success set of a horn logic program is computed as the least fixed - point of an abstract immediate consequence operator associated with the program .",
    "the abstract immediate consequence operator is defined in terms of abstract unification and abstract application .",
    "abstract unification computes an abstract substitution given a term and a type .",
    "abstract application computes a type given an abstract substitution and a term .",
    "both computations are derivations of a prolog program that is derived from _ a priori _ type definitions .",
    "the inferred type description describes only part of the success set of the program though abstract operations can be modified so that the type description approximates the whole success set .",
    "ill - typed atoms are not described by the type description . nor are those well - typed atoms that possess only ill - typed sld resolutions .",
    "an sld resolution is ill - typed if any of its selected atoms is ill - typed .",
    "their type definitions are slightly different form ours .",
    "for instance , they define the type of the empty list @xmath3 $ ] as @xmath3 \\rightarrow \\tlist(\\bot)$ ] which is equivalent to @xmath888 $ ] in our notation whilst the empty list @xmath3 $ ] is typed by @xmath889 $ ] in our analysis .",
    "barbuti and giacobazzi also informally introduced and exemplified an associative , commutative and idempotent operator @xmath890 that expresses non - deterministic union at the level of types .",
    "however , abstract unification and abstract application operations for this modified domain of types are not given .",
    "in addition , it requires changing type definitions , for instance , from @xmath891 to @xmath892 .",
    "barbuti and giacobazzi s analysis captures more type dependency than ours .",
    "this is achieved through type parameters .",
    "for instance , the type description for the program @xmath893)\\leftarrow\\}$ ] is @xmath894 .",
    "abstract unification of the query @xmath895 with the only type atom in the type description yields the abstract substitution @xmath896 , this kind of type dependency will be lost in our analysis .",
    "the use of type parameters and the use of non - discriminative union are orthogonal to each other and it is an interesting topic for future research to combine them for more analysis precision .",
    "codish and demoen   apply abstract compilation  @xcite to infer type dependencies by associating each type with an incarnation of the abstract domain @xmath897  @xcite .",
    "the incarnations of @xmath898 define meanings of types and capture interactions between types .",
    "the type dependencies of a logic program is similar to the type description of the program inferred by the type analysis of barbuti and giacobazzi   except that the type dependencies describe the whole success set of the program .",
    "codish and lagoon   improve  @xcite by augmenting abstract compilation with aci - unification .",
    "an associative , commutative and idempotent operator @xmath899 is introduced to form the type of a term from the types of its sub - terms .",
    "it has the flavor of set union .",
    "nevertheless , it does not denote the set union .",
    "for an example , the term @xmath900 $ ] has type @xmath901 according to  @xcite while it has type @xmath902 in our type analysis . like  @xcite ,",
    "type analyses in  @xcite capture type dependency via type parameters .",
    "in addition , they have the desired property of condensing which our analysis does not have .",
    "hill and spoto   provide a method that enriches an abstract domain with type dependency information .",
    "the enriched domain contain elements like @xmath903 meaning if @xmath340 has type @xmath341 then @xmath342 has type @xmath852 .",
    "each element in the enriched domain is represented as a logic program .",
    "type analysis is performed by abstract compilation .",
    "their approach to improving precision of type analysis is different from ours .",
    "their domain can express type dependencies that ours can not whilst our domain can express non - discriminative union at the level of types but theirs can not .",
    "hill and spoto do not take subtyping into account in their design of abstract operations possibly because subtyping is outside the focus of their work .",
    "gallagher and de waal   approximates the success set of the program by a unary regular logic program  @xcite .",
    "this analysis infers both type definitions and types and is incorporated into the ciao system  @xcite .",
    "saglam and gallagher   extend  @xcite by allowing the programmer to supply deterministic type definitions for some function symbols .",
    "the supplied type definitions are used to transform the program and the transformed program is analyzed as in  @xcite .",
    "an interesting topic for further study is to integrate non - deterministic type definitions and non - discriminative union into  @xcite and evaluate their impact on analysis precision and analysis cost .    finally , it is also worthy mentioning work on directional types  @xcite .",
    "aiken and lakshman   present an algorithm for automatic checking directional types of logic programs .",
    "directional types describe both the structure of terms and the directionality of predicates .",
    "a directional type for a predicate @xmath904 is of the form @xmath905 .",
    "type @xmath906 is called an input type and type @xmath907 an output type .",
    "they are type tuples of dimension @xmath85 .",
    "the directional type expresses two requirements .",
    "firstly , if @xmath904 is called with an argument of type @xmath908 then the argument has type @xmath909 upon its success .",
    "secondly , each predicate @xmath910 invoked by @xmath121 is called with an argument that has the input type of a directional type for @xmath910 .",
    "a program is well - typed with respect to a collection of directional types if each directional type in the collection is verified .",
    "the type checking problem is reduced to a decision problem on systems of inclusion constraints over set expressions .",
    "the algorithm is sound and complete for discriminative directional types .",
    "charatonik and podelski   provide an algorithm for inferring directional types with respect to which the program is well - typed .",
    "we have presented a type analysis .",
    "the type analysis supports non - deterministic type definitions , allows set operators in type expressions , and uses a set of variable typings to describe type information in a set of substitutions .",
    "the analysis is presented as an abstract domain and four abstract operations for nilsson s abstract semantics  @xcite extended to deal with negation and built - in predicates .",
    "these operations are defined in detail and their local correctness proved .",
    "the abstract unification involves propagation of type information downwards and upwards the structure of a term .",
    "given a set of equations in solved form and an abstract substitution , abstract unification is accomplished in two steps . in the first step , more type information for variables occurring on the right - hand side of each equation is derived from type information for the variable on the left - hand side .",
    "the second step derives more type information for the variable on the left - hand side of each equation from type information for the variables on the right - hand side .",
    "the abstract built - in execution operation approximates the execution of built - in predicates .",
    "each built - in is modeled as a function of abstract substitutions .",
    "detection of the least fixpoint and elimination of redundancy in a set of variable typings are both reduced to checking the emptiness of types .",
    "though types denote sets of possibly non - ground terms and are not closed under set complement , checking the emptiness of types can be done by using an algorithm that checks for the emptiness of the types that denote sets of ground terms .",
    "an experimental study shows that due to a large repetition of emptiness checks , with tabling , the precision improvement measures incurs only a small increase in analysis time .",
    "[ [ acknowledgments ] ] acknowledgments : + + + + + + + + + + + + + + + +    the work is supported in part by the national science foundation under grants ccr-0131862 and int-0327760 . a preliminary version of this article appeared , under the title `` a precise type analysis of logic programs '' , in _ proceedings of the second international acm sigplan conference on principles and practice of declarative programming _ ,",
    "montreal , canada , 2000 .",
    "we would like to thank anonymous reviewers for insightful comments on previous drafts of this report .",
    "let @xmath911 denote the set of natural numbers .",
    "define @xmath912 as follows .",
    "@xmath913 for all @xmath318 and @xmath914 .",
    "define @xmath915 in the same way . note @xmath916 for any @xmath329",
    "let @xmath917 .        basis .",
    "we have that @xmath919 and that @xmath920 .",
    "so , @xmath921 which implies @xmath435 since @xmath310\\!\\!]}_{\\rules}}$ ] and @xmath920 .",
    "thus , @xmath760\\!\\!]}_{\\rules}}=\\term$ ] and @xmath331\\!\\!]}_{\\rules}}$ ] .",
    "either that @xmath919 or that @xmath922 .",
    "consider the case where @xmath919 first . then @xmath921 . either ( i ) @xmath435 ; ( ii ) @xmath923 ; or ( iii ) @xmath450 .",
    "the case ( i ) is a special case of the base case .",
    "consider the case ( ii ) .",
    "we have either that @xmath924\\!\\!]}_{\\rules}}$ ] or that @xmath925\\!\\!]}_{\\rules}}$ ] . if @xmath926\\!\\!]}_{\\rules}}$ ] then , by induction hypothesis , @xmath927\\!\\!]}_{\\rules}}$ ] for @xmath566 since @xmath928 .",
    "so , @xmath331\\!\\!]}_{\\rules}}$ ] by the definition of @xmath306\\!\\!]}_{\\rules}}$ ] .",
    "the case ( iii ) is symmetric to the case ( ii ) .",
    "thus , @xmath331\\!\\!]}_{\\rules}}$ ] .    now consider the case where @xmath922 .",
    "then @xmath453 . either ( i ) @xmath435 ; ( ii ) @xmath923 ; ( iii ) @xmath450 ; or ( iv ) @xmath576 . the proof for that @xmath331\\!\\!]}_{\\rules}}$ ] in the cases ( i ) , ( ii ) and ( iii )",
    "is the same as in the previous paragraph . consider the case ( iv ) .",
    "since @xmath310\\!\\!]}_{\\rules}}$ ] , there is a type rule @xmath929 such that @xmath930\\!\\!]}_{\\rules}}$ ] where @xmath931 .",
    "we have that @xmath932 and that @xmath933 . by the induction hypothesis , @xmath934\\!\\!]}_{\\rules}}$ ] ,",
    "which together with the definition for @xmath306\\!\\!]}_{\\rules}}$ ] , implies that @xmath331\\!\\!]}_{\\rules}}$ ] .      since , @xmath935}_\\req)=\\ctop$ ] and @xmath936 is the supremum on @xmath937 , @xmath381 contains the supremum on @xmath937",
    "let @xmath938}_\\req,{[\\scal_2]}_\\req\\in\\rsub$ ]",
    ". then @xmath938}_\\req\\rglb{[\\scal_2]}_\\req\\in\\rsub$ ] .",
    "furthermore , @xmath939}_\\req\\rglb{[\\scal_2]}_\\req ) & = &     \\rcon({[\\scal_1^{\\downarrow}\\cap\\scal_2^{\\downarrow}]}_\\req)\\\\ & = & ( \\bigcup_{\\mu\\in\\scal_1^{\\downarrow}}\\vtcon(\\mu))\\cap       ( \\bigcup_{\\nu\\in\\scal_2^{\\downarrow}}\\vtcon(\\nu))\\\\ & = & ( \\bigcup_{\\mu\\in\\scal_1}\\vtcon(\\mu))\\cap       ( \\bigcup_{\\nu\\in\\scal_2}\\vtcon(\\nu))\\\\ & = & \\rcon({[\\scal_1]}_\\req)\\cap\\rcon({[\\scal_2]}_\\req)\\end{aligned}\\ ] ] thus , @xmath381 is closed under @xmath940  the meet on @xmath937 .",
    "so , @xmath381 is a moore family .",
    "we first prove that @xmath392}_\\req ) \\subseteq\\rcon({[\\scal_1]}_\\req\\rglb{[\\scal_2]}_\\req)$ ] .",
    "let @xmath941}_\\req)$ ] .",
    "then there is @xmath172 in @xmath942 such that @xmath943 .",
    "this implies that there are @xmath58 in @xmath389 and @xmath944 such that @xmath945 .",
    "we have @xmath946 and @xmath947 , implying @xmath948 and @xmath949",
    ". therefore , @xmath950 . since @xmath943",
    ", we have that @xmath951}_\\req)$ ] and @xmath952}_\\req\\rglb{[\\scal_2]}_\\req)$ ] .",
    "we now prove that @xmath392}_\\req ) \\supseteq\\rcon({[\\scal_1]}_\\req\\rglb{[\\scal_2]}_\\req)$ ] .",
    "let @xmath952}_\\req\\rglb{[\\scal_2]}_\\req)$ ] .",
    "then @xmath943 for some @xmath950 by the definition of @xmath382 .",
    "there are @xmath953 and @xmath944 such that @xmath946 and @xmath947 , implying @xmath954\\!\\!]}_{\\rules}})$ ] .",
    "thus , @xmath941}_\\req)$ ] by the definition of @xmath397 .",
    "consider the case ( 1 ) .",
    "either ( i ) @xmath961 or ( ii ) @xmath923 or ( iii ) @xmath576 for some @xmath962 .",
    "the cases ( i ) and ( ii ) are immediate .",
    "consider the case ( iii ) . by the definition of @xmath306\\!\\!]}_{\\rules}}$ ] , @xmath963\\!\\!]}_{\\rules}}$ ] implies that there is a type rule @xmath929 in @xmath290 such that @xmath964\\!\\!]}_{\\rules}}$ ] where @xmath965 .",
    "we have @xmath966 . by the induction hypothesis , @xmath967}_\\req)\\ ] ] for all @xmath968 . by lemmas  [ lm : a ] and  [ lm : b ] , @xmath969}_\\req)\\ ] ] by the definition of @xmath666",
    ", we have @xmath970}_\\req)\\ ] ] thus , the lemma holds for the case ( 1 ) .",
    "let @xmath971 .",
    "it suffices to prove that @xmath972}_\\req)$ ] for all @xmath973 .",
    "@xmath974 as the denotation of any type in @xmath339 is closed under substitution . by lemma  [ lm : c ]",
    ", we have @xmath975}_\\req)$ ] for any @xmath976 in @xmath162 .",
    "so , @xmath972}_\\req)$ ] .",
    "we prove only ( a ) since the proof for ( b ) is similar to that for ( a ) .",
    "let @xmath977\\!\\!]}_{\\rules}}$ ] .",
    "either ( 1 ) @xmath978\\!\\!]}_{\\rules}}$ ] or ( 2 ) @xmath979\\!\\!]}_{\\rules}}$ ] . without loss of generality ,",
    "we assume ( 1 ) . we prove @xmath980\\!\\!]}_{\\rules}}$ ] by induction on @xmath981 .",
    "@xmath985 implies that @xmath986 . if @xmath921 then @xmath987 and hence @xmath988 and @xmath980\\!\\!]}_{\\rules}}$ ]",
    "otherwise , @xmath587 . since @xmath978\\!\\!]}_{\\rules}}$ ]",
    ", there is a type rule @xmath589 such that @xmath989\\!\\!]}_{\\rules}}$ ] for @xmath588 .",
    "we have @xmath990 and @xmath991 .",
    "thus , @xmath992\\!\\!]}_{\\rules}}$ ] by the induction hypothesis and hence @xmath980\\!\\!]}_{\\rules}}$ ] by the definition @xmath306\\!\\!]}_{\\rules}}$ ] .",
    "let @xmath993\\!\\!]}_{\\rules}}$ ] . then @xmath310\\!\\!]}_{\\rules}}$ ] and @xmath994\\!\\!]}_{\\rules}}$ ] . by assumption , there are @xmath995 such that @xmath978\\!\\!]}_{\\rules}}$ ] and @xmath996 such that @xmath997\\!\\!]}_{\\rules}}$ ]",
    ". let @xmath998 .",
    "we have @xmath999 by the definition of @xmath1000 and @xmath1001\\!\\!]}_{\\rules}}$ ] and @xmath1002\\!\\!]}_{\\rules}}$ ] by lemma  [ p:1 ] .",
    "thus , @xmath1003\\!\\!]}_{\\rules}}$ ] by the definition of @xmath306\\!\\!]}_{\\rules}}$ ] .        basis .",
    "@xmath309 is atomic .",
    "@xmath435 or @xmath562 or @xmath1004 for some @xmath477 and @xmath1005 .",
    "if @xmath435 or @xmath562 then the lemma holds by the definitions of @xmath1006 , @xmath1007 and @xmath306\\!\\!]}_{\\rules}}$ ] .",
    "let @xmath576 .",
    "either ( a ) @xmath983 or ( b ) @xmath1008 with @xmath1009 being different type parameters in @xmath281 . in the case ( a )",
    ", we have @xmath1010 with @xmath1011 .",
    "the lemma holds because @xmath1012 .",
    "consider the case ( b ) , if @xmath578 then @xmath1010 with @xmath1013 by the definition of @xmath600 and we have @xmath1012 .",
    "otherwise , @xmath1010 with @xmath1014 by the definition of @xmath600 and @xmath1015 by the definition of @xmath1006 .",
    "so , the lemma holds in the case ( b ) .",
    "either ( 1 ) @xmath923 or ( 2 ) @xmath450 . in the case",
    "( 1 ) , let @xmath1016 and @xmath1017 .",
    "we have @xmath1018\\!\\!]}_{\\rules}}\\subseteq \\bigcup_{\\bbbk\\in\\kcal_i}{{[\\!\\![\\bbbk(\\tau)]\\!\\!]}_{\\rules}}$ ] for @xmath1019 by the induction hypothesis .",
    "therefore , @xmath1020\\!\\!]}_{\\rules } } & = &     { { [ \\!\\![\\rt_1]\\!\\!]}_{\\rules}}\\cup{{[\\!\\![\\rt_2]\\!\\!]}_{\\rules}}\\\\      & \\subseteq &     \\bigcup_{\\bbbk\\in\\kcal_1}{{[\\!\\![\\bbbk(\\tau)]\\!\\!]}_{\\rules}}\\cup     \\bigcup_{\\bbbk\\in\\kcal_2}{{[\\!\\![\\bbbk(\\tau)]\\!\\!]}_{\\rules } } \\\\     & = &      \\bigcup_{\\bbbk\\in(\\kcal_1\\cup\\kcal_2)}{{[\\!\\![\\bbbk(\\tau)]\\!\\!]}_{\\rules}}\\\\     & = & \\bigcup_{\\bbbk\\in\\tvs(\\rt,\\tau)}{{[\\!\\![\\bbbk(\\tau)]\\!\\!]}_{\\rules}}\\end{aligned}\\ ] ] so the lemma holds for the case ( 1 ) . consider the case ( 2 ) .",
    "let @xmath1016 and @xmath1017 .",
    "we have @xmath1018\\!\\!]}_{\\rules}}\\subseteq \\bigcup_{\\bbbk\\in\\kcal_i } { { [ \\!\\![\\bbbk(\\tau)]\\!\\!]}_{\\rules}}$ ] for @xmath1019 by the induction hypothesis .",
    "so , @xmath1021\\!\\!]}_{\\rules } } & = &     { { [ \\!\\![\\rt_1]\\!\\!]}_{\\rules}}\\cap{{[\\!\\![\\rt_2]\\!\\!]}_{\\rules}}\\\\      & \\subseteq &     \\bigcup_{\\bbbk\\in\\kcal_1}{{[\\!\\![\\bbbk(\\tau)]\\!\\!]}_{\\rules}}\\cap     \\bigcup_{\\bbbk\\in\\kcal_2}{{[\\!\\![\\bbbk(\\tau)]\\!\\!]}_{\\rules } } \\\\     & = &      \\bigcup_{\\bbbk\\in(\\kcal_1\\bigtvalglb\\kcal_2)}{{[\\!\\![\\bbbk(\\tau)]\\!\\!]}_{\\rules}}~~\\mbox{by lemma~\\ref{p:1}.(b)}\\\\     & = & \\bigcup_{\\bbbk\\in\\tvs(\\rt,\\tau)}{{[\\!\\![\\bbbk(\\tau)]\\!\\!]}_{\\rules}}\\end{aligned}\\ ] ] thus , the lemma holds for the case ( 2 ) .",
    "let @xmath453 and @xmath1024 for @xmath1025 and @xmath399 . by the induction hypothesis , we have @xmath1026\\!\\!]}_{\\rules}}$ ] for all @xmath588",
    "let @xmath1027 be a type rule in @xmath290 and @xmath1028 .",
    "by lemma  [ lm : d ] , @xmath1018\\!\\!]}_{\\rules}}\\subseteq\\bigcup_{\\bbbk\\in\\kcal_i}{{[\\!\\![\\bbbk(\\tau_i)]\\!\\!]}_{\\rules}}$ ] .",
    "thus , @xmath1029\\!\\!]}_{\\rules}}\\subseteq \\bigcup_{\\bbbk\\in(\\bigtvallub_{1\\leq{i}\\leq{n}}\\kcal_i ) } { { [ \\!\\![\\bbbk(\\langle{{\\tau_1,\\cdots,\\tau_n}}\\rangle)]\\!\\!]}_{\\rules}}$ ] by lemma  [ p:2 ] , which implies @xmath1030\\!\\!]}_{\\rules}}$ ] by the definition of @xmath306\\!\\!]}_{\\rules}}$ ] .",
    "this is true of each type rule for @xmath457 .",
    "therefore , @xmath609\\!\\!]}_{\\rules}}$ ] .",
    "let @xmath1031 it suffices to prove that @xmath1032 for all @xmath973 . by lemma  [ lm : f ] , @xmath1033\\!\\!]}_{\\rules}}$ ] .",
    "we have @xmath1034\\!\\!]}_{\\rules}}$ ] for all @xmath340 and @xmath308 such that @xmath1035",
    ". therefore , @xmath1036 .",
    "* theorem *  [ lm : i ] . for any @xmath617}_\\req,{[\\scal_{2}]}_\\req\\in    \\rsub$ ] and any @xmath270 , @xmath647}_\\req ) ,    a_2,\\rcon({[\\scal_{2}]}_\\req ) ) }   & \\subseteq & \\rcon    ( \\munify(a_1,{[\\scal_{1}]}_\\req , a_2,{[\\scal_{2}]}_\\req ) )    \\end{aligned}\\ ] ]    we first prove a preliminary result on substitution and unification .",
    "let @xmath1037 and @xmath1038 and assume that @xmath1039 .",
    "recall that @xmath1040 and @xmath1041  @xcite . then @xmath1042 we are now ready to prove the theorem .",
    "let @xmath1043}_\\req)$ ] , @xmath1044}_\\req)$ ] and @xmath1045 .",
    "assume that @xmath1046 .",
    "it is equivalent to prove @xmath1047}_\\req , a_2,{[\\scal_{2}]}_\\req))$ ] . by the definition of @xmath380 and @xmath636 ,",
    "if @xmath1048}_\\req)$ ] then @xmath1049}_\\req)$ ] for any substitution @xmath1050 and any set of variable typings over @xmath398 .",
    "thus , it suffices to prove that @xmath1051}_\\req)$ ] by the definitions for @xmath646 and @xmath1052 .",
    "without loss of generality , assume that @xmath393 renames @xmath1053 apart from @xmath1054 .",
    "let @xmath1055 and @xmath1056 . then @xmath1057}_\\req ) } \\\\   & \\lequiv &   \\mgu((\\psi(\\theta_1))(\\psi(a_1)),\\theta_2(a_2))\\circ\\theta_2 \\in \\rcon({[\\mup(e_0,\\mdown(e_0,\\psi(\\scal_1)\\biguplus\\scal_2))]}_\\req ) \\\\   & \\lequiv &   \\mgu(\\eta(e_0))\\circ\\eta\\in \\rcon({[\\mup(e_0,\\mdown(e_0,\\psi(\\scal_1)\\biguplus\\scal_2))]}_\\req ) \\\\",
    "& \\lequiv &   \\theta\\in \\rcon({[\\mup(e_0,\\mdown(e_0,\\psi(\\scal_1)\\biguplus\\scal_2))]}_\\req)\\end{aligned}\\ ] ] thus , it remains to prove @xmath1058}_\\req)$ ] .",
    "since @xmath1059 and @xmath1056 , it holds that @xmath1060}_\\req)$ ] according to lemma  [ lm : g ] . according to lemma  [ lm : h ] , we have @xmath1061}_\\req)$ ] .",
    "note that @xmath1062 .",
    "thus , @xmath1058}_\\req)$ ] .",
    "induction . either @xmath919 and @xmath960 or @xmath922 and @xmath1065 .",
    "consider first the case where @xmath919 and @xmath960 .",
    "then @xmath921 and either ( i ) @xmath441 ; or ( ii ) @xmath569 .",
    "we only prove the case ( i ) since the case ( ii ) is dual to the case ( i ) . since @xmath310\\!\\!]}_{\\rules}}$ ] ,",
    "either @xmath924\\!\\!]}_{\\rules}}$ ] or @xmath925\\!\\!]}_{\\rules}}$ ] .",
    "so , we have either @xmath1066 or @xmath1067 by the induction hypothesis .",
    "thus , @xmath768 .",
    "now consider the case @xmath922 and @xmath916 .",
    "then @xmath453 .",
    "either ( i ) @xmath441 ; ( ii ) @xmath569 ; ( iii ) @xmath435 or ( iv ) @xmath576 .",
    "the proof for that @xmath768 in cases ( i ) and ( ii ) are the same as in the previous paragraph .",
    "the case ( iii ) is vacuous . consider the case ( iv ) . since @xmath310\\!\\!]}_{\\rules}}$ ] , by the definition of @xmath306\\!\\!]}_{\\rules}}$ ] , there is a type rule @xmath929 in @xmath290 such that @xmath1068\\!\\!]}_{\\rules}}$ ] for all @xmath484 where @xmath931 . observe that @xmath991 and @xmath1069 . by induction hypothesis , @xmath1070 . by the definition of @xmath757 , @xmath1071 .",
    "either @xmath919 and @xmath960 or @xmath922 and @xmath1065 .",
    "consider first the case where @xmath919 and @xmath960 .",
    "then @xmath921 and either ( i ) @xmath441 ; or ( ii ) @xmath569 .",
    "we only prove the case ( i ) since the case ( ii ) is dual to the case ( i ) .",
    "since @xmath768 , either @xmath1066 or @xmath1067 .",
    "so , we have either @xmath924\\!\\!]}_{\\rules}}$ ] or @xmath925\\!\\!]}_{\\rules}}$ ] by the induction hypothesis .",
    "thus , @xmath310\\!\\!]}_{\\rules}}$ ] .    now consider the case @xmath922 and @xmath916 .",
    "then @xmath453 . either ( i ) @xmath441 ; ( ii ) @xmath569 ; ( iii ) @xmath435 or ( iv ) @xmath576 .",
    "the proof for that @xmath310\\!\\!]}_{\\rules}}$ ] in cases ( i ) and ( ii ) are the same as in the previous paragraph .",
    "the case ( iii ) is vacuous . consider the case ( iv ) . since @xmath768 , by the definition of @xmath757 , there is a type rule @xmath929 in @xmath290 such that @xmath1070 for all @xmath484 where @xmath931 . observe that @xmath991 and @xmath1069 . by induction hypothesis , @xmath1068\\!\\!]}_{\\rules}}$ ] . by the definition of @xmath306\\!\\!]}_{\\rules}}$",
    "] , @xmath1073\\!\\!]}_{\\rules}}$ ] .",
    "both sufficiency and necessity are proved by contradiction .",
    "we first consider sufficiency .",
    "assume that @xmath1074 but @xmath771\\!\\!]}_{\\rules}}\\not\\subseteq { { [ \\!\\![\\rt_2]\\!\\!]}_{\\rules}}$ ] .",
    "then there is a term @xmath308 such that @xmath1075\\!\\!]}_{\\rules}}$ ] and @xmath1076\\!\\!]}_{\\rules}}$ ] . by theorem",
    "[ th : eq ] , we have that @xmath1077 . by the assumption , @xmath1078 . by theorem",
    "[ th : eq ] , @xmath1079\\!\\!]}_{\\rules}}$ ] that contradicts with that @xmath1076\\!\\!]}_{\\rules}}$ ] .",
    "we now prove necessity .",
    "assume that @xmath771\\!\\!]}_{\\rules}}\\subseteq { { [ \\!\\![\\rt_2]\\!\\!]}_{\\rules}}$ ] but @xmath1080 .",
    "then there is a term @xmath308 such that @xmath1081 and @xmath1082 . by theorem",
    "[ th : eq ] , there is a term @xmath1083 such that @xmath1084 and @xmath1085\\!\\!]}_{\\rules}}$ ] . by the assumption , @xmath1086\\!\\!]}_{\\rules}}$ ] . by theorem",
    "[ th : eq ] , @xmath1087 that contradicts with that @xmath1082 .",
    "directional type checking of logic programs . in _ proceedings of the first international static analysis symposium _",
    ", b.  le  charlier , ed .",
    "lecture notes in computer science , vol .",
    "springer , 4360 .          ,",
    "lakshman , t.  k. , and reddy , u.  s. 1992 . a framework of directionality for proving termination of logic programs . in _ proceedings of the joint international conference and symposium on logic programming",
    ", k.  apt , ed . the mit press , 321335 .      \\1998 .",
    "directional type inference for logic programs . in _ proceedings of the fifth international symposium on static analysis _ , g.  levi , ed .",
    "lecture notes in computer science , vol . 1503 .",
    "springer , 278294 .",
    "\\1994 . deriving polymorphic type dependencies for logic programs using multiple incarnations of prop . in _ proceedings of the first international static analysis symposium _ ,",
    "b.  le  charlier , ed .",
    "lecture notes in computer science , vol .",
    "springer , 281297 .",
    "formal language , grammar and set - constraint - based program analysis by abstract interpretation . in _ proceedings of the seventh acm conference on functional programming languages and computer",
    "architecture_. the acm press , 170181 .            , shapiro , e. , vardi , m. , and yardeni , e. 1991 .",
    "logic programs as types for logic programs . in _ proceedings of the sixth annual ieee symposium on logic in computer",
    "science_. the ieee computer society press , 300309 .      , boulanger , d. , and saglam , h. 1995 .",
    "practical model - based static analysis for definite logic programs . in _ proceedings of the fifteenth international symposium on logic programming _ , j.  w. lloyd , ed .",
    "the mit press , 351368 .    \\2002 .",
    "abstract interpretation over non - deterministic finite tree automata for set - based analysis of logic programs . in _ proceedings of the fourth international symposium on practical aspects of declarative languages _ , s.  krishnamurthi and c.  r. ramakrishnan , eds .",
    "lecture notes in computer science , vol . 2257 .",
    "springer , 243261 .            ,",
    "bueno , f. , puebla , g. , and lpez , p. 1999 .",
    "program analysis , debugging , and optimization using the ciao system preprocessor . in _ proceedings of the 1999 international conference on logic programming_. the mit press , 5265 .        \\1988 .",
    "polymorphic type inference in prolog by abstract interpretation . in _ proceedings of the sixth conference on logic programming _",
    ", k.  furukawa , h.  tanaka , and t.  fujisaki , eds .",
    "lecture notes in computer science , vol .",
    "springer , 195214 .",
    "limits of ml - definability . in _ proceedings of the eighth international symposium on programming languages : implementation , logic and programs _ , h.  kuchen and s.  d. swierstra , eds .",
    "lecture notes in computer science , vol . 1140 .",
    "springer , 1731 .",
    "a framework for analysis of typed logic programs . in _ proceedings of the fifth international symposium on functional and logic programming _ , h.  kuchen and k.  ueda , eds .",
    "lecture notes in computer science , vol . 2024 .",
    "springer , 296310 .",
    "type analysis of logic programs in the presence of type definitions . in _ proceedings of the 1995 acm sigplan symposium on partial evaluation and semantics - based program manipulation_. the acm press , 241252 .",
    "\\1988 . towards a framework for abstract interpretation of logic programs . in _ proceedings of the first international workshop on programming language implementation and logic programming _ , p.  deransart , b.  lorho , and j.  mauszynski , eds .",
    "lecture notes in computer science , vol . 348 .",
    "springer , 6882 .",
    "polymorphic directional types for logic programming . in _ proceedings of the third acm",
    "sigplan international conference on principles and practice of declarative programming_. the acm press , 6172 .",
    "analysis of polymorphically typed logic programs using aci - unification . in _ proceedings of the eighth international conference on logic for programming , artificial intelligence , and reasoning_. lecture notes in artificial intelligence , vol .",
    "springer , 282298 ."
  ],
  "abstract_text": [
    "<S> this paper presents a new type analysis for logic programs . </S>",
    "<S> the analysis is performed with _ a priori _ type definitions ; and type expressions are formed from a fixed alphabet of type constructors . </S>",
    "<S> non - discriminative union is used to join type information from different sources without loss of precision . </S>",
    "<S> an operation that is performed repeatedly during an analysis is to detect if a fixpoint has been reached . </S>",
    "<S> this is reduced to checking the emptiness of types . due to the use of non - discriminative union , </S>",
    "<S> the fundamental problem of checking the emptiness of types is more complex in the proposed type analysis than in other type analyses with _ a priori _ type definitions . </S>",
    "<S> the experimental results , however , show that use of tabling reduces the effect to a small fraction of analysis time on a set of benchmarks .    </S>",
    "<S> rotate.tex    type analysis , non - discriminative union , abstract interpretation , tabling </S>"
  ]
}