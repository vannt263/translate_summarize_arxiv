{
  "article_text": [
    "* the background . * a team of at least two mobile agents , starting from different nodes of a network , possibly at different times , have to meet at the same node .",
    "this basic task , known as _ gathering _ or _ rendezvous _ , has been thoroughly studied in the literature .",
    "this task has even applications in everyday life , e.g. , when agents are people that have to meet in a city whose streets form a network . in computer science ,",
    "mobile agents usually represent software agents in computer networks , or mobile robots , if the network is a labyrinth .",
    "the reason to meet may be to exchange data previously collected by the agents , or to coordinate some future task , such as network maintenance or finding a map of the network .",
    "* the model and the problem . * the network is modeled as an undirected connected graph , referred to hereafter as a graph .",
    "we seek gathering algorithms that do not rely on the knowledge of node labels , and can work in anonymous graphs as well ( cf .",
    "the importance of designing such algorithms is motivated by the fact that , even when nodes are equipped with distinct labels , agents may be unable to perceive them because of limited sensory capabilities , or nodes may refuse to reveal their labels , e.g. , due to security or privacy reasons . note that if nodes had distinct labels , then agents might explore the graph and meet in the smallest node , hence gathering would reduce to exploration .",
    "on the other hand , we assume that edges incident to a node @xmath1 have distinct labels in @xmath2 , where @xmath3 is the degree of @xmath1 .",
    "thus every undirected edge @xmath4 has two labels , which are called its _ port numbers _ at @xmath5 and at @xmath1 .",
    "port numbering is _ local _",
    ", i.e. , there is no relation between port numbers at @xmath5 and at @xmath1 .",
    "note that in the absence of port numbers , edges incident to a node would be undistinguishable for agents and thus gathering would be often impossible , as the adversary could prevent an agent from taking some edge incident to the current node .",
    "there are at least two agents that start from different nodes of the graph and traverse its edges in synchronous rounds .",
    "they can not mark visited nodes or traversed edges in any way .",
    "the adversary wakes up some of the agents at possibly different times .",
    "a dormant agent , not woken up by the adversary , is woken up by the first agent that visits its starting node , if such an agent exists .",
    "agents are anonymous ( identical ) and they execute the same deterministic algorithm .",
    "every agent starts executing the algorithm in the round of its wake - up .",
    "agents do not know the topology of the graph or the size of the team .",
    "we consider two scenarios : one when agents know an upper bound on the size of the graph and another when no bound is known . in every round",
    "an agent may perform some local computations and move to an adjacent node by a chosen port , or stay at the current node .",
    "when an agent enters a node , it learns its degree and the port of entry .",
    "when several agents are at the same node in the same round , they can exchange all information they currently have .",
    "however , agents that cross each other on an edge , traversing it simultaneously in different directions , do not notice this fact .",
    "we assume that the memory of the agents is unlimited : from the computational point of view they are modeled as turing machines .",
    "an initial configuration of agents , i.e. , their placement at some nodes of the graph , is called _ gatherable _ if there exists a deterministic algorithm ( even only dedicated to this particular configuration ) that achieves meeting of all agents in one node , regardless of the times at which some of the agents are woken up by the adversary . in this paper",
    "we study the following gathering problem :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ which initial configurations are gatherable and how to gather all of them deterministically by the same algorithm ? _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    in other words , we want to decide which initial configurations are possible to gather , even by an algorithm specifically designed for this particular configuration , and we want to find a _",
    "universal _ gathering algorithm that gathers all such configurations .",
    "we are interested only in _ terminating _ algorithms , in which every agent eventually stops forever .    * our results .",
    "* we give a complete solution of the gathering problem in arbitrary networks .",
    "we characterize all gatherable configurations and give two _ universal _ deterministic gathering algorithms , i.e. , algorithms that gather all gatherable configurations .",
    "the first algorithm works under the assumption that an upper bound @xmath0 on the size of the network is known . in this case",
    "our algorithm guarantees _ gathering with detection _ ,",
    "i.e. , the existence of a round for any gatherable configuration , such that all agents are at the same node and all declare that gathering is accomplished .",
    "if no upper bound on the size of the network is known , we show that a universal algorithm for gathering with detection does not exist .",
    "hence , for this harder scenario , we construct a second universal gathering algorithm , which guarantees that , for any gatherable configuration , all agents eventually get to one node and stop , although they can not tell if gathering is over .",
    "the time of the first algorithm is polynomial in the upper bound @xmath0 on the size of the network , and the time of the second algorithm is polynomial in the ( unknown ) size itself .    while gathering two anonymous agents is a relatively easy task ( cf .",
    "@xcite ) , our problem of gathering an unknown team of anonymous agents presents the following major difficulty .",
    "the asymmetry of the initial configuration because of which gathering is feasible , may be caused not only by non - similar locations of the agents in the graph , but by their different situation _ with respect to other agents_. hence a new algorithmic idea is needed in order to gather : agents that were initially identical , must make decisions based on the memories of other agents met to date , in order to distinguish their future behavior . in the beginning the memory of each agent is a blank slate and in the execution of the algorithm it records what the agent has seen in previous steps of the navigation and what it heard from other agents during meetings .",
    "even a slight asymmetry occurring in a remote part of the graph must eventually influence the behavior of initially distant agents . notice that agents in different initial situations may be unaware of this difference in early meetings , as the difference may be revealed only later on , after meeting other agents .",
    "hence , for example , an agent may mistakenly `` think '' that two different agents that it met in different stages of the algorithm execution , are the same agent .",
    "confusions due to this possibility are a significant challenge absent both in gathering two ( even anonymous ) agents and in gathering many labeled agents .",
    "our results have an important consequence for the leader election problem for anonymous agents in arbitrary graphs .",
    "leader election @xcite is a fundamental symmetry breaking problem in distributed computing .",
    "its goal is to assign , in some common round , value 1 ( leader ) to one of the entities and value 0 ( non - leader ) to all others . for anonymous agents in graphs ,",
    "leader election turns out to be equivalent to gathering with detection ( see section 5 ) .",
    "hence , as a by - product , we obtain a complete solution of the leader election problem for anonymous agents in arbitrary graphs",
    ".    * related work . *",
    "gathering has been mostly studied for two mobile agents and in this case it is usually called rendezvous .",
    "an extensive survey of randomized rendezvous in various scenarios can be found in @xcite , cf .",
    "also @xcite .",
    "deterministic rendezvous in networks has been surveyed in @xcite .",
    "several authors considered the geometric scenario ( rendezvous in an interval of the real line , see , e.g. , @xcite , or in the plane , see , e.g. , @xcite ) .",
    "gathering more than two agents has been studied , e.g. , in @xcite . in",
    "@xcite the authors considered rendezvous of many agents with unique labels , and gathering many labeled agents in the presence of byzantine agents was studied in @xcite .",
    "the problem was also studied in the context of multiple robot systems , cf .",
    "@xcite , and fault tolerant gathering of robots in the plane was studied , e.g. , in @xcite .    for the deterministic setting",
    "a lot of effort has been dedicated to the study of the feasibility of rendezvous , and to the time required to achieve this task , when feasible . for instance , deterministic rendezvous with agents equipped with tokens used to mark nodes was considered , e.g. , in  @xcite .",
    "deterministic rendezvous of two agents that can not mark nodes but have unique labels was discussed in @xcite .",
    "these papers are concerned with the time of rendezvous in arbitrary graphs . in @xcite",
    "the authors show a rendezvous algorithm polynomial in the size of the graph , in the length of the shorter label and in the delay between the starting time of the agents . in @xcite rendezvous time",
    "is polynomial in the first two of these parameters and independent of the delay .",
    "memory required by two anonymous agents to achieve deterministic rendezvous has been studied in @xcite for trees and in @xcite for general graphs .",
    "memory needed for randomized rendezvous in the ring is discussed , e.g. , in  @xcite .",
    "apart from the synchronous model used , e.g. , in @xcite and in this paper , several authors have investigated asynchronous rendezvous in the plane @xcite and in network environments @xcite . in the latter scenario",
    "the agent chooses the edge which it decides to traverse but the adversary controls the speed of the agent . under this assumption rendezvous in a node can not be guaranteed even in very simple graphs and hence the rendezvous requirement is relaxed to permit the agents to meet inside an edge .",
    "throughout the paper , the number of nodes of a graph is called its size . in this section",
    "we recall four procedures known from the literature , that will be used as building blocks in our algorithms .",
    "the aim of the first two procedures is graph exploration , i.e. , visiting all nodes of the graph ( cf .",
    ", e.g. , @xcite ) .",
    "the first of these procedures assumes an upper bound @xmath0 on the size of the graph and the second one makes no assumptions on the size but it is performed by an agent using a fixed token placed at the starting node of the agent .",
    "( it is well known that a terminating exploration even of all anonymous rings of unknown size by a single agent without a token is impossible . ) in our applications the roles of the token and of the exploring agent will be played by agents or by groups of agents .",
    "the first procedure works in time polynomial in the known upper bound @xmath0 on the size of the graph and the second in time polynomial in the size of the graph .",
    "moreover , at the end of the second procedure the agent is with the token and has a complete map of the graph with all port numbers marked .",
    "we call the first procedure @xmath6 and the second procedure @xmath7 , for _ exploration with a stationary token_. we denote by @xmath8 ( respectively @xmath9 ) the maximum time of execution of the procedure @xmath6 ( respectively procedure @xmath7 ) in a graph of size at most @xmath0 .    before describing the third procedure",
    "we define the following notion from @xcite .",
    "let @xmath10 be a graph and @xmath1 a node of @xmath10 , of degree @xmath11 . the _ view",
    "_ from @xmath1 is the infinite rooted tree @xmath12 with labeled ports , defined recursively as follows .",
    "@xmath12 has the root @xmath13 corresponding to @xmath1 . for every node @xmath14 , @xmath15 , adjacent to @xmath1 , there is a neighbor @xmath16 in @xmath12 such that the port number at @xmath1 corresponding to edge @xmath17 is the same as the port number at @xmath13 corresponding to edge @xmath18 , and the port number at @xmath14 corresponding to edge @xmath17 is the same as the port number at @xmath16 corresponding to edge @xmath18 .",
    "node @xmath16 , for @xmath15 , is now the root of the view from @xmath14 .",
    "the third procedure , described in @xcite , permits a single anonymous agent starting at node @xmath1 to find a positive integer @xmath19 , called the signature of the agent , such that @xmath20 if and only if @xmath21 .",
    "this procedure , called @xmath22 works for any graph of known upper bound @xmath0 on its size and its running time is polynomial in @xmath0 . after the completion of @xmath22 the agent is back at its starting node .",
    "we denote by @xmath23 the maximum time of execution of the procedure @xmath22 in a graph of size at most @xmath0 .",
    "finally , the fourth procedure is for gathering two agents in a graph of unknown size .",
    "it is due to ta - shma and zwick @xcite and relies on the fact that agents have distinct labels .",
    "( using it as a building block in our scenario of anonymous agents is one of the difficulties that we need to overcome . )",
    "each agent knows its own label ( which is a parameter of the algorithm ) but not the label of the other agent .",
    "we will call this procedure @xmath24 , where @xmath25 is the label of the executing agent . in @xcite ,",
    "the authors give a polynomial @xmath26 in two variables , increasing in each of the variables , such that , if there are agents with distinct labels @xmath27 and @xmath28 operating in a graph of size @xmath0 , appearing at their starting positions in possibly different times , then they will meet after at most @xmath29 rounds since the appearance of the later agent , where @xmath25 is the smaller label .",
    "also , if an agent with label @xmath30 performs @xmath31 for @xmath32 rounds and the other agent is inert during this time , the meeting is guaranteed .",
    "we will also use a notion similar to that of the view but reflecting the positions of agents in an initial configuration . consider a graph @xmath10 and an initial configuration of agents in this graph .",
    "let @xmath1 be a node occupied by an agent . the _ enhanced view",
    "_ from @xmath1 is the couple @xmath33 , where @xmath34 is a binary valued function defined on the set of nodes of @xmath12 , such that @xmath35 if there is an agent at @xmath36 and @xmath37 otherwise .",
    "thus the enhanced view of an agent additionally marks in its view the positions of other agents in the initial configuration .",
    "an important notion used throughout the paper is the _ memory _ of an agent .",
    "intuitively , the memory of an agent in a given round is the total information the agent collected since its wake - up , both by navigating in the graph and by exchanging information with other agents met until this round .",
    "this is formalized as follows .",
    "the memory of an agent @xmath38 at the end of some round which is the @xmath39-th round since its wake - up , is the sequence @xmath40 , where @xmath41 is the information of the agent at its start and @xmath42 is the information acquired in round @xmath43 .",
    "the terms @xmath42 are defined as follows .",
    "suppose that in round @xmath43 the agent @xmath38 met agents @xmath44 at node @xmath1 of degree @xmath3 .",
    "suppose that agent @xmath38 entered node @xmath1 in round @xmath43 leaving an adjacent node @xmath36 by port @xmath45 and entering @xmath1 by port @xmath46 .",
    "suppose that agent @xmath47 entered node @xmath1 in round @xmath43 leaving an adjacent node @xmath48 by port @xmath49 and entering @xmath1 by port @xmath50 .",
    "if some agent did not move in round @xmath43 then the respective ports are replaced by @xmath51 .",
    "the term @xmath42 for agent @xmath38 , called its @xmath43-th _ memory box _ is defined as the sequence @xmath52 , where @xmath53 is the memory of the agent @xmath47 at the end of round @xmath54 .",
    "this definition is recursive with respect to global time ( unknown to agents ) , starting at the wake - up of the earliest agent by the adversary .",
    "note that if an agent is woken up by the adversary at a node of degree @xmath3 and no other agents are at this node at this time then @xmath55 for this agent ( at its wake - up the agent sees only the degree of its starting position ) .",
    "if an agent is woken up by some other agents , it also learns their memories to date .",
    "note also that , since the memory of the agent is the total information it acquired to date , any deterministic algorithm used by agents to navigate ( including any deterministic gathering algorithm ) may be viewed as a function from the set of all memories into the set of integers greater or equal to @xmath51 telling the agent to take a given port @xmath45 ( or stay idle , in which case the output is @xmath51 ) , if it has a given memory . for a memory @xmath56 and for @xmath57",
    "we denote @xmath58 .    notice that if two agents meet , they must necessarily have different memories . indeed ,",
    "if they had identical memories , then they would be woken up in the same round and they would traverse identical paths to the meeting node .",
    "this contradicts the assumption that agents start at different nodes .",
    "we will use the following order on the set @xmath59 of all possible memories .",
    "let @xmath60 be any linear order on the set of all memory boxes ( one such simple order is to code all possible memory boxes as binary sequences in some canonical way and use lexicographic order on binary sequences ) .",
    "now the linear order @xmath61 on the set @xmath59 of sequences of memory boxes is defined as the lexicographic order based on the order @xmath60 .",
    "the order @xmath61 has the property that if the memory of agent @xmath38 is smaller than the memory of agent @xmath62 in some round then it will remain smaller in all subsequent rounds .",
    "when @xmath63 , we say that memory @xmath64 is _ larger _",
    "than @xmath65 .",
    "in this section we assume that an upper bound @xmath0 on the size of the graph is known to all agents at the beginning .",
    "the aim of this section is to characterize gatherable configurations and give a _ universal _ gathering algorithm that gathers _ with detection _ all gatherable configurations .",
    "the time of such an algorithm is the number of rounds between the wake - up of the first agent and the round when all agents declare that gathering is accomplished .",
    "consider the following condition on an initial configuration in an arbitrary graph .",
    "* there exist agents with different views , and each agent has a unique enhanced view .",
    "we will prove the following result .",
    "[ eq ] an initial configuration is gatherable if and only if it satisfies the condition * g*. if an upper bound @xmath0 on the size of the graph is known then there exists an algorithm for gathering with detection all gatherable configurations .",
    "this algorithm works in time polynomial in @xmath0 .    in order to appreciate the full strength of theorem [ eq ] notice that it can be rephrased as follows .",
    "if an initial configuration does not satisfy condition * g * then there is no algorithm ( even no algorithm dedicated to this specific configuration , knowing it entirely ) that permits to gather this configuration , even gather it without detection : simply no algorithm can bring all agents simultaneously to one node . on the other hand , assuming an upper bound on the size of the graph , there is a _",
    "universal _ algorithm that gathers _ with detection _ all initial configurations satisfying condition * g*. our algorithm works in time polynomial in any known upper bound @xmath0 on the size of the graph . hence , if this upper bound is polynomial in the size of the graph , the algorithm is polynomial in the size as well . in the next section we will show how the positive part of the result changes when no upper bound on the size of the graph is known .",
    "the rest of the section is devoted to the proof of theorem [ eq ] .",
    "we start with the following lemma .    [ not ]",
    "if an initial configuration does not satisfy condition * g * , then it is not gatherable .",
    "suppose that an initial configuration @xmath66 does not satisfy condition * g * and that agents execute the same deterministic algorithm .",
    "first suppose that the configuration @xmath66 does not satisfy the first part of condition * g * , i.e. , that the views of all agents are identical .",
    "suppose that the adversary wakes up all agents in the same round .",
    "we show that no pair of agents can meet .",
    "suppose , for contradiction , that agents @xmath67 and @xmath68 are the first to meet and that this occurs in round @xmath39 from the common start .",
    "since the initial views of the agents are identical and they execute the same deterministic algorithm , the sequences of port numbers encountered by both agents are identical and hence they both enter the node at which they first meet by the same port .",
    "this is a contradiction .",
    "now suppose that the configuration @xmath66 does not satisfy the second part of condition * g * , i.e. , that there exists an agent whose enhanced view is not unique .",
    "consider distinct agents @xmath38 and @xmath69 that have identical enhanced views .",
    "let @xmath62 be any agent and suppose that @xmath46 is a sequence of port numbers that leads from agent @xmath38 to agent @xmath62 in the enhanced view of agent @xmath38 .",
    "( notice that there may be many such sequences , corresponding to different paths leading from @xmath38 to @xmath62 . )",
    "then there exists an agent @xmath70 such that @xmath46 is a sequence of port numbers that leads from agent @xmath69 to agent @xmath70 in the enhanced view of agent @xmath69 .",
    "agent @xmath70 has the same enhanced view as agent @xmath62 . since agents @xmath38 and",
    "@xmath69 were different , agents @xmath62 and @xmath70 are different as well . hence for every agent there exists another agent whose enhanced view is identical .",
    "call such agents _ homologs_.",
    "suppose again that the adversary wakes up all agents in the same round .",
    "we will show that , although now some meetings of agents are possible , homologs will never meet .",
    "suppose that agents @xmath38 and @xmath69 are homologs . since @xmath38 and @xmath69 have the same enhanced view at the beginning , it follows by induction on the round number that their memory will be identical in every round .",
    "indeed , whenever @xmath38 meets an agent @xmath62 in some round , its homolog @xmath69 meets a homolog @xmath70 of @xmath62 in the same round and hence the memories of @xmath38 and @xmath69 evolve identically .",
    "in particular , since all agents execute the same deterministic algorithm , agents @xmath38 and @xmath69 follow identical sequences of port numbers on their paths . as before ,",
    "if they met for the first time at some node , they would have to enter this node by the same port .",
    "this is a contradiction .",
    "the other ( much more difficult ) direction of the equivalence from theorem [ eq ] will be shown by constructing an algorithm which , executed by agents starting from any initial configuration satisfying condition * g * , accomplishes gathering with detection of all agents .",
    "( our algorithm uses the knowledge of an upper bound @xmath0 of the size of the graph : this is enough to prove the other direction of the equivalence , as for any specific configuration satisfying condition * g * even a gathering algorithm dedicated to this specific configuration is enough to show that the configuration is gatherable , and such a dedicated algorithm knows the exact size of the graph .",
    "of course , our algorithm accomplishes much more : knowing just an upper bound on the size of the graph it gathers _ all _ configurations satisfying condition * g * and does this _ with detection_. ) we first give a high - level idea of the algorithm , then describe it in detail and prove its correctness . from now on we assume that the initial configuration satisfies condition * g*.    * idea of the algorithm .",
    "* at high level the algorithm works in two stages .",
    "the aim of the first stage for any agent is to meet another agent , in order to perform later an exploration in which one of the agents will play the role of the token and the other the role of the explorer ( roles will be decided comparing memories of the agents ) . to this end",
    "the agent starts an exploration of the graph using the known upper bound @xmath0 on its size .",
    "the aim of this exploration is to wake up all , possibly still dormant agents .",
    "afterwards , in order to meet , agents use the procedure @xmath71 mentioned in section 2",
    ". however , this procedure requires a label for each agent and our agents are anonymous .",
    "one way to differentiate agents and give them labels is to find their views : a view ( truncated to @xmath0 ) from the initial position could serve as a label because the first part of condition * g * guarantees that there are at least two distinct views . however , finding the view of an agent ( truncated to @xmath0 ) would require exponential time .",
    "hence we use procedure @xmath22 mentioned in section 2 , which is polynomial in @xmath0 and can still assign labels to agents , producing at least two different labels . then , performing procedure @xmath71 for a sufficiently long time guarantees a meeting for every agent .    in the second stage",
    "each explorer explores the graph using procedure @xmath6 and then backtracks to its token left at the starting node of the exploration . after the backtrack ,",
    "memories of the token and of the explorer are updated to check for anomalies caused by other agents meeting in the meantime either the token or the explorer .",
    "note that , due to the fact that some agents may have identical memories at this stage of the algorithm , an explorer may sometimes falsely consider another token as its own , due to their identical memories .",
    "by contrast , an end of each backtrack is a time when an explorer can be sure that it is on its token and the token can be sure that its explorer is with it .",
    "explorers repeat these explorations with backtrack again and again , with the aim of creating meetings with other agents and detecting anomalies . as a consequence of these anomalies some agents merge with others ,",
    "mergers being decided on the basis of the memories of the agents .",
    "each explorer eventually either merges with some token or performs an exploration without anomalies . in the latter case it waits a prescribed amount of time with its token : if no new agent comes during the waiting time , the end of the gathering is declared , otherwise another exploration is launched .",
    "it will be proved that eventually , due to the second part of condition * g * , all agents merge with the same token @xmath62 and then , after the last exploration made by the explorer @xmath38 of @xmath62 and after undisturbed waiting time , the end of the gathering is correctly declared .",
    "we now give a detailed description of the algorithm .",
    "* algorithm gathering - with - detection * with parameter @xmath0 ( upper bound on the size of the graph )    during the execution of the algorithm an agent can be in one of the following six states : setup , cruiser , shadow , explorer , token , searcher , depending on its memory . for every agent @xmath38 in state shadow",
    "there is exactly one agent @xmath62 in some state different from shadow , called the _ guide _ of @xmath38 .",
    "we will also say that @xmath38 is a shadow of @xmath62 . below we describe the actions of an agent @xmath38 in each of the states and the transitions between the states .",
    "at wake - up agent @xmath38 enters the state setup .",
    "* state * setup .",
    "agent @xmath38 performs @xmath6 visiting all nodes and waking up all still dormant agents . then agent @xmath38 performs the procedure @xmath22 finding the signature of its initial position @xmath1 , called the _ label _ of agent @xmath38 .",
    "agent @xmath38 transits to state cruiser .",
    "* state * cruiser .",
    "agent @xmath38 performs @xmath24 , where @xmath25 is its label , until meeting an agent in state cruiser or token at a node @xmath1 .",
    "agent @xmath38 meets an agent @xmath62 in state token .",
    "+ then it transits to state shadow of @xmath62 .",
    "agent @xmath38 does not meet an agent in state token .",
    "+ then there is at least one other agent in state cruiser at node @xmath1 .",
    "subcase 2.1 .",
    "agent @xmath38 has the largest memory among all agents in state cruiser at node @xmath1 . +",
    "then agent @xmath38 transits to state explorer .",
    "subcase 2.2 .",
    "agent @xmath38 does not have the largest memory among all agents in state cruiser at node @xmath1 .",
    "+ if there is exactly one agent @xmath62 in state cruiser with memory larger than @xmath38 at node @xmath1 , then @xmath38 transits to state token .",
    "otherwise , it becomes shadow of the agent in state cruiser at node @xmath1 with largest memory .",
    "* state * shadow .",
    "agent @xmath38 has exactly one guide and is at the same node as the guide in every round . in every round it makes the same move as the guide .",
    "if the guide @xmath62 transits itself to state shadow and gets agent @xmath66 as its guide , then agent @xmath38 changes its guide to @xmath66 as well .",
    "agent @xmath38 declares that gathering is over if the unique agent in state explorer collocated with it makes this declaration .    before describing the actions in the three remaining states ,",
    "we define the notion of _ seniority _ of an agent in state token ( respectively explorer ) .",
    "the seniority in a given round is the number of rounds from the time when the agent became token ( respectively explorer ) .",
    "* state * explorer    when agent @xmath38 transits to state explorer , there is another agent @xmath62 that transits to state token in the same round at the same node @xmath1 .",
    "agent @xmath62 is called the token of @xmath38 .",
    "agent @xmath38 has a variable @xmath72 that it initializes to the memory of @xmath62 in this round .",
    "denote by @xmath73 the procedure @xmath6 followed by a complete backtrack in which the agent traverses all edges traversed in @xmath6 in the reverse order and the reverse direction .",
    "the variable @xmath72 is updated in the beginning of each execution of @xmath73 .",
    "an execution of @xmath73 is called _",
    "clean _ if the following condition is satisfied : in each round during this execution , in which @xmath38 met an agent @xmath66 , the memory of @xmath66 is equal to that of @xmath62 , and in each round during this execution , in which the token @xmath62 was met by an agent @xmath74 , the memory of @xmath74 was equal to that of @xmath38 .",
    "notice that after the execution of @xmath73 , agent @xmath38 is together with its token @xmath62 and thus they can verify if the execution was clean , by inspecting their memories .",
    "the execution time of @xmath73 is at most @xmath75 .",
    "after transiting to state explorer , agent @xmath38 waits for @xmath76 rounds , where @xmath77 is the largest possible label ( it is polynomial in @xmath0 ) .",
    "then it executes the following protocol :    * while * @xmath38 has not declared that gathering is over * do *     + @xmath73 + /*now agent @xmath38 is with its token.*/    @xmath38 met an agent @xmath66 in state token of higher seniority than that of @xmath38 or of equal seniority but such + that @xmath78 where @xmath79 is the memory of agent @xmath66 and @xmath39 is the last round + when agent @xmath38 updated its variable @xmath72 * then * @xmath38 transits to state searcher    @xmath62 was visited in round @xmath80 by an agent @xmath66 in state explorer of higher seniority than that of @xmath62 + or of equal seniority but such that @xmath81 where @xmath82 is the memory of agent @xmath62 + and @xmath83 is the variable @xmath72 of agent @xmath66 in round @xmath80 * then * @xmath38 transits to state searcher    the execution of @xmath73 is clean + agent @xmath38 waits @xmath84 rounds ;    during this time @xmath38 has not been met by any new agent * then * @xmath38 declares that gathering is over .    *",
    "state * token    when agent @xmath38 transits to state token , there is another agent @xmath62 that transits to state explorer in the same round at the same node @xmath1 .",
    "agent @xmath62 is called the explorer of @xmath38 .",
    "agent @xmath38 remains idle at a node @xmath1 and does not change its state , except when its explorer @xmath62 transits to state searcher . in this case",
    "it transits to state shadow and @xmath62 becomes its guide .",
    "agent @xmath38 declares that gathering is over if the unique agent in state explorer collocated with it makes this declaration .",
    "* state * searcher    agent @xmath38 performs an entire execution of @xmath73 and then another execution of @xmath73 until meeting an agent @xmath62 in state token .",
    "then agent @xmath38 transits to state shadow and @xmath62 becomes its guide .",
    "the proof of the correctness of the algorithm is split into the following lemmas .",
    "[ term ] in algorithm gathering - with - detection every agent eventually stops after time polynomial in @xmath0 and declares that gathering is over .    at its wake - up",
    "an agent @xmath38 enters state setup and remains in it for at most @xmath85 rounds ( the time to complete an exploration and find its label @xmath25 ) and then transits to state cruiser .",
    "we will prove that in state cruiser agent @xmath38 can spend at most @xmath86 rounds .",
    "we will use the following claim",
    ".    * claim 1 . *",
    "let @xmath39 be the first round in which an agent transits to state token .",
    "then there exists an agent @xmath62 that remains in state token and is idle from round @xmath39 on .    to prove the claim ,",
    "let @xmath87 be the set of agents that transited to state token in round @xmath39 .",
    "in every round @xmath88 , the agent from @xmath87 with the current largest memory remains in state token and stays idle .",
    "since an agent with the largest memory in a given round must have had the largest memory in all previous rounds , the claim follows .    in order to prove our upper bound on the time spent by @xmath38 in state cruiser ,",
    "observe that after at most @xmath85 rounds since @xmath38 transits to state cruiser , all other agents have quit state setup .",
    "consider the additional @xmath89 rounds during which agent @xmath38 performs @xmath24 .",
    "let round @xmath90 be the end of the first half of this segment @xmath91 of @xmath89 rounds .",
    "some meeting must have occurred on or before round @xmath90 , due to the properties of @xmath71 . if agent @xmath38 was involved in one of those meetings , it left state cruiser by round @xmath90 . otherwise , it must have met some other agent in state either cruiser or token during the second half of the segment @xmath91 . indeed ,",
    "if it does not meet another agent in state cruiser , it must meet another agent in state token , which transited to this state by round @xmath90 .",
    "( claim 1 guarantees the existence of such an agent after round @xmath90 . )",
    "this proves our upper bound on the time spent by @xmath38 in state cruiser .",
    "from state cruiser agent @xmath38 can transit to one of the three states : shadow , explorer or token .",
    "since the termination conditions for an agent in state shadow are the same as of its guide , we may eliminate the case of state shadow from our analysis .",
    "consider an agent in state explorer .",
    "after the waiting time of @xmath76 rounds ( where @xmath77 is the largest possible label ( it is polynomial in @xmath0 ) agent @xmath38 knows that all other agents have already transited from the state cruiser ( they used at most @xmath85 rounds in state setup and at most @xmath92 rounds in state cruiser , as their labels are at most @xmath77 and at least one token is already present in the graph ) .",
    "either agent @xmath38 never leaves state explorer , in which case we will prove that it declares that gathering is over after polynomial time , in some round @xmath93 , or it transits to state searcher before round @xmath93 , in which case it uses at most @xmath94 rounds for one execution of @xmath73 and after additional at most @xmath94 rounds it finds an idle agent in state token and becomes its shadow ( claim 1 guarantees the existence of such an agent ) .",
    "consider an agent @xmath38 that remains in state explorer till the end of the algorithm . in order to estimate the time before which it must declare that gathering is over , we first compute an upper bound on the number of non - clean explorations",
    "@xmath73 performed by it .",
    "an exploration could be non - clean due to several reasons , according to the description of the algorithm .",
    "* @xmath38 met an agent @xmath66 in state token of higher seniority than that of @xmath38 or of equal seniority but such that @xmath78 , or the token @xmath62 of @xmath38 was visited by an agent @xmath66 in state explorer of higher seniority than that of @xmath62 or of equal seniority but such that @xmath81 , where @xmath83 is the variable @xmath72 of agent @xmath66 .",
    "this case is impossible , as @xmath38 would not remain in state explorer till the end of the algorithm . *",
    "either agent @xmath38 or its token @xmath62 met an agent in state searcher .",
    "since the lifespan of a searcher is at most the time of two consecutive executions of @xmath73 , it can overlap at most three consecutive executions of this procedure .",
    "hence one searcher can make non - clean at most 6 explorations ( 3 by meeting @xmath38 and 3 by meeting @xmath62 ) .",
    "since there are at most @xmath0 searchers , this gives at most @xmath95 non - clean explorations .",
    "* @xmath38 met an agent @xmath66 in state token of lower seniority than that of @xmath38 or of equal seniority but such that @xmath96 .",
    "after this meeting , the remaining time when agent @xmath66 remains in state token is at most the duration of one execution of @xmath73 ( after at most this time the explorer of @xmath66 becomes searcher and hence @xmath66 transits to state shadow ) .",
    "this time can overlap at most two consecutive executions of @xmath73 , hence such meetings can make at most @xmath97 non - clean explorations . *",
    "the token @xmath62 of @xmath38 met an agent @xmath66 in state explorer of lower seniority than that of @xmath62 or of equal seniority but such that @xmath98 .",
    "a similar analysis as in the previous case shows that such meetings can make at most @xmath97 non - clean explorations .",
    "* agent @xmath38 met an agent @xmath66 in state explorer .",
    "the memories of the two agents at this time are different .",
    "after this meeting , the remaining time when agent @xmath66 remains in state explorer is at most the duration of two consecutive executions of @xmath73 because after the return of @xmath66 on its token , the tokens of @xmath38 and @xmath66 have different memories and hence after another exploration , @xmath66 must become a searcher . indeed , since by assumption @xmath38 remains in state explorer till the end of the algorithm , we must have @xmath99 , where @xmath83 is the variable @xmath72 of @xmath66 at the time @xmath39 , where @xmath39 is the first round after the meeting of @xmath38 and @xmath66 , in which agent @xmath66 updated its variable @xmath72 .",
    "this gives at most @xmath100 non - clean explorations .",
    "* @xmath38 met an agent @xmath66 in state token in round @xmath101 , that looked like its token @xmath62 at this time , but that turned out not to be the token @xmath62 after the backtrack of @xmath38 on @xmath62 .",
    "more precisely , @xmath102 in round @xmath101 ( where @xmath39 is the last round when the variable @xmath72 of @xmath38 was updated ) but @xmath103 . after",
    "round @xmath101 agent @xmath66 remains in state token for at most the duration of two executions of @xmath73 .",
    "this gives at most @xmath100 non - clean explorations . * the token @xmath62",
    "was visited by an agent @xmath66 in state explorer , that looked like its explorer @xmath38 at this time , but that turned out not to be @xmath38 after the backtrack of @xmath38 on @xmath62 .",
    "similarly as before , this gives at most @xmath100 non - clean explorations .",
    "hence there can be at most @xmath104 non - clean executions of procedure @xmath73 for agent @xmath38 ( notice that , e.g. , an agent can make non - clean one exploration in the state explorer and then in the state searcher , hence for simplicity we add all the above upper bounds ) .",
    "a similar analysis shows that during at most @xmath104 waiting periods of a duration @xmath75 agent @xmath38 can be met by a new agent .",
    "recall that before performing the first execution of @xmath73 agent @xmath38 has been waiting for @xmath76 rounds .",
    "hence after at most @xmath105 rounds since agent @xmath38 transited to state explorer there has been a clean execution of @xmath73 followed by a waiting period without any new agent coming .",
    "hence agent @xmath38 declares that gathering is over .",
    "it remains to consider an agent @xmath38 in state token . from this state , either at some point the agent transits to state shadow or it remains in state token till the end of the algorithm . in this latter case , its explorer declares that gathering is over after at most @xmath105 rounds since it transited to state explorer .",
    "however , as soon as an explorer declares that gathering is over , its token does the same .",
    "so , agent @xmath38 declares that gathering is over after at most @xmath105 rounds since it transited to state token ( recall that , according to the algorithm , agent @xmath38 and its explorer have reached their current state at the same time ) .",
    "hence every agent eventually terminates .",
    "we conclude by observing that the execution time of the entire algorithm is upper bounded by the sum of the following upper bounds :    * the time between the wake up of the first agent and the time of the wake up of an agent @xmath38 that will be in state explorer when declaring that gathering is over ; this time is upper bounded by @xmath8 . *",
    "the time that such an agent @xmath38 spends in state setup and cruiser * the time that such an agent @xmath38 spends in state explorer    we have shown above that each of these upper bounds is @xmath106 , where @xmath77 is polynomial in @xmath0 . since @xmath8 , @xmath23 and @xmath92",
    "are all polynomial in @xmath0 , this proves that the running time of algorithm gathering - with - detection is polynomial in @xmath0 .    in the sequel we will use the following notion , which is a generalization of the enhanced view of a node .",
    "consider a configuration of agents in any round .",
    "color nodes @xmath1 and @xmath36 with the same color if and only if they are occupied by agents @xmath107 and @xmath108 , respectively , where @xmath109 and @xmath110 have the same memory in this round . a",
    "_ colored _",
    "view from node @xmath1 is the view from @xmath1 in which nodes are colored according to the above rule .    in view of lemma [ term ] , all agents eventually declare that gathering is over .",
    "hence the final configuration must consist of agents in states explorer , token and shadow , all situated in nodes @xmath111 , such that in each node @xmath14 there is exactly one agent @xmath112 in state explorer , exactly one agent @xmath113 in state token and possibly some agents in state shadow .",
    "call such a final configuration a _ clone _",
    "configuration if there are at least two distinct nodes @xmath14 , @xmath114 which have identical colored views .",
    "we will first show that the final configuration can not be a clone configuration and then that it must consist of all agents gathered in a unique node and hence our algorithm is correct .",
    "[ clone ] the final configuration can not be a clone configuration .",
    "suppose for contradiction that the final configuration in round @xmath34 contains distinct nodes which have identical colored views .",
    "let @xmath38 be one of the agents woken up earliest by the adversary .",
    "there exists an agent @xmath69 ( also woken up earliest by the adversary ) which has an identical memory as @xmath38 and an identical colored view .",
    "notice that if two agents have the same memory at time @xmath39 they must have had the same memory at time @xmath115 .",
    "since colors in a colored view are decided by memories of agents , this implies ( by a backward induction on the round number ) that the colored views of @xmath38 and @xmath69 are the same in each round after their wake - up , and in particular _ in _ the round of their wake - up . in this round",
    "no agent has moved yet and hence each agent is in a different node . hence colored views in this round correspond to enhanced views .",
    "thus we can conclude that the enhanced views from the initial positions of agents @xmath38 and @xmath69 were identical , which contradicts the assumption that in the initial configuration every agent has a unique enhanced view .",
    "[ one ] in the final configuration all agents must be at the same node .",
    "let @xmath62 be the first ( or one of the first ) agents in state token that declares that gathering is over .",
    "let @xmath38 be its explorer .",
    "let @xmath116 be the round in which agent @xmath38 starts its last exploration @xmath73 .",
    "let @xmath117 be the round in which backtrack begins during this execution .",
    "let @xmath118 be the round in which this backtrack ( and hence the execution of @xmath73 ) is finished , and let @xmath119 be the round in which @xmath38 declares that gathering is over .",
    "* claim 1 . * in round @xmath116 all agents in state token have the same memory .    in order to prove the claim",
    "we first show that all agents in state token in round @xmath116 have the same seniority .",
    "observe that there can not be any agent in state token of higher seniority than @xmath62 : any such agent would be seen by @xmath38 during its last clean exploration @xmath73 between rounds @xmath116 and @xmath118 contradicting its cleanliness .",
    "also there can not be any agent @xmath66 in state token of lower seniority than @xmath62 .",
    "indeed , let @xmath74 be the explorer of @xmath66 .",
    "either @xmath74 becomes a searcher between @xmath116 and @xmath118 and thus it meets the token @xmath62 before time @xmath120 which contradicts the declaration of @xmath38 and @xmath62 at time @xmath119 or it remains an explorer , in which case @xmath66 remains a token between @xmath116 and @xmath118 and thus @xmath66 is visited by @xmath38 during its last clean exploration , contradicting its cleanliness .",
    "this shows that all agents in state token in round @xmath116 have the same seniority .",
    "hence their explorers start and finish @xmath73 at the same time .",
    "consequently no token existing in round @xmath116 can transit to state shadow before round @xmath118 .",
    "agent @xmath38 must have seen all these tokens during its last exploration .",
    "it follows that the memory of each such token in round @xmath116 must be equal to the memory of @xmath62 at this time : otherwise , agent @xmath38 would detect such a discrepancy during its last exploration , which would contradict the cleanliness of this exploration .",
    "this proves claim 1 .",
    "claim 1 implies that in time @xmath116 all agents in state explorer have the same memory .",
    "indeed , since at time @xmath116 agent @xmath38 is together with @xmath62 , each explorer must be with its token , since tokens have the same memory .",
    "* claim 2 . * in round @xmath116",
    "there are no agents in state searcher .",
    "suppose for contradiction that there is a searcher @xmath91 in round @xmath116 .",
    "recall that @xmath91 performs two explorations : one entire exploration @xmath73 and another partial exploration @xmath73 until meeting a token or an explorer .",
    "_ case 1 . _",
    "@xmath91 finished its first exploration @xmath73 by round @xmath116 . +",
    "hence its second exploration ends by round @xmath118 .",
    "it could not end by round @xmath116 because @xmath91 would not be a searcher in this round anymore .",
    "if it ended between @xmath116 and @xmath118 , it must have met a token @xmath66 . by claim 1 ,",
    "all explorers have the same seniority and hence at time @xmath118 the explorer @xmath74 of @xmath66 backtracked to @xmath66 .",
    "this exploration is not clean for @xmath74 .",
    "either @xmath74 becomes a searcher at time @xmath121 and thus meets @xmath38 and @xmath62 before time @xmath119 , contradicting their declaration at time @xmath119 , or @xmath74 starts another @xmath73 and it meets itself @xmath38 and @xmath62 before time @xmath119 , contradicting their declaration at time @xmath119 .",
    "this shows that the second exploration of @xmath91 can not end between @xmath116 and @xmath118 , hence case 1 is impossible .",
    "_ case 2 . _",
    "@xmath91 finished its first exploration @xmath73 between @xmath116 and @xmath117 . +",
    "hence it must visit some token @xmath66 during its second exploration ( and before starting the backtrack ) by round @xmath118 .",
    "as before , this contradicts the declaration of @xmath38 and @xmath62 at time @xmath119 .",
    "_ case 3 . _",
    "@xmath91 finished its first exploration @xmath73 between @xmath117 and @xmath118 . +",
    "hence the entire backtrack during this first exploration took place between rounds @xmath116 and @xmath118 . during this backtrack",
    ", @xmath91 visited some token .",
    "as before , this contradicts the declaration of @xmath38 and @xmath62 at time @xmath119 .",
    "_ case 4 . _",
    "@xmath91 finished its first exploration @xmath73 after round @xmath118 .",
    "+ this is impossible , as it would not be in state searcher in round @xmath116 .",
    "this concludes the proof of claim 2 .",
    "* claim 3 .",
    "* let @xmath122 be the set of agents in state explorer in round @xmath116 . in round @xmath117",
    "every agent from @xmath122 can reconstruct its colored view in round @xmath116 .    to prove the claim first note that since agent @xmath38 starts its last exploration in round @xmath116 and all agents from @xmath122 have the same memory in round @xmath116 , they all start an exploration @xmath73 in this round . in round @xmath117",
    "every agent from @xmath122 has visited all nodes of the graph and starts its backtrack . in round @xmath116",
    "there are no agents in state setup or cruiser , in view of the waiting time when @xmath38 transited to state explorer , and there are no agents in state searcher by claim 2 .",
    "hence the visit of all nodes between rounds @xmath116 and @xmath117 permits to see all agents that were tokens at time @xmath116 . since at this time every explorer were with its token , this permits to reconstruct the memories and the positions of all agents in round @xmath116 .",
    "this is enough to reconstruct the colored views of all agents in round @xmath116 , which proves the claim .    to conclude the proof of the lemma it is enough to show that in round @xmath116 only one node is occupied by agents , since this will be the final configuration .",
    "suppose that nodes @xmath123 are occupied in this round .",
    "let @xmath38 be the explorer at @xmath1 and @xmath69 the explorer at @xmath124 .",
    "note that the colored views of @xmath38 and @xmath69 in round @xmath116 must be different , for otherwise the configuration in round @xmath116 would be a clone configuration , and consequently the final configuration would also be clone , contradicting lemma [ clone ] . since , by claim 3 , in round @xmath117 each of the agents @xmath38 and @xmath69 has reconstructed its colored view in round @xmath116 , their memories in round @xmath117 are different . between rounds @xmath117 and @xmath118 , during its backtrack , agent @xmath69 has visited again all tokens , in particular the token of @xmath38 .",
    "hence @xmath38 , after backtracking to its token in round @xmath118 , realizes that another explorer has visited its token , which contradicts the cleanliness of the last exploration of @xmath38 .",
    "this contradiction shows that in round @xmath116 only one node is occupied and hence the same is true in the final configuration .",
    "this concludes the proof of the lemma .",
    "now the proof of theorem [ eq ] follows directly from lemmas [ not ] , [ term ] , and [ one ] .",
    "in this section we show that , if no upper bound on the size of the graph is known , then there is no universal algorithm for gathering _ with detection _ all gatherable configurations .",
    "nevertheless , we still show in this case a universal algorithm that gathers all gatherable configurations : upon completion of this algorithm all agents from any gatherable configuration eventually stop forever at the same node ( although no agent is ever sure that gathering is over ) .",
    "the time of such an algorithm is the number of rounds between the wake - up of the first agent and the last round in which some agent moves .",
    "our algorithm is polynomial in the ( unknown ) size of the graph .",
    "we first prove the following negative result .",
    "[ no ] there is no universal algorithm for gathering with detection all gatherable configurations in all graphs .",
    "consider the following initial configurations .",
    "in configuration @xmath66 the graph is a 4-cycle with clockwise oriented ports 0,1 at each node , and with additional nodes of degree 1 attached to two non - consecutive nodes .",
    "there are two agents starting at a node of degree 2 and at its clockwise neighbor , cf .",
    "[ fig : gatherable ] ( a ) . in configuration @xmath125 , for @xmath126 , the graph is constructed as follows .",
    "take a cycle of size @xmath0 with clockwise oriented ports 0,1 at each node .",
    "call clockwise consecutive nodes of the cycle @xmath127 ( names are used only to explain the construction ) and attach two nodes of degree 1 to @xmath128 and one node of degree 1 to every other node with even index .",
    "initial positions of agents are at nodes @xmath14 , where @xmath129 or @xmath130 , for some @xmath131 , cf . fig .",
    "[ fig : gatherable ] ( b ) .     and @xmath132 in the proof of theorem [ no ] .",
    "black nodes are occupied by agents , scaledwidth=80.0% ]    each of the configurations @xmath66 and @xmath125 , for @xmath133 , is gatherable . indeed ,",
    "in each of these configurations there exist agents with different views ( agents starting at nodes of degree 2 and of degree 3 ) and each agent has a unique enhanced view ( this is obvious for configuration @xmath66 and follows from the existence of a unique node of degree 4 for configurations @xmath125 ) .",
    "hence each of these configurations satisfies condition * g * and consequently , by theorem [ eq ] , there is an algorithm for gathering with detection each specific configuration , as such a dedicated algorithm knows the configuration and hence may use the knowledge of the size of the graph .",
    "it remains to show that there is no _ universal _ algorithm that gathers with detection all configurations @xmath66 and @xmath125 .",
    "suppose , for contradiction , that @xmath134 is such an algorithm .",
    "suppose that the adversary wakes up all agents simultaneously and let @xmath39 be the time after which agents in configuration @xmath66 stop at the same node and declare that gathering is over . consider the configuration @xmath135 and two consecutive agents antipodal to the unique node of degree 4 , i.e. , starting from nodes @xmath136 and @xmath137 .",
    "call @xmath138 the agent starting at a node of degree 2 in configuration @xmath66 and call @xmath139 the agent starting at its clockwise neighbor ( of degree 3 ) in this configuration .",
    "call @xmath140 the agent starting at node @xmath137 and call @xmath141 the agent starting at node @xmath136 in configuration @xmath135 . (",
    "again names are used only to explain the construction . )    in the first @xmath39 rounds of the executions of algorithm @xmath134 starting from configurations @xmath66 and @xmath135 the memories of the agents @xmath138 and @xmath140 and of the agents @xmath139 and @xmath141 are the same .",
    "this easily follows by induction on the round number .",
    "hence after @xmath39 rounds agents @xmath140 and @xmath141 starting from configuration @xmath135 stop and ( falsely ) declare that gathering is over .",
    "this contradicts universality of algorithm @xmath134 .",
    "our final result is a universal algorithm gathering all gatherable configurations , working without any additional knowledge .",
    "it accomplishes correct gathering and always terminates but ( as opposed to algorithm gathering - with - detection which used an upper bound on the size of the graph ) , this algorithm does not have the feature of detecting that gathering is over .",
    "we first present a high - level idea of the algorithm , then describe it in detail and prove its correctness . recall that we assume that the initial configuration satisfies condition * g * ( otherwise gathering , even without detection , is impossible by lemma [ not ] ) .",
    "* idea of the algorithm .",
    "*    since in our present scenario no upper bound on the size of the graph is known , already guaranteeing any meeting between agents must be done differently than in algorithm gathering - with - detection . after wake - up",
    "each agent proceeds in phases @xmath142 , where in phase @xmath0 it `` supposes '' that the graph has size @xmath0 . in each phase",
    "an appropriate label based on procedure @xmath22 is computed and procedure @xmath71 is performed sufficiently long to guarantee a meeting at most at the end of phase @xmath143 , where @xmath143 is the real size of the graph . if no meeting occurs in some phase for a sufficiently long time , the agent starts the next phase .",
    "another important difference occurs after the meeting , when one of the agents becomes an explorer and the other its token . unlike in the case of known upper bound on the size of the graph",
    ", there is no way for any explorer to be sure at any point of the execution that it has already visited the entire graph .",
    "clearly procedure @xmath6 can not give this guarantee , as @xmath0 is unknown , and procedure @xmath7 of exploration with a stationary token , which does not require the knowledge of an upper bound , can not give this guarantee either , as an explorer can not be always sure that it visits its own token , because memories of several agents playing the role of the token can be identical at various stages of the execution , and hence these `` tokens '' may be undistinguishable for the explorer .",
    "nevertheless , our algorithm succeeds in accomplishing the task by using a mechanism which is analogous to the `` butterfly effect '' .",
    "even a slight asymmetry in a remote part of the graph is eventually communicated to all agents and guarantees that at some point some explorer will visit the entire graph ( although in some graphs no explorer can ever be sure of it at any point of an execution ) and then all agents will eventually gather at the token of one of these explorers . making all agents decide on the same token uses property * g * and",
    "is one of the main technical difficulties of the algorithm .    * algorithm gathering - without - detection *    similarly as in algorithm gathering - with - detection , an agent can be in one of the following five states : traveler , shadow , explorer , token , searcher",
    ". state traveler partly combines the roles of previous states setup and cruiser .",
    "for every agent @xmath38 in state shadow the notion of guide is defined as before .",
    "below we describe the actions of an agent @xmath38 in each of the states and the transitions between the states . at wake - up agent",
    "@xmath38 enters the state traveler .",
    "* state * traveler .    in this state agent @xmath38",
    "works in phases numbered @xmath144 . in phase @xmath0 the agent supposes that the graph has size @xmath0",
    ". agent @xmath38 performs @xmath6 in order to visit all nodes and wake up all still dormant agents , if the assumption was correct .",
    "then agent @xmath38 performs the procedure @xmath22 finding the current signature of its initial position @xmath1 , called the _ label _",
    "@xmath145 of agent @xmath38 .",
    "let @xmath146 be the maximum possible label of an agent in phase @xmath0 ( note that @xmath146 is polynomial in @xmath0 . )",
    "then agent @xmath38 performs @xmath147 for @xmath148 rounds , where @xmath149 , for @xmath150 , and @xmath151 . in this formula , @xmath152 defined as @xmath153 is an upper bound on the duration of phase @xmath43 .",
    "if no agent has been met during phase @xmath0 , agent @xmath38 starts phase @xmath154 .",
    "as soon as another agent is met in some phase @xmath11 , agent @xmath38 interrupts this phase and transits either to state shadow or token or explorer .",
    "suppose that the first meeting of agent @xmath38 occurs in round @xmath39 at node @xmath1 .",
    "there are some agents in round @xmath39 at node @xmath1 which are either in state searcher , or explorer or token .",
    "+ let @xmath155 be the set of these agents .",
    "let @xmath156 be the agent of largest memory in set @xmath155 .",
    "agent @xmath38 transits to state shadow and its guide is @xmath156 .",
    "there are only agents in state traveler in round @xmath39 at node @xmath1 .",
    "subcase 2.1 .",
    "agent @xmath38 has the largest memory among all agents in round @xmath39 at node @xmath1 . +",
    "then agent @xmath38 transits to state explorer .",
    "subcase 2.2 .",
    "agent @xmath38 does not have the largest memory among all agents in round @xmath39 at node @xmath1 .",
    "+ if there is exactly one agent @xmath62 with memory larger than @xmath38 , then agent @xmath38 transits to state token . otherwise , it transits to state shadow of the agent with largest memory .",
    "( note that cases 1 and 2 cover all possibilities because an agent in state shadow always accompanies its guide and this guide can not be an agent in state traveler . )    * state * shadow .",
    "agent @xmath38 has exactly one guide and is at the same node as the guide in every round . in every round it makes the same move as the guide .",
    "if the guide @xmath62 transits itself to state shadow and gets agent @xmath66 as its guide , then agent @xmath38 changes its guide to @xmath66 as well .    in the description of the actions in the three remaining states ,",
    "we will use the notion of seniority defined for algorithm gathering - with - detection .",
    "* state * explorer .",
    "when agent @xmath38 transits to state explorer , there is another agent @xmath62 that transits to state token in the same round at the same node @xmath1 .",
    "agent @xmath62 is called the token of @xmath38 .",
    "agent @xmath38 has a variable @xmath72 that it initializes to the memory of @xmath62 in this round .",
    "we first define the notion of a _ consistent meeting _ for agent @xmath38 .",
    "let @xmath39 be the last round when agent @xmath38 updated its variable @xmath72 .",
    "a consistent meeting for @xmath38 is a meeting in round @xmath157 with an agent @xmath66 in state token of the same seniority as @xmath38 , such that @xmath59 is the current memory of @xmath66 and @xmath158 .",
    "intuitively , a consistent meeting is a meeting of an agent that @xmath38 can plausibly consider to be its token @xmath62 .",
    "note that , according to this definition , a meeting in the round when the variable @xmath72 is updated , is not a consistent meeting .",
    "we now briefly describe the procedure @xmath7 based on @xcite that will be subsequently adapted to our needs .",
    "the agent constructs a bfs tree rooted at its starting node @xmath159 marked by the stationary token . in this tree it marks port numbers at all nodes . during the bfs traversal",
    ", some nodes are added to the bfs tree . in the beginning the root is added . whenever a node @xmath36 is added to the bfs tree ,",
    "all its neighbors are visited by the agent . for each neighbor @xmath1 of @xmath36 , the agent verifies if @xmath1 is equal to some node @xmath5 previously added to the tree . to do this , the agent travels from @xmath1 using the reversal @xmath160 of the path @xmath46 from @xmath159 to @xmath5 ( the path @xmath46 is a sequence of port numbers ) .",
    "if at the end of this backtrack it meets the token , then @xmath161 . in this case",
    "@xmath1 is not added to the tree as a neighbor of @xmath36 and is called @xmath36-_rejected_. if not , then @xmath162 .",
    "this verification is done for all nodes that are already in the tree .",
    "if @xmath1 is different from all these nodes , then it is added to the tree .",
    "the procedure @xmath163 is a simulation of @xmath7 with the following two changes .",
    "the first change is as follows .",
    "suppose that the execution of @xmath7 produced the route @xmath164 of the agent . in procedure @xmath163 , upon completing procedure @xmath7 , the agent traverses the reverse route @xmath165 and then again @xmath164 and @xmath165 .",
    "hence in procedure @xmath163 the agent traverses the concatenation of routes @xmath166 .",
    "these parts of the trajectory will be called , respectively , the first , second , third and fourth segment of @xmath163 . the variable @xmath72 is updated in the beginning of the first and third segment of @xmath163 .",
    "note that in these rounds agent @xmath38 is certain to be with its token .",
    "the second change concerns meetings with the token .",
    "consider a verification if a newly reached node @xmath36 in @xmath7 is equal to some previously constructed node @xmath5 .",
    "this verification consists in traveling from @xmath36 using the reverse path @xmath160 , where @xmath46 is the path from the root @xmath159 to @xmath5 in the bfs tree and checking the presence of the token .",
    "if at the end of the simulation of path @xmath160 in the first segment of @xmath163 agent @xmath38 makes a consistent meeting , then it acts as if it saw the token in @xmath7 ; otherwise it acts as if it did not see the token in @xmath7 .",
    "similarly as for @xmath73 , an execution of @xmath163 is called _",
    "clean _ if the following condition is satisfied : in each round during this execution , in which @xmath38 met an agent @xmath66 , the memory of @xmath66 is equal to that of @xmath62 , and in each round during this execution , in which the token @xmath62 was met by an agent @xmath74 , the memory of @xmath74 was equal to that of @xmath38 .",
    "notice that after the execution of @xmath163 , agent @xmath38 is together with its token @xmath62 and thus they can verify if the execution was clean , by inspecting their memories .",
    "the execution time of @xmath163 in a graph of size @xmath143 ( unknown to the agents ) is at most @xmath167 .",
    "after transiting to state explorer , agent @xmath38 executes the following protocol :    * repeat forever * + /*before the first turn of the loop agent @xmath38 has just entered state explorer and is with its token .",
    "after each turn of the loop , agent @xmath38 is with its token , waiting after a clean exploration.*/    @xmath38 has just transited to state explorer * or * @xmath38 has just been visited by another agent * then * +   + @xmath163    @xmath38 met an agent @xmath66 in state token of higher seniority than that of @xmath38 or of equal seniority but + such that @xmath78 where @xmath79 is the memory of agent @xmath66 and @xmath39 is the last + round when agent @xmath38 updated its variable @xmath72 * then * @xmath38 transits to state searcher    @xmath38 met another agent @xmath66 in state explorer , such that either the seniority of @xmath66 is higher + than that of @xmath38 , or these seniorities are equal but @xmath168 , + where @xmath169 is the value of the variable @xmath72 of @xmath38 and @xmath170 is the value + of the variable @xmath72 of @xmath62 at the time of the meeting , + or the seniorities are equal and @xmath171 , but @xmath172 , + where @xmath173 ( resp .",
    "@xmath174 ) is the memory of @xmath38 ( resp . of @xmath66 ) at the time of the meeting + @xmath38 transits to state searcher    @xmath62 was visited in round @xmath80 by an agent @xmath66 in state explorer of higher seniority than that of @xmath62 + or of equal seniority but such that @xmath81 where @xmath82 is the memory of agent @xmath62 + and @xmath83 is the variable @xmath72 of agent @xmath66 in round @xmath80 * then * @xmath38 transits to state searcher    the execution of @xmath163 is clean    * state * token .    when agent @xmath38 transits to state token , there is another agent @xmath62 that transits to state explorer in the same round at the same node @xmath1 .",
    "agent @xmath62 is called the explorer of @xmath38 .",
    "agent @xmath38 remains idle at a node @xmath1 and does not change its state , except when its explorer @xmath62 transits to state searcher . in this case",
    "it transits to state shadow and @xmath62 becomes its guide .    * state * searcher    after transiting to state searcher agent @xmath38 performs the sequence of explorations @xmath6 for @xmath142 until it meets an agent in state token or explorer in round @xmath39 . let @xmath175 be the set of these agents met by @xmath38 in round @xmath39 .",
    "agent @xmath38 transits to state shadow and its guide is the agent from @xmath175 with largest memory .",
    "the analysis of the algorithm is split into the following lemmas .",
    "[ term2 ] in algorithm gathering - without - detection every agent eventually stops after time polynomial in the size of the graph .",
    "let @xmath143 be the size of the graph ( unknown to the agents ) .",
    "let @xmath38 be any agent .",
    "we may assume that at some point @xmath38 is woken up ( otherwise it would be idle all the time ) .",
    "similarly as in the proof of lemma [ term ] we show that @xmath38 must meet some other agent at the end of phase @xmath143 at the latest . indeed , the time @xmath176 during which @xmath38 performs the procedure @xmath71 in phase @xmath143 is sufficiently long for meeting some agent , as all agents have to be woken up by the round when @xmath38 starts performing @xmath71 in phase @xmath143 .",
    "hence after time at most @xmath176 agent @xmath38 transits from state traveler either to state shadow or token or explorer . as before we may exclude the state shadow from our analysis .",
    "consider an agent in state explorer .",
    "either at some point it transits to state searcher , in which case , after this transition , it uses at most @xmath177 rounds to perform procedures @xmath178 for @xmath179 , by which time it must have met some token or explorer ( because at least one token is idle all the time , cf .",
    "claim 1 in the proof of lemma [ term ] ) and hence must have transited to state shadow , or it remains in state explorer till the end of the algorithm .",
    "consider an agent @xmath38 that remains in state explorer till the end of the algorithm .",
    "we will first show that the total number of rounds when this agent moves is polynomial in @xmath143 .",
    "this is not enough to show that @xmath38 remains idle forever after polynomial time , since we still need to bound the duration of each period of idleness between any consecutive periods of moving .",
    "this will be addressed later .",
    "two events can trigger further moves of the agent : a meeting causing a non - clean exploration @xmath163 or a visit of @xmath38 by some agent , when @xmath38 stays with its token after a clean exploration .",
    "we first treat the first of these two types of events and bound the total time of explorations caused by them .",
    "an exploration could be non - clean due to several reasons , according to the description of the algorithm .",
    "* @xmath38 met an agent @xmath66 in state token of higher seniority than that of @xmath38 or of equal seniority but such that @xmath78 , or the token @xmath62 of @xmath38 was visited by an agent @xmath66 in state explorer of higher seniority than that of @xmath62 or of equal seniority but such that @xmath81 , where @xmath83 is the variable @xmath72 of agent @xmath66 .",
    "this case is impossible , as @xmath38 would not remain in state explorer till the end of the algorithm . *",
    "either agent @xmath38 or its token @xmath62 met an agent @xmath66 in state traveler . since @xmath66 transits immediately to state shadow",
    ", all agents in state traveler can cause at most @xmath180 rounds of motion of @xmath38 .",
    "indeed , each agent in state traveler can cause at most one exploration @xmath163 to be non - clean . *",
    "either agent @xmath38 or its token @xmath62 met an agent @xmath66 in state searcher . since @xmath66 transits immediately to state shadow",
    ", all agents in state searcher can cause at most @xmath180 rounds of motion of @xmath38 .",
    "indeed , each agent in state searcher can cause at most one exploration @xmath163 to be non - clean .",
    "* @xmath38 met an agent @xmath66 in state token of lower seniority than that of @xmath38 or of equal seniority but such that @xmath96 .",
    "after this meeting , the remaining time when agent @xmath66 remains in state token is at most the longest duration of one execution of @xmath163 ( after at most this time the explorer of @xmath66 becomes searcher and hence @xmath66 transits to state shadow ) .",
    "let @xmath39 be the round of the meeting .",
    "agent @xmath66 remains in state token till round @xmath80 , where @xmath181 .",
    "so after @xmath80 there can be at most one exploration @xmath163 of @xmath38 non - clean because of @xmath66 , finishing in round at most @xmath182 and then a possibly clean exploration till round @xmath183 .",
    "hence all such meetings can cause at most @xmath184 rounds of motion of @xmath38 , apart from the current exploration . *",
    "the token @xmath62 of @xmath38 met an agent @xmath66 in state explorer of lower seniority than that of @xmath62 or of equal seniority but such that @xmath98 .",
    "a similar analysis as in the previous case shows that such meetings can cause at most @xmath184 rounds of motion of @xmath38 , apart from the current exploration .",
    "* agent @xmath38 met an agent @xmath66 in state explorer .",
    "after the meeting one of these agents `` loses '' , i.e. , it will transit to state searcher after backtracking to its token .",
    "this loser can not be @xmath38 because , by definition @xmath38 is an agent that remains in state explorer till the end .",
    "hence agent @xmath66 remains in state explorer for at most @xmath167 rounds after the meeting .",
    "similarly as before such meetings can cause at most @xmath184 rounds of motion of @xmath38 , apart from the current exploration . * @xmath38 met an agent @xmath66 in state token in round @xmath101 , that looked like its token @xmath62 at this time , but that turned out not to be the token @xmath62 after the backtrack of @xmath38 on @xmath62 .",
    "more precisely , @xmath102 in round @xmath101 ( where @xmath39 is the last round when the variable @xmath72 of @xmath38 was updated ) but @xmath103 . after round @xmath101 agent @xmath66",
    "may look like token @xmath62 of @xmath38 for at most @xmath167 rounds because after at most this time @xmath38 backtracks to its token @xmath62 and , from this time on , it can see the difference between @xmath62 and @xmath66 . similarly as before such meetings can cause at most @xmath184 rounds of motion of @xmath38 , apart from the current exploration . * the token @xmath62 was visited by an agent @xmath66 in state explorer , that looked like its explorer @xmath38 at this time , but that turned out not to be @xmath38 after the backtrack of @xmath38 on @xmath62 . similarly as before such meetings can cause at most @xmath184 rounds of motion of @xmath38 , apart from the current exploration .",
    "hence the first of the two types of events ( meeting causing a non - clean exploration ) can cause at most @xmath185 rounds of motion of @xmath38 , apart from the first exploration .",
    "( as before we add all upper bounds for simplicity ) .",
    "the second type of events ( a visit of @xmath38 by some agent , when @xmath38 stays with its token after a clean exploration ) can cause at most the above time of moving of @xmath38 .",
    "adding one clean exploration that must be made by @xmath38 even without any meetings and adding the first exploration , we get an upper bound of @xmath186 rounds during which agent @xmath38 moves in state explorer .    it remains to consider an agent in state token .",
    "it may either transit to state shadow or remain in state token forever . in the latter case it is idle all the time .    since @xmath187 , @xmath9 and @xmath8 are all polynomial in @xmath0 , the above analysis shows that there exists a polynomial @xmath139 , such that , for each agent @xmath38 executing algorithm gathering - without - detection in any graph of size @xmath143 , the number of rounds during which this agent moves is at most @xmath188 . in order to finish the proof",
    ", we need to bound the number of rounds during which an agent @xmath38 can be idle before moving again .",
    "to do this we will use the following claim .",
    "* claim . *",
    "if in round @xmath39 of the execution of algorithm gathering - without - detection no agent moves , then no agent moves in any later round of this execution .",
    "to prove the claim notice that if no agent moves in round @xmath39 , then in this round no agent is in state traveler or searcher",
    ". moreover each agent in state explorer must be idle and stay with its token in this round ( all other nodes must be in state shadow ) . in order for some agent to move in round @xmath189",
    ", some explorer would have to visit some other token in round @xmath39 , contradicting the definition of @xmath39 .",
    "hence all agents are idle in round @xmath189 . by induction ,",
    "all agents are idle from round @xmath39 on .",
    "this proves the claim .    since for each agent executing algorithm gathering - without - detection in a graph of size @xmath143 ,",
    "the number of rounds in which it moves is at most @xmath188 and there are at most @xmath143 agents , the claim implies that after time at most @xmath190 since the wake up of the first agent , all agents must stop forever .    by lemma [ term2 ]",
    "there exists a round after which , according to algorithm gathering - without - detection , no agent moves .",
    "call the resulting configuration _",
    "final_. the following lemma implies that algorithm gathering - without - detection is correct .",
    "[ cor ] in every final configuration exactly one node is occupied by agents .",
    "a final configuration must consist of agents in states explorer , token and shadow , all situated in nodes @xmath111 , such that in each node @xmath14 there is exactly one agent @xmath112 in state explorer , exactly one agent @xmath113 in state token and possibly some agents in state shadow .",
    "as before we call such a final configuration a _ clone _",
    "configuration if there are at least two distinct nodes @xmath14 , @xmath114 which have identical colored views .",
    "the same argument as in the proof of lemma [ clone ] shows that a final configuration can not be a clone configuration .",
    "it is enough to prove that @xmath191 .",
    "suppose for contradiction that @xmath192 .",
    "we will consider two cases .",
    "in the first case the memories of all explorers @xmath112 are identical and in the second case they are not . in both cases",
    "we will derive a contradiction .",
    "all explorers @xmath112 in the final configuration have identical memory .    in this case",
    "all these explorers performed the last exploration @xmath163 simultaneously .",
    "we start with the following claim .    * claim 1 . *",
    "if a node @xmath36 has been rejected by the explorer @xmath193 in the construction of its bfs tree during its last exploration @xmath163 , then node @xmath36 must have been either added previously by @xmath193 to its bfs tree , or added by another explorer @xmath194 in the construction of its bfs tree during its last exploration @xmath163 .",
    "the node @xmath36 was rejected by @xmath193 for the following reason .",
    "@xmath193 traveled from @xmath36 using the reversal @xmath160 of the path @xmath46 , where @xmath46 is a path ( coded as a sequence of ports ) from @xmath114 to some node @xmath5 already in the bfs tree of @xmath193 , and at the end of this path @xmath160 , @xmath193 met a token with memory @xmath59 , such that @xmath158 , where @xmath39 is the last round when @xmath193 updated its variable @xmath72 .",
    "there are two possible cases .",
    "if the token met by @xmath193 is its own token ( residing at @xmath114 ) , then @xmath36 is equal to some node @xmath5 already added previously to the bfs tree of @xmath193 . if , on the other hand , the token met by @xmath193 is the token of some other explorer @xmath194 , then we will show that @xmath36 is added by @xmath194 to its bfs tree .",
    "indeed , since @xmath193 has added a node @xmath5 to its bfs tree , such that the path from @xmath114 to @xmath5 is @xmath46 , the explorer @xmath194 must have added a node @xmath195 to its bfs tree , such that the path from @xmath196 to @xmath195 is @xmath46 as well , because both @xmath194 and @xmath193 have identical memories . however , this node @xmath195 must be equal to @xmath36 , since the path from @xmath36 to @xmath196 is @xmath160 .",
    "this proves the claim .",
    "the contradiction in case 1 will be obtained in the following way . using bfs trees produced by explorers @xmath112 during their last exploration @xmath163 ( recall that these trees are isomorphic , since memories of the explorers are identical ) , we will construct the colored view for each explorer .",
    "using the fact that memories of the explorers are identical , these colored views will be identical .",
    "this will imply that the final configuration is a clone configuration , which is impossible .",
    "the construction proceeds as follows ( we will show it for explorer @xmath197 ) .",
    "let @xmath113 be the bfs tree produced by @xmath112 .",
    "each tree @xmath113 has its root @xmath14 colored black and all other nodes colored white .",
    "we will gradually attach various trees to @xmath198 in order to obtain the colored view from @xmath199 .",
    "first attach to every node of @xmath198 its neighbors that have been rejected by @xmath197 during the construction of @xmath198 .",
    "explorer @xmath197 has visited these nodes , hence the respective port numbers can be faithfully added .",
    "consider any such rejected node @xmath36 . by claim 1 , there are two possibilities . if node @xmath36 was previously added by @xmath197 to @xmath198 as some node @xmath5 , then we proceed as follows .",
    "let @xmath200 be the tree @xmath198 but rooted at @xmath5 instead of @xmath199 .",
    "we attach tree @xmath200 at @xmath36 , identifying its root @xmath5 with @xmath36 .",
    "if node @xmath36 was added by another explorer @xmath194 in the construction of its bfs tree @xmath201 , we proceed as follows .",
    "as mentioned in the proof of claim 1 , the explorer @xmath194 must have added a node @xmath195 to its bfs tree , such that the path from @xmath196 to @xmath195 is @xmath46 .",
    "let @xmath202 be the tree @xmath201 but rooted at @xmath195 instead of @xmath196 .",
    "we attach tree @xmath202 at @xmath36 , identifying its root @xmath195 with @xmath36 .",
    "after processing all nodes rejected by @xmath197 and adding the appropriate trees , we attach all rejected neighbors of nodes in the newly obtained increased tree .",
    "these nodes could have been rejected either by @xmath197 itself or by another explorer @xmath193 whose ( re - rooted ) tree @xmath203 has been attached . for each newly attached node rejected by @xmath193 ,",
    "the construction continues as before , replacing the role of @xmath198 by @xmath204 .",
    "the above construction proceeds infinitely , producing the view from @xmath199 , which is an infinite tree .",
    "( this infinite tree is indeed the view from @xmath199 because whenever a node is added to the tree , all its neighbors are eventually added as well , with the correct port numbers . ) to produce the colored view , notice that there are only two colors in this colored view : white corresponding to empty nodes in the final configuration and black corresponding to nodes @xmath199 , ... , @xmath205 ( all these nodes get identical colors : since memories of explorers are the same , memories of their tokens are also the same and memories of corresponding nodes in state shadow are also identical ) .",
    "it remains to indicate how the colors are distributed in the constructed view .",
    "this is done as follows .",
    "when a tree @xmath203 is attached , exactly one of its nodes ( namely the node corresponding to @xmath114 ) is black .",
    "exactly these nodes become black in the obtained colored view .",
    "this construction of colored views is done for all explorers @xmath112 .",
    "consider two explorers @xmath112 and @xmath193 .",
    "since these explorers have the same memory , the trees @xmath202 attached at a given stage of the construction of the views of @xmath112 and @xmath193 are isomorphic .",
    "they are also attached in the same places of the view .",
    "hence by induction of the level of the view it follows that both colored views are identical .",
    "this implies that the final configuration is a clone configuration which gives a contradiction in case 1 .",
    "there are at least two explorers @xmath112 and @xmath193 with different memories in the final configuration .",
    "consider the equivalence relation on the set of explorers @xmath206 , such that two explorers are equivalent if their memories in the final configuration are identical .",
    "let @xmath207 , where @xmath208 , be the equivalence classes of this relation .",
    "suppose w.l.o.g . that @xmath209 is a class of explorers with smallest seniority .",
    "we will use the following claim .",
    "* claim 2 . * during the last exploration @xmath163 of explorers in @xmath209 , at least one of the following statements holds :    * an explorer from @xmath209 has visited a token of an explorer not belonging to @xmath209 ; * a token of an explorer from @xmath209 has been visited by an explorer not belonging to @xmath209 .    in order to prove the claim consider two cases .",
    "if every node of the graph has been visited by some explorer from @xmath209 we will show that the first statement holds .",
    "indeed , since explorers from @xmath209 have the smallest seniority , during their last execution of @xmath163 all tokens are already at their respective nodes .",
    "hence some explorers from @xmath209 must visit the tokens of explorers outside of @xmath209 .",
    "hence we can restrict attention to the second case , when some nodes of the graph have not been visited by any explorer from @xmath209 .",
    "notice that if there were no other classes than @xmath209 , this could not occur .",
    "indeed , we would be then in case 1 ( in which all explorers have identical memory ) .",
    "thus claim 1 would hold , which implies that all nodes must be visited by some explorer , in view of the graph connectivity .",
    "hence the fact that some node is not visited by explorers from @xmath209 must be due to a meeting of some other agent ( which is neither an explorer from @xmath209 nor a token of such an explorer ) during their last exploration @xmath163 .",
    "what kind of a meeting can it be ?",
    "it can not be a meeting with an agent in state traveler or searcher because this would contradict that the last exploration was clean .",
    "for the same reason it can not be a meeting of an explorer from @xmath209 with another explorer .",
    "this leaves only the two types of meetings specified in the claim , which finishes the proof of the claim .",
    "let @xmath210 be a couple of an explorer outside of @xmath209 and of its token , such that either an explorer from @xmath209 visited @xmath211 or a token of an explorer from @xmath209 has been visited by @xmath212 during the last exploration of explorers in the class @xmath209 .",
    "such a couple exists by claim 2 .",
    "the seniority of @xmath212 and @xmath211 must be the same as that of explorers from @xmath209 , for otherwise their last exploration would not be clean .",
    "for the same reason , when explorers from @xmath209 started their last exploration , the explorer @xmath212 must have started an exploration as well ( possibly not its final exploration ) : otherwise the exploration of explorers from @xmath209 would not be clean . moreover we show that when explorers from @xmath209 finished their last exploration , explorer @xmath212 must have finished an exploration as well . to prove this ,",
    "consider two cases , corresponding to two possibilities in claim 2 .",
    "suppose that an explorer @xmath193 from @xmath209 has visited @xmath211 and that its exploration did not finish simultaneously with the exploration of @xmath212 .",
    "consider the consecutive segments @xmath213 of the last exploration @xmath163 of @xmath193 .",
    "( recall that these segments were specified in the definition of @xmath163 . ) since @xmath193 has visited @xmath211 during @xmath163 , it must have visited it during each segment @xmath214 . at the end of @xmath215 ,",
    "explorer @xmath193 knows how long @xmath163 will take . at the end of @xmath216",
    "its token learns it as well .",
    "when @xmath193 visits @xmath211 again in segment @xmath217 , there are two possibilities .",
    "either @xmath211 does not know when the exploration of @xmath212 finishes , or it does know that it finishes at a different time than the exploration of @xmath193 . in both cases",
    "the explorer @xmath193 that updated its variable @xmath72 at the end of @xmath216 can see that @xmath218 , where @xmath59 is the memory of @xmath211 and @xmath39 is the end of @xmath216 .",
    "this makes the last exploration of @xmath193 non clean , which is a contradiction .",
    "this proves that @xmath212 and @xmath193 finish their exploration simultaneously , if @xmath193 has visited @xmath211 .",
    "the other case , when @xmath212 has visited the token of @xmath193 is similar .",
    "hence we conclude that explorations of @xmath193 and of @xmath212 started and finished simultaneously .",
    "let @xmath90 be the round in which the last exploration of @xmath193 ( and hence of all explorers in @xmath209 ) finished .",
    "the exploration of @xmath212 that finished in round @xmath90 can not be its final exploration because then it would have the same memory as @xmath193 in the final configuration and thus it would be in the class @xmath209 contrary to the choice of @xmath212 . hence @xmath212 must move after round @xmath90 .",
    "it follows that there exists a class @xmath219 ( w.l.o.g .",
    "let it be @xmath220 ) such that explorers from this class started their last exploration after round @xmath90 .",
    "note that during this last exploration , explorers from @xmath220 could not visit all nodes of the graph , for otherwise they would meet explorers from @xmath209 after round @xmath90 , inducing them to move after this round , contradicting the fact that explorers from @xmath209 do not move after round @xmath90 .",
    "the fact that some node is not visited by explorers from @xmath220 must be due to a meeting of some other agent ( which is neither an explorer from @xmath220 nor a token of such an explorer ) during their last exploration @xmath163 .",
    "otherwise , for explorers in @xmath220 the situation would be identical as if their equivalence class were the only one , and hence , as in case 1 , they would visit all nodes .",
    "moreover , the fact that some node is not visited by explorers from @xmath220 must be due to a meeting of some explorer outside of @xmath209 or of its token ( if not , explorers from @xmath209 would move after round @xmath90 , which is a contradiction ) .",
    "an argument similar to that used in the proof of claim 2 shows that there exists a couple @xmath221 , such that @xmath222 is an explorer outside of @xmath223 , @xmath224 is its token , and either an explorer from @xmath220 visited @xmath224 or a token of an explorer from @xmath220 has been visited by @xmath222 during the last exploration of explorers in the class @xmath220 .",
    "let @xmath225 be the round in which the last exploration of explorers from @xmath220 is finished .",
    "similarly as before , the explorer @xmath222 terminates some exploration in round @xmath225 but continues to move afterwards .    repeating the same argument @xmath226 times",
    "we conclude that there exists a round @xmath227 after which all explorers from @xmath228 never move again , but the last exploration of explorers from @xmath229 starts on or after @xmath227 . during this last exploration",
    "there must be a node not visited by any explorer from @xmath229 , otherwise some explorers from @xmath228 would move after @xmath227 .",
    "this is due to a meeting .",
    "it can not be a meeting with an agent in state traveler or searcher because this would contradict that the last exploration was clean .",
    "for the same reason it can not be a meeting of an explorer from @xmath229 with another explorer . hence two possibilities remain .",
    "either an explorer from @xmath229 visits a token of an explorer from @xmath228 or a token of an explorer from @xmath229 is visited by an explorer from @xmath228 .",
    "the first situation is impossible because it would contradict the cleanliness of the last exploration of explorers from @xmath229 and the second situation is impossible because explorers from @xmath228 do not move after @xmath227 .",
    "hence in case 2 we obtain a contradiction as well , which completes the proof .",
    "lemmas [ term2 ] and [ cor ] imply the following result .",
    "algorithm gathering - without - detection performs a correct gathering of all gatherable configurations and terminates in time polynomial in the size of the graph .",
    "leader election @xcite is a fundamental symmetry breaking problem in distributed computing .",
    "its goal is to assign , in some common round , value 1 ( leader ) to one of the entities and value 0 ( non - leader ) to all others . in the context of anonymous agents in graphs ,",
    "leader election can be formulated as follows :      the following proposition implies that algorithm gathering - with - detection solves the leader election problem for anonymous agents in arbitrary graphs , assuming a known upper bound on the size of the graph .",
    "suppose that gathering with detection is accomplished and let @xmath39 be the round when all agents are together and declare that gathering is over . as mentioned in the preliminaries , all agents must have different memories , since they are at the same node , and , being together , they can compare these memories . since , in view of detection , the round @xmath39 is known to all agents , in round @xmath189 the agent with the largest memory assigns itself value 1 and all other agents assign themselves value 0 .",
    "conversely , suppose that leader election is accomplished and let @xmath39 be the round in which one of the agents assigns itself value 1 and all other agents assign themselves value 0 .",
    "starting from round @xmath39 the agent with value 1 stops forever and plays the role of the token , all other agents playing the role of explorers .",
    "first , every explorer finds the token by executing procedure @xmath6 for @xmath8 rounds in phases @xmath230 , until it finds the token in round @xmath80 ( this round may be different for every explorer ) .",
    "then every explorer executes procedure @xmath7 ( using the token ) and finds the map of the graph and hence its size @xmath143 .",
    "then it waits with the token until round @xmath231 . by this round all explorers must have found the token and executed procedure @xmath7 , i.e. , they are all together with the token . in round",
    "@xmath232 all agents declare that gathering is over .",
    "proposition [ eqbis ] implies that the class of initial configurations for which leader election is at all possible ( even only using an algorithm dedicated to this specific configuration ) is equal to the class of initial configurations for which gathering with detection is possible , i.e. , the class of configurations satisfying property * g*. similarly as for gathering , we will say that a leader election algorithm is _ universal _ if it performs leader election for all such configurations .",
    "if an upper bound on the size of the graph is known , then leader election is possible if and only if the initial configuration satisfies condition * g*. algorithm gathering - with - detection accomplishes leader election for all these configurations ( by electing as leader the agent that has the largest memory in the round of the gathering declaration ) . if no upper bound on the size of the graph is known , then a universal algorithm for leader election does not exist .",
    "e. bampas , j. czyzowicz , l. gasieniec , d. ilcinkas , a. labourel , almost optimal asynchronous rendezvous in infinite multidimensional grids .",
    "24th international symposium on distributed computing ( disc 2010 ) , 297 - 311 .",
    "j. chalopin , s. das , a. kosowski , constructing a map of an anonymous graph : applications of universal sequences , proc .",
    "14th international conference on principles of distributed systems ( opodis 2010 ) , 119 - 134 .",
    "p. flocchini , g. prencipe , n. santoro , p. widmayer , gathering of asynchronous oblivious robots with limited visibility , proc .",
    "18th annual symposium on theoretical aspects of computer science ( stacs 2001 ) , springer lncs 2010 , 247 - 258 ."
  ],
  "abstract_text": [
    "<S> a team consisting of an unknown number of mobile agents , starting from different nodes of an unknown network , possibly at different times , have to meet at the same node . </S>",
    "<S> agents are anonymous ( identical ) , execute the same deterministic algorithm and move in synchronous rounds along links of the network . </S>",
    "<S> an initial configuration of agents is called _ gatherable _ if there exists a deterministic algorithm ( even dedicated to this particular configuration ) that achieves meeting of all agents in one node . </S>",
    "<S> which configurations are gatherable and how to gather all of them deterministically by the same algorithm ?    </S>",
    "<S> we give a complete solution of this gathering problem in arbitrary networks . </S>",
    "<S> we characterize all gatherable configurations and give two _ universal _ deterministic gathering algorithms , i.e. , algorithms that gather all gatherable configurations . </S>",
    "<S> the first algorithm works under the assumption that an upper bound @xmath0 on the size of the network is known . in this case </S>",
    "<S> our algorithm guarantees _ gathering with detection _ , i.e. , the existence of a round for any gatherable configuration , such that all agents are at the same node and all declare that gathering is accomplished . if no upper bound on the size of the network is known , we show that a universal algorithm for gathering with detection does not exist . </S>",
    "<S> hence , for this harder scenario , we construct a second universal gathering algorithm , which guarantees that , for any gatherable configuration , all agents eventually get to one node and stop , although they can not tell if gathering is over . </S>",
    "<S> the time of the first algorithm is polynomial in the upper bound @xmath0 on the size of the network , and the time of the second algorithm is polynomial in the ( unknown ) size itself .    </S>",
    "<S> our results have an important consequence for the leader election problem for anonymous agents in arbitrary graphs . </S>",
    "<S> leader election is a fundamental symmetry breaking problem in distributed computing . </S>",
    "<S> its goal is to assign , in some common round , value 1 ( leader ) to one of the entities and value 0 ( non - leader ) to all others . for anonymous agents in graphs , </S>",
    "<S> leader election turns out to be equivalent to gathering with detection . </S>",
    "<S> hence , as a by - product , we obtain a complete solution of the leader election problem for anonymous agents in arbitrary graphs .    </S>",
    "<S> * keywords : * gathering , deterministic algorithm , anonymous mobile agent .    0.18 in 0.0 in 0.3 in </S>"
  ]
}