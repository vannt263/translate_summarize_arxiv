{
  "article_text": [
    "graph coloring is an important problem related to ( optimal ) resource allocation , mainly used to establish an optimal order in which resources have to be allocated to processes  @xcite .",
    "the distance-@xmath5 coloring problem consists in assigning colors to the vertices of the graph such that no two vertices at distance at most @xmath5 have the same color .",
    "let us remember that minimum distance-@xmath6 vertex coloring is an np - complete problem  @xcite .",
    "coloring is ( with leader election  @xcite and renaming  @xcite ) one of the most important _ symmetry breaking _ problems encountered in distributed computing  @xcite .",
    "solving such problems requires a pre - existing initial asymmetry from which the problem can be solved . in a lot of cases ,",
    "this initial asymmetry is given by the assumption that no two processes have the same identity .",
    "[ [ distributed - distance-1-coloring - in - the - classical - point - to - point - synchronous - message - passing - model ] ] distributed distance-1 coloring in the classical point - to - point synchronous message - passing model + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    let us consider a distributed computing setting , where the processes constitute the vertices of a graph , and the communication channels its edges .",
    "the distributed distance-1 vertex coloring problem consists in associating a color with each process such that ( a ) no two neighbors have the same color , and ( b ) the total number of colors is as small as possible .",
    "this process - coloring problem has essentially been investigated in reliable synchronous networks where any two neighboring processes are connected by a bi - directional channel on which each of them can send and receive messages ( e.g.  @xcite ) .",
    "the main results are described in the monograph  @xcite .    in these reliable point - to - point synchronous systems ,",
    "processes proceed in synchronized steps , usually called rounds .",
    "each round consists of three phases : during the first phase , each process sends messages to its neighbors ; during the second phase , each process receives messages ; and during the last phase , each process executes local computation .",
    "the fundamental synchrony property is that a message is received in the very same round in which it is sent .",
    "hence , when solving a problem in this synchronous computation model , a crucial attribute of a problem is the minimal number or rounds needed to solve it . as far as the distance-1 coloring problem is concerned",
    ", it has been shown that , if the communication graph can be logically oriented such that each process has only one predecessor ( e.g. , a tree or a ring ) , @xmath7 rounds are necessary and sufficient to color the processes with three colors  @xcite ( @xmath8 being the total number of processes is the number of times the function @xmath9 needs to be iteratively applied in @xmath10 to obtain a value @xmath11 . as an example , if @xmath8 is the number of atoms in the universe , @xmath12 . ] ) .",
    "other d1-coloring algorithms are described in several articles ( e.g.  @xcite ) .",
    "they differ in the number of rounds they need and in the number of colors they use to implement d1-coloring .",
    "both the algorithms in  @xcite color the vertices with @xmath13 colors ; the first one requires @xmath14 rounds , while the second one uses @xmath15 rounds .",
    "an algorithm described in  @xcite is for tree graphs or graphs where each vertex has two neighbors ; it uses three colors and @xmath16 rounds .",
    "another algorithm presented in the same paper addresses constant - degree graphs ; it uses @xmath13 colors and @xmath16 rounds .",
    "the algorithm presented in  @xcite requires @xmath17 rounds .",
    "these algorithms assume that the processes ( vertices ) have distinct identities , which are their initial colors .",
    "they proceed iteratively , each round reducing the total number of colors .",
    "[ [ distance-2-and - distance-3-coloring - in - shared - memory - and - message - passing - models ] ] distance-2 and distance-3 coloring in shared memory and message - passing models + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a first class of algorithms addresses the distance-2 vertex coloring problems in systems where communication is through shared memory , message - passing , or a mix of the two  @xcite .",
    "these algorithms find their motivation in the application of distance-2 coloring to scientific computing . as a result",
    ", they do not fit well the characteristics of wireless networks .    on the other hand ,",
    "wireless protocols apply or require distance-2 and distance-3 coloring algorithms to prevent packet collisions  @xcite . to this end",
    ", they build a tdma ( time division multiple access ) schedule  @xcite from the result of the coloring process .",
    "tdma allows processes to share the same frequency channel by dividing the signal into different time slots , one per color .",
    "hence , protocols based on distance-2 coloring guarantee that nodes can transmit messages undisturbed during their time slots . those based on distance-3",
    "coloring additionally allow receiving nodes to acknowledge unicast messages in the sender s slot .    with this motivation ,",
    "some authors have proposed self - stabilizing algorithms to solve the distance-2 problem  @xcite for example ,  @xcite presents a self - stabilizing distance-2 algorithm that uses a constant number of variables on each node and that stabilizes in @xmath18 moves and uses at most @xmath19 colors , where @xmath20 is the number of edges . but",
    "these algorithms do not take the broadcast nature of the wireless medium into account , and their operation may thus results in significant packet collisions .",
    "differently , cadca  @xcite is a distributed distance-2 coloring algorithm that takes into account the risk of collisions during the coloring process . to limit this risk",
    ", cadca organizes the nodes to be colored in concentric layers around a sink node .",
    "the coloring process proceeds in three phases : the first colors layers 1 , 4 , 7 , ... ; the second colors layers 2 , 5 , 8 , .... , and the third colors layers 3 , 6 , 9 .",
    "each such phase uses a specific color palette to avoid conflicts between nodes in different layers and exploits five stages in which the nodes in a layer select colors and resolve the conflicts that arise during the process .",
    "however , the algorithm requires nodes to know their position with respect to the sink node , and most importantly it does not entirely eliminate packet collisions , it only reduces their number .    with respect to the distance-3 version of a problem ,",
    "@xcite proposes a self - stabilizing algorithm .",
    "processes compute a maximal independent set and then use it to assign themselves colors .",
    "the self - stabilizing part of the algorithm gathers information about each process s 3-hop neighborhood , and does generate collisions .",
    "however , the protocol uses a special tdma slot to continuously run the self - stabilizing protocol without interfering with colored slots .",
    "serena  @xcite uses a similar approach and also presents a distance-3 coloring algorithm in a broadcast - receive model .",
    "however , it does not use a special time - slot to limit the impact of the collisions occurring during the coloring process .",
    "the protocols we present in this paper , on the other hand , do not lead to any conflict or collision and do not need any special time slots .    [ [ content - of - the - paper ] ] content of the paper + + + + + + + + + + + + + + + + + + + +    differently from the previous articles , we propose a collision- and conflict - free algorithm that solves the distance-2 ( d2 ) coloring problem in synchronous networks where ( a ) processes communicate by broadcasting and receiving messages , and ( b ) collisions and conflicts are not prevented by the communication model . a collision occurs when a process receives messages from two or more neighbors in the same round .",
    "a conflict occurs when , during the same round , two neighbors send a message to each other .",
    "in this broadcast / receive communication model ( which covers practical system deployments ) , there is not a dedicated communication medium for each pair of processes , but a single shared communication medium for each pair composed of a process and all its neighbors .",
    "examples of such communication media are encountered in wireless networks such as sensor networks . in such networks , collision - freedom and conflict - freedom",
    "do not come for free , and the algorithms built on top of them must be collision / conflict - free to ensure the consistency of the messages that are exchanged , and consequently the progress of upper - layer applications .",
    "this paper is on collision / conflict - free d2-coloring for the synchronous broadcast / receive communication model , where the processes are connected by a tree network . considering such a context , it presents an algorithm which uses @xmath13 colors , and is consequently optimal with respect to the number of colors .",
    "this algorithm relies on two assumptions to break symmetry : ( a ) it assumes that a process ( not predetermined in advance ) receives an external message that defines it as the root of the tree ; ( b ) it assumes that any two processes at distance less than or equal to @xmath0 have distinct identities ( hence , depending on the structure of the tree , lots of processes can have the same identity ) .",
    "its round complexity is @xmath3 where @xmath4 is the depth of the tree .",
    "moreover , no process needs to know @xmath8 , @xmath2 , or the depth of the tree .",
    "hence a process has no information on the global structure of the tree .",
    "its initial knowledge is purely local : it is restricted to its identity , and the identities of its neighbors .",
    "[ [ roadmap ] ] roadmap + + + + + + +    the paper consists of  [ sec : conclusion ] sections .",
    "section  [ sec : model ] presents the synchronous broadcast / receive model , and section  [ sec : d2-coloring ] introduces the distance-2 coloring problem .",
    "then , two distributed ( message - passing ) distance-2 coloring algorithms suited to trees are presented .",
    "the presentation is incremental .",
    "section  [ sec : sequential - d2-tree - algorithm ] presents first a simple distributed distance-2 coloring algorithm which exploits a sequential tree traversal algorithm as a skeleton , on which are appropriately grafted statements implementing distance-2 the coloring .",
    "then , section  [ sec : parallel - d2-tree - algorithm ] presents a distributed distance-2 coloring algorithm based on a parallel traversal of the tree .",
    "this second algorithm extends the basic coloring principles introduced in the first algorithm .",
    "[ [ processes - initial - knowledge - and - the - communication - graph ] ] processes , initial knowledge , and the communication graph + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the system model consists of @xmath8 sequential processes denoted @xmath21 , ... ,",
    "@xmath22 , connected by a tree communication network .",
    "each process @xmath23 has an identity @xmath24 , which is known only by itself and its neighbors ( processes at distance @xmath6 from it ) .",
    "the constant @xmath25 is a local set , known only by @xmath23 , including the identities of its neighbors ( and only them ) . as noticed in the introduction , in order for a process @xmath23 not to confuse its neighbors , it is assumed that no two processes at distance less than or equal to @xmath0 have distinct identities . hence , any two processes at distance greater than @xmath0 may have the same identity .",
    "when computing bit complexities , we will assume that any process identity is encoded in @xmath26 bits .",
    "let @xmath27 denote the degree of a process @xmath23 ( i.e. @xmath28 ) and let @xmath2 denote the maximal degree of the process graph ( @xmath29 ) .",
    "while each process @xmath23 knows @xmath27 , no process knows @xmath2 ( a process @xmath30 such that @xmath31 does not know that @xmath32 is @xmath2 ) .",
    "when considering a process @xmath23 , @xmath33 , the integer @xmath34 is called its index .",
    "indexes are not known by the processes .",
    "they are only a notation convenience used as a subscript to distinguish processes and their local variables .",
    "[ [ timing - model ] ] timing model + + + + + + + + + + + +    we assume that processing durations are equal to @xmath35 .",
    "this is justified by the following observations : ( a ) the duration of the local computations of a process is negligible with respect to message transfer delays , and ( b ) the processing duration of a message may be considered as a part of its transfer delay .    communication is synchronous in the sense that there is an upper bound @xmath36 on message transfer delays , and this bound is known by all the processes ( global knowledge ) . from an algorithm design point of view",
    ", we consider that there is a global clock , denoted @xmath37 , which is increased by @xmath6 , after each period of @xmath36 physical time units .",
    "each value of @xmath37 defines what is usually called a _ time slot _ or a _",
    "round_.    [ [ communication - operations ] ] communication operations + + + + + + + + + + + + + + + + + + + + + + + +    the processes are provided with two operations denoted @xmath38 and @xmath39 .",
    "a process @xmath23 invokes @xmath40 tag@xmath41 to send the message @xmath20 , whose type is tag , to all its neighbors .",
    "it is assumed that a process invokes @xmath42 only at a beginning of a time slot .",
    "when a message tag@xmath41 arrives at a process @xmath23 , this process is immediately warned of it , which triggers the execution of operation @xmath39 to obtain the message .",
    "hence , a message is always received and processed during the time slot round in which it was broadcast .    from a linguistic point of of view",
    ", we use the two following * when * notations when writing algorithms , where @xmath43 is a predicate involving @xmath37 and possibly local variables of the concerned process .",
    "@xmath44 * when * tag@xmath41 * is received do * processing of the message .",
    "+ @xmath44 * when * @xmath43 * do * code entailing at most one @xmath42 invocation .",
    "[ [ message - collision - and - message - conflict ] ] message collision and message conflict + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    traditional wired round - based synchronous systems assume a dedicated a communication medium for each pair of processes ( i.e. , this medium is not accessible to the other processes ) .",
    "hence , in these systems a process @xmath23 obeys the following sequential pattern during each round : ( a ) first @xmath23 sends a message to all or a subset of its neighbors , ( b ) then @xmath23 receives the messages sent to it by its neighbors during the current round , and ( c ) finally executes a local computation which depends on its local state at the beginning of the round and the messages it has received during the current round .",
    "the situation is different in systems such as wireless networks ( e.g. , sensor networks ) , which lack a dedicated communication medium per pair of processes .",
    "a process @xmath23 shares a single communication medium with all its neighbors , and `` message clash '' problems can occur , each message corrupting the other ones , and being corrupted by them .",
    "consider a process @xmath23 , these problems are the following .    *",
    "if two neighbors of @xmath23 invoke the operation @xmath42 during the same time slot ( round ) , a message _ collision _ occurs . *",
    "if @xmath23 and one of its neighbors invoke @xmath42 during the same time slot ( round ) , a message _ conflict _ occurs .",
    "as already indicated , this paper considers this broadcast / receive communication model .",
    "this implies that protocols must prevent collisions and conflicts to ensure both message consistency and computation progress .",
    "[ [ solving - the - collisionconflict - problem ] ] solving the collision / conflict problem + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    to prevent collisions and conflicts involving a process @xmath23 , only a single process in the set @xmath45 can obtain the right to communicate during a given round .",
    "to this end , we associate each process with time slots ( rounds ) in which it can broadcast a message , while none of its 2-hop neighbors can broadcast during these time slots . when considering the whole set of processes",
    ", this assignment must be optimal in terms of numbers of colors ( ideally allowing as many processes as possible to broadcast during the same round ) .",
    "this problem is a well - known graph coloring problem called _",
    "distance-2 _ coloring .",
    "the aim is to design distributed algorithms associating a color with each process ( which will define the time - slots during which it will be allowed to broadcast ) such that the following properties are satisfied .",
    "[ [ definition ] ] definition + + + + + + + + + +    * validity : the final color of each process belongs to @xmath46 . * consistency : no two processes at distance @xmath11 have the same color . *",
    "termination : each process obtains a color and one process knows that this occurred .    let us observe that , as at least one process has @xmath2 neighbors , @xmath1 different colors are necessary .",
    "the validity property states that we are looking for _ distributed _ algorithms which ensure that @xmath1 is also a tight upper bound . as we will see",
    "such algorithms exist for tree networks .    [",
    "[ using - the - colors - to - define - the - time - slots ] ] using the colors to define the time slots + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the colors obtained by the processes are used as follows , where @xmath47 is the color obtained by process @xmath23 . the time slots ( rounds ) during which @xmath23 is allowed to broadcast a message to its neighbors",
    "correspond to the values of @xmath37 such that @xmath48 .",
    "as we will see , these time slots are different from the time slots used during the ( sequential and parallel ) distributed distance-2 algorithms which are presented below .",
    "it follows that these algorithms must provide each process with the ( initially unknown ) value of @xmath2 .",
    "this section presents a distributed distance-2 coloring algorithm in which there are neither message collisions , nor message conflicts .",
    "this algorithm is sequential in the sense that its skeleton is a depth - first tree traversal in which the control flow ( implemented by appropriate messages ) moves sequentially from a process to another one .",
    "algorithm  [ fig : dftree - traversal - algorithm ] assumes that a single process receives a message , start@xmath49 , which defines it as the root of the tree .",
    "( as noticed in the introduction , this introduces the initial asymmetry needed to solve the symmetry - breaking problem we are interested in . )",
    "this external message causes the receiving process , @xmath50 , to simulate the reception of a fictitious message , color@xmath51 .",
    "this message initiates a depth - first traversal of the tree .",
    "[ [ messages ] ] messages + + + + + + + +    the algorithm uses two types of messages : color@xmath49 and term@xmath49 . as each message",
    "is broadcast by its sender and received by all its neighbors , it carries the identity of its destination process .",
    "hence , when a process receives a message @xmath20 , it discards @xmath20 if it is not the destination of @xmath20 ( predicate @xmath52 at line  [ seq-04 ] and line  [ seq-19 ] ) .",
    "these messages implement a depth - first traversal of the tree network  @xcite .",
    "each carries the identity of its destination @xmath53 , the identity of its sender @xmath54 , and the color of its sender @xmath55 .",
    "a message color@xmath49 additionally carries the colors of the already colored neighbors of the sender @xmath56 .",
    "[ [ local - variables ] ] local variables + + + + + + + + + + + + + + +    each process @xmath23 manages the following local variables .    * @xmath57 ( initialized to @xmath35 ) is used by @xmath23 to manage the progress of the tree traversal .",
    "each process traverses five different states during the execution of the algorithm .",
    "states @xmath6 and @xmath58 are active : a process in state @xmath6 sends a color@xmath49 message to a child , while a process in state @xmath58 sends a term@xmath49 message to its parent .",
    "states @xmath35 and @xmath0 are waiting states .",
    "nodes listen on the broadcast channel but can not send any message .",
    "finally , state @xmath59 identifies local termination . *",
    "@xmath60 saves the identity of the process @xmath61 from which @xmath23 received the message color@xmath62 ; @xmath23 receives exactly one such message .",
    "this process , @xmath61 , defines the parent of @xmath23 in the tree .",
    "the root @xmath50 of the tree , defined by the reception of the external message start@xmath49 , is the only process such that @xmath63 .",
    "* @xmath64 records the color of the parent of @xmath23 .",
    "@xmath23 receives this information in the parent s colormessage .",
    "* @xmath65 is a set containing the colors of the neighbors of @xmath23 , that have already obtained their color .",
    "* @xmath66 ( initialized to @xmath25 ) is a set containing the identities of the neighbors of @xmath23 not yet colored .",
    "* @xmath47 contains the color of @xmath23 .    [",
    "[ description - of - the - algorithm ] ] description of the algorithm + + + + + + + + + + + + + + + + + + + + + + + + + + + +    nodes start the algorithm in state @xmath35 , waiting for a color@xmath62 message .",
    "a process , @xmath23 , receives such a message exactly once .",
    "when it receives it , it is visited for the first time by the depth - first tree traversal .",
    "it consequently assigns the values of the message parameters to its local variables @xmath60 , @xmath64 and @xmath65 ( line  [ seq-05 ] ) .",
    "then , it computes its color , which is different from the color of the sender of the message and from the colors of the sender s already colored neighbors ( lines  [ seq-06]-[seq-07 ] ) .",
    "finally , @xmath23 updates @xmath66 , and transitions to a new state : @xmath6 if it has any children , or @xmath58 if it is a leaf node .",
    "this prepares the progress of the tree traversal , which will take place at the next time slot ( round ) ( lines  [ seq-08]-[seq-09 ] ) .    when @xmath23 enters the new time slot with @xmath67 ( line  [ seq-10 ] ) , it operates as follows to ensure the progress of the tree traversal .    *",
    "if @xmath68 , it means that @xmath23 has neighbors that have not yet been colored . in this case , @xmath23 selects one of them , and makes the tree traversal progress by broadcasting a message , color@xmath69 , which will be processed only by @xmath70 ( line  [ seq-13 ] ) .",
    "then , @xmath23 moves into @xmath71 and waits until it receive a termmessage , term@xmath72 . *",
    "if @xmath73 , it means that all the neighbors of @xmath23 have been colored . in this case , if @xmath23 is the root , the distance-2 coloring has terminated ( line  [ seq-14 ] ) .",
    "otherwise , if @xmath23 is not the root , it broadcasts the message term@xmath74 to inform its parent that the sub - tree of which it is the root has been colored ( line  [ seq-15 ] ) . in both cases , @xmath23 transitions to @xmath75 , thereby indicating that the algorithm is terminated as far as @xmath23 is concerned ( local termination ) .",
    "finally , when @xmath23 receives the message term@xmath76 , it first updates its local variables @xmath66 and @xmath65 according to the received values ( line  [ seq-20 ] ) . then , it updates @xmath57 according to the value of @xmath66 ( indicating whether it has colored all its neighbors , line  [ seq-21 ] ) . in the first case",
    ", it moves to state @xmath6 and continues traversing another sub - tree .",
    "otherwise it moves to state @xmath58 , which will then evolve into state @xmath59 ( signaling local termination ) as indicated above .",
    "[ [ how - a - process - learns - the - value - of - delta ] ] how a process learns the value of @xmath2 + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    a process maintains a local variable @xmath77 initialized to @xmath27 , and each message term@xmath49 now carries this value .",
    "when a process @xmath23 receives a message term@xmath78 it executes the update statement @xmath79 . finally , when the root process @xmath50 claims termination , it launches a second traversal of the tree to inform the other processes .",
    "we do not describe such a propagation of the value of @xmath2 here .",
    "this will be done in section  [ sec : inform - others ] in the context of a parallel tree traversal .",
    "[ collision - conflict - freedom ] algorithm  _ [ fig : dftree - traversal - algorithm ] _ is both collision - free and conflict - free .    let us first observe that , due to the assignment of the variable @xmath57 at line  [ seq-09 ] ( in the processing of a message color@xmath49 ) , or line  [ seq-21 ] ( in the processing of a message term@xmath49 ) , a process @xmath23 is allowed to broadcast one and only one message when it executes line  [ seq-13 ] or  [ seq-15 ] .",
    "it follows from the associated assignment of the control value @xmath0 or @xmath59 to @xmath57 ( line  [ seq-13 ] or  [ seq-15 ] ) , that @xmath23 can not broadcast other messages color@xmath49 or term@xmath49 before executing line  [ seq-21 ] ( i.e. , before it receives a message term@xmath49 ) .",
    "let us now observe that , due to line  [ seq-04 ] , a message color@xmath49 broadcast by a process at line  [ seq-13 ] is processed by a single destination process . hence",
    ", the control flow generated by these messages remains sequential , moving sequentially from a parent process to a child process .",
    "similarly , the control flow generated by the messages term@xmath49 ( broadcast at line  [ seq-15 ] ) moves sequentially from a child process @xmath23 to its parent process ( whose identity is saved in @xmath60 ) .    the collision - freedom and conflict - freedom properties of the algorithm follow directly from the sequentiality of the control flow realized by the messages color@xmath49 and term@xmath49 .",
    "[ lemma - three - properties ] algorithm  _ [ fig : dftree - traversal - algorithm ] _ satisfies the validity , consistency , and termination properties .",
    "let us first prove the following claim . + claim .",
    "for any @xmath23 and at any time , @xmath80 .",
    "+ proof of the claim .",
    "let us consider the local variable @xmath65 of a process @xmath23 .",
    "this variable is initialized at line  [ seq-05 ] , when @xmath23 receives a message color@xmath49 for the first time .",
    "it then contains the color of its parent in the tree .",
    "when the algorithm progresses , the color of a child @xmath61 of @xmath23 is added to @xmath65 ( line  [ seq-20 ] ) when @xmath23 receives from @xmath61 a message term@xmath49 carrying @xmath61 s color .",
    "it follows that , when @xmath23 issues its last broadcast of color@xmath81 , @xmath82 is the identity of its only child without a color , and @xmath65 contains the colors of all the other neighbors of @xmath23 .",
    "hence , @xmath80 .",
    "end of the proof of the claim .",
    "the validity property follows from the following observation .",
    "when a process @xmath23 selects its color , it follows from the previous claim and lines  [ seq-06]-[seq-07 ] that @xmath83 .",
    "consequently , there is at least one free color in the set @xmath84 .    to prove the proper - coloring property",
    "let us first observe that , due to ( a ) the initialization of @xmath85 done when a process @xmath61 receives a message color@xmath49 from its parent ( line  [ seq-05 ] ) , and ( b ) the updates that follow when it receives messages term@xmath49 from its children ( line  [ seq-20 ] ) , it follows that @xmath85 contains the colors of the already colored neighbors of @xmath61 .",
    "hence , when a process @xmath23 selects a color ( lines  [ seq-06]-[seq-07 ] ) , the colors of the already colored processes at distance 2 from it are in the set @xmath86 carried by the message color@xmath49 entailing @xmath23 s coloring .",
    "due to line  [ seq-06 ] , @xmath23 does not select any of these colors .",
    "the termination property follows from the termination of the sequential traversal , at the end of which the root learns the algorithm has terminated .",
    "the following theorem is an immediate consequence of the previous lemmas .",
    "[ theo : seq - traversal - coloring ] algorithm  _ [ fig : dftree - traversal - algorithm ] _ is a collision - free and conflict - free distance-2 coloring algorithm for trees .",
    "[ [ cost - of - the - algorithm ] ] cost of the algorithm + + + + + + + + + + + + + + + + + + + + +    ( let us recall that a process identity can be encoded with @xmath87 bits . )",
    "there are two message types .",
    "a message term@xmath49 carries two process identities and a color .",
    "a message color@xmath49 carries two process identities , a color , and set of at most @xmath88 colors .",
    "it follows that a message carries at most @xmath89 bits .",
    "a tree of maximal degree @xmath2 has at least @xmath90 leaves .",
    "let us first count the number of broadcasts of a message color@xmath49 .",
    "the root issues at most @xmath2 broadcasts ; a process , which is neither the root nor a leaf , issues at most @xmath88 broadcasts ; and a leaf issues no broadcast of such a message .",
    "it follows that there are @xmath91 broadcasts of a message color@xmath49 . as @xmath90 ,",
    "the number of broadcasts of a message color@xmath49 is upper bounded by @xmath92 .",
    "each process which is not the root of the tree issues exactly one broadcast of a message term@xmath49 .",
    "it follows that there are @xmath93 broadcasts of such a message .",
    "this section presents a distributed distance-2 coloring for trees , which based on a parallel traversal of the tree network , with feedback ( i.e. , the dynamically defined root process that launches the network traversal learns of the end of the traversal ) .",
    "this algorithm can be seen as improvement of the previous algorithm in terms of time efficiency .",
    "[ [ underlying - principle ] ] underlying principle + + + + + + + + + + + + + + + + + + + +    let us first observe that any two children of a process must be prevented from broadcasting simultaneously a message to their neighbors .",
    "this is because , being issued by processes at distance at most two , such simultaneous broadcasts will create a collision at least at the parent process .    the idea to prevent this vicinity /",
    "concurrency problem is first to direct a parent process to compute the colors of its children , and then , as soon as a process has obtained a color , to allow it to broadcast a message ( color@xmath49 or term@xmath49 ) only during the time slots ( rounds ) associated with its color . to this end",
    ", each process uses the values provided by the global clock ( @xmath37 ) .",
    "[ [ messages - and - local - variables ] ] messages and local variables + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the message types implementing the parallel tree traversal are the same as in algorithm  [ fig : dftree - traversal - algorithm ] .",
    "similarly , the local variables @xmath60 , @xmath66 , @xmath47 , @xmath64 , and the constant @xmath25 , have the same meaning as in algorithm  [ fig : dftree - traversal - algorithm ] .",
    "each process @xmath23 manages an additional variable @xmath94 , initially @xmath35 , which will contain the number of colors needed to color its parent @xmath61 and its neighbors ( processes of @xmath95 ) .",
    "this value is known to @xmath23 when it receives its first message color@xmath49 ( which defines its sender @xmath61 as @xmath23 s parent ) .",
    "each process has also a constant @xmath96 which represents the number of colors needed to color itself and its neighbors .",
    "[ [ description - of - the - algorithm-1 ] ] description of the algorithm + + + + + + + + + + + + + + + + + + + + + + + + + + + +    to simplify the presentation , we assume that the initial value of @xmath37 is @xmath97 . as in the sequential version ,",
    "a single process @xmath50 receives the external message start@xmath49 , that defines it as the root of the tree .",
    "moreover , this reception entails the fictitious sending of the message color@xmath98 where @xmath99 ( line  [ p-02 ] ) . similarly to algorithm  [ fig : dftree - traversal - algorithm ] , according to the values carried by the message color@xmath49 , @xmath50 initializes its local variables and obtains the color @xmath100 ( lines  [ p-05]-[p-07 ] ) .",
    "it finally updates @xmath101 .",
    "then , when @xmath102 , @xmath50 executes lines  [ p-10]-[p-19 ] .",
    "more generally , these lines are executed by any process @xmath23 as soon as , after it received its first message color@xmath49 , the color it obtained ( @xmath47 ) is such that @xmath103 ( line  [ p-09 ] ) .",
    "hence , as the algorithm ( a ) allows a process to broadcast only at a round corresponding to its color , ( b ) allows only colored processes to broadcast color@xmath49 or term@xmath49 messages , and ( c ) ensures the distance-2 coloring property ( see the proof ) without any message collision or message conflict during its execution .",
    "let us consider a process @xmath23 such that the predicate of line  [ p-09 ] is satisfied .",
    "there are two cases .    * if @xmath68 , the neighbors of @xmath23 are not colored .",
    "process @xmath23 computes then a color for each of its children ( lines  [ p-11]-[p-16 ] ) , and broadcasts a message color@xmath49 to inform them of it ( line  [ p-17 ] ) .",
    "it is easy to see that the messages color@xmath49 implements a parallel traversal of the tree from the root to the leaves .",
    "then , @xmath23 enters a waiting period by setting @xmath57 to @xmath0 . * if @xmath73 , all neighbors of @xmath23 ( and all processes in their sub - trees ) are colored . in this case",
    ", @xmath23 forwards this information to its parent . as its local participation to the algorithm",
    "is terminated , @xmath23 sets @xmath57 to @xmath59 .",
    "finally , when a process @xmath23 receives a message term@xmath49 from one of its children , it first updates @xmath66 accordingly ( line  [ p-22 ] ) .",
    "if this set is empty , it claims termination if it is the root . otherwise , it assigns @xmath58 to @xmath57 , so that it will inform its parent of its local termination at the first time slot ( round ) at which its color satisfies the predicate of line  [ p-09 ] .      [ lemma : par - nocollision - noconflict ] algorithm  _ [ fig : tree - parallel - coloring - algorithm ] _ is collision - free and conflict free .",
    "let us observe that a process @xmath23 is allowed to broadcast a message color@xmath49 ( line  [ p-16 ] ) only if @xmath104 .",
    "as such a sending entails the assignment @xmath105 ( and @xmath57 never decreases ) , it follows that @xmath23 issues at most one such broadcast . the same occurs for the broadcast of a message term@xmath49 .    due to the initialization of its local variable @xmath57",
    ", no process @xmath23 can broadcast a message until one of them receives the message @xmath106 .",
    "let us assume that ( without loss of generality ) that @xmath107 when a process a process @xmath23 receives this message .",
    "it follows from the text of lines  [ p-01]-[p-08 ] that , before @xmath37 increases , we have @xmath108 and @xmath68 ( if the graph is not a singleton ) , or @xmath108 and @xmath73 ( if the graph is a singleton ) .",
    "hence , when @xmath102 , @xmath23 executes lines  [ p-09]-[p-19 ] and broadcasts a message color@xmath49 ( line  [ p-17 ] ) , or a message term@xmath49 ( line  [ p-18 ] ) , while no other process can broadcast a message .",
    "moreover , due to the color assignment done by @xmath23 at lines  [ p-12]-[p-16 ] , its neighbors obtain different colors when they receive the message color@xmath49 from @xmath23 at time @xmath102 .    due to the color computation done by @xmath23 at line  [ p-12]-[p-16 ] ( when @xmath102 ) , no two of its neighbors have the same color , and none of them has the same color as @xmath23 .",
    "it follows from the time predicate of line  [ p-09 ] that no two processes of the set @xmath109 can broadcast during the same time slot .",
    "let @xmath61 be a neighbor of the root process @xmath23 .",
    "it follows from line[p-12 ] that , when @xmath61 selects colors for its neighbors , it assigns them colors which are different among themselves and different from its own color and the color of @xmath23 .",
    "hence , due the time predicate of line  [ p-09 ] , it follows that no two processes of the set @xmath110 can broadcast during the same time slot .",
    "the same reasoning applies to the neighbors of @xmath61 , etc . , which completes the proof of the lemma .",
    "[ lemma : color - size ] let @xmath23 and @xmath61 be two processes such that such @xmath111 .",
    "the color of @xmath23 belong to the set @xmath112 .",
    "let @xmath23 be any children pf @xmath61 .",
    "the color of @xmath23 is defined by @xmath61 when it executes the lines  [ p-12]-[p-16 ] .",
    "the local palette of @xmath61 is then the sequence @xmath113 , from which its own color ( @xmath114 ) and the color of its neighbor which is parent ( @xmath115 ) are suppressed ( line  [ p-12 ] ) .",
    "hence , at most two integers ( one in case of the root ) are suppressed from the first @xmath116 non - negative integers from which the palette is built .",
    "hence , @xmath61 can color its neighbors with up to @xmath117 ( @xmath118 if @xmath61 is the root ) colors with values less than @xmath116 and different from that of its parent .",
    "[ lemma : par - proper - color - bound ] algorithm  _ [ fig : tree - parallel - coloring - algorithm ] _ uses at most @xmath1 different colors to the processes , and no two processes at distance @xmath11 have the same color .",
    "let us consider a process @xmath23 .",
    "it has at most @xmath2 neighbors .",
    "it follows from lines  [ p-12]-[p-16 ] , that all its neighbors ( including the process from which it received the message color@xmath49 ) are assigned different colors , and those are different from its color @xmath47 .",
    "hence no two processes at distance @xmath11 have the same color . as @xmath119 , it follows from lemma  [ lemma : color - size ] that at most @xmath13 colors are used by the algorithm .",
    "[ lemma : par - termination ] any process is colored , and ( only after all processes are colored ) this is known by the root process .",
    "once a process received an external message start@xmath49 , it becomes the root of the tree , it takes a color , and broadcasts a message color@xmath49 to its neighbors at line  [ p-17 ] as soon as the predicate of line  [ p-09 ] becomes satisfied .",
    "then , each of these neighbor processes broadcasts a message color@xmath49 to their neighbors , etc .",
    "as soon as its neighbors are colored , a process @xmath23 is such that @xmath73 , and consequently it broadcasts a message term@xmath49 at line  [ p-18 ] .",
    "let @xmath61 be the parent process that broadcasts the message color@xmath49 received by @xmath23 .",
    "when @xmath61 has received message term@xmath49 from all its children , it will proceed to @xmath120 ( line  [ p-24 ] ) and will broadcast term@xmath49 at line  [ p-18 ] as soon as the time predicate of line  [ p-09 ] becomes satisfied .",
    "it follows from the previous observations that the process that received the message start@xmath49 eventually claims termination at line  [ p-24 ] .",
    "the following theorem is an immediate consequence of the previous lemmas .",
    "[ theo : parallel - coloring ] algorithm  _ [ fig : tree - parallel - coloring - algorithm ] _ is a collision - free and conflict - free distance-2 coloring parallel algorithm for trees .",
    "[ [ cost - of - the - algorithm-1 ] ] cost of the algorithm + + + + + + + + + + + + + + + + + + + + +    each process which is not a leaf issues one broadcast of a message color@xmath49 , and each process which is not the root issues one broadcast of a message term@xmath49 .",
    "let @xmath121 be the number of leaves .",
    "there are consequently @xmath122 broadcasts .",
    "as @xmath123 , the number of broadcasts is upper bounded by @xmath124 .    as far as time complexity is concerned , we have the following .",
    "let @xmath4 be the depth of the tree , and assume @xmath107 when a process @xmath50 receives the message start@xmath49 , which defines it as the root of the tree .",
    "it follows from their color assignment ( lines  [ p-12]-[p-16 ] ) that @xmath50 s children start one after the other at times @xmath6 , @xmath0 , ... , @xmath125 .",
    "let @xmath30 be the child of @xmath50 that obtains the color @xmath125 .",
    "it broadcasts a message color@xmath49 to its own children at time @xmath126 , and its child with the highest color will do the same at time @xmath127 . etc .",
    "as this worst pattern can repeat along a path of the tree , it follows than process does not receive a message color@xmath49 before time @xmath128 .",
    "an analogous reasoning applies to the `` return '' messages term@xmath49 starting from the leaves to the root .",
    "hence , the time complexity is @xmath3 .",
    "( let us remind that @xmath129 when the tree is well - balanced .",
    "[ [ global - vs - local - termination ] ] global vs local termination + + + + + + + + + + + + + + + + + + + + + + + + + + +    algorithm  [ fig : tree - parallel - coloring - algorithm ] implements a parallel distance-2 coloring , but only the root learns that the algorithm has terminated ( global termination ) .",
    "a non - root process @xmath23 knows only that the sub - tree of which it is the root has terminated ( local termination ) .",
    "this section , enriches this algorithm so that any process learns about global termination .",
    "[ [ the - extended - algorithm ] ] the extended algorithm + + + + + + + + + + + + + + + + + + + + + +    this extended algorithm is made up of algorithm  [ fig : tree - parallel - coloring - algorithm ] where line  [ p-18 ] is modified , and the statement `` * when * term@xmath130 * is received do * ... '' ( lines  [ p-20]-[p-24 ] ) is replaced by the statements described in algorithm  [ fig :- tree - parallel - coloring - termination ] .",
    "moreover , each process @xmath23 manages an additional local variable denoted @xmath131 , which is initialized to @xmath132 .",
    "when considering base algorithm  [ fig : tree - parallel - coloring - algorithm ] and its extension algorithm  [ fig :- tree - parallel - coloring - termination ] , the lines with the same number are the same in both algorithms , the lines suffixed by a `` prime '' are modified lines , and the lines n1-n7 are new lines .    the message term@xmath133 broadcast by a process @xmath23 at line  [ p-18 ] must now carry the current value of @xmath131 , i.e. , @xmath23 broadcasts term@xmath134 .",
    "the local variable @xmath131 of a process @xmath23 is updated at line n1 . in this way ,",
    "starting from the leaves , these local variables allow the root to know the value @xmath13 ( upper bound on the number of colors needed by a process to color itself and its neighbors ) .",
    "when the root learns about global termination , it proceeds to @xmath135 ( line  [ p-24] ) . at this point ,",
    "the value of its local variable @xmath131 is @xmath1 .",
    "moreover , its new local state @xmath57 allows it to inform its children about global termination by broadcasting the message end@xmath49 carrying the value @xmath1 ( lines  n2-n3 ) .    finally , when a process @xmath23 , which is not the root ( hence @xmath75 ) receives an end @xmath136 message , from its parent , it updates @xmath131 and proceeds to @xmath135 ( lines n4-n7 ) , which allows it to forward the end message to its children , if any ( lines n2-n3 ) .",
    "let us notice that , as the children of a process @xmath30 do not broadcast end@xmath49 messages during the same time slot ( round ) , there is no collision of these messages at their parent .",
    "but since the parent simply discards these messages , a trivial optimization may consist in relaxing the collision - freedom constraint .",
    "specifically , the children could send their end ( ) messages in parallel as their parent does not need to receive them .",
    "independently of the optimization , it follows from the propagation of the end@xmath49 messages that , eventually , all the processes are such that @xmath137 .",
    "when this occurs , they learn about global termination .    [ [ remark ] ] remark + + + + + +    let us consider the situation where , while the coloring algorithm has terminated ( i.e. , each process has obtained a color and knows @xmath2 ) , a new process @xmath30 wants to enter the tree and obtains a color .",
    "let @xmath23 be the process chosen to be @xmath30 s parent .",
    "if @xmath138 , @xmath23 can not accept @xmath30 as a child ( this would require an additional color ) .",
    "differently , if @xmath139 , it is easy to dynamically add @xmath30 as a child of @xmath23 . to this end",
    ", @xmath23 takes the first color @xmath140 in @xmath35 , @xmath6 , ... ,",
    "@xmath2 , which is different from its own color and the colors of its neighbors . then , during its next time slot , @xmath23 broadcasts the message new@xmath141 , which , when received by @xmath30 , gives it a proper color .",
    "let us notice that this `` join '' does not require @xmath30 to have an identity .",
    "it is consequently possible for @xmath23 to also assign to @xmath30 an identity not belonging to @xmath142 .",
    "considering two trees @xmath143 and @xmath144 , which have the same maximal degree @xmath2 , let @xmath30 be a process of @xmath143 and @xmath145 a process of @xmath144 , both having a degree less than @xmath2 .",
    "it is easy to see that , if @xmath146 , the trees @xmath143 and @xmath144 can be `` added '' to compose a single tree made up of @xmath143 and @xmath144 connected by the additional edge @xmath147 , this composition preserves the colors previously assigned by two independent executions of the algorithm , the one which assigned colors to @xmath143 and the one which assigned colors to @xmath144 .",
    "synchronous networks where the time is decomposed in a sequence of time slots ( rounds ) and the communication operations are `` broadcast a message to neighbors '' and `` receive a message a neighbor '' , are prone to message collisions ( which occur when two neighbors of a process send it a message during the same time slot ) , and message conflicts ( ( which occur when a process and one of its neighbors broadcast during the same time slot ) .",
    "distance-2 coloring solves this problem by assigning a color to each process such that there is a matching of time slots with colors which prevents message collisions / conflicts from occurring .",
    "this paper has presented a distributed algorithm which solves the distance-2 coloring problem in tree networks .",
    "this algorithm is based on a parallel tree traversal algorithm skeleton on which are grafted appropriate coloring assignments .",
    "it is itself collision / conflict - free .",
    "it uses only @xmath1 colors ( @xmath2 being the maximal degree of the network ) , which is optimal . its time complexity is @xmath3 ( where @xmath4 is the depth of the tree )",
    ". this algorithm does not require a process to initially know more than its identity and the ones of its neighbors .",
    "moreover , any two processes at distance greater than @xmath0 are not prevented from having the same identity ( which is important for scalability issues ) .",
    "let us also notice that this algorithm is relatively simple ( a first - class property ) .",
    "a very challenging issue is now the design of a parallel collision / conflict - free distance-2 coloring algorithm for synchronous broadcast / receive systems whose communication graph is more general than a tree . as , when considering sequential computing , distance-2 coloring is an np - complete problem , the design of such a distributed algorithm using a `` reasonable '' number of colors does not seem to be a `` trivial '' challenge .",
    "( a sequential algorithm suited to an arbitrary graph is presented in appendix  [ sec : seq - arbitrary - graph ] . )",
    "this work has been partially supported by the franco - hong kong anr - rgc joint research programme 12-is02 - 004 - 02 co@xmath1482dim , the franco - german dfg - anr project 40300781 discmat ( devoted to connections between mathematics and distributed computing ) , the french anr project socioplug ( anr-13-infr-0003 ) , and the labex cominlabs excellence laboratory ( anr-10-labx-07 - 01 ) through the descent project .",
    "algorithm  [ fig : coloring - of - an - arbitrary - graph ] is a sequential distance-2 coloring algorithm for an arbitrary ( connected ) graph . the design of this algorithm is the same the one of algorithm  [ fig : dftree - traversal - algorithm ] .",
    "it added complexity comes from the fact it allows the sequential control flow ( implemented by the messages color@xmath49 and term@xmath49 in algorithm  [ fig : dftree - traversal - algorithm ] ) to back track when a process discovers a coloring conflict .",
    "this backtracking is implemented by the messages correct@xmath49 , corrected_color@xmath49 , and resume_coloring@xmath49 .",
    "considering the network of figure  [ arbitrary - graph ] , an example of execution of algorithm  [ fig : coloring - of - an - arbitrary - graph ] is depicted in table  [ fig : table - example ] . due to",
    "space restriction we abbreviate the following : +    * br = @xmath149 operation , * @xmath150 = @xmath65 , * @xmath151 = @xmath152 , * cl(@xmath153,@xmath154,c , z , s ) = color(@xmath153,@xmath154,c , z , s ) , * crl(@xmath153,@xmath154,c , s ) = correct(@xmath153,@xmath154,c , z , s ) , * cr_cl(@xmath153,@xmath154,c , s ) = corrected_cl(@xmath153,@xmath154,c , s ) , * rsm_cl(@xmath153,@xmath154 ) = resume_cl(@xmath153,@xmath154 ) , * @xmath155 .    process @xmath21 receives the message start@xmath49 at round @xmath97 .",
    "it broadcasts the message color(@xmath156 , @xmath156 , -1 , 0 , @xmath157 ) to itself .",
    "it receives this message at round @xmath35 .",
    "it updates its local variables @xmath158 at line 02 ( abbreviated as l2 ) , @xmath159 , @xmath160 and @xmath161 at line 06 ( abbreviated as l6 ) .",
    "this appears in the first row of the table where the value of @xmath37 is @xmath35 .",
    "then , when @xmath37 progresses to @xmath6 , @xmath21 has @xmath162 , therefore , it broadcasts the message color@xmath49 with appropriate parameters , where it proposes a color that is not in @xmath163 to each of its neighbors , and subsequently enters @xmath164 ( l16 ) .",
    "this appears in the second row of the table where the value of @xmath37 is @xmath6 .",
    "when @xmath165 and @xmath166 receive this message at round @xmath0 , they execute the associated processing at l2 and l6 for @xmath165 and at l10 for @xmath166 .",
    "so , in this round @xmath165 updates its local variables @xmath167 at l2 , @xmath168 , @xmath169 and @xmath170 at l6 .",
    "@xmath166 updates its local variables @xmath171 at l2 , @xmath172 , at l10 .",
    "this appears in the third row of the table where @xmath37 is @xmath0 . in round 3 , @xmath165 has @xmath173 , so it broadcasts the message color@xmath49 with appropriate parameters ( l16 ) and gets @xmath174 ( l16 ) , etc .",
    "in round 6 , @xmath166 finds that the color proposed by its neighbor @xmath175 ( color 0 proposed in round 5 ) is in @xmath172 , so it  refuses  this color and gets @xmath176 ( l4 ) . in round 7 , @xmath166 gets a color which is not in @xmath177 ( l11 ) and broadcasts the message correct(@xmath178 , @xmath179 , 2 , 0 , @xmath180 ) . in round 8",
    ", @xmath175 updates @xmath181 and @xmath182 and gets a new color ( l31 ) .",
    "its state will allow it to broadcast the message corrected_cl@xmath49 ( round 11 ) .",
    "the broadcast of this message will trigger the broadcast of the message resume_cl@xmath49 ( round 15 ) to resume the coloring as described before ."
  ],
  "abstract_text": [
    "<S> this article is on message - passing systems where communication is ( a ) synchronous and ( b ) based on the `` broadcast / receive '' pair of communication operations . </S>",
    "<S> `` synchronous '' means that time is discrete and appears as a sequence of time slots ( or rounds ) such that each message is received in the very same round in which it is sent . </S>",
    "<S> `` broadcast / receive '' means that during a round a process can either broadcast a message to its neighbors or receive a message from one of them . in such a communication model , </S>",
    "<S> no two neighbors of the same process , nor a process and any of its neighbors , must be allowed to broadcast during the same time slot ( thereby preventing message collisions in the first case , and message conflicts in the second case ) . from a graph theory point of view , the allocation of slots to processes is know as the distance-2 coloring problem : a color must be associated with each process ( defining the time slots in which it will be allowed to broadcast ) in such a way that any two processes at distance at most @xmath0 obtain different colors , while the total number of colors is `` as small as possible '' .    </S>",
    "<S> the paper presents a parallel message - passing distance-2 coloring algorithm suited to trees , whose roots are dynamically defined . </S>",
    "<S> this algorithm , which is itself collision - free and conflict - free , uses @xmath1 colors where @xmath2 is the maximal degree of the graph ( hence the algorithm is color - optimal ) . </S>",
    "<S> it does not require all processes to have different initial identities , and its time complexity is @xmath3 , where @xmath4 is the depth of the tree . </S>",
    "<S> as far as we know , this is the first distributed distance-2 coloring algorithm designed for the broadcast / receive round - based communication model , which owns all the previous properties .     +   + * keywords * : broadcast / receive communication , collision , conflict , distance-2 graph coloring , message - passing , network traversal , synchronous system , time slot assignment , tree network , wireless network . </S>"
  ]
}