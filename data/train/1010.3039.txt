{
  "article_text": [
    "a finite state automaton is a machine that reads a string of letters over some finite alphabet one letter at a time , and either accepts or rejects the string after reading it .",
    "it has a finite set of internal states , some of which are designated `` start states , '' some of which are designated `` accept states , '' and some may be both or neither .",
    "the string of letters is written on a tape that is fed to the machine .",
    "the machine then starts in one of the start states , and upon reading the first letter , it changes to another state ( possibly the same one ) that depends on the current state and the letter being read .",
    "it then moves to the second letter on the tape and repeats the process . when it reaches the end of the string , if the machine is in an accept state , the string is accepted , and otherwise the string is rejected .",
    "there are several different ways to generalize finite state automata to machines that read @xmath2 tapes at once for some @xmath4 , and either accept or reject the entire @xmath2-tuple of strings written on the tapes .",
    "@xmath2-tape automaton reads all @xmath2 tapes simultaneously and at the same speed , reading the first letter of each tape , then the second letter on each tape , and so on , possibly changing states at each step .",
    "an _ asynchronous _",
    "@xmath2-tape automaton reads from one string at a time , and its current state determines which tape it reads from next .",
    "a _ non - deterministic asynchronous _",
    "@xmath2-tape automaton has its choice of several possible sets of tapes to read from at each step , and reads one letter from each of those tapes before moving to a next state and repeating the process .",
    "the set of accepted strings or @xmath2-tuples of strings is called the _ language _ accepted by the automaton . in general , an @xmath2-variable language over a finite alphabet @xmath0 is any subset of @xmath5 , where @xmath6 is the set of finite strings over @xmath0 .",
    "a language is _ regular _ if it is accepted by a synchronous automaton , it is _ quasi - regular _ if it is accepted by an asynchronous automaton , and it is _ weakly regular _ if it is accepted by a non - deterministic asynchronous automaton .",
    "regular languages are well studied throughout the literature ( see @xcite for an introduction to the topic ) , but quasi - regular and weakly regular languages are less understood .",
    "in fact , several different definitions of each notion have appeared throughout the literature .",
    "furthermore , while the relations defined by regular languages are closed under first - order logical operators ( union ( @xmath7 ) , intersection ( @xmath8 ) , complementation ( @xmath9 ) , and projection ( @xmath10 ) ) , this is not true of quasi - regular or weakly regular languages .    in this paper",
    ", we investigate the properties of quasi - regular and weakly regular languages and their use in automatic group theory . in section [ unifying ] ,",
    "we unify several of the notions of asynchronous and non - deterministic asynchronous automata that have appeared throughout the literature . in section [ closure ] , we investigate the closure properties of each class of languages under first order logical operators . in section",
    "[ groups ] , we apply our results to a decidability problem in asynchronous automatic group theory posed in @xcite .",
    "for any set @xmath11 , let @xmath12 denote the power set of @xmath11 .    a ( non - deterministic ) _ finite state automaton _ over an alphabet @xmath0 is a quadruple @xmath13 , where @xmath11 is a finite set of states , @xmath14 is the _ transition function _",
    ", @xmath15 is the set of _ initial states _ , and",
    "@xmath16 is the set of _ accept states_.    the _ state diagram _ of a non - deterministic finite state automaton @xmath17 is the edge - labeled directed graph with vertex set @xmath11 and whose directed edges are the pairs @xmath18 of states for which @xmath19 for some @xmath20 .",
    "we label such an edge by the letter @xmath21 .",
    "we circle the accept states , and the remaining states are called _",
    "failure states_.    the _ language _",
    "@xmath22 accepted by a finite state automaton @xmath23 is the set of all words @xmath24 for which there is a sequence of states @xmath25 with @xmath26 , @xmath27 , and @xmath28 for @xmath29 . in terms of the state diagram ,",
    "a word @xmath24 is accepted by @xmath23 ( that is , @xmath30 ) if and only if there is a path of edges , starting at a start state and ending at an accept state , whose labels are @xmath31 in that order .",
    "it is often useful to consider the finite state automata for which the next state is completely determined by the current state and the letter being read .",
    "a finite state automaton @xmath13 over an alphabet @xmath0 is _ partial deterministic _ if there is a unique start state @xmath26 and for each state @xmath32 and letter @xmath33 , we have that @xmath34 and @xmath35 . the automaton is",
    "_ deterministic _ if @xmath36 for all @xmath32 and @xmath33 .    in terms of the state diagram",
    ", a partial deterministic automaton has a unique start state , no @xmath37-arrows , and at most one @xmath21-arrow starting from each state .",
    "it is deterministic if there is exactly one @xmath21-arrow starting from each state .",
    "let @xmath38 denote the set of all ( possibly empty ) strings of letters in @xmath0 .",
    "a _ language _ over @xmath0 is any subset of @xmath38 .",
    "given languages @xmath3 and @xmath39 over @xmath0 , let @xmath40 denote the set of all strings formed by concatenating a finite sequence of elements of @xmath3 , and let @xmath41 denote the language consisting of all strings of the form @xmath42 where @xmath43 and @xmath44 .",
    "[ regular ] the class of _ regular languages _ over @xmath0 is the smallest class of languages over @xmath0 that :    * contains the empty language , * contains the languages @xmath45 for each @xmath33 , and * is closed under @xmath46 , concatenation , union , and intersection .",
    "a well known theorem by kleene , rabin , and scott ( see @xcite , @xcite ) states that all of these notions are equivalent :    [ kleenerabinscott ] let @xmath3 be a language over an alphabet @xmath0 .",
    "the following are equivalent :    * @xmath3 is accepted by a deterministic finite state automaton .",
    "* @xmath3 is accepted by a partial deterministic finite state automaton .",
    "* @xmath3 is accepted by a non - deterministic finite state automaton .",
    "* @xmath3 is a regular language over @xmath0 .",
    "the notion of a finite state automaton can be generalized to allow multiple tapes to be read by the machine simultaneously . in this section ,",
    "we follow the conventions in @xcite . to account for the fact that the word written on one tape may be longer than the word written on another , we introduce a _ padding symbol _",
    "@xmath47 that we use to pad the shorter strings in order to obtain strings of the same length .    the @xmath2-tape _ padded alphabet _ over @xmath0 is the set @xmath48 we denote the @xmath2-tape padded alphabet by @xmath49 when @xmath2 is understood .",
    "in order to distinguish between letters or words over @xmath0 and letters or words over @xmath50 or @xmath49 , we use the following conventions .",
    "a greek character such as @xmath51 or @xmath52 will be used to denote a letter in @xmath53 , and we will use @xmath54 , @xmath55 , @xmath56 , @xmath57 , @xmath21 , @xmath58 , and @xmath59 to denote letters of @xmath0 ( other than @xmath47 or @xmath37 ) .",
    "the letters @xmath60 , @xmath61 , or @xmath62 will be used to denote a word over @xmath0 , an overlined greek character such as @xmath63 will be used to denote an @xmath2-tuple of letters @xmath64 , and an overlined english character such as @xmath65 will be used to denote an @xmath2-tuple of words .",
    "we use @xmath66 to denote the number of letters in @xmath62 .    given an @xmath2-tuple of strings @xmath67 ,",
    "let @xmath68 , and for @xmath69 define @xmath70 to be the @xmath2-tuple consisting of the @xmath71th letters of each @xmath72 , where the @xmath71th letter is taken to be a padding symbol @xmath47 if @xmath73 .",
    "then the _ padded string _ associated with @xmath65 is the word @xmath74 .",
    "if @xmath3 is any set of @xmath2-tuples of strings over @xmath0 , the associated _ padded extension _ over @xmath49 , denoted @xmath75 , is the language consisting of the padded strings associated with the elements of @xmath3 .",
    "the padded string associated with @xmath76 is @xmath77 .",
    "notice that , given a language @xmath78 consisting of only padded strings , we may remove the @xmath47 symbols to obtain the unique set @xmath3 of @xmath2-tuples of words over @xmath0 for which @xmath79 .",
    "we now have the tools to define an @xmath2-tape finite state automaton .",
    "an _ @xmath2-tape deterministic finite state automaton _ over @xmath0 is a deterministic finite state automaton @xmath23 over the padded alphabet @xmath49 that only accepts padded strings .",
    "if the language @xmath78 consisting of the padded strings accepted by @xmath23 is equal to @xmath75 , then we say that @xmath23 accepts the language @xmath3 , and that @xmath3 is an _",
    "@xmath2-tape regular language _ over @xmath0 .",
    "notice that , by theorem [ kleenerabinscott ] , the definition of @xmath2-tape regular language agrees with definition [ regular ] in the case @xmath80 .      the @xmath2-tape automata described above read all @xmath2 tapes in parallel , at the same speed .",
    "for this reason , we say that such automata are _",
    "synchronous_. we now consider _ asynchronous automata _ , which read from one tape at a time , and may switch tapes several times in the process .",
    "two equivalent definitions of two - tape automata have appeared in the literature independently .",
    "the notion was first introduced in @xcite :    a two - tape _ asynchronous automaton _ over an alphabet @xmath0 is a deterministic automaton over the alphabet @xmath53 , along with a partition of the state set into two sets @xmath81 and @xmath82 , called the _ left _ and _ right _ state sets .",
    "shuffle _ of an @xmath2-tuple of words @xmath83 over an alphabet @xmath0 is an ordering of all the letters of @xmath84 that respects the ordering in each of the words @xmath72 .",
    "for instance , two valid shuffles of @xmath85 are @xmath86 and @xmath87 ( the shuffle @xmath86 also carries information about which @xmath55 came from the left or right component , but we use the term ` shuffle ' loosely to refer to either the mapping of the letters to their position , or to the word spelled by the shuffle ) .",
    "also , for any word @xmath62 , define @xmath88 to be the word formed by appending the symbol @xmath47 at the end of the string @xmath62 .",
    "the language @xmath22 accepted by an asynchronous automaton @xmath23 is defined to be the set of all pairs @xmath89 of words over @xmath0 such that there is some ( unique ) shuffle of @xmath90 that is accepted by the underlying deterministic automaton and has the property that the automaton must be in a state in @xmath81 to read a letter from @xmath60 and in a state in @xmath82 to read a letter from @xmath61 .    in @xcite ,",
    "asynchronous automata are defined as follows .",
    "a two - tape asynchronous automaton over an alphabet @xmath0 is a partial deterministic finite state automaton @xmath23 over the language @xmath91 , along with a partition of the set of states into five subsets @xmath81 , @xmath82 , @xmath92 , @xmath93 , and @xmath94 , such that the following hold :    * @xmath94 contains exactly one element , @xmath95 , which is also the unique accept state of the automaton . *",
    "the start state of @xmath23 is in either @xmath81 or @xmath82 . *",
    "an arrow is labeled by @xmath47 if and only if it maps a state in @xmath96 to a state in @xmath97 , where the pair @xmath98 is one of @xmath99 , @xmath100 , @xmath101 , or @xmath102 .",
    "* arrows starting in @xmath81 can only end in @xmath81 , @xmath82 , or @xmath93 .",
    "* arrows starting in @xmath82 can only end in @xmath81 , @xmath82 , or @xmath92 .",
    "* arrows starting in @xmath92 can only end in @xmath92 or @xmath94 .",
    "* arrows starting in @xmath93 can only end in @xmath93 or @xmath94 . *",
    "no arrows start in @xmath94 .    in this definition ,",
    "the language accepted by an asynchronous automaton is the set of all pairs of words @xmath89 such that there is a ( unique ) shuffle of @xmath103 accepted by the underlying deterministic automaton .",
    "following a @xmath47-arrow from , say , @xmath81 to @xmath104 indicates that we have reached the end of the left tape and now only need to read the right tape until we reach another @xmath47 .    in order to distinguish between these two definitions , we call the former a _ semi - sorted _ asynchronous automaton , and the latter a _ sorted _ asynchronous automaton , since the states of the former are only sorted based on the tape being read , while the states of the latter are further sorted based on the number of @xmath47 symbols the automaton has read so far .",
    "we can easily generalize each of these definitions to @xmath2 tapes .",
    "for simplicity , we write @xmath105 $ ] to denote the set @xmath106 .",
    "an @xmath2-tape _ semi - sorted asynchronous automaton _ over an alphabet @xmath0 is a partial deterministic finite state automaton over the alphabet @xmath53 , along with a partition of the state set into @xmath2 sets @xmath107 .",
    "an @xmath2-tape _ sorted asynchronous automaton _ over an alphabet @xmath0 is a partial deterministic finite state automaton @xmath23 over the language @xmath91 , along with a partition of the set of states into subsets of the form @xmath108 where @xmath109 is a proper subset of @xmath105 $ ] and @xmath110\\backslash v$ ] , and a final subset @xmath111}$ ] , such that the following hold :    * the start state of @xmath23 is in @xmath112 for some @xmath113 . *",
    "an arrow is labeled by @xmath47 if and only if it maps a state in @xmath96 to a state in @xmath97 , where the pair @xmath98 is of the form @xmath114 with @xmath115 and @xmath116 .",
    "* arrows _ not _ labeled by @xmath47 that start in @xmath117 must end in @xmath118 for some @xmath119 .",
    "* @xmath111}$ ] contains exactly one element , @xmath95 , which is also the unique accept state of the automaton .",
    "* no arrows start in @xmath111}$ ] .",
    "we show that these two definitions are equivalent",
    ".    sorted and semi - sorted asynchronous automata accept the same class of languages .",
    "let @xmath23 be an @xmath2-tape sorted asynchronous automaton with ( partial ) transition function @xmath120 and with state sets @xmath117 and @xmath111}$ ] as in the definition .",
    "for @xmath121 , define @xmath122 where @xmath109 ranges over the proper subsets of @xmath105 $ ] not containing @xmath113 . also define @xmath123}\\ ] ] where @xmath109 ranges over the proper subsets of @xmath105 $ ] not containing @xmath2 .",
    "then we see that the partition @xmath124 makes @xmath23 into a semi - sorted asynchronous automaton @xmath39 with @xmath125",
    ".    conversely , let @xmath39 be an @xmath2-tape semi - sorted asynchronous automaton , with state sets @xmath126 , @xmath29 .",
    "we construct a sorted asynchronous automaton @xmath23 as follows .",
    "we first construct @xmath127 exact copies of each @xmath126 , labeled @xmath117 for each proper subset @xmath109 of @xmath106 , inheriting any arrows that start and end in @xmath126 .",
    "for any set @xmath109 and any two distinct indices @xmath128 , we draw arrows between states @xmath129 and @xmath130 if and only if the corresponding states in @xmath126 and @xmath131 are connected in @xmath39 .    the quality of being a start state or accept state is _ not _ inherited , with one exception : if the start state of @xmath39 is in @xmath126 , we define the corresponding element of @xmath132 to be the start state of @xmath23 . we also construct a new accept state @xmath133 and define @xmath134 .",
    "we now perform the following operations in order :    * for each @xmath110 $ ] , let @xmath135\\backslash\\{i\\}$ ] .",
    "if an arrow labeled by @xmath47 in @xmath39 starts at a state @xmath136 and ends at an accept state of @xmath23 , draw a new arrow in @xmath23 labeled by @xmath47 from the corresponding state in @xmath137 to @xmath133 . *",
    "if an arrow labeled by @xmath47 in @xmath39 starts in @xmath126 and ends in @xmath131 , then for each @xmath109 not containing @xmath113 or @xmath138 , draw a new arrow in @xmath23 labeled by @xmath47 starting and ending at the corresponding states in @xmath117 and @xmath139 . *",
    "remove any @xmath47-arrow in @xmath23 that both starts and ends in any of the sets @xmath117 .",
    "these operations guarantee that when we are done reading the @xmath113th tape and reach the corresponding @xmath47-arrow , the next state is in some @xmath118 where @xmath109 contains @xmath113 .",
    "this makes the resulting automaton @xmath23 into a sorted asynchronous automaton that accepts the same language as @xmath39 .",
    "this completes the proof .",
    "we call a language accepted by a ( sorted or unsorted ) asynchronous automaton a _ quasi - regular _ language .",
    "we shall see that the class of quasi - regular languages is a strict superset of the class of regular languages . to illustrate this ,",
    "we first prove a generalization of the well - known _ pumping lemma _ for @xmath2-tape regular languages .",
    "[ npumping ] let @xmath3 be a regular @xmath2-variable language over an alphabet @xmath0 .",
    "there is a positive integer @xmath140 such that for any @xmath2-tuple of words @xmath141 with @xmath142 , there are nonnegative integers @xmath143 and @xmath144 , with @xmath145 , such that if we write each @xmath72 as @xmath146 where @xmath147 consists of the @xmath71th through @xmath148th letters of @xmath72 , then we have @xmath149 for all @xmath150 .",
    "moreover , each substring @xmath147 either consists entirely of letters in @xmath0 or consists entirely of @xmath47 symbols .",
    "let @xmath23 be an @xmath2-tape finite state automaton accepting @xmath3 , and let @xmath140 be the number of states of @xmath3 . then if @xmath67 is in @xmath3 such that @xmath142 , the path of arrows traced out on @xmath23 that read @xmath62 visits at least @xmath151 states , and so some state must be visited more than once . in particular",
    ", there is a loop of some length @xmath144 in the path , that starts at the @xmath71th arrow in the path . for each @xmath29 ,",
    "let @xmath152 denote the sequence of letters appearing in the @xmath113th coordinate along this loop .",
    "we may now form new accepted paths by repeating this loop @xmath153 times before continuing along the path . thus ,",
    "if we write @xmath154 then @xmath155 is also accepted by @xmath23 for any @xmath150 .    finally ,",
    "if @xmath152 consists of some letters and some @xmath47 symbols , we would obtain an accepted @xmath2-tuple of words which is not a padded string , which contradicts the definition of an @xmath2-tape finite state automaton .",
    "thus each @xmath152 either consists entirely of letters in @xmath0 or consists entirely of @xmath47 symbols .",
    "we now provide an example demonstrating that not all quasi - regular languages are regular .",
    "+    [ quasinotregular ] the two - variable language @xmath156 is quasi - regular but not regular .",
    "since @xmath3 is accepted by the sorted asynchronous automaton shown in figure [ sorted1 ] , @xmath3 is quasi - regular .    now , suppose @xmath3 were regular . by lemma [ npumping ] there are nonnegative integers @xmath71 and @xmath144 such that we may repeat the @xmath71th to @xmath148th letters of each component any number of times to obtain new elements of @xmath3 , as long as either @xmath157 ( when both subwords consist only of @xmath21 s ) or @xmath158 ( when the left subword consists only of @xmath47 symbols and the right consists only of @xmath21 s ) .",
    "we consider these two cases separately .    if @xmath157 , the words @xmath159 would be in @xmath3 for each @xmath160 , but since @xmath161 we have @xmath162 for @xmath163 .",
    "thus these words are not in the language , a contradiction .    if @xmath158 , the words @xmath164 would be in @xmath3 for @xmath160 , again a contradiction since @xmath165 for @xmath166 .",
    "it follows that @xmath3 is not regular .    a sorted asynchronous automaton that accepts the language @xmath156 .",
    "the darkened circle indicates the start state , and the double circle indicates the accept state of the automaton .",
    "the sets @xmath81 , @xmath82 , @xmath167 , @xmath104 , and @xmath168 are outlined . ]",
    "we now study _ non - deterministic _ asynchronous automata , which may read from any of several possible subcollections of the tapes , called _ filters _",
    ", at each step , and has a choice of several possible next states at each transition . in @xcite , khoussainov and nerode",
    "defined these automata as follows .",
    "[ faa ] let @xmath169)\\backslash\\{\\emptyset\\}\\right)$ ] , and call @xmath170 the set of _ filters _ on @xmath2 tapes . let @xmath0 be a finite alphabet , and let @xmath171 be the associated padded alphabet",
    ". then an _",
    "@xmath2-tape non - deterministic filter asynchronous automaton _ , or _",
    "faa _ , is a quadruple @xmath172 where :    * @xmath11 is a finite set of states , * @xmath15 is the set of initial states , * @xmath16 is the set of accept states , and * @xmath173 is a transition function that , given a state and a letter over @xmath49 , returns a set of next states along with a set of filters , and * for all @xmath174 and for all @xmath32 , if @xmath175 and the set of next states given by @xmath176 is nonempty , then @xmath113 is not in any of the filters given by @xmath176 .",
    "an @xmath2-tuple of words is accepted by a faa if the following condition is satisfied .",
    "we write the @xmath2 words in question on @xmath2 tapes , starting in a start state of @xmath23 , we choose a valid filter as given by the transition function , move one position to the right along precisely those tapes whose index is in that filter , and non - deterministically choose one of the next possible states as the next state . if this process can be repeated until the end of every tape is reached , and the final state of this process is an accept state , then the tuple is accepted by @xmath23 .",
    "formally , an @xmath2-tuple of words @xmath67 is accepted by @xmath23 if and only if there is a sequence of states @xmath177 where @xmath178 is a start state and @xmath179 is an accept state , along with an associated sequence of filters @xmath180 , with the following properties .",
    "for each @xmath181 , let @xmath182 be the @xmath2-tuple whose @xmath113th coordinate is the @xmath153th entry of @xmath72 , where @xmath153 is the total number of filters of @xmath183 containing @xmath113 . then if for all @xmath71 , @xmath184 where @xmath11 contains @xmath185 and @xmath96 contains @xmath186 , the @xmath2-tuple @xmath62 is accepted by @xmath23 .",
    "this is a slight modification of the original definition of khoussainov and nerode in @xcite , which does not include the condition that the state set of @xmath176 is nonempty in the last bullet point .",
    "note that , in a faa , if @xmath187 then we can not make a move starting at @xmath188 with input @xmath63 , and so the content of @xmath96 does not matter in determining its accepted language .",
    "thus , the two definitions are equivalent .",
    "we use our modified version throughout .",
    "another definition of non - deterministic asynchronous automata in the two - tape case appeared independently in @xcite .",
    "shapiro defined a two - tape non - deterministic asynchronous automaton to be a non - deterministic automaton along with a partition of the set of states into two sets .",
    "we may generalize shapiro s definition to @xmath2 tapes as follows .",
    "@xmath2-tape non - deterministic semi - sorted asynchronous automaton _",
    "( saa ) over an alphabet @xmath0 is a non - deterministic finite state automaton over @xmath189 along with a partition of the set of states into @xmath2 sets @xmath107 .",
    "we say that an @xmath2-tuple of words @xmath67 is accepted by a saa with transition function @xmath120 if there is a shuffle @xmath60 of @xmath190 and a sequence of states @xmath191 for which @xmath192 on the diagram of the non - deterministic automaton , starting at a start state and ending at an accept state , that reads the tuple in question , where an arrow from a state in @xmath193 corresponds to reading and moving one position along the @xmath113th tape .",
    "we will show that the class of languages ( @xmath2-tuple relations ) accepted by faa s is identical to the class of languages accepted by saa s . in order to do so ,",
    "we first define yet another type of automaton that accepts the same class of languages .    a _ deterministic - filter ( non - deterministic ) asynchronous automaton _ , or dfaa , is a faa with the property that , in any given state , there is at most one possible filter to choose from . in other words , if @xmath194 then @xmath195 .",
    "we now show that faa s , dfaa s , and saa s all have the same class of accepted languages .",
    "let @xmath3 be an @xmath2-variable language over a finite alphabet @xmath0 .",
    "the following are equivalent .    * @xmath3 is the accepted language of an faa .",
    "* @xmath3 is the accepted language of an dfaa . *",
    "@xmath3 is the accepted language of a saa .",
    "let @xmath196 be a faa .",
    "we construct a dfaa @xmath197 accepting the same language as @xmath23 .",
    "define the state set of @xmath197 to be @xmath198)\\backslash{\\emptyset})=\\{(s,\\chi)\\mid s\\in s\\text { and } \\chi\\in p([n])\\backslash\\{\\emptyset\\}\\}.\\ ] ] define the set of start states @xmath199 to be the set of states @xmath200 such that @xmath26 , and define the set of final states @xmath201 to be the set of states @xmath202 such that @xmath203 .",
    "the transition function @xmath204 is given by @xmath205    in other words , the transition function for @xmath197 takes in a pair @xmath206 and reads an @xmath2-tuple @xmath63 .",
    "if @xmath207 is a possible move of @xmath23 on state @xmath188 with input @xmath63 , then @xmath197 may move to any state @xmath208 where @xmath209 is a state that @xmath23 can reach from @xmath188 upon input @xmath63 and @xmath52 is any valid filter . furthermore ,",
    "@xmath197 moves along precisely those tapes whose index is in the filter @xmath207 .",
    "we now show that @xmath197 is a well - defined faa ; since there is a unique filter to choose from in any given state , it then follows that it is a dfaa .    to show that @xmath204 is a valid faa transition function , let @xmath206 be any state of @xmath197 and",
    "let @xmath210 be any @xmath2-tuple of letters over @xmath0 .",
    "first , suppose @xmath207 is in the set of possible filters of @xmath176 .",
    "then for any @xmath113 for which @xmath175 , we have that @xmath211 since @xmath23 is a faa .",
    "thus @xmath113 does not occur in the set of possible filters , namely , @xmath212 , of @xmath213 .    otherwise , if @xmath207 is not in the set of possible filters of @xmath176 , then the state set of @xmath213 is empty , and so the condition is trivially satisfied .",
    "we now show that @xmath197 accepts the same language as @xmath23 .",
    "given an accepted @xmath2-tuple @xmath62 of words in @xmath23 , there is a path of filters @xmath214 that one follows from a start state @xmath178 to a final ( accept ) state @xmath179 .",
    "let @xmath215 be the @xmath2-tuples of letters that are read at each step along the way .",
    "consider the path of states @xmath216 in @xmath197 . by our definition of @xmath217",
    ", we may read @xmath217 with filter @xmath218 to move from state @xmath219 to @xmath220 , at which point we are reading @xmath221 , and so on , until we read all of @xmath62 and reach the accept state @xmath222 .",
    "thus every word accepted by @xmath23 is accepted by @xmath197 .",
    "conversely , suppose @xmath216 is any path of states in @xmath197 , ending on an accept state @xmath222 , that defines the sequence @xmath215 of @xmath2-tuples of letters being read by the corresponding arrows .",
    "then there is a path between the states @xmath223 with associated filters @xmath224 that is accepted by @xmath23 and reads off precisely these @xmath2-tuples . thus every word accepted by @xmath197",
    "is accepted by @xmath23 .",
    "it follows that every language accepted by a faa is also accepted by an dfaa .",
    "note that every dfaa is also a faa by definition , and so every dfaa language is also accepted by a faa .",
    "this completes the first equivalence .",
    "now , let @xmath109 be an arbitrary dfaa .",
    "we construct a saa @xmath225 that accepts the same language as @xmath109 .",
    "to do so , we first note that the states of @xmath109 can be sorted into sets based on their associated filter @xmath207 .",
    "we can represent @xmath109 as a graph with the states as nodes and with arrows between states labeled by @xmath2-tuples of letters to indicate the transition diagram , where the nodes are sorted into @xmath226 disjoint sets , one for each filter @xmath207 .",
    "let @xmath193 be the set whose filter consists only of the tape @xmath113 . for each state",
    "@xmath227 that is not in any @xmath193 , we perform the following operation :    1 .",
    "let @xmath228 be the elements of the filter @xmath207 of @xmath229 .",
    "then we move @xmath229 to the set @xmath230 .",
    "2 .   for each arrow starting at @xmath229 ,",
    "say @xmath231 labeled by @xmath51 , add new states @xmath232 to the sets @xmath233 respectively , and draw arrows labeled by @xmath51 from @xmath229 to @xmath234 , from @xmath234 to @xmath235 , etc . , and then from @xmath236 to @xmath237 .",
    "once this has been done , we replace the label @xmath51 on any arrow starting in @xmath193 with the label @xmath238 , for it is only this letter which is allowed through .",
    "it is clear that the resulting automaton @xmath225 accepts the same set of @xmath2-tuples of words as @xmath109 .",
    "it follows that every language accepted by a dfaa is also accepted by a saa .    finally , given a saa @xmath109",
    ", we may interpret it as a dfaa by making the associated filter of each state in @xmath193 be the filter @xmath239 , and re - labeling the arrows starting in @xmath193 with @xmath2-tuples that match in the @xmath113th position for each @xmath113 . thus every language accepted by a saa",
    "is also accepted by a dfaa .",
    "a _ regular predicate _ over an alphabet @xmath0 is any statement @xmath240 such that the set of tuples of words @xmath241 in @xmath50 for which @xmath225 holds is a regular language .",
    "we can similarly define quasi - regular and weakly regular predicates .",
    "it is known that regular predicates are closed under first - order predicate logic .",
    "we now investigate the closure properties of quasi - regular and weakly regular predicates .",
    "[ quasiclosure ] in the following , let @xmath240 and @xmath242 be @xmath2-variable quasi - regular predicates .    1 .",
    "the predicate @xmath243 is quasi - regular .",
    "the predicate @xmath244 is not necessarily quasi - regular .",
    "the predicate @xmath245 is not necessarily quasi - regular .",
    "the predicate @xmath246 is weakly regular , but not necessarily quasi - regular .",
    "the predicate @xmath247 is not necessarily quasi - regular .",
    "if @xmath248 , the predicate @xmath249 is regular .",
    "7 .   if @xmath248 , the predicate @xmath250 is regular .    in summary , @xmath2-variable quasi - regular predicates ( languages )",
    "are closed under @xmath9 ( complementation ) , but not under @xmath7 ( union ) , @xmath8 ( intersection ) , @xmath10 ( projection ) or @xmath251 ( complementation of the projection of the complement ) . in the case @xmath248 , the application of @xmath10 or @xmath251 yields a @xmath252-variable regular language .",
    "see @xcite for a proof of claims ( a ) , ( f ) , and ( g ) .    for ( b ) , recall from example [ quasinotregular ] that the language @xmath253 is quasi - regular . similarly , the language @xmath254 is quasi - regular .",
    "we show that their union @xmath255 is not quasi - regular .",
    "assume to the contrary that there is a semi - sorted deterministic asynchronous automaton @xmath39 accepting @xmath3 .",
    "since @xmath39 has a finite number of states and the lengths of the paths accepting pairs of the form @xmath256 become arbitrarily large , there must exist a cycle in its state diagram .",
    "since no cycle can contain a @xmath47 symbol , the cycle must consist entirely of edges labeled by @xmath21 .",
    "tracing around this cycle will yield a word of the form @xmath257 for some @xmath188 and @xmath209 .",
    "choose @xmath258 large enough so that the path accepting @xmath259 traverses this cycle at least once .",
    "we can repeat the cycle @xmath71 times , so that @xmath39 accepts all words of the form @xmath260 for nonnegative integers @xmath71 .",
    "it follows from the definition of @xmath3 that @xmath261 .",
    "similarly , there exists a cycle of the form @xmath262 where @xmath263 .",
    "these cycles are clearly distinct , and must occur on a path from the start vertex that does not contain any @xmath47 symbols .",
    "but since @xmath39 is deterministic , this is impossible , and we have a contradiction .    to prove ( c ) , assume to the contrary that @xmath264 is quasi - regular for any @xmath2-variable quasi - regular predicates @xmath265 and @xmath11 .",
    "note that @xmath266 is equivalent to @xmath267 .",
    "since @xmath268 and @xmath269 are quasi - regular , by our assumption we have that @xmath270 is quasi - regular , and hence @xmath267 is quasi - regular as well .",
    "thus @xmath271 is necessarily quasi - regular , contradicting ( b ) .    for ( d ) , we first show that the predicate is weakly regular .",
    "let @xmath39 be a semi - sorted asynchronous automaton accepting the relation defined by @xmath225 , with state sets @xmath272 .",
    "then we can replace all arrows starting in the state set @xmath273 corresponding to @xmath274 by @xmath37-arrows and merge the states of @xmath273 with @xmath275 to obtain a non - deterministic saa that accepts @xmath276 .",
    "to show @xmath276 is not necessarily quasi - regular , let @xmath277 , and let @xmath278 , where @xmath2 ranges over the nonnegative integers .",
    "we show that the predicate @xmath279 is a quasi - regular predicate over @xmath0 , but its projection @xmath280 is not quasi - regular . a semi - sorted asynchronous automaton accepting the language @xmath3 is shown in figure [ sorted2 ] .    a semi - sorted asynchronous automaton accepting the language @xmath281 .",
    "]    now , the predicate @xmath280 defines the two - variable language @xmath282 , which is not quasi - regular , by our example for ( b ) .    for ( e )",
    ", we note that @xmath276 is equivalent to @xmath283 .",
    "thus , if @xmath251 maps quasi - regular predicates to quasi - regular predicates , it would follow that @xmath10 does as well by closure under complementation , contradicting ( d ) .",
    "thus @xmath251 does not preserve quasi - regularity .",
    "in part ( d ) of the above proposition , we found that applying the @xmath10 operator to a quasi - regular predicate yields a weakly regular predicate .",
    "we now show that every weakly regular predicate can be obtained in this way .",
    "[ bridge ] suppose @xmath240 is an @xmath2-variable weakly regular predicate .",
    "then there is an @xmath284-variable quasi - regular predicate @xmath285 for which @xmath286    let @xmath3 denote the language defined by @xmath240 .",
    "let @xmath39 be a non - deterministic semi - sorted asynchronous automaton ( saa ) over an alphabet @xmath287 , with state sets @xmath107 , accepting the language @xmath3 .",
    "we construct from @xmath39 a semi - sorted asynchronous automaton @xmath288 , with an additional state set @xmath289 , as follows .",
    "let @xmath71 be the number of @xmath37-arrows appearing in the state diagram of @xmath2 .",
    "we choose any ordering of the @xmath37-arrows , and perform the following operation on the @xmath113th @xmath37 arrow for @xmath290 .",
    "we create a new state @xmath291 in the new state set @xmath289 , and make @xmath291 an accept state or start state if and only if @xmath188 is an accept state or start state , respectively .",
    "suppose the @xmath37 arrow begins in a state @xmath292 and ends in a state @xmath293 defined by @xmath240 .",
    "for each arrow @xmath294 from any other state @xmath209 into @xmath292 , we draw a new arrow with the same label as @xmath294 from @xmath209 to @xmath291 , and an arrow labeled by a new letter @xmath295 from @xmath291 to @xmath293 .",
    "then , we remove the @xmath37 arrow .",
    "we now have a new saa @xmath296 over an extended alphabet @xmath297 having no @xmath37-arrows ( here @xmath71 is the number of @xmath37-arrows in the original automaton @xmath39 ) .",
    "note that we have simply re - routed every path through the original @xmath37-arrows with the use of extra letters appearing in the @xmath298th component , and so the @xmath2-tuples of words appearing as the last @xmath2 words in an @xmath284-tuple accepted by @xmath296 are precisely those @xmath2-tuples in @xmath3 .",
    "thus , @xmath296 accepts a language @xmath299 whose projection onto the last @xmath2 variables is the language @xmath3 .",
    "next , we modify @xmath296 to form a semi - sorted asynchronous automaton @xmath288 , accepting another language @xmath300 whose projection onto the last @xmath2 variables is also @xmath3 .",
    "let @xmath138 be the total number of arrows @xmath294 of @xmath39 such that the state @xmath188 at which @xmath294 begins has at least one more arrow with the same label as @xmath294 beginning at @xmath188 .",
    "( notice that @xmath188 can not lie in @xmath289 , since in our construction above , every arrow starting in @xmath289 was given a unique label . )",
    "choose an ordering @xmath301 of these arrows .    for each state",
    "@xmath188 having two arrows of the same label @xmath51 beginning at @xmath188 , we create a new state @xmath302 in @xmath289 .",
    "we make @xmath302 an accept state or start state if and only if @xmath188 is an accept state or start state , respectively .",
    "next , we draw an arrow labeled by @xmath51 from @xmath188 to @xmath302 . now , each arrow labeled by @xmath51 starting at @xmath188 is one of the arrows @xmath303 by construction .",
    "suppose @xmath303 ends at the state @xmath291 .",
    "we draw an arrow from @xmath302 to @xmath291 labeled by a new letter @xmath304 , and we remove the arrow @xmath303 . notice that there is now exactly one arrow labeled @xmath51 beginning at @xmath188 , and by following the arrow into @xmath289 , we can come out to any of the states that @xmath51 originally pointed to in @xmath296 .",
    "thus , we have re - routed the redundant arrows through a single arrow into @xmath289 , without changing any of the nonzero components of our accepted paths .",
    "we now have an automaton with no @xmath37-arrows and at most one arrow of each label starting from a given state .",
    "thus , to make it partial deterministic , we only need to consider the possibility that there are multiple start states .",
    "let @xmath305 be the start states of the automaton .",
    "we construct a new start state @xmath153 in @xmath289 , and for each @xmath306 we draw an arrow from @xmath153 to @xmath306 labeled by a new letter @xmath307 .",
    "we then make the states @xmath306 into non - start states .",
    "this yields a semi - sorted asynchronous automaton @xmath288 , accepting a quasi - regular language @xmath300 , such that @xmath308 defines the language @xmath3 .",
    "[ weaklyclosure ] in the following , let @xmath240 and @xmath242 be @xmath2-variable weakly regular predicates .    1 .",
    "the predicate @xmath243 is not necessarily weakly regular .",
    "the predicate @xmath309 is weakly regular .",
    "the predicate @xmath310 is not necessarily weakly regular .",
    "4 .   the predicate",
    "@xmath246 is weakly regular .",
    "the predicate @xmath247 is not necessarily weakly regular .",
    "6 .   if @xmath248 , the predicate @xmath249 is regular .",
    "claim ( f ) is shown in @xcite .",
    "we first prove ( b ) .",
    "given two @xmath2-variable weakly regular languages , let @xmath39 and @xmath311 be corresponding non - deterministic semi - sorted asynchronous automata ( saa s ) , with state sets @xmath107 and @xmath312 respectively .",
    "then the disjoint union of their state diagrams , with state sets @xmath313 , is another saa that accepts the union of the two weakly regular languages .    for ( c ) ,",
    "consider the two - variable languages @xmath314 and @xmath315 first , note that each of @xmath316 and @xmath317 is a weakly regular language ; in fact , they are quasi - regular , with the state diagram of a semi - sorted asynchronous automaton accepting @xmath316 shown in figure [ sorted3 ]",
    ". we can easily modify the diagram to see that @xmath317 is quasi - regular as well .    a semi - sorted asynchronous automaton accepting the language @xmath318 . ]    now , assume for contradiction that the language @xmath319 is weakly regular . by ( f ) , it follows that the one - variable language @xmath320 is regular .",
    "but the pumping lemma shows that this can not be regular , and so we have a contradiction .",
    "this proves ( c )",
    ".    we can now prove ( a ) .",
    "suppose that the complement of any weakly regular language is weakly regular . then using the identity @xmath321 and the fact that weakly regular languages are closed under union , we have that they are closed under intersection , contradicting ( c ) .    for ( d ) , let @xmath39 be a saa accepting the language defined by @xmath225 , with state sets @xmath272 .",
    "then we can replace all arrows starting in the state set @xmath273 corresponding to @xmath274 by @xmath37-arrows and merge the states of @xmath273 with @xmath275 to obtain a saa that accepts the language defined by @xmath276 .",
    "finally , for part ( e ) , we use the languages @xmath316 and @xmath317 defined above .",
    "since they are quasi - regular , their complements @xmath322 and @xmath323 are quasi - regular as well .",
    "thus , the language @xmath324 is weakly regular by ( b ) .",
    "however , its complement , @xmath325 , is not weakly regular , as above .    by theorem [ bridge ] ,",
    "there is a quasi - regular predicate @xmath326 for which @xmath327 defines the language @xmath3 .",
    "thus , the negation of the statement , @xmath328 is not weakly regular .",
    "this statement can be rewritten as @xmath329 . since",
    "quasi - regular predicates are closed under negation , it follows that there is a quasi - regular ( and hence weakly regular ) predicate @xmath330 , namely , @xmath331 , for which @xmath332 is not weakly regular .",
    "this completes the proof .",
    "we first give some background on finitely presented and automatic groups , following the conventions and terminology in @xcite .",
    "let @xmath0 be a finite set along with a pairing of its elements , so that paired elements are called _ inverses _ of each other . if @xmath33 , we write @xmath333 to denote the formal inverse of @xmath21 in @xmath0 .",
    "( note that an element may be its own inverse . )",
    "then the _ free group _ on @xmath0 , denoted @xmath334 , is the group under concatenation of all words over @xmath0 that contain no adjacent inverse generators .",
    "a _ finite presentation _ of a group @xmath335 consists of a finite inverse - closed set @xmath336 called the _ generating set _ or the set of _ generators _ , along with a finite set @xmath337 called the set of _ relators _ , and such that if @xmath311 denotes the smallest normal subgroup of @xmath334 containing @xmath265 , then @xmath338 . in this case , we write @xmath339 .",
    "given a finite presentation @xmath340 and a word @xmath341 , we write @xmath342 to denote the element of @xmath335 that @xmath62 represents , that is , when we interpret concatenation as group multiplication .",
    "let @xmath339 be a finitely presented group .",
    "a _ automatic structure _ for the presentation is a finite state automaton @xmath23 , called the _ word acceptor _ , along with _",
    "multiplier automata _",
    "@xmath343 for each @xmath344 , such that the following hold :    * the language accepted by @xmath3 represents every element of the group , that is , @xmath345 .",
    "* for each @xmath33 , @xmath343 is a finite state automaton that accepts precisely those pairs of words @xmath346 for which @xmath347 .",
    "* @xmath348 is a finite state automaton that accepts precisely those pairs of words @xmath346 for which @xmath349 .",
    "it is known that if a group has an automatic structure with respect to one set of generators , then it has an automatic structure with respect to every set of generators @xcite .",
    "thus , if a group has a finite presentation with an automatic structure , it is said that the group is _",
    "automatic_.    epstein , et .",
    "al @xcite gave a similar definition of an asynchronous automatic group .",
    "let @xmath339 be a finitely presented group .",
    "asynchronous automatic structure _ for the presentation is a finite state automaton @xmath23 , called the word acceptor , along with asynchronous multiplier automata @xmath343 for each @xmath344 , such that the following hold :    * the language accepted by @xmath3 represents every element of the group , that is , @xmath345 . * for each @xmath33 , @xmath343 is an asynchronous automaton that accepts precisely those pairs of words @xmath346 for which @xmath347 .",
    "* @xmath348 is an asynchronous automaton that accepts precisely those pairs of words @xmath346 for which @xmath349 .    as in the synchronous case ,",
    "if a group has an asynchronous automatic structure with respect to one set of generators , then it has an asynchronous automatic structure with respect to every set of generators @xcite .",
    "thus , if a group has a finite presentation with an asynchronous automatic structure , we say that the group is _",
    "asynchronous automatic_.    while every asynchronous automatic group is automatic , the class of asynchronous automatic groups is strictly larger . in particular , for @xmath350 , the baumslag - solitar group @xmath351 is asynchronous automatic , but not automatic .",
    "it would seem natural to go on to define a non - deterministic asynchronous automatic group in a similar fashion .",
    "however , in @xcite , shapiro proved that any such group also admits a ( deterministic ) asynchronous automatic structure .",
    "for this reason , we work with determinstic asynchronous automatic structures throughout .    one particular type of asynchronous automaton , defined in @xcite , will be useful in our study of asynchronous automatic groups .",
    "an asynchronous automaton is _ bounded _ if there is an integer constant @xmath71 such that the automaton never reads more than @xmath71 letters in a row from any of its tapes .",
    "we say that an asynchronous automatic structure is _ bounded asynchronous _ if each of its multiplier automata are bounded .",
    "[ bounded ] let @xmath335 be a group with an asynchronous automatic structure given by an alphabet @xmath0 , a word acceptor @xmath23 , and multiplier automata @xmath343 for @xmath344 .",
    "then @xmath335 has a boundedly asynchronous automatic structure over @xmath0 , with a language that is a subset of @xmath22 .",
    "moreover , there is an effective procedure for constructing the boundedly asynchronous automatic structure from the original structure , and this procedure does not depend on @xmath335 .",
    "much work has been done on understanding which groups have an automatic structure . in parallel",
    ", the problem has been investigated in reverse : given a set of automata over an alphabet @xmath0 , how can one tell if they are the ( asynchronously ) automatic structure of some finitely presented group ?    in @xcite ,",
    "epstein , et .",
    "al answered this question in the case of synchronous automatic structures .",
    "in particular , they gave a set of @xmath352 axioms , each of which are statements about the automata @xmath23 , @xmath343 , such that the automata are the automatic structure of some group if and only if all @xmath352 axioms are satisfied .",
    "moreover , these axioms are decidable predicates ( that is , there is an algorithm that returns @xmath252 if the predicate is true and @xmath298 if the predicate is false ) , and they give an algorithm for finding a finite presentation of the group when it exists .",
    "we now provide a similar result in the case of asynchronous automata . in light of theorem",
    "[ bounded ] , we only consider the case in which the multiplier automata are bounded .    while every asynchronous automatic group is automatic ,",
    "the class of asynchronous automatic groups is strictly larger .",
    "in particular , for @xmath350 , the baumslag - solitar group @xmath351 is asynchronous automatic , but not automatic .    [ axioms ] let @xmath0 be a finite alphabet , let @xmath23 be a finite state automaton accepting the regular language @xmath353 , and let @xmath354 be a collection of two - tape boundedly asynchronous automata for each @xmath20 .",
    "then there is a group @xmath335 for which @xmath23 and @xmath354 form an asynchronous automatic structure for @xmath335 if and only if the following axioms hold :    1 .",
    "@xmath355 2 .",
    "for each @xmath356 , @xmath357 3 .",
    "@xmath358 4 .",
    "@xmath359 5 .",
    "@xmath360 6 .   for each @xmath33 , @xmath361 7 .   for each @xmath33 ,",
    "@xmath362 8 .",
    "for each @xmath33 , @xmath363 9 .   for each @xmath33 , @xmath364 10 .",
    "for each @xmath33 , @xmath365 11 . for each @xmath33 ,",
    "@xmath366 12 . for a word @xmath367 with each @xmath368 , we write @xmath369\\varphi_w=[u]$ ] to denote the statement @xmath370 then @xmath371\\varphi_w=[uw ] \\iff [ v]\\varphi_{w'}=[uw'])).\\ ] ] 13 .",
    "let @xmath56 be the maximum number of states in any of @xmath23 , @xmath348 , and @xmath343 , and let @xmath71 be the largest boundedness factor of any @xmath343 or @xmath348 .",
    "for each word @xmath62 over @xmath0 of length at most @xmath372 , @xmath373\\varphi_w=[u])\\implies(\\forall u)([u]\\varphi_w=[u]).\\ ] ]    if we are given a collection of ( possibly ) asynchronous automata , we can first apply the algorithm given by theorem [ bounded ] , check if the resulting automata are bounded ( by looking for loops entirely contained in the left or right state set ) and then apply theorem [ axioms ] . thus , if axioms @xmath252-@xmath352 are decidable for bounded asynchronous automata , then the problem of recovering a group from ( possibly unbounded ) asynchronous automata is decidable as well .",
    "it is easily verified that a bounded asynchronous automatic structure of a group must satisfy each of the axioms of theorem [ axioms ] . in order to prove the reverse direction , we first prove several lemmas .    throughout the remainder of this section ,",
    "let @xmath0 be a finite alphabet , @xmath353 and @xmath374 for each @xmath20 , where @xmath23 is a finite state automaton and each @xmath343 is a bounded asynchronous automaton over @xmath0 such that @xmath3 and @xmath375 satisfy axioms @xmath252-@xmath352 .    by axioms @xmath376-@xmath377 , we may partition @xmath3 into a set of equivalence classes @xmath96 under the equivalence relation @xmath378 if and only if @xmath379 .",
    "we write @xmath380 $ ] to denote the equivalence class of a word @xmath381 .    for each @xmath33",
    ", there exist unique invertible maps @xmath382 ( acting on the right ) such that for any @xmath383 , @xmath380\\varphi_x=[v]$ ] if and only if @xmath384 .",
    "fix @xmath33 . for each @xmath60",
    ", we can use axiom @xmath385 to choose a word @xmath386 such that @xmath384 , and define a map @xmath387 by @xmath388 . then by axiom @xmath389 ,",
    "the induced map @xmath390 by @xmath391 $ ] is independent of our original choices of @xmath61 . by axiom",
    "@xmath392 , if @xmath60 and @xmath62 are in the same equivalence class then @xmath393 maps them to the same equivalence class @xmath369 $ ] , and so @xmath393 restricts to a map @xmath382 having the desired property . finally , axiom @xmath389 shows that this map is unique .",
    "axioms @xmath394-@xmath395 similarly define maps @xmath396 for which @xmath369\\mu_x=[u]$ ] if and only if @xmath397 .",
    "then @xmath398 for each @xmath21 , and so we see that the maps @xmath399 are invertible , as desired .",
    "this lemma , combined with axiom @xmath400 , allows us to extend the notion of an equivalence class to the prefix closure of @xmath3 , which we denote by @xmath401 , as follows . for each prefix @xmath60 of a word @xmath402 in @xmath3 ,",
    "define @xmath380=[uw]\\varphi_{w}^{-1}$ ] .",
    "axiom @xmath400 shows that this is a well - defined equivalence class .",
    "if @xmath403 is a word over @xmath0 , we define @xmath404 where @xmath405 is defined to be @xmath406 .",
    "[ prefixaction ] we have @xmath407\\varphi_u=[u]$ ] for any prefix @xmath408 .    notice that if @xmath409 , then @xmath407\\varphi_{uw}=[uw]$ ] by the definition of the extension of @xmath410 to prefixes , and so @xmath407\\varphi_{u}=[uw]\\varphi_{w}^{-1}=[u]$ ] .",
    "finally , define @xmath411 to be the group generated by the maps @xmath399 under composition .",
    "then @xmath411 acts on @xmath96 on the right .",
    "we wish to show that this action is transitive and free , for we can then identify the elements of @xmath411 with the elements of @xmath96 .",
    "[ transitive ] the action of @xmath411 on @xmath96 is transitive",
    ".    given two equivalence classes @xmath380 $ ] and @xmath369 $ ] where @xmath383 , we note that @xmath412\\varphi_{u}^{-1}\\varphi_v=[\\epsilon]\\varphi_v=[v],\\ ] ] and so each equivalence class is mapped to every other under the group action .    to show that the action is free , we first prove the following lemma .    [ loops ] suppose @xmath33 and @xmath413 are words in @xmath3 such that @xmath407\\varphi_u\\varphi_x\\varphi_{u'}^{-1}=[\\epsilon]$ ] .",
    "then @xmath414 is the identity in @xmath411 .",
    "first note that the assumption implies @xmath380\\varphi_x=[u']$ ] , since @xmath415 , and so by the definition of the maps @xmath399 we have that @xmath416 is accepted by the asynchronous automaton @xmath343 . recall that this assigns a unique shuffle to @xmath416 as well .    for each @xmath417 , define @xmath418 to be the word formed by the first @xmath209 blocks of consecutive letters of @xmath60 in the shuffle of @xmath60 and @xmath419 .",
    "by our assumption , each block is of length at most @xmath71 .",
    "let the blocks of @xmath60 be @xmath420 and those of @xmath419 be @xmath421 ( where one of @xmath422 or @xmath423 may be the empty string , depending on the shuffle , and all other blocks are nonempty and of length at most @xmath71 ) . in this notation",
    ", we have @xmath424 for @xmath425 and @xmath426 for @xmath427 .",
    "note that for each @xmath209 , at some point in the path accepting @xmath416 in @xmath343 we have traversed a shuffle corresponding to @xmath428 . by removing possible loops from this path ,",
    "the shortest path from this point to the accept state is less than the number of states of @xmath343 , so it is at most @xmath429 where @xmath56 is the maximum number of states of any of the automata @xmath343 or @xmath348 . thus there",
    "exist words @xmath430 and @xmath431 of total length at most @xmath429 for which @xmath432 .",
    "consider the word @xmath433 this has length at most @xmath434 .",
    "we wish to show it fixes some element of @xmath96 , in order to apply axiom @xmath352 .",
    "we have @xmath435 \\varphi_{r_t } & = & [ u \\langle t \\rangle ] \\varphi_{w_t x w_{t}'^{-1 } b_{t+1 } ' w_{t+1 } ' x^{-1 } w_{t+1}^{-1 } b_{t+1}^{-1 } } \\\\                                     & = & [ u\\langle t\\rangle w_t ] \\varphi_{x}\\varphi_{w_{t}'^{-1}b_{t+1}'w_{t+1}'x^{-1}w_{t+1}^{-1}b_{t+1}^{-1 } } \\\\                     & = & [ u'\\langle t\\rangle w_{t } ' ] \\varphi_{w_{t}'^{-1}b_{t+1 } ' w_{t+1 } ' x^{-1}w_{t+1}^{-1}b_{t+1}^{-1 } } \\\\                     & = & [ u'\\langle t\\rangle ] \\varphi_{b_{t+1}'w_{t+1}'x^{-1}w_{t+1}^{-1}b_{t+1}^{-1 } } \\\\                     & = & [ u'\\langle t+1\\rangle ] \\varphi_{w_{t+1}'x^{-1}w_{t+1}^{-1}b_{t+1}^{-1 } } \\\\                     & = & [ u'\\langle t+1\\rangle w_{t+1 } ' ] \\varphi_{x^{-1}}\\varphi_{w_{t+1}^{-1}b_{t+1}^{-1 } } \\\\                     & = & [ u\\langle t+1\\rangle w_{t+1 } ] \\varphi_{w_{t+1}^{-1}b_{t+1}^{-1 } } \\\\                     & = & [ u\\langle t+1\\rangle ] \\varphi_{b_{t+1}^{-1 } } \\\\                     & = & [ u\\langle t\\rangle]\\end{aligned}\\ ] ] and so , by axiom @xmath352 , @xmath436 is the identity in @xmath411 .",
    "it follows that for each @xmath437 , we have @xmath438 and similarly @xmath439    multiplying these @xmath2 equations together , we find @xmath440 so @xmath441 , and thus @xmath442 is the identity , as desired .",
    "[ free ] the action of @xmath411 on @xmath96 is free .",
    "note that it suffices to show that , for all words @xmath61 , @xmath443\\varphi_v=[\\epsilon ] \\implies ( \\forall u)([u]\\varphi_v=[u]).\\ ] ]    for , if this holds , then if there is @xmath60 in the prefix closure of @xmath3 such that @xmath380\\varphi_w=[u]$ ] , then @xmath407\\varphi_{u}\\varphi_w\\varphi_{u}^{-1}=[\\epsilon]$ ] , so @xmath444 , and hence @xmath445 as well .",
    "let @xmath62 be an arbitrary word that fixes the basepoint @xmath407 $ ] , that is , @xmath407\\varphi_w=[\\epsilon]$ ] .",
    "( note that such a word @xmath62 must exist by lemma [ transitive ] . )",
    "write @xmath62 in a reduced form @xmath446 where each @xmath447 , and there are no pairs of consecutive letters of the form @xmath448 or @xmath449 .    by our definition of the equivalence classes on the prefix closure of @xmath3 , each equivalence class can be represented by an element of @xmath3 itself , so for each @xmath450 , there is some word @xmath451 such that @xmath452=[\\epsilon]\\varphi_{x_1\\cdots x_t}=[\\epsilon]\\varphi_{w_t}=[w(t)].\\ ] ] also set @xmath453 .",
    "then @xmath454\\varphi_{u_t}\\varphi_{x_{t+1}}\\varphi_{u_{t+1}}^{-1 } & = & [ u_t]\\varphi_{x_{t+1}}\\varphi_{u_{t+1}}^{-1 } \\\\         & = & [ w(t)]\\varphi_{x_{t+1}}\\varphi_{u_{t+1}}^{-1 } \\\\         & = & [ w(t+1)]\\varphi_{u_{t+1}}^{-1 } \\\\         & = & [ u_{t+1}]\\varphi_{u_{t+1}}^{-1 } \\\\         & = & [ \\epsilon].\\end{aligned}\\ ] ]    by lemma [ loops ] , we have that @xmath455 is the identity in @xmath411 .",
    "multiplying these together over @xmath456 yields @xmath457 which simplifies to @xmath458 thus @xmath459 , as desired .",
    "we now prove theorem [ axioms ] .",
    "let @xmath460 be the group having the transitive and free action on @xmath96 described in lemma [ free ] .",
    "since the action is transitive and free , we may identify the elements of @xmath335 bijectively with the elements of @xmath96 , as follows .",
    "identify the identity element of @xmath335 with @xmath407 $ ] , and for each @xmath461 , identify @xmath462 with @xmath407g$ ] .",
    "then transitivity gives that this identification is surjective , and freedom gives that this identification is injective , and thus it is a well defined bijection .",
    "it follows that the action of @xmath335 on @xmath96 is isomorphic to the action of @xmath335 on itself by right multiplication .",
    "therefore , @xmath343 accepts precisely the pairs of words representing elements of @xmath335 that differ by the generator @xmath21 in the cayley graph for each @xmath21 , and @xmath348 accepts the pairs of words in @xmath3 representing the same element of @xmath335 .",
    "it follows that @xmath3 , @xmath343 form an asynchronous automatic structure for @xmath335 , as desired .      in this section ,",
    "we assume basic familiarity with the concept of decidable predicates . for a thorough introduction to this topic ,",
    "see @xcite .    in @xcite ,",
    "epstein , et .",
    "al gave a set of axioms , each of which are first - order sentences involving regular predicates , that allow one to recover a group from a set of synchronous automata if all the axioms are decidably true , or determine that there is no such group if one of the axioms is decidably false . in theorem",
    "[ axioms ] , we have given a similar set of axioms for recovering a group from a set of asynchronous automata , each of which are first - order sentences involving quasi - regular predicates .",
    "since regular predicates are closed under first order operations , the axioms for synchronous automata are regular and therefore decidable , but it is less clear whether the axioms of theorem [ axioms ] are quasi - regular , or even decidable . in this section , we investigate the decidability of axioms @xmath252-@xmath352 .    adopting the terminology in @xcite , we say that a statement is _ partially decidable _ if there is an algorithm that halts and outputs true if the statement is true , and does not halt if the statement is false .",
    "[ partiallydecidable ] let @xmath463 denote the statement :  the finite state automaton @xmath23 over the alphabet @xmath0 and asynchronous automata @xmath343 over @xmath0 , one for each @xmath20 , do not form the asynchronous automatic structure of any finitely presented group . \"",
    "then @xmath225 is partially decidable .",
    "we first show that axioms @xmath252 , @xmath464 , @xmath385 , and @xmath394 are decidable .",
    "[ 1269 ] let @xmath23 be a finite state automaton over @xmath0 , and let @xmath343 for each @xmath465 be asynchronous automata over @xmath0",
    ". then axioms @xmath252 , @xmath464 , @xmath385 , and @xmath394 are decidable predicates .",
    "note that axiom @xmath252 is a regular predicate and is therefore decidable .    for axiom @xmath464 , we can simplify the statement as follows :    @xmath466    @xmath467 $ ]    @xmath468 $ ]    @xmath469 $ ]    @xmath470 \\vee \\left [ ( \\exists w_2)((\\exists w_1)((w_1,w_2)\\in l_x)\\wedge ( w_2\\not\\in l ) ) \\right]\\right\\}$ ]    in the last formulation of the statement above , the smaller statements @xmath471 and @xmath472 define regular languages in the variables @xmath473 and @xmath474 respectively , by part ( f ) of proposition [ quasiclosure ] .",
    "the statements @xmath475 and @xmath476 are regular as well , since regular predicates are closed under negation .",
    "thus we have rewritten the original statement as a first - order statement involving regular predicates , which is regular and hence decidable .",
    "axioms @xmath385 and @xmath394 can similarly be stated in terms of regular predicates .",
    "this completes the proof .    we now prove theorem [ partiallydecidable ] .    by lemma [ 1269 ] ,",
    "the negations of axioms @xmath252 , @xmath464 , @xmath385 , and @xmath394 are decidable , and hence partially decidable .",
    "we now show that the negation of axiom @xmath376 , that is , @xmath477 is partially decidable .",
    "indeed , we can order the words in @xmath38 in length - lexicographic order ( with respect to some ordering of @xmath0 ) , and check in order if each satisfies @xmath478 by passing @xmath62 and @xmath479 through the automata @xmath23 and @xmath348 , respectively . when we reach a word @xmath62 that satisfies the two conditions , we stop , and otherwise we check the next word in the length - lexicographic ordering .",
    "this procedure halts if the statement is true , and runs indefinitely if it is false , as desired .",
    "this argument can be easily modified to show that axioms @xmath480 , @xmath377 , @xmath389 , @xmath392 , @xmath481 , and @xmath395 are partially decidable .",
    "we next show that the statement `` either axiom @xmath394 is false or axiom @xmath400 is false '' is partially decidable .",
    "consider the natural product ordering of @xmath482 that arises from the length - lexicographic ordering of @xmath38 .",
    "we apply the following procedure to the @xmath480-tuples @xmath483 in @xmath482 in order .",
    "we use @xmath23 to check if @xmath402 and @xmath484 are in @xmath3 .",
    "if not , we go on to the next @xmath480-tuple .",
    "if @xmath402 and @xmath484 are both in @xmath3 , then we check the validity of each of the statements @xmath369\\varphi_w=[uw]$ ] and @xmath369\\varphi_{w'}=[uw']$ ] .",
    "let @xmath485 be the letters of @xmath62 .",
    "we first check if there is some @xmath486 for which @xmath487 .",
    "( we can check this since the projection of a two - variable quasi - regular language is regular . ) if there is no such @xmath486 , we stop ; this proves the negation of axiom @xmath394 . if there is such a @xmath486 , we can choose one by searching through all finite paths starting at the start state in order of length until we come across the first shuffle that spells @xmath61 in the left state set .",
    "we now apply the same procedure to either choose some @xmath488 such that @xmath489 , or halt if no such @xmath488 exists .",
    "continuing in this fashion , if we have chosen a word @xmath490 , we determine whether there is some @xmath491 with @xmath492 for @xmath493 .",
    "if at the @xmath2th step we obtain a word @xmath494 , we check if @xmath495 .",
    "if so , the statement @xmath369\\varphi_w=[uw]$ ] is true , and if not , it is false .",
    "we similarly check the validity of @xmath369\\varphi_{w'}=[uw']$ ] .",
    "if both are true or both are false , we go on to the next @xmath480-tuple . otherwise , we halt , as this proves the negation of axiom @xmath400 .",
    "thus , the statement `` either axiom @xmath394 is false or axiom @xmath400 is false '' is partially decidable .",
    "we next show that `` either axiom @xmath394 is false or axiom @xmath352 is false '' is partially decidable .",
    "for each fixed @xmath62 with length at most @xmath372 , we check all @xmath60 in the prefix closure of @xmath3 to determine if @xmath380\\varphi_w=[u]$ ] , with a procedure that halts if axiom @xmath394 is false , as before .",
    "if we find two strings @xmath496 such that the @xmath380\\varphi_w=[u]$ ] but @xmath369\\varphi_w\\neq[v]$ ] , we halt ; axiom @xmath352 is false .",
    "otherwise , our procedure runs indefinitely .",
    "finally , by theorem [ axioms ] , the statement @xmath463 is equivalent to the statement :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ `` axiom 1 is false or axiom 2 is false or ... or axiom 13 is false , '' _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    which can be rewritten as    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ `` axiom 1 is false or axiom 2 is false or ... or ( axiom 9 is false or axiom 12 is false ) or ( axiom 9 is false or axiom 13 is false ) . ''",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    the latter is partially decidable , as we can run each of our above procedures in parallel .",
    "it remains to be shown whether all of the axioms of theorem [ axioms ] are decidable .",
    "to do so , it would be useful to further understand the closure properties of quasi - regular and weakly regular predicates , as either can be used to define asynchronous automatic groups .",
    "( see @xcite )    we have shown that quasi - regular languages are closed under complementation but not under union , and weakly regular languages are closed under union but not under complementation .",
    "thus , it may also be of interest to investigate intermediate classes of languages in order to find one that is closed under both complementation and union . for instance",
    ", the class of all finite unions of quasi - regular languages is larger than the class of quasi - regular languages and smaller than that of weakly regular languages , and it is closed under union ( however , it is not closed under complementation ) .    finally , we note that rubin @xcite defined a generalized notion of quantifiers , and classified the unary quantifiers that preserve regularity",
    ". it would be of interest to study which generalized quantifiers preserve quasi - regular and weakly regular predicates .",
    "this research was done at mit through the undergraduate research opportunities program .",
    "i thank my supervisor , mia minnes , for her teaching and guidance throughout the course of this research .",
    "i also thank the colorado state university mathematics colloquium for the opportunity to give a talk on this research .",
    "finally , i thank ken g.  monks , ken m.  monks , paul christiano , and rishi gupta for numerous helpful conversations and for their support along the way .",
    "99 d.b.a .",
    "epstein , j.w .",
    "cannon , d.f .",
    "holt , f.v.f .",
    "levi , m.s .",
    "paterson , w.p .",
    "thurston , _ word processing in groups _ ,",
    "jones and bartlett publishers , boston , 1992 .",
    "n.  cutland , _ computability , an introduction to recursive function theory _ , cambridge university press , 1980 .",
    "b.  khoussainov and a.  nerode , automatic presentations of structures , _ lecture notes in computer science _ * 960 * ( 1995 ) , 367 - 392 . m.  rabin and d.  scott , finite automata and their decision problems , _ ibm journal of research and development _ * 3 * ( 1959 ) , 114 - 125 .",
    "s.  rubin , automata presenting structures : a survey of the finite string case , _ bulletin of symbolic logic _ ,",
    "14 , issue 2 ( 2008 ) , 169 - 209 .",
    "m.  shapiro , deterministic and non - deterministic asynchronous automatic structures , _ international journal of algebra and computation _ vol .",
    "2 , no . 3 ( 1992 ) ,",
    "297 - 305 ."
  ],
  "abstract_text": [
    "<S> let @xmath0 be a finite alphabet and let @xmath1 be an @xmath2-variable language over @xmath0 . </S>",
    "<S> we say that @xmath3 is _ regular _ if it is the language accepted by a synchronous @xmath2-tape finite state automaton , it is _ quasi - regular _ if it is accepted by an asynchronous @xmath2-tape automaton , and it is _ weakly regular _ if it is accepted by a non - deterministic asynchronous @xmath2-tape automaton . </S>",
    "<S> we investigate the closure properties of the classes of regular , quasi - regular , and weakly regular languages under first - order logic , and apply these observations to an open decidability problem in automatic group theory . </S>"
  ]
}