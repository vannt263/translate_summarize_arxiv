{
  "article_text": [
    "data within an event often relate to one another , e.g. , tracks are often matched to showers in the electro - magnetic calorimeter .",
    "a simple object - oriented design for objects in an event has these data items containing pointers to one another .",
    "unfortunately , this causes serious dependency problems : large compilation times , extremely long link times , and broken code affects more systems . using an object - relational model avoids these problems and allows new possibilities .",
    "a simple object - oriented design for data in an event is shown in figure  [ oo ] .",
    "this design has related data grouped into classes , e.g. , track and em shower classes .",
    "the data values are stored in objects of the appropriate class .",
    "for example , data describing one track is stored in one object of class type track .",
    "finally , links between objects are implemented by embedding pointers into the objects .",
    "for example , em shower objects hold pointers to any track which is believed to be matched with that particular shower .",
    "the appeal of this design is that it is easy for users to navigate the relationships between objects .",
    "unfortunately , the simple object - oriented approach leads to many problems .",
    "the first problem arises in the software s interfaces . adding new relationships between objects means changing the classes involved .",
    "this change forces a recompilation of all code that uses those classes .",
    "in addition , published objects ( objects that are made available to other parts of the code by placing the objects into the event ) must be mutable .",
    "this is because we need to be able to change an object in order to set its relationship to another object .",
    "this design also raises the question of how to handle links in the case where multiple algorithms produce the same data .",
    "for example , tracks from different track - finders could be matched to the same em showers .",
    "another question is where to put the data that describes the relationship . in the `` track - shower ''",
    "matching example , where does the distance between the track and the shower live ?",
    "a final question is , how do two people refer to the same object if each has made a sub - selection of a list ?",
    "this often arises when people are comparing results from two different analyses that are looking for the same decay mode .",
    "another set of problems arise for compilation and linking of code . in highly coupled systems , if one piece of code breaks , the whole system can break .",
    "e.g. , if tracking is broken a user may not be able to do em shower work .",
    "there are standard ways to decrease dependencies in c or c++  @xcite but the techniques may not be known by all developers . to avoid excess compilation dependencies in c or c++ , you must forward declare data in the header files rather than including the data object header files . to avoid excess linking dependencies",
    ", associated objects can not internally access member functions of each other .",
    "e.g. , we can not have a function that calculates the energy of an em shower divided by momentum of the track .",
    "it is possible to relax this requirement if you organize your code so that the associated routines are in a separate object file .",
    "this works since many linkers force resolution of all symbols found in an object file .",
    "a further complication is that reference counting smart pointers cause strong compile and link - time dependencies which is unfortunate since they make memory management easier .",
    "the last set of problems we will discuss occur in object storage .",
    "direct references in objects complicate storage .",
    "this arises since the storage system needs to convert pointers to and from persistent values .",
    "if objects use bidirectional links , it is necessary to construct both objects before linking them . to simplify the storage system",
    ", developers often couple their objects directly to the storage system .",
    "unfortunately , this coupling locks the developer into using only one storage mechanism even if that mechanism is not appropriate for all the experiment s data .",
    "reading and writing objects causes compile , link and runtime dependencies between classes .",
    "this is true even if objects only hold pointers to other types of objects .",
    "it is possible to avoid some of these dependencies if the developer is willing to read back unlinked objects .",
    "unfortunately , use of such unlinked objects forces physicists who use the system to tell the system when the links should be made .",
    "so the user is burdened with the responsibility to be sure the link is made before she tries to use the link .",
    "the problems mentioned in the previous section led us to try an object - relational approach . in this approach ,",
    "no objects have pointers to objects outside atomic storage boundaries .",
    "e.g. , mc particles can hold pointers to their children if they are stored as a unit .",
    "a second requirement of this approach is that all objects in lists must have a unique identifier .",
    "physicists can use the identifier when talking with other physicists about the objects . in our system",
    ", we use our own templated table class to hold lists of objects which sort the objects via their identifier method .",
    "also in our system , lists are identified via unique keys based on the type of the objects in the list plus two character strings .",
    "therefore objects can be uniquely identified by what list it is in and by what identifier it has within the list .",
    "the final requirement of the object - relational approach is to define relationships via separate objects , which we call lattices  @xcite .",
    "a lattice is an object which links relationship data ( e.g. , the distance between a track and an em shower ) to the identifiers of two different objects ( denoted by left and right ) .",
    "the lattice supports all 16 possible configurations for links .",
    "a configuration is defined by four separate sub - configurations where each sub - configuration has two choices .",
    "the four sub - configurations are :    * 1 or many lefts per link * 1 or many rights per link * 1 or many links per left * 1 or many links per right        figure  [ or ] shows an example of the object - relational approach .",
    "the figure shows the hit , track and em shower objects with each object having a unique identifier within its respective list . between the hit and track lists",
    "is the hit - to - track lattice . within the lattice",
    "you can see the separate objects holding the different link information .",
    "for example , the first link in the hit - to - track lattice says that hit 1 ( denoted by the left hand number ) is connected with track 1 ( denoted by the right hand number ) .",
    "similarly , the track to em shower lattice is shown between the track and em shower lists .",
    "the object - relational approach has many advantages .",
    "first , it shortens link times . in our experience , linking usually takes less than 30 seconds on a moderately powerful machine .",
    "however , we use dynamic loading so we only have to link to the libraries a module directly needs and this reduction in the number of libraries needed for linking also contributes to our short link times and allows compilation on very moderate machines .",
    "second , this approach simplifies the code used for storage . because the system is not coupled to one storage mechanism , it is easy to support many specialized storage formats .",
    "third , this approach speeds up data read - back since we only retrieve data a user actually uses .",
    "e.g. , we can ask if a track is matched to an em shower without needing to construct the em showers .",
    "fourth , it is possible to use multiple data sources ( each with their own format ) on read - back .",
    "e.g. , our system can build an event by combining a physicist s data skim with the experiment s event database .",
    "one disadvantage of this approach is it makes navigating the relationships between objects more complex .",
    "to offset this disadvantage , we have created navigation objects that give direct access to related objects .",
    "these objects internally look up the relationship information in the appropriate lattice and then use the regular data access mechanism to retrieve the appropriate related objects .",
    "effectively , the navigation objects do what users would have to do in order to obtain related objects . to avoid interdependencies in critical software ,",
    "only analysis code is allowed to use navigation objects . additionally , we have taken special care so that only by accessing an object via navigation does the users code become compile / link - time dependent on that object",
    ". e.g. , if a user does not use em showers then you do not need to link to them , even though the navigation tracks could access them .",
    "finally , to make code maintenance easier , we only allow the one library that holds the navigation objects to have interdependencies between objects .",
    "it also means that only the developer in charge of the navigation library has to be an expert on how to minimize interdependencies in c++ code .",
    "the general wisdom when writing code is that compile / link / run - time dependencies make code less robust .",
    "we have found it possible to avoid unnecessary dependencies by encapsulating relationships between objects into a separate object .",
    "however , providing direct link objects only to analysis users works well .",
    "their code usually accesses most high level data objects , and analysis code has the shortest usage lifetime so long - term maintenance issues are less important . by following the object - relational approach ,",
    "we have seen our user s productivity and satisfaction increase because they have gained shorter compile and run times .",
    "9 j. lakos , _ large scale c++ software design _ , addison - wesley , 1996 .",
    "j. thayer , event bookkeeping for cleo3 , _ proceedings of advanced computing and analysis techniques in physics research : vii international workshop _",
    ", 2001 , 149 - 151 ."
  ],
  "abstract_text": [
    "<S> with the use of object - oriented languages for hep , many experiments have designed their data objects to contain direct references to other objects in the event ( e.g. , tracks and electromagnetic showers have references to each other to denote matches ) . </S>",
    "<S> unfortunately this creates tremendous dependencies between packages which lead to brittle development systems ( e.g. , if the electromagnetic code has a problem you may not be able to compile the tracking code ) and makes the storage system more complex .    </S>",
    "<S> we discuss how the cleo iii experiment avoided these problems by treating an event as an object - relational database . </S>",
    "<S> the discussion will include : the constraints we placed on our objects ; our use of a separate association class to deal with inter - object references ; and our ability to use multiple sources to supply different data items for one event . </S>"
  ]
}