{
  "article_text": [
    "we order the two elements of a set @xmath0 such that @xmath1 .",
    "this extends to a partial ordering on the set @xmath2 by comparing words coordinate - wise .",
    "let @xmath3 and @xmath4 . here",
    ", @xmath5 means that @xmath6 , for every @xmath7 .",
    "a boolean function @xmath8 is _ monotone _ when @xmath9 if @xmath5 , for every @xmath10 .",
    "monotone boolean functions have an important role for proving lower bounds of circuit complexity ( see , _ e.g. _ , leeuwen @xcite , chapter 14.4 ) .",
    "any function obtained by composition of monotone boolean functions is itself monotone .",
    "examples of monotone boolean functions are the conjuction and and the disjunction or . indeed , every monotone boolean function can be realized by and and or operations ( but without not ) .",
    "boolean functions are important in applications , for example , in the implementation of a class of non - linear digital filters called stack filters @xcite .",
    "important methods for obtaining non - trivial bounds on specific monotone boolean functions have been studied ( see , _",
    "e.g. _ , @xcite ) .",
    "the concept of _ zero forcing _ on graphs is a recent idea that is part of a program studying minimum ranks of matrices with specific combinatorial constraints .",
    "zero forcing has been also called graph infection and graph propagation @xcite .",
    "notice that , in the context described here , the term zero forcing  seems to be unfortunate , because we are forcing ones , not zeros .",
    "however , we keep the term given that this is now the most commonly used in the literature . in order to define zero forcing , we first need to define a _ color - change rule _ : if @xmath11 is a graph with each vertex colored either white or black , @xmath12 is a black vertex of @xmath13 , and exactly one neighbor @xmath14 of @xmath12 is white , then change the color of @xmath14 to black . given a coloring of @xmath13 , the _ final coloring _",
    "is the result of applying the color - change rule until no more changes are possible .",
    "zero forcing set _ for @xmath13 is a set @xmath15 such that if the elements of @xmath16 are initially colored black and the elements of @xmath17 are colored white , the final coloring of @xmath13 is all black .",
    "zero forcing is related to certain minimum rank / maximum nullity problems of matrices associated to graphs ( see @xcite ) and to the controllability of quantum spin systems @xcite .",
    "minimimizing the size of zero forcing sets is a difficult combinatorial optimization problem @xcite .",
    "the remainder of this paper is organized as follows . in section 2",
    ", we prove that zero forcing on graphs realizes all monotone boolean functions , and highlight some simple related facts .",
    "the connection between zero forcing and circuits is obtained by associating a graph to each logic gate .",
    "we will show that the functions and and or are indeed easily realized by two different gadgets with a few vertices .",
    "this is not the first work observing that monotone boolean functions can be realized in a combinatorial setting .",
    "for example , demaine _ et al .",
    "_ @xcite have used the movements of a collections of simple interlocked polygons .    in section 3",
    ", we describe the phenomenon of _ back forcing _ in the circuit .",
    "the phenomenon occurs when the color - change rule acts to modify the color of a vertex which has been already used during the computation . in some cases ,",
    "back forcing implies that information about the output of a boolean circuit can be read not just by looking at the color of a _",
    "target _ vertex corresponding to the final output of the process , but at the color of the vertices in certain intermediate or initial gadgets .",
    "the idea opens a simple but intriguing scenario consisting of many parties that perform computation in a distributed way : each party holds a subset of the gates and it is able to read certain information about the input of other parties , since the color of its gates may have been modified by back forcing .",
    "back forcing can be avoided by including some extra gadget acting as a filter .    in section 4 ,",
    "we show that zero forcing becomes _ universal _ , _ i.e. _ , it can realize any boolean function , if we apply a proper encoding .",
    "specifically the _ dual rail encoding _ , where two vertices are assigned to each logical bit , is a method to construct the not gate and therefore to obtain universal computation .",
    "conclusions are in section  5 .",
    "our main result is easy to prove :    zero forcing realizes all monotone boolean functions .    it is sufficient to show that zero forcing realizes the functions and and or .",
    "_ claim 1 . _ the gate and is realized by the gadget @xmath18 with vertices @xmath19 and edges @xmath20 , where @xmath21 and @xmath22 are the input vertices and @xmath23 is the output vertex , containing the result and being able to propagate the color .",
    "all vertices are initially colored white .",
    "an illustration of the gadget @xmath18 is below :    [ h ]    and.eps    _ proof of claim 1 . _",
    "if no action is taken then the final coloring of the gadget is white .",
    "if we color vertex @xmath21 black then the final coloring is all white but for vertex @xmath21 .",
    "the same holds for vertex @xmath22 .",
    "however , if we color vertex @xmath21 and vertex @xmath22 black then the color - change rule implies that vertex @xmath23 is black at step @xmath22 . in fact",
    ", @xmath24 is a zero forcing set for @xmath18 .",
    "_ claim 2 . _ the gate or is realized by the gadget @xmath25 with vertices @xmath26 and edges @xmath27 , where @xmath21 and @xmath22 are the input vertices .",
    "the output vertex is vertex @xmath28 .",
    "vertex @xmath23 is initially colored black :    [ h ]    or0.eps    _ proof of claim 2 . _",
    "if no action is taken then the final coloring of the gadget is all white , but for vertex @xmath23 .",
    "if we color vertex @xmath21 black then the color - change rule implies that vertex @xmath28 is black at step @xmath22 .",
    "the same holds for vertex @xmath22 and for vertex @xmath21 and vertex @xmath22 together .",
    "in fact , @xmath29 are zero forcing sets for @xmath25 , able to propagate the color for inducing the next step of the computation .",
    "it is important to observe that zero forcing does not realize the function not , since when a vertex is colored black , it can not change color anymore .",
    "the consequence is that zero forcing does not realize universal computation ( any boolean function can be implemented using and , or and not gates ) but monotone boolean functions only .",
    "this concludes the proof .    it may be worth observing the following points :    * notice that extra vertices forming _ delay lines _ may be needed to assemble a circuit such that the output produced by zero forcing in parallel gates is syncronous",
    "however , given our choice of gadgets , exactly @xmath22 time steps are required for output of zero forcing in @xmath30 and @xmath25 . at time step @xmath23 the color - change rule acts on the next gate in the circuit .",
    "there is then a convenient distinction between internal and external time :  _ internal time",
    "_ refers to the zero forcing steps inside the gadgets / gates ; _ external time",
    "_ refers to the time steps of the computation .",
    "* the gadgets @xmath18 and @xmath25 have three and four vertices , respectively . by inspection on all possible combinations of white and black vertices for graphs with at most four vertices , we can observe that we have chosen the smallest possible gadgets , in terms of number of vertices and edges , realizing the two functions .",
    "one might think that the gate or is realized also by the gagdet with three vertices in the figure : + [ h ] + or3vertices.eps + although the gadget implements the or correctly , it can not be used as an initial or intermediate gate of a circuit , since in this gadget the color - change rule does not move fowards the output to the next gate , but it halts at vertex @xmath23 : + [ h ] + or3verticesstop.eps * let us consider the gadget @xmath25 .",
    "if we color vertex @xmath21 black then the color - change rule implies that vertex @xmath28 is black at step @xmath22 .",
    "suppose that vertex @xmath22 is colored white at step @xmath21 . at step @xmath22",
    "the gate has computed the or function in vertex @xmath28 with input @xmath31 . at step @xmath22 vertex @xmath22",
    "is also colored black under the action of the color - change rule , because this is the unique white neighbour of vertex @xmath23 .",
    "this is necessary in order for the computation to proceed using the output ( black vertex @xmath28 ) .",
    "so , for all inputs with output @xmath21 , the vertices of @xmath25 are black after two steps of the internal time .",
    "such behaviour is discussed in more detail in the next section .",
    "* it is straightforward to realize the operation copy : + [ h ] + copy.eps",
    "if each boolean variable in the input of a circuit is set to @xmath21 , then the vertices of the circuit that are initially colored black form a zero forcing set .",
    "however , this is not the only situation in which we have a zero forcing set .",
    "the next figure gives an example :    [ h ]    back1.eps    this is a circuit computing the boolean function @xmath32 and @xmath33 or @xmath34 and @xmath35 .",
    "the number in the vertices of the figure specify the internal time step at which the vertex is black ; the vertices labeled by @xmath21 are initially colored black .",
    "the output of the circuit is @xmath21 at step @xmath28 and at step @xmath36 of the internal time the vertices encoding the input of the function are all colored black .",
    "this can happen if and only if three of the input vertices are colored white at internal time @xmath21 .",
    "the phenomenon will be called _ back forcing _ , because it is induced by the color - change rule acting backwards with respect to the direction from input to output in the whole circuit . the gadget @xmath30 exhibits back forcing conditionally on having input @xmath31 .",
    "the type of back forcing in @xmath18 can be called _ transmittal back forcing _ , because if something back forces its output black then the gate transmits the back force , _",
    "i.e. _ , it modifies the color of the output vertex in a gate used previously .",
    "the figure clarifies the dynamics :    [ h ]    backand.eps    the gadget @xmath25 needs to force an input forward in order to color black one of the output vertices adjacent to its inputs and in another gate . in this sense",
    ", @xmath25 does not have transmittal back forcing .",
    "in other words , a gate at external time @xmath37 , can not back force its color into @xmath25 at external time @xmath38 .",
    "in contrast , the circuit @xmath32 and @xmath33 or @xmath34 and @xmath35 can initiate back forcing as described above ( when it an intermediate element in the circuit ) .",
    "we can also slow down back forcing , by including appropriate _ delay lines _  for example , by adding extra vertices in each gadget or between them .",
    "alternatively , we could consider delay lines directly embedded in the structure of the gadgets implementing the logical gates .",
    "also , back forcing can be avoided completely by including the gadget below .",
    "the gadget acts as a _",
    "filter_. in some sense , the filter can be understood as an _ electronic diode _ allowing zero forcing only in one direction :    [ h ]    filter.eps    in relation to the circuit for the function @xmath32 and @xmath33 or @xmath34 and @xmath35 , it may be interesting to see that if there are two parties each one chosing the input of one of the two and gates , and each one having access to only the corrisponding vertices , given the back forcing , the parties can then learn the output of the circuit by looking at the color of their vertices at the end of the computation , except when a party chooses @xmath39 ( _ i.e. _ , white , white ) .",
    "despite the fact that the color - change rule induces a non - reversible process ( black coloring can not be undone ) a simple modification of the encoding strategy allows us to implement universal , and hence also reversible , computation .",
    "the idea is to adopt a _ dual rail _ strategy , where two vertices are employed to encode a single _",
    "logical bit_. specifically , as shown in fig .",
    "[ figudual ] , in this scheme we associate the logical bit 0 to a configuration in which ( say ) the first vertex is colored in black while the second is kept white , and the logical 1 to the opposite configuration ( i.e. the first vertex being left white and the second one being colored black ) . with such encoding",
    "we can now design the gate not by simply drawing a graph in which the nodes are exchanged at the output ( see fig .",
    "[ figunot ] ) .",
    "also a dual rail and gate can be easily realized .",
    "universal computation is hence achieved by constructing a nand gate via concatenation of and with not and by observing that the copy gate for the dual rail encoding is simply obtained by just applying to both the nodes that form a bit the transformation of fig .",
    "[ figucopy ] .",
    "once universal computation has been achieved , we can easily turn it into a reversible one , _",
    "e.g. _ , by building a toffoli gate  @xcite .",
    "this to remark that even if zero forcing is an irreversible process , it can still be used to induce a reversible computational dynamics .",
    "[ h ]    zeroonedual.eps    [ h ]    not.eps",
    "we have shown that all monotone boolean functions can be realized by zero forcing in a graph constructed by _ gluing _ together the copies of two types of subgraphs / gadgets corresponding to the boolean gates and and or .",
    "we have briefly discussed the minimality of such gadgets in terms of vertices and edges .",
    "we have highlighted a back forcing action .",
    "back forcing has an effect on the coloring of gates already used , as a function of what has happened in the future , _",
    "i.e. _ , at a later stage of the computation .",
    "because of the relation between zero forcing and minimum ranks , the model described here is amenable to be studied with linear algebraic tools , potentially suggesting a novel direction in the analysis of monotone boolean functions .",
    "an open problem suggested by the paper is to understand the link between zero forcing and the dynamics at the basis of other unconventional models of computation , like , for example , the billiard ball computer  introduced as a model of reversible computing @xcite  , models involving geometric objects , and dominos @xcite .",
    "this work has been done while db was with the blackett laboratory at imperial college london , supported by epsrc grant ep / f043678/1 .",
    "vg acknowledges support by the firb - ideas project ( rbid08b3fm ) .",
    "ss is a newton international fellow .",
    "american institute of mathematics ( aim ) minimum rank - special graphs work group , aim minimum rank  special graphs work group ( f. barioli , w. barrett , s. butler , s. m. cioab , d. cvetkovi , s. m. fallat , c. godsil , w. haemers , l. hogben , r. mikkelson , s. narayan , o. pryporova , i. sciriha , w. so , d. stevanovi , h. van der holst , k. vander meulen , a. wangsness ) , zero forcing sets and the minimum rank of graphs , _ linear algebra and its application _ * 428 * ( 2008 ) , 1628 - 1648 .",
    "p. vitanyi , time , space , and energy in reversible computing , _ proc .",
    "2005 acm international conference on computing frontiers _ ,",
    "ischia , italy , 4 - 6 may 2005 , 1st international workshop on reversible computing ."
  ],
  "abstract_text": [
    "<S> we design logic circuits based on the notion of zero forcing on graphs ; each gate of the circuits is a gadget in which zero forcing is performed . </S>",
    "<S> we show that such circuits can evaluate every monotone boolean function . by using two vertices to encode each logical bit </S>",
    "<S> , we obtain universal computation . </S>",
    "<S> we also highlight a phenomenon of back forcing  as a property of each function . </S>",
    "<S> such a phenomenon occurs in a circuit when the input of gates which have been already used at a given time step is further modified by a computation actually performed at a later stage . </S>",
    "<S> finally , we show that zero forcing can be also used to implement reversible computation . </S>",
    "<S> the model introduced here provides a potentially new tool in the analysis of boolean functions , with particular attention to monotonicity . </S>"
  ]
}