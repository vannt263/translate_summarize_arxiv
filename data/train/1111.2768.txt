{
  "article_text": [
    "the _ model - checking _ is a widely used technique to verify correctness of hardware and software systems .",
    "a model checker explores the state space of a model of a given system to determine whether a given specification is satisfied .",
    "usually such specifications are expressed by means of formulas in a temporal logic , such as the computational temporal logics ctl , @xcite .",
    "a very useful feature to fix the possible errors in the model is that when the model checker detects that the specification is violated then it returns a counterexample . in the last years",
    "this feature has also been exploited in the simulation framework .",
    "in fact , it is nowadays a well - established fact that formal ( both software and hardware ) analysis is a valid complementary technique to simulation and testing ( see e.g.,@xcite ) .",
    "on one side , the model checking approach , @xcite , allows a full verification of system components to be free of errors , but its use is limited to small and medium sized models , due to the so - called state explosion problem . on the other hand the testing and simulation approaches @xcite are usually applied to larger systems : they check the presence of errors in the system behavior through the observation of a chosen set of controlled executions .",
    "shortly , the efficacy of testing relies on the creation of test benches and that of model - checking on the ability of formally defining the properties to be verified , through temporal logic formulas .",
    "more explicitly , the complementarity of the two techniques lies in the fact that the counterexamples generated by a model - checker can be interpreted as test cases .",
    "a good choice of the test suite is the key for successful deductions of faults in simulation processes .",
    "it is now more than a decade that model - checking is used for this purpose , see @xcite . in this context",
    ", a high level abstraction of the system under test ( sut ) , is necessary . such abstraction should be simple and easy to model check , but precise enough to serve as a basis for the generation of test cases . this approach can be usefully adopted also in the devs modeling and simulation framework , @xcite .",
    "however not surprisingly , the most challenging problem is the performance and two issues are crucial : the choice of an efficient tool to generate the test suite and the choice of a suitable abstract model to check .",
    "for the first issue , we propose the use of graded temporal logic specifications .",
    "in fact standard model - checking tools generate only one counterexample for each run and the check stage ( of the model against a specification ) is often expensive , in terms of time resources .",
    "we claim that it is highly desirable to get more meaningful counterexamples with a unique run of the model checker . for the second issue",
    "we propose the use of hsm as an abstract model of a devs modeling the sut , which preserves the hierarchical structure while abstracting the continuous variables .",
    "thus we focus on how to generate simulation scenarios for devs by providing a tool which automatically generates multiple counter - examples in an unique run , using hierarchical state machines as abstract model .",
    "the sequence of events of each counterexample will then be used to create a timed test trace for devs simulation . in figure",
    "[ esempioastrazione ] a small example of our idea is shown ( the states labeled _ try1 _ and _ try2 _ are states on a higher hierarchy level standing for the graph @xmath0 ) .",
    "suppose we want to check whether the ( timed ) model in the figure satisfies the specification ( clearly false ) stating that if a _ fail",
    "_ occurs in the first attempt ( _ try1 _ ) of sending a message , then an _ abort _ event is eventually reached .",
    "we can model - check an ( untimed ) over - approximation of the model ( shown on the left ) obtaining the error trace _ start , try1.(send , wait , timeout , fail ) , try2.(send , wait , ack ) , success_. this trace lets us concentrate on the portion of the model with a potential error and can guide the simulation process to detect the error in the timed model .",
    "( 70,50)(-40,-10 )    ( m2)(0,25)@xmath1 ( n1)(-29,25)start ( n2)(-13,25)try@xmath2 ( n3)(9,25)try@xmath3 ( n4)(27,30)success ( n5)(27,20)abort ( n1,n2 ) ( n2,n3 ) ( n3,n4 ) ( n3,n5 ) ( n2,n4 )    ( -18,22)(-28,10 ) ( -8,22)(28,10 ) ( 4,22)(-28,10 ) ( 14,22)(28,10 )    ( m1)(0,0)@xmath0 ( n6)(-23,0)send ( n7)(-9,0)wait ( n8)(9,-5)timeout ( n9)(24,5)ack ( n10)(24,-5)fail ( n6,n7 ) ( n7,n8 ) ( n8,n10 ) ( n7,n9 )    ( m2t)(95,25)@xmath1 ( n11)(66,25)start ( n12)(82,25)try@xmath2 ( n13)(104,25)try@xmath3 ( n14)(122,30)success ( n15)(122,20)abort ( n11,n12 ) ( n12,n13)@xmath4 ( n13,n14 ) ( n13,n15 ) ( n12,n14 )    ( 77,22)(67,10 ) ( 87,22)(123,10 ) ( 99,22)(67,10 ) ( 109,22)(123,10 )    ( m1t)(95,0)@xmath0 ( n16)(72,0)send ( n17)(86,0)wait ( n18)(104,-5)timeout ( n19)(119,5)ack ( n110)(119,-5)fail ( n16,n17 ) ( n17,n18)@xmath5 ( n18,n110 ) ( n17,n19 )    let us now briefly detail the two notions of graded logics and hsm . in order to get more counterexamples in a unique run we use specifications expressed in _",
    "graded_- , recently introduced in @xcite .",
    "graded-  strictly extends classical  with graded modalities : classical ctl can be used for reasoning about the temporal behavior of systems considering either _ all _ the possible futures or _ at least one _ possible future , while graded - ctl uses graded extensions on both existential and universal quantifiers . with graded-  formulas",
    "one can describe a constant number of future scenarios .",
    "for example , one can express that in @xmath6 different cases it is possible that a waiting process never obtains a requested resource , or that there are @xmath6 different ways for a system to reach a _",
    "safe state _ from a given state .",
    "the notion of finite state machine with a hierarchical structure has been used for many years for modelling discrete systems , since the introduction of statecharts , @xcite , and is actually applied into many fields as a specification formalism . in particular , in the model - checking framework , one of the most considered models is the hierarchical state machine ( hsm ) ( see e.g. @xcite ) .",
    "a generalization of hsm  is introduced in @xcite , as an exponentially more succinct model where also higher level states , called _ boxes _ , are labeled with atomic propositions .",
    "the intended meaning of such labeling is that when a box @xmath7 expands to a machine @xmath8 , all the vertices of @xmath8 _ inherit _ the atomic propositions of @xmath7 ( _ scope _ ) , such that different vertices expanding to @xmath8 can place @xmath8 into different scopes .",
    "such model is called a _",
    "hierarchical state machine with scope - dependent properties _",
    "( scope - dependent hierarchical state machine , shortly shsm ) .",
    "our contribution aims in providing also strong theoretical evidence of the soundness of our approach .",
    "in particular we study the problem of verifying whether an shsm  models a given graded-  formula .",
    "we first give an algorithm to solve the graded-  model - checking of an hsm , and then we extend it to model - check general shsms .",
    "we show that the problem has the same computational complexity as  model checking , and we show how to solve it both for hsm  and shsm , with an extra factor in the exponent which is logarithmic in the maximal grading constant occurring in the  formula .",
    "let us stress that the experimental results for flat models reported in @xcite shows that this extra factor does not have real effects in the running time of the algorithms ( currently we are implementing also the algorithms presented here for hierarchical structures and the initial tests are very promising ) .",
    "the rest of the paper is organized as follows : in sections  [ sec : gradeddefinition ] and  [ sec : hierardefinition ] we give basic definitions and known results of graded - ctl , and of shsm , respectively ; in section  [ sec : algo ] we give the algorithm to model - check shsmagainst graded - ctl specifications . in section  [ sec : conclusions ] we give our conclusions .",
    "in this section we first recall the definitions of and then give that of graded- , see @xcite .",
    "the temporal logic @xcite is a branching - time logic in which each temporal operator , expressing properties about a possible future , has to be preceded either by an existential or by an universal path quantifier .",
    "so , in one can express properties that have to be true either _ immediately after now _",
    "( @xmath9 ) , or _",
    "each time from now _ ( @xmath10 ) , or _ from now until something happens _ ( @xmath11 ) , and it is possible to specify that each property must hold either in _ some possible futures _",
    "( @xmath12 ) or in _ each possible future _ ( @xmath13 ) .",
    "formally , given a finite set of _ atomic propositions _",
    "@xmath14 , is the set of formulas @xmath15 defined as follows : @xmath16 where @xmath17 is an atomic proposition and @xmath18 and @xmath19 are formulas .",
    "the semantics of a formula is defined with respect to a _",
    "kripke structure _ by means of the classical relation @xmath20 . as usual , a kripke structure over a set of atomic propositions @xmath14 , is a tuple @xmath21 , where @xmath22 is a finite set of states , @xmath23 is the initial state , @xmath24 is a transition relation with the property that for each @xmath25 there is @xmath26 such that @xmath27 , and @xmath28 is a labeling function . a path in @xmath29",
    "is denoted by the sequence of states @xmath30 or by @xmath31 , if it is infinite .",
    "the length of a path , denoted by @xmath32 , is the number of states in the sequence , and @xmath33 $ ] denotes the @xmath34-th state @xmath35 .",
    "then , the relation @xmath20 for a state @xmath25 of @xmath29 is iteratively defined as follows :    * @xmath36 iff @xmath37 ; * @xmath38 iff @xmath39 ( in short , @xmath40 ) ; * @xmath41 iff @xmath42 and @xmath43 ; * @xmath44 iff there exists @xmath45 such that @xmath46 and @xmath47 ( the path @xmath48 is called an _ evidence _ of the formula @xmath49 ) ; * @xmath50 iff there exists an infinite path @xmath51 starting from @xmath52 ( i.e. , @xmath53 = s$ ] ) such that for all @xmath54 , @xmath55 ) \\models \\psi_1 $ ] ( the path @xmath51 is called an _ evidence _ of the formula @xmath56 ) ; * @xmath57 iff there exists a finite path @xmath51 with length @xmath58 starting from @xmath52 such that @xmath59 ) \\models \\psi_2 $ ] and , for all @xmath60 , @xmath61 ) \\models \\psi_1 $ ] ( the path @xmath51 is called an _ evidence _ of the formula @xmath62 ) ;    we say that a kripke structure @xmath21 _ models _ a formula @xmath15 iff @xmath63 .",
    "note that we have expressed the syntax of with one of the possible minimal sets of operators .",
    "other temporal operators as well as the universal path quantifier @xmath13 , can be easily derived from those .",
    "* graded- * extends the classical by adding graded modalities on the quantifier operators .",
    "graded modalities specify in how many possible futures a given path property has to hold , and thus generalize allowing to reason about more than a given number of possible distinct future behaviors .",
    "let us first define the notion of _ distinct_. let @xmath64 be a kripke structure .",
    "we say that two paths @xmath65 and @xmath66 on @xmath29 are _ distinct _ if there exists an index @xmath67 such that @xmath68 \\neq \\pi_2[i]$ ] . observe that from this definition if a path is the prefix of another path , then they are not distinct .",
    "the _ graded existential path quantifier _ @xmath69 , requires the existence of @xmath70 pairwise distinct evidences of a path - formula .",
    "given a set of atomic proposition @xmath14 , the syntax of graded - is defined as follows : @xmath71 where @xmath17 , @xmath6 is a non - negative integer and @xmath18 and @xmath19 are graded - formulas .",
    "the semantics of graded - is still defined with respect to a kripke structure @xmath72 on the set of atomic propositions @xmath14 . in particular , for formulas of the form @xmath73 , @xmath74 and @xmath75 the semantics is the same as in the classical . for the remaining formulas ,",
    "the semantics is defined as follows :    * @xmath76 , with @xmath77 and either @xmath78 or @xmath79 or @xmath80 , iff there exist @xmath70 pairwise distinct evidences of @xmath81 starting from @xmath52 .",
    "it is easy to observe that classical is a proper fragment of graded - since the simple graded formula @xmath82 can not be expressed in , whereas any formula is also a graded - formula ( note that @xmath83 is equivalent to @xmath84 ) .",
    "we can also consider the graded extension of the universal quantifier , @xmath85 , with the meaning that _ all the paths starting from a node @xmath52 , but at most @xmath6 pairwise distinct paths , are evidences of a given path - formula_. the quantifier @xmath85 is the dual operator of @xmath69 and can obviously be re - written in terms of @xmath86 .",
    "however , while @xmath87 and @xmath88 can be easily re - written respectively as @xmath89 and @xmath90 , the transformation of the formula @xmath91 with @xmath92 in terms of @xmath86 deserves more care ( see @xcite for a detailed treatment ) .    the * graded - model - checking * is the problem of verifying whether a kripke structure @xmath29 models a graded - formula @xmath15 .",
    "the complexity of the graded - model - checking problem is linear with respect to the size of the kripke structure and to the size of the formula , ( this latter being the number of the temporal and the boolean operators occurring in it ) .",
    "let us remark that this complexity is independent from the integers @xmath6 occurring in the formula .",
    "in this section we formally define the scope - dependent hierarchical state machines and recall some known results .",
    "the scope - dependent hierarchical state machines are defined as follows .    a _ scope - dependent hierarchical state machine _ ( shsm ) over @xmath14 is a tuple @xmath93 , each @xmath94 is called _ machine _ and consists of :    * a finite set of  @xmath95 , an _ initial _  @xmath96 and a set of _ output",
    "_  @xmath97 ; * a labeling function @xmath98 that maps each  with a set of atomic propositions ; * an expansion mapping @xmath99 such that @xmath100 , for each @xmath101 , and @xmath102 , for each @xmath103 ; * a set of edges @xmath104 where each edge is either a couple @xmath105 , with @xmath106 and @xmath107 , or a triple @xmath108 with @xmath109 , @xmath110 , and @xmath111 .",
    "( 137,52)(-8,-52 ) ( n0)(34.55,-16.19 ) @xmath112    ( n39)(46.55,-16.19 ) @xmath113 ( n39)@xmath114    ( n41)(40.55,-16.19 )    ( n56)(22.55,-16.19 ) @xmath115 ( n56)@xmath116    ( n57)(28.55,-16.19 )    ( n58)(16.65,-16.19 )    ( n108)(4.55,-16.19 ) @xmath117 ( n108)@xmath116    ( n108,n58 )    ( n76)(52.55,-16.19 )    ( n188)(64.55,-16.19 ) @xmath118 ( n188 ) @xmath119    ( n57,n41 )    ( n76,n188 )    ( n108 )    ( n188 )    ( n230)(102.71,-40.32 ) @xmath0    ( n232)(87.71,-40.32 ) @xmath120 ( n232)@xmath116    ( n234)(117.71,-40.32 ) @xmath121 ( n234)@xmath122    ( n232 )    ( n234 )    ( n232,n234 )    ( n95)(34.55,-40.52 ) @xmath1    ( n96)(46.55,-40.52 ) @xmath123 ( n96)@xmath124    ( n97)(40.55,-40.52 )    ( n98)(22.55,-40.52 ) @xmath125 ( n98 ) @xmath116    ( n99)(28.55,-40.52 )    ( n100)(16.55,-40.52 )    ( n101)(4.55,-40.52 ) @xmath126 ( n101)@xmath116    ( n101,n100 )    ( n102)(52.55,-40.52 )    ( n103)(64.55,-40.52)@xmath127 ( n103)@xmath128    ( n99,n97 )    ( n102,n103 )    ( n101 )    ( n103 )    in the rest of the paper we use @xmath129 as the number of machines of an shsm  @xmath130 and @xmath131 is called _ top - level _ machine .",
    "we assume that the sets of  @xmath95 are pairwise disjoint .",
    "the set of all  of @xmath130 is @xmath132 .",
    "the mappings @xmath133 and @xmath134 extend the mappings @xmath135 and @xmath136 , respectively .",
    "if @xmath137 , the  @xmath138 expands to the machine @xmath139 and is called _",
    "box_. when @xmath140 , @xmath138 is called a _",
    "node_. let us define the closure @xmath141 , as : @xmath142 if either @xmath143 or there exists @xmath144 such that @xmath145 .",
    "we say that a  @xmath138 is an _ ancestor _ of @xmath146 and @xmath146 is a _ descendant _ from @xmath138 if @xmath147 , for @xmath148 .",
    "a vertex @xmath149 is called a _",
    "successor _ of @xmath150 if there is an edge @xmath151 , and it is called a _ z - successor _ of @xmath138 , for @xmath152 , if @xmath153 .    an hsm  is an shsm  such that @xmath154 , for any box @xmath7 .    as an example of an shsm",
    "@xmath130 see figure  [ esempiochsm ] , where @xmath155 are atomic propositions labeling nodes  and boxes  of @xmath130 , @xmath156 and @xmath157 are respectively entry nodes  and exit nodes  for @xmath158 , and @xmath159 for @xmath160 and @xmath161 .",
    "* semantics . *",
    "the semantics of an shsm  @xmath130 is given by a _ flat _",
    "kripke structure , denoted @xmath162 .",
    "a sequence of  @xmath163 , @xmath164 , is called a _",
    "well - formed sequence _ if @xmath165 , for @xmath166 .",
    "moreover , @xmath167 is also _ complete _ when @xmath168 and @xmath169 is a node .",
    "a state of @xmath162 is @xmath170 where @xmath167 is a complete well - formed sequence  of @xmath130 .",
    "note that the length of a complete well - formed sequence  is at most @xmath129 , therefore the number of states of @xmath162 is at most exponential in the number of machines composing @xmath130 .",
    "transitions of @xmath162 are obtained by using as templates the edges of @xmath130 .",
    "figure  [ peggiodinoi ] shows the kripke structure which is equivalent to the shsm  of figure  [ esempiochsm ] .",
    "we formally define @xmath162 as follows .",
    "given an shsm  @xmath171 , it is immediate to observe that the tuple @xmath172 , @xmath173 , is an shsm  as well .",
    "clearly , @xmath174 . in the following ,",
    "we sketch how to compute recursively the flat kripke structures @xmath175 .",
    "we start with @xmath176 which is obtained from machine @xmath0 by simply replacing each  @xmath138 with a state @xmath177 labeled with @xmath178 ( recall that by definition all  of @xmath179 are nodes ) .",
    "thus , for each edge @xmath180 we add a transition @xmath181 in @xmath176 .    for @xmath182 , @xmath175 is obtained from @xmath139 by simply replacing each box  @xmath138 of @xmath139 with a copy of the kripke structure @xmath183 .",
    "more precisely , for each node  @xmath184 , @xmath185 is a state of @xmath175 which is labeled with @xmath186 and for each box  @xmath187 and state @xmath188 of @xmath183 , @xmath189 is a state of @xmath175 and is labeled with @xmath190 .",
    "the transitions of @xmath183 are all inherited in @xmath175 , that is , there is a transition @xmath191 in @xmath175 for each transition @xmath192 of @xmath183 .",
    "the remaining transitions of @xmath175 correspond to the edges of @xmath139 :    * for each node  @xmath193 and edge @xmath194 ( resp .",
    "@xmath195 ) there is a transition from @xmath177 ( resp .",
    "@xmath196 ) to @xmath197 ; * for each box  @xmath193 and edge @xmath194 ( resp .",
    "@xmath195 ) there is a transition from @xmath177 ( resp .",
    "@xmath196 ) to @xmath198 .",
    "a box  @xmath138 expanding into @xmath139 is a placeholder for @xmath175 and determines a subgraph in @xmath162 isomorphic to @xmath175 .",
    "this is emphasized in figure  [ peggiodinoi ] , where we have enclosed in shades of the same shape and color the isomorphic subgraphs corresponding to a same graph @xmath175 .",
    "therefore , figure  [ peggiodinoi ] also illustrates the recursive definition of @xmath162 .",
    "if two distinct boxes  @xmath199 and @xmath200 both expand into the same machine @xmath139 , that is @xmath201 , then the states of @xmath175 appear in @xmath162 in two different scopes , possibly labeled with different sets of atomic propositions : in one scope this set contains @xmath202 and in the other it contains @xmath203 .",
    "the atomic propositions labeling boxes  represent _ scope - properties_. in fact , for a given box  @xmath138 , the set @xmath186 of atomic propositions is meant to hold true at @xmath138 and at all its possible descendants .    ( 213,58)(0,-58 )    ( 18,-1)(18,-23)(120,-23)(120,-1 )    ( 35,-4)(35,-20)(67,-20)(67,-4 )    ( 69,-4)(69,-20)(101,-20)(101,-4 )    ( 9,-31.07)(9,-53.07)(111,-53.07)(111,-31.07 )    ( 27,-34.07)(27,-50.07)(59,-50.07)(59,-34.07 )    ( 61,-34.07)(61,-50.07)(93,-50.07)(93,-34.07 )    ( n2)(4.98,-12.0 ) @xmath204 ( n2 ) @xmath116    ( n6)(111.98,-12.0 ) @xmath205 ( n6 ) @xmath128    ( n7)(24.98,-12.0 ) @xmath206 ( n7)@xmath116    ( n14)(58.57,-12.48 ) @xmath207 ( n14 ) @xmath122    ( n15)(42.97,-12.48 ) @xmath208 ( n15 ) @xmath116    ( n57)(92.97,-12.48 ) @xmath209 ( n57 ) @xmath128    ( n58)(77.47,-12.48 ) @xmath210 ( n58 ) @xmath123 ( n63)(123.88,-42.01 ) @xmath211 ( n63 ) @xmath119    ( n64)(103.11,-42.01 ) @xmath212 ( n64 ) @xmath119    ( n65)(16.49,-42.15 ) @xmath213 ( n65)@xmath113    ( n68)(50.68,-42.07 ) @xmath214 ( n68 ) @xmath113    ( n69)(35.28,-42.07 ) @xmath215 ( n69 ) @xmath113    ( n72)(85.18,-42.07 ) @xmath216 ( n72 ) @xmath119 ( n73)(69.08,-42.07 ) @xmath217 ( n73 ) @xmath218    ( n2,n7 )    ( n68,n73 )    ( n64,n63 )    ( n2 )    ( n7 )    ( n6 )    ( n65 )    ( n64 )    ( n63 )    ( n73 )    ( n15 )    ( n14 )    ( n58 )    ( n57 )    ( n69 )    ( n68 ) ( n72 )    ( n14,n58 )    ( n15,n14 )    ( n58,n57 )    ( n7,n15 )    ( n65,n69 )    ( n73,n72 )    ( n72,n64 )    ( n69,n68 ) ( n6,-18,85.88,n65,-203,66.37 )    ( n57,n6 )    * succinctness . * clearly , any hierarchical structure , either an hsm  or an shsm , is in general more succinct than a traditional kripke structure .",
    "scope properties make shsmpossibly even more succinct than hsm .",
    "in fact , two isomorphic subgraphs of a kripke structure which differ only on the labeling of the vertices can be represented in an shsm  by the single machine @xmath139 , while it should be represented by two different machines in an hsm .",
    "let us recall two main results from @xcite on the succinctness of these models , where a restricted shsm  @xmath219 is an shsmwhere for all vertices @xmath220 such that @xmath138 is an ancestor of @xmath146 in @xmath130 it holds that @xmath221 .",
    "[ theo : succintezza1 ] restricted shsms can be exponentially more succinct than hsms and finite state machines .",
    "there is an exponential gap also between restricted shsms and shsms as shown in the following proposition .",
    "shsms can be exponentially more succinct than restricted shsms .",
    "observe that hsms , restricted shsms and shsms can all be translated to equivalent finite state machines with a single exponential blow - up .",
    "thus , the two succinctness results do not add up to each other , in the sense that it is not true that shsms can be double exponentially more succinct than hsms .",
    "the * model - checking * is the problem of verifying whether a kripke structure @xmath29 models a formula . for an shsm",
    "@xmath130 , the * model - checking * is the problem of verifying whether the flat structure @xmath162 models a formula . it is known that the model - checking problem can be solved in linear time in the size of both the formula and the machine , see @xcite , while it is exponential for both hsm  and shsm .",
    "more precisely , the following theorem holds .",
    "[ theo : ctlmc ] the  model - checking of an shsm  @xmath130 for a formula @xmath15 can be solved in @xmath222 time , where @xmath223 is the maximum number of exit nodes of @xmath130 and @xmath224 is the set of atomic proposition occurring in @xmath15 .",
    "moreover , if @xmath130 is an hsm , then it can be solved in @xmath225 time .    in this section",
    "we extend the result to model - checking a hierarchical structure against a graded - formula .",
    "we first show an algorithm for graded-  model - checking of an hsm , and then we extend it to model - check shsms .",
    "the aim of the algorithm is to determine , for each node @xmath138 in a machine @xmath139 of @xmath130 and each subformula @xmath226 of @xmath15 , whether @xmath138 _ satisfies _ @xmath226 or not .",
    "anyway , the concept of satisfiability may be ambiguous , since whether @xmath138 satisfies @xmath226 or not may depend on the possible different sequences of boxes which expand in @xmath139 .",
    "thus , the algorithm transforms @xmath130 in such a way that either for every box sequence @xmath227 it holds that @xmath228 ( and in this case we say that @xmath138 satisfies @xmath226 ) , or for every @xmath227 it holds that @xmath229 .",
    "this transformation determines multiple copies of each @xmath139 , for @xmath230 ( clearly , since there are no nodes expanding in the top - level machine @xmath131 , there is not such ambiguity for a @xmath231 ) .",
    "the algorithm considers the subformulas @xmath226 of @xmath15 , starting from the innermost subformulas , and , for each node @xmath138 in @xmath130 sets @xmath232 if @xmath138 satisfies @xmath226 , modifying possibly the hierarchical structure .",
    "if @xmath226 is an atomic proposition or it is either @xmath233 or @xmath234 , the algorithm is trivial . for subformulas with temporal operators and grade @xmath235",
    ", then the algorithm behaves exactly as in @xcite for the  model - checking .",
    "we now show how it behaves for subformulas of the form @xmath236 , with @xmath237 and @xmath238 . by inductive hypothesis",
    ", we assume that the algorithm has already set @xmath239 if @xmath138 satisfies @xmath240 , for @xmath241 .",
    "the algorithm for @xmath242 is rather simple .",
    "it starts from the nodes of @xmath0 setting @xmath232 if @xmath138 satisfies @xmath226 , and then inductively considers all the machines .",
    "let @xmath138 be a node of @xmath139 . if @xmath243 , then it satisfies @xmath226 if there are at least @xmath70 successors in @xmath139 satisfying @xmath244 .",
    "for an output node @xmath245 , whether @xmath246 satisfies @xmath226 depends also on the successors of a box expanding in @xmath139 .",
    "multiple copies of @xmath139 are then created , denoted @xmath247 , where @xmath248 , which correspond to the different contexts in which @xmath139 occurs .",
    "the nodes of @xmath247 are @xmath249 , for a node @xmath138 of @xmath139 , and the boxes are @xmath250 , for a box @xmath7 of @xmath139 .",
    "the idea is that @xmath251 is the number of @xmath246-successors , satisfying @xmath244 , of a box expanding in @xmath139 ( recall that the edges outgoing from a box @xmath7 are of the type @xmath252 , and we call such @xmath146 a @xmath246-successor of @xmath7 ) .",
    "thus , the algorithm sets @xmath253 if the sum of @xmath254 and the number of successors in @xmath139 satisfying @xmath244 , is greater than @xmath6 .",
    "moreover , for each box @xmath7 , the algorithm calculates the number of @xmath246-successors of @xmath7 satisfying @xmath244 .",
    "the new hsm  is then obtained by defining the new expansion of @xmath7 in @xmath139 : @xmath7 expands in the copy @xmath255 of @xmath256 such that @xmath254 is the number of @xmath246-successors of @xmath7 satisfying @xmath244 .",
    "consider now formulas of the type @xmath257 and let us call @xmath258 .",
    "the algorithm first determines which nodes of the hsm  @xmath130 satisfy the formula @xmath259 . at the end of this step",
    "@xmath130 is modified in such a way that each node @xmath138 either satisfies @xmath259 or satisfies @xmath260 . in doing that ,",
    "the size of @xmath130 may double ( cf .",
    "@xcite ) . call @xmath22 the set of the nodes satisfying @xmath259 .",
    "the algorithm determines , for each node @xmath261 , whether @xmath138 satisfies @xmath226 using the following idea .",
    "sink - cycle _ be a cycle containing only nodes with out - degree @xmath2 .",
    "* claim 1 . * consider the graph induced by the states of @xmath162 where @xmath259 holds .",
    "then , given a state @xmath262 , @xmath263 iff in this graph either there is a _ non - sink - cycle _ reachable from @xmath52 , or there are @xmath70 pairwise distinct finite paths connecting @xmath52 to _ sink - cycles_.    the algorithm checks the property of the claim analyzing all the machines @xmath139 of @xmath130 starting from the bottom - level machine @xmath0 , which contains no boxes .",
    "for each machine @xmath139 , it performs a preliminary step to determine the set of non - sink - cycles @xmath264 of nodes @xmath184 such that a non sink - cycle is reachable in @xmath175 from @xmath265 , through nodes of @xmath22 .",
    "then , in a successive step , the algorithm detects the other nodes satisfying @xmath226 .",
    "in particular for any detected node @xmath184 and for any sequence @xmath167 of boxes ( below we show how to remove this dependency from @xmath167 ) the following situation can occur :    * there is a non - sink cycle reachable in @xmath162 from a state @xmath266 including only nodes in @xmath22 ; * @xmath70 paths start in @xmath162 from @xmath267 , each going through nodes belonging to @xmath22 , and ending into sink - cycles .",
    "observe that , if the non - sink cycle is in @xmath162 , but it is not in @xmath268 , then @xmath269 and thus the former case has not been detected by the algorithm in the previous preliminary step .    in order to get that the above properties do not depend on the choice of @xmath167 , also in this case multiple copies of each @xmath139 are created , each for a different context in which @xmath139 occurs .",
    "each copy is denoted @xmath247 where @xmath248 is a mapping such that if @xmath246 does not satisfies @xmath259 then @xmath270 . its nodes and boxes are obtained by renaming nodes and boxes of @xmath139 , as in the previous case .",
    "let us now give some details on how the above steps are realized .",
    "the set @xmath271 , for @xmath272 , is computed by visiting a graph @xmath273 , with the nodes in @xmath274 .",
    "if @xmath275 , then @xmath273 contains also the boxes @xmath7 of @xmath139 , such that @xmath276 , and new vertices @xmath277 , for @xmath278 ( recall that there are no boxes in @xmath0 ) .",
    "the edges of @xmath139 connecting the boxes and the nodes above are edges also of this graph , moreover , there is an edge from @xmath7 to @xmath277 if there is a path from @xmath279 to @xmath246 in @xmath256 , constituted of all vertices not belonging to @xmath280 .",
    "the algorithm proceeds inductively , starting from @xmath0 .",
    "when @xmath139 is considered , for @xmath281 , we assume that the sets @xmath282 have already been determined , for all @xmath283 , and that , for each @xmath284 , it has also been checked whether there is a path from @xmath285 to @xmath246 , constituted of all vertices not belonging to @xmath282 ( observe that this property is used to define the edges in @xmath273 ) .",
    "moreover , we assume that , if there is such a path , it has also been checked whether there are vertices in the path with out - degree greater than @xmath2 and whether @xmath246 has an out - going edge within @xmath286 .",
    "the result of this test is useful to detect the non - sink cycles and thus to determine the set @xmath271 .",
    "in fact , if either a node @xmath287 has an out - going edge or there is a vertex with out - degree at least @xmath3 in the path from @xmath279 to @xmath246 , then a cycle going through @xmath277 in @xmath273 determines a non - sink cycle on the corresponding flat machine .",
    "once the set @xmath271 has been computed , the algorithm sets @xmath232 for all @xmath288 and then it performs the successive step considering only the remaining nodes .    for each @xmath289 and each mapping @xmath248 ,",
    "a dag @xmath290 is constructed with the nodes @xmath291 such that @xmath292 , the boxes @xmath7 and the new vertices @xmath277 , for @xmath287 , such that both @xmath279 and @xmath293 satisfy @xmath259 and do not belong to @xmath294 , and with the exception that the sink cycles are substituted by a single vertex .",
    "the edges in @xmath290 are those of @xmath139 .",
    "the algorithm labels the vertices of @xmath290 , starting from the leaves , as follows .",
    "* @xmath245 is labeled by @xmath254 , * if @xmath295 in @xmath290 is not a box and has successors @xmath296 , labeled by @xmath297 , then @xmath295 is labeled by @xmath298 ; * for a box @xmath7 , such that @xmath299 , let @xmath300 be the mapping such that @xmath301 if @xmath277 is labeled by @xmath302 , for @xmath284 .",
    "if @xmath285 has been labeled by @xmath34 in the dag @xmath303 then @xmath7 is labeled @xmath34 as well ( observe that the labeling of @xmath285 in @xmath303 has already been determined , since @xmath304 ) .    as said above , new machines @xmath247 have been constructed as copies of @xmath139 , by renaming its nodes and boxes .",
    "now , for each @xmath184 , the algorithm sets @xmath305 if @xmath138 is labeled by @xmath70 in @xmath290 .    finally , the expansion mapping for @xmath247 is defined as follows : if @xmath306 then @xmath250 now expands into @xmath307 , where @xmath300 is such that @xmath301 for @xmath284 which has been labeled by @xmath302 in @xmath303 .",
    "finally , for the case of a subformula @xmath308 , for @xmath92 , the algorithm behaves in a similar way .",
    "it first determines the nodes of @xmath130 which satisfy @xmath309 and then it determines , for each node @xmath261 , whether @xmath138 satisfies @xmath226 , with an approach suggested by the following claim .",
    "* claim 2 . * consider the graph induced by the states of @xmath162 where @xmath310 holds , and by deleting the edges outgoing from states where @xmath244 does not hold .",
    "then , given a state @xmath262 , @xmath263 iff in this graph either there is a _ non - sink - cycle _ reachable from @xmath52 , or there are @xmath70 pairwise distinct finite paths connecting @xmath52 to states where @xmath311 holds .",
    "thus , the main difference with respect to the steps described above , is in the definition of the graphs @xmath273 and @xmath290 since they now do not have edges outgoing from states where @xmath244 does not hold , in accordance to the claim 2 .",
    "we will omit further details .",
    "now we can state the first main result , where @xmath312 is the number of the boolean and temporal operators in @xmath15 , @xmath223 is the maximum number of exit nodes of @xmath130 and @xmath313 is the maximal constant occurring in a graded modalities of @xmath15 .",
    "[ theo : ghsmmc ] the graded-  model - checking of an hsm  @xmath130 can be solved in @xmath314 .",
    "the algorithm sketched above considers the subformulas @xmath226 of @xmath15 , and , for each node @xmath138 in @xmath130 , sets @xmath232 if @xmath138 satisfies @xmath226 . for @xmath236 , with @xmath237 , and @xmath315 ,",
    "the correctness of the algorithm is rather immediate , while if either @xmath316 or @xmath317 , the correctness of the algorithm mainly relies on the given claims . for sake of brevity , we omit here the proof of the claims .    the crucial point is to prove that the algorithm detects all the nodes @xmath138 in a machine @xmath139 such that a non - sink cycle is reached from @xmath318 along a path including only nodes satisfying @xmath83 .",
    "let @xmath138 be a node in @xmath139 . if there is a non - sink cycle reachable from @xmath319 in @xmath175 , including only nodes in the set @xmath22 of nodes satisfying @xmath83 , then @xmath320 and the algorithm sets @xmath321 .",
    "now suppose that there are boxes @xmath322 and that a non - sink cycle is reachable from @xmath323 in @xmath324 ( again including only nodes in @xmath22 ) and suppose also that no non - sink cycles are reachable from @xmath325 , for @xmath326 .",
    "this implies that there is @xmath327 , and a non - sink cycle reachable from @xmath328 in @xmath324 , and there are @xmath329 such that , for @xmath330 ,    * @xmath331 * @xmath332 is reachable from @xmath333 , in @xmath268 , * @xmath334 is reachable from @xmath335 , in @xmath336    in this case the algorithm sets @xmath337 .",
    "moreover , in the new hsm each @xmath338 will expand in a copy @xmath339 of @xmath340 , where @xmath341 is such that @xmath342 . and",
    "thus , called @xmath249 the copy of @xmath138 in in @xmath247 , the algorithm sets @xmath343 similarly , the algorithm detects all the nodes @xmath138 in @xmath139 such that @xmath70 paths start from @xmath318 ending in sink cycles including only nodes in @xmath22 . to state the complexity of the algorithm , observe that , while processing a subformula @xmath236 , with @xmath237 and @xmath344 , the algorithm creates several copies of each machine @xmath139 , denoted @xmath247 where @xmath248 .",
    "thus the size of the current hsm  grows for a factor not exceeding @xmath345 , where @xmath223 is the maximum number of exit nodes of @xmath130 and @xmath313 is the maximal constant occurring in a graded modalities of @xmath15 .",
    "since , for each operator in @xmath15 , the time spent by the algorithm is linear in the size of the current hsm , than the overall running time is @xmath346 .",
    "let us remark that , although the multiple copies created by the given algorithm can be seen as a step towards the flattening of the input hsm , the resulting structure is in general much smaller than the corresponding flat kripke structure . to solve the graded-  model - checking for shsm  we show now how to reduce it to the model - checking problem for hsm",
    "let @xmath171 be an shsm  and let @xmath15 be a graded-  formula .",
    "let @xmath224 be the set of atomic propositions that occur in @xmath15 .",
    "the first step of our algorithm consists of constructing an hsm  @xmath347 such that @xmath348 is isomorphic to @xmath162 .",
    "let @xmath349 be a bijection such that @xmath350 whenever @xmath351 .",
    "clearly , @xmath352 maps @xmath353 into a strictly increasing sequence of consecutive positive integers starting from @xmath2 . for a machine @xmath94 , @xmath354 and @xmath355 ,",
    "define @xmath356 as the machine @xmath357 where :    * @xmath358 , and @xmath359 ; * @xmath360 if @xmath138 is a node  and @xmath361 , otherwise ; * @xmath362 if @xmath138 is a node  and @xmath363 , otherwise ; * @xmath364 .",
    "let @xmath365 .",
    "we define @xmath347 be the tuple of machines @xmath366 such that for @xmath367 , @xmath368 where @xmath369 . from the definition of @xmath370 it is simple to verify that @xmath347 is an hsm  and",
    "@xmath371 is @xmath372 .",
    "moreover , @xmath348 and @xmath162 coincide , up to a renaming of the states .",
    "thus , from theorem  [ theo : ghsmmc ] , we have the following second main result .",
    "[ theo : gshsmmc ] the graded  model checking of an shsm  can be solved in @xmath373 time .",
    "in this paper we have proposed the use of graded - ctl specifications to model - check hierarchical state machines .",
    "we think that the added power in the specification formalism can be fruitfully exploited in the simulation and testing community to get more meaningful test benches to perform simulation of more and more complex systems .",
    "we have given algorithms for checking classical hsms and so - called shsms .",
    "let us observe that the alternative approach of model - checking the fully expanded flat structure has in general a worse performance because of the exponential gap between an hsm  and its corresponding flat structure .",
    "in fact the gain in size of the hierarchical model , is in practice much greater than the extra exponential factor paid , which depends on the size of ( the formula for ) the specification , usually quite small .",
    "one last consideration is that we have considered only sequential hierarchical finite state machines ( as an abstraction of the devs model ) .",
    "it is a standard approach , when model checking concurrent systems , to first sequentialize the model of the sut ( possibly on - the - fly ) and then check it with model checking algorithms for sequential models .",
    "moreover , the cost of considering parallel and communicating machines would lead to a double exponential blow - up , the so - called state explosion problem . +",
    "* acknowledgements . *",
    "we thank the anonymous referees for their valuable comments ."
  ],
  "abstract_text": [
    "<S> recently there has been a great attention from the scientific community towards the use of the model - checking technique as a tool for _ test generation _ in the simulation field . </S>",
    "<S> this paper aims to provide a useful mean to get more insights along these lines . by applying recent results in the field of </S>",
    "<S> _ graded _ temporal logics , we present a new efficient model - checking algorithm for hierarchical finite state machines ( hsm ) , a well established symbolism long and widely used for representing hierarchical models of discrete systems . performing model - checking against specifications </S>",
    "<S> expressed using graded temporal logics has the peculiarity of returning more counterexamples within a _ </S>",
    "<S> unique run_. we think that this can greatly improve the efficacy of automatically getting test cases . </S>",
    "<S> in particular we verify two different models of hsm against branching time temporal properties . </S>"
  ]
}