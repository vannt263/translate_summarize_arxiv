{
  "article_text": [
    "given an undirected graph @xmath6 with @xmath7 vertices and @xmath8 edges , an orientation transforms @xmath9 into a directed graph @xmath10 by assigning a direction to each edge .",
    "that is , an orientation of @xmath9 is the directed graph @xmath11 such that the vertex set @xmath12 is the same as @xmath9 , and the edge set @xmath13 is an orientation of @xmath14 : exactly one direction between @xmath15 and @xmath16 holds for any undirected edge @xmath17 .",
    "an orientation @xmath10 is _ acyclic _ when @xmath10 does not contain any directed cycles , so @xmath10 is a directed acyclic graph ( dag ) ; otherwise we say that the orientation @xmath10 is cyclic .",
    "acyclic orientations of undirected graphs have been studied in depth .",
    "many results concern the number of such orientations : stanley  @xcite shows how , given a graph @xmath9 and its chromatic number @xmath18 , the number of acyclic orientations of @xmath9 can be computed by using the chromatic polynomial ( a special case of tutte s polynomial ) .",
    "other results rely on the so called acyclic orientation game : alon et al .",
    "@xcite inquire about the number of edges that have to be examined in order to identify an acyclic orientation of a random graph @xmath9 ; pikhurko  @xcite gives an upper bound on this number of edges in general graphs .",
    "the counting problem is known to be # p - complete  @xcite and enumeration algorithms that list all the acyclic orientations of a graph are given in @xcite and @xcite .",
    "we consider _ cyclic _ orientations , which have been also studied from many points of view .",
    "counting them is co-#p - complete  @xcite . in fisher",
    "@xcite , given a graph g and an acyclic orientation of it , the number of _ dependent edges _",
    ", i.e. edges generating a cycle if reversed , has been studied .",
    "this number of edges implicitly gives a hint on the number of cyclic orientations in a graph . in",
    "@xcite an algorithm has been given to make inference about causal structure in cyclic graphs .",
    "in  @xcite directed cyclic graphs are used to model economic processes , and an algorithm is given to characterize conditional independence constraints of these processes .    in this paper",
    "we address the problem of enumerating all the cyclic orientations of a graph .",
    "enumerating the set of all the directed graphs @xmath10 that are cyclic orientations of an undirected graph @xmath9 .",
    "[ problem1 ]    we analyze the cost of an enumeration algorithm for problem  [ problem1 ] in terms of its _ setup _ cost , meant as the initialization time before the algorithm is able to lists the solutions , and its _ delay _ cost , which is the worst - case time between any two consecutively enumerated solutions ( e.g. @xcite ) .",
    "we are interested in algorithms with guaranteed @xmath2 delay , where the @xmath19 notation ignores polylogs .",
    "a naive solution to problem  [ problem1 ] uses the fact that enumeration algorithms exist for listing acyclic orientations  @xcite .",
    "it enumerates the cyclic orientations by difference , namely , by enumerating all the @xmath20 possible edge orientations and removing the @xmath21 acyclic ones .",
    "however , this solution does not guarantee any polynomial delay , as the number @xmath22 if cyclic orientations can be much larger or much smaller than the number @xmath21 of acyclic ones .",
    "for example , a tree with @xmath1 edges has @xmath23 and @xmath24 . on the other extreme of the situation",
    ", we have cliques .",
    "an oriented clique is also called a _ tournament _ , and a _ transitive tournament _ is a tournament with no cycles . a clique of @xmath0 nodes ( and @xmath25 edges )",
    "can generate @xmath20 different tournaments , out of which exactly @xmath26 will be transitive tournaments  @xcite . as @xmath20 grows faster than @xmath27 , we have that the ratio @xmath28 tends to 0 for increasing @xmath0 , where @xmath22 .    to the best of our knowledge , an enumeration algorithm for problem  [ problem1 ] with guaranteed @xmath2 delay is still missing .",
    "we provide such an algorithm in this paper , namely , listing each cyclic orientation with @xmath2 delay time .",
    "space usage is @xmath3 memory cells with a setup cost of @xmath4 time , or @xmath5 memory cells with a setup cost of @xmath2 time .",
    "interestingly , problem  [ problem1 ] reveals to be a rich source for enumerations techniques , and our solution offers new combinatorial and algorithmic techniques when compared to previous work on the enumeration of acyclic orientations  @xcite .    in the following , for the sake of clarity , we will call _ edges _ the elements of @xmath14 ( undirected graph ) and _ arcs _ the elements of @xmath13 ( directed graph ) .",
    "we will assume that the graph in input @xmath9 is connected and we will denote as @xmath7 and @xmath8 respectively its number of nodes and edges .",
    "the paper is organized as follows .",
    "section  [ sec : overview ] gives an overview of our enumeration algorithm .",
    "section  [ sec : setup ] describes the initialization steps , and shows how to reduce the problem from the input graph to a suitable multi - graph that guarantees to have a chordless cycle ( hole ) of logarithmic size .",
    "the latter is crucial to obtain the claimed delay .",
    "section  [ sec : enum ] shows how to enumerate in the multigraph and obtain the cyclic orientations for the input graph .",
    "section  [ sec : absorb ] describes how to absorb the setup cost using more space .",
    "finally , some conclusions are drawn in section  [ sec : conclusions ] .",
    "the intuition behind our algorithm for an undirected connected graph @xmath29 is the following one .",
    "suppose that @xmath9 is cyclic , otherwise there are no cyclic orientations .",
    "consider one cycle @xmath30 in @xmath9 : we can orient its edges in two ways so that the resulting @xmath31 is a directed cycle . at this point , _ any _ orientation of the remaining edges , e.g. those in @xmath32 , will give a cyclic orientation of @xmath9 .",
    "thus , the interesting cases are when the resulting @xmath31 is not a directed cycle .",
    "the idea is first to generate all possible orientations of the edges in @xmath32 , and then assign some suitable orientations to the edges in @xmath33 .",
    "this guarantees that we have at least two solutions for each orientation of @xmath32 , namely , setting the orientation of @xmath33 so that @xmath31 is one of the two possible directed cycles .",
    "yet this is not enough as we could have a cyclic orientation even if @xmath31 is _ not _ a directed cycle .",
    "therefore we must consider some cases .",
    "one easy case is that the orientation of @xmath32 already produces a directed cycle : any orientation of @xmath33 will give a cyclic orientation of @xmath9",
    ". another easy case , as seen above , is for the two orientations of @xmath33 such that @xmath31 is a directed cycle : any orientation of @xmath32 will give a cyclic orientation of @xmath9 .",
    "it remains the case when the orientations of both @xmath32 and @xmath33 are individually acyclic : when put together , we might have or not a directed cycle in the resulting orientation of @xmath9 . to deal with the latter case , we need to `` massage '' @xmath9 and transform it into a multigraph as follows .",
    "we refer the reader to algorithm  [ alg : structure ] .",
    "* algorithm setup * is performed as described in section  [ sec : setup ] .",
    "we preprocess @xmath9 with dead - ends removal and edge chain compression .",
    "the result is an undirected connected multigraph @xmath34 , where the edges are labeled as _ simple _ and _ chain_. after that we find a chordless cycle of logarithmic size @xmath35 in @xmath36 , and remove @xmath33 from @xmath37 , obtaining the labeled multigraph @xmath38 , where @xmath39 .",
    "* enumerating cyclic orientations * described in section  [ sec : enum ] exploits the property ( which we will show later ) that finding cyclic orientations of @xmath9 corresponds to finding particular orientations in @xmath40 , called _ extended cyclic orientations _ , and of @xmath35 , called _",
    "legal orientations_. in the * for * loop , these orientations of @xmath40 and @xmath35 are enumerated so as to find all the cyclic orientations of @xmath9 . as we will see for the latter task , it is important to have @xmath35 of logarithmic size to guarantee our claimed delay .",
    "* algorithm setup ( section  [ sec : setup ] ) : * + remove dead - ends ( nodes of degree @xmath41 ) recursively from @xmath9 + @xmath42 replace @xmath9 s maximal paths of degree-2 nodes with chain edges + @xmath43 a log - holeof @xmath36 + @xmath44 delete the edges of @xmath35 from @xmath36 , i.e. @xmath39 + * enumerate cyclic orientations ( section  [ sec : enum ] ) : * +",
    "in the following we show how to reduce problem  [ problem1 ] to an extended version that allows us to neglect dead - ends and chains .    [ [ dead - end - removal . ] ] * dead - end removal . * + + + + + + + + + + + + + + + + + + +    given an undirected graph @xmath6 , a dead - end is a node of degree 1 .",
    "we recursively remove all _ dead - ends _",
    ", so that all the surviving nodes have degree 2 or greater . by removing these nodes and computing the cyclic orientations in the cleaned graph , we can still generate solutions for the original graph by using both orientations of the unique incident edge to each dead - end , as emphasized by the following lemma , whose proof is straightforward .",
    "let @xmath9 be a graph , @xmath45 a dead - end and @xmath46 its unique incident edge .",
    "let @xmath47 be the graph @xmath9 without @xmath45 and the edge @xmath46 .",
    "the set of all the cyclic orientations of @xmath9 is composed by the orientations @xmath48 and @xmath49 , for all the cyclic orientations @xmath50 of @xmath47 .",
    "[ lem : deadends ]    \\(1 ) this is trivial , as adding an edge to a cyclic graph can not make it acyclic ; since @xmath47 was obtained by removing @xmath46 from @xmath9 , orienting the edge and adding it to to @xmath51 will indeed yield an orientation @xmath10 of @xmath9.(2 ) if this was false , then there would exist a cyclic orientation @xmath10 that can not be obtained by adding @xmath52 or @xmath53 to a cyclic orientation @xmath51 .",
    "this implies that @xmath10 is obtained by adding the edge @xmath52 or @xmath53 to an _ acyclic _ orientation @xmath51 of @xmath47 .",
    "as @xmath54 has degree 1 , any cycle in @xmath9 can not involve the node @xmath54 or the edge @xmath46 , so any cycle in @xmath10 was already present in @xmath51 .",
    "hence @xmath51 must be cyclic , a contradiction .",
    "the dead - end removal can be done by performing a dfs recursive traversal of @xmath9 , starting from an arbitrary node @xmath55 . every time a node of degree 1 is visited , it is removed from the graph .",
    "when the recursion ends in a node , the latter is removed if all of its neighbors have been removed except one ( which is its parent in the dfs tree ) .",
    "finally , when the traversal ends , it might be that the node from which we started has degree 1 . to complete the process ,",
    "if @xmath55 has now degree 1 , we remove it from the graph .",
    "the dfs of @xmath9 and the removal of its dead - ends can be done in @xmath3 .",
    "the rationale for removing dead - ends is to have shorter cycles : for example , consider a `` necklace '' graph with @xmath0 nodes , for @xmath0 even , such that @xmath56 nodes form a cycle , and the remaining @xmath56 nodes have degree  1 and are attached to one of the nodes in the cycle , such that each node in the cycle has degree  3 and is connected to one node of degree 1 . with the removal of dead - ends ,",
    "the cycle has only nodes of degree  2 and can be compressed as discussed in the next paragraph .",
    "[ [ chain - compression . ] ] * chain compression . * + + + + + + + + + + + + + + + + + + + +    it consists in finding all the maximal paths @xmath57 where @xmath58 has degree 2 ( with @xmath59 ) , and replacing each of them , called _ chain _",
    ", with just one edge , called _",
    "chain edge_. it is easy to see that this task can be accomplished in @xmath3 time by traversing the graph @xmath9 in a dfs fashion from a node of degree @xmath60 .",
    "the output is an undirected connected multigraph @xmath34 , where @xmath61 are the nodes of @xmath12 whose degree is @xmath60 , and @xmath37 are the chain edges plus all the edges in @xmath14 which are not part of a chain . with @xmath62 nodes can be handled separately . ]",
    "the latter ones are called simple edges to distinguish them from the chain edges . in the rest of the paper , @xmath36 will be seen as a multigraph where @xmath63 and each of the edges has a label in \\{simple , chain } , since it might contain parallel edges or loops . for this , we define the concept of _ extended orientation _ as follows .",
    "_ for a multigraph @xmath34 having self loops and edges labeled as simple and chain , an _ extended orientation _",
    "@xmath64 is an orientation @xmath65 of its edge set @xmath37 : for any simple edge @xmath46 , exactly one direction between @xmath52 and @xmath53 holds ; for any chain edge @xmath46 , either is _ broken _ , or exactly one direction between @xmath52 and @xmath53 holds .",
    "a directed cycle in @xmath66 can not contain a broken edge .",
    "_    broken edges correspond to chain edges that , when expanded as edges of @xmath9 , do not have an orientation as a directed path .",
    "this means that they can not be traversed in either direction .",
    "note that this situation can not happen for simple edges .",
    "the following lemma holds .",
    "[ lem : ext ] if we have an algorithm that list all the extended cyclic orientations of @xmath34 with delay @xmath67 , for some @xmath68 , then we have an algorithm that lists all the acyclic orientations of the graph @xmath6 with delay @xmath69 .    for each extended cyclic orientations",
    "@xmath66 we return a set @xmath70 of cyclic orientations of @xmath9 : any edge @xmath71 of @xmath66 maintains the same direction specified by @xmath66 in all the solutions in @xmath70 ; for each chain @xmath72 of @xmath66 , we consider the edges corresponding to @xmath72 in @xmath9 , say @xmath73 : if @xmath72 has a direction in @xmath66 , the same direction of @xmath72 is assigned to all the edges @xmath74 in all the solutions in @xmath70 ; if @xmath72 has no direction assigned , i.e. _ broken _ , we have to consider all the possible @xmath75 ways of making the path @xmath73 broken ( these are all the possible ways of directing the edges except the only two directing a path ) .",
    "all the solutions in @xmath70 differ for the way they replace the chain edges .",
    "getting extended cyclic orientations in @xmath67 delay , iterating over all the chain edges @xmath72 , and iterating over all the corresponding edges of @xmath72 assigning the specified directions as explained above , we return acyclic orientations of the graph @xmath6 with delay @xmath69 .",
    "lemma [ lem : ext ] allows us to concentrate on extended cyclic orientations of the labeled multigraph @xmath36 rather than on cyclic orientations of @xmath9 .",
    "conceptually , we have to assign binary values ( the orientation ) to simple edges and ternary values ( the orientation or broken ) to chain edges .",
    "if we complicate the problem on one side by introducing these multigraphs with chain edges , we have a relevant benefit on the other side , as shown next .",
    "given the labeled multigraph obtained in section  [ sec : rec ] , namely @xmath34 , we perform the following two steps .    1 .   * finding a log - hole . *",
    "find a _ logarithmically bounded hole _ ( hereafter , log - hole ) @xmath30 in @xmath34 : it is a chordless cycle whose length is either the _ girth _ of the graph ( i.e. the length of its shortest cycle ) or this length plus one",
    "removing the log - hole . *",
    "remove the edges in @xmath33 from @xmath36 , obtaining @xmath38 , where @xmath76 .      since @xmath36 is a multigraph with self - loops , a log - hole@xmath30 of @xmath36",
    "can potentially be a self - loop . in any case , the following well - known result holds .",
    "[ prop : girth ] let @xmath6 be a graph in which every node has degree at least @xmath77 .",
    "the girth of @xmath9 is @xmath78 .",
    "lemma  [ prop : girth ] means that the log - hole@xmath35 of @xmath36 has length at most @xmath79 , thus motivating our terminology .",
    "the log - hole@xmath35 can be found by finding the girth , that is performing a bfs on each node of the multigraph @xmath36 to identify the shortest cycle that contains that node , in time @xmath80 . by applying the algorithm in  @xcite , which easily extends to multigraphs",
    ", we compute @xmath35 in time @xmath81 : in this case , if chords are present in the found @xmath35 , in time @xmath82 we can check whether @xmath35 includes a smaller cycle and redefine @xmath35 accordingly .",
    "we now want to list all the cyclic orientations of the input graph @xmath9 . by lemma  [ lem : ext ]",
    "this is equivalent to listing the extended cyclic orientations of the corresponding labeled multigraph @xmath34 obtained from @xmath9 by dead - end removal and chain compression .",
    "we now show that the latter task can be done by suitably combining some orientations from the labeled multigraph @xmath38 and the log - hole@xmath30 using an algorithm that is organized as follows .    1 .   * finding extended orientations .",
    "* enumerate all extended orientations ( not necessarily cyclic ) @xmath83 of the multigraph @xmath40 .",
    "* putting back the log - hole .",
    "* for each listed @xmath84 , consider all the extended orientations @xmath85 of the log - hole@xmath35 such that @xmath86 contains a directed cycle , and obtain the extended cyclic orientations for the multigraph @xmath36 .",
    "this is now an easy task . for each edge",
    "@xmath46 in @xmath87 that is labeled as simple , both the directions @xmath52 and @xmath53 can be assigned ; if @xmath46 is labeled as chain , the directions @xmath52 and @xmath53 , and broken can be assigned .",
    "each combination of these decisions produces an extended orientation of @xmath88 .",
    "if there are @xmath89 simple edges and @xmath90 broken edges in @xmath40 , where @xmath91 , this generates all possible @xmath92 extended orientations .",
    "each of them can be easily listed in @xmath93 delay ( actually less , but this is not the dominant cost ) .      for each listed @xmath83",
    "we have to decide how to put back the edges of the cycle @xmath35 , namely , how to find the orientations of @xmath35 that create directed cycles .    given the cycle @xmath30 and @xmath94 , we call _ legal orientation _",
    "@xmath85 any extended orientation of @xmath35 such that the resulting multigraph @xmath95 is cyclic , where @xmath96 .",
    "the two following cases are possible .    1",
    ".   @xmath97 is cyclic . in this case",
    "each edge in @xmath33 can receive any direction , including broken if the edge is a chain edge : each combination of these assignments will produce a legal orientation that will be output .",
    "2 .   @xmath97 is acyclic . since @xmath35 is a cycle , there are at least two legal orientations obtained by orienting @xmath35 as a directed cycle clockwise and counterclockwise .",
    "moreover , adding just an oriented subset of edges @xmath98 to @xmath97 can create a cycle in @xmath97 : in this case , any orientation of the remaining edges of @xmath99 ( including broken for chain edges ) will clearly produce a legal orientation .    while the first case is immediate , the second case has to efficiently deal with the following problem .",
    "[ prob : reintegrate ] given @xmath83 acyclic and cycle @xmath35 , enumerate all the legal orientations @xmath85 of @xmath35 .    in order to solve problem  [ prob : reintegrate ]",
    ", we exploit the properties of @xmath35 . in particular , we compute the reachability matrix @xmath100 among all the nodes in @xmath101 , that is , for each pair @xmath102 of nodes in @xmath101 , @xmath103 is @xmath41 if @xmath45 can reach @xmath54 in the starting @xmath66 , @xmath104 otherwise .",
    "we say that @xmath100 is _ cyclic _ whether there exists a pair @xmath105 such that @xmath106 .",
    "this step can be done by performing a bfs in @xmath83 from each node in @xmath101 : by we have @xmath107 , and so the cost is @xmath108 time .",
    "deciding the orientation of the edges and the chain edges in @xmath33 is done with a ternary partition of the search space .",
    "namely , for each edge @xmath46 in @xmath33 ,",
    "if @xmath46 is simple we try the two possible direction assignments , while if it is a chain we also try the broken assignment . in order to avoid dead - end recursive calls , after each assignment we update the reachability matrix @xmath100 and perform the recursive call only if this partial direction assignment will produce at least a solution : both the update of @xmath100 and the dead - end check can be done in @xmath109 ( that is , the size of @xmath100 ) .    [ [ scheme - for - legal - orientations . ] ] * scheme for legal orientations . * + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the steps are shown by algorithm  [ alg : ternpart ] . at the beginning the reachability matrix @xmath100 is computed and is passed to the recursive routine ` legalorientations ` . at each step , @xmath110 is the partial legal orientation to be completed and @xmath111 is the set of broken edges declared so far . also , @xmath112 is the index of the next edge @xmath113 of the cycle @xmath35 , with @xmath114 ( we assume @xmath115 to close the cycle ) : if @xmath116 then all the edges of @xmath35 have been considered and we output the solution @xmath110 together with the list @xmath111 of broken edges in @xmath110 .",
    "each time the procedure is called we guarantee that the reachability matrix @xmath100 is updated .",
    "let @xmath46 be the next edge of @xmath35 to be considered : for each possible direction assignment @xmath52 or @xmath53 of this edge , we have to decide whether we will be able to complete the solution considering this assignment .",
    "this is done by trying to add the arc to the current solution .",
    "if there is already a cycle , clearly we can complete the solution .",
    "otherwise , we perform a _ reachability check _ on @xmath117 : it is still possible to create a directed cycle if and only if any two of the nodes in @xmath117 , say @xmath118 and @xmath119 satisfy @xmath120 or @xmath121 .",
    "this condition guarantees that a cycle will be created in the next calls , since we know there are edges in @xmath35 between @xmath118 and @xmath119 that can be oriented suitably .",
    "finally , when @xmath46 is a chain , the broken assignment is also considered : @xmath100 does not need to be updated as the broken edge does not change the reachability of @xmath83 .",
    "the reachability and cyclicity checks are done by updating and checking the reachability matrix @xmath100 ( and restoring @xmath100 when needed ) .",
    "updating @xmath100 when adding an arc @xmath52 corresponds to making @xmath54 , and all nodes reachable from @xmath54 , reachable from @xmath45 and nodes that can reach @xmath45 .",
    "this can be done by simply performing an ` or ` between the corresponding rows in time @xmath122 , since @xmath100 is @xmath123 .",
    "the reachability check can be done in @xmath109 time .",
    "the cyclicity ( checking whether a cycle has been already created ) takes the same amount of time by looking for a pair of nodes in @xmath124 @xmath125,@xmath126 such @xmath127 .",
    "algorithm  [ alg : ternpart ] outputs in @xmath128 time the first legal orientation of @xmath35 , and each of the remaining ones with @xmath129 delay .",
    "[ lem : delaytern ]    before calling the ` legalorientations ` procedure we have to compute the reachability matrix from scratch and this costs @xmath128 time . in the following",
    "we will bound the delay between two outputs returned by the ` legalorientations ` procedure .",
    "firstly , note that each call produces at least one solution .",
    "this is true when @xmath130 since we have two possible legal orientations of @xmath35 . before performing any call at depth @xmath112 , the caller function checks whether this will produce at least one solution .",
    "only calls that will produce at least one solution are then performed .",
    "this means that in the recursion tree , every internal node has at least a child and each leaf corresponds to a solution . hence the delay between any two consecutive solutions is bounded by the cost of a leaf - to - root path and the cost of a root - to - the - next - leaf path in the recursion tree induced by ` legalorientations ` .",
    "since the height of the recursion tree is @xmath82 , i.e. the edges of @xmath35 , and the cost of each recursion node is @xmath131 , we can conclude that the delay between any two consecutive solutions is bounded by @xmath129 . as it can be seen , it is crucial that the size of @xmath35 is ( poly)logarithmic .",
    "@xmath132 +    build the reachability matrix @xmath100 for the nodes of @xmath101 in @xmath83 + let @xmath133 , where @xmath115 by definition + execute @xmath134 +    1 .",
    "all the extended cyclic orientations of @xmath36 are output .",
    "2 .   only extended cyclic orientations of @xmath36 are output .",
    "3 .   there are no duplicates .    1 .",
    "any extended cyclic orientation @xmath66 can be seen as the union @xmath135 of @xmath97 and @xmath31 , which are two edge disjoint directed subgraphs .",
    "our algorithm enumerates all the extended orientations of @xmath40 , and , for each of them , all legal extended orientations @xmath31 : if there is a cycle in @xmath66 involving only edges in @xmath87 all the extended orientations of @xmath35 are legal ; otherwise just the extended orientations @xmath31 of @xmath35 whose arcs create a cycle in @xmath135 are legal .",
    "hence any extended cyclic orientation @xmath66 is output .",
    "any output solution is an extended orientation : each edge in @xmath40 and in @xmath35 has exactly one direction or is broken .",
    "moreover , any output solution contains at least a cycle : if there is not a cycle in @xmath40 , a cycle is created involving the edges in @xmath35 .",
    "all the extended orientations @xmath136 in output differ for at least an arc in @xmath137 or an arc in @xmath138 .",
    "hence there are no duplicate solutions .    as a result",
    ", we obtain delay @xmath139 .",
    "the extended cyclic orientations of @xmath34 can be enumerated with delay @xmath139 and space @xmath140 .",
    "[ lem : delay2 ]    finding extended orientations @xmath83 of @xmath40 can be done with @xmath93 delay . every time a new @xmath83 has been generated , we apply algorithm  [ alg : ternpart ] . by lemma",
    "[ lem : delaytern ] we output the first cyclic orientation @xmath66 of @xmath36 with delay @xmath141 and the remaining ones with delay @xmath129 . hence the maximum delay between any two consecutive solutions is @xmath142 .",
    "the space usage is linear in all the phases : in particular in algorithm  [ alg : ternpart ] the space is @xmath131 , because of the reachability matrix @xmath100 , which is smaller than @xmath140 .    applying and , and considering the setup cost in section  [ sec : setup ] ( @xmath143 and @xmath144 ) ,",
    "we can conclude as follows .",
    "[ the : delay ] algorithm  [ alg : structure ] lists all cyclic orientations of @xmath6 with setup cost @xmath145 , and delay @xmath146 .",
    "the space usage is @xmath147 memory cells .",
    "in this section , we show how to modify our approach to get a setup time equal to the delay , requiring space @xmath148 .    [",
    "the : absorb ] all cyclic orientations of @xmath6 can be listed with setup cost @xmath146 , delay @xmath146 , and space usage of @xmath148 memory cells .",
    "we use @xmath149 and @xmath150 for brevity .",
    "let @xmath151 be the following algorithm that takes @xmath152 time to generate @xmath0 solutions , each with @xmath2 delay , starting from any given cycle of size @xmath153 .",
    "this cycle is found by performing a bfs on an arbitrary node @xmath45 , and identifying the shortest cycle @xmath154 containing @xmath45 .",
    "note that @xmath154 is a log - holeas required .",
    "now , if @xmath155 , we stop the setup and run the algorithms in the previous sections setting @xmath156 . the case of interest in this section",
    "is when @xmath157 .",
    "we take a cyclic orientation @xmath158 of @xmath154 , and then @xmath0 arbitrary orientations of the edges in @xmath159 .",
    "the setup cost is @xmath3 time and we can easily output each solution in @xmath2 delay .",
    "we denote this set of @xmath0 solutions by @xmath160 .    also , let @xmath161 be the algorithm behind theorem  [ the : delay ] , with a setup cost of @xmath5 and @xmath2 delay ( i.e. algorithm  [ alg : structure ] ) .",
    "we denote the time taken by @xmath161 to list the first @xmath0 solutions , including the @xmath5 setup cost , by @xmath162 , and this set of @xmath0 solutions by @xmath163 .",
    "since @xmath160 and @xmath163 can have nonempty intersection , we want to avoid duplicates .",
    "we show how to obtain an algorithm @xmath164 that lists all the cyclic orientations without duplicates with @xmath2 setup cost and delay , using @xmath5 space . even though the delay cost of @xmath164 is larger than that of @xmath151 and @xmath161 by a constant factor , the asymptotic complexity is not affected by this constant , and remains @xmath2 .",
    "algorithm @xmath164 executes simultaneously and independently the two algorithms @xmath151 and @xmath161 .",
    "recall that these two algorithms take @xmath165 time in total to generate @xmath160 and @xmath163 with @xmath2 delay .",
    "however those in @xmath163 are produced after a setup cost of @xmath5 .",
    "hence @xmath164 slows down on purpose by a constant factor @xmath72 , thus requiring @xmath166 time : it has time to find the distinct solutions in @xmath167 and build a dictionary @xmath168 on the solutions in @xmath160 .",
    "( since an orientation can be represented as a binary string of length @xmath1 , a binary trie can be employed as dictionary @xmath168 , supporting each dictionary operation in @xmath3 time . ) during this time , @xmath164 outputs the @xmath0 solutions from @xmath160 with a delay of @xmath169 time each , while storing the rest of solutions of @xmath170 in a buffer @xmath171 .",
    "after @xmath166 time , the situation is the following : algorithm @xmath164 has output the @xmath0 solutions in @xmath160 with @xmath2 setup cost and delay .",
    "these solutions are stored in @xmath168 , so we can check for duplicates .",
    "we have buffered at most @xmath0 solutions of @xmath170 in @xmath171 .",
    "now the purpose of @xmath164 is to continue with algorithm @xmath161 alone , with @xmath2 delay per solution , avoiding duplicates .",
    "thus for each solution given by @xmath161 , algorithm @xmath164 suspends @xmath161 and waits so that each solution is output in @xmath172 time : if the solution is not in @xmath168 , @xmath164 outputs it ; otherwise @xmath164 extracts one solution from the buffer @xmath171 and outputs the latter instead . note that if there are still @xmath173 duplicates to handle in the future , then @xmath171 contains exactly @xmath173 solutions from @xmath170 ( and @xmath171 is empty when @xmath174 completes its execution ) .",
    "thus , @xmath164 never has to wait for a non - duplicated solution .",
    "the delay is the maximum between @xmath172 and the delay of @xmath161 , hence @xmath2 .",
    "the additional space is dominated by that of @xmath171 , namely , @xmath5 memory cells to store up to @xmath0 solutions .",
    "we also have an amortized cost using the lemma below , where @xmath175 and @xmath176 .",
    "listing all the extended cyclic orientations of @xmath34 with delay @xmath177 and setup cost @xmath178 implies that the average cost per solution is @xmath179 .",
    "[ lem : preproc ]    we perform a bfs on an arbitrary node @xmath45 , and identify the shortest cycle @xmath180 that contains @xmath45 .",
    "this costs @xmath3 time .",
    "note that @xmath180 is a hole ( i.e. it has no chords ) .",
    "note that a minimum cycle in @xmath36 either is @xmath154 or contains a node in @xmath181 : hence we perform all the bfss from each node in @xmath181 , as explained in  @xcite with an overall cost of @xmath182 .",
    "the number of extended orientations of @xmath36 is at least @xmath183 .",
    "our setup cost is @xmath178 , with @xmath184 , and the number of solutions is at least @xmath185 .",
    "the overall average cost per solution is at most @xmath186",
    "in this paper we considered the problem of efficiently enumerating cyclic orientations of graphs .",
    "the problem is interesting from a combinatorial and algorithmic point of view , as the fraction of cyclic orientations over all the possible orientations can be as small as 0 or very close to 1 .",
    "we provided an efficient algorithm to enumerate the solutions with delay @xmath2 and overall complexity @xmath187 , with @xmath21 being the number of solutions .",
    "t.  richardson .",
    "a discovery algorithm for directed cyclic graphs . in _ proceedings of the twelfth international conference on uncertainty in artificial intelligence _",
    ", uai96 , pages 454461 , san francisco , ca , usa , 1996 .",
    "morgan kaufmann publishers inc .",
    "p.  spirtes .",
    "directed cyclic graphical representations of feedback models . in _ proceedings of the eleventh conference on uncertainty in artificial intelligence _ ,",
    "uai95 , pages 491498 , san francisco , ca , usa , 1995 .",
    "morgan kaufmann publishers inc ."
  ],
  "abstract_text": [
    "<S> acyclic and cyclic orientations of an undirected graph have been widely studied for their importance : an orientation is acyclic if it assigns a direction to each edge so as to obtain a directed acyclic graph ( dag ) with the same vertex set ; it is cyclic otherwise . </S>",
    "<S> as far as we know , only the enumeration of acyclic orientations has been addressed in the literature . in this paper </S>",
    "<S> , we pose the problem of efficiently enumerating all the _ cyclic _ orientations of an undirected connected graph with @xmath0 vertices and @xmath1 edges , observing that it can not be solved using algorithmic techniques previously employed for enumerating acyclic orientations . </S>",
    "<S> we show that the problem is of independent interest from both combinatorial and algorithmic points of view , and that each cyclic orientation can be listed with @xmath2 delay time . </S>",
    "<S> space usage is @xmath3 with an additional setup cost of @xmath4 time before the enumeration begins , or @xmath5 with a setup cost of @xmath2 time . </S>"
  ]
}