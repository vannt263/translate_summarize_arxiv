{
  "article_text": [
    "cgh ( computer - generated - hologram ) has the ability to correctly record and reconstruct a light wave for a 3d object . electroholography@xcite",
    "using the cgh technique is attractive as a 3d display , because the cgh technique has remarkable features ; however , due to two significant problems , it is difficult to develop a practical 3d display system using electroholography .",
    "one problem is the need for an slm ( spatial light modulator ) that can display a cgh with large area and high resolution , because the resolution of a cgh is that of wavelength - order@xcite .",
    "the other problem is the enormous computational time required for generating a cgh .",
    "this paper focuses on this problem .    assuming that a 3d object is composed of @xmath3 point light sources , the formula for computing a cgh",
    "is expressed as : @xmath4 where , @xmath5 is the light intensity on a cgh , @xmath6 and @xmath7 are the coordinates for the cgh and a 3d object , @xmath8 is the light intensity of the 3d object , @xmath9 is the wavelength of the reference light , and @xmath10 , where @xmath11 is the sampling interval on the cgh plane .",
    "note that the coordinates @xmath12 and @xmath13 are normalized by @xmath11 .",
    "the computational complexity of the above formula is o(@xmath14 ) , where @xmath15 and @xmath16 are the horizontal and vertical sampling numbers of the cgh .",
    "this creates very enormous computational complexity .    to solve this problem ,",
    "several software approaches have been proposed : for example , recurrence approaches@xcite , and the look - up table methods@xcite .",
    "another approach to dramatically reduce the calculation time is the hardware approach , such as fpga ( field - programmable gate array ) and gpu ( graphics processing unit ) . we have designed and built special - purpose computers for holography using fpga technology , called horn ( holographic reconstruction ) @xcite .",
    "the fpga - based approaches showed excellent computational speed , however , the approach has the following restrictions : the high cost for developing the fpga board , long development time and technical know - how required for the fpga technology .",
    "gpu - based approaches have already been applied to the optics field .",
    "especially , cgh calculations @xcite and reconstruction calculations in digital holography @xcite are used to accelerate the calculation . in 2007",
    ", nvidia released a new architecture of gpu and its software development environment , cuda ( compute unified device architecture ) .",
    "using cuda allows us to program gpu easier than prior software developments , such as hlsl , cg language and so forth . since the release",
    ", many papers using nvidia gpu and cuda have been published in optics .    on the other hand , more recently in december 2009",
    ", a new gpu of the hd5000 series ( rv870 ) made by amd was released .",
    "the rv870 gpu has new architecture and its software environment , opencl ( open computing language ) .",
    "the architecture of the rv870 gpu is different from that of the nvidia gpu .",
    "the rv870 gpu has huge potential for fast calculation because one gpu chip has over 1,000 floating - point number processors , while one nvidia gpu chip has about 200 floating - point number processors .",
    "however , fast cgh calculation using the rv870 gpu has not been reported so far .    in this paper",
    ", we report fast cgh calculation using rv870 gpu and opencl . using these",
    ", we can calculate @xmath0 resolution of a cgh from a 3d object consisting of @xmath1 points in @xmath2 milli - seconds . to the best of our knowledge ,",
    "this article is the first report of using the rv870 gpu and opencl in optics .",
    "in addition , we compare the calculation performance between the rv870 gpu and the gpu made by nvidia .    in section 2 , we describe a fast cgh calculation on amd rv870 and opencl . in section 3 ,",
    "we show and compare the performance between the rv870 gpu and the gpu made by nvidia . in section 4",
    ", we conclude this work .",
    "the architecture of rv870 gpu is shown in fig.[fig : amd ] .",
    "the top level of the gpu consists of many simd ( single instruction multiple data ) engines .",
    "the simd engine has 16 thread processors ( tp ) and a shared memory , which is small and high - speed .",
    "in addition , the thread processor has four stream cores and one t - stream core .",
    "the stream core is a simple floating - point - number operation unit . and",
    ", the t - stream core also has a floating - point - number operation unit and special function unit .",
    "the special function unit can calculate special functions at high speed , such as trigonometric function , logarithm function and so on .",
    "the stream cores in the same simd engine operate by the same instructions ; therefore , the simd engine is similar to a simd processor .",
    "calculation on the gpu using opencl is executed using the following steps : ( 1 ) we initialize a gpu using opencl api ( application program interface ) functions . ( 2 ) we allocate the required amount of memory on a device memory in fig.[fig : amd ] .",
    "the device memory is large amount , but large latency access of memory .",
    "( 3 ) we send an input data to the device memory . ( 4 ) we send a kernel function from the host computer to the gpu .",
    "the kernel function is compiled to native code of gpu using the opencl compiler .",
    "the gpu executes the kernel function .",
    "( 5 ) we receive a calculated result from the device memory . ( 6 ) we release the device memory and gpu resources .",
    "figure [ fig : block_list](a ) shows the outline of the cgh calculation on the rv870 gpu with opencl .",
    "when calculating a cgh with the resolution of @xmath17 , we need to divide the cgh area into @xmath18s with the size of @xmath19 .",
    "therefore , the number of @xmath18s is @xmath20 .",
    "in addition , each @xmath18 has @xmath19 @xmath21s ( in the cuda , @xmath18 and @xmath21 are equivalent to @xmath22 and @xmath23 , respectively ) .",
    "each @xmath18 is allocated to simd engines and each @xmath21 simultaneously calculate eq.([eqn : cgh_basic ] ) by each stream core on an simd engine .    in fig.[fig :",
    "block_list](b ) , we show the kernel source code of the cgh calculation on the rv870 gpu with opencl .",
    "the source code is not optimized because we understand it easily .",
    "the optimization is shown in the next subsection .",
    "each @xmath18 and @xmath21 have the indices , group_id and local_id .",
    "the opencl functions , get_group_id(0 ) and get_group_id(1 ) , give us the horizontal and vertical indices of group_ids respectively .",
    "the opencl functions , get_local_id(0 ) and get_local_id(1 ) , also give us the horizontal and vertical indices of local_ids respectively .",
    "the arguments of the kernel function are a cgh data ( @xmath24 ) , an object data ( @xmath25 ) , the number of object points ( @xmath3 ) and the cgh size ( @xmath26 ) .",
    "an object data ( @xmath25 ) consists of the coordinates and the intensity as four float data ( @xmath27 ) . in lines 5 , 6 and 7 of the fig.[fig : block_list](b ) , the variables @xmath28 and @xmath29 calculate the coordinates ( @xmath30 on the cgh plane and @xmath31 calculates the address of the device memory for storing the calculation result @xmath32 . in lines 11 to 16 , a cgh point @xmath32 can be calculated by iterating for @xmath3 .",
    "although seeming to execute only one kernel , in fact , each stream core corresponding to @xmath33 and @xmath34 can perform the kernel in parallel .    when calculating a cgh with @xmath0 from a 3d object composed of @xmath1 points , the kernel with @xmath35 took about @xmath36 .",
    "the calculation speed of the kernel is slow .",
    "the previous source code is not optimized . in this section ,",
    "we optimize the previous source code to obtain more acceleration speed .",
    "figure [ fig : list2 ] shows the optimized kernel function from fig.[fig : block_list](b ) .    for more acceleration , we applied the following optimization techniques to the previous kernel : ( 1 ) recurrence algorithm ( 2 ) shared memory ( 3 ) loop unrolling ( 4 ) vectorization ( 5 ) native instruction .",
    "we proposed a fast cgh computation method using two recurrence formulas @xcite .",
    "our recurrence algorithm can compute the phase component of the cosine function in eq.([eqn : cgh_basic ] ) by two recurrence formulas .",
    "the recurrence algorithm is as follows :    @xmath37    here , we define @xmath38 , @xmath39 , @xmath40 .",
    "eventually , we can compute the phase @xmath41 at the next coordinate by the two recurrence formulas . for more details , see ref.@xcite    in lines 15 to 18 , we copy the object data from the device memory ( @xmath25 ) to a shared memory ( @xmath42 ) .",
    "the shared memory can store 256 object points at a time because the shared memory is small and high - speed .",
    "therefore , in the 13 , we must iterate @xmath43 times .",
    "note that @xmath44 means a barrier synchronization in line 18 .",
    "it is equivalent to the @xmath45 function in the cuda .",
    "loop unrolling is a well - known technique for optimizing a kernel function .",
    "it can be realized by reducing the number of iterations and replicating the body of the loop .",
    "benefits of the loop unrolling are the capable to decrease the loop frequency , branch instructions and conditional instructions . in the optimized kernel",
    ", we applied the loop unrolling to the loop of object points . in lines 20 to 51 in fig.[fig : list2 ] , we can perform four object points per one iteration of the loop . in addition , we vectorize the operations in the loop using the @xmath27 type , in order to handle four object points at a time . for example , in line 22 , we can calculate the four subtractions simultaneously .",
    "in the same way , the kernel can handle eight cgh points using the @xmath46 type at same time in lines 40 to 50 .    in lines 42 to 45",
    ", we used native cosine functions , instead of the normal cosine function shown in fig.[fig : block_list](b ) .",
    "the native cosine function can compute the fast cosine function using the hardware .",
    "table [ tbl : time ] shows a comparison of the calculation times for a cpu alone , nvidia gpu and an amd rv870 gpu .",
    "the size of the cgh is @xmath0 .",
    "the specifications of the personal computer are as follows : intel core 2 quad q6600 ( we used one core for the calculation ) , 2 gb of memory , microsoft windows xp sp3 .",
    "we used a geforce gtx260 as the nvidia gpu board and its software development environment of cuda version 2.3 , and a radeon hd5850 as the amd gpu board and its software development environment of streamsdk version2.0 .",
    "the radeon hd5850 gpu has 1,440 stream cores ( namely , 18 simd engines ) with the clock frequency of 725mhz .",
    "we can see that the optimization method for the amd gpu described in section [ sec : opt ] can perform more than ten times faster than that without the optimization . in the calculation times for the nvidia gpu in the table , we optimized the kernel for the nvidia gpu using the same method as described in section [ sec : opt ] : namely , recurrence algorithm , shared memory , loop unrolling , vectorization , native instruction . and",
    ", in the calculation times for the cpu alone in the table , we used eq.([eqn : cgh_rec ] ) for the cgh calculation .",
    "all calculation times using amd and nvidia are superior to those using the cpu alone .",
    "in addition , the amd gpu can calculate a cgh approximately two times faster than the nvidia gpu .",
    "[ tbl : time ]",
    "in this paper , we described a fast cgh calculation using an amd rv870 gpu with new architecture and its new software development environment , opencl .",
    "many fast cgh calculation methods using a nvidia gpu and the cuda have already been reported in optics field ; however , a study using the rv870 gpu has not been reported so far . to the best of our knowledge",
    ", this article is the first report of using the rv870 gpu and opencl in optics . using the rv870 gpu and opencl",
    ", we can calculate @xmath0 resolution of a cgh from a 3d object consisting of @xmath1 points in about 30 ms .",
    "the calculation speed can realize approximately two times faster than the nvidia gpu .",
    "this research was partially supported by the ministry of internal affairs and communications , strategic information and communications r&d promotion programme ( scope ) , 2009 , and japan society for the promotion of science ( jsps ) , grant - in - aid for scientific research ( c ) ( 21500094 ) .",
    "j. hahn , h. kim , y. lim , g. park and b. lee , `` wide viewing angle dynamic holographic stereogram with a curved array of spatial light modulators , '' opt .",
    "express , * 16 * , 1237212386 ( 2008 ) .",
    "y. takaki and n. okada , `` hologram generation by horizontal scanning of a high - speed spatial light modulator , '' appl .",
    ", * 48 * , 32563261 ( 2009 ) .",
    "h.yoshikawa , `` fast computation of fresnel holograms employing difference , '' opt.rev . , * 8 , * 331 ( 2000 ) .          h. yoshikawa , t. yamaguchi , and r. kitayama , `` real - time generation of full color image hologram with compact distance look - up table , '' osa topical meeting on digital holography and three - dimensional imaging 2009 , dwc4 ( 2009 )",
    ".      t. shimobaba , a. shiraki , n. masuda , and t. ito , `` electroholographic display unit for three - dimensional display by use of special - purpose computational chip for holography and reflective lcd panel , '' opt .",
    "express , * 13 * , 41964201 ( 2005 ) ."
  ],
  "abstract_text": [
    "<S> in this paper , we report fast calculation of a computer - generated - hologram using a new architecture of the hd5000 series gpu ( rv870 ) made by amd and its new software development environment , opencl . using a rv870 gpu and opencl </S>",
    "<S> , we can calculate @xmath0 resolution of a cgh from a 3d object consisting of @xmath1 points in @xmath2 milli - seconds . </S>",
    "<S> the calculation speed realizes a speed approximately two times faster than that of a gpu made by nvidia . </S>"
  ]
}