{
  "article_text": [
    "problems of reachability for dynamical systems have been extensively studied in the control literature for a long time .",
    "these problems have attracted renewed interest due to the emergence of new paradigms for switched and piecewise linear systems . this paper studies the problem for an affine system to reach a polytopic target set starting from inside a polytope in the state space .",
    "promising new ideas have appeared in the last five years in this area , and these ideas have stimulated deeper study of the many open questions that remain .",
    "an important gap in the literature is an exhaustive solution which covers the following sub - problems : explicit conditions for and an analysis of all states which can reach the target by open - loop control ; a method to approximate the open - loop reachable states when there are control constraints ; a systematic method to form a subdivision of the polytope into a set of reachable states and a set of failure states ; and finally a systematic procedure to synthesize a feedback control .",
    "while parts of this research program have been studied under various assumptions , no overall end - to - end solution has been presented .",
    "the reason is that the problem is generally extremely difficult and for certain steps , almost nothing is known about systematic procedures . in order to tackle this problem , rather than scoping back the problem specification as has typically been done before , we retain the complete problem statement but work with a specific class of systems : affine hypersurface systems which are @xmath0-dimensional affine systems with @xmath1 inputs .",
    "this class is our focus of study for the following reasons : ( 1 ) the problem of developing a systematic methodology to synthesize controllers for reachability specifications is essentially open , and beginning with a specific class of models provides much needed insight which can be built upon for generalization .",
    "the outcome of our study is that we are able to provide a complete solution for affine hypersurface systems . in",
    "so doing we introduce new techniques for triangulation and subdivision which can be adapted to the general problem .",
    "( 2 ) hypersurface systems include as a special case second - order mechanical systems , which are an important benchmark class for new control design methods .",
    "more generally , second - order systems have attracted extensive theoretical study due to their strong geometric properties .",
    "( see @xcite for a recent example ) .",
    "( 3 ) hypersurface systems have particularly simple reachable sets . by studying these systems , we separate the challenges inherent in dealing with complex reachable sets from the other challenges presented by dealing with control synthesis on a state space which is a polytope .",
    "the contributions of the paper are therefore squarely in the area of triangulations , subdivisions , and covers .",
    "what this suggests for future investigations is very important : if the designer is willing to relax the requirement to find the _ largest _ set of states in the polytope that can reach the target and instead he works with approximations which have reasonable properties , and where importantly , _",
    "reasonable properties are determined not based on traditional interpretations of hard and easy reachability computations , but based on how easily one can find triangulations and subdivisions to solve the synthesis problem _ , then one has a hope to develop systematic procedures which are provably successful .",
    "we will now outline the sub - problems which are addressed in this paper .",
    "some of these sub - problems simply involve packaging known results in an appropriate way .",
    "other results are novel and have never been studied before .",
    "the latter are especially in the area of forming triangulations and subdvisions adapted to a given control synthesis problem .",
    "the first sub - problem we address is : given a polytopic state space @xmath2 and a polytopic target set @xmath3 in the boundary of @xmath2 , characterize explicitly the set of states in @xmath2 which can reach the target by open - loop control .",
    "this result relies on well - known properties of the reachable sets of hypersurface systems .",
    "while it is a stepping stone to later results , its importance stems from the fact that knowing explicitly if a particular reachability problem is solvable by open - loop control gives a concrete metric against which to test our results : our synthesis methods should apply to any problem for which is a solution by open - loop control exists .",
    "the next sub - problem is to develop an algorithm which `` cuts off '' the failure states in a systematic way , so that the remaining set @xmath4 contains the original target set @xmath3 and is a polytope for which the open - loop reachability problem is solvable .",
    "it is shown that a systematic method to cut off the failure regions can be done with only two techniques based on the system structure .",
    "this algorithm can be easily adapted to include bounds on the control input . once it is known that for a polytopic subset of the state space all points can reach the target by open - loop control ,",
    "one then addresses questions of control synthesis , and this is the heart of the paper .",
    "we develop a set of triangulation and subdivision procedures which are organized hierarchically . by a hierarchical organization",
    "we mean the following . at level one of the hierarchy is a subdivision method which solves the given reachability problem on the polytope .",
    "when that subdivision method is applied , it leads to sub - reachability problems on sub - polytopes which are solved by subdivision methods at level two of the hierarchy , and so forth .",
    "what is important is that there are a finite number of levels and one can prove that the refinement by new subdivisions terminates .",
    "this contrasts with the view that one simply refines by arbitrary subdivisions selected by a computer program - a method that has no guarantee to terminate even of the problem is solvable by open - loop control .",
    "one of the challenges in developing these subdivision methods is to determine the simplest set of methods which can completely solve the problem .",
    "we present such a set , though it is by no means unique .",
    "we propose a five - level hierarchy :    1 .   for linear and affine systems , problems of reachability",
    "are closely tied to existence of equilibria .",
    "therefore , the first level is a subdivision along the hyperplane @xmath5 of the possible equilibria of the system ; namely those points in the state space for which there exists a control input to make the vector field exactly zero . 2 .",
    "the second level of the hierarchy is a subdivision of a polytope which has two possible target sets : a neighboring polytope and a target facet .",
    "the subdivision is in fact a _",
    "cover _ to be discussed further below , and is with respect to the boundary of the two reachability sets .",
    "the third level entails a subdivision with respect to @xmath3 the target set .",
    "in particular , it applies to the case when @xmath3 is not a facet of @xmath2 ( motivation for this is discussed in section  [ intro : motivate ] ) .",
    "two techniques are presented : one is a subdivision and the other is a cover .",
    "4 .   the fourth subdivision is a triangulation within a polytope whose interior does not intersect @xmath5 and it has a single target facet .",
    "the triangulation is determined using information about the dynamics on that polytope .",
    "the fifth subdivision is a triangulation within a simplex whose interior does not intersect @xmath5 and it has a single target facet .    in the remainder of the introduction",
    ", we review the relevant literature on control synthesis for reachability problems on simplices and polytopes . in section  [",
    "intro : motivate ] we give the context of the problem and from this arises the motivation and characteristics of our solution",
    ". section  [ intro : org ] presents notation and the organization of the remainder of the paper .",
    "while control problems of reaching target sets in the state space have been studied since the 1960 s , our formulation and approach arise from more recent investigations on affine and piecewise affine systems defined on simplices and polytopes .",
    "the first problem to be studied of this type was by luc habets and jan van schuppen @xcite in which they formulated the so - called control - to - facet problem .",
    "further results were given in @xcite .",
    "given an affine system , the problem is to synthesize an affine control to reach an exit facet of a simplex in finite time .",
    "necessary conditions called _ invariance conditions _ in the form of linear inequalities defined at the vertices of the simplex were presented which restrict the closed - loop vector field to point inside appropriately defined tangent cones of the simplex .",
    "a sufficient condition was also presented to ensure that all closed - loop trajectories exit the simplex .",
    "based on the invariance conditions , an elegant synthesis method was proposed to obtain an affine control @xmath6 to solve the problem . in @xcite the control - to - facet problem using affine controls for affine systems defined on simplices was improved ( to allow that trajectories need not exit the simplex at the first time they reach the exit facet ) , and more concise necessary and sufficient conditions were obtained .",
    "the new conditions consist of the original invariance conditions of @xcite combined with a _ flow condition _ which guarantees that all trajectories exit the simplex , or equivalently that the closed - loop system has no equilibria in the simplex .",
    "the control - to - facet problem for a polytope as well as hybrid systems was also studied in @xcite .",
    "the proposed method is to partition the state space into simplices , to form a discrete graph capturing the adjacency of simplices , and then to solve , via a dynamic programming algorithm , a sequence of control - to - facet problems .",
    "when the algorithm terminates successfully it is guaranteed to provide a piecewise affine controller solving the reachability problem .",
    "the problem of reachability with state constraints is related to the viability / capturability problem in viability theory , especially characterizing viability kernels with a target and viable - capture basins for differential inclusions .",
    "the concept of viability kernel with a target by a lipschitz set - valued map has been introduce and studied in @xcite : this is the subset of initial states in a constrained set from which at least one solution remains in the constrained set ( i.e. , is viable ) forever or reaches ( i.e. , captures ) a target in finite time before possibly violating the constraints .",
    "the set of initial states satisfying only the latter condition is called the viable - capture basin of the target . some abstract properties and characterizations of viability kernels and viable - capture basins of a target",
    "are further studied and provided in @xcite .",
    "a number of methods to construct piecewise affine feedbacks on polytopes for various control specifications such as stabilization , optimal control , and set invariance have already been developed .",
    "the recent text @xcite presents an overview of methods for set invariance , which can be viewed as the dual to the problem of reachability .",
    "piecewise affine systems have been the subject of a large number of papers .",
    "a small sampling of recent papers includes @xcite .",
    "several interesting applications of piecewise affine modeling have recently been explored .",
    "see for example @xcite .",
    "this paper considers the problem of reaching a target @xmath7 with state constraint in a set @xmath8 , denoted as @xmath9 .",
    "the motivation for this fundamental problem arises from a family of related reachability problems .",
    "two sample reachability problems are as follows .    1 .",
    "_ reach - avoid problem_. starting at any initial state in a bounded set @xmath10 , reach a target set @xmath11 while avoiding an unsafe region @xmath12 .",
    "the problem can be formulated as @xmath13 , where @xmath14 .",
    "a typical example of the problem is motion planning of multiple vehicles . 2 .",
    "_ temporal logic controller synthesis_. consider , for example , three areas of interest denoted by @xmath15 such that @xmath16 ( see figure  [ fig : ltl ] ) and the temporal logic specification @xmath17 , which is interpreted in natural language as : `` stay always in @xmath18 and visit @xmath19 , then stay in @xmath19 until it visits @xmath20 eventually . ''",
    "the problem can be thought of as two reachability problems @xmath21 and @xmath22 .",
    "this family of reachability problems motivates the particular features of the problem studied in the paper , in which each @xmath23 is a polytope and each target is a polytope in the boundary of @xmath23 .",
    "the dynamics in each @xmath23 may or may not be the same ( although we do not study the hybrid problem here ) .",
    "sub - reachability problems are sequenced in order to achieve a global specification .",
    "it may happen that a certain reachability problem fails for a particular polytope and one must restrict the polytope by cutting off failure regions .",
    "such restrictions would propagate to neighboring polytopes and reduce their feasible target sets .",
    "it would be extremely tedious to leave these interventions to the designer , and rather , an automated algorithm should resolve these failures .",
    "this justifies our choice to solve the reachability problem when the target is not a facet of a polytope .",
    "we use the following notation .",
    "let @xmath24 and @xmath25 denote the rank and the image of a matrix @xmath26 .",
    "let @xmath27 be a set .",
    "@xmath28 , @xmath29 , @xmath30 , and @xmath31 denote the interior of @xmath27 , the convex hull of @xmath27 , the vertices of @xmath27 , and the smallest affine space containing @xmath27 , respectively .",
    "let @xmath32 be another set .",
    "@xmath33 expresses the set difference .",
    "moreover , @xmath34 expresses the distance from a point @xmath35 to the set @xmath27 .",
    "finally , we let @xmath36 $ ] be the volume of an @xmath0-dimensional set @xmath37 .",
    "if @xmath37 is of dimension less than @xmath0 then @xmath36=0 $ ] .",
    "the paper is organized as follows . in section  [ sec : formulate ] we formulate the problems to be solved . in section  [ sec : reachpoly ]",
    "we characterize the set of states which can reach the target @xmath3 starting in a polytope @xmath2 .",
    "then in sections  [ sec : simplices ] and [ sec : controlpoly ] we show how to synthesize piecewise affine controls on simplices and polytopes , respectively , assuming the problem is solvable by open loop control . in section  [ sec : trianglewrtf ]",
    "we show how to subdivide a polytope with respect to a target set which is not a facet , and in section  [ sec : trianglewrto ] we show how to subdivide a polytope with respect to the set of possible equilibria of the system .",
    "let @xmath2 be an @xmath0-dimensional polytope in @xmath38 and consider an affine control system on @xmath2 , @xmath39 where @xmath40 , @xmath41 , @xmath42 and the control @xmath43 lives in the space of piecewise continuous functions .",
    "assuming that @xmath44 , we call @xmath45 an _ affine hypersurface system_. given a piecewise continuous function @xmath46 and an initial state @xmath47 , let @xmath48 denote the unique solution of @xmath45 starting from @xmath49 .    in order to precisely formulate our problem , we begin by defining two concepts .",
    "the first is that of reaching a target with constraint in a set , which is the analogue to the notion of capturability in viability theory @xcite .",
    "second , we define @xmath50-invariant sets . in viability theory",
    "such a set is called locally invariant relative to @xmath50 @xcite .",
    "let @xmath51 and @xmath52 be closed sets satisfying @xmath53 .    1 .",
    "[ def : pointbr ] a point @xmath54 can _ reach @xmath52 with constraint in @xmath50 _ , denoted by @xmath55 , if there exists a piecewise continuous control @xmath46 and @xmath56 satisfying @xmath57 and @xmath58 for all @xmath59 $ ] .",
    "otherwise , we say @xmath35 can not reach @xmath52 with constraint in @xmath50 , denoted by @xmath60 .",
    "[ def : setbr ] a set @xmath61 can _ reach @xmath52 with constraint in @xmath50 _ , denoted by @xmath62 , if @xmath63 for every @xmath64 .",
    "the _ maximal reachable set of @xmath52 in @xmath50 _ will be denoted by @xmath65 .",
    "[ def : invset ] for a closed set @xmath50 , a set @xmath66 is called _ @xmath50-invariant _ if for all @xmath67 and for all piecewise continuous functions @xmath46 , every trajectory @xmath68 in @xmath50 on an interval @xmath69 $ ] with @xmath70 or @xmath71 is in @xmath27 on the same time interval .",
    "the definition means that the trajectories can not leave @xmath27 before leaving @xmath50 .",
    "the following are elementary properties of @xmath50-invariant sets which can be obtained directly from the definition .",
    "[ lem : elem ] the union and intersection of two @xmath50-invariant sets are also @xmath50-invariant sets .",
    "the union of all points @xmath67 for which each trajectory segment @xmath68 is in @xmath27 for the same time it is in @xmath50 is the maximal @xmath50-invariant set in @xmath27 .",
    "the following result relates the set of states that can reach @xmath52 with constraint in @xmath50 to @xmath50-invariant sets .",
    "the proof is in the appendix .",
    "[ thm : ns ] @xmath72 if and only if no @xmath50-invariant set is in @xmath73 .",
    "now we introduce the assumptions on @xmath45 .",
    "let @xmath32 denote the @xmath1-dimensional subspace spanned by the column vectors of @xmath26 ( namely , @xmath74 , the image of @xmath26 ) .",
    "define @xmath75 when the pair @xmath76 is controllable it can be shown that @xmath5 is an affine space ( see also @xcite ) .",
    "notice that @xmath77 on @xmath78 can vanish for an appropriate choice of @xmath79 , so @xmath78 is the set of all possible equilibrium points of the system .",
    "we make the following standing assumptions until section  [ sec : trianglewrto ] .",
    "[ assum1 ]    * @xmath44 . *",
    "the pair @xmath76 is controllable .",
    "* @xmath80 . *",
    "the target set @xmath81 is an @xmath1-dimensional polytope on the boundary of @xmath2 .",
    "[ prob1 ] we are given @xmath45 such that assumption  [ assum1 ] holds .    *",
    "find necessary and sufficient conditions such that @xmath82 .",
    "* find @xmath83 , the maximal reachable set of @xmath3 in @xmath2 .",
    "* find a triangulation @xmath84 and a piecewise affine feedback such that @xmath85 .",
    "in this section , we focus on the open - loop reachability problem and the first aim is to find necessary and sufficient conditions for @xmath82 . the strategy is to isolate all @xmath2-invariant sets in @xmath86 . note that proofs of lemmas for this part can either be found in the appendix or we have omitted them in case they were direct logic arguments not adding insight for the reader .",
    "denote by @xmath87 the hyperplane parallel to @xmath32 and going through a point @xmath35 .",
    "let @xmath88 be the unit normal vector to @xmath32 satisfying @xmath89 for all @xmath90 .",
    "such @xmath88 always exists by our assumption that @xmath91 .",
    "let @xmath92 be a point in @xmath93 and @xmath94 a point in @xmath95 .",
    "define the closed half - spaces in @xmath2 @xmath96 also , for any @xmath97 , define @xmath98 and @xmath99 .",
    "finally , we introduce the set @xmath100 because @xmath101 , we know that for each initial condition in @xmath2 , all trajectories will only flow in one direction relative to hyperplane @xmath102 . in particular , the @xmath88-component of any trajectory , @xmath103 , is always non - increasing by the convention that @xmath104 , @xmath105 .",
    "now the points @xmath92 and @xmath94 mark the points in @xmath3 with minimum and maximum @xmath88 components .",
    "it is clear that if there is any @xmath47 with a @xmath88 component smaller than @xmath92 , then no @xmath68 can reach @xmath3 .",
    "the following lemma confirms this intuition by showing that @xmath106 and @xmath107 are @xmath2-invariant sets .",
    "[ lem1 ] let @xmath108 be a point in @xmath2 .",
    "the sets @xmath109 and @xmath110 are @xmath2-invariant .",
    "the previous discussion suggests that a first necessary condition for @xmath82 is that @xmath111 is empty .",
    "this is not quite right .",
    "there can be points @xmath112 which can still reach @xmath3 .",
    "this is the content of the next lemma .",
    "let @xmath113 be distinct points in @xmath114 and let @xmath115 be the line segment joining them .",
    "if @xmath116 and @xmath117 , then @xmath118 .",
    "in light of this , we define the following set : @xmath119 lemma  [ lem2 ] says that points in @xmath120 can reach @xmath3 , so these points should not be included in a candidate failure set .",
    "thus we arrive at our first necessary condition for @xmath82 : @xmath121 .",
    "figure  [ fig : ns ] shows a shaded region corresponding to failure of this condition .",
    "another failure leading to a second necessary condition is as follows .",
    "if @xmath122 , then it is on the boundary of @xmath2 and the instantaneous motion from this point is only along @xmath102 . if @xmath102 does not intersect the tangent cone of @xmath2 at @xmath49 , then the only way to avoid a trajectory leaving @xmath2 immediately is to place an equilibrium point at @xmath49 .",
    "the following lemma captures this situation by showing how @xmath2-invariant sets arise along @xmath5 .",
    "see the right side of figure  [ fig : ns ] .",
    "[ lem : faceinvariance ] let @xmath108 be a point in @xmath114 . if @xmath123 , then @xmath124 and @xmath125 are @xmath114-invariant .",
    "a more subtle argument is needed to show that our proposed conditions are also sufficient to solve the reachability problem .",
    "sufficiency relies are two properties : the system is controllable , so it has sufficient maneuverability on @xmath5 , and the following lemma which provides the required maneuverability off of @xmath5 .",
    "[ lem : line ] let @xmath126 and let @xmath115 be the line segment joining them . if @xmath127 and @xmath128 , then @xmath118 .",
    "[ thm : nointersection ] @xmath129  if and only if   ( a )  @xmath121 , and ( b )  @xmath130 .",
    "( @xmath131 ) first , suppose ( a ) does not hold .",
    "if @xmath132 , then @xmath107 is a @xmath114-invariant set by lemma  [ lem1 ] , and it is in @xmath133 , so the conclusion follows from proposition  [ thm : ns ] .",
    "instead , if @xmath134 , then @xmath135 . since ( a )",
    "does not hold , there is @xmath136 .",
    "for this point @xmath137 , so for any @xmath79 , @xmath138 .",
    "this implies any trajectory starting at @xmath108 immediately leaves @xmath2 .",
    "hence , @xmath139 .",
    "second , suppose ( b ) does not hold , i.e. @xmath140 .",
    "let @xmath141 and notice that @xmath142 .",
    "thus , @xmath143 . by lemma  [ lem : faceinvariance ]",
    "it follows that @xmath144 is @xmath114-invariant .",
    "in addition , from the assumption that @xmath145 , @xmath146 .",
    "the conclusion follows from proposition  [ thm : ns ] .",
    "( @xmath147 ) suppose conditions ( a ) and ( b ) hold .",
    "for a point @xmath148 , it is trivial that @xmath149",
    ".    let @xmath150 . by assumption ( a )",
    "@xmath151 or equivalently @xmath152 .",
    "consequently , there is a point @xmath153 satisfying @xmath154 , where @xmath155 is a sufficiently small neighborhood of @xmath92 . if @xmath81 is not in @xmath78 , such a point @xmath156 can be chosen not in @xmath78 .",
    "then these two points @xmath35 and @xmath156 satisfy the assumption in lemma  [ lem : line ] , so @xmath157 , where @xmath115 is the line segment joining @xmath35 and @xmath156 .",
    "clearly , @xmath115 is in @xmath114 as @xmath114 is convex .",
    "hence , @xmath158 .",
    "otherwise , suppose @xmath159 .",
    "it is easy to show that because @xmath76 is controllable , @xmath160 is not parallel to @xmath78 .",
    "it means we can select a control @xmath79 so that @xmath161 points outside of @xmath114 .",
    "thus , there is a sufficiently small @xmath162 such that @xmath163 is in @xmath164 .",
    "note that @xmath165 is continuous and @xmath166 , so there is a point @xmath167 satisfying @xmath168 and therefore @xmath169 .",
    "thus , @xmath170 by assumption .",
    "applying lemma  [ lem : line ] for the two points @xmath35 and @xmath108 leads to @xmath171 , where @xmath115 is the line segment in @xmath114 joining @xmath35 and @xmath108 . considering @xmath172 , we then have @xmath158 .    finally , let @xmath173 .",
    "clearly , @xmath35 is on the boundary of @xmath2 .",
    "if @xmath174 , then select a point @xmath175 and let @xmath79 be chosen such that @xmath176 , which is possible because both @xmath177 and @xmath178 are in @xmath25 .",
    "note that this vector field @xmath77 points inside the polytope @xmath114 .",
    "this implies the trajectory instantaneously enters the interior of @xmath114 , which is not in @xmath78 any more .",
    "then by the previous argument , it can be driven to reach @xmath81 through a line . otherwise , if @xmath179 , then the whole set @xmath180 is on the boundary of @xmath114 , and moreover it comprises either @xmath144 or @xmath93 . from condition ( b ) , @xmath181 and",
    "this implies @xmath182 . from condition ( a ) ,",
    "@xmath183 so @xmath184 , which implies @xmath185 . for both cases , we get @xmath186 .",
    "now we select a point @xmath187 .",
    "then these two points satisfy the assumption in lemma  [ lem2 ] .",
    "thus , it follows that @xmath188 , where @xmath115 is the line segment joining from @xmath35 to @xmath156 , and so @xmath158 .",
    "theorem  [ thm : nointersection ] gives necessary and sufficient conditions for the reachability problem @xmath189 .",
    "this result , in turn , can be tied to failure sets , apropos proposition  [ thm : ns ] , which are the @xmath114-invariant sets in @xmath133 : @xmath190    [ cor : nonintersect ] let @xmath191 . then @xmath192 .",
    "moreover , @xmath193 and @xmath194 .",
    "we have identified @xmath83 , the maximal reachable set of @xmath81 in @xmath114 .",
    "this set , in general , is not closed .",
    "this leads to difficulties with unbounded control effort and unbounded time to reach @xmath81 .",
    "consequently , once failure sets have been identified , it is desirable to remove them via a procedure that both well - approximates the maximal reachable set and also yields a closed @xmath0-dimensional polytope that can reach @xmath81 .",
    "the approach is to `` cut off '' failure sets from @xmath114 by one of two procedures .",
    "one procedure is for removing the failure @xmath195 by cutting along a hyperplane which is parallel to a slightly shifted version of @xmath32 .",
    "the second procedure is for removing @xmath196 by cutting exactly along a hyperplane parallel to @xmath32 .",
    "these cuts are chosen arbitrarily close to the failure sets and so that the remaining polytope has no failure sets .",
    "it should be noted that the following procedure can be easily adapted to convert explicit bounds on the controls to an appropriate @xmath197 .",
    "[ alg : practicalcut ] ( let @xmath198 be sufficiently small . )    1 .",
    "if @xmath199 , select affinely independent points @xmath200 in @xmath201 and also in the relative boundary of the facet containing @xmath3 , and then select points @xmath202 in @xmath203 such that @xmath204 is of dimension @xmath205 and @xmath206 .",
    "then divide @xmath114 along @xmath207 .",
    "if @xmath208 , select a point @xmath209 such that @xmath210 . then divide @xmath114 along @xmath211 .",
    "let @xmath212 , @xmath213 , and @xmath214 be the collection of sets after the application of the division rules in algorithm  [ alg : practicalcut ] , where @xmath212 contains @xmath215 , @xmath213 contains @xmath196 , and @xmath214 is the remainder . clearly , these three sets ( if not empty ) are @xmath0-dimensional polytopes and @xmath216",
    ". then we have the following corollary which follows directly from algorithm  [ alg : practicalcut ] and theorem  [ thm : nointersection ] .",
    "[ cor : practicalcut ]    1 .",
    "2 .   @xmath218 = 0 $ ] .",
    "3 .   for any @xmath219 , if @xmath158 there exists an @xmath198 such that @xmath220 .    consider the example in figure  [ fig : ce1 ] which illustrates the first step of algorithm  [ alg : practicalcut ] .",
    "suppose that there a failure set to reach @xmath3 along the red segment .",
    "if one were to cut only along points in @xmath221 which corresponds to the blue plane , then the failure set would not be cut off . instead ,",
    "if points in the relative boundary of the facet containing @xmath3 can be used , then this failure set can be removed .",
    "[ example1 ] a simple example is presented to illustrate the possible failure sets and how algorithm  [ alg : practicalcut ] cuts them off .",
    "consider the system @xmath222 it can be easily verified that @xmath223 , the @xmath224 axis , and that @xmath32 is just the @xmath225 axis .    [ ] [ ] [ 0.8]@xmath92 [ ] [ ] [ 0.8]@xmath94 [ ] [ ] [ 0.8]@xmath224 [ ] [ ] [ 0.8]@xmath225 [ ] [ ] [ 0.8]@xmath81 [ ] [ ] [ 0.8]@xmath78 [ ] [ ] [ 0.8]@xmath195 [ ] [ ] [ 0.8]@xmath196 [ ] [ ] [ 0.8]@xmath212 [ ] [ ] [ 0.8]@xmath213 [ ] [ ] [ 0.8]@xmath32 [ ] [ ] [ 0.8]@xmath88 [ ] [ ] [ 0.8]@xmath226 [ ] [ ] [ 0.8]@xmath214    suppose that the polytope @xmath114 and the target set @xmath81 are as shown in figure  [ fig : ex1 ] . the hyperplane @xmath78 touches the polytope but has empty intersection with its interior .",
    "we get @xmath227 which is the patterned region in figure  [ fig : ex1 ] ; and @xmath196 is just a point .",
    "@xmath228 is the set @xmath226 not including the boundary of @xmath195 and @xmath196 .",
    "this set is not closed .",
    "moreover , if an initial state @xmath229 approaches the boundary of @xmath195 , the control input @xmath230 tends to infinity in order to reach @xmath81 with constraint in @xmath114 . also , if @xmath229 approaches the boundary of @xmath196 , the time to reach @xmath81 tends to infinity . applying algorithm  [ alg : practicalcut ] ,",
    "a good closed @xmath197-approximation @xmath231 of @xmath226 is given on the right of figure  [ fig : ex1 ] .",
    "consider an @xmath0-dimensional simplex @xmath232 with vertices @xmath233 and facets @xmath234 ( the facet is indexed by the vertex not contained ) .",
    "let @xmath235 .",
    "[ prbm : ctf ] consider system ( [ eq : affinesystem ] ) defined on @xmath232 .",
    "find an affine feedback control @xmath236 such that for every @xmath237 there exist @xmath238 and @xmath239 satisfying :    1 .",
    "@xmath240 for all @xmath59 $ ] ; 2 .",
    "@xmath241 ; 3 .",
    "@xmath242 for all @xmath243 .    condition ( iii ) is interpreted to mean that the closed - loop dynamics on @xmath232 are extended to a neighborhood of @xmath232 .",
    "the _ invariance conditions _ for @xmath244 require that there exist @xmath245 such that : @xmath246    @xcite [ thm : linearsimplex ] given the system and an affine feedback @xmath247 , where @xmath248 , @xmath249 , and @xmath250 , the closed - loop system satisfies @xmath251 if and only if    1 .",
    "the invariance conditions hold",
    "there is no equilibrium in @xmath252 .",
    "theorem  [ thm : linearsimplex ] can not be used directly for our present work because it enforces that affine feedbacks be used .",
    "unfortunately , this class is not large enough if solvability of rcp by open - loop control is the starting point .",
    "the next result shows that for hypersurface systems on simplices , one sufficiently rich feedback class is piecewise affine feedbacks .",
    "the proof is in the appendix .",
    "@xcite [ prop : controlforsimplex ] if @xmath253 then there exists a piecewise affine state feedback @xmath254 , @xmath255 that also achieves @xmath253 .",
    "we now begin our investigation of state feedback synthesis on polytopes .",
    "we want to show that if @xmath256 using open - loop control then there exists a piecewise affine feedback solving the reachability problem .",
    "the idea is to triangulate the polytope , transform the reachability problem within a polytope into a set of reachability problems for simplices , and then devise appropriate piecewise affine controllers on each simplex using proposition  [ prop : controlforsimplex ] of the previous section .",
    "the triangulation must be performed properly otherwise the procedure may fail .",
    "first we present a lemma that aids in finding a proper triangulation .",
    "[ lem : extremepoint ] if @xmath129 , then there exists a vertex @xmath257 of @xmath114 in @xmath144 such that either @xmath258 or @xmath259 .",
    "suppose by contradiction that for any vertex @xmath260 we have @xmath261 and @xmath262 .",
    "note that @xmath263 for all vertices @xmath260 implies , by convexity , @xmath145 .",
    "moreover , since @xmath264 for all @xmath260 , it follows from the convexity of @xmath78 that @xmath265 .",
    "hence , by theorem  [ thm : nointersection ] , this contradicts @xmath256 .",
    "we review some concepts on triangulation @xcite .",
    "suppose @xmath266 is a finite set of points such that @xmath267 is @xmath0-dimensional .",
    "a _ subdivision _ of @xmath266 is a finite collection @xmath268 of @xmath0-dimensional polytopes such that the vertices of each @xmath269 are drawn from @xmath266 ; @xmath267 is the union of @xmath270 ; and @xmath271 ( @xmath272 ) is a common ( possibly empty ) face of @xmath269 and @xmath273 .",
    "a _ triangulation _ of @xmath266 is a subdivision in which each @xmath269 is a simplex . in the following",
    "we assume that @xmath3 is a facet of @xmath2 .    *",
    "basic triangulation of @xmath2 : * [ triangle1 ]    1 .",
    "select @xmath274 as in lemma  [ lem : extremepoint ] .",
    "2 .   triangulate each facet @xmath275 of @xmath114 .",
    "denote @xmath276 the triangulation for @xmath275 .",
    "3 .   let @xmath277 .",
    "[ lem : triangulation ] the collection @xmath278 is a triangulation of @xmath279 such that every simplex in @xmath278 contains @xmath257 as a vertex .    by construction , it is clear that every simplex @xmath280 contains @xmath257 as a vertex , the vertices of @xmath281 are drawn from @xmath279 , and @xmath282 ( @xmath283 ) is a common ( possibly empty ) face of @xmath281 and @xmath284 .",
    "next , we show that @xmath114 is the union of @xmath285 .",
    "let @xmath35 be a point in the union of @xmath285",
    ". then it must be in a simplex @xmath281 .",
    "thus , by convexity of @xmath114 , @xmath286 . on the other hand , let @xmath35 be a point in @xmath114 .",
    "draw a line through @xmath257 and @xmath35 .",
    "it intersects at a point @xmath156 with a facet ( say @xmath275 ) of @xmath114 that does not contain @xmath257 .",
    "it means there exists a simplex @xmath287 containing @xmath156 .",
    "so @xmath288 , one of the simplices in @xmath278 .",
    "the conclusion follows .",
    "now suppose we have a triangulation @xmath289 as above , and denote @xmath290 .",
    "we say @xmath281 and @xmath291 are _ adjacent _ ( denoted by @xmath292 ) if @xmath293 is a facet .",
    "a sequence @xmath294 is called a _ path _ to reach @xmath295 if @xmath296 and @xmath297 for each @xmath298 .",
    "the _ length _ of such a path is @xmath299 .",
    "we propose a greedy algorithm that orders simplices according to minimum @xmath88 component of exit vertices first .",
    "more precisely , at every iteration a pair @xmath300 is selected that minimizes the @xmath88-component of any vertex on the exit facet @xmath301 .",
    "if there is more than one pair achieving the minimum , select a pair which has the maximum number of exit vertices achieving the minimum . in the algorithm below @xmath302 and @xmath303 denote the finished and unfinished set of simplices , respectively , and let @xmath304    * greedy algorithm for path generation in @xmath278 : *    1 .",
    "initialization : @xmath305 , @xmath306 ; 2 .   while @xmath307 , choose @xmath308 such that @xmath309 , it achieves @xmath310 , and @xmath311 contains the maximum number of vertices in @xmath312 .",
    "then move @xmath313 from @xmath314 to @xmath315 .",
    "once the greedy algorithm has generated paths , the synthesis of a piecewise affine control is straightforward .",
    "see also @xcite .",
    "* piecewise affine synthesis : *    1 .",
    "let @xmath316 be a collection of paths to reach @xmath317 ; 2 .   find @xmath318 , that solves @xmath319 , where @xmath311 is the common facet of @xmath281 and the next simplex in the path ; 3 .   for all @xmath320 , let @xmath321 . if @xmath286 belongs to more than one simplex , set @xmath322 where @xmath323 is the index of a simplex that has the shortest path to reach @xmath317 .",
    "[ thm : controlforpolytope ] suppose that @xmath3 is a facet of @xmath2 .",
    "there exists a piecewise affine state feedback that achieves @xmath129 if and only if @xmath129 using open - loop control .",
    "the idea of the proof is to show that the path generation algorithm does not terminate until @xmath324 by showing that for the next selected pair @xmath325 , the reachability problem @xmath326 can be solved .",
    "this is done by applying theorem  [ thm : nointersection ] and verifying conditions ( a ) and ( b ) for the selected pair @xmath325 .",
    "the main effect of our selection of triangulation based on vertex @xmath327 is that condition ( b ) holds trivially for any such pair .",
    "the fact that condition ( a ) can be made to hold is the main feature of the greedy strategy with respect to @xmath88 .",
    "this strategy guarantees that the vertex @xmath328 not contained in the exit facet has a strictly larger @xmath88-component , and this means that failure set @xmath329 for @xmath313 .",
    "the proof now easily follows from these observations .",
    "( @xmath131 ) obvious . ( @xmath147 ) if the path generation algorithm terminates with @xmath330 then by straightforward dynamic programming arguments there exists a piecewise affine feedback control that achieves @xmath129 .",
    "it is therefore sufficient to show that if @xmath331 , there exists a pair @xmath325 such that @xmath332 is a facet and @xmath326 .",
    "consider any pair @xmath333 .",
    "we must verify conditions ( a ) and ( b ) of theorem  [ thm : nointersection ] to show @xmath334 .",
    "consider condition ( b ) .",
    "we have two observations about @xmath327 .",
    "first , from lemma  [ lem : triangulation ] , @xmath335 , @xmath336 , and therefore @xmath337 .",
    "second , @xmath338 implies @xmath339 . applying these two facts , condition ( b ) for @xmath326",
    "says that @xmath340 , and this is obviously true .",
    "so far we have shown that for any pair @xmath341 as above , condition ( b ) of theorem  [ thm : nointersection ] holds for the problem @xmath342 .",
    "now we will show that for the selected pair @xmath343 , condition ( a ) holds .",
    "let @xmath344 be the vertex of @xmath281 not in @xmath311 .",
    "let @xmath345 .",
    "there are three cases .    1 .",
    ". then condition ( a ) holds .",
    "2 .   suppose @xmath347 .",
    "also , we know @xmath348 from the assumption @xmath82 . by convexity , for every point @xmath156 on the line segment joining @xmath92 and @xmath344 , @xmath349",
    "however , @xmath350 and @xmath351 , which means the line segment contains a point @xmath156 on the boundary of @xmath352 and @xmath353 .",
    "this contradicts the choice of the pair @xmath354 that achieves @xmath310 .",
    "3 .   suppose @xmath355 .",
    "let @xmath356 be the set of vertices of @xmath311 that lie in @xmath312 . if @xmath357 then condition ( a ) holds and we are done . if not , it follows from the assumption @xmath129 that either @xmath358 or @xmath359 .",
    "for both cases we claim that @xmath360 belongs to some @xmath361 . for the former case",
    ", it is obvious since @xmath362 .",
    "for the latter case , suppose not .",
    "say a point @xmath363 does not belong to some @xmath364 .",
    "then since the union of sets in @xmath302 is a closed set , there exists a point @xmath365 near @xmath35 satisfying @xmath366 , and @xmath156 also does not belong to some @xmath361 .",
    "this contradicts the choice of the pair @xmath354 that achieves @xmath367",
    ". therefore @xmath368 belongs to some @xmath369 which implies it belongs to some facet @xmath370 with @xmath371 , where @xmath352 , @xmath372 , and @xmath373 has one more vertex , namely @xmath344 , in @xmath374 .",
    "this contradicts the choice of @xmath311 .",
    "consider again example  [ example1 ] .",
    "after applying algorithm  [ alg : practicalcut ] to cut the failure sets off , we know from corollary  [ cor : practicalcut ] that @xmath375 using open - loop control .",
    "we want to find a piecewise affine state feedback that achieves @xmath375 .",
    "denote the vertices of @xmath214 by @xmath376 in figure  [ fig : ex2 ] .",
    "it can be easily obtained that @xmath377 is the only vertex of @xmath214 satisfying the property of lemma  [ lem : extremepoint ] so @xmath378 . also , @xmath379 . by the proposed triangulation method",
    ", we obtain a triangulation @xmath380 as shown in figure  [ fig : ex2 ] . by applying theorem  [ thm : nointersection ] to each simplex ,",
    "it can be easily checked that @xmath381 , @xmath382 , and @xmath383 .",
    "thus , we can find a control to solve the reachability problem on each simplex ( based on proposition  [ prop : controlforsimplex ] ) and then we can construct a piecewise affine control which achieves @xmath375 .",
    "in this section we study how the previous results can be extended to solve the control synthesis problem if @xmath3 is not given as a facet of @xmath2 .",
    "if the designer has flexibility in modifying the given state constraints , then one perform a slight modification ( by pulling out @xmath3 ) so that @xmath3 is a facet of a larger polytope @xmath4 . however , this approach has two caveats : ( 1 ) the problem @xmath384 may not be solvable even if @xmath82 is ; ( 2 ) if @xmath2 is part of a larger subdivision of the state space , then possibly other polytopes in the subdivision must be modified .",
    "a more desirable procedure is to use a triangulation method that refines the given subdivision of the state space by splitting @xmath2 so that @xmath3 becomes a facet of one of the polytopes in the refined subdivision .",
    "this approach also has pitfalls , because if one does not refine the subdivision properly , failure sets may emerge even if @xmath82 by open - loop control . in this section",
    "we show one method ( among several ) to obtain a proper triangulation .",
    "let @xmath385 denote the facet of @xmath2 containing @xmath3 .",
    "first we consider a simple case when @xmath386 of lemma  [ lem : triangulation ] can be selected so that @xmath387 .",
    "see figure  [ fig : ill1 ] .",
    "* triangulation of @xmath2 with respect to @xmath3 : * [ triangulation2 ]    1 .",
    "select @xmath257 as in lemma  [ lem : extremepoint ] and so that @xmath388 .",
    "2 .   make a triangulation of @xmath389 such that the interior of each resulting simplex is either entirely in @xmath81 or not in @xmath81 .",
    "for the remaining facets @xmath275 of @xmath114 , make a triangulation of @xmath390 .",
    "denote @xmath391 the triangulation for @xmath275 .",
    "3 .   let @xmath277 .",
    "the first thing we notice is that nothing about the proof of lemma  [ lem : triangulation ] is specific to @xmath3 being a facet , so the lemma still holds for the new triangulation .",
    "also the proof of theorem  [ thm : controlforpolytope ] is unchanged since the essential property of @xmath386 ( namely lemma  [ lem : triangulation ] ) is still true .",
    "therefore , we have the following direct extension of theorem  [ thm : controlforpolytope ] .",
    "[ cor : fnotfacet1 ] suppose that @xmath3 is not a facet of @xmath2 and there exists @xmath386 as in lemma  [ lem : extremepoint ] such that @xmath387 .",
    "there exists a piecewise affine state feedback that achieves @xmath129 if and only if @xmath82 using open - loop control .",
    "when there does not exist @xmath388 , the problem is more complex because lemma  [ lem : triangulation ] breaks down .",
    "nevertheless , we would like to build upon our previous triangulation and control methods by appropriately subdividing @xmath2 .",
    "a natural idea would be to form @xmath392 , a polytope for which @xmath3 is a facet .",
    "there are two problems to be addressed .",
    "first , can @xmath393 have failure sets for the problem @xmath394 even if @xmath82 ?",
    "theorem  [ thm : nointersection ] tell us that @xmath395 and we observe that this condition is identical for any polytope with the same exit facet @xmath3 .",
    "therefore , condition ( a ) holds for @xmath394 .",
    "instead , it is condition ( b ) which is problematic because generally @xmath396 and equilibria can appear on @xmath397 when we try to solve @xmath394 .",
    "a more careful approach is needed , and inspiration is provided by the proof of theorem  [ thm : controlforpolytope ] : for any @xmath0-dimensional polytope @xmath398 with exit facet @xmath3 , if @xmath399 , then condition ( b ) automatically holds .",
    "see figure  [ fig : ill3 ] for an example .",
    "thus , we have the following .",
    "[ prop1 ] suppose there exists @xmath386 a vertex of @xmath3 such that @xmath400 .",
    "let @xmath401 be an @xmath0-dimensional polytope such that @xmath3 is a facet of @xmath402",
    ". then @xmath82 implies @xmath403 .",
    "consider condition ( b ) of theorem  [ thm : nointersection ] for @xmath403 .",
    "we have to show that @xmath404 .",
    "but @xmath400 implies @xmath405 , so condition ( b ) is obviously true .    for condition ( a ) , theorem  [ thm : nointersection ] tells us that @xmath406 and since @xmath407 and @xmath408 , condition ( a ) obviously holds for @xmath403 .",
    "proposition  [ prop1 ] gives some indication of how the polytope @xmath393 which has @xmath3 as a facet could be constructed .",
    "now we face the second problem .",
    "the set @xmath409 is of course not a polytope . how shall it be subdivided and what reachability problems need to be assigned to avoid new failure sets from appearing ?",
    "the problem is difficult due to the generality of the description of @xmath3 .",
    "however , the following proposition gives some indication of how other polytopes can be constructed which do not have @xmath3 as their exit facet .",
    "[ prop2 ] suppose there exists @xmath386 , a vertex of @xmath3 , such that @xmath400 .",
    "let @xmath410 be an @xmath0-dimensional polytope and let @xmath411 be an @xmath1-dimensional polytope which is a facet of @xmath402 .",
    "suppose there exist @xmath412 and @xmath413",
    ". then @xmath82 implies @xmath414 .    by the assumption @xmath415 and by the same argument as in proposition  [ prop1 ] ,",
    "condition ( b ) for @xmath416 obviously holds .",
    "consider condition ( a ) for @xmath82 .",
    "it says that @xmath417 .",
    "equivalently , @xmath418 and @xmath419 .",
    "because @xmath420 , this means @xmath421 and because @xmath422 , one obtains @xmath423 .",
    "thus condition ( a ) for @xmath424 holds .",
    "so the conclusion follows .",
    "we would like to apply propositions  [ prop1 ] and [ prop2 ] to solve the synthesis problem when @xmath3 is not a facet of @xmath2 and there exists a vertex of @xmath3 satisfying @xmath425 .",
    "we introduce an important new construct for synthesis of piecewise affine controllers . rather than using a subdivision of @xmath2",
    "we begin the design with a cover of @xmath2 , which later will be refined to a subdivision for control synthesis .",
    "cover _ of @xmath266 is a finite collection @xmath426 of @xmath0-dimensional polytopes such that the vertices of each @xmath269 are drawn from @xmath266 and @xmath267 is the union of @xmath427 .",
    "informally , a cover is a subdivision except that the sub - polytopes can intersect on their interiors .",
    "* cover of @xmath2 with respect to @xmath3 : * [ cover1 ]    1 .",
    "select @xmath257 a vertex of @xmath3 such that @xmath400 .",
    "2 .   construct any hyperplane that goes through points @xmath428 and @xmath257 , and partitions @xmath114 into two @xmath0-dimensional sub - polytopes @xmath429 and @xmath430 .",
    "3 .   define @xmath431 .",
    "4 .   define the cover @xmath432 .    by using this cover ,",
    "we obtain the following result .",
    "[ theorem1 ] suppose that @xmath3 is not a facet of @xmath2 and there exists @xmath386 , a vertex of @xmath3 , such that @xmath400 .",
    "there exists a piecewise affine state feedback that achieves @xmath129 if and only if @xmath82 using open - loop control .",
    "@xmath433 is an @xmath0-dimensional polytope in @xmath114 for which @xmath3 is a facet .",
    "also , @xmath400 , so by proposition  [ prop1 ] , @xmath434 .",
    "next , let @xmath435 and notice that @xmath436 and @xmath437 .",
    "so by proposition  [ prop2 ] , @xmath438 and @xmath439 .",
    "theorem  [ thm : controlforpolytope ] gives a piecewise affine control @xmath440 , @xmath441 , that achieves @xmath442 .",
    "and it gives @xmath443 and @xmath444 , that achieve @xmath445 and @xmath446 , respectively .",
    "since @xmath447 , it means that the controllers can drive all the states not in @xmath393 to @xmath393 .",
    "thus , the following controller @xmath448 achieves @xmath129 .",
    "finally , we are left with the case when @xmath81 is not a facet of @xmath114 , all vertices of @xmath2 satisfying lemma  [ lem : extremepoint ] are in @xmath449 but none of them is in @xmath81 , and moreover there are no vertices of @xmath3 in @xmath144 .",
    "see figure  [ fig : ill2 ] .",
    "fortunately , this case can be easily handled by our previous results , by observing that @xmath3 and @xmath144 are strongly separated so we can split @xmath2 into a sub - polytope which contains @xmath3 and satisfies theorem  [ theorem1 ] and another sub - polytope that does not contain @xmath3 but must be able to reach it .",
    "we have the following straightforward extension of theorem  [ theorem1 ] and main result of this section .",
    "[ theorem2 ] suppose that @xmath3 is not a facet of @xmath2 .",
    "there exists a piecewise affine state feedback that achieves @xmath129 if and only if @xmath82 using open - loop control .",
    "we only consider the case excluded by corollary  [ cor : fnotfacet1 ] and theorem  [ theorem1 ] as described above .",
    "consider the hyperplane @xmath450 that partitions @xmath2 into two sub - polytopes @xmath393 and @xmath451 , such that @xmath452 and @xmath453 is a vertex of @xmath3 satisfying @xmath454 ( see figure  [ fig : ill2 ] for an example ) . from theorem  [ theorem1",
    "] , we have that @xmath455 and from the assumption @xmath82 and theorem  [ thm : nointersection ] it can be verified that @xmath456 .",
    "so far we have studied reachability problems and control synthesis under the assumption @xmath457 . in order to solve the general problem",
    "when @xmath458 we want to partition @xmath2 along @xmath5 and apply the results of the previous sections .",
    "there are two related complications .",
    "first , it can happen that when we split @xmath2 along @xmath5 to form two polytopes , @xmath393 and @xmath451 , one of the two target sets @xmath459 , even if not empty , may no longer be an @xmath1-dimensional polytope .",
    "even if for example @xmath460 with the target of dimension less than @xmath1 , the control synthesis methods of the previous section do not apply .",
    "second , the same lower - dimensional reachability problem can arise even if we have not already partitioned along @xmath5 .",
    "therefore , we assume in the following that when we say @xmath129 , there does not exist a full - dimensional set of states in @xmath114 that must reach a lower - dimensional ( less than @xmath205 ) subset in @xmath3 in order to achieve @xmath256 .",
    "now we would like to propose a partition method which splits @xmath2 along @xmath5 into two polytopes @xmath393 and @xmath451 .",
    "each subpolytope @xmath461 will then have two possible target sets .",
    "one target is the original facet @xmath462 .",
    "a second target is @xmath463 .",
    "this second target captures the idea that some trajectories must cross over from one side of @xmath5 to the other before reaching @xmath3 .",
    "this means that a new reachability problem must be investigated which involves two targets .",
    "one could try to make a subdivision according to which target the points in @xmath461 can reach .",
    "however , this approach will generally require new techniques not already developed in the paper .",
    "we illustrate with an example .",
    "consider the 2d example as in fig .",
    "[ fig : ce3 ] .",
    "suppose there are two target sets @xmath464 and @xmath465 where @xmath466 .",
    "it can be checked that @xmath467 , but neither @xmath468 or @xmath469 holds .",
    "if we were to apply algorithm 1 to cut off the failure set for reaching @xmath464 , we would obtain the region on the left - side of the ( red ) dotted line ( parallel to @xmath102 ) . however , the approximate failure set to reach @xmath464 can not reach @xmath465 , no matter how small is @xmath197 , without crossing into the region that can reach @xmath464 .",
    "thus , if one insists on a true subdivision , the reachability problem would not be solvable using our feedback methods .",
    "on the other hand , @xmath470 and @xmath471 is a cover for @xmath2 , where @xmath470 is the right - side of the red line and @xmath472 is the left - side of the green line .    to most",
    "efficiently overcome the issue in the above example , we first subdivide @xmath2 along @xmath5 and then use a cover in each subpolytope according to two possible target sets .",
    "* cover of @xmath2 with respect to @xmath5 : * [ partition1 ] ( let @xmath162 be sufficiently small . )    1 .",
    "divide @xmath2 along @xmath5 to obtain @xmath393 and @xmath451 .",
    "2 .   if @xmath473 , compute @xmath474 , @xmath475 . otherwise @xmath476 .",
    "3 .   if @xmath477 , compute @xmath478 , @xmath475 , @xmath479 . otherwise @xmath480 .",
    "4 .   define the cover @xmath481 .",
    "[ thm : oinside ] suppose @xmath482 .",
    "there exists a piecewise affine state feedback that achieves @xmath129 if and only if @xmath483 using open - loop control .",
    "the main idea of the result is that when @xmath2 is partitioned along @xmath5 , there are only two types of points in each sub - polytope : those that reach @xmath3 while remaining in the sub - polytope , or those that cross over to the other polytope to then reach @xmath3 .",
    "the proof requires a technical lemma on reachability of two target sets , whose proof is in the appendix .",
    "[ lem : inclusion ] let @xmath484 and @xmath485 be two @xmath1-dimensional polytopes on the boundary of @xmath114 but not on a common hyperplane and assume @xmath101 . if @xmath486 , then there exists @xmath162 sufficiently small such that @xmath487 .",
    "( @xmath131 ) obvious .",
    "( @xmath147 )  we use the notation @xmath488 to mean open loop reachability with an @xmath1-dimensional target .",
    "we consider two cases .",
    "for the first case , suppose there exists one sub - polytope , say w.l.o.g .",
    "@xmath433 , satisfying @xmath489 .",
    "if , in addition , @xmath490 , then we are done .",
    "otherwise , find @xmath491 by the method above . also compute @xmath492 .",
    "now we know that if @xmath493 , then @xmath256 implies @xmath494 by our assumption , and we are done . instead , if @xmath495 then by lemma  [ lem : inclusion ] , @xmath496 .",
    "for the second case , suppose no @xmath497 satisfies @xmath498 .",
    "without loss of generality , suppose @xmath499 and @xmath500 .",
    "find @xmath491 , as above .",
    "note that @xmath491 may be empty . because @xmath82 , there exists @xmath501 sufficiently small so that @xmath502 and the states in @xmath451 that can not reach @xmath503 must be able to reach @xmath504 .",
    "therefore , we have @xmath505",
    ". compute @xmath506 by the method above .",
    "now we know that if @xmath507 , then @xmath508 implies @xmath509 by our assumption . instead , if @xmath510 then by lemma  [ lem : inclusion ] , @xmath511 . repeating the argument for @xmath393 , the result is obtained .",
    "we have presented methods of triangulation , subdivision , and covers for reachability and control synthesis for affine hypersurface systems .",
    "some unique features of this work are : ( 1 ) we begin with an analysis of open - loop reachability , and we do not impose what class of controls should be used to implement the reachability specifications . because of the structure of hypersurface systems , we then derive that piecewise affine feedbacks are a sufficiently rich class to solve such problems .",
    "( 2 ) we place emphasis on techniques of triangulation and subdivision , guided by the the principle that these can not be performed independently of control synthesis . in particular , we show how the flow conditions of a system provide critical information for triangulation , and this can be used to establish greedy dynamic programming algorithms which are guaranteed to outperform dynamic programming algorithms based on random triangulations of the polytopic state space : our algorithm always finds a solution when one exists via open - loop control .",
    "( 3 ) we introduce a technique of covers for forming partitions of the state space .",
    "this useful technique overcomes many technical problems with taking subdivisions .",
    "fortunately , it naturally leads to synthesis of piecewise affine feedbacks .",
    "we have concentrated on hypersurface systems because of their simple , well - understood reachable sets . to extend our ideas to general systems , a carefully weighed analysis of the tradeoff between the conservatism of reach set approximations and complexity of the resulting algorithms must be made .",
    "our work points in the direction of keeping the algorithms as simple as possible , by using the simplest possible partition methods which can guarantee successful termination of numerical procedures .",
    "our future work will explore these challenging problems .",
    "( @xmath131 ) assume that there exists an @xmath50-invariant set , say @xmath27 , in @xmath512 . for any @xmath67 ,",
    "let @xmath46 be any piecewise continuous function . then by definition  [ def : invset ]",
    "every trajectory in @xmath50 on an interval is also in @xmath27 on the same time interval .",
    "furthermore , since @xmath513 by assumption , it means @xmath514 .",
    "( @xmath147 ) assume it is not true that @xmath515 .",
    "then @xmath50 can be partitioned into two nonempty sets @xmath516 and @xmath517 , where @xmath62 and @xmath518 .",
    "it is easily seen that @xmath519 and @xmath520 .",
    "this also immediately implies that @xmath517 is an @xmath50-invariant set , since otherwise there would exist some trajectory @xmath68 with @xmath521 that reaches @xmath522 .",
    "also @xmath523 .",
    "this completes the proof .",
    "let @xmath8 and @xmath524 be two sets , @xmath525 be a set - valued map from @xmath524 to @xmath8 and @xmath526 be a real - valued function defined on @xmath527 .",
    "we consider the family of maximization problems @xmath528 which depend upon the parameter @xmath156 .",
    "the function @xmath529 is called the _",
    "marginal function_. a general discussion on continuity properties of marginal functions can be found in @xcite .",
    "here we focus on the case of linear affine functions and single out a useful consequence of lipschitz continuity .",
    "let @xmath530 where @xmath42 , @xmath531 , @xmath532 , and @xmath114 is a full dimensional polytope in @xmath38 .",
    "( in another form , @xmath114 can be written as @xmath533 , where @xmath534 , @xmath535 , and @xmath536 means less or equal componentwise . )",
    "the domain of the marginal function @xmath529 is given by @xmath537 .",
    "for any @xmath540 , it is clear that @xmath541 and @xmath542 are lower - dimensional polytopes in @xmath114 .",
    "let @xmath543 be the vertices of @xmath541 . for each @xmath544",
    ", let a point start moving from @xmath545 along the edges of @xmath114 .",
    "it first meets the hyperplane @xmath546 at a point , denoted by @xmath547 .",
    "then , @xmath547 must be a vertex of @xmath542 ( note that @xmath547 and @xmath548 may not be distinct ) .",
    "the path that the point goes through from @xmath545 to @xmath547 is composed of either a single edge or joint edges of @xmath114 ( see figure  [ fig : lipschitzproof ] for an illustration in 2d ) .",
    "firstly , if it is a single edge of @xmath114 , this edge can be algebraically represented by @xmath549 , where @xmath550 and @xmath551 are formed by the columns of @xmath552 with suitable order .",
    "since @xmath545 is on the edge and also on the hyperplane @xmath553 , it follows that @xmath554^{-1 } \\left [ \\begin{array}{c } e_{i1 } \\\\",
    "y_1 \\end{array } \\right].\\ ] ] for the same reason , we have @xmath555^{-1 } \\left [ \\begin{array}{c } e_{i1 } \\\\ y_2 \\end{array } \\right].\\ ] ] hence , @xmath556 , where @xmath557 only depends on @xmath552 and @xmath558 .",
    "secondly , if it is composed of joint edges , without loss of generality , say there are two connected edges since it has the same argument for the case with more than two edges .",
    "two edges are connected at a point , say @xmath559 , which lies between the hyperplanes @xmath553 and @xmath546 ( see figure  [ fig : lipschitzproof ] for an example ) .",
    "let the parallel hyperplane going through the point @xmath559 be @xmath560 .",
    "thus , @xmath561 $ ] . by the same argument above",
    ", it follows that @xmath562 and @xmath563 , where @xmath564 and @xmath565 depend on @xmath552 and @xmath558 . let @xmath566 .",
    "thus , we have @xmath567    next , we show that @xmath568 , where @xmath569 is a constant . we know",
    "that for any @xmath570 , there exists a @xmath571 satisfying @xmath572 . on the other hand ,",
    "the point @xmath224 can be written as a convex combination of the vertices of @xmath541 , i.e. , @xmath573 , where @xmath574 and @xmath575 .",
    "now consider the same convex combination of points @xmath576 , which is given by @xmath577 .",
    "notice that @xmath576 are vertices of @xmath542 as we showed before , so the point @xmath225 is in @xmath542 and therefore @xmath578 .",
    "then we deduce that @xmath579 recall that @xmath557 depends only on @xmath552 and @xmath558 .",
    "so there is an upper bound @xmath580 only depending on @xmath552 and @xmath558 such that @xmath581 for any @xmath582 .",
    "thus , let @xmath583 and we obtain @xmath584 .",
    "hence , it is locally lipschitz .",
    "let @xmath585 be the set - valued map @xmath586 .",
    "its domain is @xmath587 .",
    "we define the real - valued function @xmath588 by lemma  [ lem : lipschitz ] , the function @xmath589 is locally lipschitz .",
    "let @xmath590 be the solution of @xmath591 with initial state @xmath592 .",
    "since @xmath593 for all @xmath594 and @xmath595 , for some @xmath596 , we have @xmath597 .",
    "thus , we know @xmath598 for all @xmath599 if @xmath600 .",
    "now , consider any initial state @xmath601 and any piecewise continuous function @xmath46 .",
    "let @xmath602 $ ] be the trajectory segment defined in @xmath114 with initial condition @xmath49 and control input @xmath603 .",
    "introduce @xmath604 , @xmath605 $ ] .",
    "then we have @xmath606 notice that @xmath607 and @xmath608 .",
    "it implies that @xmath609 for @xmath610 $ ] .",
    "hence , we know @xmath611 ( or equivalently , @xmath612 ) from our construction of @xmath589 . by the comparison principle ( theorem 1.4.1 , @xcite )",
    "it follows that @xmath613 for @xmath614 $ ] .",
    "also , @xmath615 implies that @xmath616 , so @xmath617 .",
    "consequently , we obtain @xmath618 , which in turn implies @xmath619 for all @xmath610 $ ] , meaning that @xmath620 is @xmath114-invariant . following along the same lines , @xmath621 is @xmath114-invariant .      for any @xmath622 ,",
    "let @xmath623 where @xmath624 is any constant .",
    "note that @xmath625 implies @xmath626 , and by convexity we have @xmath627 , which implies @xmath628 .",
    "therefore , the above linear equation has a unique solution @xmath629 . then following along the same lines as for lemma  [ lem : line ]",
    ", it is obtained that @xmath118 .",
    "if @xmath630 for all @xmath631 , then from lemma  [ lem1 ] it follows that @xmath632 and @xmath633 are @xmath114-invariant . on the other hand , rewrite @xmath630 as @xmath634 .",
    "then @xmath635 for all @xmath631 , so again from lemma  [ lem1 ] we obtain @xmath636 and @xmath637 are @xmath114-invariant . by lemma  [ lem : elem ] ,",
    "@xmath638 and @xmath639 are @xmath114-invariant .",
    "the former set is exactly @xmath640 and the latter set is @xmath641 .",
    "since @xmath642 , one obtains @xmath643 .",
    "it implies that the stacked matrix @xmath644 $ ] is of full rank .",
    "then there is a unique solution @xmath629 and @xmath645 to the linear equation @xmath646 for a given point @xmath622 .",
    "moreover , from the assumption @xmath647 , we obtain that @xmath648 , @xmath649 and then by convexity we have @xmath650 , @xmath651 .",
    "so @xmath652 .",
    "this together with @xmath643 leads to @xmath653 , @xmath651 . applying @xmath629 ,",
    "the resulting closed - loop system is @xmath654 .",
    "thus , the trajectory remains in @xmath115 .",
    "moreover , in the compact set @xmath115 , @xmath645 is bounded away from zero .",
    "so @xmath655 for some @xmath656 , which implies that the trajectory starting from @xmath108 reaches @xmath156 in finite time .",
    "first , we consider the case that @xmath661 .",
    "for this , we discuss two situations depending on @xmath662 or @xmath663 .",
    "( note that it is impossible to have @xmath664 by theorem  [ thm : nointersection](a ) since @xmath253 . )",
    "\\(i ) if @xmath662 , then there is a point @xmath665 such that @xmath666 ( or equivalently @xmath667 ) .",
    "let @xmath668 where @xmath669 is a scalar to be determined .",
    "writing in a compact form , we have @xmath670\\left[\\begin{array}{c } u_i \\\\ \\lambda \\end{array } \\right ] = av_i+a.\\ ] ] note that @xmath671 , so the matrix @xmath672 $ ] is of full rank and therefore the above equation has a unique solution @xmath673 and @xmath669 .",
    "also , notice that @xmath674 and that @xmath667 .",
    "thus , we have @xmath675 from ( [ eq : unotino ] ) . from the definition of simplices",
    ", it follows that @xmath676 and @xmath677 for any @xmath678 , where @xmath679 is a constant .",
    "this leads to @xmath680 , which further implies that there exists a @xmath673 attained from ( [ eq : unotino ] ) satisfying @xmath681    \\(ii ) if @xmath682 , then @xmath683 since otherwise it contradicts to @xmath684 inferred from @xmath253 by theorem  [ thm : nointersection ] .",
    "then for this , we claim that @xmath685 .",
    "( to see this , assume in contrast that @xmath686 .",
    "since @xmath661 , there is a point @xmath156 on the line segment joining @xmath344 and @xmath545 and also in a small neighborhood of @xmath545 , satisfying @xmath687 and @xmath688 .",
    "it contradicts to @xmath684 again . )",
    "consequently , there is a point @xmath665 such that @xmath689 .",
    "let @xmath690 where @xmath669 is a scalar to be determined .",
    "following along the same lines as above , there exists a @xmath673 attained from ( [ eq : u - v0-notino ] ) satisfying @xmath691      \\(i ) if @xmath695 , then there is a @xmath696 such that @xmath697 .",
    "let @xmath698 where @xmath624 is an arbitrary constant .",
    "note that @xmath699 by this choice and that @xmath700 ( due to @xmath692 ) , so there is a @xmath673 satisfying the equation above . on the other hand , from the definition of simplices",
    ", it follows that @xmath701 for any @xmath702 .",
    "thus , there exists a @xmath673 attained from ( [ eq : uino ] ) satisfying @xmath703 in addition , for this @xmath704 , there has to be a facet @xmath705 not containing @xmath704 , where @xmath706 .",
    "thus , we have @xmath707 and therefore @xmath708    \\(ii ) if @xmath709 , then we claim that @xmath88 together any @xmath205 vectors from @xmath710 are linearly independent .",
    "( to this end , assume it is not true . without loss of generality , we suppose that @xmath88 and @xmath711 are linearly dependent . then @xmath88 can be written as @xmath712 .",
    "thus , @xmath713 note that @xmath714 for any @xmath715 , so @xmath716 and @xmath717 , a contradiction . ) since @xmath718 and @xmath719 in this case , from theorem  [ thm : nointersection ] we have @xmath720 .",
    "let @xmath721 be a scalar .",
    "since @xmath88 and @xmath722 are linear independent , there is a unique solution to the following linear equation @xmath723 moreover , note that @xmath724 implies @xmath725 and that @xmath692 implies @xmath700 .",
    "so there exists a @xmath726 satisfying @xmath727 , which further implies that @xmath728      note that once the control inputs @xmath729 at corresponding vertices @xmath730 are found , an affine control @xmath236 can be uniquely constructed by solving the equation @xmath731 = \\left[\\begin{array}{cc } f & g \\end{array } \\right ] \\left[\\begin{array}{ccc } v_0 & \\cdots & v_n \\\\ 1 & \\cdots & 1 \\end{array } \\right].\\ ] ] now we examine three cases to synthesize the feedback .    first , consider the case when @xmath732 .",
    "select the control inputs @xmath733 satisfying the invariance condition and construct the affine control @xmath734 from  ( [ eq : lacontroller ] ) . with this choice of control",
    ", we have shown that ( [ eq : flowino ] ) also holds for every vertex @xmath692 . since @xmath735 ,",
    "one obtains that @xmath736 is the convex hull of these vertices in @xmath78 . by convexity",
    ", it follows from ( [ eq : flowino ] ) that @xmath737 for any @xmath35 in @xmath736 .",
    "recall that the possible equilibria of the closed - loop system lie in @xmath78 .",
    "so it implies that no equilibrium of the closed - loop system is in @xmath232 .",
    "therefore , by theorem  [ thm : linearsimplex ] , the affine control @xmath738 solves problem  [ prbm : ctf ] and therefore achieves @xmath739 .",
    "second , consider the case when @xmath740 and @xmath741 . select the control inputs @xmath729 satisfying the invariance condition and construct the affine control @xmath734 from  ( [ eq : lacontroller ] ) . we know",
    "@xmath720 and there is a vertex @xmath742 not in @xmath78 . from ( [ eq : restrict - ino ] ) , we have @xmath743 for every @xmath692 since @xmath744 . following along the same lines as above , by theorem  [ thm : linearsimplex ] ,",
    "an affine control @xmath738 solves problem  [ prbm : ctf ] and therefore achieves @xmath253 .",
    "finally , consider the case when @xmath709 and @xmath745 . by theorem  [ thm : nointersection ] @xmath32 is not parallel to @xmath78 , which implies @xmath746 .",
    "so we can pick a point @xmath747 on the line segment joining @xmath657 and @xmath344 satisfying @xmath748 .",
    "the simplex @xmath232 is then partitioned into two simplices , @xmath749 and @xmath750 , along the hyperplane containing @xmath747 and the vertices in @xmath751 .",
    "see figure  [ fig : pwa ] for an example",
    ".      note that in this case @xmath78 is the hyperplane containing @xmath752 , so @xmath747 and @xmath344 are not in @xmath78 .",
    "let @xmath753 be the common facet of @xmath749 and @xmath750 . for @xmath749 ,",
    "we know @xmath754 and @xmath755 is not in @xmath756 .",
    "hence , from the second case above , there exists an affine feedback @xmath757 that achieves @xmath758 . for @xmath750",
    ", we have @xmath759 .",
    "so from the first case above , there exists an affine feedback @xmath760 that achieves @xmath761 . in total",
    ", the feedback @xmath762 achieves @xmath253 .",
    "we first claim that if @xmath767 then @xmath768 for @xmath479 . to see this ,",
    "suppose that @xmath769 .",
    "then it follows from  ( [ eq : failuresets2 ] ) that @xmath770 . also for same reason",
    ", @xmath767 implies @xmath771 .",
    "it means @xmath144 is a failure set to reach @xmath772 , a contradiction to @xmath773 .",
    "second , we claim that if @xmath774 then @xmath775 for @xmath479 .",
    "suppose instead that both sets are not empty .",
    "then from  ( [ eq : failuresets1 ] ) , there is a point @xmath776 that belongs to both @xmath777 and @xmath778 .",
    "so this point can not reach @xmath779 , a contradiction , too .",
    "third , we claim that @xmath780 for @xmath781 .",
    "note that @xmath782 , so if there is a @xmath783 such that @xmath784 , then it is clear from  ( [ eq : failuresets1 ] ) that @xmath785 . instead",
    "if for all @xmath786 , @xmath787 , then we know @xmath788 . so @xmath144 is of @xmath1-dimension that is clearly parallel to @xmath102 .",
    "notice that @xmath5 is not parallel to @xmath102 from the controllability assumption .",
    "hence , @xmath789 , which implies @xmath790 from  ( [ eq : failuresets2 ] ) .",
    "so the conclusion follows .",
    "now we come to prove that @xmath487 .",
    "let @xmath791 and @xmath792 ( @xmath763 ) be the over - approximations of @xmath764 and @xmath765 obtained by applying algorithm  [ alg : practicalcut ] .",
    "consider a point @xmath793 if it exists .",
    "then @xmath35 is either in @xmath794 or in @xmath795 .",
    "consider the first case when @xmath796 .",
    "that means , @xmath797 .",
    "thus by our first claim , we get @xmath798 . moreover , by our third claim that @xmath799 , we know for sufficiently small @xmath197 , @xmath800 . thus @xmath801 and it must be in @xmath802 .",
    "consider now the second case when @xmath803 .",
    "that means , @xmath804 .",
    "then by our second claim , we obtain that @xmath805 .",
    "moreover , since @xmath806 , then by the same argument as above , we know the point @xmath35 has to be in @xmath802 .",
    "habets and j.h .",
    "van schuppen .",
    "control of piecewise - linear hybrid systems on simplices and rectangles , in : m.d .",
    "di benedetto and a.l .",
    "sangiovanni - vincentelli ( eds . ) _ hybrid systems : computation and control , lecture notes in computer science_. springer verlag , vol . 2034 , pp .",
    "261274 , 2001 .",
    "g. nenninger , g. frehse , and v. krebs .",
    "reachability analysis and control of a special class of hybrid systems , in _ modelling , analysis and design of hybrid systems_. s. engell , g. frehse , and e. schnieder , eds .",
    "springer - verlag , 2002 , pp ."
  ],
  "abstract_text": [
    "<S> this paper studies the problem for an affine hypersurface system to reach a polytopic target set starting from inside a polytope in the state space . </S>",
    "<S> we present an exhaustive solution which begins with a characterization of states which can reach the target by open - loop control and concludes with a systematic procedure to synthesize a feedback control . </S>",
    "<S> our emphasis is on methods of subdivision , triangulation , and covers which explicitly account for the capabilities of the control system . </S>",
    "<S> in contrast with previous literature , the partition methods are guaranteed to yield a correct feedback synthesis , assuming the problem is solvable by open - loop control . </S>"
  ]
}