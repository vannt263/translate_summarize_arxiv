{
  "article_text": [
    "a _ software design pattern _ is not a finished design , it is a description or template that can be instanciated in order to be used in many different situations . in this paper , we propose _ inference system patterns _ that can be instanciated with monads or comonads in order to be used for proving properties of different effects .    in order to formalize computational effects one can choose between types and effects systems @xcite , monads @xcite and their associated lawvere theories @xcite , comonads @xcite , or decorated logics @xcite . starting with moggi s seminal paper @xcite and its application to haskell @xcite",
    ", various papers deal with the effects arising from a monad , for instance @xcite .",
    "each of these approaches rely on some classification of the syntactic expressions according to their interaction with effects . in this paper",
    "we use decorated logics which , by extending this classification to equations , provide a proof system adapted to each effect .",
    "this paper presents equational - based logics for proving first order properties of programming languages involving effects .",
    "we propose two dual patterns , consisting in a language with an inference system , for building such a logic .",
    "the first pattern provides inference rules which can be interpreted in the cokleisli category of a comonad and the kleisli category of the associated monad . in a dual way",
    ", the second pattern provides inference rules which can be interpreted in the kleisli category of a monad and the cokleisli category of the associated comonad .",
    "the logics combine a three - levels effect system for terms consisting of pure terms and two other kinds of effects called observers / constructors and modifiers , and a two - levels system for strong and weak equations .",
    "each pattern provides generic rules for dealing with any comonad ( respectively monad ) , and it can be extended with specific rules for each effect .",
    "the paper presents two use cases : a language with state and a language with exceptions . for the language with state we use a comonadic semantics and",
    "we prove that the equational theory obtained is hilbert - post complete , which provides a new proof for a result in @xcite .",
    "for the language with exceptions we extend the standard monadic semantics in order to catch exceptions ; this relies on the duality between states and exceptions from  @xcite .",
    "we do not claim that each effect arises either from a comonad or from a monad , but this paper only deals with such effects . intuitively , an effect which observes features may arise from a comonad , while an effect which constructs features may arise from a monad @xcite .",
    "however , some interesting features in the comonad pattern stem from the well - known fact that each comonad determines a monad on its cokleisli category , and dually for the monad pattern .",
    "more precisely , on the monads side , let @xmath0 be a monad on a category @xmath1 and let @xmath2 be the kleisli category of @xmath0 on @xmath1 .",
    "then @xmath3 can be seen as the endofunctor of a comonad @xmath4 on @xmath2 , so that we may consider the cokleisli category @xmath5 of @xmath4 on @xmath2 .",
    "the canonical functors from @xmath1 to @xmath2 and from @xmath2 to @xmath5 give rise to a hierarchy of terms : pure terms in @xmath1 , constructors in @xmath2 , modifiers in @xmath5 .",
    "this corresponds to the three translations of a typed lambda calculus into a monadic language @xcite .    on the comonads side",
    ", we get a dual hierarchy : pure terms in @xmath1 , observers in @xmath2 , modifiers in @xmath5 .",
    "we instanciate these patterns with two fundamental examples of effects : state and exceptions .",
    "following @xcite , we consider that the states effect arise from the comonad @xmath6 ( where @xmath7 is the set of states ) , thus a decorated logic for states is built by extending the pattern for comonads .",
    "the comonad itself provides a decoration for the lookup operation , which observes the state , while the monad on its cokleisli category provides a decoration for the update operation .    following @xcite , we consider that the exceptions effect arise from the monad @xmath8 ( where @xmath9 is the set of exceptions ) , thus a decorated logic for exceptions is built by extending the pattern for monads .",
    "the monad itself provides a decoration for the raising operation , which constructs an exception , while the comonad on its kleisli category provides a decoration for the handling operation .",
    "in fact the decorated logic for exceptions is not exactly dual to the decorated logic for states if we assume that the intended interpretation takes place in a distributive category , like the category of sets , which is not codistributive .",
    "other effects would lead to other additional rules , but we have chosen to focus on two effects which are well known from various points of view . our goal is to enligthen the contributions of each approach : the annotation system from the types and effects systems @xcite , the major role of monads for some effects @xcite , and the dual role of comonads @xcite , as well as the flexibility of decorated logics @xcite .",
    "moreover , proofs in decorated logics can be checked with the coq proof assistant ; a library for states is available there : http://coqeffects.forge.imag.fr .    in this paper",
    "we focus on finite products and coproducts ; from a programming point of view this means that we are considering languages with @xmath10-ary operations and with case distinction , but without loops or higher - order functions . in a language with effects",
    "there is a well - known issue with @xmath10-ary operations : their interpretation may depend on the order of evaluation of their arguments . in this paper",
    "we are looking for languages with case distinction and with _ sequential products _ , which allows to force the order of evaluation of the arguments , whenever this is required .",
    "it is well known that ( co)monads fit very well with composition but require additional assumptions for being fully compatible with products and coproducts .",
    "this corresponds to the fact that in the patterns from section  [ sec : patterns ] , which are valid for any ( co)monad , the rules for products and coproducts hold only under some decoration constraints .",
    "however , such assumptions are satisfied for several ( co)monads .",
    "this is in particular the case for the state comonad and the exceptions monad .    in section  [ sec :",
    "patterns ] we describe the patterns for a comonad and for a monad .",
    "the first pattern is instanciated with the comonad for state in section  [ sec : states ] , and we prove the hilbert - post completeness of the decorated theory for state . in section  [ sec : exceptions ] we instanciate the second pattern to the monad for exceptions .",
    "in this section we define a grammar and an inference system for two logics @xmath11 and @xmath12 , then we define an interpretation of these logics in a category with a comonad and a monad , respectively .",
    "the logics @xmath11 and @xmath12 are called _ decorated _ logics because their grammar and inference rules are essentially the grammar and inference rules for a `` usual '' logic , namely the equational logic with conditionals ( denoted @xmath13 ) , together with _ decorations _ for the terms and for the equations .",
    "the decorations for the terms are similar to the _ annotations _ of the types and effects systems @xcite .",
    "decorated logics are introduced in @xcite in an abstract categorical framework , which will not be explicitly used in this paper .",
    "the grammar of the equational logic with conditionals is reminded in figure  [ fig : logeq - grammar ] .",
    "each term has a source type and a target type . as usual in categorical presentations of equational logic ,",
    "a term has precisely one source type , which can be a product type or the unit type .",
    "each equation relates two parallel terms , i.e. , two terms with the same source and the same target .",
    "this grammar will be extended with decorations    in order to get the grammar of the logics @xmath11 and @xmath12 .",
    "@xmath14}\\mid { \\mathit{in}}_{t , t,1}\\mid{\\mathit{in}}_{t , t,2}\\mid{[\\;]}_t\\mid   \\\\   \\textrm{equations : } & e::=   f\\equiv f    \\\\    \\hline \\end{array}\\ ] ]      the rules in figure  [ fig : pattern - rules ] are _ patterns _ , in the following sense : when the boxes in the rules are removed , we get usual rules for the logic @xmath13 , which may be interpreted in any bicartesian category .",
    "when the boxes are replaced by decorations , we get a logic which , according to the choice of decorations , may be interpreted in a bicartesian category with a comonad or a monad",
    ". there may be other ways to decorate the rules for @xmath13 , but this is beyond the scope of this paper .",
    "@xmath15[c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}f } \\qquad { \\textrm{(sym ) } } \\quad     \\dfrac{f^\\box { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}g^\\box}{g { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}f }   \\qquad { \\textrm{(trans ) } } \\quad     \\dfrac{f^\\box { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}g^\\box { \\;\\;}g^\\box { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}h^\\box}{f { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}h }   \\\\   { \\textrm{(repl ) } } \\quad     \\dfrac{f_1^\\box{{\\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}f_2^\\box\\colon a\\to b { \\;\\;}g^\\box\\colon b\\to c }      { g\\circ f_1 { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}g\\circ f_2 }   \\qquad { \\textrm{(subs ) } } \\quad     \\dfrac{f^\\box\\colon a\\to b { \\;\\;}g_1^\\box{{\\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}g_2^\\box\\colon b\\to c }      { g_1 \\circ f { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}g_2\\circ f } \\\\",
    "\\hline \\mbox{categorical rules } \\\\",
    "{ \\textrm{(id ) } } \\quad    \\dfrac{a}{{\\mathit{id}}_a^\\box\\colon a\\to a } \\qquad   { \\textrm{(comp ) } } \\quad    \\dfrac{f^\\box\\colon a\\to b \\quad g^\\box\\colon b\\to c }      { ( g\\circ f)^\\box \\colon a\\to c }   \\\\ { \\textrm{(id - source ) } } \\quad     \\dfrac{f^\\box\\colon a\\to b}{f\\circ { \\mathit{id}}_a { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}f } \\qquad   { \\textrm{(id - target ) } } \\quad     \\dfrac{f^\\box\\colon a\\to b}{{\\mathit{id}}_b\\circ f { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}f } \\\\ { \\textrm{(assoc ) } } \\quad     \\dfrac{f^\\box\\colon a\\to b { \\;\\;}g^\\box\\colon b\\to c { \\;\\;}h^\\box\\colon c\\to d }    { h\\circ ( g\\circ f ) { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}(h\\circ g)\\circ f }   \\\\",
    "\\hline \\mbox{product rules } \\\\   { \\textrm{(prod ) } } \\quad    \\dfrac{b_1 \\quad b_2 }      { b_1{\\!\\times\\!}b_2 \\quad { \\mathit{pr}}_1^\\box\\colon b_1{\\!\\times\\!}b_2 \\to b_1 \\quad       { \\mathit{pr}}_2^\\box\\colon b_1{\\!\\times\\!}b_2 \\to b_2 }   \\\\   { \\textrm{(pair ) } }   \\quad    \\dfrac { f_1^\\box\\colon   a \\to b_1 \\quad f_2^\\box\\colon   a \\to b_2 }      { { \\langle f_1,f_2 \\rangle}^\\box\\colon   a\\to b_1{\\!\\times\\!}b_2 } \\\\ { \\textrm{(pair - eq ) } } \\quad     \\dfrac{f_1^\\box\\colon a\\to b_1 { \\;\\;}f_2^\\box\\colon a\\to b_2 }      { { \\mathit{pr}}_1\\circ{\\langle f_1,f_2 \\rangle } { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}f_1 \\quad    { \\mathit{pr}}_2\\circ{\\langle f_1,f_2 \\rangle } { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}f_2 }   \\\\ { \\textrm{(pair - u ) } } \\quad     \\dfrac{f_1^\\box{\\!\\colon\\!}a\\!{\\!\\to\\!}\\ ! b_1 { \\;\\;}f_2^\\box{\\!\\colon\\!}a\\!{\\!\\to\\!}\\ ! b_2 { \\;\\;}g^\\box{\\!\\colon\\!}a\\!{\\!\\to\\!}\\ ! b_1{\\!\\times\\!}b_2       { \\;\\;}{\\mathit{pr}}_1\\circ g{{\\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}f_1 { \\;\\;}{\\mathit{pr}}_2\\circ g{{\\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}f_2 }      { g { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}{\\langle f_1,f_2 \\rangle } } \\\\ { \\textrm{(unit ) } } \\quad    \\dfrac{}{{\\mathbb{1 } } } \\qquad { \\textrm{(final ) } } \\quad    \\dfrac{a}{{\\langle \\ ; \\rangle}_a^\\box\\colon a\\to { \\mathbb{1 } } } \\qquad { \\textrm{(final - u ) } } \\quad     \\dfrac{f^\\box\\colon a\\to",
    "{ \\mathbb{1}}}{f { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}{\\langle \\ ; \\rangle}_a } \\\\ \\hline \\mbox{coproduct rules } \\\\   { \\textrm{(coprod ) } } \\quad    \\dfrac{a_1 \\quad a_2 }      { a_1{\\!+\\!}a_2 \\quad { \\mathit{in}}_1^\\box\\colon a_1\\to a_1{\\!+\\!}a_2 \\quad       { \\mathit{in}}_2^\\box\\colon a_2\\to a_1{\\!+\\!}a_2 } \\\\   { \\textrm{(copair ) } } \\quad     \\dfrac { f_1^\\box\\colon   a_1 \\to b \\quad f_2^\\box\\colon   a_2 \\to b }      { { [ f_1|f_2 ] } ^\\box\\colon   a_1{\\!+\\!}a_2 \\to b } \\\\ { \\textrm{(copair - eq ) } } \\quad     \\dfrac { f_1^\\box\\colon   a_1 \\to b { \\;\\;}f_2^\\box\\colon   a_2 \\to b }      { { [ f_1|f_2 ] } \\circ { \\mathit{in}}_1 { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}f_1 \\quad      { [ f_1|f_2 ] } \\circ { \\mathit{in}}_2 { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}f_2   } \\\\ { \\textrm{(copair - u ) } } \\quad     \\dfrac{g^\\box{\\!\\colon\\!}a_1\\!{\\!+\\!}\\ ! a_2 { \\!\\to\\!}b { \\;\\;}f_1^\\box{\\!\\colon\\!}a_1 { \\!\\to\\!}b       { \\;\\;}f_2^\\box{\\!\\colon\\!}a_2 { \\!\\to\\!}b { \\;\\;}g\\circ { \\mathit{in}}_1 { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}f_1 { \\;\\;}g\\circ { \\mathit{in}}_2 { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}f_2 }      { g { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\ , } } { [ f_1|f_2 ] } }   \\\\ { \\textrm{(empty ) } } \\quad    \\dfrac{}{{\\mathbb{0 } } } \\qquad { \\textrm{(initial ) } } \\quad    \\dfrac{b}{{[\\;]}_b^\\box\\colon { \\mathbb{0}}\\to b } \\qquad { \\textrm{(initial - u ) } } \\quad     \\dfrac{g^\\box\\colon { \\mathbb{0}}\\to b}{g { { \\,\\,\\makebox[0pt][c]{{$\\box$}}\\makebox[0pt][c]{\\raisebox{2pt}{\\tiny\\ensuremath{\\equiv}}}\\,\\,}}{[\\;]}_b } \\\\ \\hline   \\end{array}\\ ] ]      in the logic @xmath11 for comonads , each term has a decoration which is denoted as a superscript @xmath16 , @xmath17 or @xmath18 : a term is _ pure _ when its decoration is @xmath16 , it is an _ accessor _ ( or an _ observer _ ) when its decoration is @xmath17 and a _ modifier _ when its decoration is @xmath18 .",
    "each equation has a decoration which is denoted by replacing the symbol @xmath19 either by @xmath20 or by @xmath21 : an equation with @xmath20 is called _ strong _ , with @xmath21 it is called _",
    "the inference rules of @xmath11 are obtained by introducing some _ conversion _ rules and by decorating the rules in figure  [ fig : pattern - rules ] .    when writing terms , if a decoration does not matter or if it is clear from the context , it may be omitted .    *",
    "the conversion rules are : @xmath22 the conversions for terms are _ upcasting _ conversions .",
    "+ we will always use them in a _ safe _ way , by interpreting them as injections .",
    "this allows to avoid any specific notation for these conversions ; an accessor @xmath23 may be converted to a modifier which is denoted @xmath24 : both have the same name although they are distinct terms ; similarly , a pure term @xmath25 may be converted to @xmath26 or to @xmath27 .",
    "an equation between terms with distinct decorations does not imply any downcasting of its members ; for instance , if @xmath28 then it does not follow that @xmath29 is downcasted to @xmath30 .",
    "the conversions for equations mean that strong and weak equations coincide on pure terms and accessors and that each strong equation between modifiers can be seen as a weak one . *",
    "all rules of @xmath13 are decorated with @xmath16 for terms and @xmath20 for equations : the pure terms with the strong equations form a sublogic of @xmath11 which is isomorphic to @xmath13 .",
    "thus we get @xmath31 , @xmath32 , @xmath33 , @xmath34 , @xmath35}^{{(0)}}$ ] .",
    "* the congruence rules for equations take all decorations for terms and for equations , with one notable exception : the replacement rule for weak equations holds only when the replaced term is pure : @xmath36 * the categorical rules hold for all decorations and the decoration of a composed terms is the maximum of the decorations of its components .",
    "* the product rules hold only when the given terms are pure or accessors and the decoration of a pair is the maximum of the decorations of its components .",
    "thus , @xmath10-ary operations can be used only when their arguments are accessors . *",
    "the coproduct rules hold only when the given terms are pure and a copair is always pure , which is the maximum of the decorations of its components .",
    "thus , case distinction can be done only for pure terms .      in order to give a meaning to the logic @xmath11 ,",
    "let us consider a bicartesian category @xmath37 with a comonad @xmath38 satisfying the epi requirement , i.e. , @xmath39 is an epimorphism for each object @xmath40 ( the dual assumption is discussed in @xcite ) .",
    "then we get a model @xmath41 of the decorated logic @xmath11 as follows .",
    "* the types are interpreted as the objects of @xmath37 . *",
    "the terms are interpreted as morphisms of @xmath37 : a pure term @xmath42 as a morphism @xmath43 in  @xmath37 ; an accessor @xmath44 as a morphism @xmath45 in  @xmath37 ; and a modifier @xmath46 as a morphism @xmath47 in  @xmath37 . *",
    "the conversion from pure terms to accessors is interpreted by mapping @xmath48 to @xmath49 .",
    "the epi requirement implies that this conversion is safe . * the conversion from accessors to modifiers",
    "is interpreted by mapping @xmath50 to @xmath51 .",
    "it is easy to check that this conversion is safe .",
    "* when a term @xmath29 has several decorations ( because it is pure or accessor , and thus can be upcasted ) we will denote by @xmath29 any one of its interpretations : a pure term @xmath42 may be interpreted as @xmath43 and as @xmath52 and as @xmath47 , and an accessor @xmath44 as @xmath52 and as @xmath47 .",
    "the choice will be clear from the context , and when several choices are possible they will give the same result , up to conversions .",
    "for this reason , we will describe the interpretation of the rules only for the largest possible decorations . *",
    "the identity @xmath53 is interpreted as @xmath54 in @xmath37 ; * the composition of two modifiers @xmath55 and @xmath56 is interpreted as @xmath57 in  @xmath37 . *",
    "an equation between modifiers @xmath58 is interpreted by an equality @xmath59 in  @xmath37 . * a weak equation between modifiers @xmath60",
    "is interpreted by an equality @xmath61 in @xmath37 .",
    "* the unit type is interpreted as the final object of @xmath37 and the term @xmath62 as the unique morphism from @xmath40 to @xmath63 in  @xmath37 . *",
    "the product @xmath64 with its projections is interpreted as the binary product in  @xmath37 and the pair of @xmath65 and @xmath66 as the pair @xmath67 in  @xmath37 . *",
    "the empty type is interpreted as the initial object of @xmath37 and the term @xmath35}_a^{{(0)}}\\colon { \\mathbb{0}}\\to a$ ] as the unique morphism from @xmath68 to @xmath40 in  @xmath37 .",
    "* the coproduct @xmath69 with its coprojections is interpreted as the binary coproduct in @xmath37 and the copair of @xmath70 and @xmath71 as the copair @xmath72 } \\colon a_1+a_2\\to { t}b$ ] in  @xmath37 .",
    "the dual of the decorated logic @xmath11 for a comonad is the decorated logic @xmath12 for a monad .",
    "thus , the grammar of @xmath12 is the same as the grammar of @xmath11 , but a term with decoration @xmath17 is now called a _",
    "constructor_.    the rules for @xmath12 are nearly the same as the corresponding rules for @xmath11 , except that for weak equations the replacement rule always holds while the substitution rule holds only when the substituted term is pure : @xmath73 in the rules for pairs and copairs , the decorations are permuted .    the logic @xmath12 can be interpreted dually to @xmath11 .",
    "let @xmath37 be a bicartesian category and @xmath0 a monad on @xmath37 satisfying the mono requirement , which means that @xmath74 is a monomorphism for each object @xmath40 .",
    "then we get a model @xmath75 of the decorated logic @xmath12 , where    a constructor @xmath44 is interpreted as a morphism @xmath76 in  @xmath37    and a weak equation @xmath60 is interpreted as an equality @xmath77 in @xmath37 .",
    "let us consider a distributive category @xmath37 with epimorphic projections and with a distinguished object @xmath7 called the _ object of states_. we consider the comonad @xmath38 with endofunctor @xmath78 , with counit @xmath79 made of the projections @xmath80 , and with comultiplication @xmath81 which `` duplicates '' the states , in the sense that @xmath82 where @xmath83 is the projection .",
    "we call this comonad the _ comonad of state_. it is sometimes called the _ product comonad _ , and it is different from the _ costate comonad _ or _ store comonad _ with endofuntor @xmath84 @xcite .",
    "the category @xmath37 with the comonad of states provides a model of the logic @xmath11",
    ". we can extend @xmath11 into a logic @xmath85 dedicated to the state comonad .",
    "first , because of the specific choice of the comonad @xmath78 , we can add new decorations to the rule patterns for pairs in @xmath11 , involving modifiers : there is a _",
    "left pair _",
    "@xmath86 of an accessor @xmath87 and a modifier @xmath88 , satisfying the first three rules in figure  [ fig : state - prod ] .",
    "there are also three rules ( omitted ) , symmetric to these ones , for the _ right pair _",
    "@xmath89 of a modifier @xmath90 and an accessor @xmath91 .",
    "the interpretation of the left pair @xmath92 is the pair @xmath93 of @xmath94 and @xmath95 .",
    "moreover , the rule expresses the fact that , when @xmath78 , two modifiers coincide as soon as they return the same result and modify the state in the same way .",
    "@xmath96_l}^{{(2)}}\\colon   a \\to b_1\\times b_2 }   \\\\ { \\textrm{(l - pair - eq ) } } & \\dfrac { f_1^{{(1)}}\\colon a\\to b_1 \\quad f_2^{{(2)}}\\colon   a \\to b_2 }    { { \\mathit{pr}}_1^{{(0)}}\\circ { \\langle f_1,f_2 \\rangle_l}^{{(2)}}{\\sim}f_1^{{(1)}}\\quad      { \\mathit{pr}}_2^{{(0)}}\\circ { \\langle f_1,f_2 \\rangle_l}^{{(2)}}{\\cong}f_2^{{(2 ) } } } \\\\ { \\textrm{(l - pair - u ) } } & \\dfrac{g^{{(2)}}{\\!\\colon\\!}a { \\!\\to\\!}b_1{\\!\\times\\!}b_2 { \\;\\;}f_1^{{(1)}}{\\!\\colon\\!}a{\\!\\to\\!}b_1 \\quad",
    "f_2^{{(2)}}{\\!\\colon\\!}a { \\!\\to\\!}b_2 { \\;\\;}{\\mathit{pr}}_1^{{(0)}}\\circ g { \\sim}f_1 { \\;\\;}{\\mathit{pr}}_2^{{(0)}}\\circ g { \\cong}f_2 }    { g^{{(2)}}{\\cong}{\\langle f_1,f_2 \\rangle_l}^{{(2 ) } } }     \\\\",
    "\\hline { \\textrm{(effect ) } } & \\dfrac{f , g\\colon a \\to b \\quad f{\\sim}g \\quad     { \\langle \\ ; \\rangle}_a\\circ f { \\cong}{\\langle \\ ; \\rangle}_a\\circ g }    { f{\\cong}g } \\\\   \\hline \\end{array}\\ ] ]    for each set @xmath97 of _ locations _ ( or identifiers ) , additional grammar and rules for the logic @xmath85 are given in figure  [ fig : state - lookup ] .",
    "we extend the grammar of @xmath11 with a type @xmath98 , an accessor @xmath99 and a modifier @xmath100 for each location @xmath101 , and we also extend its rules .",
    "the rule asserts that two functions without result coincide as soon as they coincide when observed at each location . together with the rule it implies that two functions coincide as soon as they return the same value and coincide on each location .",
    "@xmath102    for each family of objects @xmath103 in @xmath37 such that @xmath104 we build a model @xmath105 of @xmath85 , which extends the model the model @xmath41 of @xmath11 with functions for looking up and updating the locations .",
    "the types @xmath98 are interpreted as the objects @xmath98 and the accessors @xmath99 as the projections from @xmath7 to @xmath98 .",
    "then the interpretation of each modifier @xmath106 is the function from @xmath107 to @xmath7 defined as the tuple of the functions @xmath108 where @xmath109 is the projection from @xmath107 to @xmath98 and @xmath110 is made of the projection from @xmath107 to @xmath7 followed by @xmath111 when @xmath112 .",
    "the logic we get , and its model , are essentially the same as in @xcite : thus , the pattern for a comonad in section  [ sec : patterns ] can be seen as a generalization to arbitrary comonads of the approach in @xcite .",
    "since we have assumed that the category @xmath37 is _ distributive _ we get new decorations for the rule patterns for coproducts : the copair of two modifiers now exists , the corresponding decorated rules are given in figure  [ fig : state - coprod ] .",
    "the interpretation of the modifier @xmath72}$ ] , when both @xmath113 and @xmath114 are modifiers , is the composition of @xmath72}\\colon   ( a_1\\times s)+(a_2\\times s)\\to b\\times s$ ] with the inverse of the canonical morphism @xmath115 : this inverse exists because @xmath37 is distributive .",
    "@xmath116}^{{(2)}}\\colon   a_1\\!+\\!a_2 \\to b } \\\\",
    "{ \\textrm{(copair - eq ) } } &   \\dfrac { f_1^{{(2)}}\\colon   a_1 \\to b { \\;\\;}f_2^{{(2)}}\\colon   a_2 \\to b }    { { [ f_1|f_2 ] } \\circ { \\mathit{in}}_1 { \\cong}f_1 \\quad      { [ f_1|f_2 ] } \\circ { \\mathit{in}}_2 { \\cong}f_2   } \\\\ { \\textrm{(copair - u ) } } &   \\dfrac{f_i^{{(2)}}{\\!\\colon\\!}a_i { \\!\\to\\!}b { \\;\\;}g^{{(2)}}{\\!\\colon\\!}a_1\\!{\\!+\\!}\\!a_2 { \\!\\to\\!}b { \\;\\;}g\\circ { \\mathit{in}}_i { \\cong}f_i }    { g^{{(2)}}{\\cong } { [ f_1|f_2 ] } ^{{(2 ) } } } \\\\ \\hline \\end{array}\\ ] ]      to conclude with states , let us look at the constructions for conditionals and binary operations in the language for states .",
    "the rules in figure  [ fig : state - coprod ] provide conditionals .",
    "there is no binary product of modifiers , but there is a left product of a constructor and a modifier and a right product of a modifier and a constructor .",
    "it follows that the _ left and right sequential products _ of two modifiers @xmath113 and @xmath114 can be defined , as in @xcite , by composing , e.g. , the left product of an identity and @xmath113 with the right product of @xmath114 and an identity .",
    "a major feature of this approach is that , for states , sequential products are defined without any new ingredient : no kind of strength , in contrast with the approach using the strong monad of states @xmath117 @xcite , no `` external '' decoration for equations , in contrast with @xcite .",
    "this property is due to the introduction of the intermediate notion of _ accessors _ between pure terms ( or _ values _ ) and modifiers ( or _ computations _ ) .",
    "now we use the decorated logic @xmath85 for proving that the decorated theory for states is hilbert - post complete .",
    "this result is proved in ( * ? ? ? * prop.2.40 ) in the framework of lawvere theories . here",
    "we give a proof in the decorated logic for states .",
    "this proof has been checked in coq .",
    "the logic we use is the fragment @xmath118 of @xmath85 which involves neither products nor coproducts nor the empty type ( but which involves the unit type ) .",
    "the _ theory of state _",
    ", denoted @xmath119 , is the family of equations which may be derived from the axioms of @xmath118 using the rules of @xmath118 .",
    "more generally , a _ theory _ @xmath120 with respect to @xmath118 is a family of equations between terms of @xmath118 which is saturated with respect to the rules of @xmath118 .",
    "a theory @xmath121 is an _ extension _ of a theory @xmath120 if it contains all the equations of @xmath120 .",
    "two families of equations are called _ equivalent _ if each one can be derived from the other with the rules of @xmath118 .    as in (",
    "* prop.2.40 ) , for the sake of simplicity it is assumed that there is a single location @xmath101 , and we write @xmath122 , @xmath123 and @xmath124 instead of @xmath98 , @xmath125 and @xmath126 . then there is a single axiom @xmath127 .    in addition , it is assumed that all types are _ inhabited _ , in the sense that for each type @xmath101 there exists a closed pure term with type @xmath101 .",
    "[ theo : equations ] every equation between terms of @xmath118 is equivalent to four equations between pure terms .    the proof is obtained by merging the two parts of proposition  [ prop : equations ] , which is proved in appendix  [ app - complete ] .    [ prop : equations ]    1 .",
    "[ prop : equations - acc ] every equation between accessors is equivalent to two equations between pure terms .",
    "[ prop : equations - modi ] every equation between modifiers is equivalent to two equations between accessors .    roughly speaking , a theory ( with respect to some logic ) is said _ syntactically complete _ if no unprovable axiom can be added to the theory without introducing an inconsistency .",
    "more precisely , a theory with respect to the equational logic is _ hilbert - post complete _ if it is consistent and has no consistent proper extension ( * ? ? ?",
    "* definition  2.8 . ) .",
    "since we use a decorated version of the equational logic , we have to define a decorated version of hilbert - post completeness .",
    "[ defi : complete ] with respect to the logic @xmath118 ,    a theory @xmath120 is _ consistent _ if there is an equation which is not in @xmath120 .",
    "an extension @xmath121 of a theory @xmath120 is a _ pure extension _ if it is generated by @xmath120 and by equations between pure terms .",
    "it is a _ proper extension _ if it is not a pure extension .",
    "a theory @xmath120 is _ hilbert - post complete _ if it is consistent and has no consistent proper extension .",
    "the proof of theorem  [ theo : complete ] relies on theorem  [ theo : equations ] .",
    "we do not have to assume that the interpretation of the type @xmath122 is a countable set .",
    "we have assumed that @xmath97 is a singleton , but we conjecture that our result can be generalized to any set of locations , without any finiteness condition .",
    "[ theo : complete ] the theory for state is hilbert - post complete .",
    "the theory @xmath119 is consistent : it can not be proved that @xmath128 .",
    "let us consider an extension @xmath120 of @xmath119 and let @xmath129 be the theory generated by @xmath119 and by the equations between pure terms in @xmath120 .",
    "thus , @xmath129 is a pure extension of @xmath119 and @xmath120 is an extension of @xmath129 .",
    "let us consider an arbitrary equation @xmath130 in @xmath120 , according to theorem  [ theo : equations ] we get a family @xmath9 of equations between pure terms which is equivalent to the given equation @xmath130 .    since @xmath130 is in @xmath120 and @xmath120",
    "is saturated , the equations in @xmath9 are also in @xmath120 , hence they are in @xmath129 .    since @xmath9 is in @xmath129 and @xmath129",
    "is saturated , the equation @xmath130 is also in @xmath129 .",
    "this proves that @xmath131 , so that the theory @xmath119 has no proper extension .",
    "let us consider a bicartesian category @xmath37 with monomorphic coprojections and with a distinguished object @xmath9 called the _ object of exceptions_. we do not assume that @xmath37 is distributive ( it would not help ) nor codistributive , because usually this is not the case .",
    "the _ monad of exceptions _ on @xmath37 is the monad @xmath0 with endofunctor @xmath132 , its unit @xmath133 is made of the coprojections @xmath134 , and its multiplication @xmath135 `` merges '' the exceptions , in the sense that @xmath136}\\colon ( a+e)+e\\to a+e$ ] where @xmath137 is the coprojection .",
    "it satisfies the mono requirement because the coprojections are monomorphisms .",
    "thus , the category @xmath37 with the monad of exceptions provides a model of the logic @xmath12 .",
    "the name of the decorations is adapted to the monad of exceptions : a constructor is called a _ propagator _ : it may raise an exception but can not recover from an exception , so that it has to propagate all exceptions ; a modifier is called a _ catcher_.    for this specific monad @xmath132 , it is possible to extend the logic @xmath12 as @xmath138 , called the _",
    "logic for exceptions _ , so that @xmath37 with @xmath132 can be extended as a model @xmath139 of @xmath138 .",
    "first , dually to the left and right pairs for states in figure  [ fig : state - prod ] , we get new decorations to the rule patterns for copairs in @xmath12 , involving modifiers , as in figure  [ fig : exc - coprod ] for the left copairs ( the rules for the right copairs are omitted ) .    the interpretation of the left copair @xmath72_l}^{{(2 ) } } : a_1+a_2\\to b$ ] is the copair @xmath72}:a_1+a_2+e\\to b+e$ ] of @xmath140 and @xmath141 in  @xmath37 .",
    "for instance , the coproduct of @xmath142 , with coprojections @xmath143 and @xmath35}_a^{{(0)}}:{\\mathbb{0}}\\to a$ ] , gives rise to the left copair @xmath72_l}^{{(2)}}:a \\to b$ ] of any constructor @xmath144 with any modifier @xmath145 , which is characterized up to strong equations by @xmath72_l}{\\sim}f_1 $ ] and @xmath72_l}{\\cong}f_2 $ ] .",
    "this will be used in the construction of the @xmath146 expressions .",
    "moreover , the rule expresses the fact that , when @xmath132 , two modifiers coincide as soon as they coincide on ordinary values and on exceptions .",
    "@xmath147_l}^{{(2)}}\\colon   a_1\\!+\\!a_2 \\to b }   \\\\ { \\textrm{(l - copair - eq ) } } & \\dfrac { f_1^{{(1)}}\\colon   a_1 \\to b { \\;\\;}f_2^{{(2)}}\\colon   a_2 \\to b }    { { [ f_1|f_2 ] _ l}^{{(2)}}\\circ { \\mathit{in}}_1^{{(0)}}{\\sim}f_1^{{(1)}}\\quad      { [ f_1|f_2 ] _ l}^{{(2)}}\\circ { \\mathit{in}}_2^{{(0)}}{\\cong}f_2^{{(2 ) } } } \\\\ { \\textrm{(l - copair - u ) } } & \\dfrac{g^{{(2)}}{\\!\\colon\\!}a_1\\!+\\!a_2 { \\!\\to\\!}b { \\;\\;}f_1^{{(1)}}{\\!\\colon\\!}a_1 { \\!\\to\\!}b { \\;\\;}f_2^{{(2)}}{\\!\\colon\\!}a_2 { \\!\\to\\!}b { \\;\\;}g\\circ { \\mathit{in}}_1 { \\sim}f_1 { \\;\\;}g\\circ { \\mathit{in}}_2 { \\cong}f_2 }    { g^{{(2)}}{\\cong } { [ f_1|f_2 ] _",
    "l}^{{(2 ) } } }     \\\\ \\hline { \\textrm{(effect ) } } & \\dfrac{f , g\\colon a \\to b \\quad f{\\sim}g",
    "\\quad     f\\circ { [ \\;]}_a { \\cong}g\\circ { [ \\;]}_a }    { f{\\cong}g }   \\\\   \\hline \\end{array}\\ ] ]    for each set @xmath148 of _ exception names _ , additional grammar and rules for the logic @xmath138 are given in figure  [ fig : exc - tag ] .",
    "we extend the grammar of @xmath12 with a type @xmath149 , a propagator @xmath150 and a catcher @xmath151 for each exception name @xmath152 , and we also extend its rules .",
    "the logic @xmath138 obtained performs the _ core _ operations on exceptions : the _ tagging _ operations encapsulate an ordinary value into an exception , and the _ untagging _ operations recover the ordinary value which has been encapsulated in an exception .",
    "this may be generalized by assuming a hierarchy of exception names @xcite .",
    "the rule asserts that two functions without argument coincide as soon as they coincide on each exception . together with the rule it implies that two functions coincide as soon as they coincide on their argument and on each exception .",
    "@xmath153}_{v_t}\\circ{\\mathtt{tag}}_r }   \\\\   { \\textrm{(local - global ) } } &   \\dfrac { f , g\\colon { \\mathbb{0}}\\to b \\quad \\mbox{for all } t\\in { \\mathit{exn}}\\ ;     f\\circ { \\mathtt{tag}}_t { \\sim}g\\circ { \\mathtt{tag}}_t }    { f{\\cong}g } \\\\ \\hline \\end{array}\\ ] ]    for each family of objects @xmath154 in @xmath37 such that @xmath155 we build a model @xmath139 of @xmath138 , which extends the model the model @xmath156 of @xmath12 with functions for tagging and untagging the exceptions .",
    "the types @xmath149 are interpreted as the objects @xmath149 and the propagators @xmath150 as the coprojections from @xmath149 to @xmath9 .",
    "then the interpretation of each catcher @xmath151 is the function @xmath157 defined as the cotuple ( or case distinction ) of the functions @xmath158 where @xmath159 is the coprojection of @xmath149 in @xmath160 and @xmath161 is made of @xmath162 followed by the coprojection of @xmath9 in @xmath160 when @xmath163 .",
    "this can be illustrated , in an informal way , as follows : @xmath164 encloses its argument @xmath165 in a box with name @xmath152 , while @xmath166 opens every box with name @xmath152 to recover its argument and returns every box with name @xmath167 without opening it : @xmath168^{{\\mathtt{tag}}_t } & & * + [ f-]{a } \\ar@{}[r]_(.2){t } & & * + [ f-]{a } \\ar@{}[r]_(.2){t } \\ar[rr]^{{\\mathtt{untag}}_t } & & a \\\\   & & & & & * + [ f-]{a } \\ar@{}[r]_(.2){r } \\ar[rr]^{{\\mathtt{untag}}_t } & &     * + [ f-]{a } \\ar@{}[r]_(.2){r } & \\\\ } \\ ] ]    since we did not assume that the category @xmath37 is codistributive we can not get products of modifiers in a way dual to the coproducts of modifiers for states .    however these rules have not been used for proving the hilbert - post completeness of the theory for state . thus by duality from theorem  [ theo : complete ] we get `` for free '' a result about the core language for exceptions .    [ coro : complete ]",
    "the core theory for exceptions is hilbert - post complete .",
    "we have obtained a logic @xmath138 for exceptions , with the core operations for tagging and untagging .",
    "this logic provides a direct access to catchers ( the untagging functions ) , which is not provided by the usual mechanism of exceptions in programming languages .",
    "in fact the core operations remain _ private _ , while there is a _",
    "programmer s _ language , which is _ public _ , with no direct access to the catchers .    the programmer s language for exceptions provides the operations for _ raising _ and _ handling _ exceptions , which are defined in terms of the core operations .",
    "this language has no catcher : the only way to catch an exception is by using a @xmath146 expression , which itself propagates exceptions .",
    "thus , all terms of the programmer s language are propagators",
    ". this language does not include the private tagging and untagging operations , but the public @xmath169 and @xmath146 constructions , which are defined in terms of @xmath170 and @xmath171 . for the sake of simplicity",
    "we assume that only one type of exception is handled in a @xmath146 expression , the general case is treated in @xcite .",
    "the main ingredients for building the programmer s language from the core language are the coproducts @xmath172 and a new conversion rule for terms .",
    "the _ downcast _ conversion of a catcher to a propagator could have been defined in section  [ sec : patterns ] for the logic @xmath11 , and dually for the logic @xmath12 ; the rule is : @xmath173 this downcasting conversion from catchers to propagators is interpreted by mapping @xmath174 to @xmath175 .",
    "it is related to weak equations : @xmath176 , and @xmath177 if and only if @xmath178 .",
    "but the downcasting conversion is _ unsafe _ : several catchers may be downcasted to the same propagator .",
    "this powerful operation turns an effectful term to an effect - free one ; since it is not required for states nor for the core language for exceptions , we did not introduce it earlier .",
    "[ defi : exc ] for each type @xmath179 and each exception name @xmath152 , the propagator @xmath180 is : @xmath181}_b^{{(0)}}\\circ { \\mathtt{tag}}_t^{{(1)}}\\colon v_t\\to b\\ ] ] for each each propagator @xmath182 , each exception name @xmath152 and each propagator @xmath183 , the propagator @xmath184 is defined in three steps , involving two catchers @xmath185 and @xmath186 , as follows :    @xmath187}_b^{{(0)}}\\ ; ] } ^{{(1)}}\\circ{\\mathtt{untag}}_t^{{(2)}}\\colon   { \\mathbb{0}}\\to b \\\\   { \\mathtt{try}}(f){\\mathtt{catch}}(t{\\rightarrow}g)^{{(2)}}=     { [ \\ ; { \\mathit{id}}_b \\;|\\ ; { \\mathtt{catch}}(t{\\rightarrow}g ) \\ ; ] _",
    "l}^{{(2)}}\\circ f^{{(1)}}\\colon a\\to b \\\\ { \\mathtt{try}}(f){\\mathtt{catch}}(t{\\rightarrow}g)^{{(1)}}=     { { \\downarrow}}({\\mathtt{try}}(f){\\mathtt{catch}}(t{\\rightarrow}g ) )     \\colon a\\to b \\\\ \\end{array}\\ ] ]    this means that raising an exception with name @xmath152 consists in tagging the given ordinary value ( in @xmath149 ) as an exception and coerce it to any given type @xmath179 .    for handling an exception ,",
    "the intermediate expressions @xmath188 and @xmath189 are private catchers and the expression @xmath190 is a public propagator : the downcast operator prevents it from catching exceptions with name @xmath152 which might have been raised before the @xmath190 expression is considered .",
    "the definition of @xmath190 corresponds to the java mechanims for exceptions @xcite .",
    "the definition of @xmath190 corresponds to the following control flow , where ` exc ? ` means `` _ _ is this value an exception ? _ _ '' , an _ abrupt _ termination returns an uncaught exception and a _ normal _ termination returns an ordinary value ; this corresponds , for instance , to the java mechanims for exceptions @xcite .",
    "@xmath191 & & \\\\ & { \\txt{exc?}}\\ar[ld]_{y}\\ar[rd]^{n } & & \\\\",
    "{ \\boxed{\\mathit{abrupt } } } & & f^{{(1)}}\\ar[d ] & \\\\ & & { \\txt{exc?}}\\ar[ld]_{y}\\ar[rd]^{n } & \\\\ & { \\mathtt{untag}}_t^{{(2)}}\\ar[d ] & & { \\boxed{\\mathit{normal}}}\\\\ & { \\txt{exc?}}\\ar[ld]_{y}\\ar[rd]^{n } & & \\\\   { \\boxed{\\mathit{abrupt } } } & & g^{{(1)}}\\ar[d ] & \\\\ & & \\txt{{\\boxed{\\mathit{normal}}}\\mbox { or } { \\boxed{\\mathit{abrupt } } } } \\\\ } \\ ] ]      to conclude with exceptions , let us look at the constructions for case distinction and binary operations in the programmer s language for exceptions , which means , copairs and pairs of _",
    "constructors_.    the general rules of the logic @xmath12 include coproducts of constructors ( figure  [ fig : pattern - rules ] ) , which provide case distinction for all terms in the programmer s language for exceptions .",
    "but the general rules for a monad do not include binary products involving a constructor , hence they can not be used for dealing with binary operations in the programmer s language for exceptions when at least an argument is not pure .",
    "indeed , if @xmath65 is pure and @xmath192 does raise an exception , it is in general impossible to find @xmath193 such that @xmath194 and @xmath195 .",
    "however , there are several ways to formalize the fact of first evaluating @xmath113 then @xmath114 : for instance by using a strong monad @xcite , or a sequential product @xcite , or productors @xcite .",
    "the sequential product approach can be used in our framework ; it requires the introduction of a third kind of `` equations '' , in addition to the strong and weak equations , which corresponds to the usual order between partial functions : details are provided in @xcite .",
    "we have presented two patterns giving sound inference systems for effects arising from a monad or a comonad .",
    "we also gave detailed examples of applications of these patterns to the state and the exceptions effects .",
    "the obtained decorated proof system for states has been implemented in coq , so that the given proofs can be automatically verified .",
    "we plan to adapt this logic to local states ( with allocation ) in order to provide a decorated proof of the completeness theorem in @xcite .    from this implementation , we plan to extract the generic part corresponding to the comonad pattern , dualize it and extend it to handle the programmer s language for exceptions .",
    "then a major issue is scalability : how can we combine effects ? within the framework of this paper , it may seem difficult to guess how several effects arising from either monads or comonads can be combined . however , as mentioned in the introduction , this paper deals with two patterns for instanciating the more general framework of decorated logics @xcite .",
    "decorated logics are based on spans in a relevant category of logics , so that the combination of effects can be based on the well - known composition of spans .",
    "[ [ acknowledgment . ] ] acknowledgment .",
    "+ + + + + + + + + + + + + + +    we are grateful to samuel mimram for enlightning discussions .",
    "00    csar domnguez , dominique duval .",
    "diagrammatic logic applied to a parameterization process .",
    "mathematical structures in computer science 20 , p.  639 - 654",
    "( 2010 ) .",
    "jean - guillaume dumas , dominique duval , laurent fousse , jean - claude reynaud . decorated proofs for computational effects : states .",
    "accat 2012 .",
    "electronic proceedings in theoretical computer science 93 , p.  45 - 59",
    "( 2012 ) .",
    "jean - guillaume dumas , dominique duval , laurent fousse , jean - claude reynaud . a duality between exceptions and states .",
    "mathematical structures in computer science 22 , p.  719 - 722",
    "( 2012 ) .",
    "jean - guillaume dumas , dominique duval , jean - claude reynaud .",
    "cartesian effect categories are freyd - categories .",
    "journal of symbolic computation 46 , p.  272 - 293",
    "( 2011 ) .",
    "jean - guillaume dumas , dominique duval , jean - claude reynaud . a decorated proof system for exceptions . arxiv:1310.2338 ( 2013 ) .",
    "jean - guillaume dumas , dominique duval , burak ekici , damien pous . formal verification in coq of program properties involving the global state effect .",
    "arxiv:1310.0794 ( 2013 ) .",
    "jeremy gibbons , michael johnson .",
    "relating algebraic and coalgebraic descriptions of lenses bx 2012 .",
    "eceasst 49 ( 2012 ) .",
    "james gosling , bill joy , guy steele , gilad bracha .",
    "the java language specification , third edition .",
    "addison - wesley longman ( 2005 ) .",
    "bart jacobs .",
    "a formalisation of java s exception mechanism .",
    "esop 2001 .",
    "lncs , vol .",
    "2028 , p.  284 - 301",
    "springer ( 2001 ) .    bart jacobs and jan rutten .",
    "an introduction to ( co)algebras and ( co)induction . in : d. sangiorgi and j. rutten ( eds ) , advanced topics in bisimulation and coinduction , p.38 - 99 , 2011 .",
    "paul blain levy .",
    "monads and adjunctions for global exceptions .",
    "mfps 2006 .",
    "electronic notes in theoretical computer science 158 , p.  261 - 287",
    "( 2006 ) .",
    "john m. lucassen , david k. gifford .",
    "polymorphic effect systems .",
    "popl 1988 .",
    "acm press , p.  47 - 57 .",
    "paul - andr mellis .",
    "segal condition meets computational effects .",
    "lics 2010 .",
    "p.  150 - 159 , ieee computer society ( 2010 ) .",
    "eugenio moggi .",
    "notions of computation and monads .",
    "information and computation 93(1 ) , p.  55 - 92",
    "( 1991 ) .",
    "eugenio moggi and sonia fagorzi . a monadic multi - stage metalanguage .",
    "fossacs 2003 , lncs , vol . 2620 , p.  358 - 374 , springer ( 2003 ) .",
    "matija pretnar .",
    "the logic and handling of algebraic effects .",
    "university of edinburgh 2010 .",
    "gordon d. plotkin , john power .",
    "notions of computation determine monads .",
    "fossacs 2002 .",
    "lncs , vol .",
    "2620 , p.  342 - 356 , springer ( 2002 ) .",
    "gordon d. plotkin , matija pretnar .",
    "handlers of algebraic effects .",
    "esop 2009 .",
    "lncs , vol .",
    "5502 , p.  80 - 94 , mpringer ( 2009 ) .",
    "lutz schrder , till mossakowski .",
    "generic exception handling and the java monad .",
    "amast 2004 .",
    "lncs , vol .",
    "3116 , p.  443 - 459 , springer ( 2004 ) .",
    "sam staton .",
    "completeness for algebraic theories of local state .",
    "fossacs 2010 .",
    "lncs , vol .",
    "6014 , p.  48 - 63 , springer ( 2010 ) .",
    "ross tate .",
    "the sequential semantics of producer effect systems .",
    "popl 2013 .",
    "acm press , p.  15 - 26",
    "( 2013 ) .",
    "tarmo uustalu , varmo vene .",
    "comonadic notions of computation .",
    "cmcs 2008 .",
    "entcs 203 , p.  263 - 284",
    "( 2008 ) .",
    "philip wadler . the essence of functional programming .",
    "popl 1992 .",
    "acm press , p.  1 - 14",
    "the logic used in this appendix is the fragment @xmath118 of the decorated logic for states @xmath85 which involves neither products nor coproducts nor the empty type , but which involves the unit type .    for the sake of simplicity",
    "it is assumed that there is a single location @xmath101 , and we write @xmath122 , @xmath196 and @xmath197 instead of @xmath98 , @xmath198 and @xmath199 .",
    "then there is a single axiom @xmath200 .    in section  [ sec : states ] , the proof of hilbert - post completeness in theorem  [ theo : complete ] relies on proposition  [ prop : equations ] , which is restated here as proposition  [ prop : equations - app ] .",
    "the aim of this appendix is to prove proposition  [ prop : equations - app ] .      1 .",
    "[ lemm : eqns - rule - unit ] @xmath201 2 .",
    "[ lemm : eqns - rule - val ] @xmath202 3 .",
    "[ lemm : eqns - strong ] + @xmath203 4 .",
    "[ lem : pure_mid_id ] @xmath204 5 .",
    "[ lemm : onepureacc ] @xmath205 6 .",
    "[ lemm : lkppureequal ] @xmath206 7 .",
    "[ lemm : lkpuseless ] @xmath207    1 .",
    "consequence of the observational rule   with only one location .",
    "2 .   consequence of  [ lemm : eqns - rule - unit ] applied to @xmath208 : indeed , from the axiom @xmath209 we get @xmath210 .",
    "3 .   from axiom @xmath209 by substitution",
    "we get @xmath211 ; thus , point  [ lemm : eqns - rule - unit ] implies @xmath212 .",
    "4 .   from @xmath213 , as @xmath214 is pure , by the weak replacement we have @xmath215 . then , weak substitution with @xmath165 yields @xmath216 .",
    "5 .   we know",
    "that @xmath217 .",
    "+ it follows that @xmath218 .",
    "let @xmath219 .",
    "composing with @xmath197 we get @xmath220 . using the axiom @xmath209 and the replacement rule for @xmath21 , which can be used here because both @xmath221 and @xmath214 are pure",
    ", we get @xmath222 . since weak and strong equations coincide on pure terms we get @xmath223 .",
    "let @xmath224 .",
    "by point  [ lemm : onepureacc ] above we get @xmath225 , thus @xmath226 . then by point  [ lemm : lkppureequal ] above we get @xmath227 .",
    "now , let us prove proposition  [ prop : canonical - form ] , which says that , up to strong equations , it can be assumed that there is at most one occurrence of @xmath196 in any accessor and at most one occurrence of @xmath197 in any modifier .      1 .   for each accessor @xmath228 ,",
    "if @xmath165 is not pure then there is a pure term @xmath229 such that @xmath230 2 .   for each modifier",
    "@xmath231 , if @xmath29 is not an accessor then there is an accessor @xmath232 and a pure term @xmath233 such that @xmath234    1 .",
    "if @xmath228 is not pure then it contains at least one occurrence of @xmath235 .",
    "thus , it can be written in a unique way as @xmath236 for some pure term @xmath229 and some accessor @xmath237 . since @xmath237 is such that @xmath238 , the result follows .",
    "if @xmath231 is not an accessor then it contains at least one occurrence of @xmath239 .",
    "thus , it can be written in a unique way as @xmath240 for some accessor @xmath241 and some modifier @xmath242 . from point",
    "[ prop : canonical - form - acc ] , we also have that @xmath243 for some pure term @xmath229 so that @xmath244 . *",
    "if @xmath113 is an accessor , the result follows with @xmath245 . *",
    "otherwise , @xmath90 contains at least one occurrence of @xmath239 .",
    "thus , it can be written in a unique way as @xmath246 for some accessor @xmath247 and some modifier @xmath248 . according to point  [ prop : canonical - form - acc ]",
    "applied to the accessor @xmath249 , either @xmath249 is pure or @xmath250 for some pure term @xmath251 * * if @xmath250 then @xmath252 . the axiom @xmath253 and the replacement and substitution rules for @xmath21 ( since @xmath254 is pure ) yield @xmath255 .",
    "then it follows from point  [ lemm : eqns - rule - val ] in lemma  [ lemm : eqns ] that @xmath256 , and since @xmath257 we get @xmath258 .",
    "the result follows by induction on the number of occurrences of @xmath197 in @xmath29 : indeed , there is one less occurrence of @xmath197 in @xmath259 than in @xmath260 . * * if @xmath249 is pure then @xmath261 from point  [ lemm : onepureacc ] in lemma  [ lemm : eqns ] .",
    "thus the previous proof applies by replacing @xmath249 with @xmath262 .        1 .   * if @xmath267 is pure , since @xmath268 ( because @xmath269 is an accessor ) we get @xmath270 , thus the result is obtained with @xmath271 . *",
    "otherwise , we have just proved that @xmath272 with @xmath273 , then @xmath274 and @xmath275 .",
    "if @xmath276 is an accessor , since @xmath277 we get @xmath278 , thus the result is obtained with @xmath279 .",
    "* otherwise , we have just proved that @xmath280 with @xmath281 , then @xmath282 and @xmath283 .",
    "we can now prove proposition  [ prop : equations - app ] on which the hilbert - post completeness theorem relies .",
    "this proof has been checked with the coq proof assistant using the system for states of  @xcite .",
    "the coq library with the inference system is available there : http://coqeffects.forge.imag.fr .",
    "the single proof of the following proposition ( roughly 16 pages in coq ) is directly available there : http://coqeffects.forge.imag.fr/hpcompletecoq.v .        1 .",
    "we prove that for any accessors @xmath290 there are three cases : 1 .   either they are both pure and @xmath291 is the required equation between pure terms .",
    "2 .   either they are both accessors and it can be derived from @xmath292 that @xmath293 for some pure terms @xmath294 .",
    "3 .   or one of them is pure and the other one is an accessor and it can be derived from @xmath292 that @xmath293 and @xmath295 for some pure terms @xmath294 and @xmath296 .",
    "+ we prove , moreover , that the converse also hold . 1 .   as already mentioned , if @xmath297 and @xmath298 are both pure and @xmath291 is the required equation between pure terms .",
    "2 .   if neither @xmath297 nor @xmath298 is pure , then according to proposition  [ prop : canonical - form ] @xmath299 and @xmath300 for some pure terms @xmath301 . *",
    "starting from the equation @xmath302 we thus get @xmath303 .",
    "then , using the assumption , for any function @xmath289 , we have that @xmath304 . now @xmath305 . this , together with the axiom @xmath306 and the replacement rule for @xmath21 ( which can be used here because both @xmath254 and @xmath307 are pure ) yield @xmath308 .",
    "as the latter are both pure terms we also have @xmath309 . *",
    "conversely , if @xmath310 then @xmath311 , which means that @xmath312 .",
    "the only remaining case is w.l.o.g . if @xmath297 is pure and @xmath298 is not .",
    "* then @xmath313 from proposition  [ prop : canonical - form ] as previously and @xmath314 satisfies @xmath315 for any assumed @xmath289 .",
    "indeed from @xmath316 we get @xmath317 but , on the one hand , @xmath318 so that point  [ lemm : onepureacc ] in lemma  [ lemm : eqns ] gives @xmath319 with @xmath320 . on the other hand , @xmath321 so that @xmath322 .",
    "thus equation  ( [ eq : fullpureacc ] ) rewrites as @xmath323 and point  [ lemm : lkpuseless ] in lemma  [ lemm : eqns ] yields @xmath324 thus now we also have @xmath325 . from the original equation @xmath326 we finally get @xmath327 * conversely , we start from @xmath328 and @xmath329 satisfying both equations  ( [ eq : pureaccfirst ] ) and  ( [ eq : pureaccsecond ] ) .",
    "then , we define @xmath330 which satisfies @xmath331 thanks to equation  ( [ eq : pureaccfirst ] ) .",
    "the latter is also @xmath332 which is thus @xmath333 thanks to equation  ( [ eq : pureaccsecond ] ) .",
    "the rule for states means that two modifiers coincide as soon as they return the same result and modify the state in the same way .",
    "this means that @xmath334 if and only if @xmath335 and @xmath336 . thanks to corollary  [ coro : downcast ] the equation @xmath335 is equivalent to an equation between accessors . it remains to prove that the equation @xmath336 is also equivalent to an equation between accessors .",
    "+ for @xmath337 , since @xmath338 , proposition  [ prop : canonical - form ] says that @xmath339 for some accessor @xmath340 .",
    "thus , @xmath336 if and only if @xmath341 . let us check that this equation is equivalent to @xmath291 . + clearly if @xmath342 then @xmath341 .",
    "conversely , if @xmath343 then @xmath344 and since @xmath253 we get @xmath345 , which is the same as @xmath291 because @xmath297 and @xmath298 are accessors . + thus , @xmath336 if and only if @xmath291 , as required ."
  ],
  "abstract_text": [
    "<S> this paper presents equational - based logics for proving first order properties of programming languages involving effects .    </S>",
    "<S> we propose two dual inference system patterns that can be instanciated with monads or comonads in order to be used for proving properties of different effects . </S>",
    "<S> the first pattern provides inference rules which can be interpreted in the kleisli category of a monad and the cokleisli category of the associated comonad . in a dual way </S>",
    "<S> , the second pattern provides inference rules which can be interpreted in the cokleisli category of a comonad and the kleisli category of the associated monad . </S>",
    "<S> the logics combine a 3-tier effect system for terms consisting of pure terms and two other kinds of effects called constructors / observers and modifiers , and a 2-tier system for up - to - effects and strong equations . </S>",
    "<S> each pattern provides generic rules for dealing with any monad ( respectively comonad ) , and it can be extended with specific rules for each effect . </S>",
    "<S> the paper presents two use cases : a language with exceptions ( using the standard monadic semantics ) , and a language with state ( using the less standard comonadic semantics ) . </S>",
    "<S> finally , we prove that the obtained inference system for states is hilbert - post complete . </S>"
  ]
}