{
  "article_text": [
    "in this section we recall a result about conditional kolmogorov complexity due to an .  muchnik  @xcite . by @xmath3",
    "we denote kolmogorov complexity of string @xmath4 , i.e. , the length of a shortest program generating @xmath4 .. the conditional complexity of @xmath4 given @xmath5 , the length of a shortest program that translates @xmath5 to @xmath4 , is denoted by @xmath6 , see @xcite .",
    "[ main - theorem ] let @xmath0 and @xmath1 be two binary strings , @xmath7 and @xmath8 .",
    "then there exists a string  @xmath2 such that    @xmath9 ;    @xmath10 ;    @xmath11 .",
    "this is true for all @xmath12 , and the constants hidden in @xmath13 do not depend on them .",
    "* remarks*. 1 . in the second inequality we can replace complexity @xmath14 of a string @xmath2 by its length @xmath15 .",
    "indeed , we can use the shortest description of @xmath2 instead of @xmath2 .",
    "we may let @xmath16 and replace @xmath17 by @xmath18 in the second inequality .",
    "we may also let @xmath19 .",
    "\\3 . finally ,",
    "having @xmath20 , we can delete @xmath13 last bits in @xmath2 , and the first and third inequalities will remain true .",
    "we come to the following reformulation of muchnik s theorem : _ for every two binary strings @xmath0 and @xmath1 there exist a binary string @xmath2 of length at most @xmath21 such that @xmath22 and @xmath23_.    informally , muchnik s theorem says that there exists a program @xmath2 that transforms @xmath1 to @xmath0 , has the minimal possible complexity @xmath21 up to a logarithmic term , and , moreover , can be easily obtained from @xmath0 .",
    "the last requirement is crucial , otherwise the statement becomes a trivial reformulation of the definition of conditional kolmogorov complexity .",
    "this theorem is an algorithmic counterpart of slepian  wolf theorem  @xcite in multisource information theory .",
    "assume that somebody ( * s * ) knows @xmath1 and wants to know @xmath0 .",
    "we know @xmath0 and want to send some message @xmath2 to * s * that will allow * s * to reconstruct @xmath0 .",
    "how long should be this message ?",
    "do we need to know @xmath1 to be able to find such a message ?",
    "muchnik s theorem provides kind of a negative answer to the last question , though we still need a logarithmic advice .",
    "indeed , the absolute minimum for a complexity of a piece of information @xmath2 that together with @xmath1 allows * s * to reconstruct @xmath0 , is @xmath21 .",
    "it is easy to see that this minimum can be achieved with logarithmic precision by a string @xmath2 that has logarithmic complexity conditional on @xmath0 and @xmath1 .",
    "but it turns out that in fact @xmath1 is not needed and we can provide @xmath2 that is simple conditional on @xmath0 and still does the job .    in many cases statements about kolmogorov complexity have combinatorial counterparts ( and sometimes it is easy to show the equivalence between complexity and combinatorial statements ) . in the present paper",
    "we study two different combinatorial objects closely related to muchnik s theorem and its proof .",
    "first ( sect .  [ online ] ) , we define the _ on - line matching _",
    "problem for bipartite graphs .",
    "we formulate some combinatorial statement about on - line matchings .",
    "this statement ( 1 )  easily implies muchnik s theorem and ( 2 )  can be proven using the same ideas ( slightly modified ) that were used by muchnik in his original proof .",
    "second ( sect .",
    "[ ext - muchnik - proof ] ) , following @xcite , we use extractors and their combinatorial properties . based on this technique , we give a new proof of muchnik s theorem . with this method",
    "we prove versions of this theorem for polynomial space kolmogorov complexity and also for some very special version of polynomial time kolmogorov complexity .",
    "this work was presented on the csr2009 conference in novosibirsk , russia on 1823 august , 2009 , and the conference version of the paper was published in csr2009 proceedings by springer - verlag .",
    "this version of the paper is slightly rearranged and extended .",
    "in this section we introduce a combinatorial problem that we call _ on - line matching_. it can be considered as an on - line version of the classical matching problem .",
    "then we formulate some combinatorial statement about on - line matchings and explain how it implies muchnik s theorem .",
    "finally , we provide a proof of this combinatorial statement ( starting with the off - line version of it ) thus finishing the proof of muchnik s theorem .",
    "consider a bipartite graph with the left part @xmath24 , the right part @xmath25 and a set of edges @xmath26 .",
    "let @xmath27 be some integer .",
    "we are interested in the following property of the graph :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ for any subset @xmath28 of @xmath24 of size at most @xmath27 there exists a subset @xmath29 that performs a bijection between @xmath28 and some @xmath30_. _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    a necessary and sufficient condition for this property is provided by the well - known hall s theorem .",
    "it says that _ for each set @xmath31 of size @xmath32 the set of all neighbors of elements of @xmath28 contains at least @xmath33 elements .",
    "_    r30 mm    this condition is not sufficient for the following on - line version of matching .",
    "we assume that an adversary gives us elements of @xmath24 ( up to @xmath27 elements ) one by one . at each step",
    "we should provide a counterpart for each given element @xmath34 , i.e. , to choose some neighbor @xmath35 not used before .",
    "this choice is final and can not be changed later .    providing a matching on - line ,",
    "when next steps of the adversary are not known in advance , is a more subtle problem than the usual off - line matching . now",
    "the hall s criterion , while still being necessary , is no more sufficient .",
    "for example , for the graph shown in the picture , one can find a matching for each subset of size at most 2 of the left part , but this can not be done on - line .",
    "indeed , we are blocked if the adversary starts with @xmath34 .",
    "now we formulate a combinatorial statement about on - line matching ; then we show that this property implies muchnik s theorem ( sect .",
    "[ proof - muchnik ] ) and prove this property ( sect .",
    "[ olm - exist ] ) .",
    "* combinatorial statement about on - line matchings * ( * om * ) .",
    "_ there exists a constant @xmath36 such that for every integers @xmath37 and @xmath38 there exists a bipartite graph @xmath26 whose left part @xmath24 has size @xmath39 , right part @xmath25 has size @xmath40 , each vertex in @xmath24 has at most @xmath41 neighbors in @xmath25 , and for which on - line matching is possible up to size @xmath42 . _",
    "note that the size of the on - line matching is close to the size of @xmath25 up to a polynomial factor , and the degrees of all @xmath24-elements are polynomially bounded , so we are close to hall s bound .",
    "first we show how ( om ) implies muchnik s theorem .",
    "we may assume without loss of generality that the _ length _ of the string @xmath0 ( instead of its complexity ) is less than @xmath37 .",
    "indeed , if we replace @xmath0 by a shortest program that generates @xmath0 , all complexities involving @xmath0 change by only @xmath13 term : knowing the shortest program for @xmath0 , we can get @xmath0 without any additional information , and to get a shortest program for @xmath0 given @xmath0 we need only to know the value of @xmath43 , because we can try all programs of length @xmath43 until one of them produces @xmath0",
    ". there may exist several different shortest programs for  @xmath0 ; we take that one which appears first when trying in parallel all programs of length @xmath43 . as we have said , for similar reasons it does not matter whether we speak about @xmath14 or @xmath15 in the conclusion of the theorem .",
    "we used @xmath14 to make the statement more uniform ; however , in the proof we get the bound for @xmath15 directly .",
    "we may assume that @xmath44 , otherwise the statement of theorem  [ main - theorem ] is trivial ( let @xmath45 ) .",
    "consider the graph @xmath46 provided by ( om ) with parameters @xmath37 and @xmath47 .",
    "its left part @xmath24 is interpreted as the set of all strings of length less than @xmath37 ; therefore , @xmath0 is an element of @xmath24 .",
    "knowing @xmath1 , we can enumerate all strings @xmath34 of length less than @xmath37 such that @xmath48 .",
    "there exist at most @xmath42 such strings , and @xmath0 is one of them .",
    "the property ( om ) implies that it is possible to find an on - line matching for all these strings ( in the order they appear during the enumeration ) .",
    "let @xmath2 be an element of @xmath25 that corresponds to @xmath0 in this matching .",
    "let us check that @xmath2 satisfies all the conditions of muchnik s theorem .",
    "first of all , note that the graph @xmath46 can be chosen in such a way that its complexity is @xmath13 .",
    "indeed , ( om ) guarantees that a graph with the required properties exists . given @xmath37 and @xmath47",
    ", we can perform an exhaustive search until the first graph with these properties is found .",
    "this graph is a computable function of @xmath37 and @xmath47 , so its complexity does not exceed the complexity of the pair @xmath49 , which is @xmath13 .",
    "if @xmath0 is given ( as well as @xmath37 and @xmath47 ) , then @xmath2 can be specified by its ordinal number in the list of @xmath0-neighbors .",
    "this list contains at most @xmath41 elements , so the ordinal number contains @xmath13 bits .",
    "to specify @xmath2 without knowing @xmath0 , we give the ordinal number of @xmath2 in @xmath25 , which is @xmath17 bits long . here",
    "we again need @xmath37 and @xmath47 , but this is another @xmath13 bits .",
    "to reconstruct @xmath0 from @xmath1 and @xmath2 , we enumerate all strings of lengths less than @xmath37 that have conditional complexity ( relative to @xmath1 , which is known ) less than  @xmath47 , and find @xmath25-counterparts for them using ( om ) until @xmath2 appears . then @xmath0 is the @xmath24-counterpart of @xmath2 in this matching .    formally speaking , for given @xmath37 and @xmath47 we should fix not only a graph @xmath50 but also some on - line matching procedure , and use the same procedure both for constructing @xmath2 and for reconstructing @xmath0 from @xmath1 and @xmath2 .",
    "it remains to prove the statement ( om ) .",
    "our proof follows the original muchnik s argument adapted for the combinatorial setting .",
    "first , let us prove a weaker statement when on - line matchings are replaced by off - line matchings . in this case",
    "the statement can be reformulated using hall s criterion , and we get the following statement :    * off - line version of ( om)*. _ there exists a constant  @xmath36 such that for any integers @xmath37 and @xmath38 there exists a bipartite graph @xmath26 whose left part @xmath24 is of size @xmath39 , the right part @xmath25 is of size @xmath51 , each vertex in @xmath24 has at most @xmath41 neighbors in @xmath25 and for any subset @xmath52 of size @xmath53 the set @xmath54 of all neighbors of all elements of @xmath55 contains at least @xmath33 elements . _    we prove this statement by probabilistic arguments .",
    "we choose at random ( uniformly and independently ) @xmath41 neighbors for each vertex @xmath56 . in this way",
    "we obtain a ( random ) graph where all vertices in @xmath24 have degree at most @xmath41 ; the degree can be less , as two independent choices for some vertex may coincide .",
    "we claim that this random graph has the required property with positive probability .",
    "if it does not , there exists a set @xmath52 of some size @xmath53 and a set @xmath57 of size less than @xmath33 such that all neighbors of all elements of @xmath55 belong to  @xmath57 . for fixed @xmath55 and @xmath57 the probability of this event",
    "is bounded by @xmath58 since we made @xmath59 independent choices ( @xmath41 times for each of @xmath33 elements ) and for each choice the probability to get into @xmath57 is at most @xmath60 ( the set @xmath57 covers at most @xmath60 fraction of points in @xmath25 ) .    to bound the probability of violating the required property of the graph",
    ", we multiply the bound above by the number of pairs @xmath55 , @xmath57 .",
    "the set @xmath55 can be chosen in at most @xmath61 different ways , since for each of @xmath33 elements we have at most @xmath39 choices ; actually the number is smaller since the order of elements does not matter . for @xmath57",
    "we have at most @xmath62 choices .",
    "further we sum up these bounds for all @xmath63 .",
    "therefore the total bound is @xmath64 this is a geometric series ; the sum is less than @xmath65 ( which is our goal ) if the base is small .",
    "the base is @xmath66 and @xmath67 makes it small enough , it even tends to zero as @xmath68 .",
    "off - line version is proven .",
    "now we have to prove ( om ) in its original on - line version .",
    "fix a graph @xmath26 that satisfies the conditions for the off - line version ( for given @xmath37 and @xmath47 ) .",
    "let us use the same graph in the on - line setting with the following straightforward ( `` greedy '' ) strategy .",
    "when a new element @xmath69 arrives , we check if it has neighbors that are not used yet . if yes , one of these neighbors is chosen to be a counterpart of @xmath34 . if not , @xmath34 is `` rejected '' .",
    "before we explain what to do with the rejected elements , let us prove that at most half of @xmath42 given elements could be rejected .",
    "assume that more than @xmath70 elements are rejected .",
    "then less than @xmath70 elements are served and therefore less than @xmath70 elements of @xmath25 are used as counterparts . but",
    "all neighbors of all rejected elements are used ( this is the only reason for rejection ) , and we get the contradiction with the condition @xmath71 if @xmath55 is the set of rejected elements .",
    "now we need to deal with rejected elements .",
    "they are forwarded to the `` next layer '' where the new task is to find on - line matching for @xmath70 elements .",
    "if we can do this , then we combine both graphs using the same @xmath24 and disjoint right parts @xmath72 and @xmath73 ; the elements rejected at the first layer are sent to the second one . in other terms : @xmath49 on - line problem is reduced to @xmath49 off - line problem and @xmath74 on - line problem .",
    "the latter can then be reduced to @xmath74 off - line and @xmath75 on - line problems etc .",
    "finally we get @xmath47 levels . at each level",
    "we serve at least half of the requests and forward the remaining ones to the next layer .",
    "after @xmath47 levels of filtering only one request can be left unserved , so one more layer is enough .",
    "note also that we may use copies of the same graph on all layers .",
    "more precisely , we have proven the following statement : _ let @xmath26 be a graph that satisfies the conditions of the off - line version for given @xmath37 and @xmath47 .",
    "replace each element in @xmath25 by @xmath76 copies , all connected to the same elements of @xmath24 as before .",
    "then the new graph provides on - line matchings up to size @xmath42 . _    note that this construction multiplies both the size of @xmath25 and the degree of vertices in @xmath24 by @xmath76 ( a polynomial in @xmath37 factor ) .",
    "the statement ( om ) is proven .",
    "in this section we present another proof of muchnik s theorem based on the notion of extractors .",
    "this technique was first used in a similar situation in  @xcite . with this technique",
    "we prove some versions of muchnik s theorem for resource - bounded kolmogorov complexity .",
    "this result was presented in the master thesis of one of the authors  @xcite .",
    "let @xmath50 be a bipartite graph with @xmath77 vertices in the left part and @xmath78 vertices in the right part .",
    "the graph may have multiple edges .",
    "let all vertices of the left part have the same degree @xmath79 .",
    "let us fix an integer @xmath80 and a real number @xmath81 .",
    "a bipartite graph @xmath50 is a @xmath82-extractor if for all subsets @xmath83 of its left part such that @xmath84 and for all subsets @xmath57 of the right part the inequality @xmath85 holds , where @xmath86 stands for the set of edges between @xmath83 and @xmath57 .    in the sequel",
    "we always assume that @xmath77 , @xmath78 and @xmath79 ( and sometimes other quantities denoted by uppercase letters ) are powers of @xmath87 , and use corresponding lowercase letters ( @xmath37 , @xmath88 , @xmath89 , etc . ) to denote their logarithms . in this case",
    "the extractor may be seen as a function that maps a pair of binary strings of length @xmath90 ( an index of a vertex on the left ) and of length @xmath91 ( an index of an edge incident to this vertex ) to a binary string of length @xmath92 ( an index of the corresponding vertex on the right ) .",
    "the extractor property may be reformulated as follows : consider a uniform distribution on a set @xmath83 of left - part vertices .",
    "the probability of getting a vertex in @xmath57 by taking a random neighbor of a random vertex in @xmath83 is equal to @xmath93 ; this probability must be @xmath94-close to @xmath95 , i.e. the probability of getting a vertex in @xmath57 by taking a random vertex in the right part .",
    "it can be proven that ( for an extractor graph ) a similar property holds not only for uniform distributions on @xmath83 , but for all distributions with min - entropy at least @xmath96 ( this means that no element of  @xmath24 appears with probability greater than @xmath97 ) .",
    "that is , an extractor extracts @xmath88 almost random bits from @xmath37 quasi - random bits ( with min - entropy @xmath47 or more ) using @xmath89 truly random bits . for a good extractor @xmath88 should be close to @xmath98 and @xmath89",
    "should be small ( as well as  @xmath94 ) .",
    "standard probabilistic argument shows that for all @xmath37 , @xmath47 and @xmath94 extractors with near - optimal parameters @xmath88 and @xmath89 do exist :          so far no explicit constructions of optimal extractors have been invented . by saying the extractor is _ explicit _ we mean that there exists a family of extractors for arbitrary values of @xmath37 and @xmath47 , other parameters are computable in time @xmath105 , and the extractor itself as a function of two arguments is computable in @xmath105 time .",
    "all known explicit constructions are not optimal in at least one parameter : they either use too many truly random bits , or not fully extract randomness ( i.e. , @xmath106 ) , or do not work for all values of @xmath47 . in the sequel we use the following theorem proven in  @xcite :          now we show how to prove muchnik s theorem using the extractor technique",
    ". consider an extractor with some @xmath77 , @xmath99 , @xmath79 , @xmath78 and @xmath94 .",
    "let @xmath83 be a subset of its left part such that @xmath114 .",
    "we say that a right - part element is _",
    "bad for @xmath83 _ if it has more than @xmath115 neighbors in @xmath83 ( twice more than the expected value if neighbors in the right part are chosen at random and @xmath83 has maximal possible size @xmath99 ) , and we say that a left - part element is _ dangerous in @xmath83 _ if all its neighbors are bad for @xmath83 .      we reproduce a simple proof from  @xcite . without loss of generality we may assume that @xmath83 contains exactly @xmath99 elements ( the sets of bad and dangerous elements can only increase when @xmath83 increases . )    for any graph the fraction of bad right - part vertices is at most  @xmath117 , because the degree of a bad vertex is at least twice as large as the average degree .",
    "the extractor property reduces this bound from @xmath117 to @xmath94 .",
    "indeed , let @xmath118 be the fraction of bad elements in the right part .",
    "then the fraction of edges going to bad elements ( among all edges starting at @xmath83 ) is at least @xmath119 . due to the extractor property",
    ", the difference between these fractions should be less than @xmath94 .",
    "the inequality @xmath120 follows .",
    "now we count dangerous elements in @xmath83 . if their fraction in @xmath83 is @xmath121 or more , then the fraction of edges going to the bad elements ( among all edges leaving @xmath83 ) is at least @xmath121 .",
    "but the fraction of bad vertices is less than @xmath94 , and the difference between two fractions should be less than @xmath94 due to the extractor property .",
    "now we present a new proof of muchnik s theorem . as we have seen before",
    ", we may assume without loss of generality that the length of @xmath0 is less than @xmath37 .",
    "moreover , as we have said , we may assume that conditional complexity @xmath21 equals @xmath122 ( otherwise we decrease @xmath47 ) and that @xmath123 ( otherwise the theorem is obvious , take @xmath45 ) .",
    "consider an extractor with given @xmath37 , @xmath47 ; let @xmath124 , @xmath125 and @xmath126 ; such an extractor exists due to theorem  [ ext - probabilistic ] .",
    "( the choice of @xmath94 will become clear later ) .",
    "we choose an extractor whose complexity is at most @xmath127 .",
    "it is possible , because only @xmath37 and @xmath47 are needed to describe such an extractor : other parameters are functions of @xmath37 and @xmath47 , and we can search through all bipartite graphs with given parameters in some natural order until the first extractor with required parameters is found .",
    "( this search requires a very long time , so this extractor is not explicit . )    now assume that an extractor is fixed .",
    "we treat the left part of the extractor as the set of all binary strings of length less than @xmath37 ( including @xmath0 ) , and the right part as the set of all binary strings of length @xmath125 ( we will choose @xmath2 among them ) .",
    "consider the set @xmath128 of all strings in the left part such that their complexity conditional on @xmath1 is less than @xmath47 ( @xmath0 belongs to this set ) .",
    "we want to apply lemma  [ fortnow - lemma ] to the set @xmath128 and prove that @xmath0 is not dangerous in @xmath128 ( by showing that otherwise @xmath21 would be too small ) .",
    "so @xmath0 has a neighbor @xmath2 that is not bad for @xmath128 , and this @xmath2 has the required properties .",
    "conditional complexity @xmath130 is logarithmic because @xmath2 is a neighbor of @xmath0 in the extractor and to specify @xmath2 we need a description of the extractor ( @xmath127 bits ) and the ordinal number of @xmath2 among the neighbors of @xmath0 ( @xmath131 bits ) .    as @xmath2 is not bad for @xmath128 , it has less than @xmath132 neighbors in @xmath128 .",
    "if @xmath1 is known , the set @xmath128 can be enumerated ; knowing @xmath2 , we select neighbors of @xmath2 in this enumeration .",
    "thus , to describe @xmath0 given @xmath2 and @xmath1 , we need only a description of the extractor and the ordinal number of @xmath0 in the enumeration of the neighbors of @xmath2 in @xmath128 , i.e. , @xmath133 bits in total .    *",
    "case 2*. assume that @xmath0 is dangerous in @xmath128 . since the set @xmath128 can be enumerated ( given @xmath1 )",
    ", the sets of all bad vertices ( for @xmath128 ) and all dangerous elements in @xmath128 can also be enumerated .",
    "therefore , @xmath0 can be specified by the string @xmath1 , the extractor and the ordinal number of @xmath0 in the enumeration of all dangerous elements in @xmath128 .",
    "this ordinal number consists of @xmath134 bits due to the choice of @xmath94 ( lemma  [ fortnow - lemma ] ) .",
    "so , the full description of @xmath0 given @xmath1 consists of @xmath135 bits ( here @xmath136 additional bits are needed for separating @xmath37 , @xmath47 and the ordinal number ) .",
    "this contradicts the assumption that @xmath137 .",
    "thus , the second case is impossible and muchnik s theorem is proven .",
    "let @xmath0 , @xmath1 and @xmath36 be binary strings , and let @xmath37 , @xmath47 and @xmath138 be numbers such that @xmath7 , @xmath8 and @xmath139 . then there exist binary strings @xmath2 and @xmath140 of length @xmath47 and @xmath138 respectively such that one of them is a prefix of the other one and all the conditional complexities @xmath141 , @xmath142 , @xmath130 , @xmath143 are of order @xmath13 .",
    "this theorem is quite non - trivial : indeed , it says that information about @xmath0 that is missing in @xmath1 and @xmath36 can be represented by two strings such that one is a prefix of the other ( though @xmath1 and @xmath36 could be totally unrelated ) .",
    "it implies also that for every three strings @xmath144 of length at most @xmath37 the minimal length of a program that transforms @xmath1 to @xmath0 and at the same time transforms @xmath36 to @xmath0 is at most @xmath145 .",
    "we say that a @xmath109-extractor @xmath146 is a _ prefix extractor _ if for every @xmath147 its prefix of length @xmath148 ( a function @xmath149 obtained by truncating @xmath150 last bits ) is a @xmath151-extractor .",
    "* proof : * this proof is quite similar to the standard proof of theorem  [ th : extractor - explicit ] . in that proof",
    "the probabilistic argument is used to show that a random graph has the required property with positive probability .",
    "in fact it is shown that this probability is not only positive but close to @xmath65 .",
    "then we show that the restriction of a random graph is also a random graph , and the intersection of several events having probability close to @xmath65 has a positive probability .",
    "let us explain these arguments in more detail .",
    "we want to show that a random bipartite graph with given parameters is a prefix extractor with a positive probability .",
    "first of all we note that it is enough to show that inequality  ( [ extractor ] ) holds for @xmath83 of size exactly @xmath99 .",
    "then this condition is true also for every bigger set @xmath83 , since the uniform distribution on @xmath83 is an average of the distributions on its subsets of size @xmath99 .",
    "second , it is enough to check the bound ( [ extractor ] ) only in one direction : @xmath154 ( for all sets @xmath83 of cardinality @xmath99 and for all @xmath57 ) .",
    "indeed , the inequality @xmath155 follows from the previous one applied to the complement of @xmath57 : if there are too few edges from @xmath83 to @xmath57 then there are too many edges from @xmath83 to the complement of @xmath57 .",
    "now we specify the distribution on graphs . for every string of length @xmath37 ( a vertex of the left part ) we choose at random ( uniformly and independently ) @xmath156 strings of length @xmath88 ( its neighbors in the right part ) .",
    "now we bound the probability of the event _ a random graph is not a prefix extractor_.    if the extractor property is violated for some prefix of length @xmath148 then there exists a set @xmath83 of @xmath157 elements from the left part and a set @xmath158 of size @xmath159 ( for some @xmath160 ) such that the number of edges between @xmath83 and @xmath57 is greater than @xmath161 . from the chernov bound it follows that probability of this event is not greater than @xmath162 .",
    "hence , probability of the event _ a random graph is not a prefix extractor _ can be limited by the sum of such bounds for all @xmath150 , @xmath83 , and @xmath57 : @xmath163 since @xmath164 , this sum does not exceed @xmath165 the condition of the theorem implies that @xmath166 , assuming that @xmath167 constant is large enough .",
    "hence , the second factor in each term of the sum is not greater than @xmath65 . respectively",
    ", the first factor equals @xmath168 which is less than @xmath169 , since @xmath170 .",
    "the sum of these terms is strictly less than @xmath65 .",
    "thus , probability of the event _ a random graph is a prefix extractor _ must be positive .",
    "however , using prefix extractors is not enough ; we need to modify the argument , since now we need to find two related neighbors in two graphs .",
    "so we modify the notion of a dangerous vertex and use the following analog of lemma  [ fortnow - lemma ] :    [ generalized - fortnow - lemma ] let us call a left - part element weakly dangerous in @xmath83 if at least half of its neighbors are bad for @xmath83 .",
    "then the number of weakly dangerous elements in @xmath83 is at most @xmath171 .",
    "now we give a new proof of theorem  [ prefix - extractor - theorem ] based on prefix extractors .",
    "fix a prefix extractor @xmath46 with parameters @xmath37 , @xmath47 , @xmath124 , @xmath125 and @xmath126 ( again , we may assume that complexity of this extractor is @xmath127 ) .",
    "we also may assume that @xmath172 , @xmath173 and ( without loss of generality ) @xmath174 .",
    "let @xmath128 and @xmath175 be the sets of strings of conditional complexity less than @xmath47 and @xmath138 conditional on @xmath1 and @xmath36 respectively .",
    "call an element _ weakly dangerous in @xmath128 _ if it is weakly dangerous ( in @xmath128 ) for the original extractor and _ weakly dangerous in @xmath175 _ if it is weakly dangerous ( in @xmath175 ) for the @xmath138-bit prefix of @xmath46 .",
    "since this prefix @xmath176 is also an extractor , the statement of lemma  [ generalized - fortnow - lemma ] holds for @xmath175 .",
    "the string @xmath0 belongs to the intersection of @xmath128 and @xmath175 and is not weakly dangerous in both .",
    "hence , a random neighbor of @xmath0 and its prefix are not bad for @xmath128 [ resp .",
    "@xmath175 ] with probability greater than @xmath117 .",
    "so we can find a @xmath47-bit string @xmath2 such that @xmath2 and its @xmath138-bit prefix @xmath140 are not bad for @xmath128 and @xmath175 respectively .",
    "they satisfy the requirements . indeed , the conditional complexities @xmath130 and @xmath143 are logarithmic because @xmath2 and @xmath140 can be specified by their ordinal numbers among the neighbors of @xmath0 in the extractor",
    ". the string @xmath0 may be obtained from @xmath2 and @xmath1 with logarithmic advice because @xmath2 is not bad for @xmath128 in @xmath46 ; similarly , @xmath0 can be obtained from @xmath140 and @xmath36 with logarithmic advice because @xmath140 is not bad for @xmath175 in @xmath176 .",
    "this completes the proof of muchnik s theorem for two conditions .      the arguments from sect .",
    "[ muchnik - with - extractor - section ] together with constructions of explicit extractors imply some versions of muchnik s theorem for resource - bounded kolmogorov complexity . in this section",
    "we present such a theorem for the space - bounded complexity .",
    "first of all , the definitions .",
    "let @xmath178 be a multi - tape turing machine that transforms pairs of binary strings to binary strings .",
    "conditional complexity @xmath179 is the length of the shortest @xmath34 such that @xmath180 produces @xmath0 in ( at most ) @xmath33 steps using space ( at most )  @xmath27 .",
    "it is known ( see  @xcite ) that there exists an _ optimal description method _ @xmath181 in the following sense : for every @xmath178 there exists a constant @xmath36 such that @xmath182 we fix such a method @xmath181 , and in the sequel use notation @xmath183 instead of @xmath184 .",
    "the proof of this theorem starts as an effectivization of the argument of sect .",
    "[ muchnik - with - extractor - section ] . to find @xmath2 effectively , we use an explicit extractor with parameters @xmath37 , @xmath47 , @xmath192 , @xmath125 and @xmath126 .",
    "we increase @xmath89 and respectively the conditional complexity of @xmath2 ( when @xmath0 is given ) from @xmath13 to @xmath112 , because ( currently known ) explicit extractors use more random bits than the ideal extractors from theorem  [ ext - probabilistic ] .",
    "the advantage is that to obtain @xmath2 from @xmath0 we now need only polynomial space ( in fact , even polynomial time ) .",
    "first we prove a weaker version of the theorem assuming that the value of @xmath27 is added as a condition ( in three complexities that are bounded by the theorem ) .",
    "later we explain how to get rid of this restriction .",
    "recall that a right - part element is bad if it has more than @xmath193 neighbors on the left and a left - part element is dangerous if all its neighbors are bad .",
    "let us show that if @xmath0 is not dangerous and @xmath2 is a neighbor of @xmath0 that is not bad , then we can recover @xmath0 from @xmath1 and @xmath2 using @xmath112 extra bits of information and @xmath194 space .",
    "for any string @xmath195 we can test in @xmath194 space whether @xmath196 : we test sequentially all programs of length less than @xmath47 and check if they produce @xmath195 on space @xmath27 given @xmath1 .",
    "simulating every such a program , we limit its workspace to @xmath27 , and prevent infinite loops by counting the number of steps . if a program makes more than @xmath197 steps in space @xmath27 then it loops ; here @xmath36 is some constant that depends only on the choice of the universal turing machine .",
    "this counter uses only @xmath198 space .",
    "therefore , given @xmath1 and @xmath2 we can enumerate all the strings @xmath195 that are neighbors of @xmath2 and @xmath196 , and wait until a string with a given ordinal number appears .",
    "the difficulty arises when we try to prove that @xmath0 is not dangerous .",
    "let us try to repeat our arguments taking into account the space restrictions .",
    "first we note that one can enumerate ( or recognize : for space complexity it is the same ) all bad elements in the right part using space @xmath194 .",
    "( as before , we assume here that @xmath27 is given in addition to @xmath37 , @xmath47 , and @xmath1 . ) indeed , bad elements ( as defined above ) have many neighbors among strings @xmath195 such that @xmath196 , and those strings can be enumerated .",
    "therefore , we can also enumerate all dangerous elements in the left part using space @xmath194 .",
    "we know also that the number of dangerous elements is small , but this does not give us a contradiction ( as it did before ) since the space used by this enumeration increases from @xmath27 to @xmath194 , and even a small increase destroys the argument .",
    "so we can not claim that @xmath0 is not dangerous and need to deal somehow with dangerous elements .    to overcome this difficulty",
    ", we use the same argument as in sect .",
    "[ olm - exist ] .",
    "we treat the dangerous elements on the next layer , with reduced @xmath47 and other extractor graph .",
    "we need @xmath199 layers ( in fact even @xmath200 layers ) since by lemma  [ fortnow - lemma ] at every next layer the number of dangerous elements that still need to be served is reduced at least by the factor @xmath121 .",
    "note also that the space overhead needed to keep the accounting information is @xmath105 and we never need to run in parallel several computations that require space @xmath27 ( this space is needed only at the bottom level of the recursion , in all other cases @xmath105 is enough ) .",
    "so we get the theorem in its weak form ( with condition @xmath27 ) . for the full statement",
    "some changes are needed .",
    "let us sequentially use space bounds @xmath201 : to enumerate all strings @xmath195 such that @xmath196 , we sequentially enumerate all strings that can be obtained from @xmath1 and a @xmath47-bit encoding using space @xmath202 , etc .",
    "the corresponding set increases as @xmath203 increases , and at some point we enumerate all strings @xmath195 such that @xmath196 ( though this moment is not known to us ) . note that we can avoid multiple copies of the same string for different values of @xmath203 : performing the enumeration for @xmath203 , we check for every string whether it has appeared earlier ( using @xmath204 instead of @xmath203 ) .",
    "this requires a lot of time , but only @xmath198 space . knowing the ordinal number of @xmath0 in the entire enumeration",
    ", we stop as soon as it is achieved ; hence , the enumeration process requires only space @xmath194 ( though @xmath27 is not specified explicitly ) .",
    "similarly , the set of dangerous words @xmath0 ( that go to the second or higher layer ) increases as @xmath203 increases , and can be enumerated sequentially for @xmath205 without repetitions in @xmath206 space .",
    "therefore , at every layer we can use the same argument ( enumerating all the elements that reach this layer and at the same time are neighbors of @xmath2 , until we produce as many of them as required ) .",
    "* remarks*. 1 .",
    "the process of enumerating @xmath195 such that @xmath207 sequentially for @xmath208 can be considered as the enumeration of all @xmath195 such that @xmath209 .",
    "so we just get the proof for the unrestricted version of muchnik s theorem with an additional remark : if an explicit extractor is used , then the short programs provided by this theorem require only slightly more space than the programs given in the condition .    2 .",
    "when we use several layers ( instead of a contradiction with the assumption that the complexity @xmath21 is exactly @xmath122 ) we in fact do not need to use small @xmath94 ( like @xmath210 that we have used in our argument ) ; small constant value of @xmath94 is enough .",
    "the arguments from the previous sections can not be applied for kolmogorov complexity with polynomial _ time _ bound .",
    "roughly speaking , the obstacle is the fact that we can not implement an exhaustive search over the list of ` bad ' strings in polynomial time unless @xmath212 .",
    "the best result that we can prove for poly - time bounded complexity involves a version of kolmogorov complexity introduced in  @xcite :          this definition is typically used for @xmath218 .",
    "intuitively , a @xmath211-description @xmath2 of a string @xmath34 ( given another string @xmath219 ) is an interactive arthur ",
    "merlin protocol : arthur himself can do probabilistic polynomial computations , and can ask questions to all - powerful but not trustworthy merlin ; merlin can do any computations and provide to arthur any requested certificate .",
    "so , arthur should ask such questions that the certificates returned by merlin could be effectively used to generate @xmath34 .",
    "with this version of resource - bounded kolmogorov complexity we have a variant of muchnik s theorem :    [ amd - theorem ] for every polynomial @xmath220 there exists a polynomial @xmath221 such that the following condition holds .",
    "for all strings @xmath222 of length at most @xmath37 such that @xmath223 , there exists a string @xmath2 of length @xmath224 such that      * proof : * in the proof of this theorem we can not use an arbitrary effective extractor .",
    "we employ very essentially properties of one particular extractor constructed by l.  trevisan  @xcite .",
    "our arguments mostly repeat the proof of theorem  3 from  @xcite .",
    "first of all we recall the definition of the trevisan extractor , which is based on the technique from the seminal paper by nisan and wigderson  @xcite . the first crucial ingredient of the trevisan function is a weak design .",
    "a system of sets @xmath227 is called a weak design with parameters @xmath228 if each @xmath229 consists of @xmath138 elements and for every @xmath230 the sum @xmath231 is bounded by @xmath232 .",
    "weak designs exist ; moreover , they can be constructed effectively .",
    "more precisely , there exists an algorithm that for any given @xmath233 generates a week design with @xmath234 in time polynomial in @xmath138 and @xmath88 , see  @xcite .",
    "let us fix a weak design as above .",
    "for @xmath235 we use the following notation : @xmath236 denotes the @xmath138-bit string that is obtained by projecting @xmath34 onto coordinates specified by @xmath229 .",
    "the second important ingredient of trevisan s construction is an error correcting code . for every positive integer @xmath37 and @xmath237 , there exists a list decodable code @xmath238 where @xmath239 , such that    1 .",
    "@xmath240 can be computed in polynomial time ; 2 .   given any @xmath241 ,",
    "the list of all @xmath242 such that @xmath243 and @xmath219 agree in at least @xmath244 fraction of bits , can be generated in time @xmath245 .",
    "in particular , this property means that the number of words @xmath34 in this list is not greater than @xmath245 ;      let us fix an encoding as above and denote @xmath247 .",
    "for @xmath248 the value @xmath249 is a string of length @xmath250 .",
    "so , we can view @xmath249 as a boolean function @xmath251 having fixed a weak design @xmath252 and an encoding @xmath253 , we define the trevisan function @xmath254 as @xmath255 we do not need to show that @xmath256 is an extractor ( for suitable values of @xmath257 ) ; in our proof we refer directly to the definition of this function .",
    "we will use the trevisan function for @xmath258 and @xmath259 .",
    "more precisely , the parameters are chosen as follows .",
    "numbers @xmath47 and @xmath37 are taken from the statement of the theorem ; @xmath247 is obtained from the construction of @xmath253 ; it remains to choose an appropriate @xmath88 and @xmath260 so that ( i ) there exists a week design with parameters @xmath261 , and ( ii ) the equation @xmath259 holds true .",
    "denote by @xmath262 the set of all strings whose time - bounded complexity conditional on @xmath1 is not greater than @xmath47 : @xmath263 ( obviously @xmath264 and @xmath265 ) .",
    "we have chosen such an @xmath88 that the @xmath256-image of @xmath262 ( i.e. , the set of values @xmath266 for some @xmath267 and @xmath268 ) covers at most @xmath269 of the set @xmath270 .",
    "denote by @xmath271 the predicate _ being in the @xmath256-image of @xmath262_. trivially , for every @xmath267 @xmath272-    \\operatorname{prob}_{r_1\\ldots r_m}[b(r_1\\ldots r_m)=1]\\ge 1/2\\ ] ] ( the first probability is equal to @xmath65 and the second one is not greater than @xmath117 ) .",
    "in other notation , we have @xmath273 - \\ \\ \\ { } \\\\      -\\operatorname{prob}_{r_1\\ldots r_m}[b(r_1\\ldots r_m)=1]\\ge 1/2           \\end{aligned}\\ ] ]",
    "we apply the standard ` hybridization ' trick : we note that for some @xmath150 @xmath274       -{}\\\\",
    "\\operatorname{prob}_{y , r_i , r_{i+1},\\ldots , r_m }       [ b(\\hat u(y|_{s_1 } ) \\hat u(y|_{s_2 } ) \\ldots \\hat u(y|_{s_{i-1 } } ) r_i \\ldots r_m     ) = 1 ]      \\ge 1/(2 m )      \\label{hybr - ineq }   \\end{gathered}\\ ] ] further , we can somehow fix the bits of @xmath219 outside of @xmath229 so that  ( [ hybr - ineq ] ) remains true .",
    "denote @xmath275 by @xmath34 .",
    "now all functions @xmath276 depend on @xmath277 bits from @xmath34 ( the other bits of @xmath219 are fixed ) .",
    "thus , every @xmath276 can be considered as a function @xmath278 , with a truth table of size @xmath279 .",
    "it follows that all functions @xmath280 ,  , @xmath281 together can be specified by @xmath282 bits ( the last inequality follows from the definition of weak designs ) .",
    "this argument holds for every @xmath283 .",
    "we are interested in the case @xmath284 , where @xmath0 is the string from the statement of the theorem .",
    "we denote by @xmath2 the concatenation of the truth tables of @xmath285 ,  , @xmath286 for @xmath284 ( so its length is less than @xmath88 ) . to specify this @xmath2 given @xmath0",
    ", we need to know only @xmath88 , @xmath150 and the bits of @xmath219 outside of @xmath229 .",
    "hence , @xmath287 .    in the rest of the proof",
    "we show that there exists an arthur  merlin protocol that reconstructs @xmath0 given @xmath1 , @xmath2 and some small additional information . since @xmath284 , it is enough to reconstruct the string @xmath288 ( then we apply the decoding procedure and find @xmath289 ) .",
    "( this is a standard argument from the computational xor lemma , see  @xcite . )",
    "now we fix a value of @xmath293 ( set it to @xmath294 or @xmath65 ) so that inequality  ( [ approx - ineq ] ) remains true .",
    "this bit must be included into the description of @xmath4 given @xmath1 and @xmath2 .",
    "we assume that @xmath295 , and in the sequel we omit @xmath293 in our notations . if the word @xmath2 defined above and a `` typical '' sequence @xmath296 are given , arthur can approximate @xmath288 and then reconstruct @xmath4 ( using decoding algorithm for @xmath253 ) .",
    "so , arthur chooses at random several copies of @xmath296 and tries to approximate @xmath288 with each copy .",
    "further we explain how it works .",
    "we say that @xmath297 provides an @xmath298-approximation of @xmath288 if @xmath299\\ge \\alpha$ ] .",
    "for every fixed @xmath300 we identify the function @xmath301 with the string @xmath302 of length @xmath303 where every @xmath34-th bit equals @xmath65 iff @xmath304 .",
    "so , the number of @xmath65 s in @xmath302 is equal to the number of strings @xmath34 such that @xmath305 .    _",
    "observation : _ if @xmath306 for some string @xmath307 , merlin can provide a certificate for this fact .",
    "indeed , he communicates to arthur ( i ) some @xmath308 such that @xmath309 , and ( ii ) provides a poly - time program @xmath310 of length at most @xmath47 such that @xmath311 stops in @xmath220 steps and returns @xmath4 ( i.e. , merlin proves to arthur that @xmath267 ) .",
    "we say that a string @xmath312 is a _ candidate _ if at least @xmath313 of all @xmath314 provide an @xmath315-approximation for @xmath5 . from the decoding property of the code @xmath253",
    ", each @xmath316 can be an approximation for at most @xmath317 different codewords @xmath249 .",
    "hence , there exist at most @xmath318 candidates ( of course , @xmath288 is a candidate ) .",
    "by sipser s @xmath319-coding theorem  @xcite there exists a poly - time program @xmath320 of length @xmath321 that accepts @xmath288 and rejects all other candidates ( no warranty about non - candidates : @xmath320 may accept or reject any of them ) .    *",
    "first part of the arthur ",
    "merlin protocol * : denote @xmath322 this is the average number of strings @xmath323 such that @xmath324 for a random @xmath297 . at first",
    "arthur chooses @xmath27 random strings @xmath325 of length @xmath326 ( a polynomial @xmath327 will be specified below ) .",
    "he asks merlin to generates @xmath328 ( @xmath329 is specified in what follows ) certificates for the facts that different tuples @xmath330 satisfy @xmath331 , and verifies these certificates . if at least one certificate is false , arthur stops without any answer .",
    "if the certificates are ok , arthur calculates @xmath332 , where @xmath34-th bit of @xmath333 is @xmath65 iff merlin provided a certificate of the fact that @xmath331 .",
    "[ lemma1 ] for some rational @xmath334 and integer @xmath335 , with probability at least @xmath336 merlin can provide @xmath328 certificates corresponding to random @xmath325 , and ( whatever certificates are chosen by merlin ) the following two conditions hold :    * at least @xmath337 of the strings @xmath338 ( corresponding to the certificates given by merlin ) provide some @xmath315-approximation to @xmath288 . * for every @xmath5 , if at least @xmath339 of the strings @xmath338 provide some @xmath315-approximation to @xmath5 , then @xmath5 is a candidate .        *",
    "second part of the arthur  merlin protocol*. arthur does not need anymore to communicate with merlin .",
    "now he composes the list of all codewords @xmath5 that are @xmath315-close ( coincide on a fraction at least @xmath315 of bits ) to at least @xmath341 of strings @xmath342 . from lemma  [ lemma1 ]",
    "it follows that with probability at least @xmath336 all strings in this list are candidates , and the string @xmath288 is included in the list .",
    "the program @xmath320defined above can distinguish @xmath288 from other strings from the list .",
    "thus , arthur can find @xmath288 in polynomial time if he is given @xmath343 and the following additional information : the index @xmath150 , the bit @xmath293 , the mean value @xmath344 of positive values of @xmath271 , and the distinguishing program @xmath320 .",
    "in fact , it is enough to know not the exact value of @xmath344 but only an approximation to this number ; this approximation must be precise enough so that arthur can find the integer part of @xmath345 .",
    "thus , the required additional information contains only @xmath13 bits .",
    "now it is not hard to check that the described protocol of generating @xmath0 satisfies the definition of @xmath211-complexity .",
    "let us summarize the argument .",
    "the @xmath211-program for @xmath0 consists of ( i ) the truth tables of @xmath285 ,  , @xmath286 for @xmath284 ( this is the most important part ; we denoted is by @xmath2 ) , ( ii ) the bit @xmath293 chosen so that ( [ approx - ineq ] ) is true , ( iii ) a rational @xmath340 and an approximation to a rational @xmath344 , and ( iv ) sipser s code @xmath320 that distinguishes @xmath288 between all `` candidates '' . the arthur ",
    "merlin protocol works as follows .",
    "arthur chooses at random strings @xmath325 .",
    "merlin provides @xmath328 certificates corresponding to these @xmath346 .",
    "arthur computes the list of @xmath347 ( strings with many approximations ) corresponding to the obtained certificates .",
    "then arthur selects @xmath288 from the list of @xmath348 using @xmath320 , and computes @xmath349 .",
    "if merlin is fair , this plan works ok with probability at least @xmath336 ( lemma  [ lemma1 ] ) .",
    "if merlin wants to cheat , he has two options : provide a list of certificates such that the required string @xmath288 is not in the list of @xmath347 , or such that at least one of @xmath348 is not a candidate ( in these cases arthur fails to select @xmath288 using @xmath320 ) .",
    "however from lemma  [ lemma1 ] it follows that for random @xmath347 both these options are closed with probability at least @xmath336 .",
    "this article is based on the discussions and results reported at the kolmogorov seminar ( moscow ) .",
    "preliminary versions appeared as @xcite and @xcite .",
    "the authors are grateful to all participants of the seminar for many useful comments .",
    "a.  shen , combinatorial proof of muchnik s theorem , _ kolmogorov complexity and applications _ , m.  hutter , w.  merkle , p.  vitanyi , eds .",
    ", dagstuhl seminar proceedings 06051 , issn 18624405 , ` http://drops.dagstuhl.de/opus/volltexte/2006/625 ` ."
  ],
  "abstract_text": [
    "<S> muchnik s theorem about simple conditional descriptions states that for all strings @xmath0 and @xmath1 there exists a program @xmath2 transforming @xmath0 to @xmath1 that has the least possible length and is simple conditional on  @xmath1 . in this paper </S>",
    "<S> we present two new proofs of this theorem . the first one is based on the on - line matching algorithm for bipartite graphs . </S>",
    "<S> the second one , based on extractors , can be generalized to prove a version of muchnik s theorem for space - bounded kolmogorov complexity . </S>",
    "<S> another version of muchnik s theorem is proven for a resource - bounded variant of kolmogorov complexity based on arthur  merlin protocols . </S>"
  ]
}