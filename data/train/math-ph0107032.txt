{
  "article_text": [
    "@xcite describes how computational group theory provides tools for manipulating tensors with free indices .",
    "the tensors obey what we call _ permutation symmetries _ , which are a set of tensor equations of the form @xmath0 where @xmath1 is a permutation of @xmath2 and @xmath3 is either 1 or @xmath4 .",
    "this kind of symmetry can be described by finite group theory and the index manipulation can be performed using the algorithms of computational group theory @xcite .",
    "the detailed description of symmetry as a group is given in ref .",
    "@xcite .    in this work",
    "we address the problem of applying computational group theory for manipulating dummy indices .",
    "it is more complex then the free index problem , since one has to deal with two groups : the group that describes the symmetries of the indexed object and the group that describes the symmetry of interchange of dummy indices .",
    "these groups act on a standard index configuration , generating sets of equivalent configurations .",
    "these sets are double cosets , which have already been studied in computational group theory @xcite .",
    "the most important concept for simplifying tensor expressions is the determination of canonical forms , which correspond to canonical representatives of single cosets for free indices and double cosets for dummy indices .",
    "the algorithms of the present work and the algorithms of refs .",
    "@xcite , @xcite , and @xcite allow the manipulation of expressions built out of indexed objects obeying permutation symmetries , such as tensors , spinors , objects with gauge indices , and so on , with commutative or anticommutative properties . on the other hand",
    ", these algorithms do not solve yet the problem when there are algebraic constraints , such as the cyclic symmetry of the riemann tensor .",
    "manipulation of dummy indices can also be found in general algebraic expressions with sums and multiple integrals .",
    "for instance , the calculation of feynman diagrams in quantum field theory generates a large number of multiple integrals of the propagator which can in principle be reduced using the algorithms of this work by canonicalizing the integration variables .",
    "the structure of this paper is as follows . in section 2",
    "we describe the representation theory for dummy indices . in section 3",
    "we describe the algorithm to canonicalize indexed objects with dummy indices , and in section 4 we discuss the algorithm complexity . in section 5",
    "we discuss the simplification of general expressions in order to have a birds - eye view of the problem , and present an example of canonicalizing a riemann monomial of degree 3 .",
    "we assume that the reader is familiar with the concepts and notations described in ref .",
    "suppose that @xmath5 is a fully contracted rank-@xmath6 tensor with symmetry @xmath7 .",
    "we define the standard configuration as @xmath8 this configuration is associated with permutation @xmath9 , which is the least element of the symmetric group @xmath10 .",
    "our first task is to determine the configurations that are equivalent to ( [ abs ] ) .",
    "we know that the dummy index names can be interchanged .",
    "for example , the configuration @xmath11 is equivalent to ( [ abs ] ) and is obtained by the action of the element @xmath12 on ( [ abs ] ) .",
    "this element is not in @xmath7 in general .",
    "if the metric is symmetric , the configuration @xmath13 is also equivalent to ( [ abs ] ) and is obtained by the action of the element @xmath14 .",
    "what is the group that describes these kinds of symmetries ?",
    "let @xmath15 be a subgroup of @xmath16 generated by @xmath17 with the base @xmath18 $ ] .",
    "@xmath19 is a strong generating set with respect to @xmath20 .",
    "the action of @xmath15 on configuration ( [ abs ] ) yields all configurations that can be obtained from ( [ abs ] ) by interchanging dummy index names or by using the symmetry of the metric .    besides the action of @xmath15",
    ", we consider the action of @xmath7 .",
    "if we take configuration ( [ abs ] ) as the starting point , similar as we have done for the free index case , we have to apply @xmath15 first , followed by @xmath7 in order to obtain all configurations equivalent to ( [ abs ] ) .",
    "this order is crucial .",
    "if one applied an element of @xmath7 first , the positions of the dummy indices would change and the application of @xmath15 on this new configuration would make no sense",
    ". it would not be an interchange of dummy index names nor an interchange of contravariant index to a covariant one inside a pair .",
    "let us see an example .",
    "suppose that @xmath21 , and let us apply @xmath22 on configuration ( [ abs ] ) followed by @xmath23 .",
    "we obtain @xmath24 which is not equivalent to ( [ abs ] ) at all .",
    "the reverse order is perfectly fine , let us apply @xmath25 first , followed by @xmath22 : @xmath26 the configuration above is equivalent to ( [ abs ] ) .",
    "the set ( @xmath27 ) of all configurations equivalent to ( [ abs ] ) is given by the action of @xmath28 on ( [ abs ] ) , i.e. @xmath29 the set @xmath28 is the double coset of @xmath7 and @xmath15 in @xmath16 that contains the identity @xmath9 .",
    "the cardinality of this set is @xmath30 .",
    "consider a fully contracted configuration ( @xmath31 ) that is not equivalent to ( [ abs ] ) , one can take ( [ e6 ] ) as an example .",
    "suppose that @xmath31 is obtained by acting @xmath32 on ( [ abs ] )",
    ". then @xmath33 .",
    "the set of all configurations equivalent to @xmath31 is given by the action of the double coset @xmath34 on ( [ abs ] ) .",
    "the cardinality of this set is @xmath35 , where @xmath36 is the conjugate set @xmath37 @xcite .",
    "now we address the following problem .",
    "suppose one gives a fully contracted rank-@xmath6 tensor which has some symmetry described by a set of tensor equations of the form ( [ ts ] ) .",
    "find the canonical index configuration using the tensor symmetries , renaming of dummy indices , and the metric symmetries .    in representation theory ,",
    "this problem can be solved if one knows the solution of the following equivalent problem .",
    "given a generating set @xmath38 for the group @xmath7 , and an element @xmath39 , find the canonical representative of the double coset @xmath34 , where @xmath15 is the group generated by ( [ e4 ] ) with respect to the base @xmath20 .",
    "butler @xcite describes an algorithm for determining the double coset canonical representative for permutations groups .",
    "the input of his algorithm is :    \\(a ) a permutation group @xmath40 acting on a set @xmath41 with a base @xmath42 $ ] ; + ( b ) subgroups @xmath43 and @xmath44 of @xmath40 given by a base and strong generating set ; and + ( c ) an element @xmath32 of @xmath40 .",
    "the algorithm determines the image of the base @xmath45 under the first element of the double coset @xmath46 .",
    "we modify butler s algorithm in order to work within the direct product @xmath16 . fortunately ,",
    "in the tensor problem , the subgroup @xmath15 is fixed and we know beforehand a base and a strong generating set for it .",
    "butler s algorithm keeps changing the base for the subgroup @xmath44 ( see item ( b ) above ) during the determination of the image of the canonical representative .",
    "this base change is very simple for group @xmath15 .",
    "suppose that the settings in terms of tensor notation have already been converted into group notation .",
    "so , the input of the algorithm is :    \\(a ) @xmath47 ; + ( b ) a base @xmath48 $ ] and strong generating set @xmath38 for @xmath7 ; and + ( c ) an element @xmath39 .",
    "the output is either the canonical representative @xmath49 of the double coset @xmath50 or 0 .",
    "the output 0 occurs if and only if both @xmath51 and @xmath52 are in @xmath50 . to have the solution in terms of tensor notation",
    "when the output is not 0 , one simply acts @xmath53 on ( [ abs ] ) .",
    "the algorithm basically consists of @xmath54 loops .",
    "we describe the first two loops , which are enough to understand the whole process .",
    "the algorithm is formally described ahead .",
    "the base @xmath55 must be extended in order to be a base for @xmath10 .",
    "let @xmath56 $ ] be the extended base and @xmath57 $ ] the image of the canonical representative .",
    "the goal is to find @xmath58 each at a time .",
    "first loop determines @xmath59 .",
    "the orbit @xmath60 gives all possible values of the first point of the image of the elements of the double coset @xmath34 .",
    "call this set images@xmath61 .",
    "@xmath59 is the least point of images@xmath61 with respect to @xmath55 .",
    "so , if @xmath62 then @xmath63 the least point is calculated with respect to base @xmath55 .",
    "the order of points is @xmath64 . before finding @xmath65",
    ", we have to determine the pairs of elements @xmath66 of @xmath67 that satisfy @xmath68 since , from now on , @xmath59 must remain as the first point .",
    "suppose that @xmath66 is a pair that satisfies ( [ b1 ] ) , then @xmath69 so we have to determine a small set of pairs @xmath66 and amplify it by using the stabilizers @xmath70 and @xmath71 in order to obtain all pairs @xmath66 that satisfy ( [ b1 ] ) .",
    "notice that to determine @xmath71 , we have to perform a base change so that @xmath59 becomes the first point of @xmath15 .",
    "this is easily performed .",
    "the pairs @xmath66 are stored in table tab defined in the following way : @xmath72)=(s_1,d_1),\\,[i]\\in { \\rm alpha}_1 ,   \\label{tab}\\ ] ] where alpha@xmath61 is defined by @xmath73,\\ , i \\in b_1^s\\,{\\rm and}\\,i^g\\in p_1^d\\}.   \\label{a}\\ ] ] the size of list @xmath74 $ ] is given by the index 1 of alpha@xmath61",
    ". one can find alpha@xmath61 using @xmath75 we omit the dependence of @xmath66 on the entries of alpha@xmath61 , since the explicit notation @xmath76),d_1([i]))$ ] is cumbersome .",
    "it is important to keep in mind that for each entry of alpha@xmath61 there is a correspondent pair @xmath66 .",
    "note that the variables with index 1 are calculated in the first loop of the algorithm .",
    "the pair @xmath66 corresponding to @xmath74 $ ] is given by @xmath77 where @xmath78 and @xmath79 are the schreier vectors relative to the orbits of @xmath7 and @xmath15 respectively .",
    "first loop finishes here .    for each pair",
    "@xmath66 we calculate @xmath80 in order to obtain @xmath81\\in { \\rm alpha}_1 }   \\left ( ( b_2^{s_{b_1}})^{s_1\\ , g \\ , d_1 } \\right ) ^{d_{p_1}}.   \\label{images2}\\ ] ] images@xmath82 yields all images of @xmath83 in the double coset @xmath34 obeying the constraint ( [ b1 ] ) .",
    "then @xmath65 is the least point of images@xmath82 .",
    "now we show how to find alpha@xmath82 and the associated pairs @xmath84 . at this point ,",
    "a pair @xmath84 has the following property : @xmath85^{{s_2}\\ , g \\ , { d_2 } } = [ p_1,p_2 ] .",
    "\\label{b1b2}\\ ] ] for each pair @xmath84 , define @xmath86 this is the set of images of @xmath83 in @xmath7 that yields @xmath65 after applying @xmath32 and @xmath87 .",
    "this set gives the points that extend alpha@xmath61 .",
    "so @xmath88,\\ , [ i ] \\in { \\rm alpha}_1,\\ ,   j\\in { \\rm next}_2\\}.   \\label{aij}\\ ] ] for each @xmath89 $ ] in alpha@xmath82 we have to determine a pair @xmath84 that satisfies @xmath85^{s_{b_1,b_2}\\times { s_2 } \\ , g \\",
    ", { d_2 } \\times d_{p_1,p_2 } } =   [ p_1,p_2 ] .",
    "\\label{b1b2_2}\\ ] ] let @xmath90 where @xmath91 and @xmath92 are the schreier vectors relative to the orbits of the stabilizers @xmath93 and @xmath94 respectively .",
    "we define the new entries of tab as @xmath95)=(s_2,d_2),\\,[i , j]\\in { \\rm alpha}_2 ,   \\label{tab2}\\ ] ] and clear the old ones .",
    "second loop finishes here .    in the @xmath96th loop ,",
    "images@xmath97 is given by @xmath98 where @xmath99 and @xmath100 are obtained from tab(@xmath101 ) .",
    "next@xmath97 is given by @xmath102 and the pairs @xmath103 obey @xmath104^{s_i\\,g\\,d_i}=[p_1,\\cdots , p_i ] .",
    "\\label{sidi}\\ ] ]    now we present algorithm canonical for dummy indices and the sub - routines @xmath105 and @xmath106 .",
    "we use a pseudo - language that can be converted into programs of some computer algebra system .    * algorithm canonical ( dummy indices ) *    * procedure *  double_coset_can_rep(@xmath47,@xmath107,@xmath38,@xmath32 ) +   + * input : * = @xmath47 number of pairs of dummy indices ; + @xmath48 $ ] base of group @xmath7 ; + @xmath38 strong generating set of @xmath7 with respect to base @xmath55 ; and + an element @xmath39",
    ". +   + * output : * = @xmath49 canonical representative of the double coset @xmath50 or + 0 if @xmath51 and @xmath52 are in @xmath50 .",
    "+ = = = = = = + * begin * + @xmath108 $ ] is the extension of @xmath55 in order + to be a base for @xmath10 ; + if metric is symmetric then + @xmath109=@xmath110 + @xmath111 ; + else_if metric is antisymmetric then + @xmath112 + @xmath111 ; + else + @xmath113 ; + end if ; + @xmath20:=@xmath114 $ ] ; + @xmath115 initialize table tab and alpha @xmath116 + tab([]):=@xmath117 ; + alpha@xmath118\\}$ ] ; +   + for @xmath96 from 1 to @xmath119 do + @xmath120all orbits of @xmath7 ( and calculate @xmath78 - schreier vector with respect to @xmath55 ) ; + @xmath121 ; + @xmath122 all orbits of @xmath19 ; + @xmath115 images is given by eq .",
    "( [ i m ] ) @xmath116 + images:=map @xmath105 on each entry of alpha passing tab , + @xmath123 , @xmath124 and @xmath32 as extra arguments ; + @xmath125least point of images with respect to base @xmath55 ; + @xmath126remove @xmath127 and move @xmath128 ( or @xmath129 if @xmath128 is even ) to the 1st + position in @xmath20 ; + @xmath130schreier vector of @xmath19 with respect to @xmath20 ; + @xmath131 ; +   + for each @xmath101 in alpha do + @xmath1321st element of tab(@xmath101 ) ; + @xmath1332nd element of tab(@xmath101 ) ; + next@xmath134 ; +   + for each @xmath135 in next do + @xmath136 ; + @xmath137 @xmath138 ; + @xmath139 append @xmath135 to @xmath101 ; + tab(@xmath140):=@xmath66 ; + end for ; + clear(tab(@xmath101 ) ) ; + end for ; +   + alpha:=indices of tab that were assigned ; +   + @xmath115 verify if there are 2 equal permutations of opposite sign in @xmath34 @xmath116 + if either @xmath38 or @xmath19 has some permutation with @xmath4 then + @xmath115 calculate @xmath141 for all @xmath142 in tab @xmath116 + set_sgd@xmath143map @xmath106 on each entry of alpha passing tab + and @xmath32 as extra arguments ; + if set_sgd has two equal permutations with opposite sign then + break the loop and + 0 ; + end if ; + end if ; +   + @xmath115 find the stabilizers @xmath144 and @xmath145 @xmath116 + @xmath146remove permutations that have point @xmath147 from @xmath38 ; + @xmath148remove permutations that have point @xmath128 from @xmath19 ; +   + end for ; +   + @xmath149(any entry of alpha ) ; + @xmath53 ; + * end * +    * sub routine @xmath105 *    * procedure *  @xmath105(@xmath101,tab,@xmath123,@xmath124,@xmath32 ) +   + * input : * = @xmath101 some entry of alpha ; + tab table of elements @xmath142 ; + @xmath123 all orbits of @xmath19 ; + @xmath124 orbit of some @xmath147 ; and + @xmath39 . +   + *",
    "output : * = @xmath150 , where @xmath151 and @xmath152 are the permutations associated with @xmath101 .",
    "+ tab(@xmath101 ) yields @xmath151 and @xmath152 .",
    "+ = = = = = + * begin * + @xmath153tab@xmath154 ) ; + : = select the points of all partitions of @xmath123 that + have at least one point in @xmath155 ; + ; + * end * +    * sub routine @xmath106 *    * procedure *  @xmath106(@xmath101,tab,@xmath32 ) +   + * input : * = @xmath101 some entry of alpha ; + tab table of elements @xmath142 ; + @xmath39 . +   + * output : * = @xmath141 , where @xmath151 and @xmath152 are the permutations associated with @xmath101",
    ". + = = = = = + * begin * + @xmath132 1st element of tab(@xmath101 ) ; + @xmath133 2nd element of tab(@xmath101 ) ; + @xmath156 ; + ; + * end * +",
    "the complexity of the general algorithm to find double coset canonical representative is known to be exponential in the worst case @xcite . on the other hand ,",
    "the symmetries of tensor expressions are special cases of subgroups of @xmath16 , and actual verifications show that in practical applications the algorithm is efficient .",
    "the symmetries of the riemann tensor are one of the most complex that occur in practice .",
    "therefore , monomials built out of riemann tensors are examples of complex tensor expressions . we have implemented algorithm canonical and the auxiliary routines in maple system @xcite and have developed a program that generates at random riemann monomials of any degree ( number of riemann tensors ) with all indices contracted ( riemann scalar invariants ) . for each riemann monomial",
    "we calculate the timing to find the canonical representative .",
    "we use a pc with a processor of 600mhz .",
    "the vertical axis of the plot of fig .",
    "1 is the mean of 50 timings for each monomial .",
    "the horizontal axis is the degree .",
    "we have eliminated all timings of vanishing results .    to    [ fig.1 ]",
    "> from fig . 1",
    "one can not prove that the algorithm is polynomial .",
    "it only shows that the implementation in maple can handle monomials with large number of indices .",
    "the storage space is very low in order to produce the data . if we try to fit the experimental curve by a polynomial of the form @xmath157 , for @xmath158 the dashed curve passes above the experimental curve , and for @xmath159 the dashed curve passes below for most of the points .",
    "the best polynomial using the least square method is @xmath160 .",
    "notice that the deviation from the polynomial curve depends on the degree due to the fact that 50 timings give worse and worse statistics with increasing degree .",
    "consider an algebraic expression with indexed objects of tensorial nature .",
    "the product of these objects can be commutative or anticommutative .",
    "if we expand the expression , it becomes a sum of monomials .",
    "@xcite and @xcite describe a method for merging monomials into single indexed objects , which inherit the symmetries of the original objects .",
    "the commutative or anticommutative properties are converted into permutation symmetries of the merged object . at the end",
    ", the problem of manipulating an expression reduces to the problem of dealing with single indexed objects with free and dummy indices obeying permutation symmetries .    without loss of generality ,",
    "suppose that the merged object is a tensor @xmath5 with @xmath161 free indices and @xmath162 pairs of dummy indices .",
    "we define the standard configuration as @xmath163 we do not distinguish contravariant free indices from covariant ones . if the original configuration has covariant free indices , we pretend that they are contravariant and proceed until the end , when the character of the covariant indices is restored .",
    "this means that there is no preference of putting contravariant free indices in front of covariant ones or vice - versa .",
    "the minimal order is dictated by the base of @xmath7 which we do not know a priori , since it is built out by the strong generating set algorithm .",
    "this choice follows the criteria of least computational effort .",
    "all configurations of ( [ abscon ] ) taking into account sign changes are given by the application of elements in @xmath164 on ( [ abscon ] ) .",
    "suppose one gives an index configuration .",
    "the algorithms to canonicalize free and dummy indices can be applied in sequence on this configuration .",
    "the first step is the application of the algorithm of ref .",
    "@xcite in order to find the canonical ordering and positions of the free indices .",
    "the next step is the application of the algorithm of section 3 , translating the points @xmath165 $ ] to the current positions of dummy indices .",
    "if @xmath166 $ ] are the new positions in increasing order , then group @xmath15 is strongly generated by @xmath167 with respect to the base @xmath168 $ ] , if the metric is symmetric .    for example , let @xmath169 be the riemann tensor and we want to canonicalize expression @xmath170 ref .",
    "@xcite describes how this expression merges into a single tensor , which is @xmath171 with the following permutations symmetries @xmath172 @xmath38 is a strong generating set .",
    "the standard configuration is @xmath173 the element of @xmath174 , which acts on the standard configuration ( [ tstan ] ) and yields ( [ t ] ) , is @xmath175 now we call the algorithm canonical for free indices ( ref .",
    "@xcite ) with the following input : @xmath176 , @xmath38 , and @xmath177 $ ] .",
    "we are using the simplest base in order to help the visualization of the order of the indices , and we are aware that it has unnecessary points .",
    "the output of the algorithm is @xmath178 which corresponds to @xmath179 the free indices are in the canonical positions , which are given by @xmath180^{{\\,g_2}\\,^{-1}}=[1,3 ] ,   \\label{f12}\\ ] ] and the positions of dummy indices are @xmath181^{{\\,g_2}\\,^{-1}}=[7,11,2,5,10,6,8,9,12,4 ] .",
    "\\label{d12}\\ ] ] sorting with respect to the basis and concatenating ( [ f12 ] ) , ( [ d12 ] ) ; converting to disjoint cycle notation we obtain @xmath182 which is the group element that converts @xmath19 given by ( [ e4 ] ) to @xmath183 given by ( [ kdbar ] ) via conjugation , i.e. @xmath184 . the input of the algorithm canonical for dummy indices ( section 3 ) is @xmath185 @xmath186,\\ ] ] and @xmath187 the algorithm must be modified so that the generating set for group @xmath15 must be @xmath188 with base @xmath189 $ ] .",
    "the output is @xmath190 the permutations @xmath191 and @xmath192 do not act on the standard configuration ( [ tstan ] ) .",
    "they act on @xmath193 the final answer is @xmath194 in terms of tensor notation , the canonical form is @xmath195 which is obtained acting @xmath196 on ( [ tstan ] ) and splitting back the merged tensor ."
  ],
  "abstract_text": [
    "<S> computational group theory is applied to indexed objects ( tensors , spinors , and so on ) with dummy indices . </S>",
    "<S> there are two groups to consider : one describes the intrinsic symmetries of the object and the other describes the interchange of names of dummy indices . </S>",
    "<S> the problem of finding canonical forms for indexed objects with dummy indices reduces to finding double coset canonical representatives . </S>",
    "<S> well known computational group algorithms are applied to index manipulation , which allow to address the simplification of expressions with hundreds of indices going further to what is needed in practical applications .    </S>",
    "<S> symbolic tensor manipulation , computational group theory , algorithms , canonical coset representative , symmetric group    * group - theoretic approach for symbolic tensor manipulation : ii . </S>",
    "<S> dummy indices *    l. r. u. manssur and r. portugal    laboratrio nacional de computao cientfica , + av . getlio vargas , 333 , + petrpolis , rj , brazil . </S>",
    "<S> cep 25651 - 070 . </S>"
  ]
}