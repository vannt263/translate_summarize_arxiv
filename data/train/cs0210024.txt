{
  "article_text": [
    "scheduling problems have been studied extensively from the point of view of the objectives of the enterprise that stands to gain from the completion of a set of jobs .",
    "we take a new look at the problem from the point of view of the workers who perform the tasks that earn the company its profits .",
    "in fact , it is natural to expect that some employees may lack the motivation to perform at their peak levels of efficiency , either because they have no stake in the company s profits or because they are simply lazy .",
    "the following example illustrates the situation facing a `` typical '' office worker , who may be one small cog in a large bureaucracy :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ example._it is 3:00  p.m. , and dilbert goes home at 5:00  p.m. dilbert has two tasks that have been given to him : one requires 10 minutes , the other requires an hour .",
    "if there is a task in his `` in - box , '' dilbert must work on it , or risk getting fired .",
    "however , if he has multiple tasks , dilbert has the freedom to choose which one to do first .",
    "he also knows that at  3:15 , another task will appear  a 45-minute personnel meeting .",
    "if dilbert begins the 10-minute task first , he will be free to attend the personnel meeting at  3:15 and then work on the hour - long task from  4:00 until  5:00 . on the other hand ,",
    "if dilbert is part way into the hour - long job at  3:15 , he may be excused from the meeting .",
    "after finishing the 10-minute job by  4:10 , he will have 50  minutes to twiddle his thumbs , iron his tie , or enjoy engaging in other mindless trivia .",
    "naturally , dilbert prefers this latter option . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    an historical example of a situation where it proved crucial to schedule tasks inefficiently is documented in the book / movie _ schindler s list _",
    "it was essential for the workers and management of schindler s factory to appear to be busy at all times in order for the factory to stay in operation , but they simultaneously sought to minimize their contribution to the german war effort .",
    "these examples illustrate a general and natural type of scheduling problem , which we term the `` lazy bureaucrat problem '' ( lbp ) ; the goal of the lbp is to schedule jobs as _ inefficiently _ ( in some sense ) as possible .",
    "there exists a vast literature on scheduling ; see e.g. , some of the recent surveys  @xcite .",
    "the lbp studies these traditional problems `` in reverse .",
    "'' several other combinatorial optimization problems have also been studied in reverse , leading , e.g. , to maximum tsp  @xcite , maximum cut  @xcite , and longest path  @xcite ; such inquiries often lead to a better understanding of the structure and algorithmic complexity of the original optimization problem .",
    "in this paper we schedule a set of jobs @xmath0 having processing times ( lengths ) @xmath1 respectively .",
    "job @xmath2 _ arrives _ at time @xmath3 and has its _ deadline _ at time @xmath4 .",
    "we assume throughout this paper that @xmath5 , @xmath3 , and @xmath4 have nonnegative integral values .",
    "the jobs have _ hard deadlines , _ meaning that each job @xmath2 can only be executed during its allowed interval @xmath6 $ ] ; we also call @xmath7 the job s _",
    "window_. we let @xmath8 denote the _",
    "critical time _ of job  @xmath2 ; job  @xmath2 must be started by time @xmath9 if there is any chance of completing it on time .",
    "the jobs are executed on a single processor , the ( lazy ) _ bureaucrat_. the bureaucrat executes only one job at a time .",
    "the bureaucrat chooses a subset of jobs to execute .",
    "since the bureaucrat s goal is to minimize his effort , he would prefer to remain idle all the time and to leave all the jobs unexecuted .",
    "however , this scenario is forbidden by what we call the _ busy requirement , _ which stipulates that the bureaucrat work on an _ executable _ job , if any executable jobs exist .",
    "executable _ if the constraints of the lbp allow the job to be run .",
    "thus , in the nonpreemptive setting a job @xmath10 is executable as long as it begun during the interval @xmath11 $ ] , at which point it is run to completion . in the preemptive setting the constraints that govern whether or not a job can be executed are more complicated ; see section  [ sec : preempt ] .      in traditional scheduling problems ,",
    "if it is impossible to complete the set of all jobs by their deadlines , one typically optimizes according to some objective , e.g. , to maximize a weighted sum of on - time jobs , to minimize the maximum lateness of the jobs , or to minimize the number of late jobs . for the lbp we consider three different objective functions , which naturally arise from the bureaucrat s goal of inefficiency :    1 .",
    "_ minimize the total amount of time spent working _ ",
    "this objective naturally appeals to a `` lazy '' bureaucrat .",
    "2 .   _ minimize the weighted sum of completed jobs _  in this paper we usually assume that the weight of job @xmath2 is its length , @xmath5 ; however , other weights ( e.g. , unit weights ) are also of interest .",
    "this objective appeals to a `` spiteful '' bureaucrat whose goal it is to minimize the fees that the company collects on the basis of his labors , assuming that the fee ( in proportion to the task length , or a fixed fee per task ) is collected only for those tasks that are actually completed .",
    "minimize the _ makespan _",
    ", the maximum completion time of the jobs _  this objective appeals to an `` impatient '' bureaucrat , whose goal it is to go home as early as possible , at the completion of the last job he is able to complete .",
    "he cares about the number of hours spent at the office , not the number of hours spent doing work ( productive or otherwise ) at the office .",
    "+ note that , in contrast with standard scheduling problems on one processor , the makespan in the lbp varies ; it is a function of which jobs have passed their deadlines and can no longer be executed .      as with most scheduling problems , additional parameters of the model must be set .",
    "for example , we must explicitly allow or forbid _ preemption _ of jobs .",
    "when a job is _ preempted _ , it is interrupted and may be resumed later at no additional cost . if we forbid preemption , then once a job is begun , it must be completed without interruptions .",
    "we must also specify whether scheduling occurs _ on - line _ or _",
    "off - line .",
    "_ a scheduling algorithm is off - line if all the jobs are known to the scheduler at the outset ; it is on - line if the jobs are known to the scheduler only as they arrive . in this paper",
    "we restrict ourselves to off - line scheduling ; we leave the on - line case as an open problem .",
    "# 1    [ cols=\"<,^,^\",options=\"header \" , ]      recently hepner and stein  @xcite published a pseudo - polynomial - time algorithm for minimizing the makespan subject to preemption constraint ii , thus resolving an open problem from an earlier version of this paper  @xcite .",
    "they also extend the lbp to the parallel setting , in which there are multiple bureaucrats .",
    "in this section , we assume that no job can be preempted : if a job is started , then it is performed without interruption until it completes .",
    "we show that the lazy bureaucrat problem ( lbp ) without preemption is strongly np - complete and is not approximable to within any factor for the three metrics we consider .",
    "these hardness results distinguish our problem from traditional scheduling metrics , which can be approximated in polynomial time , as proved in  @xcite .",
    "we show , however , that several special cases of the problem have pseudo - polynomial - time algorithms , using applications of dynamic programming .",
    "we begin by describing the relationship between the three different objective functions from section  [ sec : hard ] in the case of no preemption .    the problem of minimizing the total work ( objective function 1 ) is a special case of the problem of minimizing the weighted sum of completed jobs ( objective function 2 ) , because without preemption every job that is executed must be completed .",
    "( the weights become the job lengths . ) furthermore , if all jobs have the same arrival time , say time zero , then the two objectives minimizing the total amount of time spent working and minimizing the makespan ( go home early ) are equivalent ( objective functions 1 and 3 ) , since no feasible schedule will have any gaps .",
    "our first hardness theorem applies therefore to all three objective functions from section  [ sec : hard ] .",
    "[ thm : hard1 ] the lazy bureaucrat problem with no preemption is ( weakly ) np - complete for objective functions ( 1)-(3 ) , and is not approximable to within any fixed factor , even when all arrival times are the same .",
    "we use a reduction from the subset sum problem  @xcite : given a set of integers @xmath12 and a target integer @xmath13 , does there exist a subset @xmath14 , such that @xmath15 ?",
    "we construct an instance of the lbp having @xmath16 jobs , each having release time zero ( @xmath17 for all @xmath2 ) . for @xmath18 ,",
    "job @xmath2 has processing time @xmath19 and deadline @xmath20 .",
    "job @xmath16 has processing time @xmath21 and deadline @xmath22 ; thus , job @xmath16 can be started at time @xmath23 or earlier . because job @xmath16 is so long , the bureaucrat wants to avoid executing it , but can do so if and only if he selects a subset of jobs from @xmath24 to execute whose lengths sum to exactly  @xmath13 . in summary , the large job @xmath16 is executed if and only if the subset problem is solved exactly and executing the long job leads to a schedule whose makespan ( i.e. , total work executed ) is not within any fixed factor of the optimal solution .",
    "we now show that the lbp with no preemption is strongly np - complete . as we will show in section  [ pseudo",
    "] , the lbp from theorem  [ thm : hard1 ] when all arrival times are equal , has a pseudo - polynomial - time algorithm .",
    "however , if arrival times and deadlines are arbitrary integers , the problem becomes strongly np - complete .",
    "thus , the following theorem subsumes theorem  [ thm : hard1 ] when arrival times and deadlines our unconstrained , whereas theorem  [ thm : hard1 ] is more generally applicable .",
    "[ thm : hard2 ] the lazy bureaucrat problem with no preemption is strongly np - complete for objective functions ( 1)(3 ) , and is not approximable to within any fixed factor .",
    "clearly the problem is in np , since any solution can be represented by an ordered list of jobs , given their arrival times . to show hardness",
    ", we use a reduction from the 3-partition problem  @xcite : given a set @xmath25 of @xmath26 positive integers and a positive integer bound @xmath27 such that @xmath28 , for @xmath29 and @xmath30 , does there exist a partitioning of @xmath31 into @xmath32 disjoint sets , @xmath33 , such that for @xmath34 , @xmath35 ? ( note that , by the assumption that @xmath28 , each set @xmath36 must contain exactly 3 elements . )",
    "objective function ( 1 ) is a special case of objective function ( 2 ) because without preemption , any job that is begun must be completed .",
    "furthermore , hard instances will be designed so that there are no gaps , ensuring that the optimal solution for objective function ( 1 ) is also the optimal solution for objective function ( 3 ) .",
    "we construct an instance of the lbp containing three classes of jobs :    * _ element jobs _  we define one `` element job '' corresponding to each element @xmath37 , having arrival time  @xmath38 , deadline @xmath39 , and processing time  @xmath40 . * _ unit jobs _  we define @xmath41 `` unit '' jobs , each of length @xmath42 . the @xmath2-th unit job ( for @xmath43 )",
    "has arrival time @xmath44 and deadline @xmath45 .",
    "note that for these unit - length jobs we have @xmath46 ; thus , these jobs must be processed immediately upon their arrival , or not at all . *",
    "_ large job _",
    " we define one `` large '' job of length @xmath47 , arrival time @xmath38 , and deadline @xmath48 .",
    "note that in order to complete this job , it must be started at time @xmath49 or before .",
    "as in the proof of theorem  [ thm : hard1 ] , the lazy bureaucrat wants to avoid executing the long job , but can do so if and only if all other jobs are actually executed .",
    "otherwise , there will be a time when the large job is the only job in the system and the lazy bureaucrat will be forced to execute it .",
    "thus , the unit jobs must be done immediately upon their arrival , and the element jobs must fit in the intervals between the unit jobs .",
    "each such interval between consecutive unit jobs is of length exactly @xmath27 .",
    "refer to figure  [ fig : no - preempt - hard ] . in summary ,",
    "the long job is not processed if and only if all of the element and unit jobs can be processed before their deadlines , which happens if and only if the corresponding instance of 3-partition is a `` yes '' instance .",
    "note that since @xmath50 can be as large as we want , this also implies that no polynomial - time approximation algorithm with any fixed approximation bound can exist , unless p = np .",
    "consider the special case of the lbp in which all jobs have unit processing times .",
    "( recall that all inputs are assumed to be integral . )",
    "the latest due date ( ldd ) scheduling policy selects the job in the system having the latest deadline .",
    "note that this policy in nonpreemptive for unit - length jobs , since all jobs have integral arrival times .",
    "consider the latest deadline first scheduling policy when jobs have unit lengths and all inputs are integral .",
    "the ldd scheduling policy minimizes the amount of executed work .",
    "assume by contradiction that no optimal schedule is ldd .",
    "we use an exchange argument . consider an optimal ( non - ldd ) schedule that has the fewest pairs of jobs executed in non - ldd order .",
    "the schedule must have two neighboring jobs @xmath51 such that @xmath52 in the schedule but @xmath53 , and @xmath54 is in the system when @xmath2 starts its execution .",
    "consider the first such pair of jobs .",
    "there are two cases :    \\(1 ) the new schedule with @xmath2 and @xmath54 switched , is feasible .",
    "it executes no more work than the optimal schedules , and is therefore also optimal .",
    "\\(2 ) the schedule with @xmath2 and @xmath54 switched is not feasible .",
    "this happens if @xmath2 s deadline has passed .",
    "if no job is in the system to replace @xmath2 , then we obtain a better schedule than the optimal schedule and reach a contradiction .",
    "otherwise , we replace @xmath2 with the other job and repeat the switching process .",
    "we obtain a schedule executing no more work than an optimal schedule , but with fewer pairs of jobs in non - ldd order , a contradiction .",
    "consider now the version in which jobs are large in comparison with their intervals , that is , the intervals are `` narrow . ''",
    "let @xmath55 be a bound on the ratio of window length to job length ; i.e. , for each job @xmath2 , @xmath56 . we show that a pseudo - polynomial algorithm exists for the case of sufficiently narrow windows , that is , when @xmath57 .",
    "[ lem : unique - ordering ] assume that for each job @xmath2 , @xmath58 .",
    "then , if job @xmath2 can be scheduled before job @xmath54 , then job @xmath54 can not be scheduled before job  @xmath2 .",
    "we rewrite the assumption : for each @xmath2 , @xmath59 .",
    "the fact that job @xmath2 can be scheduled before job @xmath54 is equivalent to the statement that @xmath60 , since the earliest that job @xmath2 can be completed is at time @xmath61 and the latest that job @xmath54 can be started is at time @xmath62 .",
    "combining these inequalities , we obtain @xmath63 which implies that job @xmath54 can not be scheduled before job  @xmath2 .    under the assumption that @xmath58 for each @xmath2 , the ordering of any subset of jobs in a schedule is uniquely determined .",
    "suppose that for each job @xmath2 , @xmath64 .",
    "let @xmath65 .",
    "consider the problem of minimizing objective functions  ( 1)-(3 ) from section  [ subsec - model ] , in the nonpreemptive setting .",
    "then the lbp can be solved in @xmath66 time .",
    "[ fixed - window - dp ]    we use dynamic programming to find the shortest path in a directed acyclic graph ( dag ) .",
    "there are @xmath67 states the system can enter .",
    "let @xmath68 denote the state of the system when the processor begins executing the @xmath54-th unit of work of job @xmath2 at time @xmath69 .",
    "thus , @xmath70 , @xmath71 , and @xmath72 .",
    "transitions from state to state are defined according to the following rules :    1 .",
    "no preemption : once a job is begun , it must be completed without interruptions . 2 .",
    "when a job is completed at time @xmath69 , another job must begin immediately if one exists in the system .",
    "( by lemma  [ lem : unique - ordering ] , we know this job has not yet been executed . ) otherwise , the system is idle and begins executing a job as soon as one arrives .",
    "3 .   state @xmath73 is an end state if and only if when job @xmath2 completes at time @xmath69 , no jobs can be executed subsequently .",
    "the start state has transitions to the jobs @xmath74 that arrive first .",
    "the goal of the dynamic program is to find the length of a shortest path from the start state to an end state .",
    "depending on how we assign weights to the edges we can force our algorithm to minimize all three metrics from section  [ subsec - model ] . to complete the time analysis , note that only @xmath75 of the @xmath76 states have more than constant outdegree , and these states each have outdegree bounded by  @xmath77 .    for @xmath78 we know of no efficient algorithm without additional conditions .",
    "let @xmath79 be a bound on the ratio of longest window to shortest window , and let @xmath80 be a bound on the ratio of the longest job to the shortest job .",
    "note that bounds on @xmath55 and @xmath80 imply a bound on @xmath79 , and bounds on @xmath55 and @xmath79 imply a bound on @xmath80 .",
    "however , a bound on @xmath80 alone is not sufficient for a pseudo - polynomial - time algorithm .",
    "[ thm : bounded - delta ] even with a bound on the ratio @xmath80 , the lbp with no preemption is strongly np - complete for objective functions  ( 1)-(3 ) .",
    "it can not be approximated to within a factor of @xmath81 , for any @xmath82 , unless p = np .",
    "modify the reduction from 3-partition of theorem  [ thm : hard2 ] , by changing all the fixed `` unit '' jobs to have length @xmath83 , and adjust the arrival times and deadlines accordingly .    instead of one",
    "very long job as in the proof from theorem  [ thm : hard2 ] , we create a sequence of bounded - length jobs that serve the same purpose .",
    "one unit before the deadline of the `` element '' jobs ( see theorem  [ thm : hard2 ] ) a sequence of longer jobs @xmath84 arrives .",
    "each job @xmath85 entirely fills its window and so can only be executed directly when it arrives .",
    "job @xmath86 arrives at the deadline of job @xmath85 . in addition , a sequence of shorter jobs @xmath87 arrives , where each shorter job @xmath88 also entirely fills its window and can only be executed when it arrives .",
    "shorter job @xmath88 overlaps @xmath85 and @xmath86 ; it arrives one unit before the deadline of job @xmath85 .",
    "jobs @xmath88 have length @xmath89 and jobs @xmath85 have length @xmath90 .",
    "thus , if all the jobs comprising the @xmath91-partition problem can be executed , jobs @xmath84 will be avoided by executing jobs @xmath87 .",
    "otherwise , jobs @xmath84 must be executed .",
    "the index of @xmath32 can be adjusted to any @xmath92 .",
    "bounds on both @xmath80 and @xmath55 are sufficient to yield a pseudo - polynomial algorithm :    let @xmath93 . given bounds on @xmath55 and @xmath80 , the lazy bureaucrat problem with no preemption can be solved in @xmath94 for objective functions  ( 1)-(3 ) .",
    "we modify the dynamic programming algorithm of theorem  [ fixed - window - dp ] for this more complex situation .",
    "the set of jobs potentially available to work on in a given schedule at time @xmath69 are the jobs @xmath54 that have not yet been executed , for which @xmath95 .",
    "our state space will encode the _",
    "complement _ of this set for each time @xmath69 , specifically , the set of jobs that were executed earlier but could otherwise have been executed at time @xmath69 .",
    "the bounds on @xmath55 and @xmath80 together imply an upper bound on the number of subsets of jobs active at time @xmath69 that could have been executed prior to time @xmath69 .",
    "let @xmath96 be the length of the shortest job potentially active at time @xmath69 .",
    "we can partition all potentially active jobs into @xmath97 classes , where the @xmath54th class consists of the jobs of size greater than or equal to @xmath98 and less than @xmath99 .",
    "the earliest possible arrival time of any class-@xmath54 job is @xmath100 , since each job has an @xmath55-bounded window .",
    "only @xmath101 jobs from class @xmath54 can be executed within this window .",
    "summing over all the classes implies that at most @xmath102 jobs potentially active at time @xmath69 could have been executed in a non - preemptive schedule by time @xmath69 . as before the choice of weights on the edges determines the metric that is optimized .",
    "the time bound on the running time follows by observing that each of the @xmath103 states has outdegree at most @xmath102 .      in the next version of the problem",
    "all jobs are released at time zero , i.e. , @xmath17 for all @xmath2 .",
    "this problem can be solved in pseudo - polynomial time by dynamic programming , specifically , reducing the problem to that of finding the shortest path in a directed acyclic graph .",
    "the dynamic programming works because of the following structural result : there exists an optimal schedule that executes the jobs earliest due date ( edd ) .",
    "in fact this problem is a special case of the following general problem : minimizing the weighted sum of jobs not completed by their deadlines .",
    "a similar problem was solved by  @xcite , using the same structural result .",
    "the lbp can be solved in pseudo - polynomial time for all three metrics when all jobs have a common release time .",
    "specifically , let @xmath93 ; then the running time is @xmath104",
    "in this section we consider the lazy bureaucrat problem in which jobs may be preempted : a job in progress can be set aside , while another job is processed , and then possibly resumed later .",
    "it is important to distinguish among different constraints that specify which jobs are available to be processed .",
    "we consider three natural choices of such constraints :    constraint i : : :    in order to work on job @xmath2 at time @xmath69 , we    require only that the current time @xmath69 lies within the    job s interval @xmath7 : @xmath105 .",
    "constraint ii : : :    in order to work on job @xmath2 at time @xmath69 , we    require not only that the current time @xmath69 lies within    the job s interval @xmath7 , but also that the job has a    _ chance _ to be completed , e.g. , if it is processed without    interruption until completion .",
    "+    this condition is equivalent to requiring that    @xmath106 , where @xmath107 is    the _ adjusted critical time _ of job @xmath2 :    @xmath108 is the latest possible time to start job    @xmath2 , in order to meet its deadline @xmath4 ,    given that an amount @xmath109 of the job has already been    completed .",
    "constraint iii : : :    in order to work on job @xmath2 , we require that    @xmath110 .",
    "further , we require that any job that is    started is eventually completed .",
    "we divide this section into subsections , where each subsection considers one of the three objective functions ( 1)(3 ) from section  [ subsec - model ] , in which the goals are to minimize ( 1 ) the total time working ( regardless of which jobs are completed ) , ( 2 ) the weighted sum of completed jobs , or ( 3 ) the makespan of the schedule ( the `` go home '' time ) . for each metric",
    "we see that the constraints on preemption can dramatically affect the complexity of the problem .",
    "constraint iii makes the lbp with preemption quite similar to the lbp with no preemption .",
    "in fact , if all jobs arrive at the same time ( @xmath17 for all @xmath2 ) , then the three objective functions are equivalent , and the problem is hard :    [ hard - pre-3 ] the lbp with preemption , under constraint  iii ( one must complete any job that is begun ) , is ( weakly ) np - complete and hard to approximate for all three objective functions .",
    "we use the same reduction as the one given in the proof of theorem  [ thm : hard1 ] .",
    "note that any schedule for an instance given by the reduction , in which all jobs processed must be completed eventually , can be transformed into an equivalent schedule with no preemptions .",
    "this makes the problem of finding an optimal schedule with no preemption equivalent to the problem of finding an optimal schedule in the preemptive case under constraint iii .",
    "note that we can not use a proof similar to that of theorem  [ thm : hard2 ] to show that this problem is strongly np - complete , since preemption can lead to improved schedules in that instance .",
    "[ thm : preempt - i.1 ] the lbp with preemption , under constraint  i ( one can work on any job in its interval ) and objective  ( 1 ) ( minimize total time working ) , is polynomially solvable",
    ".    the algorithm schedules jobs according to latest due date ( ldd ) , in which at all times the job in the system with the latest deadline is being processed , with ties broken arbitrarily .",
    "an exchange argument shows that this is optimal .",
    "suppose there is an optimal schedule that is not ldd .",
    "consider the first time in which an optimal schedule differs from ldd , and let opt be an optimal schedule in which this time is as late as possible .",
    "let opt be executing a piece of job @xmath2 , @xmath111 and ldd executes a piece of job @xmath54 , @xmath112 .",
    "we know that @xmath113 .",
    "we want to show that we can replace the first unit of @xmath111 by one unit of @xmath112 , contradicting the choice of opt , and thereby proving the claim .",
    "if in opt , job @xmath54 is not completely processed , then this swap is feasible , and we are done . on the other hand , if all of @xmath54 is processed in opt , such a swap causes a unit of job @xmath54 later on to be removed , leaving a gap of one unit .",
    "if this gap can not be filled by any other job piece , we get a schedule with less work than opt , which is a contradiction .",
    "therefore assume the gap can be filled , possibly causing a later unit gap",
    ". continue this process , and at its conclusion , either a unit gap remains contradicting the optimality of opt , or no gaps remain , contradicting the choice of opt .",
    "the lbp with preemption , under constraint  ii ( one can only work on jobs that can be completed ) and objective  ( 1 ) ( minimize total time working ) , is ( weakly ) np - complete .    if all arrival times are the same , then this problem is equivalent to the one in which the objective function is to minimize the makespan , which is shown to be np - complete in theorem  [ thm : preempt - ii.3 ] .      the lbp with preemption , under constraint  i ( one can work on any job in its interval ) and objective  ( 2 ) ( minimize the weighted sum of completed jobs ) , is polynomially solvable .    without loss of generality ,",
    "assume that jobs @xmath114 are indexed in order of increasing deadlines .",
    "we show how to decompose the jobs into separate components that can be treated independently .",
    "schedule the jobs according to edd ( if a job is executing and its deadline passes , preempt and execute the next job ) .",
    "whenever there is a gap ( potentially of size zero ) , where no jobs are in the system , the jobs are divided into separate components that can be scheduled independently and their weights summed .",
    "now we focus on one such set of jobs ( having no gaps ) .",
    "we modify the edd schedule by preempting a job @xmath92 units of time before it completes",
    ". then we move the rest of the jobs of the schedule forward by @xmath92 time units and continue to process . at the end of the schedule",
    ", there are two possibilities .",
    "( 1 ) the last job is interrupted because its deadline passes ; in this case we obtain a schedule in which no jobs are completed ; ( 2 ) the last job completes and in addition all other jobs whose deadlines have not passed are also forced to complete .    the proof is completed by noting the following :    * there is an optimal schedule that completes all of its jobs at the end ; and * the above schedule executes the maximum amount of work possible .",
    "( in other words , edd ( `` minus @xmath92 '' ) allows one to execute the maximum amount of work on jobs 1 through @xmath2 without completing any of them . )    the lbp with preemption , under constraint  ii ( one can only work on jobs that can be completed ) and objective  ( 2 ) ( minimize the weighted sum of completed jobs ) , is ( weakly ) np - complete .",
    "consider the lbp under constraint  ii , where the objective is to minimize the makespan .",
    "the proof of theorem  [ thm : preempt - ii.3 ] will have hard instances where all jobs have the same arrival time , and where the optimal solution completes any job that it begins .",
    "thus , for these instances the metric of minimizing the makespan is equivalent to the metric of minimizing the weighted sum of completed jobs , for weights proportional to the processing times .",
    "we assume now that the bureaucrat s goal is to go home as soon as possible .",
    "we begin by noting that if the arrival times are all the same ( @xmath17 , for all @xmath2 ) , then the objective ( 3 ) ( go home as soon as possible ) is in fact equivalent to the objective ( 1 ) ( minimize total time working ) , since , under any of the three constraints i  iii , the bureaucrat will be busy nonstop until he can go home .",
    "observe that if the _ deadlines _ are all the same ( @xmath115 , for all @xmath2 ) , then the objectives ( 1 ) and ( 3 ) are quite different . consider the following example .",
    "job  1 arrives at time @xmath116 and is of length @xmath117 , job  2 arrives at time @xmath118 and is of length @xmath119 , job  3 arrives at time @xmath120 and is of length @xmath121 , and all jobs have deadline @xmath122 .",
    "then , in order to minimize total time working , the bureaucrat will do jobs 1 and 3 , a total of 4 units of work , and will go home at time 10 .",
    "however , in order to go home as soon as possible , the bureaucrat will do job  2 , performing 9 units of work , and go home at time 9 ( since there is not enough time to do either job  1 or job  3 ) .",
    "[ thm : preempt - i.3 ] the lbp with preemption , under constraint  i ( one can do any job in its interval ) and objective  ( 3 ) ( go home as early as possible ) , is polynomially solvable .    the algorithm is to schedule by latest due date ( ldd ) .",
    "the proof is similar to the one given in theorem  [ thm : preempt - i.1 ] .",
    "if instead of constraint  i we impose constraint  ii , the problem becomes hard :    [ thm : preempt - ii.3 ] the lbp with preemption , under constraint  ii ( one can only work on jobs that can be completed ) and objective  ( 3 ) ( go home as early as possible ) , is ( weakly ) np - complete , even if all arrival times are the same .",
    "we give a reduction from subset sum .",
    "consider an instance of subset sum given by a set @xmath31 of @xmath77 positive integers , @xmath123 , @xmath124 , and target sum @xmath13 .",
    "we construct an instance of the required version of the lbp as follows . for each integer @xmath40",
    ", we have a job @xmath2 that arrives at time @xmath17 , has length @xmath19 , and is due at time @xmath125 , where @xmath92 is a small constant ( it suffices to use @xmath126 ) .",
    "in addition , we have a `` long '' job @xmath16 , with length @xmath127 , that arrives at time @xmath128 and is due at time @xmath129 .",
    "we claim that it is possible for the bureaucrat to go home by time @xmath13 if and only if there exists a subset of @xmath130 that sums to exactly  @xmath13 .",
    "if there is a subset of @xmath130 that sums to exactly  @xmath13 , then the bureaucrat can perform the corresponding subset of jobs ( of total length @xmath13 ) and go home at time @xmath13 ; he is able to avoid doing any of the other jobs , since their critical times fall at an earlier time ( @xmath131 or @xmath132 ) , making it infeasible to begin them at time @xmath13 , by our assumption .",
    "if , on the other hand , the bureaucrat is able to go home at time @xmath13 , then we know the following :    1 .   _",
    "the bureaucrat must have just completed a job at time @xmath13 . _",
    "+ he can not quit a job and go home in the middle of a job , since the job must have been completable at the instant he started ( or restarted ) working on it , and it remains completable at the moment that he would like to quit and go home .",
    "_ the bureaucrat must have been busy the entire time from 0 until time @xmath13 . _ + he is not allowed to be idle for any period of time , since he could always have been working on some available job , e.g. , job @xmath133 .",
    "if the bureaucrat starts a job , then he must finish it . _",
    "+ first , we note that if he starts job @xmath134 and does at least @xmath92 of it , then he must finish it , since at time @xmath13 less than @xmath135 remains to be done of the job , and it is not due until time @xmath136 , making it feasible to return to the job at time @xmath13 ( so that he can not go home at time @xmath13 ) .",
    "+ second , we must consider the possibility that he may perform very small amounts ( less than @xmath92 ) of some jobs without finishing them . however , in this case , the _ total _ amount that he completes of these barely started jobs is at most @xmath137 .",
    "this is a contradiction , since his total work time consists of this fractional length of time , plus the sum of the integral lengths of the jobs that he completed , which can not add up to the integer @xmath13 .",
    "thus , in order for him to go home at exactly time @xmath13 , he must have completed every job that he started .",
    "+ finally , note that he can not use job @xmath133 as `` filler '' , and do part of it before going home at time @xmath13 , since , if he starts it and works at least time @xmath138 on it , then , by the same reasoning as above , he will be forced to stay and complete it .",
    "thus , he will not start it at all , since he can not complete it before time @xmath13 ( recall that @xmath127 ) .",
    "we conclude that the bureaucrat must complete a set of jobs whose lengths sum exactly to  @xmath13 .",
    "thus , we have reduced subset sum to our problem , showing that it is ( weakly ) np - complete .",
    "note that the lbp we have constructed has non integer data .",
    "however , we can `` stretch '' time to get an equivalent problem in which all the data is integral . letting @xmath139",
    ", we multiply all job lengths and due dates by  @xmath140 .    _ remark . _",
    "hepner and stein  @xcite recently published a pseudo - polynomial - time algorithm for this problem , thus resolving an open problem from an earlier version of this paper  @xcite .",
    "we come now to one of the main results of the paper .",
    "we emphasize this result because it uses a rather sophisticated algorithm and analysis in order to show that , in contrast with the case of identical arrival times , the lbp with identical deadlines is polynomially solvable .",
    "specifically , the problems addressed in theorems  [ thm : preempt - ii.3 ]  and  [ thm : preempt - ii.3-same - dead ] are identical except that the flow of time is reversed .",
    "thus , we demonstrate that in contrast to most classical scheduling problems , in the lbp , when time flows in one direction , the problem is np - hard , whereas when the flow of time is reversed , the problem is polynomial - time solvable .",
    "the remainder of this section is devoted to proving the following theorem :    [ thm : preempt - ii.3-same - dead ] the lbp with preemption , under constraint  ii ( one can only work on jobs that can be completed ) and objective  ( 3 ) ( go home as early as possible ) , is solvable in polynomial time if all jobs have the same deadlines ( @xmath115 , for all @xmath2 ) .",
    "we begin with a definition a `` forced gap : '' there is a _ forced gap _ starting at time @xmath69 if @xmath69 is the earliest time such that the total work arriving by time @xmath69 is less than @xmath69 .",
    "this ( first ) forced gap ends at the arrival time , @xmath141 , of the next job .",
    "subsequently , there may be more forced gaps , each determined by considering the scheduling problem that starts at the end , @xmath141 , of the previous forced gap .",
    "we note that a forced gap can have length zero .    under the `` go home early '' objective , we can assume , without loss of generality , that there are no forced gaps , since our problem really begins only at the time @xmath141 that the _ last _ forced gap ends .",
    "( the bureaucrat is certainly not allowed to go home before the end @xmath141 of the last forced gap , since more jobs arrive after @xmath141 that can be processed before their deadlines . )",
    "while an optimal schedule may contain gaps that are not forced , the next lemma implies that there exists an optimal schedule having no unforced gaps .",
    "consider the lbp of theorem  [ thm : preempt - ii.3-same - dead ] , and assume that there are no forced gaps .",
    "if there is a schedule having makespan @xmath13 , then there is a schedule with no gaps , also having makespan  @xmath13 .",
    "consider the first gap in the schedule , which begins at time @xmath142 .",
    "because the gap is not forced , there is some job @xmath54 that is not completed , and whose critical time is at time @xmath143 .",
    "this is because there must be a job that arrived before @xmath142 that is not completed in the schedule , and at time @xmath142 it is no longer feasible to complete it , and therefore its critical time is before @xmath142 .",
    "the interval of time between @xmath144 and @xmath13 may consist of ( 1 ) gaps , ( 2 ) work on completed jobs , and ( 3 ) work on jobs that are never completed .",
    "consider a revised schedule in which , after time @xmath144 , jobs of type  3 are removed , and jobs of type  2 are deferred to the end of the schedule .",
    "( since a job of type  2 is completed and all jobs have the same deadline , we know that it is possible to move it later in the schedule without passing its critical time . it may not be possible to move a ( piece of a ) job of type  3 later in the schedule , since its critical time may have passed . ) in the revised schedule , extend job  @xmath54 to fill the empty space .",
    "note that there is enough work in job @xmath54 to fill the space , since a critical time of @xmath144 means that the job must be executed continuously until deadline @xmath145 in order to complete it .",
    "consider an lbp of theorem  [ thm : preempt - ii.3-same - dead ] in which there are no forced gaps .",
    "any feasible schedule can be rearranged so that all completed jobs are ordered by their arrival times and all incomplete jobs are ordered by their arrival times .",
    "the proof uses a simple exchange argument as in the standard proof of optimality for the edd ( earliest due date ) policy in traditional scheduling problems .",
    "our algorithm checks if there exists a schedule having no gaps that completes exactly at time @xmath13 .",
    "assume that the jobs @xmath114 are labeled so that @xmath146 .",
    "the main steps of the algorithm are as follows :      1 .",
    "determine the forced gaps .",
    "this allows us to reduce to a problem having no forced gaps , which starts at the end of the last forced gap .",
    "+ the forced gaps are readily determined by computing the partial sums , @xmath147 , for @xmath148 , and comparing them to the arrival times .",
    "( we define @xmath149 . ) the first forced gap , then , begins at the time @xmath150 and ends at time @xmath151 .",
    "( @xmath152 if @xmath153 ; @xmath154 if there are no forced gaps . ) subsequent forced gaps , if any , are computed similarly , just by re - zeroing time at  @xmath141 , and proceeding as with the first forced gap .",
    "2 .   let @xmath155 be the length of time between the common deadline @xmath145 and our target makespan @xmath13 .",
    "a job @xmath2 for which @xmath156 is called _ short _ ; jobs for which @xmath157 are called _ long_. +",
    "if it is _ not _ possible to schedule the set of short jobs so that each is completed and they are all done by time @xmath13 , then our algorithm stops and returns `` no , '' concluding that going home by time @xmath13 is impossible .",
    "otherwise , we continue with the next step of the algorithm .",
    "+ the rationale for this step is the observation that any job of length at most @xmath158 must be completed in any schedule that permits the bureaucrat to go home by time @xmath13 , since its critical time occurs at or after time  @xmath13 .",
    "3 .   create a schedule @xmath159 of all of the jobs , ordered by their arrival times , in which the amount of time spent on job @xmath2 is @xmath5 if the job is short ( so it is done completely ) and is @xmath160 if the job is long .",
    "+ for a long job @xmath2 , @xmath160 is the maximum amount of time that can be spent on this job without committing the bureaucrat to completing the job , i.e. , without causing the adjusted critical time of the job to occur after time  @xmath13 .",
    "+ if this schedule @xmath159 has no gaps and ends at a time after @xmath13 , then our algorithm stops and returns `` yes . '' a feasible schedule that allows the bureaucrat to go home by time @xmath13 is readily constructed by `` squishing '' the schedule that we just constructed : we reduce the amount of time spent on the long jobs , starting with the latest long jobs and working backwards in time , until the completion time of the last short job exactly equals  @xmath13 .",
    "this schedule completes all short jobs ( as it should ) , and does partial work on long jobs , leaving all of them with adjusted critical times that fall _ before _ time @xmath13 ( and are therefore not possible to resume at time @xmath13 , so they can be avoided ) .",
    "if the above schedule @xmath159 has gaps or ends before time @xmath13 , then @xmath159 is not a feasible schedule for the lazy bureaucrat , so we must continue the algorithm .",
    "+ our objective is to decide _ which _ long jobs to complete , that is , is there a set of long jobs to complete that will make it possible to go home by time  @xmath13 .",
    "this problem is solved using the dynamic programming algorithm _ schedule - by-@xmath13 _ , which is described in detail below .",
    "let @xmath161 be the sum of the gap lengths that occur before time @xmath3 in schedule @xmath159 .",
    "then , we know that in order to construct a gapless schedule , at least @xmath162 long jobs ( in addition to the short jobs ) from @xmath163 must be completed",
    ". for each @xmath2 we have such a constraint ; collectively , we call these the _ gap constraints_.    if for each gap in schedule @xmath159 , there are enough long jobs to be completed in order to fill the gap , then a feasible schedule ending at @xmath13 exists .",
    "we devise a dynamic programming algorithm as follows .",
    "let @xmath164 be the earliest completion time of a schedule that satisfies the following :    1 .",
    "it completes by time @xmath13 ; 2 .",
    "it uses jobs from the set @xmath165 ; 3 .",
    "it completes exactly @xmath32 jobs and does no other work ( so it may have gaps , making it an infeasible schedule ) ; 4 .",
    "it satisfies the gap constraints ; and 5 .",
    "it completes all short jobs ( of size @xmath166 ) .",
    "the boundary conditions on @xmath164 are given by :    : :    @xmath167 ; : :    @xmath168 , which implies that at least one of the    jobs must be completed ; : :    @xmath169 for @xmath170 ; : :    @xmath171 if there exist constraints such that at    least @xmath172 jobs from @xmath173 must be    completed , some of the jobs from @xmath173 must be    completed because they are short , and some additional jobs may need to    be completed because of the gap constraints .",
    "note that this implies    that @xmath174 is equal to zero or infinity , depending on    whether gap constraints are disobeyed .    in general ,",
    "@xmath164 is given by selecting the better of two options : @xmath175 where @xmath176 is the earliest completion time if we choose not to execute job @xmath177 ( which is a legal option only if job @xmath177 is long ) , giving @xmath178 and @xmath179 is the earliest completion time if we choose to execute job @xmath177 ( which is a legal option only if the resulting completion time is by time @xmath13 ) , giving @xmath180    there exists a feasible schedule completing at time @xmath13 if and only if there exists an @xmath32 for which @xmath181 .",
    "if @xmath182 for all @xmath32 , then , since the gap constraints apply to any feasible schedule , and it is not possible to find such a schedule for any number of jobs @xmath32 , there is no feasible schedule that completes on or before  @xmath13 .",
    "if there exists an @xmath32 for which @xmath181 , let @xmath183 be the smallest such @xmath32",
    ". then , by definition , @xmath184 .",
    "we show that the schedule @xmath185 obtained by the dynamic program can be made into a feasible schedule ending at @xmath13 .",
    "consider jobs that are not completed in the schedule @xmath186 ; we wish to use some of them to `` fill in '' the schedule to make it feasible , as follows .",
    "ordered by arrival times of incomplete jobs , and doing up to @xmath160 of each incomplete job , fill in the gaps . note",
    "that by the gap constraints , there is enough work to fill in all gaps .",
    "there are two things that may make this schedule infeasible : ( i ) some jobs are worked on beyond their critical times , and ( ii ) the last job to be done must be a completed one .",
    "_ fixing the critical time problem:_consider a job @xmath2 that is processed at some time , beginning at @xmath69 , after its critical time , @xmath9 .",
    "we move all completed job pieces that fall between @xmath9 and @xmath13 to the end of the schedule , lining them up to end at @xmath13 ; then , we do job @xmath2 from time @xmath9 up until this batch of completed jobs .",
    "this is legal because all completed jobs can be pushed to the end of the schedule , and job @xmath2 can not complete once it stops processing .",
    "( ii ) . _ fixing the last job to be a complete one:_move a `` sliver '' of the last completed job to just before time @xmath13 . if this is not possible ( because the job would have to be done before it arrives )",
    ", then it means that we _ must _ complete one additional job , so we consider @xmath187 , and repeat the process .",
    "note that a technical difficulty arises in the case in which the sum of the gap lengths is an exact multiple of @xmath158 : do we have to complete an additional job or not ? this depends on whether we can put a sliver of a completed job at @xmath13 .",
    "there are several ways to deal with this issue , including conditioning on the last completed job , modifying the gap constraint , or ignoring the problem and fixing it if it occurs ( that is if we can not put a sliver , then add another job which must be completed to the gap constraint ) .",
    "this completes the proof of our main theorem , theorem  [ thm : preempt - ii.3-same - dead ] .    _",
    "remark._even if all arrival times are the same , and deadlines are the same , and data is integer , an optimal solution may not be integer .",
    "in fact , there may not be an optimal solution , only a limiting one , as the following example shows : let @xmath17 and @xmath188 , for all @xmath2 .",
    "jobs @xmath189 have length 51 , while job @xmath77 has length @xmath190 .",
    "a feasible schedule executes @xmath92 of each of the first @xmath191 jobs , where @xmath192 , and all of job  @xmath77 , so the total work done is @xmath193 .",
    "note that each of the first @xmath194 jobs have @xmath195 remaining to do , while there is only time @xmath196 left before the deadline .",
    "now , by making @xmath92 arbitrarily close to @xmath197 , we can make the schedule better and better .",
    "we thank the referees for constructive comments and suggestions that improved the presentation of the paper .",
    "a.   i.  barvinok , d.  s.  johnson , g.  j.  woeginger , and r.  woodroofe .",
    "the maximum traveling salesman problem under polyhedral norms . in _ proc .",
    "6th conference on integer programming and combinatorial optimization ( ipco ) _ , _ lecture notes in computer science _ , vol .  1412 , pages 195201 , 1998 .",
    "e.  l.  lawler , j.  k. lenstra , a.  h.  g. rinnooy kan , and d.  b.  shmoys .",
    "sequencing and scheduling : algorithms and complexity .",
    "graves , p.h .",
    "zipkin , and a.h.g .",
    "rinnooy kan ( eds . ) in _ logistics of production and inventory : handbooks in operations research and management science _ , volume  4 , pages 445522 .",
    "north - holland , amsterdam , 445 - 522 , 1993 ."
  ],
  "abstract_text": [
    "<S> we introduce a new class of scheduling problems in which the optimization is performed by the worker ( single `` machine '' ) who performs the tasks . </S>",
    "<S> a typical worker s objective is to minimize the amount of work he does ( he is `` lazy '' ) , or more generally , to schedule as inefficiently ( in some sense ) as possible . </S>",
    "<S> the worker is subject to the constraint that he must be busy when there is work that he _ can _ do ; we make this notion precise both in the preemptive and nonpreemptive settings . </S>",
    "<S> the resulting class of `` perverse '' scheduling problems , which we denote `` lazy bureaucrat problems , '' gives rise to a rich set of new questions that explore the distinction between maximization and minimization in computing optimal schedules .    </S>",
    "<S> * keywords:*scheduling , approximation algorithms , optimization , dynamic programming , np - completeness , lazy bureaucrat . </S>",
    "<S> 68m20 , 68q25 , 90b35 , 90b70 . </S>"
  ]
}