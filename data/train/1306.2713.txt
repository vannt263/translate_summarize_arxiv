{
  "article_text": [
    "quantum phase estimation ( qpe ) is a key quantum operation in many quantum algorithms @xcite .",
    "phase estimation is extensively used to solve a variety of problems , such as hidden subgroup , graph isomorphism , quantum walk , quantum sampling , adiabatic computing , order - finding and large number factorization .",
    "qpe comprises two components : _ phase kick back _ and _ inverse quantum fourier transform_. the implementation of quantum fourier transform has been described in numerous research articles @xcite . the physical implementation ( algorithms based on quantum fourier transform ( qft ) )",
    "is highly constrained by the requirement of ( 1 ) high - precision controlled rotation gates ( phase shift operators ) , which remain difficult to realize , and ( 2 ) sufficient number of qubits to approximate the eigenphase to a required precision .",
    "+ at the early stage of a quantum computing implementation , we can imagine that scalability could be an issue .",
    "the quantum resources could be limited , in terms of available quantum qubits and quantum gates . from that perspective ,",
    "efficient implementations of quantum algorithms are essential when available quantum resources are scarce .",
    "for instance , parker and plenio @xcite show that a single pure qubit together with a collection of @xmath4 qubits in an arbitrary mixed ( or pure ) state is sufficient to implement shor s factorization algorithm efficiently to factorize a large number @xmath5 .",
    "such implementation addresses the issue of limited qubits but introduces the concern for the decoherence .",
    "+ in this paper , we are interested in the following two aspects .",
    "( 1 ) given certain available qubits , assuming @xmath6 qubits in total , we want to have an efficient way to implement quantum phase estimation and use as few controlled rotation gates ( c - r.g . ) as possible . ( 2 ) apply this technique to shor s factorization algorithm along with simultaneous diophantine approximation @xcite to investigate the feasible implementation structure when the available qubits are limited .",
    "we assume only one copy of the eigenvector @xmath7 ( requiring @xmath4 qubits ) and additional @xmath0 qubits are available .",
    "one copy of the eigenvector implies a restriction on the use of controlled - u gates : all controlled - u gates should be applied on the workspace register ( @xmath0 qubits ) .",
    "+ one copy of an eigenvector is a reasonable assumption because multiple copies of @xmath7 would imply the requirement for extra multiple of @xmath4 qubits for storage .",
    "hence , it is practical as we are considering the case that the available qubits are scarce .",
    "thus , the entire process is a single circuit ( @xmath8 stages ) that _ can not be divided into parallel processes_. under such an assumption , for approaches that require repetitions , such as kitaev s @xcite and others @xcite , parallelization can not be done and the circuit depth is the same as the size of the circuit . on the other hand , if we have enough qubits for storing multiple copies of eigenvector @xmath7 , we should choose kitaev s approach because the processes can thus be run in parallel . throughout the rest of the article , we will refer to the @xmath0 available qubits as the qubits used in the workspace register .",
    "+ generally speaking , quantum circuits for qft implemented in different approaches @xcite would require the same number of controlled - u gates but different numbers of rotation gates .",
    "we are interested in using the recursive approach , along with some classical resources , to implement the inverse quantum fourier transform .",
    "we bound the number of required rotation gates from above .",
    "+ we give an overview of the conventional quantum phase estimation technique in section [ sect : overview ] .",
    "we detail our algorithms and the analysis in section [ sect : thealgorithm ] , including a brief analysis of kitaev s original approach @xcite .",
    "an application of our approach along with simultaneous diophantine approximation to the factorization problem is given in section [ sect : application ] .",
    "finally we state our conclusion in section [ sect : theconclusion ] .",
    "one of the standard methods to approximate the phase of a unitary matrix is qpe based on qft .",
    "the structure of this method is depicted in figure  [ qpefig ] .",
    "qubits as ancilla .",
    "the dash - line box is the phase kickback.,width=355,height=124 ]    the qpe algorithm requires two registers and contains two stages .",
    "suppose the eigenphase of unitary @xmath9 is @xmath10 in the binary representation such that @xmath11 then the first register is prepared as a composition of @xmath1 qubits initialized in the state @xmath12 .",
    "the second register is initially prepared in the state @xmath7 .",
    "the first stage prepares a uniform superposition over all possible states and then applies controlled-@xmath13 operations .",
    "consequently , the state becomes @xmath14    the second stage in the qpe algorithm is the qft@xmath15 operation . at each step ( starting from the least significant bit ) by using the information from previous steps , the inverse fourier transform transforms the state @xmath16 to get closer to one of the states @xmath17    suppose @xmath18 is precise to the @xmath19rd bit , that is @xmath20 .",
    "as shown in figure [ fig : inverseqft_3qubit ] , each step ( dashed - line box ) uses the result of previous steps , where phase shift operators are defined as @xmath21\\ ] ] for @xmath22 . by concatenating @xmath23 , @xmath24 and @xmath25",
    ", we obtain @xmath18 .",
    "therefore , when @xmath18 is precise to the @xmath26 bit , the total number of rotation gate invocations is @xmath3 .    , @xmath27 ) .",
    ", width=355,height=124 ]",
    "before proceeding to our algorithm , we provided the description of the recursive circuit for quantum fourier transform @xcite technique . in @xcite , in addition to the recursive circuit , the authors also adopted the technique by schnhage and strassen @xcite for integer multiplication .",
    "however , the integer multiplication is performed via classical computation .",
    "we use the classical bits and operators to compute the parameter ( the desired phase shift ) of a quantum rotation gate .",
    "the algorithm structure is explained in subsection [ sect : algstruct ] .",
    "+      let @xmath28 denote the inverse fourier transform modulo @xmath29 that acts on @xmath1 qubits .",
    "the standard quantum circuit for @xmath30 can be described recursively as follows .",
    "let us denote this circuit as @xmath31 .    1 .",
    "suppose the state of the work register after phase kickback is @xmath32 2 .",
    "apply @xmath33 to the last m qubits ( @xmath34 ) .",
    "3 .   read out and store the values of the @xmath35 qubits in classical bits ( @xmath36 ) .",
    "4 .   compute rotation angle : @xmath37 .",
    "5 .   for each @xmath38 , apply the rotation gate @xmath39 to the @xmath40 qubit . here",
    "the rotation gate @xmath39 is defined as @xmath41 6 .",
    "apply @xmath42 to the first @xmath43 qubits .    for simplicity ,",
    "let us assume that @xmath1 is some power of 2 .",
    "then step 5 is the step that resets the disturbing eigenphase bits for the first @xmath43 qubits because all the disturbing eigenphase bits from the last @xmath35 bits will be cleared .",
    "the number of required rotation operations for such a step is @xmath44 ( suppose we choose @xmath45 ) as we have to reset for each qubit in the last @xmath43 qubits .",
    "+ it is clear to that the total number of required rotation gates is @xmath46 where @xmath47 .",
    "hence , the complexity is @xmath48 is always of base @xmath49 , unless otherwise specified .",
    "] for such a recursive circuit .",
    "given @xmath0 ancillary bits initialized in @xmath12 and eigenvector @xmath7 of unitary @xmath9 where @xmath50 as input , we want to estimate the eigenphase of @xmath9 precise to the @xmath26 bit .",
    "the algorithm comprises @xmath51 stages that run in sequence . at each stage",
    ", we perform phase kickback , controlled - rotation operation and recursive inverse fourier transform to obtain @xmath0 eigenphase bits .",
    "once the last stage finishes , we can concatenate the obtained eigenphase bits , resulting in an estimated eigenphase of @xmath18 . for the details ,",
    "please refer to algorithm [ alg : kqubits ] listed below .",
    "* input : * @xmath0 ancillary bits initialized in @xmath12 and eigenvector @xmath7 of unitary @xmath9 where @xmath50 .",
    "+ * step i : * + at stage @xmath52 , where @xmath53 , run phase kick back on @xmath0 qubits by using the controlled @xmath13 operations .",
    "note that @xmath54 . +",
    "* step ii : * + for @xmath55 , apply the rotation gate @xmath56}{2^{k - t+1}}}^\\dagger$ ] to the @xmath57 qubit . +",
    "apply the generalized recursive circuit @xmath58 .",
    "+ read out the result to @xmath0 classical bits @xmath59 ( the actual label is @xmath60 ) .",
    "+ compute the value @xmath61 = f(c_1\\ldots c_k ) + \\frac{f[j-1]}{2^k}$ ] where @xmath62 .",
    "+ reset @xmath0 qubits to @xmath12 + * step iii : * + repeat step i and step ii @xmath63 times ( i.e. @xmath64 stages ) + * output : * + concatenate the @xmath1 classical bits @xmath65 , resulting in an estimated eigenphase @xmath66 .",
    "let us write the eigenphase @xmath18 in the binary presentation as @xmath67 .",
    "let @xmath68 be the initial state at stage @xmath52 before the phase kickback .",
    "after step i , we obtain the state @xmath69    it is clear to see that for the @xmath57 qubit that the eigenphase discovered from previous stages is shifted to the right by @xmath70 bits in the binary presentation . at the beginning of step ii , by applying the rotation gate @xmath71}^\\dagger$ ] , = 0 $ ] . ]",
    "we reset the discovered eigenphase in those @xmath0 qubits .",
    "hence , we obtain the state @xmath72 now we have reduced the scenario to the case where the disturbing eigenphase bits from previous stages are reset to @xmath73 .",
    "hence we can use the general recursive circuit for the inverse quantum fourier transform to obtain the eigenphase bits ( @xmath74 ) .",
    "+ once we obtain the @xmath0 eigenphase bits , we can read out and store them in classical bits to compute @xmath61 $ ] .",
    "we refer interested readers to @xcite for the details in this semiclassical approach .",
    "the value , @xmath61 $ ] will be used again in the next stage for resetting the previous @xmath75 eigenphase bits .",
    "figure [ fig : stage ] depicts the process of a single iteration .    : with @xmath0 qubits as ancilla , @xmath0 rotation operations and one @xmath76 operation.,width=537,height=172 ]      the cost of our algorithm has two parts : classical and quantum . for the classical part , we need @xmath1 classical bits , @xmath77 doubles and @xmath77 classical operators .",
    "@xmath1 classical bits are used to store _ all of the _ observed eigenphase bits . at any given stage ( say @xmath52 ) , two primitive doubles , @xmath78 and @xmath79 are required such that we have @xmath80 , \\quad y = f[j-1].\\ ] ]    to generate @xmath0 different rotation angle operators ( see the first substep of step ii in algorithm [ alg : kqubits ] ) , we need @xmath0 doubles ( @xmath81 $ ] , an array of @xmath0 doubles ) and @xmath0 operators to generate the parameter , @xmath82}{2^{k - t+1}}},\\ ] ] of a quantum rotation gate for the @xmath57 qubit at the @xmath83 iteration where @xmath84 .",
    "once the @xmath0 eigenphase bits are stored in classical bits in the @xmath83 iteration , a classical operator computes @xmath61 $ ] such that @xmath85 = x= f(c_1\\ldots c_k ) + \\frac{y}{2^k}.\\ ] ] then another operator sets @xmath86 . by doing so , double @xmath78 and @xmath79 can be reused in the next iteration .",
    "therefore , classically @xmath1 classical bits , @xmath77 doubles and @xmath77 classical operators are needed . the same device ( classical requirement ) can be used inside the recursive circuit since our approach is sequential , not parallelled .",
    "the classical requirements are summed in table [ table : bitnum ] .",
    "+    .required classical bits [ cols=\"<,<\",options=\"header \" , ]     [ table : qbitnum ]      in this section , we will focus on how to use @xmath0 available qubits to implement the quantum factorization algorithm .",
    "shor s factorization algorithm provides a polynomial approach to factorize a large number @xmath5 .",
    "suppose @xmath5 is an @xmath87 bit composite number of interest .",
    "there is no known classical algorithm for factoring in only polynomial time , i.e. , that can factor in time @xmath88 for some constant @xmath89 .",
    "the most difficult integers to factor in practice using existing algorithms are those that are products of two large primes of _ similar size _ , and for this reason these are the integers used in cryptographic applications .",
    "the largest such semiprime yet factored was rsa-768 , a 768-bit number with 232 decimal digits @xcite .",
    "+ quantumly , it is shown such a task can be done by using @xmath90 operations .",
    "the algorithm is two - fold .",
    "it first runs phase estimation to obtain the eigenphase @xmath91 where @xmath92 is the order of an arbitrary element @xmath93 ( that is @xmath94mod @xmath95 ) . the second part of the algorithm involves the continued fractions algorithm to approximate @xmath96 , based on the eigenphase we obtain in phase estimation , in order to recover the order @xmath92 .",
    "if @xmath92 is even , then we know that @xmath97mod @xmath95 and we successfully factorize @xmath5 into a product of two large numbers of similar size .",
    "+ however , using the continued fraction algorithm leads inevitably to a squaring of the number to be factored .",
    "this follows from the following theorem .",
    "@xcite suppose @xmath96 is a rational number such that @xmath98 then @xmath96 is a convergent of the continued fraction for @xmath18 , and thus can be computed in @xmath90 operations using the continued fractions algorithm .",
    "this in turn doubles the length , approximately to @xmath99 qubits , of the quantum registers in order to achieve required precision @xmath100 since @xmath101 .",
    "park and plenio @xcite show that they can implement the algorithm by use of @xmath102 qubit to be exact , required by the eigenvector of the unitary . ] along with the semiclassical approach @xcite .",
    "for such a design , the whole circuit ( quantum - wise ) consists of @xmath103 stages of recovering @xmath104 , where @xmath105 , and calculating a controlled rotation for the next stage . after obtaining all the @xmath104 , the post processing ( continued fractions )",
    "recovers the order @xmath92 .",
    "+ in the work by seifert@xcite , he proposes an alternative to approximate the order by using the simultaneous diophantine approximation @xcite .",
    "the theorem is as follows .",
    "@xcite let @xmath5 be the product of two randomly chosen primes of equal size , i.e. of the same length in the binary representations .",
    "there exists a randomized polynomial - time quantum algorithm that factors @xmath5 and uses quantum registers of binary length @xmath106 , where @xmath107 is an arbitrarily small positive constant . determines the dimension @xmath108 needed for the good simultaneous diophantine approximation .",
    "it is shown @xcite that the complexity is upper bounded from above by @xmath109 independent of the dimension @xmath110 . ]    in such a design , more computations are shifted from the quantum computation part to the classical computation part , in comparison to shor s algorithm .",
    "this might be of importance to practical realizations of a quantum computer .",
    "it is also clear that the simultaneous diophantine approach only requires @xmath111 qubits , that is the precision requirement of @xmath112 for the phase estimation , to guarantee the existence of a polynomial quantum algorithm for the factorization problem .",
    "+ given the constraint that we only have @xmath0 qubits available for implementation , we have the following scheme .",
    "* input : * @xmath0 ancillary bits initialized in @xmath12 and eigenvector @xmath7 of unitary @xmath9 where @xmath50 . +",
    "* case i : continued fractions * + choose @xmath113 .",
    "+ run algorithm [ alg : kqubits ] to approximate @xmath18 and the number of stages is @xmath114 .",
    "+ run the continued fractions algorithm to recover the order @xmath92 from the approximated @xmath18 .",
    "+ * case ii : diophantine approximation * + choose @xmath115 .",
    "+ run algorithm [ alg : kqubits ] to approximate @xmath18 and the number of stages is @xmath116 .",
    "+ run the simultaneous diophantine approximation algorithm to recover the order @xmath92 from the approximated @xmath18 .",
    "+    clearly this is the tradeoff between the computational complexity ( even though both are polynomial ) and the available qubits .",
    "quantumly they both have the same number of invocation of the unitary @xmath9 .",
    "however , based on eq .",
    "[ eqn : invkcost ] , the number of total quantum rotation gates invocation in the first case is approximately @xmath117 while that of the second case is approximately @xmath118 . at the early stage of a quantum computing implementation ,",
    "@xmath0 is probably significantly less than @xmath87 .",
    "in such a scenario , the number of total rotation gate invocation in the first case is approximately twice of that in the second case .",
    "+ furthermore , another important issue we need to consider is the decoherence .",
    "despite the fact that the complexity for case i is smaller ( classically ) , it is more costly quantumly .",
    "the difference in quantum resources might be amplified when the implementation of error correction is considered as the first case has more stages and more rotation gate invocations .",
    "we expect the cost of classical computation to be fairly inexpensive in comparison to its quantum counterpart .",
    "our approach provides a way to obtain the eigenphase when the number of available qubits is rather limited .",
    "it invokes @xmath2 rotation gates and this gain comes from ( 1 ) the use of recursive circuits for @xmath119 and ( 2 ) the use of the classical bits and classical operators .",
    "+ another obstacle of high - precision rotation gates ( phase shift operators ) is not addressed yet . for future work , we could combine with another approach @xcite to approximate the eigenphase with variable number of qubits and arbitrary constant - precision operators .",
    "c.  c gratefully acknowledges the support of lockheed martin corporation and nsf grants ccf-0726771 and ccf-0746600 . we would like to thank david poulin and pawel wocjan for useful comments and suggestions ."
  ],
  "abstract_text": [
    "<S> due to the great difficulty in scalability , quantum computers are limited in the number of qubits during the early stages of the quantum computing regime . </S>",
    "<S> in addition to the required qubits for storing the corresponding eigenvector , suppose we have additional @xmath0 qubits available . </S>",
    "<S> given such a constraint @xmath0 , we propose an approach for the phase estimation for an eigenphase of exactly @xmath1-bit precision . </S>",
    "<S> this approach adopts the standard recursive circuit for quantum fourier transform ( qft ) in @xcite and adopts classical bits to implement such a task . </S>",
    "<S> our algorithm has the complexity of @xmath2 , instead of @xmath3 in the conventional qft , in terms of the total invocation of rotation gates . </S>",
    "<S> we also design a scheme to implement the factorization algorithm by using @xmath0 available qubits via either the continued fractions approach or the simultaneous diophantine approximation . </S>"
  ]
}