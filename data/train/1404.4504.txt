{
  "article_text": [
    "the design of efficient procedures for searching in a discrete structure is a fundamental problem in discrete mathematics @xcite and computer science @xcite .",
    "searching is a basic primitive for building and managing operations of an information system as ordering , updating , and retrieval .",
    "the typical example of a search procedure is binary search which allows to retrieve an element in a sorted list of size @xmath6 by only looking at @xmath7 elements of the list .",
    "if no order can be assumed on the list , then it is known that any procedure will have to look at the complete list in the worst case . besides these two well characterized extremes , extensive work has also been devoted to the case where the underlying structure of the search space is a partial order .",
    "partial orders can be used to model lack of information on the totally ordered elements of the search space @xcite or can naturally arise from the relationship among the elements of the search space , like in hierarchies used to model knowledge representation @xcite , or in tree - like indices for information retrieval of large databases @xcite . for more about applications of tree search see below .    in this paper",
    ", we focus on the case where the underlying search space is a tree - like partially ordered set and tests have nonuniform costs .",
    "we investigate the following problem .",
    "is the input tree and @xmath8 is a decision tree with @xmath9 .",
    "if the vertices of the tree @xmath3 represent the parts of a device to assemble , the decision tree corresponds to the assembly procedure that at time 0 joins @xmath0 with @xmath10 ; then at time @xmath11 joins @xmath10 with @xmath12 and @xmath0 with @xmath13 . at time",
    "@xmath14 the joining of @xmath15 with @xmath12 and @xmath0 with @xmath16 is started .",
    "finally , at time @xmath17 part @xmath18 is joined with part @xmath12 and the procedure ends by time @xmath19 . ]    the tree search problem with non - uniform costs    _ input _ : a tree @xmath20 with non - negative rational costs assigned to the edges defined by a @xmath21 .    _ output _ : a strategy that minimizes ( in the worst case ) the cost spent to identify an initially unknown vertex @xmath22 of @xmath3 by using _",
    "edge queries_. an _ edge query _",
    "@xmath23 asks for the subtree @xmath24 or @xmath25 which contains @xmath22 , where @xmath24 and @xmath25 are the connected components of @xmath1 , including the vertex @xmath26 and @xmath27 respectively .",
    "the cost of the query @xmath0 is @xmath2 .",
    "the cost of identifying a vertex @xmath22 is the sum of the costs of the queries asked .",
    "more formally , a strategy for the tree search problem with nonuniform costs over the tree @xmath3 is a _ decision tree _ @xmath8 which is a rooted binary tree with @xmath28 leaves where every leaf @xmath29 is associated with one vertex @xmath30 and every internal node and the term @xmath31 for the vertices of the decision tree @xmath8 . ]",
    "@xmath32 is associated with one test @xmath23 .",
    "the outgoing edges from @xmath33 are associated with the possible outcomes of the query , namely , to the case where the vertex to identify lies in @xmath24 or @xmath25 respectively .",
    "every vertex has at least one associated leaf .",
    "the actual identification process can be obtained from @xmath8 starting with the query associated to the root and moving towards the leaves based on the answers received . when a leaf @xmath29 is reached , the associated vertex is output ( see fig .  [",
    "fig : problem - defi ] for an example ) .    given a decision tree @xmath8 , for each vertex @xmath34 ,",
    "let @xmath35 be the sum of costs of the edges associated to nodes on the path from the root of @xmath8 to the leaf identifying @xmath27 .",
    "this is the total cost of the queries performed when the strategy @xmath8 is used and @xmath27 is the vertex to be identified .",
    "in addition , let the cost of @xmath8 be defined by @xmath36 this is the worst - case cost of identifying a vertex of @xmath3 by the decision tree @xmath8 .",
    "the optimal cost of a decision tree for the instance represented by the tree @xmath3 and the cost assignment @xmath37 is given by @xmath38 where the @xmath39 is over all decision trees @xmath8 for the instance @xmath40 .",
    "* previous results and related work . * the tree search problem has been first studied under the name of tree edge ranking @xcite , motivated by multi - part product assembly . in @xcite",
    "it was shown that in the case where the tests have uniform cost , an optimal strategy can be found in linear time . a linear algorithm for searching in a tree with uniform cost",
    "was also provided in @xcite . independently of the above articles ,",
    "the first paper where the problem is considered in terms of searching in a tree is @xcite , where the more general problem of searching in a poset was also addressed .",
    "the variant considered here in which the costs of the tests are non - uniform was first studied by dereniowski @xcite in the context of edge ranking . in this paper ,",
    "the problem was proved np - complete for trees of diameter at most 10 .",
    "dereniowski also provided an @xmath7 approximation algorithm . in @xcite cicalese",
    ".   showed that the tree search problem with non - uniform costs is strongly np - complete already for input trees of diameter 6 , or maximum degree 3 , moreover , these results are tight . in fact , in @xcite , a polynomial time algorithm computing the optimal solution is also provided for diameter 5 instances and an @xmath41 algorithm for the case where the input tree is a path . for arbitrary trees , cicalese et al .  provided an @xmath42-approximation algorithm .    * our result . *",
    "our contribution is both on the algorithmic and on the complexity side . on the one hand",
    ", we provide a new approximation algorithm for the tree search problem with non - uniform costs which improves upon the best known guarantee given in @xcite . in section 3",
    "we will prove the following result .",
    "[ thm : main ] there is an @xmath43-approximation algorithm for the weighted tree search problem that runs in polynomial time in @xmath6 .",
    "in addition , we show that the tree search problem with non - uniform costs is np - hard already when the input tree is a spider of diameter 6 .",
    "* more about applications . *",
    "we discuss some scenarios in which the problem of searching in trees with non - uniform costs naturally arises .",
    "consider the problem of locating a buggy module in a program in which the dependencies between different modules can be represented by a tree .",
    "for each module we can verify the correct behavior independently .",
    "such a verification may consist in checking , for instance , whether all branches and statements in a given module work properly . for different modules",
    ", the cost of using the checking procedure can be different ( here the cost might refer to the time to complete the check ) .",
    "in such a situation , it is important to device a debugging strategy that minimizes the cost incurred in order to locate the buggy module in the worst case .",
    "checking for consistency in different sites keeping distributed copies of tree - like data structures ( e.g. , file systems ) can be performed by maintaining at each node some check sum information about the subtree rooted at that node .",
    "tree search can be used to identify the presence of `` buggy nodes '' , and efficiently identifying the inconsistent part in the structure , rather than retransmitting or exhaustively checking the whole data structure . in @xcite , an application of this model in the area of information retrieval",
    "is also described .",
    "another examples comes from a class of problems which is in some sense dual to the previous ones : deciding the assembly schedule of a multi - part device .",
    "assume that the set of pairs of parts that must be assembled together can be represented by a tree .",
    "each assembly operation requires some ( given ) amount of time to be performed and while assembling two pieces , the same pieces can not be involved in any other assembly operation . at any time different pairs of parts can be assembled in parallel .",
    "the problem is to define the schedule of assembly operations which minimize the total time spent to completely assembly the device .",
    "the schedule is an edge ranking of the tree defined by the assembly operations . by reversing the order of the assembly operation in the schedule",
    "we obtain a decision tree for the problem of searching in the tree of assembly operation where each edge cost is equal to the cost of the corresponding assembly .",
    "in this section we provide some preliminary results which will be useful in the analysis of our algorithm presented in the next section .",
    "we introduce some lower bounds on the cost of the optimal decision tree for a given instance of the problem .",
    "we also recall two exact algorithm for constructing optimal decision tree which were given in @xcite .",
    "the first is an exponential time dynamic programming algorithm which works for any input tree .",
    "the second is a quadratic time algorithm for instances where the input tree is a path . finally , we show a construction of 2-approximation decision trees for spider graphs .",
    "let @xmath3 denote the input tree and @xmath37 the cost function .",
    "it is not hard to see that , given a decision tree @xmath8 for @xmath3 we can extract from it a decision tree for the instance of the problem defined on a subtree @xmath44 of @xmath3 and the restriction of @xmath37 to the vertices in @xmath44 . for this , we can repeatedly apply the following operation : if in @xmath8 there is a node @xmath33 associated with an edge @xmath45 , such that @xmath24 ( reps .",
    "@xmath25 ) is included @xmath46 then remove the node @xmath33 together with the subtree rooted at the child of @xmath33 corresponding to the case where the vertex to identify is in @xmath24 ( resp .",
    "@xmath25 ) .",
    "let @xmath47 be the resulting decision tree when the above step can not be performed anymore . then",
    ", clearly @xmath48 .",
    "we have shown the following ( also observed in @xcite ) .",
    "[ lem : subtree ] let @xmath44 be a subtree of @xmath3 .",
    "then , @xmath49 .",
    "another immediate observation is that for a given input tree @xmath3 , the value @xmath50 is monotonically non - decreasing with respect to the cost of any edge .",
    "this is recorded in the following .",
    "[ lem : decreasec ] let @xmath37 and @xmath51 be cost assignments on a tree @xmath3 such that @xmath52 for every @xmath53 .",
    "then , @xmath54 .",
    "the next proposition shows that subdividing an edge can not decrease the cost of the optimal decision tree .",
    "[ prop : contract ] let @xmath37 be a cost assignment on a tree @xmath3 .",
    "let @xmath34 have exactly two neighbors @xmath55 .",
    "if @xmath44 is obtained from @xmath56 by adding the edge @xmath57 and @xmath51 is obtained from @xmath37 by setting @xmath58 then @xmath59 .",
    "the proof of proposition  [ prop : contract ] is deferred to the appendix .",
    "the following two results from @xcite provide exact algorithms for the construction of optimal strategies .",
    "more precisely , proposition [ prop : exp ] provides an exponential dynamic programming based algorithm for general trees .",
    "theorem [ thm : path ] gives an @xmath41 time algorithm for the special case where the input tree is a path and will be useful in the analysis of our main algorithm and also in the following lemma regarding the spider tree .",
    "[ prop : exp ] let @xmath3 be an edge - weighted tree on @xmath6 vertices .",
    "then an optimal decision tree for @xmath3 can be constructed in @xmath60 time .",
    "the following theorem was proved by cicalese et al .  in @xcite and will be useful later in the analysis of our algorithm and also in the following lemma regarding the spider tree .",
    "[ thm : path ] there is an @xmath41 time algorithm that constructs an optimal decision tree @xmath8 for a given weighted path on @xmath6 vertices .",
    "note that for a star @xmath3 any decision tree @xmath8 has the same cost , since all the edges have to be asked in the worst case .",
    "hence , for a tree @xmath3 such that there is only one node with degree greater than @xmath61 we have @xmath62 for any cost function @xmath37 .    a tree @xmath3 is a _ spider _ if there is at most one vertex in @xmath3 of degree greater than two .",
    "we refer to this vertex as the _ head _ ( or _ center _ ) of the spider .",
    "moreover , each path from the head of the spider to one of the leaves will be referred to as a _ leg _ of the spider .",
    "[ lem : spider ] let @xmath3 be a spider . then there is an algorithm which computes a 2-approximate decision tree @xmath8 for @xmath3 and runs in time @xmath41 .",
    "if @xmath3 is a path , then by theorem  [ thm : path ] there exists an algorithm computing the optimal decision tree in @xmath41 time .",
    "assume @xmath3 is not a path .",
    "then @xmath3 contains exactly one vertex @xmath27 of degree at least three .",
    "let @xmath63 be the star induced by @xmath27 and the vertices adjacent to @xmath27 .",
    "let us denote by @xmath64 the vertices adjacent to @xmath27 , where @xmath65 . by theorem  [ thm : path ] ,",
    "for every @xmath66 we construct the optimal decision tree @xmath67 for the path component @xmath68 of @xmath56 containing @xmath69 in time @xmath70 .",
    "note that the total running time for construction of @xmath71 is @xmath41 .",
    "finally , for @xmath63 we compute the optimal decision tree @xmath72 ( in @xmath73 time ) .",
    "the decision tree @xmath8 for @xmath3 is obtained from @xmath72 by replacing the node corresponding to @xmath69 by the root of @xmath67 for every @xmath74 .",
    "clearly , the algorithm runs in @xmath41 time and @xmath75 .",
    "the last inequality follows since by lemma  [ lem : subtree ] both @xmath76 and @xmath77 are lower bounds on @xmath50 .",
    "let @xmath6 be the size of the input tree and @xmath78 be a parameter fixed for the whole run of the algorithm .",
    "it holds that @xmath79 .    the basic idea of our algorithm is to construct a subtree @xmath80 of the input tree @xmath3 such that",
    ": ( i ) we can construct a decision tree for @xmath80 whose cost is at most a constant times the cost of an optimal decision tree for @xmath80 ; ( ii ) each component of @xmath81 has size not larger than @xmath82 .",
    "this will allow us to build a decision tree for @xmath3 by assembling the decision tree for @xmath80 with the decision trees recursively constructed for the components of @xmath83 .",
    "the constant approximation guarantee on @xmath80 and the fact that , due to the size of the subtrees on which we recurs , we need at most @xmath5 levels of recursion to show that our algorithm gives an @xmath5 approximation",
    ".    * the subtree @xmath80 . *",
    "we iteratively build subtrees @xmath84 . starting with the empty tree @xmath85 , in every iteration",
    "@xmath86 we pick a centroid @xmath87 of the largest connected component of the forest @xmath88 .",
    "the subtree @xmath89 is set to be the minimal subtree containing @xmath87 and @xmath90 .",
    "if for some @xmath91 we have that @xmath92 , then we set @xmath93 and we stop the iterations .",
    "if all @xmath94 iterations are completed then we set @xmath95 .    by definition ,",
    "the _ centroid _ of a tree @xmath3 is a vertex @xmath27 such that any maximal component of @xmath96 has size at most @xmath97 .",
    "therefore , we have the following lemma  which establishes ( ii ) above .",
    "[ lem : h - components ] if @xmath98 is a maximal connected component of @xmath99 , then @xmath100 .",
    "we prove by induction on @xmath101 that after @xmath102 iterations all maximal components of @xmath103 have size at most @xmath104 .",
    "let @xmath105 .",
    "we observe that by the definition of centroid , after @xmath106 iterations all components of @xmath107 have size at most @xmath108 .",
    "this establishes the basis of our induction .",
    "now fix some @xmath109 and assume ( induction hypothesis ) that after @xmath110 iterations all maximal components of @xmath111 have size at most @xmath112 . among these there are at most @xmath110 components that have size at least @xmath104 . in the next @xmath110 iterations",
    "we will choose a centroid in each of these components , one by one .",
    "choosing a centroid in a component @xmath98 splits @xmath98 into parts that have size at most half of @xmath98 , thus after @xmath113 steps all components of @xmath103 have size at most @xmath104 .",
    "thus , if the process of constructing @xmath80 is stopped after @xmath114 iterations all components have size at most @xmath115 . on the other hand ,",
    "if the process of constructing @xmath80 is stopped at some iteration @xmath116 then it means that @xmath117 and , trivially , we have @xmath118 .    * the decision tree for @xmath80 .",
    "* let @xmath119 contain all @xmath87 for @xmath120 and vertices of degree at least three in @xmath80 .",
    "note that @xmath121 .",
    "let @xmath122 be the path of @xmath3 whose endpoints are vertices @xmath26 and @xmath27 .",
    "we define an auxiliary tree @xmath123 on the vertex set @xmath119 .",
    "vertices @xmath124 form an edge of @xmath123 if @xmath26 and @xmath27 are the only vertices of @xmath119 of the path @xmath122 in @xmath3 with endpoints @xmath26 and @xmath27 .",
    "let @xmath125 ( the edge of @xmath122 with minimal cost ) and @xmath126 .",
    "let @xmath127 . by proposition  [ prop : exp",
    "] , we can compute an optimal decision tree @xmath128 for @xmath123 in @xmath129 which is polynomial in @xmath6 .",
    "let @xmath130 be obtained from @xmath128 by changing the label of every internal node from @xmath131 to @xmath132 , for each @xmath133 .",
    "the tree @xmath130 is not a decision tree for @xmath80 , however , leaves of @xmath130 correspond to connected components of @xmath134 . notice that @xmath135 .",
    "since every connected component @xmath136 of @xmath134 contains at most one vertex of degree at least three , every such component is a spider . by lemma  [ lem : spider ] , a decision tree @xmath137 for each such component @xmath138 can be computed in @xmath41 time with approximation ratio 2 .",
    "we can now obtain the decision tree @xmath139 for @xmath80 by replacing each leaf in @xmath130 with the decision tree for the corresponding component in @xmath134 .",
    "we have    @xmath140    where the second inequality holds because of @xmath141 ( given by proposition [ prop : contract ] ) and @xmath142 ( given by lemma [ lem : subtree ] ) .    *",
    "assembling the pieces in the decision tree for @xmath3*. let @xmath27 be a vertex in @xmath80 with a neighbor not in @xmath80 , let @xmath63 be the star induced by @xmath27 and its neighbors outside @xmath143 .",
    "let @xmath72 be a decision tree for @xmath63 ( notice that they all have the same cost ) . for every neighbor @xmath144 of",
    "@xmath27 we compute recursively the decision tree @xmath145 for the component @xmath146 of @xmath83 containing @xmath147 and replace the leaf node of @xmath72 associated to @xmath147 with the root of @xmath145 .",
    "the result is a decision tree @xmath148 for the subtree of @xmath3 including @xmath63 and all the components of @xmath83 including some neighbor @xmath147 of @xmath27 .    in order to obtain a decision tree @xmath149 for @xmath3",
    "we now modify @xmath139 as follows : for each vertex @xmath27 in @xmath80 with a neighbor not in @xmath80 , replace the leaf in @xmath139 associated with @xmath27 with the decision tree @xmath148 computed above .    , the important set of vertices @xmath119 and the auxiliary tree @xmath123 ]    * the approximation guarantee for @xmath149 .",
    "* let @xmath151 denote the approximation ratio obtained by algorithm  [ alg ] on the instance @xmath40 .",
    "let @xmath152 .",
    "[ lem : apx ] for any tree @xmath3 on @xmath6 vertices and any cost assignment @xmath37 , we have @xmath153 .    for every @xmath154 let @xmath155 .",
    "we shall prove by induction on @xmath101 that @xmath156 , which implies the statement of the lemma .    if @xmath157 then our algorithm builds an optimal decision tree , thus @xmath158 for @xmath159 .",
    "this establishes the induction base .",
    "choose a tree @xmath3 as in the statement of the lemma such that @xmath160 .",
    "let @xmath80 and @xmath123 be the substructures of @xmath3 built by the algorithm as described above .",
    "let @xmath161 be the set of vertices of @xmath80 with some neighbor not in @xmath80 .",
    "for each @xmath162 let @xmath146 be the maximal component of @xmath83 containing @xmath147 .",
    "let @xmath163 be the set of maximal components of @xmath83 .",
    "then , by construction , we have @xmath164 where    * ( [ eq : b ] ) follows from ( [ eq : a ] ) because of @xmath165 ( lemma [ lem : subtree ] ) * ( [ eq : c ] ) follows from ( [ eq : b ] ) because of ( [ eq : s - approx ] ) and the fact that any decision tree for a star @xmath63 has the same cost , hence also equal to @xmath166 * in ( [ eq : d ] ) the first inequality follows by induction and the second inequality by lemma  [ lem : h - components ] * ( [ eq : e ] ) follows from ( [ eq : d ] ) because of @xmath167 and the definition of @xmath168 .",
    "[ lem : time ] for a tree @xmath3 on @xmath6 vertices , the algorithm  [ alg ] builds the decision tree @xmath149 in time polynomial in @xmath6 .",
    "the proof of lemma  [ lem : time ] is deferred to the appendix .",
    "lemma  [ lem : time ] and lemma  [ lem : apx ] now imply theorem  [ thm : main ] .",
    "[ 1]@xmath169 # 1    ts    @xmath170 @xmath171 @xmath157 * then * * return * optimal decision tree @xmath130 for @xmath3 computed by proposition  [ prop : exp ] @xmath172 [ alg : sbuild1 ] @xmath173 centroid of a maximum size connected component of @xmath88 @xmath174 smallest subtree containing @xmath87 and @xmath90 [ alg : sbuild2 ] @xmath175 @xmath176 tree on vertex set @xmath119 , @xmath177 iff @xmath178 @xmath179 @xmath180 edge of @xmath122 with minimum cost @xmath181 compute optimal decision tree @xmath128 for @xmath182 by proposition  [ prop : exp ] replace label of @xmath131 in @xmath128 by @xmath132 compute 2-approximate decision tree @xmath183 for @xmath98 by lemma  [ lem : spider ] [ alg : spider ] replace the leaf @xmath184 corresponding to @xmath98 by the root of @xmath183 @xmath185 star induced by @xmath27 and its neighbors outside of @xmath143 [ alg : sv ] construct decision tree @xmath72 for @xmath186 @xmath187 connected component of @xmath83 containing @xmath147 @xmath188 [ alg : recurse ] leaf of @xmath72 corresponding to @xmath147 @xmath189 root of @xmath145 replace the leaf of @xmath128 associated to @xmath27 by the root of @xmath72    @xmath128",
    "in this section we provide a new hardness result which contributes to refining the separation between hard and polynomial instances of the tree search problem with non - uniform costs .",
    "we show that the problem of finding a minimum cost decision tree is hard even for instances where the input graph is a spider and the length of every leg is three .",
    "our reduction is from the knapsack problem .",
    "the input of the knapsack problem is given by : a knapsack size @xmath190 , a desired value @xmath191 , and a set of items , @xmath192}$ ] , where @xmath193 is the value and @xmath69 is the weight of the @xmath91th item .",
    "the goal is to decide whether there exists a subset of items of total value at least @xmath191 and whose weight can be contained in the knapsack , i.e. , whether there is a @xmath194 $ ] such that @xmath195 and @xmath196 .",
    "from a knapsack instance we construct an instance @xmath197 for the tree search problem with non - uniform costs , where @xmath80 is a spider .",
    "each leg will correspond to an item .",
    "therefore , we will speak of the @xmath91th leg as the leg corresponding to the @xmath91th item . for each @xmath198 $ ] ,",
    "the @xmath91th leg will consist of three edges : the one closest to the head will be called _ femur _ ( and referred to as @xmath199 ) , the middle edge will be called _ tibia _ ( and referred to as @xmath200 ) , the end will be called the _ tarsus _ ( and referred to as @xmath201 ) .",
    "the cost function is defined as follows : for each @xmath198 $ ] , we set @xmath202 ; @xmath203 and @xmath204 , with @xmath205 a large number to be determined later .",
    "it is easy to see that in an optimal strategy , for each @xmath198 $ ] the edge @xmath201 is always queried last among the edges on the @xmath91th leg . given a decision tree @xmath8 , we denote by @xmath206 the set of indices of the legs for which , in @xmath8 , the node associated with the query to the tibia is an ancestor of the node associated with the query to the femur . then , we have the following proposition , whose proof is deferred to the appendix .",
    "[ prop : knap - dectreestructure ] there is an optimal decision tree @xmath8 with @xmath207 and such that :    \\(i ) for any @xmath208 and @xmath209 \\setminus i^d$ ] the node of d associated with the @xmath210th femur is an ancestor of the node associated with the @xmath91th tibia .",
    "\\(ii ) for any @xmath211 the node of d associated with the @xmath91th tibia is an ancestor of the node associated with the @xmath210th femur .    by this proposition",
    ", we can assume that in the optimal decision tree @xmath8 for at least one leg of the spider the first edge queried is a tibia .",
    "in addition , in @xmath8 , there is a root to leaf path where first all femurs not in @xmath206 are queried , then all tibias in @xmath206 and finally all femurs in @xmath206 ( see fig .  [",
    "fig : knap - spider ] in appendix for a pictorial example ) .",
    "then , the cost of such a decision tree is given by the maximum between the cost of the leaf on the legs with index in @xmath206 and whose tibia is queried as last , and the cost of the central vertex of the spider .",
    "it follows that the cost of the optimal solution is given by the following expression @xmath212 } \\max \\left\\{n + \\sum_{i \\not \\in i } ( v_i+w_i ) + \\sum_{i \\in i } v_i ;",
    "\\sum_{i \\in i } v_i + \\sum_{i \\in [ m ] } ( v_i + w_i ) \\right\\}\\ ] ]    if we set @xmath213 } ( v_i + w_i ) - w - v$ ] , then we can rewrite the above expression as follows : @xmath212 } \\max \\left\\{n + \\sum_{i \\not \\in i } w_i + \\sum_{i \\in [ m ] } v_i ; n + w + v   + \\sum_{i \\in i } v_i   \\right\\}\\ ] ]    now , it is easy to see that @xmath214 is at most @xmath215 } v_i+n+w$ ] if an only if @xmath216 and @xmath217 , that is , if and only if the set @xmath218 \\setminus i$ ] is a solution for the knapsack problem .",
    "note that as the values and weights are unrelated , we can indeed choose @xmath205 as big as necessary for the above reduction , which is clearly polynomial in the size of the input to the knapsack problem .",
    "we are very grateful to balzs patks for organizing @xmath219 emlktbla workshop where we collaborated on this paper .    1    r. ahlswede , i. wegener .",
    "_ search problems_. j. wiley & sons , chichester  new york , 1987 .",
    "m. aigner .",
    "_ combinatorial search_. wiley  teubner , new york ",
    "stuttgart , 1988 .",
    "y. ben - asher , e. farchi , and i. newman .",
    "optimal search in trees . _ siam journal on computing _",
    ", 28(6):20902102 , 1999 .",
    "f. cicalese , t. jacobs , e. laber , and c. valentim .",
    "the binary identification problem for weighted trees .",
    ", 459:100112 , 2012 .",
    "p. de  la torre , r. greenlaw , and a. schffer .",
    "optimal edge ranking of trees in polynomial time .",
    ", 13(6):592618 , 1995 .",
    "d. dereniowski .",
    "edge ranking of weighted trees .",
    ", 154:11981209 , may 2006 .",
    "d. dereniowski . edge ranking and searching in partial orders .",
    ", 156(13):24932500 , 2008 .",
    "u. faigle , l. lovsz , r. schrader , gy . turn .",
    "searching in trees , series - parallel and interval orders .",
    "_ siam journal on computing _ , 15(4):10751084 , 1986 .",
    "iyer , h.d .",
    "ratliff , and g. vijayan . on an edge ranking problem of trees and graphs .",
    ", 30(1):4352 , 1991 .",
    "_ searching and sorting _ , 3rd volume of the art of computer programming , addison - wesley , 1998 .",
    "t. wah lam and f.  ling yue .",
    "optimal edge ranking of trees in linear time . in _",
    "soda 98 : proceedings of the ninth annual acm - siam symposium on discrete algorithms _ , pages 436445 , philadelphia , pa , usa , 1998 .",
    "society for industrial and applied mathematics .",
    "n. linial and m. saks .",
    "searching order structures .",
    "_ journal of algorithms _ , 6:86103 , 1985 .",
    "k. makino , y. uno , and t. ibaraki . on minimum edge ranking spanning trees .",
    ", 38:411437 , february 2001 .",
    "s. mozes , k. onak , o. weimann .",
    "finding an optimal tree searching strategy in linear time . in _ proc .",
    "of the 19th annual acm - siam symp .",
    "om discrete algorithms _ ( soda08 ) , pp . 10961105 , 2009 .",
    "m. wermelinger .",
    "searching efficiently in posets .",
    "_ topics in programming techonology _ , new university of lisbon , 1993 .",
    "let @xmath8 be an optimal decision tree for the instance @xmath220 .",
    "let us assume without loss of generality that in @xmath8 the node @xmath221 associated with @xmath222 is an ancestor of the node @xmath223 associated with @xmath224 .",
    "notice that one of the children of @xmath223 is a leaf associated with the vertex @xmath27 .",
    "let @xmath225 be the subtree of @xmath8 rooted at the non - leaf child of @xmath223 .",
    "it is not hard to see that @xmath47 is a proper decision tree for @xmath44 .",
    "in addition we also have that for any vertex @xmath227 of @xmath44 which is associated to a leaf in @xmath225 it holds that @xmath228 , and for any other vertex @xmath227 of @xmath44 we have @xmath229 or @xmath230 .",
    "it follows that @xmath231 .      if @xmath157 then the algorithm builds an optimal decision tree for @xmath3 in time @xmath232 using the construction from proposition  [ prop : exp ]",
    "otherwise , every iteration needed to build the subtree @xmath80 ( lines [ alg : sbuild1][alg : sbuild2 ] of the algorithm ) introduces one new vertex @xmath87 and at most one other vertex of degree at least three , thus @xmath233 .",
    "proposition  [ prop : exp ] then implies that an optimal decision tree @xmath128 for @xmath123 can be computed in time @xmath234 which is polynomial in @xmath6 . by lemma  [ lem : spider ] ,",
    "the @xmath235-approximation decision tree @xmath183 for @xmath98 can be computed in @xmath41 time . building the decision tree @xmath72 for the stars @xmath63 takes @xmath236 time ( line  [ alg : sv ] ) .",
    "the rest of the algorithm , not counting the recursion on line  [ alg : recurse ] , needs time @xmath41 . as the recursion is for a graph whose size is at most half of the original , the overall algorithm running time is polynomial in @xmath6 .      .",
    "for the ease of notation , we use @xmath237 for @xmath206 .",
    "the cost of this decision tree can be obtained as the max of the costs provided by the leaf associated to @xmath238 and the leaf associated with @xmath239 . ]",
    "we first show that there is an optimal decision tree with @xmath240 .",
    "let @xmath241 be a decision tree where each femur is queried before the corresponding tibia , i.e. , @xmath242 . let @xmath91 be the index of the last femur queried .",
    "therefore one of the two children of the node querying @xmath199 is a leaf associated to @xmath239 , while in the subtree rooted at the other child the leaves are associated to the vertices in the @xmath91th leg .",
    "let @xmath243 , denote the vertices on the @xmath91th leg in order of increasing distance from @xmath239 .",
    "it is not hard to see that @xmath244 where @xmath245 is the cost of the queries on the path from the root of @xmath241 to the parent of the node associated with the query to @xmath199 .",
    "now consider the decision tree obtained from @xmath241 by replacing the query to @xmath199 with a query to @xmath200 , then one child of this node queries @xmath199 and the other child queries @xmath201 .",
    "let @xmath47 be the resulting decision tree .",
    "it is not difficult to see that we now have @xmath246 and @xmath247 for any @xmath248 .",
    "hence @xmath249 with @xmath250 for @xmath47 .",
    "* there exists @xmath252 and @xmath209\\setminus i$ ] such that the node @xmath253 associated with @xmath254 is a child of the node @xmath255 associated with @xmath200 ; * there exists @xmath256 such that the node @xmath255 associated with @xmath200 is a child of the node @xmath253 associated with @xmath254 ; * there exists @xmath252 and @xmath209\\setminus i$ ] such that the node @xmath253 associated with @xmath254 is a child of the node @xmath255 associated with @xmath199 .",
    "therefore , it is enough to show that if we have an optimal tree where one of the three conditions holds , by swapping the nodes @xmath255 and @xmath253 involved , we can obtain a new decision tree whose total cost is not larger than the cost of the original decision tree .",
    "this implies that by repeated use of this swapping procedure , we have an optimal decision tree where both ( i ) and ( ii ) hold ."
  ],
  "abstract_text": [
    "<S> searching in partially ordered structures has been considered in the context of information retrieval and efficient tree - like indexes , as well as in hierarchy based knowledge representation . in this paper </S>",
    "<S> we focus on tree - like partial orders and consider the problem of identifying an initially unknown vertex in a tree by asking edge queries : an edge query @xmath0 returns the component of @xmath1 containing the vertex sought for , while incurring some known cost @xmath2 .    </S>",
    "<S> the tree search problem with non - uniform cost is : given a tree @xmath3 where each edge has an associated cost , construct a strategy that minimizes the total cost of the identification in the worst case .    </S>",
    "<S> finding the strategy guaranteeing the minimum possible cost is an np - complete problem already for input tree of degree 3 or diameter 6 . </S>",
    "<S> the best known approximation guarantee is the @xmath4-approximation algorithm of [ cicalese et al . </S>",
    "<S> tcs 2012 ] .    </S>",
    "<S> we improve upon the above results both from the algorithmic and the computational complexity point of view : we provide a novel algorithm that provides an @xmath5-approximation of the cost of the optimal strategy . </S>",
    "<S> in addition , we show that finding an optimal strategy is np - complete even when the input tree is a spider , i.e. , at most one vertex has degree larger than 2 . </S>"
  ]
}