{
  "article_text": [
    "the asymptotic shape of conditioned galton - watson trees has been widely studied .",
    "for example , one could condition on the number of nodes of the tree being @xmath0 , and letting @xmath1 . in a lot of cases ,",
    "the limiting tree is quite well understood , see for example the survey paper by janson @xcite .",
    "some work on finite conditioned trees has been done by geiger and kersting @xcite , who studies the shape of a tree conditioned on having height exactly equal to @xmath0 . in this context",
    ", we also mention the spinal construction of a galton - watson tree conditioned to reach generation k , as derived in @xcite .    in this paper",
    ", we will investigate conditioning multi - type galton - watson trees on events of a recursive nature ( as explained in section [ section : conditioning ] ) , one example being conditioning on survival to a given level .",
    "the main idea is that we consider different classes of trees , where the class of a tree is determined by the types and classes of her children .",
    "the offspring distribution of a node depends on its type and on the level of the tree where this node is living .",
    "in fact , we show that the conditioned tree again is a multi - type galton - watson tree and how this can be used to directly construct such a conditioned tree .",
    "our approach can be seen as a generalization of the well - known decomposition of a supercritical galton - watson tree into nodes whose offspring survives forever and nodes whose offspring eventually goes to extinction as discussed in @xcite .",
    "section [ section : examples ] discusses a couple of examples that illustrate the applicability of our results .",
    "we give an example concerning mutants in a population , we discuss an alternative to geiger s construction of a tree conditioned on having height exactly @xmath2 and we show how to condition on the size of the @xmath2th generation",
    ".      we will consider rooted multi - type galton - watson trees with arbitrary offspring distribution , that can depend on the current generation .",
    "in such a tree each node has a type , which we indicate by a natural number @xmath3 .",
    "if the root of a tree has type @xmath4 , we use a bold - face @xmath4 to denote this root .",
    "define the set of trees of heigth @xmath5 as @xmath6 .",
    "then we define inductively for @xmath7 the set of trees of height at most @xmath2 by @xmath8)\\mid t_i\\in { { \\mathcal t}}_{k-1},t\\in\\theta\\},\\ ] ] and denote the set of all trees by @xmath9 . for a tree @xmath10 )",
    "\\in \\theta\\times({{\\mathcal t}}_{k-1})^n$ ] , the trees @xmath11 will be called the children of @xmath12 ( notation : @xmath13 )",
    ". the type of @xmath12 will be just the type of its root and will be denoted by @xmath14 .",
    "we now define a function @xmath15 that counts how many children of each type a tree @xmath12 has : @xmath16 the set of trees of heigth at most @xmath2 having a root of type @xmath4 is denoted by @xmath17)\\mid t_i\\in { { \\mathcal t}}_{k-1}\\}.\\ ] ] let @xmath18 .",
    "denote the offspring distribution of a type @xmath4 node at height @xmath19 by @xmath20 , for arbitrary probability measures @xmath20 on @xmath21 .",
    "define independent random variables @xmath22 . for a vector @xmath23",
    ", we write the corresponding multinomial coefficient as @xmath24 we now introduce the galton - watson probability measures on @xmath25 .",
    "firstly , let @xmath26 be the trivial probability measure on @xmath27 , so @xmath28 .",
    "now define inductively the probability measure @xmath29 for @xmath30 and @xmath31 as the following probability measure on @xmath32 : if @xmath33 , then @xmath34 . otherwise for all @xmath35 @xmath36 where empty products are taken to be @xmath37 .",
    "the intuition is that the second sub - index determines the size of the final tree we are considering , whereas the first sub - index determines at which level we are building up the tree ( so @xmath29 generates trees of type @xmath4 at level @xmath38 of size @xmath39 ) .",
    "we are interested in @xmath40 , which is the galton - watson probability measure on @xmath25 ( trees cut off at height @xmath2 with a root of type @xmath4 ) .",
    "+ in the next section we will introduce a class of recursive - type events on which we would like to condition , and discuss several examples of such events . in section [ section : conditionalmeasures ] we will introduce the conditional measures corresponding to our events , and in section [ section : proof ] we show that these conditional measures indeed coincide with the original galton - watson measure , conditioned on our event .",
    "in this section we introduce a class of recursive - type events on which we would like to condition , such as the event that the tree survives until a specific level .",
    "we will now set up our general framework and show how some examples fit into it .",
    "we start by choosing @xmath41 and partitioning @xmath42 into @xmath43 classes @xmath44 . typically , all trees in such a class have some property that all trees in the other classes do not have .",
    "one of the simplest examples would be a partition into two classes , where trees that survive until some level @xmath2 are in the first class and all other trees in the second .",
    "the partition of @xmath42 will be the starting point to recursively define partitions of @xmath45 , @xmath46 into sets @xmath47 , where @xmath2 is the ( maximum ) height of the trees that we are considering .",
    "suppose that the partition of @xmath48 is already defined .",
    "then we are able to introduce a counting matrix for trees in @xmath45 .",
    "define @xmath49 such that for @xmath50 the @xmath51th position is given by @xmath52 so this is the number of children of @xmath12 having type @xmath53 and being an element of the @xmath54th partition class .",
    "now for @xmath46 we partition @xmath55 into subsets @xmath56 .",
    "this partition is the key for the recursive definition of @xmath57 .",
    "the set @xmath57 will contain exactly those trees for which the counting matrix @xmath58 is in @xmath59 : @xmath60      before going into the details of the construction of conditioned trees , we will discuss some examples of recursive events that can be handled by our approach .",
    "suppose we have a population in which sometimes an individual ( mutant ) is born having a particular mutation in its genetic material .",
    "this mutation can be inherited by subsequent generations .",
    "suppose we know the probability that the root is mutated .",
    "such a population can be described as a two - type galton - watson process in which the offspring distribution is type- and possibly level - dependent .",
    "we take @xmath61 to be the set of types , where mutants have type @xmath37 . +   +",
    "suppose we would like to condition on the event  there is at least one mutant in the @xmath2th generation \" .",
    "choose @xmath62 and partition @xmath63 into the classes @xmath64 and @xmath65 .",
    "for @xmath66 , we want to define @xmath67 and @xmath68 by @xmath69 these events satisfy a recursive relation : @xmath67 contains exactly those trees that have at least one child in @xmath70 . for @xmath71 ,",
    "the first row of the @xmath72-counting matrix @xmath58 counts the children of @xmath12 that are in @xmath70 .",
    "therefore , for all @xmath66 we let @xmath73\\in { { \\mathbb n}}^{2\\times 2}:a+b\\geq 1\\right\\ } , b_{l,2 } = { { \\mathbb n}}^{2\\times 2}\\backslash b_{l,1},\\ ] ] and now ( [ eq : partition ] ) gives the desired partition of @xmath74 .",
    "for the sake of illustration , we note that with a minor change , we can condition on  there is at least one mutant in the @xmath2th generation inheriting its mutation from the root \" . to achieve this",
    ", it suffices to merely redefine @xmath75 and @xmath76 for all @xmath66 as follows @xmath73\\in { { \\mathbb n}}^{2\\times 2}:a\\geq 1\\right\\ } , b_{l,2 } = { { \\mathbb n}}^{2\\times 2}\\backslash b_{l,1}.\\ ] ]    in these two examples , we defined one partition class @xmath77 by the event on which conditioning is required .",
    "the only other partition class was just the complement of the first one .",
    "finding a suitable partition of the set of trees is not always that obvious , as is demonstrated in the next example .",
    "we will show how to condition on the slightly more complicated event  all mutants in the tree inherit their mutation from the root and at least one mutant is present in generation @xmath2 \" .",
    "as before , define one partition class @xmath67 as the set of trees satisfying the condition .",
    "here it is not sufficient to define only one other partition class .",
    "one obstacle is that some trees ( namely those with a  spontaneous mutation \" ) in the complement @xmath78 are forbidden as a child of trees in @xmath79 and others are not .    nevertheless , with a slightly more elaborate partition",
    ", we can still handle this case .",
    "we distinguish four classes and partition @xmath80 into @xmath81 for @xmath66 , we define the following subsets of @xmath82 : @xmath83:a\\geq 1\\right\\ } , &   b_{l,2 } = \\left\\{\\left[\\begin{array}{cc}0&0\\\\0&a\\\\0&0\\\\0&0\\end{array}\\right]\\right\\}\\\\   & b_{l,3 } = \\left\\{\\left[\\begin{array}{cc}a&b\\\\c&d\\\\e&f\\\\g&h\\end{array}\\right]:b+e+f+h\\geq   1\\right\\ } , &   b_{l,4 } = \\left\\{\\left[\\begin{array}{cc}0&0\\\\a&b\\\\0&0\\\\c&0\\end{array}\\right]:a+c\\geq 1\\right\\}\\\\\\end{aligned}\\ ] ] as can be easily checked , these sets are disjoint and @xmath84 , so this indeed is a partition .",
    "it follows by induction that the sets @xmath57 partition @xmath45 in such a way that    * @xmath85 contains exactly the trees having * * at least one mutated child of which the mutated progeny reaches level @xmath38 , and * * no  spontaneous \" mutants in the progeny of their children .",
    "* @xmath86 contains the trees having only type 2 descendants .",
    "* @xmath87 contains the trees having a type 2 descendant with a type 1 child (  spontaneous mutation \" ) . *",
    "@xmath88 contains all other trees in @xmath45 .",
    "note that these classes are defined by properties of the children of a tree and not by the type of the tree itself .",
    "for example , a tree in @xmath68 can have a type 1 root , but all its descendants have type 2 .",
    "the conditional measure we are interested in is now obtained by conditioning @xmath89 on @xmath90 .      as a next example , we show how to condition a single - type galton - watson tree on having exactly @xmath91 individuals in the @xmath2th generation . in this case , we partition @xmath92 into @xmath93 classes by defining @xmath94 define @xmath95 by @xmath96^t$ ] . for @xmath97 , we define @xmath98 where @xmath99 .",
    "partitioning @xmath45 according to ( [ eq : partition ] ) gives the following : for @xmath100 , @xmath57 contains the trees of which the @xmath38th generation has exactly size @xmath54 , while @xmath101 contains the trees of which the @xmath38th generation has at least size @xmath102 .",
    "conditioning @xmath103 on @xmath104 gives the result we are looking for .      as a final illustration",
    ", we explain how to condition a galton - watson tree on having height exactly @xmath2 , thus producing an alternative for the construction of geiger and kersting @xcite .",
    "we consider trees in @xmath105 that are conditioned to reach level @xmath2 , but not level @xmath106 .",
    "we start by choosing @xmath107 , and partitioning @xmath108 into three sets , namely correct trees , short trees and long trees : @xmath109 define for each @xmath110 @xmath111 and let @xmath112 be partitioned as in ( [ eq : partition ] ) .",
    "this construction guarantees that if a tree @xmath113 is an element of @xmath114 , then it has at least one child that reaches level @xmath2 , and no children that reach level @xmath106 .",
    "if @xmath115 , all its children do not reach level @xmath2 , and if @xmath116 , then at least one child reaches level @xmath106 .",
    "conditioning on being in @xmath114 therefore gives the desired result .",
    "as it turns out from the examples in the previous section , the setup allows to condition on quite a variety of events .",
    "a fundamental requirement on these events is that they are determined only by the _ number _ of children of a tree having particular properties .",
    "so we can ( for instance ) not distinguish between trees having the same children in a different order .",
    "an additional example is discussed in detail in @xcite . as an application of the theory developed in the present paper ,",
    "the cost of searching a tree to a given level is determined .",
    "the proposed model takes into account costs for having a lot of children , but also for walking into dead ends .",
    "so both a high expected offspring and a low expected offspring would give high search costs .",
    "this gives rise to an optimization problem : which offspring distribution gives minimal costs ?",
    "for this model the conditional probability measures are explicitly constructed , leading to recursions that enable us to calculate the costs and solve the optimization problem for poisson offspring .",
    "conditioning on recursive events as in the examples allows us to compute ( conditional ) probabilities that are defined in terms of such events . as an illustration : in the example on genetic mutations we can easily compute the probability that the root is mutated , given that there is at least one mutant in generation @xmath2 .",
    "what makes the results even more useful is that they show how to directly construct a tree conditioned on some event .",
    "this means that trees conditioned on ( rare ) events can be studied by just simulating them .",
    "in this section we construct an alternative measure @xmath117 on @xmath32 , that depends on the event we want to condition on .",
    "as soon as we have this measure , conditioning on the desired event is a triviality . in the next section",
    ", we will show that in fact the two measures @xmath29 and @xmath117 are the same .",
    "+ define @xmath118 for @xmath119 by @xmath120 we can calculate this probability in a recursive way .",
    "denote , for @xmath121^m$ ] with @xmath122 , by @xmath123 the multinomial distribution where we distribute @xmath0 elements over @xmath43 classes , according to the probabilities @xmath124 .",
    "we also choose independent random vectors @xmath125 according to the offspring distribution of a type @xmath4 node at level @xmath38 and denote the @xmath53th coordinate by @xmath126 .",
    "then , for @xmath127 @xmath128 where , for @xmath129 , we defined @xmath130 to be the matrix for which @xmath131 .",
    "we proceed by defining the conditional measure @xmath132 on @xmath133 . to do this ,",
    "define for each @xmath134 and @xmath135 on the same probability space as @xmath136 , the random matrices @xmath137 such that conditional on @xmath136 , all columns are independent and the distribution of the @xmath53th column satisfies @xmath138 this determines the full joint distribution of @xmath139 . for a type @xmath4 node at level @xmath38 ,",
    "the distribution of its children over the @xmath140 types is given by the random vector @xmath141 .",
    "furthermore , the @xmath53th column of @xmath142 represents how the type @xmath53 children of this type @xmath4 node are distributed over the @xmath43 classes . for @xmath143",
    ", we define for each @xmath144 @xmath145 as a probability measure on @xmath146 .",
    "next , we inductively define the probability measures @xmath132 on @xmath133 for each @xmath135 such that for each @xmath147 @xmath148 where we extended the definition of @xmath149 ( see section [ section : notation ] ) to integer - valued matrices , and once again empty products are taken to be 1 .",
    "note that this definition is valid for all @xmath150 : we simply get @xmath151 whenever @xmath152 .",
    "we can now define the alternative measure @xmath153 on @xmath32 : @xmath154      we can describe the random tree @xmath155 as follows .",
    "the root of the tree has type @xmath4 . to construct the tree , we first toss an @xmath43-sided coin to determine in which of the @xmath43 classes @xmath156 is , giving probability @xmath118 to the @xmath54th class @xmath157 . if @xmath158 , then we choose it according to @xmath132 .",
    "this means that we choose @xmath159 , where @xmath160 counts the numbers of children of @xmath156 of each type and @xmath161 counts for each type the numbers of children that will lie in each of the @xmath43 classes , according to @xmath162 the @xmath163 children are distributed over the @xmath164 positions uniformly at random .",
    "then for each child of type @xmath53 in @xmath165 we draw a tree according to @xmath166 .    in this way we have described the random tree as a galton - watson tree with @xmath167 ` types ' of children and type- and level - dependent offspring distribution .",
    "note that conditioning @xmath168 on @xmath157 is trivial : we simply have to draw @xmath156 according to @xmath132 .",
    "the following theorem shows that the construction procedure of section [ section : conditionalmeasures ] in fact generates trees with the same probabilities as under the original galton - watson measure .",
    "fix @xmath2 and @xmath169 and define all measures as before .    for all @xmath119 , @xmath170 and @xmath35 , @xmath171    * proof : * the theorem is true by construction for @xmath143 .",
    "now suppose that we have already shown that @xmath172 for all @xmath4 .",
    "choose @xmath173 and suppose @xmath174 .",
    "before we show that @xmath175 , we collect some useful observations .",
    "first of all , note that the number of ways to distribute the individuals over the positions in @xmath176 can be written as a product by first assigning a type to each individual and then distributing all individuals of a given type over the classes ( writing @xmath176 for @xmath177 and @xmath178 for @xmath179 ) : @xmath180 secondly , note that @xmath181 is equal to @xmath182 and by ( [ eq : tplk(i ) ] ) this is exactly @xmath183 .",
    "next , since @xmath177 determines @xmath179 , we have : @xmath184 combining these observations gives @xmath185 @xmath186",
    "in this section we use our results to work out one of the examples of section [ section : examples ] . for these calculations it will turn out to be very useful that our conditioned tree is again a galton - watson multitype tree .",
    "we consider a population with mutants and let the set of types be @xmath187 , where type @xmath37 denotes a mutant .",
    "the number of children of a type @xmath4 node will have a @xmath188 distribution and each child has probability @xmath189 to be a mutant itself , independent of all other children .",
    "+   + we will condition on the event that there is at least one mutant in the @xmath2th generation .",
    "the corresponding partition of @xmath45 is given by @xmath190 where @xmath75 is the set of matrices @xmath191\\in { { \\mathbb n}}^{2\\times 2}:a+b\\geq 1\\right\\}.\\ ] ] remember that this means that a tree in @xmath45 is an element of @xmath67 if and only if it has a type @xmath37 or a type @xmath192 child in @xmath70 .",
    "we will now derive the recursions for the probabilities @xmath118 . a type @xmath4 subtree that starts on level @xmath193 has two types of children , and each child is in one of the two classes .",
    "type and class of a child are independent of all other children s properties .",
    "so we can introduce four new ` types ' , occurring according to the following distributions : @xmath194 all independent of each other . in",
    "this notation @xmath195 stands for the number of type @xmath196-children in class @xmath197 of a type @xmath4 node at level @xmath38 .",
    "note that the intensities indeed add up to @xmath198 .",
    "for instance , the probability that a mutant ( type @xmath37 ) on level @xmath38 does not generate a mutant on level @xmath2 satisfies @xmath199 and similarly it follows that @xmath200 the corresponding initial conditions are @xmath201 figure [ fig : kansen ] shows the behavior of these probabilities for the following choice of parameters : mutants reproduce at rate @xmath202 and non - mutants at rate @xmath203 .",
    "mutants can only generate mutants ( @xmath204 ) and a child of a non - mutant has a very small probability to be a mutant , @xmath205 .",
    "the dashed line shows the probability that a tree with mutated root has a mutant on the @xmath2th level as a function of @xmath2 . this is a critical tree with only mutants that eventually goes extinct .",
    "the solid line shows the probability that a tree with non - mutated root has a mutant on the @xmath2th level .",
    "this tree is supercritical , with reproduction rate ( very close to ) @xmath206 . in a tree with poisson(@xmath207 ) offspring ,",
    "the extinction probability is the non - trivial solution of @xmath208 for @xmath209 , this gives @xmath210 .",
    "the corresponding survival probability is given as a dotted line in figure [ fig : kansen ] .",
    "this indicates that if the tree does not die out , then eventually there will be mutants almost surely , since the population grows exponentially .",
    "the population is of order @xmath211 around generation @xmath212 , which explains the location of the increase of the solid line .",
    "we will now consider a tree with a non - mutated root , conditioned on having a mutant on level @xmath2 .",
    "we will show how to compute the expected number of mutants on each level in such a conditioned tree .",
    "a type @xmath4 subtree at level @xmath38 is in class @xmath37 if and only if its counting matrix is in @xmath213 .",
    "this corresponds to conditioning the distributions in ( [ eq : offspring ] ) on @xmath214 write @xmath215 for @xmath216 and @xmath217 for @xmath218 . then @xmath219 = { { \\mathbb e}}[x\\mid x+y \\geq",
    "1]\\cdot{{\\mathbb p}}(x+y \\geq 1 ) + { { \\mathbb e}}[x\\mid x+y = 0]\\cdot{{\\mathbb p}}(x+y = 0).\\ ] ] since @xmath220 = 0 $ ] and @xmath221 , we obtain @xmath222 = \\frac{{{\\mathbb e}}[x]}{{{\\mathbb p}}(x+y \\geq 1 ) } = \\frac{{^1}p_{l+1,k}^{(1)}\\cdot p_t\\cdot\\mu_t}{^tp_{lk}^{(1)}}.\\ ] ] and analogously : @xmath223 =   \\frac{{{\\mathbb e}}[y]}{{{\\mathbb p}}(x+y \\geq 1 ) } = \\frac{{^2}p_{l+1,k}^{(1)}\\cdot ( 1-p_t)\\cdot\\mu_t}{^tp_{lk}^{(1)}}.\\ ] ] the conditioned tree is in fact a four - type galton - watson tree : @xmath224 abbreviating @xmath225 by @xmath226 and @xmath227 by @xmath124 , the expected offspring of a node at level @xmath193 described by the following matrix : @xmath228 in this matrix , the columns give the expected offspring of a type @xmath229 , @xmath230 , @xmath231 or @xmath232 node respectively at level @xmath38 in the tree . now",
    "the conditioned tree we are interested in is just a tree with a root of type @xmath231 .",
    "the types @xmath229 and @xmath230 correspond to mutated individuals .",
    "therefore , the expected number of mutants on level @xmath38 in the conditioned tree is given by @xmath233 see figure [ fig : verwachtingen ] , for a plot of these expected numbers as a function of the generation .",
    "+    as a last example , we computed the expected total number of individuals in a tree with a non - mutant root and conditioned to have _ no _ mutant in generation @xmath2",
    ". if @xmath2 is small , occurrence of mutants is unlikely anyway , so then the tree just grows exponentially .",
    "if the population grows beyond order @xmath211 , then the condition has a serious influence on the expected size of the tree .",
    "for example , taking @xmath234 , the population size in the unconditioned tree would be of order @xmath235 , but in the conditioned tree it is only of order @xmath236 .",
    "see figure [ fig : remarkable ] , left plot . for even larger @xmath2 the condition to have no mutant in generation @xmath2 is very restrictive .",
    "see figure [ fig : remarkable ] , right plot .",
    "apparently , the condition more or less forces the tree to die out early . in the unlikely case that it survives to generation @xmath237",
    ", the population stays small for a long time .",
    "the minimal expected size is @xmath238 individuals and is attained around generation @xmath239 .",
    "after that the population starts expanding .",
    "the later an individual is born , the less its progeny is influenced by the condition that no mutant is present in generation @xmath237 .",
    "this also explains the increase in the curve that is seen at the end .",
    "we have demonstrated how to condition multi - type galton - watson trees on events having some recursive nature .",
    "more specifically , we looked at partitions of the set of trees in which each partition set is defined by some tree property .",
    "a crucial aspect of these properties is that they are determined completely by the types of children of the tree and the partition sets to which they belong .",
    "as our examples show , there is a wide variety of events fitting into this framework .",
    "we have shown that such a conditioned tree itself is again a multi - type galton - watson tree , and we derived equations for the type- and level - dependent offspring distribution .",
    "these results turn out to be very useful to analyze conditioned trees .",
    "also , using our explicit construction procedure we can directly generate a tree that is conditioned to satisfy some property that has very low probability , which should also be useful for simulation purposes ."
  ],
  "abstract_text": [
    "<S> we consider multi - type galton watson trees , and find the distribution of these trees when conditioning on very general types of recursive events . </S>",
    "<S> it turns out that the conditioned tree is again a multi - type galton watson tree , possibly with more types and with offspring distributions depending on the type of the father node and on the height of the father node . </S>",
    "<S> these distributions are given explicitly . </S>",
    "<S> we give some interesting examples for the kind of conditioning we can handle , showing that our methods have a wide range of applications . </S>"
  ]
}