{
  "article_text": [
    "in this paper we introduce a new approach for approximately counting in bounded degree systems with higher - order constraints .",
    "for example , if we are given a cnf formula @xmath0 with @xmath3 variables and @xmath4 clauses with the property that each clause contains at least @xmath1 variables and each variable belongs to at most @xmath2 clauses we ask :    how does @xmath1 need to relate to @xmath2 for there to be algorithms to estimate the number of satisfying assignments to @xmath0 within a @xmath5 multiplicative factor ?    in the case of a monotone cnf formula where no variable appears negated , the problem is equivalent to the following : suppose we are given a hypergraph on @xmath3 nodes and @xmath4 hyperedges with the property that each hyperedge contains at least @xmath1 nodes and each node belongs to at most @xmath2 hyper edges . how does @xmath1 need to relate to @xmath2 in order to be able to approximately compute the number of independent sets . here",
    "an independent set is a subset of nodes for which there is no induced hyperedge .",
    "bordewich , dyer and karpinski @xcite gave an mcmc algorithm for approximating the number of hypergraph independent sets ( equivalently , the number of satisfying assignments in a monotone cnf formula ) that succeeds whenever @xmath6 .",
    "bezakova et al .",
    "@xcite gave a deterministic algorithm that succeeds whenever @xmath7 and proved that when @xmath8 it is @xmath9-hard to approximate the number of hypergraph independent sets even within an exponential factor .",
    "more broadly , there is a rich literature on approximate counting problems . in a seminal work ,",
    "weitz @xcite gave an algorithm to approximately count in the hardcore model with parameter @xmath10 in graphs of degree at most @xmath2 whenever @xmath11 and in another seminal work , sly @xcite showed a matching hardness result which was later improved in various respects by sly and sun @xcite and galanis , stefankovic and vigoda @xcite .",
    "these results show that approximate counting is algorithmically possible if and only if there is spatial mixing .",
    "moreover , weitz s result can be thought of as a comparison theorem that spatial mixing holds on a bounded degree graph if and only if it holds on an infinite tree with the same degree bound .",
    "there have been a number of attempts to generalize these results to hypergraphs , many of which follow the approach of defining analogues of the self - avoiding walk trees used in weitz s algorithm @xcite .",
    "however what makes hypergraph versions of these problems more challenging is that spatial mixing fails , even on trees .",
    "and we can see that there are _ exponential _ gaps between the upper and lower bounds , since the algorithms above require @xmath1 to be linear in @xmath2 while the lower bounds only rule out @xmath12 .",
    "we can take another vantage point to study these problems .",
    "bounded degree cnf formulae are also one of the principal objects of study in the lovsz local lemma @xcite which is a celebrated result in combinatorics that guarantees when @xmath13 that @xmath0 has at least one satisfying assignment .",
    "the original proof of the lovsz local lemma was non - constructive and did not yield a polynomial time algorithm for finding such an assignment , even though it was guaranteed to exist .",
    "beck @xcite gave an algorithm followed by a parallel version due to alon @xcite that can find a satisfying assignment whenever @xmath14 .",
    "and in a celebrated recent result , moser and tardos @xcite gave an algorithm matching exactly the existential result .",
    "this was followed by a number of works giving constructive proofs of various other settings and generalizations of the lovsz local lemma @xcite .",
    "however these works leave open the following question :    under the conditions of the lovsz local lemma ( i.e. when @xmath1 is logarithmic in @xmath2 ) is it possible to approximately sample from the uniform distribution on satisfying assignments ?",
    "approximate counting and approximate sampling problems are well - known to be related .",
    "when the problem is self - reducible , they are in fact algorithmically equivalent @xcite .",
    "however in our setting the problem is not self - reducible because as we fix variables we could violate the assumption that @xmath1 is at least logarithmic in @xmath2 .",
    "it is natural to hope that under the conditions of the lovsz local lemma , that there is an algorithm for approximate sampling that matches the limits of the existential and now algorithmic results .",
    "however the hardness results of bezkova et al .",
    "@xcite imply that we need at least another factor of two , and that it is @xmath9-hard to approximately count when @xmath12 .",
    "in fact , there is another connection between the lovsz local lemma and approximate counting .",
    "scott and sokal @xcite showed that given the dependency graph of events in the local lemma , the best lower bound on the probability of an event guaranteed to exist by the lovsz local lemma ( i.e. the fraction of satisfying assignments ) is exactly the solution to some counting problem .",
    "harvey , srivastava and vondrk @xcite recently adapted techniques of weitz to complex polydisks and gave an algorithm for approximately computing this lower bound .",
    "this yields a lower bound on the fraction of satisfying assignments , however the actual number could be exponentially larger .",
    "our main result is an algorithm to approximately count the number of solutions when @xmath1 is at least logarithmic in @xmath2 . in what follows ,",
    "let @xmath15 , @xmath1 and @xmath2 be constants .",
    "we prove :    suppose @xmath0 is a cnf formula with at least @xmath1 variables per clause and at most @xmath2 clauses containing any one variable . for any @xmath16",
    "there is a deterministic polynomial time algorithm for approximating the number of satisfying assignments to @xmath0 within a multiplicative @xmath17 factor .",
    "moreover there is a randomized polynomial time algorithm to sample from a distribution that is @xmath18-close in total variation distance to the uniform distribution on satisfying assignments .",
    "this algorithm closes an exponential gap between the known upper @xcite and lower @xcite bounds .",
    "it also shows that under lovsz local lemma - like conditions not only is it possible to efficiently find a satisfying assignment , it is possible to find a random one .",
    "moreover our approach is a significant departure from earlier techniques based either on path coupling @xcite or adapting weitz s approach to non - binary models and hypergraphs @xcite .",
    "the results above appear in theorem  [ thm : nonmonotonecounting ] and theorem  [ thm : approximatesampling ] .",
    "our approach starts from a thought experiment about what we could do if we had access to a very powerful oracle that could answer questions about the marginal distributions of individual variables under the uniform distribution on satisfying assignments .",
    "we use this oracle and properties of the lovsz local lemma ( namely , bounds it gives on the marginal distribution of individual variables ) to construct a coupling between two random satisfying assignments so that both agree outside some logarithmic sized component . if we knew the distribution on what logarithmic sized component this coupling procedure produces , we could brute force and find the ratio of the number of satisfying assignments with @xmath19 to the number with @xmath20 to compute marginals at @xmath21",
    ". however the distribution of what component the coupling produces depends intimately on the powerful oracle we have assumed that we have access to .    instead",
    ", we abstract the coupling procedure as a random root - to - leaf path in a tree that represents the state of the coupling .",
    "we show that at the leaves of this tree , there is a way to fractionally charge assignments where @xmath19 against assignments where @xmath20 .",
    "crucially , doing so requires only brute - force search on a logarithmic sized component .",
    "finally , we show that there is a polynomial sized linear program to find a flow through the tree that produces an approximately valid way to fractionally charge assignments with @xmath19 against ones with @xmath20 , and that any such solution _ certifies _ the correct marginal distribution . from these steps",
    ", we have thus bootstrapped an oracle for answering queries about the marginal distribution .",
    "our main results then follow from utilizing this oracle . in settings where the problem is self - reducible @xcite",
    "it is well - known how to go from knowing the marginal to approximate counting and sampling . in our setting ,",
    "the problem is not self - reducible because setting variables could result in clauses becoming too small in which case @xmath1 would not be large enough as a function of @xmath2 .",
    "we are able to get around this by using the lovsz local lemma once more to find a safe ordering in which to set the variables .",
    "our algorithms have an interesting application in graphical models . directed graphical models are a rich language for describing distributions by the conditional relationships of their variables .",
    "however very little is known algorithmically about learning them or performing basic tasks such as inference @xcite . in most settings , these problems are computationally hard . however we can study an interesting class of directed graphical models which we call _ cause networks_. see figure  [ fig : causenetwork ] .",
    "hidden variables .",
    "a sample is generated by choosing each hidden variable to be @xmath22 independently with equal probability , and observing the truth values of each clause .",
    ", width=226 ]    in a cause network there is a collection of hidden variables @xmath23 that are chosen independently to be @xmath24 or @xmath25 with equal probability .",
    "there is a collection of @xmath4 observed variables each of which is either an or or an and of several variables or their negations .",
    "our goal is : given a random sample @xmath23 from the model where we observe the truth value of each of the @xmath4 clauses , to sample from the posterior distribution on the hidden variables .",
    "this generalizes graphical models such as the symptom - disease network where the hidden variables represent diseases that a patient may have , and the clauses represent observed symptoms .",
    "we will require the following regularity condition on our observations :    a collection of observations is regular if for every observed variable , the corresponding clause is adjacent to ( i.e. shares a variable with ) at most @xmath26 or clauses that are false and at most @xmath26 and clauses that are true .",
    "now , as an immediate corollary we have :    [ corr : inference ] given a cause network where each observed variable depends on at least @xmath1 hidden variables , each hidden variable affects at most @xmath2 observed variables and @xmath27 , there is a polynomial time algorithm for sampling from the posterior distribution for any regular collection of observations .",
    "this is a rare setting where there is an algorithm to solve an inference problem in graphical models but @xmath28 the underlying graph does not have bounded treewidth and @xmath29 correlation decay fails .",
    "we believe that our techniques may eventually be applicable to settings where the observed variables are noisy functions of the hidden variables and where the hidden variables are not distributed uniformly .",
    "in this paper , we will be interested in approximately counting the number of satisfying assignments to a cnf formula .",
    "for example , we could be given : @xmath30 let s fix some parameters .",
    "we will assume that there are @xmath3 variables and there are @xmath4 clauses each of which is an or of at least @xmath1 distinct variables .",
    "finally , we will require a degree bound that each variable appears in at most @xmath2 clauses .",
    "we will be interested in the relationships between @xmath1 and @xmath2 that allow us to approximately count the number of satisfying assignments in polynomial time .",
    "the celebrated lovsz local lemma tells us conditions on @xmath1 and @xmath2 where we are guaranteed that there is at least one satisfying assignment :    @xcite if @xmath31 then @xmath0 has at least one satisfying assignment .",
    "moser and tardos @xcite gave an algorithm to find a satisfying assignment under these same conditions .",
    "however the assignment that their randomized algorithm finds is not uniform from the set of all satisfying assignments .",
    "our goal is to solve to be able to both approximately count and uniformly sample when @xmath1 is logarithmic in @xmath2 .",
    "there are many more related results , but we will not review them all here .",
    "instead we state a version of the asymmetric local lemma given in @xcite which gives us some control on the uniform distribution on assignments .",
    "let @xmath32 be the collection of clauses in @xmath0 .",
    "let @xmath33 $ ] denote the uniform distribution all assignments  i.e. uniform on @xmath34 . finally , for a clause @xmath35 let @xmath36 denote all the clauses that intersect @xmath35 .",
    "we can abuse notation and for any event @xmath37 that depends on some set of the variables , let @xmath38 denote all the clauses that contain any of the variables on which @xmath37 depends .",
    "[ thm : distributionlll ] suppose there is an assignment @xmath39 such that for all @xmath40 we have @xmath41 \\leq x(c ) \\prod_{b \\in \\gamma(c ) } \\big ( 1 - x(b ) \\big ) \\ ] ] then there is at least one satisfying assignment .",
    "moreover the uniform distribution @xmath42 on satisfying assignments satisfies that for any event @xmath37",
    "@xmath43 \\leq \\mbox{pr}[a ] \\prod_{b \\in \\gamma(a ) } \\big ( 1 - x(b ) \\big ) ^{-1}\\ ] ]    notice that this inequality is one - sided , as it ought to be .",
    "after all if we take @xmath35 to be some clause , and @xmath37 to be the event that @xmath35 is not satisfied then we know that @xmath44 = 0 $ ] even though @xmath45 $ ] is nonzero .",
    "however what this theorem does tell us is that the marginal distribution of @xmath42 on any variable is close to uniform .",
    "we will establish a quantitative version of this statement in the following corollary :    [ corr : uniform ] suppose that @xmath46 .",
    "then for every variable @xmath47 , we have @xmath48 \\leq \\frac{1}{2 } + \\frac{2}{d^5}\\ ] ]    set @xmath49 for each clause @xmath15 , and consider the event @xmath37 that @xmath50 . now invoking theorem  [ thm : distributionlll ] we calculate : @xmath51 & \\leq & \\mbox{pr}[x_i = t ]   \\prod_{b \\in \\gamma(a ) } \\big ( 1 - x(b ) \\big ) ^{-1 } \\\\ & \\leq & \\big ( \\frac{1}{2 } \\big ) \\big ( 1 - \\frac{1}{d^6 } \\big ) ^{-1 } \\leq \\frac{1}{2 } + \\frac{2}{d^5}\\end{aligned}\\ ] ] where the last inequality follows because @xmath52 .",
    "an identical calculation works for the event @xmath53 .",
    "all that remains is to check that the condition in theorem  [ thm : distributionlll ] holds , which is a standard calculation : if @xmath15 is a clause then @xmath41 \\leq \\big ( \\frac{1}{d^6 } \\big ) \\big ( 1 - \\frac{1}{d^6 } \\big ) ^d\\ ] ] the left hand side is at most @xmath54 because each clause has at least @xmath1 distinct variables , and the right hand side is at least @xmath55 .",
    "rearranging completes the proof .",
    "notice that @xmath1 is still only logarithmic in @xmath2 but with a larger constant , and by increasing this constant we get some useful facts about the marginals of the uniform distribution on satisfying assignments .",
    "now we are almost ready to define a coupling procedure .",
    "the basic strategy that we will employ is to start from either @xmath19 and @xmath20 , and then sample from the corresponding marginal distribution on satisfying assignments .",
    "if we sample a variable @xmath56 next , then corollary  [ corr : uniform ] tells us that regardless of whether @xmath19 or @xmath20 , each clause has at least @xmath57 variables remaining and so the marginal distribution on @xmath56 is still close to uniform .    thus we will try to couple the conditional distributions , when starting from @xmath19 or @xmath20 as well as we can , to show that the marginal distribution on variables that are all at least some distance @xmath58 away must converge in total variation distance .",
    "there is , however , an important catch that motivates the need for a fix .",
    "imagine that we continue in this fashion , sampling variables from the appropriate conditional distribution .",
    "we can reach a situation where a clause @xmath15 has all of its variables except @xmath56 set and yet the clause is still unsatisfied .",
    "the marginal distribution on @xmath56 is no longer close to uniform .",
    "hence , reaching small clauses is problematic because then we can not say much about the marginal distribution on the remaining variables and it would be difficult to construct a good coupling .    instead , our strategy is to use the lovsz local lemma once more , but to decide on a set of variables in advance which we call _",
    "marked_.    [ lemma : marked ] set @xmath59 .",
    "suppose that @xmath60 .",
    "then there is an assignment @xmath61 such that for every clause @xmath15 , it has at least @xmath62 marked and at least @xmath62 unmarked variables",
    ".    we will choose each variable to be marked or unmarked with equal probability , and independently .",
    "consider the @xmath4 bad events , one for each clause @xmath15 , that @xmath15 does not have enough marked or enough unmarked variables .",
    "then we have @xmath63 \\leq 2 e^{-(\\frac{1}{2})(\\frac{1}{6})^2 k } = 2 c_0^{-k}\\ ] ] which follows from the chernoff bound .",
    "now we can appeal to the lovsz local lemma to get the desired conclusion .",
    "only the variables that are marked will be allowed to be set to either @xmath24 or @xmath25 by the coupling procedure .",
    "the above lemma guarantees that every clause @xmath15 always has enough remaining variables that can make it true that the marginal distribution on any marked variable always is close to uniform .      now fix a variable @xmath21 .",
    "we will build up two partial assignments , and will use the notation @xmath64 to indicate that the first partial assignment sets @xmath21 to @xmath24 , and the second one sets @xmath21 to @xmath25 . furthermore we will refer to the conditional distribution that is uniform on all satisfying assignments consistent with the decisions made so far in @xmath65 and @xmath66 . similarly we will refer to the other conditional distribution as @xmath67 . note that these distributions are updated as more variables are set .",
    "we can now state our goal .",
    "suppose we have partial assignments @xmath65 and @xmath68 .",
    "then we will want to write @xmath69 where @xmath70 is the subformula we get after making the assignments in @xmath65 and simplifying  i.e. removing variables that are @xmath25 , and deleting clauses that already have a variable set to @xmath24 .",
    "similarly we will want to write @xmath71 finally , we want the following conditions to be met :    1 .",
    "@xmath72 2 .",
    "@xmath73 and @xmath74 share no variables , and similarly for @xmath75 and @xmath74    the crucial point is that if we can find partial assignments @xmath65 and @xmath68 where @xmath70 and @xmath76 meet the above conditions , then the conditional distribution on all variables in @xmath74 is exactly the same .",
    "we will use the notation @xmath77 to denote the conditional distribution of @xmath66 projected onto just the variables in @xmath74 .",
    "then we have :    if the above factorization conditions are met , then @xmath78    from the assumption that @xmath79 and because @xmath73 and @xmath74 share no variables , it means that there are no clauses that contain variables from both the subformulas @xmath73 and @xmath74 .",
    "any such clause would prevent us from writing the formula @xmath70 in such a factorized form .",
    "thus the distribution @xmath66 is simply the cross product of the uniform distributions on satisfying assignments to @xmath73 and @xmath74 .",
    "an identical statement holds for @xmath66 which completes the proof .",
    "note that meeting the factorization conditions does _ not _ mean that the _ number _ of satisfying assignments to @xmath70 and @xmath76 are the same .",
    "our goal in this subsection is to give a coupling procedure to generate partial assignments @xmath65 and @xmath68 starting from @xmath19 and @xmath20 respectively , that result in a factorized formula .",
    "in fact , we will set exactly the same set @xmath80 of variables in both , although not all variables will be set to the same value in the two partial assignments and this set @xmath80 will also be random .",
    "there are two important constraints that we will impose on how we construct the partial assignments , that will make it somewhat more tricky .",
    "first , suppose we have only set the variable @xmath21 and next we choose to set the variable @xmath56 in both @xmath65 and @xmath68 .",
    "we will want that the distribution on how we set @xmath56 in the coupling procedure in @xmath65 to match the conditional distribution @xmath66 and similarly for @xmath68 .",
    "now suppose we terminate with some set @xmath80 having been set",
    ". we can continue sampling the variables in @xmath81 from @xmath66 , and we are now guaranteed that the full assignment we generate is uniform from the set of assignments with @xmath19 .",
    "an identical statement holds when starting with @xmath20 .",
    "second , we will want that with very high probability , the coupling procedure terminates with not too many variables in the formula @xmath73 or @xmath75 .",
    "finally , we will assume that we are given access to a powerful oracle :    we will call the following a _ conditional distribution _ oracle : given a cnf formula @xmath0 , a partial assignment @xmath82 and a variable @xmath56 it can answer with the probability that @xmath83 in a uniformly random satisfying assignment that is also consistent with @xmath82    such an oracle is obviously very powerful , and it is well known that if we had access to it we could compute the number of satisfying assignments to @xmath0 exactly with a polynomial number of queries .",
    "however one should think of the coupling procedure as a though experiment , which will be useful in an indirect way to build up towards our algorithm for approximate counting .    1 .",
    "using lemma  [ lemma : marked ] , label variables as marked or unmarked 2 .",
    "initialize @xmath84 and @xmath85 3 .",
    "initialize @xmath86 and @xmath87 4 .   while there is a clause @xmath15 with variables in both @xmath88 and @xmath89 5 .",
    "@xmath90 sequentially sample its marked variables ( if any ) from @xmath66 and @xmath67 , using @xmath25 to construct best coupling 6 .",
    "@xmath90 case # 1 : @xmath15 is satisfied by variables already set in both @xmath65 and @xmath68 7 .",
    "@xmath90 @xmath90 let @xmath80 be the variables in @xmath15 that have different truth values in @xmath65 and @xmath68 .",
    "@xmath90 @xmath90 update @xmath91 , @xmath92 9 .",
    "@xmath90 @xmath90 delete @xmath15 10 .",
    "@xmath90 case # 2 : @xmath15 is not satisfied by variables already set in either @xmath65 or @xmath68 11 .",
    "@xmath90 @xmath90 let @xmath80 be all variables in @xmath15 ( marked or unmarked ) 12 .",
    "@xmath90 @xmath90 update @xmath91 , @xmath92 13 .",
    "end    notice that a clause @xmath15 can only trigger the while loop at most once .",
    "if it ends up in case # 1 then it is deleted from the formula .",
    "if it ends up in case # 2 then all its variables are included in @xmath88 and once a variable is included in @xmath88 it is never removed .",
    "thus the procedure clearly terminates .",
    "our first step is to show that when it does , the formula factorizes .",
    "let @xmath93 be the set of remaining clauses which have all of their variables in @xmath88 .",
    "similarly let @xmath94 be the set of remaining clauses which have all of their variables in @xmath89 . then set @xmath95 and let @xmath73 and @xmath75 be the simplification of @xmath96 with respect to the partial assignments @xmath65 and @xmath68 .",
    "similarly set @xmath97 and let @xmath98 and @xmath99 be the simplification of @xmath100 with respect to the partial assignments @xmath65 and @xmath68 .    [",
    "claim : vi ] all variables with different truth assignments in @xmath65 and @xmath68 are in @xmath88 .",
    "a variable is set in response to it being contained in some clause @xmath15 that triggers the while loop .",
    "any such variable is moved into @xmath88 in both case # 1 and case # 2 .",
    "now we have an immediate corollary that helps us towards proving that we have found partial assignments for which @xmath0 factorizes :    @xmath101    recall that @xmath98 and @xmath99 come from simplifying @xmath100 ( which contains only variables in @xmath89 ) according to @xmath65 and @xmath68 . from claim  [ claim : vi ] , we know that @xmath65 and @xmath68 are the same restricted to @xmath89 and thus we get the same formula in both cases .",
    "now that we know they are equal , we can define @xmath102 .",
    "what remains is to show that the subformulas we have are actually factorizations of the original formula @xmath0 :    [ lemma : isfactored ] @xmath79 and @xmath103    when the while loop terminates , every clause @xmath15 in the original formula @xmath0 either has all of its variables in @xmath88 or in @xmath89 , or was deleted because it already contains at least one variable in both @xmath65 and @xmath68 that satisfies it ( although it need not be the same variable ) .",
    "hence every clause in @xmath0 that is not already satisfied in both @xmath65 and @xmath68 shows up in @xmath104 .",
    "some clauses that are already satisfied in both may show up as well . in any case , this completes the proof because the remaining operation just simplifies the formulas according to the partial assignments .",
    "what remains is to bound the probability that the number of variables included in @xmath88 is at most @xmath105 .",
    "first we need an elementary definition :    when a variable @xmath47 is given different truth assignments in @xmath65 and @xmath68 , we call it a _ type @xmath106 _ error .",
    "when a clause @xmath15 has all of its marked variables set in both @xmath65 and @xmath68 , but in at least one of them is not yet satisfied , we call it a _ type @xmath107 _ error .    note that it is possible for a variable to participate in both a type @xmath106 and type @xmath107 error . in any case , these are the _ only _ reasons that a variable is included in @xmath88 in an execution of the coupling procedure :    [ obs : errors ] all variables in @xmath88 are included either due to a type @xmath106 error or a type @xmath107 error , or both",
    ".    now our approach to showing that @xmath88 contains not too many variables with high probability is to show that if it did , there would be a large collection of disjoint errors .",
    "first we construct a useful graph underlying the process :    let @xmath108 be the graph on vertices @xmath88 where we connect variables if and only if they appear in the same clause together ( _ any _ clause from the original formula @xmath0 ) .",
    "the crucial property is that it is connected :    @xmath108 is connected    this property holds by induction .",
    "assume that at the start of the while loop , the property holds .",
    "then at the end of the loop , any variable @xmath47 added to @xmath88 must have been contained in a clause @xmath15 that at the outset had one of its variables in @xmath88 .",
    "this completes the proof .",
    "now by observation  [ obs : errors ] , for every variable in @xmath88 we can blame it on either a type @xmath106 or a type @xmath107 error . both of these types of errors are unlikely .",
    "but for each variable , charging it to an error is problematic because of overlaps in the events . in particular , suppose we have two variables @xmath47 and @xmath109 that are both included in @xmath88 .",
    "it could be that both variables are in the same clause @xmath15 which resulted in a type @xmath107 error , in which case we could only charge one of the variables to it .",
    "this turns out not to be a major issue .",
    "the more challenging type of overlap is when two clauses @xmath15 and @xmath110 both experience type @xmath107 errors and overlap . in isolation",
    ", each clause would be unlikely to experience a type @xmath107 error .",
    "but it could be that @xmath15 and @xmath110 share all but one of their marked variables , in which case once we know that @xmath15 experiences a type @xmath107 error , then @xmath110 has a reasonable chance of experiencing one as well .",
    "we will get around this issue by building what we call a @xmath111-tree .",
    "this approach is inspired by noga alon s parallel algorithmic local lemma @xcite where he uses a @xmath112-tree .",
    "we call a graph @xmath24 on subset of @xmath88 a @xmath111-tree if each vertex is distance at least @xmath111 from all the others , and when we add edges between vertices at distance exactly @xmath111 the tree is connected .    next",
    "we show that @xmath108 contains a large @xmath111-tree :    [ lemma:3tree ] any maximal @xmath111-tree contains at least @xmath113 vertices .",
    "consider a maximal @xmath111-tree @xmath24 .",
    "we claim that every vertex @xmath114 must be distance at most @xmath107 from some @xmath109 in @xmath24 .",
    "if not , then we could take the shortest path from @xmath47 to @xmath24 and move along it , and at some point we would encounter a vertex that is also not in @xmath24 whose distance from @xmath24 is exactly @xmath111 , at which point we could add it , contradicting @xmath24 s maximality .",
    "now for every @xmath47 in @xmath24 , we remove from consideration at most @xmath115 other variables ( all those at distance at most @xmath107 from @xmath47 in @xmath108 ) .",
    "this completes the proof .",
    "now we can indeed charge every variable in @xmath24 to a disjoint error :    [ claim : disj ] if two variables @xmath47 and @xmath109 in @xmath24 are the result of type @xmath107 errors for @xmath15 and @xmath110 , then @xmath116    for the sake of contradiction , suppose that @xmath117 .",
    "then since @xmath15 and @xmath110 experience type @xmath107 errors , all of their variables are included in @xmath88 .",
    "this gives a length @xmath107 path from @xmath47 to @xmath109 in @xmath108 , which if they were both included in @xmath24 , would contradict the assumption that @xmath24 is a @xmath111-tree .",
    "we are now ready to prove the main theorem of this section :    [ thm : couplingterminates ] suppose that @xmath118",
    ". then @xmath119 \\leq \\big ( \\frac{3}{d } \\big ) ^t\\ ] ]    suppose that @xmath120 .",
    "then by lemma  [ lemma:3tree ] we can find a @xmath111-tree @xmath24 with at least @xmath105 vertices .",
    "the probability of any particular @xmath111-tree on @xmath105 vertices can be bounded by : @xmath121 this is because by observation  [ obs : errors ] each vertex is caused by either a type @xmath106 or type @xmath107 error ( or both ) .",
    "moreover by claim  [ claim : disj ] the clauses that cause the type @xmath107 errors for each vertex in @xmath24 are disjoint . now the first term in the expression above is the probability of a type @xmath106 error , which follows from corollary  [ corr : uniform ] .",
    "the second term follows from the fact that each variable is contained in at most @xmath2 clauses each of which could cause a type @xmath107 error , from lemma  [ lemma : marked ] which implies that each clause has at least @xmath122 marked variables , and again from corollary  [ corr : uniform ] which implies that for any variable @xmath47 , the minimum of the probability it is set to @xmath24 or to @xmath24 in _ either _ @xmath65 or @xmath68 is conservatively at least @xmath123 ( because we chose the best coupling ) .",
    "now it is well - known ( see @xcite ) that the number of trees of size @xmath105 in a graph of degree at most @xmath124 is at most @xmath125 .",
    "moreover if we connect pairs of vertices in @xmath108 that are distance exactly @xmath111 from each other , then we get a new graph @xmath126 whose maximum degree is at most @xmath127 . thus putting it all together we have that the probability that @xmath128 can be bounded by @xmath129 where the last inequality follows from the constraint @xmath118 .",
    "thus we can conclude that with high probability , the number of variables in @xmath88 is at most logarithmic .",
    "we can now brute - force search over all assignments to count the number of satisfying assignments to either @xmath73 or @xmath75 .",
    "the trouble is that we do not have access to the marginal probabilities , so we can not actually execute the coupling procedure .",
    "we will need to circumvent this issue next .",
    "in this section , we give an abstraction that allows us to think about the coupling procedure as a randomly chosen root - to - leaf path in a certain tree whose nodes represent states . first , we make an elementary observation that will be useful in discussing how this tree is constructed .",
    "recall that the coupling procedure chooses _ any _ clause that contains variables in both @xmath88 and @xmath89 and then samples _ all _ marked variables in it .",
    "we will assume without loss of generality that the choices it makes are done in lexicographic order .",
    "so if the clauses in @xmath0 are ordered arbitrarily as @xmath130 and the variables are ordered as @xmath131 when executing the while loop , if it has a choice of more than one clause it chooses among them the clause @xmath132 with the lowest subscript @xmath133 .",
    "similarly , given a choice of which marked variable to sample next , it chooses among them the @xmath109 with the lowest subscript @xmath134 .",
    "the important point is that now we can think of a state associated with the coupling procedure , which we will denote by @xmath135 .",
    "[ def : states ] the state @xmath135 of the coupling procedure specifies the following :    1 .",
    "the set of remaining clauses @xmath136  i.e. that have not yet been deleted 2 .   the partition of the variables into @xmath88 and @xmath89 3",
    ".   the set @xmath80 of variables whose values have been set , along with their values in both @xmath65 and @xmath68 4 .   the current clause @xmath137 being operated on in the while loop , if any    we will assume that the set @xmath138 of marked variables is fixed once and for all .",
    "now the transition rules are that if @xmath137 has any marked variables that are unset , it chooses the lexicographically first and sets it . and when @xmath137 has no remaining marked variables to set , it updates @xmath136 , @xmath88 and @xmath89 according to whether it falls into case # 1 or case # 2 and sets the current clause to empty .",
    "finally , if the current clause is empty then it chooses the lexicographically first clause from @xmath136 which has at least one variable in each of @xmath88 and @xmath89 to be @xmath137 .",
    "finally , we can define the next variable operation :    [ def : nextset ] let @xmath139 be the function that takes in a state @xmath135 , transitions to the next state @xmath140 that sets some variable @xmath56 and outputs @xmath141 .",
    "note that some states @xmath135 do not immediately set a variable ",
    "e.g. if the next operation is to choose the next clause , or update @xmath136 , @xmath88 and @xmath89 .",
    "these latter transitions are deterministic , so we let @xmath140 be the end resulting state and @xmath56 be the variable that it sets .",
    "now we can define the stochastic decision tree underlying the coupling procedure :    [ def : twosided ] given a conditional distribution oracle @xmath25 , the function @xmath142 and a stopping threshold @xmath143 , the associated _ stochastic decision tree _ is the following :    1 .",
    "the root node corresponds to the state where only @xmath21 is set , @xmath84 , @xmath85 , @xmath86 and @xmath87 .",
    "each node has either zero or four descendants .",
    "if the current node corresponds to state @xmath135 , let @xmath144 . then if @xmath145 or if @xmath146 there are no descendants and the current node is a leaf corresponding to the termination of the coupling procedure or @xmath147 being to large .",
    "otherwise the four descendants correspond to the four choices for how to set @xmath56 in @xmath65 and @xmath68 , and are marked with the state @xmath148 which incorporates their respective choices into @xmath140 .",
    "3 .   moreover the probability on an edge from a state @xmath140 to a state @xmath148 where @xmath56 has been set as @xmath149 and @xmath150 is equal to @xmath151 and the transition to the state where @xmath152 and @xmath153 has probability @xmath154 finally if @xmath155 then the transition to @xmath149 and @xmath153 is non - zero and is assigned all the remaining probability .",
    "otherwise the transition to @xmath152 and @xmath150 is non - zero and is assigned all the remaining probability .",
    "now we can use the stochastic decision tree to give an alternative procedure to sample a uniformly random satisfying assignment of @xmath0 .",
    "we will refer to the process of starting from the root , and choosing a descendant with the corresponding transition probability , until a leaf node is reached as  choosing a random root - to - leaf path \" .    1 .",
    "choose a random root - to - leaf path in @xmath80 2 .",
    "choose a uniformly random assignment @xmath156 consistent with @xmath65 3 .",
    "choose a uniformly random assignment @xmath157 consistent with @xmath68 4 .",
    "output @xmath156 with probability @xmath158 $ ] , and otherwise output @xmath157    [ lemma : altgen ] the decision tree sampling procedure outputs a uniformly random satisfying assignment of @xmath0 .",
    "we could alternatively think of the decision tree sampling procedure as deciding on @xmath156 or @xmath157 with probability @xmath159 vs. @xmath160 at the outset . then if we choose @xmath156 , and we only keep track of the choices made for @xmath65 , marginally these correspond to sequentially sampling the assignment of variables from @xmath66 . and",
    "when we reach a leaf node in @xmath80 we can interpret the remaining choices to @xmath156 as sampling all unset variables from @xmath66 .",
    "thus the output in this case is a uniformly random satisfying assignment with @xmath19 .",
    "an identical statement holds for when we choose @xmath157 , and because we decided between them at the outset with the correct probability , this completes the proof of the claim .",
    "now let @xmath135 be the state of a leaf node @xmath161 and let @xmath65 and @xmath68 be the resulting partial assignments .",
    "let @xmath162 be the product of certain probabilities along the root - to - leaf path .",
    "in particular , suppose along the path there is a transition with @xmath56 being set .",
    "let @xmath163 be the probability of the transition to @xmath164 ",
    "i.e. along the branch that it actually went down . and",
    "let @xmath165 be the probability of the transition to @xmath166 ",
    "i.e. where @xmath56 is set the same in @xmath65 but is set to the opposite value as it was in @xmath68 .",
    "we let @xmath162 be the product of all @xmath167 over all such decision on the root - to - leaf path .",
    "[ lemma : paths ] let @xmath168 be an assignment that agrees with @xmath65 .",
    "then for the decision tree sampling procedure @xmath169 = p_1\\ ] ]    the idea behind this proof is to think of the random choice of which of the four descendants to transition to as being broken down into two separate random choices where we first choose @xmath170 and then we choose @xmath171 .",
    "see figure  [ fig : releveling ] .",
    "now we can make the random choices in the decision tree sampling procedure in an entirely different order . instead of choosing the transition in the first layer , then the second layer and so on , we instead make _ all _ of the choices in the odd layers .",
    "moreover at each leaf , we choose which assignment consistent with @xmath65 we would output .",
    "this is the first phase .",
    "next we choose whether to output the assignment consistent with @xmath65 or with @xmath68 . finally ,",
    "we make all the choices in the even layers which fixes the root - to - leaf path and then we choose an assignment consistent with @xmath68 .",
    "this is the second phase .",
    "the key point is that once the output @xmath168 is fixed , all of the choices in the first phase are determined , because every time a variable @xmath56 is set it must agree with its setting in @xmath168 .",
    "moreover each leaf node must choose @xmath168 for its assignment consistent with @xmath65 . and",
    "finally , we know that the sampling procedure must output the assignment consistent with @xmath65 because @xmath168 agrees with @xmath65 and not @xmath68 ( because they differ on how they set @xmath21 ) . thus conditioned on outputting @xmath168 the only random choices left are those in the second phase . now the lemma follows because the probability of reaching leaf node @xmath161 is exactly the probability along the path of all of the even layer choices , which is how we defined @xmath162 .     that is output by decision tree sampling .",
    ", width=453 ]    we can define @xmath172 in an analogous way to how we defined @xmath162 ( i.e. as the product of certain probabilities along the root - to - leaf path ) , and the lemma above shows that @xmath172 is exactly the probability of all the decisions made along the root - to - leaf path conditioned on the output being @xmath168 where @xmath168 agrees with @xmath68 .",
    "the key lemma is the following :    [ lemma : balance ] let @xmath173 be the number of satisfying assignments consistent with @xmath65 and let @xmath174 be the number of satisfying assignments consistent with @xmath68 .",
    "then @xmath175    let @xmath161 be a leaf node .",
    "consider a random variable @xmath176 that when we run the decision tree sampling procedure is non - zero if and only if we end at @xmath161 .",
    "moreover let @xmath177 if an assignment with @xmath19 is output , and @xmath178 if an assignment with @xmath20 is output .",
    "then clearly @xmath179 = 0 $ ] .",
    "now alternatively we can write : @xmath180 = { \\mathop{\\bf e\\/}}_a [ { \\mathop{\\bf e\\/}}[z_u | a \\mbox { is output}]]\\ ] ] where @xmath168 is a uniformly random satisfying assignment of @xmath0 , precisely because of lemma  [ lemma : altgen ] .",
    "let @xmath181 be the total number of such assignments",
    ". then @xmath182 = \\big ( \\frac{n_1}{n } \\big ) ( p_1 ) ( 1-q ) + \\big ( \\frac{n_2}{n } \\big ) ( p_2 ) ( -q)\\ ] ] this follows because the only assignments @xmath168 that can be output at @xmath161 must be consistent with either @xmath65 or @xmath68 .",
    "note that these are disjoint events because in one of them @xmath19 while in the other @xmath20 .",
    "then once we know that @xmath168 is consistent with @xmath65 ( which happens with probability @xmath183 ) the probability for the decisions made in @xmath68 being such that we reach @xmath161 is exactly @xmath162 , as this was how it was defined .",
    "the final term in the product of three terms is just the value of @xmath176 .",
    "an identical argument justifies the second term . now using the fact that the above expression evaluates to zero and rearranging completes the proof .",
    "the stochastic decision tree that we defined in the previous section is a natural representation of the trajectory of the coupling procedure .",
    "however it has an important drawback that we will remedy here .",
    "its crucial property is captured in lemma  [ lemma : balance ] which gives a relation between    1 .",
    "@xmath184  the conditional probability of an assignment consistent with @xmath185 reaching @xmath161 and 2 .",
    "@xmath186  the number of assignments consistent with @xmath185    for @xmath187 .",
    "however @xmath162 is the product of various ratios of probabilities along the root - to - leaf path .",
    "this means that if we think of the transition probabilities as variables , the constraint imposed by lemma  [ lemma : balance ] is far from linear and @xmath172 is a multiplication by one of two ratios of probabilities , _ which have different denominators_. for reasons that we will not digress into , this makes it challenging to encode the total probability @xmath162 as a flow in a tree . ] .    in this section",
    ", we will transform a stochastic decision tree into two separate trees , that we call _ one - sided stochastic decision trees_. these will have the property that the constraint imposed by lemma  [ lemma : balance ] will be linear in the unknown probabilities that we think of as variables . ultimately we will show that any such pair can @xmath188 certify that a given value @xmath159 is within an additive inverse polynomial factor of @xmath189 $ ] and @xmath190 can be constructed in polynomial time through linear programming .",
    "first we explain the transformation from a stochastic decision tree to a one - sided stochastic decision tree .",
    "we will then formally define its properties and what we require of it .",
    "now suppose we are given a stochastic decision tree @xmath80 .",
    "let s construct the one - sided stochastic decision tree @xmath191 that represents the trajectory of the partial assignment @xmath65 .",
    "when we start from the starting state @xmath135 ( see definition  [ def : states ] ) , the four descendants of it in @xmath80 will now be four grand - children",
    ". it s immediate descendants will be two nodes @xmath161 and @xmath192 , one representing the choice @xmath149 and one representing @xmath152 , where @xmath56 is the next variable set ( see definition  [ def : nextset ] ) .",
    "the two children of @xmath135 in @xmath80 that correspond to @xmath149 will now be the children of @xmath161 and the other two children will now be the children of @xmath192",
    ". we will continue in this way so that alternate layers represent nodes present in @xmath80 and new nodes .",
    "this alone does not change much the semantics of the trajectory .",
    "all we are doing is breaking up the decision of which of the four children to proceed to , into two separate decisions .",
    "the first decision is based on just @xmath65 and the second is based on @xmath68 .",
    "however we will change the semantics of what probabilities we associate with different transitions . for starters , we will work with total probabilities .",
    "so the total probability incoming into the starting node is @xmath106 .",
    "let s see how this works inductively .",
    "let s now suppose that @xmath135 represents the state of some node in @xmath80 ( not necessarily the starting state ) and @xmath161 and @xmath192 are its descendants in @xmath191",
    ". then if the total probability into @xmath135 in @xmath191 is @xmath193 , we place @xmath193 along both the edges to @xmath161 and to @xmath192 .",
    "this is because the decision tree is now from the perspective of @xmath65 , who perhaps has already chosen his assignment uniformly at random from those with @xmath19 but has not set all of those values in @xmath65 .",
    "hence his decision is not a random variable , since given the option of transition to @xmath161 or @xmath192 he must go to whichever one is consistent with his hidden values .",
    "however from this perspective , the choices corresponding to @xmath68 are random because he has no knowledge of the assignment that the other player is working with .",
    "if we have @xmath193 total probability coming into @xmath161 , then the total probability into its two descendants will be @xmath194 and @xmath195 respectively , where @xmath163 and @xmath165 were the probabilities on the transitions in @xmath80 into the two corresponding descendants .",
    "in particular , if @xmath163 is the probability of setting @xmath149 and @xmath150 and @xmath165 is the probability of setting @xmath149 and @xmath153 then @xmath194 is the total probability on the transition from @xmath161 to the descendant where @xmath150 and @xmath195 is the total probability on the transition from @xmath161 to the descendant where @xmath153 .",
    "note that from corollary  [ corr : uniform ] we have that @xmath196 this is an important property that we will make crucial use of later .",
    "notice that it is a linear constraint in the total probability .",
    "now we are ready to define a one - sided stochastic decision tree , which closely mirrors definition  [ def : twosided ] .",
    "[ def : onesided ] given the function @xmath142 and a stopping threshold @xmath143 , the associated _ one - sided stochastic decision tree _",
    "for @xmath65 is the following :    1 .",
    "the root node corresponds to the state where only @xmath21 is set , @xmath84 , @xmath85 , @xmath86 and @xmath87 .",
    "each node has either two descendants and four _ grand_-descendants or zero descendants .",
    "if the current node @xmath37 corresponds to state @xmath135 , let @xmath144 . then if @xmath145 or if @xmath146 there are no descendants and the current node is a leaf corresponding to the termination of the coupling procedure or @xmath147 being to large .",
    "otherwise the two descendants correspond to the two choices for how to set @xmath56 in @xmath65 .",
    "each of their two descendants correspond to the two choices for how to set @xmath56 in @xmath68 .",
    "each grand - descendant is marked with the state @xmath140 which incorporates their respective choices .",
    "let @xmath193 be the total probability into @xmath37 .",
    "then the total probability into each descendant is @xmath193 .",
    "moreover let the total probability into the grand - descendants with states @xmath149 and @xmath150 and @xmath149 and @xmath153 be @xmath197 and @xmath198 respectively .",
    "then @xmath197 and @xmath198 are nonnegative , sum to @xmath193 and satisfy @xmath199 .",
    "similarly , let the total probability into the grand - descendants with states @xmath152 and @xmath153 and @xmath152 and @xmath150 be @xmath200 and @xmath201 respectively .",
    "then @xmath200 and @xmath201 are nonnegative , sum to @xmath193 and satisfy @xmath202 .",
    "the one - sided stochastic decision tree for @xmath68 is defined analogously , in the obvious way .",
    "finally we record an elementary fact :    [ claim : match ] there is a perfect matching between the root - to - leaf paths in @xmath191 and @xmath203 , so that any pair of assignments @xmath156 and @xmath157 that takes a root - to - leaf path @xmath204 in @xmath191 , must also take the root - to - leaf path in @xmath203 to which @xmath204 is matched .",
    "recall that the odd levels in @xmath191 and @xmath203 correspond to the nodes in @xmath80 .",
    "therefore from a root - to - leaf path @xmath204 in @xmath191 we can construct the root - to - leaf path in @xmath80 , which in turn uniquely defines a root - to - leaf path in @xmath203 ( because it specifies which nodes are visited in odd layers , and all paths end on a node in an odd layer ) .",
    "we are now ready to prove one of the two main theorems of this section :    [ thm : constructive ] let @xmath158 $ ] and @xmath205 .",
    "then there are two one - sided stochastic decision trees @xmath191 and @xmath203 that for any pair of matched root - to - leaf paths terminating in @xmath161 and @xmath192 respectively satisfy @xmath206 where @xmath173 and @xmath174 are number of satisfying assignments consistent with @xmath65 and @xmath68 respectively , and @xmath162 and @xmath172 are the total probability into @xmath161 and @xmath192 respectively .",
    "moreover given @xmath207 and @xmath208 that satisfy @xmath205 there is an algorithm to construct two one - sided stochastic decision trees @xmath191 and @xmath203 that satisfy the above condition on all matched leaf nodes corresponding to a termination of the coupling procedure , which runs in time polynomial in @xmath4 and @xmath209 where @xmath143 is the stopping size .",
    "the first part of the theorem follows from the transformation we gave from a stochastic decision tree to two one - sided stochastic decision trees .",
    "then claim  [ claim : match ] combined with lemma  [ lemma : balance ] implies @xmath210 , which then necessarily satisfies @xmath211 .",
    "rearranging completes the proof of the first part .    to prove the second part of the theorem , notice that if @xmath143 is the stopping size , then the number of leaf nodes in @xmath191 and in @xmath203 is bounded by @xmath209",
    "at each leaf node that corresponds to a termination of the coupling procedure , from lemma  [ lemma : isfactored ] we can compute the ratio of @xmath173 to @xmath174 as the ratio of the number of satisfying assignments to @xmath73 to the number of satisfying assignments to @xmath75 .",
    "this can be done in polynomial in @xmath4 and @xmath212 time by brute - force . finally , the constraints in definition  [ def : onesided ] are all linear in the variables that represent total probability ( if we treat @xmath213 , @xmath214 , @xmath215 and all ratios @xmath216 as given constants ) .",
    "thus we can find a valid choice of the total probability variables by linear programming .",
    "this completes the proof of the second part .",
    "recall that we will be able to choose @xmath217 and theorem  [ thm : couplingterminates ] will imply that at most an inverse polynomial fraction of the distribution fails to couple .",
    "thus the algorithm above runs in polynomial time for any constants @xmath2 and @xmath1 .",
    "what remains is to show that any valid choice of total probabilities _ certifies _ that @xmath218 \\leq q''$ ] .",
    "we are now ready to prove the second main theorem of this section .",
    "we will show that having any two one - sided stochastic decision trees that meet the constraints on the leaves imposed by theorem  [ thm : constructive ] is enough to certify that @xmath189 $ ] is approximately between @xmath207 and @xmath208 .",
    "this result will rest on two facts .",
    "fix any assignment @xmath168",
    ". then either    1 .",
    "the assignment has too many clauses that restricted to marked variables are all @xmath25 or 2 .",
    "the total probability of @xmath168 reaching a leaf node @xmath161 where the coupling procedure failed to terminate before reaching size @xmath143 is at most @xmath219 .",
    "[ thm : certify ] suppose that @xmath118 . then any two one - sided stochastic decision trees @xmath191 and @xmath203 that meet the constraints on the leaves imposed by theorem  [ thm : constructive ] and satisfy @xmath220 imply that @xmath221 \\leq q '' + o\\big(\\frac{1}{n^c}\\big)\\ ] ]    the proof of this theorem will use many of the same tools that appeared in the proof of theorem  [ thm : couplingterminates ] , since in essence we are performing a one - sided charging argument .    the proof will proceed by constructing a complete bipartite graph @xmath222 and finding a fractional approximate matching as follows .",
    "the nodes in @xmath223 represent the satisfying assignments of @xmath0 with @xmath19 .",
    "the nodes in @xmath224 represent the satisfying assignments of @xmath0 with @xmath20 .",
    "moreover all but a @xmath219 fraction of the nodes on the left will send between @xmath225 and @xmath226 flow along their outgoing edges .",
    "finally all but a @xmath219 fraction of the nodes on the right will receive between @xmath227 and @xmath228 flow along their incoming edges .",
    "first notice that any assignment @xmath168 ( say with @xmath19 ) is mapped by @xmath191 to a distribution over leaf nodes , some of which correspond to a coupling and some of which correspond to a failure to couple before reaching size @xmath143 .",
    "now consider matched pairs of leaf nodes ( according to claim  [ claim : match ] ) that correspond to a coupling .",
    "let @xmath162 and @xmath172 be the total probability of the leaf nodes in @xmath191 and @xmath203 respectively .",
    "let @xmath173 and @xmath174 be the total number of assignments that are consistent with @xmath65 and @xmath68 , and let @xmath229 and @xmath230 be the corresponding sets of assignments . from the assumption that @xmath206 and the intermediate value theorem it follows that there is a @xmath231 which satisfies @xmath232 hence there is a flow that sends exactly @xmath233 units of flow out of each node in @xmath229 and which each node in @xmath230 receives exactly @xmath234 units of flow .",
    "if every leaf node corresponding to a coupling , we would indeed have the fractional matching we are looking for , just by summing these flows over all leaf nodes .",
    "what remains is to handle the leaf nodes that do not correspond to the coupling terminating before size @xmath143 .",
    "consider any such leaf node @xmath161 in @xmath191 and the corresponding leaf node @xmath235 in @xmath203 . from lemma  [ lemma:3tree ]",
    "we have that there is a @xmath111-tree @xmath24 of size at least @xmath236 . for each node in @xmath24 , from claim  [ claim : disj ] we have there are at least @xmath236 disjoint type @xmath106 or type @xmath107 errors .",
    "* case # 1 : * suppose that there are at least @xmath237 disjoint type @xmath106 errors .",
    "fix the @xmath111-tree @xmath24 , and look at all root - to - leaf paths that are consistent with just the type @xmath106 errors .",
    "then the sum of their total probabilities is at most @xmath238 this follows because the constraint that @xmath239 ( and similarly for @xmath201 ) in definition  [ def : onesided ] implies that for each path we can factor out the above term corresponding to just the decisions where there are type @xmath106 errors .",
    "the remaining probabilities are conditional distributions on the paths ( after having taken into account the type @xmath106 errors ) and sum to at most one .",
    "finally the total number of @xmath111-trees of size @xmath236 is at most @xmath240 .",
    "thus for any assignment @xmath168 , if we ignore what happens to it when it ends up at a leaf node which did not couple and which has at least @xmath237 disjoint type @xmath106 errors , in total we have ignored at most @xmath241 of its probability .",
    "* case # 2 : * suppose that there are at least @xmath237 disjoint type @xmath107 errors .",
    "each type @xmath107 error can be blamed on either @xmath65 or @xmath68 or both ( e.g. it could be that the clause @xmath15 might only have all of its marked variables set to @xmath25 in @xmath65 ) . let s suppose that the assignment @xmath168 contributes at least @xmath242 disjoint type @xmath107 errors . in this case we will completely ignore @xmath168 in the constraints imposed by our flow .",
    "how many such assignments can there be ?",
    "the probability of getting any such assignment is bounded by @xmath243 thus if we ignore the flow constraints for all such assignments , we will be ignoring at most a @xmath18 fraction of the nodes in @xmath223 and the nodes in @xmath224 . the only remaining case is when the assignment @xmath168 ends up at a leaf node @xmath161 that has at least @xmath237 disjoint type @xmath107 errors , but it contributes less than @xmath242 itself . for each type @xmath107 error that it does not contribute to , it contributes to another type @xmath106 error .",
    "the only minor complication is that the node responsible might not be in the @xmath111-tree @xmath24 .",
    "however it is distance at most @xmath106 from the @xmath111-tree because it is contained in a clause that results in type @xmath107 error that does contain a node in @xmath24 .",
    "now by an analogous reasoning as in case # 1 above , if we fix the pattern of these type @xmath106 errors ",
    "i.e. we fix the @xmath111-tree and the extra nodes at distance @xmath106 from it that contribute the missing type @xmath106 errors  the sum of the total probability of all consistent root - to - leaf paths is at most @xmath238 now the number of patterns can be bounded by @xmath244 , which accounts for the inclusion of extra nodes that are not in @xmath24 . once again , for such an assignment @xmath168 if we ignore what happens to it when it ends up at a leaf node which did not couple and which has at least @xmath237 disjoint type @xmath107 but it contributes less than @xmath242 itself , in total we have ignored at most @xmath241 of its probability .    now returning to the beginning of the proof and letting @xmath173 and @xmath174 be the total number of satisfying assignments with @xmath19 and @xmath20 respectively .",
    "we have that the flow in the bipartite graph implies @xmath245 and the further condition @xmath246 which gives @xmath247 which completes the proof of the theorem .",
    "here we show how to use our algorithm for computing marginal probabilities when @xmath1 is logarithmic in @xmath2 for approximate counting and sampling from the uniform distribution on satisfying assignments .",
    "first , we show how to use an algorithm for computing marginal probabilities to do approximate counting in a monotone cnf , where no variable is negated .",
    "this approach is standard , and appears in @xcite .",
    "[ corr : monotonecount ] suppose we are given a monotone cnf formula @xmath0 on @xmath3 variables with at least @xmath1 variables per clause and at most @xmath2 clauses containing any one variable with @xmath118 .",
    "let @xmath248 be the number of satisfying assignments .",
    "then there is an algorithm that outputs a quantity @xmath249 that satisfies @xmath250 and runs in time polynomial in @xmath4 and @xmath251 .",
    "first , we fix an ordering of the variables @xmath23 and a sequence of formulas @xmath252 .",
    "let @xmath253 and let @xmath254 be the subformula we get when substituting @xmath255 into @xmath0 and simplifying .",
    "notice that each such formula is a monotone cnf and inherits the properties we need from @xmath0 .",
    "in particular , each clause has at least @xmath1 variables because the only clauses left in @xmath256 ( i.e. not already satisfied ) are the ones which have all of their variables unset .",
    "also , each variable belongs to at most @xmath2 clauses because we have only removed variables and clauses .",
    "thus we can appeal to theorem  [ thm : constructive ] and theorem  [ thm : certify ] to compute for each variable @xmath47 the quantity @xmath257 $ ] to within an additive @xmath258 where @xmath259 is the uniform distribution on satisfying assignments to @xmath256 .",
    "let our estimate be @xmath260 .",
    "since @xmath261 we have that @xmath260 and @xmath184 are also multiplicatively close , with @xmath262 . now",
    "if we take the product of the @xmath184 s we get a telescoping product which computes the ratio of the number of satisfying assignments with all variables set to @xmath24 divided by the number of satisfying assignments to @xmath0 .",
    "moreover each @xmath261 .",
    "thus we conclude @xmath263 which completes the proof .",
    "the above approach heavily used monotonicity to ensure that no clause becomes too small ( i.e. contains few variables , but is still unsatisfied ) .",
    "this is a similarly issue to what happened with the coupling procedure , which necessitating using _ marked _ and _ unmarked _ variables , the latter being variables that are never set and are used to make sure no clause becomes too small .",
    "we can take a similar approach here . in what follows",
    "we will no longer assume @xmath0 is monotone .",
    "[ lemma : nonmonotonehelper ] set @xmath264 .",
    "suppose that @xmath265 .",
    "then there is a partial assignment @xmath82 so that every clause is satisfied and each clause has at least @xmath122 unset variables .",
    "moreover there is a randomized algorithm to find such a partial assignment that runs in time polynomial in @xmath4 , @xmath3 , @xmath1 and @xmath2 .",
    "alternatively there is a deterministic algorithm that runs in time polynomial in @xmath4 and @xmath266 .",
    "we will choose independent for each variable to set it to @xmath24 with probability @xmath267 , to set it to @xmath25 with probability @xmath267 and to leave it unset with probability @xmath268 .",
    "now consider the @xmath4 bad events , one for each clause @xmath15 , that @xmath15 is either unsatisfied or has not enough unset variables ( or both ) .",
    "then we have @xmath63 \\leq e^{-(\\frac{1}{2})(\\frac{1}{6})^2 k } + \\big ( \\frac{3}{4 } \\big ) ^k \\leq 2 c_0^{-k}\\ ] ] where the first term follows from the chernoff bound and represents the probability that there are not enough unset variables , and the second term is the probability that the clause is unsatisfied . once again we can appeal to the lovsz local lemma to show the existence . finally we can use the algorithm of moser and tardos @xcite to find such a partial assignment in randomized polynomial time .",
    "moreover moser and tardos @xcite also give a deterministic algorithm that runs in time polynomial in @xmath4 and @xmath266 .",
    "[ thm : nonmonotonecounting ] suppose we are given a cnf formula @xmath0 on @xmath3 variables with at least @xmath1 variables per clause and at most @xmath2 clauses containing any one variable with @xmath118 .",
    "let @xmath248 be the number of satisfying assignments .",
    "then there is a deterministic algorithm that outputs a quantity @xmath249 that satisfies @xmath250 and runs in time polynomial in @xmath4 and @xmath251 .",
    "our proof follows the same basic outline as in corollary  [ corr : monotonecount ] .",
    "first we ( deterministically ) find a partial assignment that meets lemma  [ lemma : nonmonotonehelper ] and let @xmath269 be an ordering of the set variables .",
    "we define @xmath270 in the same way as the subformula we get by substituting in the assignments for @xmath271 and simplifying to get @xmath256 .",
    "again let @xmath260 be our estimate for the marginal probabilities .",
    "the key point is that @xmath272 would be empty , because all clauses are satisfied .",
    "moreover each clause that appears in any formula @xmath256 for @xmath273 has at least @xmath122 variables because it has at least that many unset variables in the partial assignment .",
    "moreover we can now output @xmath274 because @xmath272 has exactly @xmath275 satisfying assignments ( every choice of the unset variables ) and we have used the same telescoping product , but now to compute the ratio of the number of satisfying assignments to @xmath272 divided by the number of satisfying assignments to @xmath0 .      here",
    "we give an algorithm to generate an assignment approximately uniformly from the set of all satisfying assignments .",
    "again , the complication is that our oracle for approximating the marginals works only if @xmath1 is at least logarithmic in @xmath2 so we need some care in the order we choose to sample variables .",
    "first we give the algorithm :    1 .",
    "using lemma  [ lemma : marked ] , label variables as marked or unmarked 2 .   while there is a marked variable @xmath21 that is unset 3 .",
    "@xmath90 sample @xmath21 using @xmath25 4 .",
    "@xmath90 initialize @xmath86 and @xmath89 to be all unset variables ( @xmath21 is already set ) 5 .",
    "@xmath90 while there is a clause @xmath15 with variables in both @xmath88 and @xmath89 6 .",
    "@xmath90 @xmath90 sequentially sample its marked variables ( if any ) using @xmath25 7 .",
    "@xmath90 @xmath90 case # 1 : @xmath15 is satisfied 8 .",
    "@xmath90 @xmath90 @xmath90 delete @xmath15 9 .",
    "@xmath90 @xmath90 case # 2 : @xmath15 is unsatisfied 10 .",
    "@xmath90 @xmath90 @xmath90 let @xmath80 be all variables in @xmath15 ( marked or unmarked ) 11 .",
    "@xmath90 @xmath90 @xmath90 update @xmath91 , @xmath92 12 .",
    "@xmath90 end 13 .",
    "end 14 . for each connected component of the remaining clauses 15 .",
    "@xmath90 enumerate and uniformly choose a satisfying assignment of the unset variables 16 .",
    "end      [ lemma : approxunif ] if the oracle @xmath25 outputs a marginal probability that is @xmath276 close to the true marginal distribution for each variable queried , then the output of the sampling procedure is a random assignment whose distribution is @xmath18-close in total variation distance to the uniform distribution on all satisfying assignments .",
    "the proof of this lemma is in two parts .",
    "first , imagine we were instead given access to an oracle @xmath108 that answered each query for a marginal distribution with the exact value .",
    "then each variable set using the oracle is chosen from the correct marginal distribution .",
    "and in the last step , the set of satisfying assignments is a cross - product of the satisfying assignments for each component .",
    "thus the procedure would output a uniformly random assignment from the set of all satisfying assignments .",
    "second , since at most @xmath3 variables are queried , we have that with probability at least @xmath277 all of the random decision of the procedure would be the same if we had given it answers from @xmath108 instead of from @xmath25 .",
    "this now completes the proof .",
    "[ thm : approximatesampling ] suppose we are given a cnf formula @xmath0 on @xmath3 variables with at least @xmath1 variables per clause and at most @xmath2 clauses containing any one variable with @xmath278 .",
    "there is an algorithm that outputs a random assignment whose distribution is @xmath18-close in total variation distance to the uniform distribution on all satisfying assignments .",
    "moreover the algorithm runs in time polynomial in @xmath4 and @xmath251 .",
    "the proof of this theorem uses many ideas from the coupling procedure as analyzed in section  [ sec : couple ] .",
    "let @xmath279 be the formula at the start of some iteration of the inner while loop .",
    "then at the end of the inner while loop , using lemma  [ lemma : isfactored ] we can write : @xmath280 where @xmath96 is a formula on the variables in @xmath88 and @xmath100 is a formula on the variables in @xmath89 .",
    "in particular , no clause has variables in both because the inner while loop terminated .",
    "now we can appeal to the analysis in theorem  [ thm : couplingterminates ] which gives a with high probability bound on the size of @xmath88 .",
    "the analysis presented in its proof is nominally for a different procedure , the coupling procedure , but the inner while loop of the sampling procedure is identical except for the fact that there are no type 1 errors because we are building up just one assignment .",
    "thus @xmath119 \\leq \\big ( \\frac{3}{d } \\big ) ^t\\ ] ] the inner while loop is run at most @xmath3 times and so if we choose @xmath281 we get that with probability at least @xmath282 no component has size larger than @xmath283 . now",
    "the brute force search in the last step can be implemented in time polynomial in @xmath4 and @xmath251 , which combined with lemma  [ lemma : approxunif ] completes the proof .",
    "recall , we are given a cause network and the truth assignment of each observed variable .",
    "first we do some preprocessing . if an observed variable is an or of several hidden variables or their negation , and the observed variable is set to @xmath25 we know the assignment of each hidden variable on which it depends .",
    "similarly , if an observed variable is an and and it is set to @xmath24 again we know the assignment of each of its variables . for all the remaining observed variables ,",
    "we know there is exactly one configuration of its variables that is prohibited so each yields a clause in a cnf formula @xmath0 .",
    "moreover each clause depends on at least @xmath284 variables whose truth value has not been set because the collection of observations is regular .",
    "finally each variable is contained in at most @xmath2 clauses .",
    "the posterior distribution on the remaining hidden variables ( whose value has not already been set ) is uniform on the set of satisfying assignments to @xmath0 and thus we can appeal to theorem  [ thm : approximatesampling ] to complete the proof ."
  ],
  "abstract_text": [
    "<S> in this paper we introduce a new approach for approximately counting in bounded degree systems with higher - order constraints . </S>",
    "<S> our main result is an algorithm to approximately count the number of solutions to a cnf formula @xmath0 with at least @xmath1 variables per clause and degree at most @xmath2 when @xmath1 is logarithmic in @xmath2 . </S>",
    "<S> this closes an exponential gap between the known upper and lower bounds .    </S>",
    "<S> moreover our algorithm extends straightforwardly to approximate sampling , which shows that under lovsz local lemma - like conditions it is not only possible to find a satisfying assignment , it is also possible to generate one approximately uniformly at random from the set of all satisfying assignments . </S>",
    "<S> our approach is a significant departure from earlier techniques in approximate counting , and is based on a framework to bootstrap an oracle for computing marginal probabilities on individual variables . </S>",
    "<S> finally , we give an application of our results to show that it is algorithmically possible to sample from the posterior distribution in an interesting class of graphical models . </S>"
  ]
}