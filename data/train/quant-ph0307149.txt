{
  "article_text": [
    "this paper deals with the following problem .",
    "local search.__given an undirected graph _ _ @xmath4 _ _  and a function _",
    "_ @xmath5 _ _ , find a local minimum of _ _ @xmath6__that is , a vertex _ _",
    "@xmath7 _ _  such that _ _ @xmath8 _ _  for all neighbors _ _ @xmath9 _ of _ @xmath7__. _ _    we are interested in the number of _ queries _ that an algorithm needs to solve this problem , where a query just returns @xmath10  given @xmath7 .",
    "we consider deterministic , randomized , and quantum algorithms .",
    "section [ motivation ]  motivates the problem theoretically and practically ; this section explains our results .",
    "we start with some simple observations .",
    "if @xmath11 is the complete graph of size @xmath12 , then clearly @xmath13  queries are needed to find a local minimum ( or @xmath14  with a quantum computer @xcite ) .  at the other extreme ,",
    "if @xmath11  is a line of length @xmath12 , then even a deterministic algorithm can find a local minimum in @xmath15  queries , using binary search : query the middle two vertices , @xmath7 and @xmath9 .  if @xmath16 , then search the line of length @xmath17  connected to @xmath7 ; otherwise search the line connected to @xmath9 .  continue recursively in this manner until a local minimum is found .",
    "so the interesting case is when @xmath11 is a graph of ` intermediate ' connectedness : for example , the boolean hypercube @xmath18 , with two vertices adjacent if and only if they have hamming distance @xmath19 .  for this graph , llewellyn , tovey , and trick @xcite  showed a @xmath20 lower bound  on the number of queries needed by any deterministic algorithm , using a simple adversary argument .  intuitively , until the set of vertices queried so far comprises a _ vertex cut _ ( that is , splits the graph into two or more connected components ) ,",
    "an adversary is free to return a descending sequence of @xmath21-values : @xmath22  for the first vertex @xmath23  queried by the algorithm , @xmath24  for the second vertex queried , and so on .",
    "moreover , once the set of queried vertices does comprise a cut , the adversary can choose the largest connected component of unqueried vertices , and restrict the problem recursively  to that component .",
    "so to lower - bound the deterministic query complexity , it suffices to lower - bound the size of any cut that splits the graph into two reasonably large components .  for the boolean hypercube , llewellyn et al",
    "showed that the best one can do is essentially to query all @xmath20  vertices of hamming weight @xmath25 .",
    "llewellyn et al.s argument fails completely in the case of randomized algorithms .  by yao s minimax principle ,",
    "what we want here is a fixed _ distribution _",
    "@xmath26 over functions @xmath27 , such that any deterministic algorithm needs many queries to find a local minimum of @xmath21 , with high probability if @xmath21 is drawn from @xmath26 .",
    "taking @xmath26  to be uniform will not do , since a local minimum of a uniform random function is easily found .  however , aldous @xcite  had the idea of defining @xmath26  via a _ random walk _",
    ", as follows .",
    "choose a vertex @xmath28  uniformly at random ; then perform an unbiased walk  to @xmath29 . ]",
    "@xmath30  starting from @xmath31 .  for each vertex @xmath7 ,",
    "set @xmath10 equal to the first hitting time of the walk at @xmath7that is , @xmath32 .",
    "clearly any @xmath21 produced in this way has a unique local minimum at @xmath31 , since for all @xmath33 , if vertex @xmath34  is visited for the first time at step @xmath35 then @xmath36 .  using sophisticated random walk analysis , aldous managed to show a lower bound of @xmath37  on the expected number of queries needed by any randomized algorithm to find @xmath31 .",
    "for any @xmath38 . ]",
    "( as we will see in section [ prelim ] , this lower bound is close to tight . )  intuitively , since a random walk on the hypercube mixes in @xmath39  steps , an algorithm that has not queried a @xmath7 with @xmath40  has almost no useful information about where the unique minimum @xmath31  is , so its next query will just be a `` stab in the dark . ''",
    "aldous s result leaves several questions about local search  unanswered .",
    "what if the graph @xmath11 is a @xmath41-d cube , on which a random walk does _ not _ mix very rapidly ?  can we still lower - bound the randomized query complexity of finding a local minimum ?  more generally , what parameters of @xmath11 make the problem hard or easy ?",
    "also , what is the quantum query complexity of local search ?",
    "this paper presents a new approach to local search ,  which we believe points the way to a complete understanding of its complexity .",
    "our approach is based on the _ quantum adversary method _ , introduced by ambainis @xcite  to prove lower bounds on quantum query complexity .",
    "surprisingly , our approach yields new and simpler lower bounds for the problem s _ classical _ randomized query complexity , in addition to quantum lower bounds .",
    "thus , along with recent work by kerenidis and de wolf @xcite  and by aharonov and regev @xcite , this paper illustrates how quantum ideas can help to resolve classical open problems .",
    "our results are as follows .  for the boolean hypercube @xmath42",
    ", we show that any quantum algorithm needs @xmath43  queries to find a local minimum on @xmath11 , and any randomized algorithm needs @xmath2  queries ( improving the @xmath44  lower bound of aldous @xcite ) .",
    "our proofs are elementary and do not require random walk analysis .  by comparison ,",
    "the best known upper bounds are @xmath45  for a quantum algorithm and @xmath46  for a randomized algorithm .",
    "if @xmath11 is a @xmath47-dimensional grid of size @xmath48 , where @xmath3  is a constant , then we show that any quantum algorithm needs @xmath49  queries to find a local minimum on @xmath11 , and any randomized algorithm needs @xmath50  queries .",
    "no nontrivial lower bounds ( randomized or quantum ) were previously known in this case .    in an earlier version of this paper",
    ", we raised as our `` most ambitious ''  conjecture that the deterministic and quantum query complexities of local search are polynomially related for _ every _ family of graphs .  at the time , it was not even known whether deterministic and _ randomized _ query complexities were polynomially related , not even for simple examples such as the @xmath51-dimensional square grid .",
    "recently santha and szegedy @xcite spectacularly resolved our conjecture , by showing that the quantum query complexity is at least the @xmath52  root ( ! ) of the deterministic complexity .",
    "given that their result generalizes ours to such an extent , we feel obligated to defend why this paper is still relevant",
    ".  first , for specific graphs such as the hypercube , our lower bounds are close to tight ; those of santha and szegedy are not .",
    "second , we give randomized lower bounds that are quadratically better than our quantum lower bounds ; santha and szegedy give only quantum lower bounds .",
    "in another recent development , ambainis ( personal communication ) has improved our @xmath1  quantum lower bound for local search on the hypercube to @xmath53 , using a hybrid argument .",
    "note that ambainis lower bound matches the upper bound up to a polynomial factor .",
    "the paper is organized as follows .",
    "section [ motivation ]  motivates lower bounds on local search , pointing out connections to simulated annealing , quantum adiabatic algorithms , and the complexity class @xmath54  of total function problems .",
    "section [ prelim ]  defines notation and reviews basic facts about local search , including upper bounds .  in section [ adversary ]  we give an intuitive explanation of ambainis s quantum adversary method , then state and prove a classical analogue of ambainis s main lower bound theorem .",
    "section [ snake ]  introduces _ snakes _ , a construction by which we apply the two adversary methods to local search .",
    "we show there that to prove lower bounds for any graph @xmath11 , it suffices to upper - bound a combinatorial parameter @xmath55  of a ` snake distribution '  on @xmath11 .",
    "section [ graphs ] applies this framework to specific examples of graphs : the boolean hypercube in section [ boolean ] , and the @xmath47-dimensional grid in section [ ddim ] .",
    "local search is the most effective weapon ever devised against hard optimization problems .  for many real applications , neither backtrack search , nor approximation algorithms , nor even grover s algorithm ( assuming we had a quantum computer ) can compare .",
    "furthermore , along with quantum computing , local search ( broadly defined ) is one of the most interesting links between computer science and nature .",
    "it is related to evolutionary biology via genetic algorithms , and to the physics of materials via simulated annealing .",
    "thus it is both practically and scientifically important to understand its performance .",
    "the conventional wisdom is that , although local search performs well in practice , its central ( indeed defining ) flaw is a tendency to get stuck at local optima .",
    "if this were correct , one corollary would be that the reason local search performs so well is that the problem it really solves  finding a local optimum  is intrinsically easy",
    ".  it would thus be unnecessary to seek further explanations for its performance .",
    "another corollary would be that , for _ unimodal _ functions ( which have no local optima besides the global optimum ) , the global optimum would be easily found",
    ".    however , the conventional wisdom is false .  the results of llewellyn et al .",
    "@xcite and aldous @xcite  show that even if @xmath21 is unimodal , any classical algorithm that treats @xmath21 as a black box needs exponential time to find the global minimum of @xmath21 in general .",
    "our results extend this conclusion to quantum algorithms .  in our view",
    ", the practical upshot of these results is that they force us to confront the question : what is it about ` real - world '  problems that makes it easy to find a local optimum ?  that is , why do exponentially long chains of descending values , such as those used for lower bounds , almost never occur in practice ( even in functions with large range sizes ) ?",
    "we do not know a good answer to this .",
    "our results are also relevant for physics .",
    "many physical systems , including folding proteins and networks of springs and pulleys , can be understood as performing ` local search ' through an energy landscape to reach a locally - minimal energy configuration .",
    "a key question is , how long will the system take to reach its ground state ( that is , a globally - minimal configuration ) ?  of course , if there are local optima , the system might _ never _ reach its ground state , just as a rock in a mountain crevice does not roll to the bottom by going up first .  but what if the energy landscape is unimodal ?  and moreover , what if the physical system is quantum ?",
    "our results show that , for certain energy landscapes , even a quantum system would take exponential time to reach its ground state , regardless of what hamiltonian is applied to it .",
    "so in particular , the quantum adiabatic algorithm proposed by farhi et al .",
    "@xcite , which can be seen as a quantum analogue of simulated annealing , needs exponential time to find a local minimum in the worst case .",
    "finally , our results have implications for so - called _ total function problems _ in complexity theory .",
    "megiddo and papadimitriou @xcite  defined a complexity class @xmath54 , consisting ( informally ) of those @xmath56  search problems for which a solution always exists .",
    "for example , we might be given a function @xmath57  as a boolean circuit , and asked to find any distinct @xmath58 pair such that @xmath59 .",
    "this particular problem belongs to a subclass of @xmath54 called @xmath60 ( polynomial pigeonhole principle ) .",
    "notice that no promise is involved : the combinatorial nature of the problem itself forces a solution to exist , even if we have no idea how to find it .  in a recent talk ,",
    "papadimitriou @xcite asked broadly whether such ` nonconstructive existence problems ' might be good candidates for efficient quantum algorithms .  in the case of @xmath60  problems",
    ", the collision lower bound of aaronson @xcite ( improved by shi @xcite  and others )  implies a negative answer in the black - box setting .  for other subclasses of @xmath54 , such as @xmath61  ( polynomial odd - degree node ) , a quantum black - box lower",
    "bound follows easily from the optimality of grover s search algorithm .",
    "however , there is one important subclass of @xmath54  for which no quantum lower bound was previously known .",
    "this is @xmath62 ( polynomial local search ) , defined by johnson , papadimitriou , and yannakakis @xcite as a class of optimization problems whose cost function @xmath21 and neighborhood function @xmath63 ( that is , the set of neighbors of a given point ) are both computable in polynomial time .  given such a problem ,",
    "the task is to output any local minimum of the cost function : that is , a @xmath7 such that @xmath64  for all @xmath65 .",
    "the lower bound of llewellyn et al .",
    "@xcite yields an oracle @xmath66 relative to which @xmath67 , by a standard diagonalization argument along the lines of baker , gill , and solovay @xcite .  likewise , the lower bound of aldous @xcite  yields an oracle relative to which @xmath68 , where @xmath69  is simply the function version of @xmath70 .",
    "our results yield the first oracle relative to which @xmath71 .  in light of this oracle separation , we raise an admittedly vague question : is there a nontrivial `` combinatorial ''  subclass of @xmath54  that we can show _ is _ contained in @xmath72 ?",
    "in the local search  problem , we are given an undirected graph @xmath73 with @xmath74 ,  and oracle access to a function @xmath5 .",
    "the goal is to find any _ local minimum _ of @xmath21 , defined as a vertex @xmath75 such that @xmath16  for all neighbors @xmath9  of @xmath7",
    ".  clearly such a local minimum exists .",
    "we want to find one using as few queries as possible , where a query returns @xmath10  given @xmath7 .",
    "queries can be adaptive ; that is , can depend on the outcomes of previous queries .",
    "we assume @xmath11 is known in advance , so that only @xmath21 needs to be queried .",
    "since we care only about query complexity , not computation time , there is no difficulty in dealing with an infinite range for @xmath21though for our lower bounds , it will turn out that a range of size @xmath76  suffices .",
    "our model of query algorithms is the standard one ; see @xcite  for a survey .",
    "given a graph @xmath11 , the deterministic query complexity of local search on @xmath11 , which we denote @xmath77 , is @xmath78  where the minimum ranges over all deterministic algorithms @xmath79 , the maximum ranges over all @xmath21 , and @xmath80  is the number of queries made to @xmath21 by @xmath79  before it halts and outputs a local minimum of @xmath21 ( or @xmath81  if @xmath79 fails to do so ) .",
    "the randomized query complexity @xmath82  is defined similarly , except that now the algorithm has access to an infinite random string @xmath83 , and must only output a local minimum with probability at least @xmath84 over @xmath83 .  for simplicity , we assume that the number of queries @xmath85 is the same for all @xmath83 ; clearly this assumption changes the complexity by at most a constant factor .    in the quantum model",
    ", an algorithm s state has the form @xmath86 , where @xmath7 is the label of a vertex in @xmath11 , and @xmath87 and @xmath88 are strings representing the answer register and workspace respectively .",
    "the @xmath89 s  are complex amplitudes satisfying @xmath90 .  starting from an arbitrary ( fixed ) initial state , the algorithm proceeds by an alternating sequence of _ queries _ and _ algorithm steps_.  a query maps each @xmath91  to @xmath92 , where @xmath93  denotes bitwise exclusive - or .",
    "an algorithm step multiplies the vector of @xmath89 s  by an arbitrary unitary matrix that does not depend on @xmath21 .  letting @xmath94  denote the set of local minima of @xmath21 , the algorithm succeeds if at the end @xmath95 .",
    "then the bounded - error quantum query complexity , or @xmath96 , is defined as the minimum number of queries used by a quantum algorithm that succeeds on every @xmath21 .",
    "it is immediate that @xmath97 .",
    "also , letting @xmath98  be the maximum degree of @xmath11 , we have the following trivial lower bound .",
    "[ degree]@xmath99  and @xmath100 .",
    "let @xmath7 be a vertex of @xmath11 with degree @xmath98 .  choose a neighbor @xmath9 of @xmath7 uniformly at random , and",
    "let @xmath101 .",
    "let @xmath102 , and @xmath103 for all neighbors @xmath104 of @xmath7 other than @xmath9 .",
    "let @xmath105  be the neighbor set of @xmath7 ( including @xmath7 itself ) ; then for all @xmath106 , let @xmath107  where @xmath108 is the minimum distance from @xmath109 to a vertex in @xmath105 .",
    "clearly @xmath21 has a unique local minimum at @xmath9 .",
    "however , finding @xmath110 requires exhaustive search among the @xmath98  neighbors of @xmath7 , which requires @xmath111 quantum queries @xcite .",
    "a corollary of proposition [ degree ]  is that classically , zero - error randomized query complexity is equivalent to bounded - error up to a constant factor .  for given a candidate local minimum @xmath7",
    ", one can check using @xmath112  queries that @xmath7 is indeed a local minimum .  since @xmath113  queries are needed anyway",
    ", this verification step does not affect the overall complexity .",
    "as pointed out by aldous @xcite , a classical randomized algorithm can find a local minimum of @xmath21 with high probability in @xmath114  queries .",
    "the algorithm just queries @xmath115  vertices uniformly at random , and lets @xmath31  be a queried vertex for which @xmath116  is minimal .",
    "it then follows @xmath31  to a local minimum by steepest descent .",
    "that is , for @xmath117 , it queries all neighbors of @xmath34 , halts if @xmath34  is a local minimum , and otherwise sets @xmath118  to be the neighbor @xmath9 of @xmath34  for which @xmath119  is minimal ( breaking ties by lexicographic ordering ) .",
    "a similar idea yields an improved quantum upper bound .",
    "[ upper]for any @xmath11 , @xmath120 .",
    "the algorithm first chooses @xmath121  vertices of @xmath11 uniformly at random , then uses grover search to find a chosen vertex @xmath122 for which @xmath10  is minimal .  by a result of drr and hyer @xcite ,",
    "this can be done with high probability in @xmath123  queries .  next , for @xmath117 , the algorithm performs grover search over all neighbors of @xmath124 , looking for a neighbor @xmath9 such that @xmath125 .",
    "if it finds such a @xmath9 , then it sets @xmath126 and continues to the next iteration .",
    "otherwise , it repeats the grover search @xmath127  times before finally giving up and returning @xmath124  as a claimed local minimum .    the expected number of vertices @xmath104 such that @xmath128 is at most @xmath129 .",
    "since @xmath130 for all @xmath35 , clearly the number of such @xmath104 provides an upper bound on @xmath35 .",
    "furthermore , assuming there exists a @xmath9 such that @xmath131 , the expected number of repetitions of grover s algorithm until such a @xmath9 is found is @xmath132 .  since each repetition takes @xmath133  queries , by linearity of expectation the total expected number of queries used by the algorithm is therefore@xmath134 or @xmath135 .",
    "to see that the algorithm finds a local minimum with high probability , observe that for each @xmath35 , the probability of not finding a @xmath9 such that @xmath136 , given that one exists , is at most @xmath137  for a suitable constant @xmath138 .",
    "so by the union bound , the probability that the algorithm returns a ` false positive ' is at most @xmath139 .",
    "we know of essentially two methods for proving lower bounds on quantum query complexity : the polynomial method of beals et al .",
    "@xcite , and the quantum adversary method of ambainis @xcite .  for a few problems , such as the collision problem @xcite , the polynomial method succeeded where the adversary method failed .",
    "however , for problems that lack permutation symmetry ( such as local search ) , the adversary method has proven more effective .",
    "how could a quantum lower bound method possibly be applied classically ?",
    "when proving randomized lower bounds , the tendency is to attack `` bare - handed '' : fix a distribution over inputs , and let @xmath140  be the locations queried so far by the algorithm .",
    "show that for small @xmath35 , the posterior distribution over inputs , _ conditioned _ on @xmath140 , is still ` hard ' with high probability  so that the algorithm knows almost nothing even about which location @xmath141  to query next .",
    "this is essentially the approach taken by aldous @xcite  to prove a @xmath44  lower bound on @xmath142 .    in the quantum case",
    ", however , it is unclear how to specify what an algorithm ` knows '  after a given number of queries .",
    "so we are almost _ forced _ to step back , and identify general combinatorial properties of input sets that make them hard to distinguish .",
    "once we have such properties , we can then try to exhibit them in functions of interest .",
    "we believe this gloved  attack can be useful for classical lower bounds as well as quantum ones .  in our _ relational adversary method _ , we assume there exists a @xmath85-query randomized algorithm for function @xmath143 .",
    "we consider a set @xmath144  of @xmath145-inputs of @xmath143 , a set @xmath146  of @xmath19-inputs , and an arbitrary real - valued _ relation function _ @xmath147  for @xmath148  and @xmath149",
    ".  intuitively , @xmath150  should be large if @xmath66 and @xmath151 differ in only a few locations .",
    "we then fix a probability distribution @xmath26  over inputs ; by yao s minimax principle , there exists a @xmath85-query deterministic algorithm @xmath152  that succeeds with high probability on inputs drawn from @xmath26 .",
    "let @xmath153  be the set of @xmath145-inputs and @xmath154  the set of @xmath19-inputs on which @xmath155  succeeds .  using the relation function @xmath83",
    ", we define a _ separation measure _ @xmath105  between @xmath153  and @xmath154 , and show that ( 1 ) initially @xmath156 ,  ( 2 ) by the end of the computation @xmath105  must be large , and ( 3 ) @xmath105 increases by only a small amount as the result of each query .",
    "it follows that @xmath85  must be large .",
    "undoubtedly any randomized lower bound proved using our relational method could also be proved bare - handed ,  without any quantum intuition",
    ".  however , our method makes it easier to focus on what is unique about a problem , and ignore what is common among many problems .",
    "our starting point is the `` most general ''  adversary theorem in ambainis s original paper ( theorem 6  in @xcite ) , which he introduced to prove a quantum lower bound for the problem of inverting a permutation .",
    "here the input is a permutation @xmath157 , and the task is to output @xmath145 if @xmath158  and @xmath19 otherwise .  to lower - bound this problem s query complexity , what we would like to say is this :    _ given any _ @xmath145__-input _ _ @xmath159 _ _  and any location _ _ @xmath109 _ _ , if we choose a random _ _ @xmath19__-input _ _ @xmath160 _ _  that is ` related ' to _ _ @xmath159 _ _ , then the probability _ _ @xmath161 _ over _ @xmath160 _ _  that _ _ @xmath162 _ does not equal _ @xmath163 _ _  is small .  in other words ,",
    "the algorithm is unlikely to distinguish _ _ @xmath164 _ _  from a random neighbor _",
    "_ @xmath160 _ _  of _ _ @xmath159 _ _  by querying _ _ @xmath109__. _ _",
    "unfortunately , the above claim is false .",
    "letting @xmath165 , we have that @xmath166  for _ every _ @xmath19-input @xmath160 , and thus @xmath167 .",
    "ambainis resolves this difficulty by letting us take the maximum , over all @xmath145-inputs @xmath159  and @xmath19-inputs @xmath160 that are related and differ at @xmath109 , of the _ geometric mean _ @xmath168 .  even if @xmath169",
    ", the geometric mean is still small provided that @xmath170  is small .",
    "more formally :    [ ambainis][ambthm]let @xmath171 and @xmath172  be sets of inputs to function @xmath143 .",
    "let @xmath147 be a real - valued function , and for @xmath148 , @xmath149 , and location @xmath109 , let@xmath173 where the denominators are all nonzero .",
    "then the number of quantum queries needed to evaluate @xmath143 with at least @xmath174 probability is @xmath175 , where@xmath176    to illustrate we show the following .",
    "[ ambainis]the quantum query complexity of inverting a permutation is @xmath14 .",
    "let @xmath177  be the set of all permutations @xmath159  with @xmath178 @xmath179 , and @xmath180  be the set of permutations @xmath160  with @xmath181 .  given @xmath182  and @xmath183 , let @xmath184  if @xmath159  and @xmath160  differ only at locations @xmath185  and @xmath186 , and @xmath187  otherwise .",
    "then given @xmath188  with @xmath189 ,  if @xmath190  then @xmath191 , and if @xmath192  then @xmath193 .",
    "so @xmath194 .",
    "the only difference between theorem [ ambthm ]  and our relational adversary theorem is that in the latter , we take the _ minimum _ of @xmath195 and @xmath196  instead of the geometric mean .  taking the reciprocal then gives up to a quadratically better lower bound : for example , we obtain that the randomized query complexity of inverting a permutation is @xmath197 .  however , the proofs of the two theorems are quite different .",
    "[ classadv]let @xmath198 be as in theorem [ ambthm ] .",
    "then the number of randomized queries needed to evaluate @xmath143  with at least @xmath174 probability is @xmath199 , where@xmath200    let @xmath79 be a randomized algorithm that , given an input @xmath66 , returns @xmath201 with at least @xmath174 probability .",
    "let @xmath85 be the number of queries made by @xmath79 .  for all @xmath202 , @xmath149 , define@xmath203 now let @xmath204  be the distribution over @xmath202  in which each @xmath66 is chosen with probability @xmath205 ; and let @xmath206  be the distribution over @xmath207  in which each @xmath151 is chosen with probability @xmath208 .",
    "let @xmath209  be an equal mixture of @xmath210  and @xmath211 .",
    "by yao s minimax principle , there exists a deterministic algorithm @xmath212  that makes @xmath85 queries , and succeeds with at least @xmath174 probability given an input drawn from @xmath213 .",
    "therefore @xmath152  succeeds with at least @xmath214  probability given an input drawn from @xmath215 alone , or from @xmath216 alone .",
    "in other words , letting @xmath153  be the set of @xmath202  and @xmath154  the set of @xmath149  on which @xmath152  succeeds , we have@xmath217 define a predicate @xmath218 , which is true if @xmath152 has distinguished @xmath148 from @xmath219  by the @xmath220  query and false otherwise .",
    "( to distinguish @xmath66 from @xmath151 means to query an index @xmath109  for which @xmath221 , given either @xmath66 or @xmath151 as input . )  also , for all @xmath222 , define a score function@xmath223 this function measures how much `` progress '' has been made so far in separating @xmath66 from @xmath180-inputs , where the @xmath180-inputs  are weighted by @xmath224 .",
    "similarly , for all @xmath207 define@xmath225 it is clear that for all @xmath35,@xmath226 so we can denote the above sum by @xmath227 and think of it as a  global progress measure .  we will show the following about @xmath228 :    1 .",
    "@xmath229 initially .",
    "@xmath230 by the end .",
    "3 .   @xmath231  for all @xmath35 , where @xmath232 is the amount by which @xmath227  increases as the result of a single query .",
    "it follows from ( i)-(iii ) that@xmath233 which establishes the theorem .  part ( i ) is obvious .  for part ( ii ) , observe that for every pair @xmath234 with @xmath235 and @xmath236 , the algorithm @xmath152  must query an @xmath109 such that @xmath237 .",
    "thus@xmath238it remains only to show part ( iii ) .",
    "suppose @xmath239  for some @xmath35 ; we will obtain a contradiction .  let@xmath240 and let @xmath241  be the set of @xmath202 for which @xmath242 .",
    "since@xmath243 it follows by markov s inequality that@xmath244 similarly , letting @xmath245  be the set of @xmath149 for which @xmath246 , we have@xmath247 in other words , at least @xmath84  of the increase in @xmath248  comes from @xmath234  pairs such that @xmath249 ,  and at least @xmath84  comes from @xmath234  pairs such that @xmath250 .",
    "hence , by a ` pigeonhole ' argument , there exists an @xmath249 and @xmath251  with @xmath252  that are distinguished by the @xmath253  query .",
    "in other words , there exists an @xmath109 with @xmath254 , such that the @xmath220  index queried by @xmath212  is @xmath109 whether the input is @xmath66 or @xmath151 .  then since @xmath249 , we have @xmath255 , and hence@xmath256 which equals @xmath195 .",
    "similarly @xmath257 since @xmath250 .",
    "this contradicts the definition@xmath258 and we are done .",
    "for our lower bounds , it will be convenient to generalize random walks to arbitrary distributions over paths , which we call _",
    "snakes_.    [ snake]given a vertex @xmath259 in @xmath11 and a positive integer @xmath260 ,",
    "a _ snake distribution _ @xmath261  ( parameterized by @xmath259 and @xmath260 ) is a probability distribution over paths @xmath262  in @xmath11 , such that each @xmath263  is either equal or adjacent to @xmath141 , and @xmath264 .",
    "let @xmath265  be the support of @xmath261 .",
    "then an element of @xmath265  is called a _ snake _ ; the part near @xmath266  is the _ tail _ and the part near @xmath264  is the _",
    "head_.    given a snake @xmath267 and integer @xmath35 , we use @xmath268 $ ]  as shorthand for @xmath269 .",
    "[ elgood]we say a snake @xmath270  is @xmath271__-good _ _  if the following holds .",
    "choose @xmath272 uniformly at random from @xmath273 , and let @xmath274  be a snake drawn from @xmath261  conditioned on @xmath275  for all @xmath276",
    ".  then    1 .",
    "letting @xmath277  be the set of vertices @xmath7 in @xmath278  such that @xmath279 , we have@xmath280   \\geq9/10.\\ ] ] 2 .   for all vertices",
    "@xmath7 , @xmath281 \\right ]   \\leq\\varepsilon$ ] .",
    "the procedure above  wherein we choose a @xmath272 uniformly at random , then draw a @xmath282  from @xmath261  consistent with @xmath267 on all steps later than @xmath272will be important in what follows .",
    "we call it _ the snake _ @xmath283 _ flicking its tail_.  intuitively , a snake is good if it is spread out fairly evenly in @xmath11so that when it flicks its tail , ( 1 ) with high probability the old and new tails do not intersect , and ( 2 ) any particular vertex is hit by the new tail with probability at most @xmath271 .",
    "we now explain our ` snake method ' for proving lower bounds for local search .  given a snake @xmath267 , we define an input @xmath284  with a unique local minimum at @xmath266 , and @xmath21-values that decrease along @xmath267 from head to tail .  then , given inputs @xmath284 and @xmath285 with @xmath286 , we let the relation function @xmath287 be proportional to the probability that snake @xmath282 is obtained by @xmath267 flicking its tail .",
    "( if @xmath288 we let @xmath289 . )",
    "let @xmath284 and @xmath290 be inputs with @xmath291 , and let @xmath7 be a vertex such that @xmath292 .",
    "then if all snakes were good , there would be two mutually exclusive cases : ( 1 ) @xmath7 belongs to the tail of @xmath267 , or ( 2 ) @xmath7 belongs to the tail of @xmath282 .  in case",
    "( 1 ) , @xmath7 is hit with small probability when @xmath282  flicks its tail , so @xmath293  is small .  in case",
    "( 2 ) , @xmath7 is hit with small probability when @xmath267 flicks its tail , so @xmath294  is small .  in either case , then , the _ geometric mean _",
    "@xmath295  and _ minimum _",
    "@xmath296  are small .",
    "so even though @xmath294  or @xmath297  could be large individually , theorems [ ambthm ]  and [ classadv ] yield a good lower bound , as in the case of inverting a permutation ( see figure 1 ) .",
    "[ ptb ]    snakefig.eps    one difficulty is that not all snakes are good ; at best , a large fraction of them are .",
    "we could try deleting all inputs @xmath284  such that @xmath267 is not good , but that might ruin some remaining inputs , which would then have fewer neighbors .",
    "so we would have to delete _ those _ inputs as well , and so on ad infinitum .",
    "what we need is basically a way to replace `` all inputs ''  by `` most inputs ''  in theorems [ ambthm ]  and [ classadv ] .",
    "fortunately , a simple graph - theoretic lemma can accomplish this .",
    "the lemma ( see diestel @xcite for example ) says that any graph with average degree at least @xmath298 contains an induced subgraph with _ minimum _",
    "degree at least @xmath299 .",
    "here we prove a weighted analogue of the lemma .",
    "[ subgraph]let @xmath300  be positive reals summing to @xmath19 .",
    "also let @xmath301 for @xmath302  be nonnegative reals satisfying @xmath303  and @xmath304 .  then there exists a nonempty subset @xmath305  such that for all @xmath306 , @xmath307    if @xmath308 then the lemma trivially holds , so assume @xmath309 .",
    "we construct @xmath310 via an iterative procedure .",
    "let @xmath311 .",
    "then for all @xmath35 , if there exists an  @xmath312 for which@xmath313 then set @xmath314 .",
    "otherwise halt and return @xmath315 .  to see that the @xmath310 so constructed is nonempty , observe that when we remove @xmath316 , the sum @xmath317  decreases by @xmath318 , while @xmath319  decreases by at most@xmath320 so since @xmath321  was positive to begin with , it must still be positive at the end of the procedure ; hence @xmath310  must be nonempty .",
    "we can now prove the main result of the section .",
    "[ kappathm]suppose a snake drawn from @xmath261  is @xmath271__-__good  with probability at least @xmath174 .",
    "then@xmath322    given a snake @xmath323 , we construct an input function @xmath324 as follows .  for each @xmath325 , let @xmath326 ; and for each @xmath327 , let @xmath328  where @xmath329  is the distance from @xmath7 to @xmath259 in @xmath11 .",
    "clearly @xmath324 so defined has a unique local minimum at @xmath330 .  to obtain a decision problem , we stipulate that querying @xmath330  reveals an answer bit ( @xmath145 or @xmath19 ) in addition to @xmath331 ; the algorithm s goal is then to return the answer bit .",
    "obviously a lower bound for the decision problem implies a corresponding lower bound for the search problem .",
    "let us first prove the theorem in the case that all snakes in @xmath332  are @xmath271__-__good .",
    "let @xmath333  be the probability of drawing snake @xmath267 from @xmath334 .  also , given snakes @xmath335  and @xmath336 , let @xmath337  be the probability that @xmath338 , if @xmath339 is drawn from @xmath340 conditioned on agreeing with @xmath267  on all steps later than @xmath272 .",
    "then define@xmath341 our first claim is that @xmath9  is symmetric ; that is , @xmath342 .",
    "it suffices to show that @xmath343 for all @xmath272 .",
    "we can assume @xmath267  agrees with @xmath282 on all steps later than @xmath272 , since otherwise @xmath344 .",
    "given an @xmath345 , let @xmath66 denote the event that @xmath339 agrees with @xmath267 ( or equivalently @xmath282 ) on all steps later than @xmath272 , and let @xmath346 ( resp .",
    "@xmath347 ) denote the event that @xmath339 agrees with @xmath267  ( resp .",
    "@xmath282 ) on steps @xmath19 to @xmath272 .  then@xmath348 \\pr\\left [   b_{x}%    &   = p\\left (   y\\right )   q_{j}% \\left (   y , x\\right )   .\\end{aligned}\\]]now let @xmath349  denote the event that @xmath350 ,  where @xmath277  is as in definition [ elgood ] .  also , let @xmath324  be the input obtained from @xmath267 that has answer bit @xmath145 , and @xmath351  be the input that has answer bit @xmath19 .  to apply theorems [ ambthm ]  and [ classadv ] , take @xmath352 and @xmath353 .  then take @xmath354  if @xmath349  holds , and @xmath355  otherwise",
    ".  given @xmath356  and @xmath357  with @xmath358 , and letting @xmath7 be a vertex such that @xmath359 , we must then have either @xmath327  or @xmath360 .",
    "suppose the former case ; then@xmath361since @xmath282  is @xmath271-good .",
    "thus@xmath362 similarly , if @xmath360  then @xmath363  by symmetry .",
    "hence@xmath364 the latter since @xmath365  and @xmath366  for all @xmath367 and @xmath7 .",
    "we now turn to the general case , in which a snake drawn from @xmath368  is @xmath271__-__good  with probability at least @xmath174 .",
    "let @xmath369  denote the event that @xmath267 is @xmath271-good .",
    "take @xmath370 and @xmath371 , and  take @xmath372  as before .",
    "then since@xmath373 by the union bound we have@xmath374",
    "so by lemma [ subgraph ] , there exist subsets @xmath375  and @xmath376  such that for all @xmath377 and @xmath378,@xmath379so for all @xmath380  with @xmath358 , and all @xmath7 such that @xmath381 , either @xmath382  or @xmath383 .",
    "hence @xmath384  and @xmath385 .",
    "in this section we apply the ` snake method ' developed in section [ snake ] to specific examples of graphs : the boolean hypercube in section [ boolean ] , and the @xmath47-dimensional cubic grid ( for @xmath3 )  in section [ ddim ] .",
    "abusing notation , we let @xmath0  denote the @xmath386-dimensional boolean hypercube  that is , the graph whose vertices are @xmath386-bit strings ,  with two vertices adjacent if and only if they have hamming distance @xmath19 .  given a vertex @xmath387 , we let @xmath388   , \\ldots , v\\left [   n-1\\right ]   $ ]  denote the @xmath386 bits of @xmath7 , and let @xmath389 denote the neighbor obtained by flipping bit @xmath390   $ ] .  in this section",
    "we lower - bound @xmath391  and @xmath392 .    fix a ` snake head ' @xmath393 and take @xmath394 .",
    "we define the snake distribution @xmath261  via what we call a _ coordinate loop _",
    ", as follows .  starting from @xmath395 ,  for each @xmath35 take @xmath396  with @xmath397 probability , and @xmath398  with @xmath397 probability .",
    "the following is a basic fact about this distribution .",
    "[ mixtime]the coordinate loop mixes completely in @xmath386 steps , in the sense that if @xmath399 , then @xmath400  is a uniform random vertex  conditioned on @xmath263 .",
    "we could also use the random walk distribution , following aldous @xcite .",
    "however , not only is the coordinate loop distribution easier to work with ( since it produces fewer self - intersections ) , it also yields a better lower bound ( since it mixes completely in @xmath386 steps , as opposed to approximately in @xmath401 steps ) .",
    "we first upper - bound the probability , over @xmath267 , @xmath272 , and @xmath402 $ ] , that @xmath403 ( where @xmath277  is as in definition [ elgood ] ) .",
    "[ intersect]suppose @xmath267 is drawn from @xmath261 , @xmath272 is drawn uniformly from @xmath404 , and @xmath402 $ ]  is drawn from @xmath405 .",
    "then @xmath406 } \\left [   x\\cap y = s_{x , y}\\right ]   \\geq0.9999 $ ] .",
    "call a _ disagreement _ a vertex @xmath7  such that@xmath407 clearly if there are no disagreements then @xmath408 .",
    "if @xmath7  is a disagreement , then by the definition of @xmath368  we can not have both @xmath409  and @xmath410 .",
    "so by proposition [ mixtime ] , either @xmath411  is uniformly random conditioned on @xmath267 , or @xmath412  is uniformly random conditioned on @xmath402   $ ] .",
    "hence @xmath413   } % \\left [   x_{t}=y_{t^{\\ast}}\\right ]   = 1/2^{n}% $ ] .",
    "so by the union bound,@xmath414   } % \\left [   x\\cap y\\neq s_{x , y}\\right ] \\leq\\frac{l^{2}}{2^{n}}% = 0.0001.\\ ] ]    we now argue that , unless @xmath267 spends a ` pathological ' amount of time in one part of the hypercube , the probability of any vertex @xmath7 being hit when @xmath267 flicks its tail is small .  to prove this , we define a notion of _ sparseness _ , and then show that ( 1 ) almost all snakes drawn from @xmath261  are sparse ( lemma [ hammingball ] ) , and ( 2 ) sparse snakes are unlikely to hit any given vertex @xmath7 ( lemma [ sparsegood ] ) .",
    "[ sparse]given vertices @xmath415 and @xmath416 , let @xmath417  be the number of steps needed to reach @xmath7 from @xmath109 by first setting @xmath418   : = v\\left [   i\\right ]   $ ] , then setting @xmath419   : = v\\left [   i-1\\right ]   $ ] , and so on .",
    "( after we set @xmath420   $ ]  we wrap around to @xmath421   $ ] . )",
    "then @xmath267 is _ sparse _ if there exists a constant @xmath138 such that for all @xmath387 and all @xmath298,@xmath422    [ hammingball]if @xmath267 is drawn from @xmath261 , then @xmath267 is sparse with probability @xmath423 .    for each @xmath416 , the number of @xmath424  such that @xmath425  is at most @xmath426 .",
    "for such a @xmath35 , let @xmath427  be the event that @xmath428 ; then @xmath429  holds if and only if@xmath430   = v\\left [   i\\right ]   , \\ldots , x_{t}% \\left [   i - k+1\\right ] = v\\left [   i - k+1\\right]\\ ] ] ( where we wrap around to @xmath431   $ ]  after reaching @xmath432   $ ] ) .",
    "this occurs with probability @xmath433  over @xmath267 .",
    "furthermore , by proposition [ mixtime ] , the @xmath434  events for different @xmath35 s are independent .",
    "so let@xmath435 then for fixed @xmath436 , the expected number of @xmath35 s  for which @xmath437  holds is at most @xmath438 .  thus by a chernoff bound ,",
    "if @xmath439  then@xmath440   < \\left (   \\frac{e^{cn-1}% } { \\left (   cn\\right ) ^{cn}}\\right )   ^{\\mu_{k}}<\\frac{1}{2^{2n}}%\\ ] ] for sufficiently large @xmath138 .  similarly , if @xmath441  then@xmath442   < \\left (   \\frac{e^{cn/\\mu_{k}-1}}% { \\left (   cn/\\mu _ { k}\\right )   ^{cn/\\mu_{k}}}\\right )   ^{\\mu_{k}}<\\frac{1}% { 2^{2n}}%\\ ] ] for sufficiently large @xmath138 .  by the union bound , then,@xmath443 for every @xmath436 triple _ simultaneously _ with probability at least @xmath444",
    ".  summing over all @xmath445 s produces the additional factor of @xmath386 .",
    "[ sparsegood]if @xmath267 is sparse , then for every @xmath446,@xmath447   \\right ]   = o\\left (   \\frac{n^{2}}% { l}\\right )   .\\ ] ]    by assumption , for every @xmath448,@xmath449 &   \\leq\\frac{\\left|   \\left\\ {   t:\\delta\\left (   x_{t}% , v ,",
    "t\\operatorname{mod}% n\\right )   = k\\right\\ }   \\right|   } { l}% \\\\ &   \\leq\\frac{cn}{l}\\left (   n+\\frac{l}{2^{n - k}}\\right )   .\\end{aligned}\\]]consider the probability that @xmath450   $ ]  in the event that @xmath451 .",
    "clearly@xmath452 = \\frac{1}{2^{k}% } .\\ ] ] also , proposition [ mixtime ]  implies that for every @xmath453 , the probability that @xmath454  is @xmath455 .",
    "so by the union bound,@xmath456 \\leq\\frac{l}% { 2^{n}}.\\ ] ] then @xmath457   \\right ]   $ ]  equals@xmath458{c}% \\pr_{j}% \\left [   \\delta\\left (   x_{j},v , j\\operatorname{mod}% n\\right )   = k\\right ] \\cdot\\\\ \\pr_{y}% \\left [   v\\in y\\left [   j\\right ]   ~|~\\delta\\left (   x_{j}% % , v , j\\operatorname{mod}n\\right )   = k\\right ] \\end{array}% \\right ) \\\\ &   \\leq\\sum_{k=0}^{n}\\frac{cn}{l}\\left (   n+\\frac{l}{2^{n - k}% } \\right )   \\left ( \\frac{1}{2^{k}}+\\frac{l}{2^{n}}% \\right )   = o\\left (   \\frac{cn^{2}}{l}\\right)\\end{aligned}\\]]as can be verified by breaking the sum into cases and doing some manipulations .",
    "the main result follows easily :    [ boolean]@xmath459    take @xmath460 .",
    "then by theorem [ kappathm ] ,  it suffices to show that a snake @xmath267 drawn from @xmath334  is @xmath461-good with probability at least  @xmath174 .",
    "first , since@xmath414   } % \\left [   x\\cap y = s_{x , y}\\right ]   \\geq0.9999\\ ] ] by lemma [ intersect ] , markov s inequality shows that@xmath462   } \\left [   x\\cap y = s_{x , y}% \\right ] \\geq\\frac{9}{10}\\right ]   \\geq\\frac{19}{20}% .\\ ] ] second , by lemma [ hammingball ] , @xmath267 is sparse with probability @xmath463 , and by lemma [ sparsegood ] , if @xmath267 is sparse then@xmath464",
    "\\right ]   = o\\left (   \\frac{n^{2}}% { l}% \\right )   = o\\left (   \\varepsilon\\right)\\ ] ] for every @xmath7 .",
    "so both requirements of definition [ elgood ]  hold simultaneously with probability at least @xmath174 .      in the boolean hypercube case",
    ", we defined @xmath261  by a ` coordinate loop ' instead of the usual random walk mainly for convenience .",
    "when we move to the @xmath47-dimensional grid , though , the drawbacks of random walks become more serious : first , the mixing time is too long , and second , there are too many self - intersections , particularly if @xmath465 .",
    "our snake distribution will instead use straight lines of randomly chosen lengths attached at the endpoints , as in figure 2 .",
    "[ ptb ]    linefig.eps    let @xmath466  be a @xmath47-dimensional grid graph with @xmath3 .",
    "that is , @xmath466  has @xmath12 vertices of the form @xmath467 , \\ldots , v\\left [   d-1\\right ]   \\right )   $ ] , where each @xmath390   $ ]  is in @xmath468 ( we assume for simplicity that @xmath12 is a @xmath469  power ) .",
    "vertices @xmath7 and @xmath9 are adjacent if and only if @xmath470   -w\\left [   i\\right ]   \\right\\vert = 1 $ ]  for some @xmath471 , and @xmath472   = w\\left [ j\\right ]   $ ]  for all @xmath473 ( so @xmath466  does not wrap around at the boundaries ) .",
    "we take @xmath474 , and define the snake distribution @xmath368  as follows .",
    "starting from @xmath395 , for each @xmath85  we take @xmath475  identical to @xmath476 , but with the @xmath477  coordinate @xmath478   $ ]  replaced by a uniform random value in @xmath468 .",
    "we then take the vertices @xmath479  to lie along the shortest path from @xmath476  to @xmath480 ,  ` stalling '  at @xmath475  once that vertex has been reached .",
    "we call@xmath481 a _ line _ of vertices , whose _ direction _",
    "is @xmath482 .  as in the boolean hypercube case",
    ", we have :    [ mixtime2]@xmath261 mixes completely in @xmath483 steps , in the sense that if @xmath484 , then @xmath485  is a uniform random vertex  conditioned on @xmath476 .",
    "lemma [ intersect ]  in section [ boolean ]  goes through essentially without change .",
    "[ sparse2]letting @xmath417  be as before , we say @xmath267 is _ sparse _ if there exists a constant @xmath138 ( possibly dependent on @xmath47 ) such that for all vertices @xmath7 and all @xmath298,@xmath486    [ hammingball2]if @xmath267 is drawn from @xmath261 , then @xmath267 is sparse with probability @xmath423 .    [ sparsegood2]if @xmath267 is sparse , then for every @xmath487,@xmath447   \\right ]   = o\\left (   \\frac{n^{1/d}\\log n}{l}\\right )   , \\ ] ] where the big-@xmath488 hides a constant dependent on @xmath47 .",
    "the proofs of lemmas [ hammingball2 ]  and [ sparsegood2 ]  are omitted from this abstract , since they involve no new ideas beyond those of lemmas [ hammingball ] and [ sparsegood ] .",
    "taking @xmath489  we get , by the same proof as for theorem [ boolean ] :    [ grid]neglecting a constant dependent on @xmath47 , for all @xmath3@xmath490",
    "i thank andris ambainis for suggesting an improvement to proposition [ upper ] ; david aldous , christos papadimitriou , yuval peres , and umesh vazirani for discussions during the early stages of this work ; and ronald de wolf and the anonymous reviewers for helpful comments .",
    "e. farhi , j. goldstone , s. gutmann , j. lapan , a. lundgren , and d. preda .",
    "a quantum adiabatic evolution algorithm applied to random instances of an np - complete problem , _ science _ 292:472476 , 2001 .",
    "quant - ph/0104129 ."
  ],
  "abstract_text": [
    "<S> the problem of finding a local minimum of a black - box function is central for understanding local search as well as quantum adiabatic algorithms .  for functions on the boolean hypercube @xmath0 </S>",
    "<S> , we show a lower bound of @xmath1 on the number of queries needed by a quantum computer to solve this problem .  </S>",
    "<S> more surprisingly , our approach , based on ambainis s quantum adversary method , also yields a lower bound of @xmath2 on the problem s _ classical _ randomized query complexity .  </S>",
    "<S> this improves and simplifies a 1983 result of aldous .  finally , in both the randomized and quantum cases </S>",
    "<S> , we give the first nontrivial lower bounds for finding local minima on grids of constant dimension @xmath3 . </S>"
  ]
}