{
  "article_text": [
    "polar codes , invented by arikan @xcite , are the first provably capacity - achieving codes with low encoding and decoding complexity .",
    "arikan s presentation of polar codes includes a successive cancellation decoding algorithm , which generally does not perform as well as the state - of - the - art error - correcting codes at finite block lengths  @xcite . to improve the performance of polar codes , tal and vardy @xcite devised a list decoding algorithm .",
    "the initial work of arikan considers binary symmetric memoryless channels .",
    "there have been attempts to study polar codes for other channels , e.g. , the awgn channel  @xcite . however , there are not many constructions of polar codes for channels with memory",
    ". see @xcite and references therein .",
    "the deletion channel is a canonical example of a non - stationary , non - ergodic channel with memory .",
    "it deletes symbols arbitrarily and the positions of the deletions are unknown to the receiver . a survey by mitzenmacher  @xcite discusses the major developments in the understanding of deletion channels in greater detail .",
    "to date , the shannon capacity of deletion channels , in general , remains unknown .",
    "however , there have been attempts to find upper and lower bounds on the capacity of deletion channels @xcite .",
    "our motivation is partly the work of dolecek and anantharam  @xcite , in which the run length properties of reed - muller ( rm ) codes were exploited to correct a certain number of substitutions together with a _",
    "deletion ; our work involves correcting _ erasures _ rather than substitiutions .",
    "rm codes and polar codes have similar algebraic structures and therefore polar codes are also potential candidates for correcting single deletions .",
    "however , they can not be used directly on deletion channels since the polarization of a channel with memory has not been well - studied .",
    "developing polarization techniques for deletion channels is beyond the scope of this study . instead , motivated by decoders that are possibly defective and delete symbols arbitrarily , we consider polar codes over a binary erasure channel ( bec ) and an adversarial version of the deletion channel with one deletion , and provide a list decoding algorithm to successfully recover the original message with high probability as the blocklength of the code @xmath1 tends to infinity . ]",
    "( w.h.p . ) .",
    "unlike rm codes , polar codes do not have rich run length properties .",
    "instead , we use the successive cancellation algorithm  @xcite for decoding . in addition , we provide a detailed analysis of the error probability , which was lacking in @xcite .",
    "channel cascades were studied previously in @xcite but our model has not been previously considered in the literature .",
    "we argue that the capacity of the cascade can be achieved ; in constrast , @xcite does not discuss capacity issues .",
    "[ sec : prelim ]      [ sec : twoa ] we consider polar codes of length @xmath2 constructed recursively from the kernel @xmath3 .",
    "given an information vector ( message ) @xmath4 where @xmath5 , a codeword @xmath6 is generated using the relation @xmath7 where @xmath8 is the @xmath9-th kronecker product of @xmath10 and @xmath11 is a bit - reversal permutation matrix , defined explicitly in @xcite .",
    "the vector @xmath6 is transmitted through @xmath1 independent copies of a binary discrete memoryless channel ( bdmc ) @xmath12 with transition probabilities @xmath13 and capacity @xmath14 .",
    "as @xmath9 grows , the individual channels start polarizing .",
    "that is , a subset of the channels tend to noise - free channels and others tend to completely noisy channels .",
    "the fraction of noise - free channels tends to the capacity @xmath14 .",
    "the polarization behavior suggests using the noise - free channels to transmit information bits , while setting the inputs to the noisy channels to values that are known _ a priori _ to the decoder ( i.e. , the frozen bits ) .",
    "that is , a message vector @xmath15 consists of information bits and frozen bits ( often set to zero ) where @xmath16 of size @xmath17 is the information set and @xmath18 is the set of frozen bits .",
    "this scheme achieves capacity  @xcite .",
    "denote the channel output by @xmath19 and the @xmath20-th synthesized subchannel with input @xmath21 and output @xmath22 by @xmath23 for @xmath24 .",
    "the transition probability matrix @xmath23 is defined as @xmath25 where @xmath26 and @xmath7 is the codeword corresponding to the message @xmath15 .",
    "the encoding complexity of polar coding is @xmath27  @xcite .",
    "arikan @xcite proposed a successive cancellation ( sc ) decoding scheme for polar codes .",
    "given @xmath28 and the estimates @xmath29 of @xmath30 , the sc algorithm estimates @xmath21 .",
    "the following logarithmic likelihood ratios ( llr ) are used to estimate each @xmath21 for @xmath31 : @xmath32 the estimate of an unfrozen bit @xmath21 is determined by the signs of the llrs , i.e. , @xmath33 if @xmath34 and @xmath35 otherwise .",
    "it is known that polar codes with sc decoding achieve capacity with decoding complexity of @xmath27 @xcite .",
    "we suppose that @xmath1 bits are sent over a channel and exactly @xmath36 bits are deleted .",
    "we call this a _ @xmath36-deletion channel_. that is , for @xmath1 bits sent , the decoder only receives @xmath37 bits after @xmath36 deletions and the positions of deletions are not known to the receiver .",
    "note that this is not the probabilistic deletion channel in which each symbol is independently deleted with some fixed probability @xmath38  @xcite .",
    "consider the _ 1-deletion channel _",
    "( @xmath39 in the definition in section  [ sec : adv ] ) , where exactly one bit is deleted .",
    "we suppose that @xmath2 where @xmath40 .",
    "a message vector @xmath15 is encoded using the polar encoder and is sent across @xmath1 uses of a bec @xmath41 , each with erasure probability @xmath42 .",
    "the output vector is passed through a 1-deletion channel @xmath43 .",
    "we denote this cascade of @xmath44 and @xmath45 as @xmath46 and call this a _",
    "bec-1-deletion cascade_. this model is shown in fig .  [ model ] .",
    "the output of @xmath46 is denoted as @xmath47 .",
    "note that @xmath46 permits erasures and a single deletion .",
    "that is , a message @xmath15 is sent across @xmath46 and a vector @xmath47 is received .",
    "a decoder is designed in such a way that w.h.p . , a list @xmath48 ( of linear size in @xmath1 ) containing an estimate @xmath49 of the original message @xmath15 is returned .",
    "( 210 , 60 ) ( 3,54 ) ( 98,54 ) ( 98,14 ) ( 3,14 ) ( 190,30 )    ( 48,48 ) ( 48,8 )    ( 138,48 ) ( 138,8 )    ( 5,50)(1,0)40 ( 45,60)(1,0)40 ( 45,40)(1,0)40 ( 45,40)(0,1)20 ( 85,40)(0,1)20    ( 85,50)(1,0)40 ( 125,60)(1,0)40 ( 125,40)(1,0)40 ( 125,40)(0,1)20 ( 165,40)(0,1)20    ( 165,50)(1,0)20 ( 185,50)(0,-1)40 ( 185,10)(-1,0)20 ( 125,20)(1,0)40 ( 125,00)(1,0)40 ( 125,00)(0,1)20 ( 165,00)(0,1)20    ( 125,10)(-1,0)40 ( 45,20)(1,0)40 ( 45,00)(1,0)40 ( 45,00)(0,1)20 ( 85,00)(0,1)20 ( 45,10)(-1,0)40",
    "a message @xmath15 is sent over a bec-1-deletion cascade using a polar encoder described in section  [ sec : twoa ] and @xmath47 is received . in order to decode @xmath47",
    ", we use the sc algorithm ( refer to section  [ sec : twob ] ) .",
    "since the position of the deletion is unknown , we first identify a set of vectors , called the _",
    "candidate set _ , which contains @xmath47 as a sub - sequence .",
    "a nave algorithm to construct the candidate set would be to insert @xmath50 in the @xmath1 locations before and after each symbol of @xmath47 .",
    "we then apply the sc algorithm to each vector in the candidate set .    for example , suppose @xmath51 and the received vector is @xmath52 .",
    "then the following set @xmath53 includes all vectors which contain the subsequence @xmath54 : @xmath55 the size of this set can be further reduced if we notice that inserting @xmath56 at @xmath1 positions is enough to identify all possible messages those can output @xmath47 after a single deletion .",
    "this is because of the following : suppose the @xmath20-th symbol is deleted from @xmath28 . instead of inserting 0 or 1 at position @xmath20 , we insert an erasure symbol @xmath56 . since a polar code correcting @xmath57 ( where @xmath58 ) erasures also corrects @xmath59 erasures w.h.p .",
    ", under the sc decoding algorithm , this new length-@xmath1 vector decodes to the correct message w.h.p .",
    "no matter which symbol was at position @xmath20 .",
    "we state this observation formally :    [ pro : cand ] suppose @xmath15 is sent over a bec-1-deletion cascade @xmath60 .",
    "( see fig .",
    "[ model ] . )",
    "the size of the candidate set @xmath61 ( constructed above ) is @xmath62 where @xmath63 is the number of erasures present in the received string @xmath47 .",
    "the candidate set is @xmath64 where @xmath47 is the received string .",
    "suppose that the @xmath65-th symbol of @xmath47 is @xmath56 .",
    "inserting another @xmath56 before the @xmath65-th symbol @xmath56 forms vector @xmath66 .",
    "this vector repeats if we insert @xmath56 again after the the @xmath65-th symbol @xmath56 .",
    "therefore , considering non - erasure bits of @xmath47 and inserting exactly one erasure symbol @xmath56 at positions before and after these non - erasure bits produces unique vectors in the candidate set @xmath61 .",
    "since the number of erasure symbols is @xmath63 , the total number of vectors in @xmath61 is @xmath62 .",
    "we remark that as @xmath67 , by the law of large numbers @xmath68 and hence @xmath69 where @xmath70 is the erasure probability of the bec .",
    "after the construction of the set @xmath61 , the problem reduces to the decoding of each vector in @xmath61 using the sc algorithm .",
    "since @xmath71 , we get a list of messages of size at most @xmath62 at the end of the whole decoding procedure .",
    "let @xmath72 denote the sc decoding of @xmath28 , and define @xmath73 as the list of messages returned by the set @xmath61 where @xmath74 is the information set .",
    "since we insert the erasure symbol @xmath56 at each of the @xmath1 possible positions ( including the deleted position ) , the original message sent belongs to @xmath48 w.h.p .",
    "arikan  @xcite proved that the probability of error @xmath75 vanishes asymptotically for polar codes over any bdmc .",
    "a more precise estimate was provided by arikan and telatar  @xcite who showed that for any @xmath76 , @xmath77 for sufficiently large block lengths @xmath1 .",
    "therefore , under sc decoding , vectors in @xmath61 return all possible messages that can produce the string @xmath47 under a single ( adversarial ) deletion .",
    "naturally , there can be multiple @xmath78 that belong to the list @xmath48 and it may not be easy to single out the original message .",
    "however , by applying a simple pre - coding technique using an @xmath79-bit crc ( or a code having an @xmath80 parity check matrix ) @xcite , the original message can be detected from the list , albeit with some additional probability of error .",
    "we describe how to recover the correct message w.h.p .  here .",
    "recall that we have @xmath81 frozen bits that we usually set to zero . instead of setting all of them to zero",
    ", we set @xmath82 frozen bits to zero , where @xmath79 is a small number we optimize in section  [ sec : analysis ] . these @xmath79 bits will contain the @xmath79-bit crc value of the @xmath17 unfrozen bits ( or simply the parity bits ) . to generate a @xmath79-bit crc",
    ", we select a polynomial of degree @xmath79 , called a _",
    "crc polynomial _ , having @xmath83 coefficients .",
    "we then divide the message ( by treating it as a binary polynomial ) by this crc polynomial to generate a remainder of degree at most @xmath84 , with total number of coefficients @xmath79 .",
    "we append these @xmath79 coefficients at the end of the @xmath17-bit message to generate a @xmath85-bit vector . to verify that the correct message is received , we perform the polynomial division again to check if the remainder is zero . for more details on the choice of crc polynomials",
    ", please refer to @xcite .",
    "we send these @xmath86 bits across the cascade .",
    "this new encoding is a slight variation the original polar coding scheme @xcite .",
    "also , note that the original information rate @xmath87 is preserved .",
    "however , the rate of the polar code is slightly increased to @xmath88 .    to summarize",
    ", we encode the message @xmath89 of length @xmath17 into a length @xmath86 vector @xmath90 having redundancy @xmath79 where @xmath91 .",
    "then we apply the polar coding scheme for the codebook @xmath92 .",
    "this will result in a polar code @xmath93 of length @xmath1 and size @xmath94 where only the subset @xmath95 carries information that we wish to transmit .",
    "the codeword @xmath96 corresponding to the original message @xmath97 is then passed through the bec-1-deletion channel and outputs a vector @xmath98 . after constructing the set @xmath61 by inserting @xmath99 at each possible @xmath1 positions ,",
    "we apply the sc algorithm on @xmath61 . however , not all of these resulting vectors in @xmath93 carry information",
    ". we can check this using the initial @xmath79-bit crc ( or the parity check matrix ) .",
    "all vectors which fail under the crc check are removed and we then select the message with the maximum likelihood from the list .",
    "suppose @xmath100 denotes the @xmath101 parity check matrix with rows @xmath102 that is being used for adding parity to the @xmath17 bit message .",
    "then the set of messages that carries any information can be identified as @xmath103 where @xmath104 is the modified version of ( [ eq : listl ] ) according to the new polar coding scheme defined as @xmath105 and where @xmath106 is the set of parity bits ( @xmath18 is the set of frozen bits ) . if the rows of @xmath100 are chosen uniformly and independently from @xmath107 , the probability that a vector @xmath89 is in @xmath108 is @xmath109 where @xmath110 .",
    "that is , a message in @xmath104 is wrongly identified as the original message with probability @xmath111 .",
    "however , the true message sent satisfies the parity - check condition @xmath112 .",
    "therefore , by the union bound , the total probability that an incorrect message is returned is upper bounded as @xmath113 where @xmath75 is the probability of error of the sc decoding algorithm and @xmath114 for a single deletion .    to maintain that @xmath115 ( that is , as the block length @xmath1 grows , @xmath116 converges to @xmath117 ) and the upper bound on @xmath118 in ( [ eq : err ] ) is minimized , we have to choose @xmath79 carefully .",
    "for a single deletion , the size of the candidate set @xmath119 and hence @xmath120 w.h.p . from hassani _ et al . _",
    "@xcite , the rate - dependent error probability of the polar code for the bec with rate @xmath116 is @xmath121 where @xmath2 , @xmath122 is the complementary gaussian cumulative distribution function , and @xmath123 is the capacity of the channel cascade .    from ( [ eq : err ] ) , @xmath124\\label{eqn : two_terms } . \\ ] ] it can be verified easily that the first term in the square parentheses in is decreasing and the second term with @xmath125 is increasing in @xmath79 . to optimize the upper bound in",
    ", we set the exponents of two terms to be equal ( neglecting the insignificant @xmath126 term ) , i.e. , @xmath127 where we used the fact that @xmath2 .",
    "now we find an expression for @xmath79 in terms of the backoff from capacity . to transmit the code at a rate close to the capacity , for a small constant @xmath128 , assume that",
    "@xmath129 where @xmath130 since a polar code over the bec 1-deletion cascade achieves the capacity of the bec ; this is a simple consequence of  ( * ? ? ?",
    "* problem  3.14 ) and the fact that the list size is polynomial .",
    "then the rate @xmath131 for @xmath1 large enough .",
    "therefore , @xmath132 let @xmath133 . since @xmath134 , @xmath135 .",
    "then @xmath136 and hence @xmath137 .",
    "since @xmath138 decays as @xmath139 as @xmath140 , @xmath141",
    ". then @xmath142 .",
    "therefore , the optimal value of the number of parity bits @xmath79 is @xmath143 this is a rate - dependent choice of @xmath79 ( through @xmath144 ) that simultaneously ensures that @xmath145 and the upper bound on @xmath118 in ( [ eq : err ] ) is minimized .",
    "now consider the cascade of a bec and a @xmath36-deletion channel where @xmath146 is finite .",
    "this model can be analyzed using the same techniques presented here .",
    "the only difference is the size of the candidate set @xmath61 . by using the same arguments as in the @xmath147-deletion case ,",
    "we construct @xmath61 by inserting erasure symbols at @xmath36 positions and @xmath148 . therefore , the list size @xmath149 .",
    "since the models are similar , a crc construction and error probability analysis for the bec-@xmath36-deletion cascade similar to that presented in sections  [ sec : crc ] and  [ sec : analysis ] respectively can be performed .",
    "in addition , we see that even if the list size is @xmath150 , the capacity of the bec is achieved because @xmath151 is still subexponential .",
    "the encoding complexity of the bec-1-deletion cascade is same as that for standard polar codes , i.e. , @xmath152 .",
    "however , the sc decoding algorithm has to be applied to all vectors in the candidate set @xmath61 of size @xmath62 ( cf .",
    "[ pro : cand ] ) .",
    "thus , the complexity of the decoding algorithm of the bec-1-deletion cascade is @xmath153 and that for the bec-@xmath36-deletion cascade is @xmath154 .",
    "although the complexity of the decoding algorithm increases by @xmath155 for each additional deletion , it can still be performed in polynomial time .",
    "in this section , we demonstrate the utility of the proposed algorithm by performing numerical simulations .",
    "the simulations are carried out in matlab using code provided in  @xcite with the following parameters .",
    "let @xmath156 vary from @xmath157 to  @xmath158 .",
    "the erasure probability of the bec is @xmath159 .",
    "thus , the capacity of the cascade is @xmath160 .",
    "we consider three different code rates : @xmath161 and @xmath162 .",
    "we fix @xmath163 and the @xmath79-bit crc polynomial is chosen according to  @xcite .",
    "the error probability is computed by averaging over @xmath164 independent runs .",
    "we encode a random length-@xmath165 message using a @xmath79-bit crc polynomial so that the input of the encoder is a @xmath166 length input vector and the output is an @xmath1-bit vector .",
    "this vector is then transmitted through a bec-1-deletion cascade and received a length-@xmath167 vector .",
    "the crc list decoder then computes a list of possible messages given the channel output .",
    "[ fig : errprob ] shows that , with a suitable choice of the number of crc bits @xmath79 and crc polynomials , as @xmath1 grows , the list is of size @xmath147 and contains only the original message w.h.p .",
    "1 e. arikan ,  channel polarization : a method for constructing capacity - achieving codes for symmetric binary - input memoryless channels \" , _ ieee trans .",
    "inform . theory _",
    "55 , no . 7 , pp . 3051 - 3073 , jul 2009 .",
    "s. h. hassani , k. alishahi and r. l. urbanke ,  finite - length scaling for polar codes \" , _ ieee trans .",
    "inform . theory _",
    "5875 - 5898 , oct 2014 .",
    "i. tal and a. vardy ,  list decoding of polar codes \" , _ ieee trans .",
    "inform . theory _",
    "2213 - 2226 , may 2015 .",
    "e. abbe and a. barron , ",
    "polar coding schemes for the awgn channel \" , _ proceedings of the isit _ , 2011 , pp .",
    "194 - 198 .",
    "r. wang , j. honda , h. yamamoto and r. liu ,  construction of polar codes for channels with memory \" , _ proceedings of the fall itw _ , jeju island , south korea , 2015 , pp .",
    "187 - 191 .",
    "m. mitzenmacher ,  a survey of results for deletion channels and related synchronization channels \" , _ probability surveys _ , vol",
    ". 6 , pp 1 - 33 , 2009 .",
    "r. venkataramanan , s. tatikonda , and k. ramchandran ,  achievable rates for channels with deletions and insertions \" , _ ieee trans .",
    "inform . theory _",
    "6990 - 7013 , nov 2013 . s. diggavi , m. mitzenmacher and h. d. pfister , ",
    "capacity upper bounds for the deletion channel \" , _ proceedings of the isit _ , 2007 ,",
    "1716 - 1720 .",
    "l. dolecek and v. anantharam ,  using reed - muller @xmath168 codes over channels with synchronization and substitution errors \" , _ ieee trans .",
    "inform . theory _",
    "1430 - 1443 , apr 2007 .",
    "a. kiely and j. coffey ,  on the capacity of a cascade of channels \" , _ ieee trans .",
    "inform . theory _",
    "1310 - 1321 , apr 1993 .",
    "k. niu and k. chen ,  crc - aided decoding of polar codes \" , _ ieee comm .",
    "1668 - 1671 , oct 2012 .",
    "p. koopman and t. chakravarty ,  cyclic redundancy code ( crc ) polynomial selection for embedded networks \" , _ international conference on dependable systems and networks _ , 2004 ,",
    "145 - 154 .",
    "s. h. hassani , r. mori , t. tanaka and r. l. urbanke ,  rate - dependent analysis of the asymptotic behavior of channel polarization \" , _ ieee trans .",
    "inform . theory _",
    "2267 - 2276 , apr 2013 .",
    "a. el gamal and y .- h .",
    "kim ,  network information theory \" , _ cambridge university press _ , 2012 .",
    "h. vangala , y. hong and e. viterbo ,  efficient algorithms for systematic polar encoding \" , _ ieee comm .",
    "17 - 20 , jan 2016 ."
  ],
  "abstract_text": [
    "<S> we study the application of polar codes in deletion channels by analyzing the cascade of a binary erasure channel ( bec ) and a deletion channel . </S>",
    "<S> we show how polar codes can be used effectively on a bec with a single deletion , and propose a list decoding algorithm with a cyclic redundancy check for this case . </S>",
    "<S> the decoding complexity is @xmath0 , where @xmath1 is the blocklength of the code . </S>",
    "<S> an important contribution is an optimization of the amount of redundancy added to minimize the overall error probability . </S>",
    "<S> our theoretical results are corroborated by numerical simulations which show that the list size can be reduced to one and the original message can be recovered with high probability as the length of the code grows .    </S>",
    "<S> draft paper    polar codes , deletions , binary erasure channel , cascade , list decoding , cyclic redundancy check , candidate set </S>"
  ]
}