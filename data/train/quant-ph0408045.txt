{
  "article_text": [
    "in many applications of quantum computers , a quantum register , composed of a fixed number of qubits , is initially prepared in some simple standard state .",
    "this initial preparation step is followed by a sequence of quantum gate operations and measurements .",
    "there are applications of quantum computers , however , notably the task of simulating the dynamics of a physical system @xcite , that may require the initialization of a quantum register in a more general state , corresponding to the initial physical state of the simulated system .",
    "this leads naturally to the question of what quantum states can be efficiently prepared on a quantum register .",
    "the memory of a classical computer can be easily put into any state by writing an arbitrary bit string into it .",
    "the situation for quantum computers is very different .",
    "the hilbert space associated with a quantum register composed of as few as 100 quantum bits ( qubits ) is so large that it is impossible to give a classical description of a generic state vector , i.e. , to list the @xmath0 complex coefficients defining it . in this sense",
    "it can be said that arbitrary pure states can not be prepared @xcite .",
    "it is nevertheless possible to formulate the problem of arbitrary state preparation for a register of qubits in a meaningful way .",
    "this is achieved by starting from the assumption that the state is initially defined by a set of quantum _ oracles_. by assuming that the state is given in this form , we shift the focus from the problem of describing the state to the problem of the computational resources needed to actually prepare it .",
    "in other words , we address the computational complexity rather than the algorithmic complexity of the state .",
    "for the purpose of quantifying these computational resources , we simply count the number of oracle calls .",
    "we are thereby deliberately ignoring the internal structure of the oracles and the computational resources needed in each oracle call .",
    "the algorithm we describe here is applicable to any set of oracles , i.e. , to any state .",
    "we will show that it is _ efficient _ for a large class of states of particular interest for the simulation of physical systems .",
    "let @xmath1 be a positive integer .",
    "we will describe a quantum algorithm for preparing a @xmath2-qubit quantum register in an approximation to the state @xmath3 and arbitrary phases @xmath4 .",
    "here and throughout the paper , @xmath5 denote computational basis states .",
    "more precisely , given any small positive numbers @xmath6 and @xmath7 , our algorithm prepares the quantum register in a state @xmath8 such that , with probability greater than @xmath9 , the fidelity obeys the bound latexmath:[\\[\\label{eq : fidelitybound }     to define the algorithm and to assess its efficiency for large @xmath1 , we need to specify in which form the coefficients @xmath11 and @xmath4 are given .",
    "we assume that we are given classical algorithms to compute the functions @xmath11 and @xmath4 for any @xmath12 .",
    "these classical algorithms are used to construct a set of quantum _",
    "oracles_. we will quantify the resources needed by our state preparation algorithm in terms of ( i ) the number of oracle calls , ( ii ) the number of additional gate operations , and ( iii ) the number of auxiliary qubits needed in addition to the @xmath13 register qubits .    to analyze the asymptotic , large @xmath1 , behavior of our algorithm , we consider a sequence of probability functions @xmath14 $ ] , @xmath15 , and a sequence of phase functions @xmath16 $ ] , where @xmath17 . for any @xmath1",
    ", the algorithm prepares the quantum register in a state @xmath8 such that , with probability greater than @xmath9 , the fidelity obeys the bound ( [ eq : fidelitybound ] ) , where in the definition  ( [ eq : psi ] ) of @xmath18 the functions @xmath19 and @xmath20 are replaced by @xmath21 and @xmath22 , respectively . under the assumption that there exists a real number @xmath23 , @xmath24 , such that @xmath25 we show that the resources needed by our state preparation algorithm are polynomial in the number of qubits , @xmath26 , and the inverse parameters @xmath27 , @xmath28 and @xmath29 .",
    "an obvious example of a sequence of functions that do not satisfy the bound  ( [ eq : etabound ] ) and for which the resources required for state preparation scale exponentially with the number of qubits is given by @xmath30 for some integer @xmath31 . in this case",
    ", it follows from the optimality of grover s algorithm @xcite that the number of oracle calls needed is proportional to @xmath32 .",
    "sequences that do satisfy the bound  ( [ eq : etabound ] ) arise naturally in the problem of encoding a bounded probability density function @xmath33\\to[0,f_{\\rm max}]$ ] in a state of the form @xmath34 where @xmath35 is a normalization factor .",
    "grover and rudolph have given an efficient algorithm for this problem if the function @xmath36 is efficiently integrable @xcite .",
    "essentially the same algorithm was found independently by kaye and mosca @xcite , who also mention that phase factors can be introduced using the methods discussed in ref .",
    "recently , rudolph @xcite has found a simple nondeterministic state - preparation algorithm that is efficient for all sequences satisfying the bound  ( [ eq : etabound ] ) .    for general sequences of states satisfying the bound ( [ eq : etabound ] ) , a given value of the fidelity bound @xmath6 , and assuming polynomial resources for the oracles , our algorithm is exponentially more efficient than the algorithm proposed by ventura and martinez @xcite and later related proposals @xcite , for which the resources needed grow like @xmath37 .",
    "the use of grover s algorithm for state preparation has been suggested by zeng and kuang for a special class of coherent states in the context of ion - trap quantum computers @xcite .",
    "a general analysis of the state preparation problem in the context of adiabatic quantum computation was given by aharonov and ta - shma @xcite .",
    "this paper is organized as follows . in sec .",
    "[ sec : algorithm ] we give a full description of our algorithm .",
    "a detailed derivation is deferred to sec .",
    "[ sec : derivation ] .",
    "the algorithm depends on a number of parameters that can be freely chosen . in sec .",
    "[ sec : fidelity ] we consider a particular choice for these parameters and show that it guarantees the fidelity bound  ( [ eq : fidelitybound ] ) .",
    "we use the same choice of parameters in sec .",
    "[ sec : resources ] to derive worst case bounds on the time and the memory resources required by the algorithm . in sec .",
    "[ sec : conclusions ] we conclude with a brief summary .",
    "our algorithm consists of two main stages . in the first stage , the algorithm prepares the register in an approximation to the state @xmath38 which differs from @xmath18 only in the phases @xmath4 .",
    "more precisely , let @xmath39 be the largest small parameter such that @xmath40 and @xmath41 is an integer .",
    "the first stage of the algorithm prepares the register in a state @xmath42 such that , with probability greater than @xmath9 , we have that latexmath:[\\[\\label{thefidelitybound }    describe the details of the first stage below .",
    "the second stage of the algorithm adds the phases @xmath4 to the state @xmath44 resulting from the first stage .",
    "this can be done in a straightforward way as follows .",
    "we start by choosing a small parameter @xmath45 such that @xmath46 is a positive integer .",
    "we then define a list of unitary operations , @xmath47 , on our quantum register by @xmath48 the operators @xmath49 are conditional phase shifts that can be realized as quantum gate sequences using the classical algorithm for computing the function @xmath4 @xcite .",
    "if we apply the operators @xmath49 sequentially to the result of the first stage , we obtain @xmath50 where the function @xmath51 satisfies the inequality @xmath52 for all @xmath12 . it can be shown ( see section  [ sec : stage2fidelity ] ) that together with eq .",
    "( [ thefidelitybound ] ) this implies the bound @xmath53 .",
    "notice the slight abuse of notation identifying the parameter @xmath6 in the inequality  ( [ eq : fidelitybound ] ) with the sum @xmath54 in the inequality  ( [ eq : properfidelitybound ] ) .",
    "we now proceed to a more detailed description of the first stage of the algorithm . from now on we assume that @xmath1 is an integer power of 2 .",
    "this can always be achieved by padding the function @xmath11 with zeros .",
    "given our choice of the parameter @xmath39 , eq .",
    "( [ eq : epsilonbound ] ) , we define a list of _ oracles _ , @xmath55 , by @xmath56 we extend this definition beyond the domain of the function @xmath19 by setting @xmath57 for @xmath58 . using the classical algorithm to compute @xmath11 , one can construct quantum circuits implementing the unitary oracles @xmath59 these circuits are efficient if the classical algorithm is efficient .",
    "the list of oracles @xmath60 defines a new function @xmath61 via @xmath62 where @xmath63 by convention .",
    "the situation is illustrated in fig .",
    "[ figure1 ] , where the @xmath12 values have been permuted for clarity .",
    "knowledge of this permutation is not required for our algorithm .",
    "the essence of the first stage of the algorithm consists in using a number of grover iterations based on the oracles @xmath64 to prepare the register in an approximation to the state @xmath65 reflects the fact that @xmath61 may not be normalized . to find the number of required grover iterations for each oracle @xmath64",
    ", we need an estimate of the number of solutions , @xmath66 , for each oracle , defined by @xmath67 this estimate can be obtained from running the quantum counting algorithm @xcite for each oracle @xmath64 .",
    "we denote the estimates obtained in this way by @xmath68 .",
    "the accuracy of the estimate @xmath69 relative to @xmath66 can be characterized by two real parameters , @xmath70 and @xmath71 , in such a way that , as a result of quantum counting , with probability greater than @xmath9 we have @xmath72 for each oracle , @xmath73 , the resources needed to achieve the counting accuracy specified by @xmath74 and @xmath7 depend on the actual number of solutions @xmath66 .",
    "this dependence is important for optimizing the performance of our algorithm . in this paper , however , we present a simpler analysis assuming worst case conditions for each oracle @xmath73 . for this analysis we use a specific choice of @xmath74 , which is given by eq .",
    "( [ eq : worstcase ] ) .",
    "the analysis of the algorithm is simplified if we concentrate on a subset of oracles , @xmath75 where @xmath76 and the indices @xmath77 are determined by the construction below .",
    "we introduce a new parameter @xmath78 ( see eq .",
    "( [ eq : worstcase ] ) below ) such that @xmath79 . the index @xmath80 is defined to be the smallest integer such that @xmath81 and , for @xmath82 , the index @xmath83 is the smallest integer such that @xmath84 the number @xmath76 is the largest value of @xmath85 for which these inequalities can be satisfied .",
    "the effect of eq .",
    "( [ eq : ignorepeak ] ) is to neglect narrow peaks ( corresponding to small values of @xmath86 in fig .",
    "[ figure1 ] ) .",
    "equation  ( [ eq : increasing ] ) makes sure that the numbers @xmath87 form an increasing sequence even if , due to counting errors , the estimates @xmath68 do not ( see fig .",
    "[ figure1 ] ) .    for @xmath88 ,",
    "define @xmath89 , @xmath90 and @xmath91 where we define @xmath92 . for every oracle @xmath93 , the value of @xmath94 is an approximation to the number of solutions , @xmath95 ,",
    "satisfying the bound @xmath96    in what follows it will be convenient to introduce the notation @xmath97 the oracles @xmath93 define a new function @xmath98 via @xmath99 where @xmath100 by convention .",
    "the function @xmath101 is a decreasing step function , with step sizes @xmath102 which are multiples of @xmath103 .",
    "the widths of the steps are given by the numbers @xmath95 which are determined by the oracles ( see fig .  [ figure1 ] ) .",
    "the algorithm can now be completely described as follows .",
    "choose a suitable ( small ) number , @xmath104 , of _ auxiliary qubits _",
    "( see eq .",
    "( [ eq : worstcase ] ) below ) , and define @xmath105 . for @xmath88 , find the quantities @xmath106 @xmath107 @xmath108 and @xmath109 for @xmath88 , define the grover operator @xmath110 where @xmath111 @xmath112 is the @xmath113-qubit identity operator , @xmath114 , and where the domain of the oracles @xmath93 is extended to the range @xmath115 by setting @xmath116 if @xmath117 .",
    "prepare a register of @xmath113 qubits in the state @xmath118 , then apply the grover operators successively to create the state latexmath:[\\[\\label{eq : psit }    now measure the @xmath104 auxiliary qubits in the computational basis .",
    "if all @xmath104 outcomes are @xmath120 this stage of the algorithm is successfully prepares the desired state eq .",
    "( [ eq : psiptilde ] ) .    if one of the measurements of the auxiliary qubits returns 1 , this stage of the algorithm has failed , and one has to start again by preparing the register in the state @xmath118 as in eq .",
    "( [ eq : psi0 ] ) . assuming the choice of parameters in eq .",
    "( [ eq : worstcase ] ) , the probability , @xmath121 , that the algorithm fails in this way satisfies the bound @xmath122 ( see eq .",
    "( [ thefailureprobability ] ) ) .    before we provide detailed proofs of the above",
    "claims it is helpful to give a hint of how this stage of the algorithm achieves its goal .",
    "the algorithm aims at constructing the function @xmath123 which is close to the function @xmath124 defined in eq .",
    "( [ eq : pdoubleprime ] ) . the sequence of grover operators in eq .",
    "( [ eq : psit ] ) creates a step function that is close to @xmath101 ( see fig .",
    "[ figure1 ] ) .",
    "in particular each operator @xmath125 in eq .",
    "( [ eq : psit ] ) creates a step with the correct width @xmath95 and a height @xmath126 which is close to the target height @xmath127 . due to a remarkable property of grover s algorithm  @xcite , once the features @xmath128 have been developed they are not distorted by @xmath125 which develops @xmath126 . in this way the algorithm proceeds building feature after feature until it constructs all @xmath76 of them . at the end , because of the inherent errors , the auxiliary qubits end up having small amplitudes for nonzero values .",
    "measuring them projects the auxiliary qubits onto the zero values with a probability that can be made arbitrarily close to 1 .",
    "this also slightly changes the features @xmath126 due to renormalization of the state after the measurement , which we take into account when we estimate the overall loss of fidelity .",
    "in section  [ sec : algorithm ] we have already explained the second stage of our algorithm . here",
    "we present a detailed explanation of the first stage .",
    "this section is organized as follows . in subsection  [ subsecbiham ]",
    "we review some properties of the grover operator introducing our notation as we go along . in subsection  [ subseconestep ]",
    "we introduce a convenient mathematical form for analyzing intermediate quantum states visited by the algorithm . and finally , in subsection  [ subsec : t_and_h ] we derive the values  ( [ eq : t_k ] ) of the times @xmath129 used in our algorithm .",
    "we will be using the following result  @xcite .",
    "consider an oracle @xmath130 , which accepts @xmath131 values of @xmath12 ( out of the total of @xmath132 , i.e. , @xmath133 ) .",
    "we shall call such values of @xmath12 _ good _ , as opposed to _ bad _ values of @xmath12 that are rejected by the oracle . using different notation for the coefficients of good and bad states",
    ", we have that after @xmath134 grover iterations an arbitrary quantum state @xmath135 is transformed into @xmath136 let @xmath137 and @xmath138 be the averages of the initial amplitudes of the good and the bad states respectively : @xmath139 and similarly for the final amplitudes @xmath140 let us also define @xmath141 in other words , @xmath142 and @xmath143 define the _ features _ of the initial amplitude functions @xmath144 and @xmath145 relative to their averages @xmath137 and @xmath138 .",
    "biham _ et .",
    "al . _ have shown that the change of the amplitudes is essentially determined by the change of the averages : @xmath146 where the averages @xmath147 and @xmath148 are given as follows .",
    "define @xmath149 the averages are given by @xmath150 we shall also use the separations , @xmath151 and @xmath152 , of the averages @xmath153 directly from the definition we obtain @xmath154 where the phase @xmath155 can be found from @xmath151 , @xmath156 in our applications we will only need the case when the initial amplitude of the bad states is flat , i.e.  @xmath157 . in this case , the amplitude of the bad states always remains flat @xmath158    this fact and the fact that the initial features , @xmath159 , of the amplitude of the good states are preserved , @xmath160 see  ( [ bihamequations ] ) , is crucial for understanding the rest of this paper .",
    "the preparation stage of our algorithm summarized in eq .",
    "( [ eq : psit ] ) gives rise to a sequence of states defined by @xmath161 be the set of solutions to the oracle @xmath93 : @xmath162 for @xmath163 , these states can be written in the form @xmath164 where @xmath165 since @xmath166 is real and positive , the value of @xmath166 can be determined from the normalization condition @xmath167 .",
    "the action of the algorithm can be visualized as shown in fig .",
    "[ unfinishedstateprep ] , which shows the result of the first three iterations .",
    "the integers @xmath95 [ defined in eq .  (",
    "[ eq : definenk ] ) ] are the number of good values of @xmath12 according to oracle @xmath93 .",
    "we see that each operation @xmath125 prepares a feature of height @xmath168 .",
    "it follows from the conclusions of section  [ subsecbiham ] that once such a feature is developed , its height remains constant throughout the computation .      in this subsection",
    "we show how the times @xmath129 are related to the corresponding features @xmath126 .",
    "the normalization condition @xmath167 reads @xmath169 substituting ( [ a_jk ] ) , this gives us a quadratic equation for @xmath166 : @xmath170 where we define @xmath171 and @xmath172 solving this equation , and using the fact that @xmath173 , we obtain @xmath174 this formula together with eq .",
    "( [ a_jk ] ) provide an explicit expression ( [ psikminusone ] ) for @xmath175 in terms of the numbers @xmath176 and @xmath177 .    to build the @xmath85th feature",
    ", we apply the grover operator @xmath125 to the state @xmath178",
    ". we will now derive an expression for the integer `` time '' @xmath129 in terms of the features @xmath179 and the widths @xmath180 .",
    "given @xmath178 as an initial state , let us define @xmath181 and @xmath182 to be the initial average amplitudes of the good and the bad states according to the oracle  @xmath93 : @xmath183 @xmath184    the initial separation , @xmath185 , between the good and the bad averages is therefore @xmath186 observe that developing a new feature of height @xmath126 is equivalent to increasing the initial separation @xmath185 by @xmath126 .",
    "the final separation ( after @xmath129 steps ) between the good and bad averages is therefore @xmath187 using ( [ delta0 ] ) and ( [ delta_tk ] ) together with  ( [ deltat ] ) , we therefore have @xmath188 where @xmath189 and @xmath190    to achieve a good fidelity between the state @xmath191 that we actually prepare and our `` target '' state @xmath192 , we want the features @xmath126 to be as close as possible to the target values @xmath127 defined in eq .",
    "( [ deltas ] ) .",
    "this motivates the formulas  ( [ eq : alpha_k][eq : t_k ] ) for @xmath129 which are obtained from the formulas  ( [ delta0][eq : alpha_ksquared ] ) by ( i ) replacing the features @xmath126 by the targets @xmath127 , ( ii ) replacing the widths @xmath95 by the measured values @xmath94 , and ( iii ) by rounding to the nearest integer .",
    "in the above description of the algorithm , we have not specified how to choose the parameters @xmath74 , @xmath78 and @xmath104 as a function of @xmath39 ( or , alternatively , of the initially given parameters @xmath6 and @xmath23 ) .",
    "the optimal choice for these parameters depends on the estimates @xmath193 obtained in the quantum counting step . in this section",
    "we provide a rather generous worst case analysis which shows that the choice @xmath194 guarantees , with probability greater than @xmath9 , the fidelity bound latexmath:[\\[\\label{eq : realfidelitybound }    valid for arbitrary values of the @xmath68 . in most actual applications , much larger values of the accuracy parameters @xmath39 , @xmath78 and @xmath74 will be sufficient to guarantee this fidelity bound .",
    "we now show that eq .",
    "( [ eq : t_k ] ) , for the times @xmath129 which we motivated in the previous section , implies the fidelity bound  ( [ eq : realfidelitybound ] ) under the assumption that the parameters @xmath74 , @xmath78 and @xmath104 are chosen as in eq .",
    "( [ eq : worstcase ] ) .",
    "our starting point will be two sets of expressions for the @xmath129 , namely the definition of the @xmath129 , eqs .",
    "( [ eq : alpha_k][eq : t_k ] ) , in terms of the measured values @xmath94 and the target values @xmath127 , and eqs .",
    "( [ delta0][eq : alpha_ksquared ] ) above in terms of the actual values @xmath95 and @xmath126 . in subsection",
    "[ sec : hk - minus - deltak ] we will derive an upper bound on the error @xmath196 .",
    "this bound shows how accurate our algorithm is in achieving the target height , @xmath127 , for the features @xmath126 .",
    "the overall accuracy of our algorithm , however , also depends on how accurate it is in achieving the correct width of the features .",
    "this accuracy is determined by the fraction of @xmath12 values for which @xmath197 ( see figure  [ figure1 ] ) . in subsection",
    "[ sec : exceptions ] we obtain an upper bound on this fraction . in subsection",
    "[ sec : stage1fidelity ] , we derive the fidelity bound  ( [ eq : realfidelitybound ] ) and an upper bound on the probability that the algorithm fails due to a nonzero outcome of the measurement of the auxiliary qubits . and finally , in subsection  [ sec : stage2fidelity ] , we show that the bound  ( [ eq : tildephibound ] ) on the phases @xmath51 implies the overall fidelity bound  ( [ eq : properfidelitybound ] ) .",
    "it is convenient to perform the proof of the bound on @xmath196 in three steps .",
    "for this we note that @xmath129 depend on the values of @xmath198 , @xmath199 and @xmath200 . in subsection",
    "[ subsec : rangeforgammas ] we determine the range of possible values for @xmath198 and @xmath199 that corresponds to the uncertainty in the measured values of @xmath201 .",
    "similarly in subsection  [ subsec : rangeforomegas ] we determine the error range for @xmath200 , and finally , in subsection  [ subsec : proofofthebound ] we complete the proof of the bound .",
    "equation  ( [ fortk ] ) provides an explicit expression for @xmath129 in terms of @xmath202 and @xmath203 : @xmath204 in what follows it will be convenient to use auxiliary quantities @xmath205 defined as @xmath206 the meaning of @xmath207 becomes clear in comparison with ( [ t_kf1 ] ) : @xmath207 are the time intervals that correspond to the target features @xmath208 .",
    "unlike @xmath209 , @xmath205 are not necessarily integers",
    ".    it will be convenient to rewrite the definition of @xmath129 given in eqs .",
    "( [ eq : alpha_k][eq : t_k ] ) in a slightly modified form : @xmath210 where we use the following definitions : @xmath211 @xmath212 @xmath213 and @xmath214 where @xmath215 it is also convenient to define @xmath216 in this notation eq .",
    "( [ tau_kf1 ] ) can be rewritten as @xmath217    directly from the definitions we have @xmath218 by direct calculation we get @xmath219 the @xmath220 notation is an abbreviation for a double inequality ( see the appendix ) . since @xmath221 we obtain @xmath222 and similarly @xmath223 since @xmath224 , we therefore have @xmath225 and similarly @xmath226 in the above formulas we have used the mean value theorem that states that for any function @xmath36 that is continuous on the interval @xmath227 , where @xmath228 is some constant , and differentiable on @xmath229 we can write @xmath230 where @xmath231 denotes the derivative of @xmath36 at some point @xmath232 .",
    "this gives , for example , that for @xmath233 @xmath234 the error bounds  ( [ approxgammatk ] ) and  ( [ approxgamma0 ] ) were obtained by simplifying the somewhat tighter but unwieldy bounds using these methods .",
    "+      the aim of this subsection is to determine the ratio between @xmath200 and the true value @xmath235 given by equations ( [ tildeomega_k ] ) and ( [ omega_k ] ) respectively . using the mean value theorem we have , by definition , @xmath236 ^ 2 } } \\big(\\pm\\frac{2n_k}{2^an}\\frac{\\eta_c}{\\eta_g-\\eta_c}\\big)\\,,\\end{aligned}\\ ] ] where @xmath237 is a real number such that @xmath238 .",
    "this implies @xmath239 since @xmath224 we have @xmath240 and therefore @xmath241 it now remains to find a bound on @xmath242 that is linear in @xmath235 .",
    "we have , by definition , @xmath243 since @xmath244 we obtain @xmath245 and therefore @xmath246      during the @xmath85th stage our algorithm creates a feature of height @xmath247 where @xmath248 is some initial phase . on the other hand , the target height @xmath127 is @xmath249 hence @xmath250 directly from the definition we obtain @xmath251 using eqs .",
    "( [ approxgammatk ] ) , ( [ approxgamma0 ] ) , and  ( [ approxomega ] ) , using the fact that @xmath252 and using the inequality  ( [ arcsininequality ] ) we have @xmath253 now using  ( [ meanvalueexamples ] ) and the fact that @xmath254 we derive from the above equation @xmath255 since @xmath256 [ see eqs.([eq : worstcase ] ) and  ( [ eq : epsilonbound ] ) ] , we have that @xmath257 , and we can therefore use the inequality  ( [ arccosinequality ] ) to show that @xmath258 since @xmath259 , we obtain the bound @xmath260      when describing our algorithm in section  [ sec : algorithm ] we have introduced functions @xmath266 and @xmath267 to distinguish two different approximations to the target function @xmath19 .",
    "namely , if @xmath266 is an approximation of @xmath19 which is defined by the oracles @xmath60 , then @xmath267 also takes into account the fact that we may not know the exact values of @xmath66 . in our algorithm",
    "we therefore use @xmath267 as our target function which coincides with @xmath266 everywhere apart for a small fraction of values of @xmath12 for which @xmath197 . in this section",
    "we obtain an upper bound on this fraction which will then be used in the next section where we derive bounds on the fidelity and the failure probability .    for all @xmath268",
    ", we have @xmath269 . for @xmath270",
    ", we have @xmath271 , and hence @xmath272 we now consider , for each @xmath273 , all values of @xmath268 such that @xmath274 . for these values of @xmath268 , we have @xmath275 since @xmath276 , we have @xmath277 hence @xmath278 and finally @xmath279 since @xmath280 , we find that @xmath281 for at most @xmath282 values , where @xmath283      for @xmath284 , eq .",
    "( [ psikminusone ] ) can be rewritten in the form @xmath285 where @xmath286 let us define @xmath287 using this definition we have @xmath288 where we have used the fact that @xmath289 for @xmath290 .",
    "using  ( [ h_delta_bound ] ) , and since @xmath291 we obtain @xmath292 , this implies @xmath293 rewriting eq .",
    "( [ eq : pdoubleprime ] ) in terms of the coefficients @xmath294 , @xmath295 we can write @xmath296 for all @xmath12 with a possible exception of at most @xmath282 values @xmath297 ( see sec .  [",
    "sec : exceptions ] ) .",
    "let @xmath298 be the set of exceptional values of @xmath12 for which @xmath299 .",
    "we have @xmath300 since @xmath301 , @xmath302 and @xmath124 are all bounded from above by @xmath303 we obtain @xmath304 by definition of @xmath266 @xmath305 and since @xmath19 is normalized we get @xmath306 in order to continue we need to calculate @xmath307 .",
    "this can be done by examining the normalization condition @xmath308 .",
    "this condition reads @xmath309 using  ( [ d ] ) and  ( [ ppp_in_terms_of_c ] ) this can be rewritten as @xmath310 or @xmath311 where @xmath312",
    "let us define @xmath313 since @xmath19 is normalized , equation  ( [ justbeforequadratic ] ) gives a quadratic equation for @xmath314 : @xmath315 where @xmath316 and @xmath317 since @xmath302 and @xmath124 are bounded from above by @xmath303 and since @xmath298 contains at most @xmath282 elements ( see sec .",
    "[ sec : exceptions ] ) , we obtain with the help of  eq.([bound_on_d ] ) @xmath318 similarly , since @xmath319 we have @xmath320 since @xmath321 and @xmath322 , see eqs .  ( [ mu ] ) and  ( [ eq : worstcase ] ) respectively , we obtain @xmath323 together with eq .",
    "( [ fidelity_bound_almost ] ) this gives the lower bound on the fidelity , @xmath324 where we have observed that @xmath325 and used the bounds @xmath326 , @xmath321 , which follow from our settings given in eq .",
    "( [ eq : worstcase ] ) .",
    "the failure probability is @xmath327      we now show that the choice @xmath328 together with the inequality  ( [ eq : tildephibound ] ) , i.e. , @xmath329 , implies the overall fidelity bound  ( [ eq : properfidelitybound ] ) .",
    "the proof is straightforward .",
    "@xmath330 \\big| \\cr & \\ge & \\sum_x \\sqrt{p(x)\\tilde p(x ) } \\ ,         \\cos[\\phi(x)-\\tilde \\phi(x ) ]   \\cr & \\ge & \\sum_x \\sqrt{p(x)\\tilde p(x ) } \\ ,         \\big ( 1- [ \\phi(x)-\\tilde \\phi(x)]^2/2 \\big ) \\cr & \\ge & \\sum_x \\sqrt{p(x)\\tilde p(x ) } \\ ,         ( 1-\\epsilon'^2/8 ) \\cr & = & |\\langle\\psi_{\\tilde p}|\\psi_p\\rangle| \\ ;        ( 1-\\lambda ' ) \\cr & > & 1-\\lambda-\\lambda ' \\;.\\end{aligned}\\ ] ]",
    "in this section we provide worst case upper bounds on the resources required by the algorithm .",
    "we distinguish between the resources that are needed for the state preparation part of the algorithm ( subsection  [ subsec : stateprep ] ) and the resources that are needed by the quantum counting that precedes the actual state preparation ( subsection  [ subsec : qcounting ] ) .        from our settings  ( [ eq : worstcase ] )",
    "we obtain @xmath331 we thus obtain for the number of auxiliary qubits @xmath332      here we give an upper bound on the time resources needed by the algorithm .",
    "the construction of one feature requires at most @xmath333 oracle calls . using inequality  ( [ inequality112 ] )",
    "we can therefore write @xmath334 from  ( [ eq : worstcase ] ) we have @xmath335 since there are at most @xmath41 features and because @xmath336 and @xmath337 we therefore have that the total number of oracle calls , @xmath338 , satisfies the bound @xmath339        consider an oracle @xmath130 on the set of @xmath132 possible values of @xmath12 .",
    "using standard techniques we can count the number @xmath340 of solutions of @xmath130 within the absolute error @xmath341 @xmath342 where @xmath343 is the number of auxiliary qubits needed by the standard quantum counting routine  @xcite .",
    "we want @xmath344 , where @xmath74 is the counting accuracy introduced earlier .",
    "this connects the desired counting accuracy @xmath74 with the number of auxiliary qubits @xmath343 , @xmath345 where @xmath346 . solving this equation for @xmath6 in the case @xmath347",
    ", we have @xmath348 where @xmath349 .",
    "we see that , the bigger the value of @xmath104 , the bigger @xmath343 has to be in order to give the required counting accuracy @xmath74 .",
    "we therefore set @xmath104 to the minimum , i.e. , @xmath350 ( this doubles the range of @xmath12 values to ensure reliable counting , see e.g.  @xcite ) .",
    "it is easy to check that the dependence of @xmath6 on @xmath351 is monotonic .",
    "as we vary @xmath340 in the range 0 to @xmath352 , the corresponding values of @xmath6 vary between the limits @xmath353 and @xmath354 .",
    "it follows that the required number of auxiliary working qubits needed for counting with accuracy @xmath74 is @xmath355 .",
    "thus we choose @xmath356 .",
    "this choice guarantees the required accuracy of counting irrespective of the true value of @xmath340 .",
    "the above counting procedure does not output the correct result with probability 1 .",
    "for the procedure to work correctly with probability @xmath9 we have to increase the number of auxiliary qubits from @xmath343 to @xmath357 which is given by @xmath358 the number , @xmath359 , of oracle calls that is required by the counting procedure is @xmath360 substituting @xmath361 and using eq .",
    "( [ eq : worstcase ] ) we obtain @xmath362 since there are at most @xmath41 features the total number of oracle calls needed by the counting stage of our algorithm is bounded as @xmath363",
    "in conclusion , we have described a quantum algorithm to prepare an arbitrary state of a quantum register of @xmath26 qubits , provided the state is initially given in the form of a classical algorithm to compute the @xmath1 complex amplitudes defining the state .",
    "for an important class of states , the algorithm is efficient in the sense of requiring numbers of oracle calls and additional gate operations that are polynomial in the number of qubits .",
    "the following table lists , for each stage of the algorithm , upper bounds on the number of oracle calls and the number of auxiliary qubits needed .    [ cols=\"<,^,^ \" , ]     the bounds are not tight and can be improved by a more detailed error analysis .",
    "the total number of quantum gate operations depends on the implementation of the oracles .",
    "it is proportional to the number of oracle calls times a factor polynomial in @xmath364 if the functions @xmath11 and @xmath4 can be efficiently computed classically .",
    "depending on the nature of the function @xmath11 and the prior information about @xmath11 , the algorithm we have described in this paper can be optimized in a number of ways .",
    "for instance , the counting stage is the most expensive in terms of both oracle calls and additional qubits .",
    "if for some reason the numbers @xmath66 characterizing the oracles are known in advance , the counting stage can be omitted , leading to considerable savings .",
    "furthermore , in this case the fidelity bound can be guaranteed with probability 1 , i.e. , we can set @xmath365 .    in some cases",
    "the algorithm can be simplified if , instead of using the oracles defined in eq .",
    "( [ eq : ok ] ) , one uses oracles that return the @xmath85-th bit of the expression @xmath366 .",
    "the general conclusions of the paper continue to hold for this variant of the algorithm , which we analyze in detail in  ref .",
    "@xcite .    finally , by using generalizations of grover s algorithm in which the oracles and the inversion about the mean introduce complex phase factors @xcite it is possible to reduce the number of auxiliary qubits needed in the preparation stage of the algorithm .",
    "this leads to a reduction in the number of required oracle calls , and could also be important in implementations where the number of qubits is the main limiting factor .",
    "this work was supported in part by the european union ist - fet project ediqip .",
    "in this paper we have made a frequent use of the following convention .",
    "let @xmath104 , @xmath367 and @xmath228 be three numbers .",
    "the notation @xmath368 is then understood to be equivalent to the double inequality @xmath369 furthermore , let @xmath370 , @xmath371 and @xmath372 be functions .",
    "the notation @xmath373 is then equivalent to the statement that @xmath374 can be written in the form @xmath375 where @xmath376 for all @xmath377 .",
    "here we prove the following inequalities @xmath378 , which implies that for any @xmath12 @xmath379 by inspection of @xmath380-function we have that for @xmath381 the maximum value of the difference @xmath382 is achieved for @xmath383 : @xmath384 in the case of @xmath385 the following equality holds  @xcite @xmath386 applying this equality to the right hand side of  ( [ maxarcsindifference ] ) we obtain @xmath387 let us now look for a constant @xmath228 such that @xmath388 since @xmath389 is a decreasing function the above requirement is equivalent to @xmath390 according to the mean value theorem , there exists @xmath391 such that @xmath392 and therefore the requirement  ( [ oneminusnu ] ) can be rewritten as @xmath393 it is clear that this requirement is guaranteed to be satisfied if we set @xmath394 .",
    "indeed , @xmath395 for any nonnegative @xmath396 which includes all possible values of @xmath237 that can correspond to @xmath394 and @xmath397 . since @xmath394 guarantees that  ( [ arccosoneminusnu ] )",
    "is satisfied , we obtain from  ( [ aftergradshteynryzhik ] ) @xmath398 the case of negative @xmath7 can be treated in an analogous fashion leading to the inequality @xmath399 the required inequality  ( [ arcsininequality ] ) follows trivially .",
    "moreover , since @xmath400 we also obtain ( [ arccosinequality ] ) as required ."
  ],
  "abstract_text": [
    "<S> we describe a quantum algorithm to prepare an arbitrary pure state of a register of a quantum computer with fidelity arbitrarily close to 1 . our algorithm is based on grover s quantum search algorithm . for sequences of states with suitably bounded amplitudes , </S>",
    "<S> the algorithm requires resources that are polynomial in the number of qubits . </S>",
    "<S> such sequences of states occur naturally in the problem of encoding a classical probability distribution in a quantum register . </S>"
  ]
}