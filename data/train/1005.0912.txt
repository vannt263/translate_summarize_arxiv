{
  "article_text": [
    "let @xmath7 be a set of @xmath1 moving points in the plane .",
    "we assume that the motions of the points are simple , in the sense that the trajectory of each point is a piecewise - algebraic curve of _ constant description complexity _ , meaning that it can be described as a boolean combination of a constant number of polynomial equalities and inequalities of constant maximum degree .",
    "our goal is to devise a reasonably simple scheme for triangulating @xmath8 at any fixed time @xmath9 , and to maintain the triangulation as the points move .",
    "that is , we wish to partition the convex hull @xmath10 of @xmath0 into pairwise openly disjoint triangles whose vertices are the points of @xmath0 , so that the interior of each triangle is empty  it does not contain any point of @xmath0 .",
    "the scheme has to be _",
    ", so that we can keep track of the discrete combinatorial changes that the triangulation undergoes as the points move , and update the triangulation so that it continues to conform to the underlying scheme .",
    "( that is , at any given time @xmath9 the maintained triangulation coincides with the one that would result in applying the static scheme to @xmath8 . )",
    "the study of triangulations plays a central role in computational geometry because of their numerous applications in such areas as computer graphics , physical simulation , collision detection , and geographic information systems @xcite . with the advancement in technology , many applications , for instance , video games , virtual reality , dynamic simulations , and robotics , call for maintaining a triangulation as the points move . for example , the arbitrary eulerian - lagrangian method @xcite provides a way to integrate the motion of fluids and solids within a moving finite - element mesh .    in @xmath11 , the delaunay triangulation @xmath12 of",
    "@xmath0 produces well - shaped triangles , and thus is a good candidate for such a triangulation scheme . the problem , though",
    ", is that the best known upper bound on the number of discrete changes in @xmath13 , as a function of time @xmath9 , is only nearly cubic in @xmath1 ( the bound is cubic if the points move with constant velocities ) ; see @xcite .",
    "while it is strongly believed that the maximum possible number of discrete changes that @xmath13 can experience is only nearly quadratic in @xmath1 , this is one of the hardest open problems in computational and combinatorial geometry ( as recognized , e.g. , in @xcite ) .",
    "until this conjecture is established , one seeks alternative triangulation schemes with a provable _ nearly - quadratic _ upper bound on the number of discrete changes .",
    "( this is best possible , since the convex hull itself can change @xmath14 times during a simple motion of the points of @xmath0 ; see @xcite . )",
    "moreover , the scheme should be sufficiently simple to define , to implement , and ( as a secondary aesthetic virtue ) to analyze .",
    "finally , the scheme should satisfy the four basic properties of kinetic data structures @xcite detailed below .",
    "agarwal et al .",
    "@xcite have recently presented such a randomized triangulation scheme which experiences @xmath15 discrete changes .",
    "their scheme , however , is fairly complicated , and its analysis is also rather involved .",
    "it uses a hierarchy of subsets @xmath16 , where each set @xmath17 , for @xmath18 , is a random sample of roughly @xmath19 points of @xmath20 .",
    "the algorithm maintains an entire hierarchy of triangulations @xmath21 , where each @xmath22 is a triangulation of @xmath23 ; it is a refinement of @xmath24 which is obtained by a suitable variant of the _ fan triangulation _ , introduced in @xcite .",
    "* kinetic data structures .",
    "* the _ kinetic data structure _ ( kds ) framework , introduced by basch et al .",
    "@xcite , proposes an algorithmic approach , together with several quality criteria , for maintaining certain geometric configurations determined by a set of objects , each moving along a trajectory whose graph , as a function of time , is a piecewise - algebraic curve ( in space - time ) of constant description complexity .",
    "several interesting algorithms have been designed , using this framework , over the past decade , including algorithms for maintaining the convex hull of a set of ( moving ) points in the plane @xcite , the closest pair and all nearest neighbors in any dimension @xcite , and many other configurations .",
    "see @xcite for a comprehensive , albeit old , survey , and @xcite for a list of more recent results and references .",
    "typically , a kds operates by maintaining a set of _ certificates_. as long as they are all valid , the structure being maintained is guaranteed to be valid too .",
    "each certificate has a ( first future ) failure time , and we store these critical times in an event priority queue .",
    "when a certificate fails , we repair the kds , update , if needed , the geometric structure that we maintain , generate new certificates and insert their failure times into the queue .",
    "generally , a good kds is expected to possess the following four properties : ( i ) _ compactness _ , meaning that the storage that it requires is larger only by a polylogarithmic factor than the space required for the structure being maintained .",
    "( ii ) _ efficiency _ , meaning that the number of events that it processes ( i.e. , failure times of the certificates ) is larger only by a polylogarithmic factor than the maximum possible number of discrete changes in the structure being maintained .",
    "( iii ) _ responsiveness _ , meaning that repairing the kds at a certificate failure event takes only polylogarithmic time .",
    "( iv ) _ locality _ , meaning that each input object is stored at only a polylogarithmic number of places in the kds , so that an expected change in the motion of a single object can be processed efficiently .",
    "see @xcite for more details .",
    "therefore , a good kds for kinetic triangulation in @xmath11 should have only nearly linear storage , process only a nearly - quadratic number of events , each in polylogarithmic time , and each moving point should be stored at only a polylogarithmic number of places in the kds .    *",
    "our result . *",
    "in section [ sect : static ] , we present a simple triangulation scheme for a set @xmath0 of @xmath1 moving points in the plane . for the sake of efficient kinetization",
    "we make the scheme randomized , and assume a ( natural ) model in which the flight plans of the moving points are independent of the randomization used by the algorithm .",
    "the basic idea of the ( static ) triangulation is quite simple ( some details are glossed over in this informal overview ) : we sort the points of @xmath0 by their @xmath25-coordinates , split @xmath0 at a ( random ) point @xmath26 into a left portion @xmath27 and a right portion @xmath28 , compute recursively the upper convex hulls of @xmath29 and of @xmath30 , and merge them into the upper convex hull of the whole set @xmath0 .",
    "this process results in a _ pseudo - triangulation _ of the portion of the convex hull of @xmath0 lying above the @xmath25-monotone polygonal chain @xmath31 connecting the points of @xmath0 in their @xmath25-order .",
    "each pseudo - triangle is @xmath25-monotone , and consists of an upper _ base _ and of a left and right lower concave chains , meeting at its bottom _",
    "see figure [ fig : pseudotail ] for an illustration .",
    "a symmetric process is applied to the portion of the hull below @xmath31 , by computing recursively lower convex hulls of the respective subsets of @xmath0 .",
    "( in particular , we obtain a hierarchical representation of @xmath10 , similar to the one of overmars and van leeuwen  @xcite ; see also @xcite .",
    "see  @xcite for additional applications of hierarchical pseudo - triangulations to kinetic problems . )    to obtain a proper triangulation of ( the convex hull of ) @xmath0 , we partition each pseudo - triangle @xmath32 into triangles . we accomplish this in the following randomized incremental manner .",
    "we process the vertices of @xmath32 ( other than its apex and its leftmost and rightmost vertices ) in order , according to the random ranks that they received during the first splitting phase , and draw from each processed vertex @xmath33 a chord , within the current sub - pseudo - triangle @xmath34 of @xmath32 containing @xmath33 , which splits @xmath34 into two sub - pseudo - triangles .",
    "this process ends with a triangulation of @xmath32 , and we apply it to each of the pseudo - triangles , to obtain the full triangulation of @xmath10 .    in section [ sec :",
    "combichanges ] , we prove that the expected number of events that can arise during the motion is @xmath35 ( with @xmath3 and @xmath36 as defined in the abstract ) , and that the expected number of discrete ( also called topological ) changes caused in our triangulation by each such event is bounded by @xmath37 . in section [ sec : datastruct ] , we show how to maintain this triangulation , as the points of @xmath0 move , using a kinetic data structure that satisfies the criteria of @xcite , as listed above .",
    "there are several kinds of critical events we need to watch for , in which pairs of points are swapped in the @xmath25-order or triples of points become collinear .",
    "we process each event of the former type in @xmath38 expected time , and each event of the latter type in @xmath37 expected time , for a total of @xmath2 ( expected ) processing time .",
    "our implementation encodes the pseudo - triangulation as a _",
    "treap _ on @xmath0 @xcite .",
    "the upper bounds that we obtain on the number of discrete events , and on their overall processing time , are slightly better than those of the scheme in @xcite , and we believe that our scheme is simpler ( and more  explicit \" ) than that of @xcite .",
    "in this section we describe a simple scheme for constructing a static triangulation @xmath39 of @xmath10 .",
    "we fix a random permutation @xmath40 of the points of @xmath0 . for each @xmath41",
    "we denote its rank in @xmath40 as @xmath42 .",
    "let @xmath31 denote , as above , the @xmath25-monotone polygonal chain which connects the points of @xmath0 in their @xmath25-order , assuming that no two points of @xmath0 have the same @xmath25-coordinate .",
    "( in degenerate cases , which will arise at discrete instances during the motion of the points of @xmath0 , @xmath31 connects the points in the lexicographical order of their coordinates . ) since the two points of @xmath0 with extreme @xmath25-coordinates are vertices of @xmath10 , @xmath31 partitions @xmath10 into two components , @xmath43 and @xmath44 , lying respectively above and below @xmath31 . with no loss of generality , we only describe a triangulation @xmath45 of @xmath43 , and obtain the triangulation @xmath46 of @xmath44 in a fully symmetric fashion .",
    "the overall triangulation @xmath39 is the union of @xmath45 and @xmath46 . * a static pseudo - triangulation of @xmath43 .",
    "* we first construct a _",
    "pseudo - triangulation _ of @xmath43 and then refine it into a triangulation by partitioning each pseudo - triangle into triangles .",
    "each pseudo - triangle @xmath32 that we construct consists of a _ left tail _ , a middle _ funnel _ , and a _ right tail _ ( any of these substructures may be empty ; the tails were not mentioned in the overview in the introduction ) .",
    "the funnel is an @xmath25-monotone simple polygon , whose boundary consists of an upper _ base _ , which is the segment connecting its leftmost and rightmost vertices , and of a left and right lower concave _ chains _ , which are denoted respectively as @xmath47 and @xmath48 .",
    "the point in which @xmath47 and @xmath48 meet is called the _ apex _ of @xmath32 and denoted by @xmath49 .",
    "the left chain @xmath47 extends from the left endpoint of the base to @xmath49 , and the right chain extends from @xmath49 to the right endpoint of the base ; see figure [ fig : pseudotail ] .",
    "in addition , @xmath32 may have a left tail @xmath50 and a right tail @xmath51 , so that @xmath50 is an @xmath25-monotone polygonal chain which extends from the left vertex of the funnel to the left , till the _ left endpoint _",
    "@xmath52 of @xmath32 , so that @xmath53 is a concave chain , and symmmetrically for @xmath51 , which extends to the right till the _ right endpoint _",
    "@xmath54 of @xmath32 .",
    "moreover , the line containing the base of @xmath32 is an upper common tangent of @xmath53 and @xmath55 .",
    "again , see figure [ fig : pseudotail ] .",
    "we construct the pseudo - triangulation of @xmath43 recursively . at each step of the recursion we have some subset @xmath56 of points which are consecutive in the @xmath25-order of @xmath0 , and we construct a pseudo - triangulation @xmath57 of @xmath58 . at the topmost level of the recursion we have @xmath59 .",
    "the construction of @xmath57 proceeds as follows ; see figure [ fig : pseudotrian ] .",
    "let @xmath60 ( resp . ,",
    "@xmath61 ) denote the point of @xmath62 with the minimal ( resp .",
    ", maximal ) @xmath25-coordinate , and let @xmath63 be the point @xmath26 of @xmath64 with the minimum value of @xmath42",
    ". set @xmath65 , @xmath66 ( so @xmath63 belongs to both sets ) .",
    "we add to @xmath57 the following pseudo - triangle @xmath32 .",
    "the base of @xmath32 is the portion of the upper common tangent to @xmath67 and @xmath68 between the points of tangency .",
    "we call this base the _ bridge _ of @xmath32 and denote it by @xmath69 . the left ( resp . , right )",
    "chain @xmath47 ( resp . , @xmath48 ) is the portion of the upper hull of @xmath70 ( resp .",
    ", @xmath71 ) below @xmath69 .",
    "we take @xmath50 to be the portion of the upper hull of @xmath70 to the left of @xmath47 , and define @xmath51 symmetrically as the portion of the upper hull of @xmath71 to the right of @xmath48 .",
    "the points @xmath60 and @xmath61 become the respective _ endpoints _ @xmath52 , @xmath54 of @xmath32 .",
    "we also have @xmath72 which belongs , by definition , to both chains .",
    "( the funnel of @xmath32 may be empty , if @xmath63 is a vertex of the upper hull of @xmath62 . in this case",
    "we can think of the funnel of @xmath32 as the singleton @xmath72 , and @xmath32 consists of the two tails @xmath73 , meeting at @xmath63 , and forming together a common concave chain .",
    "similarly , a pseudo - triangle may have an empty left tail and/or empty right tail . )",
    "we then recursively pseudo - triangulate each of @xmath67 , @xmath68 .",
    "the recursion terminates when @xmath74 ( by construction , @xmath75 ) .",
    "if @xmath76 then we output a single pseudo - triangle @xmath32 , which is either a triangle , when the midpoint lies below the segment connecting the endpoints , or , in the opposite case , consists of the two segments @xmath77 and @xmath78 . if @xmath79 , no pseudo - triangle is output . in this case",
    "@xmath58 is a single edge of the chain @xmath31 .",
    "consider a pseudo - triangle @xmath32 such that @xmath52 is not the leftmost point of @xmath0 and @xmath54 is not the rightmost point of @xmath0 .",
    "then one can show that the triple @xmath80 have the smallest priorities among all points whose @xmath25-coordinates are between @xmath81 and @xmath82 , inclusive ( see lemma [ lemma : conditionpseudo ] below ) . to make this true for all pseudo - triangles ,",
    "we augment the initial point set @xmath0 with two dummy points @xmath83 and @xmath84 , and assign to them priorities @xmath85 and @xmath86 . the upper hull of the augmented point set is obtained from the upper hull of @xmath0 by adding two vertical downward - directed rays at the leftmost and rightmost points of @xmath0 .",
    "hence , any triangulation of @xmath43 is also a triangulation of @xmath87 , and vice versa . in the rest of the paper",
    "we denote by @xmath0 the augmented point set .",
    "the following lemma gives an operational definition of @xmath88 , which will be used in the sequel .",
    "[ lemma : conditionpseudo ] let @xmath89 , @xmath90 , and @xmath91 be three points in @xmath0 , such that @xmath92 .",
    "then @xmath88 contains a pseudo - triangle @xmath32 having endpoints @xmath93 , @xmath94 , and @xmath95 , if and only if + ( i ) @xmath96 , and + ( ii ) all points @xmath97 , such that @xmath98 satisfy @xmath99 .    to prove the `` only if '' part we proceed by induction on our recursive construction .",
    "recall that at each recursive step we process some subset @xmath56 whose points are consecutive in the @xmath25-order of @xmath0 , and add to @xmath88 a pseudo - triangle @xmath32 with @xmath100 , @xmath101 , and @xmath72 . to establish both asserted conditions ( i ) and ( ii ) for @xmath32 , it is sufficient to observe that each point @xmath26 , such that @xmath102 , satisfies @xmath103 .",
    "indeed , the desired property holds initially for @xmath0 by our choice of the artificial points @xmath104 and @xmath105 and their priorities . assuming that this holds when we process some subset @xmath62 , and using the fact that @xmath63 is the point with smallest priority in the range @xmath102 , the claim also holds for @xmath70 and @xmath71 .    for the `` if '' part",
    ", we observe that for every choice of @xmath106 there is exactly one choice of @xmath89 and @xmath91 in @xmath0 so that the triple @xmath107 satisfies ( i ) and ( ii ) , and every point @xmath106 is an apex of exactly one pseudo - triangle of @xmath88 ( and the apex of each pseudo - triangle is distinct from each of @xmath108 and @xmath104 ) .",
    "the latter is easy to establish by induction on the increasing order of the priorities of the points .",
    "this , combined with the arguments in the `` only if '' part , completes the proof .    * the pseudo - triangulation tree . *",
    "the pseudo - triangulation @xmath88 can be represented by a binary tree in which every node @xmath33 represents a pseudo - triangle @xmath109 , and stores the point @xmath110 .",
    "the inorder of the tree is the increasing @xmath25-order of the apices ( i.e. , the points of @xmath0 ) .",
    "the subtree rooted at @xmath33 represents the recursive pseudo - triangulation of @xmath111 , where @xmath112 denotes the set of points stored at the nodes of the subtree rooted at @xmath33 .",
    "note that @xmath113 and @xmath114 are not stored at this subtree  they are the next points to the left and to the right of the points of @xmath115 . abusing the notation slightly ,",
    "we denote by @xmath88 both the pseudo - triangulation @xmath88 and the tree representing it .",
    "* remark : * let @xmath33 be a node in @xmath88 , so that @xmath116",
    ". then @xmath113 is stored at the lowest ancestor of @xmath33 whose right subree contains @xmath33 . if @xmath117 then @xmath33 belongs to the path from the root of @xmath88 to the leftmost leaf .",
    "symmetric properties hold for @xmath114 .    in summary , we have the following lemma , whose proof is immediate from the construction .",
    "[ lemma : treap ] the tree representing @xmath88 is a treap on @xmath118 .",
    "that is , @xmath88 is a heap with respect to the _ priorities _ , and a search tree with respect to the @xmath25-coordinates of the points .    *",
    "triangulating a fixed pseudo - triangle .",
    "* let @xmath32 be a pseudo - triangle of @xmath88 .",
    "assume that the funnel of @xmath32 is not empty , and is not already a triangle .",
    "we say that two vertices @xmath119 of the funnel of @xmath32 , where @xmath26 belongs to @xmath47 and @xmath120 belongs to @xmath48 , are _ visible _ from each other if @xmath121 does not intersect @xmath122 ( except at its endpoints ) ; in this case @xmath121 lies inside the funnel of @xmath32 .",
    "denote by @xmath123 the rightmost point on the right chain which is visible from @xmath26 .",
    "note that either @xmath123 is the rightmost vertex of @xmath32 or @xmath124 is an upper tangent to @xmath48 .",
    "symmetic definition and properties hold for points @xmath120 on @xmath48 .",
    "this definition also applies when @xmath26 is the leftmost vertex of @xmath47 and when @xmath120 the rightmost vertex of @xmath48 ( the endpoints of @xmath69 ) , in which case @xmath125 and @xmath126 .",
    "see figure [ fig : trianpseudo ] ( left ) .",
    "the triangulation @xmath127 of @xmath32 is obtained by recursively splitting @xmath32 by chords into sub - pseudo - triangles , in the following manner .",
    "choose the minimum priority vertex @xmath120 of the funnel of @xmath32 , other than the leftmost and the rightmost vertices and the apex .",
    "assume , without loss of generality , that @xmath120 lies on @xmath47 .",
    "see figure [ fig : trianpseudo ] ( left ) .",
    "the segment @xmath128 splits @xmath32 into two sub - pseudo - triangles @xmath129 and @xmath130 .",
    "the pseudo - triangle @xmath129 has @xmath120 as an apex and the same base as @xmath32 .",
    "its left chain is the portion of @xmath47 from @xmath120 to the left , and its right chain is the concatenation of @xmath128 with the portion of @xmath48 to the right of @xmath131 .",
    "the pseudo - triangle @xmath130 has @xmath128 as its base , the same apex as @xmath32 , and its left and right chains are the portions of @xmath47 and @xmath48 delimited respectively by @xmath120 and by @xmath131 .",
    "a symmetric situation arises when @xmath132 .",
    "we add the edge @xmath128 to @xmath127 , and recursively triangulate each of @xmath129 and @xmath130 .",
    "we say that the edge @xmath128 in @xmath127 is _ generated _ by @xmath120 . in the further recursive steps , we redefine @xmath123 , for vertices @xmath26 of each of these sub - pseudo - triangles , restricting the visibility to only within the respective pseudo - triangle .",
    "note that for any pair of vertices @xmath119 that lie on the same chain of @xmath32 , the segments @xmath124 and @xmath128 do not intersect in their relative interiors . therefore , if @xmath123 changes after a recursive call then it must change to a vertex of the base of the corresponding sub - pseudo - triangle .",
    "see figure [ fig : trianpseudo ] ( right ) .",
    "the recursion bottoms out when the interior of @xmath32 is a triangle .",
    "note also that all the chords in @xmath127 cross the vertical ray above @xmath49 , and so they are totally ordered in the vertical direction .",
    "* properties of @xmath127 . *",
    "every vertex @xmath26 of the funnel of @xmath32 , other than the leftmost and the rightmost vertices and the apex , generates exactly one edge @xmath133 during the whole recursive process .",
    "( for example , in figure [ fig : trianpseudo ] ( left ) , the vertex @xmath131 will not generate an edge in @xmath130 , since it is an endpoint of that funnel , but will still generate an edge within @xmath129 , or within some recursive sub - pseudo - triangle of @xmath129 . )",
    "we denote by @xmath134 the sub - pseudo - triangle in which @xmath133 is generated , and by @xmath135 the other endpoint of @xmath133 .",
    "note that @xmath135 is either the original @xmath123 or an endpoint of the base of @xmath134 .",
    "in this section we bound the overall expected number of discrete changes that @xmath136 experiences as the points of @xmath0 move along ( continuous ) pseudo - algebraic trajectories of constant description complexity .",
    "the analysis is with respect to a fixed random permutation @xmath40 of @xmath0 drawn ahead of the motion , so that the motion is `` oblivious '' to the choice of @xmath40 .",
    "thus , even though the @xmath25-order of the points may change during the motion , each point retains its initial priority , and the permutation @xmath40 is still a random permutation of @xmath0 , with respect to the @xmath25-order of these points , at any fixed @xmath9 .    * discrete changes in @xmath88 .",
    "* for a fixed time instance @xmath137 , each pseudo - triangle @xmath138 is defined by its endpoints @xmath52 , @xmath54 , and by its apex @xmath49 .",
    "given such a triple of points , they define a valid pseudo - triangle at time @xmath9 if and only if they , and the points in - between in the @xmath25-order , satisfy the conditions of lemma [ lemma : conditionpseudo ] ( at time @xmath9 ) .",
    "thus , as long as the @xmath25-order of the points does not change , @xmath139 does not change either .",
    "that is , it consists of a fixed set of pseudo - triangles , each defined by a fixed triple of points .",
    "however , the geometric structure of a pseudo - triangle may change during such a time interval , and we will bound the number of these changes separately .",
    "changes in ( the labelings of the pseudo - triangles of ) @xmath139 occur only at discrete times when the @xmath25-order of some pair of points in @xmath8 changes ; we refer to these changes as @xmath25-_swap events_.    we assume that each pseudo - triangle @xmath32 is present in @xmath139 at a maximal connected time interval @xmath140 , which is associated with @xmath32 . that is , pseudo - triangles with the same triple @xmath52 , @xmath54 , and @xmath49 that appear in @xmath139 at disjoint time intervals , are considered distinct .",
    "we emphasize that all the other features of @xmath32 , such as @xmath69 , the chains @xmath47 and @xmath48 , and the triangulation @xmath127 of its funnel , may undergo discrete changes during the time interval @xmath140 . a pseudo - triangle @xmath32",
    "is created or destroyed only at a swap event when a point @xmath41 with @xmath141 crosses one of the vertical lines through its endpoints @xmath52 and @xmath54 ( of course , this also subsumes the cases where @xmath42 is smaller than that of an endpoint of @xmath32 ) , or when the @xmath25-order of the points in the triple defining @xmath32 changes . in the former case , if @xmath142 then @xmath32 is replaced by another pseudo - triangle @xmath34 with the same endpoints @xmath143 , @xmath144 but with @xmath26 as a new apex .    if @xmath145 then @xmath26 replaces the endpoint it was swapped with .",
    "thus , each pseudo - triangle @xmath32 in our kinetic pseudo - triangulation + @xmath139 is _ defined _ by at most five points : @xmath52 , @xmath54 , @xmath49 , and at most two additional points which determine , by swaps with the endpoints of @xmath32 , the endpoints of the lifespan @xmath140 of @xmath32 in @xmath139 .    * discrete changes in @xmath127 . *",
    "fix a pseudo - triangle @xmath146 .",
    "we only consider discrete changes in the funnel of @xmath32 and its triangulation @xmath140 , and ignore changes in the tails @xmath147 ( unless they also affect the funnel ) .",
    "this is because the changes in the tails will also show up as changes in the funnels of other pseudo - triangles that are created further down the recursion .    for a fixed time",
    "instance @xmath148 , the combinatorial structure of the triangulation @xmath127 of @xmath32 depends only on the discrete structure of the boundary of the funnel of @xmath32 ( i.e. , the ordered sequences of the points along the chains @xmath47 , @xmath48 , and the base @xmath69 ) and the visibility points @xmath123 of all the vertices of the funnel of @xmath32 , excluding @xmath49 ( of course , it also depends on @xmath40 ) .",
    "therefore , as the points of @xmath0 move during the time interval @xmath140 , @xmath127 can change combinatorially only at events where the boundary or visibility structure of @xmath32 changes .",
    "these events fall into the following three types :    \\(i ) _ envelope events _ , which occur at instances when one of the chains @xmath47 , @xmath48 contains three collinear vertices ; see figure [ fig : visibilityevent ] ( right ) .",
    "this happens when a vertex ( which is not an endpoint of @xmath69 ) is added to or removed from one of the chains bounding @xmath32 .",
    "we denote the total number of such events during the period @xmath140 by @xmath149 .",
    "\\(ii ) _ visibility events _ , at which a vertex @xmath120 of @xmath48 becomes collinear with an edge @xmath150 of @xmath151 , or vice versa .",
    "see figure [ fig : visibilityevent ] ( left ) ( @xmath50 is relevant only for visibility events that affect @xmath69 and then @xmath150 has to be its rightmost edge , and symmetrically for @xmath51 ) .",
    "this happens when @xmath131 changes from @xmath26 to @xmath152 , or vice versa .",
    "in particular , each ( discrete ) change of @xmath69 corresponds to a visibility event in which the bridge becomes collinear with an edge of @xmath53 or of @xmath55 that is incident to the respective endpoint of the bridge .",
    "we denote the total number of visibility events during @xmath140 by @xmath153 .",
    "a special case of this event occurs when @xmath69 is created ( resp . ,",
    "destroyed ) , so that right before ( resp . , after ) the event",
    ", the funnel of @xmath32 is empty .",
    "note that immediately after ( resp .",
    ", before ) the creation ( resp . , destruction ) of @xmath69 ,",
    "the funnel of @xmath32 is a triangle .",
    "\\(iii ) _ swap events _ , at which some point @xmath41 , satisfying @xmath154 , crosses one of the vertical lines through @xmath155 or @xmath49 .",
    "note that a single swap event of this kind may cause massive discrete changes , of highly unlocal nature , in the chains @xmath47 , @xmath48 , in the visibility pointers @xmath131 of the vertices of @xmath32 , and in @xmath69 .",
    "see figure [ fig : envelopeevent ] ( left ) for an illustration .",
    "note that a swap between any other pair of points @xmath119 within the @xmath25-range of @xmath32 can be ignored in the present analysis , since the lower of the two points can not belong to the funnel of @xmath32 at the time of swap .",
    "assuming general position of the trajectories of the points , the above events occur at distinct time instances ( except that the same event may show up , in different forms , in several pseudo - triangles ) .",
    "a visibility event happens when @xmath123 changes for some point @xmath26 ; we then say that @xmath26 is _ involved _ in the visibility event .",
    "an envelope event happens when a point @xmath26 joins or leaves one of the chains @xmath47 , @xmath48 ; we then say that @xmath26 is _ involved _ in the envelope event .",
    "[ lemma : ingoingenvelopeevent ] the only point @xmath26 for which @xmath123 changes in an envelope event is the point @xmath26 involved in the event .",
    "the lemma follows since at the moment following ( resp . ,",
    "preceding ) the appearance of @xmath26 on ( resp .",
    ", disappearance from ) its chain , say @xmath47 , its two incident edges are almost collinear .",
    "thus , all vertices @xmath120 on the opposite chain satisfy @xmath156 both before and after the event , and @xmath131 is not affected by the event .    * the number of changes in @xmath127 .",
    "* we define @xmath157 as the set of points @xmath41 , other than @xmath49 , that appear on @xmath31 between @xmath52 and @xmath54 , at any time during the life span @xmath140 , and put @xmath158 .",
    "( note that the points of @xmath157 may enter or leave the interval between @xmath52 and @xmath54 in the middle of @xmath140 , at @xmath25-swaps with either @xmath52 or @xmath54 . ) as noted above , every point @xmath159 satisfies @xmath154 .",
    "clearly , our triangulation undergoes @xmath160 swap events during @xmath140 ( recall that we only consider swaps with @xmath155 or @xmath49 ) , and each of them leads to @xmath160 edge insertions and deletions to @xmath127 ( the maximum number of edges in the whole triangulation @xmath127 ) , for a total of @xmath161 such updates .",
    "we next bound the number of discrete changes in @xmath127 caused by events of the remaining two types .    fix a set of at most five points that can potentially define a pseudo - triangle for some set of priorities .",
    "this set has an associated time interval @xmath162 $ ] , and consists of three points @xmath89 , @xmath90 , and @xmath91 , such that , at all times @xmath163 , @xmath164 , and of two additional points @xmath165 and @xmath166 ( each of which could be equal to @xmath90 ) , so that the @xmath25-coordinate of @xmath167 swaps with either @xmath89 or @xmath91 at times @xmath168 , for @xmath169 .",
    "for some drawings of the random priorities , @xmath32 appears as a pseudo - triangle , and for other drawings it does not . for @xmath32 to appear in @xmath139",
    ", the priorities of @xmath170 and @xmath171 should be smaller than the priority of @xmath172 .",
    "the priorities of @xmath165 and @xmath166 have to be at most the priority of @xmath172 , and the priorities of all other points in @xmath157 should be larger than the priority of @xmath90 . the probability of this to happen , assuming @xmath173 are all distinct , is easily seen to be @xmath174 ( for @xmath175 ) .    when we condition on drawings in which @xmath32 indeed appears in @xmath139 , the following holds .",
    "[ thm : logcostevent ] let @xmath32 be a pseudo - triangle in the kinetic triangulation @xmath139 . then the expected number of discrete changes in the triangulation @xmath127 of @xmath32 , after any single envelope or visibility event which happens during the period @xmath140 , and conditioned on @xmath32 appearing in @xmath139 , is @xmath176 .    clearly , the chords of @xmath127 ( the additional edges which partition @xmath32 into triangles ) admit a total vertical order , because they all cross the vertical line through @xmath49 . consider a time instance @xmath177 when an envelope or a visibility event occurs , and let @xmath178 be the point involved in the event .",
    "let @xmath179 ( resp . ,",
    "@xmath180 ) be the time right before ( resp .",
    ", after ) the event .",
    "note that @xmath181 can not be the apex of @xmath32 ( unless the funnel of @xmath32 is already , or is going to become , a triangle ) .",
    "note also that @xmath181 is not a vertex of @xmath69 , neither at @xmath180 nor at @xmath179 , unless @xmath181 is involved in a visibility event which changes @xmath69 . in the latter case , @xmath127 gains or loses its topmost triangle at time @xmath182 but there are no other changes in the triangulation , as is easily checked .",
    "we may therefore assume that @xmath69 does not change at time @xmath182 , and that @xmath181 is not a vertex of @xmath69 .    with no loss of generality , we assume that @xmath181 is a vertex of @xmath48 at time @xmath180 , and treat the remaining cases symmetrically ( for a visibility event",
    ", @xmath181 belongs to @xmath48 also at time @xmath179 ) .",
    "consider the triangulation @xmath127 at time @xmath180 ( that we would have obtained if we were to reconstruct @xmath45 statically at time @xmath180 ) .",
    "let @xmath183 be the sub - pseudo - triangle of @xmath32 within which the edge @xmath184 is generated during the construction of @xmath45 ( see figure [ fig : visibilityevent ] ( right ) ) .",
    "note that the event at time @xmath182 leaves unchanged the visibility vertex @xmath123 of each vertex @xmath26 in @xmath32 other than @xmath181 .",
    "indeed , this follows from lemma [ lemma : ingoingenvelopeevent ] for envelope events and is obvious for visibility events , using our assumption that @xmath69 does not change . the recursive construction of @xmath127 is easily seen to imply that @xmath183 appears as a sub - pseudo - triangle in the construction also at time @xmath179 .",
    "indeed , an easy inductive argument on the order of the ranks of the funnel vertices implies that the modified visibility vertices @xmath135 , and the resulting chords @xmath185 , also do not change , up to the point where @xmath183 is constructed . right after this step , the chord from @xmath181 is drawn , so the rest of the construction of @xmath127 might change completely , but only within @xmath183 .",
    "hence , @xmath183 contains every edge which is inserted to or deleted from @xmath127 at time @xmath182 .",
    "therefore , the number of changes in @xmath127 is bounded by @xmath186 , where @xmath187 denotes the number of vertices of @xmath183 at the time of the event .    note",
    "that @xmath187 is a random variable depending ( only ) on the permutation @xmath188 of @xmath157 , which is obtained by restricting @xmath40 to @xmath157 . recall that we condition the analysis on permutations @xmath40 such that @xmath32 indeed appears in @xmath88 . in these permutations , the points of @xmath157 have to follow all the ( at most ) five points defining @xmath32 , but as long as they obey this restriction they can appear in any order .",
    "it follows that , in our conditional probability subspace , the restriction of @xmath40 to @xmath157 is a random permutation of @xmath157 .    to bound the expected value of @xmath187 , we fix an arbitrary threshold @xmath189 and prove that the event @xmath190 occurs with probability at most @xmath191 . the expected value of @xmath187",
    "is then bounded by @xmath192    to show that @xmath193 , we proceed through the following cases . in each case , except for the last one , we find a set @xmath194 of @xmath195 points which does not depend on @xmath188 , so that all its elements must appear in @xmath188 after @xmath181 .",
    "this readily implies the asserted bound .",
    "the last case is more involved but it is still based on the same general idea .    _ visibility event . _",
    "if @xmath196 is a vertex of the base of @xmath183 , both at time @xmath179 and at time @xmath180 , then @xmath127 does not change combinatorially at time @xmath182 . otherwise , as follows from the discussion in section [ sect : static ] , all three vertices that become collinear in the event appear in @xmath183 , both before and after the event , which implies that @xmath197 at both times @xmath179 and @xmath180 ( although they assume different values of these times ) .",
    "recall that @xmath26 is assumed to be a vertex of @xmath48 , and suppose that @xmath198 .",
    "if @xmath183 contains at least @xmath199 vertices of @xmath48 , then it also contains a sequence @xmath194 of @xmath200 consecutive vertices of @xmath48 either immediately to the left or immediately to the right of @xmath181 .",
    "otherwise , @xmath183 contains @xmath201 together with at least @xmath202 other vertices of @xmath47 , so it must contain a sequence @xmath194 of @xmath200 consecutive vertices of @xmath47 lying either immediately to the left or immediately to the right of @xmath203 . in both cases ,",
    "the key observation is that @xmath194 does not depend on @xmath188 , and that @xmath181 precedes all the vertices of @xmath194 in @xmath188 ( except possibly for one extremal vertex which is a corner of @xmath183 ) .",
    "as noted above , this establishes the asserted bound .",
    "_ envelope event .",
    "_ again , suppose that @xmath198 .",
    "if @xmath183 contains at least @xmath199 vertices of @xmath48 , the bound follows by exactly the same argument as in the case of a visibility event . otherwise , if @xmath183 contains @xmath49 we set @xmath194 to be the first @xmath204 points of @xmath47 to the left of @xmath49 .",
    "again , @xmath194 does not depend on @xmath188 , and all its elements must appear in @xmath188 after @xmath181 , so the bound follows .",
    "we therefore assume that @xmath183 contains at most @xmath199 vertices of @xmath48 , and that its apex @xmath205 is distinct from @xmath49 .",
    "thus , the edge @xmath206 that @xmath205 generates is the lowest edge of @xmath183 which is a chord of @xmath32 .",
    "we argue that @xmath207 ( before and after @xmath182 ; the definition of @xmath183 implies that @xmath205 precedes @xmath181 in @xmath188 ) .",
    "indeed , otherwise , by the definition of @xmath127 , @xmath208 is a vertex of the base of @xmath183 , which happens only if one of the chains of @xmath183 consists of the single edge @xmath206 .",
    "since @xmath209 and is involved in an envelope event , the edge @xmath206 must be the only edge of the left chain of @xmath183 , which contradicts the fact that @xmath47 must contain at least @xmath199 vertices of @xmath183 ( for @xmath189 ) .",
    "we distinguish between the following two cases .",
    "\\(i ) @xmath210 ( as depicted in figure [ fig : visibilityevent ] ( right ) ) . then the entire left chain of @xmath183 is contained in @xmath47 .",
    "let @xmath211 be the line passing through @xmath181 and the other two vertices of @xmath48 participating in the envelope event , and let @xmath212 be the edge of @xmath47 intersected by @xmath213 .",
    "clearly , @xmath212 is contained in @xmath183 , because otherwise @xmath214 would not be convex .",
    "if @xmath183 contains @xmath200 consecutive vertices of @xmath47 which lie immediately to the left @xmath212 , we set @xmath194 to be the set of these points , except for the leftmost one ( which may be the endpoint of the base of @xmath183 ) .",
    "otherwise we set @xmath194 to be the set of @xmath215 points lying on @xmath47 to the right of @xmath212 .",
    "since the definition of @xmath212 does not depend on @xmath188 , the set @xmath194 too does not depend on @xmath188 .",
    "\\(ii ) @xmath216 ( as depicted in figure [ fig : envelopeevent ] ( right ) ) . in this case",
    "we define at most @xmath199 sets , each consisting of @xmath217 points and independent of @xmath188 , such that all the points in at least one of these sets appear after both @xmath181 and @xmath205 in @xmath188 .",
    "we fix @xmath205 on @xmath48 to the left of @xmath181 and define @xmath218 as the set of @xmath204 consecutive vertices of @xmath47 which appear at time @xmath182 ( along @xmath47 ) immediately to the left of @xmath207 . by the current assumptions , if @xmath205 is indeed the apex of @xmath183 then all points @xmath219 belong to @xmath183 and , hence , satisfy @xmath220 .",
    "since @xmath205 is fixed , @xmath218 is also fixed and is independent of @xmath188 .",
    "hence , the above event happens with probability @xmath221 .",
    "moreover , @xmath205 is one of the at most @xmath199 vertices of @xmath48 that lie to the left of @xmath181 .",
    "hence , by the probability union bound , the total probability of this scenario ( over all the appropriate vertices @xmath216 ) is @xmath191 .",
    "we have proved that @xmath222 for any @xmath189 .",
    "this implies equation ( [ eq : logcost ] ) and completes the proof of proposition [ thm : logcostevent ] .",
    "[ corol : logcostevent ] let @xmath32 be a pseudo - triangle in the kinetic pseudo - triangulation @xmath139",
    ". then the expected number of edge insertions and deletions in @xmath127 during the period @xmath140 , conditioned upon the event that @xmath32 appears in @xmath88 , is @xmath223 .    for a fixed pseudo - triangle @xmath32 ( including the choice of the connected life span @xmath140 ) , @xmath153 and @xmath149 are 2-valued random variables : they are @xmath86 if @xmath32 does not appear in @xmath88 , and assume a fixed ",
    "deterministic \" value if @xmath32 does appear .",
    "the following theorem gives an upper bound on these values .",
    "[ theorem : quadevents ] for each pseudo - triangle @xmath224 we have @xmath225 and @xmath226 , where @xmath3 is the maximum number of times at which any fixed triple of points of @xmath0 becomes collinear .    we show the bound for visibility events .",
    "the bound for envelope events is known ( see @xcite ) and can be proved similarly .",
    "we fix a point @xmath227 and count the number of visibility events where @xmath26 is a vertex of @xmath47 which is collinear with an edge of @xmath48 .",
    "to do so , we define , for each @xmath228 , a partially defined function @xmath229 which measures the angle between @xmath121 and the @xmath230-axis , and whose domain consists of all @xmath137 at which @xmath231 .",
    "clearly , each visibility event under consideration corresponds to a breakpoint of the lower envelope of @xmath232 ( but not necessarily vice versa ; for example , such a breakpoint can arise at a time when @xmath26 is not a vertex of the funnel of @xmath32 ) . since any pair @xmath233 , @xmath234 of these functions can intersect in at most @xmath3 points ( these are times at which @xmath26 , @xmath235 , and @xmath236 are collinear ) , and for each @xmath120 the domain of @xmath229 consists of a constant number of intervals ( delimited by times at which either @xmath26 or @xmath120 swap with @xmath155 , or @xmath49 ) , it follows that the number of breakpoints is @xmath237 @xcite .",
    "a symmetric argument holds for the number of visibility events where @xmath26 is a vertex of @xmath48 which is collinear with an edge of @xmath47 . repeating this analysis for each @xmath41 yields the asserted overall bound .",
    "fix a pseudo - triangle @xmath32 . conditioned on priorities that cause @xmath32 to appear in @xmath139 , corollary [ corol : logcostevent ] and theorem [ theorem : quadevents ]",
    "imply that the expected number of discrete changes in @xmath127 is @xmath238 .",
    "let @xmath239 be the probability that @xmath32 indeed appears in @xmath139 .",
    "then the total expected number of discrete changes in @xmath139 is    @xmath240    [ lemma : boundsumquads ] @xmath241 , where the sum is over all ( possible sets of @xmath242 points defining ) possible pseudo - triangles @xmath32 .    without loss of generality",
    ", we only consider pseudo - triangles @xmath32 with @xmath175 , which are defined by five distinct points of @xmath243 .",
    "( pseudo - triangles defined by fewer than five distinct points , or those whose defining @xmath244-tuple includes @xmath104 and/or @xmath105 are analyzed similarly , replacing the exponent @xmath244 by the appropriate @xmath245 . )",
    "thus , as already noted , @xmath246 , because @xmath32 appears in @xmath139 if and only if the priorities of the five points that define @xmath32 are smaller than the priorities of all other points in @xmath157 ( and @xmath49 has the largest priority among the defining points ) .",
    "therefore @xmath247    in what follows , we call @xmath248 the _ level _ of @xmath32 .",
    "let @xmath249 ( resp .",
    "@xmath250 ) denote the maximum number of pseudo - triangles of level @xmath251 ( resp .",
    ", of level at most @xmath251 ) , defined by @xmath244 points , in a set of @xmath1 moving points .",
    "we claim that @xmath252 . to see this , consider all the pseudo - triangles @xmath32 ( defined by five points ) whose birth time is determined by a fixed @xmath25-swap event occurring at some time @xmath182 , between some pair of points @xmath253 .",
    "assume without loss of generality that @xmath170 .",
    "then @xmath49 and @xmath54 are among the @xmath254 points whose @xmath25-coordinates lie at time @xmath182 immediately to the right of @xmath255 .",
    "similarly , the fifth point , which is responsible for the destruction of @xmath32 , is one of the first @xmath256 points whose @xmath25-coordinates enter the interval between @xmath257 and @xmath82 .",
    "thus , each of the @xmath258 @xmath25-swap events defines the creation time of at most @xmath259 pseudo - triangles of level at most @xmath251 , which readily implies the asserted bound on @xmath260 .",
    "we thus have @xmath261 @xmath262    the combination of corollary [ corol : logcostevent ] , theorem [ theorem : quadevents ] , and lemma [ lemma : boundsumquads ] implies the following summary theorem .",
    "the total expected number of discrete changes in the kinetic triangulation @xmath136 is @xmath2 .",
    "in this section we describe a kinetic data structure which supports efficient maintenance of @xmath263 under motion . the structure satisfies . ]",
    "the standard requirements of _ efficiency , compactness , responsiveness _ , and _ locality _ , as reviewed in the introduction .    * the static structure . *",
    "we store the pseudo - triangulation tree @xmath88 as a treap over @xmath0 , as described in theorem [ lemma : treap ] , whose inorder is the @xmath25-order of the points and where the heap order is according to their random priorities .",
    "each node @xmath33 in @xmath88 corresponds to the pseudo - triangle @xmath264 whose apex is the point stored at @xmath33 .",
    "we also store at @xmath33 , as auxiliary data , the endpoints @xmath113 and @xmath114 , which are inherited from appropriate ancestors of @xmath33 .",
    "in addition , we also store at @xmath33 the combinatorial description of the funnel of @xmath264 , and of its triangulation @xmath265 .",
    "this includes @xmath266 , two ordered lists storing the vertices of @xmath267 , and @xmath268 in their left - to - right order , and the list of the chords of @xmath265 , sorted in their vertical order ( i.e. , the order of their intersections with the vertical line through @xmath269 ) .",
    "we represent any sorted list of vertices or edges , because the overall storage that they would require could be too large , as they can be shared by many pseudo - triangles . ] as a balanced binary tree supporting each of the operations search , split , and concatenate , in @xmath37 time @xcite . to facilitate efficient kinetic maintenance of @xmath263",
    ", we also store the vertices of the upper hull of @xmath0 , in their left - to - right order in a balanced search tree .",
    "note that each edge of the triangulation ( not on @xmath31 ) appears twice in our structure , once as @xmath266 for some pseudo triangle @xmath264 , and once on @xmath270 or @xmath271 for some ancestor @xmath272 of @xmath33 or on the convex hull of @xmath0 .",
    "[ thm : initstructure ] let @xmath0 be a set of @xmath1 points in the plane .",
    "the pseudo - triangulation tree @xmath88 , augmented with the auxiliary data items , as above , uses @xmath273 space , and it can be initialized in @xmath274 time .    the asserted bound on the overall storage follows from the easy observation that @xmath88 contains @xmath273 nodes , and every point @xmath41 appears as a non - corner vertex on at most one chain @xmath267 , @xmath268 , over all nodes @xmath33 of @xmath88 .",
    "we construct the pseudo - triangulation tree @xmath88 ( excluding the auxiliary items @xmath266 , @xmath267 , @xmath268 and the chords of @xmath265 ) in a single _ top - down _ pass , which implements the recursive construction given in section [ sect : static ] .",
    "clearly , this can be done in @xmath273 time , after an initial sorting of the points of @xmath0 , by their @xmath25-coordinates and by their priorities ; sorting the points takes @xmath275 time .",
    "we next compute the items @xmath267 , @xmath268 , and @xmath266 stored at the nodes @xmath33 of @xmath88 , by a single _ bottom - up _ traversal of @xmath88 , which computes for every node @xmath33 the upper hull @xmath276 of the set @xmath277 .",
    "when we process a new non - leaf node @xmath33 , we have already visited its respective left and right children @xmath278 and @xmath279 , so their hulls @xmath280 and @xmath281 are already available .",
    "we compute @xmath266 in @xmath37 time by a simultaneous binary seach over @xmath280 and @xmath281 , in the manner described in @xcite",
    ". then we use @xmath266 to split @xmath280 ( resp . ,",
    "@xmath281 ) into @xmath282 and @xmath267 ( resp . , @xmath268 and @xmath283 ) .",
    "we store explicitly the chains @xmath267 @xmath268 at @xmath33 , and compute @xmath276 by concatenating the three edge lists @xmath50 , @xmath284 , and @xmath51 , in a similar manner to that described in @xcite .",
    "overall , we spend @xmath37 time at each node of @xmath88 , for a total of @xmath275 time .",
    "finally , for each node @xmath33 in @xmath88 , we compute the list of chords of @xmath265 using the recursive mechanism described in section [ sect : static ] . recall that every non - corner vertex @xmath26 of the funnel of @xmath264 generates exactly one edge @xmath133 which recursively splits the unique sub - pseudo - triangle @xmath134 of @xmath264 .",
    "we process the non - corner vertices of @xmath265 in the increasing order of their priorities , and store the edges constructed so far in a list , in the order of their intersections with the vertical line through @xmath269 .",
    "it takes @xmath37 time to process a non - corner vertex @xmath26 of @xmath264 , for a total of @xmath275 time .",
    "indeed , we can determine the corners of @xmath134 in @xmath37 time , by a binary search over the list of the previously generated edges .",
    "in addition , we can determine @xmath123 by a binary search over the appropriate chain @xmath267 or @xmath268 , obtain @xmath135 in @xmath285 additional time , and insert the chord @xmath185 into the list of chords in @xmath37 time .",
    "* the kinetic certificates . * to ensure the validity of @xmath88 and its triangulation @xmath45 , we use three types of _ certificates _ , denoted as @xmath286 , @xmath287 and @xmath288 . each certificate is a predicate on a constant number of points . as long as all the certificates remain true , the validity of @xmath88 and @xmath45 is ensured .",
    "each certificate contributes a critical event to the global event priority queue @xmath289 , which is the first future time at which the certificate becomes invalid ( if there is such a time ) .",
    "* _ @xmath286-certificates_. * to ensure the validity of the tree @xmath88 ( ignoring the auxiliary data ) , each pair of points @xmath290 with consecutive @xmath25-coordinates contributes a @xmath286-certificate asserting that the order of @xmath291 and @xmath292 remains unchanged .",
    "this certificate fails at the first future moment of an @xmath25-swap between @xmath26 and @xmath120 . according to lemma [ lemma : conditionpseudo ] , @xmath286-certificates ( together with the chosen priorities )",
    "are sufficient to ensure the validity of the  bare \" tree @xmath88 .",
    "* _ @xmath287-certificates_. * for each node @xmath33 in @xmath88 , the edge @xmath293 contributes a @xmath287-certificate ensuring that the ( current ) neighbors of @xmath26 and @xmath120 on @xmath294 and @xmath295 remain below the line through @xmath26 and @xmath120 .",
    "this certificate involves does not exist then we have an even simpler certificate which fails when the two edges of @xmath296 incident to @xmath269 become collinear . ] at most six points and fails at the first future time of collinearity between @xmath119 , and one of their four neighbor vertices on @xmath294 and on @xmath295 .",
    "so far , we have ensured the validity of the tree @xmath88 and of the edges @xmath266 stored at its nodes @xmath33 .",
    "moreover , the validity of all the chains @xmath297 is also ensured because each one of their edges either belongs to @xmath31 or appears as @xmath298 at some descendant @xmath272 of @xmath33 . here",
    "a collinearity between three consecutive points on @xmath267 or on @xmath268 ( an envelope event ) will be detected as a change in @xmath298 , for the appropriate descendant @xmath272 .",
    "similarly , the validity of the upper hull of @xmath0 follows since each of its edges either belongs to @xmath31 or appears as @xmath266 at some node @xmath33 .",
    "see @xcite and @xcite for more details .    *",
    "_ @xmath288-certificates_. * it only remains to ensure the validity of the triangulations @xmath265 , over all nodes @xmath299 .",
    "for this we need the third type of certificates , denoted by @xmath288 .",
    "fix a node @xmath33 in @xmath88 .",
    "every internal point @xmath26 of @xmath267 or @xmath268 contributes a @xmath288 certificate ensuring the validity of @xmath123 .",
    "this certificate involves @xmath26 , @xmath123 , and the two points adjacent to @xmath123 on its chain .",
    "it fails when one of the points adjacent to @xmath123 becomes collinear with @xmath26 and @xmath123 .",
    "clearly , all of the above certificates use @xmath273 storage , and can be initialized , including the construction of the event queue @xmath62 of their first failure times , by the algorithm of theorem [ thm : initstructure ] , without increasing its overall assymptotic running time , i.e. , in @xmath275 time .      *",
    "_ @xmath286-certificates .",
    "_ * failure of a @xmath286-certificate occurs at an @xmath25-swap .",
    "that is , the order of the @xmath25-coordinates of two consecutive points along @xmath31 switches , at some time @xmath300 .    with no loss of generality",
    "we assume that @xmath301 , implying that @xmath302 is a descendant of @xmath303 , where @xmath304 denote the time just before and just after @xmath182 , respectively . to update @xmath305 we reconstruct from scratch the subtree rooted at the node @xmath33 containing @xmath26 , and recompute the kinetic certificates associated with its nodes and the points that they contain .",
    "we remove the failure times of the expired certificates from @xmath289 , and insert the new ones .",
    "all this can be done in @xmath306 time using the algorithm of theorem [ thm : initstructure ] , where @xmath307 .",
    "we prove that @xmath308 by applying a simplified version of the analysis used in proposition [ thm : logcostevent ] .",
    "as above , it suffices to show that @xmath309 , for any @xmath310 .",
    "indeed , @xmath311 implies that either each of the @xmath199 points @xmath272 whose @xmath25-coordinates immediately precede @xmath291 or each of the @xmath199 points @xmath272 whose @xmath25-coordinates immediately follow @xmath291 at time @xmath182 satisfies @xmath312 .",
    "this happens with probability at most @xmath313 .",
    "thus , we can reconstruct the subtree rooted at @xmath33 in @xmath314 expected time .    as can easily be checked , if neither @xmath26 nor @xmath120 is the leftmost or the rightmost point of @xmath0 ( excluding the points at infinity which we added ) then no further updates outside the subtree of @xmath33",
    "are needed , and no additional certificates need to be created or destroyed .",
    "( that is because @xmath116 and @xmath315 , so the upper hull @xmath276 contains at most one of @xmath119 , and it does not change as a result of the swap . )",
    "we next describe the necessary modifications in the setting , depicted in figure [ fig : swapenvelope ] , in which case we assume that ( i ) @xmath26 and @xmath120 are the two points with the smallest @xmath25-coordinates , ( ii ) @xmath316 , and ( iii ) the @xmath230-coordinate of @xmath26 is larger than at @xmath120 when they swap ; the other cases are treated symmetrically .",
    "the @xmath25-swap between @xmath26 and @xmath120 causes @xmath120 to appear on the upper hull of @xmath0 , below and to the left of @xmath26 .",
    "we add @xmath120 to the upper hull in @xmath37 time .",
    "similarly , @xmath120 becomes part of the tail @xmath317 of every ancestor @xmath272 of @xmath33 ( both @xmath272 and @xmath33 lie on the leftmost path of the treap ) .",
    "if @xmath272 is such an ancestor whose bridge is incident to @xmath26 ( from the right ) , then we have to incorporate @xmath120 into the certificate of @xmath298 , and possibly replace its old failure time in @xmath289 with a new one . since the expected number of ancestors @xmath272 of @xmath33 , in the treap @xmath88 , is @xmath37 ( see , e.g. , @xcite ) , any swap event can be processed in @xmath38 expected time .    * _ @xmath287-certificates_. * consider a time @xmath182 when a @xmath287-certificate at some node @xmath33 fails .",
    "we assume without loss of generality that at time @xmath182 the leftmost vertex @xmath26 of @xmath267 becomes collinear with the leftmost edge @xmath318 of @xmath283 , so that @xmath266 was @xmath121 before the event and is @xmath150 afterwards , and treat the remaining cases symmetrically .",
    "see figure [ fig : updateancestor ] for an illustration . as a result of this event ,",
    "the edge @xmath150 replaces @xmath121 as @xmath266 , the edge @xmath318 is added to the end of @xmath268 , and the triangulation @xmath265 gains the new triangle @xmath319 .",
    "we need @xmath37 time to update the edge lists of @xmath268 and @xmath265 , and to compute the @xmath288-certificate of @xmath120 ( which ceases to be the endpoint of @xmath320 ) and add its failure time to @xmath289 .",
    "( note that the @xmath288-certificate of @xmath120 is part of the former @xmath287-certificate at @xmath33 . )    to recompute the new certificate of @xmath266 , we have to determine the next edge @xmath321 of @xmath283 that is incident to @xmath152 from the right .",
    "this edge is either stored in one of the lists @xmath270 or @xmath271 at some ancestor @xmath272 of @xmath33 , or it belongs to the upper hull of @xmath0 .",
    "see figure [ fig : updateancestor ] ( left ) .",
    "we find @xmath321 by doing a binary search on the lists @xmath270 and @xmath271 for the ancestors @xmath272 of @xmath33 , and if necessary also on the convex hull of @xmath0 .",
    "if @xmath121 and @xmath318 were part of the upper hull at time @xmath179 , we replace them by a single edge @xmath150 , in @xmath37 time . otherwise , @xmath33 has some ancestor @xmath322 such that @xmath121 and @xmath318 are stored in the edge list of @xmath323 or @xmath324 .",
    "( there is exactly one such ancestor @xmath322 , which is equal to @xmath272 unless @xmath152 is incident to @xmath325 ; see figure [ fig : updateancestor ] . in the terminology of section [ sec : combichanges ]",
    ", @xmath326 experiences an envelope event at time @xmath182 . )",
    "we find @xmath322 in @xmath38 expected time by searching the edge lists stored at all ancestor nodes of @xmath33 , whose expected number is bounded by @xmath37 .",
    "we then replace @xmath121 and @xmath318 by @xmath150 in the edge list of the respective chain @xmath327 or @xmath328 , and remove from @xmath289 the failure time of the @xmath288-certificate of @xmath120 ( within @xmath326 ) .",
    "moreover , we have to retriangulate a suitable sub - pseudo - triangle @xmath183 of @xmath326 whose boundary , according to proposition [ thm : logcostevent ] , has expected complexity @xmath37 ( see also figure [ fig : envelopeevent ] ) .",
    "to do so , we first determine @xmath183 , by locating the edge @xmath329 in the edge list of @xmath330 , and then looking for the lowest ( resp . ,",
    "highest ) edge above ( resp . , below ) @xmath329 which is generated by a vertex whose priority is smaller than @xmath331 .",
    "we then recursively triangulate @xmath183 , as described in the proof of theorem [ thm : initstructure ] .",
    "all this can be done in @xmath38 expected time .",
    "therefore , we can process any @xmath287-certificate failure in @xmath38 expected time .",
    "* _ @xmath288-certificates_. * we finally consider the case when a visibility event , involving some point @xmath26 within the funnel of @xmath264 , for some node @xmath33 of @xmath88 , causes the failure of the corresponding @xmath288-certificate at some time @xmath182 . since the failed certificate is associated with an internal vertex of @xmath267 or @xmath268 ,",
    "all the necessary updates are local to the funnel of @xmath264 , and to its triangulation @xmath265 .",
    "we update the @xmath288-certificate of @xmath26 and insert its new failure time into @xmath289 , in @xmath37 time ( the new neighbor of @xmath123 is easily obtained in @xmath37 from the respective edge list ) .",
    "in addition , we may have to determine and re - triangulate a suitable sub - pseudo - triangle @xmath183 of @xmath264 , whose boundary has expected complexity @xmath332 ( see proposition [ thm : logcostevent ] ) . an in the case of a failure of a @xmath287-certificate , this can be done in @xmath333 expected time , by searching the edge list of @xmath265 .      [ maintheorem ] let @xmath8 be a collection of @xmath1 moving points , as above .",
    "we can maintain the triangulation @xmath136 under motion in a kinetic data structure of linear size , which processes an expected number of @xmath35 events , each in @xmath38 expected time , where @xmath3 is the maximum number of times at which any single triple of points of @xmath8 can become collinear .",
    "* enforcing locality . * as implied by theorem [ maintheorem ] , the proposed data structure for maintaining @xmath39 is compact , efficient , and responsive ( where the last two properties hold in expectation ) . to make it also local ( in expectation ) , it is sufficient to ensure that at any moment of time the expected number of kinetic certificates involving any single point is @xmath37 .",
    "clearly , each point is associated with at most two @xmath286-certificates .",
    "since the expected depth of @xmath88 is @xmath37 and each pseudo - triangle of @xmath88 defines a single @xmath287-certificate , each point participates in an expected number of @xmath37 @xmath287-certificates .",
    "we next slightly modify the definition of @xmath288-certificates , in order to ensure that at any moment of time the total expected number of @xmath288-certificates involving any point is also @xmath37 .",
    "consider a fixed moment of time @xmath182 and a fixed node @xmath33 in @xmath334 , and choose any vertex @xmath26 on , say , the left chain @xmath267 .",
    "currently , @xmath26 participates in a single certificate that it generates ( ensuring the validity of @xmath123 ) , and in an arbitrary number of certificates generated by all the vertices @xmath120 of @xmath268 satisfying @xmath126 .",
    "we modify our algorithm by keeping ( i.e. , storing in @xmath289 the failure times of ) only the certificates of @xmath26 that are generated by the leftmost and the rightmost such vertices @xmath120 in @xmath268 .",
    "if @xmath26 lies on @xmath268 , we act symmetrically .",
    "we apply this modification to every node @xmath33 and every vertex of @xmath335",
    ". this modification does not affect the correctness of the kinetic data structure because , as can be easily checked , among all the @xmath288-certificates involving @xmath26 and points @xmath120 with @xmath126 , the first to fail must be the extreme ones that we keep .",
    "now , at each node @xmath33 , every vertex of @xmath297 participates in at most three @xmath288-certificates .",
    "since the expected depth of @xmath88 is @xmath37 , the asserted ( expected ) locality bound follows .",
    "the kinetic maintenance of this restricted set of @xmath288-certificates resembles that of the original set , with the following minor modification .",
    "each time when we process a visibility event caused by the failure of some @xmath288-certificate , generated by a vertex @xmath26 at some node @xmath33 , we also have to recompute the @xmath288-certificates involving the old and the new points @xmath123 .",
    "this can be done in @xmath37 time using a binary search over @xmath267 or @xmath268 , which does not affect the time bounds in theorem [ maintheorem ] .",
    "j. donea , arbitrary lagrangian - eulerian finite element methods , in : _ computational methods for transient analysis _",
    "( t. b. belytschk and t. j. r. hughes , eds . ) , north - holland , elsevier , 1983 , pp .",
    "474516 .",
    "l. guibas , j. mitchell and t. roos , voronoi diagrams of moving points in the plane , _ proc .",
    "17th internat .",
    "workshop graph - theoret .",
    "concepts computer science _ , lecture notes in comp .",
    "570 , springer - verlag , 1991 , pp ."
  ],
  "abstract_text": [
    "<S> we present a simple randomized scheme for triangulating a set @xmath0 of @xmath1 points in the plane , and construct a kinetic data structure which maintains the triangulation as the points of @xmath0 move continuously along piecewise algebraic trajectories of constant description complexity . </S>",
    "<S> our triangulation scheme experiences an expected number of @xmath2 discrete changes , and handles them in a manner that satisfies all the standard requirements from a kinetic data structure : compactness , efficiency , locality and responsiveness . here </S>",
    "<S> @xmath3 is the maximum number of times where any specific triple of points of @xmath0 can become collinear , @xmath4 , and @xmath5 is the maximum length of davenport - schinzel sequences of order @xmath6 on @xmath1 symbols . </S>",
    "<S> thus , compared to the previous solution of agarwal et al .  </S>",
    "<S> @xcite , we achieve a ( slightly ) improved bound on the number of discrete changes in the triangulation . </S>",
    "<S> in addition , we believe that our scheme is simpler to implement and analyze . </S>"
  ]
}