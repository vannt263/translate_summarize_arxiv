{
  "article_text": [
    "in this paper we study extremal problems appearing in the context of finite propositional logic programs . specifically , we consider the following problem : given a class of logic programs @xmath0 , determine the maximum number of stable models a program in @xmath0 may have .",
    "extremal problems have been studied in other disciplines , especially in combinatorics and graph theory @xcite .",
    "however , no such results for logic programming have been known so far .",
    "we will consider finite propositional disjunctive logic programs built of _ clauses _ ( _ rules _ ) of the form @xmath4 where @xmath5 , @xmath6 and @xmath7 are atoms . in an effort to establish a semantics for disjunctive logic programming , gelfond and lifschitz @xcite introduced the notion of an _ answer set _ of a disjunctive program .",
    "it is well - known that for _ normal _ logic programs ( each clause has exactly one literal in the head ) , answer sets coincide with _ stable _ models @xcite .",
    "we will denote the set of answer sets of a disjunctive program @xmath8 ( stable models , if @xmath8 is normal ) by @xmath9 and we will set @xmath10    given a class @xmath0 of disjunctive programs , our goal will be to determine the value of @xmath11 we will also study the structure of _ extremal _ programs in @xmath0 , that is , those programs in @xmath0 for which the maximum is attained .",
    "we will focus our considerations on the following classes of programs :    1 .",
    "@xmath12  the class of disjunctive programs with at most @xmath1 clauses and with the length of each clause bounded by @xmath2 2 .",
    "@xmath13  the class of normal logic programs with at most @xmath1 clauses",
    ".    we will establish the values @xmath14 and @xmath15 we will show that @xmath16 ( an exact formula will be given ) and @xmath17 , and we will characterize the corresponding _ extremal _ programs .",
    "we will also show that the bound for logic programs can be improved if additional restriction on the length of a clause is imposed .",
    "we will study the class @xmath18 of logic programs with @xmath1 clauses such that each clause has at most one literal in its body .",
    "we will show that if @xmath8 is in @xmath18 , then @xmath19 .",
    "we will also study classes of programs defined by imposing restrictions on the total size of programs . by the _ size _ of a program @xmath8 , we mean the total number of atom occurrences in @xmath8 .",
    "we will investigate the following classes of programs :    1 .",
    "@xmath20  the class of disjunctive programs with size at most @xmath1 2 .",
    "@xmath21  the class of normal logic programs with size at most @xmath1    and obtain similar results to those listed above .    the motivation for this work comes from several sources .",
    "first of all , this work has been motivated by our efforts to develop fast algorithms for computing stable models of logic programs .",
    "it turns out that bounding the number of stable models and search for extremal logic programs are intimately connected to some recursive algorithms for computing stable models .",
    "two results given in section [ norm ] ( corollaries [ cor.a ] and [ cor.r ] ) imply both the bounds on the number of stable models , and a whole spectrum of algorithms to compute stable models .",
    "these algorithms share some common features with the davis - putnam procedure for testing satisfiability of cnf formulas .",
    "one of these algorithms is similar to the algorithms recently described and studied in @xcite .",
    "the corollaries also imply the worst - case bounds on the size of the search space traversed by those algorithms .",
    "let us note here that in order to lead to implemented systems for computing stable models , several research issues remain to be resolved .",
    "in particular , heuristics for choosing atoms and rules in the algorithms presented in section [ algs ] must be studied .",
    "simlarly , the effects of using well founded semantics as a preprocessing mechanism , which is known to be critical for the performance of the s - models system @xcite , has to be investigated .",
    "finally , in order to gain actual insights into the quality of the algorithms proposed here and compare them to other systems ( such as s - models ) , extensive experimental studies is necessary .",
    "all these issues are the subject of our current studies .",
    "additional motivation for our work presented here comes from considerations of expressive power of logic programming and of representability issues .",
    "both concepts help understand the scope of applicability of logic programming as a knowledge representation tool .",
    "disjunctive logic programs with answer set semantics ( logic programs with stable model semantics ) can be viewed as encodings of families of sets , namely , of the families of their answer sets ( stable models ) .",
    "a family of sets @xmath22 is _ representable _ if there is a ( disjunctive ) logic program @xmath8 such that @xmath23 important problems are : ( 1 ) to find properties of representable families of sets , and ( 2 ) given a representable family of sets @xmath24 , to find possibly concise logic program representations of @xmath24 .",
    "related problems in default logic have been studied in @xcite .",
    "it is well - known @xcite that every representable family of sets must be an antichain .",
    "our study of extremal problems in logic programming provide additional conditions .",
    "namely , every family of sets representable by a program from @xmath12 must have cardinality bounded by @xmath25 and every family of sets representable by a logic program from @xmath13 must have size bounded by @xmath26 .",
    "the best bound known previously for families of sets representable by logic programs from @xmath13 was @xmath27 .",
    "in addition , the results of this paper allow some comparison of the expressive power of different classes of programs .",
    "for example , there is a disjunctive logic program of size @xmath1 with @xmath28 answer sets while the largest cardinality of a family of sets representable by a logic program of size @xmath1 is only @xmath29 .",
    "this observation might perhaps be interpreted as evidence of stronger expressive power of disjunctive logic programs . a formal definition of the appropriate notion of expressiveness and its properties are open areas of research .    to make the paper self - contained we will now recall the definitions of a stable model and an answer set @xcite .",
    "let @xmath8 be a ( disjunctive ) propositional logic program built of atoms in the set @xmath30 .",
    "let @xmath31 .",
    "by the _ gelfond - lifschitz reduct of @xmath8 with respect to @xmath32 _ , denoted by @xmath33 , we mean the program obtained from @xmath8 by :    1 .   removing from @xmath8 all rules with a literal @xmath34 in the body , for some @xmath35 2 .",
    "removing all negative literals from all other rules in @xmath8 .",
    "if @xmath8 is a normal logic program ( no disjunctions ) , @xmath33 is a horn program .",
    "consequently , this logic program has its least model @xmath36 .",
    "a set of atoms @xmath32 is a _ stable model _ of @xmath8 if @xmath37 .",
    "if @xmath8 is a disjunctive logic program , instead of the notion of a least model of @xmath33 ( which may not exist ) , we will use the concept of a minimal model .",
    "a set of atoms @xmath32 is an _ answer set _ for @xmath8 if @xmath32 is a minimal model for @xmath33 .",
    "the paper is organized as follows . in the next section",
    ", we present our main results on normal logic programs .",
    "in particular , we determine @xmath38 and characterize the class of extremal logic programs .",
    "the following section discusses the implications of these results for the design and analysis of algorithms to compute stable models . in section [ disj ]",
    ", we study disjunctive logic programs and the last section contains conclusions .",
    "in this section we study extremal problems for normal ( non - disjunctive ) logic programs . we will determine the value of the function @xmath38 and we will provide a characterization of all programs in the class @xmath13 which have @xmath38 stable models .",
    "no bounds on the length of a clause are needed in this case .",
    "it is well known that each stable model of a program @xmath8 is a subset of the set of heads of @xmath8 .",
    "consequently , @xmath39 .",
    "this bound can easily be improved .",
    "stable models of a program form an antichain .",
    "since the size of the largest antichain in the algebra of subsets of an @xmath1-element set is @xmath40 , it clearly follows that , @xmath41 .",
    "we will still improve on this bound by showing that @xmath42 .",
    "we obtain similar results for the class @xmath43 of logic programs with @xmath1 clauses each of which has at most one literal in the body , and for the class @xmath21 of all logic programs with at most @xmath1 atom occurrences .",
    "our approach is based on the following version of the notion of reduct first described in @xcite and , independently , in @xcite .",
    "let @xmath8 be a logic program and let @xmath44 and @xmath45 be two sets of atoms such that @xmath46 .",
    "by @xmath47 we mean a logic program obtained from @xmath8 by    1 .   removing all clauses with the head in @xmath48 2 .",
    "removing all clauses that contain an atom from @xmath45 in the body 3 .   removing all clauses that contain literal @xmath34 , where @xmath49 , in the body 4 .   removing all atoms @xmath50 , @xmath49 and literals @xmath34 , @xmath51 , from the bodies of all remaining rules .",
    "the simplified program contains all information necessary to reconstruct stable models of @xmath8 that contain all atoms from @xmath44 ( `` make them true '' ) and that do not contain any atoms from @xmath45 ( `` make them false '' ) .",
    "the following result was obtained in @xcite ( see also @xcite ) .",
    "we provide its proof due to the key role this result plays in our considerations .",
    "[ key ] let @xmath8 be a logic program and let @xmath44 and @xmath45 be disjoint sets of atoms .",
    "if @xmath32 is a stable model of @xmath8 such that @xmath52 and @xmath53 , then @xmath54 is a stable model of @xmath47 .",
    "let us define a partition of @xmath8 into five disjoint programs @xmath55 ( some of them may be empty ) :    1 .",
    "@xmath56 consists of all clauses in @xmath8 with the head in @xmath44 2 .",
    "@xmath57 consists of all clauses in @xmath8 with the head in @xmath45 3 .",
    "@xmath58 consists of all the remaining clauses in @xmath8 that have an atom @xmath50 , where @xmath51 in the body 4 .",
    "@xmath59 consists of all the remaining clauses in @xmath8 that have a literal @xmath34 , where @xmath49 in the body 5 .",
    "@xmath60 consists of all remaining clauses in @xmath8    it is clear that @xmath61 .",
    "let @xmath32 be a stable model for @xmath8 such that @xmath52 and @xmath53 . since @xmath32 is the least model of @xmath33",
    ", @xmath32 is a model of @xmath62 .",
    "define @xmath63 .",
    "we will show that @xmath64 is a model of @xmath65 . consider a clause @xmath66 from @xmath65 such that @xmath67 . by the definition of gelfond - lifschitz reduct",
    ", there is a clause @xmath68 in @xmath69 such that @xmath70 , @xmath71 .",
    "furthermore , by the definition of @xmath69 , there is a clause @xmath72 in @xmath60 such that @xmath73 , @xmath74 , and @xmath75 , @xmath76 . since @xmath77",
    ", it follows that the clause @xmath78 belongs to @xmath62 .",
    "moreover , since @xmath52 , @xmath79 . since @xmath32 is a model of @xmath62 , @xmath35 . by the definition of programs @xmath80 , @xmath81 .",
    "hence , @xmath82 and , consequently , @xmath64 is a model of @xmath65 .",
    "consider a model @xmath83 of @xmath65 .",
    "assume that @xmath84 .",
    "observe that @xmath85 is a model of @xmath86 .",
    "since @xmath87 , @xmath85 is a model of @xmath88 .",
    "it is also clear ( @xmath52 ) that @xmath89 .",
    "consider a rule @xmath66 from @xmath90 . since @xmath32 is a model of @xmath90 and since @xmath91 ( recall that @xmath51 and @xmath53 )",
    ", there is @xmath92 , @xmath93 , such that @xmath94 . since @xmath95 , @xmath96 .",
    "thus , any rule in @xmath90 is satisfied by @xmath97 .",
    "finally , consider a rule @xmath98 from @xmath62 .",
    "assume that @xmath99 .",
    "without loss of generality , we may assume that @xmath100 are the only @xmath6s that belong to @xmath44 .",
    "then , @xmath101 and @xmath66 is in @xmath65 . since @xmath83 is a model of @xmath65 , @xmath102 .",
    "thus , it follows that @xmath85 is a model of @xmath62 and , taking into account the observations made earlier , also of @xmath33 . since @xmath95 and",
    "since @xmath32 is the least model of @xmath33 , it follows that @xmath103 . since @xmath104",
    ", it follows that @xmath105 .",
    "consequently , @xmath64 is the least model of @xmath65 . by the definition of @xmath80s",
    ", it follows that @xmath106 .",
    "moreover , since @xmath61 , we have that @xmath107 .",
    "therefore , @xmath64 is the least model of @xmath108 and , consequently , a stable model of @xmath47 .    in general , the implication in this result can not be reversed .",
    "however , it is well known @xcite that if @xmath44 and @xmath45 are the sets of atoms respectively true and false under the well - founded semantics for @xmath8 , then the converse result holds , too . that is , for every stable model @xmath64 of @xmath47 , @xmath109 is a stable model of @xmath8 .",
    "let @xmath8 be a propositional logic program and let @xmath110 be an atom .",
    "we define    1 .",
    "@xmath111 2 .",
    "@xmath112 .",
    "programs @xmath113 and @xmath114 are referred to as _ positive _ and _ negative reducts of @xmath8 with respect to @xmath110 _ , respectively .",
    "intuitively , @xmath113 and @xmath114 are the programs implied by @xmath8 and sufficient to determine all stable models of @xmath8 .",
    "those stable models of @xmath8 that contain @xmath110 can be determined from @xmath113 , and those stable models of @xmath8 that do not contain @xmath110 , from @xmath114 .",
    "formally , we have the following result .    [ cor.a ]",
    "let @xmath8 be a logic program and @xmath110 be an atom in @xmath8 .    1 .",
    "let @xmath32 be a stable model of @xmath8 .",
    "if @xmath115 then @xmath116 is a stable model of @xmath113 . if @xmath117 then @xmath32 is a stable model of @xmath114",
    "2 .   @xmath118 .",
    "similarly , we will define now _ positive _ and _ negative reducts of @xmath8 with respect to a clause @xmath119_. assume that @xmath120 . then , define    1 .",
    "@xmath121 , and 2 .",
    "@xmath122 .",
    "we say that a logic program clause @xmath119 is _ generating _ for a set of atoms @xmath123 if every atom occurring positively in the body of @xmath119 is in @xmath123 and every atom occurring negated in @xmath119 is not in @xmath123 . using the concept of a generating clause , the intuition behind the definitions of @xmath124 and @xmath125 is as follows .",
    "the reduct @xmath124 allows us to compute all those stable models of @xmath8 for which @xmath119 _ is _ a generating clause .",
    "the reduct @xmath125 , on the other hand , allows us to compute all those stable models of @xmath8 for which @xmath119 is _ not _ generating .",
    "more formally , we have the following lemma .",
    "[ cor.r ] let @xmath8 be a logic program and @xmath126 be a clause of @xmath8 .    1 .",
    "let @xmath32 be a stable model of @xmath8 . if @xmath127 and @xmath128 then @xmath129 is a stable model of @xmath124 .",
    "otherwise @xmath32 is a stable model of @xmath125 .",
    "2 .   @xmath130 .",
    "also in the case of this result , the implication in its statement can not be replaced by equivalence .",
    "that is , not every stable model of the reduct ( @xmath124 or @xmath125 ) gives rise to a stable model of @xmath8 .",
    "it should be clear that corollaries [ cor.a ] and [ cor.r ] imply recursive algorithms to compute stable models of a logic program .",
    "we will discuss these algorithms in the next section . in the remainder of this section",
    ", we will investigate the problem of the maximum number of stable models of logic programs in classes @xmath13 , @xmath43 and @xmath21 .    to this end",
    ", we will introduce the class of canonical logic programs and determine for them the number of their stable models .",
    "we will use canonical programs to characterize extremal logic programs in the class @xmath13 .",
    "[ def.can ] let @xmath131 be a set of atoms .",
    "by @xmath132 we denote the clause @xmath133 a _ canonical _ logic program over @xmath134 , denoted by @xmath135 $ ] , is the logic program containing exactly @xmath136 clauses @xmath137 , that is @xmath138 = \\bigcup_{i=1}^k \\{c(a_i)\\}.\\ ] ]    intuitively , the program @xmath135 $ ] `` works '' by selecting exactly one atom from @xmath134 .",
    "formally , @xmath135 $ ] has exactly @xmath136 stable models of the form @xmath139 , for @xmath140 .",
    "[ def.234 ] let @xmath8 be a logic program and @xmath134 be the set of atoms which appear in @xmath8 .",
    "program @xmath8 is a _ @xmath141-program _",
    "if @xmath134 can be partitioned into pairwise disjoint sets @xmath142 such that @xmath143 for @xmath144 , and @xmath145.\\ ] ]    roughly speaking , a @xmath141-program is a program which arises as a union of independent canonical programs of sizes 2 , 3 or 4 .",
    "a @xmath141-program is stratified in the sense of @xcite and the canonical programs are its strata",
    ". stable models of a @xmath141-program can be obtained by selecting ( arbitrarily ) stable models for each stratum independently and , then , forming their unions .    by the _ signature _ of a @xmath141-program @xmath8 we mean the triple @xmath146 , where @xmath147 , @xmath148 , is the number of canonical programs over an @xmath92-element set appearing in @xmath8 .",
    "up to isomorphism , a @xmath141-program is uniquely determined by its signature .",
    "other basic properties of @xmath141-programs are gathered in the following proposition ( its proof is straightforward and is omitted ) .",
    "[ lem.234 ] let @xmath8 be a @xmath141-program with @xmath1 clauses and with the signature @xmath149 .",
    "then :    1 .",
    "@xmath150 , 2 .",
    "@xmath151 .    as a direct corollary to proposition [ lem.234 ] ,",
    "we obtain a result describing @xmath141-programs with @xmath1 clauses and maximum possible number of stable models . for @xmath152 ,",
    "let us define @xmath153 to be the unique ( up to isomorphism ) @xmath141-program with the signature @xmath154 , and @xmath155 and @xmath156 to be the unique ( up to isomorphism ) @xmath141-programs with the signatures @xmath157 and @xmath158 , respectively .",
    "finally , for @xmath159 , let us define @xmath160 to be the unique ( up to isomorphism ) @xmath141-program with the signature @xmath161 .",
    "[ cor-4 ] let @xmath8 be a @xmath141-program with @xmath1 clauses and maximum number of stable models .",
    "then ,    1 .   if @xmath162 for some @xmath152 , @xmath163 , 2 .   if @xmath164 for some @xmath152 , @xmath165 or @xmath156 , 3 .   if @xmath166 for some @xmath167 , @xmath168",
    "consequently , the maximum number of stable models of an @xmath141-programs with @xmath1 clauses is given by @xmath169    corollary [ cor-4 ] implies that @xmath170 and that @xmath171 we will show that @xmath172",
    ". we will also determine the class of all extremal programs .",
    "we call an atom @xmath110 occurring in @xmath8 _ redundant _ if @xmath110 is not the head of a clause in @xmath8 .",
    "let @xmath8 be a logic program .",
    "by @xmath173 we denote the logic program obtained from @xmath8 by removing all negated occurrences of redundant atoms .",
    "we define the class @xmath174 to consist of all programs @xmath8 such that    1 .",
    "@xmath173 is @xmath153 , if @xmath162 ( @xmath152 ) , 2 .",
    "@xmath173 is @xmath160 , if @xmath166 ( @xmath167 ) , or 3 .",
    "@xmath173 is @xmath155 or @xmath156 , if @xmath164 ( @xmath152 ) .",
    "[ thm.main ] if @xmath8 is an extremal logic program with @xmath175 clauses , then @xmath8 has @xmath176 stable models . that is , for any @xmath175 @xmath177 in addition , the extremal programs in @xmath13 are exactly the programs in @xmath174 .",
    "theorem [ thm.main ] can be proved by induction on @xmath1 .",
    "the proof relies on corollaries [ cor.a ] and [ cor.r ] that establish recursive dependencies between the number of stable models of @xmath8 and of its reducts .",
    "it is rather lengthy and , therefore , we provide it in the appendix .",
    "the general bound of theorem [ thm.main ] can still be slightly improved ( lowered ) if the class of programs is further restricted .",
    "since there are extremal programs for the whole class @xmath13 with no more than 2 literals in the body of each clause , the only reasonable restriction is to limit the number of literal occurrences in the body to at most 1 .",
    "the class of programs with @xmath1 clauses and satisfying this restriction will be denoted by @xmath43 .",
    "denote by @xmath178 a @xmath141-program with signature @xmath179 .",
    "clearly , @xmath180 .",
    "we have the following result .",
    "the proof uses similar techniques as the proof of theorem [ thm.main ] and is omitted .",
    "[ body-1 ] for every program @xmath181 , @xmath182 . moreover , there are programs in @xmath43 for which this bound is attained .",
    "program @xmath178 is a unique ( up to isomorphism ) extremal program with @xmath183 clauses , and every extremal program with @xmath184 clauses can be obtained by adding one more clause to @xmath178 of one of the following forms : @xmath185 , @xmath186 , and @xmath187 , where @xmath188 is an arbitrary atom ( may or may not occur in @xmath178 ) , and @xmath50 and @xmath189 are atoms not occurring in @xmath178 .",
    "next , we will consider the class @xmath21 of all logic programs with the total size ( number of literal occurrences in the bodies and heads ) at most @xmath1 .",
    "let @xmath190 be defined as the maximum number of stable models for a program in @xmath21 .",
    "we have the following result .    [ total - n ] for every integer @xmath191 , @xmath192",
    ".    we will show that for every @xmath191 , and for every logic program of size at most @xmath1 , @xmath193 .",
    "we will proceed by induction .",
    "consider a logic program @xmath8 such that the size of @xmath8 is at most @xmath194 .",
    "if @xmath8 has one rule , then it has at most one stable model . if @xmath8 has two rules and one of them is a fact ( rule with empty body ) , then @xmath8 has at most one stable model .",
    "otherwise , @xmath181 and @xmath193 follows from theorem [ body-1 ] .",
    "if @xmath8 has three rules , then at least two of these rules are facts and @xmath8 has at most one stable model .",
    "if @xmath8 has four rules , it is a horn program and has exactly one stable model . hence , in all these cases , @xmath193 .",
    "since @xmath8 has size 4 , it has at most four rules and the basis of induction is established .",
    "consider now a logic program @xmath8 of size @xmath195 .",
    "assume that @xmath8 has a rule , @xmath119 , with at least two elements in its body .",
    "let @xmath50 be the head of @xmath119 . if @xmath50 and @xmath34 do not occur in the body of any rule in @xmath196 , then @xmath197 and the result follows by the induction hypothesis",
    "so , assume that there is a rule in @xmath196 such that @xmath50 or @xmath34 occurs in its body .",
    "then , both @xmath198 and @xmath199 have sizes at most @xmath200 . by corollary [ cor.a ] , @xmath201 .",
    "consequently , by the induction hypothesis , @xmath202 .",
    "thus , assume that each rule in @xmath8 has at most one literal in its body .",
    "if at least one of these rules , say @xmath119 , has empty body , then every stable model of @xmath8 contains the head of @xmath119 ( say @xmath50 ) .",
    "thus , @xmath203 ( corollary [ cor.a ] ) and the result follows by the induction hypothesis .",
    "hence , assume that each rule in @xmath8 has nonempty body .",
    "let @xmath188 be the number of rules in @xmath8 .",
    "then , @xmath204 .",
    "moreover , @xmath205 . by theorem [ body-1 ] , @xmath206 .    finally , let us observe that every antichain @xmath24 of sets of atoms is representable by a logic program .",
    "[ rep ] for every antichain @xmath24 of finite sets there is a logic program @xmath8 such that @xmath207 .",
    "moreover , there exists such @xmath8 with at most @xmath208 clauses and total size at most @xmath209 .",
    "consider a finite antichain @xmath24 of finite sets .",
    "let @xmath210 .",
    "for every @xmath211 , @xmath212 , denote by @xmath213 an element from @xmath214 ( it is possible as @xmath24 is an antichain ) .",
    "now , for each element @xmath215 , define @xmath216 where @xmath217 are all elements of @xmath24 _ other _ than @xmath218 .",
    "next , define a program @xmath219 to consist of all rules @xmath220 , for @xmath215 . finally , define @xmath221 it is easy to verify that @xmath222 and that the size of @xmath223 is @xmath224 .",
    "on one hand this theorem states that logic programs can encode any antichain @xmath24 . on the other ,",
    "the encoding that is guaranteed by this result is quite large ( in fact , larger than the explicit encoding of @xmath24 ) . in the same time , our earlier results show that often substantial compression can be achieved . in particular , there are antichains of the total size of @xmath225 that can be encoded by logic programs of size @xmath226 .",
    "more in - depth understanding of applicability of logic programming as a tool to concisely represent antichains of sets remains an open area of investigation .",
    "in this section we will describe algorithms for computing stable models of logic programs .",
    "these algorithms are recursive and are implied by corollaries [ cor.a ] and [ cor.r ] .",
    "they select an atom ( or a clause , in the case of corollary [ cor.r ] ) and compute the corresponding reducts . according to corollaries",
    "[ cor.a ] and [ cor.r ] , stable models of @xmath8 can be reconstructed from stable models of the reducts .",
    "however , it is not , in general , the case that every stable model of a reduct implies a stable model of @xmath8 ( see the comments after corollary [ cor.r ] ) .",
    "therefore , all candidates for stable models for @xmath8 , that are produced out of the stable models of the reduct , must be tested for stability for @xmath8 . to this end",
    ", an auxiliary procedure is_stable is used .",
    "calling is_stable for a set of atoms @xmath32 and a logic program @xmath8 returns * true * if @xmath32 is a stable model of @xmath8 , and it returns * false * , otherwise .",
    "in our algorithms we use yet another auxiliary procedure , implied_set .",
    "this procedure takes one input parameter , a logic program @xmath8 , and outputs a set of atoms @xmath32 and a logic program @xmath227 ( modified @xmath8 ) with the following properties :    1 .",
    "@xmath32 is a subset of every stable model of @xmath8 , and 2 .",
    "stable models of @xmath8 are exactly the unions of @xmath32 and stable models of @xmath227",
    ".    there are several specific choices for the procedure implied_set .",
    "a trivial option is to return @xmath228 and @xmath229 . another possibility is implied by our comments following the proof of lemma [ key ] .",
    "let @xmath44 and @xmath45 be sets of atoms that are true and false , respectively , under the well - founded semantics for @xmath8 .",
    "the procedure implied_set might return @xmath44 as @xmath32 , the program @xmath47 as @xmath227 .",
    "this choice turned out to be critical to the performance of the s - models system @xcite and , we expect , it will lead to significant speedups once our algorithms are implemented . however , in general , there are many other , intermediate , ways to compute @xmath32 and @xmath227 in polynomial time so that conditions ( 1 ) and ( 2 ) above are satisfied .",
    "experimental studies are necessary to compare these defferent choices among each other ( this is a subject of an ongoing work ) .    ' '' ''",
    "+ stable_models_a@xmath230 + _ input : _ a finite logic program @xmath8 ; + _ returns : _ family @xmath231 of all stable models of @xmath8 ; +   + implied_set(@xmath232 ) ; + * if * @xmath233 * then * * return * @xmath234 + * else * + @xmath235 ; + @xmath236 select_atom(@xmath227 ) ; +   + @xmath237 ; + @xmath238 stable_models_a(@xmath56 ) ; + @xmath239 * do * * if * is_stable(@xmath240 ) * then * @xmath241 ; +   + @xmath242 ; + @xmath238 stable_models_a(@xmath57 ) ; + @xmath239 * do * * if * is_stable(@xmath243 ) * then * @xmath244 ; +   + @xmath231 ; +    ' '' ''    we will now describe the algorithms .",
    "we adopt the following notation . for a logic program clause @xmath119 , by @xmath245 we denote the head of @xmath119 and by @xmath246 , the set of atoms occurring positively in the body of @xmath119 .",
    "first , we will discuss an algorithm based on splitting the original program ( that is , computing the reducts ) with respect to a selected atom .",
    "this idea and the resulting algorithm appeared first in @xcite .",
    "the correctness of this method is guaranteed by lemma [ key ] ( or , more specifically , by corollary [ cor.a ] ) .",
    "we call this algorithm stable_models_a .    in this algorithm , to compute stable models for an input program @xmath8 we first simplify it to a program @xmath227 by executing the procedure implied_set",
    ". a set of atoms @xmath32 contained in all stable models of @xmath8 is also computed . due to our requirements on the implied_set procedure , at this point , to compute all models of @xmath8 , we need to compute all models of @xmath227 and expand each by @xmath32 . to this end , we select an atom occurring in @xmath227 , say @xmath110 , by calling a procedure select_atom .",
    "then , we compute the reducts @xmath247 and @xmath248 .",
    "for both reducts we compute their stable models .",
    "each of these stable models gives rise to a set of atoms @xmath249 ( in the case of stable models for @xmath247 ) or @xmath250 ( in the case of stable models for @xmath248 ) .",
    "each of these sets is a candidate for a stable model for @xmath227 .",
    "calls to the procedure is_stable determine those that are .",
    "these sets , expanded by @xmath32 , are returned as the stable models of @xmath8 .",
    "we present the pseudocode for this algorithm in figure [ fig.alg1 ] .    ' '' ''     + stable_models_r@xmath230 + _ input : _ a finite logic program @xmath8 ; + _ returns : _ family @xmath231 of all stable models of @xmath8 ; +   + implied_set(@xmath232 ) ; + * if * @xmath233 * then * * return * @xmath234 + * else * + @xmath235 ; + @xmath251 select_clause(@xmath227 ) ; +   + @xmath252 ; + @xmath238   stable_models_r(@xmath56 ) ; + @xmath239 * do * * if *   is_stable(@xmath253 ) + @xmath254 ; +   + @xmath255 ; + @xmath238  stable_models_r(@xmath57 ) ; + @xmath239 * do * * if *   is_stable(@xmath243 ) * then * @xmath244 ; +   + @xmath231 ; +    ' '' ''    the second algorithm , stable_models_r , is similar .",
    "it is based on corollary [ cor.r ] . that is , instead of trying to find stable models of @xmath8 among the sets of atoms implied by the stable models of @xmath113 and @xmath114 , we search for stable models of @xmath8 using stable models of @xmath124 and @xmath125 , where @xmath119 is a _ clause _ of @xmath8 .",
    "the correctness of this approach follows by corollary [ cor.r ] .",
    "the pseudocode is given in figure [ fig.alg2 ] .",
    "algorithms stable_models_a and stable_models_r can easily be merged together into a hybrid method , which we call stable_models_h ( figure [ fig.hyb ] ) . here ,",
    "in each recursive call to stable_models_h we start by deciding whether the splitting ( reduct computation ) will be performed with respect to an atom or to a clause .",
    "the function select_mode(``atom'',``clause '' ) makes this decision .",
    "then , depending on the outcome , the algorithm follows the approach of either stable_models_a or stable_models_r .",
    "that is , either an atom or a clause is selected , the corresponding reducts are computed and recursive calls to stable_models_h are made .",
    "all three algorithms provide a convenient framework for experimentation with different heuristics for pruning the search space of all subsets of the set of atoms .",
    "in general , the performance of these algorithms depends heavily on how the selection routines select_atom , select_clause and select_mode are implemented .",
    "although any selection strategy yields a correct algorithm , some approaches are more efficient than others . in particular",
    ", the proof of theorem [ thm.main ] implies selecting techniques for the algorithm stable_models_h guaranteeing that the algorithm terminates after the total of at most @xmath3 recursive calls .",
    "let us also observe that the recursive dependencies given in corollaries [ cor.a ] and [ cor.r ] indicate that in order to keep the search space ( number of recursive calls ) small , selection heuristics should attempt to keep the total size of @xmath256 or @xmath257 as small as possible .    ' '' ''",
    "+ stable_models_h@xmath230 + _ input : _ a finite logic program @xmath8 ; + _ returns : _ family @xmath231 of all stable models of @xmath8 ; +   + implied_set(@xmath232 ) ; + * if * @xmath233 * then * * return * @xmath234 + * else * + @xmath235 ; + @xmath258 select_mode(``atom'',``clause '' ) ; + @xmath259  * then * +   + @xmath236 select_atom(@xmath227 ) ; + @xmath237 ; + @xmath238 stable_models_h(@xmath56 ) ; + @xmath239 * do * * if * is_stable(@xmath240 ) * then * @xmath241 ; + @xmath242 ; + @xmath238 stable_models_h(@xmath57 ) ; + @xmath239 * do * * if * is_stable(@xmath243 ) * then * @xmath244 ; +   + @xmath260 +   + @xmath251 select_clause(@xmath227 ) ; + @xmath252 ; + @xmath238",
    "stable_models_h(@xmath56 ) ; + @xmath239 * do * * if *   is_stable(@xmath253 ) + @xmath254 ; + @xmath255 ; + @xmath238  stable_models_h(@xmath57 ) ; + @xmath239 * do * * if *   is_stable(@xmath243 ) * then * @xmath244 ; +   + @xmath231 ; +    ' '' ''    the presented algorithms compute all stable models for the input program @xmath8 .",
    "they can be easily modified to handle other tasks associated with logic programming .",
    "that is , they can be tailored to compute one stable model , determine whether a stable model for @xmath8 exists , as well as answer whether an atom is true or false in all stable models of @xmath8 ( cautious reasoning ) , or in one model of @xmath8 ( brave reasoning ) .",
    "all these tasks can be accomplished by adding a suitable stop function and by halting the algorithm as soon as the query can be answered .",
    "the general structure of our algorithms is similar to well - known davis - putnam method for satisfiability problem .",
    "the implied_set procedure corresponds to the , so called , unit - propagation phase of davis - putnam algorithm . in this phase",
    "necessary and easy - to - compute conclusions of the current state are drawn to reduce the search space .",
    "if the answer is still unknown then a guess is needed and two recursive calls are performed to try both possibilities .",
    "but there are also differences . first , in our case",
    ", splitting can also be done with respect to a clause .",
    "the second difference is due to nonmonotonicity of stable semantics for logic programs .",
    "when a recursive call in davis - putnam procedure returns an answer , this answer is guaranteed to be correct .",
    "there is no such guarantee in the case of stable models .",
    "each answer ( stable model ) returned by a recursive call in our algorithms must be additionally tested ( by is_stable procedure ) to see whether it is a stable model for the original program .",
    "in this section , we will focus on the class of disjunctive logic programs @xmath12 . for",
    "a set of atoms @xmath261 , let us denote by @xmath262 the disjunctive clause of the form @xmath263 by @xmath264 , we will denote the disjunctive logic program consisting of @xmath1 clauses : @xmath265 @xmath266 @xmath267 with all atoms @xmath268  distinct .",
    "it is clear that every set of the form @xmath269 is an answer set for @xmath264 , and that all answer sets for @xmath264 are of this form .",
    "hence , @xmath270 consequently , general upper bounds on the number of answer sets for disjunctive programs in such classes that allow clauses of arbitrary length do not exist .",
    "turning attention to the class @xmath12 , it is now clear that , since @xmath271 , @xmath272 the main result of this section shows that , in fact , @xmath273 and the program @xmath264 is the only ( up to isomorphism ) extremal program in this class .    consider a clause @xmath274 of the form @xmath275 by @xmath276 we will denote the clause obtained from @xmath274 by moving all negated atoms to the head .",
    "that is , @xmath276 is of the form : @xmath277 let @xmath278 be a disjunctive program .",
    "define @xmath279    [ lem-1 ] for every disjunctive logic program @xmath278 , @xmath280 .",
    "let @xmath281 .",
    "then , @xmath32 is a minimal model of the gelfond - lifschitz reduct @xmath282 and , as is well - known , @xmath32 is a model of @xmath278 .",
    "it follows that @xmath32 is a model of @xmath283 . to show that @xmath284 , we need to show that @xmath32 is a minimal model of @xmath283 .    consider a model @xmath64 of @xmath283 and assume that @xmath285 .",
    "take a clause @xmath286 from @xmath282 .",
    "then , there is a rule @xmath287 in @xmath278 such that @xmath288 and @xmath289 . since @xmath285 , @xmath290 .",
    "assume that @xmath291 .",
    "then , since @xmath64 is a model of @xmath278 ( recall that it is a model of @xmath283 ) , there is @xmath92 , @xmath292 , such that @xmath293 .",
    "it follows that @xmath64 is a model of @xmath282 . since @xmath32 is a minimal model of @xmath282 , @xmath294 .",
    "hence , @xmath32 is a minimal model of @xmath283 .",
    "lemma [ lem-1 ] allows us to restrict our search for disjunctive programs with the largest number of answer sets to those programs that do not contain negated occurrences of atoms .",
    "[ aux-1 ] let @xmath278 be a disjunctive program with @xmath1 rules @xmath295",
    ". assume that for each @xmath92 , @xmath296 , @xmath297 has empty body and exactly @xmath298 different disjuncts in the head .",
    "then @xmath278 has at most @xmath299 answer sets .",
    "moreover , if @xmath278 has exactly @xmath299 different answer sets , then no two rules have the same atom in their heads .",
    "clearly , for each program whose every rule has empty body , answer sets are exactly minimal models .",
    "so , we have to prove that @xmath278 has at most @xmath299 minimal models",
    ". we will proceed by induction on the size of @xmath278 ( total number of literal occurrences in @xmath278 ) .",
    "if the size of @xmath278 is 1 , the assertion holds .",
    "consider now a disjunctive logic program @xmath278 of size @xmath300 , whose each rule has empty body .",
    "assume @xmath278 has @xmath1 rules @xmath295 and that for each @xmath92 , @xmath296 , @xmath297 has exactly @xmath298 different disjuncts in the head .",
    "consider a minimal model @xmath32 of @xmath278 .",
    "let @xmath50 be any atom appearing in the head of @xmath301 .",
    "let @xmath32 be a minimal model of @xmath278 .",
    "assume that @xmath91 .",
    "then , @xmath32 is a minimal model of a program @xmath302 obtained from @xmath278 by removing @xmath50 from the head of each rule in which it appears . by induction hypothesis",
    "applied to @xmath302 , there are at most @xmath303 minimal models @xmath32 of @xmath278 that do not contain @xmath50 . moreover",
    ", this number equals @xmath303 precisely if the heads of rules of @xmath302 have @xmath304 , @xmath305 disjuncts in their heads , and if no atom appears in @xmath302 more than once .",
    "this happens precisely when no atom appears more than once in @xmath278 .",
    "the other possibility for @xmath32 is that @xmath35 . in this case , define @xmath302 to be a program obtained from @xmath278 by removing all clauses with @xmath50 in the head ( in particular , @xmath301 is removed ) .",
    "assume that @xmath306 .",
    "since @xmath301 is removed , @xmath307 . clearly , @xmath308 is a minimal model of @xmath302 .",
    "if @xmath309 , by induction hypothesis , it follows that there are at most @xmath310 minimal model of @xmath278 that contain @xmath50 .",
    "moreover , this number equals @xmath311 occurs precisely when @xmath50 occurs only in @xmath301 and if no atom appears more than once in @xmath312 .",
    "it follows that the total number of minimal models of @xmath278 is at most @xmath313 it also follows that the number of minimal models of @xmath278 is @xmath299 if and only if no atom appears in @xmath278 more than once .",
    "[ th-1 ] for every integers @xmath314 and @xmath191 , and for every program @xmath315 , @xmath316 .",
    "moreover , the program @xmath264 is the only program in the class @xmath12 for which the bound of @xmath25 is reached .",
    "in particular , @xmath17",
    ".    we will proceed by induction on @xmath1 .",
    "the theorem clearly holds if @xmath317 .",
    "it is also true if @xmath318 .",
    "so , assume that @xmath319 and @xmath320 .",
    "we will first focus on disjunctive programs in @xmath12 that do not contain negated occurrences of atoms .",
    "let @xmath321 be such a program , say @xmath322 .",
    "assume that the rule @xmath297 has @xmath298 atoms in its head .",
    "if each clause in @xmath278 has a nonempty body , @xmath278 has exactly one answer set model , the empty set . since @xmath319 , @xmath323 ( the inequality holds and @xmath278 is not extremal ) .",
    "next , assume that at least one rule in @xmath278 has empty body .",
    "let @xmath302 be a subset of @xmath278 consisting of all the clauses with the empty body .",
    "let @xmath324 denote the number of clauses in @xmath302 .",
    "hence , @xmath325 .",
    "each minimal model for @xmath278 can be obtained by the following procedure :    1 .",
    "pick a minimal model @xmath64 of @xmath302 . if @xmath326 , output @xmath64 and stop .",
    "2 .   otherwise ,",
    "reduce @xmath327 by removing clauses satisfied by @xmath64 as well as atoms from the bodies of the remaining rules that belong to @xmath64 .",
    "call the resulting program @xmath328 .",
    "3 .   pick a minimal model @xmath83 of @xmath328 .",
    "output @xmath329 as a minimal model of @xmath278 .",
    "clearly , lemma [ aux-1 ] applies to @xmath302 .",
    "hence , @xmath330 , with equality if and only if @xmath331 .",
    "if @xmath332 , then there is only one possibility for @xmath83 , namely @xmath333 . if @xmath334 , @xmath335 , for some @xmath336 . by induction hypothesis , @xmath337",
    "moreover , equality holds if and only if @xmath338 .",
    "consequently , @xmath339 , with equality holding if and only if @xmath340 .",
    "consider now an arbitrary program @xmath321 .",
    "assume that @xmath278 is extremal .",
    "it follows from lemma [ lem-1 ] that @xmath283 is also extremal .",
    "hence , @xmath341 .",
    "assume that @xmath342 .",
    "then , there is a rule in @xmath278 that contains at least one negated atom , say @xmath50 .",
    "it follows from the definitions of @xmath283 and @xmath264 , and from the equality @xmath341 that :    1 .",
    "there is an answer set @xmath32 of @xmath283 such that @xmath35 , and 2 .",
    "no answer set for @xmath278 contains @xmath50 .    since @xmath280 , and since @xmath283 is extremal",
    ", it follows that @xmath278 is not extremal , a contradiction .",
    "hence , @xmath343 .",
    "finally , we will consider the class @xmath344 of all logic programs with the total size ( number of literal occurrences in the bodies and heads ) at most @xmath1 .",
    "let @xmath345 be defined as the maximum number of answer sets for a disjunctive program in @xmath344 .",
    "we have the following result .",
    "[ d - total - n ] for every @xmath320 , @xmath346 .",
    "assume that @xmath278 has size @xmath1 and that it has @xmath136 rules . by theorem [ th-1 ]",
    "it follows that @xmath347 , where @xmath348 .",
    "the value @xmath349 , under the constraint @xmath348 , assumes its maximum for @xmath350 .",
    "hence , for every disjunctive logic program @xmath278 of size @xmath1 , @xmath351 . in the same time , program @xmath352 demonstrates that there is a disjunctive program @xmath278 of size at most @xmath1 such that @xmath353 .",
    "hence , the assertion follows .    compared with the estimate from theorem [ total - n ] for the function @xmath190 ,",
    "the function @xmath345 is much larger ( it is , roughly the square of @xmath190 .",
    "consequently , there are antichains representable by disjunctive logic programs with the cardinality of the order of the square of the cardinality of largest antichains representable by logic programs of the same total size .",
    "this may be an additional argument for disjunctive logic programs as a knowledge representation mechanism .",
    "in this paper , we studied extremal problems appearing in the area of logic programming .",
    "specifically , we were interested in the maximum number of stable models ( answer sets ) a program ( disjunctive program ) from a given class may have .",
    "we have studied several classes in detail .",
    "we determined the maximum number of stable models for logic programs with @xmath1 clauses . similarly ,",
    "this maximum was also established for logic programs with @xmath1 clauses , each of length at most 2 , and for logic programs of total size at most @xmath1 . in some of these cases we also characterized the extremal programs , that is , the programs for which the maxima are attained .",
    "similar results were obtained for disjunctive logic programs .",
    "our results have interesting algorithmic implications .",
    "several algorithms , having a flavor of davis - putnam procedure , for computing stable model semantics are presented in the paper .",
    "extremal problems for logic programming have not been studied so far .",
    "this paper shows that they deserve more attention .",
    "they are interesting in their own right and have interesting computational and knowledge representation applications .",
    "first , we prove auxiliary lemmas which will be used in the proof of theorem [ thm.main ]      let @xmath8 be a program with @xmath1 rules and @xmath356 stable models . to complete the proof it is enough to show that there is a logic program @xmath357 with @xmath358 rules and @xmath359 .",
    "assume first that @xmath360 .",
    "then , as @xmath357 we can take any program with @xmath358 rules and 2 or more stable models ( since @xmath361 , such programs exist ) .",
    "suppose now , that @xmath8 has at least 2 stable models .",
    "let @xmath362 be the all stable models of @xmath8 .",
    "we construct @xmath357 as follows .",
    "since stable models of a logic program form an antichain , every model @xmath363 , @xmath364 , is not empty . let @xmath189 be a propositional atom not occurring in @xmath8 .",
    "let @xmath365 be any set of atoms such that for all @xmath366 , @xmath367 .",
    "finally , let @xmath368 it is easy to see that @xmath369 are stable models for @xmath357 .",
    "thus , the proof of the lemma is complete .",
    "a clause @xmath119 of @xmath8 is called _ redundant _ if the head of @xmath119 occurs ( negated or not ) in the body of @xmath119 , or if there is an atom @xmath110 such that both @xmath110 and @xmath370 occur in the body of @xmath119 .      1 .",
    "@xmath8 contains no positive redundant literals , 2 .",
    "@xmath8 contains no redundant rules , 3 .",
    "@xmath8 contains no facts ( i.e. rules with empty body ) , 4 .",
    "every head of a rule in @xmath8 appears in the body of another rule in @xmath8 .    if @xmath8 contains a positive redundant literal @xmath110 in the body of a rule @xmath119 then every stable model for @xmath8 is a stable model for @xmath125 .",
    "hence @xmath371 .",
    "so , from lemma [ f.incr ] , we have that @xmath372 this means that @xmath8 is not extremal .",
    "if @xmath8 contains a redundant rule @xmath119 then stable models of @xmath8 are exactly the stable models of @xmath125 .",
    "again , @xmath8 is not extremal .",
    "if @xmath8 contains a fact @xmath373 then @xmath110 must belong to every stable model of @xmath8 .",
    "that is , @xmath374 and @xmath8 is not extremal .",
    "assume that @xmath8 contains a rule @xmath119 with head @xmath110 and @xmath110 does not appear negatively or positively in the body of any other rule .",
    "for any set of atoms @xmath32 , @xmath32 is a stable model for @xmath8 if and only if @xmath375 is a stable model for @xmath113 .",
    "hence , again @xmath376 and @xmath8 is not an extremal program .",
    "observe that since @xmath402 is generating for @xmath403 , the only positive literal it may contain is @xmath404 .",
    "so , assume that @xmath404 appears positively in the body of @xmath402 .",
    "then , @xmath405 contains the rule @xmath406 .",
    "since all other rules in @xmath405 have atoms different from @xmath404 in their heads , @xmath404 does not belong to the least model of @xmath405 , a contradiction .",
    "hence , @xmath402 has no positive literals . by symmetry ,",
    "all rules @xmath401 have no positive literals in their bodies .",
    "next , observe that @xmath402 is generating for @xmath403 but not for any other stable model @xmath407 ( @xmath408 ) .",
    "hence , all literals @xmath409 , @xmath410 , must appear in the body of @xmath402 and @xmath411 does not .",
    "since @xmath402 has no redundant negative literals , @xmath412 by symmetry , it follows that @xmath413 $ ] .",
    "let @xmath8 be an extremal program with @xmath1 clauses , @xmath414 .",
    "since @xmath8 is extremal , @xmath8 has at least @xmath1 stable models ( note that @xmath426 has 2 stable models , @xmath427 has 3 stable models , and @xmath428 and @xmath429 have 4 stable models each ) .",
    "let @xmath430 be the set of heads of the rules in @xmath8 .",
    "then , each stable model of @xmath8 is a subset of @xmath430 , and all stable models of @xmath8 form an antichain .",
    "if @xmath431 , the largest antichain of subsets of @xmath430 has one element .",
    "thus , @xmath432 .",
    "observe also that since @xmath8 is extremal , its rules contain no positive redundant literals in their bodies ( lemma [ bounds.1 ] ) .",
    "additionally , by the construction of @xmath173 , its rules contain no redundant negative literals , either .",
    "hence , the rules of @xmath173 are built of atoms in @xmath430 only .",
    "assume first that @xmath416 .",
    "then , @xmath433 , say @xmath434 .",
    "there is only one antichain of subsets of @xmath430 that has two elements : @xmath435 .",
    "hence , @xmath8 has two stable models : @xmath436 and @xmath437 .",
    "the assertion follows by lemma [ aux ] .",
    "assume next that @xmath419 .",
    "if @xmath433 , then the largest antichain of subsets of @xmath430 has two elements , a contradiction ( recall that @xmath8 has at least three stable models ) .",
    "hence , @xmath438 , say @xmath439 .",
    "the program @xmath173 has three rules , say @xmath119 , @xmath440 and @xmath441 , with heads @xmath50 , @xmath189 and @xmath415 , respectively .",
    "there are only two antichains of subsets of @xmath430 with three elements : + ( 1 ) @xmath442 , and + ( 2 ) @xmath443 .",
    "+ hence , the family of stable models of @xmath8 ( and , hence , also of @xmath173 ) is either @xmath444 @xmath445 @xmath446 or @xmath443 .",
    "consider the first possibility .",
    "assume that rule @xmath119 contains a negative literal .",
    "clearly , rules @xmath119 and @xmath440 are generating for @xmath447 .",
    "thus , the only negative literal that they may contain is @xmath448 .",
    "reasoning in the same way , we find that the only negative literal that may be contained in the rules @xmath119 and @xmath441 is @xmath449 , a contradiction .",
    "hence , @xmath119 and , by symmetry , @xmath440 and @xmath441 have no negative literals .",
    "thus , @xmath173 is a horn program and has exactly one stable model , a contradiction .",
    "finally , assume that @xmath422 . if @xmath450 , the size of any antichain of subsets of @xmath430 is at most 3 .",
    "since @xmath8 has at least 4 stable models , @xmath451 .",
    "assume that @xmath452 and that @xmath173 consists of rules @xmath119 , @xmath440 , @xmath441 , and @xmath453 with heads @xmath50 , @xmath189 , @xmath415 and @xmath274 , respectively .",
    "let @xmath454 be an antichain consisting of 4 or more subsets of @xmath430 .",
    "clearly , @xmath454 contains neither @xmath455 nor @xmath430 .",
    "assume that @xmath456 contains a one - element subset of @xmath430 , say @xmath436 .",
    "then , there are exactly two possibilities for @xmath454 : + ( 1 ) @xmath457 , and + ( 2 ) @xmath458 .",
    "+ in the first case , the assertion follows from lemma [ aux ] .",
    "so , let us consider the second case . in this case",
    ", rule @xmath119 is not generating for any of the stable models @xmath459 , @xmath460 and @xmath461 .",
    "hence , @xmath459 , @xmath460 and @xmath461 are the stable models of @xmath462 .",
    "this is a contradiction .",
    "we proved above that no 3-rule program can have the antichain @xmath463 as its family of stable models .",
    "next , assume that @xmath454 contains a set with three elements , say @xmath464 .",
    "then , there are exactly two possibilities for @xmath454 : + ( 1 ) @xmath465 , and + ( 2 ) @xmath466 .",
    "+ assume the first case .",
    "assume that at least one rule in @xmath173 , say @xmath119 , has a negative literal .",
    "since @xmath119 , @xmath440 and @xmath441 are generating for @xmath464 , it follows that @xmath119 has exactly one negative literal , @xmath467 .",
    "but then , @xmath119 is not generating for @xmath468 , a contradiction .",
    "hence , @xmath119 and , by symmetry , all the rules in @xmath173 have no negative literals in their bodies .",
    "consequently , @xmath173 is a horn program and has only one stable model , a contradiction .",
    "thus , assume that @xmath466 .",
    "assume that @xmath119 has a negative literal .",
    "reasoning as before , it follows that @xmath119 has exactly one negative literal , @xmath467 .",
    "but then , @xmath119 is not generating for the stable model @xmath469 , a contradiction .",
    "hence , @xmath119 and , by symmetry , @xmath440 and @xmath441 have no negative literals in their bodies .",
    "assume that @xmath453 has a negative literal in its body , say @xmath470 .",
    "then , since @xmath453 is generating for @xmath469 , @xmath460 and @xmath461 , @xmath471 , which is impossible . hence , as before , @xmath173 is a horn program and has only one stable model , a contradiction .",
    "the last case to consider is when @xmath454 contains only sets consisting of two elements .",
    "first , assume that some three sets in @xmath454 contain the same element , say @xmath50 .",
    "then @xmath447 , @xmath472 and @xmath469 are all in @xmath454 .",
    "since @xmath119 is a generating rule for all three stable models , it contains no negative literals and the only positive literal it may contain in its body is @xmath50 .",
    "since facts do not belong to extremal programs ( lemma [ bounds.1 ] ) , @xmath50 is in the body of @xmath119 .",
    "consequently , @xmath473 is in @xmath474 .",
    "hence , @xmath50 is not in the least model of @xmath474 , a contradiction .",
    "assume that @xmath119 has a positive literal in its body .",
    "since @xmath119 is a generating rule for @xmath472 and @xmath469 , it follows that @xmath119 has exactly one such literal , namely @xmath50 .",
    "hence , rule @xmath478 is in @xmath479 .",
    "since no other rule in @xmath480 has @xmath50 as its head , @xmath50 is not in the least model of @xmath479 , a contradiction .",
    "hence , @xmath119 and , by symmetry , all rules in @xmath479 have no positive literals in their bodies .",
    "next observe that @xmath119 is generating for @xmath472 and @xmath469 and it is not generating for @xmath459 and @xmath460 .",
    "since it has no positive literals in the body , it follows that @xmath481 . by symmetry , clauses @xmath482 , @xmath483 and @xmath484",
    "are all in @xmath173 .",
    "hence , @xmath485",
    "\\cup cp[\\{c , d\\}]$ ] .",
    "let @xmath1 be an integer , @xmath388 .",
    "assume that every extremal program with @xmath486 rules and no redundant atoms is a @xmath141-program .",
    "if @xmath8 is an extremal program with @xmath388 rules and no redundant atoms than :    1 .",
    "@xmath8 contains no two rules with the same head 2 .",
    "@xmath8 contains no atoms that appear only positively in the bodies of the rules in @xmath8 3 .",
    "@xmath8 contains no rules of the form @xmath487 4 .",
    "@xmath8 is a @xmath141-program      \\(1 ) let @xmath120 be a rule in @xmath8 .",
    "assume that there is another rule @xmath490 with head @xmath110 .",
    "from lemma [ bounds.1 ] it follows that @xmath491 or @xmath492 .",
    "moreover , from lemma [ bounds.1 ] we have that that there is a rule @xmath493 such that @xmath110 appears in the body of @xmath493 .",
    "also , since there are no redundant rules in @xmath8 , @xmath493 is different than @xmath119 and @xmath490 .    if @xmath110 appears positively in the body of @xmath493 then @xmath494 .",
    "since @xmath495 , the inequality ( [ inq.f0b ] ) in lemma [ bounds.1 ] and the inductive assumption imply that @xmath496 so , p is not extremal .",
    "assume then that @xmath110 appears negatively in the body of @xmath493 .",
    "now , @xmath497 , @xmath498 and we can show that @xmath499 in the same way as before .",
    "hence , @xmath8 contains no two rules with same head and ( 1 ) follows .",
    "\\(2 ) assume that @xmath8 contains an atom @xmath110 which appears only positively in bodies of rules of @xmath8 .",
    "there is a unique rule @xmath500 .",
    "let @xmath501 and @xmath357 be the program obtained from @xmath8 by replacing every premise @xmath110 by the sequence @xmath502 @xmath503 .",
    "then @xmath504 and the programs @xmath8 and @xmath357 have the same stable models .",
    "also , @xmath357 contains an atom which never appears in a body of a rule in @xmath8 .",
    "so , from lemma [ bounds.1 ] it follows that @xmath357 is not extremal .",
    "hence , @xmath505 , a contradiction .",
    "\\(3 ) assume that @xmath8 contains a rule of the form @xmath506 . since there is only one rule in @xmath8 with head @xmath110 , for every stable model @xmath32 of @xmath8 , @xmath507 if and only if @xmath508",
    "let @xmath357 be the program obtained from @xmath8 by replacing every premise @xmath370 by the premise @xmath509 .",
    "clearly , @xmath8 and @xmath357 have the same stable models .",
    "in addition , @xmath357 contains an atom which does not appear negated in @xmath357 . from part ( 2 ) of this proof , it follows that @xmath357 is not extremal .",
    "consequently , since @xmath8 and @xmath357 have the same number of rules and the same number of stable models , @xmath8 is not extremal , contrary to the assumption .",
    "\\(4 ) assume first that @xmath8 contains a rule @xmath119 of the form @xmath510 .",
    "let @xmath511 . if @xmath115 , then @xmath512 . if @xmath513 , then , @xmath514 and @xmath515 .",
    "hence , @xmath516 ( recall that @xmath517 is the unique rule in @xmath8 with @xmath188 as its head , cf .",
    "part ( 1 ) of the proof ) .",
    "hence , @xmath518      next , observe that @xmath521 , where @xmath522 is the number of literals in the body of @xmath517 different than @xmath110 and @xmath370 .",
    "therefore , @xmath523 if @xmath524 or @xmath525 then the inequality [ inq.f0b ] of lemma [ inq.f0 ] and the equality @xmath526 , for @xmath527 , imply that @xmath528 .",
    "it follows that @xmath529 , @xmath530 and both @xmath124 and @xmath531 are extremal .",
    "moreover , since @xmath530 , @xmath532 ( @xmath8 does not contain redundant rules and rules of the form @xmath533 ) .",
    "assume now that there is a rule in @xmath357 , say @xmath490 , containing @xmath110 in its body .",
    "again , let @xmath511 . if @xmath115 , then @xmath536 is a stable model of @xmath537 . otherwise , @xmath32 is a stable model of @xmath538 . since @xmath539 and @xmath540 , @xmath541 a contradiction .",
    "hence , neither @xmath110 nor ( by symmetry ) @xmath188 appear in @xmath357 .",
    "it is easy to see that @xmath542 . since @xmath124 is extremal",
    ", @xmath357 is extremal .",
    "it follows by induction that @xmath357 and , consequently , @xmath8 are both @xmath543-programs .    from now on , we will assume that every rule in @xmath8 has at least 2 literals in the body .",
    "assume that there is a rule @xmath119 in @xmath8 with a positive literal , say @xmath50 , in its body .",
    "since the body of @xmath544 has at least two literals , @xmath545 . since @xmath119 has @xmath50 in its body , @xmath546 .",
    "it follows that @xmath547 , a contradiction .",
    "hence , every rule in @xmath8 has only negative literals in its body .",
    "assume next that there is a rule @xmath119 in @xmath8 with @xmath548 literals in the body .",
    "let @xmath110 be the head of @xmath119",
    ". then @xmath549 and @xmath550 .",
    "hence , @xmath551 , a contradiction .",
    "it follows that every rule in @xmath8 has 2 or 3 literals in its body .",
    "we will show now that @xmath8 is a @xmath543-program . to this end",
    ", we will consider two cases .",
    "first , we will assume that all rules in @xmath8 have exactly 3 negative literals in their bodies .",
    "consider a rule @xmath119 from @xmath8 , say @xmath119 is of the form : @xmath552 assume that the rules @xmath553 , @xmath554 , and @xmath555 are of the following respective forms ( by our assumption , each must have exactly 3 negative literals in the body ) : @xmath556 @xmath557 @xmath558 assume that at least one of the atoms @xmath393 , @xmath559 , @xmath560 , @xmath561 , @xmath562 , @xmath563 , @xmath564 , @xmath565 and @xmath566 is not in @xmath567 . without the loss of generality",
    ", we may assume that @xmath568 .",
    "consider @xmath583 .",
    "since @xmath584 , the number of stable models for which ( iv ) holds is bounded by @xmath585 .",
    "hence , @xmath586 .",
    "lemma [ f.incr ] implies that @xmath587 . using the inductive assumption and , twice , the inequality [ inq.f0a ] of lemma [ inq.f0 ] we have that @xmath588 .",
    "so , @xmath589 . this is a contradiction .",
    "consequently , all atoms appearing in the negated form in the bodies of the rules @xmath553 , @xmath554 and @xmath555 belong to @xmath567 .",
    "hence , @xmath590 $ ] .",
    "let us now observe that none of @xmath34 , @xmath449 , @xmath448 and @xmath449 appears in @xmath591 indeed , if , say @xmath34 , appears in the body of a rule @xmath500 , where @xmath592 , then one can show that @xmath593 , a contradiction .      to complete the proof we need to consider one more case when @xmath8 contains a rule ,",
    "say @xmath544 , with exactly 2 negative literals in the body .",
    "let us assume that @xmath597 let us also assume that @xmath553 has literals @xmath470 and @xmath598 in its body ( and , possibly , one more ) and that @xmath554 has literals @xmath599 and @xmath600 ( and , possibly , one more ) in its body . if @xmath553 or @xmath554 has three negative literals in its body or if at least one of @xmath393 , @xmath559 , @xmath561 and @xmath562 is not in @xmath464 , reasoning as in the previous case we can show that @xmath601 .",
    "corollary [ cor-4 ] implies that @xmath602 .",
    "hence , @xmath505 .",
    "this is a contradiction .",
    "hence , @xmath603 $ ] .",
    "moreover , again reasoning similarly as before , we can show that none of @xmath34 , @xmath449 and @xmath448 occurs in @xmath604 .",
    "hence , @xmath605 .",
    "it follows that @xmath198 is extremal .",
    "moreover , @xmath606 .",
    "consequently , @xmath607 is a @xmath543-program and , thus , so is @xmath8 .",
    "we can now complete the proof of theorem [ thm.main ] .",
    "let @xmath8 be an extremal program .",
    "then , by lemmas [ ind.b ] and [ ind.1 ] , @xmath173 is a 2,3,4-program .",
    "thus , by corollary [ cor-4 ] , @xmath608 . consequently , @xmath172 .",
    "m.  gelfond and v.  lifschitz .",
    "the stable semantics for logic programs . in r.",
    "kowalski and k.  bowen , editors , _ proceedings of the 5th international symposium on logic programming _ , pages 10701080 , cambridge , ma , 1988 .",
    "mit press .",
    "w.  marek , j.  treur , and m.  truszczyski .",
    "representability by default theories . in _ proceedings of the fourth international symposium on artificial intelligence and mathematics , ft .",
    "lauderdale , florida _ , 1996 . extended version submitted for journal publication ."
  ],
  "abstract_text": [
    "<S> we study the following problem : given a class of logic programs @xmath0 , determine the maximum number of stable models of a program from @xmath0 . </S>",
    "<S> we establish the maximum for the class of all logic programs with at most @xmath1 clauses , and for the class of all logic programs of size at most @xmath1 . </S>",
    "<S> we also characterize the programs for which the maxima are attained . </S>",
    "<S> we obtain similar results for the class of all disjunctive logic programs with at most @xmath1 clauses , each of length at most @xmath2 , and for the class of all disjunctive logic programs of size at most @xmath1 . </S>",
    "<S> our results on logic programs have direct implication for the design of algorithms to compute stable models . </S>",
    "<S> several such algorithms , similar in spirit to the davis - putnam procedure , are described in the paper . </S>",
    "<S> our results imply that there is an algorithm that finds all stable models of a program with @xmath1 clauses after considering the search space of size @xmath3 in the worst case . </S>",
    "<S> our results also provide some insights into the question of representability of families of sets as families of stable models of logic programs . </S>"
  ]
}