{
  "article_text": [
    "polynomial factorization is a fundamental problem in computational algebra .",
    "the algorithms used to solve it depend on the ring of coefficients , with finite fields , local fields , number fields and rings of integers of particular interest to number theorists . in this article , we focus on a task that forms a building block for factorization algorithms over complete discrete valuation fields : the decomposition into factors based on the slopes of the newton polygon .",
    "the newton polygon of a polynomial @xmath0 over such a field is given by the convex hull of the points @xmath1 and the point @xmath2 .",
    "the lower boundary of this polygon consists of line segments @xmath3  @xmath4 of slope @xmath5 .",
    "the slope factorization of @xmath6 expresses @xmath6 as a product of polynomials @xmath7 with degree @xmath8 whose roots all have valuation @xmath9 .",
    "our main result is a new algorithm for computing these @xmath7 .",
    "polynomial factorization over local fields has seen a great deal of progress recently following an algorithm of montes .",
    "slope factorization provides a subroutine in such algorithms ( * ? ? ?",
    "* section  2 ) .",
    "for the most difficult inputs , it is not the dominant contributor to the runtime of the algorithm , but in some circumstances it will be .",
    "we underline moreover that the methods introduced in this paper extend partially to the noncommutative setting and appear this way as an essential building block in several decomposition algorithms of @xmath10-adic galois representations and @xmath10-adic differential equations  @xcite .",
    "any computation with @xmath10-adic fields must work with approximations modulo finite powers of @xmath10 , and one of the key requirements in designing an algorithm is an analysis of how the precision of the variables evolve over the computation .",
    "we work with precision models developed by the same authors ( * ? ? ?",
    "* section  4.2 ) , focusing on the lattice and newton models . as part of the analysis of the slope factorization algorithm",
    ", we describe how the precision of the quotient and remainder depend on the input polynomials in euclidean division .",
    "* main results . *",
    "suppose that the newton polygon of @xmath11 has a break at @xmath12 .",
    "set @xmath13 , @xmath14 and @xmath15 our main result is theorem [ theo : slope - factor ] , which states that the sequence @xmath16 converges quadratically to a divisor of @xmath17 .",
    "this provides a quasi - optimal simple - to - implement algorithm for computing slope factorizations .",
    "we moreover carry out a careful study of the precision and , applying a strategy coming from  @xcite , we end up with an algorithm that outputs optimal results regarding to accuracy .    in order to prove theorem  [ theo : slope - factor ] , we also determine the precision of the quotient and remainder in euclidean division , which may be of independent interest .",
    "these results are found in section [ sec : prec_track ] .",
    "* organization of the paper .",
    "* after setting notation , in section [ sec : prec_data ] we recall various models for tracking precision in polynomial arithmetic .",
    "we give some background on newton polygons and explain how using lattices to store precision can allow for extra _ diffuse _",
    "@xmath10-adic digits that are not localized on any single coefficient .    in section [ sec : quo_rem",
    "] , we consider euclidean division .",
    "we describe in theorem [ theo : edivisionnp ] how the newton polygons of the quotient and remainder depend on numerator and denominator .",
    "we use this result to describe in proposition [ prop : newtonpreceuclide ] the precision evolution in euclidean division using the newton precision model .",
    "we then compare the precision performance of euclidean division in the jagged , newton and lattice models experimentally , finding different behavior depending on the modulus .",
    "finally , in section [ sec : slope_fac ] we describe our slope factorization algorithm , which is based on a newton iteration . unlike other algorithms for slope factorization , ours does not require working with fractional exponents . in theorem [ theo : slope - factor ]",
    "we define a sequence of polynomials that will converge to the factors determined by an extremal point in the newton polygon .",
    "we then discuss the precision behavior of the algorithm .",
    "* notations . * throughout this paper , we fix a complete discrete valuation field @xmath18 ; we denote by @xmath19 the valuation on it and by @xmath20 its ring of integers ( _ i.e. _ the set of elements with nonnegative valuation ) .",
    "we assume that @xmath21 is normalized so that it is surjective and denote by @xmath22 a uniformizer of @xmath18 , that is an element of valuation @xmath23 .",
    "denoting by @xmath24 a fixed set of representatives of the classes modulo @xmath22 and assuming @xmath25 , one can prove that each element in @xmath26 can be represented uniquely as a convergent series : @xmath27 the two most important examples are the field of @xmath10-adic numbers @xmath28 and the field of laurent series @xmath29 over a field @xmath30 .",
    "the valuation on them are the @xmath10-adic valuation and the usual valuation of a laurent series respectively .",
    "their ring of integers are therefore @xmath31 and @xmath32 $ ] respectively .",
    "a distinguished uniformizer is @xmath10 and @xmath33 whereas a possible set @xmath34 is @xmath35 and @xmath30 respectively .",
    "the reader who is not familiar with complete discrete valuation fields may assume ( without sacrifying too much to the generality ) that @xmath18 is one of the two aforementioned examples",
    ".    in what follows , the notation @xmath36 $ ] refers to the ring of univariate polynomials with coefficients in @xmath18 .",
    "the subspace of polynomials of degree at most @xmath37 ( resp . exactly @xmath37 ) is denoted by @xmath38 $ ] ( resp .",
    "elements in @xmath18 ( and _ a fortiori _ in @xmath36 $ ] ) carry an infinite amount of information .",
    "they thus can not be stored entirely in the memory of a computer and have to be truncated .",
    "elements of @xmath18 are usually represented by truncating eq . as follows : @xmath40 where @xmath41 is an integer called the _ absolute precision _ and the notation @xmath42 means that the coefficients @xmath43 for @xmath44 are discarded . if @xmath45 and @xmath46 , the integer @xmath47 is the valuation of @xmath48 and the difference @xmath49 is called the _ relative precision_. alternatively , one may think that the writing   represents a subset of @xmath18 which consists of all elements in @xmath18 for which the @xmath43 s in the range @xmath50 $ ] are those specified . from the metric point of view , this is a ball ( centered at any point inside it ) .",
    "it is worth noting that tracking precision using this representation is rather easy .",
    "for example , if @xmath48 and @xmath51 are known with absolute ( resp .",
    "relative ) precision @xmath52 and @xmath53 respectively , one can compute the sum @xmath54 ( resp .",
    "the product @xmath55 ) at absolute ( resp .",
    "relative ) precision @xmath56 .",
    "computations with @xmath10-adic and laurent series are often handled this way on symbolic computation softwares .",
    "the situation is much more subtle when we are working with a collection of elements of @xmath18 ( _ e.g. _ a polynomial ) and not just a single one . indeed ,",
    "several precision data may be considered and , as we shall see later , each of them has its own interest .",
    "below we detail three models of precision for the special case of polynomials .    * flat precision . * the simplest method for tracking the precision of a polynomial is to record each coefficient modulo a fixed power of @xmath10 . while easy to analyze and",
    "implement , this method suffers when applied to polynomials whose newton polygons are far from flat .    * jagged precision . * the next obvious approach is to record the precision of each coefficient individually , a method that we will refer to as _ jagged _ precision .",
    "jagged precision is commonly implemented in computer algebra systems , since standard polynomial algorithms can be written for generic coefficient rings . however",
    ", these generic implementations often have suboptimal precision behavior , since combining intermediate expressions into a final answer may lose precision . moreover , when compared to the newton precision model , extra precision in the middle coefficients , above the newton polygon of the remaining terms , will have no effect on any of the values of that polynomial .",
    "* newton precision .",
    "* we now move to _ newton precision _ data .",
    "they can be actually seen as particular instances of jagged precision but there exist for them better representations and better algorithms .",
    "a _ newton function of degree @xmath37 _ is a convex function @xmath57 \\to { \\mathbb r}\\cup \\{+\\infty\\}$ ] which is piecewise affine , which takes a finite value at @xmath37 and whose epigraph @xmath58 have extremal points with integral abscissa .",
    "the datum of @xmath59 is equivalent to that of @xmath58 and they can easily be represented and manipulated on a computer .",
    "we recall that one can attach a newton function to each polynomial .",
    "if @xmath60 $ ] , we define its newton polygon @xmath61 as the convex hull of the points @xmath62 ( @xmath63 ) together with the point at infinity @xmath64 and then its newton function @xmath65 \\to { \\mathbb r}$ ] as the unique function whose epigraph is @xmath61 .",
    "it is well known ( * ? ? ?",
    "* section  1.6 ) that : @xmath66 where @xmath67 denotes the convex hull and the plus sign stands for the minkowski sum .",
    "this translates to : @xmath68 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ + $ } ; \\end{scope } \\end{tikzpicture}}}}{\\text{\\rm nf}}(q ) \\smallskip \\\\ { \\text{\\rm nf}}(pq ) = { \\text{\\rm nf}}(p ) { { \\raisebox{-0.1mm}{\\begin{tikzpicture } \\draw[transparent ] ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ \\times$ } ; \\end{scope } \\end{tikzpicture}}}}{\\text{\\rm nf}}(q ) \\end{array}\\ ] ] where the operations @xmath69 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ + $ } ; \\end{scope } \\end{tikzpicture}}}}$ ] and @xmath69 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ \\times$ } ; \\end{scope } \\end{tikzpicture}}}}$ ] are defined accordingly . there",
    "exist classical algorithms for computing these two operations whose complexity is quasi - linear with respect to the degree .    in a similar fashion , newton functions can be used to model precision : given a newton function @xmath59 of degree @xmath37 , we agree that a polynomial of degree at most @xmath37 is given at precision @xmath70 when , for all @xmath71 , its @xmath71-th coefficient is given at precision @xmath72 ( where @xmath73 is the ceiling function ) . in the sequel , we shall write @xmath74 and use the notation @xmath75 ( where the coefficients @xmath43 are given by truncated series ) to refer to a polynomial given at precision @xmath70 .    it is easily checked that if @xmath17 and @xmath76 are two polynomials known at precision @xmath77 and @xmath78 respectively , then @xmath79 is known at precision @xmath80 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ + $ } ; \\end{scope } \\end{tikzpicture}}}}\\varphi_q)$ ] and @xmath81 is known at precision @xmath82 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ \\times$ } ; \\end{scope } \\end{tikzpicture}}}}{\\text{\\rm nf}}(q ) ) { { \\raisebox{-0.1mm}{\\begin{tikzpicture } \\draw[transparent ] ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ + $ } ; \\end{scope } \\end{tikzpicture}}}}({\\text{\\rm nf}}(p ) { { \\raisebox{-0.1mm}{\\begin{tikzpicture } \\draw[transparent ] ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ \\times$ } ; \\end{scope } \\end{tikzpicture}}}}\\varphi_q)\\big)$ ] .",
    "[ def : nondeg ] let @xmath83 .",
    "we say that the newton precision @xmath77 on @xmath17 is _ nondegenerate _ if @xmath84 and @xmath85 for all extremal point @xmath86 of @xmath87 .",
    "we notice that , under the conditions of the above definition , the newton polygon of @xmath17 is well defined .",
    "indeed , if @xmath88 is any polynomial whose newton function is not less than @xmath89 , we have @xmath90 .    * lattice precision . * the notion of _ lattice precision _ was developed in @xcite .",
    "it encompasses the two previous models and has the decisive advantage of precision optimality . as a counterpart",
    ", it might be very space - consuming and time - consuming for polynomials of large degree .",
    "let @xmath91 be a finite dimensional vector space over @xmath18 .",
    "a lattice in @xmath91 is a sub-@xmath20-module of @xmath91 generated by a @xmath18-basis of @xmath91 .",
    "we fix an integer @xmath37 .",
    "a lattice precision datum for a polynomial of degree @xmath37 is a lattice @xmath92 lying in the vector space @xmath38 $ ]",
    ". we shall sometimes denote it @xmath93 in order to emphasize that it should be considered as a precision datum .",
    "the notation @xmath94 then refers to any polynomial in the @xmath20-affine space @xmath95 .",
    "tracking lattice precision can be done using differentials as shown in ( * ? ? ?",
    "* lemma  3.4 and proposition  3.12 ) : if @xmath96   \\to k_{\\leq m}[x]$ ] denotes any strictly differentiable function with surjective differential , under mild assumption on @xmath92 , we have : @xmath97 where @xmath98 denotes the differential of @xmath99 at @xmath100 . the equality sign reflets the optimality of the method .",
    "as already mentioned , the jagged precision model is a particular case of the lattice precision .",
    "indeed , a precision of the shape @xmath101 corresponds to the lattice generated by the elements @xmath102 ( @xmath103 ) .",
    "this remark is the origin of the notion of _ diffused digits of precision _ introduced in ( * ? ? ?",
    "* definition  2.3 ) .",
    "we shall use it repeatedly in the sequel in order to compare the behaviour of the three aforementioned precision data in concrete situations .",
    "euclidean division provides a building block for many algorithms associated to polynomials in one variable . in order to analyze the precision behavior of such algorithms , we need to first understand the precision attached to the quotient and remainder when dividing two polynomials . in the sequel",
    ", we use the notation @xmath104 and @xmath105 for the polynomials satisfying @xmath106 and @xmath107 .",
    "let @xmath59 and @xmath108 be two newton functions of degree @xmath37 and @xmath109 respectively .",
    "set @xmath110 .",
    "letting @xmath111 be the greatest affine function of slope @xmath112 with @xmath113}$ ] and @xmath114 , we define : @xmath115 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ \\mod$ } ; \\end{scope } \\end{tikzpicture}}}}\\psi &   \\multicolumn{3}{@{}l}{= \\varphi_{|[0,d{-}1 ] } { { \\raisebox{-0.1mm}{\\begin{tikzpicture } \\draw[transparent ] ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ + $ } ; \\end{scope } \\end{tikzpicture}}}}\\big (   \\psi_{|[0,d{-}1 ] } + \\delta\\big ) } \\medskip \\\\ \\varphi { { \\raisebox{-0.1mm}{\\begin{tikzpicture } \\draw[transparent ] ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ { \\,/\\hspace{-0.3em}/\\,}$ } ; \\end{scope } \\end{tikzpicture}}}}\\psi & : \\ , [ 0 , n - d ] & \\to & { \\mathbb r}\\cup \\{+\\infty\\ } \\smallskip \\\\ & x & \\mapsto & \\inf_{h \\geq 0 } \\varphi(x+d+h ) - \\lambda h. \\end{array}\\ ] ]    ( 4,9.5)(4,2.667)(2,2)(0.5,4)(0,8)(0,9.5)cycle ; ( 5,9.5)(5,3)(4,2.667)(4,9.5)cycle ; ( 5,9.5)(5,3)(8,4)(11,8)(11,9.5)cycle ; ( -0.5,0)(11.5,0 ) ; ( 0,-0.5)(0,9.5 ) ; ( 0,6)(0.5,2)(2,0)(5,1 ) ; ( 0,9)(3,5)(8,4)(11,8 ) ; ( 11,5)(8,4 ) ; ( 8,4)(2,2)(0.5,4)(0,8 ) ; ( 5,0)(5,9.5 ) ; ( 4,0)(4,9.5 ) ; at ( 0,0 ) @xmath116 ; at ( 5,0 ) @xmath109 ; at ( 4,0 ) @xmath117 ; at ( 2.5,1.2 ) @xmath108 ; at ( 9.8,7.3 ) @xmath59 ; at ( 10.5,4.4 ) @xmath111 ;    figure  [ fig : newtoneuclide ] illustrates the definition : if @xmath59 and @xmath108 are the functions represented on the diagram , the epigraph of @xmath118 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ \\mod$ } ; \\end{scope } \\end{tikzpicture}}}}\\psi$ ] is the blue area whereas that of @xmath118 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ { \\,/\\hspace{-0.3em}/\\,}$ } ; \\end{scope } \\end{tikzpicture}}}}\\psi$ ] is the green area translated by @xmath119 .",
    "it is an easy exercise ( left to the reader ) to design quasi - linear algorithms for computing @xmath118 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ \\mod$ } ; \\end{scope } \\end{tikzpicture}}}}\\psi$ ] and @xmath118 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ { \\,/\\hspace{-0.3em}/\\,}$ } ; \\end{scope } \\end{tikzpicture}}}}\\psi$ ] .",
    "[ theo : edivisionnp ] given @xmath120 $ ] with @xmath121 , we have : @xmath122 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ \\mod$ } ; \\end{scope } \\end{tikzpicture}}}}{\\text{\\rm nf}}(b ) \\label{eq : amodb } \\\\",
    "\\text{and } \\hspace{4 mm } { \\text{\\rm nf}}(a { \\,/\\hspace{-0.3em}/\\,}b ) & \\geq { \\text{\\rm nf}}(a ) { { \\raisebox{-0.1mm}{\\begin{tikzpicture } \\draw[transparent ] ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ { \\,/\\hspace{-0.3em}/\\,}$ } ; \\end{scope } \\end{tikzpicture}}}}{\\text{\\rm nf}}(b ) \\label{eq : adivb}\\end{aligned}\\ ] ]    write @xmath123 where @xmath124 ( resp .",
    "@xmath125 ) consists of monomials of @xmath126 of degree less than @xmath109 ( resp .",
    "at least @xmath109 ) . noting that : @xmath127 we may assume that @xmath128 .",
    "let us now prove eq .  .",
    "replacing @xmath129 by @xmath130 where @xmath131 denotes the leading coefficient of @xmath129 , we may assume that @xmath129 is monic .",
    "using linearity , we may further assume that @xmath126 is a monomial .",
    "set @xmath132 .",
    "the relation we have to prove is : @xmath133 we proceed by induction .",
    "the initialisation is clear because @xmath134 agrees with @xmath135 up to degree @xmath117 .",
    "we have the relation @xmath136 where @xmath137 is the coefficient in @xmath138 of @xmath139 .",
    "thanks to the induction hypothesis , we have : @xmath140 since @xmath141 because @xmath129 is monic .",
    "therefore @xmath142 for all @xmath48 . on the other hand , for all @xmath48",
    ", we have : @xmath143 from what we get @xmath144 . as a consequence @xmath145 and",
    "the induction follows .",
    "is now derived from : @xmath146 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ \\times$ } ; \\end{scope } \\end{tikzpicture}}}}{\\text{\\rm nf}}(b ) \\geq { \\text{\\rm nf}}(a ) { { \\raisebox{-0.1mm}{\\begin{tikzpicture } \\draw[transparent ] ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ + $ } ; \\end{scope } \\end{tikzpicture}}}}{\\text{\\rm nf}}(a \\mod b)\\ ] ] using the estimation on @xmath147 we have just proved ( see figure  [ fig : newtoneuclide ] ) .",
    "* newton precision . *",
    "we first analyze the precision behavior of euclidean division in the newton model .",
    "concretely , we pick @xmath120 $ ] two polynomials which are known at precision @xmath148 and @xmath149 respectively : @xmath150 here @xmath151 and @xmath152 are some approximations of @xmath126 and @xmath129 respectively and @xmath153 and @xmath154 denotes two newton functions of degree @xmath155 and @xmath156 respectively .",
    "we are interested in determining the precision on @xmath105 and @xmath157 .",
    "the following proposition gives a theoretical answer under mild assumptions .",
    "[ prop : newtonpreceuclide ] we keep the above notations and assume that the newton precisions @xmath148 and @xmath149 on @xmath126 and @xmath129 respectively are both nondegenerate ( _ cf _ definition  [ def : nondeg ] ) .",
    "then , setting : @xmath158 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ + $ } ; \\end{scope } \\end{tikzpicture}}}}\\big [ \\varphi_b { { \\raisebox{-0.1mm}{\\begin{tikzpicture } \\draw[transparent ] ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ \\times$ } ; \\end{scope } \\end{tikzpicture}}}}\\big({\\text{\\rm nf}}(a ) { { \\raisebox{-0.1mm}{\\begin{tikzpicture } \\draw[transparent ] ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ { \\,/\\hspace{-0.3em}/\\,}$ } ; \\end{scope } \\end{tikzpicture}}}}{\\text{\\rm nf}}(b)\\big ) \\big]\\ ] ] the polynomials @xmath104 and @xmath105 are known at precision @xmath159 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ { \\,/\\hspace{-0.3em}/\\,}$ } ; \\end{scope } \\end{tikzpicture}}}}{\\text{\\rm nf}}(b))$ ] and @xmath159 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ \\mod$ } ; \\end{scope } \\end{tikzpicture}}}}{\\text{\\rm nf}}(b))$ ] respectively .",
    "let @xmath160 ( resp .",
    "@xmath161 ) be a polynomial whose newton function is not less than @xmath153 ( resp .",
    "@xmath154 ) and define @xmath162 and @xmath163 by : @xmath164 where @xmath165 and @xmath166 . we have to show that @xmath167 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ { \\,/\\hspace{-0.3em}/\\,}$ } ; \\end{scope } \\end{tikzpicture}}}}{\\text{\\rm nf}}(b)$ ] and @xmath168 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ \\mod$ } ; \\end{scope } \\end{tikzpicture}}}}{\\text{\\rm nf}}(b)$ ] .",
    "set @xmath169 .",
    "using theorem  [ theo : edivisionnp ] , we obtain @xmath170 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ { \\,/\\hspace{-0.3em}/\\,}$ } ; \\end{scope } \\end{tikzpicture}}}}{\\text{\\rm nf}}(b)$ ] and consequently @xmath171 . on the other hand , an easy computation yields",
    "@xmath172 so that @xmath173 and @xmath174 . using again theorem  [ theo : edivisionnp ] , we get the desired result .    with this result in hand , we may split the computation of euclidean division into two pieces , first computing approximations @xmath175 and @xmath176 and separately computing @xmath162 and @xmath163 .",
    "both the approximations and the precision can be computing in time that is quasi - linear in the degree .",
    "* lattice precision .",
    "* we now move to lattice precision .",
    "we pick @xmath126 and @xmath129 two polynomials of respective degree @xmath37 and @xmath109 and assume that they are known at precision @xmath177 and @xmath178 respectively : @xmath179 where @xmath180 $ ] and @xmath181 $ ] are lattices . according to the results of @xcite , in order to determine the precision on @xmath104 and @xmath105 , we need to compute the differential of the mappings @xmath182 and @xmath183 at the point @xmath184 .",
    "writing @xmath165 and @xmath166 , this can be done by expanding the relation : @xmath185 and neglecting the terms of order @xmath186 .",
    "we get this way @xmath187 meaning that @xmath188 and @xmath189 appears respectively as the quotient and the remainder of the euclidean division of @xmath190 by @xmath152 .",
    "once this has been done , the strategy is quite similar to that explained for newton precision : compute approximations and precision lattices separately for quotient and remainder .      for this example",
    ", we work over @xmath191 and fix a monic polynomial @xmath192 $ ] ( known exactly ) of degree @xmath193 .",
    "our aim is to compare the numerical stability of the multiplication in the quotient @xmath194/m$ ] depending on the precision model we are using . in order to do so",
    ", we pick @xmath37 random polynomials @xmath195 in @xmath194/m(x)$ ] ( according to the haar measure ) whose coefficients are all known at precision @xmath196 for some large integer @xmath41 .",
    "we then compute the product of the @xmath197 s using the following quite naive algorithm .    1 .",
    "* set * @xmath198    2 .  * for * @xmath199 * do * * compute * @xmath200    3 .",
    "* return * @xmath17    the table of figure  [ fig : modularmult ] reports the average gain of _ absolute _ precision @xmath201 which is observed while executing the algorithm above for various modulus and @xmath37 .",
    "the average is taken on a sample of @xmath202 random inputs .",
    "we recall that @xmath201 is defined as follows :    @xmath203 in the case of jagged and newton precision , the precision on the output may be written into the form @xmath204 and @xmath205 ;    @xmath203 in the case of lattice precision , the precision on the output is a lattice @xmath92 and @xmath201 is the index of @xmath92 in @xmath206 where @xmath207/m$ ] is the standard lattice ; in that case , we write @xmath201 as a sum @xmath208 where @xmath209 is the index of @xmath92 in the largest lattice @xmath210 contained in @xmath92 which can be generated by elements of the shape @xmath211 ( @xmath212 ) .",
    "( the term @xmath213 corresponds to diffused digits according to ( * ? ? ?",
    "* definition  2.3 ) . )    [ cols=\"^,^,^,^,^ \" , ]     we observe several interesting properties .",
    "first of all , the gains for newton precision and jagged precision always agree though one may have thought at first that newton precision is weaker . since performing precision computations in the newton framework is cheaper , it seems ( at least on this example ) that using the jagged precision model is not relevant .",
    "on the other hand , the lattice precision may end up with better results .",
    "nevertheless this strongly depends on the modulus @xmath214 .",
    "for instance , when @xmath214 is irreducible modulo @xmath215 or eiseistein , there is apparently no benefit to using the lattice precision model .",
    "we emphasize that these two particular cases correspond to modulus that are usually used to define ( unramified and totally ramified respectively ) extensions of @xmath216 .    for other moduli ,",
    "the situation is quite different and the benefit of using the lattice precision model becomes more apparent .",
    "the comparison between the gain of precision in the jagged model and the number of not diffused digits in the lattice model makes sense : indeed the latter appears as a theoretical upper bound of the former and the difference between them quantifies the quality of the way we track precision in the jagged ( or the newton ) precision model .",
    "we observe that this difference is usually not negligible ( _ cf _ notably the case of @xmath217 ) meaning that this quality is not very good in general . as for diffused digits , they correspond to digits that can not be `` seen '' in the jagged precision model .",
    "their number then measures the intrinsic limitations of this model .",
    "we observe that it can be very important as well in several cases .",
    "the modulus @xmath218 shows the advantage of working with lattice precision in intermediate computations .",
    "indeed , the precision behavior using the lattice model closely parallels that of @xmath219 , since the lattices are related by a change of variables .",
    "but this structure is not detected in the newton or jagged models .",
    "a well - known theorem ( * ? ? ? * theorem  6.1 ) asserts that each extremal point @xmath214 in the newton polygon @xmath61 of a polynomial @xmath220 $ ] corresponds to a factorization @xmath221 where the newton polygon of @xmath126 ( resp .",
    "@xmath129 ) is given by the part of @xmath61 located at the left ( resp .",
    "the right ) of @xmath214 .",
    "such a factorization is often called a _",
    "slope factorization_.    the aim of this section is to design efficient and stable algorithms for computing these factorizations .",
    "precisely the algorithm we obtain has a quasi - optimal complexity ( compared to the size of the input polynomial ) and outputs a result whose precision is ( close to be ) optimal .",
    "two of its important additional features are simplicity and flexibility .",
    "the factor @xmath126 defined above is usually obtained _ via _ a newton iteration after having prepared our polynomial by flattening the first slope using a change of variables involving possibly rational exponents .",
    "we introduce here a variant of this iteration which does not require the flattening step and is entirely defined over @xmath36 $ ] .",
    "[ theo : slope - factor ] let @xmath11 be a polynomial of degree @xmath37 with coefficients in @xmath18 .",
    "we assume that @xmath61 has an extremal point whose abscissa is @xmath109 .",
    "we define the sequences @xmath222 and @xmath223 recursively by : @xmath224 then the sequence @xmath16 converges to a divisor @xmath225 of @xmath17 of degree @xmath109 whose leading coefficient is @xmath226 and whose newton function agrees with @xmath227 on @xmath228 $ ] . moreover , setting : @xmath229 ( with @xmath230 if necessary )",
    ", we have @xmath231 and the following rate of convergence : @xmath232 } \\,+\\ , 2^i \\kappa.\\ ] ]    [ rem : unicity ] the divisor @xmath126 is uniquely determined by the conditions of theorem  [ theo : slope - factor ] .",
    "indeed , consider two divisors @xmath126 and @xmath233 of @xmath17 such that @xmath234}$ ] .",
    "then @xmath235 is a divisor of @xmath17 as well and the slopes of its newton polygon are all at most @xmath236 . therefore @xmath237 and @xmath238 differs from @xmath126 and @xmath233 by a multiplicative nonzero constant .",
    "then , if @xmath126 and @xmath233 share in addition the same leading coefficient , they must coincide .",
    "the rest of this subsection is devoted to the proof of the theorem . if @xmath239 ( resp .",
    "@xmath240 ) , the sequence @xmath241 is constant equal to @xmath17 ( resp . to the constant coefficient of @xmath17 ) and theorem is clear .",
    "we then assume @xmath242 .",
    "we set : @xmath243 so that @xmath244 .",
    "the existence of an extremal point of @xmath61 located at abscissa @xmath109 ensures that @xmath245 , _",
    "i.e. _ @xmath231 . for all indices",
    "@xmath71 , we define : @xmath246 and when @xmath247 is some letter , we put @xmath248 .      from @xmath250",
    ", we get @xmath251 . hence , by consideration of degree , we obtain and . on the other hand , from @xmath252",
    ", we derive @xmath253 thus @xmath254 .",
    "hence @xmath255 and @xmath256 , from which follows directly by definition of @xmath257 , we get @xmath258 and consequently .",
    "we now write @xmath259 . using and noting that @xmath260 , we get .",
    "we define the function @xmath269 by : @xmath270 we notice that , when the polynomial @xmath17 is changed into @xmath271 where @xmath131 is a nonzero constant lying in a finite extension of @xmath18 , the @xmath241 s are all multiplied by @xmath131 as well whereas the @xmath272 s and the @xmath257 s remained unchanged . therefore , the theorem holds for @xmath17 if and only if it holds for @xmath271 . as a consequence",
    "we may assume that @xmath17 is normalized so that @xmath273 , _",
    "i.e. _ @xmath274 for @xmath275 . for a polynomial @xmath276 $ ] of degree @xmath37 ,",
    "we further define : @xmath277 } { \\text{\\rm nf}}(q)(x ) - \\varphi(x )   \\label{eqdef : bphi } \\\\",
    "\\text{and } \\quad b_i(q ) & = \\min_{x \\in [ 0,n ] } { \\text{\\rm nf}}(q)(x ) - \\lambda_i x \\quad \\text{for } i \\in \\{0,1\\}. \\label{eqdef : b0}\\end{aligned}\\ ] ] set also @xmath278 by convention . with the normalization of @xmath17 we chose above , we have @xmath279 and @xmath280 for all polynomial @xmath76 .",
    "similarly @xmath281 for all @xmath76 .",
    "let @xmath292 ( resp .",
    "@xmath293 ) be the translation of vector @xmath294 ( resp .",
    "it follows from the definition of @xmath296 that @xmath297 is a subset of @xmath298 where @xmath58 denotes the epigraph of @xmath59 .",
    "similarly @xmath299 where @xmath300 is the convex cone generated by the vectors starting from @xmath301 to @xmath302 and @xmath303 .",
    "thus @xmath304 and _ c ) _ follows .",
    "we are now going to prove by induction on @xmath71 the conjonction of all equalities and inequalities below : @xmath305 } , \\smallskip \\\\",
    "b_1(v_i ) \\geq 0 , \\quad b_\\varphi(r_i ) \\geq",
    "2^i \\kappa \\smallskip \\\\",
    "b_\\varphi(s_i ) \\geq 0 , \\quad b_0(t_i ) \\geq",
    "2^i \\kappa . \\end{array}\\ ] ]    noting that @xmath306 and @xmath17 agree up to degree @xmath109 and that @xmath61 has an extremal point at abscissa @xmath109 , we get @xmath307}$ ] .",
    "clearly @xmath308 since @xmath14 .",
    "it follows from the definitions that @xmath309 .",
    "we remark that @xmath310 using theorem [ theo : edivisionnp ] , we obtain that @xmath311 and then @xmath312 ( see figure  [ fig : boundr0s0 ] ) .",
    "( 4,9.5)(4,1.6)(2,1.2)(0.5,2.8)(0,6.8)(0,9.5)cycle ; ( 6,9.5)(6,2)(4,1.6)(4,9.5)cycle ; ( 6,9.5)(6,2)(8,4)(11,9)(11,9.5)cycle ; ( -0.5,0)(11,0 ) ; ( 0,-0.5)(0,9.5 ) ; ( 0,6)(0.5,2)(2,.4)(5,1 ) ; ( 5,1)(8,4)(11,9 ) ; ( 4,9.5) ( 4,1.6)(2,1.2)(0.5,2.8)(0,6.8 ) ; ( 6,2)(4,1.6 ) ; ( 7,3)(2,2)(0.5,3.6)(0,7.6 ) ; ( 8,4)(2,2.8)(0.5,4.4)(0,8.4 ) ; ( 9,5.667)(2,4.267)(0.5,5.867)(0.046,9.5 ) ; ( 10,7.333)(2,5.733)(0.5,7.333)(0.229,9.5 ) ; ( 11,9)(2,7.2)(0.5,8.8) ( .413,9.5);(5,1)(11,2.2 ) ; ( 0,0) ( 5,1 ) ;    ( 4,.8)(4,1.6 ) ; ( 5,0)(5,9.5 ) ; ( 4,0)(4,9.5 ) ; ( 6,0)(6,9.5 ) ; at ( 0,0 ) @xmath116 ; at ( 5,0 ) @xmath109 ; at ( 4,0 ) @xmath117 ; at ( 6,0 ) @xmath313 ; at ( 1.5,1.3 ) @xmath314 ; at ( 10.1,7.3 ) @xmath315 ; at ( 4.2,1.2 ) @xmath316 ; at ( 3,9 ) @xmath317 ; at ( 3,8.3 ) @xmath318 ; at ( 6.2,1.7 ) @xmath319 ; at ( 6.8,.9 ) @xmath320 ; at ( 10,1.6 ) @xmath59 ;      we now assume   for the index @xmath71 . from @xmath325 and the estimation @xmath326",
    ", we derive @xmath327}$ ] .",
    "therefore , lemma  [ lem : bphib0 ] applies with @xmath328 and @xmath329 .",
    "now coming back to the the definition of @xmath330 and using theorem  [ theo : edivisionnp ] , we get @xmath331 . as a consequence : @xmath332 by lemma  [ lem : bphib0 ] and the induction hypothesis . using again lemma  [ lem : bphib0 ] , we then derive from and that @xmath333 and @xmath334 .",
    "similarly , using and the estimations we already know , we obtain @xmath335 . combining this with @xmath334",
    ", we find @xmath336 as well . applying again and again the same strategy",
    ", we deduce successively @xmath337 using  , @xmath338 using  , @xmath339 using  , and then @xmath340 using  . finally , coming back to the recurrence defining @xmath341 and remembering that @xmath342 and @xmath343 are both nonnegative , we find @xmath344 .",
    "the equalities and inequalities of eq .",
    "have then all been established for the index @xmath345 and the induction goes .    from the inequalities @xmath346",
    ", we deduce that the sequence @xmath16 is cauchy and therefore converges .",
    "its limit @xmath225 certainly satisfies @xmath347}$ ] because all the @xmath241 s do .",
    "moreover we know that @xmath348 from what we derive that the sequence @xmath349 goes to @xmath116 .",
    "coming back to the definition of @xmath350 , we find @xmath351 , _",
    "i.e. _ @xmath225 divides @xmath17 .",
    "finally , eq .   giving the rate of convergence follows from the writing @xmath352 together with the facts that @xmath353 and @xmath354 for all @xmath355 .",
    "[ rem : slope - factor ] it follows from the proof above that the sequence @xmath223 converges as well .",
    "its limit @xmath356 is an inverse of @xmath357 modulo @xmath225 and it satisfies in addition @xmath358 .",
    "moreover , the conclusion of theorem  [ theo : slope - factor ] is still correct if @xmath306 is any polynomial of degree @xmath109 with leading coefficient @xmath226 and @xmath359 is any polynomial as soon as they satisfy : @xmath360 except that the constant @xmath316 giving the rate of convergence should be now @xmath361 .",
    "let @xmath362 $ ] and @xmath109 be the abscissa of an extremal point of @xmath61 .",
    "previously ( _ cf _ theorem  [ theo : slope - factor ] ) , we have defined a sequence @xmath363 converging to @xmath364 where @xmath126 is a factor of @xmath17 whose newton function is @xmath365}$ ] and @xmath91 is the inverse of @xmath366 modulo @xmath126 .",
    "we now assume that @xmath17 is known up to some finite precision : @xmath367 where the object inside the @xmath368 depends on the chosen precision model .",
    "we address the two following questions : ( 1 )  what is the precision on the factor @xmath126 , and ( 2 )  how can one compute in practice @xmath126 at this precision ?    in the sequel , it will be convenient to use a different normalization on @xmath126 and @xmath129 : if @xmath226 is the coefficient of @xmath17 of degree @xmath109 , we set @xmath369 and @xmath370 so that @xmath371 is monic and @xmath372 .",
    "we shall also always assume that @xmath17 is monic in the sense that its leading coefficient is _ exactly _  @xmath23 ; the precision datum on @xmath17 then only concerns the coefficients up to degree @xmath373 .",
    "similarly , noting that @xmath371 and @xmath374 are monic as well , they only carry a precision datum up to degree @xmath117 and @xmath375 respectively .",
    "* newton precision .",
    "* we assume that the precision on the input @xmath17 has the shape @xmath77 where @xmath89 is a newton function of degree @xmath373 . from now on , we assume that the precision @xmath77 is nondegenerate in the sense of definition  [ def : nondeg ] .",
    "this ensures in particular that the newton polygon of @xmath17 is well defined .",
    "we import the notations @xmath59 , @xmath296 and @xmath376 from  [ ssec : newtoniter ] and refer to eqs .",
    " for the definitions .",
    "[ prop : newtonprecslope ] we keep all the above notations and assumptions .",
    "we set : @xmath377 } \\varphi_p(x ) - \\varphi(x)\\ ] ] and assume that @xmath378 .",
    "then the factor @xmath371 is known with precision at least @xmath379 with @xmath380 } - \\varphi(d ) + \\delta$ ] .",
    "we define the sequences @xmath16 and @xmath387 by the recurrence : @xmath388 where @xmath151 and @xmath389 are those related to @xmath384 .",
    "note that @xmath390 if @xmath226 denotes the coefficient of @xmath391 in @xmath384 . by remark  [ rem : slope - factor ] , we know that the sequence @xmath16 converges to @xmath392 and furthermore : @xmath393 } +   b_\\varphi\\big((v_{\\textrm{app}}\\cdot \\delta p ) \\mod a_{\\textrm{app}}\\big)\\ ] ] since @xmath394 . using repeatedly lemma  [ lem : bphib0 ] , we obtain : @xmath395 thus @xmath396 } + \\delta$ ] .",
    "dividing by @xmath226 , we find @xmath397 and we are done .    under the hypothesis  * ( h ) * introduced below , a correct precision on @xmath371 is also @xmath398 where : @xmath399 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ \\times$ } ; \\end{scope } \\end{tikzpicture}}}}\\big({\\text{\\rm nf}}(v_{\\textrm{app } } ) - { \\text{\\rm nf}}(p)(d)\\big)\\big ) { { \\raisebox{-0.1mm}{\\begin{tikzpicture } \\draw[transparent ] ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ \\mod$ } ; \\end{scope } \\end{tikzpicture}}}}{\\text{\\rm nf}}(p)_{|[0,d]}.\\ ] ] this follows from proposition  [ prop : preca1 ] using @xmath400 .",
    "it follows in addition from remark  [ rem : slope - factor ] that @xmath401 is bounded from below by @xmath402 . this yields the bound @xmath403 ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ \\times$ } ; \\end{scope } \\end{tikzpicture}}}}\\psi\\big ) { { \\raisebox{-0.1mm}{\\begin{tikzpicture } \\draw[transparent ] ( -0.18,0)--(0.18,0 ) ; \\draw[very thin ] ( 0,0 ) circle ( 0.11 cm ) ; \\begin{scope } \\clip ( 0,0 ) circle ( 0.11 cm ) ; \\node[scale=0.75 ] at ( 0,0 ) { $ \\mod$ } ; \\end{scope } \\end{tikzpicture}}}}{\\text{\\rm nf}}(p)_{|[0,d]}$ ] where @xmath404 \\to { \\mathbb r}$ ] is the affine function mapping @xmath48 to @xmath405",
    ".    we can now move to the second question we have raised before , _",
    "i.e. _ the design of an algorithm for computing @xmath371 with the precision given by proposition  [ prop : newtonprecslope ] .",
    "our strategy consists in computing first the precision and applying then the newton iteration until the expected precision is reached .",
    "below is the precise description of our algorithm .",
    "the precision needed at line 6 is of course governed by the computation performed at line 7 .",
    "note that it can be either computed _ a priori _ by using proposition  [ prop : newtonpreceuclide ] or dynamically by using relaxed algorithms from @xcite . in both cases , it is in @xmath417 with @xmath418 .",
    "it follows from theorem  [ theo : slope - factor ] , remark  [ rem : slope - factor ] and proposition  [ prop : newtonprecslope ] that algorithm slope_factorisation_newton is correct and stable . using the standard soft-@xmath368 notation @xmath419 for hiding logarithmic factor",
    ", our algorithm performs at most @xmath420 combinatorial operations and @xmath420 operations in @xmath18 at precision @xmath42 with @xmath421 if one uses quasi - optimal algorithms for multiplication and euclidean division of polynomials .",
    "* lattice precision . * the precision datum is given here by a lattice @xmath422 in @xmath423 $ ] ; we shall then write @xmath424 where @xmath384 is a _ monic _",
    "approximation of the inexact polynomial @xmath17 we want to factor .",
    "we assume from now that @xmath422 is sufficiently small so that the newton polygon of @xmath17 is well defined .",
    "we then can define the function : @xmath425 \\times k_{=n{-}d}[x]\\ ] ] mapping a polynomial @xmath17 to the couple @xmath426 obtained from it .",
    "we set @xmath427 .",
    "obviously * ( h ) * gives an answer to the first question we have raised above : the precision on the couple @xmath371 is the lattice @xmath431 defined as projection on the first component of @xmath432 .",
    "it turns out that it can be computed explicitely as shown by the next proposition .",
    "[ prop : preca1 ] the application @xmath433 is of class @xmath434 on @xmath428 and its differential at some point @xmath17 is the linear mapping @xmath435 where @xmath436 and @xmath437 is the inverse of @xmath374 modulo @xmath371 .    the function @xmath438 is injective and a left inverse of it is @xmath439",
    ". clearly @xmath201 is of class @xmath434 and its differential is given by @xmath440 thanks to bzout theorem , it is invertible as soon as @xmath371 and @xmath374 are coprime , which is true because @xmath441 and @xmath442 do not shape a common slope . as",
    "a consequence @xmath438 is of class @xmath434 and its differential is obtained by inverting eq .  .",
    "reducing modulo @xmath371 , we get @xmath443 .",
    "the claimed result follows after having noticed that @xmath444 has degree at most @xmath117 .",
    "first remark that the @xmath447 defined in the statement of proposition  [ prop : newtonprecslope ] coincide with the @xmath447 introduced in the corollary .",
    "define @xmath380 } - \\varphi(d ) + \\delta$ ] .",
    "let @xmath422 ( resp .",
    "@xmath448 be the lattice consisting of polynomials of degree at most @xmath373 ( resp . at most @xmath117 )",
    "whose newton function is not less that @xmath449 } + \\delta$ ] ( resp .",
    "@xmath450 ) . we have to show that @xmath451 . according to proposition  [ prop : preca1 ] the mapping",
    "@xmath452 \\to k_{\\leq n{-}1}[x]$ ] , @xmath453 is a right inverse of @xmath454 .",
    "it is then enough to prove that @xmath201 takes @xmath431 to @xmath422 , which can be done easily using theorem  [ theo : edivisionnp ] .          _",
    "( i ) _ set @xmath462 .",
    "we know by assumption that @xmath463 . thus @xmath464 is well defined .",
    "the unicity of the slope factorization ( _ cf _ remark  [ rem : unicity ] ) further implies that @xmath465 .",
    "the claimed result now follows from the hypothesis  * ( h)*.    _ ( ii ) _ by applying  * ( h ) * with @xmath466 and replacing @xmath467 by its expression given by proposition  [ prop : preca1 ] , we find : @xmath468 dividing @xmath469 by @xmath470 modulo @xmath471 , we get @xmath461 as expected .    as a conclusion ,",
    "the algorithm we propose consists in computing the newton sequences @xmath16 and @xmath387 ( following the strategy of the algorithm ` slope_factorisation_newton ` regarding to precision ) until we find a couple @xmath472 satisfying the requirements ( i ) and ( ii ) of proposition  [ prop : stop ] .",
    "once this couple has been found , one may safely output @xmath473 under * ( h)*. the resulting algorithm has quasi - optimal running time and optimal stability ."
  ],
  "abstract_text": [
    "<S> we study two important operations on polynomials defined over complete discrete valuation fields : euclidean division and factorization . in particular , we design a simple and efficient algorithm for computing slope factorizations , based on newton iteration . one of its main features is that we avoid working with fractional exponents . </S>",
    "<S> we pay particular attention to stability , and analyze the behavior of the algorithm using several precision models .    </S>",
    "<S> [ section ] [ theo]lemma [ theo]proposition [ theo]corollary [ theo]question [ theo]conjecture [ theo]remark [ theo]example [ theo]definition </S>"
  ]
}