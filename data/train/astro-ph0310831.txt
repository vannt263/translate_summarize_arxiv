{
  "article_text": [
    "since the introduction of correlation functions into modern cosmology by e.g. , totsuji & kihara ( 1969 ) and peebles ( 1973 ) , such functions have proved to be useful in a large variety of situations .",
    "a few typical applications are the study of the distribution of galaxies and clusters of galaxies in the universe ( e.g. , connolly et al .",
    "2002 ; maddox , efstathiou & sutherland 1996 ; dalton et al .",
    "1994 ; croft , dalton , & efstathiou 1999 ; lilje & efstathiou 1988 ; frieman & gaztaaga 1999 ; jing & brner 1998 ) , the analysis of the gravitational lensing shear ( e.g. , bernardeau , van waerbeke , & mellier 2003 ; takada & jain 2003 ) , or measurements of non - gaussianity in the cosmic microwave background ( e.g. , eriksen , banday , & grski 2002 ; kogut et al .",
    "1996 ) .",
    "unfortunately , higher order @xmath0-point correlation functions are also notorious for being computationally expensive . in general the evaluation of an @xmath0-point",
    "correlation function scales as @xmath1 , and therefore the required cpu time soon becomes too large to handle .",
    "to remedy this situation several `` fast '' algorithms have been proposed , in particular for analyzing discrete particle data sets ( such as galaxy catalogs ) .",
    "one commonly used method is to aggregate particles on small scales , and treat each of these aggregations as a single particle ( e.g. , davis et al .",
    "1985 ; kaiser 1986 ) .",
    "this method effectively corresponds to smoothing the data set , and is only valid when the distance between the aggregated particles is much smaller than the scale of interest .",
    "it is therefore of limited use if the primary interest lies in small scales , which often is the case for cmb data .",
    "the main motivation behind this work is analysis of new high - resolution cmb maps . in this case , as in several other applications , the data are not consisting of point sets ( e.g. , positions of galaxies ) but in values of a function ( like temperature , polarization , or shear ) given for all pixel positions on a map covering part of or the full sky , where some fixed pixelization scheme has been used to divide the area of concern into pixels .",
    "further , when analyzing such maps , the main interest is usually in comparing a statistic ( e.g. , a correlation function ) estimated on a map of the real sky with a large monte carlo set of the same statistic estimated on several thousand random realizations based on some theory , e.g. , gaussian fluctuations with a given power spectrum .",
    "hence , one must estimate the correlation function for a set of many thousand similar maps with the same pixelization to do the analysis of interest .    the @xmath2d - tree approach ( e.g. , moore et al .",
    "2001 ) is based on a similar idea to the idea of aggregating particles on small scales .",
    "it organizes nearby particles ( or pixels ) into a hierarchy of bounding boxes , and uses this hierarchy for rapidly discarding uninteresting pixel sets .",
    "however , it is not obvious that the @xmath2d - tree approach is well suited for estimating correlation functions from a pixelized map ( which completely fills the @xmath2-dimensional space ) , unless bin widths much greater than the pixel size is desired .",
    "( normally one sets the bin width roughly equal to the pixel size in order to obtain optimal resolution . )",
    "a third approach relies on the fourier - transform , and this approach drastically speeds up the algorithms whenever the fast fourier transform ( fft ) is applicable ( for a two - point application , see , e.g. , szapudi , prunet , & colombi [ 2001a ] ) . however , this method is not very attractive for higher - order correlation functions . in the three - point case one",
    "replaces an @xmath3 algorithm with a very _ small _ prefactor ( multiply three numbers together ) with an @xmath4 algorithm with an extremely _ large _ prefactor ( compute several wigner 3-@xmath5 symbols ; see , e.g. , gangui et al .  [ 1994 ] ) .",
    "four - point functions are obviously even more expensive .",
    "thus , the advantage of fourier - methods for estimating high - order correlation functions is so far unclear .    in this paper",
    "we describe a new set of algorithms which allows computation of any ( small ) subset of the general @xmath0-point correlation functions from a pixelized map of the whole celestial sphere , or a part of the celestial sphere , with up to several hundred thousand pixels .",
    "these algorithms are extremely well suited for monte carlo studies , since we organize the processes so that the very substantial amount of initialization cpu time is spent only once for the whole ensemble of sky maps , and not for each individual map . for ensembles of more than about one thousand realizations",
    ", most of the cpu time is therefore spent on adding pixel values together , not on geometric computations .",
    "the general idea behind these algorithms is to replace cpu - intensive inverse cosine operations by much less cpu - intensive ` if`-tests , at the cost of increasing the memory requirements .",
    "first we compute the distances between any two pixels in the map and store this information in a set of tables optimized for fast searches ( and compression , if desirable ) .",
    "these tables can be compared with a set of compasses , in the sense that each column of a table draws out a circle on the sphere of a given radius , centered on a given pixel .",
    "then , by searching through two different columns for equal entries , we generate triangles with the desired size and shape , and , if necessary , add two or more such triangles to produce @xmath0-point multiplets .",
    "in fact , our method is equivalent to ruler and compass construction of triangles .    a similar algorithm for estimating @xmath0-point correlation functions for point sets ( e.g. , galaxies ) in three - dimensional space has recently been developed by barriga & gaztaaga ( 2002 )",
    "however , there are several important differences between the two methods .",
    "first , our methods are designed particularly for monte carlo simulations , in that we organize the information so that initialization costs are paid only once .",
    "second , we use the `` compasses '' to determine all three edges in the triangle , while barriga & gaztaaga ( 2002 ) only use them for constraining two of the edges .",
    "finally , our methods are particularly designed to take advantage of the healpix nested pixelization scheme ( grski , hivon , & wandelt 1999 ) , although they can ( at a considerable efficiency cost ) be generalized to any pixelization .",
    "a first application of a preliminary version of these algorithms to estimate the three- and four - point correlation functions of the @xmath6-dmr maps was presented by eriksen et al .",
    "( 2002 ) , and a thorough application of the algorithms to the wmap ( bennett et al .",
    "2003 ) data will shortly be published ( eriksen et al .",
    "2004 , in preparation ) .",
    "the examples given at the end of this paper are in fact chosen to correspond with that analysis .",
    "an @xmath0-point correlation function is defined as the average product of @xmath0 temperatures can of course be replaced by any scalar quantity . ] , as measured in a fixed relative configuration on the sky , @xmath7 here @xmath8 span an @xmath0-point polygon with geometric parameters , @xmath9 , on the sky , and @xmath10 is the field value in the direction given by the unit vector @xmath11 .    in all common applications we assume isotropy , and",
    "then the @xmath0-point correlation functions are only dependent on the shape and size of the @xmath0-point polygon , and not its particular position or orientation on the sky .",
    "the smallest number of parameters which uniquely determines such a polygon is @xmath12 .    on a pixelized map ,",
    "the @xmath0-point correlation functions are estimated as simple averages over all pixel multiplets ( pairs , triplets , quadruples etc . ) satisfying the geometric constraints of the particular configuration , @xmath13 the pixel weights , @xmath14 , may be adjusted to account for , e.g. , noise or boundary effects .",
    "note also that we always , but often implicitly , bin our correlation functions with a given bin width , @xmath15 . a pixel pair of angular separation @xmath16",
    "is then defined to belong the the @xmath17th bin if @xmath18 . as seen from equation ( [ eq : def_comp_npt ] )",
    ", the evaluation of an @xmath0-point correlation function is in principle very simple .",
    "however , before we can multiply and add the individual pixel values , we need to determine all the correct pixel multiplets . that is less than trivial , and constitutes the main theme of this paper .",
    "our starting point is the brute force method for estimating @xmath0-point correlation functions .",
    "if we want to estimate the three - point correlation function for only a subset of all possible configurations , e.g. , for all equilateral triangles , the brute force method is to go through the set of all pixel triplets in the map ( resulting in an @xmath19 $ ] algorithm ) , and compute the three distances between each pixel pair .",
    "each of the three distances is computed by taking the inverse cosine of the the dot product of the two pixel unit vectors . knowing that one inverse cosine operation takes about 40 times as many cpu cycles as a multiplication , we see that not only does the brute force algorithm scale as @xmath3 , but its prefactor is also very high . however , the most time consuming shortcoming of the brute - force approach is that we have to go through every single pixel triplet existing in the map , even though we may only be interested in a very small subset of all configurations .",
    "thus , most of the cpu time is wasted on computing uninteresting information .",
    "our first task is to produce `` compasses '' for picking out the right pixels .",
    "having decided on a number of external parameters , such as pixel resolution ( parameterized by @xmath20 of healpix ) , separation bin width , @xmath21 , and total number of pixels in the data set , @xmath22 ( usually by introducing a mask ) , we make `` compasses '' by going through the set of all pixel pairs , compute the distance between the two pixels in each pair , and determine which separation bin the pair belongs to .",
    "we then insert the pair into a special table ( in the following called a two - point table ) for that bin , a table which is optimized for fast searches ; the @xmath23th column of the @xmath2th table contains all pixels with a distance in the interval @xmath24 from pixel number @xmath23 , sorted according to increasing pixel number . in other words ,",
    "the @xmath23th column of the @xmath2th table is a `` compass '' that draws out a circle on the healpix sphere with radius @xmath25 and width @xmath15 , centered on pixel number @xmath23 .",
    "these two - point tables are computed once and for all , and stored in individual files for later use . already at this point",
    "we can estimate the two - point correlation function with unprecedented efficiency , essentially performing just one addition for each pixel pair . the particular algorithm for this",
    "is described in  [",
    "sec : calculations ] .    however , our main goal is to estimate higher - order @xmath0-point correlation functions , and then we have to find all triangles , quadrilaterals etc .  on the sky of some",
    "given geometric configuration .",
    "here it is worth noting that once we are able to construct triangles , all higher - order structures may be generated simply by putting triangles together .",
    "therefore we here focus on how to construct triangles .",
    "as noted previously , construction of triangles is performed by the use of `` compasses '' : suppose that we want to find all triangles with edge lengths of @xmath26 , @xmath27 and @xmath28 .",
    "we then pick out one pair of pixels , @xmath23 and @xmath5 , from the two - point @xmath26-table , and look up the @xmath23th column in the @xmath27-table and the @xmath5th column in the @xmath28-table .",
    "any common entries in these two tables will have the correct distances from the two base pixels , and together the three points span a triangle of the desired size and shape .",
    "this search is fully equivalent to drawing out circles on the sky , and looking for intersections .",
    "the correspondence between the geometric and algorithmic views is illustrated in figure [ fig : gen_triangles ] .",
    "once this process has been performed for all base pairs in the @xmath26-table , we have also found all triangles of the correct shape and size . at this point",
    "we may therefore forget all about expensive geometric computations , and concentrate on multiplying and adding the pixel triplets together as fast as possible .",
    "let us now go through each step of the underlying algorithms in detail , paying particular attention to real - world problems , such as how to deal with limited physical ram and cpu - time .",
    "the first step in our @xmath0-point correlation algorithm is to construct a set of two - point distance tables .",
    "each of these tables corresponds to a set of `` compasses '' with fixed radius .",
    "for our idea to be of practical use , the two - point tables must meet two requirements : first of all , each table must be small enough to comfortably fit into the physical memory of the computer .",
    "second , the tables must facilitate fast searches for `` neighboring '' pixels ( defined as pixels within a ring of a given radius and width ) for any given center pixel .",
    "since we always bin our correlation functions with a given bin width @xmath15 , the first requirement is met by splitting the full @xmath29 distance matrix up according to these bins , simply by letting the bin width be small enough .",
    "thus , all pixel pairs belonging to the same bin are collected into one table , which later is stored as a separate file .",
    "the next question is how to organize these tables .",
    "the important point is to be able to efficiently draw out a circle around any given center pixel .",
    "that is , given any position on the sky , we must be able to easily look up all pixels with a given distance from that position .",
    "for this purpose we choose a simple two - dimensional array , in which each column corresponds to one single ring on the sky , centered on the pixel @xmath30 , listed in the zeroth row .",
    "thus , all other pixels , @xmath31 , in that column satisfies the relation , @xmath32 , where @xmath33 are unit vectors and @xmath34 are the angular limits of the bin .",
    "we will later be searching for identical entries in two different columns in order to generate triangles , and therefore we already at this point sort the neighbors of each column according to pixel number .",
    "this facilitates @xmath35 searches , as opposed to @xmath36 for unsorted columns .    in most experiments",
    "we introduce a mask , either in order to exclude noise - contaminated pixels , or simply to limit our region of interest .",
    "whatever reason , we incorporate such a mask already at the construction level , by only including accepted pixels in the tables .",
    "thus , the zeroth row is nothing but a list of all accepted pixels , and all pixels in the table are guaranteed to be accepted by the mask . not only does this remove many redundant ` if`-tests later on , but more importantly , it makes sure that the algorithms and disk usage scale as @xmath37 , rather than @xmath38 , where @xmath22 is the number of _ accepted _ pixels . for small regions in a high - resolution map ,",
    "the difference is crucial .",
    "the remaining details are mostly of cosmetic nature .",
    "first , since the two - point tables are simple two - dimensional arrays , there will be a small amount of unused space in many columns .",
    "this extra space is padded with -1 s , distinguishing those entries from valid pixel numbers .",
    "secondly , we also store all external parameters ( @xmath20 , @xmath39 , ` ordering ` , bin number etc . ) together with the two - point table in an external file , making each file an independent entity , in the spirit of object - oriented programming .    although the two - point tables are quite simple to describe , they are surprisingly complicated to generate , the fundamental problem being their size .",
    "suppose that we have a map with 100000 pixels , and we want to generate a complete set of two - point tables .",
    "doing it straight - forwardly ( i.e. , by keeping all information stored in memory at once ) , we would need at least 100000@xmath40 of memory , and few current computers have that much physical ram available . on the other hand , this number is not prohibitive in terms of disk storage .",
    "the question is therefore how to generate the two - point tables .",
    "once this operation is completed , we can store them on a hard drive , compress them if desirable , and then read only a few at a time when actually estimating the correlation functions .",
    "we utilize the healpix pixelization with _ nested _ pixel ordering .",
    "this pixelization has the highly desirable property that any low - resolution pixel may be divided into four high - resolution pixels , where the pixel numbers of the high - resolution pixels are given by @xmath41 , @xmath23 being the pixel number of the low - resolution pixel and @xmath42 .    in short",
    "the generation process can be described as a three - step operation :    first we generate a set of tables with low resolution , choosing a resolution low enough to keep all information simultaneously in the computer s physical memory .",
    "second , each table is expanded to a higher resolution by replacing the low - resolution pixel numbers by the high - resolution pixel numbers .",
    "since each mother pixel has four children , the output array is four times as wide and deep as the input array .",
    "all pairs in the output array have distances in approximately the correct range , and therefore the output two - point table is almost a valid high - resolution table .",
    "however , since the boundary between two rings is smoothed when the resolution is increased , one may find that a number of pixel pairs actually belong to the neighboring bins after expansion .",
    "this has to be accounted for , and to do so we sort the pixel pairs in the the high - resolution output table according to actual bin number , and output these as incomplete two - point tables .    finally , after subjecting all low - resolution tables to this operation , we complete the expansion process by collecting all partial tables of the same output bin number into complete two - point tables .",
    "these two last expansion steps are repeated as many times as necessary to obtain the desired resolution .    in the following three subsections ,",
    "we describe each of these steps in more detail .",
    "the first step is illustrated in figure [ fig : inmemgen ] while the two last steps are illustrated in figure [ fig : expansion ] .",
    "assume first that we actually do have enough memory available to simultaneously store all @xmath43 pixel pairs in the computer s ram , i.e. , that there are no memory restrictions .",
    "in that case the procedure is quite simple .",
    "first we allocate an @xmath29 array , and run through the set of all pixel pairs . for each pair",
    "we compute the angular distance @xmath44 between the two pixels @xmath23 and @xmath5 , and mark both the @xmath5th row of the @xmath23th column and the @xmath23th row of the @xmath5th column by the integer part of @xmath45 .",
    "once this process is completed , the desired two - point tables can easily be extracted from the main array  the @xmath2th table is found by scanning each column for the number @xmath2 , while storing the row numbers of these entries in the output array .",
    "note that the output two - point table is automatically sorted by this method , maintaining the @xmath37 scaling of the algorithm ( rather than @xmath46 $ ] as would be the case if explicit sorting was necessary ) .",
    "as is indicated in figure [ fig : inmemgen ] , we do not count the center pixel as a valid neighbor to itself in the zeroth bin . or speaking in terms of correlation functions , we never let a pixel be multiplied with itself . for most experiments",
    "the noise in each pixel is quite high , but , fortunately , it is also usually independent from pixel to pixel . in order to eliminate this noise bias , we exclude powers of single pixel values from the correlation functions .",
    "this is a general problem for all quadratic estimators .",
    "let us also make one note on how to compute the binned distance between two pixels efficiently : the standard method is to take the dot product of the two pixel center vectors , compute the inverse cosine of that product , divide the angular distance by the bin width , and keep the integer part .",
    "this method is quite slow because of the inverse cosine operation which requires about 40 times the cpu time of a multiplication .",
    "when using the healpix nested pixelization , a faster alternative is available by means of a linear search : one simply allocates an array , ` binlim ` , of length @xmath47 which contains the cosine of the bin limits , such that @xmath48 } = \\cos([i-1]d\\theta)$ ] and @xmath49 } = \\cos(n_{\\textrm{bin}}d\\theta)$ ]",
    ". then the correct bin number , ` bin ` , may be found by searching for the array position defined by @xmath50 } \\le \\cos\\theta_{ij } < \\texttt{binlim[bin+1]}$ ] .",
    "the crucial point here is that the bin position must be stored between consecutive searches : since the pixels @xmath5 and @xmath51 are very close to each other on the sky in the nested healpix pixelization , the distance between @xmath23 and @xmath51 will be almost the same as the distance between @xmath23 and @xmath5 .",
    "therefore one does not have to move more than a few steps to find the correct bin for each pixel .",
    "for the same reason the search should _ not _ be implemented by a quicksearch - algorithm , but rather with a straight - forward linear method . while the former is superior for general searches , the latter has considerably less overhead per step , and is therefore much faster if we only want to move a few steps , as is the case here .",
    "the above trick is in fact very useful in most two - point correlation function algorithms , and if the nested healpix scheme is employed , one can often reduce the total cpu time by 60 - 70% .",
    "another advantage is that the bin limits may be set arbitrarily , and therefore the method seamlessly accommodates for alternative binning schemes . in particular ,",
    "gauss - legendre binning ( ie . , placing the bins at the roots of the legendre polynomials ) is often useful if one wants to integrate the two - point correlation function to find the power spectrum ( szapudi et al .",
    "1991b ) .",
    "the output from the above process is a completely valid set of two - point tables , but , unless massive amounts of memory is available , they only describe a low resolution map",
    ". a computer with 1 gb of ram can typically only handle up to 15000 pixels through the above description , and a super - computer with shared memory of @xmath52 gb up to about 100000 pixels .",
    "usually we therefore have to expand the structure set segment by segment in order to obtain the desired resolution and pixel number .    as mentioned above",
    ", increasing the resolution of a healpix map is particularly simple in the nested pixelization  each mother pixel is replaced by four children pixels having pixel numbers given by @xmath41 , where @xmath23 is the pixel number of the mother pixel and @xmath42 .",
    "the expansion in resolution is therefore easily performed by substituting each entry of the original two - point table by a @xmath53 sub - array ( the zeroth row has to be treated individually , though ) . however , since pairs that originate from the same mother pixel may belong to different high - resolution bins , we can not simply substitute the low - resolution pixel numbers by the above method , and hope that the resulting array will be a valid high - resolution two - point table .",
    "usually we also want to increase the number of bins during such an expansion , considering that a higher resolution supports a smaller bin width .",
    "for these two reasons we have to compute all angular distances once again to determine to which bins the various pairs belong . based on this information",
    "we extract a set of partial two - point tables , similar to what was done in the first , low - resolution step , and store the resulting partial tables on file , labeled by two numbers , ` bin_from ` and ` bin_to ` .",
    "the output from the above process is a set of arrays characterized by the set of parameters \\{@xmath54 , @xmath55 , @xmath56 , @xmath57 , ` bin_from ` , ` bin_to`}. the final task is to collect all partial tables with the same ` bin_to ` ( containing pixel pairs in the same output bin , but originating from different low - resolution bins ) into complete two - point tables .",
    "this operation obviously amounts to merging the partial array columns , while maintaining the already sorted relationships , and inserting the final result into a large output array .",
    "since the partial tables are already sorted according to pixel number , no additional sorting is required .",
    "this is actually true for all the above steps  no explicit sorting is necessary to generate sorted output two - point tables .",
    "at this point we have obtained a set of high - resolution two - point tables stored on disk files . and already at this point we may estimate the two - point correlation function extremely efficiently .",
    "however , our main goal is to study the higher - order correlation functions , and we therefore proceed to the construction of triangles by means of the two - point tables , before turning to applications .",
    "our algorithm for constructing triangles on the healpix sphere is fully equivalent to ruler and compass construction of triangles ( i.e. , where an equilateral triangle is constructed by first drawing a base line , then from a given first vertex on this line drawing a circle with the given length as radius , and then drawing a new circle with the same radius from the second vertex at the intersection between the line and the first circle , finding the third vertex of the triangle at the intersection between the two circles ) , the only difference is that the physical compass is replaced with the two - point tables .    wanting to find all _ equilateral _ triangles having a given pixel @xmath23 as one vertex and edges given by a given bin number @xmath2 , the first step is to look up the @xmath23th column of the @xmath2th two - point table .",
    "all entries in this column are located in the correct distance from pixel @xmath23 .",
    "next , we pick an arbitrary pixel , @xmath5 , from this column . together",
    "these two pixels constitute the base line of the triangle .",
    "now we scan the @xmath23th and the @xmath5th column simultaneously , searching for identical entries .",
    "any common entries in the two columns will be located in the correct distance from both pixel @xmath23 and @xmath5 , and therefore the three pixels together span an equilateral triangle .",
    "once we find such a triplet we store it in an auxiliary array for later use .",
    "we then keep scanning until the bottom of one column is reached .",
    "note that since the columns are sorted according to pixel number , the searches scale as @xmath35 , rather than as @xmath36 in the unsorted case .    for our ranges of pixel numbers in the maps and bin widths",
    ", we typically find between two and six valid pixels in each such scan . if we are only interested in scalar valued symmetric three - point correlation functions , all of these triplets are acceptable , and in such cases we store all of them for later use .",
    "however , if we want to estimate for instance the four - point correlation function , asymmetric three - point correlation functions or spin-2 field correlation functions ( for polarization maps ) , we need to know the orientation of the triangle , or in other words , we need to know whether we traverse the triangle clockwise or counter - clockwise when listing the pixels as \\{@xmath23 , @xmath5 , @xmath58}. in these cases we introduce the convention that the two first pixels form the base line and the third pixel is positioned _ above _ the base line . in other words , @xmath59 .",
    "the above procedure results in a @xmath60 array , in which each column is an acceptable pixel triplet for the current geometric configuration ( in practice we organize the the array slightly differently , to accommodate for fast summing over the third pixel  see  [ sec : calculations ] for details ) . at this point we can estimate the three - point correlation function by multiplying the three pixels together , and sum it all up . however , if we want to estimate the four - point correlation function we need to go one step further .    we find the simplest example of a more complicated geometry when we want to estimate the rhombic four - point correlation function .",
    "this configuration consists of two equilateral triangles `` glued '' together on one edge .",
    "we can therefore use our list of equilateral triangles to find the set of all such quadruples .",
    "the idea here is simply that the two triangles must have the same base line , but in reversed order ( since they must have opposite orientation ) .",
    "thus , we must search for pairs of triangles for which @xmath61 and @xmath62 , where @xmath63 is the first vertex of the first triangle , @xmath64 is the second vertex of the first triangle , etc .",
    "the four required pixels are then given by the two common vertices and the two third pixels .",
    "this time we store the sets of four pixels in a @xmath65 array , listed so that the two first entries of each column forms the base line , the third pixel lies above the base line and the fourth lies below the base line .    note that any @xmath0-point polygon may be built up by triangles , and the same ideas may therefore be used for computing any @xmath0-point correlation function . in the above examples we have focused on polygons for which all edges have the same length .",
    "however , the same algorithm can easily be used to also produce general triangles , and thereby general quadrilaterals .",
    "suppose , e.g. , that we want to find all triangles with edges given by the bin numbers @xmath66 .",
    "in that case we would use the @xmath2th two - point table to find pixel pairs , @xmath23 and @xmath5 , which forms the base line of the triangle .",
    "then we would simultaneously scan the @xmath23th column of the @xmath58th two - point table and the @xmath5th column of the @xmath67th two - point table to find the desired third pixels .",
    "we start with the case where we want to estimate the two - point correlation function for separation given by bin number @xmath2 , for which we already have constructed a two - point table as described above .",
    "if the number of different pairs with separation in this bin is @xmath68 , then the two - point correlation function is estimated by @xmath69 ) \\cdot \\sum_{j < i } \\delta    t(\\texttt{table}[j , i ] ) .",
    "\\label{eq : comp_twopt}\\ ] ] explicitly , we sum up all field values in each column , and multiply that sum with the zeroth row value .",
    "it is difficult to imagine a more efficient method for estimating the two - point correlation function than this ; we basically perform only one addition for each pixel pair .",
    "note also that we only sum over pairs for which @xmath70 in order to avoid double counting , and thus the total cpu time is reduced by a factor of 2 .    for monte",
    "carlo studies the initialization cost is paid once only , and in such cases the above equation is where the massive amounts of cpu time are spent . although our method intrinsically is quite slow , being an @xmath37 method , it is for this reason probably as fast as a two - point correlation function algorithm will ever be , without introducing either fourier - methods or large - scale smoothing .",
    "let us now take a look at the higher - ordered correlation functions , and suppose that for any given configuration we have already computed an @xmath71 array containing all pixel multiplets satisfying the binned geometric requirements . here",
    "@xmath0 is the order of the correlation function and @xmath17 is the number of pixel multiplets .",
    "with such a table the correlation function is estimated by @xmath72 ) \\cdots \\delta    t(\\texttt{table}[n , i ] ) .",
    "\\label{eq : comp_npt}\\ ] ]    when the bin width is very small , there is typically only one polygon corresponding to each base line , and in such cases it is not possible to accelerate equation ( [ eq : comp_npt ] ) .",
    "however , when the bin width is comparable to or larger than the pixel size , one often finds that for two given base line pixels there may be several acceptable third pixels .",
    "if we want to estimate the three - point correlation function in such cases , we may organize our arrays a little differently : rather than listing each triplet individually , we may first list the two base line pixels , then the number of third pixels , and finally list all those third pixels . obviously , a one - dimensional array is more suitable for this organization than the original two - dimensional one , since the number of third pixels may vary strongly from set to set .",
    "if the average number of third pixels is larger than about 1.5 ( as often is the case in real - life applications ) , this linear organization will both result in a smaller triplet array , and speed up the computations , since equation ( [ eq : comp_npt ] ) is replaced by @xmath73 if @xmath74 , we here have to perform two multiplications and two additions for each base pair , a total of four operations , while in the `` unrolled '' organization , the corresponding numbers are six multiplications and two additions .",
    "thus the total cpu time is roughly halved by introducing the linear organization .",
    "the same trick is even more powerful when estimating four - point correlation functions , since we in that case can sum over both the upper and the lower groups of third pixels .",
    "having , e.g. , two pixels in both groups ( or in other words , having four different quadruples ) , would require twelve multiplications and four additions for each base pair in the `` unrolled '' organization , but only three multiplications and three additions in the linear one .",
    "note also that this linear organization is very simple to construct , it falls out naturally from the method we use to construct the triangles in the first place where we fix our interest on two base line pixels , and scan through the two corresponding columns for third pixels .",
    "thus , producing the linear organization is only a matter of storing the results from the scans appropriately .",
    "before benchmarking the algorithms , we briefly discuss a few ideas of interest to anyone who wants to use these algorithms in practice , and which are implemented in our software .",
    "first we show how to optimize the cache usage in the case of monte carlo studies , and then we briefly comment on how to parallelize these algorithms .",
    "finally , we show how to compress the two - point tables in order to save disk space .      from the previous sections it should be clear that these @xmath0-point algorithms are very close to being optimal for monte carlo simulations . in applications where the initialization cost is small compared to the computational costs ,",
    "there is not much left to gain from an algorithmic point of view  we have removed all geometry from the computations , and all that is left is to multiply field values together as fast as possible , and sum it all up . however , there are two main issues left to consider , cache optimization and parallelization .",
    "let us start by looking at the cache usage .    in a monte carlo application",
    ", we want to estimate the two - point correlation function for , say , 1000 different maps .",
    "the naive approach is simply to loop over the maps , applying equation ( [ eq : comp_twopt ] ) repeatedly .",
    "however , this has two negative effects .",
    "first of all , the cpu has to move the two - point table information from the main memory into the cache 1000 times .",
    "secondly , the number of hits per memory page in the map array may be less than optimal , since consecutive rows may contain widely separated pixel numbers .",
    "on the other hand , both the fact that the columns of the two - point tables are sorted , and the nested healpix pixelization , improve the situation .",
    "if we have considerable amounts of physical memory available , we can do better by analyzing all maps simultaneously . in this case",
    "we store all 1000 maps row - wise in a two - dimensional array , so that each column contains the map values of one single pixel . with this large super - array",
    "we can loop over the maps in the innermost loop , rather than in the outermost .",
    "thus we are guaranteed almost perfect cache usage . also , we only need to look up the two - point table once , further reducing the memory traffic .",
    "the question is then , do we have enough memory available to store all 1000 maps ? for a map of , say , three million pixels , the answer is clearly `` no '' , since that would require about 12 gb of memory , assuming single precision floating point numbers .",
    "on the other hand , for maps with less than 50000 pixels we only need 400 mb , and that is not a large amount for current computers .",
    "even with our algorithms , estimation of @xmath0-point correlation functions is cpu intensive , and maps of several million pixels are out of reach for today s computers .",
    "thus , cpu time is the limiting factor , rather than available memory . for this reason we often choose to analyze high - resolution maps region by region ( by the introduction of masks ) , where each region contains no more than , e.g. , 50000 pixels to @xmath75 , and then computing each correlation function in @xmath76 bins on a set of complementary hemispheres .",
    "the smaller scales were studied by partitioning the sky into @xmath77 disks , on each of which the three - point function was estimated . ] . in these cases",
    "we can discard all the unused map information , and retain the included pixels only .",
    "explicitly , we now introduce a new pixel ordering scheme , counting relative to the mask rather than to the resolution parameter @xmath20 .",
    "the maps are converted from the standard healpix numbering to the mask - based ordering by extracting all included pixels , while conserving their relative order .",
    "thus , the first included pixel is assigned the new pixel number 1 , the second included pixel is assigned the new pixel number 2 etc . by storing these conversion rules in an external table , we may easily go back and forth between mask - based and map - based pixel ordering . in order to optimize the cache usage for high - resolution maps , we convert all maps and two - point tables to mask - based pixel ordering , and then proceed as before .",
    "the final issue to consider from an efficiency point of view is parallelization .",
    "there are two different cases , the geometric computations and the actual correlation function calculations .",
    "the latter part is quite trivial , considering that we already in the algorithmic design have divided the problem into completely separate parts  usually we want to compute many bins of each correlation function , and then we let each processor work on its own geometric configuration .",
    "this obviously results in perfect speed - up ( i.e. , doubling the number of processors halves the total cpu time ) .",
    "parallelization of the construction of the two - point tables is not quite as simple , at least not for the very first step , in which we generate a full @xmath29 table .",
    "however , one possibility is to let each processor work on separate columns , and then merge the partial results into one complete array in the end .",
    "once this task is performed , the problem is once again divided into separate parts , and the expansion steps may be trivially parallelized , like the @xmath0-point calculations .",
    "if disk space is a limiting factor , one may be discouraged by the substantial size of the two - point tables . in such cases",
    "one may wish to implement file compression .",
    "one common algorithm for this purpose is the huffman ( 1952 ) coding method .",
    "the idea behind this algorithm is to assign short bit strings to frequently occurring symbols ( i.e. , integers in our setting ) , and long bit strings to rarely occurring symbols .",
    "the average number of bits per symbol is thus minimized .",
    "applied to our two - point tables , it appears at first sight as though little is gained ; since any pixel number has to occur somewhere in each column , each number is more or less equally frequent in each two - point table .",
    "however , one property of our two - point tables still makes huffman coding most efficient , namely the fact that each column is sorted according to increasing pixel number .",
    "therefore , if we subtract the values in two consecutive rows , we get a small positive number , and the total histogram of the table is strongly skewed toward low values .",
    "this new , transformed array may be compressed very efficiently .",
    "a simple way of taking advantage of this idea is to do the following : first we transform the original array by subtracting consecutive rows , and store the resulting array in an external file .",
    "then we compress that file using any available compression utility ( which usually relies on a combination of huffman and run - length coding ) , e.g. , ` gzip ` .",
    "this method routinely reduces the required disk space by 80 - 90% for standard combinations of @xmath20 and @xmath39 .    in the current implementation",
    "there are special routines for reading and writing two - point tables .",
    "compression may therefore be enabled simply by adding a few appropriate lines in each of those routines ( subtracting consecutive rows , making a system call to ` gunzip`/`gzip ` etc . ) , leaving the rest of the source code unchanged .",
    "we have run several tests to determine what resources are required for application of the above algorithms .",
    "the parameters of these tests mimic those used in the small - scale wmap analysis of @xcite , in that we let our region of interest be a disk on the healpix sky , pixelized at @xmath78 , and with a bin width of @xmath79 .",
    "the only difference is that we let the radius of the disk vary between @xmath80 and @xmath81 ( in steps of @xmath82 ) in order to see how the algorithms scale with respect to number of pixels .",
    "these disks correspond to pixel numbers between 5940 and 53464 , and we should therefore get a good picture of how the algorithms behave in real - world situations . the computer used in the following tests is a compaq ev6 alpha server .",
    "we start by generating a set of two - point tables for each disk , and measure the cpu time and disk space spent in this process .",
    "next we estimate the two- , three- and four - point correlation functions from 100 simulated maps , and find the number of pixel multiplets ( pairs , triplets and quadruples ) , the cpu time per realization and initialization cost as a function of @xmath22 .",
    "the results from the two - point table generation tests are shown in figure [ fig : struct_gen ] . in panel",
    "( a ) we see that the time spent on this process does not follow the expected @xmath37 relationship .",
    "in fact , the cpu time scales as @xmath83 , while the input / output time ( i.e. , disk activity ) does nt even follow a power law .",
    "the explanation is the same in both cases : each of these quantities follows a relation of the general form , @xmath84 .",
    "algorithmic overhead and initialization costs are typically linear in @xmath22 , and these are likely to dominate for a small number of pixels . in other words , @xmath85 .",
    "what we see in figure [ fig : struct_gen_cputime ] is the manifestation of this . for the relatively modest number of pixels we consider",
    ", we do not reach the asymptotic @xmath43 region , and therefore the effective scaling coefficient in this region is smaller than 2 .",
    "this result may seem somewhat counter - intuitive ; normally a low scaling coefficient is interpreted in a positive direction .",
    "that is not the case here .",
    "rather , it may suggest that the current implementation is sub - optimal , and that there is room for improvements .",
    "however , it should also be noted that a truly @xmath86 implementation can probably only be devised if one is able to store the full @xmath87 distance matrix in the physical ram simultaneously , and in that case our methods are superfluous .    the important conclusion , however , is that the current algorithms are in fact sufficiently efficient to handle data sets with at least a few hundred thousand pixels , considering that it only takes about an hour to generate a set of two - point tables for 50000 pixels .    in figure",
    "[ fig : struct_gen_diskspace ] the corresponding disk space usage is shown .",
    "here we do see a virtually perfect @xmath86 scaling , a result which should come as no surprise .",
    "the linear overhead for storing the two - point tables is basically just a few extra rows ( for storing the pixel centers and padding extra space with -1 s ) , and this is normally negligible compared to the total number of `` neighboring '' pixels .",
    "note also that disk space is not a critical factor in these computations ; a data set of 50000 pixels requires less than 20 gb of space , a trivial amount of disk space for current computers .",
    "if we want to include as many pixels as 200000 , we would need 160 gb , and then perhaps compression might be needed , as described in the previous section .",
    "then the disk space requirements would be less than 30 gb , and once again well within the limits of current computers .",
    "we may therefore conclude that the first step in the two - point table strategy , the construction of the two - point tables , do not pose a serious problem neither in terms of wall - clock time nor disk space , when analyzing data sets which contain fewer than a few hundred thousand pixels .",
    "finally , we check that the amount of time spent on actually computing the correlation functions is not prohibitively large .",
    "this experiment is carried out by measuring both the initialization and the addition / multiplication time for each of the two- , three- and four - point correlation functions , for one particular configuration on each of the disks described above .",
    "the configurations were arbitrarily chosen to be the @xmath88 two - point , equilateral three - point , and rhombic four - point configurations .",
    "the results are shown in figure [ fig : comp_resources ] . in panel",
    "( a ) we see the numbers of pairs , triplets and quadruples contributing to the bin as a function of @xmath22 .",
    "note that these numbers increase almost linearly with the number of pixels in the data set , with best - fit power - law indexes of 1.15 , 1.23 and 1.34 , respectively .",
    "this is an intuitive result ; doubling the area of interest also doubles the number of polygons that fit into it . the deviation from a perfect linear relationship",
    "is caused by boundary effects .",
    "given this linear relationship , we also expect the cpu time required for multiplying and adding the pixel multiplets together to increase linearly with @xmath22 . in figure",
    "[ fig : corr_init ] we see that this is the case .",
    "it is important to note that the cpu time for computing any single bin of any @xmath0-point correlation function increases _ linearly _ with the number of pixels in the data set .",
    "it is well known that the evaluation of a general @xmath0-point correlation function scales as @xmath89 . however",
    ", this relation only applies to the computation of the full correlation function , i.e. , when including all @xmath90 pixel multiplets with all possible multiples of the bin size as lengths of the edges . in most applications ,",
    "this is found unfeasible , and one uses only a small subset of all available geometric configurations of the @xmath0 vertices . in those cases the computational scalings are less severe ; the cost for computing one single bin increases only proportionally with the number of pixels in the data set , and that time is not radically different for the two- , three- , and four - point correlation functions . only the number of different available configurations change from correlation function to correlation function , not the cost for computing one given separation bin .    in figure [ fig :",
    "corr_init ] and [ fig : corr_comp ] we see that for a data set with 50000 pixels it takes about 90 seconds to find all equilateral triangles with @xmath88 edges , and 200 seconds to find all rhombi .",
    "in general it takes about twice as long to find all quadruples as finding all triangles , an obviously logical result  quadrilaterals are constructed by merging two triangles .",
    "however , it is worth noting that this extra cost can be avoided when computing quadrilaterals constructed from isosceles triangles , since one then does not have to worry about the orientation of the triangles .",
    "as mentioned in the introduction , our methods are designed for monte carlo studies , and in figure [ fig : corr_comp ] the cpu time for analyzing 1000 realizations simultaneously is shown , excluding initialization .",
    "we see that for a 50000 pixel data set it takes about 30 seconds to estimate one two - point function bin , 150 seconds for one three - point configuration and 210 seconds for one four - point configuration . for the higher - order correlation functions",
    "these numbers are about the same as the initialization costs , and we therefore conclude that it is crucial to organize our programs so that the initialization costs are paid once only",
    ".    a typical example of an @xmath0-point correlation function analysis could be the following : we analyze 5000 monte carlo realizations on a disk containing about 50000 pixels , with 100 configurations ( distance bins ) in the two - point correlation function , 500 different configurations in the three - point correlation function , and 1000 different configurations in the four - point correlation function .",
    "we assume that the time for computing each of these configurations is constant and equal to the @xmath88 configurations . while this obviously is not strictly true ( more pixel multiplets are associated with larger configurations ) , this particular size is a good average of what is used in real - world cmb analysis .",
    "first we have to generate the two - point tables for the disk , a process which is performed only once .",
    "the total wall - clock time for this is about 3 hours , and we need about 20 gb of disk space to store the tables .",
    "next , about 1 gb of ram is required for storing the maps , and an additional few hundred mb for generating the triangles and quadrilaterals .",
    "this amount of disk space and ram is not a major obstacle for current workstations or super - computers .",
    "next , the estimation of the two - point correlation functions takes about @xmath91 , while the three - point configurations require @xmath92 . finally , the four - point configurations need @xmath93 .",
    "none of these numbers are prohibitively large , and we can therefore conclude that the proposed algorithms are able to handle real - world data sets using reasonable computational resources .",
    "we have described a set of algorithms for estimating @xmath0-point correlation functions from a pixelized map . the fundamental idea is first to locate all pixel multiplets ( pairs , triplets , quadruples etc . ) corresponding to one given geometric configuration , store these in a table , and then finally use that information to efficiently add and multiply the pixel values together .",
    "the pixel multiplets are found by searching through a set of two - point tables , motivated by ruler and compass construction of triangles .",
    "the construction of the two - point tables only take a small amount of cpu time ( typically a few hours ) , and since this operation is performed only once , it is completely negligible compared to the following operations",
    ". the storage requirements of these tables are well within the limits of current computers .",
    "we have found that the initialization cost for each configuration roughly equals the computation time of 1000 realizations , so for a monte carlo simulation with , say , 5000 realizations , the major amount of time is spent on adding pixel values together .",
    "thus , the geometric computations are removed from the problem . in other words ,",
    "our methods are probably as fast as any fully @xmath1 algorithm can ever be , when applied to a monte carlo analysis .    however , the main advantage of our method over a brute - force analysis is the fact that we estimate the correlation functions configuration - by - configuration  no cpu time is spent on uninteresting configurations .",
    "this effectively reduces the scaling of an experiment in which only a fixed number of configurations is desired ( such as only equilateral triangles , rhombic quadrilaterals , or configurations covering scales smaller than , say , @xmath94 ) to @xmath95 .",
    "thus , even large data sets may be subjected to an @xmath0-point correlation function analysis .",
    "another consequence of this configuration - wise division is optimal parallelization . by letting each processor work on separate configurations , optimal speed - up",
    "is obtained , at the cost of some extra ram requirements .",
    "hke and pbl thanks the research council of norway for economic support , including a phd studentship for hke .",
    "this work has also received support from the research council of norway ( programme for supercomputing ) through a grant of computing time .",
    "the authors acknowledge use of the healpix ( grski et al .",
    "1999 ) software and analysis package for deriving the results in this paper .",
    "barriga , j. , & gaztaaga , e. 2002 , , 333 , 443 bennett , c.  l.  et al .",
    "2003 , , 148 , 1 bernardeau .",
    "f. , van waerbeke , l. , & mellier , y. 2003 , , 397 , 405 connolly , a. j. , et al .",
    "2002 , , 579 , 42 croft , r. a. c. , dalton , g. b. , & efstathiou , g. 1999 , , 305 , 547 dalton , g. b. , croft , r. a. c. , efstathiou , g. , sutherland , w. j. , maddox , s. j. , & davis , m. 1994 , , 271 , l47 davis , m. , efstathiou , g. , frenk , c. s. , & white , s. d. m. 1985 , , 292 , 371 eriksen , h. k. , banday , a. j. , & grski , k. m. 2002 , , 395 , 409 eriksen , h. k. , hansen , f. k. , banday , a. j. , grski , k. m. , & lilje , p. b. 2004 , apj , in press ( astro - ph/0307507 ) frieman , j. a. , & gaztaaga , e. 1999 , , 521 , l83 gangui , a. , lucchin , f. , matarrese , s. , & mollerach , s. 1994 , , 430 , 447 grski , k. m. , hivon , e. , & wandelt , b. d. , 1999 , in evolution of large - scale structure : from recombination to garching , ed .",
    "j. banday , r. k. sheth , & l. n. da costa ( garching , germany : european southern observatory ) , 37 huffman , d. a. 1952 , proc .",
    "ire , 40(9 ) , 1098        maddox , s. j. , efstathiou , g. , & sutherland , w. j. 1996 , , 283 , 1227 moore , a. w. et al .",
    "2001 , in mining the sky , ed .",
    "a. j. banday , s. zaroubi , & m. bartelmann ( berlin ,",
    "heidelberg : springer - verlag ) , 71 peebles , p. j. e. , 1973 , , 185 , 413    szapudi , i. , prunet , s. , & colombi , s. 2001a , , 561 , 11 szapudi , i. , prunet , s. , pogosyan , d. , szalay , a. s. , & bond , j. r .. 2001b , , 548 , l115 takada , m. , & jain , b. 2003 , , 344 , 857 totsuji , h. , & kihara , t. 1969 , , 21 , 221"
  ],
  "abstract_text": [
    "<S> we develop , implement and test a set of algorithms for estimating @xmath0-point correlation functions from pixelized sky maps . </S>",
    "<S> these algorithms are slow , in the sense that they do not break the @xmath1 barrier , and yet , they are fast enough for efficient analysis of data sets up to several hundred thousand pixels . </S>",
    "<S> the typical application of these methods is monte carlo analysis using several thousand realizations , and therefore we organize our programs so that the initialization cost is paid only once . </S>",
    "<S> the effective cost is then reduced to a few additions per pixel multiplet ( pair , triplet etc . ) . </S>",
    "<S> further , the algorithms waste no cpu time on computing undesired geometric configurations , and , finally , the computations are naturally divided into independent parts , allowing for trivial ( i.e. , optimal ) parallelization . </S>"
  ]
}