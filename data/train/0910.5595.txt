{
  "article_text": [
    "constrained environments applications such as hardware authentication devices ( rfid , etc ) , smartcards , and wireless networks ( bluetooth , nfc , etc ) require power - efficient , area - efficient and high - performance hardware encryption systems with large security margins . until today , no adequate cryptographic solution has been proposed which satisfies the extreme limitations of devices like rfids  @xcite .",
    "even the most compact of today s encryption systems - non - linear feedback shift register ( nlfsr)-based stream ciphers - contain an order of magnitude more gates than can be dedicated for security functionality in the low - cost rfid tags  @xcite .",
    "the lack of adequate encryption mechanisms gives rise to many security and privacy problems and blocks off a variety of potential applications of rfids .",
    "motivated by these needs , in 2004 - 2008 the eu ecrypt network carried out the estream project with the objective to identify the best stream ciphers designs  @xcite .",
    "stream ciphers grain-80  @xcite , trivium  @xcite , and mickey - v2  @xcite were selected as finalists for the hardware - oriented profile .",
    "grain-80 with 1 bit / cycle throughput has the smallest hardware among all estream candidates , which makes it a particularly interesting case .",
    "grain-80 consists of one 80-bit lfsr  @xcite , one 80-bit nlfsr  @xcite , and a function combining selected state bits .",
    "the shift registers take almost 80 percent of the total area of the system and define its critical path . in this paper , we show that by transforming the shift registers of grain from their original fibonacci configuration to the galois configuration , we can significantly improve its throughput . in the fibonacci configuration of shift registers ,",
    "the feedback is applied to the first bit of the register only . in the galois configuration",
    ", the feedback can be applied to any bit .",
    "thus , the depth of the circuits implementing feedback functions of the galois configuration can potentially be smaller , leading to shorter propagation time and higher throughput .    however , unlike the lfsr case in which the mapping from the fibonacci configuration to the galois configuration is one - to - one , in the nlfsr case multiple galois nlfsrs can be equivalent to a given fibonacci one  @xcite .",
    "the problem of selecting a `` best '' galois nlfsr for a given fibonacci one is still open .",
    "one of the contributions of this paper is finding the minimal - throughput galois configurations of nlfsrs for grain-80 and grain-128  @xcite .",
    "another contribution is the introduction of the clock division block which divides the clock frequency of grain by two or four during the initialization phase .",
    "without such a block , the potential benefits of the galois configuration can not be utilized .",
    "a _ non - linear feedback shift register ( nlfsr ) _ consists of @xmath0 binary storage elements , called _ bits_. each bit @xmath1 has an associated _ state variable _ @xmath2 which represents the current value of the bit @xmath3 and a _ feedback function _",
    "@xmath4 which determines how the value of @xmath3 is updated .",
    "a _ state _ of an nlfsr is an ordered set of values of its state variables . at every clock cycle",
    ", the next state is determined from the current state by updating the values of all bits simultaneously to the values of the corresponding @xmath5 s .",
    "the _ output _ of an nlfsr is the value of its 0th bit .",
    "if for all @xmath6 the feedback functions are of type @xmath7 , we call an nlfsr the _ fibonacci _ type .",
    "otherwise , we call an nlfsr the _ galois _ type .",
    "two nlfsrs are _ equivalent _ if their sets of output sequences are equal .",
    "let @xmath5 and @xmath8 be feedback functions of bits @xmath3 and @xmath9 of an @xmath0-bit nlfsr , respectively .",
    "the operation _ shifting _ , denoted by @xmath10 , moves a set of product - terms @xmath11 from @xmath5 to @xmath8 .",
    "the index of each variable @xmath12 of each product - term in @xmath11 is changed to @xmath13 .    the _ terminal bit _",
    "@xmath14 of an @xmath0-bit nlfsr is the bit with the maximal index which satisfies the following condition : for all bits @xmath3 such that @xmath15 , @xmath5 is of type @xmath7 .",
    "[ def_unif ] an @xmath0-bit nlfsr is _ uniform _ if the following two conditions hold :    1 .",
    "all its feedback functions are _ singular _ functions of type @xmath16 where @xmath17 does not depend on @xmath18 , 2 .   for all its bits @xmath3 such",
    "that @xmath19 , the index of every variable of @xmath17 is not larger than @xmath14 .",
    "@xcite [ th_main ] given a uniform nlfsr with the terminal bit @xmath14 , a shifting @xmath20 , @xmath21 , results in an equivalent nlfsr if the transformed nlfsr is uniform as well .",
    "there are two versions of grain : 80-bit  @xcite key and 128-bit key  @xcite .",
    "both consist of an lfsr , an nlfsr , and two combining functions .    in grain-80",
    "the shift registers are 80-bits .",
    "they are both the fibonacci type , i.e. all bits except the 79th repeat the value of the previous bit .",
    "the feedback function of the 79th bit of the lfsr is given by : @xmath22 where @xmath23 is the state variable of the @xmath3th bit , @xmath24 .",
    "the feedback function of the of the 79th bit of the nlfsr is given by : @xmath25 where @xmath26 is the state variable of the @xmath3th bit , @xmath24 .",
    "the first combining function of grain-80 produces it output value based of the selected bits from the nlfsr and the lfsr : @xmath27 the second combining function of grain-80 generates the output stream of the system from the selected bits from the nlfsr and lfsr states and the output of @xmath28 : @xmath29 where @xmath30 .    for grain-128 ,",
    "the corresponding functions are : @xmath31 \\begin{array}{l } g_{127 } =   s_{0 } \\oplus b_{0 } \\oplus",
    "b_{26 } \\oplus b_{56 } \\oplus b_{91 } \\oplus b_{96}\\oplus b_{3 } b_{67 } \\oplus b_{11 } b_{13 }    \\\\",
    "\\oplus b_{17 } b_{18 } \\oplus     \\oplus b_{27 } b_{59 } \\oplus b_{40 } b_{48 }   \\oplus    b_{61 } b_{65}\\oplus    b_{68 } b_{84 } \\\\[2 mm ] \\end{array } \\\\",
    "~~h = b_{12 } s_8 \\oplus s_{13 } s_{20 } \\oplus b_{95 } s_{42 }   \\oplus s_{60 } s_{79 } \\oplus b_{12 } b_{95 } s_{95}\\\\[2 mm ] ~~z = \\sum_{k \\in a } b_{k } \\oplus s_{93 } \\oplus h % \\\\[2 mm ] \\end{array}\\ ] ] where @xmath32 .    before generating a stream of data",
    ", a cipher must be initialized with default keys . during the initializing phase",
    "the cipher does not produce any output for 160 clock cycles for grain-80 and 256 cycles for grain-128 .",
    "the output of the @xmath33 function is xor - ed with the outputs of lfsr and nlfsr and then fed into the inputs of both shift registers , as shown in figure [ fig : longest - path ] .",
    "after the initialization , the loops are opened and there is no feedback between the two shift registers .",
    "it is possible to increase the throughput of grain at the expense of extra hardware by introducing parallelism in its architecture . in parallelized versions of grain , in each clock cycle blocks of duplicated nlfsr and lfsr feedback functions produce output bits in parallel . to allow for up to 16 ( 32 ) degrees of parallelization , grain-80 ( 128 )",
    "is designed so that the bits @xmath34 ( @xmath35 ) of the shift registers are not used in the feedback functions or in the input to the combining functions .",
    "grain can be modified by transforming its lfsr and nlfsr from their original fibonacci configurations to the galois configurations .",
    "the transformation of lfsrs is done using standard techniques , in this section we only describe the transformation of nlfsrs .    the nlfsr of grain-80 ( 128 ) can be transformed to the galois configuration by shifting the product - terms of the feedback function of 79th ( 127th bit ) to the feedback functions of bits with lower indexes . by theorem  [ th_main ] ,",
    "if the nlfsr after shifting satisfies the conditions of the definition  [ def_unif ] , then it produces the same sets of output sequences as the nlfsr before shifting .    ideally , in order to maximize the throughput , we want to distribute the products equally among feedback functions .",
    "however , according to  @xcite , to guarantee equivalence of nlfsrs before and after shifting , we can not shift to bits with indexes lower that the bit @xmath14 which is given by : @xmath36 where @xmath11 is the set of all product - terms of the feedback function of the fibonacci nlfsr , and @xmath37 ( @xmath38 ) denotes the minimal ( maximal ) index of variables the product - term @xmath39 .    for grain-80 ,",
    "the product - term with the maximal difference in indexes of variables is @xmath40 , so @xmath41 . for grain-128",
    ", we have @xmath42 due to the product - term @xmath43 .",
    "however , in order to avoid modifications of the encrypting algorithm of grain , we need to guarantee not only the equivalence of the sequences of output bits , but also the equivalence of the sequences of of all internal bits of the nlfsr used by the combining functions .",
    "a modification of the encrypting algorithm could lead to undesirable changes in the grain security .",
    "for grain-80 , the bit 63 of the nlfsr is used in the function @xmath28 , and bits @xmath44 are used in the function @xmath33 .",
    "since 56 and 63 are greater than 54 , we can not use @xmath41 as the terminal bit of the galois configuration .",
    "we need to set the terminal bit to 63 .",
    "then , for all bits @xmath45 , the feedback functions will be of type @xmath46 , an the output sequences of the bits @xmath47 will be the same as the output sequence of the bit 0 shifted in time .",
    "consequently , the algorithm of grain will not change .    for grain-128 ,",
    "the bits 12 and 95 of the nlfsr are used in @xmath28 and the bits @xmath48 are used in @xmath33 .",
    "therefore , the terminal bit has to be 95 .",
    "after we have chosen the position of the terminal bit , we can start shifting products from the function @xmath49 to the functions with indexes larger or equal than the terminal bit .",
    "shifting can be done in many different ways . at present",
    "there is no systematic technique which guarantees that the transformation produces an nlfsr with the minimal throughput for a given technology .",
    "we found the solutions presented below by trying many different choices .      according to our simulation results , the following galois nlfsr results in the maximal throughput for 1bit / cycle version of grain-80 : @xmath50 here and further in this section , all omitted feedback functions are of type @xmath51 .    for grain-128 ,",
    "the maximal - throughput galois nlfsr is : @xmath52      we can extend the theory presented in  @xcite ,  @xcite to @xmath53 bits / cycle versions of grain by restricting bit positions to which the feedback can be applied .",
    "it is easy to see that , to ensure times @xmath53 degree of parallelization of an @xmath0-bit galois nlfsr with the terminal bit @xmath14 , all bits except @xmath54 should have feedback functions of type @xmath55 .",
    "so , for example , for 4 bits / cycle version of grain-80 , we can apply feedback to the bits 79,75,71 and 67 : @xmath56 for 8 bit / cycle version of grain-80 , we can apply feedback to the bits 79 and 71 : @xmath57 for 16 bit / cycle version of grain-80 , we can apply feedback only to the bit 79 , i.e. no transformations can be done .    for 4 bit / cycle version of grain-128 , we can apply feedback to the bits 127,123,119,115,111,107 103 and 99 : @xmath58 for 8 bit / cycle version of grain-128 , we can apply feedback to the bits 127,119,111,103 : @xmath59 for 16 bit / cycle version of grain-128 , we can apply feedback to the bits 127 and 111 .",
    "@xmath60 for 32 bit / cycle version of grain-128 , we can apply feed - back only to the bit 127 , i.e. no transformations can be done .      by transforming grain s shift registers to the galois configuration",
    "as described in the previous section , we can obtain up to 40 % reduction in their propagation time .",
    "however , the clock frequency of the overall grain system improves only about 10% .",
    "the problem is in the hardware architecture of grain during key initialization , during which the output value of @xmath61 is fed back to the lfsr and nlfsr making two loops , as shown in figure [ fig : longest - path ] . after the transformation from the fibonacci to the galois configuration , due to the reduction of the critical path in the nlfsr ,",
    "the critical path of the system is no longer in the nlfsr but is in the initialization loops , which are closed only during initialization .",
    "thus , the highest frequency that the system supports during initialization is lower than the highest frequency supported during key stream generation ( see table  [ table : inital freq ] ) .",
    ".clock frequencies of galois grain-80 [ cols=\"^,^,^ \" , ]     [ table : grain801 ]    to obtain a higher improvement in the throughput of grain , we introduce a clock division block to divide the frequency of the clock during the initialization phase . the clock divider is realized as a simple block containing one or two d - flipflops which divides the clock frequency of the system by 2 or 4 . in figure",
    "[ fig : double_clk4 ] we show the structure of the clock division block for division of the clock frequency by 4 . in some versions of grain ,",
    "division by 2 is sufficient to ensure correct operation during the initialization phase .",
    "division by 3 would be suitable in some cases , but it would overcomplicate the hardware for only a modest speedup of the initialization phase .",
    "the clock division block is a very small component .",
    "clock division by four gives area overhead of 25.67 ge and negligible power consumption .",
    "grain always moves from the slower to the faster clock frequency and the run signal is set internally by the counter on the positive edge of the clock . because of the delay in the production of the run signal , the first clock cycle of the key generation phase will be shortened , which could potentially lead to critical path violations in a performance - optimized design such as grain .",
    "we can handle this problem by using a flip - flop in front of the run signal which is output by the counter . in this case , if the run signal rises to 1 after a positive edge of the faster clock signal , the clock of the system changes to the faster clock in the next positive edge of the system .",
    "this solution is shown in figure [ fig : clkglitch1 ] .",
    "we have synthesized the fibonacci and the galois versions of grain using cadence rtl compiler in the tsmc 90 nm standard cell technology library .",
    "since the synthesis tool does not handle multiple clocking , we set the two initialization loops as false paths and optimized the designs for the key - generation phase .",
    "table  [ table : grain801 ] shows the results for throughput , power consumption , area , and frequency .",
    "area is measured in terms of nand2 gate equivalents ( ge ) .",
    "the total power consumption of the system is estimated as a combination of dynamic and leakage power for operation at 25 c , with a power supply of 1.2 v at 10mhz clock frequency as in  @xcite .    as we can see , the throughput for galois 1bit / cycle grain-80 and grain-128 is more than doubled compared to fibonacci .",
    "trivium is the highest ranked finalist in the estream project . in table",
    "[ table : triviumgrain ] , we compared the frequency and area of trivium ( t ) and grain-80 with galois configuration(g ) .",
    "both ciphers were implemented in tsmc 90 nm technology . due to the galois configuration ,",
    "grain-80 ( 1bit / cycle ) is faster and smaller than trivium ( 1bit / cycle ) , with a significantly better throughput / area ratio .",
    "this is an important result for applications such as rfid systems which require efficiency in both throughput and area .",
    "the throughput / area figures are compared graphically in figure  [ fig : throughput ] , where the figures for the fibonacci configuration ( grain(f ) ) of grain-80 are also reported .",
    "| c | l l | l l |    & & +    & & & & + 1 & 3.8 & 4 & 2810 & 1772 + 4 & 3.4 & 2.7 & 2955 & 2471 + 8 & 3.6 & 2.3 & 3763 & 3575 + 16 & 3.6 & 1.7 & 3841 & 5768 +    [ table : triviumgrain ]",
    "in this paper , we presented an improved version of the grain stream cipher .",
    "we found new implementations for its nlfsrs which generate the same cryptographically strong pseudo - random bit sequences as the ones of the original grain , but have a better hardware efficiency .",
    "the presented technique is general and can be applied to any nlfsr - based stream cipher .",
    "its efficiency depends on the feedback ufnction of the nlfsr and the desired degree of parallelization . for trivium",
    "the presented technique brings no improvement .",
    "e.  dubrova , m.  teslenko , and h.  tenhunen , `` on analysis and synthesis of ( n , k)-non - linear feedback shift registers , '' _ design , automation and test in europe conference and exhibition _ , vol .  0 , pp .",
    "12861291 , 2008 ."
  ],
  "abstract_text": [
    "<S> a common approach to protect confidential information is to use a stream cipher which combines plain text bits with a pseudo - random bit sequence . among the existing stream ciphers , non - linear feedback shift register ( nlfsr)-based ones provide the best trade - off between cryptographic security and hardware efficiency . in this paper , we show how to further improve the hardware efficiency of grain stream cipher . by transforming the nlfsr of grain from its original fibonacci configuration to the galois configuration and by introducing a clock division block , </S>",
    "<S> we double the throughput of the 80 and 128-bit key 1bit / cycle architectures of grain with no area penalty . </S>"
  ]
}