{
  "article_text": [
    "pushdown systems and their related decision and algorithmic analysis problems ( reachability analysis , model checking , games solving and control synthesis , etc ) have been widely investigated in the last few years @xcite .",
    "this recent intensive research effort is mainly motivated by the fact that pushdown systems are quite natural models for sequential programs with recursive procedure calls ( see e.g. , @xcite ) , and therefore they are particularly relevant for software verification and design .    higher - order pushdown systems @xcite ( hpds ) are generalizations of these models in which the elements appearing in a pushdown stack are no longer single letters but stacks themselves .",
    "we call this kind of nested stack structures _ higher - order stores_. stores of level @xmath3 are sequences of symbols in some finite alphabet ( those are standard pushdown stacks ) , and stores of level @xmath4 are sequences of stores of level @xmath5 , for any @xmath6",
    ". the operations allowed on these structures are ( 1 ) the usual @xmath7 and @xmath8 operations on the top - most level 1 store , ( 2 ) higher - order @xmath7 and @xmath8 operations allowing to _ duplicate _ or _ erase _ the top - most level @xmath9 store of any given level @xmath10 .",
    "this general model is quite powerful and has nice structural characterizations @xcite .",
    "it has been in particular proved in @xcite that hpds are equivalent to ( safe ) higher - order recursive program schemes .",
    "interestingly , it has also been proved that the monadic second - order theory of an infinite tree generated by a hpds is decidable @xcite , which generalizes the analogous result for pushdown systems proved by muller and schupp @xcite .",
    "also , it has been proved that parity games can be solved for hpds @xcite , which generalizes the result of walukiewicz for pushdown systems @xcite .",
    "these results actually show that model checking is decidable for hpds .",
    "however , they only allow to check that a property holds in a _",
    "single _ initial configuration and they do not provide a procedure for computing a representation of the set of configurations which satisfy some given property ( the satisfiability set of the property ) .    the basic step toward defining an algorithm which effectively computes the satisfiability sets of properties is to provide a procedure for computing the set of backward reachable configurations from a given set of configurations , i.e. their set of predecessors .",
    "in fact , the computation of forward- or backward - reachable sets is a fundamental problem in program analysis and in verification .    since hpds are infinite - state systems , to solve this problem we need to consider _ symbolic representation structures _ which ( 1 ) provide finite representations of potentially infinite sets of configurations , and ( 2 ) enjoy closure properties and decidability properties which are necessary for their use in verification .",
    "minimal requirements in this regard are closure under union and intersection , and decidability of the emptiness and inclusion problems .",
    "a natural class of symbolic representations for infinite - state systems is the class of finite - state automata .",
    "recently , many works ( including several papers on the so - called _ regular model - checking _ ) have shown that finite - state automata are suitably generic representation structures , which allow to uniformly handle a wide variety of systems including pushdown systems , fifo - channel systems , parameterized networks of processes , counter systems , etc . @xcite .",
    "in particular , for the class of pushdown systems , automata - based symbolic reachability analysis techniques have been developed and successfully applied in the context of program analysis @xcite .",
    "our aim in this paper is to extend this approach to a subclass of hpds called _ higher - order context - free processes _ ( hcfp for short ) .",
    "this class corresponds to the higher order extension of the well - known context - free processes ( also called bpa processes ) .",
    "hcfp can actually be seen as hpds with a single control state , similarly to level 1 cfp which are equivalent to level 1 pds with a single control state .",
    "the contributions of our paper can be summarized as follows .",
    "first , we observe that , due to the duplication operation , the set of immediate successors ( i.e. the @xmath11 image ) of a given regular set of configurations is in general _ not _ regular , but it is always a context - sensitive set .    then , we prove that , and this is our main result , for every hcfp of any level , the set of all predecessors ( i.e. the @xmath12 image ) of any given regular set of configurations is a regular set and effectively constructible . as a corollary of this result , we obtain a symbolic model checking algorithm ( an algorithm which computes the set of all configurations satisfying a formula ) for the temporal logic @xmath13 with regular atomic predicates , i.e. , the fragment of ctl with the modalities @xmath14 ( there exist path where a property eventually holds ) and @xmath2 ( there exist an immediate successor satisfying some property ) .",
    "furthermore , we extend our construction of the @xmath12 images by showing that the set of predecessors under a regular constraint ( i.e. , the set of all predecessors reachable by computations which stay in some given regular set of configurations ) is also regular and effectively constructible . for that",
    ", we use representation structures which can be seen as alternating finite - state automata .",
    "this result allows us to provide a symbolic model checking algorithm for the logic @xmath0 with regular atomic predicates , i.e. , the fragment of ctl with the operators @xmath1 ( exists until ) and @xmath2 ( exists next ) .",
    "the structure of this paper is the following . in the next two sections ,",
    "we introduce higher - order stores and the model of higher - order context - free processes .",
    "we also provide a symbolic representation for ( infinite ) _ regular _ sets of stores using a certain type of finite automata .",
    "then , for the sake of readability , we first present our algorithm for computing the unconstrained @xmath15 and @xmath12 sets of a regular set of stores ( section [ sect : sra ] ) , before extending it to the case of @xmath12 sets constrained by a regular set @xmath16 ( section [ sect : csra ] ) . due to lack of space , additional definitions and detailed proofs can be found in the full version of this paper . ] .",
    "we introduce a class of models we call _ higher - order context - free processes _ , which generalize context - free processes ( cfp ) and are a subclass of higher - order pushdown systems ( hpds ) .",
    "they manipulate data structures called _ higher - order stores_.    the set @xmath17 of _ level @xmath3 stores _ ( or _ @xmath3-stores _ ) over store alphabet @xmath18 is the set of all sequences @xmath19 \\in [ \\gamma^*]$ ] . for @xmath20 ,",
    "the set @xmath21 of _ level @xmath5 stores _ ( or _ @xmath5-stores _ ) over @xmath18 is the set of all sequences @xmath22 \\in [ { { \\mathcal{s}}_{n-1}}^+]$ ] .",
    "the following operations are defined on @xmath3-stores : @xmath23 ) & = [ w a_2 \\ldots a_l ] & \\quad & \\text {      for all } w \\in \\gamma^ * ,    \\\\    { \\mathit{top}}_1([a_1 \\ldots a_l ] ) & = a_1 .    \\\\",
    "\\intertext{we will sometimes abbreviate $ { \\mathit{push}}_1^\\varepsilon$ as      $ { \\mathit{pop}}_1$. the following operations are defined on $ n$-stores ( $ n >      1 $ ) : } { \\mathit{push}}_1^w([s_1 \\ldots s_l ] ) & = [ { \\mathit{push}}_1^w(s_1 ) \\ldots s_l ]    \\\\    { \\mathit{push}}_k([s_1 \\ldots s_l ] ) & = [ { \\mathit{push}}_k(s_1 ) \\ldots s_l ] & & \\text {      if } k \\in [ 2,n [ ,    \\\\    { \\mathit{push}}_n([s_1 \\ldots s_l ] ) & = [ s_1 s_1 \\ldots s_l ]    \\\\    { \\mathit{pop}}_k([s_1 \\ldots s_l ] ) & = [ { \\mathit{pop}}_k(s_1 ) \\ldots s_l ] & & \\text { if    } k \\in [ 2,n [ ,    \\\\    { \\mathit{pop}}_n([s_1 \\ldots s_l ] ) & = [ s_2 \\ldots s_l ] & & \\text { if } l >    1 , \\text { else undefined } ,    \\\\    { \\mathit{top}}_k([s_1 \\ldots s_l ] ) & = { \\mathit{top}}_k(s_1 ) & & \\text { if } k \\in    [ 1,n [ ,    \\\\    { \\mathit{top}}_n([s_1 \\ldots s_l ] ) & = s_1.\\end{aligned}\\ ] ] we denote by @xmath24 the set of operations consisting of : @xmath25 \\,\\ } \\cup \\{\\,{\\mathit{push}}_1^w\\ |\\",
    "w \\in \\gamma^*\\,\\}.\\ ] ] we say that operation @xmath26 is of level @xmath5 , written @xmath27 , if @xmath26 is either @xmath28 or @xmath29 , or @xmath30 if @xmath31 .",
    "we can now define the model studied in this paper .    a _ higher - order context - free process",
    "_ of level @xmath5 ( or @xmath5-hcfp ) is a pair @xmath32 , where @xmath18 is a finite alphabet and @xmath33 is a finite set of transitions .",
    "a configuration of @xmath34 is a @xmath5-store over @xmath18 .",
    "@xmath34 defines a transition relation @xmath35 between @xmath5-stores ( or @xmath36 when @xmath34 is clear from the context ) , where @xmath37    the level @xmath38 of a transition @xmath39 is simply the level of @xmath26 .",
    "let us give a few more notations concerning hcfp computations .",
    "let @xmath40 be a @xmath5-hcfp .",
    "a _ run _ of @xmath34 starting from some store @xmath41 is a sequence @xmath42 such that for all @xmath43 , @xmath44 .",
    "the reflexive and transitive closure of @xmath36 is written @xmath45 and called the _ reachability _ relation . for a given set @xmath16 of @xmath5-stores , we also define the _ constrained transition _ relation @xmath46 , and its reflexive and transitive closure @xmath47 .",
    "now for any set of @xmath5-stores @xmath48 , we consider the sets : @xmath49(s ) = \\{\\,s\\ |\\ \\exists s ' \\in s,\\ s ' \\hookrightarrow_c s    \\,\\ } ,    \\\\    { \\mathit{post}}^*_{\\mathcal{h}}[c](s ) = \\{\\,s\\ |\\ \\exists s ' \\in s,\\ s '    \\overset{*}{\\hookrightarrow}_c s \\,\\ } ,    \\\\    { \\mathit{pre}}_{\\mathcal{h}}[c](s ) = \\{\\,s\\ |\\ \\exists s ' \\in s,\\ s \\hookrightarrow_c s '    \\,\\ } ,    \\\\    { \\mathit{pre}}^*_{\\mathcal{h}}[c](s )",
    "= \\{\\,s\\ |\\ \\exists s ' \\in s,\\ s    \\overset{*}{\\hookrightarrow}_c s ' \\,\\}.\\end{aligned}\\ ] ] when @xmath16 is the set @xmath21 of all @xmath5-stores , we omit it in notations and simply write for instance @xmath50 instead of @xmath51(s)$ ] .",
    "we will also omit @xmath34 when it is clear from the context .",
    "when @xmath34 consists of a single transition @xmath52 , we may write @xmath53 instead of @xmath50 .",
    "to be able to design symbolic verification techniques over higher - order context - free processes , we need a way to finitely represent infinite sets ( or languages ) of configurations . in this section",
    "we present the sets of configurations ( i.e. sets of stores ) we consider , as well as the family of automata which recognize them .",
    "a @xmath5-store @xmath54 $ ] over @xmath18 is associated to a word @xmath55 $ ] , in which store letters in @xmath18 only appear at nesting depth @xmath5 .",
    "a set of stores over @xmath18 is called _ regular _ if its set of associated words is accepted by a finite automaton over @xmath56\\,\\}$ ] , which in this case we call a _ store automaton_. we will often make no distinction between a store @xmath57 and its associated word @xmath58 . due to the nested structure of pushdown stores",
    ", it will sometimes be more convenient to characterize sets of stores using _ nested store automata_.    a level @xmath3 nested store automaton is a finite automaton whose transitions have labels in @xmath18 . a nested store automaton of level @xmath20 is a finite automaton whose transitions are labelled by level @xmath59 nested automata over @xmath18 .",
    "the existence of a transition labelled by @xmath60 between two control states @xmath61 and @xmath62 in a finite automaton @xmath63 is written @xmath64 , or simply @xmath65 when @xmath63 is clear from the context .",
    "let @xmath66 be a level @xmath5 nested automaton with @xmath20 .",
    "the level @xmath9 language of @xmath63 for @xmath67 $ ] is defined recursively as : @xmath68\\ |\\ [ { \\mathcal{a}}_1 \\ldots    { \\mathcal{a}}_l ] \\in l_n({\\mathcal{a } } ) \\,\\ } & & \\text { if } k < n ,    \\\\    l_k({\\mathcal{a}})\\ & = \\ \\{\\ , [ { \\mathcal{a}}_1 \\ldots { \\mathcal{a}}_l ] \\ |\\ q_0\\ { \\ { \\overset{{\\mathcal{a}}_1}{\\underset{{\\mathcal{a}}}\\longrightarrow}}\\ }    \\ldots { \\ { \\overset{{\\mathcal{a}}_l}{\\underset{{\\mathcal{a}}}\\longrightarrow}}\\ } q_f\\,\\ } & & \\text { if } k = n.\\end{aligned}\\ ] ] for simplicity , we often abbreviate @xmath69 as @xmath70 .",
    "we say a nested automaton @xmath60 occurs in @xmath63 if @xmath60 labels a transition of @xmath63 , or occurs in the label of one .",
    "level @xmath5 automata are well suited to representing sets of @xmath5-stores , but have the same expressive power as standard level @xmath3 store automata .",
    "[ prop : rec ] the store languages accepted by nested store automata are the regular store languages .",
    "moreover , regular @xmath5-store languages are closed under union , intersection and complement in @xmath21 .",
    "we define for later use the set of automata @xmath71 such that for all @xmath72 and @xmath5 , @xmath73 .",
    "we also write @xmath74 the product operation over automata such that @xmath75 .",
    "our goal in this section is to investigate effective techniques to compute the sets @xmath76 , @xmath77 , @xmath78 and @xmath79 for a given @xmath5-hcfp @xmath34 , in the case where @xmath48 is a regular set of stores . for level @xmath3 pushdown systems ,",
    "it is a well - known result that both @xmath80 and @xmath81 are regular .",
    "we will see that this is still the case for @xmath76 and @xmath78 in the higher - order case , but not for @xmath77 ( hence not for @xmath79 either ) .",
    "[ prop : post ] given a @xmath5-hcfp @xmath34 and a regular set of @xmath5-stores @xmath48 , the set @xmath77 is in general not regular .",
    "this set is a context - sensitive language .",
    "let @xmath82 denote the set @xmath83 .",
    "suppose @xmath48 is a regular set of @xmath5-stores , then if @xmath84 or @xmath85 , it is not difficult to see that @xmath82 is regular . however , if @xmath86 with @xmath87 , then @xmath82 is the set @xmath88 .",
    "it can be shown using the usual pumping arguments that this set is not regular , because of the duplication of @xmath89 .",
    "however , one can straightforwardly build a linearly bounded turing machine recognizing this set .",
    "we first propose a transformation on automata which corresponds to the @xmath15 operation on their language . in a second time , we extend this construction to deal with the more difficult computation of @xmath12 sets .",
    "[ prop : pre ] given a @xmath5-hcfp @xmath34 and a regular set of @xmath5-stores @xmath48 , the set @xmath76 is regular and effectively computable .",
    "we introduce a construction which , for a given hcfp transition @xmath52 and a given regular set of @xmath5-stores @xmath48 recognized by a level @xmath5 nested automaton @xmath63 , allows us to compute a nested automaton @xmath90 recognizing the set @xmath76 of direct predecessors of @xmath48 by @xmath52 .",
    "this construction is a transformation over nested automata , which we call @xmath91 .",
    "we define @xmath92 as follows .",
    "+ if @xmath93 , we propagate the transformation to the first level @xmath59 automaton encountered along each path . we thus have @xmath94 , @xmath95 and @xmath96 if @xmath97 , we distinguish three cases according to the nature of @xmath52 :    1 .   if @xmath84 , then @xmath98 and @xmath99 .",
    "2 .   if @xmath100 and @xmath6 , then @xmath98 and + @xmath101 where @xmath102 .",
    "3 .   if @xmath103 , then @xmath98 and @xmath104 .",
    "it is not difficult to prove that @xmath105 .",
    "hence , if @xmath106 is the set of transitions of @xmath34 , then we have @xmath107 .",
    "this technique can be extended to compute the set @xmath78 of all predecessors of a regular set of stores @xmath48 .",
    "[ thm : pre - star ] given a @xmath5-hcfp @xmath34 and a regular set of @xmath5-stores @xmath48 , the set @xmath78 is regular and effectively computable .    to compute @xmath78",
    ", we have to deal with the problem of termination .",
    "a simple iteration of our previous construction will in general not terminate , as each step would add control states to the automaton . as a matter of fact , even the sequence @xmath108 , defined as @xmath109 and for all @xmath110 @xmath111 , does not reach a fix - point in general .",
    "for instance , if @xmath112 , then for all @xmath5 , @xmath113 ) = \\{\\,[a^i]\\ |\\ i \\leq",
    "n\\,\\ } \\neq { \\mathit{pre}}^{n+1}([a])$ ] .    to build @xmath78 for some regular @xmath48 , we modify the previous construction in order to keep constant the number of states in the nested automaton we manipulate .",
    "the idea , instead of creating new control states , is to add edges to the automaton until saturation , eventually creating loops to represent at once multiple applications of a hcfp transition .",
    "then , we prove that this new algorithm terminates and is correct .",
    "let us first define operation @xmath91 for any @xmath5-hcfp transition @xmath52 ( see figure [ fig : td ] for an illustration ) .",
    "let @xmath114 and @xmath115 be nested @xmath5-store automata over @xmath116\\,\\}$ ] , and @xmath52 a @xmath5-hcfp transition .",
    "we define @xmath117 as follows .",
    "+ if the level of @xmath52 is less than @xmath5 , then we simply propagate the transformation to the first level @xmath59 automaton encountered along each path : @xmath96 if @xmath97 then as previously we distinguish three cases according to @xmath52 :    1 .   if @xmath118 and @xmath84 , then @xmath119 .",
    "2 .   if @xmath100 for some @xmath6 , then + @xmath120 where @xmath102 .",
    "if @xmath103 , then @xmath121    suppose @xmath122 with @xmath123 .",
    "given an automaton @xmath63 such that @xmath124 , consider the sequence @xmath125 defined as @xmath126 and for all @xmath127 and @xmath128 , @xmath129 . in order to obtain the result , we have to prove that this sequence always reaches a fix - point ( lemma [ lem : term ] ) and this fix - point is an automaton actually recognizing @xmath78 ( lemmas [ lem : snd ] and [ lem : cmpl ] ) .",
    "[ lem : term ] for all nested @xmath5-store automaton @xmath63 and @xmath5-hcfp @xmath130 , the sequence @xmath125 defined with respect to @xmath63 eventually stabilizes : @xmath131 , which implies @xmath132 .",
    "first , notice that for all @xmath52 , @xmath91 does not change the set of control states of any automaton occurring in @xmath63 , and only adds transitions .",
    "this means @xmath125 is monotonous in the size of each @xmath133 .    to establish the termination of the conctruction",
    ", we prove that the number of transitions which can be added to @xmath134 is finite .",
    "note that by definition of @xmath91 , the number of states of each @xmath133 is constant .",
    "moreover , each new transition originates from the initial state of the automaton it is added to .",
    "hence , the total number of transitions which can be added to a given automaton is equal to @xmath135 , where @xmath136 is the level @xmath5 vocabulary and @xmath137 its set of states . since @xmath138 does not change",
    ", we only have to prove that @xmath136 is finite for all @xmath5 . if @xmath118 , @xmath139 , and the property holds .",
    "now suppose @xmath6 and the property holds up to level @xmath59 .",
    "by induction hypothesis , @xmath140 is finite . with this set of labels",
    ", one can build a finite number @xmath141 of different level @xmath59 automata which is exponential in @xmath142 , where @xmath143 depends on the number of level @xmath59 automata in @xmath134 and of their sets of control states .",
    "as each transition of a level @xmath5 automaton is labelled by a product of level @xmath59 automata , then @xmath144 is itself exponential in @xmath141 , and thus doubly exponential in @xmath145 .",
    "remark that , as a consequence , the number of steps of the construction is non - elementary in @xmath5 .",
    "[ lem : snd ] @xmath146    we prove by induction on @xmath147 the equivalent result that @xmath148 .",
    "the base case is trivial since by definition @xmath126 and @xmath149 . for the inductive step ,",
    "we consider a store @xmath57 accepted by a run in @xmath150 and reason by induction on the number @xmath151 of new level @xmath9 transitions used in this run , where @xmath9 is the level of the operation @xmath52 such that @xmath152 .",
    "the idea is to decompose each run containing @xmath151 new transitions into a first part with less than @xmath151 new transitions , one new transition , and a second part also containing less than @xmath151 new transitions .",
    "then , by induction hypothesis on @xmath151 and @xmath147 , one can re - compose a path in @xmath133 recognizing some store @xmath153 such that @xmath154 and @xmath155 .",
    "[ lem : cmpl ] @xmath156    we prove the sufficient property that for all nested store automaton @xmath63 and hcfp transition @xmath52 , @xmath157 .",
    "we consider automata @xmath63 and @xmath158 such that @xmath159 , and any pair of stores @xmath160 and @xmath161 .",
    "it suffices to isolate a run in @xmath63 recognizing @xmath57 and enumerate the possible forms of @xmath153 with respect to @xmath57 and @xmath52 to be able to exhibit a possible run in @xmath158 accepting @xmath153 , by definition of @xmath91 .",
    "this establishes the fact that @xmath91 adds to the language @xmath162 of its argument _ at least _ the set of direct predecessors of stores of @xmath162 by @xmath52 .    as a direct consequence of proposition [ prop : pre ] and theorem [ thm : pre - star ]",
    ", we obtain a symbolic model checking algorithm for the logic @xmath13 with regular store languages as atomic predicates , i.e. the fragment of the temporal logic ctl for the modal operators @xmath14 ( there exists a path where eventually a property holds ) and @xmath2 ( there exist an immediate successor satisfying a property ) .",
    "[ thm : efx ] for every hcfp @xmath34 and formula @xmath163 of @xmath13 , the set of configurations ( stores ) satisfying @xmath163 is regular and effectively computable .",
    "in this section we address the more general problem of computing a finite automaton recognizing @xmath164(s)$ ] for any hcfp @xmath165 and pair of regular store languages @xmath16 and @xmath48 .",
    "we provide an extension of the construction of proposition [ thm : pre - star ] allowing us to ensure that we only consider runs of @xmath165 whose configurations all belong to @xmath16 . again , from a given automaton @xmath63 , we construct a sequence of automata whose limit recognizes exactly @xmath164(l({\\mathcal{a}}))$ ] . the main ( and only ) difference with the previous case",
    "is that we need to compute language intersections at each iteration without invalidating our termination arguments ( i.e. without adding any new states to the original automaton ) .",
    "for this reason , we use a class of _ alternating _ automata , which we call _ constrained _ nested automata .",
    "let @xmath60 be a non - nested @xmath151-store automaton finite state automaton . ]",
    "( with @xmath166 ) . a level @xmath5 @xmath60-constrained nested automaton @xmath63 is a nested automaton @xmath167 with special transitions of the form @xmath168 where @xmath169 , @xmath170 is a control state of @xmath60 and @xmath171 is a level @xmath59 @xmath60-constrained nested automaton .    for lack of space",
    ", we are not able to provide here the complete semantics of these automata . however , the intuitive idea is quite simple .",
    "suppose @xmath63 is a @xmath60-constrained nested @xmath5-store automaton , and @xmath60 also recognizes @xmath5-stores .",
    "first , we require all the words accepted by @xmath63 to be also accepted by @xmath60 : @xmath172 .",
    "then , in any run of @xmath63 where a transition of the form @xmath173 occurs , the remaining part of the input word should be accepted both by @xmath63 when resuming from state @xmath62 and by @xmath60 when starting from state @xmath170 . of course , when expanding @xmath174 into a word of its language , it may require additional checks in @xmath60 . as a matter of fact , constrained nested automata can be transformed into equivalent level @xmath3 alternating automata . as such , the languages they accept are all regular .    constrained",
    "nested automata accept regular languages .",
    "the construction we want to provide needs to refer to whole sets of paths in a level @xmath3 store automaton recognizing the constraint language . to do this , we need to introduce a couple of additional definitions and notations .",
    "let @xmath63 be a finite store automaton over @xmath175\\,\\}$ ] .",
    "a state @xmath61 of @xmath63 is of level @xmath176 if it has no successor by @xmath177 and no predecessor by @xmath178 $ ] .",
    "it is of level @xmath9 if all its successors by @xmath177 and predecessors by @xmath178 $ ] are of level @xmath179 .",
    "the level of @xmath61 is written @xmath180 .",
    "we can show that any automaton recognizing only @xmath5-stores is equivalent to an automaton whose control states all have a well - defined level .",
    "a notion of level can also be defined for paths .",
    "a _ level @xmath5 path _ in a store automaton is a path @xmath181 with @xmath182 and @xmath183,\\ l(p_i ) < n$ ] .",
    "all such paths are labelled by @xmath5-stores .",
    "now , to concisely refer to the whole set of level @xmath5 paths between two level @xmath5 control states , we introduce the following notation .",
    "let @xmath184 be the set of all states of @xmath63 occurring on a level @xmath5 path between @xmath185 and @xmath186 .",
    "if @xmath137 is not empty , we write @xmath187 , where @xmath60 is defined as : @xmath188 thanks to these few notions , we can state our result :    [ thm : pre - starc ] given a @xmath5-hcfp @xmath34 and regular sets of @xmath5-stores @xmath48 and @xmath16 , the set @xmath189(s)$ ] is regular and effectively computable .    to address this problem , we propose a modified version of the construction of the previous section , which uses constrained nested automata .",
    "let @xmath39 be a hcfp transition rule , @xmath190 and @xmath191 two nested @xmath9-store automata constrained by a level @xmath3 @xmath5-store automaton @xmath192 accepting @xmath16 ( with @xmath193 .",
    "we define a transformation @xmath194 , which is very similar to @xmath195 , except that we need to add alternating transitions to ensure that no new store is accepted by @xmath158 unless it is the transformation of a store previously accepted by @xmath60 ( cf .",
    "figure [ fig : tdb ] ) . if @xmath196 , we propagate the transformation to the first level @xmath179 automaton along each path : @xmath197 if @xmath97 , we distinguish three cases according to the nature of @xmath52 :    1 .   if @xmath84 , then @xmath198 2 .   if @xmath86 , then for @xmath199 and @xmath200 , @xmath201 3 .   if @xmath85 , then for @xmath199 , @xmath202    suppose @xmath122 with @xmath123 . given an automaton @xmath63 such that @xmath124 ,",
    "consider the sequence @xmath125 defined as @xmath203 ( the @xmath60-constrained automaton with the same set of states and transitions as @xmath63 , whose language is @xmath204 ) and for all @xmath43 and @xmath128 , @xmath205 . by definition of @xmath206 ,",
    "the number of states in each @xmath133 does not vary , and since the number of control states of @xmath60 is finite the same termination arguments as in lemma [ lem : term ] still hold .",
    "it is then quite straightforward to extend the proofs of lemma [ lem : snd ] and lemma [ lem : cmpl ] to the constrained case .",
    "this more general construction also allows us to extend theorem [ thm : efx ] to the larger fragment @xmath0 of ctl , where formulas can now contain the modal operator @xmath1 ( there exists a path along which a first property continuously holds until a second property eventually holds ) instead of just @xmath14 .",
    "given a hcfp @xmath34 and formula @xmath163 of @xmath0 , the set of configurations ( stores ) satisfying @xmath163 is regular and effectively computable .",
    "we have provided an automata - based symbolic technique for backward reachability analysis of higher - order context - free processes .",
    "this technique can be used to check temporal properties expressed in the logic @xmath0 . in this respect ,",
    "our results provide a first step toward developing symbolic techniques for the model - checking of higher - order context - free or pushdown processes .",
    "several important questions remain open and are left for future investigation . in particular , it would be interesting to extend our approach to the more general case of higher - order pushdown systems , i.e. by taking into account a set of control states . this does not seem to be technically trivial , and naive extensions of our construction lead to procedures which are not guaranteed to terminate .    another interesting issue is to generalize our symbolic approach to more general properties than reachability and/or safety , including liveness properties .",
    "finally , it would also be very interesting to extend our symbolic techniques in order to solve games ( such as safety and parity games ) and to compute representations of the sets of all winning configurations for these games .",
    "10    p.  abdulla , a.  bouajjani , and b.  jonsson . on - the - fly analysis of systems with unbounded , lossy fifo channels . in _",
    "10th cav _ ,",
    "volume 1427 of _ lncs _ , pages 305318 , 1998 .",
    "r.  alur , k.  etessami , and p.  madhusudan . a temporal logic of nested calls and returns . in _ 10th tacas _ ,",
    "volume 2988 of _ lncs _ , pages 467481 , 2004 .",
    "b.  boigelot , p.  godefroid , b.  willems , and p.  wolper .",
    "the power of qdds . in _",
    ", volume 1302 of _ lncs _ , pages 172186 , 1997 .",
    "a.  bouajjani .",
    "languages , rewriting systems , and verification of infinite - state systems . in _",
    "28th icalp _ ,",
    "volume 2076 of _ lncs _ , pages 2439 , 2001 .",
    "a.  bouajjani , j.  esparza , and o.  maler .",
    "reachability analysis of pushdown automata : application to model - checking . in _",
    "8th concur _ , volume 1243 of _ lncs _ , pages 135150 , 1997 .",
    "a.  bouajjani , b.  jonsson , m.  nilsson , and t.  touili . regular model checking . in _",
    "12th cav _ ,",
    "volume 1855 of _ lncs _ , pages 403418 , 2000 .",
    "o.  burkart , d.  caucal , and b.  steffen .",
    "bisimulation collapse and the process taxonomy . in _",
    "7th concur _ ,",
    "volume 1119 of _ lncs _ , pages 247262 , 1996 .",
    "t.  cachat .",
    "symbolic strategy synthesis for games on pushdown graphs . in _",
    "29th icalp _ ,",
    "volume 2380 of _ lncs _ , pages 704715 , 2002 .",
    "t.  cachat .",
    "higher order pushdown automata , the caucal hierarchy of graphs and parity games . in _ 30th icalp _ ,",
    "volume 2719 of _ lncs _ , pages 556569 , 2003 .",
    "a.  carayol and s.  whrle .",
    "the caucal hierarchy of infinite graphs in terms of logic and higher - order pushdown automata . in _",
    "23rd fsttcs _ ,",
    "volume 2914 of _ lncs _ , pages 112123 , 2003 .",
    "d.  caucal . on the regular structure of prefix rewriting .",
    ", 106:6186 , 1992 .",
    "d.  caucal . on infinite terms having a decidable monadic theory . in _",
    "27th mfcs _ ,",
    "volume 2420 of _ lncs _ , pages 165176 , 2002 .",
    "j.  engelfriet . iterated pushdown automata and complexity classes . in",
    "15th stoc _ , pages 365373 , 1983 .",
    "j.  esparza .",
    "grammars as processes . in _",
    "formal and natural computing _",
    ", volume 2300 of _ lncs _ , pages 232247 , 2002 .",
    "j.  esparza , d.  hansel , p.  rossmanith , and s.  schwoon .",
    "efficient algorithm for model checking pushdown systems . in _",
    "12th cav _ ,",
    "volume 1885 of _ lncs _ , pages 232247 , 2000 .",
    "j.  esparza and j.  knoop .",
    "an automata - theoretic approach to interprocedural data - flow analysis . in _ fossacs _",
    ", volume 1578 of _ lncs _ , pages 1430 , 1999 .",
    "j.  henriksen , j.  jensen , m.  jrgensen , n.  klarlund , r.  paige , t.  rauhe , and a.  sandholm .",
    "mona : monadic second - order logic in practice . in _",
    "1st tacas _ ,",
    "volume 1019 of _ lncs _ , pages 89110 , 1995 .",
    "y.  kesten , o.  maler , m.  marcus , a.  pnueli , and e.  shahar .",
    "symbolic model checking with rich assertional languages . in _",
    "9th cav _ , volume 1254 of _ lncs _ , pages 424435 , 1997 .",
    "t.  knapik , d.  niwinski , and p.  urzyczyn .",
    "higher - order pushdown trees are easy . in _",
    "5th fossacs _ ,",
    "volume 2303 of _ lncs _ , pages 205222 , 2002 .",
    "d.  muller and p.  schupp .",
    "the theory of ends , pushdown automata , and second - order logic .",
    ", 37:5175 , 1985 .",
    "stefan schwoon . .",
    "phd thesis , technische universitt mnchen , 2002 .",
    "i.  walukiewicz .",
    "pushdown processes : games and model checking . in _",
    "8th cav _ , volume 1102 of _ lncs _ , pages 6274 , 1996 .",
    "p.  wolper and b.  boigelot . verifying systems with infinite but regular state spaces . in _",
    "10th cav _ ,",
    "volume 1427 of _ lncs _ , pages 8897 , 1998 .",
    "we will prove that given a nested store automaton @xmath207 , one can effectively compute a level @xmath3 store automaton @xmath208 such that @xmath209",
    ". we reason by induction on the level @xmath5 of @xmath63 . for @xmath210 ,",
    "the property trivially holds . for greater values of @xmath5 , consider the property as true for all levels less than @xmath5 and let @xmath211 be the level @xmath59 automata labelling the transitions of @xmath63 . by induction hypothesis , we can build level @xmath3 automata @xmath212 such that @xmath213 $ ] , @xmath214 .",
    "let @xmath215 , with all @xmath216 supposed disjoint .",
    "we now build the level @xmath3 automaton @xmath217 where for all @xmath218,\\ r , s , t , u \\in q_j$ ] and @xmath219 such that @xmath220 , @xmath221 , @xmath222 and @xmath223}{\\underset{{{\\mathcal{a}}_j\\!\\downarrow}}\\longrightarrow}}\\ } f_j$ ] , we have : @xmath224}{\\underset{{{\\mathcal{a}}\\!\\downarrow}}\\longrightarrow}}\\ } q & f &      { \\ { \\overset{]}{\\underset{{{\\mathcal{a}}\\!\\downarrow}}\\longrightarrow}}\\ } f '    \\end{aligned}\\ ] ] according to this construction , a path of @xmath208 between two control states @xmath61 and @xmath62 in @xmath225 is labelled by a word @xmath57 if and only if @xmath57 represents a @xmath226-store accepted by some @xmath227 such that @xmath220 .",
    "hence @xmath208 accepts all words of the form @xmath22 $ ] such that @xmath228 \\in l_n({\\mathcal{a}})$ ] and for all @xmath229 , @xmath230 , which is precisely the definition of @xmath70 .    before stating the converse",
    ", we need to introduce the notion of _ level _ of a level @xmath3 store automaton control state .",
    "let @xmath63 be a finite store automaton over @xmath56\\,\\}$ ] .",
    "a state @xmath61 of @xmath63 is of level @xmath176 if it has no successor by @xmath177 and no predecessor by @xmath178 $ ] .",
    "it is of level @xmath9 if all its successors by @xmath177 and predecessors by @xmath178 $ ] are of level @xmath179 .",
    "the level of @xmath61 is written @xmath180 .",
    "we also define a notion of level for paths .",
    "a _ level @xmath5 path _ in a store automaton is a path @xmath231 with @xmath182 and @xmath183,\\   l(p_i ) < n$ ] .",
    "all such paths are labelled by @xmath5-stores . finally , to concisely refer to the whole set of level @xmath5 paths between two level @xmath5 control states , we introduce the following notation .",
    "let @xmath184 be the set of all states of @xmath63 occurring on a level @xmath5 path between @xmath185 and @xmath186 .",
    "if @xmath137 is not empty , we write @xmath187 , where @xmath60 is defined as : @xmath188 using this notation , we can also very easily translate any level @xmath3 @xmath5-store automaton into a level @xmath5 nested automaton .",
    "let @xmath232 be a level @xmath3 automaton recognizing @xmath5-stores .",
    "we want to build a level @xmath5 nested automaton @xmath233 such that @xmath234 . as no path of @xmath63 labelled by a word which does not denote a correct store can be accepting , we may consider without loss of generality that the level of every state in @xmath137 is well - defined .",
    "let @xmath235 be the set of level @xmath59 states of @xmath63 .",
    "the only states of level @xmath5 are @xmath147 and @xmath236 .",
    "if @xmath118 , we build @xmath158 with a set of states @xmath237 and the following set of transitions : @xmath238}{\\underset{{\\mathcal{a}}}\\longrightarrow}}\\ } f\\,\\}.    \\end{gathered}\\ ] ] if @xmath6 , for each @xmath239 and @xmath60 such that @xmath240 , we first build inductively a nested automaton @xmath241 such that @xmath242 .",
    "we then give @xmath158 the following set of transitions : @xmath243}{\\underset{{\\mathcal{a}}}\\longrightarrow}}\\ } f\\,\\}.    \\end{gathered}\\ ] ] a store @xmath57 is accepted by @xmath158 if and only if there is a path in @xmath158 labelled by @xmath244 from @xmath245 to @xmath246 such that @xmath247 $ ] .",
    "we thus also have @xmath248 $ ] , and hence @xmath160 .        before proceeding , we have to present a few additional definitions and notations . to be able to easily express and manipulate sets of possible runs of nested automata ,",
    "we first define the notion of _ store expression_.    a store expression of level @xmath176 over alphabet @xmath18 is simply a letter in @xmath18 .",
    "a store expression of level @xmath249 is either a @xmath5-store @xmath57 , the name @xmath63 of a ( nested or not ) @xmath5-store automaton , a concatenation of level @xmath5 store expressions , a level @xmath59 store expression between square brackets @xmath250 $ ] , or the repeated concatenation @xmath251 of a level @xmath5 expression @xmath252 .",
    "let @xmath254 be a store expression where @xmath63 is a nested @xmath5-store automaton , we write @xmath255 v$ ] whenever @xmath256 . as usual , we write @xmath257 the reflexive and transitive closure of @xmath253 .",
    "a sequence of store expressions @xmath258 such that @xmath259 , @xmath260 and @xmath261,\\ e_i\\ \\longmapsto\\ e_{i+1}$ ] is called a run of @xmath63 .",
    "let @xmath262 $ ] , @xmath236 and @xmath263 be store expressions , we write @xmath264 if either @xmath265 and @xmath266 $ ] , or @xmath267 and @xmath268 $ ] . note that if @xmath252 is a letter in @xmath18 or an automaton , there are no @xmath236 and @xmath263 such that @xmath269 .    for instance",
    ", we could write @xmath270[a][bcd ] ] = a \\cdot [ [ { \\mathcal{b}}][a][bcd]]$ ] , or @xmath270[a][bcd ] ] = [ a{\\mathcal{b}}][a ] \\cdot [ [ bcd]]$ ] . before proving the soundness of the construction of proposition [ thm : pre - star ] , we need a technical lemma expressing the fact that all cycles on the initial state of a nested automaton during the computation of @xmath271 correspond to possible runs of the context - free process we consider .",
    "the following elementary lemma expresses the simple fact that if some transition @xmath272 can be applied on a certain store , then it must also be applicable to any store with the same top - most level @xmath179 store .",
    "[ lem : snd1 ] for all @xmath274 and nested @xmath9-store automaton @xmath275 occurring in @xmath133 , whenever there exist a state @xmath276 , path labels @xmath277 and @xmath278 , a transition label @xmath171 and a path @xmath279 in @xmath60 , then for all run @xmath280 \\cdot r    { \\ { \\overset{*}{\\longmapsto}}\\ } t \\cdot s\\ ] ] where @xmath170 is any store expression , @xmath281 and @xmath282 \\cdot r { \\ { \\overset{*}{\\longmapsto}}\\ } s$ ] , we necessarily have @xmath283 and @xmath284 \\cdot r { \\ { \\overset{*}{\\longmapsto}}\\ } s.\\ ] ]    let us reason by induction on @xmath147 .",
    "assume for simplicity that no transition leads to the initial state in any automaton occurring in @xmath63 .",
    "if @xmath285 , then @xmath286 and the property is trivial .",
    "now suppose the property is true up to some rank @xmath287 .",
    "call @xmath52 the level @xmath9 operation such that @xmath288 .",
    "consider the following run @xmath289 of @xmath150 : @xmath290 \\cdot r    { \\ { \\overset{*}{\\longmapsto}}\\ } t \\cdot s \\text { with } w_1 { \\ { \\overset{*}{\\longmapsto}}\\ } t.\\ ] ] as @xmath277 labels a loop on the initial state of @xmath60 , another possible run of @xmath150 is : @xmath291 \\cdot r { \\ { \\overset{*}{\\longmapsto}}\\ }    s.\\ ] ] we only need to show that @xmath292 to conclude the proof . to do this",
    ", we will reason by induction on the number @xmath151 of new level @xmath9 transitions of @xmath150 ( i.e. transitions of @xmath150 not in @xmath133 ) used in the @xmath277 cycle on @xmath293 .",
    "as @xmath277 contains no new transition , it also labels a cycle in @xmath133 .",
    "now , either transition @xmath171 belongs to @xmath133 or not .",
    "in the positive case , @xmath289 is a path in @xmath133 , hence the property is true by induction on @xmath147 . in the case where @xmath171 is a new transition , by definition of @xmath150 , @xmath133 admits the following run : @xmath294 \\cdot r      { \\ { \\overset{*}{\\longmapsto}}\\ } t \\cdot s ' \\text { with } w_1 { \\ { \\overset{*}{\\longmapsto}}\\ } t \\text { and }      [ uw_2 ] \\cdot r { \\ { \\overset{*}{\\longmapsto}}\\ } s',\\ ] ] where @xmath295 is equal to @xmath296 , @xmath297 or @xmath298 when @xmath52 is @xmath272 , @xmath299 or @xmath300 respectively . by induction on @xmath147 , this run verifies the property , hence we have @xmath301 \\cdot r { \\ { \\overset{*}{\\longmapsto}}\\ }      s ' \\text { with } t \\cdot s ' \\overset{*}{\\hookrightarrow } s'.\\ ] ] by lemma [ lem : head - off ] , this implies that @xmath302 , and in particular @xmath303 .",
    "suppose the @xmath277 cycle in @xmath60 contains @xmath304 new transitions .",
    "let @xmath305 be one of these new transitions , we have @xmath306 . hence @xmath60 has a path @xmath307 which begins with a cycle on @xmath293 labelled by @xmath308 , containing @xmath151 or less new transitions of @xmath150 . suppose @xmath309 and @xmath310 , by induction hypothesis on @xmath151 we have : @xmath311      \\cdot r { \\ { \\overset{*}{\\longmapsto}}\\ } t_2 \\cdot s\\ ] ] and @xmath312 .",
    "we now have to examine the way transition @xmath174 is created in @xmath150 , which depends on the type of @xmath52 .",
    "as previously , by definition of @xmath150 there must be a run of the form @xmath313 \\cdot      r { \\ { \\overset{*}{\\longmapsto}}\\ } t_3 \\cdot s,\\ ] ] where @xmath295 is equal to @xmath296 , @xmath314 or @xmath298 when @xmath52 is @xmath272 , @xmath315 or @xmath300 respectively .",
    "it is easy to show that @xmath316 can be chosen to be @xmath317 .",
    "this run uses a path in @xmath60 starting with a cycle on @xmath293 labelled by @xmath318 which contains @xmath151 or less new level @xmath9 transitions : @xmath319 using the induction hypothesis on @xmath151 , we can now conclude that : @xmath320",
    "\\cdot r { \\ { \\overset{*}{\\longmapsto}}\\ } s \\text { and }      t_3 \\cdot s \\in { \\mathit{pre}}^*_{\\mathcal{h}}(s).\\ ] ] we have @xmath321 , hence @xmath322 , which concludes the proof .",
    "assume for simplicity that no transition of an automaton occurring in @xmath63 leads to its initial state .",
    "we reason by induction on @xmath147 .",
    "the base case is trivial since @xmath126 and @xmath324 . now consider a store @xmath57 in @xmath325 .",
    "if @xmath57 is accepted by @xmath150 using no new transition , then it is accepted by @xmath133 . hence by induction hypothesis it belongs to @xmath80 .",
    "otherwise , the accepting run must be of the form @xmath290 \\cdot r    { \\ { \\overset{*}{\\longmapsto}}\\ } s,\\ ] ] where the path in @xmath60 which generates @xmath326 is of the form @xmath327 with @xmath276 . by lemma [ lem : snd1 ]",
    "there exist @xmath328 such that @xmath329 , @xmath330 and @xmath291 \\cdot r { \\ { \\overset{*}{\\longmapsto}}\\ }    s_1.\\ ] ] note that by definition of @xmath91 , all new transitions start from the initial states of automata in @xmath150 . hence",
    ", if the transition labelled by @xmath171 in the previous run is not new , then the whole run exists in @xmath133 . by induction hypothesis on @xmath147",
    ", there exists @xmath331 such that @xmath332 , hence by transitivity @xmath333 .",
    "+ if the transition labelled by @xmath171 is new , then since @xmath276 and by definition of @xmath91 , @xmath52 must be of the form @xmath334 or @xmath335 . then by construction of @xmath150",
    "there is a run @xmath336 \\cdot r { \\ { \\overset{*}{\\longmapsto}}\\ }    s_2,\\ ] ] where @xmath295 is either @xmath297 if @xmath87 or @xmath298 is @xmath337 , and @xmath338 can be chosen as @xmath339 .",
    "now by induction hypothesis on @xmath147 , there exists @xmath340 such that @xmath341 , hence by transitivity @xmath342 .",
    "let @xmath117 .",
    "consider a store @xmath160 , and let @xmath153 be any store such that @xmath344 .",
    "there is a run @xmath289 of @xmath63 recognizing @xmath57 as follows : @xmath345 \\cdot r    { \\ { \\overset{*}{\\longmapsto}}\\ } s.\\ ] ] depending on @xmath52 , we have to consider three cases :    1 .   if @xmath346 , then @xmath347 where @xmath89 is any store of level @xmath179 such that @xmath348 , and by definition of @xmath91 the following run exists : @xmath349 \\cdot r { \\ { \\overset{*}{\\longmapsto}}\\ }      s'.\\ ] ] 2 .   if @xmath350 , then @xmath351 and @xmath352 where @xmath348 and @xmath89 is in both @xmath353 and @xmath354 .",
    "hence @xmath89 is also accepted by the level @xmath179 automaton @xmath355 .",
    "thus , by definition of @xmath91 the following run exists : @xmath356 \\cdot r { \\ { \\overset{*}{\\longmapsto}}\\ } s'.\\ ] ] 3 .   if @xmath357 , then @xmath358 and @xmath359",
    ". this means @xmath360 are level @xmath176 automata ( i.e. letters ) , and @xmath361 . by definition of @xmath91",
    "the following run exists : @xmath362 \\cdot r { \\ { \\overset{*}{\\longmapsto}}\\ } s'.\\ ] ]        the language of a constrained nested automaton is defined _ via _ a simple adaptation of the construction of prop . [ prop : flatten ] .",
    "consider a nested automaton @xmath363 of level @xmath5 constrained with respect to a level @xmath3 @xmath5-store automaton @xmath364 .",
    "and @xmath60 have to be the same for @xmath70 to be defined . ]",
    "first , consider the ( unconstrained ) nested automaton @xmath365 , where @xmath366 .",
    "second , build according to the construction of prop .",
    "[ prop : flatten ] a level @xmath3 automaton @xmath367 with the same accepted language as @xmath158 . by adding to @xmath368 the control states of @xmath60 and integrating into it the set of constrained transitions of @xmath63 , one gets an alternating store automaton @xmath369 , where @xmath370 . by construction ,",
    "control states in @xmath371 are of the form @xmath372 where @xmath373 $ ] and each @xmath374 is a control state of a level @xmath9 automaton occurring in @xmath158 .",
    "we define @xmath375 as the union of @xmath376 and the set of all @xmath377 such that :    1 .",
    "@xmath378 , @xmath379 , @xmath380 , @xmath381 $ ] and @xmath382 where @xmath171 occurs in @xmath63 and @xmath170 is a control state of @xmath174 , 2 .",
    "@xmath383 , @xmath384 , @xmath380 , @xmath385 , and @xmath386 where @xmath171 is a level @xmath3 automaton occurring in @xmath63 , 3 .",
    "@xmath387 in all other cases .",
    "we now define the language accepted by @xmath63 as the language accepted by the alternating automaton @xmath208 we just defined , according to the usual notion of acceptance for alternating automata : @xmath388 ( please note that the initial state of @xmath208 is @xmath389 ) .",
    "for all nested @xmath5-store automaton @xmath63 , level @xmath3 @xmath5-store automaton @xmath60 and @xmath5-hcfp @xmath390 , the sequence @xmath391 defined with respect to @xmath63 and @xmath60 eventually reaches @xmath392 : @xmath393    the algorithm for computing @xmath392 is similar to the one for computing @xmath394 , except that it labels some of the transitions of each @xmath395 by a state of @xmath60 . as the number of such states remains unchanged throughout the whole computation , this does not add any unboundedness in the computation and the maximal number of iterations before reaching a fix - point is still finite .      by definition of @xmath397 , @xmath398 for all @xmath147 .",
    "so , by lemma [ lem : snd ] , we already have @xmath399 .",
    "let us reason by induction on @xmath147 . by definition of constrained nested automata , @xmath400 , hence @xmath401(s)$ ] .",
    "now assume the property is true up to some rank @xmath147 , and consider the automaton @xmath402 .",
    "note that everywhere transformation @xmath403 adds a transition in @xmath395 to get @xmath402 , the alternating transitions induced in @xmath404 ensure that each store labelling a new accepting path in the automaton is a transformation of a store labelling an accepting path in @xmath60 . this way , one makes sure that no element of @xmath16 in @xmath405(s)$ ] is added to the language of @xmath402 .",
    "for instance , assume @xmath84 and some store @xmath57 is accepted by @xmath404 using a @xmath72-transition newly created by @xmath206 . according to the definition of @xmath206 ,",
    "this transition is of the form @xmath406 , where @xmath170 is a control state reachable in @xmath60 through a path labelled by @xmath407 .",
    "thus , if we let @xmath408 , for @xmath57 to be accepted by @xmath404 , then necessarily @xmath153 must be accepted by @xmath60 from state @xmath170 .",
    "the same kind of reasoning holds for the other types of operations .      by definition , @xmath410 .",
    "now suppose the property is true up to some rank @xmath147 , and consider a store @xmath411 .",
    "let @xmath52 be the operation such that @xmath412 . by definition",
    ", there is a store @xmath413 such that @xmath414 , and by induction hypothesis @xmath153 is accepted by @xmath415 .",
    "moreover , since both @xmath57 and @xmath153 are in @xmath16 , they are accepted by @xmath60 .",
    "as seen in lemma [ lem : cmpl ] , transformation @xmath91 adds a new transition @xmath416 creating in particular a path labelled by @xmath57 .",
    "the additional constraints @xmath206 puts on this transition , and all paths in @xmath402 in general , forbids any path labelled by some @xmath170 using this transition to be accepted unless both @xmath170 and @xmath417 also have an accepting run in @xmath60 .",
    "this is the case for @xmath57 and @xmath153 , hence @xmath418 ."
  ],
  "abstract_text": [
    "<S> we consider the problem of symbolic reachability analysis of higher - order context - free processes . </S>",
    "<S> these models are generalizations of the context - free processes ( also called bpa processes ) where each process manipulates a data structure which can be seen as a nested stack of stacks . </S>",
    "<S> our main result is that , for any higher - order context - free process , the set of all predecessors of a given regular set of configurations is regular and effectively constructible . </S>",
    "<S> this result generalizes the analogous result which is known for level 1 context - free processes . </S>",
    "<S> we show that this result holds also in the case of backward reachability analysis under a regular constraint on configurations . as a corollary </S>",
    "<S> , we obtain a symbolic model checking algorithm for the temporal logic @xmath0 with regular atomic predicates , i.e. , the fragment of ctl restricted to the @xmath1 and @xmath2 modalities . </S>"
  ]
}