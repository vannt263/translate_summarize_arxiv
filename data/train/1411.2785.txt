{
  "article_text": [
    "storing and querying two - dimensional points sets is fundamental in computational geometry , geographic information systems , graphics , and many other fields .",
    "most researchers have aimed at designing data structures whose size , measured in machine words , is linear in the number of points .",
    "that is , data structures are considered small if they store a set of @xmath1 points on a @xmath2 grid in @xmath3 words of @xmath4 bits each .",
    "using @xmath5 bits is within a constant factor of optimality when the points are distributed sparsely and randomly over the grid , but we can often do better on real - word point sets because they tend to be clustered and , therefore , compressible .",
    "quadtrees  @xcite tend to have @xmath6 nodes when the points are clustered , but pointer - based quadtree data structures can still take @xmath7 bits .",
    "one way to avoid storing pointers is to store the points coordinates instead  @xcite , but that also takes @xmath7 bits .",
    "hudson  @xcite gave a structure that uses @xmath3 bits when the points are spaced appropriately and we are willing to tolerate some distortion of the points positions .",
    "recently , de bernardo et al .",
    "@xcite and venkat and mount  @xcite independently proposed similar structures based on static and dynamic succinct tree representations , respectively ( see , e.g. ,  @xcite ) .",
    "both structures use @xmath0 bits per node in the quadtree and have the same asymptotic query times as traditional structures , which support only edge - by - edge navigation .",
    "venkat and mount noted , however , that    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ `` a method for compressing paths or moving over multiple edges at once using a succinct structure may speed up the many algorithms that rely on traversal of the quadtree . ''",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    in section  [ sec : space ] we review the ideas behind quadtrees and prove a simple upper bound on the number of nodes in terms of the points clustering . in section  [ sec : structure ]",
    "we describe a quadtree data structure that uses @xmath0 bits per node in the quadtree and allows us to move over multiple edges at once . in section",
    "[ sec : membership ] we show how this lets us perform faster membership queries .",
    "finally , in section  [ sec : experiments ] we present experimental evidence that our structure is practical .",
    "we leave as future work making our structure dynamic .",
    "let @xmath8 be a set of @xmath1 points on a @xmath2 grid .",
    "if @xmath1 is 0 or @xmath9 points then the quadtree for the grid is only a root storing either 0 or 1 , respectively ; otherwise , the root stores 1 and has four children , which are the quadtrees of the grid s four quadrants . figure  [ fig : tree ] shows an example , taken from  @xcite .",
    "notice the order of the quadrants is top - left , top - right , bottom - left , bottom - right , instead of the counterclockwise order customary in mathematics .",
    "this is called the morton or z - ordering and it is useful because , assuming @xmath10 is a power of 2 and the origin is at the top right  without loss of generality , since we can manipulate the coordinate system to make it so  the obvious binary encoding of a root - to - leaf path is the interleaving of the binary representations of the corresponding point s @xmath11- and @xmath12-coordinates",
    ".     grid ( left ) ; the quadtree for those points ( right ) .",
    "the heavy lines in the quadtree indicate the path to the leaf corresponding to the shaded point on the grid.,scaledwidth=90.0% ]    for example , if we imagine the edges descending from each internal node in figure  [ fig : tree ] are labelled @xmath13 from left to right , then the thick edges are labelled @xmath14 ; the obvious binary encoding for this path is @xmath15 .",
    "the coordinates for the shaded point , which corresponds to the leaf at the end of this path , are @xmath16 , so interleaving the binary representations 1001 and _ 0110 _ of its @xmath11- and @xmath12-coordinates also gives @xmath17 .",
    "we can interleave a point s coordinates in @xmath0 time on a ram  @xcite ; this operation is also fast in practice on real machines , e.g. , using pre - computed tables .",
    "the quadtree has height at most @xmath18 and @xmath5 nodes , and a subtree rooted at depth @xmath19 encodes the points on a @xmath20 square .",
    "given a query rectangle @xmath21 , we can find all the points in @xmath22 by starting at the root and visiting all the nodes whose subtrees squares overlap @xmath21 , recording the leaves storing 1s .",
    "this is called range reporting or , in the special case @xmath23 , a membership test for @xmath24 .",
    "if we report @xmath25 points then we visit @xmath26 nodes .",
    "if the points in @xmath8 are clustered , however , then intuitively the root - to - leaf paths in the quadtree will share many nodes and we will use less space and time .    [",
    "thm : space ] suppose we can partition @xmath8 into @xmath27 clusters , not necessarily disjoint , with @xmath28 points and diameters @xmath29 .",
    "then the quadtree has @xmath30 nodes .",
    "let @xmath31 be an @xmath32 square on the grid , let @xmath33 , and let @xmath34 be the set of ancestors in the quadtree of the points in @xmath35 .",
    "( for simplicity , we identify points in @xmath8 with their corresponding leaves in the quadtree . ) let @xmath36 be the ancestors of only the corners of @xmath31 ( which may or may not be in @xmath8 ) .",
    "notice @xmath37    for any ancestor @xmath38 of a point in @xmath35 that has depth at most @xmath39 , @xmath38 s subtree contains all the points in a square of size at least @xmath40 .",
    "therefore , the square must contain at least one corner of @xmath31 , so @xmath41 .",
    "it follows that @xmath42 so @xmath43 .    the proof above is something like a two - dimensional analogue of gupta , hon , shah and vitter s  @xcite analysis of tries . in the full version of this paper",
    "we will consider higher dimensions and give bounds with respect to hierarchical clustering .",
    "the structure by de bernardo et al .",
    "@xcite mentioned in section  [ sec : introduction ] is a variation of brisaboa , ladra and navarro s  @xcite @xmath44-tree structure .",
    "brisaboa , ladra and navarro designed @xmath44-trees to compress the web graph , and de bernardo et al .  adapted it to other domains , such as geographic data .",
    "the main difference is that if @xmath8 contains all the @xmath20 points encoded by the subtree of a node at depth @xmath19 , then in de bernardo et al.s structure that subtree is only the node itself , conforming to the definition of a quadtree ; in brisaboa , ladra and navarro s structure , that subtree has height @xmath45 and @xmath46 leaves .",
    "thus , the original @xmath44-tree can have more nodes than the quadtree .    for many applications it is rare that point sets contain large squares that are completely filled .",
    "therefore , in this version of this paper we make the simplifying assumption that each internal node of the quadtree has at least one descendant storing a 0 , so both versions of the @xmath44-tree have the same number of nodes as the quadtree",
    ". we will remove this assumption in the full version .    to store a quadtree",
    ", we first replace each internal node by a binary tree of height 2 and remove any node that has no descendant storing a 1 ; this increases the size of the whole tree by a factor of at most @xmath47 .",
    "let @xmath48 be the resulting binary tree .",
    "in addition to simplifying our construction , this modification makes quadtrees more practical in higher dimensions ( see  @xcite ) , which we will also consider in the full version of this paper .",
    "we then perform a heavy - path decomposition  @xcite of @xmath48 .",
    "that is , we partition @xmath48 into root - to - leaf paths , called heavy paths , such that the path containing a node @xmath38 also contains the child of @xmath38 with the most leaf descendants ( breaking ties arbitrarily ) .",
    "one well - known property of this decomposition is that each root - to - leaf path in @xmath48 consists of @xmath49 initial segments of heavy paths .",
    "figure  [ fig : decomposition ] shows the heavy - path decomposition of the binary tree for our example from figure  [ fig : tree ] .    .",
    "nodes storing 1s are black ; nodes storing 0s are shown hollow , and discarded ; thick edges belong to heavy paths .",
    "the numbers below the black leaves indicate our ordering of the paths.,scaledwidth=90.0% ]    we encode each heavy path @xmath50 as a binary string whose 0s and 1s indicate which of @xmath50 s nodes are left children and which are right children ( considering the root as a left child , say , for simplicity ) in increasing order by their depths .",
    "we sort the encodings into decreasing order by length , breaking ties such that if two paths @xmath50 and @xmath51 have the same length and their topmost nodes are @xmath38 and @xmath52 , then the encodings of @xmath50 and @xmath51 appear in the same order as the encodings of the paths containing the parents of @xmath38 and @xmath52 .",
    "( notice @xmath38 and @xmath52 can not have the same parent , since they have the same height and the tree is binary . ) the numbers below the leaves in figure  [ fig : decomposition ] indicate how we order the paths in our example .",
    "we store the concatenation @xmath53 of the paths encodings , which consists of @xmath54 bits .",
    "we say the bit @xmath55 $ ] corresponds to the node @xmath38 if @xmath55 $ ] indicates whether @xmath38 is a left child or a right child .    for each depth @xmath56 ( considering the root to have depth 0 and leaves to have depth @xmath18 ) , we store a bitvector @xmath57 with 1s indicating which nodes at that depth in @xmath48 have two children ; see , e.g. ,  @xcite for a discussion of bitvectors .",
    "these bitvectors have as many bits as there are internal nodes in @xmath48 . for our example",
    ", @xmath58 dashes and spaces are only for legibility . storing @xmath53 and",
    "all the @xmath57s takes @xmath0 bits per node in @xmath48 and , therefore , also @xmath0 bits per node in the original quadtree . for each length",
    ", we also store the starting position in @xmath53 of the first encoding with that length ; this also takes a total of @xmath59 bits . in the full version of this paper",
    "we will give more details and discuss ways in which we can slightly reduce our space usage .",
    "suppose @xmath55 $ ] corresponds to node @xmath38 in @xmath48 .",
    "given @xmath60 , in @xmath0 time we can determine the length of the heavy path containing @xmath38 , that path s rank in our ordering , @xmath38 s depth in @xmath48 , and whether @xmath38 is the top node in its path . if @xmath38 is the top node in the @xmath61th path starting at depth @xmath19 then , by our choice of ordering , @xmath38 s parent @xmath10 is the @xmath61th node at depth @xmath62 that @xmath63 indicates has two children .",
    "it follows that we can compute in @xmath0 time which bit of @xmath53 corresponds to @xmath10 , via a select query on @xmath63 and some arithmetic .",
    "( since select queries are quite slow in practice , however , even in applications involving ascents it may be better for us simply to backtrack . ) for example , if @xmath38 is the top node in the ninth path in our ordering , which is the third path starting at depth 5 , then @xmath10 is the third node at depth 4 which @xmath64 indicates has two children . since the third 1 in @xmath64 is its fourth bit , @xmath10 is the node at depth 4 in @xmath48 in the fourth path in our ordering .",
    "once we know @xmath38 s depth @xmath19 in @xmath48 and its path s ranking in our ordering , we know immediately whether @xmath38 is a leaf and we can check @xmath57 to see whether @xmath38 has two children .",
    "if @xmath38 is the @xmath61th node at depth @xmath19 which has two children then the child of @xmath38 that is not in the same path as @xmath38 , is the top node in the @xmath61th path starting at depth @xmath65 .",
    "it follows that we can compute in @xmath0 time which bit of @xmath53 corresponds to @xmath66 , via a rank query on @xmath57 and some arithmetic ; the other child of @xmath38 corresponds to @xmath67 $ ] , and that bit tells us which child is which .",
    "reversing the example in the previous paragraph , if @xmath38 is the node at depth 4 in @xmath48 in the fourth path in our ordering , then it is the third node at depth 4 which @xmath64 indicates has two children .",
    "therefore , one of @xmath38 s children is the node at depth 5 in the same path , while @xmath38 s other child is the top node in the third path starting at depth 5 , which is the ninth path in our ordering .",
    "suppose we want to perform a membership query for @xmath24 . we compute the label on the path to @xmath24 in @xmath0 time , as described in section  [ sec : introduction ] .",
    "we set @xmath38 to be the root of @xmath48 , then repeat the following steps until we reach @xmath24 or can descend no further : we find the longest common prefix of the remainder of the path label for @xmath24 and the encoding of the heavy path starting at @xmath38 ( except that we ignore the first bit of @xmath53 , which is 0 and corresponds to the root ) , which takes @xmath0 time because the path label and the encoding are @xmath4 bits ; we descend the initial segment of the heavy path encoded by that common prefix ; if we reach @xmath24 , then we report @xmath68 ; if the node we are currently visiting has only one child , then we report @xmath69 ; otherwise , we set @xmath38 to be the child of the node we are currently visiting that is not in the same heavy path , and continue . in total , the query takes time proportional to the number of initial segments we traverse .",
    "since we only descend , we never need select queries .    to perform a membership query for @xmath16 in our example",
    ", we compute the path label 10010110 and set @xmath38 to be the root ; we find that this label does not share any non - empty prefix with the encoding of the heavy path starting at @xmath38 ( ignoring the leading 0 because @xmath38 is the root , although in this case it makes no difference ) ; and we set @xmath38 to be the root s right child .",
    "we then find that the remainder of the path label ( which is all of it ) shares a prefix of length 6 , 100101 , with the encoding of the heavy path starting at @xmath38 ; we descend to the 6th node on that path ; we set @xmath38 to be that node s right child .",
    "finally , we find the remainder of the path label , 10 , shares a prefix of length 2 , all of 10 , with the encoding of the heavy path starting at @xmath38 ; we descend to the 2nd node on that path ; and we report @xmath70 .",
    "since each root - to - leaf path in @xmath48 consists of @xmath49 initial segments of heavy paths , our data structure obviously supports membership queries in @xmath49 time .",
    "if the query point is isolated , we use even less time .",
    "[ thm : membership ] we can store @xmath8 using @xmath0 bits per node in the quadtree such that a membership query for @xmath24 takes @xmath71 time , where @xmath72 is the number of points in @xmath8 within distance @xmath73 of @xmath24 .    any node @xmath38 at depth at least @xmath74 in @xmath48 whose subtree s",
    "square contains @xmath24 , has at most @xmath72 leaf descendants .",
    "it follows that the path from @xmath38 to the deepest node @xmath66 of @xmath48 whose subtree s square contains @xmath24 , consists of @xmath75 initial segments of heavy paths . to see why ,",
    "consider that if we ascend from @xmath66 to @xmath38 , every time we move from the top - most node in one heavy path to its parent in another heavy path , the number of leaf descendants in the subtree below us at least doubles .",
    "since the path from the root to @xmath38 has length @xmath76 , the path from the root to @xmath66 consists of @xmath77 initial segments of heavy paths .",
    "we note that combining theorems  [ thm : space ] and  [ thm : membership ] suggests our structure should be particularly suited to applications in which , e.g. , points are highly clustered but queries are chosen according to a very different distribution .",
    "[ cor : combination ] suppose we can partition a set @xmath8 of @xmath1 points into @xmath27 clusters , not necessarily disjoint , with @xmath28 points and diameters @xmath29 .",
    "then we can store @xmath8 in @xmath30 bits such that a membership query for @xmath24 takes @xmath71 time , where @xmath72 is the number of points in @xmath8 within distance @xmath73 of @xmath24 .",
    "we have implemented the data structure from section  [ sec : structure ] and compared it experimentally with the @xmath44-tree . due to space constraints ,",
    "we present the results only for membership queries ; in the full paper we will present results for range reporting .",
    "all the experiments presented here were performed in an intel core i7 - 3820@3.60ghz , 32 gb ram , running ubuntu server ( kernel 3.13.0 - 35 ) .",
    "we compiled with gnu / g++ version 4.6.3 using -o3 directive .    in our implementation",
    "we make use of the bitvector implementations available in libcds ( https://github.com/fclaude/libcds ) .",
    "specifically , we use three types of bitvectors .",
    "our first variant , a heavy - path implementation with plain bitvectors , we call hp@xmath78 ; for our second variant , named hp@xmath79 , we use compressed bitmaps .",
    "libcds provides several implementations of compressed bitmaps , and we use either the raman , raman and rao ( rrr ) implementation or sadakane s sdarray ( for each dataset , we select the one achieving better compression ) .",
    "we compare these two variants with two configurations of @xmath44-trees .",
    "the first variant , named @xmath44-tree@xmath80 , consists of a basic version of the @xmath44-tree where the degree @xmath81 for all the levels of the tree .",
    "the second variant , named @xmath44-tree@xmath82 , is the configuration considered as optimal for the @xmath44-tree @xcite , which includes a hybrid approach with different @xmath25 values for the levels of the tree and a vocabulary of leaf submatrices to obtain better compression .",
    "we did not compare to venkat and mount s structure because they have not yet made an implementation available .",
    "we also did not compare to the classical quadtree representations since the @xmath44-tree is an order of magnitude smaller and has better access time  @xcite .    for our experimental evaluation we use grid datasets from different domains : geographic information systems ( gis ) , social networks ( sn ) , web graphs ( web ) and rdf datasets ( rdf ) .",
    "for gis data we use the geonames dataset , which contains more than 9 million populated places , and convert it into three grids with different resolutions : geo - sparse , geo - med , and geo - dense .",
    "( the higher the resolution , the sparser the matrix . ) for sn and web we consider the grid associated with the adjacency matrix of two web graphs ( indochina-2004 , uk-2002 ) and two social networks ( dblp-2011 , enwiki-2013 ) obtained from the laboratory for web algorithmics  @xcite .",
    "finally , we use rdf data obtained from the dbpedia dataset .",
    "this rdf dataset contains triples ( s , p , o ) indicating subjects that are related to objects with a specific predicate .",
    "thus , each predicate defines a binary relation among subjects and objects that can be represented in a grid with points .",
    "we create three different grids for our experiments , selecting predicates with different numbers of related objects ( triples - sparse , triples - med , and triples - dense ) .",
    "table [ tab : space ] gives the main characteristics of the datasets used : name of the dataset , size of the grid ( @xmath10 ) , number of points it contains ( @xmath1 ) and the space achieved by the four representations compared : @xmath44-tree@xmath80 , @xmath44-tree@xmath82 , hp@xmath78 , and hp@xmath79 .",
    "the space is measured in bits per points ( bpp ) , dividing the total space of the structure by the number of points ( @xmath1 ) in the grid .",
    "we can observe that hp@xmath83 obtains the worst compression among all the alternatives , but hp@xmath79 obtains better results than @xmath44-tree@xmath82 for some of the datasets , which is remarkable as this configuration of the @xmath44-tree exploits several compression techniques that may be considered for future extensions of this proposal and may allow the hp@xmath79 variant to reduce its space .",
    "hp@xmath79 clearly outperforms @xmath44-tree@xmath82 for very sparse grids .",
    ".description of the datasets and space comparison [ cols= \" < , < , > , > , > , > , > , > \" , ]     [ tab : space ]    we now analyze the time performance of our proposed structure .",
    "we distinguish three different types of membership queries : empty cells , filled cells and isolated filled cells ( top 100,000 most isolated filled cells ) , and measure average times per query in nanoseconds .",
    "we show in figure [ fig : times ] the results obtained by the four representations over two kinds of grid datasets , gis and sn .",
    "( due to space constraints we omit results for the web and rdf datasets . )",
    "we can observe that for both scenarios we obtain similar performance .",
    "the @xmath44-tree representation obtains better results when querying empty cells , as the computation for reaching a zero node in the @xmath44-tree is lighter than using heavy paths .",
    "however , hp becomes the best alternative when querying filled cells : our non - compressed data structure is always the fastest one for cells with values , and much faster for isolated points . in this latter case ,",
    "even the compressed variant of our structure outperforms the most optimized @xmath44-tree both in time and space .",
    "-tree variants , for the gis ( left ) and sn ( right ) datasets and each type of membership query : empty cells ( top ) , filled cells ( center ) and isolated filled cells ( bottom ) .",
    "curves for the gis datasets show results for geo - sparse , geo - med , and geo - dense ; curves for the sn datasets show results for dblp-2011 and enwiki-2013 .",
    "for example , consider the graph for the gis dataset and queries on isolated filled cells ( bottom left ) : the middle point on the curve for hp@xmath79 is to the left of and below the bend in the curve for @xmath44-tree@xmath82 ; this means that , for the geo - med dataset , the hp@xmath79 structure uses less space than the @xmath44-tree@xmath82 structure and also answers faster .",
    "( notice the query type does not affect space usages.),title=\"fig:\",scaledwidth=48.0%]-tree variants , for the gis ( left ) and sn ( right ) datasets and each type of membership query : empty cells ( top ) , filled cells ( center ) and isolated filled cells ( bottom ) .",
    "curves for the gis datasets show results for geo - sparse , geo - med , and geo - dense ; curves for the sn datasets show results for dblp-2011 and enwiki-2013 .",
    "for example , consider the graph for the gis dataset and queries on isolated filled cells ( bottom left ) : the middle point on the curve for hp@xmath79 is to the left of and below the bend in the curve for @xmath44-tree@xmath82 ; this means that , for the geo - med dataset , the hp@xmath79 structure uses less space than the @xmath44-tree@xmath82 structure and also answers faster .",
    "( notice the query type does not affect space usages.),title=\"fig:\",scaledwidth=48.0% ] -tree variants , for the gis ( left ) and sn ( right ) datasets and each type of membership query : empty cells ( top ) , filled cells ( center ) and isolated filled cells ( bottom ) .",
    "curves for the gis datasets show results for geo - sparse , geo - med , and geo - dense ; curves for the sn datasets show results for dblp-2011 and enwiki-2013 .",
    "for example , consider the graph for the gis dataset and queries on isolated filled cells ( bottom left ) : the middle point on the curve for hp@xmath79 is to the left of and below the bend in the curve for @xmath44-tree@xmath82 ; this means that , for the geo - med dataset , the hp@xmath79 structure uses less space than the @xmath44-tree@xmath82 structure and also answers faster .",
    "( notice the query type does not affect space usages.),title=\"fig:\",scaledwidth=48.0%]-tree variants , for the gis ( left ) and sn ( right ) datasets and each type of membership query : empty cells ( top ) , filled cells ( center ) and isolated filled cells ( bottom ) .",
    "curves for the gis datasets show results for geo - sparse , geo - med , and geo - dense ; curves for the sn datasets show results for dblp-2011 and enwiki-2013 .",
    "for example , consider the graph for the gis dataset and queries on isolated filled cells ( bottom left ) : the middle point on the curve for hp@xmath79 is to the left of and below the bend in the curve for @xmath44-tree@xmath82 ; this means that , for the geo - med dataset , the hp@xmath79 structure uses less space than the @xmath44-tree@xmath82 structure and also answers faster .",
    "( notice the query type does not affect space usages.),title=\"fig:\",scaledwidth=48.0% ] -tree variants , for the gis ( left ) and sn ( right ) datasets and each type of membership query : empty cells ( top ) , filled cells ( center ) and isolated filled cells ( bottom ) .",
    "curves for the gis datasets show results for geo - sparse , geo - med , and geo - dense ; curves for the sn datasets show results for dblp-2011 and enwiki-2013 .",
    "for example , consider the graph for the gis dataset and queries on isolated filled cells ( bottom left ) : the middle point on the curve for hp@xmath79 is to the left of and below the bend in the curve for @xmath44-tree@xmath82 ; this means that , for the geo - med dataset , the hp@xmath79 structure uses less space than the @xmath44-tree@xmath82 structure and also answers faster .",
    "( notice the query type does not affect space usages.),title=\"fig:\",scaledwidth=48.0%]-tree variants , for the gis ( left ) and sn ( right ) datasets and each type of membership query : empty cells ( top ) , filled cells ( center ) and isolated filled cells ( bottom ) .",
    "curves for the gis datasets show results for geo - sparse , geo - med , and geo - dense ; curves for the sn datasets show results for dblp-2011 and enwiki-2013 .",
    "for example , consider the graph for the gis dataset and queries on isolated filled cells ( bottom left ) : the middle point on the curve for hp@xmath79 is to the left of and below the bend in the curve for @xmath44-tree@xmath82 ; this means that , for the geo - med dataset , the hp@xmath79 structure uses less space than the @xmath44-tree@xmath82 structure and also answers faster .",
    "( notice the query type does not affect space usages.),title=\"fig:\",scaledwidth=48.0% ]",
    "we have presented a fast space - efficient representation of quadtrees , answering in the affirmative to the conjecture of venkat and mount  @xcite .",
    "our structure has nice theoretical bounds and it is practical .",
    "space requirements are similar to other space - efficient representations of quadtrees , e.g. , the @xmath44-trees , but our structure is faster handling isolated filled cells . in the full version of this paper",
    "we will generalize our structure to higher dimensions , give bounds in terms of hierarchical clustering and present experimental results for range reporting .",
    "many thanks to timothy chan and yakov nekrich for directing us toward venkat and mount s paper .",
    "the first author is also grateful to the late ken sevcik for introducing him to some concepts used in this paper .",
    "d.  arroyuelo , r.  cnovas , g.  navarro , and k.  sadakane .",
    "succinct trees in practice . in _ proc .",
    "alenex _ , pages 8497 , 2010 .",
    "+ n.  bereczky , a.  duch , k.  nmeth , and s.  roura .",
    "quad - k - d trees . in _ proc .",
    "latin _ , pages 743754 , 2014 .",
    "+ p.  boldi , m.  rosa , m.  santini , and s.  vigna .",
    "layered label propagation : a multiresolution coordinate - free ordering for compressing social networks . in _ proc .",
    "www _ , pages 587596 , 2011 .",
    "+ p.  boldi and s.  vigna .",
    "the webgraph framework i : compression techniques . in _ proc .",
    "www _ , pages 595601 , 2004 .",
    "+ n.  r.  brisaboa , s.  ladra , and g.  navarro . compact representation of web graphs with extended functionality . , 39:152174 , 2014 .",
    "+ p.  davoodi and s.  s. rao .",
    "succinct dynamic cardinal trees with constant time operations for small alphabet . in _ proc .",
    "tamc _ , pages 195205 , 2011 .",
    "+ g.  de  bernardo , s.  lvarez - garca , n.  r. brisaboa , g.  navarro , and o.  pedreira .",
    "compact querieable representations of raster data . in _ proc .  spire _ , pages 96108 , 2013 . + f.  e. fich .",
    "constant time operations for words of length w. 1999 . + i.  gargantini .",
    "an effective way to represent quadtrees .",
    "25:905910 , 1982 . + a.  gupta , w .- k .",
    "hon , r.  shah , and j.  s. vitter .",
    "compressed data structures : dictionaries and data - aware measures .",
    ", 387:313331 , 2007 .",
    "+ b.  hudson .",
    "succinct representation of well - spaced point clouds .",
    "technical report abs/0909.3137 , corr , 2009 .",
    "+ g.  m. morton . a computer oriented geodetic data base ; and a new technique in file sequencing .",
    "technical report , ibm ltd .",
    "+ g.  navarro and k.  sadakane .",
    "fully functional static and dynamic succinct trees . , 10:16 , 2014 .",
    "+ m.  ptracu . succincter . in _ proc .",
    "focs _ , pages 305313 , 2008 .",
    "+ d.  d. sleator and r.  e. tarjan . a data structure for dynamic trees .",
    ", 26:362391 , 1983 .",
    "+ p.  venkat and d.  m.  mount .",
    "a succinct , dynamic data structure for proximity queries on point sets . in _ proc .",
    "cccg _ , 2014 .",
    "to appear ."
  ],
  "abstract_text": [
    "<S> real - world point sets tend to be clustered , so using a machine word for each point is wasteful . in this paper </S>",
    "<S> we first bound the number of nodes in the quadtree for a point set in terms of the points clustering . </S>",
    "<S> we then describe a quadtree data structure that uses @xmath0 bits per node and supports faster queries than previous structures with this property . </S>",
    "<S> finally , we present experimental evidence that our structure is practical . </S>"
  ]
}