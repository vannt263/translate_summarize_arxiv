{
  "article_text": [
    "monomial ideals provide ubiquitous links between combinatorics and commutative algebra @xcite . though simple they carry plentiful algebraic and geometric information of general ideals .",
    "our interest in monomial ideals is motivated by a paper of @xcite , where they studied the connection between the structure of monomial basis and the geometric structure of the solution sets of zero - dimensional polynomial ideals .",
    "irreducible decomposition of monomial ideals is a basic computational problem and it finds applications in several areas , ranging from pure mathematics to computational biology , see for example @xcite for computing integer programming gaps , @xcite for computing tropical convex hulls , @xcite for finding the joins and secant varieties of monomial ideals , @xcite for partition of a simplicial complex , @xcite for solving the frobenius problem , and @xcite for modeling gene networks .",
    "we are interested in efficient algorithms for computing irreducible decomposition of monomial ideals .",
    "there are a variety of algorithms available in the literature .",
    "the so - called splitting algorithm : algorithm 3.1.2 in @xcite is not efficient on large scale monomial ideals .",
    "@xcite gives two algorithms : one is based on alexander duality @xcite , and the other is based on scarf complex @xcite .",
    "@xcite improves the scarf complex method by a factor of up to more than 1000 .",
    "recently , @xcite proposed several slicing algorithms based on various strategies .",
    "our goals in this paper are to study the structure of monomial ideals and present two new algorithms for irreducible decomposition .",
    "we first observe some staircase structural properties of monomial bases in section [ structure ] .",
    "the recursive algorithm presented in section [ recursive ] is based on these properties , which allow decomposition of monomial ideals recursively from lower to higher dimensions .",
    "this algorithm was presented as posters in issac 2005 and in the workshop on algorithms in algebraic geometry at i m a in 2006 .",
    "our algorithm was recently generalized by @xcite where several cutting strategies were developed and our algorithm corresponds to the minimum strategy there . also , the computational experiments there shows that our algorithm has good performance for most cases , especially for highly non - generic monomial ideals .",
    "our second algorithm is presented in section [ distrbn ] .",
    "it can be viewed as an improved alexander dual method ( @xcite ) .",
    "it is incremental based on some distribution rules for @xmath4  and @xmath5  operations of monomial ideals .",
    "we maintain an output list of irreducible components , and at each step we add one generator and update the output list . in @xcite , there is no specific criterion for selecting candidates that need to be updated , and the updating process is inefficient too .",
    "our algorithm avoids these two deficiencies .",
    "our analysis in section [ conclusion ] shows that the second algorithm works more efficiently than the first algorithm for generic monomial ideals .",
    "we prove that , for generic monomial ideals , the intermediate storage size ( ie .",
    "number of irreducible components at each stage ) is always bounded by the final output size , provided that the generators are added in lex order .",
    "this enables us to show that the time complexity of the second algorithm is at most @xmath6 where @xmath1 is the number of variables , @xmath2 is the number of minimal generators and @xmath3 is the number of irreducible components .    in section [ prelim ] , we present some notations and introductory materials on monomial ideals . in section [ treer ]",
    "we discuss tree representations and operations of monomial ideals .",
    "we refer the reader to the books of @xcite for background in algebraic geometry and commutative algebra , and to the monograph @xcite for monomial ideals and their combinatorial properties .",
    "let @xmath7 be a field and @xmath8 $ ] , the polynomial ring over @xmath7 in @xmath1 indeterminates @xmath9 . for a vector @xmath10 , where @xmath11 denotes the set of nonnegative integers , we set @xmath12 which is called a * monomial*. thus monomials in @xmath1 variables are in @xmath13 correspondence with vectors in @xmath14 .",
    "suppose @xmath15 and @xmath16 are two vectors in @xmath14 , we say @xmath17 this defines a partial order on @xmath14 , which corresponds to division order for monomials since @xmath18 if and only if @xmath19 .",
    "we say @xmath20 also we define @xmath21 then @xmath22 means that @xmath23 for at least one @xmath24 .",
    "an ideal @xmath25 $ ] is called a * monomial ideal * if it is generated by monomials .",
    "dickson s lemma states that every monomial ideal in @xmath8 $ ] has a unique minimal set of monomial generators , and this set is finite .",
    "denote this set to be @xmath26 , that is , @xmath27    a monomial ideal @xmath28 is called * artinian * if @xmath28 contains a power of each variable , or equivalently , if the quotient ring @xmath8/i$ ] has finite dimension as vector space over @xmath7 . for convenience of notations , we define @xmath29 by adding infinity power of variables if necessary , a non - artinian monomial ideal can be treated like an artinian monomial ideal . for example , @xmath30 . instead of adding infinity powers , we can also add powers @xmath31 where @xmath32 is a sufficiently large integer , say larger than the largest degree of @xmath33 in all the monomials in @xmath26 .",
    "then the irreducible components of the original ideal are in 1 - 1 correspondence to those of the modified artinian ideal ; see exercise 5.8 in @xcite or proposition 3 in @xcite . in our algorithms belows",
    ", we will use infinity powers , but in the proofs of all the results , we will use powers @xmath31 .",
    "an ideal @xmath34 $ ] is called * irreducible * if it can not be expressed as the intersection of two strictly larger ideals in @xmath8 $ ] .",
    "that is , @xmath35 implies that @xmath36 or @xmath37 .",
    "a monomial ideal @xmath28 is irreducible if and only if @xmath28 is of the form @xmath38 for some vector @xmath39 where @xmath40 .",
    "thus irreducible monomial ideals are in 1 - 1 correspondence with @xmath41 .",
    "an * irreducible decomposition * of a monomial ideal @xmath28 is an expression of the form @xmath42 where @xmath43 .",
    "since the polynomial ring @xmath8 $ ] is noetherian , every ideal can be written as irredundant intersection of irreducible ideals . such an intersection is not unique for a general ideal , but unique for a monomial ideal .",
    "we say that the irreducible decomposition ( [ eqn1.1 ] ) is * irredundant * if none of the components can be dropped from the right hand side . if ( [ eqn1.1 ] ) is irredundant , then the ideals @xmath44 are called * irreducible components * of @xmath28 .",
    "we denote by @xmath45 the set of exponents of irreducible components of @xmath28 , that is , @xmath46 by this notation , we have @xmath47    note that , for two vectors @xmath48 and @xmath49 , @xmath50 and @xmath51    a monomial ideal @xmath28 is called * generic * if no variable @xmath33 appears with the same non - zero exponent in two distinct minimal generators of @xmath28 .",
    "this definition comes from @xcite .",
    "for example , @xmath52 is generic , but @xmath53 is non - generic , as @xmath54 appears in two generators . loosely speaking",
    ", we can say @xmath55 is nearly generic , but @xmath56 is highly non - generic .",
    "previous algorithms @xcite behave very different for generic monomial ideals and highly non - generic monomial ideals .",
    "for example , the scarf complex method works more efficient when dealing with generic monomial ideals @xcite .    in the following sections",
    ", we always assume that we are given the minimal generating set of a monomial ideal .",
    "though our algorithms work for monomial ideals given by an arbitrary set of generators , it will be more efficient if the generators are made minimal first . +",
    "note that monomials are represented by vectors in @xmath14 and irreducible components are represented by vectors in @xmath57 . to efficiently represent a collect of vectors , we use a tree structure .",
    "this is used in @xcite .",
    "this data structure is also widely used in computer science , where it is called a trie . + * tree representation . *",
    "first we want to define the orderings on @xmath14 or @xmath57 .",
    "suppose @xmath15 and @xmath16 are two vectors in @xmath14 or @xmath57 , and the variable ordering is @xmath58 in @xmath8 $ ] .",
    "we say @xmath59 if @xmath60 for @xmath61 , but @xmath62 for some @xmath63 .",
    "next , suppose @xmath64 is a set of vectors corresponding to the generators of a monomial ideal @xmath25 $ ] .",
    "we represent @xmath65 as a rooted tree @xmath66 of height @xmath1 in a natural way .",
    "the tree should have @xmath67 leaves and the unique path of the tree from the root to a leaf represents a vector in @xmath65 .",
    "precisely , to represent a vector @xmath68 , we label all the nodes except the root of the path simply by @xmath69 in the order from the root to the leaf .",
    "we regard the root as being at height @xmath70 . for two vectors @xmath68 and @xmath71 , if @xmath60 for @xmath61 but @xmath72 , then @xmath48 and @xmath49 share their corresponding path until height @xmath73 . after that their children are listed in increasing order with respect to their coordinates .",
    "figure [ tree ] is the tree representation for @xmath74 with variable order @xmath75 .",
    "@xmath76[390,813]{tree.ps}\\ ] ]    the tree representation for a set of irreducible components could be constructed in a similar manner .    to perform the operations on sets of vectors ,",
    "we need only perform on trees .",
    "we need three basic tree operations : @xmath77 and @xmath78 . + * merge . *",
    "given @xmath79 rooted trees @xmath80 with the same height , merge them to form one rooted tree with the same height .",
    "here we simply put the paths from all the trees together with repetition ignored ( actually no repeated paths occur in our algorithms ) .",
    "we stress that no reduction work is performed under this operation . + * minmerge .",
    "* we use @xmath81 to represent the set of minimal elements in @xmath82 . for two vectors @xmath83 in @xmath82 , if @xmath19 , ie . @xmath18 , then the path for @xmath49 should be removed in this operation .",
    "the purpose is to find the minimal generating set for the ideal @xmath84 where @xmath85 is the tree representation for @xmath86 . +",
    "* maxmerge . *",
    "similarly , the set of maximal elements in @xmath87 is represented by @xmath88 . if @xmath19 , ie .",
    "@xmath89 , then the path for @xmath48 should be removed in this operation .",
    "hence , if @xmath85 represents the set of irreducible components of @xmath86 , @xmath90 , then @xmath88 represents the the set of irreducible components of the ideal @xmath91 .",
    "in the results and their proofs below , we explicitly assume that all the ideals are artinian , adding large powers @xmath92 if necessary where @xmath93 is an integer , though infinity powers will be used in the algorithms and examples .",
    "the monomial basis @xmath94 for a monomial ideal @xmath28 is defined as @xmath95 which form a linear basis for the quotient ring @xmath8/i$ ] over @xmath7 .",
    "thus , for @xmath96 , @xmath97 if and only if @xmath98 for every @xmath99 . note that @xmath94 is a @xmath100-set , that is , if @xmath101 and @xmath102 , then @xmath103 .",
    "the next lemma characterizes @xmath104 in terms of @xmath105 .",
    "[ bi ] for @xmath106 , @xmath97 if and only if @xmath107 for some @xmath108 .    since @xmath109",
    ", we have @xmath110 if and only if @xmath111 , ie . , @xmath112 , for each @xmath108 .",
    "hence @xmath113 if and only if @xmath107 for some @xmath108 , as desired .",
    "we now want to express @xmath105 in terms of @xmath94 . since @xmath28 is artinian , for @xmath114 , we have @xmath115 for @xmath116 .",
    "define @xmath117 lemma [ bi ] implies that , for each @xmath118 , we have @xmath119 .    a vector @xmath96 is called _ maximal _ in @xmath94 if @xmath120    [ irri ] for any vector @xmath121 , @xmath118 if and only if @xmath122 is maximal in @xmath94 .    by lemma [ bi ] ,",
    "@xmath123 if and only if there is @xmath124 such that @xmath125 .",
    "notice that @xmath126 and @xmath127 is equivalent to say @xmath128 .",
    "hence @xmath122 is maximal in @xmath104 if and only if @xmath129 , that is , @xmath130 .    @xmath131{\\includegraphics*[210,633][400,813]{staircase.ps}}\\ ] ]    the staircase diagram will help us visualize the structural properties of monomial ideals .",
    "for example , figure [ irr ] is the staircase diagram for the monomial ideal @xmath132 . in this figure",
    "the gray points are in 1 - 1 correspondence with the minimal generators , while the white points are in 1 - 1 correspondence with the irreducible components of @xmath28 .",
    "geometrically , @xmath94 is exactly the set of interior integral points of the solid .",
    "for bivariate monomial ideals , irreducible decomposition is simple @xcite .",
    "suppose @xmath133 where @xmath134 , @xmath135 , and @xmath136 or @xmath137 can be infinity . then the irreducible decomposition of @xmath28 is @xmath138    our recursive algorithm is a generalization of the above observation to higher dimensions .",
    "let @xmath139 $ ] be a monomial ideal .",
    "suppose all the distinct degrees of @xmath140 in @xmath26 are @xmath141 for example , in @xmath142 , the distinct degrees in @xmath143 are @xmath144 and @xmath145 .",
    "we collect the coefficients of @xmath146 as polynomials in @xmath147 .",
    "precisely , for @xmath148 , let @xmath149.\\ ] ] then @xmath150 by ( [ ichn ] ) , it follows that @xmath151 for the example with @xmath152 , @xmath153 , @xmath154 , and @xmath155 $ ] .",
    "we show how to read off the irreducible components of @xmath28 from those of @xmath156 s , which have one less variables . for any vector @xmath157 and @xmath158 , define @xmath159    [ d ] for any @xmath160 and @xmath161 , @xmath162 if and only if there exists @xmath163 , where @xmath164 , such that @xmath165 and @xmath166 .",
    "@xmath162 if and only if there is no @xmath167 such that @xmath168 . as @xmath169 , we only need to see that there is no @xmath167 with @xmath170 . but",
    "this is equivalent to requiring that @xmath166 .    for a set of vectors @xmath171 and an integer @xmath172 , define @xmath173    [ rec ] @xmath174 , which is a disjoint union",
    "assume @xmath175 .",
    "we first show that @xmath176 and @xmath177 . since @xmath178",
    ", we have @xmath179 , so @xmath180 by lemma [ d ] .",
    "also , by lemma [ irri ] , there is no @xmath181 such that @xmath182 , in particular no @xmath183 such that @xmath184 , as @xmath185 .",
    "thus @xmath186 , otherwise we would have @xmath187 which contradicts the assumption on @xmath188 .    for @xmath189",
    ", we need to prove that @xmath190 is maximal in @xmath104 .",
    "assume otherwise , say @xmath191 and @xmath192",
    ". then @xmath193 or @xmath194 .",
    "if @xmath193 , then @xmath195 where @xmath196 by lemma [ d ] . since @xmath197 and @xmath198 is a @xmath100-set , @xmath195 implies @xmath199 too , a contradiction . if @xmath194 , then @xmath200 .",
    "note that @xmath201 implies @xmath181 by lemma [ d ] .",
    "however , @xmath202 so there is no @xmath181 such that @xmath200 , a contradiction .",
    "hence such @xmath203 does not exist .",
    "consequently , @xmath189 .",
    "conversely , assume @xmath204 , we need to prove that there exist some @xmath205 such that @xmath206 and @xmath175 . by lemma [ irri ]",
    ", @xmath204 implies @xmath207 and there is no @xmath208 such that @xmath209 by lemma [ d ] , ( [ a ] ) implies there exists @xmath163 such that @xmath210 , and @xmath211 by lemma [ d ] again , @xmath212 . then ( [ b ] ) and ( [ c ] ) imply that @xmath206 .",
    "( [ b ] ) and ( [ c ] ) also imply that there is no @xmath213 such that @xmath214 and @xmath200 , so @xmath178 .",
    "it remains to prove @xmath215 .",
    ". then @xmath216 . by lemma [ d ] , @xmath217 and @xmath218 , contradicting to @xmath189 .",
    "thus @xmath175 .",
    "theorem [ rec ] gives us the following recursive algorithm for finding irreducible decomposition of monomial ideals .",
    "suppose we are given @xmath219 and fixed variable order @xmath220 .",
    "we encode the set @xmath221 as a tree @xmath66 of height @xmath1 .",
    "our algorithm @xmath222 takes @xmath66 as input and produce @xmath105 as output .",
    "that is , @xmath223 .    * recursive algorithm * : @xmath222    = kk = xxx = input : @xmath66 , a tree encoding @xmath26 + output : @xmath65 , a set ( or a tree ) representing @xmath105 + step 1 .",
    "start at the root of @xmath66 .",
    "if the height of @xmath66 is @xmath224 , then @xmath66 consists of a few leaves ; + let @xmath172 be the largest label on these leaves and let @xmath225 .",
    "+ return @xmath65 ( and stop the algorithm ) .",
    "now assume @xmath66 has height at least two .",
    "set @xmath226 .",
    "suppose @xmath227 are the labels of the children under the root of @xmath66 , + and let @xmath228 be the subtree extending from @xmath229 , @xmath148 .",
    "+ note that the root of @xmath228 is the node labeled by @xmath229 , but now unlabeled .",
    "+ find @xmath230 by recursive call of this algorithm .",
    "+ for @xmath163 from 1 to @xmath231 do + 3.1 .",
    "find @xmath232 , and delete @xmath233 .",
    "find @xmath234 by recursive call of this algorithm .",
    "find @xmath235 , delete @xmath236 , and @xmath237 .",
    "return ( @xmath65 ) .",
    "+    [ 3var ] we end this section by demonstrating how the algorithm is used to decompose the ideal @xmath238 first represent the monomials as a tree with variable order @xmath75 , where @xmath228 s are the subtrees extending from the node with label @xmath229 , @xmath239 .",
    "@xmath240[565,814]{step1.ps}\\ ] ]    @xmath241[565,814]{step22.ps}\\ ] ]    @xmath242[565,814]{step3.ps}\\ ] ]    figure [ step2]-[step3 ] show the process of finding the irredundant irreducible decomposition of @xmath28 . for each @xmath228 , inductively minmerge the subtrees from left to right , corresponding to step 3.1 in the recursive algorithm .",
    "see figure [ step2 ] . in figure [ step3 ]",
    "we call the procedure @xmath243 for each @xmath228 to compute @xmath244 , corresponding to step 3.2 .",
    "since the height of @xmath228 is 2 , we bind each leaf that is not in the most - right side of @xmath228 with the node of height 2 on the next path - just do the shifting in adjacent paths , see figure [ step3 ] .",
    "finally we find the paths in @xmath245 that are not in @xmath246 .",
    "the one with a mark @xmath247 in @xmath246 is discarded .",
    "then bind the resulting paths with @xmath229 .",
    "the irreducible components can be read from the last figure : @xmath248",
    "in this section we shall present an incremental algorithm based on the idea of adding one generator at a time .",
    "this algorithm can be viewed as an improvement of alexander dual method ( @xcite ) .",
    "we maintain an output list of irreducible components , and at each step we use a new generator to update the output list . in @xcite , it is not clear how to select good candidates that need to be updated , and the updating process there is also inefficient .",
    "our algorithm avoids these two deficiencies .",
    "we establish some rules that help us to exclude many unnecessary comparisons .",
    "monomial ideal are much simpler than general ideals .",
    "the next theorem tells us that monomial ideals satisfy distribution rules for the operations @xmath4  and @xmath5 .",
    "these rules may not be true for general ideals .",
    "[ distr ] let @xmath249 be any monomial ideals in @xmath8 $ ]",
    ". then    1 .",
    "@xmath250 , 2 .",
    "@xmath251 .    by induction , we just need to prove the case for @xmath252 .",
    "note that ( b ) follows form ( a ) , as @xmath253 to prove ( a ) for the case @xmath252 , suppose @xmath254 is a generator for @xmath255",
    ". then @xmath254 must be in @xmath256 and @xmath257 . since @xmath258 is also a monomial ideal",
    ", @xmath254 is a monomial .",
    "the fact that @xmath259 implies that @xmath254 is in either @xmath260 or @xmath261 .",
    "hence @xmath254 is in @xmath262 or in @xmath263 , so @xmath264 .",
    "going backward yields the proof for the other direction .",
    "theorem [ distr ] gives us an incremental algorithm for irreducible decomposition of monomial ideals .",
    "precisely , we have the following situation at each incremental step : given the irreducible decomposition @xmath105 of an arbitrary ideal @xmath28 and a new monomial @xmath265 where @xmath266 , we want to decompose @xmath267 . by the distribution rule ( b ) , @xmath268 we need to see how to decompose each ideal on the right hand side of ( [ whole ] ) and how to get rid of redundant components .",
    "we partition @xmath105 into two disjoint sets : @xmath269 note that if @xmath270 then @xmath271 .",
    "for each @xmath272 , we have @xmath273 , thus @xmath274 for each @xmath275 , we have @xmath276 . in this case , we split @xmath277 as @xmath278 by the distribution rule ( b ) , we have @xmath279 define @xmath280 since @xmath281 , we have @xmath282 for all @xmath283",
    ". hence @xmath284 , and @xmath285 therefore , @xmath286    it remains to see which of the components in the right hand side of the above expression belong to @xmath287 , so others are redundant .",
    "[ case1 ] @xmath288 .",
    "let @xmath289 . by equation ( [ wti ] ) if @xmath290 , then there exists some @xmath291 such that @xmath292 is maxmergeed by @xmath293 for some @xmath24 , ie .",
    "@xmath294 . since @xmath295",
    ", @xmath296 implies that @xmath297 , which contradicts with the fact that @xmath298 .",
    "hence @xmath299 as claimed .",
    "lemma [ case1 ] shows that the elements in @xmath300 will be automatically in @xmath287 .",
    "now we turn to the components @xmath301 . for @xmath302 , define @xmath303 for @xmath304 , if @xmath305 , then we say @xmath306 _ matches _ @xmath49 in @xmath307 .",
    "it is possible that one monomial matches @xmath49 in multiple variables .",
    "for example , with @xmath308 and @xmath309 , the monomial @xmath310 matches @xmath49 in @xmath311 and @xmath143 .",
    "we say @xmath306 matches @xmath49 only in @xmath307 if @xmath305 and @xmath312 for all @xmath313 .",
    "[ only ] for each @xmath314 and each @xmath315 , there exists @xmath304 such that @xmath306 matches @xmath49 only in @xmath307 .",
    "note that a vector @xmath101 is maximal if and only if @xmath316 for every @xmath317 .",
    "since @xmath108 , @xmath122 is maximal in @xmath104 .",
    "thus , for each @xmath318 , @xmath319 , so there exists a monomial say @xmath320 such that @xmath321 .",
    "then @xmath312 for @xmath322 .",
    "if @xmath323 as well , then @xmath324 , which implies that @xmath325 , a contradiction .",
    "therefore @xmath305 .",
    "note that @xmath326 , so @xmath304 .    for any set of monomials",
    "@xmath327 $ ] , define @xmath328 be the exponent @xmath213 such that @xmath329 .",
    "@xmath330 .    by the definition of @xmath331 , we know that @xmath332 . by lemma",
    "[ only ] we have @xmath333 .",
    "thus @xmath330 .    for @xmath334 ,",
    "let @xmath335 note that @xmath336 .",
    "define @xmath337    [ du ] for each @xmath302 and @xmath318 , @xmath338 if and only if @xmath339 .",
    "suppose @xmath339 .",
    "we want to prove that @xmath338 . by lemma [ irri ] , this is equivalent to proving that @xmath340 and is maximal .",
    "assume @xmath341 .",
    "then there exists @xmath342 such that @xmath343 .",
    "first note that @xmath344 because @xmath345 can not divide @xmath346 .",
    "thus @xmath320 , which implies @xmath347 .",
    "since @xmath348 , we have @xmath349 , contradicting to @xmath118 .",
    "hence @xmath350 .",
    "we next need to prove that @xmath351 is maximal in @xmath352 , that is , @xmath353 for every @xmath163 . in the case for @xmath354",
    ", we have @xmath355 . for any @xmath313 ,",
    "let @xmath306 be any monomial in ( [ dbeta ] ) such that @xmath356 .",
    "then @xmath357 , hence @xmath358 as @xmath359 and @xmath360 for @xmath361 .",
    "conversely , suppose @xmath338 .",
    "we want to prove that @xmath339 . we know that @xmath351 is maximal in @xmath352 .",
    "thus @xmath362 for every @xmath163 .",
    "for any @xmath313 , suppose @xmath363 is divisible by @xmath364",
    ". then @xmath365 and @xmath366 . as @xmath367 , @xmath306 can not divide @xmath346 .",
    "hence @xmath366 .",
    "so @xmath306 matches @xmath49 only in @xmath368 .",
    "note that @xmath344 , so @xmath369 and thus @xmath370 .",
    "it follows that @xmath371 by ( [ degx_u ] ) .",
    "therefore , @xmath339 as desired .    by the above lemma",
    ", for each @xmath302 , we only need to find @xmath331 and @xmath372 , which will tell us whether @xmath338 .",
    "this gives us the following incremental algorithm .",
    "* incremental algorithm *    = kk = kkk = = input : @xmath373 , a set of monomials in @xmath1 variables @xmath374 .",
    "+ output : @xmath105 , the irredundant irreducible components of the ideal @xmath28 generated by @xmath373 .",
    "compute @xmath375 and sort it into the form : + @xmath376 + where @xmath32 can be @xmath377 and @xmath378 are sorted in lex order with variable + order @xmath379 . set + @xmath380 .",
    "+ step 2 . for each @xmath163 from 1 to @xmath2 do :",
    "set the temporal variables @xmath381 and @xmath382 .",
    "+ 2.2 . for every @xmath383 with @xmath22",
    "do + @xmath384 + 2.3 . for every @xmath383 with @xmath281",
    "do , + @xmath385 find @xmath331 as defined in ( [ abeta ] ) ; + @xmath385 for @xmath315 , compute @xmath386 , and if @xmath339 then update + @xmath387 + 2.4 .",
    "set @xmath388 .",
    "output @xmath389 .",
    "+    we next prove that there is a nice property of the above algorithm for generic monomial ideals , that is , the size of @xmath389 is always non - decreasing at each stage when a new generator is added .",
    "this will allow us to bound the running time of the algorithm in term of input and output sizes .",
    "[ nondecr ] suppose @xmath28 is generic and @xmath390 where @xmath391 s are sorted in lex order with variable order @xmath379 .",
    "let @xmath392 @xmath393@xmath394",
    ". then @xmath395 .",
    "keep notations as above . for every @xmath396 , @xmath397 .",
    "thus @xmath398 is the only monomial in @xmath399 that has degree in @xmath140 larger than @xmath400 .",
    "hence @xmath401 and @xmath402 . by the equation ( [ wti ] ) and lemma [ case1 ] , @xmath403    the reader might wonder whether a similar statement holds in non - generic case as well .",
    "the answer is negative .",
    "let @xmath404 $ ] with lex order and @xmath405",
    ". then @xmath406 by adding @xmath407 , we can see @xmath408 .",
    "note that @xmath409 @xmath410 . since @xmath411 for @xmath412 , no new @xmath301 will be generated .",
    "thus the number of irreducible components decreases by 1 instead .",
    "we find the irreducible components for the monomial ideal in example [ 3var ] again by the flow of our incremental algorithm .",
    "[ 3var2 ] decompose @xmath413    note : @xmath414  means @xmath415 for corresponding @xmath416 and @xmath317 , while @xmath417  means not .",
    "= kk = kkk = = = step 1 .",
    "@xmath418 . set @xmath419 + step 2 .",
    "( i ) for @xmath420 do : + 2.1 .",
    "+ 2.2 . since @xmath422 , @xmath421 .",
    "let @xmath423 .",
    "we find @xmath424 .",
    "+ so we have @xmath425(@xmath414 ) , @xmath426(@xmath414 ) and @xmath427(@xmath414 ) . + then @xmath428 + 2.4 .",
    "let @xmath388 .",
    "+ ( ii ) for @xmath429 do : + 2.1 . @xmath421 .",
    "update @xmath430 by @xmath431 .",
    "+ let @xmath433 .",
    "we find @xmath434 .",
    "+ so @xmath425(@xmath414 ) , @xmath435(@xmath414 ) and @xmath436(@xmath247 ) .",
    "+ then @xmath437 + 2.4 .",
    "let @xmath388 .",
    "+ ( iii ) for @xmath438 do : + 2.1 .",
    "@xmath440 , and @xmath441 .",
    "+ @xmath385 let @xmath442 .",
    "we find @xmath443 .",
    "+ so @xmath444(@xmath247 ) , @xmath426(@xmath414 ) and @xmath436(@xmath414 ) .",
    "+ then @xmath445 + @xmath385 let @xmath446",
    ". then @xmath447 .",
    "+ @xmath448(@xmath414 ) , @xmath435(@xmath247 ) , @xmath436(@xmath414 ) .",
    "+ so @xmath449 + 2.4 .",
    "let @xmath388 . + step 3 .",
    "@xmath450 + @xmath451 .",
    "+    some preprocess can be taken right before step 2 to improve the efficiency of the incremental algorithm .",
    "for each @xmath452 , we partition @xmath373 into disjoint subsets such that the monomials in each subset have the same degree in @xmath307 .",
    "we then store these information , which requires memory complexity @xmath453 .",
    "for each @xmath302 , we can find @xmath331 by only checking the monomials in the subset with degree @xmath454 in variable @xmath307 for every @xmath317 .",
    "note that for generic monomial ideals each subset contains a unique monomial .",
    "in this case @xmath331 contains @xmath1 monomials , and it can be found by @xmath455 operations , instead of @xmath456 operations by scanning through the whole input monomial set .",
    "we estimate the running time of our algorithms by counting the number of monomial operations ( ie .",
    "comparisons and divisibility ) used .",
    "our recursive algorithm depends heavily on the number of distinct degrees of each variable .",
    "let @xmath457 be the number of distinct degrees of @xmath458 where @xmath459 .",
    "then the total number of merge of subtrees used by the algorithm is at most @xmath460 .",
    "since each subtree has at most @xmath2 leaves(ie .",
    "@xmath2 generators ) , each merge takes @xmath461 monomial operations .",
    "hence the algorithm uses @xmath462 monomial operations .",
    "this algorithm is more efficient for highly non - generic monomial ideals .",
    "the benchmark analysis in @xcite compare several algorithms based on various slicing strategies , including our recursive algorithm .",
    "it is shown there that our algorithm performs as a very close second best one .",
    "the running time of our incremental algorithm is harder to estimate for general ideals . for generic ideals , however , we can bound the time in terms of input and output sizes . more precisely ,",
    "suppose @xmath463 is a generic monomial ideal in @xmath8 $ ] where @xmath391 s are sorted in lex order with variable order @xmath379 . for @xmath464 , let @xmath465 all these ideals are generic . by theorem [ nondecr ]",
    ", we have @xmath466 in an arbitrary stage of the incremental algorithm , we try to find the irreducible components of @xmath467 from those of @xmath468 . for each @xmath469 , only those @xmath49 in @xmath470 ( as defined in ( [ t12 ] ) ) need to be updated .",
    "note that @xmath28 is generic , by the preprocess @xmath331 can be found in @xmath455 operations .",
    "the numbers @xmath471 , @xmath472 , can be computed by scanning through the monomials in @xmath331 once , thus using only @xmath455 monomial operations .",
    "then the numbers @xmath386 , @xmath473 , can be computed in @xmath474 operations .",
    "hence for each @xmath475 , step 2.3 uses at most @xmath476 monomial operations . since @xmath477 has at most @xmath3 elements where @xmath478 ,",
    "step 2.3 needs at most @xmath479 monomial operations .",
    "therefore , the total number of monomial operations is at most @xmath6 .",
    "in fact , @xmath470 is usually a small subset of @xmath389 , the actual running time is much better than our worst - case estimate indicates .",
    "we also want to point out that for generic monomial ideals , the incremental algorithm is an improved version of the recursive algorithm .",
    "suppose we add the new monomial @xmath391 into @xmath468 . in step 3.2 of the recursive algorithm , we need to compute @xmath244 .",
    "but in step 2.3 of the incremental algorithm , only @xmath475 need to be updated .",
    "we have the observation that @xmath470 is a small subset of @xmath480 . by this observation",
    "we conclude the incremental algorithm is more efficient than the recursive algorithm for generic monomial ideals . in non - generic case ,",
    "the comparison is not clear .    in all previous algorithms ( including our recursive one ) for monomial decomposition , the storage in the intermediate stages may grow exponentially larger than the output size .",
    "our incremental algorithm seems to be the first algorithm for monomial decomposition that the intermediate storage is bounded by the final output size .",
    "note that the output size @xmath3 can be exponentially large in @xmath1 .",
    "in fact , it is proven in @xcite that @xmath481})$ ] for large @xmath2 . since the output size",
    "can be exponential in @xmath1 , it is impossible to have a polynomial time algorithm for monomial decomposition .",
    "we thank alexander milowski and bjarke roune for comments and suggestions , and ezara miller for helpful communications ( especially for providing some of the diagrams ) .",
    "99 agnarsson , g. , 1997 . the number of outside corners of monomial ideals .",
    "j pure appl algebra . 117&118 , 3 - 22 .",
    "anwar , i. , 2007 .",
    "janet s algorithm .",
    "eprint http : //arxiv.org / abs/0712.0068[arxiv , 0712.0068 ] .",
    "block , f. , yu , j. , 2006 .",
    "tropical convexity via cellular resolutions .",
    "j algebr comb .",
    "24(1 ) , 103 - 114 .",
    "eprint http://arxiv.org/abs/math/0503279[arxiv,math/0503279 ] .",
    "bayer , d . ,",
    "peeva , i. , sturmfels , b. , 1998 , monomial resolutions .",
    "math res lett . 5(5),31 - 46 .",
    "cox , d. , little , j. , oshea , d. , 1997 .",
    "ideals , varieties , and algorithms , an introduction to computational algebraic geometry and commutative algebra .",
    "springer - verlag .",
    "cox , d. , little , j. , oshea , d. , 1998 . using algebraic geometry . in : graduate texts in mathematics ,",
    "vol . 185 .",
    "eisenbud , d. , 1995 .",
    "commutative algebra , with a view toward algebraic geometry . in : graduate texts in mathematics ,",
    "150 , springer .",
    "far , j. , gao , s. , 2006 .",
    "computing grbner bases for vanishing ideals of finite sets of points . applied algebra , algebraic algorithms and error - correcting codes . in : springer lecture notes in computer science ,",
    "3857 , springer - verlag , 118 - 127 .",
    "gao , s. , rodrigues , v. , stroomer , j. , 2003 .",
    "grbner basis structure of finite sets of points .",
    "gao , s. , zhu , m. , 2008 .",
    "upper bound on the number of irreducible components of monomial ideals . in preparation .",
    "hoten s. , smith , g. , 2002 .",
    "monomial ideals .",
    "computations in algebraic geometry with macaulay 2 , springer - verlag .",
    "hoten s. , sturmfels , b. , 2007 .",
    "computing the integer programming gap .",
    "combinatorica , 27 , 367 - 382 .",
    "jarrah , a. , laubenbacher , r. , stigler , b. , stillman , m. , 2006 .",
    "reverse - engineering of polynomial dynamical systems .",
    "adv appl math , 39(4 ) , 477 - 489 .",
    "miller , e. , 2000 .",
    "resolutions and duality for monomial ideals .",
    "phd thesis , university of california , berkeley , mathematics department .",
    "miller , e. , sturmfels , b. , 1999 .",
    "monomial ideals and planar graphs .",
    "applied algebra , algebraic algorithms and error - correcting codes . in : springer lecture notes in computer science ,",
    "1719 , springer - verlag , aaecc-13 proceedings ( honolulu , nov . 1999 ) , pp .",
    "miller , e. , sturmfels , b. , 2004 .",
    "combinatorial commutative algebra . in : graduate texts in mathematics ,",
    "227 , springer .",
    "milowski , a. , 2004 . computing irredundant irreducible decompositions of large scale monomial ideals . in : proceedings of the international symposium on symbolic and algebraic computation 04 , 235 - 242 .",
    "roune , b. , 2007 .",
    "the label algorithm for irreducible decomposition of monomial ideals .",
    "eprint http://arxiv.org/abs/0705.4483[arxiv,0705.4483 ] .",
    "roune , b. , 2008 . solving thousand - digit frobenius problems using grbner bases .",
    "j symb comput , 43(1 ) , 1 - 7 .",
    "eprint http://arxiv.org/abs/math.co/0702040[arxiv,math/0702040 ] .",
    "roune , b. , 2008 .",
    "the slice algorithm for irreducible decomposition of monomial ideals . to appear in j",
    "symb comput .",
    "eprint http://arxiv.org/abs/0806.3680[arxiv,0806.3680 ] .",
    "sturmfels , b. , grebner bases and convex polytopes . in : ams university",
    "lecture series , vol . 8 .",
    "sturmfels , b. , sullivant , s. , 2006 .",
    "combinatorial secant varieties .",
    "pure and applied mathematics quarterly , 2 , 285 - 309 .",
    "eprint http://arxiv.org/abs/math/0506223[arxiv,math/0506223 ] .",
    "vasconcelos , w. , 1998 .",
    "computational methods in commutative algebra and geometry . algorithms and computation in mathematics , vol .",
    "springer - verlag .",
    "villarreal , r. , 2001 .",
    "monomial algebras .",
    "monographs and textbooks in pure and applied mathematics , vol .",
    "crc press ."
  ],
  "abstract_text": [
    "<S> the paper presents two algorithms for finding irreducible decomposition of monomial ideals . </S>",
    "<S> the first one is recursive , derived from staircase structures of monomial ideals . </S>",
    "<S> this algorithm has a good performance for highly non - generic monomial ideals . </S>",
    "<S> the second one is an incremental algorithm , which computes decompositions of ideals by adding one generator at a time . </S>",
    "<S> our analysis shows that the second algorithm is more efficient than the first one for generic monomial ideals . </S>",
    "<S> furthermore , the time complexity of the second algorithm is at most @xmath0 where @xmath1 is the number of variables , @xmath2 is the number of minimal generators and @xmath3 is the number of irreducible components . </S>",
    "<S> another novelty of the second algorithm is that , for generic monomial ideals , the intermediate storage is always bounded by the final output size which may be exponential in the input size . </S>"
  ]
}