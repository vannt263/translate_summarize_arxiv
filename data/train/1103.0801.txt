{
  "article_text": [
    "high speed communication systems such as flash memory , optical communication and free space optics require extremely fast and low complexity error correcting schemes . among existing decoding algorithms for ldpc codes",
    "@xcite on the bsc , the bit flipping ( serial or parallel ) algorithms are least complex yet possess desirable error correcting abilities .",
    "first described by gallager @xcite , the parallel bit flipping algorithm was shown by zyablov and pinsker @xcite to be capable of asymptotically correcting a linear number of errors ( in the code length ) for almost all codes in the regular ensemble with left - degree @xmath0 .",
    "later , sipser and spielman @xcite used expander graph arguments to show that this algorithm and the serial bit flipping algorithm can correct a linear number of errors if the underlying tanner graph is a good expander .",
    "note that their arguments also apply for regular codes with left - degree @xmath0 .",
    "it was then recently shown by burshtein @xcite that regular codes with left - degree @xmath1 are also capable of correcting a linear number of errors under the parallel bit flipping algorithm .    despite being theoretically valuable ,",
    "the above - mentioned capability to correct a linear number of errors is not practically attractive .",
    "this is mainly because the fraction of correctable errors is extremely small and hence the code length must be large . besides , the above - mentioned results do not apply for column - weight - three codes , which allow very low decoding complexity . also , compared to hard decoding message passing algorithms such as the gallager a / b algorithm , the error performance of the bit flipping algorithms on finite length codes is usually inferior .",
    "this drawback is especially visible for column - weight - three codes for which the guaranteed error correction capability is upper - bounded by @xmath2 ( to be discussed later ) , where @xmath3 is the girth of a code .",
    "the fact that a code with @xmath4 or @xmath5 can not correct certain error patterns of weight two indeed makes the algorithm impractical regardless of its low complexity .    in recent years",
    ", numerous bit - flipping - oriented decoding algorithms have been proposed ( see @xcite for a list of references ) .",
    "however , almost all of these algorithms require some soft information from a channel with capacity larger than that of the bsc .",
    "a few exceptions include the probabilistic bit flipping algorithm ( pbfa ) proposed by miladinovic and fossorier @xcite . in that algorithm , whenever the number of unsatisfied check nodes suggests that a variable ( bit ) node should be flipped , it is flipped with some probability @xmath6 rather than being flipped automatically .",
    "this random nature of the algorithm slows down the decoding , which was demonstrated to be helpful in practical codes whose tanner graphs contain cycles .",
    "the idea of slowing down the decoding can also be found in a bit flipping algorithm proposed by chan and kschischang @xcite .",
    "this algorithm , which is used on the additive white gaussian noise channel ( awgnc ) , requires a certain number of decoding iterations between two possible flips of a variable node .    in this paper",
    ", we propose a new class of bit flipping algorithms for ldpc codes on the bsc .",
    "these algorithms are designed in the same spirit as the class of finite alphabet iterative message passing algorithms @xcite . in the proposed algorithms , an additional bit",
    "is introduced to represent the strength of a variable node .",
    "given a combination of satisfied and unsatisfied check nodes , the algorithm may reduce the strength of a variable node before flipping it . an additional bit",
    "can also be introduced at a check node to indicate its reliability .",
    "the novelty of these algorithms is three - fold .",
    "first , similar to the above - mentioned pbfa , our class of algorithms also slows down the decoding .",
    "however they only do so when necessary and in a deterministic manner .",
    "second , their deterministic nature and simplicity allow simple and thorough analysis .",
    "all subgraphs up to a certain size on which an algorithm fails to converge can be found by a recursive algorithm .",
    "consequently , the guaranteed error correction capability of a code with such algorithms can be derived .",
    "third , the failure analysis of an algorithm gives rise to better algorithms .",
    "more importantly , it leads to decoders which use a concatenation of two - bit bit flipping algorithms .",
    "these decoders show excellent trade offs between complexity and performance .    the rest of the paper is organized as follows .",
    "section [ sect_pre ] provides preliminaries .",
    "section [ sect_tbd ] motivates and describes the class of two - bit bit flipping algorithms .",
    "section [ sect_analysis ] gives a framework to analyze these algorithms .",
    "finally , numerical results are presented in section [ sect_numerical ] along with discussion .",
    "let @xmath7 denote an ( @xmath8 ) ldpc code over the binary field gf(2 ) .",
    "@xmath7 is defined by the null space of @xmath9 , an @xmath10 _ parity check matrix_. @xmath9 is the bi - adjacency matrix of @xmath11 , a tanner graph representation of @xmath7 .",
    "@xmath11 is a bipartite graph with two sets of nodes : @xmath12 variable nodes and @xmath13 check nodes . in a @xmath14-left - regular code ,",
    "all variable nodes have degree @xmath14 .",
    "each check node imposes a constraint on the neighboring variable nodes .",
    "a check node is said to be satisfied by a setting of variable nodes if the modulo - two sum of its neighbors is zero , otherwise it is unsatisfied .",
    "a vector @xmath15 is a codeword if and only if all check nodes are satisfied .",
    "the length of the shortest cycle in the tanner graph @xmath11 is called the girth @xmath3 of @xmath11 .    in this paper",
    ", we consider 3-left - regular ldpc codes with girth @xmath5 , although the class of two - bit bit flipping algorithms can be generalized to decode any ldpc code .",
    "we assume transmission over the bsc .",
    "a variable node is said to be corrupt if it is different from its original sent value , otherwise it is correct . throughout the paper ,",
    "we also assume without loss of generality that the all - zero codeword is transmitted .",
    "let @xmath16 denote the input to an iterative decoder . with the all - zero codeword assumption , the support of @xmath17 , denoted as @xmath18 is simply the set of variable nodes initially corrupt . in our case ,",
    "a variable node is corrupt if it is 1 and is correct if it is 0 .",
    "a simple hard decision decoding algorithm for ldpc codes on the bsc , known as the parallel bit flipping algorithm @xcite is defined as follows . for",
    "any variable node @xmath19 in a tanner graph @xmath11 , let @xmath20 and @xmath21 denote the number of satisfied check nodes and unsatisfied check nodes that are connected to @xmath19 , respectively .",
    "* in parallel , flip each variable node @xmath19 if @xmath22 . *",
    "repeat until all check nodes are satisfied .",
    "the class of two - bit bit flipping algorithms is described in this section .",
    "we start with two motivating examples .",
    "the first one illustrates the advantage of an additional bit at a variable node while the second illustrates the advantage at a check node .      in this subsection",
    ", symbols @xmath23 and @xmath24 denote a correct and a corrupt variable node while @xmath25 and @xmath26 denote a satisfied and an unsatisfied check node .",
    "let @xmath7 be a 3-left - regular ldpc code with girth @xmath5 and assume that the variable nodes @xmath27 and @xmath28 form an eight cycle as shown in fig .",
    "[ fig_fp ] .",
    "also assume that only @xmath29 and @xmath30 are initially in error and that the parallel bit flipping algorithm is employed .",
    "in the first iteration illustrated in fig .",
    "[ fig_fp ] , @xmath31 and @xmath32 are unsatisfied while @xmath33 and @xmath34 are satisfied .",
    "since @xmath35 and @xmath36 , @xmath29 and @xmath30 are flipped and become correct .",
    "however , @xmath37 and @xmath28 are also flipped and become incorrect since @xmath38 and @xmath39 . in the second iteration ( fig .",
    "[ fig_fp ] ) , the algorithm again flips @xmath27 and @xmath28 .",
    "it can be seen that the set of corrupt variable nodes alternates between @xmath40 and @xmath41 , and thus the algorithm does not converge .",
    "[ fp13 ]   [ fp24 ]     [ fp12 ]        the parallel bit flipping algorithm fails in the above situation because it uses the same treatment for variable nodes with @xmath42 and @xmath43 .",
    "the algorithm is too `` aggressive '' when flipping a variable node @xmath19 with @xmath43 .",
    "let us consider a modified algorithm which only flips a variable node @xmath19 with @xmath42 .",
    "this modified algorithm will converge in the above situation .",
    "however , if only @xmath29 and @xmath37 are initially in error ( fig .  [ fig_fp ] ) then the modified algorithm does not converge because it does not flip any variable node .",
    "the modified algorithm is now too `` cautious '' to flip a variable node @xmath19 with @xmath43 .",
    "both decisions ( to flip and not to flip ) a variable node @xmath19 with @xmath43 can lead to decoding failure .",
    "however , we must pick one or the other due the assumption that a variable node takes its value from the set @xmath44 . relaxing this assumption",
    "is therefore required for a better bit flipping algorithm .",
    "let us now assume that a variable node can take four values instead of two .",
    "specifically , a variable node takes its value from the set @xmath45 , where @xmath46 ( @xmath47 ) stands for `` strong zero '' ( `` strong one '' ) and @xmath48 ( @xmath49 ) stands for `` weak zero '' ( `` weak one '' ) .",
    "assume for now that a check node only sees a variable node either as 0 if the variable node is @xmath46 or @xmath48 , or as 1 if the variable node is @xmath47 or @xmath49 .",
    "recall that @xmath50 is the number of unsatisfied check nodes that are connected to the variable node @xmath19 .",
    "let @xmath51 be the function defined in table [ tb_f1 ] .    .@xmath51",
    "[ cols=\"^,^,^,^,^,^,^,^,^,^ \" , ]     [ tb_f1 ]    consider the following bit flipping algorithm .",
    "initialization : each variable node @xmath19 is initialized to @xmath46 if @xmath52 and is initialized to @xmath47 if @xmath53 .    * in parallel , flip each variable node @xmath19 to @xmath54 .",
    "* repeat until all check nodes are satisfied .    compared to the parallel bit flipping algorithm and",
    "its modified version discussed above , the tbfa1 possesses a gentler treatment for a variable node @xmath19 with @xmath55 .",
    "it tries to reduce the `` strength '' of @xmath19 before flipping it .",
    "one may realize at this point that it is rather imprecise to say that the tbfa1 flips a variable node @xmath19 from @xmath46 to @xmath48 or vice versa , since a check node still sees @xmath19 as 0 .",
    "however , as the values of @xmath19 can be represented by two bits , i.e. , @xmath56 can be mapped onto the alphabet @xmath57 , the flipping of @xmath19 should be understood as either the flipping of one bit or the flipping of both bits .",
    "it is easy to verify that the tbfa1 is capable of correcting the error configurations shown in fig .",
    "[ fig_fp ] .",
    "moreover , the guaranteed correction capability of this algorithm is given in the following proposition .",
    "[ algo1cap ] the tbfa1 is capable of correcting any error pattern with up to @xmath58 errors in a left - regular column - weight - three code with tanner graph @xmath11 which has girth @xmath59 and which does not contain any codeword of weight @xmath60 .",
    "the proof is omitted due to page limits .    _ remarks : _    * it can be shown that the guaranteed error correction capability of a 3-left - regular code with the parallel bit flipping algorithm is strictly less than @xmath61 . thus , the tbfa1 increases the guaranteed error correction capability by a factor of at least 2 . * in @xcite",
    ", we have shown that the gallager a / b algorithm is capable of correcting any error pattern with up to @xmath58 errors in a 3-left - regular code with girth @xmath62 . for codes with girth @xmath5 and minimum distance @xmath63 , the gallager a / b algorithm can only correct up to two errors .",
    "this means that the guaranteed error correction capability of the tbfa1 is at least as good as that of the gallager a / b algorithm ( and better for codes with @xmath5 ) .",
    "it is also not difficult to see that the complexity of the tbfa1 is much lower than that of the gallager a / b algorithm .",
    "now that the advantage of having more than one bit to represent the values of a variable node is clear , let us explore the possibility of using more than one bit to represent the values of a check node in the next subsection .      in this subsection , we use the symbols @xmath23 and @xmath24 to denote a @xmath46 variable node and a @xmath47 variable node , respectively .",
    "the symbols used to denote a @xmath48 variable node and a @xmath49 variable node are shown in fig .",
    "[ fig_fvp ] where @xmath37 is a @xmath48 variable node and @xmath29 is a @xmath49 variable node .",
    "the symbols @xmath25 and @xmath26 still represent a satisfied and an unsatisfied check node .",
    "[ fvp1 ]         [ fvp2 ]   [ fvp3 ]     assume a decoder that uses the tbfa1 algorithm .",
    "[ fig_fvp ] , and illustrates the first , second and third decoding iteration of the tbfa1 on an error configuration with four variable nodes @xmath64 and @xmath65 that are initially in error .",
    "we assume that all variable nodes which are not in this subgraph remain correct during decoding and will not be referred to . in the first iteration ,",
    "variable nodes @xmath66 and @xmath67 are strong and connected to two unsatisfied check nodes . consequently , the tbfa1 reduces their strength .",
    "since variable nodes @xmath30 and @xmath28 are strong and only connected to one unsatisfied check node , their values are not changed . in the second iteration",
    ", all check nodes retain their values ( satisfied or unsatisfied ) from the first iteration .",
    "the tbfa1 hence flips @xmath29 and @xmath65 from @xmath49 to @xmath46 and flips @xmath68 and @xmath67 from @xmath48 to @xmath47 . at the beginning of the third iteration , the value of any variable node is either @xmath46 or @xmath47 .",
    "every variable node is connected to two satisfied check nodes and one unsatisfied check node . since",
    "no variable node can change its value , the algorithm fails to converge .",
    "the failure of the tbfa1 to correct this error configuration can be attributed to the fact that check node @xmath69 is connected to two initially erroneous variable nodes @xmath30 and @xmath28 , consequently preventing them from changing their values .",
    "let us slightly divert from our discussion and revisit the pbfa proposed by miladinovic and fossorier @xcite .",
    "the authors observed that variable node estimates corresponding to a number close to @xmath70 unsatisfied check nodes are unreliable due to multiple errors , cycles in the code graph and equally likely a priori hard decisions .",
    "based on this observation , the pbfa only flips a variable node with some probability @xmath6 . in the above error configuration",
    ", a combination of two unsatisfied and one satisfied check nodes would be considered unreliable .",
    "therefore , the pbfa would flip the corrupt variable nodes @xmath29 and @xmath65 as well as the correct variable node @xmath68 and @xmath67 with the same probability @xmath71 .",
    "however , one can see that a combination of one unsatisfied and two satisfied check nodes would also be unreliable because such combination prevents the corrupt variable nodes @xmath30 and @xmath28 from being corrected .",
    "unfortunately , the pbfa can not flip variable nodes with less than @xmath72 unsatisfied check nodes since many other correct variable nodes in the tanner graph would also be flipped . in other words , the pbfa can not evaluate the reliability of estimates corresponding to a number close to @xmath73 unsatisfied check nodes .",
    "we demonstrate that such reliability can be evaluated with a new concept introduced below .",
    "revisit the decoding of the tbfa1 on the error configuration illustrated in fig .",
    "[ fig_fvp ] .",
    "notice that in the third iteration , except check node @xmath69 , all check nodes that are unsatisfied in the second iteration become satisfied while all check nodes that are satisfied in the second iteration become unsatisfied .",
    "we will provide this information to the variable nodes .",
    "[ checkdef ] a satisfied ( unsatisfied ) check node is called _ previously satisfied _ ( _ previously unsatisfied _ )",
    "if it was satisfied ( unsatisfied ) in the previous decoding iteration , otherwise it is called _ newly satisfied _",
    "( _ newly unsatisfied _ ) .",
    "the possible transitions of a check node are illustrated in fig .",
    "[ transcheck ] .",
    "let @xmath74 , @xmath75 , @xmath76 and @xmath77 be the number of previously satisfied check nodes , previously unsatisfied check nodes , newly satisfied check nodes and newly unsatisfied check nodes that are connected to a variable node @xmath19 , respectively .",
    "let @xmath78 be a function defined as follows : @xmath79    consider the following bit flipping algorithm :    initialization : each variable node @xmath19 is initialized to @xmath46 if @xmath52 and is initialized to @xmath47 if @xmath53 . in the first iteration , check nodes are either previously satisfied or previously unsatisfied .",
    "* in parallel , flip each variable node @xmath19 to + @xmath80 . *",
    "repeat until all check nodes are satisfied .",
    "the tbfa2 considers a combination of one newly unsatisfied , one newly satisfied and one previously satisfied check node to be less reliable than a combination of one previously unsatisfied and two previously satisfied check nodes .",
    "therefore , it will reduce the strength of @xmath30 and @xmath28 at the end of the third iteration .",
    "consequently , the error configuration shown in fig . [ fig_fvp ] can now be corrected after 9 iterations .",
    "proposition [ algo1cap ] also holds for the tbfa2 .",
    "_ remarks : _ let @xmath81 be the set of all functions from @xmath82 .",
    "a natural question to ask is whether @xmath83 can be replaced with some @xmath84 such that the tbfa1 algorithm can correct the error configuration shown in fig .",
    "[ fig_fvp ] .",
    "brute force search reveals many of such functions .",
    "unfortunately , none of those functions allow the algorithm to retain its guaranteed error correction capability stated in proposition [ algo1cap ] .",
    "we recap this section by giving the formal definition of the class of two - bit bit flipping algorithms .    for the class of",
    "two - bit bit flipping algorithms , a variable node @xmath19 takes its value from the set @xmath45 .",
    "a check node sees a @xmath46 and a @xmath48 variable node as 0 and sees a @xmath47 and a @xmath49 variable node as 1 .",
    "according to definition [ checkdef ] , a check node can be previously satisfied , previously unsatisfied , newly satisfied or newly unsatisfied .",
    "an algorithm @xmath85 is defined by a mapping @xmath86 , where @xmath14 is the column - weight of a code .",
    "different algorithms in this class are specified by different functions @xmath87 . in order to evaluate the performance of an algorithm ,",
    "it is necessary to analyze its failures . to that task",
    "we shall now proceed .",
    "in this section , we describe a framework for the analysis of two - bit bit flipping algorithms ( the details will be provided in the journal version of this paper ) .",
    "consider the decoding of a two - bit bit flipping algorithm @xmath85 on a tanner graph @xmath11 .",
    "assume a maximum number of @xmath88 iterations and assume that the channel makes @xmath89 errors .",
    "let @xmath90 denote the subgraph induced by the @xmath89 variable nodes that are initially in error .",
    "let @xmath91 be the set of all tanner graphs that contain @xmath90 .",
    "let @xmath92 be the subset of @xmath91 with the following property : if @xmath93 then there exists an induced subgraph @xmath94 of @xmath95 such that ( i ) @xmath94 is isomorphic to @xmath90 and ( ii ) the two - bit bit flipping algorithm @xmath85 fails to decode on @xmath95 after @xmath88 iterations if the @xmath89 initially corrupt variable nodes are variable nodes in @xmath94 .",
    "let @xmath96 be a subset of @xmath92 such that any graph @xmath97 contains a graph @xmath98 and no graph in @xmath96 contains another graph in @xmath96 . with the above formulation , we give the following proposition .",
    "[ proff ] algorithm @xmath85 will converge on @xmath11 after @xmath88 decoding iterations if the induced subgraph @xmath90 is not contained in any induced subgraph @xmath99 of @xmath11 that is isomorphic to a graph in @xmath96 .",
    "if @xmath85 fails to converge on @xmath11 after @xmath88 iterations then @xmath100 , hence @xmath90 must be contained in an induced subgraph @xmath99 of @xmath11 that are isomorphic to a graph in @xmath96 .",
    "we remark that proposition [ proff ] only gives a sufficient condition .",
    "this is because @xmath99 might be contained in an induced subgraph of @xmath11 that is not isomorphic to any graph in @xmath92 .",
    "nevertheless , @xmath96 can still be used as a benchmark to evaluate the algorithm @xmath85 .",
    "a better algorithm should allow the above sufficient condition to be met with higher probability .",
    "for a more precise statement , we give the following .",
    "[ profg ] the probability that a tanner graph @xmath90 is contained in a tanner graph @xmath101 with @xmath102 variable nodes is less than the probability that @xmath90 is contained in a tanner graph @xmath103 with @xmath104 variable nodes if @xmath105    let @xmath106 be a tanner graph with @xmath102 variable nodes such that @xmath106 contains @xmath103 .",
    "since @xmath101 and @xmath106 both have @xmath102 variable nodes , the probability that @xmath90 is contained in @xmath101 equals the probability that @xmath90 is contained in @xmath106 . on the other hand ,",
    "since @xmath106 contains @xmath103 , the probability that @xmath90 is contained in @xmath106 is less than the probability that @xmath90 is contained in @xmath103 by conditional probability .",
    "proposition [ profg ] suggests that a two - bit bit flipping algorithm should be chosen to maximize the size ( in terms of number of variable nodes ) of the smallest tanner graph in @xmath96 .",
    "given an algorithm @xmath85 , one can find all graphs in @xmath96 up to a certain number of variable nodes by a recursive algorithm .",
    "let @xmath107 denote the set of corrupt variable nodes at the beginning of the @xmath108-th iteration .",
    "the algorithm starts with the subgraph @xmath90 , which is induced by the variable nodes in @xmath109 .",
    "let @xmath110 be the set of check nodes that are connected to at least one variable node in @xmath107 .",
    "in the first iteration , only the check nodes in @xmath111 can be unsatisfied .",
    "therefore , if a correct variable node becomes corrupt at the end of the first iteration then it must connect to at least one check node in @xmath110 .",
    "in all possible ways , the algorithm then expands @xmath90 recursively by adjoining new variable nodes such that these variable nodes become corrupt at the end of the first iteration . the recursive introduction of new variable nodes halts if a graph in @xmath96 is found .",
    "let @xmath112 be the set of graphs obtained by expanding @xmath90 .",
    "each graph in @xmath113 is then again expanded by adjoining new variable nodes that become corrupt at the end of the second iteration .",
    "this process is repeated @xmath88 times where @xmath88 is the maximum number of iterations .",
    "we demonstrate the performance of two - bit bit flipping algorithms on a regular column - weight - three quasi - cyclic ldpc code of length @xmath114 .",
    "the code has rate @xmath115 and minimum distance @xmath116 .",
    "two different decoders are considered .",
    "the first decoder , denoted as bfd1 , employs a single two - bit bit flipping algorithm .",
    "the bfd1 may perform iterative decoding for a maximum number of 30 iterations .",
    "the second decoder , denoted as bfd2 , is a concatenation of 55 algorithms , namely @xmath117 .",
    "associated with algorithm @xmath118 is a maximum number of iterations @xmath119 .",
    "the bfd2 operates by performing decoding using algorithm @xmath118 on an input vector @xmath17 for @xmath120 or until a codeword is found .",
    "the maximum possible number of decoding iterations performed by the bfd2 is @xmath121 .",
    "details on the algorithms @xmath117 as well as the parity check matrix of the quasi - cyclic ldpc code can be found in @xcite .",
    "simulations for frame error rate ( fer ) are shown in fig .",
    "[ fig_fer ] .",
    "both decoders outperform decoders which use the gallager a / b algorithm or the min - sum algorithm .",
    "in particular , the fer performance of the bfd2 is significantly better .",
    "more importantly , the slope of the fer curve of the bfd2 is larger than that of the bp decoder .",
    "this shows the potential of two - bit bit flipping decoders with comparable or even better error floor performance than that of the bp decoder .",
    "it is also important to remark that although the bfd2 uses 55 different decoding algorithms , at cross over probability @xmath122 , more than 99.99% of codewords are decoded by the first algorithm .",
    "consequently , the average number of iterations per output word of the bfd2 is not much higher than that of the bfd1 , as illustrated in fig .",
    "[ fig_iter ] .",
    "this means that similar to the bfd1 , the bfd2 has an extremely high speed .",
    "this work was funded by nsf under the grants ccf-0963726 and ccf-0830245 .",
    "s.  planjery , d.  declercq , s.  chilappagari , and b.  vasic  and , `` multilevel decoders surpassing belief propagation on the binary symmetric channel , '' in _ ieee int .",
    "inf . theory _ , jun .",
    "2010 , pp . 769773 .",
    "s.  k. chilappagari , d.  v. nguyen , b.  v. vasic , and m.  w. marcellin , `` error correction capability of column - weight - three ldpc codes under the gallager a algorithm - part ii , '' _ ieee trans .",
    "inf . theory _ ,",
    "56 , no .  6 , pp . 26262639 , jun .",
    "`` error floors of ldpc codes - multi - bit bit flipping algorithm . ''",
    "[ online ] .",
    "available : http://www2.engr.arizona.edu/~vasiclab / projects / codingtheory / errorfloor% home.html[http://www2.engr.arizona.edu/~vasiclab / projects / codingtheory / errorfloor% home.html ]"
  ],
  "abstract_text": [
    "<S> in this paper , we propose a new class of bit flipping algorithms for low - density parity - check ( ldpc ) codes over the binary symmetric channel ( bsc ) . compared to the regular ( parallel or serial ) bit flipping algorithms , </S>",
    "<S> the proposed algorithms employ one additional bit at a variable node to represent its `` strength . '' </S>",
    "<S> the introduction of this additional bit increases the guaranteed error correction capability by a factor of at least 2 . an additional bit can also be employed at a check node to capture information which is beneficial to decoding . a framework for failure analysis of the proposed algorithms </S>",
    "<S> is described . </S>",
    "<S> these algorithms outperform the gallager a / b algorithm and the min - sum algorithm at much lower complexity . </S>",
    "<S> concatenation of two - bit bit flipping algorithms show a potential to approach the performance of belief propagation ( bp ) decoding in the error floor region , also at lower complexity . </S>"
  ]
}