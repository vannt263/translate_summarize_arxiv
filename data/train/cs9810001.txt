{
  "article_text": [
    "types are ubiquitous in programming languages  @xcite .",
    "they make programs easier to understand and help detect errors since a large number of errors are type errors .",
    "types have been introduced into logic programming in the forms of type checking and inference  @xcite or type analysis  @xcite or typed languages  @xcite .",
    "recent logic programming systems allow the programmer declare types for predicates and type errors are then detected either at compile time or at run time . even in early logic programming systems ,",
    "built - in predicates are usually typed and type checking for these predicates are performed at run time .",
    "the reader is referred to @xcite for more details on type in logic programming .",
    "a _ type _ is a possibly infinite set of ground terms with a finite representation .",
    "an integral part of any type system is its type language that specifies which sets of ground terms are types . to be useful ,",
    "types should be closed under intersection , union and complement operations . the decision problems such as the emptiness of a type , inclusion of a type in another , equivalence of two types should be decidable .",
    "regular term languages  @xcite , called regular types , satisfy these constraints and has been used widely used as types  @xcite .",
    "most type systems use _ tuple distributive regular types _ which are strictly less powerful than regular types  @xcite .",
    "tuple distributive regular types are regular types closed under tuple distributive closure . intuitively , the tuple distributive closure of a set of terms is the set of all terms constructed recursively by permuting each argument position among all terms that have the same function symbol  @xcite .",
    "tuple distributive regular types are discussed in section  [ sec : tuple ] .    to our knowledge",
    ", dart and zobel s work  @xcite is the only one to present , among others , an inclusion algorithm for regular types with respect to a given set of type definitions without the tuple distributive restriction .",
    "set - based analysis can also be used to deriving types based on set constraint solving  @xcite . however , set constraint solving methods are intended to infer descriptive types  @xcite rather than for testing inclusion of a prescriptive type  @xcite in another .",
    "therefore , they are useful in different settings from dart - zobel algorithm .",
    "dart - zobel algorithm has been used in type or type related analyses  @xcite .",
    "however , the completeness and the correctness of the algorithm are left open .",
    "this paper provides answers to these open questions .",
    "we show that the algorithm is incorrect for regular types .",
    "we also prove that the algorithm is complete for regular types in general as well as correct for tuple distributive regular types .",
    "these results lead to a simplified version of dart - zobel algorithm that is complete and correct for tuple distributive regular types .",
    "the remainder of this paper is organised as follows .",
    "section  [ sec : regular ] defines regular types by regular term grammars .",
    "section  [ sec : algo ] recalls dart - zobel algorithm for testing if a regular type is a subset of another regular type .",
    "section  [ sec : open ] addresses the completeness and the correctness of their algorithm that have been left open . in section  [ sec : tuple ] , we show that their algorithm is both complete and correct for tuple distributive regular types and provides a simplified version of their algorithm for tuple distributive regular types .",
    "several equivalent formalisms such as tree automata  @xcite , regular term grammars  @xcite , regular unary logic programs  @xcite have been used to describe regular types . in  @xcite , dart and zobel use regular term grammars to describe regular types that are sets of ground terms over a ranked alphabet @xmath0 .",
    "a regular term grammar is a tuple @xmath1 where    * @xmath0 is a fixed ranked alphabet .",
    "each symbol in @xmath0 is called a function symbol and has a fixed arity .",
    "it is assumed that @xmath0 contains at least one constant that is a function symbol of arity @xmath2 .",
    "* @xmath3 is a set of symbols called nonterminals .",
    "these terminals will be called type symbols as they represent types .",
    "type symbols are of arity @xmath2 .",
    "it is assumed that @xmath4 . * @xmath5 is a set of production rules of the form @xmath6 with @xmath7 and @xmath8 where @xmath9 is the set of all terms over @xmath10 .",
    "terms in @xmath9 will be called pure type terms .",
    "[ ex1 ] let @xmath11 and @xmath12 .",
    "@xmath13 defines natural numbers and lists of natural numbers where @xmath14    @xmath15    the above presentation is slightly different from @xcite where production rules with the same type symbol on their lefthand sides are grouped together and called a type rule .",
    "for instance , production rules in the above examples are grouped into two type rules @xmath16 and @xmath17 .",
    "types denoted by a pure type term is given by a rewrite rule @xmath18 associated with @xmath19 .",
    "@xmath20 if @xmath5 contains a rule @xmath6 , @xmath21 occurs in @xmath22 and @xmath23 results from replacing an occurrence of @xmath21 in @xmath22 by @xmath24 .",
    "let @xmath25 be the reflexive and transitive closure of @xmath18 .",
    "the type denoted by a pure type term @xmath24 is defined as follows .",
    "@xmath26\\!\\!]}_{\\grammar } } { \\stackrel{\\em def}{=}}\\{t\\in\\terms(\\sigma)~|~\\tau\\rightarrow_{\\grammar}^ { * } t\\}\\ ] ] @xmath27\\!\\!]}_{\\grammar}}$ ] is the set of terms over @xmath0 that can be derived from @xmath24 by repeatedly replacing the lefthand side of a rule in @xmath5 with its righthand side .",
    "let @xmath19 be the regular term grammar in example  [ ex1 ] .",
    "we have @xmath28 thus , @xmath29\\!\\!]}_{\\grammar}}$ ] contains @xmath30 .",
    "the type represented by a sequence @xmath31 of pure type terms and a set @xmath32 of sequences of pure type terms are defined as follows .",
    "@xmath33\\!\\!]}_{\\grammar } } & { \\stackrel{\\em def}{=}}&\\{\\epsilon\\}\\\\ { { [ \\!\\![\\ll\\tau\\rl+\\psi']\\!\\!]}_{\\grammar } } & { \\stackrel{\\em def}{= } } & { { [ \\!\\![\\tau]\\!\\!]}_{\\grammar}}\\times{{[\\!\\![\\psi']\\!\\!]}_{\\grammar}}\\\\   { { [ \\!\\![\\psi]\\!\\!]}_{\\grammar } } & { \\stackrel{\\em def}{= } } & \\bigcup_{\\psi\\in\\psi}{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}}\\end{aligned}\\ ] ] where @xmath34 is the empty sequence , @xmath35 is the infix sequence concatenation operator , @xmath36 is the sequence consisting of the pure type term @xmath24 and @xmath37 is the cartesian product operator .",
    "the set @xmath3 of nonterminals in dart and zobel s type language also contains constant type symbols .",
    "constant type symbols are not defined by production rules and they denote constant types . in particular , @xmath3 contains @xmath38 denoting the set of all terms over @xmath0 and @xmath39 denoting the empty set of terms",
    ". we will leave out constant type symbols in this paper in order to simplify presentation .",
    "re - introducing constant type symbols will not affect the results of the paper .",
    "dart - zobel algorithm works with simplified regular term grammars .",
    "a regular term grammar @xmath13 is simplified if @xmath40\\!\\!]}_{\\grammar}}\\neq\\emptyset$ ] for each @xmath7 and @xmath41 for each @xmath42 .",
    "every regular grammar can be simplified .",
    "this section recalls dart and zobel s inclusion algorithm for regular types . as indicated in section  [ sec : regular ] , we shall disregard constant type symbols and simplify their algorithm accordingly .",
    "we note that without constant type symbols , many functions in their algorithm can be greatly simplified . in place of a type rule , we use the corresponding set of production rules .",
    "these superficial changes do nt change the essence of the algorithm but facilitate the presentation .",
    "we shall assume that @xmath19 is a simplified regular term grammar and omit references to @xmath19 where there is no confusion .",
    "we first describe the ancillary functions used in their algorithm .",
    "let @xmath43 be a non - empty sequence of pure type terms and @xmath32 be a set of non - empty sequences of pure type terms .",
    "@xmath44 and @xmath45 .",
    "@xmath46 and @xmath47 are defined as @xmath48 and @xmath49 .",
    "the function @xmath50 rewrites a non - empty sequence into a set of sequences when necessary .",
    "@xmath51 @xmath52 .",
    "the function @xmath53 defined below applies when @xmath24 is pure type term and @xmath41 and @xmath32 is a set of non - empty sequences with @xmath54 .",
    "the output of @xmath53 is the set of the sequences in @xmath32 that have the same principal function symbol as @xmath24 .",
    "@xmath55 note that @xmath56 is a constant when @xmath57 .",
    "the function @xmath58 defined below applies when @xmath59 is a non - empty sequence with @xmath60 .",
    "@xmath58 replaces the head of @xmath59 with its arguments .",
    "@xmath61 when @xmath57 , @xmath62 . without constant type symbols",
    ", @xmath63 does nt need an extra argument as in  @xcite that is used to test membership of a term in a constant type and to indicate the required number of arguments when the constant type symbol is @xmath38 .",
    "@xmath64 .",
    "the inclusion algorithm @xmath65 takes two pure type terms @xmath66 and @xmath67 and is intended to decide if @xmath68\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\tau_2]\\!\\!]}_{\\grammar}}$ ] is true or false .",
    "the core part @xmath69 of the inclusion algorithm takes a sequence @xmath31 of pure type terms and a set @xmath32 of sequences of pure type terms that are of the same length as @xmath31 and is intended to decide if @xmath70\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}}$ ] .",
    "@xmath69 takes a third argument @xmath71 to ensure termination .",
    "@xmath71 is a set of pairs @xmath72 where @xmath73 is a type symbol and @xmath74 is a set of pure type terms .",
    "a pair @xmath72 in @xmath71 can be read as @xmath75\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\upsilon]\\!\\!]}_{\\grammar}}$ ] .",
    "the functions @xmath76 and @xmath69 are defined in the following . where several alternative definitions of @xmath69 apply , the first is used .",
    "@xmath77    the second condition @xmath78 for the third alternative is obviously mistaken to be @xmath79 in  @xcite .",
    "the first two alternatives deal with two trivial cases .",
    "the third alternative uses pairs in @xmath71 to force termination .",
    "as we shall see later , this is fine for tuple distributive regular types but is problematic for regular types in general .",
    "the fourth alternative expands @xmath31 into a set of sequences @xmath59 and compares each of them with @xmath32 .",
    "the fifth alternative applies when @xmath80 .",
    "sequences in @xmath32 are expanded and the expanded sequences of the form @xmath81 are selected . @xmath31 and the set of the selected sequences",
    "are then compared after replacing @xmath56 with @xmath82 in @xmath31 and replacing @xmath83 with @xmath84 in each @xmath81 .",
    "we now address the correctness and the completeness of dart - zobel algorithm that were left open .",
    "we first show that the algorithm is incorrect for regular types by means of a counterexample .",
    "we then prove that the algorithm is complete for regular types .",
    "thus , the algorithm provides an approximate solution to the inclusion problem of regular types in that it returns true if inclusion relation holds between its two arguments while the reverse is not necessarily true .",
    "the following example shows that dart - zobel algorithm is incorrect for regular types .",
    "let @xmath13 with @xmath85 , + @xmath86 and @xmath87 where , for instance , @xmath88 is an abbreviation of two rules @xmath89 and @xmath90 .",
    "let @xmath91 .",
    "we have @xmath92\\!\\!]}_{\\grammar } } & = & \\{t\\in\\terms(\\sigma_{h})~|~\\mbox{t is left - skewed and leaves of t are a's}\\}\\\\ { { [ \\!\\![\\sigma]\\!\\!]}_{\\grammar } } & = & \\{t\\in\\terms(\\sigma_{h})~|~\\mbox{t is left - skewed and leaves of t are b's}\\}\\\\ { { [ \\!\\![\\omega]\\!\\!]}_{\\grammar } } & = & \\{t\\in\\terms(\\sigma_{h})~|~\\mbox{t is left - skewed}\\}\\\\ { { [ \\!\\![\\alpha]\\!\\!]}_{\\grammar } } & = & \\{g(t)~|~t\\in{{[\\!\\![\\omega]\\!\\!]}_{\\grammar}}\\}\\\\ { { [ \\!\\![\\beta]\\!\\!]}_{\\grammar } } & = & \\{g(t)~|~t\\in{{[\\!\\![\\theta]\\!\\!]}_{\\grammar}}\\cup{{[\\!\\![\\sigma]\\!\\!]}_{\\grammar}}\\}\\end{aligned}\\ ] ]    let @xmath93 .",
    "@xmath94\\!\\!]}_{\\grammar}}$ ] and @xmath95\\!\\!]}_{\\grammar}}$ ] .",
    "therefore , @xmath40\\!\\!]}_{\\grammar}}\\not\\subseteq{{[\\!\\![\\beta]\\!\\!]}_{\\grammar}}$ ] .",
    "the incorrectness of dart - zobel algorithm is illustrated by showing @xmath96 as follows .",
    "let @xmath97 .",
    "we have    @xmath98    let @xmath99 . by the fourth definition of @xmath69 and the above equation , @xmath100    by applying the fifth and then the second definitions of @xmath69 , @xmath101 . in the same way",
    ", we obtain @xmath102 .",
    "@xmath103 we can show @xmath104 in the same way as above",
    ". therefore , by equation  [ eq:1 ] , @xmath96 and @xmath76 is incorrect for regular types .",
    "@xmath15    the problem with the algorithm stems from the way the set @xmath71 is used in the third definition of @xmath69 . as the above example indicates , the third definition of @xmath69 severs the dependency between the terms in a tuple , i.e. , subterms of a term .    in  @xcite , dart and",
    "zobel show by an example that their algorithm works for some regular types which are not tuple distributive .",
    "we do nt know what is the largest subclass of the class of regular types for which the algorithm is correct .",
    "we now prove that dart - zobel algorithm is complete for regular types in the sense that @xmath105 whenever @xmath68\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\tau_2]\\!\\!]}_{\\grammar}}$ ] .",
    "let @xmath71 be a set of pairs @xmath72 with @xmath73 and @xmath74 .",
    "a pair @xmath72 in @xmath71 states that the denotation of @xmath106 is included in that of @xmath107 , i.e. , @xmath75\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\upsilon]\\!\\!]}_{\\grammar}}$ ] for regular types .",
    "define @xmath108\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\upsilon]\\!\\!]}_{\\grammar}}\\ ] ]    the completeness of @xmath76 follows from the following theorem which asserts the completeness of @xmath69 .",
    "[ th:1 ] let @xmath31 be a sequence of pure type terms and @xmath32 a set of sequences of pure type terms of the same length as @xmath31 , @xmath71 a set of pairs @xmath72 with @xmath73 and @xmath74 . if @xmath109\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}}$ ] then @xmath110 .",
    "assume @xmath111 .",
    "the proof is done by showing @xmath112\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}}$ ] .",
    "this is accomplished by induction on @xmath113 where @xmath114 is the length of @xmath31 and @xmath115 is the depth of the computation tree for @xmath116 . define @xmath117 .",
    "basis . @xmath118 and @xmath119 .",
    "@xmath120 and @xmath121 since @xmath111 .",
    "let @xmath122 .",
    "@xmath123\\!\\!]}_{\\grammar}}$ ] and @xmath124\\!\\!]}_{\\grammar}}$ ] .",
    "so , @xmath125\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}}$ ] .",
    "@xmath126 or @xmath127 . by the definition of @xmath69 ,    * @xmath121 ; or * @xmath128 and there is @xmath74 such that @xmath129 ; or * @xmath130 and @xmath131 where @xmath132 ; or * @xmath133 and @xmath134 where @xmath135 and @xmath136 .    it remains to prove that @xmath112\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}}$ ] in each of the cases ( a)-(d ) .",
    "the case ( a ) is trivial as @xmath19 is simplified and hence @xmath70\\!\\!]}_{\\grammar}}\\neq\\emptyset$ ] .    in the case ( b )",
    ", we have @xmath137 and @xmath138 . by the induction hypothesis , @xmath139\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\tls(\\psi)]\\!\\!]}_{\\grammar}}$ ] .",
    "thus , @xmath140\\!\\!]}_{\\grammar}}\\land\\bt'\\not\\in{{[\\!\\![\\tls(\\psi)]\\!\\!]}_{\\grammar}})$ ] .",
    "let @xmath141\\!\\!]}_{\\grammar}}$ ] and @xmath142 .",
    "note that @xmath22 exists as @xmath19 is simplified .",
    "we have @xmath143\\!\\!]}_{\\grammar}}\\land\\bt\\not\\in{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}}$ ] .",
    "so , @xmath125\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}}$ ] .    in the case ( c ) ,",
    "@xmath144 . by the induction hypothesis , @xmath145\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}}$ ] .",
    "note that @xmath146\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\hds(\\psi)]\\!\\!]}_{\\grammar}})$ ] .",
    "so , we have @xmath147\\!\\!]}_{\\grammar}}\\not\\subseteq{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}}\\lor{{[\\!\\![\\hd(\\psi)]\\!\\!]}_{\\grammar}}\\not\\subseteq{{[\\!\\![\\hds(\\psi)]\\!\\!]}_{\\grammar}}$ ] .",
    "assume @xmath148 .",
    "either ( i ) @xmath70\\!\\!]}_{\\grammar}}\\not\\subseteq{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}}$ ] or ( ii ) @xmath149\\!\\!]}_{\\grammar}}\\not\\subseteq{{[\\!\\![\\hds(\\psi)]\\!\\!]}_{\\grammar}}$ ] . in the case ( i ) , @xmath150\\!\\!]}_{\\grammar}})\\land(\\bt'\\not\\in{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}})$ ] . by proposition 5.26 in  @xcite , we have @xmath125\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}}$ ] . in the case ( ii ) , @xmath151\\!\\!]}_{\\grammar}})\\land(t\\not\\in{{[\\!\\![\\hds(\\psi)]\\!\\!]}_{\\grammar}})$ ] .",
    "let @xmath152\\!\\!]}_{\\grammar}}$ ] and @xmath153 .",
    "note that @xmath154 exists as @xmath19 is simplified .",
    "we have @xmath123\\!\\!]}_{\\grammar}}\\land\\bt\\not\\in{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}}$ ] .",
    "so , @xmath125\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}}$ ] in the case ( c ) .    in the case",
    "( d ) , we have @xmath155 and @xmath156 . by the induction hypothesis , @xmath157\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\psi']\\!\\!]}_{\\grammar}}$ ] .",
    "thus , @xmath158\\!\\!]}_{\\grammar}})\\land((\\bt_{1}+\\bt_{2})\\not\\in{{[\\!\\![\\psi']\\!\\!]}_{\\grammar}})$ ] , which implies @xmath159\\!\\!]}_{\\grammar}})\\land((\\ll f(\\bt_{1})\\rl+\\bt_{2})\\not\\in{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}})$ ] .",
    "so , @xmath125\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\psi]\\!\\!]}_{\\grammar}}$ ] .",
    "@xmath15    the completeness of @xmath76 is a corollary of the above theorem .",
    "[ co:1 ] let @xmath66 and @xmath67 be pure type terms .",
    "if @xmath68\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\tau_2]\\!\\!]}_{\\grammar}}$ ] then @xmath105 .",
    "@xmath160 by the definition of @xmath76 .",
    "we have @xmath161\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\{\\ll\\tau_2\\rl\\}]\\!\\!]}_{\\grammar}}$ ] since @xmath68\\!\\!]}_{\\grammar}}\\subseteq{{[\\!\\![\\tau_2]\\!\\!]}_{\\grammar}}$ ] .",
    "the corollary now follows from the above theorem as @xmath162 .",
    "most type languages in logic programming use tuple distributive closures of regular term languages as types  @xcite .",
    "the notion of tuple distributivity is due to mishra  @xcite .",
    "the following definition of tuple distributivity is due to heintze and jaffar  @xcite .",
    "each function symbol of arity @xmath163 is associated with @xmath163 projection operators @xmath164 .",
    "let @xmath165 be a set of ground terms in @xmath166 .",
    "@xmath167 is defined as follows . @xmath168",
    "the tuple distributive closure of @xmath165 is @xmath169 where @xmath170 is the set of constants in @xmath0 .    the following proposition results from the fact that @xmath171 is a closure operator and preserves set inclusion , i.e. , @xmath172 implies @xmath173 .    [ lm:1 ]",
    "let @xmath174 . @xmath175 .",
    "@xmath15    the tuple distributive regular type @xmath176 associated with a pure type term @xmath24 is the tuple distributive closure of the regular type @xmath27\\!\\!]}_{\\grammar}}$ ] associated with @xmath24  @xcite .",
    "@xmath177\\!\\!]}_{\\grammar}}^{\\star}\\ ] ]    let @xmath31 be a sequence of pure type terms , @xmath32 be a set of sequences of pure type terms of the same length .",
    "@xmath178 the definition of @xmath179 makes use of tuple distributivity and hence severs the inter - dependency between components of a sequences of terms .",
    "we now prove that dart - zobel algorithm is correct for tuple distributive regular types in the sense that if @xmath105 then @xmath180 .",
    "let @xmath71 be a set of pairs @xmath72 with @xmath73 and @xmath74 .",
    "a pair @xmath72 in @xmath71 represents @xmath181 for tuple distributive regular types .",
    "define @xmath182    the correctness of @xmath76 follows from the following theorem which asserts the correctness of @xmath69 for tuple distributive regular types .    [ th:2 ]",
    "let @xmath31 be a sequence of pure type terms and @xmath32 a set of sequences of pure type terms of the same length as @xmath31 , @xmath71 a set of pairs @xmath72 with @xmath73 and @xmath74 .",
    "if @xmath110 then @xmath183 .",
    "assume @xmath110 .",
    "the proof is done by induction on @xmath113 .    basis . @xmath118 and @xmath119 .",
    "@xmath120 and @xmath184 by the second definition of @xmath69 .",
    "so , @xmath185 and @xmath183 .",
    "@xmath126 or @xmath127 by the definition of @xmath69 ,    * @xmath186 and there is @xmath74 such that @xmath187 ; or * @xmath130 and @xmath188 where @xmath132 ; or * @xmath133 and @xmath189 where @xmath135 and @xmath136 .",
    "it remains to prove that @xmath183 in each of the cases ( a)-(c ) .    in the case (",
    "a ) , we have @xmath137 and @xmath138 . by the induction hypothesis , @xmath190 . @xmath191 and",
    "@xmath192 imply @xmath193 .",
    "thus , @xmath194 by the definitions of @xmath195 and @xmath179 .",
    "note that tuple distributivity is used in the definition of @xmath179 .    in the case ( b ) ,",
    "@xmath144 . by the induction hypothesis , @xmath196 .",
    "note that @xmath197 .",
    "so , @xmath198 @xmath199 since @xmath110 .",
    "we have @xmath200 by the induction hypothesis since @xmath201 .",
    "so , @xmath202 .",
    "@xmath203 since @xmath171 is a closure operator and hence @xmath194    in the case ( c ) , we have @xmath155 and @xmath156 . by the induction hypothesis , @xmath204 . by proposition 5.29 in  @xcite ,",
    "this completes the proof of the theorem .",
    "@xmath15    the correctness of @xmath76 is a corollary of the above theorem .",
    "let @xmath66 and @xmath67 be pure type terms . if @xmath105 then @xmath180 .",
    "let @xmath105 .",
    "@xmath205 by the definition of @xmath76 .",
    "thus , @xmath206 according to the above theorem .",
    "so , @xmath180 as @xmath207 .",
    "@xmath15      this section presents the completeness of dart - zobel algorithm for tuple distributive regular types . the following theorem is the counterpart of theorem  [ th:1 ] .    [ th:6 ]",
    "let @xmath31 be a sequence of pure type terms and @xmath32 a set of sequences of pure type terms of the same length as @xmath31 , @xmath71 a set of pairs @xmath72 with @xmath73 and @xmath74 .",
    "if @xmath194 then @xmath110 .",
    "the proof can be obtained from that for theorem  [ th:1 ] by simply replacing @xmath208 with @xmath209 and @xmath210\\!\\!]}_{\\grammar}}$ ] with @xmath211 .",
    "@xmath15    the following completeness result of dart - zobel algorithm for tuple distributive regular types follows from the above theorem .",
    "let @xmath66 and @xmath67 be pure type terms . if @xmath180 then @xmath105",
    ".    the proof can be obtained from that for corollary  [ co:1 ] by simply replacing @xmath212 with @xmath213 , @xmath210\\!\\!]}_{\\grammar}}$ ] with @xmath211 and theorem  [ th:1 ] with theorem  [ th:6 ] .",
    "@xmath15      now that dart - zobel algorithm is complete and correct for tuple distributive regular types but not correct for general regular types .",
    "it is desirable to specialise dart - zobel algorithm for tuple distributive regular types which was originally proposed for general regular types .",
    "the following is a simplified version of the algorithm for tuple distributive regular types .",
    "@xmath214    while dart - zobel algorithm mainly deals with sequences of pure type terms , the simplified algorithm primarily deals with pure type terms by breaking a sequence of pure type terms into its component pure type terms .",
    "this is allowed because tuple distributive regular types abstract away inter - dependency between component terms in a sequence of ground terms .",
    "we forgo presenting the correctness and the completeness of the simplified algorithm because they can be proved by emulating proofs for theorems  [ th:1 ] and  [ th:2 ] .",
    "we have provided answers to open questions about the correctness and the completeness of dart - zobel algorithm for testing inclusion of one regular type in another .",
    "the algorithm is complete but incorrect for general regular types .",
    "it is both complete and correct for tuple distributive regular types .",
    "it is our hope that the results presented in this paper will help identify the applicability of dart - zobel algorithm .",
    "we have also provided a simplified version of dart - zobel algorithm for tuple distributive regular types .",
    "a.  aiken and t.k . lakshman . directional type checking of logic programs .",
    "in b.  le  charlier , editor , _ proceedings of the first international static analysis symposium _ , pages 4360 .",
    "springer - verlag , 1994 .      c.  beierle .",
    "type inferencing for polymorphic order - sorted logic programs . in l.",
    "sterling , editor , _ proceedings of the twelfth international conference on logic programming _ , pages 765779 . the mit press , 1995 .",
    "m.  codish and v.  lagoon .",
    "type dependencies for logic programs using aci - unification . in _ proceedings of the 1996 israeli symposium on theory of computing and systems _ , pages 136145 .",
    "ieee press , june 1996 .",
    "s.  k. debray , p.  lpez - garcia , and m.  hermenegildo .",
    "non - failure analysis for logic programs . in lee naish ,",
    "editor , _ logic programming : proceedings of the fourteenth international conference on logic programming _ , pages 4862 . the mit press , july 1997 .",
    "p.  devienne , j - m .",
    "talbot , and s.  tison .",
    "co - definite set constraints with membership expressions . in j.",
    "jaffar , editor , _ proceedings of the 1998 joint conference and symposium on logic programming _ , pages 2539 . the mit press , 1998 .",
    "t.  fruhwirth , e.  shapiro , m.y .",
    "vardi , and e.  yardeni .",
    "logic programs as types for logic programs . in _ proceedings of sixth annual ieee symposium on logic in computer science _ , pages 300309 . the ieee computer society press , 1991 .",
    "gallagher and d.a . de  waal .",
    "fast and precise regular approximations of logic programs . in m.",
    "bruynooghe , editor , _ proceedings of the eleventh international conference on logic programming _ , pages 599613 . the mit press , 1994 .        n.  heintze and j.  jaffar . a finite presentation theorem for approximating logic programs . in _ proceedings of the seventh annual acm symposium on principles of programming languages _ , pages 197209 . the acm press , 1990 .",
    "n.  heintze and j.  jaffar . a decision procedure for a class of set constraints .",
    "technical report cmu - cs-91 - 110 , carnegie - mellon university , february 1991 .",
    "( later version of a paper in proc .",
    "5th ieee symposium on lics ) .",
    "n.  heintze and j.  jaffar . set constraints and set - based analysis . in alan",
    "borning , editor , _ principles and practice of constraint programming _ , volume 874 of _ lecture notes in computer science_. springer , may 1994 .",
    "( ppcp94 : second international workshop , orcas island , seattle , usa ) .",
    "type analysis of logic programs in the presence of type definitions . in _ proceedings of the 1995 acm sigplan symposium on partial evaluation and semantics - based program manipulation _ ,",
    "pages 241252 . the acm press , 1995 .",
    "e.  yardeni , t.  fruehwirth , and e.  shapiro .",
    "polymorphically typed logic programs . in k.",
    "furukawa , editor , _ logic programming .",
    "proceedings of the eighth international conference _ , pages 37993 . the mit press , 1991 ."
  ],
  "abstract_text": [
    "<S> this paper answers open questions about the correctness and the completeness of dart - zobel algorithm for testing the inclusion relation between two regular types . </S>",
    "<S> we show that the algorithm is incorrect for regular types . </S>",
    "<S> we also prove that the algorithm is complete for regular types as well as correct for tuple distributive regular types . </S>",
    "<S> also presented is a simplified version of dart - zobel algorithm for tuple distributive regular types .    </S>",
    "<S> * keywords : * type , regular term language , regular term grammar , tuple distributivity </S>"
  ]
}