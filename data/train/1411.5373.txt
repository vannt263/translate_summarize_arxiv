{
  "article_text": [
    "when a radio pulse propagates through the interstellar and intergalactic plasma , different frequencies travel at different speeds .",
    "this phenomenon , known as dispersion , hinders the detection of radio pulses .",
    "this is because integrating over many frequencies during a given time frame dilutes the signal with noise , as only a single frequency contributes signal at any given interval within the integration frame .",
    "the solution to this problem is to dedisperse the signal ( i.e. , to apply frequency dependent time delays to the signal prior to integration ) . since in most cases",
    "the dispersion is a priori unknown , we need to test a large number of dispersions .",
    "the best dispesrion is the one that maximizes the signal - to - noise ratio of the pulse .",
    "a different way to look at this problem is that we need to integrate the flux along many dispersion curves in the frequency - time domain .",
    "the difference in pulse arrival time between two frequencies is given by : @xmath4 where @xmath5 is called the dispersion measure of the signal and it is traditionally measured in units of @xmath6 .",
    "@xmath7 are frequencies measured in ghz and @xmath8 is the arrival time of the signal at frequency @xmath7 . for brevity , throughout the paper , we will use @xmath9 to denote the dispersion measure in which all the dimensional constants are absorbed , i.e. , the relation is given by @xmath10    the raw input from a radio reciever is a time series of voltage measurments sampled typically at high frequency ( e.g. , @xmath11mhz ) .",
    "we denote the sampling interval by @xmath12 . in order to generate a spectrum ( @xmath13 $ ] ) as a function of time ( @xmath14 ) and frequency ( @xmath15 )",
    "the time series is divided to blocks of size @xmath16 samples , and each block is then fourier transformed ( a process known as short time fourier transform , or stft ) and the absolute value squared at each frquency is saved .",
    "there are two distinct processes that we can apply to dedisperse a signal : incoherent dedispersion and coherent dedispersion .",
    "the term incoherent dedeispersion refers to applying frequency - dependent time delays to the @xmath17 matrix , while coherent dedispersion involves applying a frequency - dependent phase shift directly to the fourier transform of the raw signal .",
    "this subtle difference is important  incoherent dedispersion is only an approximation that is valid under certain conditions that we are going to review shortly (  [ sec : sensitivityincoherentdedispersion ] ) .",
    "a typical input matrix ( @xmath13 $ ] ) to incoherent dedispersion is presented in the top panel of figure [ fig : inputoutput ] , while on the bottom we show a zoom in on the output of the transform .",
    "the exact mathematical description of signal dispersion is the multiplication of the fourier transform of the raw signal with the phase - only filter @xmath18 @xcite , where @xmath19 is the base - band frequency . in order to exactly dedisperse the signal",
    ", we can apply the inverse of this shift .",
    "this process is referred as coherent dedispersion .",
    "the computational requirements of incoherent dedispersion are more tractable than those of coherent dedispersion , and therefore whenever a blind search for astrophysical pulses is done , incoherent dedispersion is usually the method of choice ( e.g. @xcite ) .",
    "the main practical motivation for improving dedispersion algorithms is to allow efficient analysis of modern radio interferometers data .",
    "when a blind search for new sources is conducted using a multi - component radio interferometer , coherent dedispersion of a large number of synthesized beams is the most sensitive detection method , but usually this is unfeasible .",
    "the standard solution for this problem is to either combine the power from all antennas incoherently , or to use only a small core of the interferometer for blind searches .",
    "both approaches result in a significant loss of sensitivity and angular resolution that can amount to an order of magnitude sensitivity loss .",
    "it is important to improve upon these methods , especially when searching for non - repeating radio transients such as fast radio bursts ( frbs ; @xcite ) .",
    "efficient detection of such objects requires both high sensitivity and a good spatial localization that is calculated in real time .",
    "this is crucial for the multi - wavelength followup of these illusive transients ( e.g. , @xcite ) .    in this paper",
    ", we present the fast discrete dispersion measure transform algorithm ( henceforth fdmt ) to solve the problem of incoherent dedispersion .",
    "fdmt is a transform algorithm , having ( generally ) equal sizes for both input and output , and complexity that is only logarithmically larger than the input itself .",
    "in addition , we present a hybrid algorithm that achieves both the sensitivity of coherent dedispersion , and the computational efficiency of incoherent dedispersion .",
    "finally , we show that using this algorithm , it is feasible to perform blind searches with modern radio interferometers , and consequently to open new frontiers in the search for pulsars and radio transients .",
    "the structure of the paper is as follows . in  [ sec : sensitivityincoherentdedispersion ] we analyze the sensitivity of incoherent dedispersion . in  [ sec : existingmethods ] we review the existing approaches for incoherent dedispersion . in  [ sec : fdmtalgorithm ] we describe the proposed algorithm , along with its complexity analysis . in  [ sec : fdmtfft ] we present a variant of the algorithm that utilizes the fast fourier transform to make the algorithm much more parallel friendly . in  [ sec : runtimeandbenchmarking ] we compare the runtime of the implementation we provide with existing implementations of brute force dedispersion . in ",
    "[ sec : coherentincoherenthybrid ] we propose a new hybrid algorithm for detection of pulses shorter than sensitively detectable by incoherent dedispersion . in ",
    "[ sec : dedispersioninterferometers ] we discuss the application of the proposed algorithms for interferometers , and show that sensitive detection of short pulses , with maximal resolution , using all the elements of the interferometer , is feasible with current facilities .",
    "we conclude in  [ sec : conclusion ] .",
    "in this subsection , we develop the condition on the pulse length , the sampling interval and the dispersion delay that allows sensitive detection with incoherent dedispersion .",
    "this will be of importance in section  [ sec : coherentincoherenthybrid ] .",
    "we denote by @xmath20 the raw voltage signal , and by @xmath21 the total number of samples .",
    "we further denote the pulse duty time ( length ) by @xmath22 , where @xmath23 is the number of samples within the pulse .",
    "the optimal score for pulse detection is the sum of the squared voltage measurements within the pulse start time ( @xmath24 ) and end time , @xmath25 we further define the dispersion time @xmath26 to be the total delay of the pulse within the band and we define @xmath3 to be the dispersion time in units of samples , i.e. @xmath27 .",
    "an important property of the dispersion kernel @xmath28 is that it is power preserving ( @xmath29 ) .",
    "another important property is that the majority of pulse power will lay within the dispersion curve in @xmath17 . by summing over the dispersion curve in @xmath30",
    ", we also sum the power of the noise outside the pulse , which its total variance is proportional to the number of added @xmath30 bins  i.e .",
    ", to the length of the dispersion curve .",
    "the total length of the dispersion curve can be approximated by @xmath31 assuming the dispersion curve is close to linear .",
    "therefore , the ratio of the noise power summed by incoherent dedispersion and the noise power within the pulse ( assuming @xmath32 ) is @xmath33 immediately , we get that the choice of @xmath34 that maximizes sensitivity is @xmath35 regradless of pulse length @xmath36 . in order for the sensitivity loss to be less than a factor of @xmath37 ,",
    "we need both @xmath38 and @xmath39 this implies that @xmath40 this transforms to an important relation between the minimal pulse duration @xmath41 , the maximal dispersion time @xmath26 , and the sampling time @xmath12 .",
    "@xmath42 or , simplified , @xmath43    using a standard order of magnitude value for @xmath12 and @xmath26 , @xmath44 ( @xmath45 sampling ) and @xmath46 we get that @xmath47 this means that incoherent dedispersion analysis of pulses shorter than about @xmath48s usually loses sensitivity relative to coherent dedispersion .",
    "algorithmically , there are two leading approaches for inchorerent dedispersion of single - dish data streams .",
    "these are the the tree dedispersion @xcite and brute force dedispersion ( e.g. , @xcite;@xcite ; @xcite ) .",
    "the tree dedispersion algorithm , efficiently calculates the integrals of all the straight line paths with slopes between @xmath49 and @xmath50 through the input time vs. frequency matrix ( this is similar to the discrete radon transform , @xcite ) .",
    "the computational complexity of this algorithm is @xmath51 , where we use the notation @xmath52 ( note that @xmath2 and @xmath1 are the dimensions of @xmath17 ) .",
    "however , since the dispersion curve is not linear , the use of this method results in a substantial loss of sensitivity .",
    "this can be somewhat mitigated by applying the algorithm to many small sub - bands of the data , and then combining the results with a dedicated algorithm .",
    "this approach is not exact , and it increases the computational complexity of the algorithm . for more details on the sensitivity analysis and computational complexity of this algorithm we refer readers to @xcite .",
    "the brute force dedispersion algorithm simply scans all the trial dispersion measures , one at a time , integrating its path on the input map and finding curves with excess power .",
    "this method is exact , but has the high complexity of @xmath53 , where @xmath54 is the number of trial dispersion measures scanned ( note that @xmath55 ) . in order to expedite the search speed ,",
    "the algorithm was implemented on graphical processing units ( gpus ) , and this method is now capable of analyzing single beam data in real time @xcite . the maximal sensitivity , along with the possibility of real time analysis using gpus , makes this method likely to be the most popular algorithm for dedispersion .    here",
    "we present an algorithm that combines both maximal sensitivity and low computational complexity .",
    "a comparison of all these mentioned algorithms is summarized in table [ algorithmcomparisontable ] .",
    "lccc[h ] computational complexity & @xmath56 & @xmath57 & @xmath58 + information efficient & yes & yes & no + memory access friendly & yes & yes & yes + parallelization friendly & yes & yes & no",
    "the input to the fdmt algorithm is a two dimensional array of intensities , denoted by @xmath17 .",
    "the fdmt algorithm calculates the integral over all curves defined by equation [ eq : dtd ] .",
    "a dispersion curve can be uniquely defined by the arrival time of the signal at the lowest frequency ( @xmath24 ) and the time delay between the arrival times of the lowest and highest frequencies ( @xmath59 ) .",
    "therefore , the fdmt result can be expressed as a two dimensional array that contains the integrals along dispersion curves as a function of @xmath60 and @xmath61    @xmath62,f)},\\ ] ]    where @xmath63 and @xmath64 are the minimum and maximum frequencies in the base - band .    to compute the fdmt transform of the input , the algorithm works in @xmath65 iterations .",
    "the inputs of the @xmath66th iteration are the fdmt transforms of a partition of the original band into @xmath67 sub - bands of size @xmath68 frequencies .",
    "the outputs of @xmath66th iteration are the fdmt transforms of a partition of the original input into @xmath69 sub - bands of size @xmath70 frequencies .",
    "every two successive sub - bands are combined using the addition rule described below .",
    "after @xmath65 iterations , we have the fdmt over the whole band .",
    "the fdmt combining process of two successive sub - bands into @xmath71 , is given by the following addition rule : @xmath72 here , @xmath73 and @xmath74 are part of the output of the previous iteration and @xmath75 is the intersection time of the dispersion curve at the central frequency @xmath76 .",
    "@xmath75 is uniquely determined by the formula @xmath77",
    "where @xmath78    by definition , @xmath79 is the calculated sum over the unique dispersion curve between the coordinates @xmath80 and @xmath81 , and @xmath82 is the same for @xmath81 and @xmath83 . after an fdmt iteration",
    ", the only dispersion curve passing through @xmath84 , will be given by @xmath85 .",
    "for sufficiently early @xmath24 , the time @xmath75 will be smaller than zero . in that case",
    "we just copy  i.e , use the alternative addition rule @xmath86 the operation of one iteration of the algorithm is graphically illustrated in figure [ fig : additionrule ] .",
    "the only thing left to deal with is the data initialization .",
    "this is done prior to the first iteration , generating @xmath87 for every two consecutive frequencies .",
    "if the maximum dispersion delay between two consecutive frequencies is smaller than the width of a time bin , then we can use the simple initialization : @xmath88 where @xmath89 otherwise , the energy of the signal at some frequencies is not located at a single bin .",
    "this can be compensated for by two ways :    1 .   by computing partial sums over the time axis .",
    "i.e @xmath90 2 .",
    "if for a certain @xmath9 , the time delay within each single frequency bin is larger than one time bin , we can simply reduce the time resolution ( i.e. , bin ) . note that this implies @xmath91 , which we show in  [ sec : sensitivityincoherentdedispersion ] to be suboptimal in terms of sensitivity .    in the matlab and python codes we provide , we use option 1 . the maximal time delay within each frequency bin",
    "is uniquely determined by @xmath92 , the maximal @xmath9 we want to scan , and is given by @xmath93 therefore , this decision can be made prior to the computation .",
    "a pseudo code of fdmt is given in algorithm [ fdmt ] .",
    "in addition , we provide implementation for the algorithm in python and matlab .",
    "note that so far we did not treat rounding and binning issues , these are discussed in ",
    "[ subsec : implementataiondetailsfdmt ] and are implemented in the codes we provide .",
    "input : @xmath94 input matrix ( possibly packed ) , @xmath14 axis is continuous in memory .",
    "output : packed dispersion measure scores arranged in a two dimensional table @xmath95 where @xmath59 represents the dispersion measure axis .",
    "initiate the table by @xmath96    @xmath97 @xmath98 @xmath99 @xmath100 @xmath101 @xmath102 @xmath103      to calculate the computational complexity , we need to trace the number of operations done throughout the algorithm .",
    "the amount of additions in iteration @xmath66 is bounded from above by @xmath104 where @xmath105 is the number of sub - bands processed at the current iteration , and @xmath106 is the maximum time shift within a single sub - band at iteration @xmath66 for the curve with highest dispersion measure : @xmath107    @xmath108    as a first approximation , one can assume that the dispersion curve is almost linear , meaning that the number of @xmath59 s needed in iteration @xmath66 is roughly twice the number needed in iteration @xmath109 .",
    "in the last iteration , @xmath110 , and therefore , in iteration @xmath66 , @xmath111 the number of bands ( @xmath105 ) in each iteration is @xmath112 .",
    "therefore , under the approximation of almost linear dispersion ( or narrow band ) , the following approximation is correct : @xmath113 summing this for all iterations , and assuming @xmath114 is dominant in all iterations , and taking into account the number of entries in each added row ( @xmath2 ) , we get the complexity @xmath115 if we assume @xmath105 is dominant , we get @xmath116 therefore , the total complexity of the algorithm is bounded from above by : @xmath117    casting the complexity analysis of the fdmt algorithm with the more naturally defined @xmath118 , using @xmath119 and @xmath120 we get @xmath121 adding to the above the complexity of data preparation by stft , @xmath122 , and the fact that if we chose @xmath123 we can effectively bin ( or low pass , see  [ subsec : fdmtfftpulseprofile ] ) to size @xmath36 , we get @xmath124 here we can see that the data preparation complexity dominates the operation count of the algorithm whenever incoherent dedispersion is maximally sensitive ( i.e , @xmath125 ) .      in this subsection",
    "we consider implementation issues , such as rounding and binning , pulse profile convolution and using an arbitrary number of frequencies .",
    "in addition , it is important to implement the tricks of the trade , in order to transform the theoretical complexity reduction to a real speedup .",
    "the exact formulas written above need to take into account discreteness of both frequency and time axes . to keep the formulas readable",
    ", we did not include these considerations in the algorithm description and pseudo - code .",
    "however , we include them in the implementation we provide , and we advise readers who want to implement the fdmt to pay attention to the discretization process . that is because an incorrect choice might lead to a significant reduction in accuracy .",
    "an example of the most important discretization issue , is that when combining two sub - bands , the point @xmath75 , where the dispersion curve travels from one sub - band to the next might not be well defined .",
    "this can happen , because the dispersion curve might travel one bin between the end frequency of the first band @xmath126 and the start frequency of the second band @xmath127 .",
    "the implemented solution for this problem is to calculate two versions of @xmath128 , one with the end frequency of the lower sub - band , and the other with the start frequency of the upper sub - band . using the different versions of @xmath128 in the two different uses of @xmath75 ,",
    "we can account for a time shift between the added bands , approximating the dispersion curve better .",
    "* machine word utilization : * one can utilize the machine word width ( or the width of the sse registers ) to pack few instances of the dedispersion procedure into one computation ( since modern computers operate on machine words of 64 bits , this will result in a speedup factor of 48 depending on the number of bits per frequency and the pulse maximum allowed strength ) .    * memory access : * an important issue in run - time reduction , is the continuity of memory access .",
    "the fdmt algorithm never performs any re - ordering action along the time axis .",
    "therefore , it is recommended to store the time axis continuously in order to speed up the memory access operations .",
    "* different range of dispersions : * sometimes , we have a prior knowledge of the range of dispersion measures needed to scan . in that case , one can still employ the fdmt algorithm after an additional preparation of applying either a frequency dependent shift to the input ( according to some @xmath129 ) , or a coherent dedispersion of the signal ( using @xmath129 ) .",
    "* pulse profile:*[subsubsec : pulseprofile ] sometimes we have prior knowledge on the pulse width or profile ( might be a different profile for each frequency , like in pulse scattering ) . by applying a matched filter approach",
    ", one can convolve each frequency time series with the predicted profile for that frequency and employ the fdmt at the end . for wide enough pulse shapes",
    ", one might consider binning the time resolution .",
    "we note that convolution of the time axis with a uniform pulse profile ( for all frequencies ) commutes with the entire fdmt operation .",
    "therefore , we can test a few pulse profiles per fdmt without repeating the dedispersion process .    * dealing with the case of @xmath130 : * the algorithm presented above assumes that the number of frequencies is strictly a power of two .",
    "this assumption can be abandoned by slightly adjusting the addition rule to allow a merge of non - equal size sub - bands .",
    "the only change needed is to switch @xmath131 in equation [ eq : cf2f0 ] from being the middle frequency between @xmath19 and @xmath132 to be the border frequency between the sub - bands .",
    "* applying fdmt for other functional forms : * the dispersion equation ( eq . [ eq : dtd ] ) is used only in the preparation of @xmath133 .",
    "one can easily extend the fdmt algorithm to search for other functional forms , for example , @xmath134 the only required modification is to change the power of the frequency in equation [ eq : cf2f0 ] from @xmath135 to @xmath136 .",
    "furthermore , it could be extended to any family of curves that satisfies the condition that there is only one curve passing between any two points in the input data . using this , one can calculate the required @xmath133 , by finding the only curve passing through both @xmath80 and @xmath83 , and defining @xmath75 to be the intersection time of the curve with the frequency @xmath131 . while the complexity of the algorithm , may change with the functional form , for a sufficiently regular functional form",
    ", the complexity will close to @xmath137",
    "in modern computers and gpu s , memory access is frequently the bottleneck of many algorithms , especially when programming transforms , where the computational complexity is only slightly larger than the data size .",
    "efficient implementation of transform algorithms is non - trivial and requires architecture dependent changes in order to avoid cache misses ( in a general cpu setup ) or to avoid communication when using distributed computing .",
    "while it is probably possible to control the algorithms behavior as presented above , it is non - trivial to distribute the data between different processing units while avoiding duplication and communication issues .    in this subsection",
    ", we present a variant of the algorithm which is easily parallelized on all architectures and where the memory access pattern is as parallelization friendly as possible .    the algorithm , as it is described in  [ sec : fdmtalgorithm ] ,",
    "has only one core operation : adding a complete shifted `` time '' row .",
    "it is the shift operation which makes the data transfer and memory management of the algorithm challenging , and therefore we wish to eliminate shifts from the algorithm . in order to do that",
    ", we can fourier transform the time axis .",
    "this makes the shift operation become a multiplication with a `` shift vector '' which is the fourier transform of a shifted delta function . in this version ,",
    "all additions are of numbers from the same ( fourier transformed ) time coordinate .",
    "therefore , we can assign different parts of the ( fourier transformed ) time axis to different processing units , and consequently reduce the need for shared memory or data transport . at the end",
    ", we need to fourier transform back the time axis .",
    "we call this algorithm fft  fdmt and it is summarized in algorithm [ fdmtfft ] .",
    "tracking the data in this algorithm , we can see that there are only two `` global '' steps and that they are both transpose operations of the data . to perform all other steps of the algorithm",
    "we need only to access memory that is not larger than one row or one column of the input .",
    "since present l1 cache architectures can contain more than a typical row or column of data , the algorithm can be computing - power limited .",
    "the run - time of this algorithm on any machine is comparable to the run - time of two dimensional convolution , because of the similar number of operations and data access patterns .",
    "we note that in the basic preparation of radio data , one often applies fourier transforms ( for example , when applying filters or screening for radio frequency interferences ) . therefore ,",
    "if we have the computational ability to prepare the input table from the raw data , fft  fdmt is also feasible .",
    "input : @xmath94 input matrix ( possibly packed ) , @xmath14 axis is continuous in memory .",
    "output : packed dispersion measure scores arranged in a two dimensional table @xmath95 where @xmath59 represents the `` dispersion measure '' axis .",
    "initiate the table by @xmath138 initiate the `` shift vector '' @xmath139 where @xmath140 is a vector containing one at position @xmath20 and zeros everywhere else , @xmath141 is the fft operator , and @xmath142 is the index of the fourier transformed time axis .",
    "fourier transform the time axis @xmath143 transpose the data . after this action",
    ", the frequency and @xmath59 axes should be continuous in memory , time axis should be distributed across all computing units .",
    "@xmath97 @xmath98 @xmath99 @xmath100 @xmath144    b_f_0^f_2(,t ) & = + b_f_0^f_1(,t_1 ) & + b_f_1^f_2(,t - t_1)v(,t_1 )    transpose the data back .",
    "now , time is again continous in memory .",
    "perform inverse fourier transform on the time axis .",
    "@xmath145      the fft - fdmt algorithm is designed to increase the amount of computation per cache replacement . to completely optimize the algorithm for this property",
    ", we have to consider special implementation details like cache size and processing units communication geometry . though important to an efficient implementation of the algorithm ,",
    "these details are considered out of scope for this paper as they are architecture dependent .",
    "we note that all the details discussed in ",
    "[ subsec : implementataiondetailsfdmt ] are valid also for the fft - fdmt version , except for the changes listed below .",
    "* machine word utilization : * the long integer data type is the optimal choice for the regular fdmt algorithm in order to fully utilize the machine word capability . in",
    "the fourier transformed version of the algorithm , we have to use the complex floating point data type . using the floating point data type",
    ", we have to leave unused the bits of the exponent field , and leave some more bits unused to retain the floating point precision needed to perform the fourier transform operations .",
    "furthermore , some architectures such as gpus , have a clear optimization preference for the 32 bit floating point data type .",
    "however , it is possible to pack another algorithm instance in the complex field of the input vector .",
    "since the result of the fdmt algorithm is real ( as a sum of real numbers ) , packing another input to the imaginary part of the input is possible . the imaginary part of the result will be the second algorithm instance .",
    "* pulse profile : * [ subsec : fdmtfftpulseprofile ] in addition to the ability to test several pulse profiles per fdmt operation , as explained in ",
    "[ subsubsec : pulseprofile ] , we can further exploit the use of the fourier transformed time domain . if the pulse width is slightly larger than one bin , reducing the computational load by binning loses information . instead",
    ", we can effectively apply a low - pass filter on the time axis by either keeping less ( time - domain ) frequencies or multiplying with a filter .",
    "this can be both more sensitive than binning the time axis and more efficient than having a high sampling rate .    * handling large dispersion measures : * if the maximum dispersion broadens the pulse to more than one time bin per frequency bin , the initialization phase of the algorithm inflates the data from size @xmath146 to size @xmath147 ( note that the use of @xmath148 is losing sensitivity , and therefore this part is not considered a crucial part of the algorithm ) .",
    "the partial sum operation of the initialization phase is equivalent to an application of a low - pass filter on the time axis .",
    "this allows natural reduction of computation and memory by saving a differential amount of fouriered time bins for different @xmath59 s .",
    "this can be used in the case of large dispersion measures to reduce the algorithm s complexity from @xmath149 to @xmath150 .    * zero padding : *",
    "since convolution is a cyclical operation , all the shifts done in this algorithm are cyclical shifts .",
    "therefore , we have to pad the time axis with @xmath114 zeros prior to the fourier transform . this operation can increase by a factor of two the complexity of the algorithm if @xmath151 . to avoid this",
    "we can choose @xmath152 .",
    "this is usually possible if the size of the input table is not too close to the maximum memory ( or cache ) capacity of the machine used .",
    "accurate benchmarking of algorithms should use a mature code , and contain architecture dependent adaptations .",
    "however , it is important to demonstrate that the code we present , running on a single standard cpu , is competitive with the brute force dedispersion implementations on gpu s .",
    "therefore , we provide a simple benchmark for the provided code .",
    "the benchmark we use is the run - time of performing fdmt on data with the following properties : @xmath153 , @xmath154 and @xmath155 .",
    "this volume of input is similar to the one used in the `` toy observation '' defined in @xcite , @xmath156 , @xmath157 and @xmath158 . although , we modified the partition between @xmath159 , and increased @xmath3 by a factor of two usually looses sensitivity ( see  [ sec : sensitivityincoherentdedispersion ] ) , and the number of frequencies is usually larger than @xmath160 . ] .",
    "the run - time we achieve on this data is 3.5 seconds , on a standard intel core i-5 4690 processor .",
    "for example , these numbers can represent a real time dedispersion of 8 seconds of input data with 40mhz bandwidth and 1024 dispersions . to get this benchmark , we pack five instances of the algorithm to the 64 bit machine word , allocating 12 bits to each instance .",
    "the resulting packed data has dimensions @xmath161 , and serves as input to the fdmt implementation . using this scheme",
    ", we find that our run - time is already shorter than that of the state of the art brute force implementations on gpu s reported in @xcite . a comparison between the run - times is shown in table [ runtimecomparisontable ] .",
    "lccc    machine used & intel core i5 4690 & tesla c1060 gpu & tesla c1060 gpu + programming language & python ( anaconda + accelerate ) & c & c + number of instances packed & 5 & 1 & 1 + runtime & 3.5s & 4.8s & 2.1s + @xmath162 & @xmath163 & @xmath164 & @xmath164 + @xmath165 & @xmath166 & @xmath167 & @xmath167 + algorithm used & fdmt ( non - fft version ) & brute force & brute force + algorithm theoretical complexity & @xmath168 & @xmath165 & @xmath165",
    "since some interesting transient sources such as pulsar giant pulses are in the regime @xmath169 , it is of importance to find a feasible and sensitive algorithm for their exact dedispersion .",
    "coherent dedispersion was , until now , the only sensitive alternative .",
    "the noise power summed when searching for a pulse that is dispersed with a dispersion measure @xmath9 is @xmath170 the noise power summed when searching for a non - dispersed pulse is @xmath23 , and therefore the largest dispersion tolerable for sensitive pulse detection satisfies @xmath171 therefore , for sensitive detection , the number of dispersion measure trials we need to process is @xmath172 the convolution operation performed for coherent dedispersion can be efficiently calculated with fourier transforms of size @xmath173 , and therefore the complexity of coherent dedispersion is : @xmath174 noting that the computational complexity of coherent dedispersion scales with @xmath175 and that of incoherent dedispersion scales with @xmath176 , we see that using coherent dedispersion is not computationally efficient for resolved pulses ( i.e @xmath177 ) .      in order to have both the detection sensitivity of coherent dedispersion and the computational complexity of fdmt",
    ", we propose the following solution : coherently dedisperse the raw signal with coarse trial dispersion values ( with steps @xmath178 ) , and then apply stft and absolute value squared , followed by fdmt with the maximal dispersion being the next coarse - trial coherent dedispersion .",
    "this process ensures that the fdmt will not lose sensitivity , relative to coherent dedispersion .",
    "we denote by @xmath179 the number of bins of length @xmath12 that a delta function pulse will spread upon when dispersed by @xmath178 : @xmath180 as shown in ",
    "[ sec : sensitivityincoherentdedispersion ] , in order to retain sensitivity the maximal dispersion residual to be processed by the following fdmt must be bounded from above by @xmath181    therefore , the number of trial dispersions we need to coherently dedisperse is @xmath182 this process is approaching maximum sensitivity , and its complexity is : @xmath183 simplifying , we get the computational complexity for detection of a pulse of length @xmath36 : @xmath184 this complexity is near optimal , because the number of uncorrelated scores is @xmath185 , which is only a logarithmic factor smaller than the computational complexity .",
    "therefore , there is not much room for further reduction of computational complexity .",
    "the algorithm is summarized in algorithm [ alg : algorithmcoherent ] .",
    "input : antenna voltage series @xmath186.output : score table for all dispersions @xmath187 with steps @xmath36 and all exit times @xmath188 with steps @xmath36 .",
    "create the signal @xmath189 by applying the filter @xmath190 to @xmath186 .",
    "apply stft with block size @xmath36 on @xmath189 , to obtain @xmath17 .",
    "apply fdmt to @xmath30 , with maximal @xmath191 , and output the partial result @xmath192 for @xmath193 with steps @xmath36 , and @xmath24 in the range @xmath194 $ ] with steps @xmath36 .      using this algorithm , it is possible to perform blind searches for pulses with duration in the @xmath195 ",
    "@xmath196ms regime ( which implies @xmath197 for standard searches ) .",
    "together with the low computational complexity of fdmt , this can be efficiently employed in blind searches for frbs and giant pulses , both reducing the computational load , and increasing sensitivity .",
    "in this section , we analyze the complexity of blind searches of short astrophysical signals with radio interferometers using the fdmt .",
    "we first calculate the computational and communication complexity of applying the fdmt algorithm after the imaging operation .",
    "afterwards , we offer a way to reduce the communication complexity by applying the fdmt algorithm after the correlator operation and before the imaging operation .",
    "we show that in principle , using our scheme , it is possible to use modern radio interferometers to detect and locate short astrophysical pulses in real - time without the knowledge of the dispersion measure .",
    "we start by introducing some additional notation . in the scenario of a blind dispersed pulse search with a radio interferometer",
    ", we have signals of several telescopes .",
    "we denote the raw voltage signal from the @xmath198th telescope by @xmath199 .",
    "we further denote by @xmath200 the number of antennas , and by @xmath201 the number of distinct locations in the sky , or pixels , in the optimal image resolution of the interferometer . the desired statistic that we need to calculate for efficient detection",
    "is given by : @xmath202 where @xmath203 represents the time delay of the signal at antenna @xmath66 , @xmath204 is the dedispersion filter needed to be convolved with to correct for dispersion , and @xmath205 represents convolution .",
    "we wish to calculate this score for all combinations of sky positions ( which we denote their number by @xmath206 ) , dispersions @xmath207 , and start times @xmath208 .",
    "therefore , the number of calculated scores is @xmath209 .",
    "we estimate the number of computations required by using general modern radio interferometer parameters such as : @xmath210 , @xmath46 , @xmath211 . using @xmath212 antennas of diameter @xmath213 , spread out to a maximal baseline of @xmath214 .",
    "@xmath215 , @xmath216 , @xmath217 , @xmath218 we get @xmath219 scores per second , which requires a computing power of @xmath220 to process .",
    "the computational requirement of the solution we propose in the next section is only logarithmically larger than this computation rate .",
    "therefore , it is feasible with current facilities to perform a blind search using modern radio interferometers .",
    "for example , the computing facility of the australian commonwealth scientific and industrial research organisation ( known as csiro ) has computing power equivalent to 260 tflop / s .",
    "there are two existing approaches to blind search interferometry .",
    "the first is to add antennas incoherently and then dedisperse .",
    "this process loses the angular resolution and reduces the sensitivity by a factor of @xmath221 .",
    "however , this is considered to be computationally feasible , and it is sensitive to the interferometer s entire field of view .",
    "the second approach is to `` beam - form '' and dedisperse , i.e for every searched location @xmath222 , shift all the signals from all antennas with the correct shift for position @xmath222 , add them up , and perform dedispersion . to mitigate the computational load of this process ,",
    "it is custom to use only a small subset of all @xmath206 sky locations at a time , considerably reducing the overall survey speed of the instrument .",
    "another possibility is to use a combination of both approaches by dividing the interferometers to closely packed stations , beam - forming all stations to a subset of all possible directions , and then incoherently adding the stations .",
    "all methods trade the computational un - feasibility with a significant sensitivity reduction .",
    "a consideration of those approaches can be found in @xcite .",
    "first , we quickly review the standard imaging process of interferometry , using the approximations of flat sky and short observation .",
    "assuming there is no dispersion , the desired score is @xmath223 denoting by @xmath224 the fourier transform of @xmath20 . to efficiently calculate this score for every pixel @xmath225 , it is useful to use the relation @xmath226 denoting by @xmath227 the two dimensional location of antenna @xmath198 on the plane ( under the approximation of having all antennas on the same plane ) .",
    "now , we can calculate the score at all positions @xmath222 at the same time , by a two dimensional fourier transform of the array : @xmath228 @xmath229 where @xmath230 is equal to one if @xmath231 ( to the desired approximation ) , and zero otherwise .",
    "the summation in equation [ eq : interferometerfxscore ] is a sum of squares .",
    "this means that coherent dedispersion operations must be performed before correlating is referred to as `` correlating '' in the literature , and is calculated by a computing infrastructure usually called `` the correlator '' . ] , because the imaging process calculates the sum of square absolute values of frequencies .",
    "incorporating dedispersion into this , we can see that the block size @xmath34 we used earlier is transformed in this framework to the size of the fourier transform done by the correlator . as a result",
    ", the imaging process can not be done simultaneously in all frequencies , as different frequency sets should be used for different dispersion measures .",
    "naively , this means that we need to image separately at each frequency , performing many two dimensional fourier transform imaging operations , followed by an fdmt for every pixel .",
    "denoting the complexity of the @xmath66th step of the algorithm by @xmath232 , the complexity of the coherent dedispersion + stft of all individual antennas is @xmath233 the complexity correlating all pairs of antennas is @xmath234 the complexity of the imaging process is @xmath235 the complexity of the fdmt algorithm ( without the stft part which was already done in this context ) is @xmath236 so , the total complexity of this process is @xmath237    while the complexity of this process is indeed `` optimal '' , in the sense that it is only a logarithmic factor larger than the number of independant results , implementing this will result in a reduced computational efficiency .",
    "this is due to data transport between the imaging stage and the dedispersion stage . between these stages , @xmath238 complex numbers are being transported .",
    "this could be mitigated by the fact that dedispersion can be done before the imaging operation , if the condition @xmath239 holds does nt hold , the resulting image is said to suffer from a `` chromatic aberration '' . ] .",
    "if the band is wide , this condition will not hold for pairs of far away antennas . in this case , it is necessary to split the frequencies into sub - bands that are narrow enough to maintain condition [ eqn : nochromatic ] .",
    "since the fdmt s input and output dimensions have the same size , the communication complexity of the proposed solution is @xmath240 , which should ( if @xmath241 ) make the algorithm s run - time be computation limited , and thus feasible .",
    "another interesting point , is that if we are in the regime of @xmath242 , then the fdmt is volume shrinking , and performing it only after the imaging process will result in excessive computation in the imaging stage .",
    "this scenario is sometimes plausible , for example , when looking for pulsars in a globular cluster , where we sometimes have a relatively good guess of the dispersion measure , or if we are using the choice of @xmath243 ( with some sacrifice of sensitivity , if @xmath244 ) ,    this process is summarized in algorithm [ interferometersalgorithm ] .",
    "input : antenna voltage series output : @xmath245 for every time , dispersion , and sky location .",
    "standard choice of @xmath34 is @xmath36 .",
    "create the signal @xmath246 by convolving the @xmath247 antenna signal with the dedispersion filter with index @xmath248 .",
    "apply stft with block size of @xmath34 on the signal @xmath246 , to obtain @xmath249 generate the time vs. frequency map of all the frequenciesthat enter into the same cell @xmath250 .",
    "apply fdmt with maximal @xmath251 data `` transpose operation '' , each processing unit now holds all the @xmath252 @xmath253 cells , for the same @xmath254 .",
    "perform two dimensional inverse fourier transform to calculate @xmath255 if for some point , the power is statistically significant .",
    "we present the fdmt algorithm , that performs exact incoherent dedispersion transform with the complexity of @xmath58 .",
    "we show that regular implementation tricks of the trade can be combined with the fdmt algorithm to achieve significant computation speedup .",
    "we also present a variant of the fdmt algorithm that is slightly more computationally intensive , but concentrates all memory access operations to two global transpose operations , and might present further speedup on massively parallel architectures such as gpus .",
    "we show that the fdmt algorithm dominates all other known algorithms for incoherent dedispersion and has comparable complexity to the signal processing operations required to generate its input data .",
    "therefore , we conclude that incoherent dedispersion can now be considered a non - issue for future surveys .",
    "we provide implementations of the fdmt algorithm in high level programming languages , with a faster runtime than the state of the art implementations of brute - force dedispersion on gpus .",
    "we further present an algorithm that bridges the gap between coherent and incoherent dedispersion , and show that the computational complexity of this algorithm is orders of magnitude lower than that of coherent dedispersion for pulses of resolvable duration . using this algorithm",
    ", it will be possible to perform blind searches for frbs and giant pulse emitting pulsars with the sensitivity of coherent dedispersion searches .",
    "last , we compute the operation count for a blind search of short astrophysical searches with modern radio interferometers and arrive to the conclusion that it is computationally feasible using existing facilities .",
    "bz would like to express his deep thank to gregg halinnan for introducing him the problem of dedispersion .",
    "the authors would like to express their thanks to avishay gal - yam , shrinivas kulkarni , matthew bailes , david kaplan , ora zackay and gil cohen for their useful comments and advice regrading the paper .",
    "e.o.o . is incumbent of the arye dissentshik career development chair and is grateful to support by grants from the willner family leadership institute ilan gluzman ( secaucus nj ) , israeli ministry of science , israel science foundation , minerva and the i - core program of the planning and budgeting committee and the israel science foundation ."
  ],
  "abstract_text": [
    "<S> astronomical radio bursts disperse while traveling through the interstellar medium . </S>",
    "<S> to optimally detect a short - duration signal within a frequency band , we have to precisely compensate for the pulse dispersion , which is a computationally demanding task . </S>",
    "<S> we present the fast dispersion measure transform ( fdmt ) algorithm for optimal detection of such signals . </S>",
    "<S> our algorithm has a low theoretical complexity of @xmath0 where @xmath1 , @xmath2 and @xmath3 are the numbers of frequency bins , time bins , and dispersion measure bins , respectively . unlike previously suggested fast algorithms our algorithm conserves the sensitivity of brute force dedispersion . </S>",
    "<S> our tests indicate that this algorithm , running on a standard desktop computer , and implemented in a high - level programming language , is already faster than the state of the art dedispersion codes running on graphical processing units ( gpus ) . </S>",
    "<S> we also present a variant of the algorithm that can be efficiently implemented on gpus . the latter algorithm s computation and data transport requirements are similar to those of two - dimensional fft , indicating that incoherent dedispersion can now be considered a non - issue while planning future surveys . </S>",
    "<S> we further present a fast algorithm for sensitive dedispersion of pulses shorter than normally allowed by incoherent dedispersion . in typical cases </S>",
    "<S> this algorithm is orders of magnitude faster than coherent dedispersion by convolution . </S>",
    "<S> we analyze the computational complexity of pulsed signal searches by radio interferometers . </S>",
    "<S> we conclude that , using our suggested algorithms , maximally sensitive blind searches for such pulses is feasible using existing facilities . </S>",
    "<S> we provide an implementation of these algorithms in python and matlab . </S>"
  ]
}