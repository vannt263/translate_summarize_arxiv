{
  "article_text": [
    "constraint handling rules  @xcite ( chr ) provide a natural framework for extending logic programming with bottom - up evaluation which , together with other qualities of chr , makes it interesting to consider chr for language processing . in general ,",
    "constraint solving techniques have proved to be important for expressing and solving linguistic problems .    in order to promote and facilitate language processing in chr",
    ", we propose a standard for a grammar notation built upon chr , called chr grammars or chrg for short . at a first glance",
    ", chrg may be seen as a bottom - up counterpart to the well - known definite clause grammars  @xcite ( dcg ) , but the chrg formalism includes additional facilities that are not obvious or possible in dcg .",
    "most notably , the notation supports context - sensitive rules that may consider arbitrary symbols to the left and right of a sequence be matched .",
    "counterparts to the different sorts of rules of chr ( propagation , simplification , and simpagation ) are present in chrg and grammar rules may also refer to extra - grammatical hypotheses in both head and body of rules .",
    "chrgs are implemented by a compiler into chr analogously to the way dcgs usually are translated into prolog .",
    "this provides a seamless integration with chr and prolog , so that the high - level notation of chrg is combined with the sort of tools and libraries that are relevant for practical applications .",
    "when executed as a parser , a chrg is robust of errors and provides an elegant handling of ambiguity : rules apply bottom - up as long as possible and grammar nodes corresponding to the different parses can be read out of the final constraint store .",
    "the context - sensitive rules provide a high degree of expressiveness both for simplifying the overall grammar structure and for modeling phenomena such as long - distance reference and coordination in natural language .",
    "context - sensitivity can also be used for classifying lexical tokens in a way quite similarly to the component called a tagger in language processing systems .",
    "the possibility to apply extra - grammatical constraints in grammar rules makes it straightforward to express abductive language interpretation with integrity constraints written as chr rules ; no extra meta - level overhead is necessary .",
    "facilities from assumption grammars ( ag ) are included in chrg in a similar way ; ags are in many ways similar to abduction but provide also primitive scoping mechanisms not found in the abductive approach .",
    "the chrg system accepts any grammar whose context - free backbone is without empty - productions and loops and it has no problems with left - recursion as is the case for dcg .",
    "the efficiency is highly dependent on the grammar : for locally unambiguous grammars ( to be defined ) , execution is linear and for a general context - free grammar cubic similarly to other general parsing algorithms .",
    "the chrg system is implemented in sicstus prolog and is available on the internet  @xcite .",
    "the following section  [ background - section ] provides the background and motivation of this work and reviews important , related work .",
    "section  [ chrg - section ] describes syntax and semantics of the chrg notation together with the principles used for its implementation in chr ; section  [ examples - section ] shows examples of chrgs .",
    "the approach to abductive language interpretation is described in section  [ abduction - section ] , firstly at an abstract level as a general method for transforming abductive language interpretation into a deductive form which is not tied to a specific grammar formalism .",
    "we then show how the principles can be applied in chrg in a version for unambiguous grammars and an extension for ambiguous grammars ( some extra machinery is needed as to avoid cluttering up abducibles for different parses ) .",
    "section  [ assumption - grammar - section ] explains the implementation of assumption grammars in chrg .",
    "section  [ summary - section ] gives a summary and discusses future perspectives .",
    "our work can be described as filling out the lower right corner in the following commutative diagram :    @xmath0    definite clause grammars  @xcite ( dcgs ) have been an integral component of most prolog systems for decades and are basically a derivative of colmerauer s metamorphosis grammars  @xcite that were designed together with one of the first versions of prolog .",
    "dcgs are syntactic sugar for prolog programs which in their now standard implementation represent strings by means of difference lists .",
    "when executed as a parser , a dcg inherits prolog s top - down strategy with backtracking for checking out different alternatives .",
    "dcgs are very popular as they are very easy to write down and get running , especially for toy languages and not too complicated fragments of , say , natural language or programming languages .",
    "dcgs put very few restrictions on the context - free backbone of the grammar , as do most traditional methods for writing parsers ; see , e.g. ,  @xcite .",
    "the main drawbacks of dcgs are    * lack of robustness , if the string to be analyzed does not conform with the grammar the result is simply failure , * backtracking may lead to combinatorial explosions , so a grammar for a larger application needs to be tuned very carefully with cuts and the like to avoid this , * lacking ability to handle left - recursive grammars .    to compensate partly for this , different authors ( not referenced here ) have proposed compiling dcgs into bottom - up parsers by traditional means .",
    "the chr language  @xcite was introduced as a tool for writing constraint solvers in a declarative way for traditional constraint domains such as real or integer numbers and finite domains .",
    "chr has proved to be of more general interest and is available as extension of , among others , sicstus prolog  @xcite .",
    "the chr web pages  @xcite contain a growing collection of applications .",
    "being of special interest to language processing , @xcite have shown that chr adds bottom - up evaluation to prolog and a flexibility to combine top - down and bottom - up computations ; @xcite have taken this a step further showing that abductive logic programs can be expressed directly in chr .    the metaphor given by the diagram above is very precise as we propose a notation that can be seen as a layer of syntactic sugar over chr rules that parses bottom - up .",
    "a string is entered as a set of initial constraints and the rules apply over and over producing more and more syntax nodes from those already found . in this way",
    "we achieve a robustness not found in dcgs and avoid also the problems with backtracking and left - recursion ; furthermore , this approach gives an inherent and elegant treatment of ambiguity without backtracking . in our approach ,",
    "a string is encoded by means of integer word boundaries as also used in datalog grammars  @xcite and the classical paper on dcgs  @xcite .",
    "it is interesting to compare our chrg formalism with constraint multiset grammars  @xcite ( cmgs ) that can apply also to multidimensional languages such as diagrams",
    ". the rules of cmg include also context - conditions which seems capable of expressing the sort of context conditions included in chrg .",
    "meyer  @xcite has applied chr for parsing of cmgs with techniques very similar to ours , however without considering the compilation of a grammar notation into chr .",
    "recent work by  @xcite has proposed to apply a variant of linear logic for parsing cmgs .",
    "morawietz  @xcite has implemented deductive parsing  @xcite in chr and shown that a specialization of a general bottom - up parser for context - free rules leads to propagation rules similar to those produced by our compiler .",
    "our proposal for a grammar notation upon chr was put forward in  @xcite and presented briefly in  @xcite ; the chrg system has also been presented as  @xcite .",
    "an attempt to characterize the grammar of ancient egyptian hieroglyph inscriptions by means of context - sensitive rules in chrg is given by  @xcite .    in  @xcite , we have applied chr for parsing with error detection and correction in which we employ chrs ability to combine top - down and bottom - up computations , cf .",
    "@xcite : parsing proceeds bottom - up as described in the present paper and when symptoms of an error are seen , a top - down sweep for correcting the string is started , so that the parser may continue .",
    "the notion of constraints , with slightly different meanings , is often associated with language processing .",
    "`` constraint grammars '' and `` unification grammars '' are often used for feature - structure grammars , and constraint programming techniques have been applied for the complex constraints that arise in natural language processing ; see , e.g. ,  @xcite for introduction and overview .",
    "one approach using chr for this purpose in hpsg is  @xcite .",
    "blache  @xcite proposes a formalism with specific kinds of constraints for natural language which also seems to fit with an implementation in chr .",
    "this approach combines constraints on the order in which things must occur , on which things imply the presence or absence of other things , etc .",
    "we have not tried to model this in chrg , but chrgs contexts and possible use of arbitrary hypotheses seems to be suited .",
    "see also  @xcite for similar approaches .",
    "our approach to abductive language interpretation using chr grammars is based on extension of our previous work  @xcite who showed how an abductive logic program with integrity constraint ( but limited use of negation ) can be rewritten as a chr program ; basically , the idea is to declare abducibles as constraints and write integrity constraints as chr rules , and abduction works so to speak for free without any meta - level interpreter which usually is associated with abduction .",
    "we are not aware of other approaches to abductive language interpretation using chr in this way .",
    "the advantages of abduction for language interpretation  as theoretical model or as implementation  has been recognized be several authors , e.g. ,  @xcite just to mention a small fraction , and this is taken in the present work as an established fact .",
    "a conventional implementation of dcgs  @xcite applies a purely deductive interpretation method , synthesizing the meaning of a phrase from the meanings of its subphrases .",
    "this works well when context is known and every piece of information to be extracted is expressed in an explicit way .",
    "abduction is in favour for more subtle meanings given , e.g , by linguistic implicature , and when the attention is on context comprehension . in",
    "@xcite we have related stalnaker s",
    "@xcite view of context comprehension to abductive language interpretation .",
    "one way to achieve abduction with logic grammars is , of course , to interpret a dcg using an interpreter for abductive logic programs such as  @xcite ; we have not made any benchmark tests but we expect this to be far less efficient than what is described in the present paper",
    ". an interesting variation of our method is to combine the core of our abduction method with dcgs as shown in example  [ dcg - with - abduction - example ] below : the dcg is processed in the usual way but it may refer to abducible predicates defined as chr constraints .",
    "an earlier paper  @xcite on our approach to abductive language interpretation discusses in more detail the relation to other abduction methods . in  @xcite",
    "we have considered how our chr versions of abduction and assumptions  @xcite with integrity constraints can be used as an extension to prolog .",
    "first - order logic is assumed ; variables are typically denoted by letters such as @xmath1 , @xmath2 , @xmath3 or with capital letters in typewriter font in programming notation ; constants are typically denoted by letters such as @xmath4 ; notation with a horizontal bar as in @xmath5 refers to a sequence of variables , similarly @xmath6 for sequences of constants and @xmath7 for sequences of terms .",
    "we give the necessary definitions and properties for constraint handling rules ( chr ) in a slightly simplified form and refer to a general introduction elsewhere @xcite .",
    "two disjoint sets of constraint predicates are assumed , called _ defined constraints _ (",
    "i.e. , defined by the current program ) and _ built - in constraints _ , the latter including `` @xmath8 '' , `` @xmath9 '' , @xmath10 , and @xmath11 . atoms of constraint predicates are ( with a slight overloading of usage ) called ( _ defined _ and _ built - in _ ) _ constraints_. conjunctions are written by either `` @xmath12 '' or , in programming notation , a comma .",
    "the following chr rules are recognized :    progagation rules : :    @xmath13 , simplification rules : :    @xmath14 , and simpagation rules : :    @xmath15 being an abbreviation    for @xmath16 .    each @xmath17 ( and @xmath18 ) is called the _ head _ of the rule and is a conjunction of one or more defined constraints indicated by commas , @xmath19 the _ guard _ being a conjunction of built - in atoms , and @xmath20 the _ body _ being a conjunction of constraints .",
    "a guard corresponding to @xmath10 can be left out together with the vertical bar .    in examples and extensions to the framework we apply occasionally the possibility in the implemented chr system of including arbitrary prolog code in rule bodies , including those auxiliaries of the chr system that goes beyond a declarative semantics as well as the abstract , procedural semantics given below .",
    "the same goes for the application of so - called deep guards in which constraints are called in the guard . in such cases we supply suitable informal descriptions .",
    "a chr _ program _ is a finite set of rules with its declarative semantics given as the conjunction of a logical reading of each rule as follows ; the built - in `` @xmath8 '' and `` @xmath9 '' have their standard syntactic meaning .",
    "propagation rules and simplification rules in the format above are taken as abbreviations for the following respective formulas :    @xmath21    @xmath22 where @xmath5 refer to the variables in @xmath17 , @xmath23 to those in @xmath19 not overlapping with @xmath5 , and @xmath24 to those in @xmath20 not overlapping with @xmath5 ; for simplicity it is assumed that @xmath23 and @xmath24 do not overlap ; see  @xcite for a generalization . a rule with @xmath24 empty",
    "is said to be _ range - restricted_.    a _ state _ is defined to be a set of constraints and an _ initial _",
    "state for a _ query _ @xmath25 ( being a conjunction of constraints ) is @xmath25 itself ; we do not distinguish between sets and conjunctions .",
    "we distinguish a special state referred to as _ failure _ and any derivation step ( below ) leading to this state is said to be _",
    "failed_.    to _ execute a(n instance of a ) body _",
    "@xmath26 where @xmath27 are defined constraints , @xmath28 and @xmath29 built - in s with predicates `` @xmath8 '' and `` @xmath9 '' , resp .",
    ", in state @xmath30 , consists of forming the state @xmath31 where @xmath32 is a common , most general unifier for @xmath28 .",
    "in addition , any @xmath33 with @xmath34 and @xmath35 nonunifiable is removed . however ,",
    "if no such @xmath32 exists or @xmath36 contains @xmath37 for some term @xmath35 , the execution fails .",
    "execution of a body containing @xmath11 fails .    for an instance @xmath13 of a propagation rule",
    ", we say that it _ can be applied _ in a state @xmath30 whenever @xmath38 and @xmath39 , and to _ apply _ it means to execute @xmath20 leading to a new state .",
    "when referring to an application of a rule @xmath13 of the current program , this refers to some application of an instance @xmath40 where @xmath32 is a substitution to the variables of @xmath17 ( referred to as @xmath5 above ) .",
    "no rule can be applied to a failure state .",
    "application of simplification rules is defined in a similar way except that the head constraints are removed from the state before the body is executed .",
    "a _ derivation _ for a query @xmath25 with program @xmath41 is a sequence of states @xmath42",
    "where each @xmath43 , @xmath44 is the result of applying a rule of @xmath41 to @xmath45 with @xmath46 .",
    "a given propagation rule can not be applied to the same constraints more than once .",
    "a state in a derivation is _ final _ if it is not failed and no rule can apply , and in this case the derivation is _ successful _ ; a derivation ending with a failure state is said to be _",
    "failed_.    in practice , chr programs are executed in a specific left - to - right order which may or may not restrict the final result . to define this , we must pay attention to the order in which conjunctions are written and the textual order of the rules ; the actual computation rule applied in , say , the sicstus prolog version of chr  @xcite is quite complicated but the following simplified characterization is a good approximation that covers most cases",
    "lr - derivation _ is one in which :    * a state is a sequence of constraints @xmath47 . * a built - in constraint is considered ( as specified above ) only when it appears as @xmath48 and this takes priority over rule applications .",
    "* for all @xmath49 ,",
    "no rule application involves any of @xmath50 if another application of a rule is possible .",
    "* rules are tested for applicability in the textual order in which they occur in the program .",
    "* whenever a rule is applied in a step , requiring constraints @xmath51 to be removed from and @xmath52 ( as a sequence given by textual order in rule body ) to be added to a state @xmath53 , the new state is @xmath54 where @xmath55 is @xmath30 with @xmath51 removed and with the order of the remaining constraints preserved .    this principle is also referred to as the _ lr computation rule _ and it implies that there is only one possible derivation .",
    "the version of chr that underlies the implemented chrg system  @xcite performs lr - derivations . a derivation without this computation rule is called _ unrestricted_.",
    "the following correctness properties for chr derivations follow from  @xcite :    let @xmath41 be a chr program , @xmath25 a ground query , and @xmath56 a final state in a derivation for @xmath25",
    ". then @xmath57 and @xmath58 .",
    "let @xmath41 be a chr program and @xmath25 a ground query which has at least one finite derivation and let @xmath56 be a conjunction of constraints so that @xmath59",
    ". then there exists a derivation with final state @xmath60 so that @xmath61 .",
    "the following consequences are relevant for soundness and completeness of bottom - up parsers written in chr .",
    "let @xmath41 be a chr program consisting of range - restricted propagation rules only and let @xmath56 be a final state for a ground query @xmath25 .",
    "then @xmath56 is the least herbrand model for @xmath62 .",
    "in our treatment of abduction we may occasionally arrive at rules that are not range - restricted so the following refinement is useful :    let @xmath41 be a chr program consisting of propagation rules only and let @xmath56 be a final state for a ground query @xmath25 .",
    "then there exists a ground instance of @xmath56 which is a least herbrand model for @xmath62 .    when using chr for checking integrity constraints we rely on :    let @xmath41 be a chr program with the property that any derivation with @xmath41 is finite .",
    "we have , then , that @xmath63 for any query @xmath25 is consistent if and only if there is a successful derivation for @xmath25 with @xmath41 .",
    "soundness of disambiguation of grammars by replacing propagation rules by simplification rules follows from :    let @xmath41 be a chr program consisting of propagation rules , and @xmath64 derived from @xmath41 by changing some rules into simplification or simpagation rules , and let @xmath30 and @xmath55 be final states for a given query with the programs @xmath41 and @xmath64 .",
    "then @xmath65 .",
    "a _ chr grammar _ , or _",
    "chrg _ for short consists of finite sets of _ grammar symbols _ and _ constraints _ and a finite set of _ grammar rules _ , each of which may be a _ propagation ( grammar ) rule _",
    ", a _ simplification ( grammar ) rule _ , or a _ simpagation ( grammar ) rule_.    an _ attributed grammar symbol _ , for short called a _ grammar symbol _ , is formed as an atom whose predicate symbol is a grammar symbol ; a grammar symbol formed by token/1 is called a _ terminal _ , any other grammar symbol a _",
    "nonterminal_. sequences of terminal symbols token(@xmath66 ) , @xmath3 , token(@xmath67 ) may also be written ; if ground , such a sequence is called a _ string_.    a few grammar symbols and operators are given a special meaning ( made precise later ) :    * `` ... '' and `` @xmath49 ... @xmath68 '' with @xmath69 called _ gaps _ supposed to match sequences of arbitrary length , resp .",
    ", length @xmath70 with @xmath71 , * `` all '' referring to the entire input string , which may be useful together with : * `` @xmath72 '' , called _",
    "parallel match _",
    ", supposed to match strings that are matched by @xmath73 as well as @xmath74 .",
    "when referring to a sequence of grammar symbols , this may involve applications of the parallel match operator .",
    "a propagation rule is of the form @xmath75 the part of the rule preceding the arrow @xmath76 is called the _ head _ , @xmath19 the _ guard _ , and @xmath77 the body ; @xmath78 are sequences of grammar symbols and constraints so that @xmath74 contains at least one grammar symbol , and @xmath77 contains exactly one grammar symbol which is a nonterminal ( and perhaps constraints ) ; @xmath73 ( @xmath79 ) is called _ left ( right ) context _ and @xmath74 the _ core _ of the head ; @xmath19 is a conjunction of built - in constraints as in chr and no variable in @xmath19 can occur in @xmath77 . if left or right context is empty , the corresponding marker is left out and if @xmath19 is empty ( interpreted as true ) , the vertical bar is left out . the convention from dcg is adopted that constraints ( i.e. , non - grammatical stuff ) in head and body of a rule are enclosed by curly brackets ) .",
    "gaps and parallel match are not allowed in rule bodies .",
    "there is a restriction on the use of gaps in the core of a head so that the core must be _ bounded _ defined in the following way .",
    "this ensures that the core matches a specific interval of word boundaries when applied ( and thus defines meaningful boundaries for the body ) :    * the core is _ bounded _ if it is _ left _ and _ right bounded_. * a sequence @xmath80 is left bounded ( right bounded ) if @xmath81 ( @xmath82 ) is not a gap .",
    "* a parallel match @xmath83 is left bounded ( right bounded ) if at least one of @xmath52 and @xmath20 is left bounded ( right bounded ) .",
    "furthermore , it is assumed that any variable appearing in body as well as guard also must occur in the head .",
    "a grammar rule is _ range - restricted _ if any variable in the body appears in the head .    a _ simplification ( grammar )",
    "rule _ is similar to a propagation rule except that the arrow is replaced by @xmath84 ; a _ simpagation ( grammar ) rule _ is similar to a simplification except that one or more grammar symbols or constraints in the core of the head are prefixed by an exclamation mark `` @xmath85 '' .",
    "the intended meaning is that head core elements under a derivation are removed , except those prefixed by `` @xmath85 '' .",
    "( as the order of the elements in the head of a grammar rule does matter , we can not take over the syntax from chr . )",
    "[ simple - grammar - example ] the following source text shows the actual syntax used in the implemented system .",
    "the `` handler '' command is a reminiscent from the underlying chr system ; grammar symbols are declared by the ` grammar_symbols ` construct as shown ; constraints to be used in grammar rules are declared as in chr which will be shown in subsequent examples .",
    "the final command has no effect in the present example , but it adds extra rules needed for the extensions of chrg described in sections  [ abduction - section ] and  [ assumption - grammar - section ] .    ....",
    "handler my_grammar .",
    "grammar_symbols np/0 , verb/0 , sentence/0 .",
    "np , verb , np : :> sentence .",
    "[ peter ] : :> np .      [ mary ] : :> np .      [ likes ] : :> verb .",
    "....    when the string `` peter likes mary '' is entered word by word , the words are recognized as a respectively np , verb , and np in that order , and then the rule for sentence can apply . since this grammar consists of propagation rules ,",
    "the lexical tokens as well as the nps and verb are not consumed . if we added a rule ,",
    "say np , [ likes ] : :> sentence1 , a sentence as well as a sentence1 would be recognized . if all rules were changed into simplification rules , i.e. , replacing : :> by , only one of sentence and sentence1 would be recognized .",
    "left and right contexts of a rule may include `` disjunctions '' denoted by semicolon of different alternatives , and this is considered syntactic sugar for the set of different rules , taking one alternative for the left and one for the right",
    ".    the rule    ....      ( a ; b ) -\\ c /-",
    "( d ; e ) : :> f ....    is an abbreviation for the following four rules :    ....      a -\\ c /-",
    "d : :> f      b -\\ c /-",
    "d : :> f      a -\\ c /-",
    "e : :> f      b -\\ c /-",
    "e : :> f ....    the implemented version of chrg allows control structures in the body ( conditionals and prolog - style disjunctions ) and arbitrary prolog goals inside \\{@xmath86 } as well as bodies with no grammar symbols ; for the reason of simplicity , we ignore these options in this presentation .      in order to capture the whole chrg formalism , a semantic definition needs to be based on bottom - up derivations and the simplest way to achieve this is by a translation of chrg into chr . for comparison with traditional grammar formalisms , we provide also a definition of top - down derivations that characterize a subclass of ghrgs .    for each grammar symbol @xmath29 of arity @xmath70",
    ", we assume a corresponding constraint also denoted by @xmath29 of arity @xmath87 called an _ indexed grammar symbol _ , with the extra two arguments referred to as phrase ( or word ) _",
    "boundaries_.    for a grammar symbol @xmath88(@xmath89 ) , the notation @xmath90 refers to the indexed grammar symbol @xmath29(@xmath91,@xmath92,@xmath89 ) with integers @xmath93 ; in case of a terminal , @xmath94 is assumed .",
    "for any sequence @xmath32 of grammar symbols @xmath95 and increasing integers @xmath96 , we let @xmath97 refer to the set @xmath98 with the existence of @xmath99 understood . for the parallel match operator ,",
    "we define @xmath100 .",
    "this notation is extended so that for a sequence of grammar symbols and constraints , we remove all constraints from the sequence , put indexes on the remaining grammar symbols , and add again the constraints to the sequence in their original position .",
    "gaps are removed from rule heads under this translation but give rise to inequations to be added to the guard of the resulting chr rule ; we do not formalize this here but illustrate the principle in example  [ translate - gaps - and - parr - match - example ] below .",
    "the translation of rules from chrg into chr adds two extra variables to each grammar symbol and we use a notation analogous to the above to indicate this .",
    "so for a sequence @xmath32 of grammar symbols @xmath95 and variables @xmath101 , we let @xmath102 refer to the set @xmath103 with the existence of @xmath104 understood . the notation is extended to sequences of grammar symbols and constraints as above so that constraints are unaffected .",
    "the translation of a chrg @xmath19 into chr is denoted @xmath105 and consists of the translation @xmath106 of each rule @xmath107 . for propagation and simplification rules we have @xmath108 @xmath109 simpagation grammar rules",
    "are translated similarly to simplifications except that those elements of @xmath110 that were preceded by `` @xmath85 '' in the original grammar rule are moved to the left of the backslash .",
    "notice that a grammar rule @xmath51 is range - restricted if and only if the chr rule @xmath106 is range - restricted .",
    "the rule in following source text :    ....       constraints h/1 .",
    "grammar_symbols a/0 , b/1 , d/1 , e/2 .",
    "b(x ) , [ c ] , { h(y ) } /-",
    "d(y ) : :> e(x , y ) . ....",
    "is translated into this chr rule :    ....       a(n0,n1 ) , b(n1,n2,x ) , token(n2,n3,c ) , h(y ) , d(n3,n4,y )         = = > e(n1,n3,x , y ) .",
    "....    [ translate - gaps - and - parr - match - example ] the translation of gaps and parallel matching into chr is illustrated for the following chrg rules .    ....",
    "a , ... , b /-",
    "... , c(x ) < :> d(x ) .",
    "a$$b : :> e. ....    they are translated into the following chr rules :    ....       c(n5,_,x ) \\",
    "a(n1,n2),b(n3,n4 ) < = > n2=<n3 ,",
    "n4=<n5 | d(n1,n4,x )       a(n1,n2),b(n1,n2)==>e(n1,n2 ) ....    the gap in the context part of the first rule is used in order to make a `` long - distance reference '' to c.    notice that a gap in the head of core of a simplification rule does not imply the removal of any grammar symbols recognized in the substring spanned by the particular `` instance '' of the gap .",
    "a _ ( bottom - up ) parsing derivation _ for a string @xmath32 with a chrg @xmath19 is a derivation with the chr program @xmath111 for the query @xmath112 where @xmath70 is the length of @xmath32 .",
    "an interesting class of parsing derivations are those that apply an lr computation rule as in the implemented chrg system and for which we describe some optimizations below .",
    "[ loop - free - def ] a _ single - production _ is a grammar rule with singleton grammar symbols in head core and in body .",
    "a grammar is _ loop - free _ if there is no chain of single productions @xmath113 with @xmath114 ; here each occurrence of `` > > > '' may stand for any of `` @xmath84 '' or `` @xmath76 '' .    in order",
    "get rid of termination problems once and for all , any chrg is assumed to be loop - free .",
    "we notice without proof the following obvious properties .",
    "[ obvious - grammar - props ]    1 .",
    "any parsing derivation is finite ( as we assume all grammars to be loop - free ) .",
    "2 .   any state in a parsing derivation with a range - restricted grammar is ground .",
    "the final state in an lr parsing derivation for a given string is unique ( up to renaming of existentially quantified variables that may occur for non - range - restricted grammars ) .",
    "the final state in a parsing derivation with a propagation rule grammar is unique ( up to renaming @xmath3 ) ; thus lr - derivations are complete for propagation rule grammars . 5 .",
    "completeness of lr - derivations does not necessarily hold for a grammar with simplification or simpagation rules .",
    "[ context - part - prop - part ] let @xmath19 be a propagation rule grammar without context parts , and @xmath115 be derived from @xmath19 by adding to some rules context parts and changing some rules into simplification or simpagation rules , and let @xmath30 and @xmath55 be final states for a given string with the grammars @xmath19 and @xmath115 . then @xmath65 .",
    "this holds also when we restrict to lr - derivation for @xmath115 or for both @xmath19 and @xmath115    in order to discuss ambiguity , we define syntax trees but we do not intend that an implementation should generate trees .",
    "let chrg @xmath19 and input string @xmath32 be given .",
    "the set of _ syntax trees _ over @xmath32 is defined as follows .    *",
    "any @xmath116 token(@xmath117,@xmath70,@xmath118 ) in @xmath32 is a syntax tree with top node @xmath35 .",
    "* whenever a rule instance @xmath119 , `` > > > '' being one of `` @xmath76 '' or `` @xmath84 '' , is applied in a derivation and @xmath120 , @xmath3 , @xmath121 are trees whose top nodes are the grammar symbols in @xmath74 , then @xmath122 is a syntax tree with top node @xmath77 .    a syntax tree whose top node does not occur in the final state ( i.e. , it has been consumed by a propagation or simpagation rule ) is called a _ hidden syntax tree _ and similarly for the node itself .",
    "the set of _ lr syntax trees _ is defined in a similar way , considering only instances applied in the lr - derivation from @xmath32 with @xmath19 .",
    "the notions of subtree and proper subtree are defined in the usual way .",
    "the relevant notion of unambiguity in the context of chrg is called local unambiguity and is a stronger property than the usual notion of unambiguity for context - free grammars .",
    "chrg works bottom - up with no sort of top - down guidance so even with an unambiguous grammar ( in traditional sense ) , it may be the case that some subtree becomes part of two different , larger trees ( but only one of these contribute to a tree for the entire string ) .",
    "[ def - unambiguity ] consider a chrg @xmath19 and a derivation for string @xmath32 and let @xmath123 be a set of syntax trees with set of top nodes @xmath124 .",
    "the set @xmath123 ( and @xmath124 ) is said to be _ unambiguous _ whenever , for any two grammar symbols p(@xmath49,@xmath68,@xmath86 ) , q(@xmath125,@xmath126,@xmath86 ) @xmath127 it holds that    * if @xmath128 , then @xmath129 and @xmath130 , and * if @xmath131 , then q(@xmath125,@xmath126,@xmath86 ) is top node of a subtree of p(@xmath49,@xmath68,@xmath86 ) or the other way round [ the last case requires single productions in the grammar and @xmath132 .    if , furthermore no new syntax tree of the derivation can be added to @xmath123 without destroying unambiguity , we say that @xmath123 and @xmath124 are _",
    "maximal_. a chrg @xmath19 is _ locally unambiguous _ if the set of syntax trees in the derivation from any input string is unambiguous , and _ locally lr - unambiguous _ if the set of syntax tree in the lr - derivation from any input string is unambiguous .",
    "maximal unambiguous sets for a given parsing derivation may overlap , and each such set corresponds to one possible way of parsing the string . as we will see later ,",
    "when doing abduction with ambiguous grammars , it is possible to extend a grammar so that the different unambiguous sets are kept apart by means of indexes .",
    "although chrg provides an elegant handling of ambiguous grammars , it may be relevant to aim at unambiguity , e.g. , for efficiency or to avoid mixing up extragrammatical constraints for different parses .",
    "one obvious way to achieve this is given by the following which is easy to prove .",
    "[ prop - simplification - grammars - locally - unambiguous ] a simplification rule chrg is locally lr - unambiguous .",
    "although we have no theoretical result , it seems reasonable to believe that the local unambiguity of chrgs is undecidable as is unambiguity for context - free grammars .",
    "if unambiguity is required this can be guaranteed by proposition  [ prop - simplification - grammars - locally - unambiguous ] or perhaps using a combination of different sorts of rules , in which case the property needs to be verified .",
    "it should be noticed , that the definition of unambiguous sets does not take into account left and right context parts of grammar rules .",
    "a rule that produces a node belonging to one unambiguous set may very likely do so by referring to contextual nodes belonging to other sets .",
    "this may be considered a bug or a feature but it seems to be the only solution that fits with our general implementation principle .    to compare with traditional grammar formalisms having their meaning defined by top - down derivations we consider definite clause grammars ; to simplify the comparison , we make a restriction on how variables can be used .    a _ definite clause grammar ( dcg ) _",
    "@xmath133 consists of rules of the form @xmath134 where @xmath52 is a nonterminal , @xmath135 , @xmath3 , @xmath136 are grammar symbols , and @xmath19 a conjunction of built - in s so that any variable in @xmath52 and @xmath19 occurs in some @xmath137 .",
    "a dcg is assumed to be loop - free and without single productions ( defined in the usual way ) .",
    "for any ground sequence of grammar symbols @xmath138 ( @xmath52 a single grammar symbol ) , define the relation @xmath139 whenever there is a rule in @xmath133 with a ground instance @xmath140 with @xmath19 satisfied . the reflexive , transitive closure of @xmath141 is denoted @xmath142 .",
    "[ compare - with - dcg - prop ] let @xmath133 be a dcg and @xmath27 the chrg that for each rule in @xmath133 of the form indicated above contains @xmath143 for ground grammar symbol @xmath52 and terminal string @xmath73 , the following statements are equivalent :    * @xmath144 using the rules of @xmath133 , * @xmath52 is contained in the final state in any parsing derivation for @xmath73 using rules of @xmath27 .    the proof is easily made by induction over the length of the derivations . combining this with proposition  [ obvious - grammar - props ] , part  [ context - part - prop - part ]",
    ", we see that a chrg with context parts corresponds to a dcg with context - sensitive restrictions on the derivation relation ( that are not easily formalized in the setting of dcg ) .",
    "finally , notice that chrg do not provide empty productions .",
    "these , however , are easily mimicked by inserting for each dcg rule @xmath145}$ ] grammar symbols @xmath146 , @xmath147 , @xmath3 into the initial constraint store .",
    "we describe here very briefly the principles used for the implementation of chrg in sicstus prolog  @xcite and describe some additional features of the implemented system not already covered ; all facilities are described at the online users guide to chrgs available at  @xcite .    similarly to dcg and chr ,",
    "chrg is implemented by changing prolog s reader so that the terms read are translated into another form before given to the prolog compiler ( or interpreter ) .",
    "sicstus prolog includes a so - called hook predicate called term_ex that can be extended by the user and which is called automatically by the prolog reader for each term read from a source file .",
    "the ` term_expansion ` clauses defining the chrg syntax must work together with those already defined by chr .",
    "the general structure of the chrg implementation is illustrated by the following fragment that treats the ` grammar_symbols ` declaration :    term_expansion ( ( grammar_symbols g ) , t):- : :     +    _ add 2 to arities of gr .",
    "spec s g and add token/3 and a few more    to form c _",
    ", +    term_expansion((constraints c ) , t ) .",
    "similar rules catch terms formed by the operators and : :> , translate them into chr rules as described in section  [ translate - chrg - to - chr - subsection ] above and let the chr system translate them further into prolog rules .",
    "the chrg notation includes counterparts to chr s pragmas and rule names ( in chr using an @ operator ) , but since it is not possible for override the term_ex clauses given by chr , it has been necessary to rename these operators in the chrg syntax , gpragma and @@.    notice that this sort of implementation makes it possible to mix freely the rule formats of prolog , chr and chrg , and dcg for that matter .    finally , the chrg notation includes a where notation which can be applied to rules of prolog and chr as well .",
    "we describe it by an example :    ....      a(a ) -\\ b /-",
    "... , q(x , y )   : :>   { c } , funny_sentence(a , z )      where a = ugly(st(r , u , c(t , u , r(e ) ) ) ) ,            b = ( np , verb , np ) ,            c = ( append(x , y , z ) , write(z ) ) ....    the meaning is that any occurrence in the rule of a , b , and c is replaced by the indicated term .",
    "the implementation is very simple and one might wonder why this syntax is not standard in prolog systems :    ....      term_expansion((rule where goal ) , result):-          ( goal - > term_expansion(rule , result )           ; write('error : where - clause failed : < rule > where ' ) ,             write(goal),nl , write('compilation stopped ' ) , abort ) . ....",
    "the chrg system includes a number of options of which the most important is an optimization in the compilation of grammar rules , so that all but leftmost symbols of core and possible right context are marked by passive pragmas ; see the section on chr of  @xcite for a detailed explanation of these concepts .",
    "for example , with this option the rule np , verb , np : :> sentence gets compiled into    ....",
    "np(x0,x1)#a , verb(x1,x2)#b , np(x2,x3 ) = = > sentence(x0,x3 )        pragma passive(a ) , passive(b ) .",
    "....    this has significant influence on the efficiency that we analyze in detail in section  [ complexity - subsection ] below .",
    "operationally , the principle means that this rule is not checked for applicability at the moment when a new verb constraint is created as is the case if no pragma passive stuff were added . and",
    ", as the system performs lr - derivation , this check for applicability would anyhow fail . for the nps it means that when a new np is created , the system does not check if it might be followed ( qua the word boundary arguments ) by verb , np ; it is only checked if the new np happens to follow some existing np , verb sequence .",
    "it can be shown that the semantics is not changed for propagation rule grammars with only right contexts . when left and right context or simplification or simpagation rules are used , there are subtle cases where a rule is not applied although it intuitively should be applied .",
    "when this optimization is used for a grammar of simplification rules only , the constraint store is used effectively as a parsing stack in quite the same way as in a traditional lr@xmath148 parser .",
    "for parsing a specific string , the system includes an auxiliary predicate parse that converts a list of constants to a sequence of calls to token constraints .",
    "this predicate may ( as an option that can be switched on and off ) display the word boundaries which makes it easy to compare input and result .",
    "assuming the grammar of example  [ simple - grammar - example ] above , we have the following dialogue .    ....      ?",
    "- parse([peter , likes , mary ] ) .",
    "< 0 > peter < 1 > likes < 2 > mary <3 >       np(0,1 ) ,      verb(1,2 ) ,      np(2,3 ) ,      sentence(0,3 ) ,      token(0,1,peter ) ,      token(1,2,likes ) ,      token(2,3,mary ) ? ....    this grammar consists of propagation rules ; if all are changed into simplification rules , only sentence(0,3 ) appears as answer .",
    "an apparent advantage of chrg as compared with dcg is that we avoid the combinatorial explosions that may arise under backtracking in case a wrong choice of rule is made in beginning of the string to be analyzed .",
    "here we give theoretical measures for the running time of chrgs , more precisely the chr rules that are produced by their compilation , and discuss the behaviour of the implemented system .",
    "for simplicity , we do not consider context parts or the use of extra - grammatical constraints . without loss of generality",
    ", we consider only rules with one or two grammar symbols in the head .",
    "the chr rules to consider are , thus , of one of the following forms , possibly with @xmath149 instead of @xmath150 .",
    "1 .   @xmath151 2 .",
    "@xmath152    we refer to the so - called meta - complexity theorems of  @xcite for bottom - up evaluation of logic programs including deletion .",
    "chr rules , such as those we use , with one constraint in the body are covered by this scheme .",
    "the main theorem of  @xcite gives that time complexity for reaching a final state is of order @xmath153 where @xmath70 is number of constraints in an initial state and @xmath154 the number of prefix firings that have appeared in some state in the derivation .",
    "the number @xmath70 is the length of the string in our case .",
    "estimating @xmath154 is more difficult : for each rule of type 1 ( above ) , we count the number of occurrences of @xmath155 that have occurred in a state ; summing for all type 1 rules , we can limit the contribution by size of grammar times total number of grammar symbols that have occurred in the derivation . for each rule of type 2 , the prefix firings are of two kinds ,    * occurrences of @xmath155 ( that can be estimated as for type 1 ) , and * occurrences in any state of a pattern matching the entire head @xmath155 , @xmath156 .    the dominant contribution is the last one for type 2 rules , i.e. , for each rule of type 2 and each @xmath157 occurring in a state , the possible ways the interval @xmath158 $ ] can be split up into @xmath159 $ ] and @xmath160 $ ] so that some @xmath161 have appeared at the same time in the state during the derivation .",
    "we continue the analysis for two special cases .    * * locally unambiguous grammars : * each @xmath157 in some state is created exactly once from a specific @xmath161 combination .",
    "thus the overall time complexity is proportional to the total number of grammar symbols that have appeared in the derivation , and we argue that it is of order @xmath162 for a locally unambiguous grammar : worst case is a binary branching everywhere , so a syntax tree over a string of length @xmath70 has @xmath70 nodes in its deepest layer , @xmath163 in the second deepest layer , @xmath164 in the next one and so . summing up , we get at most @xmath165 tree nodes . *",
    "* arbitrary grammars without attributes : * first of all , let us estimate the maximum number of nodes .",
    "there are @xmath166 different substrings of the input string , each of which can represent up to @xmath167 different nodes where @xmath167 is the number of different grammar symbols in the vocabulary ; this is constant , so number of different nodes is @xmath166 .",
    "+ each such node @xmath168 spans over an interval @xmath158 $ ] , and the maximum number of ways it can be split up into two subintervals by some @xmath68 , @xmath169 , possibly representing @xmath170 , is @xmath171 .",
    "this adds another factor @xmath70 , so we end up with a total time complexity of @xmath172 .",
    "the general cubic complexity for context - free grammars is similar to that of classical algorithms such as early and cocke - younger - kasami .",
    "its interesting to notice that parsing is linear for locally unambiguous grammars despite the very naive parsing algorithm which simply applies rules over and over as long as possible .",
    "it is straightforward to show that the results also hold for grammars with context parts .",
    "so if a grammar is made locally unambiguous by a combination of simplification rules and context parts , it runs in linear time ; the presence of attributes does not affect this .",
    "when attributes are added in the general case , we can have much worse than cubic complexity as it appears in the following example :    consider the grammar    *  [ a]::>a(0 )   a(t1),a(t2)::>a(t(t1,t2 ) )    for each pair of @xmath173 marking a substring of the input string , there will be as many different nodes as there are binary trees with a frontier of @xmath174 nodes .",
    "it appears that each node is constructed in a unique way , but the total number of nodes is given by a terrible combinatorial expression far beyond @xmath175 .",
    "how do these results compare with practice ?",
    "first of all , the optimization in section  [ implementation - section ] adding passive pragmas to all but rightmost symbols is necessary in order to achieve an execution as the one assumed in the theorem of  @xcite .",
    "secondly , the method behind the implementation of chr that we have used ( based on attributed variables ) , as described by  @xcite , indicates that word boundaries should be uninstantiated prolog variables to achieve full efficiency and not integers as we have used .",
    "experiments with prolog variables for boundaries confirm these results but even with integer indexes , chrgs without too much local ambiguity execute equally fast for strings up to several hundreds of tokens .",
    "unfortunately , chr does not construct explicit prefix - firings during execution , which means that only grammars with at most two grammar symbols show the expected running times .",
    "it is possible to have the chrg compiler reduce the size of heads to at most two , but a general improvement of chr so that it incrementally builds prefix firings would solve the problem . in practice , however , grammars with heads with up to three or four symbols may run almost linearly provided the passive pragma optimization is used and local ambiguity is limited .",
    "it is often the case that an unambiguous grammar , e.g. , a context - free grammar for a programming language , can be written in a much simpler form as an ambiguous grammar with additional `` disambiguation principles '' specified outside the grammar formalism ; see , e.g. ,  @xcite .",
    "as we have noticed already , simplification rule grammars are unambiguous and by means of context parts , we can direct the derivations as to respect the priorities we have in mind .",
    "the following simplification rule chrg is based on a simple and highly ambiguous grammar for arithmetic expressions with addition , multiplication , and exponentiation .",
    "right contexts have been added which provides a conventional operator precedence .    ....",
    "e , [ + ] , e /-",
    "( [ ' + ' ] ; [ ' ) ' ] ; [ eof ] ) < :> e.      e , [ * ] , e /-",
    "( [ * ] ; [ + ] ; [ ' ) ' ] ; [ eof ] ) < :> e.      e , [ ^ ] , e /-",
    "[ x ] < :> x \\= ^ | e.      [ ' ( ' ] , e , [ ' ) ' ] <",
    ":> e.      [ n ] < :> integer(n ) | e. ....    in general , both left and right contexts are relevant , and for natural language application , it may be relevant to disambiguate some portions of the grammar in this way but keeping , say , possibilities of ambiguity at the sentence structure level .",
    "natural language processing often involves a phase called tagging in which the different words are classified before the `` real '' parsing process takes place .",
    "tagging is often performed by means of context sensitive rules that take into account what is immediately to the left and to the right of the given word  @xcite .",
    "such rules can be expressed in quite natural way in chrg using context parts .",
    "[ tagger - example ] we consider a languages including sentences such as `` peter and paul like martha and eve '' .",
    "the following rules classify the names as subject or object according to their position relative to the verb .    ....",
    "name(a ) /-",
    "verb ( _ ) < :> subject(a ) .",
    "name(a ) , [ and ] , subject(b ) < :> subject(a+b ) .      verb ( _ ) -\\",
    "name(a ) < :> object(a ) .",
    "object(a ) , [ and ] , name(b ) < :> object(a+b ) .",
    "....      context parts can also be used as a way to access attributes of grammar symbols at a certain distance .",
    "this is relevant in natural language when a part of a sentence is left out when this part is understood to be identical to the matching part of a neighbouring sentence .",
    "let us extend the language of example  [ tagger - example ] with coordination as in `` peter and paul likes and mary hates martha and eve '' ; the first sentence is incomplete but is understood to borrow its subject from the second sentence .",
    "this can be expressed as follows .    ....",
    "subject(a ) , verb(v ) , object(b ) : :> sentence(s(a , v , b ) ) .",
    "subject(a ) , verb(v ) /-",
    "[ and ] , sentence(s(_,_,b ) )             : :> sentence(s(a , v , b ) ) .",
    "....    for the sample sentence above , the final constraint store contains sentence nonterminals with attributes s(peter+paul , like , martha+eve ) and s(mary , hate , martha+eve ) .",
    "these rules work also in the case when three or more sentences share a common object . for analyzing texts consisting of a single sentence",
    ", a rule with a gap could have been used instead :    ....        subject(a ) , verb(v ) , /-",
    "[ and ] , ... , object(b )             : :> sentence(s(a , v , b ) ) ....      in an application program using chrg for text analysis it may be relevant to make some formatting of the constraint store produced by the parser .",
    "as we have noticed , parsing with an ambiguous propagation rule grammar may result in a large number of nodes , most of them not relevant for the further processing ( but necessary to guide parsing )",
    ". it may be the case that we do not want to reduce ambiguity in the grammar , so some elaboration of the constraint store needs to take place following parsing .",
    "part of such post - parsing processing can in fact be specified conveniently in chrg .",
    "assume we are scanning a text for noun phrases ( nps ) by means of a highly ambiguous grammar with a detailed description of sentence structure as a way to obtain a high degree of precision in the parser . when the parser has finished its job , we are only interested in noun phrases and",
    "let us suppose that only maximal noun phrases are of interest , maximality with respect to text inclusion .",
    "this can be achieved by using a constraint cleanup defined by the following rules .    ....",
    "vp ( _ ) , { ! cleanup } <",
    ":> true .",
    "pp ( _ ) , { ! cleanup }",
    "< :> true .      sentence ( _ ) , { ! cleanup }",
    "< :> true .",
    "% etc .",
    "( ... , np ( _ ) , ... $ $ ! np ( _ ) ) , { ! cleanup } <",
    ":> true .",
    "cleanup < = > true .",
    "....    recall that the exclamation mark combined with the double arrow indicates simpagation rules : all but those symbols marked by `` ! '' are removed from the store .",
    "assume the following query is issued    * ? - parse([_string _ ] ) , cleanup .",
    "the cleanup rules does not affect parsing as there is no cleanup constraint in the store before all token constraints have been entered and no parsing rule can apply anymore . now",
    "the call to cleanup will , via the first set of rules , remove all non - np nodes ; these simpagation rules will apply over and over until all such nodes are removed but each application leaves cleanup in the store .",
    "then the rule concerning nps will apply to each occurrence of one np textually included in a larger np ; recall that ` $ $ ` is the parallel match operator and the three dots are a gap",
    ". the final rule , conveniently written as a chr rule , will apply when the other rules are exhausted and thus clean up the cleanup constraint .",
    "left in the constraint store is the set of all maximal nps .",
    "as shown by  @xcite and developed further in  @xcite , abduction with integrity constraints can be implemented in astraightforward fashion in chr , basically by declaring abducible predicates as constraints : when an abducible atom is called , it is added to the constraint store and possible integrity constraints will be triggered automatically .",
    "the approach is limited with respect to negation : explicit negation of abducibles is easily implemented by means of an integrity constraint but more general application of negation - as - failure in background clauses or chr rules has no obvious representation .    we can illustrate the application to language interpretation in chrg by means of an example .",
    "consider the following grammar rule in which @xmath56 refers to a fact about the semantical context for a given discourse .",
    "@xmath176 if two subphrases referred to by a and b have been recognized and the context condition @xmath56 holds , it is concluded that an ab phrase is feasible , grammatically as well as with respect to the context .",
    "language analysis with such rules works quite well when context is completely known in advance , and a given discourse can be checked to be syntactically and semantically sound .",
    "here we provide a solution to the extended problem referred to as _ language interpretation _ , of finding proper context theory so that an analysis of an observed discourse is possible .",
    "this involves a transformation of grammar rules as above by moving contextual predicates to the other side of the implication : @xmath177 ituitively it reads : if suitable a and b are found , it is feasible to assert @xmath56 and ( thus , under this assumption ) to conclude ab .    although  ( [ dcg - example ] ) and  ( [ dcg - example - transformed ] ) are not logically equivalent it is straightforward to formulate and prove correctness of this transformation as we will see below",
    ".    a grammar as depicted by  ( [ dcg - example ] ) can be thought of as part of a _",
    "speaker s _ capabilities , embedding his knowledge about the context into language , whereas  ( [ dcg - example - transformed ] ) is relevant for a _ listener _ who wants to gain new context knowledge by an interpretation of the spoken .",
    "the transformation indicated above can be formulated without detailed assumptions about the grammar formalism applied , it may in principle include any kind of transformations , multiple passes and be based on trees , graphs or something completely different .",
    "the input need not necessarily be strings or sequences but might also be a combination of sensor signals or multidimensional structures , e.g. , described by means of constrained multiset grammars  @xcite .",
    "the vocabulary for a language interpretation problem consists of disjoint sets of constraints referred to as _ grammar symbols _ and _ context predicates_. grammar symbols are separated into _ token level _ symbols and _ phrase level _ symbols .",
    "the basic components in a language interpretation scenario are the following .",
    "@xmath178 : : :    a set of ground token level atoms giving the set of input tokens and    their relative order ( e.g. , sequentially or in the shape of a graph    for a visual language ) and , if available , extra information such as    prosody , colour , etc .",
    "@xmath179 : : :    a set of ground context atoms describing a part of the world . @xmath180",
    ": : :    a set of _ integrity constraints _ which must be satisfied by    @xmath179 , each of the form @xmath181    where @xmath17 is a conjunction of context atoms and    @xmath20 a conjunction of built - in s and context atoms ;    however , the total set of integrity constraints must not be recursive    ( or should satisfy some weaker criterion that guarantees termination ) .",
    "@xmath182 : : :    a set of ground phrase level atoms giving the phrases contained in the    _ discourse _ that are grammatically correct and consistent with    _",
    "context_. @xmath183 : : :    a set of formulas for the    form@xmath184    where @xmath185 and @xmath186 are    nonempty conjunctions of grammar atoms , @xmath187 a    conjunction of context atoms .",
    "each rule must be _ range - restricted _ in    the sense that any variable in @xmath186 must occur in    @xmath185 or @xmath187 and the grammar    must be _ loop - free _ defined analogously to definition  [ loop - free - def ]    ( for chrg ) . furthermore , each argument in the lefthand side must be a    variable that do not occur elsewhere in that lefthand side .",
    "we require the following fundamental relation referred to as _ faithfulness _ between the components : @xmath188 this means that the @xmath178 and the @xmath182 in it are true to the @xmath179 and correctly formulated with respect to the @xmath183 .    in case of an ambiguous grammar",
    ", we can expect different interpretations for different parses of the string .",
    "however , we do not require the grammar to be unambiguous , but assume a criterion of _ unambiguity _ of a set of @xmath182 which is particular to the grammar formalism applied ; a criterion for chrg is given by definition  [ def - unambiguity ] above .",
    "not every pair of unambiguous @xmath182 and @xmath179 is interesting :    [ def - competent - interpretation ] a pair of unambiguous @xmath182 and @xmath179 is a _ competent interpretation _ of given @xmath178 with respect to given @xmath183 whenever faithfulness and the following conditions hold :    1 .",
    "[ context - minimal ] ( minimality of @xmath179 ) if any element is removed from @xmath179 , faithfulness fails to hold .",
    "[ phrases - maximal ] ( maximality of @xmath182 ) if any new element is added to @xmath182 , unambiguity or faithfulness fails to hold .",
    "3 .   ( analysis is exhaustive )",
    "no new elements can be added to @xmath179 which allow an extension of @xmath182 so that points  [ context - minimal ] and  [ phrases - maximal ] , and faithfulness are preserved .",
    "a _ language interpretation problem _ is a problem , given @xmath183 and @xmath178 of finding a competent interpretation .    the condition of exhaustive interpretation excludes @xmath189 unless the @xmath178 is completely senseless .",
    "language interpretation is partly deductive and partly abductive : the _ context _ is a premise in  ( [ l - i - problem ] ) and by standard usage , the finding of it is an abductive problem . identifying phrases is a mainly deductive parsing process , applying grammar rules over and over , however , interacting with abduction in order to have the necessary contextual facts ready .",
    "the translation of a grammar @xmath19 into an version that can be executed in a purely deductive way is defined by a transformation @xmath190 in which each rule @xmath191 is replaced by the rule @xmath192 where @xmath24 are the variables in @xmath56 that do not occur in @xmath27 .",
    "the fact that @xmath190 may not be range - restricted indicates some technical problems that we have to deal with , but it should be emphasized that @xmath190 being non - range - restricted does not necessarily indicate that @xmath19 is too weakly specified : although a variable in @xmath56 does not receive a value by the matching of @xmath27 , it may receive a value later from an integrity constraint  or it may remain unbound in case the discourse does not provide enough information .",
    "the presence of such variables indicates that we can not expect derivations to produce ground @xmath179 and @xmath182 , and an arbitrary grounding ( instantiation of variables ) in such cases will produce a more specific solution than there is evidence for  even if it is minimal wrt .",
    "set - inclusion .",
    "this discussion should clarify the following correctness theorems .",
    "[ completeness - of - abductive ] let @xmath183 , @xmath193 and ground @xmath178 be given as above .",
    "if there exist ground @xmath179 and @xmath182 so that faithfulness  ( [ l - i - problem ] ) holds with @xmath179 minimal wrt .",
    "this property , then there exist @xmath194 and @xmath195 so that @xmath196 where @xmath197 is an instance of @xmath198 .",
    "[ soundness - of - abductive ] let @xmath183 , @xmath193 and ground @xmath178 be given as above . if there exist @xmath194 and @xmath195 so that @xmath199 then there exists a ground instance @xmath197 of @xmath198 so that @xmath200 is consistent and @xmath201    let @xmath183 , @xmath193 , ground @xmath178 , @xmath179 and @xmath182 be as in the theorem so that  ( [ l - i - problem ] ) holds .",
    "define @xmath19 to be the set of all ground instances of rules in @xmath183 , and let @xmath202 @xmath203 we have from  ( [ l - i - problem ] ) that @xmath204 and from this that @xmath205 i.e. , we have eliminated @xmath179 by using a specialized grammar .",
    "the rules of @xmath206 differs from those of @xmath207 by introducing on the righthand side an element of @xmath179 .",
    "referring to minimality of @xmath179 , we have that @xmath208 consider now a `` proof '' of @xmath209 applying a finite sequence of rules @xmath210 , @xmath211 to generate the following sets : @xmath212 @xmath213 @xmath214 @xmath215 from this , we construct another parallel proof in which the rules applied are instances of clauses of @xmath193 , @xmath216 where @xmath217 is a substitution to the variables of @xmath218 so that @xmath219 @xmath220 @xmath221 @xmath222 by induction over @xmath49 , it is straightforward to prove that @xmath223 and that @xmath197 is an instance of @xmath198 .",
    "from this ,  ( [ l - i - problem - deductively ] ) follows immediately .",
    "the restriction that each argument in the head of a grammar rule must a variable that do not occur elsewhere in that head is necessary as indicated by the following example .",
    "let @xmath224 , @xmath225 , and @xmath226 be grammar symbols , @xmath227 a context predicate and let @xmath183 consist of @xmath228 then @xmath193 consists of ( ii ) and @xmath229 given @xmath230 and @xmath231 we have that @xmath232 satisfies the faithfulness condition  [ l - i - problem ] .",
    "however , a proof using @xmath193 will only give @xmath233 , and it not sound to set this @xmath234 so that rule ( ii ) can be applied . if the head of ( ii ) had an unrestricted variable instead of a constant , it would be possible to relate it to the existentially quantified @xmath235 .    similarly to the proof of theorem  [ completeness - of - abductive ] .",
    "the general model developed in section  [ subsection - with - reqr - to - abd - grammars ] fits perfectly with locally unambigous chrgs . for simplicity ,",
    "we formulate the approach for propagation rule grammars without left and right context parts , but it is obvious that it works also in the general case ; especially interesting are chrgs of simplification rules only that are guaranteed to be locally unambigous . ( section  [ all - abductive - in - parallel - section ] below describes a generalization to ambiguous grammars . )    let us define an _ abductive chrg _ as a grammar with range - restricted rules of the form @xmath236 in which ( cf .",
    "section  [ subsection - with - reqr - to - abd - grammars ] ) each argument in _ constituents _ and _ context - facts _ is a unique variable .",
    "the grammar may be extended with a set of integrity constraints expressed as chr propagation rules .",
    "combining theorems  [ completeness - of - abductive ] and  [ soundness - of - abductive ] with the completeness and soundness properties for parsing derivations , shows that a locally unambiguous , abductive grammar , written in the format @xmath237 produces competent interpretations of the given input string .",
    "the implemented chrg system does not include this translation but assumes the user to write abductive grammars directly in the `` translated form '' which is anyhow the intuitively simplest for someone with experience in chr programming .",
    "we consider language interpretation of discourses such as the following .",
    "@xmath238 what we intend to learn from  ( [ tom - is - cat - etc ] ) are the categories to which the mentioned proper names belong and which categories that are food items for others . an interesting question is to which category garfield belongs as this is not mentioned explicitly . we define the following vocabulary ; the abducibles declaration is synonymous with chr s constraints except that it also introduces predicates for negated abducibles with integrity constraints that implement explicit negation .    ....",
    "abducibles food_for/2 , categ_of/2 .",
    "grammar_symbols name/1 , verb/1 , sentence/1 , category/1 .",
    "....    the background theory is the following consisting of integrity constraints only .    ....",
    "categ_of(n , c1 ) , categ_of(n , c2 ) = = > c1=c2 .",
    "food_for(c1,c ) , food_for(c2,c ) = = >",
    "c1=c2 . ....",
    "i.e. , the category for a name is unique , and for the sake of this example it is assumed that a given category is the food item for at most one other category . the following part of the grammar classifies the different tokens .    ....       [ tom ] : :> name(tom ) .       ...",
    "[ is ]   : :> verb(is ) .       ...",
    "verb(is ) -\\ [ x ] <",
    ":> category(x ) . ....",
    "the last rule applies a syntactic left context part in order to classify any symbol to the right of an occurrence of `` is '' as a category .    a sentence such as `` tom is cat '' is only faithful to a context if categ_of(tom , cat ) holds in it .",
    "so the grammar in the original specification of the current language interpretation problem may contain the following rule .",
    "@xmath239 by moving the context condition from the premises to the conclusion we achieve a rule that can contribute to solve the problem deductively . in chrg it becomes the following :    ....       name(n ) , verb(is ) , category(c ) : :>          { categ_of(n , c ) } ,          sentence(is(n , c ) ) .",
    "....    a sentence such as `` tom eats jerry '' is only faithful to a context if the proper categ_of and food_for facts hold in it .",
    "a chrg rule with this in its conclusion looks as follows .    ....",
    "name(n1 ) , verb(eats ) , name(n2 ) : :>           { categ_of(n1,c1 ) , categ_of(n2,c2 ) , food_for(c1,c2 ) } ,           sentence(eats(n1,n2 ) ) . ....",
    "let us now trace the processing of the discourse  ( [ tom - is - cat - etc ] ) when entered into the constraint store ; we record only the context facts .",
    "`` garfield eats mickey '' gives rise to    ....",
    "categ_of(garfield , x1 ) , categ_of(mickey , x2 ) , food_for(x1,x2 ) . ....",
    "the `` x ' 's are uninstantiated variables .",
    "the next `` tom eats jerry '' gives    ....",
    "categ_of(tom , x3 ) , categ_of(jerry , x4 ) , food_for(x3,x4 ) . ....    `` jerry is mouse '' gives ` categ_of(jerry , mouse ) ` , and the background theory immediately unifies x4 with mouse . in a similar way",
    "`` tom is cat '' gives rise to a unification of x3 with cat and ` food_for(x3,x4 ) ` has become    ....",
    "food_for(cat , mouse ) .",
    "....    finally `` mickey is mouse '' produces ` categ_of(mickey , mouse ) ` that triggers the first integrity constraint unifying x2 with mouse and thus the second integrity constraint sets x1=cat and there is no other possibility .",
    "so as part of the solution to this language interpretation problem , we have found that garfield is a cat .",
    "in addition to what we have shown , the user may also define background theories involving prolog rules that include calls to abducibles .",
    "the only restriction is that a call to an abducible must not be embedded in an application of prolog s negation by failure .",
    "interestingly , this form of abduction works also together with a definite clause grammar : declare your abducibles as chrg abducibles ( or chr constraints ) , add integrity constraints and apply them in the body of your dcg rules .",
    "[ dcg - with - abduction - example ] the following dcg together with the declarations of abducibles and integrity constraints written as chr rules will produce the same abducibles as the chrg described above .    ....",
    "name(tom ) -- > [ tom ] .",
    "% etc .",
    "category(mouse ) -- > [ mouse ] .",
    "% etc .",
    "sentence(is(n , c ) ) -- >          name(n ) , [ is ] , category(c ) ,          { categ_of(n , c)}.      sentence(eats(n1,n2 ) ) -- >          name(n1 ) , [ eats ] , name(n2 ) ,          { categ_of(n1,c1 ) , categ_of(n2,c2 ) , food_for(c1,c2)}. ....    the dcg+chr approach to abductive language interpretation works also correctly for ambiguous grammars as backtracking keeps separated the different possible parses with their abducibles",
    ".      the final state may include abducible atoms with variables with the meaning that any ground assignment to such variables ( not conflicting with integrity constraints ) represents a solution to the abductive problem .",
    "consider as an example the following set of abducible atoms returned as part of the answer @xmath240abd(x ) , abd(y)@xmath241 .",
    "it may subsume solutions with x@xmath8y as well as x@xmath9y , e.g. , @xmath240abd(a)@xmath241 , @xmath240abd(b ) , abd(c)@xmath241 ; both may be minimal but the application may impose reasons to prefer the one with fewest elements .",
    "it is possible to extend our method so that it dynamically tries to compact solutions by equating new abducibles to existing ones as a first choice , and then generate the other possibilities under backtracking .",
    "in fact , such a step is included in many abduction algorithms , e.g. ,  @xcite .    to provide this",
    ", we may add for each abducible predicate , an integrity constraint here shown for a predicate abd of arity one .",
    "@xmath242 the semicolon is prolog s disjunction realized by means of backtracking and dif/2 is a lazy test for syntactic nonidentity that behaves the way we specified for built - in `` @xmath9 '' constraints in section  [ chr - section ] . whenever a new abducible fact , say h(a ) or h(x ) , is created by the application of some rule ,  ( [ fido ] )",
    "is applied provided there is another fact p(@xmath35 ) in the constraint store .",
    "notice that  ( [ fido ] ) is logically redundant and only affects the execution .",
    "an optimization of  ( [ fido ] ) using facilities of the implemented version of chr ( see  @xcite for details ) is in place : @xmath243 the pragma prevents the rule from being activated twice due to the symmetry in its head and the purpose of the guard is to suppress useless applications .",
    "the implemented chrg system  @xcite includes this compaction principle as an option .",
    "however , in many cases the problem does not exist as user - defined integrity constraints may instantiate and equate abducibles sufficiently during the computation ; this is the case in the example with garfield and friends above .",
    "the implemented chrg system incorporates a technique for keeping track of the different unambiguous sets of grammar symbols that are created with a locally ambiguous grammar .",
    "each syntax tree and the abducibles associated with it are identified by an index , actually a prolog variable , hence referred to in the following as an _ index variable_. grammar symbols ( apart from token/1 ) and abducibles are given an extra argument to hold the index .    whenever a rule applies to syntax nodes with indices @xmath244,@xmath3,@xmath245 , a new index @xmath1",
    "is created for the new node .",
    "fresh copies are made of any abducible with an index among @xmath244,@xmath3,@xmath245 , but now with @xmath1 as index .",
    "these constraints are called together with any new abducibles from the body of the rule ( also indexed by @xmath1 ) .",
    "this activates possible integrity constraints ( translated in a suitable way to cope with indexes ; see below ) .",
    "this may result in a failure and to avoid the whole computation to stop ( as does a failure in a committed choice language such as chr ) , a suitable control structure is embedded in the body of the rule .",
    "if such a failure occurs , the rule simply succeeds but avoids the creation of a new syntax node ( and cleanses the constraint store for the newly constructed constraints ) ; this effectively stops this branch of computation but allows other successful syntax trees to continue growing .",
    "the compilation of integrity constraints ensures that they only apply to abducibles with identical indices . the compilation of the sample father(f1,c )  father(f2,c ) < = > f1=f2 shows the principle : @xmath246 the final state in a derivation contains the collection of all constraints relating to the different parses ; each parse , i.e. , each competent interpretation can be printed out separately .",
    "this implementation principle involves a quite heavy overhead due to the continual copying of constraints and repeated execution of integrity constraints that have been executed already .",
    "it is available as an option in the chrg system .",
    "obviously this is not an ultimate method for evaluation of all different abductive interpretations in parallel , but it may give inspiration for more efficient methods ; we discuss this topic in the final section .",
    "as our implementation of abduction has shown , chrg can work with different sort of hypotheses passed through the constraint store .",
    "assumption grammars  @xcite ( ags ) are similar to abductive grammars in many respect but differ in that hypotheses are explicitly produced and explicitly used , possible being consumed .",
    "assumption grammars provide a collection of operators that makes it possible to control the scope of these hypotheses which is not possible with an abductive approach .",
    "we describe here an extension of chrgs with a version of ag which is included in the available implementation of the system  @xcite . for simplicity , we describe it in a version that is only correct for locally unambiguous grammars but it is easily extended to ambiguous grammars with the technique described for abductive grammars in section  [ all - abductive - in - parallel - section ] .    in an ag",
    ", the expression + h(a ) means to assert a linear hypothesis which can be used once in the subsequent text by means of the expression -h(a ) ( or -h(x ) , binding x to a ) called an _",
    "expectation_. asserting the hypothesis by h(a ) means that it can be used over and over again .",
    "we deviate slightly from the syntax of  @xcite as to achieve a more symmetric notation and introduce three operators for so - called time - less hypotheses , ` = + ` , ` = - ` , and ` = * ` , whose meaning are similar except that hypothesis can be used and consumed in any order . compared with the initial proposal for ag , our version extends also with other features of chrg , most notably integrity constraints and context parts .",
    "these operators are defined as constraints in chr and can be called from the body of grammar rules .",
    "we introduce the principle by a simplified and incorrect version of the time - less versions given by the following chr rules .    ....",
    "= + a , = -b < = >   a = b .        =",
    "* a \\ = -b < = > a = b . ....    by the first rule , a pair of assumption = + h(a ) and expectation = -h(x ) are removed from the constraint store producing the effect of binding x to a. if assumption = * h(a ) were used instead , the second rule can apply to several instances of = -h(@xmath86 ) .",
    "the problems with this implementation are :    * the computation fails in case one of the rules is applied for incompatible hypotheses , e.g. , = + h(a ) and = -g(x ) . *",
    "if two different hypotheses can apply for the same expectation = -h(x ) things go wrong : rule one will only apply one of them and forget all about the other one , and rule two applies both of them leading obviously to failure .    to repair this ,",
    "we introduce backtracking and give back hypotheses to the store when a choice of an expectation - hypothesis pair is given up ; the latter is necessary as chr uses committed choice . in order to avoid loops , some book - keeping",
    "is added so that a choice already tested is not tried again . for = + the following is sufficient ; the rule for = * is quite similar .",
    "@xmath247 the predicate ` has_tried_rule1 ` uses chr facilities to check whether the indicated instance of the auxiliary constraint ` tried_rule1 ` is present in the store .",
    "the test for unifiability in the guard is an obvious optimization which in principle could have been left out .",
    "the operators denoted by prefix + , - , and are implemented in a quite similar way , with the chrg compiler adding an extra argument corresponding to positions in the input string ; a test that assumption is created textually before expectation is easily added to the guard .",
    "[ example - ag ] we consider sentences with pronouns and coordination such as `` martha likes and mary likes paul , she hates her '' .",
    "we add gender to names and pronouns , and whenever a name appears as subject or object ( in this grammar grouped as nps ) , an assumption is made that the given name is acting .",
    "a pronoun as subject or object gives rise to an expectation for someone acting of appropriate gender .",
    "the principles is shown by the following excerpt .    ....",
    "[ mary ] < :> name(mary , fem ) .",
    "[ she ] < :> pronoun(fem ) .",
    "name(x , gender )   < :> * acting(x , gender ) , np(x , gender ) .",
    "pronoun(gender ) < :> -acting(x , gender ) , np(x , gender ) . ....    to handle the coordination problem , an incomplete sentence followed by and raises a time - less expectation for a subject which is met by the assumption produced by the full sentence at the end .    ....",
    "np(a , _ ) , verb(v ) /-",
    ":> = -ref_object(b ) , sentence(s(a , v , b ) ) .",
    "np(a , _ ) , verb(v ) , np(b , _ ) < :> = * ref_object(b ) , sentence(s(a , v , b ) ) .",
    "....    one of the possible final states produced for the sample text above contains sen symbols with the following attributes :    to 0pt  s(martha , like , paul ) , s(mary , like , paul ) , and s(mary , hate , martha ) .",
    "the ag operators are included in the available chrg package  @xcite together with other facilities of ags described in  @xcite .    as mentioned , the chrg version of ag goes beyond the original proposal by adding integrity constraints .",
    "to see the use of this , consider again example  [ example - ag ] .",
    "another final state for the given sentence gives s(mary , hate , mary ) .",
    "we can exclude this by an integrity constraint to prevent that people hate themselves :    ....        sentence(s(a , hate , a ) ) : :> fail . ....    in general we can have such rules produce new hypotheses , e.g. , = * depressed(a ) instead of failing in the rule above , and combinations of hypotheses can give rise other hypotheses .",
    "chr grammars founded on current constraint logic technology have been introduced , and their application to aspects of natural language syntax has been illustrated by small examples .",
    "chrg can bee seen as a technologically updated ancestor of definite clause grammars : a relative transparent layer of syntactic sugar over a declarative programming language , providing both conceivable semantics and fairly efficient implementation . in chrg",
    "we have replaced prolog by constraint handling rules .",
    "the result of this shift is a very powerful formalism in which several linguistic aspects , usually considered to be complicated or difficult , are included more or less for free :    * ambiguity and grammatical errors are handled in a straightforward way as all different ( partial ) parses are evaluated in parallel .",
    "* context - sensitive rules , which are an inherent part of the paradigm , handle examples of coordination in an immediate way .",
    "* abduction , which is useful for identifying indirectly implied information , is expressed directly with no additional computational devices being involved .",
    "context - sensitive rules combined with the ability to handle left - recursion ( as opposed to dcg ) are a great help for producing grammars with relatively few , concise rules without artificial nonterminals ; a drawback is the lack of empty production .",
    "no real - world applications have been developed in chrg yet , but we have good expectation for scalability as selected grammars can run in linear time .",
    "furthermore , the full flexibility of the underlying chr and prolog machinery is available for optimizations .",
    "independently , chrg is available as powerful modeling and prototyping tool .",
    "the approach of using constraint handling rules for language possesses a potentiality for getting closer to a full integration of lexical , semantic , and pragmatic analysis .",
    "a lexical schism @xmath30 , for example , in the beginning of a discourse may be delayed until a few sentences later when the semantic context is identified so that @xmath30 can be resolved and , thus , that analysis can resume for the first sentence .",
    "although being a very powerful system in itself , chrg and the examples we have tested appear only to touch upon the surface of what is possible .",
    "it is obvious that weights can be added and used to suppress all but the most likely interpretation , and arbitrary constraint solvers can be incorporated in this process .",
    "although presented here as a strict bottom - up paradigm , it is possible to add top - down guidance to parsing in chr and chrg which is useful in order to prevent local ambiguity to result in the creation of a lot of useless constraints ; top - down guidance is applied in the work of  @xcite but for other purposes .    the basic principle may seem quite nave , almost too nave , just applying grammar rules bottom - up over and over until the process stops . however , we can rely now on the underlying , well - established computational paradigm of chr for such rules - based computations . furthermore",
    ", the approach can profit from any future improvements of chr and similar deductive systems .    as noticed above",
    ", our implementation in chr for parallel evaluation of different abductive interpretations of a discourse is far from ideal , but it may serve as an important source of inspiration for the development of better systems . instead of simulating several constraint stores by means of extra index arguments , it seems obvious to apply a sort of shared representation for the different stores so that copying of constraints is avoided .",
    "part of this work has been carried out while the author visited simon fraser university , canada , partly supported by the danish natural science council ; thanks to vernica dahl for helpful discussion and providing a stimulating environment .",
    "this research is supported in part by the ontoquery funded by the danish research councils , and the it - university of copenhagen .",
    "an experimental clp platform for integrity constraints and abduction . in _ proceedings of fqas2000 ,",
    "flexible query answering systems : advances in soft computing series_. physica - verlag ( springer ) , 141152 .    \\1998 . : a flexible query language . in _ proc .",
    "conference on flexible query answering systems fqas , roskilde , denmark _",
    ", t.  andreasen , h.  christansen , and h.  l. larsen , eds .",
    "lncs , vol .",
    "springer - verlag , 115 .",
    ". why should grammars not adapt themselves to context and discourse ? in _",
    "4th international pragmatics conference , kobe , japan , july 2330 1993 , ( abstract collection)_. international pragmatics association , 23 . extended version : http://www.dat.ruc.dk/~henning/ipra93.ps .",
    "open theories and abduction for context and accommodation . in _ proceedings of the 2nd international and interdisciplinary conference on modeling and using context ( context-99 ) _ , p.  bouquet , l.  serafini , p.  brzillon , m.  benerecetti , and f.  castellani , eds .",
    "lnai , vol .",
    "springer , berlin , 455458 .",
    "a constraint - based bottom - up counterpart to dcg . in _ proceedings of ranlp 2003 ,",
    "recent advances in natural language processing , bovorovets , bulgaria ,",
    "1012 september 2003 _ , g.  angelova , k.  bontcheva , r.  mitkov , n.  nicolov , and n.  nikolov , eds .",
    "incoma ltd .",
    ", 105111 .",
    "\\2004 . assumptions and abduction in prolog . in _",
    "3rd international workshop on multiparadigm constraint programming languages , multicpl04 ; at the 20th international conference on logic programming , iclp04 saint - malo , france , 6 - 10 september , 2004 _ , e.  albert , m.  hanus , p.  hofstedt , and p.  van roy , eds . to appear .              ,",
    "tarau , p. , and li , r. 1997 .",
    "assumption grammars for processing natural language . in _ proceedings of the 14th international conference on logic programming _ , l.  naish , ed . mit press , cambridge , 256270 .",
    "parsing with tree descriptions : a constraint - based approach . in _",
    "6th international workshop on natural language understanding and logic programming ( nlulp 99 ) , december 3 - 4_. las cruces , new mexico , usa , 1732 .        ,",
    "kempson , r. , and pitt , j. 1997 . labeled abduction and relevance reasoning . in _",
    "nonstandard queries and nonstandard answers _ , r.  demolombe and t.  imielinski , eds . oxford science publications , , 155185 .",
    "\\1999 . compiling constraint handling rules into prolog with attributed variables . in _ principles and practice of declarative programming , international conference ppdp99 , paris , france ,",
    "september 29 - october 1 , 1999 , proceedings _ , g.  nadathur , ed .",
    "lecture notes in computer science , vol . 1702 .",
    "springer - verlag , 117133 .",
    "meta - complexity theorems : talk abstract . in _ principles and practice of constraint programming - cp 2000 , 6th international conference , singapore , september 18 - 21 , 2000 , proceedings _ , r.  dechter , ed .",
    "lecture notes in computer science , vol . 1894 .",
    "springer , 1317 ."
  ],
  "abstract_text": [
    "<S> a grammar formalism based upon chr is proposed analogously to the way definite clause grammars are defined and implemented on top of prolog . </S>",
    "<S> these grammars execute as robust bottom - up parsers with an inherent treatment of ambiguity and a high flexibility to model various linguistic phenomena . </S>",
    "<S> the formalism extends previous logic programming based grammars with a form of context - sensitive rules and the possibility to include extra - grammatical hypotheses in both head and body of grammar rules . among the applications are straightforward implementations of assumption grammars and abduction under integrity constraints for language analysis . </S>",
    "<S> chr grammars appear as a powerful tool for specification and implementation of language processors and may be proposed as a new standard for bottom - up grammars in logic programming .    </S>",
    "<S> [ firstpage ]    constraint logic programming , constraint handling rules , logic grammars </S>"
  ]
}