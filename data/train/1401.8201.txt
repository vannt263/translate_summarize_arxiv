{
  "article_text": [
    "graph databases , and the design and analysis of query languages appropriate for graph data , have a rich history in database systems and theory research @xcite .",
    "originally investigated from the perspective of object - oriented databases , interest in graph databases research has been continually renewed , motivated by data on the web @xcite and new applications such as dataspaces @xcite , linked data @xcite , and rdf @xcite .",
    "typical of access to graph - structured data is its navigational nature . indeed , in restriction to trees",
    ", there is a standard navigational query language , called xpath , whose expressive power has been intensively studied @xcite .",
    "xpath has been formalized in terms of a number of basic operators on binary relations @xcite .",
    "hence a natural approach @xcite is to take this same set of operators but now evaluate them over graphs instead of over trees .",
    "our goal in this paper is to understand the relative importance of the different operators in this setting .    concretely ,",
    "in the present paper , we consider a number of natural operators on binary relations ( graphs ) : union ; composition ; intersection ; set difference ; projection ; coprojection ; converse ; and the identity and diversity relations .",
    "while some of these operators also appear in xpath , they are there evaluated on trees . the largest language that we consider has all operators , while the smallest language has only union , composition , and the identity relation .",
    "when a language has set difference , it also has intersection , by @xmath0 .",
    "interestingly , the ensemble of all operators except intersection and set difference precisely characterizes the first - order queries safe for bisimulation @xcite .",
    "this logical grouping of operators is also present in our research , where we often have to treat the case without intersection separately from the case with intersection .    just as in the relational algebra",
    ", expressions are built up from input relation names using these operators . since each operator maps binary relations to binary relations , these query languages express queries from binary relations to binary relations :",
    "we call such queries _ path queries_. by identifying nonemptiness with",
    "the boolean value ` true ' and emptiness with ` false ' , as is standard in database theory @xcite , we can also express yes / no queries within this framework . to distinguish them from general path queries",
    ", we shall refer to the latter as _",
    "boolean queries_.    the contribution of the present paper is providing a complete comparison of the expressiveness of all resulting languages , and this both for general path queries and boolean queries .",
    "while establishing the relative expressiveness for general path queries did not yield particularly surprising results , the task for the case of boolean queries proved much more challenging .",
    "for example , consider the converse operator @xmath1 . on the one hand , adding converse to a language not yet containing this feature sometimes adds boolean query power .",
    "this is , e.g. , the case for the language containing all other features .",
    "the proof , however , is nontrivial and involves a specialized application of invariance under bisimulation known from arrow logics . on the other hand , adding converse to a language containing projection but not containing intersection does not add any boolean query power .",
    "we thus obtain a result mirroring similar results known for xpath on trees @xcite , where , e.g. , downward xpath is known to be as powerful as full xpath for queries evaluated at the root .",
    "let us briefly discuss some of the methods we use .",
    "in many cases where we separate a language @xmath2 from a language @xmath3 , we can do this in a strong sense : we are able to give a single counterexample , consisting of a pair @xmath4 of finite binary relations such that @xmath5 and @xmath6 are distinguishable by an expression from @xmath2 but indistinguishable by any expression from @xmath3 . notice that in general , separation is established by providing an infinite sequence of relation pairs such that some expression from @xmath2 distinguishes all pairs but no expression of @xmath3 distinguishes all pairs .",
    "existence of a single counterexample pair is therefore nonobvious , and we do not really know whether there is a deeper reason why in our setting this strong form of separation can often be established .",
    "strong separation is desirable as it immediately implies separation of @xmath2 not only from @xmath3 but also from the infinitary variant of @xmath3 ( which allows infinite unions , as in infinitary logic @xcite ) .",
    "note that indistinguishability of a pair of finite binary relations can in principle be checked by computer , as the number of possible binary relations on a finite domain is finite .",
    "indeed , in many cases we have used this `` brute - force approach '' to verify indistinguishability . in some cases , however , this approach is not feasible within a reasonable time .",
    "fortunately , by applying invariance under bisimulation for arrow logics @xcite , we can alternatively check a sufficient condition for indistinguishability in polynomial time .",
    "we have applied this alternative approach in our computer checks . finally , the cases where we could not establish strong separation fall in the class of conjunctive queries @xcite . we developed a method based on homomorphism techniques to establish ordinary separation for these cases .",
    "the languages considered here are very natural and date all the way back to the `` calculus of relations '' created by peirce and schrder , and popularized and greatly developed by tarski and his collaborators @xcite .",
    "the full language actually has the same expressive power as 3-variable first - order logic ( fo@xmath7 ) under the active - domain semantics , for path queries as well as for boolean queries . due to the naturalness of the languages , they appear in many other fields where binary relations are important , such as description logics , dynamic logics , arrow logics , and relation algebras @xcite .",
    "thus , our results also yield some new insight into these fields .",
    "the investigation of expressive power as in the present paper is very natural from a database theory perspective . in the above - mentioned fields ,",
    "however , one is primarily interested in other questions , such as computational complexity of model checking , decidability of satisfiability , and axiomatizability of equivalence .",
    "the expressiveness issues investigated in this paper have not been investigated before ..    at this point we must repeat that also in the database field , graph query languages have been investigated intensively .",
    "there is , for example , the vast body of work on conjunctive regular path queries ( crpqs ) @xcite . as a matter of fact , crpqs",
    "are subsumed in the calculus of relations , with the exception of the kleene star ( transitive closure ) operator .",
    "indeed , the results reported in this journal article have been extended to the setting where transitive closure is present , as originally announced in our conference paper @xcite .",
    "this extension will be elaborated in a companion journal article @xcite ; additional results on the special case of a single relation name have been published in a third journal article @xcite .",
    "this paper is further organized as follows . in section[sec - prelim ] , we define the class of languages studied in the paper . in section[sec : resol - expr ] , we describe the techniques we use to separate one language from another . in section",
    "[ sec : technical - results ] we present our two main technical results in a self - contained manner : first , the added power of projection in expressing boolean queries , compared to the language without intersection and coprojection ; second , the elimination of converse in languages with projection , but without intersection .",
    "then we establish the complete hasse diagram of relative expressiveness .",
    "we do so for path queries in section[sec : path - queries ] , and for boolean queries in section[sec : boolean - queries ] . finally , we discuss future research directions in section[sec : further - research ] .",
    "in this paper , we are interested in navigating over graphs whose edges are labeled by symbols from a finite , nonempty set of labels @xmath8 .",
    "we can regard these edge labels as binary relation names and thus regard @xmath8 as a relational database schema . for our purposes , then , a _ graph _",
    "@xmath9 is an instance of this database schema @xmath8 . that is , assuming an infinite universe @xmath10 of data elements called _ nodes _",
    ", @xmath9 assigns to every @xmath11 a relation @xmath12 .",
    "each pair in @xmath13 is called an _ edge _ with label @xmath14 . in what follows",
    ", @xmath13 may be infinite , unless explicitly stated otherwise .",
    "all inexpressibility results in this paper already hold in restriction to finite graphs , however .",
    "the most basic language for navigating over graphs we consider is the algebra @xmath15 whose expressions are built recursively from the edge labels , the primitive @xmath16 , and the primitive @xmath17 , using composition ( @xmath18 ) and union ( @xmath19 ) .",
    "semantically , each expression @xmath20 defines a path query .",
    "a _ path query _ is a function @xmath21 taking any graph @xmath9 as input and returning a binary relation @xmath22 .",
    "here , @xmath23 denotes the _ active domain _ of @xmath9 , which is the set of all entries occurring in one of the relations of @xmath9 .",
    "formally , @xmath24    in detail , the semantics of @xmath15 is inductively defined as follows : @xmath25 the basic algebra @xmath15 can be extended by adding some of the following features : diversity ( @xmath26 ) , converse ( @xmath27 ) , intersection ( @xmath28 , difference ( @xmath29 ) , projections ( @xmath30 and @xmath31 ) , and the coprojections ( @xmath32 and @xmath33 ) .",
    "we refer to the operators in the basic algebra @xmath15 as _ basic features _ ; we refer to the extensions as _",
    "nonbasic features_. the semantics of the extensions is as follows : @xmath34 if @xmath35 is a set of nonbasic features , we denote by @xmath36 the language obtained by adding all features in @xmath35 to @xmath15 .",
    "for example , @xmath37 denotes the extension of @xmath15 with intersection , and @xmath38 denotes the extension of @xmath15 with intersection and both projections . in which only one of the two projections , respectively one of the two coprojections , is present . ]",
    "we will see below that extending the basic algebra with diversity , difference , and converse is sufficient to express all other nonbasic features . this full language @xmath39",
    "is known as the _ calculus of relations_.    we will actually compare language expressiveness at the level of both path queries and boolean queries .",
    "path queries were defined above ; a _ boolean query _ is a function from graphs to @xmath40 .",
    "a path query @xmath21 is expressible in a language @xmath36 if there exists an expression @xmath41 such that , for every graph @xmath9 , we have @xmath42 . similarly , a boolean query @xmath21 is expressible in @xmath36 if there exists an expression @xmath41 such that , for every graph @xmath9 , we have that @xmath43 is nonempty if , and only if , @xmath44 is true . in both cases , we say that _",
    "@xmath21 is expressed by @xmath45_.    in what follows , we write @xmath46 if every path query expressible in @xmath47 is also expressible in @xmath48 .",
    "similarly , we write @xmath49 if every boolean query expressible in @xmath47 is also expressible in @xmath48 .",
    "note that @xmath46 implies @xmath50 , but not necessarily the other way around .",
    "we write @xmath51 and @xmath52 for the negation of @xmath53 and @xmath54 .",
    "the attentive reader will note that every fragment @xmath55 actually depends on the label vocabulary @xmath56 which is arbitrary but fixed .",
    "so to be fully precise we would need to use the notation @xmath57 .",
    "for all the results in this paper , a comparison of fragments of the form @xmath58 ( with @xmath59 being @xmath53 or @xmath54 ) can be interpreted to mean that we have @xmath60 for every @xmath56 . moreover , whenever we have a negative result of the form @xmath61 , this will actually already hold for the simplest @xmath56 consisting of a single label .    to illustrate , in the interpretation described above , the @xmath17 relation may be considered redundant in any fragment that includes the projections .",
    "indeed , we can express @xmath17 as @xmath62 .",
    "this observation falls outside the scope of the present investigation , however , since we do not consider @xmath17 as an optional feature ; it belongs to all fragments considered in this paper .",
    "the language xpath @xcite also includes the path equality operator @xmath63 $ ] ( in xpath called ` general comparison ' ) , with the following semantics : @xmath64(g ) = \\{(m , m)\\mid m\\in\\operatorname{adom}(g)\\ \\&\\",
    "\\exists n\\ , ( m , n ) \\in e_1(g ) \\cap e_2(g)\\}.\\ ] ] this operator can be expressed in the fragment @xmath65 as @xmath66 , as well as in the fragment @xmath67 as @xmath68 .",
    "actually the latter expression is not particular to this example , because it reflects the way in which projection is expressed using converse and intersection , as we will see in section  [ sec : path - queries ] .",
    "our results in section[sec : path - queries ] and [ sec : boolean - queries ] will use the following tools to separate a language @xmath47 from a language @xmath48 , i.e. , to establish that @xmath69 , or @xmath70 .",
    "it will also be useful to consider stronger variants of @xmath51 and @xmath52 .",
    "[ def : strong ] the language @xmath47 is _ strongly separable from _ the language @xmath48 _ at the level of path queries _ if there exists a path query @xmath21 expressible in @xmath47 and a finite graph @xmath9 , such that , for every expression @xmath71 , we have @xmath72 . we write @xmath73 in this case .",
    "similarly , @xmath47 is _ strongly separable from _",
    "@xmath48 _ at the level of boolean queries _ if there exists a boolean query @xmath21 expressible in @xmath47 and two finite graphs @xmath74 and @xmath75 , with @xmath76 true and @xmath77 false , such that , for every expression @xmath71 , @xmath78 and @xmath79 are both empty , or both nonempty .",
    "we write @xmath80 in this case .",
    "since @xmath46 implies @xmath49 , also @xmath70 implies @xmath69 by contraposition . in most instances ,",
    "we can therefore establish separation at the level of general path queries by establishing separation at the level of boolean queries . in the cases where @xmath69 although @xmath49 , we identify a finite graph @xmath9 and an expression @xmath81 in @xmath47 and show that , for each expression",
    "@xmath82 in @xmath48 , @xmath83 .",
    "notice that we actually establish strong path separation in those cases .",
    "to establish separation at the level of boolean queries , we use the following techniques .      two graphs @xmath74 and @xmath75 are said to be _ distinguishable _ at the boolean level in a language @xmath36 if there exists a boolean query @xmath21 expressible in @xmath36 such that exactly one of @xmath76 and @xmath77 is true , and the other is false .",
    "if such a query does not exists , @xmath74 and @xmath75 are said to be _",
    "indistinguishable _ in @xmath36 .    using this terminology ,",
    "two languages @xmath47 and @xmath48 are _ strongly separable _ if there exist two finite graphs @xmath74 and @xmath75 that are distinguishable in @xmath47 , but indistinguishable in @xmath48 .    for two finite graphs @xmath74 and @xmath75 , ( in)distinguishability in a language @xmath36 can easily be machine - checked through the brute - force algorithm described below .",
    "first observe that @xmath84 and @xmath85 are finite since @xmath74 and @xmath75 are finite . moreover , for any @xmath45 in @xmath36 , @xmath86 and @xmath87 .",
    "hence , @xmath78 and @xmath79 are finite and the set @xmath88 is also finite . clearly , @xmath74 is indistinguishable from @xmath75 if this set contains only pairs that are both empty or both nonempty .",
    "the brute - force algorithm computes the above set by first initializing the set @xmath89 ( where @xmath90 is omitted if @xmath91 ) .",
    "it then adds new pairs @xmath92 to @xmath6 by closing @xmath6 pair - wise under the features in @xmath36 .",
    "that is , for every binary operator @xmath93 in @xmath36 and all pairs @xmath94 in @xmath6 the algorithm adds @xmath95 to @xmath6 , and similarly for the unary operators .",
    "since there are only a finite number of pairs , the algorithm is guaranteed to end .",
    "of course , the worst - case complexity of this brute - force algorithm is exponential .",
    "nevertheless , we have successfully checked indistinguishability using this brute - force algorithm in many of the cases that follow .      we will not always be able to use the methodology above to separate two languages .",
    "in particular , to establish that @xmath96 we will employ invariance results under the notion of bisimulation below .",
    "in essence , this notion is based on the notion of bisimulation known from arrow logics @xcite .",
    "below , we adapt this notion to the current setting .",
    "we require the following preliminary definitions .",
    "let @xmath97 denote a _ marked graph _",
    ", i.e. , a graph @xmath9 with @xmath98 .",
    "the _ degree _ of an expression @xmath45 is the maximum depth of nested applications of composition , projection and coprojection in @xmath45 .",
    "for example , the degree of @xmath99 is 1 , while the degree of both @xmath100 and @xmath101 is 2 .",
    "intuitively , the depth of @xmath45 corresponds to the quantifier rank of the standard translation of @xmath45 into @xmath102 . for a set of features @xmath35",
    ", @xmath103 denotes the set of expressions in @xmath36 of degree at most  @xmath104 .    in what follows ,",
    "we are only concerned with bisimulation results regarding @xmath105 .",
    "the following is an appropriate notion of bisimulation for this language .",
    "[ def - diff - bisimilar ]    let @xmath104 be a natural number , and let @xmath106 and @xmath107 be marked graphs .",
    "we say that @xmath108 is bisimilar to @xmath109 up to depth @xmath104 , denoted @xmath110 , if the following conditions are satisfied :    atoms : :    @xmath111 if and only if @xmath112 ; and    @xmath113 if and only if @xmath114 , for    every @xmath115 ; forth : :    if @xmath116 , then , for every @xmath117 in    @xmath84 , there exists some    @xmath118 in @xmath85 such that    both @xmath119 and    @xmath120 ; back : :    if @xmath116 , then , for every @xmath118 in    @xmath85 , there exists some    @xmath117 in @xmath84 such that    both @xmath119 and    @xmath120",
    ".    expressions in @xmath121 of depth at most @xmath104 are invariant under bisimulation :    [ theo - diff - bisimilar ] let @xmath104 be a natural number ; let @xmath45 be an expression in @xmath122 ; and let @xmath123 and @xmath124 be marked graphs . if @xmath110 then @xmath125 .",
    "in other words , if @xmath110 , then any expression of degree at most @xmath104 either both selects @xmath126 in @xmath74 and @xmath127 in @xmath75 , or neither of them . as such , the marked graphs @xmath108 and @xmath109 are _ indistinguishable _ by expressions in @xmath122 .",
    "the proof of proposition[theo - diff - bisimilar ] is by a straightforward induction on @xmath45 .",
    "the following proposition states how we can use proposition[theo - diff - bisimilar ] to show that some boolean query is not expressible in @xmath128 .",
    "[ prop - bisimilar - noparameter ] let @xmath104 be a natural number .",
    "a boolean query @xmath21 is not expressible in @xmath129 if there exist graphs @xmath74 and @xmath75 such that @xmath76 is true and @xmath77 is false , and , for each pair @xmath130 , there exists @xmath131 such that @xmath132 .",
    "we omit the straightforward proof ; we note that the converse implication holds as well @xcite .      to show that @xmath133 , we used an entirely different technique , based on the theory of conjunctive queries and the nonexistence of certain homomorphisms on particular graphs .",
    "the details are given in section  [ sec : zigzag ] .",
    "in this section , two main technical results are shown regarding the power of various operators .",
    "the first result ( proposition  [ bottom - pi - tech ] ) states that the @xmath134 operator ( in combination with the basic operators ) provides some boolean querying power that can not be provided by the @xmath135 and @xmath136 operators .",
    "this is a sharp expressivity result on projection , since adding any other feature to the fragment @xmath137 leads to the expressibility of projection .",
    "[ bottom - pi - tech ] @xmath138 .",
    "since this result is highly technical , it is proven in section  [ sec : zigzag ] .    the second result ( proposition[prop : converse - elimination ] ) shows that , at the level of boolean queries , @xmath139 does not add expressive power in the presence of @xmath134 and in the absence of @xmath140 .",
    "[ prop : converse - elimination ] let @xmath35 be a set of nonbasic features for which @xmath141 and @xmath142 . then , @xmath143 .",
    "[ ex : converse - elimination ] to illustrate proposition[prop : converse - elimination ] , consider the expression @xmath144 in @xmath145 .",
    "the expression @xmath146 can be equivalently expressed in @xmath147 as @xmath148 .",
    "now observe that , for any graph @xmath9 , we have that @xmath149 is nonempty if and only if @xmath150 is nonempty .    using this same observation",
    ", one can express the non - emptiness of the expression @xmath151 in @xmath152 by the non - emptiness of the expression @xmath153 in @xmath154 .",
    "let @xmath45 be an expression in @xmath155 .",
    "without loss of generality , we may assume that @xmath139 is only applied in @xmath45 to edge labels , so for each edge label @xmath14 we also consider @xmath156 as an edge label . by simultaneous induction on the size of @xmath45 ( the number of nodes in the syntax tree ) , we prove for @xmath157 that    * @xmath158 is expressible in @xmath159 ; and * if @xmath160 , then @xmath161 is expressible in @xmath36 .",
    "notice that the second statement is implied by the first , but we need to consider both statements together to make the induction work .",
    "the basis of the induction is trivial .",
    "for all operators except composition we reason as follows : @xmath162    this leaves the case where @xmath45 is of the form @xmath18 .",
    "let @xmath163 be the first node in preorder in the syntax tree of @xmath45 that is not an application of @xmath164 , and let @xmath165 be the expression rooted at @xmath163 . by associativity of @xmath164 , we can equivalently write @xmath45 in the form @xmath166 , where @xmath167 equals the composition of all right - child expressions from the parent of @xmath163 up to the root ( in that order ) .",
    "note that @xmath168 has the same size as @xmath45 .",
    "we now consider the different possibilities for the form of @xmath165 : @xmath169    the crucial rules that eliminate inverse in the composition step are the fourth and the fourth - last .",
    "hence we prove their correctness formally .",
    "let @xmath9 be an arbitrary graph .",
    "then , @xmath170 this proves the fourth rule .",
    "the fourth - last rule follows from the fourth rule and the fact that @xmath171 .",
    "this handles @xmath30 and @xmath32 .    to handle @xmath31 and @xmath33 ,",
    "let @xmath163 now be the first node in reverse preorder that is not an application of @xmath164 .",
    "we can now write @xmath45 as @xmath172 .",
    "the proof is now similar : @xmath173 in particular , if @xmath45 is an expression in @xmath174 , it follows from the above that @xmath30 is expressible in @xmath175 .",
    "proposition[prop : converse - elimination ] now follows from the observation that , for any graph @xmath9 , @xmath43 is nonempty if and only if @xmath176 is nonempty .",
    "proposition  [ prop : converse - elimination ] may remind one of a similar result known for xpath on trees @xcite where downward xpath is known to be as powerful as full xpath for queries evaluated at the root . however , an important difference is that we are using projections both on the first and second column of a relation , whereas in the result on trees only the first projection is present .",
    "indeed , proposition  [ prop : converse - elimination ] no longer holds for a language which only contains the first , but not the second projection , or vice versa .",
    "consider the following two graphs @xmath177 en @xmath178 .",
    "for any expression @xmath179 it must be that @xmath180 .",
    "it is not hard to see that for each @xmath181 , @xmath182 iff @xmath183 and @xmath184 iff @xmath185 .",
    "therefore , it is clear that @xmath74 and @xmath75 are indistinguishable in @xmath186 .",
    "they are , however , distinguishable in @xmath187 by @xmath188 .",
    "notice that the translation used to eliminate converse in the proof of proposition  [ prop : converse - elimination ] could blow - up the size of the expressions exponentially .",
    "indeed , define a family of expressions inductively as follows : @xmath189 and @xmath190 .",
    "let us denote the size of an expression @xmath45 as @xmath191 . clearly , @xmath192 and @xmath193 , which implies that @xmath194 is linear in @xmath163 .",
    "now , let @xmath195 be the expression formed from @xmath196 according to the rules outlined in the proof of proposition  [ prop : converse - elimination ] . clearly , @xmath197 and @xmath198",
    ". therefore , @xmath199 and @xmath200 , which implies that @xmath201 .",
    "on the other hand , our translation is never worse than single - exponential . we leave open whether a polynomial translation is possible .",
    "interestingly , the analogous question about the complexity of translating from fo@xmath7 to @xmath202 , mentioned in the introduction , has not yet been addressed in the literature . for fragments of fo@xmath203",
    ", a relevant result has been reported  @xcite .",
    "we begin by recalling some basic terminology and notions concerning conjunctive queries @xcite . a _ conjunctive query with nonequalities _",
    "is expressed in the form @xmath204 . here",
    "the body @xmath6 is a finite set of relation atoms over the vocabulary @xmath56 , as well as nonequalities of the form @xmath205 .",
    "the head @xmath206 is a tuple of variables from @xmath6 .",
    "the head may be the empty tuple in which case a boolean query is expressed .",
    "given a conjunctive query @xmath207 : @xmath204 and a graph @xmath9 , an _ assignment _ is a function @xmath208 from the set of variables in @xmath207 to @xmath209 .",
    "we call @xmath208 a _ matching _ of @xmath6 in @xmath9 if for each relation atom @xmath210 in @xmath6 , we have @xmath211 , and for each @xmath205 in @xmath6 we have @xmath212 .",
    "the evaluation of @xmath207 on @xmath9 is then defined as @xmath213    in particular , if @xmath206 is empty then @xmath214 is either @xmath215 or empty ; these two possible results are interpreted as the boolean values @xmath216 and @xmath217 respectively .",
    "a query @xmath218 is said to be _ contained _ in a query @xmath219 , if for every graph @xmath9 we have @xmath220 .",
    "this is denoted by @xmath221 .",
    "if @xmath6 is the body of a conjunctive query with nonequalities , then @xmath222 denotes the set of relation atoms in @xmath6 . as is customary in the theory of conjunctive queries",
    ", we can view the body of a conjunctive query without nonequalities as a graph whose nodes are the variables .    recall",
    "that a homomorphism is a matching from a body without nonequalities to another body without nonequalities , viewed as a graph .",
    "[ lem : cqcont ] let @xmath218 : @xmath223 and @xmath219 : @xmath224 be conjunctive queries with nonequalities . if @xmath225 then there exists a homomorphism @xmath226 .",
    "notice that @xmath227 since the identity map is clearly a matching .",
    "hence @xmath228 because @xmath221 by hypothesis .",
    "therefore there exists a matching @xmath229 , which is also a matching from @xmath230 to @xmath231 , and is hence the desired homomorphism .",
    "we say that a directed graph @xmath9 is a _ chain _ if it has no loops or cycles and its _ undirected _ version is isomorphic to the undirected chain with nodes @xmath232 where @xmath163 is the number of nodes of @xmath9 .",
    "such a chain has edges @xmath233 for @xmath234 . beware that in this terminology , a chain may have forward as well as backward edges , as illustrated in figure  [ fig : chain ] .    in 1, ... ,7 ( ) at ( , 1 ) ;     / in 1/2,2/3,4/5 (  ) to [ bend left ] ( ) ;  / in 4/3,6/5,7/6 (  ) to [ bend right ] ( ) ;    the following lemma can easily be proven by structural induction .",
    "[ lem : invdiconjunctive ] if @xmath45 is a union - free expression in @xmath235 , then there exists an equivalent conjunctive query @xmath207 : @xmath236 with nonequalities such that @xmath222 has the form of a disjoint union of chains .",
    "let @xmath237 be the conjunctive query @xmath238 that checks for the existence of the pattern displayed in figure[fig : triplezigzag ] .",
    "the name zzz is derived from the characteristic triple zigzag form of the pattern . for later use , we show the following .",
    "( recall that an _ endomorphism _ of a structure @xmath5 is a homomorphism from @xmath5 to itself . )",
    "[ lem : bzzzendo ] the @xmath239 pattern has no endomorphism except for the identity .",
    "let @xmath208 be an endomorphism of the @xmath239 pattern in figure[fig : triplezigzag ] .",
    "we first show that @xmath240 .",
    "note that there has to start a directed path of length 6 in @xmath241 for the homomorphism property to hold since there starts a directed path of length 6 in @xmath242 .",
    "therefore @xmath240 or @xmath243 .",
    "if @xmath243 then @xmath244 , and hence @xmath245 .",
    "this , however , is not possible since there starts a directed path of length 6 in @xmath246 but not in @xmath247",
    ". therefore @xmath240 .",
    "now , the only thing left to verify is that no chain starting in @xmath242 can be mapped homomorphically on another chain starting in @xmath242 .",
    "first note that every chain starting in @xmath242 has a very special structure , i.e. , a path of forward edges , followed by an inverted edge , which is again followed by the same number of forward edges as before the inverted edge .",
    "therefore , it is clear that a chain @xmath248 starting in @xmath242 can only be mapped on another chain @xmath249 starting in @xmath242 , if and only if , the number of forward edges in @xmath248 minus one is at most the number of forward edges in @xmath250 preceding the inverted edge . in our graph , however , the number of forward edges in every chain starting in @xmath242 minus one is at least seven , and the number of forward edges in every chain starting in @xmath242 preceding the inverted edge is at most six .",
    "therefore we can conclude that @xmath208 maps every node onto itself as desired .",
    "\\(a ) at ( 1,0 ) [ label=-180:@xmath242 ] ; /in cc/3,ff/6 ( ) at ( , 1 ) ;    ( bb ) at ( 2,1 ) [ label=90:@xmath252 ; ( b ) at ( 2,0 ) [ label=90:@xmath253 ;    /in gg/3,hh/4,ii/5,jj/6,kk/7,ll/8 ( ) at ( , 1.7 ) ; ( bbb ) at ( 2,-1 ) [ label=90:@xmath254 ; /in ccc/3,eee/5,fff/6,ggg/7 ( ) at ( , -1 ) ;    /in iii/5,jjj/6,kkk/7,lll/8,mmm/9,nnn/10 ( ) at ( , -0.5 ) ;    /in b/2,c/3 ( ) at ( , 0 ) ;    \\(d ) at ( 4,0 ) ; ( ee ) at ( 5,1 ) ; ( dd ) at ( 4,1 ) ; ( e ) at ( 5,0 ) ; ( ll ) at ( 8,1.7 ) ; ( j ) at ( 7,0.6 ) ; ( mmm ) at ( 9,-0.5 ) [ label=90:@xmath247 ] ; ( nnn ) at ( 10,-0.5 ) [ label=0:@xmath104 ] ; ( f ) at ( 3,0.6 ) ; ( hhh ) at ( 4,-0.5 ) [ label=180:@xmath246 ] ; ( gg ) at ( 3,1.7 ) ; ( ff ) at ( 6,1 ) ; ( fff ) at ( 6,-1 ) ;    \\(ddd ) at ( 4,-1 ) ; ( eee ) at ( 5,-1 ) ; ( ggg ) at ( 7,-1 ) [ label=0:@xmath258 ; /in f/3,g/4,h/5,i/6,j/7 ( ) at ( , 0.6 ) ;     / in a / b , b / c , c / d , d / e , f / g , g / h , h / i , i / j , bb / cc , cc / dd , dd / ee , ee / ff , gg / hh , hh / ii , ii / jj , jj / kk , kk / ll , bbb / ccc , ccc / ddd , ddd / eee , eee / fff , fff / ggg , hhh / iii , iii / jjj , jjj / kkk , kkk / lll , lll / mmm , mmm / nnn (  ) to [ out=20,in=160 ] ( ) ;    \\(f ) to [ out=-20,in=128 ] ( e ) ; ( hhh ) to [ out=-35,in=128 ] ( ggg ) ; ( a ) to [ out=-80,in=170 ] ( bbb ) ;    ( gg ) to [ out=-35,in=128 ] ( ff ) ; ( a ) to [ out=80,in=190 ] ( bb ) ;    we are now ready to prove proposition  [ bottom - pi - tech ] .",
    "the boolean query @xmath237 is expressible in @xmath259 by @xmath260 this can be seen to be equivalent to @xmath261 in @xmath262 ( a general argument for a result of this type will be given in the proof of proposition[prop : converse - elimination ] ) .",
    "let us now , for the sake of contradiction , assume that @xmath237 is also expressible in @xmath235 by an expression @xmath207 . hence , for every graph @xmath9 : ( 1 )  if @xmath263 then @xmath264 , and ( 2 )  if @xmath264 then @xmath263 . since unions in @xmath235 can always be brought outside , we can assume that @xmath265 for some @xmath266 where each @xmath267 is a union - free expression in @xmath235 .",
    "now , since @xmath268 , we also have @xmath269 .",
    "hence there exists @xmath270 such that @xmath271 . by lemma[lem : invdiconjunctive ] , @xmath45 is equivalent to a conjunctive query with nonequalities @xmath272 such that @xmath273 is a disjoint union of chains . furthermore , since @xmath274 there exists a matching @xmath275 which is a homomorphism by definition .",
    "now let @xmath276 be the conjunctive query with nonequalities",
    "@xmath277 so that @xmath278 if and only if @xmath279 for every graph @xmath9 . since @xmath280 for any graph @xmath9 , @xmath278 implies @xmath264 , whence by ( 2 ) @xmath281 . therefore @xmath282 .",
    "by lemma[lem : cqcont ] there is a homomorphism @xmath283 from @xmath239 into @xmath273 .",
    "notice that in the @xmath239 pattern displayed in figure[fig : triplezigzag ] , the left most node , labeled @xmath242 , has three outgoing edges .",
    "furthermore , since @xmath273 is a disjoint union of chains , no node in @xmath273 has 3 outgoing edges , and hence two out of @xmath284 , @xmath285 and @xmath286 are equal .",
    "thus @xmath283 is not injective .",
    "now consider @xmath283 followed by @xmath208 .",
    "this function is an endomorphism of @xmath239 . because @xmath283 is not injective , this endomorphism is not injective , and hence certainly not the identity , which contradicts lemma[lem : bzzzendo ] .",
    "therefore @xmath207 does not exist .",
    "in this section , we characterize the order @xmath53 of relative expressiveness for path queries by theorem[th : path - inclusion ] below .    towards the statement of this characterization , first notice the following interdependencies between features : @xmath287 notice that these rewriting rules with @xmath45 as their input variable provide a means to translate an expression into an equivalent expression in another language .    inspired by the above interdependencies , for any set of nonbasic features @xmath35 , we define @xmath288 to be the smallest superset of @xmath35 satisfying the following rules :    * if @xmath289 , then @xmath290 ; * if @xmath291 and @xmath292 , then @xmath290 ; * if @xmath291 and @xmath293 , then @xmath290 ; * if @xmath294 and @xmath295 , then @xmath289 . * if @xmath294 , then @xmath291 ;    we can compute @xmath288 from @xmath35 by repeated application of the above rules , a process which terminates quickly after at most three iterations .",
    "for example , @xmath296 .",
    "notice that , if @xmath297 , we can always rewrite an expression @xmath298 into an equivalent expression in @xmath48 using the rewriting rules displayed above .",
    "notice that therefore , we obtain    [ th : path - if ] if @xmath297 , then @xmath46 .",
    "we will actually show that the converse also holds , whence    [ th : path - inclusion ] @xmath46 if and only if @xmath297 .",
    "the `` only if '' direction of theorem[th : path - inclusion ] requires a detailed analysis . for clarity of presentation , we divide the languages under consideration into two classes , i.e. , the class @xmath299 of languages without intersection , and the class @xmath300}}$ ] of languages with intersection .",
    "formally : @xmath301}}&= \\ { { \\ensuremath{\\mathcal{n}}}(f ) \\mid \\cap\\ ,   \\in { \\ensuremath{\\overline f}}\\}.   \\end{aligned}\\ ] ] we first establish the `` only if '' direction for the cases where @xmath47 and @xmath48 belong to the same class .",
    "we do so for each class separately in sections[sec : languages - bottom ] and[sec : languages - cap ] . finally , in section[sec :",
    "path - separ - betw - subl ] , we consider the case where @xmath47 and @xmath48 belong to distinct classes .      in this subsection , we show the `` only if '' direction of theorem[th : path - inclusion ] , restricted to @xmath299 , the class of languages without @xmath140 .",
    "stated positively , the proposition states that for fragments @xmath302 and @xmath303 using only the operators @xmath136 , @xmath134 and @xmath304 , @xmath305 can only hold if @xmath306 .",
    "[ prop : path - bottom - hasse ] let @xmath47 and @xmath48 be in @xmath299 . if @xmath307 , then @xmath308 .",
    "propositions[th : path - if ] and[prop : path - bottom - hasse ] combined yield the hasse diagram of @xmath53 for @xmath299 , shown in figure[fig : hasse - noint ] .",
    "it is indeed readily verified that for any two languages @xmath47 and @xmath48 in @xmath299 , there is a path from @xmath47 to @xmath48 in figure[fig : hasse - noint ] if and only if @xmath297 .    [ fig : hasse - noint ]    towards a proof of proposition[prop : path - bottom - hasse ] , we first establish an auxiliary proposition . for later use , we sometimes prove results that are stronger than strictly needed for this purpose .    [ prop : path - bottom ] let @xmath302 and @xmath303 be sets of nonbasic features .    1 .   [ bottom - di ] if @xmath309 and @xmath310 , then @xmath311 .",
    "[ bottom - cpi ] if @xmath312 , @xmath313 , and @xmath314 , then @xmath80 .",
    "[ bottom - conv ] if @xmath315 and @xmath316 , then @xmath73 .",
    "[ bottom - pi ] if @xmath317 and @xmath318 , then @xmath70",
    ".    for ( [ bottom - di ] ) , consider a graph @xmath74 consisting of two self - loops , and a graph @xmath75 consisting of a single self - loop , all with the same label . for any nontrivial expression",
    "@xmath45 not using @xmath136 , @xmath319 or @xmath304 , it is evident that @xmath78 and @xmath79 both contain all possible self - loops in @xmath74 and @xmath75 respectively .",
    "therefore , applying @xmath319 or @xmath304 to any such expressions leads to expressions that show similar behavior on @xmath74 and @xmath75 .",
    "more specifically , they select either all self - loops in both @xmath74 and @xmath75 , or select nothing in both graphs simultaneously . the same reasoning can now be applied to general expressions in @xmath320 .",
    "this reasoning shows that @xmath74 and @xmath75 can not be distinguished in @xmath320 .",
    "they are , however , distinguishable by in @xmath321 by @xmath322 .    for ( [ bottom - cpi ] ) , notice that @xmath323 , whence @xmath320 only contains monotone expressions .",
    "therefore it is clear that a non - monotone query such as @xmath324 is not expressible in @xmath320 .    for ( [ bottom - conv ] )",
    ", we establish strong separation at the level of path queries as explained in section[sec : strong - path - separation ] .",
    "thereto , we consider the graph @xmath9 shown in figure[fig : converse ] . by the brute - force method described in section  [ sec : brute - force - approach ] .",
    "we can exhaustively enumerate all the possible result relations @xmath43 for all expressions @xmath325 , i.e. , not using converse .",
    "there are 128 relations in this list .",
    "it can then be verified that @xmath326 is not present in the list , say @xmath9 consisting of a single edge , then @xmath326 would be expressible without using converse , using the expression @xmath327 .",
    "the proof of ( [ bottom - pi ] ) follows directly from proposition  [ bottom - pi - tech ] since @xmath328 and @xmath329 .",
    "proposition[prop : path - bottom ] is now used to show that for every pair @xmath302 and @xmath303 of sets of nonbasic features for which @xmath330 ( i.e. , for which there is no path in figure[fig : hasse - noint ] ) , that @xmath69 .",
    "the remainder of the proof of proposition[prop : path - bottom - hasse ] is a combinatorial analysis to verify that proposition[prop : path - bottom ] covers all the cases .",
    "first , suppose that @xmath331 .",
    "then , @xmath332 if and only if @xmath333 . hence we have the following possible scenarios : @xmath334 and @xmath335 ; or @xmath336 and @xmath337 . if @xmath334 and @xmath335 , then @xmath338 due to proposition[prop : path - bottom]([bottom - di ] ) .",
    "otherwise , we achieved the result due to proposition[prop : path - bottom]([bottom - conv ] ) .    on the other hand ,",
    "suppose that @xmath339 .",
    "then , @xmath340 .",
    "thus , @xmath341",
    "if and only if @xmath342 . hence there has to exists some @xmath343 such that @xmath344 .",
    "furthermore , since @xmath345 and @xmath346 proposition[prop : path - bottom ] can be applied . notice that we can not apply this proposition directly since it makes use of @xmath347 instead of @xmath302 .",
    "this , however , is no issue since @xmath348 .      in this subsection",
    ", we show the `` only if '' direction of theorem[th : path - inclusion ] , restricted to @xmath300}}$ ] , the class of languages with @xmath140 .",
    "[ prop : path - int - hasse ] let both @xmath47 and @xmath48 be in @xmath300}}$ ] . if @xmath349 , then @xmath308 .",
    "propositions[th : path - if ] and[prop : path - int - hasse ] combined yield the hasse diagram of @xmath53 for @xmath300}}$ ] , shown in figure[fig : hasse - int ] .    towards a proof of proposition[prop : path - int - hasse ] , we first establish the following .",
    "[ prop : path - int ] let @xmath302 and @xmath303 be sets of nonbasic features .    1",
    ".   [ int - diff ] if @xmath350 and @xmath351 , then @xmath80 .",
    "[ int - pi ] if @xmath317 , and @xmath352 , then @xmath80 .    for ( [ int - diff ] ) ,",
    "consider a 3-clique @xmath74 , and a bow - tie @xmath75 consisting of two 3-cliques ( both graphs contain a self - loop on every node ) .",
    "it can be proven by straightforward induction and case analysis that for any nontrivial expression @xmath353 at least @xmath354 or @xmath355 . in either case",
    "it is clear that a projection of any nontrivial expression in @xmath356 evaluated on both graphs leads to all self - loops .",
    "using this fact , it can be seen that a coprojection of any expression in @xmath357 leads to either all self - loops , or a completely empty query result on both graphs simultaneously .",
    "therefore , no expression in @xmath357 can distinguish @xmath74 and @xmath75 .",
    "the graphs , however , are distinguishable by the boolean query expressed by @xmath358 .    for ( [ int - pi ] ) , consider the graphs displayed in figure[fig : separations ]  ( a ) .",
    "notice that expressions in @xmath15 select paths of the same length in both graphs simultaneously , e.g. , if an expression selects all paths of length two in one graph , it also selects all the paths of length two in the other and vice versa .",
    "therefore , expressions using set difference evaluate to empty or nonempty on both graphs simultaneously .",
    "thus , expressions in @xmath359 can not distinguish the considered graphs , whence they are indistinguishable in @xmath320 as well since @xmath360 .",
    "the graphs , however , are distinguishable in @xmath321 by the boolean query expressed by @xmath361 .",
    "propositions[prop : path - bottom ] and[prop : path - int ] are now used to show that for every pair @xmath302 and @xmath303 of sets of nonbasic features for which @xmath362 ( i.e. , for which there is no path in figure[fig : hasse - int ] ) , that @xmath69 .",
    "the remainder of the proof of proposition[prop : path - int - hasse ] is a combinatorial analysis to verify that propositions[prop : path - bottom ] and[prop : path - int ] cover all relevant cases .    by definition @xmath363 and @xmath364 since both @xmath321 and @xmath320 are in @xmath365 $ ] .",
    "hence , @xmath332 if and only if there exists @xmath366 such that @xmath343 and @xmath367",
    ". we will consider every such @xmath368 and show that our result directly follows from propositions  [ prop : path - bottom ] or [ prop : path - int ] .",
    "if @xmath369 , @xmath370 or @xmath371 , then respectively proposition  [ prop : path - bottom]([bottom - di ] ) , [ prop : path - bottom]([bottom - conv ] ) or [ prop : path - int]([int - diff ] ) gives us the desired result .",
    "if @xmath372 , then clearly @xmath373 if and only if @xmath374 .",
    "hence @xmath375 .",
    "now , we can apply proposition[prop : path - int]([int - pi ] ) , which proves the result .",
    "if @xmath376 , then using the interdependencies introduced in the beginning of section[sec : path - queries ] we get @xmath377 so we have two scenarios .",
    "if @xmath378 then we can apply proposition[prop : path - bottom]([bottom - cpi ] ) to prove our result . on the other hand , when @xmath379 we can not apply proposition[prop : path - bottom]([bottom - cpi ] ) .",
    "as said above , now @xmath134 can not be in @xmath380 .",
    "furthermore , note that in this scenario @xmath381 which implies that @xmath382 .",
    "moreover , @xmath383 since @xmath384 .",
    "hence , we can apply proposition[prop : path - int]([int - pi ] ) , which proves the result .",
    "to finish the proof of theorem[th : path - inclusion ] , we finally show the `` only if '' direction for the case where @xmath47 and @xmath48 belong to different classes .",
    "[ prop : path - cross - hasse ] let @xmath47 and @xmath48 be languages such that one language belongs to @xmath299 , and the other language belongs to @xmath300}}$ ] .",
    "if @xmath385 , then @xmath308 .    towards a proof of proposition[prop : path - cross - hasse ] , we first establish the following .",
    "[ prop : path - cross - comp ] let @xmath302 and @xmath303 be sets of nonbasic features . if @xmath386 and @xmath387 , then @xmath80 .",
    "since @xmath388 it must be that @xmath389 .",
    "so , it is sufficient to find a boolean query expressible in @xmath321 , which is not expressible in @xmath390 .",
    "consider the graphs @xmath74 and @xmath75 in figure[fig : separations ]  ( b ) .",
    "notice that there starts and ends a path of every length in each node in both graphs .",
    "utilizing this fact , it can be shown that for any nontrivial expression @xmath391 , it must be that @xmath392 .",
    "using this , it can be seen that the coprojection of any expression in @xmath390 leads to either all self - loops , or a completely empty query result on both graphs simultaneously .",
    "therefore , no expression in @xmath390 can distinguish @xmath74 and @xmath75 .",
    "the graphs , however , are distinguishable by the boolean query expressed by @xmath393 .    as detailed below , propositions[prop : path - bottom ] , [ prop : path - int ] and[prop : path - cross - comp ] are now subsequently used to show that for every pair @xmath302 and @xmath303 of sets of nonbasic features for which @xmath362 , that @xmath394 , in the same way as in section[sec : languages - bottom ] and [ sec : languages - cap ] .    the remainder of the proof of proposition[prop : path - cross - hasse ] is again a combinatorial analysis to verify that the above - mentioned propositions cover all relevant cases .",
    "first , suppose that @xmath395}}$ ] and @xmath396 .",
    "then , by definition @xmath363 and @xmath388 .",
    "the result now follows directly from proposition[prop : path - cross - comp ] .",
    "on the other hand , suppose that @xmath321 is in @xmath299 and @xmath320 is in @xmath300}}$ ] .",
    "clearly , then @xmath397 if and only if @xmath398 .",
    "hence at least one feature @xmath368 of @xmath399 is present in @xmath302 but missing in @xmath380 .",
    "we will consider every such @xmath368 and show that our result directly follows from propositions  [ prop : path - bottom ] , or [ prop : path - int ] .",
    "if @xmath369 or @xmath370 , then respectively proposition  [ prop : path - bottom]([bottom - di ] ) or [ prop : path - bottom]([bottom - conv ] ) gives us the desired result .    if @xmath372 then @xmath339 by the interdependencies introduced in the beginning of section[sec : path - queries ]",
    "furthermore , @xmath400 since by hypothesis @xmath364 .",
    "therefore @xmath401 , and hence proposition[prop : path - int]([int - pi ] ) can be applied , which proves the result .    if @xmath376 then @xmath402 .",
    "suppose that @xmath403 , then our result follows from proposition[prop : path - bottom]([bottom - cpi ] ) .",
    "on the other hand , if @xmath404 , then the result follows from the previous case since @xmath383 .",
    "propositions[th : path - if ] , [ prop : path - bottom - hasse ] , [ prop : path - int - hasse ] and[prop : path - cross - hasse ] , together prove theorem[th : path - inclusion ] .",
    "hence , the hasse diagram of @xmath53 can be obtained from the subdiagrams for @xmath299 and @xmath300}}$ ] by simply adding the 12 canonical inclusion arrows between the subdiagram for @xmath299 and the subdiagram for @xmath300}}$ ] . however , in the presence of @xmath140 , @xmath136 or @xmath139 gives @xmath134 , so the arrows from @xmath405 to @xmath406 , @xmath407 to @xmath408 , and @xmath235 to @xmath409 are transitive , and can therefore be omitted .",
    "so , all paths between the subdiagrams are induced by these canonical inclusion arrows and the 5 equations from the beginning of section[sec : path - queries ] .",
    "in this section , we characterize the order @xmath54 of relative expressiveness for boolean queries by theorem[th : bool - inclusion ] below .    towards the statement of this characterization , first observe that @xmath46 implies @xmath49 .",
    "the converse does not hold , however . indeed , from proposition[prop :",
    "converse - elimination ] , it follows that , e.g. , @xmath410 . from theorem[th",
    ": path - inclusion ] , however , we know that @xmath411 .    to accommodate the collapse of @xmath139 in our characterization of @xmath54 , we introduce some new notation . for a set of nonbasic features @xmath35 , define @xmath412 as follows .",
    "@xmath413 for example , @xmath414",
    ".    we will establish the following characterization .",
    "[ th : bool - inclusion ] let @xmath302 and @xmath303 be sets of nonbasic features .",
    "then , @xmath415 if and only if @xmath306 or @xmath416    the `` if '' direction of theorem[th : bool - inclusion ] is shown by proposition[th : path - if ] ( since @xmath53 implies @xmath54 ) and proposition[th : bool - if - cross ] .    [ th : bool - if - cross ] if @xmath416 then @xmath417 .",
    "we distinguish two cases . if @xmath418 , then @xmath305 , by proposition[th : path - if ] , whence @xmath417 .    in the other case , @xmath419 , and @xmath420 .",
    "hence @xmath421 by proposition[prop : converse - elimination ] .",
    "furthermore , @xmath422 since @xmath416 by proposition[th : path - if ] , whence @xmath423 .",
    "now , by transitivity @xmath417 as desired .    the converse of this proposition does not hold in general , e.g. , @xmath424 but @xmath425 .",
    "the `` only if '' direction of theorem[th : bool - inclusion ] , requires a detailed analysis , which proceeds along the same lines as the analysis in section[sec : path - queries ] .",
    "we first establish the `` only if '' direction for the cases where @xmath47 and @xmath48 belong to the same class among @xmath299 and @xmath300}}$ ] , and then consider the case where @xmath47 and @xmath48 belong to distinct classes .      in this subsection , we show the `` only if '' direction of theorem[th : bool - inclusion ] , restricted to @xmath299 , the class of languages without @xmath140 .",
    "[ prop : bool - bottom - hasse ] let @xmath47 and @xmath48 be in @xmath299 . if @xmath341 and @xmath426 , then @xmath70 .",
    "propositions[th : path - if],[th : bool - if - cross ] and[prop : bool - bottom - hasse ] combined yield the hasse diagram of @xmath54 for @xmath299 , shown in figure[fig : hasse - noint - bool ] .",
    "it is indeed readily verified that for any two languages @xmath47 and @xmath48 in @xmath299 , there is a path from @xmath47 to @xmath48 in figure[fig : hasse - noint - bool ] if and only if @xmath427 or @xmath416 .    towards a proof of proposition[prop : bool - bottom - hasse ] , we first establish the following .",
    "[ prop : conv - di ] let @xmath35 be a set of nonbasic features .",
    "if @xmath428 , then we have @xmath429 .",
    "let @xmath430 be the class of all graphs @xmath9 such that @xmath9 is acyclic and @xmath23 contains at least three elements , and let @xmath431 .",
    "we will show that on the class @xmath430 , the boolean query @xmath432 is either @xmath433 ( always false ) or equivalent to @xmath434 for some natural number @xmath435 .",
    "let us first show this for union - free expressions . since @xmath436 in @xmath430 for @xmath437 , we may assume that @xmath438 where @xmath439 and @xmath440 are natural numbers greater than zero .",
    "we set @xmath435 to be the maximum of the @xmath441 for @xmath442 .",
    "let @xmath9 be an arbitrary graph in @xmath430 . clearly , if @xmath279 then @xmath443 .",
    "for the other direction , assume @xmath444 .",
    "since @xmath9 is acyclic , @xmath205 , so @xmath445 .",
    "hence @xmath446 .",
    "for any @xmath447 , we also have @xmath448 .",
    "we conclude that @xmath449 . in particular",
    ", @xmath43 is nonempty as desired .",
    "for the claim to hold with union , it suffices to show it for a union of two union - free expressions .",
    "indeed , the form @xmath450 is union - free !",
    "so , consider an expression @xmath45 of the form @xmath451 .",
    "then @xmath432 is equivalent to @xmath452 , which proves the claim .    now consider graphs @xmath74 and @xmath75 in figure  [ fig : separations](a ) .",
    "these graphs belong to @xmath430 , and are clearly indistinguishable by any expression of the form @xmath453 .",
    "the graphs , however , are distinguishable by the boolean query @xmath454 .    as detailed below , propositions[prop : path - bottom ] and[prop : conv - di ] are now subsequently used to show that for every pair @xmath302 and @xmath303 of sets of nonbasic features for which @xmath455 , that @xmath70 , in the same way as in section[sec : languages - bottom ] and [ sec : languages - cap ] .",
    "the remainder of the proof of proposition[prop : bool - bottom - hasse ] is again a combinatorial analysis to verify that the above - mentioned propositions cover all relevant cases .",
    "first , note that @xmath456 since @xmath321 and @xmath320 are in @xmath430 .",
    "we will consider two cases : @xmath457 and @xmath458 .",
    "first we will consider @xmath457 .",
    "since @xmath426 , there must be another feature , not equal to @xmath135 or @xmath134 present .",
    "if this feature is @xmath136 , then proposition[prop : path - bottom]([bottom - di ] ) proves the result . on the other hand , if this feature is @xmath304 then proposition[prop : path - bottom]([bottom - cpi ] ) proves the result .",
    "now consider the case where @xmath373 . here ,",
    "@xmath459 and thus @xmath460 .",
    "hence one of @xmath461 or @xmath136 is present in @xmath302 but missing in @xmath380 .",
    "if that feature is @xmath139 , then @xmath462 , and hence proposition[prop : conv - di ] proves the result . on the other hand , if that feature is @xmath463 or @xmath134 , the result follows directly from proposition[prop : path - bottom ] .      in this subsection",
    ", we show the `` only if '' direction of theorem[th : bool - inclusion ] , restricted to @xmath300}}$ ] , the class of languages with @xmath140 .",
    "[ prop : bool - cap - hasse ] let @xmath47 and @xmath48 be in @xmath300}}$ ] . if @xmath341 and @xmath426 , then @xmath80 .",
    "notice that since @xmath363 , @xmath464 .",
    "hence , theorem[th : path - inclusion ] and proposition[prop : bool - cap - hasse ] combined show that @xmath54 coincides with @xmath53 on @xmath300}}$ ] . as a result , the hasse diagram of @xmath54 for @xmath300}}$ ] is the same as the hasse diagram of @xmath53 for @xmath300}}$ ] shown in figure[fig : hasse - int ] .",
    "note that , in addition , all separations are strong .    towards a proof of proposition[prop : bool - cap - hasse ] , we first establish the following .",
    "[ prop : bool - converse - cap ] let @xmath302 and @xmath303 be sets of nonbasic features . if @xmath465 , @xmath466 , and @xmath467 , then @xmath468 .    the graphs @xmath74 and",
    "@xmath75 shown in figure[fig : separations ]  ( c ) , top and bottom , are distinguished by the boolean query @xmath21 expressed by @xmath469 . on these graphs ,",
    "the brute - force algorithm of section[sec : brute - force - approach ] does not terminate in a reasonable time .",
    "it can be verified in polynomial time , however , that for each pair @xmath130 , there exists @xmath470 such that @xmath471 for any depth @xmath104 @xcite . from proposition[prop - bisimilar - noparameter ] , it follows that @xmath21 is not expressible in @xmath48 .",
    "the remainder of the proof of proposition[prop : bool - cap - hasse ] proceeds as the proof of proposition[prop : path - int - hasse ] , except that proposition[prop : bool - converse - cap ] is used instead of proposition[prop : path - bottom ]  ( [ bottom - conv ] ) .",
    "to finish the proof of theorem[th : bool - inclusion ] , we finally show the `` only if '' direction for the case where @xmath47 and @xmath48 belong to different classes .",
    "[ prop : bool - cross - hasse ] let @xmath47 and @xmath48 be languages such that one language belongs to @xmath299 , and the other language belongs to @xmath300}}$ ] . if @xmath341 and @xmath426 , then @xmath472 .    towards a proof of proposition[prop : bool - cross - hasse ] , we first establish the following .",
    "[ prop : conv - cross ] let @xmath302 be a set of nonbasic features .",
    "if @xmath315 , and @xmath473 , then @xmath80 .",
    "consider the graphs @xmath74 and @xmath75 displayed in figure[fig : separations ]  ( a ) and define @xmath474 to equal @xmath475 for @xmath476 .",
    "first , notice that @xmath475 , @xmath477,and @xmath478 are pairwise disjoint for @xmath476 . utilizing this",
    ", it can be proven by straightforward induction that for every @xmath479 there exists @xmath480 such that @xmath481 and @xmath482 .",
    "this clearly implies that @xmath74 and @xmath75 are indistinguishable in @xmath359 .",
    "whence they are also indistinguishable in @xmath320 as well since @xmath360 .",
    "the graphs , however , are distinguishable by the boolean query expressed by @xmath483 .",
    "as detailed below , propositions[prop : path - bottom ] , [ prop : path - int ] , [ prop : path - cross - comp ] and[prop : conv - cross ] are now subsequently used to show that for every pair @xmath302 and @xmath303 of sets of nonbasic features for which @xmath341 and @xmath426 , that @xmath70 , in the same way as in sections[sec : languages - bottom - bool ] and[sec : languages - cap - bool ] .",
    "the remainder of the proof of proposition[prop : bool - cross - hasse ] is again a combinatorial analysis to verify that the above - mentioned propositions cover all relevant cases .    if @xmath484}}$ ] and @xmath485 , then @xmath363 and @xmath486 .",
    "hence proposition[prop : path - cross - comp ] directly implies our result .",
    "conversely , if @xmath487 and @xmath488}}$ ] , then @xmath489 is present in @xmath302 , but lacking in @xmath380 .",
    "we will now consider every such @xmath368 .",
    "if @xmath490 then the proof proceeds as the proof of proposition[prop : path - int - hasse ] .    if @xmath370 , then @xmath491 since @xmath487 .",
    "furthermore , by hypothesis , there is a feature @xmath368 present in @xmath492 which is not present in @xmath380 .",
    "notice that @xmath493 .",
    "if @xmath494 , then there exists a feature in @xmath302 other than @xmath139 which is missing in @xmath380 , hence the result follows from the previous case . on the other hand , if @xmath372 , then @xmath495 .",
    "hence @xmath496 , and thus the result follows directly from proposition[prop : conv - cross ] .",
    "propositions[th : path - if],[th : bool - if - cross],[prop : bool - bottom - hasse ] , [ prop : bool - cap - hasse ] and[prop : bool - cross - hasse ] , together prove theorem[th : bool - inclusion ] .",
    "hence , the hasse diagram of @xmath54 can be obtained from the subdiagrams for @xmath299 , and @xmath300}}$ ] by simply adding arrows from @xmath15 to @xmath497 , @xmath498 to @xmath406 , @xmath262 to @xmath499 , @xmath500 to @xmath501 and @xmath502 to @xmath503 .",
    "so , all paths between the subdiagrams are induced by these arrows , the 5 equations from the beginning of section[sec : path - queries ] , and proposition[prop : converse - elimination ] .",
    "there are alternative modalities for expressing boolean queries apart from interpreting the nonemptiness of an expression as the value true and emptiness as the value false .",
    "for example , one possibility is to consider a boolean query @xmath21 expressible if there are two expressions @xmath81 and @xmath82 such that @xmath504 if , and only if , @xmath44 is true , for all @xmath9 .",
    "for some of our languages , such alternative modalities would not make a difference , but it would for others .",
    "looking into these alternative modalities is an interesting topic for further research .    in the present paper , we have been focusing on expressive power , but , of course , it is also interesting to investigate the decidability of satisfiability or containment of expressions .",
    "much is already known . from the undecidability of fo@xmath7",
    ", it follows that the most powerful language is undecidable , and the same holds even without converse . from the decidability of icpdl @xcite ,",
    "all languages without set difference have a decidable satisfiability problem , although this is not yet known for satisfiability restricted to finite relations .",
    "an interesting question is the decidability of satisfiability or validity of the languages with set difference , but without the diversity relation .",
    "recently , it has been shown that finite satisfiability for the quite weak fragment @xmath505 without @xmath17 , formed by the operators union , composition , set difference and nothing else , over a single binary relation , is still undecidable @xcite .",
    "another natural question is whether the notion of arrow logic bisimulation , that we use as a tool to prove some nonexpressibility results , can actually be adapted to obtain characterizations of indistinguishability in the various languages , as is the case for modal logic @xcite .",
    "we have in fact done this for all languages with intersection @xcite .",
    "a further question then is whether van benthem - style expressive completeness results @xcite can be established .    finally , there are still other interesting operators on binary relations that can be considered .",
    "a good example is residuation @xcite , a derived operator of the calculus of relations , and interesting to consider separately , as we have done for projection and coprojection .",
    "residuation is interesting from a database perspective because it corresponds to the set containment join @xcite .",
    "we thank the anonymous referees for their constructive feedback .",
    "we thank balder ten cate and maarten marx for helpful information on the question of succinctness of fo@xmath7 compared to the algebra @xmath506 .",
    "r.  angles , p.  barcel , and g.  rios . a practical query language for graph dbs . in l.",
    "bravo and m.  lenzerini , editors , _ proceedings 7th alberto mendelzon international workshop on foundations of data management _ , volume 1087 of _ ceur workshop proceedings _ , 2013 .",
    "fletcher , m.  gyssens , d.  leinders , d.  surinx , j.  van  den bussche , d.  van  gucht , s.  vansummeren , and y.  wu . relative expressive power of navigational query on graphs using transitive closure . in preparation .",
    "fletcher , m.  gyssens , d.  leinders , j.  van  den bussche , d.  van  gucht , s.  vansummeren , and y.  wu . relative expressive power of navigational querying on graphs . in _",
    "proceedings 14th international conference on database theory _ , 2011 .",
    "fletcher , m.  gyssens , d.  leinders , j.  van  den bussche , d.  van  gucht , s.  vansummeren , and y.  wu . the impact of transitive closure on the expressiveness of navigational query languages on unlabeled graphs . , 2013 . published online , 2 april .",
    "fletcher , m.  gyssens , d.  leinders , j.  van  den bussche , d.  van  gucht , and s.  vansummeren .",
    "similarity and bisimilarity notions appropriate for characterizing indistinguishability in fragments of the calculus of relations . , 2014 .",
    "to appear .",
    "m.  otto .",
    "model theoretic methods for fragments of fo and special classes of ( finite ) structures . in j.  esparza , c.  michaux , and c.  steinhorn , editors , _ finite and algorithmic model theory _ , volume 379 of _ lecture note series _ , chapter  7 .",
    "london mathematical society , 2011 ."
  ],
  "abstract_text": [
    "<S> motivated by both established and new applications , we study navigational query languages for graphs ( binary relations ) . </S>",
    "<S> the simplest language has only the two operators union and composition , together with the identity relation . </S>",
    "<S> we make more powerful languages by adding any of the following operators : intersection ; set difference ; projection ; coprojection ; converse ; and the diversity relation . </S>",
    "<S> all these operators map binary relations to binary relations . </S>",
    "<S> we compare the expressive power of all resulting languages . </S>",
    "<S> we do this not only for general path queries ( queries where the result may be any binary relation ) but also for boolean or yes / no queries ( expressed by the nonemptiness of an expression ) . for both cases , we present the complete hasse diagram of relative expressiveness . in particular </S>",
    "<S> the hasse diagram for boolean queries contains some nontrivial separations and a few surprising collapses . </S>"
  ]
}