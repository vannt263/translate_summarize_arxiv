{
  "article_text": [
    "one area of major successes for formal methods has been the verification of security protocols .",
    "a number of specialized tools have been developed in the last decade that have exposed subtle flaws in existing protocols ( see , e.g. @xcite ) .",
    "for the most part , however , these tools have been used by the researchers that developed them , and less attention has been paid to usability issues .    this paper presents a new approach to formulating and checking cryptographic protocols .",
    "it does not enable any new form of analysis .",
    "instead , it makes verification more accessible to the designers of protocols .",
    "its key contribution is a new characterization of these protocols that is both closer to how designers conceive them , and amenable to a more direct encoding in standard first - order logic .",
    "this more direct encoding allows existing tools to be applied as black boxes without modification ; it requires no tweaking of parameters or issuing of special directives by the user .",
    "moreover , because the semantic gap between informal descriptions of protocols and their formalization is smaller , there are fewer opportunities for errors to creep in .    in this paper , the alloy modeling language is used to record the details of the protocol and its security goals , and the alloy analyzer is used to find flaws .",
    "the approach , however , requires no special features of alloy or its analysis , and could be applied in the context of any formal method based on first - order logic .",
    "its simplicity suggests that it may be useful in teaching ; indeed , using the approach , we have explained cryptographic protocols to undergraduates who have had only a few weeks of experience in formal methods .    our approach , which we call _ knowledge flow analysis _ , gives a uniform framework for expressing the actions of principals , assumptions on intruders , and properties of cryptographic primitives .",
    "the dynamic behaviour of the protocol is described by an initial state of knowledge , and a collection of rules that dictate how knowledge may flow amongst principals .",
    "a state is given by a relation mapping principals to the values they know ; the allowable knowledge flows can thus be succinctly described as a standard transition relation on knowledge states , written as a constraint .    this simple setup allows us to model a range of intruder capabilities and to detect replay , parallel session , type flaw , and binding attacks .",
    "we have applied it to both symmetric and public - key cryptography under the dolev - yao @xcite approach .",
    "the modeling framework itself is more general , however , and can be extended to include the properties of cryptographic primitives @xcite and an unbounded number of sessions with bounded messages @xcite .",
    "this approach grew out of an effort to check a new cryptographic scheme @xcite .",
    "knowledge flow analysis described here was the final result of a series of incremental attempts at formalizing and checking the protocol using the alloy language and tool .",
    "this process helped crystallize our intuitions , and drew out a number of important assumptions .",
    "the final analysis , although only performed over a finite domain , actually establishes the correctness of the protocol for unbounded instantiations because of a special property of this protocol .",
    "the alloy models developed for this case study were generalized into a simple framework that was subsequently applied to some standard protocols , such as needham - schroeder @xcite and otway - rees @xcite .",
    "the contributions of this paper are :    .    the knowledge flow formalism , which characterizes the dynamic behaviour of a cryptographic protocol in terms of the increasing knowledge of the principals , avoiding the need to impose an explicit ordering on messages ;    a realization in the alloy modelling language as a generic framework with a library of primitives that can be easily instantiated for a variety of protocols ;    soundness and completeness results that guarantee that ( 1 ) any counterexample generated by the analyzer to a security theorem is legitimate , and not an artifact of the modelling framework , formalism or analysis ; and ( 2 ) that if a counterexample exists involving any number of message exchanges and any number of steps , it will be found , so long as the number of parallel sessions is within a prescribed bound ;    case study applications of the approach to two well - known protocols , one of which ( needham - schroeder )",
    "is explained in detail , and to a new key management scheme based on controlled physical random functions @xcite .",
    "section 2 explains the key intuitions underlying the approach , using needham schroeder as an example .",
    "section 3 shows the complete formalization of this example , including the statement of the security goal , and a discussion of the counterexample corresponding to the well - known attack .",
    "section 4 gives a mathematical summary of the approach without reference to any particular modeling language that might serve as a basis for implementations in other tools , and which makes precise the assumptions underlying the model .",
    "the paper closes with an evaluation and a discussion of related work .",
    "the key idea behind knowledge flow analysis is the observation that , at the most basic level , the purpose of a security protocol is to distribute knowledge among its legitimate participants .",
    "a protocol is flawed if it allows an intruder to learn a value that is intended to remain strictly within the legitimate principals pool of knowledge . to gain more intuition about knowledge flows in security applications ,",
    "consider the needham - schroeder public key protocol @xcite shown in figure [ ns - diagram ] .",
    "we have two principals , alice and bob , each of whom has an initial pool of knowledge represented with white boxes .",
    "alice s initial knowledge , for example , consists of her own public / private key pair @xmath0/@xmath1 , identity @xmath2 , nonce @xmath3 , and bob s public key @xmath4 and identity @xmath5 .",
    "the purpose of the protocol is to distribute the nonces between alice and bob in such a way that the following conditions hold at the end : ( 1 ) alice and bob both know @xmath3 and @xmath6 , and ( 2 ) no other principal knows the nonces .    to initiate the protocol",
    ", alice first expands her pool of knowledge to include @xmath7 , an encryption of her identity and nonce with bob s public key .",
    "she then sends the cipher to bob who decrypts it using his private key , @xmath8 . at the end of the first step of the protocol",
    ", each principal s knowledge has increased to include the values in light gray boxes .",
    "bob performs the second step of the protocol by adding @xmath9 to his current knowledge and sending the cipher to alice .",
    "she uses her private key to decrypt bob s message and extract @xmath6 . by using @xmath6 and @xmath4",
    ", alice can set up an authenticated and private channel with bob as is done during the final step of the protocol in which alice creates @xmath10 and forwards it to bob .",
    "both alice and bob now know the two nonces and share all other knowledge except their secret keys .",
    "following the flow of knowledge in the needham - schroeder protocol provides a crucial insight underlying our analysis method .",
    "namely , a principal can learn a value in one of three ways ; he can    @xmath11    _ draw _ the value at the start ,    _ compute _ it using his current knowledge , or    _ learn _ it by communication .",
    "our analysis treats the latter two ways of obtaining knowledge as equivalent .",
    "specifically , we can think of alice s computing @xmath7 as her learning it from a principal called _ encryptor _ whose initial pool of values includes all possible ciphers : alice sends the tuple @xmath12 to _ encryptor _ who responds by sending back the encryption of @xmath13 with @xmath4 .    treating cryptographic primitives as principals allows us to consider the total pool of knowledge to be _",
    "fixed_. that is , the set of all values before and after the execution of a security protocol is the same ; the only difference is the distribution of those values among the principals .",
    "since we assume that principals never forget values , the set of principals who know a value at the end of a protocol session subsumes the set of principals who drew the value at the beginning .",
    "the goal of analyzing knowledge flows in a protocol is to verify that particular values never leak out of the honest participants pool of knowledge . in other words ,",
    "_ we are interested in analyzing the flow of knowledge from an intruder s perspective_. this observation allows us to make sound simplifying assumptions that drastically reduce the effort needed to formalize a protocol in terms of knowledge flows :    @xmath11    we need not encode the flows of knowledge among the honest principals , such as the flow which allows alice to learn @xmath9 from @xmath14 .",
    "rather , we may assume that each honest principal draws all values in the total knowledge pool and specify protocols solely in terms of the intruders knowledge flows ( sections [ kf - basic - defs ] and [ initial - knowledge ] ) .",
    "we may model all adversaries , including the untrusted public network , with a single opponent whom we call @xmath15 .",
    "the soundness of this approach is formally proved in section [ adversary ] . intuitively , the approach makes sense if we note that the potential adversaries will be most effective when they collaborate and share knowledge among themselves .",
    "hence , we can replace the ( collaboration of ) adversaries with a single principal who possesses all their knowledge , without excluding any intrusion scenarios .    in our example",
    ", the flow of knowledge from the intruder s perspective starts with the protocol initialization message @xmath7 , since oscar needs no prior knowledge to learn the first cipher that alice sends to bob .",
    "in general , because oscar includes the untrusted public network , he learns the first message of the protocol for free , regardless of who its intended recipient and sender are : @xmath16.\\label{ns1}\\ ] ] the variables @xmath17 and @xmath18 denote the honest principals ( alice and bob ) , and the set @xmath19 stands for oscar .",
    "the notation @xmath20 represents the nonce that the nonce primitive @xmath21 generated for the principal identified by @xmath22 using the random value @xmath23 as the seed . for example , alice s identity is @xmath24 and alice s nonce is @xmath25 .",
    "the empty set means that oscar does not need prior knowledge to learn @xmath26 .",
    "once his pool of knowledge includes @xmath7 , oscar learns the corresponding response , @xmath9 . more generally in @xmath27 instead of @xmath20 because @xmath28 , the recipient of @xmath27 , can not conclusively determine that @xmath29 is , in fact , the nonce @xmath20 .",
    "] , @xmath30 \\label{ns2 }   \\\\ \\mbox{where } c = e_{pk(p')}(i(p),v ) .",
    "\\nonumber\\end{aligned}\\ ] ] the variable @xmath31 denotes the set of all values , or the fixed pool of knowledge .",
    "note that our formalization constrains the seed of bob s nonce to be alice s initialization message .",
    "this is needed to establish that bob s nonce was generated in the context of the protocol session started by alice with @xmath7 .",
    "the resulting correspondence between the nonces prevents our analysis from sounding false alarms when oscar legitimately obtains two nonces from alice and bob by running a valid protocol session with each .",
    "oscar learns the final message , @xmath10 , as a consequence of knowing @xmath9 .",
    "formally , @xmath32.\\label{ns3}\\end{aligned}\\ ] ]",
    "the needham - schroeder protocol is vulnerable to a parallel session attack discovered by gavin lowe @xcite .",
    "this section presents a knowledge flow analysis of the protocol that reproduces lowe s results , and gives a flavor of the expressiveness and simplicity of our method .",
    "we have encoded the knowledge flows in the alloy modelling language @xcite and used the alloy analyzer @xcite to find the attack .",
    "however , the modelling pattern presented here is applicable to any first - order logic with relations and transitive closure .",
    "the basic components of a knowledge flow model are the sets @xmath33 and @xmath34 , and the relations @xmath35 , @xmath36 , and @xmath37 ( model excerpt [ basicdeclarations ] ) .",
    "module kf / basicdeclarations    * abstract sig * value \\ { } [ value ]    * sig * compositevalue * extends * value \\ { } [ compositevalue ]    * sig * atomicvalue * extends * value \\ { } [ atomicvalue ]    * abstract sig * principal \\ { [ principal ]     draws : * set * value , [ draws ]     owns : * set * draws [ owns ]    } \\ { * no * owns & ( principal - this).@owns } [ owns - constraint ]    * sig * honestuser * extends * principal \\ { [ honestuser ]    } \\ { draws = value } [ draws - constraint ]    * one sig * oscar * extends * principal \\ { [ oscar ]     knows : * set * value , [ knows ]     learns : knows->knows [ learns ]    } \\ { * no * ` ^`learns & iden } [ learns - constraint ]    * pred * initialknowledge ( ) \\ { [ initialknowledge ]    no compositevalue & oscar.draws }    * pred * finalknowledge ( ) \\ { [ finalknowledge ]    * all * v : value |    v * in * ( oscar.draws).*(oscar.learns ) * iff *    v * in * oscar.knows }    the set @xmath33 includes all principals in a protocol  the legitimate protocol participants , represented by the subset @xmath38 , and the intruders , represented by @xmath15 .",
    "the set @xmath34 models the fixed pool of knowledge on which a protocol operates .",
    "we distinguish between @xmath39s , which are uninterpreted , and @xmath40s , which may consist of other values and are learned by communicating with cryptographic primitives . in the example from figure [ ns - diagram ] ,",
    "alice and bob are members of @xmath38 ; @xmath34 consists of the union of values enclosed in the boxes ` alice ' and ` bob ' ; the identifiers @xmath2 and @xmath5 are @xmath39s , and the ciphers are @xmath40s .",
    "the relation @xmath35 ( line [ draws ] ) maps each principal to the set of values known by that principal at the beginning of the protocol .",
    "for example , both alice and bob draw alice s identity @xmath2 at the start of the protocol session shown in figure [ ns - diagram ] .",
    "the declaration of @xmath41 ( line [ owns ] ) together with the constraint on line [ owns - constraint ] relate a principal to the set of drawn values which uniquely identify him .",
    "bob , for instance , @xmath41 his identity , @xmath5 , even though both he and alice draw it .",
    "the field @xmath37 ( line [ knows ] ) defines the set of all values that oscar can learn by using the knowledge flows available to him ; this includes the knowledge obtainable from both the protocol rules and the cryptographic primitives .",
    "the acyclic relation @xmath36 ( lines [ learns]-[learns - constraint ] ) encodes the partial ordering on oscar s maximal knowledge , enforced by the flows from which the knowledge was acquired .",
    "for example , the protocol rule [ ns2 ] specifies that oscar learns @xmath9 from @xmath7 .",
    "hence , oscar.knows contains both ciphers and oscar.learns includes the mapping @xmath42    the predicate ` initialknowledge ` states that oscar may not draw any composite values . rather , he must learn them from the protocol rules or the primitives .",
    "the predicate ` finalknowledge ` specifies that oscar s maximal knowledge contains a value @xmath29 if and only if oscar draws @xmath29 or he learns it from a knowledge flow originating in his initial knowledge .",
    "the needham - schroeder protocol requires the use of cryptographic primitives to encrypt / decrypt messages and generate nonces .",
    "our encoding of the knowledge flows and values associated with these primitives is shown in model excerpt [ primitives ] .",
    "note that we do not explicitly model primitives as principals .",
    "instead , we define the pools of values drawn by the primitives as signatures and encode their input / output behavior as predicates . for example",
    ", the initial knowledge of @xmath14 is given by the set @xmath43 , and @xmath14 s operation is encoded in the predicates ` encryptor ` and ` decryptor ` .",
    "module kf / primitives / encryption    open kf / basicdeclarations    * sig * ciphertext * extends * compositevalue \\ {    plaintext : * some * value , [ plaintext ]    key : value } [ key ]    * pred * publickeycryptography ( ) \\ { [ publickeycryptography ]    ciphertext.key * in * principal.owns & atomicvalue }",
    "* pred * encryptor(x : * set * value , v : value ) \\ {    v * in * ciphertext & & x = v.key + v.plaintext }",
    "* pred * decryptor(x : * set * value , v : value ) \\ {    * some * c : plaintext.v | x = ( c.key + c ) & &    ( publickeycryptography ( ) = > [ sk - constraint ]    c.key * in * oscar.owns ) }    * pred * perfectcryptography ( ) \\ {    ( * all * * disj * c1,c2 : ciphertext | c1.plaintext ! =    c2.plaintext || c1.key",
    "! = c2.key )    ( * all * c : ciphertext | c !",
    "= c.key & &    c !",
    "= c.plaintext ) }    module kf / primitives / nonces    open kf / basicdeclarations    * sig * nonce * extends * compositevalue \\ {",
    "seed : value ,    i d : value }    * pred * noncegenerator(x : * set * value , v : value ) \\ {    v * in * nonce & & v.id * in * oscar.owns & & x = v.seed }    a @xmath43 represents an encryption of a non - empty @xmath44 ( line [ plaintext ] ) with a given @xmath45 ( line [ key ] ) .",
    "the predicate ` encryptor ` formalizes the encryption knowledge flow from oscar s perspective .",
    "it states that , in order to learn the cipher @xmath29 from the encryptor , oscar must provide the input @xmath46 consisting of the plaintext and the key associated with @xmath29 .",
    "similarly , the predicate ` decryptor ` stipulates that oscar can learn the plaintext @xmath29 after he presents the input @xmath46 consisting of an encryption of @xmath29 and the corresponding decryption key .",
    "note that this model of ciphers accommodates both public and symmetric key encryption .",
    "symmetric key encryption is the default ; invoking the predicate ` publickeycryptography ` switches on public key encryption .",
    "any atomic value owned by a principal can serve as his public / private key pair .",
    "the public portion of any principal s key is accessible to oscar through the @xmath35 relation .",
    "the decryption constraint on line [ sk - constraint ] ensures that oscar can decrypt a message only if he @xmath41 the value representing the public / private key pair .",
    "nonces are encoded as composites with two fields , @xmath47 and @xmath48 .",
    "the field @xmath48 stores the identity of the principal to whom the nonce was issued .",
    "the predicate ` noncegenerator ` says that , from oscar s point of view , the generator will issue a nonce labeled with oscar s identifier when presented with the input seed @xmath46 .",
    "the models presented so far are a part of a generic alloy framework developed for analyzing knowledge flows .",
    "this section describes the values and rules specific to the needham - schroeder protocol .",
    "module kf / needham_schroeder    open kf / basicdeclarations    open kf / primitives / encryption    open kf / primitives / nonces    * sig * identity * extends * atomicvalue \\{}[identity ]    * pred * identitiesarekeys ( ) \\ {    * all * p : principal | * some * p.owns & identity & & [ unique - ids ]    ciphertext.key * in * identity } [ id - keys ]    * pred * primitiverules(x : * set * value , v : value ) \\ {    encryptor(x ,",
    "v ) || decryptor(x , v ) ||    noncegenerator(x , v ) }    * pred * protocolrules(x : * set * value , v : value ) \\",
    "{ [ ns - rules ]    v * in * ciphertext & & \\ {     ( x : * some * oscar.draws & &    * let * text = v.plaintext , n = text & nonce |    # text = 2 & & * one * n & & n.seed * in * atomicvalue & &    n.id = text & identity ) ||    ( x : * one * ciphertext & & ( * some * n : seed.x |    # x.plaintext = 2 & & v.key * in * x.plaintext & &    n.id = x.key & &    v.plaintext = ( x.plaintext - v.key ) + n ) ) ||    ( x : * one * ciphertext & &    ( * some * n : id.(x.key ) & nonce |    # x.plaintext = 2 & & n * in * x.plaintext & &    v.plaintext = x.plaintext - n ) ) } }    * pred * applyrules ( ) \\ {    * all * v : value | * let * x = oscar.learns.v |    * some * x < = > primitiverules(x , v ) ||    protocolrules(x , v ) }    principals identifiers are modelled as atomic values contained in the set @xmath49 ( model excerpt [ protocol - rules ] , line [ identity ] ) . each principal @xmath41 an @xmath49 ( [ unique - ids ] ) , which also doubles as its owners public / private key pairs ( [ id - keys ] ) .    the ` protocolrules ` predicate ( line [ ns - rules ] ) embeds the knowledge flow rules given by equations [ ns1]-[ns3 ] into first - order logic .",
    "the predicate ` applyrules ` states that the @xmath36 relation may map the set of values @xmath46 to the value @xmath29 if and only if the protocol or primitive rules define a knowledge flow from @xmath46 to @xmath29 .      the predicate ` securityassumptions ` in model excerpt [ security - theorem ] models our assumptions about the properties of cryptographic primitives and principals .",
    "we assume perfect public key cryptography ( line [ perfect - pk - crypto ] ) and the use of identifiers as public / private key pairs ( line [ ids - as - keys ] ) .    the security property that the protocol should satisfy is given by the predicate ` securitytheorem ` .",
    "it states that oscar s maximal knowledge never contains two nonces , @xmath50 and @xmath51 , such that @xmath51 is generated by bob in response to a protocol initialization message sent by alice ( a cipher containing alice s identity and one of her nonces ) .",
    "the assertion ` security ` stitches the model together to stipulate that the security property should hold if oscar obtains his maximal knowledge by applying the knowledge flow rules to the values he draws .",
    "* pred * securityassumptions ( ) \\ {    perfectcryptography ( ) & & publickeycryptography()[perfect - pk - crypto ]    identitiesarekeys ( ) } [ ids - as - keys ]    * pred * securitytheorem ( ) \\ {    * no * * disj * alice , bob : honestuser ,    na , nb : oscar.knows & nonce |    na.id * in * alice.owns & & nb.id * in * bob.owns & &    ( * some * c : ciphertext | nb.seed = c & &    c.key = nb.id & &    c.plaintext = na.id + na ) }    * assert * security \\ {    initialknowledge ( ) & & finalknowledge ( ) & &    securityassumptions ( ) & & applyrules ( ) = >    securitytheorem ( ) }    the alloy analyzer generates a counterexample to the ` security ` assertion ( figure [ lowe - attack ] ) that is a knowledge flow representation of the parallel session attack discovered by lowe @xcite .",
    "alice uses @xmath52 to initiate the protocol with oscar , who extracts @xmath50 and forwards it to bob in @xmath53 .",
    "thinking that he is authenticating with alice , bob responds with @xmath54 which oscar simply forwards to alice .",
    "she completes the session with oscar by sending him @xmath51 , which she believes is his nonce , in @xmath55 .",
    "oscar now knows both @xmath50 and @xmath51 , contrary to our claim .",
    "knowledge flow analysis is based on a simple mathematical foundation .",
    "this section formalizes the ideas outlined in the discussion of knowledge flow basics . we describe how _ communication rules",
    "_ direct knowledge flows ( [ kf - basic - defs ] ) , show that our treatment of primitives ensures a fixed pool of values ( [ initial - knowledge ] ) , formulate the analysis problem in terms of oscar s knowledge flows ( [ adversary ] ) , and present a small - model theorem which makes our analysis complete for a bounded number of parallel protocol sessions ( [ kf - completeness ] ) .",
    "we denote the sets of all _ principals _ and _ values _ by @xmath56 and @xmath31 .",
    "a subset of @xmath57 is a _ state of knowledge _ drawn from @xmath58 , the set of all possible states of knowledge . for a given state of knowledge @xmath59",
    ", we say that `` @xmath60 knows @xmath29 '' if @xmath61 .",
    "a tuple @xmath62 is a _ knowledge flow _ for @xmath63 directed by the _ communication rules _ @xmath64 and originating from the state @xmath65 .",
    "a communication rule describes the conditions under which one principal may gain knowledge from another .",
    "for example , the rule @xmath66 states that the encryptor @xmath67 will tell the cipher @xmath68 to the principal @xmath69 if @xmath69 knows @xmath70 s public key and the plaintext @xmath29 .",
    "note that our definition of a communication rule limits the class of protocols expressible in the knowledge flow framework .",
    "in particular , our rules can not be used to specify conditions under which information is _ withheld _ from a principal , such as `` @xmath17 will _ not _ tell @xmath29 to @xmath18 if @xmath18 knows @xmath46 '' . although many practical protocols do not require this form of expressiveness , withholding of knowledge is an essential concept in systems that use certificates : revoking a certificate requires withholding of information .",
    "we are working on reformulating the certificate revocation problem using valid and invalid certificate sets , which should allow us to circumvent this limitation .",
    "given a set of communication rules @xmath71 , we say that @xmath72 is reachable from @xmath59 via @xmath71 if @xmath73 is the result of applying all rules in @xmath71 to @xmath74 at most once ; i.e. @xmath75 where    @xmath76 such that @xmath77 [ fr - def ]    a state of knowledge @xmath78 is reachable in the context of a knowledge flow @xmath62 if @xmath79 .",
    "the _ maximal state of knowledge _ @xmath80 is the limit of @xmath79 as @xmath81 .",
    "a state of knowledge @xmath82 is _ valid _ for a knowledge flow @xmath62 if @xmath83 and @xmath84 . since @xmath85 is monotonically increasing that self - rules such as @xmath86 do not affect the flow of knowledge : @xmath87 .",
    "we therefore assume that @xmath71 does not contain any self - rules . ] in @xmath71 and @xmath88 , any valid state of knowledge is a subset of the maximal state of knowledge .",
    "hence , the maximal state of knowledge is also the smallest fixed point of @xmath89 which subsumes @xmath88 .      for each value @xmath29",
    ", @xmath90 defines the set of principals who draw @xmath29 . in the knowledge flow framwork",
    ", a principal @xmath60 outside of @xmath91 can learn @xmath29 only by communicating with principals who know @xmath29 .",
    "we therefore treat cryptographic primitives , and other computationally feasible algorithms , as principals .",
    "for example , suppose that , in practice , @xmath60 can compute @xmath29 by applying the algorithm @xmath92 to inputs @xmath93 .",
    "we model @xmath92 by adding the principal @xmath2 to @xmath56 , the tuple @xmath94 to @xmath88 , and the rule @xmath95 to @xmath71 .",
    "our treatment of primitives ensures that @xmath96 consists of _ all _ learnable values .",
    "hence , @xmath31 is the same in the initial and the maximal state of knowledge , @xmath97 which implies that we can safely restrict our analysis to the subset of @xmath71 applicable to @xmath88 .",
    "formally , @xmath98 where @xmath99      let @xmath100 be a group of collaborating adversaries .",
    "we collapse @xmath19 into a single principal @xmath101 using the following merging function : @xmath102 the merging of adversaries does not rule out any attacks because @xmath103 .",
    "we subsequently assume that @xmath104 is implied and use @xmath56 , @xmath71 , and @xmath88 to refer to @xmath105 , @xmath106 , and @xmath107 .",
    "security properties of protocols are expressed as predicates on the values known to oscar in the maximal state of knowledge .",
    "we therefore restrict our analysis of knowledge flows to finding all the values in the projection of @xmath108 on oscar .",
    "specifically , we introduce the projection function @xmath109 and show that its smallest fixed point is the image of oscar under @xmath108 .",
    "[ defarrow ] let @xmath110 denote the existence of a rule @xmath111 for some @xmath112 and @xmath113 with @xmath114 .",
    "we define @xmath115 as @xmath116 the set of values reachable from @xmath117 is given by @xmath118 , which is the limit of @xmath119 as @xmath81.[gr - def ]    since @xmath85 is monotonically increasing in @xmath71 and @xmath88 , oscar s pool of values under @xmath80 is maximized if ( a ) oscar tells everything he knows to the honest principals and ( b ) the honest principals tell everything they know to each other .",
    "therefore , @xmath120 should be included in the maximal state of knowledge .",
    "this is equivalent to assuming that each honest principal draws @xmath121 because @xmath122 implies that @xmath123 .",
    "[ arrow ] let @xmath124\\subseteq k_0 $ ] with @xmath125 and let @xmath126 .",
    "then there exists a unique set @xmath127 such that @xmath128 \\cup [ \\{o\\}\\times x_n].\\label{xn}\\ ] ] the set @xmath129 has the property that @xmath130 .    _",
    "_    we use induction on @xmath131 . for @xmath132 , @xmath133 .",
    "since @xmath134 and @xmath125 , there exists a unique @xmath135 such that @xmath88 satisfies ( [ xn ] ) .",
    "let @xmath136 be a unique solution to ( [ xn ] ) and + @xmath137 ( our induction hypothesis ) .",
    "we know that @xmath138 and , therefore , @xmath139 .",
    "together with @xmath124 \\subseteq k_n\\subseteq k_{n+1}$ ] , this implies the existence a unique @xmath140 for which @xmath141 satisfies ( [ xn ] ) .",
    "we now need to prove that @xmath142 .    definition ( [ xn ] ) lets us infer that @xmath143 . according to definition ( [ fr - def ] ) , @xmath144 if and only if i ) @xmath145 , which is , by ( [ xn ] ) , equivalent to @xmath146 , or ii ) there exists a @xmath147 and @xmath113 such that @xmath148 , @xmath149 , and @xmath150 .",
    "since there are no self - rules @xmath151 , we know that @xmath112 .",
    "this , together with @xmath152 , implies that @xmath153 \\subseteq k_n$ ] . given @xmath124",
    "\\subseteq k_n$ ] and @xmath154 , the condition @xmath149 is equivalent to @xmath155 since @xmath152 , @xmath156 gives us @xmath111 .",
    "therefore , case ii ) holds if and only if there exists a set @xmath157 such that @xmath158 . by definition ( [ gr - def ] ) ,",
    "case i ) or case ii ) holds if and only if @xmath159 .",
    "hence , @xmath160 and the lemma follows by induction on @xmath131 .",
    "@xmath161      let @xmath162 be the total number of values used in a single protocol session , including the subterms of each composite value .",
    "suppose that oscar can use only the primitives which _ compose _ or _ decompose _ inputs and for which the composition rules have no collisions ( e.g encryptor / decryptor ) .",
    "then , the theory in @xcite implies the following : if there exists an attack in which oscar uses @xmath163 parallel protocol sessions , then such an attack need not involve more than @xmath164 values . from ( [ v0 ] )",
    "we infer that this corresponds to a valid state of knowledge @xmath165 derived from the set @xmath166 of cardinality @xmath167 . by lemma",
    "[ arrow ] , we can conclusively _ decide _ whether there is an attack which uses @xmath163 parallel protocol sessions by computing @xmath168 \\subseteq k_\\sigma \\subseteq k_0\\\\ \\mbox{with } |knowledge(k_\\sigma)|\\leq wm    \\end{array }   \\right\\}. \\label{comp}\\ ] ]",
    "we have applied the theory developed in the previous section to check the security of the original @xcite and modified @xcite needham - schroeder public key protocol , the otway - rees mutual authentication protocol @xcite , and the bootstrapping and renewal protocols based on controlled physical random functions ( cpufs ) @xcite .",
    "the knowledge flows of the protocols were embedded into alloy using the pattern presented in section [ example ] .",
    "the pattern is embodied in a general alloy framework for knowledge flow analysis which includes definitions of basic concepts ( model excerpt [ basicdeclarations ] ) , a library of primitives , and a model outline for specifying protocol rules and security theorems .",
    "for example , model excerpt [ primitives ] shows portions of alloy modules that encode generic encryption / decryption and nonce generator primitives , and model excerpts [ protocol - rules ] and [ security - theorem ] comprise an instantiation of the modelling outline for the needham - schroeder protocol .",
    "we have found that the alloy framework and its associated tool support make the process of knowledge flow modelling fast , simple , and accurate .",
    "our analysis is sound and , since most cryptographic primitives used in practice are composing / decomposing , we can make it complete for a bounded number of parallel sessions by applying the results from section [ kf - completeness ] . in the case of the modified needham - schroeder protocol , for example , we have proved that it is secure against all attacks that use two parallel sessions .",
    "the analysis of the otway - rees protocol ( [ otway - reese - protocol ] ) produced the type flaw attack described in @xcite .",
    "we found the cupfs protocols ( [ cpuf - protocol ] ) to be secure for a single protocol session and , therefore , for an unlimited number of sessions .",
    "the main limitation of our approach is that it is not fully general .",
    "as pointed out in section [ kf - basic - defs ] , protocols that _ withhold _ information under certain conditions can not be formulated as knowledge flows . however",
    ", this limitation does not significantly detract from practical usefulness of knowledge flow analysis : as far as we know , few practical protocols contain information - withholding rules .",
    "the first formalisms designed for reasoning about cryptographic protocols are belief logics such as ban logic @xcite , used by the convince tool @xcite with the hol theorem prover @xcite , and its generalizations ( gny @xcite , at @xcite , and svo logic @xcite which the c3po tool @xcite employs with the isabelle theorem prover @xcite ) .",
    "belief logics are difficult to use since the logical form of a protocol does not correspond to the protocol itself in an obvious way .",
    "almost indistinguishable formulations of the same problem lead to different results .",
    "it is also hard to know if a formulation is over constrained or if any important assumptions are missing .",
    "ban logic and its derivatives can not deal with security flaws resulting from interleaving of protocol steps @xcite and can not express any properties of protocols other than authentication @xcite . to overcome these limitations ,",
    "the knowledge flow formalism has , like other approaches @xcite , a concrete operational model of protocol execution .",
    "our model also includes a description of how the honest participants in the protocol behave and a description of how an adversary can interfere with the execution of the protocol .",
    "specialized model checkers such as casper @xcite , mur@xmath169 @xcite , brutus @xcite , taps @xcite , and proverif @xcite have been successfully used to analyze security protocols . like knowledge flow analysis in alloy",
    ", these tools are based on state space exploration which leads to an exponential complexity .",
    "athena @xcite is based on a modification of the strand space model @xcite .",
    "even though it reduces the state space explosion problem , it remains exponential .",
    "multiset rewriting @xcite in combination with tree automata is used in timbuk @xcite . the relation between multiset rewriting and strand spaces",
    "is analyzed in @xcite .",
    "the relation between multiset rewriting and process algebras @xcite is analyzed in @xcite .",
    "proof building tools such as nrl , based on prolog @xcite , have also been helpful for analyzing security protocols . however , they are not fully automatic and often require extensive user intervention .",
    "model checkers lead to completely automated tools which generate counterexamples if a protocol is flawed . for theorem - proving - based approaches ,",
    "counterexamples are hard to produce .    for completeness , we note that if the initial knowledge of the intruder consists of a finite number of explicit ( non - parameterized , non - symbolic ) values , then a polynomial time intruder detection algorithm can be shown to exist using a generalization of the proof normalization arguments @xcite , which were employed in @xcite and have been implemented in the framework @xcite .",
    "however , in practice , the initial knowledge of an intruder is unbounded and represented by a finite number of parameterized sets , each having an infinite number of elements .",
    "the key advantage of the knowledge flow approach over other formalisms is its simplicity and flexibility .",
    "it is simple in the sense that the underlying mathematics is straightforward and elementary ; it does not require any specialized background ( in logic ) .",
    "it is flexible in the sense that the same library of cryptographic primitives can be used to model different protocols and that the security of a complex scheme involving multiple protocols can be verified .",
    "knowledge flow analysys allows modeling of confidentiality and authenticity via a wide range of primitives such as pairing , union , hashing , symmetric key encryption , public key encryption , macs and digital signatures .",
    "our formalism derives its simplicity from being just sufficiently expressive to enable modelling of practical cryptographic protocols .",
    "in particular , existentials @xcite can not be encoded as knowledge flows ; existentials are implicitly modeled in oscar s initial knowledge . as mentioned in section ( [ kf - basic - defs ] ) ,",
    "np - hardness proofs which use ( existential ) horn clause reduction @xcite or sat3 reduction @xcite are not applicable to knowledge flow analysis .",
    "this paper introduces a new method for formalizing and checking security protocols .",
    "our approach enables natural encoding of protocol rules , simple treatment of primitives , direct embedding into first order logic , and sound analysis that is also complete for many practical protocols .",
    "we have developed a general framework for analyzing knowledge flows using the alloy analyzer .",
    "the framework has been used to generate easily understandable knowledge flow representations of parallel session and type flaw attacks on the needham - schroeder and otway - rees protocols .",
    "we have also instantiated it with the rules for cpufs key management protocols and verified the protocols correctness for an unlimited number of parallel sessions .",
    "we believe that knowledge flow analysis may be polynomial - time decidable for some protocols .",
    "future work will involve identifying the class of protocols whose knowledge flows are analyzable in polynomial time and developing a specialized tool for checking them .",
    "we would like to thank viktor kuncak , ishan sachdev , and ilya shlyakhter for their contributions to and comments on earlier versions of this work .    10    m.  ababi and b.  blanchet . analyzing security protocols with secrecy types and logic programs .",
    "52(1):102146 , 2005 .    m.  abadi and a.  d. gordon .",
    "reasoning about cryptographic protocols in the spi calculus . in _ proc .",
    "of concur 97 : concurrency theory , 8th international conference , lncs 1243 _ , pages 5973 , 1997 .",
    "m.  abadi and m.  tuttle .",
    "a semantics for a logic of authentication . in _ proceedings of the tenth annual acm symposium on principles of distributed computing _ , pages 201216 , 1991 .    d.  basin and h.  ganzinger . automated complexity analysis based on ordered resolution .",
    ", 48(1):70109 , 2001 .",
    "s.  bistarelli , i.  cervesato , g.  lenzini , and f.  martinelli . relating process algebras and multiset rewriting for immediate decryption protocols . in _",
    "workshop on mathematical methods , models and architectures for computer networks security ( mmm - acns ) , lncs 2776 _ , pages 8699 , 2003 .",
    "c.  bodei , p.  degano , f.  nielson , and h.  r. nielson .",
    "flow logic for dolev - yao secrecy in cryptographic processes .",
    ", 18(6):747756 , 2002 .    c.  boyd and w.  mao .",
    "on a limitation of ban logic . in _ advances in cryptology",
    ": eurocrypt 93 , springer - verlag _ , pages 240247 , 1993 .",
    "m.  burrows , m.  abadi , and r.  needham . a logic of authentication . , 8(1):1836 , 1990 .",
    "i.  cervesato , n.  durgin , j.mitchell , p.  lincoln , and a.  scedrov . a comparison between strand spaces and multiset rewriting for security protocol analysis . in",
    "software security theories and systems , mext - nsf - jsps international symposium , isss 2002 , llncs 426 _ , 2003 .",
    "y.  chevalier , r.  kuesters , m.  rusinowitch , and m.  turuani .",
    "an np decision procedure for protocol insecurity with xor . in _ lics03 _ , 2003 .",
    "y.  chevalier , r.  ksters , m.  rusinowitch , m.  turuani , and l.  vigneron . extending the dolev - yao intruder for analyzing an unbounded number of sessions .",
    "technical report rr-4869 , rapport de recherche de linria - lorraine , equipe : cassis , july 2003 .",
    "e.  clarke , s.  jha , and w.  marrero .",
    "verifying security protocols with brutus .",
    ", 9(4):443487 , 2000 .    e.  cohen . : a first - order verifier for cryptographic protocols . in _",
    "computer security foundations workshop _ , 2004 .",
    "h.  comon - lundh and v.  shmatikov .",
    "intruder deductions , constraint solving and insecurity decision in presence of exclusive or . in _",
    "18th annual ieee symposium on logic in computer science ( lics03 ) _ , pages 271280 , 2003 .",
    "a.  h. dekker .",
    "c3po : a tool for automatic sound cryptographic protocol analysis . in _",
    "13th ieee computer security foundations workshop ( csfw00 ) _ , 2000 .",
    "d.  dolev and a.  yao . on the security of public key protocols .",
    ", 29(2):198208 , 1983 .",
    "n.  a. durgin , p.  d. lincoln , j.  c. mitchell , and a.  scedrov .",
    "multiset rewriting and the complexity of bounded security protocols .",
    ", 1:677722 , 2004 .",
    "f.  j.  t. fabrega , j.  c. herzog , and j.  d. guttman .",
    "strand spaces : why is a security protocol correct ? in _ proceedings of 1998 ieee symposium on security and privacy _",
    ", 1998 .",
    "g.  feuillade , t.  genet , and v.  v.  t. tong .",
    "reachability analysis of term rewriting systems . ,",
    "2004 .    b.  gassend , d.  clarke , m.  van dijk , and s.  devadas .",
    "controlled physical random functions . in _ proceedings of the 18th annual computer security applications conference _ , 2002 .",
    "b.  l.  p. gassend . physical random functions .",
    "master s thesis , mit , 2003 .    r.  givan and d.  mcallester .",
    "polynomial - time computation via local inference relations .",
    ", 3(4):521541 , 2002 .",
    "l.  gong , r.  needham , and r.  yahalom .",
    "reasoning about belief in cryptographic protocols .",
    "in _ proceedings of the ieee symposium on security and privacy _ , pages 234248 , 1990 .",
    "m.  j.  c. gordon and t.  f. melham . .",
    "cambridge university press , cambridge , england , 1993 .",
    "d.  jackson . automating first - order relational logic . in _ proc .",
    "acm sigsoft conf .",
    "foundations of software engineering / european software engineering conference ( fse / esec 00 ) _ , 2000 .",
    "d.  jackson .",
    "alloy : a lightweight object modelling notation .",
    ", 11(2):256290 , 2002 .",
    "r.  w. lichota , g.  l. hammonds , and s.  h. brackin .",
    "verifying cryptographic protocols for electronic commerce . in _ proceedings of the second usenix workshop on electronic commerce _ ,",
    "pages 5365 , 1996 .",
    "g.  lowe . breaking and fixing the needham - schrder public - key protocol using csp and fdr . in _",
    "2nd international workshop on tools and algorithms for construction and analysis of systems _ , 1996 .",
    "g.  lowe .",
    "casper : a compiler for the analysis of security protocols . in _ proceedings of the 1997 ieee computer society symposium on research in security and privacy _ , pages 1830 , 1997 .",
    "w.  mao and c.  boyd . towards formal analysis of security protocols . in _ proceedings of the computer security foundation workshop vi _ , pages 147158 , 1993 .",
    "d.  mcallester",
    ". automatic recognition of tractability in inference relations . , 40(2 ) , 1993 .",
    "c.  a. meadows .",
    "the nrl protocol analyzer : an overview . in _ proceedings of the 2nd conference on the practical applications of prolog _ , 1994 .",
    "j.  millen and v.  shmatikov .",
    "symbolic protocol analysis with an abelian group operator or diffie - hellman exponentiation . , 2004 .",
    "r.  milner . .",
    "cambridge university press , 2000 .",
    "j.  mitchell , m.  mitchell , and u.  stern .",
    "automated analysis of cryptographic protocols using mur@xmath169 . in",
    "_ proceedings of the 1997 ieee symposium on research in security and privacy _ , pages 141153 , 1997 .",
    "r.  needham and m.  schrder . using encryption for authentication in large networks of computers .",
    ", 21(12):993999 , 1978 .",
    "f.  nielson , h.  r. nielson , and h.  seidl .",
    "cryptographic analysis in cubic time . in _ tosca01 _ , volume  62 of _ entcs _ , 2001 .",
    "f.  nielson , h.  r. nielson , h.  sun , m.  buchholtz , r.  r. hansen , h.  pilegaard , and h.  seidl . the succinct solver suite . in _",
    "10th tacas _ ,",
    "volume 2988 of _ lncs _ , 2004 .",
    "t.  nipkow , l.  paulson , and m.  wenzel . ,",
    "march 8 2002 .",
    "d.  otway and o.  rees .",
    "efficient and timely mutual authentication .",
    ", 21:810 , january 1987 .",
    "m.  rusinowitch and m.  turuani .",
    "protocol insecurity with finite number of sessions is np - complete . in _ proceedings of the 14th computer security foundations workshop _ , pages 174187 , 2001 .",
    "v.  shmatikov .",
    "decidable analysis of cryptographic protocols with products and modular exponentiation . in _",
    "esop04 _ ,",
    "volume 2986 of _ lncs _ , 2004 .",
    "d.  song , s.  berezin , and a.  perrig .",
    "athena , a novel approach to efficient automatic security protocol analysis .",
    ", 9(1 ) , 2001 .",
    "p.  syverson and p.  van oorschot . on unifying some cryptographic protocol logics .",
    "in _ proceedings of the 13th symposium on security and privacy _ , 1994 .",
    "* module * kf / otwayreese    * open * kf / basicdeclarations    * open * kf / primitives / encryption    * open * kf / primitives / nonces    * sig * message * extends * compositevalue \\ {    contents : * some * value }    * sig * identity * extends * atomicvalue \\ { }    * pred * primitiverules(x : * set * value , v : value ) \\ {    encryptor(x ,",
    "v ) || decryptor(x , v ) || noncegenerator(x , v ) ||    ( x : message & & v * in * x.contents ) }    * pred * idcipher(cipher : value ) \\ {    cipher : ciphertext & &    * some * cipher.key.id & cipher.plaintext & &    cipher.plaintext * in * identity & &    * one * cipher.plaintext - cipher.key.id }    * pred * keycipher(cipher : value ) \\ {    cipher : ciphertext & &    * some * cipher.key.id }    * pred * message1(m : value ) \\ {    m : message & &    * let * cipher = m.contents & ciphertext | \\ {    idcipher(cipher ) & &    m.contents = cipher + cipher.plaintext } }",
    "* pred * message2(m : value ) \\ {    m : message & &    * some * cipher1 : ciphertext |    * let * cipher2 = m.contents & ciphertext - cipher1 | \\ {",
    "idcipher(cipher1 ) & &     idcipher(cipher2 ) & &     cipher1.plaintext = cipher2.plaintext & &     m.contents = cipher1 + cipher2 + cipher1.plaintext } }    * pred * message3(m : value ) \\ {    m : message & &    * some * cipher1 : ciphertext |    * let * cipher2 = m.contents & ciphertext - cipher1 | \\ {     keycipher(cipher1 ) & &     keycipher(cipher2 ) & &     cipher1.plaintext = cipher2.plaintext & &     m.contents = cipher1 + cipher2 } }",
    "* pred * message4(m : value ) \\ {    m : message & &    keycipher(m.contents ) }    * pred * protocolrules(x : * set * value , v : value ) \\ {    ( x : * some * oscar.draws & & message1(v ) ) ||    ( message1(x ) & & message2(v ) & & x.contents * in * v.contents ) ||    ( message2(x ) & & message3(v ) & & x.contents.key = v.contents.key ) ||    ( message3(x ) & & message4(v ) & & v.contents * in * x.contents ) }    * pred * applyrules ( ) \\ {    * all * v : value | * let * x = oscar.learns.v |    * some * x < = > primitiverules(x , v ) || protocolrules(x , v ) }    * pred * securityassumptions()\\ {    perfectcryptography ( ) & &    * all * p : principal | * some * p.owns & identity }    * pred * securitytheorem ( ) \\ {    * no * oldresp , newresp : pufresponse ,    renew : param.(oldresp.isrespto ) & honestuser ,    cipher : ciphertext |    * let * oldchall = oldresp.isrespto , newchall = newresp.isrespto |    oldchall.ishashof : * some * ( atomicvalue - oscar.draws ) & &    cipher.key.ishashof = oldresp + renew.hash & &    cipher.plaintext = newresp & &    newchall.ishashof = oldchall + renew.hash & &    newresp * in * oscar.knows }    * assert * security \\ {    initialknowledge ( ) & & finalknowledge ( ) & &    securityassumptions ( ) & & applyrules ( ) = > securitytheorem ( ) }    * pred * securitytheorem ( ) \\ {    * no * m1 , m2 , m3 , m4 : oscar.knows & message ,    a , b : honestuser.owns & identity | \\ {    message1(m1 ) & & message2(m2 ) & &    message3(m3 ) & & message4(m4 ) & &    m1.contents.key.id = a & &    m2.contents.key.id = a + b & &    m3.contents.key.id = a + b & &    m4.contents.key.id = a & &    m4.contents.plaintext * in *    ( honestuser.draws - oscar.draws ) & atomicvalue & &    m4.contents.plaintext * in * oscar.knows } }    * assert * security \\ {    initialknowledge ( ) & & finalknowledge ( ) & &    securityassumptions ( ) & & applyrules ( ) = > securitytheorem ( ) }",
    "* module * kf / primitives / hashing"
  ],
  "abstract_text": [
    "<S> knowledge flow analysis offers a simple and flexible way to find flaws in security protocols . </S>",
    "<S> a protocol is described by a collection of rules constraining the propagation of knowledge amongst principals . </S>",
    "<S> because this characterization corresponds closely to informal descriptions of protocols , it allows a succinct and natural formalization ; because it abstracts away message ordering , and handles communications between principals and applications of cryptographic primitives uniformly , it is readily represented in a standard logic . </S>",
    "<S> a generic framework in the alloy modelling language is presented , and instantiated for two standard protocols , and a new key management scheme . </S>"
  ]
}