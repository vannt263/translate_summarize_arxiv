{
  "article_text": [
    "in this paper , we focus on the problem of scheduling in constrained queuing networks .",
    "specifically , we consider a collection of queues operating in discrete time with constraints on which queues may be served simultaneously .",
    "such queuing systems serve as effective modeling tools for a large array of important practical problems , and their performance is crucially dependent on the effectiveness of the scheduling algorithm .    in this setup",
    ", the basic question is to design a scheduling algorithm that is optimal .",
    "there are several performance criteria , with often inherent trade - offs , that determine the optimality of a scheduling algorithm .",
    "the first is throughput optimality .",
    "a queuing system has a limited amount of resources .",
    "the natural constraints imposed result in an inherent limitation on the amount of traffic load that can be supported .",
    "this is called the capacity of the system . roughly speaking , a scheduling algorithm that achieves the capacity utilizes system resources optimally .",
    "such an algorithm is called throughput optimal .    apart from being throughput optimal",
    ", a scheduling algorithm should allocate resources in a fair manner .",
    "the queuing system is a common resource shared by various traffic flows , and the scheduling algorithm should ensure that no flow is receiving more than its fair share of resources .",
    "it is important to realize that fairness in queuing systems is not only an intuitively desired goal but also one with an immense practical impact .",
    "a very important consequence of fairness is isolation of various traffic flows .",
    "throughput optimality is oblivious to the identities of the different flows .",
    "but , identities are important for the following two important reasons : ( 1 ) being oblivious to flow identities , throughput optimal algorithms often favor flows with a high data rate . therefore",
    ", a particular flow might ill - behave and flood the system with a high data rate maliciously resulting in the deterioration of service to other flows .",
    "since the system is a shared resource , the algorithm should identify the rogue flow and limit the negative impact on well - behaved flows .",
    "( 2 ) secondly , isolation is important to provide performance guarantees , and thereby quality of service ( see keshav ( 1997 ) @xcite ) , to various flows in the system .",
    "designing a scheduling algorithm that is fair will overcome these issues .",
    "other benefits of fairness include reducing burstiness of flows , eliminating bottlenecks and reducing the impact of certain kinds of denial - of - service ( dos ) attacks ( see bonald and massoulie ( 2001 ) @xcite , and yau et al ( 2005 ) @xcite ) .",
    "in essence , a fair scheduling algorithm makes the queuing system robust and less prone to manipulation by individuals .",
    "a natural way to achieve isolation among flows , in order to provide protection and performance guarantees , is to dedicate resources to each of the flows .",
    "in fact , this is the approach taken in most of the work done on designing fair algorithms for input queued switches ( details in section  [ sub : related - work ] ) .",
    "this approach , though , is limited for the following reasons : firstly , because of constraints , it is not straightforward to determine the amount of resources to be allocated to each flow in a queuing network . moreover",
    ", such determination would require the knowledge of flow arrival rates ; whereas , in the spirit of being implementable , we require the scheduling algorithm to be online i.e. , use only current network state information like queue - sizes , age of packets , etc . , and myopic i.e. , oblivious to flow arrival rates .",
    "secondly , resource allocation takes place on an average over a long period of time .",
    "this is appropriate in a flow level model where the arrival statistics remain constant for long time periods .",
    "this assumption , though , is questionable in many applications like internet traffic where short flows predominate .",
    "we note that designing a fair scheduling algorithm comprises two sub - problems : defining a reasonable notion of fairness , and designing an algorithm to achieve the desired notion of fairness .",
    "the notion of fairness is utilized to determine the resources ( more specifically , the rate or bandwidth ) to be allocated , and the scheduling algorithm ensures that the resources are allocated on an average over a long period of time . inspired by this , our approach would be to first define a notion of packet based fairness and then design a scheduling algorithm to achieve the defined notion of fairness .",
    "for obvious reasons , we also need to reconcile the benefits of fairness with achieving throughput optimality .",
    "motivated by the above discussion , we attempt to achieve the following three goals in this paper : ( 1 ) define a notion of packet based fairness .",
    "( 2 ) design an online and myopic algorithm , that is also throughput optimal , to achieve the notion of fairness . ( 3 ) provide the throughput optimality proof of the algorithm .",
    "the need for a packet based notion of fairness that can be used in a constrained network is clear .",
    "but , defining a precise mathematical notion of fairness that achieves the desired intuitive and practical benefits of fairness is quite challenging .",
    "unfortunately , none of the existing notions of fairness directly extend to a packet based constrained queuing network .",
    "existing notions of flow based fairness are based on the utility maximization framework ( proposed by kelly , maullo and tan ( 1998 ) @xcite ) , which is a concept borrowed from economics literature . in a similar spirit , we define a notion of fairness by establishing a novel analogy between scheduling in constrained queuing networks and a ranked election problem . ] . ranked",
    "election is a widely studied problem in the economics ( and political science ) literature and this analogy provides a ready framework to leverage this work .",
    "we draw upon the work of goodman and markowitz ( 1952 )  @xcite to obtain a unique characterization of the schedule .",
    "this , rather surprisingly , yields a maximum weight ( mw ) style algorithm .",
    "mw style algorithms are very popular in the literature and are very well understood .",
    "thus , mw algorithms choose schedules in a fair manner , though the definition of fair for different weights is different .",
    "it should be noted that the choice of weights is crucial for obtaining the intuitive desirable properties of fairness , and we make an important contribution here .    as another important contribution",
    ", we prove that our algorithm is throughput optimal .",
    "there is no a priori reason for this to be true . even though the algorithm we design is the familiar mw style algorithm , it is not queue size or waiting time based",
    ". therefore traditional methods of proving throughput optimality , which include the popular lyapunov - foster method and fluid models , can not be applied in a direct manner .",
    "the proof technique we introduce to prove throughput optimality is potentially applicable to a wider class of problems .",
    "we first begin with the work on single queue fairness .",
    "fair scheduling in single queues has been widely studied since the early 1990s . in one of the earliest works , john nagle ( 1987 )",
    "@xcite proposed a fair algorithm for single queues called fair queuing . as mentioned earlier ,",
    "fair scheduling is required to minimize starvation and limit the negative impact of rogue sources . in order to achieve this , nagle proposed maintaining separate queues for different flows and serving them in a round - robin fashion .",
    "this is a great and simple to implement solution , but it works only when all the packets are of equal size . in order to overcome this problem demers ,",
    "keshav and shenker ( 1989 ) @xcite proposed the notion of weighted fair queueing ( wfq ) and its packetized implementation .",
    "parekh and gallager ( 1993 , 1994 ) @xcite analyzed the performance of this packetized implementation and showed it to be a good approximation of generalized processor sharing ( gps ) .",
    "shreedhar and varghese ( 1996 ) @xcite designed a computationally efficient version of weighted fair queuing called deficit weighted round robin ( dwrr ) .",
    "even though all these algorithms are fair , they are very complex and expensive to implement .",
    "hence , there was a lot of work done on achieving approximate fairness for internet routers through fifo queuing and appropriate packet dropping mechanisms .",
    "examples include red by floyd and jacobson ( 1993 ) @xcite , choke by pan , prabhakar and psounis ( 2000 ) @xcite , and afd by pan , prabhakar , breslau and shenker ( 2003 ) @xcite .    to address the issue of fairness in a network , kelly , maullo and tan ( 1998 ) @xcite proposed a flow - level model for the internet . under this model ,",
    "the resource allocation that maximizes the global network utility provides a notion of fair rate allocation .",
    "we refer an interested reader to survey - style papers by low ( 2003 ) @xcite and chuang et.al .",
    "( 2006 ) @xcite and the book by srikant ( 2004 ) @xcite for further details .",
    "we take a note of desirable throughput property of the dynamic flow - level resource allocation model ( see for example , bonald and massoulie ( 2001 ) @xcite , and de veciana , konstantopoulos and lee ( 2001 ) @xcite ) . this approach , though valid for a general network with arbitrary topology , does not take scheduling constraints into account .",
    "we next review the work done on the design of fair scheduling algorithms for input queued ( iq ) switches .",
    "switches are the most simple at the same time , highly non - trivial examples of constrained networks .",
    "they form the core of internet routers and there is extensive literature dealing with the design and analysis of various switch architectures and scheduling algorithms .",
    "a switch is essentially a bipartite network with input ports and output ports .",
    "the function of a network switch is to move packets from the input ports to the output ports using the switch fabric , just like the traffic at a traffic junction .",
    "depending on the placement of buffers and the switch fabric , there are mainly two kinds of switch architectures input queued switches ( iq ) and output queued ( oq ) switches .",
    "as their names suggest , input queued switches have buffers only at input ports , while output queued switches have buffers only at the output ports .",
    "the input queued switch has a cross - bar switch fabric that imposes the following natural constraints : only one packet can be moved from ( to ) each input ( output ) port in each time slot .",
    "on the other hand , since an output queued switch has buffers only at output ports , packets arriving at the input ports are immediately transferred to their respective output buffers .",
    "thus , there are no scheduling constraints at the switch fabric in an output queued switch .",
    "because of this , the memory in an output queued switch has to operate much faster than the memory in an input queued switch . in most high - speed switches , memory bandwidth is the bottleneck and hence input queued switches are more popular and widely deployed , while output queued switches are idealized versions that are easy to study .",
    "it is clear from the description that scheduling in output queued switches is equivalent to that of single queues .",
    "hence , fair scheduling in output queued switches just corresponds to implementing single queue fair algorithms at different output queues .",
    "unfortunately , such extension is not possible for input queued switches because of the presence of constraints .",
    "one approach is to emulate the performance of an oq switch by means of a iq switch running with a minimal speedup .",
    "an iq switch is said to be running with a speedup @xmath1 if it can be scheduled @xmath1 times in each time slot .",
    "this approach was taken by prabhakar and mckeown ( 1999 ) @xcite and chuang , goel , mckeown and prabhakar ( 1999 ) @xcite , where they showed that essentially a speedup of 2 is necessary and sufficient for emulating an oq switch . with the oq switch operating under any of the various policies like fifo , wfq , dwrr , strict priority , etc",
    "fairness can be achieved .",
    "equivalently , if an iq switch is loaded up to 50% of its capacity and the notion of fairness is defined by policies like fifo , wfq , dwrr , strict priority , etc .",
    ", then by emulating an oq switch with these policies , it is possible to have fair scheduling for the iq switch .",
    "however , for higher loading this approach will fail due to inability of emulating an oq switch .",
    "this necessitates the need for defining an appropriate notion of fairness that cleverly , and in a reasonable manner , combines the preferences of packets based on some absolute notions along with the scheduling constraints . in principle , this question is very similar to the question answered by utility maximization based framework for bandwidth allocation in a flow network . in fact , most of the existing literature on fair scheduling algorithms for input - queued switches is concerned with the notion of flow - based fairness . in these approaches ,",
    "a flow is identified with all the packets corresponding to an input - output pair .",
    "there are two main approaches taken in the literature for the design of fair algorithms for iq switches .",
    "one class of fair algorithms implement a fair scheduling scheme at each of the servers in the switch and then carry out an iterative matching .",
    "this approach is based on the distributed packet fair queuing architecture .",
    "examples of this approach include ipdrr proposed by zhang and bhuyan ( 2003 ) @xcite , mfiq proposed by li , chen and ansari ( 1998 ) @xcite , and ifs proposed by ni and bhuyan ( 2002 ) @xcite .",
    "this approach completely ignores fairness issues that arise because of scheduling constraints and hence need not guarantee an overall fair bandwidth allocation . in order to overcome this ,",
    "hosaagrahara and sethu ( 2005 ) @xcite and more recently pan and yang ( 2007 ) @xcite propose algorithms to calculate overall max - min rates of different flows , taking into account contention at all levels .",
    "but this approach requires knowledge of rates of flows and hence , the system should either learn these rates or know them a priori .    thus , most of the literature on the design of fair scheduling algorithms for constrained networks is limited because it either ignores fairness issues caused due to scheduling constraints or directly borrows flow - based fairness notions and allocates bandwidth accordingly . here , it is important to emphasize the limitations of a flow - based approach : ( a ) network traffic predominantly contains short - flows , while flow - based approach requires existence of ever - lasting traffic thereby inducing huge delays when applied naively , ( b ) flow - based approach requires knowledge of traffic rates , which it may have to learn , ( c ) our unit of data is a packet and modeling it as a flow is just an approximation , and ( d ) packets have priorities and they lack explicit utility functions .    in summary ,",
    "our question is inherently combinatorial which requires dealing with hard combinatorial constraints unlike the resource allocation in a flow network which deals with soft capacity constraints in a continuous optimization setup .",
    "the rest of the paper is organized as follows : section  [ sec : model - and - notation ] describes the model , introduces the notation and states the problem formally .",
    "section  [ sec : our - approach ] motivates and describes our approach .",
    "section  [ sec : ranked - election ] takes a digression into economics literature to explain the ranked election problem .",
    "section  [ sec : analogy - between - fair ] establishes the analogy between the ranked election problem and network scheduling .",
    "sections  [ sec : most - urgent - cell ] and [ sec : throughput - of - mucf ] present the main results of this paper .",
    "section  [ sec : most - urgent - cell ] formally states our algorithm , while section  [ sec : throughput - of - mucf ] provides the details of the proof of throughput optimality .",
    "we provide some simulation results in section  [ sec : experiments ] and then finally conclude in section  [ sec : conclusion ] .",
    "we now describe a generic abstract model of a constrained queuing network .",
    "the model corresponds to a single - hop network .",
    "this generic model describes important special instances like an input queued switch , wireless network limited by interference , congestion control in tcp or even traffic in a road junction . in each of these instances",
    ", the model effectively captures the constraints imposed by nature on simultaneous servicing of queues .",
    "we will describe the examples of an input queued switch and a wireless network in detail .",
    "we focus on these two examples because they encapsulate a large class of scheduling problems .",
    "consider a collection of @xmath2 queues .",
    "time is discrete and is indexed by @xmath3 .",
    "each queue has a dedicated exogenous process of packet arrival .",
    "the arrival processes of different queues are independent .",
    "all packets are assumed to be normalized to unit length .",
    "arrivals to each queue occur according to a bernoulli process .",
    "the service to the queues is subject to scheduling constraints in that not all queues can be served simultaneously .",
    "the scheduling constraints present are described by a finite set of feasible schedules @xmath4 . in each time slot a feasible schedule @xmath5",
    "is chosen and queue @xmath6 is offered a service @xmath7 in that time slot .",
    "since each packet is of unit length , when a non - empty queue receives service , a packet departs from the queue .",
    "we assume that @xmath8 is monotone i.e. , if @xmath5 , then for any @xmath9 component - wise i.e. , @xmath10 , @xmath11 .",
    "further , we assume that for each @xmath6 , there exists a schedule @xmath12 that serves it i.e. , @xmath13 .",
    "packets exit the system from any of the @xmath14 output lines .",
    "the lines are assumed to operate at unit speed and hence at most one packet can leave the network from each line in each time slot .",
    "each of the @xmath14 output lines maintain buffers termed output queues to store packets that are ready to depart .",
    "we assume that routing is pre - determined and , hence , the destination output line of each packet is known .",
    "after service , each packet is moved to its destination output queue .",
    "each output queue operates using a single queue scheduling policy ( eg . first come first serve ( fcfs ) , weighted fair queuing ( wfq ) etc . ) .",
    "the served packets are queued and served according to the single queue scheduling policy .",
    "[ fig : model ] illustrates this model .    under this setup , the problem of scheduling is to choose a _ feasible _ schedule in each time slot to serve the queues and move the packets to their respective output queues .",
    "since the scheduling policy for each of the output queues can be chosen independently , the problem reduces to that of the constrained collection of queues .    ]",
    "first , some general notation .",
    "@xmath15 denotes the set of real numbers and @xmath16 the set of non - negative real numbers i.e. , @xmath17 .",
    "@xmath18 denotes the set of natural numbers @xmath19 and @xmath20 the set of non - negative integers @xmath21 .",
    "let @xmath22 and @xmath23 denote the vectors of @xmath24s and @xmath25s respectively .",
    "all the vectors in this paper are length @xmath2 vectors .",
    "let @xmath26@xmath27 denote the indicator function , @xmath28 and @xmath29 .",
    "@xmath30 denotes @xmath31 and we use the @xmath32 norm @xmath33 .",
    "we also use the standard inner product @xmath34 .",
    "recall that we are assuming bernoulli i.i.d arrivals .",
    "let @xmath35 denotes the number of arrivals to queue @xmath36 @xmath37 , during time slot @xmath38 .",
    "the arrival rate to queue @xmath6 is denoted by @xmath39 i.e. , @xmath40 @xmath41 @xmath42 denotes the arrival rate vector .",
    "@xmath43 denotes the length of queue @xmath6 at the beginning of time slot @xmath38 .",
    "@xmath44 denotes the queue length vector .",
    "@xmath45 denotes the feasible schedule chosen in time slot @xmath38 to serve the queues . without loss of generality",
    ", we assume that a feasible schedule is chosen and service happens at the middle of the time slot , and exogenous arrivals occur at the end of the time slot .",
    "this is shown in fig .",
    "[ fig : timeline ] . with @xmath43 denoting the queue length at the beginning of time slot @xmath38 , we have : @xmath46    @xmath0    finally , let @xmath47 denote the cumulative departure process of queue @xmath6 i.e.,@xmath48      we now introduce some definitions .",
    "we call a system rate stable , or simply stable in this paper , if the following holds with probability @xmath25 : for @xmath49,@xmath50    an arrival rate vector @xmath51 is called admissible if @xmath52 a scheduling policy under which the queuing network loaded with @xmath53 has a queue size process @xmath43 such that@xmath54    let @xmath55 denote the set @xmath56 .",
    "@xmath55 is called the throughput region or capacity region of the network .",
    "tassiulas and ephremides ( 1992 ) @xcite proved that:@xmath57    where @xmath58 denotes the convex hull of @xmath8 i.e. , @xmath59 @xmath60 denotes the relative interior of @xmath58 and @xmath61 denotes the closure of @xmath58 .",
    "denote @xmath60 by @xmath62 .",
    "it was also shown by tassiulas and ephremides ( 1992 ) @xcite that :    @xmath63    we call a scheduling algorithm throughput optimal if @xmath64 , the system is rate - stable .",
    "we now introduce the notion of a constraint free network ( cfn ) .",
    "a constraint free network is defined as a queuing network in which all the queues can be served simultaneously .",
    "therefore , for a cfn , @xmath65 . thus , scheduling just entails moving arriving packets immediately to their respective destination output queues .    as discussed in related work",
    "( section  [ sub : related - work ] ) , fairness is well understood for single queues . therefore , using a single queue fair scheduling scheme for each of the output queues yields a fair scheduling algorithm for the cfn .",
    "we assume throughout that a cfn is operating using a fair scheduling algorithm . along with a cfn",
    "we define a shadow cfn as follows : given a constrained queuing network @xmath66 , a cfn @xmath67 with the same number of queues and fed with copies of exogenous arrivals to @xmath66 , is called the shadow cfn of @xmath66 .",
    "we conclude this section with a brief motivation for the definition of cfn .",
    "this also serves as a preview to our approach to the problem .",
    "as mentioned earlier , the difficulty in designing a fair scheduling algorithm for networks arises because of the presence of constraints . in the absence of such constraints , the notion of fairness is equivalent to that of a single queue .",
    "thus , we define an ideal network that is constraint - free , whose performance we want to emulate .",
    "this is in some sense the best we can do in providing fairness and , thus , serves as a benchmark for defining notions of fairness .",
    "we consider the problem of designing scheduling algorithms for constrained queuing networks .",
    "a scheduling scheme or algorithm is a procedure whereby an appropriate feasible schedule is chosen in each time slot . in this paper , we will be interested in a class of scheduling algorithms termed the maximum weight ( mw ) scheduling algorithms .",
    "in general , a maximum weight algorithm works as follows : in each time slot @xmath38 , each queue @xmath6 is assigned a weight @xmath68 .",
    "this weight is usually but not necessarily a function of the queue size @xmath43 .",
    "then , the algorithm chooses the schedule with the maximum weight i.e.,@xmath69    a feasible schedule @xmath12 is said to be maximal if @xmath70 , @xmath71 component wise .",
    "the set of all maximal feasible schedules will be denoted by @xmath72 .",
    "it is reasonable to assume that we want to serve as many queues as possible in each time slot .",
    "therefore , when the algorithm chooses a feasible schedule @xmath73 , we serve the queues according to a maximal schedule @xmath74 such that @xmath75 .    * remark . *",
    "an important special instance of the mw scheduling algorithm is the one with queue sizes as the weights i.e. , @xmath76 . in their seminal work ,",
    "tassiulas and ephremides ( 1992 ) @xcite ( and independently mckeown et .",
    "al . ( 1996 ) @xcite ) showed that the mw algorithm with queue sizes as weights is rate stable .    since these results",
    ", there has been a significant work on designing high - performance , implementable packet scheduling algorithms that are derivatives of maximum weight scheduling , where weight is some function of queue - sizes .",
    "all of these algorithms are designed to optimize network utilization as well as minimize delay ( for example , see recent work by shah and wischik ( 2006 ) @xcite ) .",
    "however , these algorithms ignore the requirement of fairness .",
    "specifically , it has been observed that the maximum weight based algorithm can lead to unwanted starvation or very unfair rate allocation when switch is overloaded ( for example , see work by kumar , pan and shah ( 2004 ) @xcite ) .",
    "we provide a simple example of a switch ( detailed description given in the next subsection ) to illustrate this : consider a 2 2 switch with arrival rate matrix @xmath77 , @xmath78 @xmath79 . here",
    "@xmath80 corresponds to the arrival rate of traffic at input port @xmath81 for output port @xmath82 . under this loading",
    ", output port 2 is overloaded .",
    "if oq switch has round robin ( or fair ) policy at output 2 so that traffic from both inputs is served equally , then input 1 will get rate 0.5 and input 2 will get rate 0.5 from output 2 . however , the maximum weight matching policy , with weight being queue - size ( or for that matter any increasing continuous function of queue - size ) , the algorithm will try to equalize lengths of queues at both inputs . therefore , input 1 will get service rate 0.55 while input 2 will get service rate 0.45 from output 2 .",
    "we now discuss an input queued switch as a special instance of the abstract model that we have described . as mentioned before",
    ", a switch is present at the core of an internet router .",
    "a router moves packets from input ports to output ports .",
    "based on the final destination of the arriving packet , a router determines the appropriate output port and then transfers the packet accordingly .",
    "the transfer of packets to the corresponding output ports is called switching .    there are various switching architectures , but we discuss the one that is commercially the most popular .",
    "consider an input queued switch containing @xmath14 input ports and @xmath14 output ports .",
    "the queues at the output ports correspond to the output queues mentioned above , and hence we retain the notation @xmath14 for the number of output of queues ; since we are considering only switches with equal number of input and output ports , the number of input ports is also @xmath14 .",
    "packets arriving for input port @xmath81 and destined for output port @xmath82 are stored at input port @xmath81 in @xmath83 .",
    "note that for a switch , it is convenient to denote the queues as @xmath83 instead of as @xmath84 , as we do in the generic model . further , note that the total number of queues @xmath85 .",
    "the switch transfers packets from input ports to output ports using the switching fabric .",
    "the crossbar switching fabric implemented in an input queued switch imposes the following constraints on packet transfer from input to output ports : in each time slot , each input port can transmit at most one packet and each output port can receive at most one packet .",
    "therefore , feasible schedules are matchings from input to output ports .",
    "this is illustrated in fig .",
    "[ fig : iqswitch ] .",
    "the left and right hand figures illustrate two different possible matchings .",
    "the scheduling algorithm in the input queued switch chooses an appropriate matching in each time slot . to link back to the abstract model that we described , note that an m port switch has @xmath85 constrained queues ; for the queues we use the notation @xmath86 and not @xmath87 for all terms to clearly reference the input and output ports .",
    "the set of all feasible schedules @xmath8 corresponds to the set of all matchings in an @xmath88 bipartite graph :    @xmath89    packets leave the switch from their respective output ports and hence the output ports correspond to the output queues .",
    "since at most one packet arrives at each output port in each time slot , the packet immediately departs from the output queue .",
    "thus , scheduling reduces to choosing an appropriate matching in each time slot .",
    "we point an interested reader to @xcite for a more detailed exposition on switch architectures .",
    "we now consider wireless networks as a special instance of the abstract model .",
    "consider a collection of devices ( eg . sensor nodes , wifi nodes , etc . ) that are using the wireless medium to transmit messages .",
    "the devices share the same frequency to transmit and hence interfere when they transmit simultaneously . because of power constraints , only devices that are close to each other geographically can communicate .",
    "this is often modeled by a graph with a node for each device and an edge between two nodes if they can communicate .",
    "power constraints also limit interference to nodes that are close to each other ; in other words , only nodes that are connected by an edge interfere . therefore , the graph also models the interference constraints on scheduling .",
    "in other words , transmission to a node is successful only if none of its neighbors in the graph is transmitting at the same time .",
    "this model of interference is termed the _ independent set _ model of interference .",
    "we assume that the network is modeled as a graph @xmath90 with @xmath91 denoting the node set @xmath92 and @xmath93 denoting the directed edge set @xmath94 .",
    "each node @xmath81 maintains a queue @xmath83 for each of its neighbors @xmath82 .",
    "we assume a single hop network in which packets arrive at nodes , get transmitted to one of the neighbors and then leave the network through output queues . fig .",
    "[ fig : wireless ] illustrates a wireless network with three nodes operating under interference constraints .    in this setup ,",
    "the scheduling problem is to decide which directed links will be active simultaneously .",
    "constraints limit feasible schedules to those in which none of the neighbors of a receiver is transmitting ; in other words , if link @xmath95 is active then none of the links in the set @xmath96 should be active . for each network represented by graph @xmath90 , we can construct a conflict graph @xmath97 with a node for each of the directed links and an edge between two links if they can not be active simultaneously .",
    "the feasible schedules then reduce to independent sets in the conflict graph .",
    "formally , @xmath98    it should be noted that using the conflict graph , more general constraints in the network can be modeled as independent set constraints .",
    "thus , the model we are considering encapsulates the essence of a large class of scheduling problems .",
    "network resources are shared by different users and our goal is to design a scheduling algorithm that allocates resources in a fair manner . before we can design such an algorithm ,",
    "there is a need to give a precise definition of the users and the resources of the network .",
    "traditionally , different traffic flows were considered the users and the bandwidth allocated to them the resource of the network .",
    "link capacity constraints limited the total amount of resources available , and each flow was allocated its fair share of bandwidth .",
    "this is the basis of the _ utility maximization _ framework in which the utility of each flow was a function of the allocated bandwidth the more the bandwidth allocated , the greater the utility . different utility functions yield different fairness criteria .",
    "an inherent limitation of this approach is that it considers entire flows as users , disregarding the fact that flows are not continuous but are composed of packets .",
    "moreover , bandwidth is a resource that is allocated on an average over a long period of time assuming that flow statistics remain constant over such long periods .",
    "we overcome this limitation by treating the head - of - line ( hol ) packet of each flow as the user of the network resources ( we assume that each queue is associated with a flow and hence we use these terms interchangeably ) .",
    "this takes into account the packetized nature of a flow and is a consequence of the realization that in each time slot the decision is whether to serve the hol packet or not , unlike the case of a continuous flow that can be given fractional service .",
    "therefore , utilities should correspond to hol packets and not entire flows .",
    "with hol packets as the users , the network resource becomes the service they receive in each time slot .",
    "the network resource is limited by the constraint set @xmath8 and the algorithm should choose a feasible schedule @xmath12 in a manner that is fair to all the hol packets .",
    "inspired by the utility maximization framework , we could define utility functions for the hol packets and choose a feasible schedule that maximizes the overall utility .",
    "but , there is no natural choice of the utility function and hence we take a different approach .",
    "we begin with the realization that packets do not have natural utility functions , but they do have a natural preference order of the feasible schedules . for each packet , there are two classes of schedules one class containing all schedules that serve it and the other containing all schedules that do not . the packet is indifferent to all the schedules in the same class and the preference relation between schedules in different classes depends on how urgently the packet wants to get served .",
    "fair scheduling now reduces to combining individual preferences in a fair manner to come up with a socially preferred schedule .",
    "this is equivalent to a ranked election problem : hol packets ( queues ) are voters , schedules are candidates and each packet has a preference list of the schedules ( refer to section  [ sec : ranked - election ] for more details on the ranked election problem ) .",
    "the problem of ranked election is very well studied in the economics literature ( also called the theory of social choice ) . in their seminal work in 1952 , goodman and markowitz @xcite prove that under certain socially desirable postulates ( detailed in section  [ sec : ranked - election ] ) , when the voters have cardinal ( quantitative ) preferences over candidates , a simple function of those quantitative preferences yields a uniquely preferred outcome .    in order to use the goodman and markowitz result , we require not just relative preferences , but quantitative preferences over the feasible schedules . by quantitative preferences",
    "we mean that each packet assigns numerical weights to schedules ; the higher the weight , the more preferred the schedule . in principle , the packet can assign any weights consistent with its relative order of preferences to obtain quantitative preferences over the schedules .",
    "but it is important to realize that the choice of quantitative preference is crucial for obtaining the practically desired benefits of the fair scheduling . in our setup",
    ", each packet has two classes of schedules : one that it prefers to the other while being indifferent to schedules within the same class .",
    "therefore , the packet assigns the same weight to all the schedules within the same class .",
    "since only relative preferences matter , we assume that each packets assigns the same weight @xmath24 to all schedules in the class it does not prefer . assigning quantitative preferences",
    "now reduces to choosing a weight for each packet to assign to the class of schedules it prefers .",
    "one feasible option would be to use queue sizes as weights .",
    "the problem with this choice is that it is oblivious to flow identities and is susceptible to manipulation ( a flow can gain advantage by overloading system with packets resulting in large queue sizes ) .",
    "another option would be to use the age ( waiting time in the system ) of the packet .",
    "this choice is still oblivious to flow and packet identities and it is difficult to provide qos by giving priority to one flow ( packet ) over other .",
    "we overcome these problems by using the idea of emulation of the shadow cfn . as mentioned in related work ( section  [ sub : related - work ] )",
    ", one way of designing a fair scheduling algorithm would be to perfectly emulate a cfn using a fair queuing policy at each of the output queues . but",
    "this results in a loss of throughput of the system .",
    "therefore , our approach would be to emulate the shadow cfn as closely as possible .",
    "in this spirit , we use a function of the departure time of the packet from the shadow cfn as the weight ; the earlier the departure time , the higher the weight .",
    "the details of the exact function used are covered in sections  [ sec : analogy - between - fair ] and [ sec : most - urgent - cell ] .",
    "we now tie this back to the utility maximization framework . using the goodman and markowitz algorithm with the above choice of weights yields a mw style algorithm with the weight of each queue equal to the weight assigned to the packet .",
    "this is identical to the result we obtain by using the assigned weights as utilities of packets and choosing a schedule that maximizes overall utility .",
    "therefore , our algorithm yields utility functions for packets that can be used in the utility maximization framework .",
    "this rather surprising result connects our approach back to utility maximization very nicely .",
    "we then establish that such an algorithm is throughput optimal under the standard stochastic model of a network . to prove throughput optimality ( rate stability to be precise )",
    ", we use an appropriate quadratic lyapunov function . however , we can not use the standard stability proof technique based on foster s criterion because the lyapunov function is not a function of queue - sizes , but is function of _ preferences _ derived from the shadow cfn .",
    "this makes the analysis rather non - trivial .",
    "to explain the consequences of our algorithm on fair emulation , we present simulations for algorithms based on fifo oq switch .",
    "intuitively , our fair algorithm should be able to reduce the queue - size ( or delay ) as well as get rid of starvation caused by well - known throughput optimal algorithms .",
    "our simulation results clearly confirm this intuition .",
    "in this section we take a digression into economics literature to describe the ranked election problem .    [",
    "ranked election ] there are @xmath14 voters that vote for @xmath99 candidates .",
    "vote of each voter consists of a ranking ( or permutation ) of all @xmath99 candidates .",
    "these votes can additionally carry quantitative values associated with their preferences .",
    "let @xmath100 denote the value voter @xmath101 gives to candidate @xmath102 , for @xmath103 , @xmath104 .",
    "the goal of the election is to relative order all the @xmath99 candidates as well as produce the ultimate winner in a manner that is consistent with the votes .",
    "the key for a good election lies in defining consistency of the outcome of election with votes .",
    "the following are canonical postulates that are used in the literature on ranked election :    * between any two candidates @xmath102 and @xmath105 , suppose that none of the @xmath14 voters prefers @xmath105 to @xmath102 and at least one voter prefers @xmath102 to @xmath105 . then @xmath105 should not be ranked higher than @xmath102 in the output of the election .",
    "this property corresponds to the economic notion of weak pareto optimality .",
    "* suppose the voters are renumbered ( or renamed ) while keeping their votes the same .",
    "then the outcome of election should remain the same .",
    "in other words , the election outcome is blind to the identity of the voters , that is election outcome is symmetric .",
    "* now , consider the setup when the votes are cardinal ( i.e. , quantitative ) .",
    "suppose candidate @xmath102 is preferred to @xmath105 by the election .",
    "then , by adding the same fixed constant to all @xmath100 and @xmath106 for @xmath107 , the relative order of candidates @xmath102 and @xmath105 should not change .",
    "this makes sense because what matters is the difference in preference levels for the two candidates , not the actual values .    in the absence of cardinal ( or quantitative )",
    "preferences , the question of ranked election with postulates p1 , p2 ( and some additional postulates ) was first studied by arrow ( 1951 )  @xcite . in his celebrated work , he established the ( then ) very surprising impossibility of the existence of any election scheme that satisfies p1 , p2 ( and additional postulates ) simultaneously .",
    "we note that this result has been an important corner stone in the field of theory of social choice .",
    "subsequent to arrow s impossibility result , many economists started looking for positive results . among many other celebrated results ,",
    "the result that is relevant to this paper is that of goodman and markowitz ( 1952 )  @xcite .",
    "they showed that if voters have cardinal preferences , as in our setup , then there is a unique ordering of candidates that satisfies p1-p2-p3 simultaneously . to describe their result ,",
    "consider the following : let the net score of a candidate@xmath102 be @xmath108 .",
    "goodman and markowitz obtained the following remarkable result .",
    "[ thm : gm]suppose the scores of all candidates are distinct .",
    "rank candidates as follows : candidate @xmath102 has higher ranking than @xmath109 if and only if @xmath110 .",
    "this ranking satisfies postulates p1-p2-p3 .",
    "further , this is the only such ranking .    for a proof of this result ,",
    "we refer the reader to  @xcite .",
    "in this section , we motivate our fair scheduling algorithm by establishing an equivalence between fair scheduling in a constrained queuing network @xmath66 and the problem of ranked election . in our context , the packets ( queues ) are the voters and the feasible schedules @xmath12 are the candidates . in order to use the goodman and markowitz setup , we need to derive preferences for packets over schedules . for each packet , there are two classes of schedules one class containing all schedules that serve it and the other containing all schedules that do not .",
    "the packet is indifferent to all the schedules in the same class . since only the relative weights matter",
    ", we assume that a packet assigns a weight of @xmath24 to all schedules that do not serve it .",
    "we derive preferences for packets over schedules that serve them from the corresponding shadow cfn @xmath111 that is operating with a single queue fair scheduling policy at each of its output queues .",
    "as defined before , a copy of every packet arriving to the network @xmath66 is fed to the shadow cfn @xmath111 .",
    "that is , ( a copy of ) a packet arriving at queue n for output queue @xmath101 of @xmath66 immediately joins the output queue @xmath101 in @xmath112 .",
    "the departures from the output queues of @xmath112 happen according to an appropriate fair scheduling policy , say @xmath113 , such as strict priority scheme , last - in - first - out or simply first - in - first - out .",
    "specifically , our objective in assigning preferences is to have the departures of packets from @xmath66 be as close as possible to the departures from the corresponding shadow cfn @xmath112 .",
    "ideally , we want @xmath66 to exactly emulate @xmath112 i.e. , we want the departure times of packets from both the networks to be exactly the same . however , we settle with approximate emulation because , as shown by chuang et .",
    "@xcite , exact emulation is not possible at speedup 1 .",
    "since the preferences of packets are chosen from @xmath112 and these preferences are combined in a fair manner , the fair scheduling polices at the output queues of @xmath112 can now be chosen according to the desired requirements .",
    "based on the above discussion , our approach is to use a value that is a function of the departure time of the packet from@xmath112 the earlier the departure time , the higher the value assigned .",
    "more specifically , let @xmath114 denote the hol packet in queue @xmath6 of network @xmath66 at time @xmath38 .",
    "let @xmath115 denote the departure time of @xmath114 from @xmath112 .",
    "for the following discussion we assume that the queue is non - empty and hence @xmath115 is well defined .",
    "we defer the discussion of empty queues to the next section .",
    "now , each queue @xmath6 assigns a value of @xmath116 to all the schedules that serve it .",
    "( the choice of @xmath116 seems arbitrary , when we could have taken any decreasing function of @xmath115 .",
    "indeed we can , though it should have some nice properties to maximize throughput .",
    "details are in section  [ sec : throughput - of - mucf ] ) .",
    "this completes the equivalence .    taking a closer look at the weight @xmath116 ,",
    "note the following .",
    "suppose at time @xmath38 the packet @xmath114 is already late i.e , @xmath117 .",
    "in this case , the weight @xmath118 , which means that @xmath114 prefers all schedules that serve it to all the schedules that do not by weight @xmath116 .",
    "thus , the more delayed the packet is , the higher the weight it assigns . on the other hand , when the packet is not late i.e. , @xmath119 , @xmath114 prefers schedules that do not serve it in order to give a chance to packets that are late to get served .",
    "now , with the above assignment of values to each schedule by each queue , the value of a schedule @xmath12 is given as : @xmath120    the postulates p1-p2-p3 translate into the following postulates for network scheduling .",
    "* between any two schedules @xmath121 and @xmath122 , suppose that none of the @xmath2 hol packets prefer @xmath122 to @xmath121 and at least one hol packet prefers @xmath121 to @xmath122 .",
    "then , we should not choose @xmath122 .",
    "* for given hol packets , let @xmath73 be the outcome of the election as per the above preferences for schedules . then , by renumbering queues while retaining the same hol preferences , the outcome of election should be only renumbered @xmath73 .",
    "in other words , the election does not give unfair priority to any port and thus is symmetric in its inputs .",
    "* suppose schedule @xmath123 is preferred to @xmath124 by the election . by adding the same fixed constant to @xmath125 for all @xmath6 , the outcome of the election should remain unchanged .",
    "the election algorithm of goodman and markowitz suggests that the following schedule @xmath126 should be chosen :    @xmath127",
    "based on the discussion in the previous section , we propose a fair scheduling algorithm called the _ most urgent cell first _ algorithm . according to this algorithm",
    ", packets are scheduled according to the maximum weight schedule ( mws ) with urgencies of queues as weights with the urgency @xmath129 of queue n defined as @xmath116 if it is non - empty i.e. , the more late the packet is , the higher is its urgency .",
    "if queue @xmath6 is empty we define its urgency as @xmath130 .",
    "note that according to this definition , the weight assigned to a schedule by an empty queue is always less than or equal to the weight assigned by any non - empty queue in the system .",
    "therefore , as desired , the fair schedule chosen by the algorithm tries to minimize the number of empty queues it serves .",
    "of course , as mentioned in the previous section , we could have used any increasing function of the urgency . in particular , suppose @xmath131 denotes a non - decreasing bi - lipschitz continuous function with lipschitz constant @xmath132 i.e. , for any @xmath133 , @xmath134 . without loss of generality , we assume that @xmath135 ; thus , @xmath136 for @xmath137 .",
    "the mucf(@xmath128 ) algorithm now chooses the mws with weight of queue @xmath6 equal to @xmath138 , defined as @xmath139 .",
    "formally , the three components of the algorithm are as follows :    1 .",
    "the arriving packets are queued according to the * fifo * queuing policy in each of the n constrained queues .",
    "2 .   for a packet @xmath140 in @xmath141",
    ", let @xmath142 denote its departure time from @xmath112 .",
    "then , the arriving packets in each of the @xmath14 output queues are queued in the order of their respective departure times from @xmath112 .",
    "more formally , in every output queue @xmath101 , a packet @xmath140 will be ahead of every packet @xmath143 that satisfies @xmath144 .",
    "3 .   in each time slot @xmath145 , the algorithm chooses a feasible schedule @xmath126 from @xmath8 using a mw criterion as follows : @xmath146",
    "the previous section described how we arrived at mucf algorithm as a fair algorithm based on preferences obtained from a shadow cfn .",
    "as established in the previous section , theorem  [ thm : gm ] implies that mucf is the only algorithm that satisfies the desirable postulates p1@xmath147-p2@xmath147-p3@xmath147 . in this section , we state and",
    "prove the throughput optimality property of the mucf algorithm .",
    "the proof of the algorithm is non - traditional and requires new techniques that may be of interest for analysis of such non - queue based weighted algorithms .",
    "[ thm : rate - stable]consider a constrained queuing system with an arbitrary set of constraints @xmath8 .",
    "suppose the system is loaded with an i.i.d .",
    "bernoulli arrival process , and is operating under the mucf(@xmath128 ) algorithm with@xmath148 a bi - lipschitz function .",
    "then , if the rate vector is strictly admissible , the queuing network is rate stable .    before we prove theorem  [ thm : rate - stable ] we need the following notation and lemmas .    * notation . *",
    "first , some useful notation .",
    "consider the hol packet @xmath114 of queue @xmath6 in network @xmath66 at the beginning of the time slot @xmath145 .",
    "as before , let @xmath149 be its time of arrival and @xmath115 be the time of its departure from @xmath112 , @xmath129 be its urgency as defined above , and @xmath150 be its waiting time ( i.e. , @xmath151 if the queue is non - empty and @xmath24 if it is empty ) .",
    "let @xmath152 denote @xmath153 and @xmath154 denote @xmath155 . also , define @xmath156 as @xmath157 .",
    "we note that if queue @xmath6 is empty , then @xmath158 and @xmath129 is as defined above .",
    "hence , @xmath156 is always non - negative .",
    "let @xmath159 , @xmath160 , denote the length of the @xmath161 busy cycle at output queue @xmath101 in @xmath112 .",
    "finally , for any function @xmath162 and a vector @xmath163 , @xmath164 denotes @xmath165 . before we state the lemmas and prove theorem  [ thm : rate - stable ] , note the following property of @xmath166:@xmath167    the equality @xmath168 follows directly from the definition of @xmath166 . coming to @xmath169 , note that since @xmath148 is non - decreasing and @xmath135 , it follows that @xmath170 for @xmath171 and @xmath136 for @xmath172 .",
    "hence , for @xmath173 , @xmath174 since @xmath136 for @xmath172 .",
    "similarly , for @xmath175 , @xmath176 since @xmath177 for @xmath178 .",
    "[ lem : lyapunov]let @xmath179 .",
    "then , under the mucf(@xmath128 ) algorithm with @xmath148 a bi - lipschitz function and @xmath53 being strictly admissible , there exists an @xmath180 such that@xmath181    for some constant @xmath182 .",
    "[ lem : w]under the mucf(@xmath183 algorithm , with @xmath148 a bi - lipschitz function and @xmath53 being strictly admissible , suppose @xmath184 and @xmath185 for all @xmath186 then , we must have@xmath187    [ lem : wcp]let @xmath188 denote @xmath189 , for @xmath160 . then",
    ", under a strictly admissible @xmath53 with the output queues of @xmath112 operating under a work conserving policy ( wcp ) , the following is true for all @xmath190and @xmath103,@xmath191    we will first prove the result of theorem  [ thm : rate - stable ] assuming the results of lemmas   [ lem : lyapunov ] and [ lem : wcp ] , and defer their proof until after the proof of theorem  [ thm : rate - stable ] .",
    "[ proof of theorem  [ thm : rate - stable]]we first note that if queue @xmath6 is non - empty then @xmath192 where @xmath101 is the destination output queue of packet @xmath114 .",
    "this is true because when queue @xmath6 is non - empty , @xmath156 denotes the waiting time of @xmath114 in its destination output queue in @xmath112 , and hence can not be more than the length of the busy cycle it belongs to .",
    "since there can be at most @xmath38 busy cycles up to time @xmath38 and @xmath114 arrived to @xmath112 before @xmath38 , ( [ eq : delta - bound ] ) should be true .",
    "therefore , from lemma  [ lem : wcp ] and ( [ eq : delta - bound ] ) it follows that:@xmath193    if queue @xmath6 is empty , then by definition it follows that either @xmath194 or @xmath195 , for some queue @xmath196 that is non - empty . since , @xmath197 @xmath198 , we have from ( [ eq : delta - bound2 ] ) that @xmath199 .",
    "hence , ( [ eq : delta - bound2 ] ) is valid even for empty queues and it thus follows that:@xmath200    from lemma  [ lem : lyapunov ] and ( [ eq : delta - bound3 ] ) , we obtain the following:@xmath201    telescopic summation of ( [ eq:16 ] ) from @xmath202 , we obtain ( after cancellations),@xmath203    now , the network starts empty at time @xmath24 .",
    "therefore , @xmath204 .",
    "further , @xmath205 is non - negative function .",
    "therefore , ( [ eq:17 ] ) gives us    @xmath206    dividing both sides by @xmath207 we obtain@xmath208    let @xmath209 and @xmath210 . from ( [ eq:19 ] ) , we have @xmath185 for all @xmath38 .",
    "it now follows from lemma  [ lem : w ] that@xmath211 using ( [ eq:20 ] ) , we complete the proof of rate stability of the algorithm as follows . at time @xmath38 , the waiting time of the hol packet of queue @xmath6 is @xmath150 .",
    "because of fifo policy and at most one arrival per time slot , we have that the queue - size of queue @xmath6 at time @xmath38 , @xmath212 . from ( [ eq:20 ] ) , we have that@xmath213 now",
    ", @xmath43 observes the following dynamics : @xmath214 where the second term on rhs is the cumulative arrival to queue @xmath6 till time @xmath38 while the third term is the cumulative departure from queue @xmath6 till time @xmath38 . by strong law of large numbers ( slln ) for bernoulli i.i.d .",
    "process we have that : @xmath215    using this along with ( [ eq:21 ] ) and ( [ eq:22 ] ) , we obtain@xmath216 this completes the proof of theorem  [ thm : rate - stable ] .",
    "[ proof of lemma  [ lem : w ] ] suppose ( [ eq:211 ] ) is not true .",
    "then , since @xmath217 we have that for some @xmath218,@xmath219 where i.o .",
    "means infinitely often .",
    "now if @xmath220 , then there exists an hol packet that has been waiting in the network for time at least @xmath221 .",
    "this is true because @xmath222 is the sum of waiting times of at most @xmath2 hol packets .",
    "call this packet @xmath140 .",
    "this packet must have arrived at time @xmath223 .",
    "since waiting time of a packet increases only by @xmath25 each time - slot , the waiting time of packet @xmath140 must be at least @xmath224 in time interval @xmath225 $ ] , where @xmath226 now , consider any time @xmath227 $ ] .",
    "the packet waiting at the hol of the queue that contains @xmath140 must have waiting time higher than that of @xmath140 due to the fifo ordering policy .",
    "therefore , the contribution to @xmath228 by hol packets of the queue that contains packet @xmath140 is at least @xmath229 .",
    "therefore , we obtain@xmath230 therefore , by the definition of @xmath231 and non - negativity of @xmath232 , we have the following logical implication:@xmath233 thus , if ( [ eq:23 ] ) holds then by ( [ eq:25 ] ) we have@xmath234 now observe the following relation of @xmath235 : since @xmath236@xmath237 for any integer @xmath238 and any integer @xmath239 $ ] , we can now write@xmath240 now , for any @xmath241 , let @xmath242 , which implies that @xmath243 .",
    "we can then write for any integer @xmath244$],@xmath245 since@xmath246 taking @xmath247 , for @xmath190 large enough , it follows that @xmath248 .",
    "thus , for @xmath190 large enough and any integer @xmath249$]@xmath250 define @xmath251 for @xmath252 .",
    "then , the following are direct implications of ( [ eq:27 ] ) : for any @xmath253,@xmath254 the first implication is true because for any @xmath38 such that @xmath255we can find a @xmath256 such that @xmath257.$ ] it then follows from ( [ eq:27 ] ) that @xmath258 similarly , for the second implication , whenever @xmath259 taking @xmath260 , we can write @xmath261    it follows from ( [ eq:28 ] ) that @xmath262 thus , in order to complete the proof of ( [ eq:20 ] ) by contradicting ( [ eq:26 ] ) , and thereby ( [ eq:23 ] ) , it is sufficient to show that for @xmath263,@xmath264 for this , let event @xmath265 then , from @xmath266 relations @xmath267 @xmath268 and markov s inequality we obtain that@xmath269 therefore ,",
    "@xmath270 therefore , by borel - cantelli s lemma , we have that @xmath271 this completes the proof of the lemma .    [ proof of lemma  [ lem : lyapunov ] ] define the following : for all @xmath6@xmath272 where @xmath273 is the schedule of mucf algorithm and @xmath274 is the inter - arrival time for the arrival process to queue @xmath275 when the queue is empty , treat @xmath274 as an independent r.v . without any meaning , while if queue is not empty then treat it as the inter - arrival time between the packet being served and the packet behind it .",
    "in either case , due to the fifo policy @xmath274 is totally independent of the scheduling decisions performed by the algorithm till ( and including ) time @xmath38 and the information utilized by the algorithm .",
    "therefore , we will treat it as an independent random variable with geometric distribution of parameter @xmath39 ( since arrival process is bernoulli i.i.d . ) .",
    "consider the following : for any @xmath38,@xmath276 it is easy to see that,@xmath277 since @xmath148 is non - decreasing bi - lipschitz continuous with @xmath278 we have @xmath279 now , it follows from ( [ eq:29 ] ) , ( [ eq:30 ] ) , and ( [ eq:31 ] ) that@xmath280 using ( [ eq:32 ] ) and the fact that @xmath274 is a geometric r.v . with mean @xmath281",
    "we have the following:@xmath282 here we have used the fact that @xmath283 and hence @xmath284 , and @xmath285 .",
    "using the fact that @xmath286 @xmath287 and @xmath288 for all @xmath6 such that @xmath289 , we obtain @xmath290 where @xmath182 is a large enough constant .",
    "now , define @xmath291 as @xmath292 that is , @xmath291 is the maximum weight schedule with weight of queue @xmath6 as @xmath152 .",
    "consider the following:@xmath293 from the definition of @xmath294 , @xmath291 , @xmath295 and bi - lipschitz continuity of @xmath148 it follows that @xmath296 now , for strictly admissible @xmath53 such that @xmath297 with @xmath298 for some @xmath299 we obtain that @xmath300 since @xmath291 is the maximum weight schedule with weight of queue @xmath6 as @xmath150:@xmath301 thus , it follows from ( [ eq:38 ] ) and ( [ eq:39 ] ) that @xmath302 now since all @xmath2 entries can be covered by @xmath2 distinct feasible schedules , it follows that the weight of maximum weight matching is at least @xmath303 the sum of weights of all the entries .",
    "that is @xmath304 the last inequality follows from the bi - lipschitz continuity of @xmath148 . combining - and taking further expectation with respect to @xmath305 we obtain @xmath306 where @xmath307 to complete the proof , note that if queue @xmath6 is non - empty after service at time @xmath38 , then @xmath308 else , @xmath309 and thus it follows from that @xmath310 this inequality along with implies the desired claim of lemma  [ lem : lyapunov ] .",
    "[ proof of lemma  [ lem : wcp ] ] this result corresponds to a constraint - free network in which scheduling at different output queues is independent .",
    "hence , we will prove the result for a single queue operating under a wcp and strictly admissible loading .",
    "we use the same notation , but with subscript @xmath101 s dropped . for a single queue operating under a wcp and strictly admissible loading",
    ", busy cycle lengths form an i.i.d process i.e. , @xmath311 are i.i.d .",
    "we now look at the large deviation behavior of this process . for a particular @xmath256 and time @xmath312 starting from the beginning of busy cycle @xmath311 ,",
    "let @xmath313 denote the cumulative arrival process during @xmath311 .",
    "now consider the event @xmath314 .",
    "if the length of the busy cycle is greater than @xmath190 , it implies that the queue has been non - empty up to time @xmath190 .",
    "further , since the service process is work conserving , it follows that there has been one departure every time slot and hence a total of @xmath190 departures up to time @xmath190 .",
    "since the total number of departures can not be more than the total number of arrivals , it follows that @xmath315 .",
    "thus , we conclude that the event @xmath314 implies the event @xmath315 . for large enough @xmath190 , we can now write@xmath316 where @xmath99 and @xmath317 are some non - negative constants .",
    "the last inequality follows from chernoff bound , which can be used because arrivals happen according to a bernoulli process .",
    "let @xmath318 denote the random variable @xmath319 .",
    "then , we have the following:@xmath320 is true for any non - negative integer @xmath321 . in particular , choose @xmath321 large enough such that is true @xmath322 .",
    "it now follows from union bound that @xmath323 the second inequality follows from .",
    "now by choosing @xmath324 we can bound @xmath325 by @xmath25 .",
    "it now follows from that @xmath326",
    "we carried out simulations to evaluate the performance of our algorithm in the context of iq switches .",
    "we assumed a fifo queuing policy at the input ports of the iq switch .",
    "we compared the performance of our algorithm with the longest queue first ( lqf ) and oldest cell first ( ocf ) algorithms .",
    "we used the fixed - length packet switch simulator available at http://klamath.stanford.edu / tools / sim/.    we first explain the simulation setting : the switch size is @xmath327 .",
    "the buffer sizes are infinite .",
    "the policy used is fifo .",
    "all inputs are equally loaded on a normalized scale , and @xmath328 denotes the normalized load .",
    "the arrival process is bernoulli i.i.d .",
    "we use a uniform load matrix , i.e. , @xmath329 @xmath330 .",
    "we ran our simulation for 2.1 million time steps removing the first @xmath331 time steps to achieve steady - state .",
    "because we are approaching this problem from the perspective of fairness , we evaluate the aforementioned switching algorithms in terms of latency and output - queue ( oq ) delay .",
    "oq delay is defined as the difference of the departure times of a packet in the input queued switch and the shadow oq switch .",
    "further , the goal can not only be to achieve a better expected latency , but in fact , we wish to value consistency , or relatively few deviations from the mean .",
    "one measure for this are higher moments of the variables .",
    "thus , here we provide plots for the logarithm of first and second moments of both latency and the oq delay versus a uniform load of @xmath332 .",
    "figures 5 and 6 plot respectively the logarithm of the first and second moments of the latency .",
    "we observe that for lower loads , i.e. , for @xmath333 the performance of all the three algorithms is almost the same .",
    "but for higher loads , the first moment of lqf and mucf are better than ocf . fig .",
    "6 shows that in terms of the second moment , mucf performs the best and lqf the worst , with ocf lying between .",
    "this is in line with our expectations because , as mentioned earlier lqf is not fair and hence performs badly at higher moments .",
    "mucf performs better than ocf for both the moments .",
    "figures 5 and 6 correspond to latency and figures 7 and 8 correspond to oq delay .",
    "we observe that mucf performs better than the other two algorithms for both the metrics at all the loads , especially for the second moments illustrating fairness .",
    "thus , the simulations illustrate that mucf tracks the performance of an oq switch better than lqf and ocf .",
    ", height=264 ]    , height=264 ]    , height=264 ]    , height=264 ]",
    "in this paper , we considered the problem of designing a fair scheduling algorithm for constrained queuing systems .",
    "fairness in networks is not only an intuitively desired goal , but also one with many practical benefits .",
    "most of the existing work concentrates on fairly allocating bandwidth to different flows in the network .",
    "a major limitation of this approach is that it disregards the packetized nature of flows .",
    "we overcame this problem and proposed a packet based notion of fairness by establishing a novel analogy with the ranked election problem . ranked",
    "election is a widely studied problem in the economics literature , and this analogy allowed us to leverage that work .",
    "this results in a packet based notion of fairness and an algorithm to achieve this fairness .    rather surprisingly , the algorithm turned out be the familiar mw style algorithm .",
    "moreover , it does not require the knowledge of flow arrival rates .",
    "our fairness algorithm also fits into the utility maximization framework that is more popular for designing fair algorithms .",
    "this , in some sense , validates our approach .",
    "we also proved that our algorithm is throughput optimal .",
    "this result is very crucial since the emulation approach already achieves fairness , but with a loss of throughput . also , the proof is non - trivial and requires some non - traditional techniques to be introduced because existing proof techniques do nt directly apply .",
    "we believe that the proof techniques we introduced are more widely applicable to similar problems and this is another important contribution of the paper . finally , our simulation results corroborate the fact that our algorithm is better at providing fairness than the more popular algorithms in the context of input queued switches .",
    "t.  bonald and l.  massouli , `` impact of fairness on internet performance , '' _ proceedings of the 2001 acm sigmetrics international conference on measurement and modeling of computer systems _ , pp .  8291 , 2001 .",
    "d.  k.  y. yau , j.  c.  s. lui , f.  liang , and y.  yam , `` defending against distributed denial - of - service attacks with max - min fair server - centric router throttles , '' _ ieee / acm trans .",
    "_ , vol .  13 , no .  1 ,",
    "pp .  2942 , 2005 .",
    "f.  kelly , a.  maulloo , and d.  tan , `` rate control for communication networks : shadow prices , proportional fairness and stability , '' _ journal of the operational research society _ , vol .",
    "49 , no .  3 , pp .",
    "237252 , 1998 .",
    "a.  demers , s.  keshav , and s.  shenker , `` analysis and simulation of a fair queueing algorithm , '' in _",
    "sigcomm 89 : symposium proceedings on communications architectures & protocols _ , ( new york , ny , usa ) , pp .  112 , acm , 1989 .",
    "a.  parekh and r.  gallager , `` a generalized processor sharing approach to flow control inintegrated services networks : the single - node case , '' _ networking , ieee / acm transactions on _ , vol .  1 , no .  3 , pp .",
    "344357 , 1993 .",
    "a.  parekh and r.  gallager , `` a generalized processor sharing approach to flow control inintegrated services networks : the multiple node case , '' _ networking , ieee / acm transactions on _ , vol .  2 , no .  2 , pp .",
    "137150 , 1994 .",
    "m.  chiang , s.  low , a.  calderbank , and j.  doyle , `` layering as optimization decomposition : a mathematical theory of network architectures , '' _ proceedings of the ieee _ ,",
    "95 , no .  1 ,",
    "255312 , jan . 2007 .",
    "g.  de  veciana , t.  konstantopoulos , and t.  lee , `` stability and performance analysis of networks supporting elastic services , '' _ ieee / acm transactions on networking ( ton ) _ , vol .  9 , no .  1 ,",
    "pp .  214 , 2001 .",
    "chuang , a.  goel , n.  mckeown , and b.  prabhakar , `` matching output queueing with a combined input output queued switch , '' _ ieee journal on selected areas in communications _",
    "17 , no .  6 , pp .",
    "10301039 , 1999 .",
    "l.  tassiulas and a.  ephremides , `` stability properties of constrained queueing systems and scheduling policies for maximum throughput in multihop radio networks , '' _ automatic control , ieee transactions on _ , vol .",
    "37 , no .  12 , pp .  19361948 , dec 1992 .",
    "srikanth jagabathula srikanth jagabathula received the btech degree in electrical engineering from the indian institute of technology ( iit ) bombay in 2006 , and the ms degree in electrical engineering and computer science from the massachusetts institute of technology ( mit ) , cambridge , ma in 2008 .",
    "he is currently a doctoral student in the department of electrical engineering and computer science at mit .",
    "his research interests are in the areas of revenue managemenr , choice modeling , queuing systems , and compressed sensing .",
    "he received the president of india gold medal from iit bombay in 2006 .",
    "he was also awarded the `` best student paper award '' at nips 2008 conference and the ernst guillemin award for the best ee sm thesis .",
    "devavrat shah devavrat shah is currently a jamieson career development associate professor with the department of electrical engineering and computer science , mit .",
    "he is a member of the laboratory of information and decision systems ( lids ) and affiliated with the operations research center ( orc ) .",
    "his research focus is on theory of large complex networks which includes network algorithms , stochastic networks , network information theory and large scale statistical inference .",
    "he received his btech degree in computer science and engg . from iit - bombay in 1999 with the honor of the president of india gold medal .",
    "he received his ph.d . from the computer science department , stanford university in october 2004 .",
    "he was a post - doc in the statistics department at stanford in 2004 - 05 .",
    "he was co - awarded the best paper awards at the ieee infocom 04 , acm sigmetrics / performance 06 ; and best student paper awards at neural information processing systems 08 and acm sigmetrics / performance 09 .",
    "he received 2005 george b. dantzig best disseration award from the informs .",
    "he received the first acm sigmetrics rising star award 2008 for his work on network scheduling algorithms ."
  ],
  "abstract_text": [
    "<S> we consider the problem of designing a fair schedul - ing algorithm for discrete - time constrained queuing networks . each queue has dedicated exogenous packet arrivals . </S>",
    "<S> there are constraints on which queues can be served simultaneously . </S>",
    "<S> this model effectively describes important special instances like network switches , interference in wireless networks , bandwidth sharing for congestion control and traffic scheduling in road roundabouts . </S>",
    "<S> fair scheduling is required because it provides isolation to different traffic flows ; isolation makes the system more robust and enables providing quality of service . </S>",
    "<S> existing work on fairness for constrained networks concentrates on flow based fairness . as a main result , </S>",
    "<S> we describe a notion of packet based fairness by establishing an analogy with the ranked election problem : packets are voters , schedules are candidates and each packet ranks the schedules based on its priorities . </S>",
    "<S> we then obtain a scheduling algorithm that achieves the described notion of fairness by drawing upon the seminal work of goodman and markowitz ( 1952 ) . </S>",
    "<S> this yields the familiar maximum weight ( mw ) style algorithm . as another important result </S>",
    "<S> , we prove that the algorithm obtained is throughput optimal . </S>",
    "<S> there is no reason a priori why this should be true , and the proof requires non - traditional methods    fair scheduling , packet - based fairness , ranked election , throughput optimality    @xmath0    # 1#2#1,#2    # 1|#1|    # 1    # 1    v#1(#1 )    # 1_\\ { # 1 } </S>"
  ]
}