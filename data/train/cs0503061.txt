{
  "article_text": [
    "trust management  @xcite ( tm ) is an approach to managing authorization in environments where authority emanates from multiple sources .",
    "authorization policy consists of statements issued by many participants , and resource sharing is facilitated by delegating authority from one principal to another .",
    "a particular authorization is decided by posing a query to the system .",
    "an evaluation procedure combines the statements issued by all relevant principals to derive the query s answer . by adding or removing a policy statement",
    ", a principal can potentially affect many authorizations of many principals .",
    "one of the difficulties of operating in such a context is that at present no system exists for monitoring unexpected consequences of policy changes made by other principals .",
    "basically , in present tm systems , delegating trust implies losing a great deal of control on the policy involved the delegation .",
    "let us first see three example of this .",
    "firstly , resources may become unavailable unexpectedly .",
    "consider for instance a team leader who needs to be informed if members of his team suffer interruption in their authorization for mission - critical resources .",
    "if the team s mission involves rapid response , the notification of interruption should not depend on team members attempting to access a critical resource and discovering its unavailability only because the attempt fails .",
    "what is needed is that the policy change triggers a procedure that pushes the notification to the team leader .",
    "secondly : properties such as mutual exclusion can not be guaranteed . while in the above example , the exceptional state involved someone losing authorization , having someone unexpectedly gain authorization can be just as important to detect .",
    "for instance , it should be possible to trigger an action if a principal becomes authorized for two mutually exclusive purposes .",
    "mutual exclusion is an approach often used , for instance in rbac systems  @xcite , to enforce separation of duty , a classic device aimed at preventing fraud . by ensuring that no individual is authorized to complete all parts of a sensitive task",
    ", the technique ensures that only a colluding group could misuse the capability .",
    "because the participants in a trust management system are autonomous , it is in general not possible to prevent a principal being given two authorizations .",
    "however , cooperating principals should be able to prevent another principal from gaining two mutually exclusive authorizations under the control of the cooperating group .",
    "what is needed is a way to distribute the mutual exclusivity requirement and monitor policy evolution to ensure that control over the key authorizations is not delegated outside the cooperating group .",
    "thirdly : quality can not be monitored .",
    "consider the situation in which the principal @xmath0 states , for instance , that he considers expert anyone that @xmath1 considers an expert ( @xmath0 delegates to @xmath1 the definition of `` expert '' ) .",
    "in addition , @xmath0 expects experts to have a phd degree .",
    "now , @xmath0 has no way of controlling that all experts added by @xmath1 actually have doctorates .",
    "of course , @xmath0 could modify his policy as follows `` @xmath0 considers expert anyone _ holding a phd _ that @xmath1 considers an expert ''",
    ". however often it would be preferable for @xmath0 to know whether a non - phd had been added to the expert list because it might suggest to @xmath0 that an exception to @xmath0 s policy is acceptable , or that some other evolution of @xmath0 s policy should take place ( perhaps it is time to revoke the trust in @xmath1 s experts ) .",
    "thus , what @xmath0 needs is to be able to monitor whether @xmath1 ever decides that a non - phd is an expert .",
    "notice that this is what would happen in practice : before delegating to @xmath1 the definition of expert @xmath0 would normally put in place a monitoring activity to guarantee that @xmath1 s expert fulfill the quality criteria .",
    "unfortunately , present decentralized tm systems do not allow for such monitoring .",
    "summarizing , there is a need for a mechanism to monitor a tm system and to reveal when an exceptional state has been entered so that appropriate steps can be taken proactively .",
    "ideally , it would even be possible to enlist the assistance of others in preventing exceptional states from arising .",
    "the problem of providing such a monitoring system is aggravated by the fact that changes are made by autonomous principals that may not agree or be trusted to assist in the monitoring .    in this paper",
    "we introduce a new trust management construct called a constraint , inspired by integrity constraints in database management systems ( see , e.g. @xcite ) , that provides system participants the ability to monitor the evolution of the policy .",
    "the author of a constraint receives notification when the constraint is violated .",
    "this is achieved by enlisting the assistance of principals to which authority is delegated and triggering constraint checks when those principals make relevant policy changes . the emphasis in this paper is on determining whether a policy change is relevant , or can be ignored .",
    "in addition we also consider the setting in which some principals are not trusted or willing to help monitoring a constraint . as mentioned above , in some environments , it is not appropriate to assume that all principals to whom one delegates authority will assist in monitoring one s constraints . by providing a sufficiently expressive constraint language ,",
    "we show how to limit to an arbitrary , specified set those principals that are trusted to cooperate in monitoring a constraint .",
    "this is done by allowing a constraint to express a security analysis problem of the kind formulated by li et al .",
    "such a constraint quantifies over policy states that are reachable by policy changes made by untrusted principals asking whether a given query holds either in all reachable states ( universal quantification ) or in some reachable state ( existential quantification ) . by checking such a constraint each time the trusted principals make relevant policy changes , and committing their changes only if the constraint is satisfied",
    ", the trusted principals can ensure that a state violating the constraint is never entered , no matter what the untrusted principals do .",
    "they are able to do this because the untrusted principals are unable to affect the validity of the constraint .",
    "the technical contribution in this paper is a method to identify portions of the policy state that must be monitored in order to detect constraint violations .",
    "we do this first under the assumption that all principals in the system can be trusted to assist in monitoring the portion of the policy state under their control .",
    "we then relax this assumption by requiring only that a given portion of the policy can be reliably monitored . in this case",
    ", monitoring is carried out by using security analysis to assess the possibility of the constraint becoming violated by policy changes that can not be monitored directly .",
    "section  [ sec : preliminaries ] discusses the tm policy language that we use .",
    "section  [ sec : main ] identifies the portion of the policy state to be monitored for constraint violations , assuming all portions can be monitored .",
    "section  [ sec : safety ] shows how to monitor constraints for potential violations when not all parts of the policy state can be monitored directly .",
    "section  [ sec : relatedwork ] discusses related work .",
    "section  [ sec : conclusion ] concludes .",
    "some proofs are reported in the appendix .",
    "trust management  @xcite is an approach to access control in decentralized distributed systems with access control decisions based on policy statements issued by multiple principals . in trust management systems , statements that are maintained in a distributed manner",
    "are often digitally signed to ensure their authenticity and integrity ; such statements are sometimes called _ credentials _ or _",
    "certificates_. this section presents the trust management language @xmath2  @xcite , which we use in this paper .",
    "a _ principal _ is a uniquely identified individual or process .",
    "principals are denoted by names starting with an uppercase , typically , @xmath0 , @xmath1 , @xmath3 .",
    "a principal can define a _ role _",
    ", which is indicated by principal s name followed by the _ role name _ , separated by a dot . for instance",
    "@xmath4 , and @xmath5 are roles . for the sake of simplicity",
    "we assume that @xmath0 is the _ owner _ ( or the administrator ) of @xmath4 , though the results of this papers apply also in the case @xmath4 is owned by some other principal .",
    "we use names starting with a lowercase letter ( sometimes with subscripts ) to indicate role names .",
    "a role denotes a set of principals ( the principals that populate it , i.e. , the members of the role ) .",
    "to indicate which principals populate a role , @xmath2  allows the owning principal to issue four kind of _ policy statements _ :    * _ simple member _ : @xmath6 + with this statement @xmath0 asserts that @xmath3 is a member of @xmath4 . *",
    "_ simple inclusion _ : @xmath7 + with this statement @xmath0 asserts that @xmath4 includes ( all members of ) @xmath8 .",
    "this represents a delegation from @xmath0 to @xmath1 , as @xmath1 may add principals to become members of the role @xmath4 by issuing statements defining ( and extending ) @xmath8 . * _ linking inclusion _ : @xmath9 + we call @xmath10 a _ linked role_. with this statement @xmath0 asserts that @xmath4 includes @xmath11 for every @xmath1 that is a member of @xmath12 .",
    "this represents a delegation from @xmath0 to all the members of the role @xmath12 . *",
    "_ intersection inclusion _ : @xmath13 + we call @xmath14 an _ intersection_. with this statement @xmath0 asserts that @xmath4 includes every principal who is a member of both @xmath15 and @xmath16 .",
    "this represents partial delegations from @xmath0 to @xmath17 and to @xmath18 .    for any statement @xmath19",
    ", @xmath4 is called the _ head _ and @xmath20",
    "is called the _ body _ of the statement .",
    "we write @xmath21 .",
    "the set of statements having head @xmath4 is called the _ definition _ of @xmath4 .",
    "the definition of @xmath2given here is a slightly simplified ( yet expressively equivalent ) version of the one given in  @xcite .",
    "a _ policy state _ ( _ state _ for short , indicated by @xmath22 ) is a set of policy statements . given a state @xmath22 , we define the following : @xmath23 is the set of principals in @xmath22 , @xmath24is the set of role names in @xmath22 , and @xmath25 .",
    "to express constraints , we need one last definition :    _ positive roles expressions _ are defined by the following grammar :    * sets of principals are positive role expressions , * roles are positive role expressions , * union and intersections of positive role expressions are positive role expressions .",
    "e.g. , @xmath4 , @xmath26 and @xmath27 .",
    "positive role expressions , and are denoted by greek letters , @xmath28 , and @xmath29 . a positive role expression containing no roles ( but only sets of principals ) is called _",
    "static_.      the semantics of a policy state is defined by translating it into a logic program .",
    "the _ semantic program _",
    ", @xmath30 , of a state @xmath22 , is a prolog program has one ternary predicate @xmath31 .",
    "intuitively , @xmath32 means that @xmath3 is a member of the role @xmath4 .",
    "[ def : sp ] given a state @xmath22 , the _ semantic program _",
    "@xmath30 for it is the logic program defined as follows : ( here symbols that start with `` @xmath33 '' represent logical variables )    * for each @xmath34 add to @xmath30 the clause + @xmath35 * for each @xmath36 , add to @xmath30 the clause + @xmath37 * for each @xmath38 add to @xmath30 the clause + @xmath39 * for each @xmath40 add to @xmath30 the clause + @xmath41    we can now define the semantics of a role in a state .    given a state @xmath22 , the semantics of a role @xmath4 is defined in terms of atoms entailed by the semantic program :    * @xmath42\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace } ) } } } } = \\{z | { \\ensuremath{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace})}}\\xspace } \\models m(a , r , z)\\}$ ]    we extend this semantics to positive role expressions in the natural way as follows : @xmath43\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace } ) } } } } & = & \\{d_1,\\ldots , d_n\\ } \\\\",
    "{ \\ensuremath{[\\![\\phi_1 \\cup \\phi_2]\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace } ) } } } } & = & { \\ensuremath{[\\![\\phi_1]\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace } ) } } } } \\cup { \\ensuremath{[\\![\\phi_2]\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace } ) } } } } \\\\ { \\ensuremath{[\\![\\phi_1 \\cap \\phi_2]\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace } ) } } } } & = & { \\ensuremath{[\\![\\phi_1]\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace } ) } } } } \\cap { \\ensuremath{[\\![\\phi_2]\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace})}}}}\\end{aligned}\\ ] ]",
    "consider a state @xmath22 , which might change in time .",
    "we are interested in defining a _ constraint _ , which intuitively is a _ query _ that is intended to hold throughout the state changes .",
    "to this end , we focus on the class of constraints already considered for the purposes of security analysis in  @xcite .",
    "these constraints express set containment .",
    "a _ constraint _ is an expression of the form @xmath44 , in which @xmath45 is a principal called the _ owner _ of the constraint , and @xmath46  and @xmath47  are positive role expressions .",
    "the following definition clarifies that @xmath48 represents set containment .",
    "let @xmath49 be a state and @xmath50 be the constraint @xmath44 , we say that    * @xmath49 _ satisfies _ @xmath51 ( @xmath52 iff @xmath53\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace } ) } } } } \\subseteq { \\ensuremath{[\\![{\\ensuremath{\\varrho}}]\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace})}}}}$ ]    ( @xmath54 _ violates _",
    "@xmath55  otherwise )    constraints of this form can capture many important and intuitive requirements .",
    "* consider @xmath56 .",
    "this constraint captures a safety requirement that bob must not become a member of @xmath4 . * the constraint @xmath57 captures the availability requirement that alice must be authorized for @xmath4 . *",
    "the constraint @xmath58 captures the mutual exclusivity requirement that no one must be authorized for both @xmath59manager and @xmath60controller .",
    "[ cols= \" < , > \" , ]      + hence the thesis .",
    "theorem [ thm : main ] also shows that , as long as the changes to @xmath22 satisfy ( i ) and ( ii ) , we do not have to recompute the set @xmath61 or the support @xmath62 .",
    "technically , this is due to the fact that changes satisfying ( i ) and ( ii ) do not affect @xmath62 ( by lemma [ lem : sprop ] , @xmath62 is still a support of @xmath47 ) , and can only reduce the set @xmath61 ( by lemma [ lem : gprop ] ) . when statements defining roles in @xmath61 are issued , ( i ) is violated , and when statements defining roles in @xmath62 are revoked , ( ii ) is violated . at these times , the constraint must be checked and the sets @xmath61 and @xmath62 must be recomputed .",
    "the theorem indicates how a system for monitoring constraints should be deployed : the first step ( mentioned above ) is to check that @xmath22satisfies @xmath63 . while doing this , we can build an appropriate @xmath62 .",
    "secondly , we have to build @xmath61 .",
    "thirdly , we need to put in place _ monitoring _ of the roles in @xmath62 and in @xmath61 such that each time a statement defining a role in @xmath61 ( resp .",
    "@xmath62 ) is added to ( resp .  deleted from ) @xmath22 , the constraint owner is warned . when the constraint owner receives a warning he has to ( a ) check whether the constraint still holds , and ( b ) recompute @xmath61 and @xmath62 .    * returning to example [ ex : hazmat ] , to monitor @xmath64",
    ", we must monitor revocation of definitions of roles in some @xmath22-support of each member of @xmath65\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace})}}$ ] for @xmath66.@xmath67 .",
    "in this example , @xmath68 is a @xmath22-support of each such member for @xmath66.@xmath67 .",
    "we must also monitor additions to @xmath69 , as discussed in example  [ ex : gamma ] .",
    "if new statements are added defining other roles , no action has to be taken . similarly , if statement ( 10 ) , , were removed , no action would be necessary because @xmath70.@xmath71is not in @xmath62 .",
    "* consider now example [ exa : support ] ( ii ) , together with the query @xmath72 . to apply theorem [ thm : main ]",
    ", we have to choose one support of @xmath73 for @xmath4 ( the two candidate support are @xmath74 and @xmath75 ) and monitor the roles in it .",
    "suppose we choose @xmath76 .",
    "suppose we now remove the statement @xmath77 .",
    "this does not yield to a violation of the constraint , but we do have to recompute @xmath62 , which now becomes @xmath75 . * finally , it is also instructive to see that a change in @xmath61 might require recomputing @xmath62 , even if it does not entail a violation of the constraint .",
    "let @xmath49 be the following set of statements : @xmath78 together with the constraint @xmath79 .",
    "this constraint is satisfied and to monitor its evolution we have to monitor the roles in @xmath80 and @xmath81 . now",
    "if we add the statement @xmath82 then the constraint owner is warned that a change in @xmath61 has occurred .",
    "the constraint owner can check that the constraint is still satisfied in @xmath83 ; however @xmath62 has to be recomputed to take into account that it should be a @xmath84-support of @xmath73 too .",
    "the new @xmath62 is @xmath85 .",
    "we have defined the _ @xmath22-support _",
    "@xmath62 to be a set of roles .",
    "alternatively , we could have defined @xmath62 to be a set of _",
    "[ def : altsupport ] let @xmath4 be a role , @xmath3 be a principal , @xmath49 be a set of statements and and @xmath86 be a set of credentials    * we say that @xmath62 is a _",
    "@xmath22-support of _ @xmath3 _ for _ @xmath4 if @xmath87\\!]_{\\mathit{sp(\\sigma)}}}}$ ] . * for @xmath88",
    ", we say that @xmath62 is a _",
    "@xmath22-support of _ @xmath89 _ for _ @xmath4 if @xmath87\\!]_{\\mathit{sp(\\sigma)}}}}$ ] for every @xmath90 . *",
    "we say that @xmath62 is a _",
    "@xmath22-support for _",
    "@xmath4 if and only if it is a @xmath49-support of every @xmath87\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace})}}}}$ ] .",
    "monitoring constraint using this definition requires more machinery than using definition [ def : support ] , but it could yield to a more efficient implementation . with this definition one",
    "monitors the _",
    "credentials _ and not the _ roles _ which might affect the right hand side of the constraint . therefore , to apply this definition",
    "one needs a mechanism for monitoring every single credential of @xmath62 ( which might be difficult ) .",
    "[ thm : altmain ] assume that @xmath49 satisfies the constraint @xmath44 .",
    "let @xmath62 be a @xmath49-support of @xmath53\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace})}}}}$ ] for @xmath91 ( according to definition [ def : altsupport ] ) , and let @xmath92 be a ( possibly multistep ) change from @xmath49 to @xmath84 . if    1 .",
    "@xmath93 , and 2 .",
    "@xmath94    then @xmath95 satisfies @xmath44 as well .",
    "the advantage of definition [ def : altsupport ] , is that the hypothesis of theorem [ thm : altmain ] hold more often than those of theorem [ thm : main ] . in other words , using definition [ def : altsupport ] one has to check whether the query still holds and to recalculate @xmath61 and @xmath62 less often than with definition [ def : support ] .",
    "the previous section showed how principals in a trust management system can monitor integrity constraints by monitoring changes in the definitions of certain roles .",
    "this section considers the problem of monitoring integrity constraints when not all principals in the system agree to assist in monitoring their roles .",
    "the idea is to make the assumption that the owners of a certain set of roles are trusted to monitor new statements added to their definitions .",
    "we call these the growth - trusted roles and denote them by @xmath96 .",
    "similarly , the owners of a set of shrink - trusted roles , denoted @xmath97 , are trusted to monitor statements removed from their definitions .",
    "the owners of these roles are trusted to test whether changes made to untrusted roles could violate the constraint and , if so , to signal that potential violation .",
    "we call the pair @xmath98 a _ role monitor _ because it indicates the roles that can be monitored with respect to growth and shrinkage .",
    "[ def : reachable ] in the presence of a role monitor @xmath99 , we say that @xmath84 is @xmath100-reachable from @xmath49 if @xmath84 can be obtained from @xmath22without adding any statements defining roles in @xmath96or removing any statements defining roles in @xmath97 .",
    "that is to say , @xmath101 and @xmath102 .",
    "the problem we address is to monitor whether the system ever enters a state @xmath22from which some reachable @xmath84 violates @xmath63 .",
    "this problem is closely related to the security analysis problem  @xcite , which also is defined in terms of a role monitor @xmath98 , although in that context it is called a restriction rule . in security analysis ,",
    "the definitions of roles in @xmath96are assumed not to grow and those of roles in @xmath97 , not to shrink ; the security analysis problem is to determine whether other changes to the policy state could cause a constraint to become violated .",
    "in @xcite it was shown that this problem is decidable ( @xmath103 ) for @xmath2 over the class of constraints we consider here , and that it is polynomial for an important subclass of those constraints .",
    "what has not been shown before , and what we show in this section , is how to identify subsets of @xmath96and @xmath97that need to be monitored so that security analysis can be used to maintain integrity constraints .    in the rest of this section ,",
    "we introduce alternative semantics that can be used to answer questions about policy states that are reachable through changes to the definitions of untrusted roles .",
    "we then formalize sets of roles that must be monitored and show that monitoring these roles is sufficient .",
    "finally , we provide a method for monitoring integrity constraints when not all principals in the system are trusted to assist the process .",
    "we now recall two non - standard semantics for a policy state @xmath22and role monitor @xmath100 .",
    "these were introduced  @xcite for computing the lower and upper bounds on role memberships under the assumption that the definition of roles in @xmath96do not grow and the definition of roles in @xmath97do not shrink .",
    "we first recall the lower - bound program for a state @xmath22and a restriction @xmath100 ; this program enables one to compute the lower - bounds of every role .",
    "[ def : lb ] given @xmath22and @xmath100 , the _ lower - bound program _ for them , @xmath104 , is constructed as follows :    * for each @xmath105 in @xmath106 , add + @xmath107(a , r , d ) * for each @xmath108 in @xmath109 , add + @xmath110 * for each @xmath111 in @xmath109 , add + @xmath112 * for each @xmath113 in @xmath109 , add + @xmath114 .",
    "we now recall the upper - bound program for a state @xmath22and a role monitor @xmath100 .",
    "this program enables one to simulate the upper - bound of any role .",
    "[ def : ub ] given @xmath22and @xmath115 , their upper - bound program , @xmath116 , is constructed as follows .",
    "( @xmath117 is a special principal symbol not occurring in @xmath22 , @xmath100 , or any query @xmath55 . )    * add @xmath118 * for each @xmath119 , add + @xmath120 * for each @xmath105 in @xmath22 , add + @xmath121 * for each @xmath108 in @xmath22 , add + @xmath122 * for each @xmath111 in @xmath22 , add + @xmath123 * for each @xmath113 in @xmath22 , add + @xmath124    the rules @xmath125 to @xmath126 follow from the meanings of the four types of statements and are similar to the semantic program construction in definition  [ def : sp ] .",
    "the rule @xmath127 means that for any role @xmath4 not in @xmath96 , the upper - bound of @xmath4 contains every principal .",
    "the rule @xmath128 means that for any role name @xmath129 , the upper - bound of @xmath130 contains every principal .",
    "this is so because @xmath117 does not appear in @xmath131 .",
    "the rule @xmath128 is needed because given @xmath132 , where @xmath133 and @xmath134 , we should ensure that the upper - bound of @xmath4 contains every principal .",
    "we define : @xmath135\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } & = & \\{z \\",
    "| \\ { \\ensuremath{\\mathit{ub}}\\xspace}({\\ensuremath{{\\cal p}}\\xspace } ) \\models m(a , r , z)\\}\\\\ { \\ensuremath{[\\![a.r]\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace } ) } } } & = & \\{z \\",
    "| \\ { \\ensuremath{\\mathit{lb}}\\xspace}({\\ensuremath{{\\cal p}}\\xspace } ) \\models m(a , r , z)\\}\\end{aligned}\\ ] ] and by definition we have that    [ rem : semantics ]    * if @xmath136 then @xmath42\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace } ) } } } = \\emptyset$ ] . *",
    "if @xmath137 then @xmath42\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } = { \\ensuremath{\\sf principals({\\ensuremath{{\\cal p}}\\xspace})}\\xspace}{\\ensuremath{\\:\\cup\\:}}\\ { \\top \\}$ ] .",
    "the next theorem gives the link between the two new semantics and the problem of checking that a constraint is satisfied in all reachable @xmath84 .",
    "[ thm : strongsemantics ] let @xmath100  be a role monitor , @xmath22be a state , and @xmath63 be a containment constraint .    *",
    "if @xmath53\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } \\subseteq { \\ensuremath{[\\![{\\ensuremath{\\varrho}}]\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] then @xmath138 for each @xmath84 reachable from @xmath22 , * if either @xmath139 or @xmath91 is _ static _",
    "( i.e. , it is a set of principals ) then @xmath138 for each @xmath84 reachable from @xmath22implies that @xmath53\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } \\subseteq    { \\ensuremath{[\\![{\\ensuremath{\\varrho}}]\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] then @xmath138 for each @xmath84 reachable from @xmath22implies that @xmath53\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } \\subseteq { \\ensuremath{[\\![{\\ensuremath{\\varrho}}]\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] . ] .",
    "we now proceed as in the previous section , by identifying the roles we have to monitor .      in the light of theorem [ thm : strongsemantics ] , given a state @xmath22 , a role monitor @xmath100 , and a role @xmath4 , we want to isolate a set @xmath140 of roles we have to monitor , as they might affect the _ growth _ of @xmath141\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace})}$ ] .",
    "one might think that when some roles are untrusted , we need only restrict @xmath142 to the @xmath131-roles ( or to check that @xmath143 ) . the following example shows that this is not adequate . consider the constraint @xmath79 , where @xmath4 is defined by @xmath144 @xmath4 depends on @xmath145 , @xmath146 and @xmath147 ( which are in @xmath142 ) , and ,",
    "if we used the method of the previous section , we would have to monitor all three of them .",
    "we now make two observations about monitoring when it is not possible to monitor all three roles .",
    "first , if @xmath147 is not in @xmath96 , we can not monitor it .",
    "this implies that there is no point in monitoring @xmath146 either , as it directly depends on @xmath147 .",
    "second if @xmath146 is not in @xmath96 , there is no point in monitoring it nor in monitoring @xmath147 ( which can only influence @xmath4 via @xmath146 ) .    to cope with this",
    "we now define the @xmath22-core of @xmath96 , which intuitively contains those role of @xmath96  which additionally do not fully depend on an untrusted role .",
    "let @xmath22be a state and @xmath96  be a set of roles .",
    "the _ @xmath22-core of _ @xmath96",
    ", @xmath148 , is the maximal subset of @xmath96such that    * if @xmath36 , and @xmath149 , then @xmath150 * if @xmath38 , and @xmath151 , then @xmath150 .",
    "* if @xmath38 , and @xmath152\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] such that @xmath153 , then @xmath150 .",
    "* if @xmath154 , and for every @xmath155 , @xmath156 , then @xmath157 .",
    "the following proposition is proved in the appendix .",
    "[ pro : noncore ] let @xmath22be a set of statements and @xmath96  be a set of roles .    *",
    "if @xmath158 , then @xmath42\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } = { \\ensuremath{\\sf principals({\\ensuremath{{\\cal p}}\\xspace})}\\xspace}{\\ensuremath{\\:\\cup\\:}}\\{\\top \\}$ ] .",
    "we now construct the set of roles that must be monitored for new definitions to detect growth in a role s membership .",
    "[ def : gpgr ] let @xmath159 be a role in @xmath148 , @xmath100  be a role monitor , and @xmath22be a state ; @xmath160 is the least set satisfying the following :    * if @xmath161 , @xmath162 . *",
    "if @xmath163 , and @xmath164 , then @xmath165 .",
    "* if @xmath163 and @xmath166 , then @xmath167 and @xmath168 for all @xmath169\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] * if @xmath163 and @xmath170 , then , for each @xmath171 $ ] if @xmath172 , @xmath173 .",
    "it is easy to prove by a simple induction on the steps in the iterative construction of @xmath174 that @xmath175    we now have the counterpart of lemma [ lem : gprop ] .",
    "[ lem : gpropsafety ] assume @xmath176\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] .",
    "let @xmath99 be a role monitor , @xmath177 , where @xmath178 , then    1 .",
    "@xmath42\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } }   = { \\ensuremath{[\\![a.r]\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace}')}}}$ ] , and 2 .",
    "@xmath179 .",
    "moreover , if @xmath84 is obtained from @xmath22by ( a ) adding zero or more statements whose head is not in @xmath180 , and ( b ) removing zero or more statements , then    1 .",
    "@xmath42\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } \\supseteq { \\ensuremath{[\\![a.r]\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace}')}}}$ ] , and 2 .",
    "@xmath181 .    _ proof ( sketch ) . _",
    "the result follows by using reasoning similar to that used for proving lemma [ lem : gprop ] .      to handle the right hand side of the constraints we simply have to generalize lemma [ lem : sprop ] in the obvious way by taking into account the presence of the role monitor .",
    "the proof of this lemma is also identical to that of lemma [ lem : sprop ]    [ lem : spropsafety ] let @xmath98 be a role monitor , @xmath4 be a role , @xmath3 be a principal , @xmath49 be a state and @xmath62 be a @xmath22-support of @xmath3 for @xmath4 _ such that @xmath182_. then    1 .",
    "@xmath87\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ]    moreover , if @xmath84 is obtained from @xmath22by ( a ) removing zero or more statements whose head is not in @xmath62 , and ( b ) adding zero or more statements , then    1 .",
    "@xmath62 is a @xmath84-support for @xmath4 , and therefore 2 .",
    "@xmath87\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace}')}}}$ ] .",
    "recall that by remark [ rem : semantics ] , if @xmath136 then we have that @xmath42\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace } ) } } } = \\emptyset$ ] .",
    "consequently , it is easy to show that if @xmath87\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] , then there exists a @xmath22-support of @xmath3 for @xmath4 consisting of roles that are in @xmath183 .      we can now prove the result we were aiming at .",
    "differently from the case in which all roles were trusted , we now want to check that @xmath63 holds in any @xmath100-reachable state @xmath84 .",
    "the additional problem here is we can not rely on the cooperation of the roles that are not in @xmath131 ( resp .",
    "@xmath183 ) in monitoring the constraint and telling the constraint owner when a statement defining a role in @xmath61 is added ( resp .",
    "a statement defining a role in @xmath62 is removed ) . because of this we refer to two `` pessimistic '' semantics , @xmath53\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] and @xmath184\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] , and we check if @xmath53\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } \\subseteq { \\ensuremath{[\\![{\\ensuremath{\\varrho}}]\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] .",
    "if this does not hold , then , by theorem [ thm : strongsemantics ] the chance is high that in some reachable @xmath84 the constraint is violated . if @xmath53\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } \\subseteq { \\ensuremath{[\\![{\\ensuremath{\\varrho}}]\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] does hold , then we can apply the following :    [ thm : mainsafety ] let @xmath98 be a role monitor .",
    "assume that @xmath53\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } \\subseteq { \\ensuremath{[\\![{\\ensuremath{\\varrho}}]\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] .",
    "let @xmath62 be a @xmath49-support of @xmath53\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] for @xmath91 such that @xmath185 , and let @xmath186 be a ( possibly multistep ) change from @xmath49 to @xmath84 . if    1 .",
    "@xmath187 , and 2 .",
    "@xmath188    then @xmath53\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ' ) } } } \\subseteq { \\ensuremath{[\\![{\\ensuremath{\\varrho}}]\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace}')}}}$ ] . + _",
    "proof_. take any @xmath189\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace}')}}}$ ] , by lemma [ lem : gpropsafety ] , @xmath189\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] . by assumption , @xmath190\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] , and by lemma [ lem : spropsafety ] , @xmath190\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace}')}}}$ ] .",
    "hence the thesis .    because of theorem  [ thm : mainsafety ] , in the presence of untrusted roles we can deploy a monitoring procedure very similar to that described after theorem [ thm : main ] .",
    "first we check that @xmath53\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } \\subseteq { \\ensuremath{[\\![{\\ensuremath{\\varrho}}]\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] holds  nor @xmath47  is static , it is possible that @xmath53\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace } ' ) } } } } \\subseteq { \\ensuremath{[\\![{\\ensuremath{\\varrho}}]\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace}')}}}}$ ] for all @xmath84 reachable from @xmath22 .",
    "however , in general , for the class of constraints we consider , determining this is * pspace*-hard  @xcite , i.e. , intractable .",
    "thus , our technique makes an efficient conservative approximation for the more general constraints we consider . ] . while doing this , we compute a @xmath22-support @xmath62 of @xmath53\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] for @xmath91this time a @xmath62 such that @xmath182 .",
    "second , we have to build @xmath191 .",
    "third , we monitor the roles in @xmath62 and in @xmath191 so that each time a statement defining a role in @xmath191 ( resp .",
    "@xmath62 ) is added to ( resp .  deleted from ) @xmath49 , the constraint owner is warned .",
    "when the constraint owner receives a warning , he has to ( a ) check whether @xmath53\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } \\subseteq { \\ensuremath{[\\![{\\ensuremath{\\varrho}}]\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace})}}}$ ] still holds , and ( b ) recompute @xmath191 and @xmath62 .",
    "reconsider again example [ ex : hazmat ] .",
    "suppose that @xmath192 is ( the only role ) not in @xmath131 , then we have that @xmath193",
    ". therefore + @xmath194 + nonetheless , if @xmath195 we have that @xmath196\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace})}}}\\\\ \\subseteq & { \\ensuremath{[\\![{\\ensuremath{\\mathit atf}\\xspace}.{\\ensuremath{\\mathit hazmatdb}\\xspace}]\\!]_{\\emph{lb}({\\ensuremath{{\\cal p}}\\xspace } ) } } } \\end{array}\\ ] ] so by theorem [ thm : strongsemantics ] we know that the constraint @xmath197 is satisfied in all reachable @xmath84 . by theorem [ thm : mainsafety ] , if the two roles @xmath198.@xmath199 , and @xmath66.@xmath200 , prompt a warning when a statement defining one of them is added and the role @xmath66.@xmath67gives a warning when one of its statement is removed , then the constraint needs to be re - checked only when a warning is given . in that case , we also have to recompute @xmath62 and @xmath201 .",
    "theorem [ thm : mainsafety ] guarantees that no matter which changes are made to @xmath49 , until a warning is given , we still have that every reachablealso changes the reachability relation , i.e. , the set of reachable @xmath84s . ]",
    "@xmath84 satisfies the constraint .",
    "in database theory , an integrity constraint is a query that must remain _ true _ after the database has been updated .",
    "originally , integrity constraints were introduces to prevent incorrect updates and to check the database for integrity .",
    "nevertheless , integrity constraints have later been used for a number of purposes , ranging from query optimization to view updating .",
    "we refer to @xcite for illustrative examples of the uses of integrity constraints in deductive databases .    in section  [ sec :",
    "preliminaries ] , we listed several papers presenting various trust management systems .",
    "none of these incorporates a notion of integrity constrains .",
    "the work in trust management that is most closely related is  @xcite . as we discussed at the beginning of section  [ sec : safety ]",
    ", that work is complimentary to ours .",
    "it studies the problem of determining , given a state @xmath22 , a role monitor @xmath100 , and a constraint @xmath202 , whether there is a reachable state in which @xmath202 is violated .",
    "by contrast , we analyze the problem of which roles must have their definitions monitored to detect when such a @xmath22is entered .",
    "we introduce the use , monitoring , and enforcement of integrity constraints in trust management - style authorization systems .",
    "we consider the portions of the policy state that must be monitored to detect violations of integrity constraints .",
    "we also address the extra difficulty that not all participants in a trust management system can be trusted to assist in such monitoring , and show how many integrity constraints can be monitored in a conservative manner so that trusted participants detect and report if the system enters a policy state from which evolution in unmonitored portions of the policy could lead to a constraint violation .",
    "we thank pieter hartel and ha manh tran for their precious help and the anonymous referees for their comments .",
    "10    k.  r. apt . .",
    "prentice hall , 1997 .",
    "m.  blaze , j.  feigenbaum , j.  ioannidis , and a.  keromytis .",
    "the keynote trust - management system , version 2 .",
    "ietf rfc 2704 ,",
    "september 1999 .",
    "m.  blaze , j.  feigenbaum , j.  ioannidis , and a.  keromytis .",
    "the role of trust management in distributed systems security . in j.",
    "vitek and c.  jensen , editors , _ secure internet programming : security issues for mobile and distributed objects _ , volume 1603 of _ lncs _ , pages 185210 .",
    "springer - verlag , 1999 .",
    "m.  blaze , j.  feigenbaum , and j.  lacy .",
    "decentralized trust management . in ieee",
    "computer  society press , editor , _ proc .",
    "1996 ieee symposium on security and privacy _ , pages 164173 , 1996 .",
    "d.  clarke , j - e .",
    "elien , c.  ellison , m.  fredette , a.  morcos , and r.  rivest .",
    "certificate chain discovery in spki / sdsi .",
    ", 9(4):285322 , 2001 .",
    "s.  k. das . .",
    "addison - wesley , 1992 .    c.  ellison , b.  frantz , b.  lampson , r.  rivest , b.  thomas , and t.  ylonen .",
    "certificate theory .",
    "ietf rfc 2693 ,",
    "september 1999 .",
    "s.  etalle and w.  h. winsborough .",
    "integrity constraints in trust management  extended abstract . in g - j .",
    "ahn , editor , _ proc .",
    "10th acm symp . on access control models and technologies ( sacmat ) _",
    ", page to appear .",
    "acm press , 2005 .",
    "p.  godfrey , j.  grant , j.  gryz , and j.  minker .",
    "integrity constraints : semantics and applications . in j.",
    "chomicki and g.  saake , editors , _ logics for databases and information systems _ , pages 265306 .",
    "kluwer academic , 1998 .",
    "c.  gunter and t.  jim .",
    "policy - directed certificate retrieval . , 30(15):16091640 , september 2000 .",
    "t.  jim . : a trust management system with certified evaluation . in",
    "_ proceedings of the 2001 ieee symposium on security and privacy _ , pages 106115 .",
    "ieee computer society press , may 2001 .",
    "n.  li , j.  mitchell , and w.  winsborough . design of a role - based trust - management framework . in _ proc . of the ieee symposium on research in security and privacy _ , pages 114130 .",
    "ieee computer society , technical committee on security and privacy , ieee computer society press , 2002 .",
    "n.  li , j.  mitchell , and w.  winsborough . beyond proof of compliance",
    ": security analysis in trust management .",
    ", 2004 . to appear .",
    "n.  li and j.  c. mitchell .",
    "datalog with constraints : a foundation for trust management languages . in v.",
    "dahl and p.  wadler , editors , _",
    "5th international symposium on practical aspects of declarative languages ( padl03 ) _ , volume 2562 of _ lncs _ , pages 5873 .",
    "springer - verlag , 2003 .",
    "n.  li , w.  winsborough , and j.  mitchell .",
    "distributed credential chain discovery in trust management .",
    ", 11(1):3586 , 2003 .",
    "ninghui li , benjamin  n. grosof , and joan feigenbaum . : a logic - based approach to distributed authorization . , 6(1):128171 , february 2003 .",
    "r.  rivest and b.  lampson .",
    " a simple distributed security infrastructure , october 1996 .",
    "available at http://theory.lcs.mit.edu/@xmath203rivest/sdsi11.html .",
    "r.  sandhu , e.  coyne , h.  feinstein , and c.  youman .",
    "role - based access control models . , 29(2):3847 , february 1996 .",
    "s.  weeks .",
    "understanding trust management systems . in _ proceedings of 2001 ieee symposium on security and privacy _",
    ", pages 94105 .",
    "ieee computer society press , 2001 .",
    "* lemma  [ lem : gprop ] * let @xmath177 , where @xmath204 , then    1 .",
    "@xmath42\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace } ) } } } }   = { \\ensuremath{[\\![a.r]\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace}')}}}}$ ] , and 2 .",
    "@xmath205 .",
    "moreover , if @xmath84 is obtained from @xmath22by ( a ) adding zero or more statements whose head is not in @xmath206 , and ( b ) removing zero or more statements , then    1 .",
    "@xmath42\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace } ) } } } } \\supseteq { \\ensuremath{[\\![a.r]\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace}')}}}}$ ] , and 2 .   @xmath207 .    _",
    "proof_.    \\(a ) let @xmath208 , and @xmath209 . first , summarize some logic - programming notation : we denote by @xmath210 the herbrand base of @xmath211 ( and @xmath212 ) , consisting of the set of all ground ( variable - free ) atoms .",
    "@xmath213 denotes the set of all ground instances of clauses in @xmath211 .",
    "the usual @xmath214 operator is defined as follows : let @xmath215 , then @xmath216 . as usual , we define @xmath217 , and @xmath218 . by well - known results ( see e.g. , @xcite ) , since @xmath211 contains no function symbols , for some @xmath219 we have that @xmath220 now we define the lp - counterpart of @xmath142 :    @xmath221 and the complement @xmath222 .",
    "furthermore , let @xmath223 and @xmath224 be two sets of ground atoms such that @xmath225 , and @xmath226 . by the monotonicity of @xmath214",
    ", we have that @xmath227 we now want to show that @xmath228 we proceed by contradiction and assume that there exists @xmath229 such that @xmath230 since @xmath231 , there exists a ground instance @xmath232 of a clause @xmath233 such that @xmath234 . since @xmath235 , @xmath233 . therefore @xmath236 .",
    "we now want to show that @xmath237 since @xmath238 , this will demonstrate that @xmath239 , and therefore that @xmath240 , contradicting ( [ eq : absurd ] ) .",
    "we distinguish two cases according to the kind of statement from which @xmath241 is generated .",
    "case 1 : @xmath241 is the lp - translation of a simple inclusion or intersection inclusion ( not a linking inclusion )",
    ". then @xmath242 by definition [ def : gp ] .",
    "case 2 : @xmath241 is the lp - translation of a linking inclusion ( linked role ) .",
    "then @xmath232 has the form @xmath243 . by definition [ def : gp ] , @xmath244 .",
    "since @xmath238 , and @xmath245 , we have that @xmath246 . since @xmath226 , then @xmath247\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace})}}}}$ ] . therefore , again by definition [ def : gp ] , @xmath248 , proving ( [ eq : nextstep ] ) ( which in turn contradicts [ eq : absurd ] ) .",
    "now that we have proven ( [ eq : tpprimeingamma ] ) , since for each @xmath31 we have that @xmath249 , from ( [ eq : tpprimebigger ] ) , ( [ eq : tpprimeingamma ] ) and a straightforward inductive reasoning it follows that , for each @xmath31 , @xmath250 since the least model of @xmath212 and @xmath211 is the least fixpoint of these continuous operators on a finite lattice , this demonstrates that @xmath251 . since by definition @xmath252 it follows that @xmath42\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace } ) } } } } = { \\ensuremath{[\\![a.r]\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace}')}}}}$ ] . hence the thesis .",
    "\\(b ) since @xmath204 , @xmath253 is not reachable from @xmath4 .",
    "so removing @xmath254does not alter the reachability from @xmath4 .",
    "\\(c ) and ( d ) first notice that , by construction , @xmath255 now , suppose that we have a chain @xmath256 , where each @xmath257 is obtained from @xmath258 by either adding a statement whose head is not in @xmath206 or removing a statement .",
    "we now show by induction on @xmath155 that for each @xmath259 $ ] : @xmath42\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace } ) } } } } \\supseteq { \\ensuremath{[\\![a.r]\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace}_{i})}}}}$ ] and @xmath260 , which imply the thesis .",
    "the base case is trivial , as @xmath261 , for the inductive case we have two subcases : case 1 . if @xmath257 is obtained from @xmath258 by adding a statement @xmath254such that @xmath262 , then by the inductive hypothesis @xmath263 , and , by statements ( a ) and ( b ) we have that @xmath42\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace}_{i } ) } } } } = { \\ensuremath{[\\![a.r]\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace}_{i+1})}}}}$ ] and @xmath264 , and the result follows from the inductive hypothesis .",
    "if @xmath257 is obtained from @xmath258 by removing a statement , then the result follows from the monotonicity of @xmath42\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace}_{i})}}}}$ ] ( [ eq : monotonicity ] ) , and ( [ eq : gdiminishes ] ) .",
    "* proposition  [ pro : noncore ] * let @xmath22be a set of statements and @xmath96  be a set of roles .",
    "if @xmath158 , then @xmath42\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } = { \\ensuremath{\\sf principals({\\ensuremath{{\\cal p}}\\xspace})}\\xspace}{\\ensuremath{\\:\\cup\\:}}\\{\\top \\}$ ] .",
    "+ _ proof_.    consider the following closure operator on sets of roles ( @xmath265 ) .",
    "let @xmath266 be a set of roles .",
    "@xmath267\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } \\mbox { such that } b.r_2 \\in \\delta \\ } \\\\ & & { \\ensuremath{\\:\\cup\\ : } } & \\ { a.r \\ | \\ a.r",
    "{ \\ensuremath{\\longleftarrow}}b_1.r_1 { \\ensuremath{\\:\\cap\\:}}\\ldots b_n.r_n \\in { \\ensuremath{{\\cal p}}\\xspace}\\mbox { and } \\forall i \\in [ 1,n]\\ b_i.r_i \\in \\delta \\ } \\end{array}\\ ] ] it is easy to see that @xmath148 is  by construction  exactly the least fixpoint of @xmath268 containing @xmath269 , the complement of @xmath131 .",
    "now , define @xmath270 , and @xmath271 .",
    "since @xmath268 is monotonically increasing , and since @xmath272 is finite , we have that , for some @xmath219 .",
    "@xmath273 now , by definition , for every @xmath274 , @xmath42\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } = { \\ensuremath{\\sf principals({\\ensuremath{{\\cal p}}\\xspace})}\\xspace}{\\ensuremath{\\:\\cup\\:}}\\{\\top \\}$ ] . + by the definition of @xmath268 , it is straightforward to check that this implies that for every @xmath275 , @xmath42\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } = { \\ensuremath{\\sf principals({\\ensuremath{{\\cal p}}\\xspace})}\\xspace}{\\ensuremath{\\:\\cup\\:}}\\{\\top \\}$ ] .",
    "+ by iterating this reasoning it is straightforward to check that this implies that for every @xmath276 , @xmath42\\!]_{\\emph{ub}({\\ensuremath{{\\cal p}}\\xspace } ) } } } = { \\ensuremath{\\sf principals({\\ensuremath{{\\cal p}}\\xspace})}\\xspace}{\\ensuremath{\\:\\cup\\:}}\\{\\top \\}$ ] .",
    "+ the thesis follows from ( [ eq : fixpoint ] ) .",
    "we now show how one can compute the support in bottom - up way .",
    "we do this by defining a semantics : @xmath277 for which it holds that if @xmath278 then @xmath62 is a minimal @xmath49-support of @xmath3 in @xmath4 .",
    "the construction is parametric wrt the partial order used to define minimality .",
    "xx = xx = xx = xx = xx = xx = xx = xx = xx = * init phase * + for each role @xmath4 , @xmath286 + * repeat * + for each role @xmath4 , do @xmath287 + for each @xmath288 do + if @xmath289 then + _ remove from @xmath290(a.r ) all triples subsumed by @xmath291 _",
    "+ @xmath292 + if @xmath293 then + for each @xmath294 do + if @xmath295 is not subsumed by any triple in @xmath296 then + _ remove from @xmath290(a.r ) all triples subsumed by @xmath297 _",
    "+ @xmath298 + if @xmath299 then + for each @xmath300 do + for each @xmath301 do + if @xmath302 is not subsumed by any triple in @xmath296 then + _ remove from @xmath290(a.r ) all triples subsumed by @xmath302 _",
    "+ @xmath303 + if @xmath304 then + for each @xmath305 do + if , for some @xmath306 , @xmath307 @xmath308 then + if @xmath302 is not subsumed by any triple in @xmath296 then + _ remove from @xmath290(a.r ) all triples subsumed by @xmath302 _ + @xmath303 + * until * for each role @xmath4 , @xmath309          _ proof . _ ( @xmath313 ) assume @xmath312 is a minimal set of roles such that @xmath314\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace}|_{\\sigma_0})}}}}$ ] .",
    "we show by induction on the construction of @xmath315 that for all @xmath316 and for each @xmath317 , if @xmath318 , then at some stage in the execution of the algorithm , for some @xmath155 and @xmath62 , @xmath319 with @xmath320 .",
    "the desired result then follows by taking @xmath321 , by using the fact , shown below in the second part of the proof , that @xmath322 implies @xmath323 , and by using the minimality of @xmath312",
    ".      _ step .",
    "_ we assume the hypothesis holds for @xmath316 and show that it holds for @xmath325 .",
    "we proceed by case analysis of the clause used to add @xmath326 to @xmath327 .",
    "we show here only the case of linking inclusion ; the other cases are similar .",
    "_ case : _ @xmath328 . by definition of @xmath329",
    ", there exists @xmath1 such that @xmath330 .",
    "so by induction hypothesis , there exist @xmath331 such that @xmath332 , @xmath333 , and @xmath301 by some stage in the execution .",
    "consider the first such stage . in the following iteration , either @xmath334 already contains a triple that subsumes @xmath335 , or else this triple is added .",
    "in either case , at the end of the iteration , @xmath334 contains a triple that subsumes @xmath336 , for all @xmath337 .",
    "( note @xmath338 . )",
    "( @xmath339 ) we show by induction on @xmath155 that if @xmath340 , then @xmath341 .",
    "this direction of the theorem then follows because , by the other direction , all minimal @xmath22-support are in @xmath296 , and the algorithm removes all entries that are subsumed by other entries .",
    "_ we assume the hypothesis holds for all @xmath347 and show that it holds for @xmath348 .",
    "we proceed by case analysis of the statement used to add @xmath349 to @xmath296 .",
    "we show here only the case of linking inclusion ; the other cases are similar .",
    "@xmath111 . in this case",
    "there are @xmath350 , @xmath306 , @xmath351 , @xmath307 , and @xmath1 such that @xmath352 , @xmath301 , @xmath353 , and @xmath354 . by induction hypothesis , @xmath355 and @xmath356 . by monotonicity of @xmath329  in @xmath211",
    ", it follows that @xmath357 .",
    "consider the first @xmath316 such that @xmath358 . because @xmath359 is in @xmath360",
    ", it follows that @xmath361 , the latter being a subset of @xmath362 .",
    "it must be acknowledged that the algorithm given here may construct a value for @xmath290  whose size is combinatorial in the size of @xmath22 . in practice",
    ", a variant of this algorithm should be used in which a small constant number of entries in @xmath296 are stored for each @xmath314\\!]_{\\mathit{sp({\\ensuremath{{\\cal p}}\\xspace})}}}}$ ] ."
  ],
  "abstract_text": [
    "<S> we introduce the use , monitoring , and enforcement of integrity constraints in trust management - style authorization systems . </S>",
    "<S> we consider what portions of the policy state must be monitored to detect violations of integrity constraints . </S>",
    "<S> then we address the fact that not all participants in a trust management system can be trusted to assist in such monitoring , and show how many integrity constraints can be monitored in a conservative manner so that trusted participants detect and report if the system enters a policy state from which evolution in unmonitored portions of the policy could lead to a constraint violation . </S>"
  ]
}