{
  "article_text": [
    "the sld resolution used in prolog may not be complete or efficient for programs in the presence of recursion .",
    "for example , for a recursive definition of the transitive closure of a relation , a query may never terminate under sld resolution if the program contains left - recursion or the graph represented by the relation contains cycles even if no rule is left - recursive . for a natural definition of the fibonacci function",
    ", the evaluation of a subgoal under sld resolution spawns an exponential number of subgoals , many of which are variants .",
    "the lack of completeness and efficiency in evaluating recursive programs is problematic : novice programmers may lose confidence in writing declarative programs that terminate and real programmers have to reformulate a natural and declarative formulation to avoid these problems , resulting in cluttered programs .",
    "tabling @xcite is a technique that can get rid of infinite loops for bounded - term - size programs and redundant computations in the execution of recursive programs .",
    "the main idea of tabling is to memorize the answers to subgoals and use the answers to resolve their variant descendents .",
    "tabling helps narrow the gap between declarative and procedural readings of logic programs .",
    "it not only is useful in the problem domains that motivated its birth , such as program analysis @xcite , parsing @xcite , deductive databases @xcite , and theorem proving @xcite , but also has been found essential in several other problem domains such as model checking @xcite and logic - based probabilistic learning@xcite .",
    "this idea of caching previously calculated solutions , called _ memoization _ , was first used to speed up the evaluation of functions @xcite .",
    "oldt @xcite is the first resolution mechanism that accommodates the idea of tabling in logic programming and xsb is the first prolog system that successfully supports tabling @xcite .",
    "tabling has become a practical technique thanks to the availability of large amounts of memory in computers .",
    "it has become an embedded feature in a number of other logic programming systems such as b - prolog @xcite , mercury @xcite , tals @xcite , and yap @xcite .",
    "oldt , and slg @xcite alike , is non - linear in the sense that the state of a consumer must be preserved before execution backtracks to its producer .",
    "this non - linearity requires freezing stack segments @xcite or copying stack segments into a different area @xcite before backtracking takes place .",
    "linear tabling is an alternative tabling scheme @xcite .",
    "the main idea of linear tabling is to use iterative computation of looping subgoals rather than suspension and resumption of them as is done in oldt to compute fixpoints .",
    "this basic idea dates back to the et * algorithm @xcite .",
    "the dra method proposed in @xcite is based on the same idea but employs different strategies for handling looping subgoals and clauses . in linear tabling , a cluster of inter - dependent subgoals as represented by a _ top - most looping subgoal _",
    "is iteratively evaluated until no subgoal in it can produce any new answers .",
    "linear tabling is relatively easy to implement on top of a stack machine thanks to its linearity , and is more space efficient than oldt since the states of subgoals need not be preserved .",
    "linear tabling is a framework from which different methods can be derived based on the strategies used in handling looping subgoals .",
    "one decision concerns when answers are consumed and returned .",
    "the _ lazy _ strategy postpones the consumption of answers until no answers can be produced .",
    "it is in general space efficient because of its locality and is well suited for all - solution search programs . the _ eager _",
    "strategy , in contrast , prefers answer consumption and return over production .",
    "it is well suited for programs with cuts .",
    "these two strategies have been compared in slg - wam as two scheduling strategies called _ local _ and _ single - stack _ @xcite .",
    "this paper gives a comprehensive analysis of these two strategies and compares their performance experimentally .",
    "linear tabling relies on iterative evaluation of top - most looping subgoals to compute fixpoints .",
    "naive re - evaluation of all looping subgoals may be computationally expensive .",
    "_ semi - naive optimization _ is an effective technique used in bottom - up evaluation of datalog programs @xcite .",
    "it avoids redundant joins by ensuring that the join of the subgoals in the body of each rule must involve at least one new answer produced in the previous round .",
    "the impact of semi - naive optimization on top - down evaluation had been unknown before @xcite . in this paper",
    ", we also propose to introduce semi - naive optimization into linear tabling .",
    "we have made efforts to properly tailor semi - naive optimization to linear tabling . in our semi - naive optimization ,",
    "answers for each tabled subgoal are divided into three regions as in bottom - up evaluation , but answers are consumed sequentially until exhaustion not incrementally as in bottom - up evaluation so that answers produced in a round are consumed in the same round .",
    "we have found that incremental consumption of answers does not fit linear tabling since it may require more iterations to reach fixpoints .",
    "moreover , consuming answers incrementally may cause redundant consumption of answers .",
    "we further propose a technique called _ early promotion _ of answers to reduce redundant consumption of answers .",
    "our benchmarking shows that this technique gives significant speed - ups to some programs .",
    "an efficient tabling system has been implemented in b - prolog , in which the lazy strategy is employed by default but the eager strategy can be used through declarations for subgoals that are in the scopes of cuts or are not required to return all the answers .",
    "our tabling system not only consumes considerably less stack space than xsb for some programs but also compares favorably well in speed with xsb .",
    "the theoretical framework of linear tabling is given in @xcite .",
    "the main objective of this paper is to propose evaluation strategies and their optimizations for linear tabling .",
    "the remainder of the paper is structured as follows : in the next section we define the terms used in this paper . in section 3",
    "we give the linear tabling framework and the two answer consumption strategies . in section 4",
    "we introduce semi - naive optimization into linear tabling and prove its completeness . in section 5",
    "we describe the implementation of our tabling system and also show how to implement semi - naive optimization . in section 6",
    "we compare the tabling strategies experimentally , evaluate the effectiveness of semi - naive optimization , and also compare the performance of b - prolog with xsb . in section 7",
    "we survey the related work and in section 8 we conclude the paper .",
    "in this section we give the definitions of the terms to make this paper as much self - contained as possible .",
    "the reader is referred to @xcite for a description of sld resolution . in this paper",
    ", we always assume the top - down strategy for selecting clauses and the left - to - right computation rule .",
    "let @xmath0 be a program .",
    "tabled predicates in @xmath0 are explicitly declared and all the other predicates are assumed to be non - tabled .",
    "a subgoal of a tabled predicate is called a _ tabled subgoal_. tabled predicates are transformed into a form that facilitates execution : each rule ends with a dummy subgoal named @xmath1 where @xmath2 is the head , and each tabled predicate contains a dummy ending rule whose body contains only one subgoal named _",
    "check_completion(h)_. for example , given the definition of the transitive closure of a relation ,    ....     : -table p/2 .",
    "p(x , y):-p(x , z),e(z , y ) .",
    "p(x , y):-e(x , y ) .",
    "....    the transformed predicate is as follows :    ....     p(x , y):-p(x , z),e(z , y),memo(p(x , y ) ) .",
    "p(x , y):-e(x , y),memo(p(x , y ) ) .",
    "p(x , y):-check_completion(p(x , y ) ) .            ....    a table is used to record subgoals and their answers . for each subgoal and its variants",
    ", there is an entry in the table that stores the state of the subgoal ( e.g. , complete or not ) and an answer table for holding the answers generated for the subgoal .",
    "initially , the answer table is empty .",
    "let @xmath3 and @xmath4 be two terms with no shared variables .",
    "the term @xmath3 _ subsumes _ @xmath4 if there exists a substitution @xmath5 such that @xmath6=@xmath4 .",
    "the two terms @xmath3 and @xmath4 are called _ variants _ if they subsume each other .",
    "let @xmath7 be a goal .",
    "the first subgoal @xmath8 is called the _ selected subgoal _ of the goal . @xmath9 is _ derived _ from @xmath10 by using a tabled _ answer _",
    "@xmath11 if there exists a unifier @xmath5 such that @xmath12 and @xmath13 .",
    "@xmath9 is _ derived _ from @xmath10 by using a rule `` @xmath14 '' if @xmath15 and @xmath16 .",
    "@xmath8 is said to be the _ parent _ of @xmath17 , ... , and @xmath18 .",
    "the relation _ ancestor _ is defined recursively from the parent relation .",
    "a tabled subgoal that occurs first in the construction of an sld tree is called a _ pioneer _ , and all subsequent variants are called _ followers _ of the pioneer .",
    "let @xmath19 be a given goal , and @xmath20 be a _ derivation _ where each goal is derived from the goal immediately preceding it .",
    "let @xmath21 be a sub - sequence of the derivation where @xmath22 and @xmath23 .",
    "the sub - sequence forms a _ loop _ if @xmath24 and @xmath25 are variants . the subgoals @xmath24 and @xmath25 are called _ looping subgoals_. in particular , @xmath24 is called the _ pioneer looping subgoal _ and @xmath25 is called the _ follower looping subgoal _ of the loop .    notice that the pioneer and follower looping subgoals are not required to have the ancestor - descendent relationship , and thus a derivation that contains two variant subgoals may not be a _ real _ loop .",
    "consider , for example , the goal `` @xmath26 '' where @xmath27 is defined by facts .",
    "the derivation `` @xmath26 '' @xmath28 @xmath29 is treated as a loop although the selected subgoal @xmath29 in the second goal is not a descendant of @xmath30 .",
    "a subgoal @xmath24 is said to be _ dependent _ on another subgoal @xmath25 if @xmath25 occurs in a derived goal from @xmath24 , i.e. , @xmath31 .",
    "two subgoals are said to be _",
    "inter - dependent _ if they are dependent on each other .",
    "inter - dependent subgoals constitute a _ cluster _ , which is called a _ strongly connected component _",
    "elsewhere @xcite .",
    "a subgoal in a cluster is called the _ top - most _ subgoal of the cluster if none of its ancestors is included in the cluster .",
    "unless a cluster contains only a single subgoal , its top - most subgoal must also be a looping subgoal .",
    "for example , the subgoals at the nodes in the sld tree in figure [ fig : loops ] constitute a cluster and the subgoal p at node 1 is the top - most looping subgoal of the cluster .",
    "linear tabling takes a transformed program and a goal , and tries to find a path in the sld tree that leads to an empty goal .",
    "the primitive @xmath32 is executed when a tabled subgoal @xmath24 is encountered .",
    "just as in sld resolution , linear tabling explores the sld tree in a depth - first fashion , taking special actions when _",
    "table_start(a ) _ , _ memo(a ) _ , and _",
    "check_completion(a ) _ are encountered .",
    "backtracking is done in exactly the same way as in sld resolution . when the current path reaches a dead end , meaning that no action can be taken on the selected subgoal , execution backtracks to the latest previous goal in the path and continues with an alternative branch .",
    "when execution backtracks to the top - most looping subgoal of a cluster , however , we can not fail the subgoal even after all the alternative clauses have been tried .",
    "in general , the evaluation of a top - most looping subgoal must be iterated until its fixpoint is reached .",
    "we call each iteration of a top - most looping subgoal a _ round_.    various linear tabling methods can be devised based on the framework . a linear tabling method",
    "comprises strategies used in the three primitives : _",
    "table_start(a ) _ , _ memo(a ) _ , and _ check_completion(a)_. in linear tabling , a pioneer subgoal has two roles : one is to produce answers into the table and the other is to return answers to its parent through its variables .",
    "different strategies can be used to produce and return answers .",
    "the _ lazy strategy _ gives priority to answer production and the _ eager strategy _ prefers answer consumption over production . in the following",
    "we define the three primitives in both strategies .",
    "the lazy strategy postpones the consumption of answers until no answers can be produced . in concrete , for top - most looping subgoals no answer is returned until they are complete , and for other pioneer subgoals answers are consumed only after all the rules have been tried .",
    "this primitive is executed when a tabled subgoal @xmath24 is encountered . the subgoal @xmath24 is registered into the table if it is not registered yet . if @xmath24 s state is _ complete _ meaning that @xmath24 has been completely evaluated before , then @xmath24 is resolved by using the answers in the table .    if @xmath24 is a pioneer , meaning that it is encountered for the first time in the current path , then different actions are taken depending on @xmath24 s state .",
    "if @xmath24 s state is _ evaluated _ meaning that @xmath24 has occurred before in a different path during the current round , then it is resolved by using answers .",
    "otherwise , if @xmath24 has never occurred before during the current round , it is resolved by using rules . in this way",
    ", a pioneer subgoal needs to be evaluated only once in each round .",
    "if @xmath24 is a follower of some ancestor @xmath33 , meaning that a loop has been encountered , must be an ancestor of @xmath24 under the lazy strategy .",
    "] then it is resolved by using the answers in the table .",
    "after the answers are exhausted , @xmath24 fails . failing @xmath24 is unsafe in general since it may have not returned all of its possible answers .",
    "for this reason , the top - most looping subgoal of the cluster of @xmath24 needs be iterated until no new answer can be produced .",
    "this primitive is executed when an answer is found for the tabled subgoal @xmath24 .",
    "if the answer @xmath24 is already in the table , then just fail ; otherwise fail after the answer is added into the table .",
    "the failure of _ memo _ postpones the return of answers until all rules have been tried .",
    "this primitive is executed when the subgoal @xmath24 is being resolved by using rules and the dummy ending rule is being tried .",
    "if @xmath24 has never occurred in a loop , then @xmath24 s state is set to _ complete _ and @xmath24 is failed after all the answers are consumed .    if @xmath24 is a top - most looping subgoal , we check if any new answers are produced during the last iteration of the cluster under @xmath24 .",
    "if so , @xmath24 is re - evaluated by calling @xmath32 after all the dependent subgoals s states are initialized .",
    "otherwise , if no new answer is produced , @xmath24 is resolved by using answers after its state and all its dependent subgoals states are set to _",
    "complete_. notice that a top - most looping subgoal does not return any answers until it is complete .",
    "if @xmath24 is a looping subgoal but not a top - most one , @xmath24 will be resolved by using answers after its state is set to _",
    "evaluated_. notice that @xmath24 s state can not be set to _ complete _ since @xmath24 is contained in a loop whose top - most subgoal has not been completely evaluated . for example , in figure [ fig : loops ] , q reaches its fixpoint only after the top - most looping subgoal p reaches its fixpoint .",
    "as described in the definition of @xmath32 , an _ evaluated _ subgoal is never evaluated using rules again in the same round .",
    "this optimization is called _ subgoal optimization _ in @xcite .",
    "if evaluating a subgoal produces some new answers then the top - most looping subgoal will be re - evaluated and so will the subgoal ; and if evaluating a subgoal does not produce any new answer , then evaluating it again in the same round would not produce any new answers either .",
    "therefore , the subgoal optimization is safe .",
    "consider the following program , where p/2 is tabled , and the query p(a , y0 ) .    ....",
    "p(x , y):-p(x , z),e(z , y),memo(p(x , y ) ) .",
    "( p1 )     p(x , y):-e(x , y),memo(p(x , y ) ) .",
    "( p2 )            p(x , y):-check_completion(p(x , y ) ) .",
    "( p3 )       e(a , b ) .",
    "e(b , c ) .",
    "....    the following shows the steps that lead to the production of the first answer :    aa = aaa = aaa = aaa = aaa = aaa = aaa 1 : + @xmath36apply p1 + 2 : , e(z1,y0),memo(p(a , y0 ) ) +   + 1 : + @xmath36 apply p2 + 3 : , memo(p(a , y0 ) ) + @xmath36 apply e(a , b ) + 4 : + @xmath36 add answer p(a , b )    after the answer p(a , b ) is added into the table , memo(p(a , b ) ) fails .",
    "the failure forces execution to backtrack to p(a , y0 ) .    aa = aaa = aaa = aaa = aaa = aaa = aaa 1 : + @xmath36 apply p3 + 5 :    since p(a , y0 ) is a top - most looping subgoal which has not been completely evaluated yet , check_completion(p(a , y0 ) )",
    "does not consume the answer in the table but instead starts re - evaluation of the subgoal .",
    "aa = aaa = aaa = aaa = aaa = aaa = aaa 1 : + @xmath36apply p1 + 6 : , e(z1,y0),memo(p(a , y0 ) ) + @xmath36use answer p(a , b ) + 7 : , memo(p(a , y0 ) ) + @xmath36apply e(b , c ) + 8 :    when the follower p(a , z1 ) is encountered this time , it consumes the answer p(a , b ) .",
    "the current path leads to the second answer p(a , c ) . on backtracking ,",
    "the goal numbered 6 becomes the current goal .",
    "aa = aaa = aaa = aaa = aaa = aaa = aaa 6 : , e(z1,y0),memo(p(a , y0 ) ) + @xmath36use answer p(a , c ) + 9 : , memo(p(a , y0 ) )    goal 9 fails .",
    "execution backtracks to the top goal and tries the clause p3 on it .",
    "aa = aaa = aaa = aaa = aaa = aaa = aaa 1 : + @xmath36 apply p3 + 10 :    since the new answer p(a , c ) is produced in the last round , the top - most looping subgoal p(a , y0 ) needs to be evaluated again .",
    "the next round produces no new answer and thus the subgoal s state is set to _ complete_. after that the top - most subgoal returns the answers p(a , b ) and p(a , c ) .      under the lazy strategy ,",
    "answers are not returned immediately after they are produced but are returned via the table after all clauses are tried .",
    "no answer is returned for a top - most looping subgoal until the subgoal is complete .",
    "all loops are guaranteed to be real : for any loop @xmath37 where @xmath24 and @xmath25 are variants , @xmath24 must be an ancestor of @xmath25 . because each cluster of inter - dependent subgoals is completely evaluated before any answers are returned to outside of the cluster , the lazy strategy has good locality and is thus suited for finding all solutions .",
    "for example , when the subgoal @xmath29 is encountered in the goal `` p(x),p(y ) '' , the subtree for p(x ) must have been explored completely and thus needs not be saved for evaluating p(y ) .",
    "the cut operator can not be handled efficiently under the lazy strategy .",
    "the goal `` @xmath38 '' produces all the answers for @xmath30 even though only one is needed .",
    "the eager strategy prefers answer consumption and return over production . for a pioneer ,",
    "answers are used first and rules are used only after all available answers are exhausted , and moreover a new answer is returned to its parent immediately after it is added into the table .",
    "the following describes how the three primitives behave under the eager strategy .      just as in the lazy strategy , @xmath24 is registered if it is not registered yet .",
    "@xmath24 is resolved by using the tabled answers if @xmath24 is complete or @xmath24 is a follower of some former variant subgoal .",
    "if @xmath24 is a pioneer , being encountered for the first time in the current round , it is resolved by using answers first , and then rules after all existing answers are exhausted .",
    "if the answer @xmath24 is already in the table , then this primitive fails ; otherwise , this primitive succeeds after adding the answer @xmath24 into the table .",
    "notice that @xmath24 is returned immediately after it is added into the table .",
    "if @xmath24 is not new , then it must have been returned before .",
    "if @xmath24 is a top - most looping subgoal , just as in the lazy strategy , we check whether any new answers are produced during the last iteration of @xmath24 .",
    "if so , @xmath24 is evaluated again by calling @xmath32 .",
    "otherwise , if no new answer is produced , this primitive fails after @xmath24 s and all its dependent subgoals states are set to _",
    "complete_. if @xmath24 is a looping subgoal but not a top - most one , this primitive fails after @xmath24 s state is set to _",
    "evaluated_. an _ evaluated _ subgoal is never evaluated using rules again in the same round .",
    "notice that unlike under the lazy strategy , the primitive @xmath35 never returns any answers under the eager strategy . as described above , all the available answers must have been returned by @xmath32 and @xmath34 by the time @xmath35 is executed .",
    "because of the need to re - evaluate a top - most looping subgoal , redundant solutions may be observed for a query .",
    "consider , for example , the following program and the query `` p(x),p(y ) '' .    ....",
    "p(1):-memo(p(1 ) ) .",
    "( r1 )     p(2):-memo(p(2 ) ) .",
    "( r2 )            p(x):-check_completion(p(x ) ) .",
    "( r3 ) ....    the following derivation steps lead to the return of the first solution ( 1,1 ) for ( x , y ) .",
    "aa = aaa = aaa = aaa = aaa = aaa = aaa 1 : , p(y ) + @xmath36 use r1 + 2 : , p(y ) + @xmath36 add answer p(1 ) + 3 : + @xmath36 loop found , use answer p(1 ) +    when the subgoal p(y ) is encountered , it is treated as a follower and is resolved using the tabled answer p(1 ) .",
    "after that the first solution ( 1,1 ) is returned to the top query . when execution backtracks to p(y ) , it fails since it is a follower and no more answer is available in the table .",
    "execution backtracks to p(x ) , which produces and adds the second answer p(2 ) into the table .",
    "aa = aaa = aaa = aaa = aaa = aaa = aaa 1 : , p(y ) + @xmath36 use r2 + 4 : , p(y ) + @xmath36 add answer p(2 ) + 5 : + @xmath36 use answer p(1 ) +    when p(y ) is encountered this time , there are two answers p(1 ) and p(2 ) in the table .",
    "so the next two solutions returned are ( 2,1 ) and ( 2,2 ) . when execution backtracks to goal 1 , the dummy ending rule is applied .",
    "aa = aaa = aaa = aaa = aaa = aaa = aaa 1 : , p(y ) + @xmath36 use r3 + 6 : , p(y ) +    since new answers are added into the table during this round , the subgoal p(x ) needs to be evaluated again , first using answers and then using rules .",
    "the second round produces no answer but returns the four solutions ( 1,1 ) , ( 1,2 ) , ( 2,1 ) and ( 2,2 ) among which only ( 1,2 ) has not been observed before .",
    "since answers are returned eagerly , a pioneer and a follower may not have an ancestor - descendant relationship .",
    "because of the existence of this kind of _ fake _ loops and the necessity of iterating the evaluation of top - most looping subgoals , redundant solutions may be observed . in the previous example , the solutions ( 1,1 ) , ( 2,1 ) and ( 2,2 ) are each observed twice .",
    "provided that the top - most looping subgoal p(x ) did not return the answer p(1 ) again in the second round , the solution ( 1,2 ) would have been lost .",
    "the eager strategy is more suited than the lazy strategy for single - solution search . for certain applications such as planning",
    "it is unreasonable to find all answers either because the set is infinite or because only one answer is needed . for these applications",
    "the eager strategy is more effective than the lazy one .",
    "cuts are handled more efficiently under the eager strategy .",
    "the basic linear tabling framework described in the previous section does not distinguish between new and old answers .",
    "the problem with this naive method is that it redundantly joins answers of subgoals that have been joined in early rounds .",
    "semi - naive optimization @xcite reduces the redundancy by ensuring that at least one new answer is involved in the join of the answers for each rule . in this section ,",
    "we introduce semi - naive optimization into linear tabling and identify sufficient conditions for it to be complete .",
    "we also propose a technique called _ early answer promotion _ to further avoid redundant consumption of answers .",
    "this optimization works with both the lazy and eager strategies .      to make semi - naive optimization possible ,",
    "we divide the answer table for each tabled subgoal into three regions :        the names of the regions indicate the rounds during which the answers in the regions are produced : _ old _ means that the answers were produced before the previous round , _ previous _ the answers produced during the previous round , and _ current _ the answers produced in the current round .",
    "the answers stored in _",
    "previous _ and _ current _ are said to be _",
    "new_. before each round is started , answers are promoted accordingly : _ previous _ answers become _ old _ and _ current _ answers become _",
    "previous_.    in our optimization , answers are consumed _",
    "sequentially_. for a subgoal , either all the available answers or only new answers are consumed .",
    "this is unlike in bottom - up evaluation where answers are consumed _ incrementally _ , i.e. , answers produced in a round are not consumed until the next round .",
    "as will be discussed later , incremental consumption of answers as is done in bottom - up evaluation does avoid certain redundant joins but does not fit linear tabling since it may require more rounds to reach fixpoints .",
    "a predicate @xmath27 _ calls _ a predicate @xmath39 if : ( 1 ) if @xmath39 occurs in the body of at least one rule in the definition of @xmath27 ( @xmath27 calls @xmath39 _ directly _ ) ; or ( 2 ) @xmath39 does not occur in the body of any rule in the definition of @xmath27 but there exists a predicate in the body of a rule in the definition of @xmath27 that calls @xmath39 ( @xmath27 calls @xmath39 _ indirectly _ ) .",
    "the calling relationship constitutes a graph called a _ call graph_.    for a given program , we find a level mapping from the predicate symbols in the program to the set of integers to represent the _ call graph _ of the program .",
    "let @xmath40 be a level mapping .",
    "we extend the notation to assume that @xmath41 for any subgoal @xmath42 of arity @xmath43 .    for a given program ,",
    "a level mapping @xmath40 represents the _ call graph _ if : for each rule `` @xmath2@xmath44@xmath45@xmath46 '' in the program , @xmath47 iff the predicate of @xmath48 does not call ( either directly or indirectly ) the predicate of @xmath2 , and @xmath49 iff the predicates of @xmath2 and @xmath48 call each other .",
    "the level mapping as defined divides predicates in a program into several strata .",
    "the predicate at each stratum depends only on those on the lower strata .",
    "the level mapping is an abstract representation of the dependence relationship of the subgoals that may occur in execution .",
    "if two subgoals @xmath24 and @xmath25 occur in a loop , then it is guaranteed that @xmath50 .",
    "let `` @xmath2@xmath44@xmath45@xmath51 '' be a rule in a program and @xmath40 be the level mapping that represents the call graph of the program .",
    "@xmath52 is called the _ last depending subgoal _ of the rule if @xmath53 and @xmath47 for @xmath54 .",
    "the last depending subgoal @xmath52 is the last subgoal in the body that may depend on the head to become complete .",
    "thus , when the rule is re - executed on a subgoal , all the subgoals to the right of @xmath52 that have occurred before must already be complete .",
    "let `` @xmath2@xmath44@xmath45@xmath46 '' be a rule in a program and @xmath40 be a level mapping that represents the call graph of the program .",
    "if there is no depending subgoal in the body , i.e. , @xmath47 for @xmath55 , then the rule is called a _",
    "base rule_.      let `` @xmath2@xmath44@xmath45@xmath51 '' be a rule where @xmath52 is the last depending tabled subgoal , and @xmath56 be a subgoal that is being resolved by using the rule in an iteration of a top - most looping subgoal @xmath57 .",
    "for a combination of answers of @xmath8 , @xmath58 , and @xmath59 , if @xmath56 has occurred in an early round and the combination does not contain any new answers , then it is safe to let @xmath52 consume new answers only .    because @xmath52 is the last depending subgoal ,",
    "the subgoals @xmath60 , @xmath58 , and @xmath61 must have been completely evaluated when @xmath56 is re - evaluated .",
    "let @xmath62 and @xmath63 be the _ old _ and _ new _ answers of the subgoal @xmath52 , respectively . for a combination of answers of @xmath8 , @xmath58 , and",
    "@xmath59 , if the combination does not contain new answers then the join of the combination and @xmath62 must have been done and all possible answers for @xmath56 that can result from the join must have been produced during the previous round because the subgoal @xmath56 has been encountered before . therefore only new answers in @xmath63 should be used .",
    "base rules need not be considered in the re - evaluation of any subgoals .",
    "semi - naive optimization would be unsafe if it were applied to new subgoals that have never been encountered before .",
    "the following example illustrates this possibility :    ....     ?",
    "- p(x , y ) .",
    ": -table p/2 .",
    "p(x , y ) : - p(x , z),q(z , y ) .",
    "( c1 )     p(b , c ) : - p(x , y ) .",
    "( c2 )     p(a , b ) .",
    "( c3 )       : -table q/2 .",
    "q(c , d ) : - p(x , y),t(x , y ) .",
    "( c4 )       t(a , b ) .",
    "( c5 ) ....    in the first round of p(x , y ) the answer p(a , b ) is added to the table by c3 , and in the second round the rule c2 produces the answer p(b , c ) by using the answer produced in the first round . in the third round ,",
    "the rule c1 generates a new subgoal q(c , y ) after p(x , z ) consumes p(b , c ) .",
    "if semi - naive optimization were applied to q(c , y ) , then the subgoal p(x , y ) in c4 could consume only the new answer p(b , c ) and the third answer p(b , d ) would be lost .",
    "semi - naive optimization can lower the complexity of evaluation for some programs . consider the following example created by david s. warren :    ....     : -table p/2 .",
    "p(x , y ) : - p(x , z),c(z , a , y ) .",
    "p(x , y ) : - p(x , z),c(z , b , y ) .",
    "p(x , x ) . ....    which detects if a given string represented as facts c@xmath64",
    "( @xmath65,@xmath66a or @xmath66b ) is a sentence of the regular expression @xmath67 . for a string @xmath68 , the query p(0,@xmath43 )",
    "needs @xmath69 rounds to reach the fixpoint . with semi - naive optimization ,",
    "the variants of p(x , z ) in the bodies consume only new answers , and therefore the program takes linear time . without semi - naive optimization , however , the program would take @xmath70 time since the variants of p(x , z ) would consume all existing answers .    in our semi - naive optimization ,",
    "answers produced in the current round are consumed immediately rather than postponed to the next round as in the bottom - up version , and answers are promoted each time a new round is started .",
    "this way of consuming and promoting answers may cause certain redundancy .    consider the conjunction @xmath71",
    ". assume @xmath72 , @xmath73 , and @xmath74 are the sets of answers in the three regions ( respectively , _ old _ , _ previous _ , and _ current _ ) of the subgoal @xmath75 when @xmath75 is encountered in round @xmath76 .",
    "assume also that @xmath0 had been complete before round @xmath76 and @xmath77 is the set of answers .",
    "the join @xmath78 is computed for the conjunction in round @xmath76 .",
    "assume @xmath79 , @xmath80 , and @xmath81 are the sets of answers in the three regions when @xmath75 is encountered in round i+1 . since answers are promoted before round @xmath82 is started , we have :    aa = aaa = aaa = aaa = aaa = aaa = aaa @xmath83 + @xmath84    where @xmath85 denotes the new answers produced for @xmath75 after the conjunction @xmath71 in round @xmath76 . when the conjunction @xmath71 is encountered in round @xmath82 , the following join is computed .",
    "aa = aaa = aaa = aaa = aaa = aaa = aaa @xmath86    notice that the join @xmath87 is computed in both round @xmath76 and @xmath82 .",
    "we could allow last depending subgoals to consume answers incrementally as is done in bottom - up evaluation , but doing so may require more rounds to reach fixpoints .",
    "consider the following example , which is the same as the one shown above but has a different ordering of clauses :    ....     ?",
    "- p(x , y ) .",
    ": -table p/2 .",
    "p(a , b ) .",
    "( c1 )     p(b , c ) : - p(x , y ) .          ( c2 )",
    "p(x , y ) : - p(x , z),q(z , y ) .",
    "( c3 )       : -table q/2 .",
    "q(c , d ) : - p(x , y),t(x , y ) .   ( c4 )",
    "t(a , b ) .",
    "( c5 ) ....    in the first round , c1 produces the answer p(a , b ) .",
    "when c2 is executed , the subgoal in the body can not consume p(a , b ) since it is produced in the current round .",
    "similarly , c3 produces no answer either . in the second round , p(a , b )",
    "is moved to the _ previous _ region , and thus can be consumed .",
    "c2 produces a new answer p(b , c ) .",
    "when c3 is executed , no answer is produced since p(b , c ) can not be consumed . in the third round , p(a , b )",
    "is moved to the _ old _ region , and p(b , c ) is moved to the _ previous _ region .",
    "c3 produces the third answer p(b , d ) .",
    "the fourth round produces no new answer and confirms the completion of the computation .",
    "so in total four rounds are needed to compute the fixpoint .",
    "if answers produced in the current round are consumed in the same round , then only two rounds are needed to reach the fixpoint .      as discussed above",
    ", sequential consumption of answers may cause redundant joins . in this subsection ,",
    "we propose a technique called _ early promotion _ of answers to reduce the redundancy .",
    "let @xmath75 be the first follower that exhausts its answers in the current round",
    ". then all the answers of @xmath75 in the _ current _ region are promoted to the _ previous _ region once being consumed by @xmath75 .",
    "consider again the conjunction @xmath71 where @xmath75 is the first follower that exhausts its answers .",
    "the answers in the current region @xmath74 are promoted to the _ previous _ region after @xmath75 has consumed all its answers in round @xmath76 . by doing so",
    ", the join @xmath87 will not be recomputed in round @xmath82 since @xmath74 must have been promoted to the _ old _ region in round @xmath82 .",
    "consider , for example , the following program :    ....     ?",
    "- p(x , y ) .",
    ": -table p/2 .",
    "p(a , b ) .",
    "( c1 )     p(b , c ) : - p(x , y ) .",
    "( c2 ) ....    before c2 is executed in the first round , p(a , b ) is in the _ current _ region . executing c2",
    "produces the second answer p(b , c ) . since the subgoal p(x , y ) in c2 is the first follower that exhausts its answers in the current round , it is qualified to promote its answers .",
    "so the answers p(a , b ) and p(b , c ) are moved from the _ current _ region to the _ previous _ region immediately after being consumed by p(x , y ) . as a result",
    ", the potential redundant consumption of these answers by p(x , y ) is avoided in the second round since they will all be transferred to the _ old _ region before the second round starts .",
    "early promotion does not lose any answers .",
    "first note that although answers are tabled in three disjoint regions , all tabled answers will be consumed except for some last depending subgoals that would skip the answers in their _ old _ regions ( see theorem 1 ) .",
    "assume , on the contrary , that applying early promotion loses answers .",
    "then there must be a last depending subgoal @xmath52 in a rule `` @xmath2@xmath44@xmath45@xmath51 '' and a tabled answer @xmath24 for @xmath52 such that @xmath24 has been moved to the _ old _ region before being consumed by @xmath52 so that @xmath24 will never be consumed by @xmath52 .",
    "assume @xmath24 is produced in round @xmath76 by a variant of @xmath52 .",
    "we distinguish between the following two cases :    1 .",
    "the last depending subgoal @xmath52 is not selected in round @xmath76 . in round @xmath88 , @xmath52 is selected either because @xmath2 is new or some @xmath89 consumes a new answer . by theorem 1",
    ", @xmath52 will consume all answers in the three regions , including the answer @xmath24 .",
    "otherwise , @xmath24 must be produced by @xmath52 itself or a variant subgoal of @xmath52 that is selected either _ before _ or _ after _",
    "@xmath52 in round @xmath76 .",
    "if @xmath24 is produced by @xmath52 itself or _ before _ @xmath52 is selected , then the answer will be consumed by @xmath52 since promoted answers will remain new by the end of the round . if @xmath24 is produced by a variant _ after _",
    "@xmath52 is selected , then the answer can not be promoted because @xmath52 exhausts its answers _ before _ the variant . in this case , the answer @xmath24 will remain new in the next round and will thus be consumed by @xmath52 .    both of the above two cases contradict our assumption .",
    "the proof then concludes .",
    "changes to the prolog machine atoam @xcite are needed to implement linear tabling . in this section",
    "we describe the changes to the data structures and the instruction set .    to make the paper self - contained , we first give an overview of the atoam architecture .",
    "the atoam uses all the data areas used by the wam .",
    "the _ heap _ stores terms created during execution .",
    "the register h points to the top of the heap .",
    "the _ trail _ stack stores updates that must be undone upon backtracking .",
    "the register t points to the top of the trail stack .",
    "the _ control _",
    "stack stores frames associated with predicate calls .",
    "unlike in the wam where arguments are passed through argument registers , arguments in the atoam are passed through stack frames and only one frame is used for each predicate call .",
    "each time a predicate is invoked by a call , a frame is placed on top of the local stack unless the frame currently at the top can be reused .",
    "frames for different types of predicates have different structures . for standard prolog ,",
    "a frame is either _ determinate _ or _ nondeterminate_. a nondeterminate frame is also called a",
    "_ choice point_. the register ar points to the current frame and the register b points to the latest _",
    "choice point_.    a determinate frame has the following structure :     & pointer to the parent frame + & continuation program pointer + & bottom of the frame + & top of the frame + & local variables +    where btm points to the bottom of the frame , i.e. , the slot for the first argument , and top points to the top of the frame , i.e. , the slot just next to that for the last local variable .",
    "the top register points to the next available slot on the stack .",
    "the btm slot is not in the original version @xcite .",
    "this slot is introduced for supporting garbage collection and co - routining .",
    "the ar register points to the ar slot of the current frame .",
    "arguments and local variables are accessed through offsets with respect to the ar slot .",
    "an argument or a local variable is denoted as y(i ) where i is the offset .",
    "arguments have positive offsets and local variables have negative offsets .",
    "it is the caller s job to place the arguments and fill in the ar , and cp slots .",
    "the callee fills in the btm and top slots and initializes the local variables .",
    "a choice point frame contains , in addition to the slots in a determinate frame , four slots located between the top slot and local variables :     & top of the heap + & top of the trail + & parent choice point +    the cpf slot stores the program pointer to continue with when the current branch fails .",
    "the slot h points to the top of the heap when the frame is allocated . as in the wam ,",
    "a new register , called hb , is used as an alias for b->h .",
    "when a variable is bound , it must be trailed if it is older than b or hb .      a new data area , called _ table area _ , is introduced for memorizing tabled subgoals and their answers .",
    "the _ subgoal table _ is a hash table that stores all the tabled subgoals encountered in execution . for each tabled subgoal and its variants",
    ", there is an entry in the table , which is a record containing the following information :      +   +   +   +   +    the field subgoalcopy points to the copy of the subgoal in the table area . in the copy ,",
    "all variables are numbered . therefore all variants of the subgoal are identical .",
    "the field pioneerar points to the frame of the pioneer , which is needed for implementing cuts .",
    "when the choice point of a tabled subgoal is cut off before the subgoal reaches completion , the field pioneerar will be set to null . when a variant of the subgoal is encountered again after",
    ", the subgoal will be treated as a pioneer .",
    "the field state indicates whether the subgoal is a looping subgoal , whether the answer table has been revised , and whether the subgoal is _ complete _ or _",
    "evaluated_. when execution backtracks to a top - most looping subgoal , if the _ revised _ bit is set , then another round will be started for the subgoal .",
    "a top - most looping subgoal becomes complete if this _ revised _ bit is unset after a round . at that time ,",
    "the subgoal and all of its dependent subgoals will be set to _ complete_. as described in [ sub : evaluated ] , an _ evaluated _ subgoal is never evaluated again using rules in each round .",
    "the topmostloopingsubgoal field points to the entry for the top - most looping subgoal , and the field dependentsubgoals stores the list of subgoals on which this subgoal depends . when a top - most looping subgoal becomes complete , all of its dependent subgoals turn to complete too .",
    "the field answertable points to the answer table for this subgoal , which is also a hash table .",
    "hash tables expand dynamically .",
    "let g be the pointer to the record for a subgoal in the table .",
    "the first answer in the answer table is referenced as ` g->answertable->firstanswer ` and the last answer is referenced as ` g->answertable->lastanswer ` . in the beginning , the answer table is empty and both firstanswer and lastanswer reference a dummy answer .",
    "the frame for a tabled predicate contains the following two slots in addition to those slots stored in a choice point frame :      +    the subgoaltable points to the subgoal table entry , and the currentanswer points to the last answer that has been consumed .",
    "the next answer can be reached from this reference on backtracking . when a frame is created , the slot currentanswer is initialized to be ` g->answertable->firstanswer ` where g is the pointer to the record for the tabled subgoal .",
    "three new instructions , namely table_start , memo , and check_completion , are introduced into the atoam for encoding the three table primitives .",
    "figure [ fig : ins ] shows the compiled code of an example program .    ....",
    "% : -tabled p/2 .",
    "% p(x , y):-p(x , z),e(z , y ) .",
    "% p(x , y):-e(x , y ) .",
    "p/2 : table_start 2,1         fork r2         para_value",
    "y(2 )         para_var y(-13 )         call p/2           % p(x , z )         para_value y(-13 )         para_value y(1 )         call e/2           % e(z , y )         memo    r2 :   fork r3         para_value y(2 )         para_value y(1 )         call e/2           % e(x , y )         memo    r3 :   check_completion p/2 ....    the table_start instruction takes two operands : the arity ( 2 ) and the number of local variables ( 1 ) .",
    "the fork instruction sets the cpf slot to hold the address to backtrack to on failure .",
    "the parameter passing instructions ( para_value and para_var in this example ) pass arguments to the callee s frame .",
    "the memo instruction is executed after an answer has been found .",
    "the check_completion instruction takes the entrance ( p/2 ) as an operand so that the predicate can be re - entered when it needs re - evaluation .      to implement semi - naive optimization",
    ", we add the following two pointers into the record for each tabled subgoal :      +    where the pointer lastoldanswer points to the last answer in the old region and the pointer lastprevanswer points to the last answer in the previous region .",
    "the check_completion instruction resets the pointers for all the tabled subgoals in the current cluster before it starts the next round :    ....     for each subgoal g in the current cluster {         g->lastoldanswer = g->lastprevanswer ;         g->lastprevanswer = g->answertable->lastanswer ;     } ....    the memo instruction is changed so that early promotion of answers is performed if the condition for promotion is met .",
    "let g be the pointer to the tabled subgoal .",
    "if the subgoal has exhausted all its answers in the table and early promotion has never be done before on the subgoal in the same round , then answers in the current region are promoted to the previous region :    ....     g->lastprevanswer = g->answertable->lastanswer ....    the promoted answers will be moved to the old region before the start of the next round .",
    "a bit vector is added into the frame for each tabled predicate to indicate if any new answer has been consumed by any tabled subgoal .",
    "semi - naive optimization can be applied only if no tabled subgoal in the predicate has consumed any new answer .    a new instruction , called last_depending_tabled_call ,",
    "is introduced to encode last depending tabled subgoals . in the example shown in figure [ fig : ins ] , the `` call p/2 '' instruction is changed to `` last_depending_tabled_call p/2 '' to enable semi - naive optimization .",
    "the last_depending_tabled_call instruction has the same behavior as the call instruction , but the callee can check the type of the instruction to see if it is invoked by a last depending tabled subgoal .",
    "let g be the pointer to the current tabled subgoal .",
    "the table_start instruction sets the currentanswer slot of the frame to ` g->lastoldanswer ` so that the subgoal consumes only new answers if : ( 1 ) the parent frame is a tabled frame ; ( 2 ) no bit in the bit vector in the parent frame is set , which means that no tabled subgoal has consumed any new answer ; and ( 3 ) the predicate is invoked by a last_depending_tabled_call instruction .",
    "if any of these condition is not satisfied , the currentanswer slot is set to ` g->answertable->firstanswer ` and all the answers will be consumed by the subgoal .",
    "we empirically compared the two answer consumption strategies and evaluated the effectiveness of semi - naive optimization .",
    "we also compared the performance of b - prolog ( version 6.9 ) with xsb ( version 3.0 ) . a linux machine with 750mhz intel process and 512 gb ram was used in the experiment .",
    "benchmarks from three different sources were used : datalog programs shown in figure [ fig : datalog ] with randomly generated graphs ; the chat benchmark suite @xcite ; and a parser , called _ atr _",
    ", for the japanese language defined by a grammar of over 860 rules @xcite .",
    "this section presents the experimental results and reports the statistics to support the results .",
    "this section also gives experimental results on the warren s example for which slg as implemented in xsb has lower time complexity than linear tabling when semi - naive optimization ceases to be effective .",
    "aa = aaa = aaa = aaa = aaa = aaa = aaa tcl : +   +   + tcr : +   +   + tcn : +   +   + sg : +      table [ tab : strategies ] compares the two answer - consumption strategies in terms of speed and stack space efficiencies .",
    "the difference of these two strategies in terms of cpu time is small on average .",
    "this result implies that for programs with cuts declaring the use of the eager strategy would not cause significant slow - down .",
    "the difference in the usage of stack space is more significant than in cpu time .",
    "this is because , as discussed before , the lazy strategy has better locality than the eager strategy .     &",
    "lazy & eager & lazy & eager + tcl & 1 & 1.02 & 1 & 1.00 + tcr & 1 & 0.96 & 1 & 1.00 + tcn & 1 & 0.90 & 1 & 1.00 + sg & 1 & 0.89 & 1 & 1.02 + cs_o & 1 & 1.17 & 1 & 1.36 + cs_r & 1 & 1.09 & 1 & 1.36 + disj & 1 & 1.06 & 1 & 1.41 + gabriel & 1 & 1.08 & 1 & 1.18 + kalah & 1 & 1.17 & 1 & 2.03 + pg & 1 & 2.28 & 1 & 3.59 + peep & 1 & 0.99 & 1 & 2.88 + read & 1 & 0.85 & 1 & 2.22 + atr & 1 & 1.03 & 1 & 1.06 + @xmath90 & 1 & 1.12 & 1 & 1.62 +      table [ tab : semi ] shows the effectiveness of semi - naive optimization in gaining speed - ups under both strategies . without this optimization ,",
    "the system would consume over 30% more cpu time on average under either strategy .",
    "our experiment also indicates that on average over 95% of the gains in speed are attributed to the _ early promotion _ technique .",
    "& lazy & eager + tcl & 2.00 & 1.89 + tcr & 1.22 & 1.19 + tcn & 1.68 & 1.74 + sg & 1.22 & 1.51 + cs_o & 1.10 & 1.10 + cs_r & 1.09 & 1.10 + disj & 1.52 & 1.46 + gabriel & 1.32 & 1.15 + kalah & 1.52 & 1.41 + pg & 1.21 & 1.05 + peep & 1.09 & 1.11 + read & 1.98 & 1.27 + atr & 1.00 & 1.00 + @xmath90 & 1.38 & 1.31 +      table [ tab : xsb ] compares bp with xsb on time and stack space efficiencies . for xsb ,",
    "the stack space is the total of the maximum amounts of global , local , trail , choice point , and slg completion stack spaces .",
    "the default setting , namely , the slg - wam and the local scheduling strategy , is used .",
    "bp is faster than xsb on the datalog programs and the parser but slower than xsb on the chat benchmark suite ; and bp consumes considerably less stack space than xsb on some of the programs ( _ tcr _ , _ tcn _ , _ sg _ , and _ atr _ ) .",
    "the results must be interpreted with two differences of the two compared systems taken into account : on the one hand , bp is on average more than twice as fast as xsb for standard prolog programs , and on the other hand the trie data structure used in xsb @xcite is far more advanced than hash tables used in bp for managing the table area .",
    "it is unclear to what extent each difference contributes to the overall efficiency .",
    "the yap implementation of slg - wam is up to twice as fast as xsb @xcite on the transitive closure and same - generation benchmarks with both chain and cyclic graphs .",
    "this entails that the bp implementation of linear tabling is comparable in speed with the most sophisticated implementation of slg - wam for the datalog benchmarks .     &",
    "( lazy ) & cpu time & stack space + tcl & 1 & 1.85 & 0.81 + tcr & 1 & 1.46 & 33.41 + tcn & 1 & 1.31 & 32.84 + sg & 1 & 1.47 & 109.12 + cs_o & 1 & 0.37 & 0.57 + cs_r & 1 & 0.35 & 0.73 + disj & 1 & 0.68 & 0.82 + gabriel & 1 & 0.61 & 2.05 + kalah & 1 & 1.00 & 0.58 + pg & 1 & 0.76 & 1.85 + peep & 1 & 0.37 & 2.97 + read & 1 & 0.69 & 11.12 + atr & 1 & 2.26 & 21.24 +    the empirical data on the usage of table space are not reported .",
    "bp constantly consumes less table space than xsb for the benchmarks . in bp , both subgoal and answer tables",
    "are maintained as dynamic hashtables . in xsb , in contrast , tables are maintained as tries @xcite .",
    "the usage of table space is independent of the strategies and optimizations .",
    "both bp and xsb would consume the same amount of table space if the same data structure were employed .",
    "table [ tab : its ] reports the statistics on the maximum ( max its . ) and average ( ave . its . ) numbers of iterations for tabled subgoals to reach their fixpoints .",
    "the column # subgoals shows the number of tabled subgoals . while for some programs , the maximum number of iterations performed is high ( e.g. , the maximum number for _ atr _ is 6 ) , the average numbers are quite low .",
    "the necessity of re - evaluating looping subgoals has been blamed for the low speed of iteration - based tabling systems @xcite .",
    "our new findings indicate that re - evaluation is not a dominant factor for the benchmarks .",
    "this statistics well explain why an implementation of linear tabling could achieve comparable speed performance with slg - wam for the benchmarks .",
    "tcl & 1 & 2 & 2.00 + tcr & 51 & 2 & 1.96 + tcn & 51 & 2 & 1.98 + sg & 153 & 2 & 1.32 + cs_o & 76 & 2 & 1.14 + cs_r & 76 & 2 & 1.16 + disj & 74 & 2 & 1.20 + gabriel & 59 & 2 & 1.20 + kalah & 102 & 3 & 1.24",
    "+ pg & 48 & 2 & 1.13 + peep & 49 & 3 & 1.29 + read & 131 & 5 & 1.34 + atr & 7139 & 6 & 1.81 +      the following is a slightly changed version of the warren s example which disenables semi - naive optimization :    ....     : -table p/2 .",
    "p(x , y ) : - q(x , z),c(z , a , y ) .",
    "p(x , y ) : - q(x , z),c(z , b , y ) .",
    "p(x , x ) .",
    "q(x , y ) : - p(x , y ) . ....    since the last depending subgoals q(x , z ) in p/2 are not tabled , semi - naive optimization can not be applied to p/2 . for a string @xmath68 , the query p(0,@xmath43 )",
    "needs @xmath69 iterations to reach the fixpoint .",
    "since in each iteration the subgoal q(x , z ) is rewritten into p(x , z ) which returns all existing answers , the total time taken is @xmath70 .",
    "in contrast , the program takes only @xmath91 time under slg . for the size n=5000",
    ", it took bp 3.5 seconds to run the program while xsb only 15 milliseconds .",
    "for the original version of the program to which semi - naive optimization is applicable , it took bp only 7 milliseconds .",
    "there are three different tabling schemes , namely oldt and slg @xcite , cat @xcite , and iteration - based tabling including linear tabling @xcite and dra @xcite .",
    "slg @xcite is a formalization based on oldt for computing well - founded semantics for general programs with negation .",
    "the basic idea of using iterative deepening to compute fixpoints dates back to the et * algorithm @xcite .    in slg - wam , a consumer fails after it exhausts all the existing answers and its state is preserved by freezing the stack so that it can be reactivated after new answers are generated .",
    "the cat approach does not freeze the stack but instead copies the stack segments between the consumer and its producer into a separate area so that backtracking can be done normally .",
    "the saved state is reinstalled after a new answer is generated .",
    "chat @xcite is a hybrid approach that combines slg - wam and cat .",
    "linear tabling relies on iterative computation of looping subgoals to compute fixpoints .",
    "linear tabling is probably the easiest scheme to implement since no effort is needed to preserve states of consumers and the garbage collector can be kept untouched for tabling .",
    "linear tabling is also the most space - efficient scheme since no extra space is needed to save states of consumers .",
    "nevertheless , linear tabling without optimization could be computationally more expensive than the other two schemes .",
    "the dra method @xcite is also iteration based , but it identifies looping clauses dynamically and iterates the execution of looping clauses to compute fixpoints . while in linear tabling iteration is performed on only top - most looping subgoals , in dra iteration is performed on every looping subgoal . in et * @xcite , every tabled subgoal is iterated even if it does not occur in a loop .",
    "besides the difference in answer consumption strategies and optimizations , the linear tabling scheme described in this paper differs from the original version @xcite in that followers fail after they exhaust their answers rather than steal their pioneers choice points .",
    "this strategy is originally adopted in the dra method .",
    "the two consumption strategies have been compared in xsb @xcite as two scheduling strategies .",
    "the lazy strategy is called _ local scheduling _ and the eager strategy is called _ single - stack scheduling_. another strategy , called _ batched scheduling _ , is similar to local scheduling but top - most looping subgoals do not have to wait until their clusters become complete to return answers .",
    "their experimental results indicate that local scheduling constantly outperforms the other two strategies on stack space and can perform asymptotically better than the other two strategies on speed .",
    "the superior performance of local scheduling is attributed to the saving of freezing stack segments .",
    "although our experiment confirms the good space performance of the lazy strategy , it gives a counterintuitive result that the eager strategy is as fast as the lazy strategy .",
    "this result implies that the cost of iterative evaluation is considerably smaller than that of freezing stack segments , and for predicates with cuts the eager strategy can be used without significant slow - down . in our tabling system",
    ", different answer consumption strategies can be used for different predicates .",
    "the tabling system described in @xcite also supports mixed strategies .",
    "semi - naive optimization is a fundamental idea for reducing redundancy in bottom - up evaluation of logic database queries @xcite . as far as we know , its impact on top - down evaluation had been unknown before @xcite .",
    "oldt @xcite and slg @xcite do not need this technique since it is not iterative and the underlying delaying mechanism successfully avoids the repetition of any derivation step .",
    "an attempt has been made by guo and gupta @xcite to make incremental consumption of tabled answers possible in dra . in their scheme ,",
    "answers are also divided into three regions but answers are consumed incrementally as in bottom - up evaluation . since no condition is given for the completeness and no experimental result is reported on the impact of the technique , we are unable to give a detailed comparison .",
    "our semi - naive optimization differs from the bottom - up version in two major aspects : firstly , no differentiated rules are used . in the bottom - up version",
    "differentiated rules are used to ensure that at least one new answer is involved in the join of answers for each rule .",
    "consider , for example , the clause :    aa = aaa = aaa = aaa = aaa = aaa = aaa @xmath92    the following two differentiated rules are used in the evaluation instead of the original one :    aa = aaa = aaa = aaa = aaa = aaa = aaa @xmath93 + @xmath94    where @xmath95 denotes the new answers produced in the previous round for p. using differentiated rules in top - down evaluation can cause considerable redundancy , especially when the body of a clause contains non - tabled subgoals .",
    "the second major difference between our semi - naive optimization and the bottom - up version is that answers in our method are consumed sequentially until exhaustion , not incrementally as in bottom - up evaluation .",
    "a tabled subgoal consumes either all available answers or only new answers including answers produced in the current round .",
    "neither incremental consumption nor sequential consumption seems satisfactory .",
    "incremental consumption avoids redundant joins but may require more rounds to reach fixpoints .",
    "in contrast , sequential consumption never need more rounds to reach fixpoints but may cause redundant joins of answers .",
    "the early promotion technique alleviates the problem of sequential consumption . by promoting answers early from the _ current _ region to the _ previous _ region",
    ", we can considerably reduce the redundancy in joins .",
    "semi - naive optimization may lower time complexities in bottom - up evaluation @xcite .",
    "the same result holds to the top - down version as demonstrated by warren s example .",
    "our experimental results show that semi - naive optimization gives an average speed - up of over @xmath96 to linear tabling if answers are promoted early , and almost no speed gain if no answer is promoted early . in linear tabling ,",
    "only looping subgoals need to be iteratively evaluated . for non - looping subgoals ,",
    "no re - evaluation is necessary and thus semi - naive optimization has no effect at all on the performance .",
    "most of the looping subgoals in our chosen benchmarks reach their fixpoints after 2 - 3 iterations . in general , more iterations are needed to reach fixpoints in bottom - up evaluation .",
    "in addition , in bottom - up evaluation , the order of the joins can be optimized and no further joins are necessary once a participating set is known to be empty .",
    "in contrast , in linear tabling joins are done in strictly chronological order . for a conjunction @xmath97 , the join @xmath98 is computed even if no answer is available for @xmath99 . because of all these factors , semi - naive optimization is not as effective in linear tabling as in bottom - up evaluation .    our semi - naive optimization requires the identification of last depending subgoals . for this purpose ,",
    "a level mapping is used to represent the call graph of a given program .",
    "the use of a level mapping to identify optimizable subgoals is analogous to the idea used in the stratification - based methods for evaluating logic programs @xcite . in our level mapping ,",
    "only predicate symbols are considered .",
    "it is expected that more accurate approximations can be achieved if arguments are considered as well .",
    "semi - naive optimization does not solve all the problems of recomputation in linear tabling .",
    "recall the warren s example :    ....     : -table p/2 .",
    "p(x , y ) : - p(x , z),c(z , a , y ) .",
    "p(x , y ) : - p(x , z),c(z , b , y ) .",
    "p(x , x ) .",
    "....    assume there is a very costly non - tabled subgoal preceding p(x , z ) , then the subgoal has to be executed in each iteration even with semi - naive optimization .",
    "this example demonstrates the acuteness of the problem of recomputation because the number of iterations needed to reach the fixpoint is not constant .",
    "one treatment would be to table the subgoal to avoid recomputation , as suggested in @xcite , but tabling extra predicates can cause other problems such as over consumption of table space .",
    "in this paper we have described two answer consumption strategies ( namely , _",
    "lazy _ and _ eager _ strategies ) and semi - naive optimization for linear tabling .",
    "we have compared the two strategies both qualitatively and quantitatively .",
    "our results indicate that , while the lazy strategy has better space efficiency than the eager strategy , the eager strategy is comparable in speed with the lazy strategy .",
    "this result implies that for all - solution search programs the lazy strategy should be adopted and for partial - solution search programs including programs with cuts the eager strategy should be used .",
    "we have tailored semi - naive optimization to linear tabling and have given sufficient conditions for it to be complete .",
    "moreover , we have proposed a technique called _ early answer promotion _ to reduce redundant consumption of answers .",
    "our experimental result indicates that semi - naive optimization gives significant speed - ups to some programs .",
    "linear tabling has several attractive advantages including its simplicity , ease of implementation , and good space efficiency .",
    "early implementations of linear tabling were several times slower than xsb .",
    "this paper has demonstrated for the first time that linear tabling with optimization is as competitive as slg on time efficiency as well for the benchmarks .",
    "semi - naive optimization does not solve all the problems of recomputation in linear tabling .",
    "there are programs for which recomputation can be costly , even leading to higher complexities .",
    "the future work is to identify the patterns of such programs and find methods to deal with them .",
    "the preliminary results of this article appear in acm ppdp03 and ppdp04 .",
    "taisuke sato is supported in part by crest , and yi - dong shen is supported in part by the national natural science foundation of china grants numbered 60673103 and 60421001 .",
    "\\2001 . a simple scheme for implementing tabled logic programming systems based on dynamic reordering of alternatives . in _ proceedings international conference on logic programming ( iclp)_. lncs 2237 , 181195 .            , nielson , h.  r. , sun , h. , buchholtz , m. , hansen , r.  r. , pilegaard , h. , and seidl , h. 2004 .",
    "the succinct solver suite . in _ proc .",
    "tools and algorithms for the construction and analysis of systems : 10th international conference ( tacas ) , lncs 2988_. 251265 .      \\1989 .",
    "every logic program has a natural stratification and an iterated least fixed point model . in _",
    "proceedings of the eighth acm sigact - sigmod - sigart symposium on principles of database systems_. acm press , 1121 ."
  ],
  "abstract_text": [
    "<S> recently there has been a growing interest of research in tabling in the logic programming community because of its usefulness in a variety of application domains including program analysis , parsing , deductive databases , theorem proving , model checking , and logic - based probabilistic learning . </S>",
    "<S> the main idea of tabling is to memorize the answers to some subgoals and use the answers to resolve subsequent variant subgoals . </S>",
    "<S> early resolution mechanisms proposed for tabling such as oldt and slg rely on suspension and resumption of subgoals to compute fixpoints . </S>",
    "<S> recently , the iterative approach named linear tabling has received considerable attention because of its simplicity , ease of implementation , and good space efficiency . </S>",
    "<S> linear tabling is a framework from which different methods can be derived based on the strategies used in handling looping subgoals . </S>",
    "<S> one decision concerns when answers are consumed and returned . this paper describes two strategies , namely , _ </S>",
    "<S> lazy _ and _ eager _ strategies , and compares them both qualitatively and quantitatively . </S>",
    "<S> the results indicate that , while the lazy strategy has good locality and is well suited for finding all solutions , the eager strategy is comparable in speed with the lazy strategy and is well suited for programs with cuts . </S>",
    "<S> linear tabling relies on depth - first iterative deepening rather than suspension to compute fixpoints . </S>",
    "<S> each cluster of inter - dependent subgoals as represented by a top - most looping subgoal is iteratively evaluated until no subgoal in it can produce any new answers . </S>",
    "<S> naive re - evaluation of all looping subgoals , albeit simple , may be computationally unacceptable . in this paper , we also introduce semi - naive optimization , an effective technique employed in bottom - up evaluation of logic programs to avoid redundant joins of answers , into linear tabling . we give the conditions for the technique to be safe ( i.e. sound and complete ) and propose an optimization technique called </S>",
    "<S> _ early answer promotion _ to enhance its effectiveness . </S>",
    "<S> benchmarking in b - prolog demonstrates that with this optimization linear tabling compares favorably well in speed with the state - of - the - art implementation of slg .    </S>",
    "<S> # 1    [ firstpage ]    prolog , semi - naive evaluation , recursion , tabling , memoization , linear tabling . </S>"
  ]
}