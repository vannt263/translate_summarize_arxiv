{
  "article_text": [
    "security protocols are `` communication protocols dedicated to achieving security goals '' ( c.j.f . cremers and s. mauw ) @xcite such as confidentiality , integrity or availability . achieving such security goals",
    "is made through the use of cryptography .",
    "the explosive development of today s internet and the technological advances made it possible to implement and use security protocols in a wide range of applications such as sensor networks , electronic commerce or routing environments .",
    "security protocols have been intensively analyzed throughout the last few decades , resulting in a variety of dedicated formal methods and tools @xcite .",
    "the majority of these methods consider a dolev - yao - like intruder model @xcite to capture the actions available to the intruder that has complete control over the network . by analyzing each individual protocol in the presence of this intruder ,",
    "the literature has reported numerous types of attacks @xcite . however , in practice , there can be multiple protocols running over the same network , thus the intruder is given new opportunities to construct attacks by combining messages from several protocols , also known as multi - protocol attacks @xcite .    designing new protocols , thus ,",
    "becomes a challenging task if we look at the number of attacks that have been discovered over the years @xcite after the protocols have been published . in the last few years",
    "the use of protocol composition @xcite has been successfully applied to create new protocols based on existing @xcite or predefined protocols @xcite .    in this paper",
    "we propose a new composition method that , as opposed to existing approaches @xcite can be fully automatized by eliminating the human factor . in order to create an automated composition method , we need an enriched protocol model that contains enough information to compose the protocol preconditions and effects and an approach for the verification of the correctness of the final , composed protocol .",
    "preconditions denote the set of properties that must be satisfied for the protocol to be executed , while the effects denote the set of properties resulting from the protocol execution . by composing preconditions and effects ( i.e. pe composition ) , we generate a new protocol sequence that ensures the satisfaction of the protocol preconditions and the propagation of generated information through effects .",
    "the protocol sequence generated by the pe composition must be correct , in the sense that it must maintain the security properties of the original protocols . in order to verify this",
    ", we use an approach developed in our previous work @xcite that verifies the independence of the involved protocols .",
    "protocol independence , called participant chain composition ( i.e. pc composition ) ensures that the intruder can not replay messages from one protocol to another to construct new attacks while running the protocols in the same environment .",
    "this property also ensures the correctness of the composed protocol .",
    "the paper is structured as follows . in section",
    "[ sec : protmodel ] we define an enriched protocol model that includes explicit description of protocol preconditions , effects , generated terms and exchanged messages . in section [ sec : composition ] we provide a description of the proposed composition method and a brief presentation of the independence verification method proposed in our previous work @xcite .",
    "the proposed composition method has been applied in the composition process of several protocols , part of these experimental results are given in section [ sec : expresults ] .",
    "we relate our work to others found in the literature in section [ sec : relwork ] and we end with a conclusion and future work in section [ sec : conclusion ] .",
    "protocol participants communicate by exchanging _ terms _ constructed from elements belonging to the following basic sets : , denoting the set of participant names ; , denoting the set of random numbers or _ nonces _ ( i.e. `` number once used '' ) ; , denoting the set of cryptographic keys ; , denoting the set of certificates and , denoting the set of user - defined message components .    in order for the protocol model to capture the message component types found in security protocol implementations",
    "@xcite we specialize the basic sets with the following subsets :    * @xmath0 , denoting the set of distinguished names ; @xmath1 , denoting the set of user - domain names ; @xmath2 , denoting the set of user - ip names ; @xmath3 , denoting the set of names that do not belong to the previous subsets ; * @xmath4 , denoting the set of timestamps ; @xmath5 , denoting the set of random numbers specific to the diffie - hellman key exchange ; @xmath6 , denoting the set of random numbers ; * @xmath7 , denoting the set of symmetric keys ; @xmath8 , denoting the set of keys generated from a diffie - hellman key exchange ; @xmath9 , denoting the set of public keys ; @xmath10 , denoting the set of private keys .",
    "to denote the encryption type used to create cryptographic terms , we define the following _ function names _ : @xmath11    the encryption and decryption process makes use of cryptographic keys .",
    "decrypting an encrypted term is only possible if participants are in the possession of the decryption key pair . in case of symmetric cryptography ,",
    "the decryption key is the same as the encryption key . in case of asymmetric cryptography",
    ", there is a public - private key pair .",
    "determining the corresponding key pair is done using the function @xmath12 .",
    "the above - defined basic sets and function names are used in the definition of _ terms _ , where we also introduce constructors for pairing and encryption : @xmath13 where the ` . '",
    "symbol is used to denote an empty term .",
    "having defined the terms exchanged by participants , we can proceed with the definition of a _ node _ and a _ participant chain_. to capture the sending and receiving of terms , the definition of nodes uses _ signed terms_. the occurrence of a term with a positive sign denotes transmission , while the occurrence of a term with a negative sign denotes reception .    a _",
    "node _ is any transmission or reception of a term denoted as @xmath14 , with @xmath15 and @xmath16 one of the symbols @xmath17 .",
    "a node is written as @xmath18 or @xmath19 .",
    "we use @xmath20 to denote a set of nodes .",
    "let @xmath21 , then we define the function @xmath22 to map the sign and the function @xmath23 to map the term corresponding to a given node .",
    "a _ participant chain _ is a sequence of nodes .",
    "we use @xmath24 to denote the set of finite sequences of nodes and @xmath25 to denote an element of @xmath24 .    in order to define a participant model",
    "we also need to define the preconditions that must be met such that a participant is able to execute a given protocol .",
    "in addition , we also need to define the effects resulting from a participant executing a protocol .",
    "preconditions and effects are defined using predicates applied on terms : @xmath26 , denoting a term that must be previously generated ( preconditions ) or it is generated ( effects ) ; @xmath27 , denoting a participant that must be previously authenticated ( preconditions ) or a participant that is authenticated ( effects ) ; @xmath28 , denoting that a given term must be confidential ( preconditions ) or it is kept confidential ( effects ) ; @xmath29 , denoting that for a given term the integrity property must be provided ( preconditions ) or that the protocol ensures the integrity property for the given term ( effects ) ; @xmath30 , denoting that for a given term the non - repudiation property must be provided ( preconditions ) or that the protocol ensures the non - repudiation property for the given term ( effects ) ; @xmath31 , denoting that a key exchange protocol must be executed before ( preconditions ) or that this protocol provides a key exchange resulting the given term ( effects ) .",
    "the set of precondition - effect predicates is denoted by @xmath32 and the set of precondition - effect predicate subsets is denoted by @xmath33 .",
    "next , we define predicates for each type of term exchanged by protocol participants .",
    "these predicates are based on the basic and specialized sets provided at the beginning of this section .",
    "we use the @xmath34 predicate to denote distinguished name terms , @xmath35 to denote user - domain name terms , @xmath36 to denote user - ip name terms , @xmath37 user name terms , @xmath38 to denote timestamp terms , @xmath39 to denote diffie - hellman random number terms , @xmath40 to denote other random number terms , @xmath41 to denote diffie - hellman symmetric key terms @xmath42 @xmath43 , @xmath44 to denote symmetric key terms @xmath45 , @xmath46 to denote public key terms @xmath47 , @xmath48 to denote private key terms @xmath47 , @xmath49 do denote certificate terms @xmath47 and @xmath50 to denote user - defined terms .",
    "the set of type predicates is denoted by @xmath51 and the set of type predicate subsets is denoted by @xmath52 .",
    "based on the defined sets and predicates we are now ready to define the participant and protocol models .",
    "a _ participant model _ is a tuple @xmath53 , where @xmath54 is a set of precondition predicates , @xmath55 is a set of effect predicates , @xmath56 is a set of type predicates , @xmath57 is a set of generated terms , @xmath58 is a participant name and @xmath59 is a participant chain .",
    "we use the @xmath60 symbol to denote the set of all participant models .",
    "a _ protocol model _ is a collection of participant models such that for each positive node @xmath61 there is exactly one negative node @xmath62 with @xmath63 .",
    "we use the @xmath64 symbol to denote the set of all protocol models .",
    "the composition process involves composing in a first stage the protocol preconditions and effects followed by the composition of participant chains . in this section",
    "we first formulate the conditions needed for the precondition - effect ( pe ) composition which involves establishing the satisfaction of protocol preconditions and the verification of the non - destructive properties of protocol effects .",
    "this is followed by the protocol - chain ( pc ) composition for which we construct a canonical model and verify the independence of the involved participant chains .      in the composition process of two security protocols",
    "we first need to compose the preconditions and effects . in other words",
    ", we need to establish if the knowledge needed by protocol participants to run a given protocol , expressed through the form of precondition predicates , is available and if the set of precondition and effect predicates is non - destructive .    in order to establish",
    "if the set of preconditions corresponding to a protocol can be satisfied based on a given context and the effects corresponding to another protocol we use the predicate @xmath65 .",
    "the context denotes the initial knowledge available to participants when running the protocol . for two participant models , @xmath66 and @xmath67 ,",
    "the @xmath68 predicate is defined as @xmath69    the non - destructive property applies only for the @xmath70 because the absence of another property , such as integrity or non - repudiation , does not affect the previous properties . in order to establish",
    "if the preconditions and effects of two participant models are destructive we use the predicate @xmath71 which holds only if all confidential terms from one participant model maintain their confidentiality property in the second participant model also .",
    "thus , the predicate is defined as @xmath72    based on the above given predicates we can state that in order to compose the preconditions and effects corresponding to two participant models we need to establish if the predicates @xmath68 and @xmath73 hold . the precondition - effect ( pe )",
    "composition is expressed through the use of the operator @xmath74 , which generates a new participant model based on two given participant models . by using this operator",
    ", we not only express the pe composition of participant models but also the order in which the given participant models appear in the final , composed participant model .",
    "thus , we can state that given two participant models , @xmath75 and @xmath76 , for which the pe composition requirements are satisfied , we have that @xmath77 .",
    "if the operator is applied on two participant models that can not be composed ( i.e. one of the two predicates does not hold ) , the result is the empty participant model , denoted by @xmath78 , where @xmath79 denotes an empty set .",
    "the pe composition requirements of two participant models can be easily extended to form the requirements for the pe composition of two protocol models .",
    "these requirements include applying the @xmath80 operator on pairs of participant models for which the names are equal .",
    "we express the pe composition of two protocol models through the use of the @xmath81 operator . for this operator also",
    ", we can state that given two protocol models , @xmath82 and @xmath83 , for which the pe composition requirements are satisfied , we have that @xmath84 . in case of protocol models that can not be composed , the result is denoted by the empty protocol model @xmath85 .",
    "the pc composition makes use of a canonical model that focuses on terms that can be verified by protocol participants . for each term",
    "the canonical model provides a corresponding syntactical representation through the use of _ basic types_. these denote the terms that can be verified by protocol participants also including a representation for terms that can not be verified because of limited participant knowledge .",
    "the verification process makes use of these types to decide if attacks can be constructed on each protocol model by using terms extracted from the other considered protocol models .    in order to compose two participant chains",
    "these must be _ instance independent _ and _ canonical independent_. the first condition refers to the non - destructive properties of preconditions and effects while the second condition refers to verifying the independence of the involved participant chains based on the canonical model .",
    "the verification of the independence property of protocol models has been covered by the authors in their previous work @xcite .",
    "if protocols are independent , then they maintain their security properties when they are run in the same context . by using this property in the composition process",
    ", protocols maintain their security properties , resulting new protocols with accumulated properties .    in the remaining of this section we briefly present the canonical model and the protocol independence property proposed in our previous work .",
    "the _ basic types _",
    "we consider are based on the specialized basic sets introduced in the protocol model : @xmath86 where the given symbols correspond to participant distinguished names , user - domain names , user - ip names , other user names , timestamps , diffie - hellman random numbers , other random numbers , keys , user defined terms , certificates and unknown terms , respectively .",
    "the _ unknown _ type corresponds to terms that can not be validated because of limited participant knowledge . by including this information in the specification we are able to detect subtle type - flaw attacks using a syntactical comparison of typed terms ,",
    "that otherwise would require the construction of a state - space that can become rather large if we consider the existence of multiple protocols in the same system @xcite .",
    "based on the defined basic terms we can now proceed with the definition of _ canonical terms _ : @xmath87    a canonical node is defined as a signed canonical term using the following definition .",
    "a _ canonical node _ is any transmission or reception of a canonical term denoted by @xmath14 , with @xmath88 and @xmath16 one of the symbols @xmath17 .",
    "we use @xmath89 to denote a set of canonical nodes .",
    "let @xmath90 , then we define the function @xmath91 to map the sign and the function @xmath92 to map the canonical term corresponding to a given canonical node .    before we proceed with the definition of canonical chains and canonical participant models we need to define _",
    "these are attached to participant chains and are used to transform canonical terms received from other participants based on local participant knowledge .",
    "we define two such classifiers : @xmath93    the first classifier @xmath94 denotes the processing chain corresponding to a participant .",
    "this chain contains canonical terms that correspond to participant knowledge .",
    "the second classifier @xmath95 denotes the virtual chain used to transform received terms from the transmitted form to the received form based on the knowledge of the receiving participant .",
    "a _ canonical participant chain _ is a sequence of canonical nodes .",
    "a _ classified canonical participant chain _ is a pair @xmath96 , where @xmath97 and @xmath98 .",
    "we use @xmath99 to denote a set of canonical participant chains .",
    "a _ canonical participant model _ is a pair @xmath100 , where @xmath58 is a participant name and @xmath101 is a set of classified canonical participant chains .",
    "we use @xmath102 to denote the set of all canonical participant models .",
    "next , we define a canonical protocol model as a set of canonical participant models .    a _ canonical protocol model _ is a collection of canonical participant models such that for each positive canonical node @xmath61 there is exactly one negative canonical node @xmath62 with @xmath103 .",
    "we use the @xmath104 symbol to denote the set of all canonical protocol models .    based on the described protocol and canonical models , we proved , through the form of a proposition , that if two protocol models are instance independent and their corresponding canonical models are canonical independent , then the intruder can not construct attacks using terms extracted from other protocols . in order to verify this we used an intruder model based on the dolev - yao @xcite model to capture the powers that can be used by an intruder .",
    "if two protocol models are independent , then their participant chains can be composed .",
    "we use the @xmath105 operator to denote the pc composition of protocol chains and the @xmath106 operator to denote the pc composition of protocol models . for the first operator we use @xmath107 to denote the empty participant model , while for the second operator we use @xmath108 to denote the empty protocol model .",
    "if two protocol models can be composed pe and pc , then they can be composed .",
    "the composition operator we use to denote the composition of protocol models is @xmath109 , for which the generated empty protocol model is denoted by @xmath108 .",
    "by sequentially composing several protocol models the resulting protocol model provides a unified set of preconditions and effects and a unified set of participant chains . by composing _",
    "i _ protocols , the resulting sequence is written as @xmath110 .",
    "the proposed composition method can be applied on protocol pairs or entire protocol sequences .",
    "let @xmath111 and @xmath112 be two protocol sequences , where each sequence is constructed by subsequently applying the @xmath113 operator on protocol pairs , and @xmath114 , @xmath115 , two symbols denoting the number of protocols in the first and in the second sequence , respectively .",
    "then , the composition algorithm must ensure that the new composed sequence maintains the security properties of the original protocols and that the knowledge available to protocol participants allows the execution of the new sequence .",
    "let @xmath116 , @xmath117 , @xmath118 , @xmath119 @xmath120 let @xmath121 let @xmath122 let @xmath123 be the @xmath124-th element of @xmath111 let @xmath125 be the @xmath126-th element of @xmath112 @xmath127 , @xmath128 @xmath129 , @xmath128 @xmath130 , @xmath131 @xmath132 , @xmath131 @xmath129 , @xmath128 @xmath132 , @xmath131    verifying if protocols from the two sequences maintain their security properties requires applying the @xmath73 predicate on each protocol pair and the verification of the independence of the participant chains by using the pc composition operator @xmath133 .",
    "as shown in algorithm [ alg : comp ] , if one of these conditions is not satisfied , the execution is stopped , symbolized using the @xmath120 keyword .",
    "if the protocol properties are not destructive , the execution of the composition algorithm continues with the composition of protocol components .",
    "the final protocol is denoted by @xmath134 , which , initially , contains a participant model with the effects @xmath135 and types @xmath136 .",
    "these denote the initial knowledge for protocol participants , extracted from the context @xmath137 , a unified context constructed from the contexts corresponding the the two sequences .",
    "the composition process locates the position of each protocol in the final sequence by using the composition operator @xmath138 .",
    "if the result is @xmath107 , the protocols can not be composed and another pair is selected .",
    "finally , the remaining protocols are added to the sequence .",
    "in order to validate the proposed method we generated several new composed protocols , based on existing ones . in order to verify",
    "if the new protocols accumulated the properties of the initial protocols , i.e. the composition is non - destructive , we applied the method proposed in this paper .",
    "however , such a verification is not enough for validating a method that must ensure the correctness of the resulted protocols , as shown by the large number of attacks discovered on protocols long after they have been published @xcite .",
    "having these in mind , we turned to existing protocol verification tools .",
    "the purpose of the verification was to determine if new attacks became available on the composed protocols .",
    "one of the few tools allowing the verification of multi - protocol attacks is scyther @xcite , which is the only tool currently available that also detects type - flaw attacks @xcite , commonly found in multi - protocol environments .",
    "we have applied our method on several pairs of security protocols defined in the library maintained by clark and jacob @xcite , for which there is also an online version available @xcite . through our experiments we composed protocol pairs such as ccitt x.509 v1 ( i.e. x509v1 ) and ccitt x.509 v1c ( i.e. x509v1c ) , ban concrete rpc ( i.e. ban - rpc ) and lowe - b ( i.e. lowe - ban ) , lowe - denning - sacco ( i.e. l - d - s ) and kao - chow v1 ( i.e. k - cv1 ) , lowe - kerberos ( i.e. lowe - kerb ) and neuman - stubblebine ( i.e. neuman - s ) , hwang - neuman - stubblebine ( i.e. h - n - s ) and neuman - stubblebine , needham - schroeder ( i.e. needh - s ) and ccitt x.509 v1 , lowe - needham - schroeder ( i.e. l - n - s ) and iso9798 , otway - rees ( i.e. otway - r ) and lowe - ban , yahalom - lowe ( i.e. y - l ) and kao - chow v1 , as shown in table [ tab : expresults ] .",
    "the non - destructive property of the composed protocol was validated using the scyther tool .    in table",
    "[ tab : expresults ] , s1 indicates the protocol composition sequence p1-p2 , while s2 indicates the sequence p2-p1 .",
    "we used `` y '' to indicate the successful composition of a sequence and `` n '' the failure of the composition process . by applying the proposed non - destructivity conditions we have discovered several new multi - protocol attacks . for example",
    ", in case of the protocol pair yahalom - lowe and kao - chow , we discovered a new attack that gives the intruder the possibility to replay valid messages from the kao - chow v1 ( i.e. k - cv1 ) protocol into the yahalom - lowe ( i.e. y - l ) protocol .",
    "we have created a composed protocol and used the scyther tool to verify it .",
    "the result was that 2 new attacks were possible .",
    "after correcting the problem by adding additional terms to the protocols messages in order for participants to be able to verify the validity of these messages , the scyther tool did not detect any attacks , which was also confirmed by our method .",
    ".protocol composition results [ cols=\"<,<,^,^,^ \" , ]",
    "in this section we briefly describe the approaches found in literature that mostly relate to our proposal .    in @xcite , guttman proposes a composition method based on predefined protocol primitives that are used to construct new , composed protocols .",
    "a similar approach is proposed by choi @xcite , that additionally defines _ bindings _ in order to correctly connect different primitives .",
    "the previously mentioned approaches have not been designed to compose existing protocols , as the one proposed in this paper .",
    "we have only mentioned them here for completeness .",
    "a. datta et all @xcite propose the description of each composed protocol and of the final protocol as a set of equations .",
    "the composition process starts out from the initial protocol equations and tries to reach the properties modeled by the final equations . by doing so",
    ", they also prove the correctness of the final protocol . in case of this approach",
    ", the human factor plays an important role . as opposed to this , our approach can be fully automatized , eliminating the interference of the human factor .",
    "the approach proposed by s. andova et all @xcite also uses equations written for each protocol and for each security property that must be satisfied by the final protocol .",
    "the composition process uses the human operator to construct the final properties from the initial equations and the scyther @xcite tool to automatically verify the correctness of the composed protocols .",
    "this approach is a semi - automatized one that uses the human operator to construct the final properties and an automatic verification tool for the verification of the correctness of the final protocol .",
    "we have developed a method for the composition of security protocols .",
    "the novelty of our approach is the fact that it provides a syntactical verification of the involved protocols , that makes it appropriate for on - line automated composition applications .",
    "our proposal makes use of an enriched protocol model that embodies protocol preconditions and effects .",
    "messages exchanged by participants are modeled as sequences of nodes called participant chains .",
    "based on this model we proposed conditions for the precondition - effect composition .",
    "this process involves determining if sufficient knowledge is provided by previous protocols and if instance - specific security properties are maintained even after the composition .",
    "the protocol - chain composition process makes use of a canonical model that eliminates message component instances .",
    "this model reduces each component of the protocol model to its basic type . by doing",
    "so we are able to verify the instance - independent components of security protocols and detect multi - protocol attacks in a syntactical manner .",
    "we have applied the proposed composition method on several pairs of well - known security protocols and have found new multi - protocol attacks .",
    "our independence verification method has been validated using the security protocol verification tool scyther , a state - space exploration method , by discovering the same multi - protocol attacks .    as future work",
    ", we intend to use the proposed composition method in the design process of new protocols for web services .",
    "this would allow us to implement more complex protocols , such as tls @xcite , currently used as a binary security protocol , using an xml message format that would enrich the properties of tls with the ones specific to web services such as extensibility or flexibility .",
    "s. andova , c.j.f .",
    "cremers , k. gjosteen , s. mauw , s. mjolsnes , s. radomirovic , `` a framework for compositional verification of security protocols '' , special issue on computer security : foundations and automated reasoning , vol",
    ". 206(2 - 4 ) , elsevier , 2008 , pp .",
    "425459 .",
    "b. genge , and i. ignat , `` verifying the independence of security protocols '' , 3rd ieee international conference on intelligent computer communication and processing , cluj - napoca , romania , 2007 , pp .",
    "155163 .",
    "j. heather , g. lowe , and s. schneider , `` how to prevent type flaw attacks on security protocols '' , in the proc . of the 13th computer security foundations workshop ,",
    "ieee computer society press , july 2000 ."
  ],
  "abstract_text": [
    "<S> determining if two protocols can be securely composed requires analyzing not only their additive properties but also their destructive properties . in this paper </S>",
    "<S> we propose a new composition method for constructing protocols based on existing ones found in the literature that can be fully automatized . </S>",
    "<S> the additive properties of the composed protocols are ensured by the composition of protocol preconditions and effects , denoting , respectively , the conditions that must hold for protocols to be executed and the conditions that hold after executing the protocols . </S>",
    "<S> the non - destructive property of the final composed protocol is verified by analyzing the independence of the involved protocols , a method proposed by the authors in their previous work . </S>",
    "<S> the fully automatized property is ensured by constructing a rich protocol model that contains explicit description of protocol preconditions , effects , generated terms and exchanged messages . </S>",
    "<S> the proposed method is validated by composing 17 protocol pairs and by verifying the correctness of the composed protocols with an existing tool . </S>"
  ]
}