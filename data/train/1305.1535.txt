{
  "article_text": [
    "we want to show that one can use probabilistic arguments to prove the existence of inifinite objects ( say , infinite sequences of zeros and ones ) with some properties .",
    "so we should discuss first in which sense a probabilistic algorithm can generate such a sequence . the most natural approach :",
    "consider a turing machine without input that has an ( initially empty ) work tape and a write - only output tape where machine prints bits sequentially .",
    "using fair coin tosses , the machine generates a ( finite or infinite ) sequence of output bits .",
    "the output distribution of such a machine @xmath0 is some probability distribution @xmath1 on the set of all finite and infinite sequences .",
    "distributions on this set are determined by their values on cones @xmath2 ( of all finite and infinite extensions of a binary string @xmath3 ) . the function @xmath4 that corresponds to the distribution @xmath1 satisfies the following conditions : @xmath5 ( here @xmath6 denotes the empty string . )",
    "any non - negative real function that satisfies these conditions corresponds to some probability distribution on the set of finite and infinite binary sequences .",
    "the output distributions of probabilistic machines correspond to functions @xmath7 that are _ lower semicomputable _ ; this means that some algorithm , given a binary string @xmath3 , computes a non - decreasing sequence of rational numbers that converges to @xmath8 .",
    "now we are ready to look at the classical result of de leeuw  moore ",
    "shannon  shapiro : _ if some individual sequence @xmath9 appears with positive probability as an output of a probabilistic turing machine , this sequence is computable_. indeed , let this probability be some @xmath10 ; take a rational threshold @xmath11 such that @xmath12 , and consider some prefix @xmath13 of @xmath9 such that @xmath14 .",
    "( such a prefix exists , since @xmath8 for prefixes of @xmath9 converges to @xmath15 . )",
    "starting from @xmath13 , we can compute the next prefix of @xmath9 by finding a son where @xmath7 exceeds @xmath11 .",
    "the correct son satisfies this condition , and no branching is possible : if for two sons the value exceeds @xmath11 , then it would exceed @xmath16 for the father .",
    "this result can be interpreted as follows : _ if our task is to produce some specific infinite sequence of zeros and ones , randomization does not help _",
    "( at least if we ignore the computational resources ) . however , if our goal is to produce _ some _ sequence with given properties , randomization can help . a trivial example : to produce a noncomputable sequence with probability @xmath17 it is enough to output the random bits .",
    "all these observations are well known , see , e.g. , the classical paper of zvonkin and levin  @xcite . for a less trivial example , let us consider another result ( proved by n.v .",
    "petri ) mentioned in this paper : _ there exists a probabilistic machine that with positive probability generates a sequence @xmath9 such that  @xmath9 contains infinitely many ones ;  the function @xmath18 has no computable upper bound_. ( in the language of recursion theory , this machine generates with positive probability a characteristic sequence of a hyperimmune set . ) a nice proof of this result was given by peter gacs ; it is reproduced in the next section ( we thank m.  bondarko for some improvements in the presentation ) .",
    "consider the following puzzle . we come to a shop where fireworks are sold .",
    "after we buy one , we can test it in place ( then we know whether it was good or not , but it is not usable anymore , so we have to buy a new one after that ) , or go home , taking the untested firework with us . we look for a probabilistic strategy that with 99% probability wins in the following sense : it _ either finds a bad firework during the testing _ ( so we can sue the shop and forget about the fireworks ) _ or takes home a good one_.    here is the solution : _ take a random number @xmath19 in @xmath20 range , make @xmath19 tests ( less if the failure happens earlier if all @xmath19 tested fireworks were good , take home the next one_. to prove that it wins with @xmath21 probability , note that the seller does not get any information from our behavior : he sees only that we are buying and testing the fireworks ; when we take the next one home instead of testing , it is too late for him to do anything .",
    "so his strategy is reduced to choosing some number @xmath22 of good fireworks sold before the bad one .",
    "he wins only if @xmath23 , i.e. , with probability at most  @xmath24 .",
    "another description of the same strategy : we take the first firework home with probability @xmath25 and test it with probability @xmath26 ; in the second case , if the firework was good , we take the second one , bringing it home with probability @xmath27 and testing it with probability @xmath28 , etc .",
    "why this game is relevant ?",
    "assume we have a program of some computable function @xmath29 and want to construct probabilistically a total function @xmath30 not bounded by @xmath29 if @xmath29 is total ; if @xmath29 is not total , any total function @xmath30 is ok for us .",
    "( it is convenient to consider a machine that constructs a total integer - valued function @xmath30 and then convert it into a bit sequence by putting @xmath31 zeros after @xmath19th occurence of @xmath17 in the sequence . )",
    "we consider @xmath32 as `` fireworks '' ; @xmath33 is considered as a good one if the computation of @xmath33 terminates .",
    "first we buy @xmath34 ; with probability @xmath25 we `` take '' it and with probability @xmath26 we `` test '' it .",
    "_ taking _ @xmath34 means that we run this computation until it terminates and then let @xmath35 . if this happens , we may relax and let all the other values of @xmath30 be zeros .",
    "( if the computation does not terminate , i.e. , if we have taken a bad firework , we are out of luck . ) _ testing _",
    "@xmath34 means that we run this computation and at the same time let @xmath36 , @xmath37 , etc . until the computation terminates .",
    "if @xmath34 is undefined , @xmath30 will be zero function , and this is ok since we do not care about non - total functions  @xmath29 .",
    "but if @xmath34 is defined , at some point testing stops , we have some initial fragment of zeros @xmath38 , and then consider @xmath39 as the next firework bought and test [ take ] it with probability @xmath28 [ resp .",
    "@xmath27 ] .",
    "for example , if we decide to test it , we run the computation @xmath39 until it terminates , and then let @xmath41 . and so  on .    in this way",
    "we can beat a given computable function @xmath29 with probability arbitrarily close to  @xmath17 .",
    "we need more : to construct with positive probability a function not bounded by _ any _ total computable function .",
    "how can we do this ?",
    "consider all the functions as functions of two natural arguments , using a computable bijection between @xmath42 and @xmath43 .",
    "use @xmath44th row in the table of such a function to beat @xmath44th potential upper bound with probability @xmath45 . to beat the upper bound ,",
    "it is enough to beat it in some row , so we can deal with all the rows in parallel , and get error probability at most @xmath46 .",
    "let us return now to the original question : can we use probabilistic arguments to construct a computable sequence with some property ? as we have seen , if we are able to construct a probabilistic machine that generates some _ specific _ sequence with positive probability , we can then conclude that this specific sequence is computable .",
    "however , we do not know arguments that follow this scheme , and it is difficult to imagine how one can describe a specific sequence that it is actually computable , and prove that it has positive probability  without actually constructing an algorithm that computes it .",
    "here is another statement that may be easier to apply . in this statement",
    "we use the standard topology on the cantor space of infinite @xmath47-@xmath17-sequences (=  the product topology on @xmath48 ) .",
    "[ closed - almost - everywhere ] let @xmath49 be a closed set of infinite sequences .",
    "let @xmath50 be a probabilistic machine ( without input ) whose output sequence belongs to @xmath49 with probability @xmath17 .",
    "then @xmath49 contains a computable element .    indeed , consider the output distribution @xmath1 of the machine @xmath50 and",
    "take a computable branch in the binary tree along which the probabilities @xmath51 remain positive ( this is possible since the function @xmath51 is lower semicomputable ) .",
    "we get some computable sequence  @xmath9 . if @xmath52 , then some prefix of @xmath9 has no extensions in @xmath49 ( recall that @xmath49 is closed ) .",
    "this prefix has positive probability by construction , so our machine can not generate elements in @xmath49 with probability  @xmath17 .",
    "this contradiction shows that @xmath53 .    in the following sections we give a specific example when this approach ( in a significantly modified form ) can be used .",
    "let @xmath54 be a sequence of mutually independent random variables ; each variable @xmath55 has a finite range @xmath56 .",
    "( in the simplest case @xmath55 are independent random bits . ) consider some family @xmath57 of events ; each @xmath58 depends on a finite set of variables , denoted @xmath59 . informally speaking",
    ", lovsz local lemma ( lll ) guarantees that these events do not cover the entire probability space if each of them has small probability and the dependence between the events ( caused by common variables ) is limited .",
    "intuitively , the events are undesirable for us and we want to avoid all of them ; lll says that this is possible ( with positive probability ) .    to make the statement exact , we need to introduce some terminology and notation .",
    "two events @xmath60 are _ disjoint _ if they do not share variables , i.e. , if @xmath61 ; otherwise they are called _ neighbors_. for every @xmath58 let @xmath62 be the neighborhood of @xmath63 , i.e. , the set of all events @xmath64 that have common variables with @xmath63 .",
    "each event is its own neighbor .",
    "[ finite ] consider a finite family @xmath65 of events .",
    "assume that for each event @xmath58 a rational number @xmath66 is fixed such that @xmath67\\le z_i\\cdot\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\prod_{j\\ne i,\\ , a_j\\in n(a_i)}(1-z_j)\\ ] ] for all @xmath44 .",
    "then @xmath68 \\ge \\prod_{i } ( 1-z_i)\\eqno ( * ) \\ ] ]    note that we skip the event @xmath63 in the right hand side of the condition .",
    "this bound was originally proved  @xcite by a simple ( though a bit misterious ) induction argument .",
    "note that the product in the right hand side of @xmath69 is positive ( though it can be very small ) , and therefore there exists an assignment that avoids all the forbidden events .",
    "this existence result can be easily extended to infinite families :    [ infinite ] consider a sequence @xmath70 of events .",
    "assume that each event @xmath58 has only finitely many neighbors in  @xmath71 , and that for each event @xmath58 a rational number @xmath66 is fixed such that @xmath67\\le z_i\\cdot\\!\\!\\!\\!\\!\\!\\!\\!\\!\\!\\prod_{j\\ne i,\\ , a_j\\in n(a_i)}(1-z_j)\\ ] ] for all @xmath44 .",
    "then there exists an assignment that avoids all the events @xmath58 .",
    "this is just a combination of finite lll and compactness argument ( knig s lemma ) .",
    "indeed , each event from @xmath71 is open the the product topology ; if the claim is false , these events cover the entire ( compact ) product space , so there exists a finite subset of events that covers the entire space , which contradicts the finite lll .",
    "our goal is to make this infinite version effective and get a _ computable version _ of lll .",
    "first , we need to add some computability conditions .",
    "let us assume that the range of @xmath55 is @xmath72 , where @xmath73 is a computable function of @xmath44 .",
    "we assume that @xmath55 has a rational - valued probability distribution that is computable given @xmath44 .",
    "we assume also that events @xmath63 are effectively presented , i.e. , for a given @xmath44 one can compute the list of all the variables in @xmath59 and the event itself ( i.e. , the list of tuples that belong to it ) .",
    "finally , we assume that for each variable @xmath55 only finitely many events involve this variable , and the list of those events can be computed given @xmath44 .",
    "[ computablelll ] suppose there is a rational constant @xmath74 and a computable sequence @xmath75 of rational numbers in @xmath76 such that @xmath67\\le \\alpha z_i\\cdot\\!\\!\\!\\!\\!\\!\\!\\!\\prod_{j\\ne i,\\ , a_j\\in n(a_i)}(1-z_j)\\ ] ] for all @xmath44 .",
    "then there exists a computable assignment that avoids all @xmath63 .",
    "note that the computability restrictions look quite naturally and that we only need to make the upper bounds for probability just a bit stronger ( adding some constant factor @xmath77 ) .",
    "it should not be a problem for typical applications of lll ; usually this stronger bound on @xmath78 $ ] can be easily established .",
    "this theorem is the main result of the paper .",
    "lance fortnow formulated this statement and conjectured that it should follow somehow from the moser ",
    "tardos effective proof of finite lll  @xcite .",
    "it turned out that it is indeed the case ( the proof , found by the first author , was published as ` arxiv ` preprint  @xcite ) .",
    "the proof goes as follows : according to proposition  [ closed - almost - everywhere ] , it is enough to construct a computable probability distribution on infinite sequences such that every @xmath63 has zero probability . to construct such a distribution ,",
    "we need first to extend the class of probabilistic machines , and then construct a machine of this extended type , based on moser  tardos algorithm .",
    "now we change the computational model and make the output tape of a probabilistic machine ( without input ) _ rewritable _ : the machine can change several times the contents of a cell , and only the final value matters .",
    "( we may assume that @xmath44th cell may contain integers in @xmath79 range , and that initially all cells contain zeros . )",
    "the final value is defined if a cell changes its value finitely many times during the computation . of course , for some values of random bits it may happen that some cell gets infinitely many changes . in this case",
    "we say that the output sequence of the machine is undefined .",
    "if the output sequence is defined with probability @xmath17 , we get an almost everywhere defined mapping from cantor space ( sequences of bits produced by coin tossing ) into the space of all assignments : the sequence of randomly generated bits is mapped to the output sequence .",
    "this mapping defines the output distribution on the assignments ( the image of the uniform distribution on random bits ) .",
    "this distribution may be non - computable ( e.g. , for every lower semicomputable real @xmath80 it is easy to generate @xmath81 with probability @xmath82 and @xmath83 with probability @xmath84 ) .",
    "however , we get a computable output distribution if we impose some restriction on the machine .    here",
    "it is : _ for every output cell @xmath44 and for every rational @xmath85 one can effectively compute integer @xmath86 such that the probability of the event `` the contents of @xmath44-th cell changes after step @xmath87 '' , taken over all possible random bit sequences , does not exceed  @xmath88_.    [ output - layerwise ] in this case the limit content of every output cell is well defined with probability @xmath17 , and the output distribution on the sequences of zeros and ones is computable .",
    "indeed , to approximate the probability of the event `` output starts with @xmath89 '' for a sequence @xmath89 of length @xmath19 with error at most @xmath88 , we find @xmath90 for @xmath19 first cells ( i.e. , for @xmath91 )",
    ". then we take @xmath92 greater than all these values of @xmath87 , and simulate first @xmath92 steps of the machine for all possible combinations of random bits .",
    "an almost everywhere defined mappings of cantor space defined by machines with described properties , are called _ layerwise computable mappings_. initially they appeared in the context of algorithmic randomness  @xcite .",
    "one can show that such a mapping is defined on all martin - lf random sequences .",
    "moreover , it can be computed by a machine with a write - only output tape if the machine additionally gets the value of randomness deficiency for the input sequence .",
    "this property can be used ( and was originally used ) as an equivalent definition of layerwise computable mapping .",
    "( the word `` layerwise '' reflects this idea : the mapping is computable on all `` randomness levels '' . )",
    "this aspect , however , is not important for us now ; all we need is to construct a layerwise computable mapping whose output distribution avoids all the undesirable events @xmath63 with probability  @xmath17 , and then apply proposition  [ closed - almost - everywhere ] .",
    "first , we recall the moser  tardos probabilistic algorithm that finds a satisfying assignment for the finite case . to make this paper",
    "self - contained , we reproduce the arguments from  @xcite ( we need to use them in a slightly modified form ) .    moser  tardos algorithm is very simple and natural :    * start by assigning random values to all @xmath93 independently ( according to their distributions ) ; * while some of the events @xmath63 are true , select one of these events and resample all the variables in @xmath59 using fresh independent random values .    several remarks :    * the resampling caused by some @xmath63 does not necessarily makes this event false ; it may remain true and can be resampled again later .",
    "* resampling for @xmath63 can affect its neighbors ; in particular , some of them could be false before and become true after the resampling ( then further resampling is needed ) .",
    "* the algorithm may terminate ( when the current assignment makes all @xmath63 false ) or continue indefinitely .",
    "the latter can happen even for finite case ( though with zero probability , under the conditions of lll , as we will see ) . in the infinite case the algorithm does not terminate :",
    "even if all @xmath63 are false at some moment , we need an infinite amount of time to check them all . * to describe the algorithm fully , one needs to specify some ( deterministic or probabilistic ) rule that says which of the ( true ) @xmath63 should be resampled .",
    "we assume that some rule is fixed . in the finite case",
    "the choice of the rule does not affect the analysis at all ; for the infinite case we assume that the _ first true @xmath63 is selected _ ( the one with minimal @xmath44 ) .",
    "let us now reproduce moser  tardos analysis for the finite case .",
    "they show that the expected number of steps ( resampling operations ) does not exceed @xmath94 this implies that the algorithm terminates with probability @xmath17 .",
    "how do they get this bound ?    * for each resampling performed during the algorithm , some tree is constructed .",
    "its vertices are labeled by events @xmath63 ; informally , the tree reflects the dependence between events that were resampled on this and previous steps . *",
    "running moser ",
    "tardos algorithm step by step , we get a sequence of trees ( one per each resampling ) ; all the trees in this sequence will be different .",
    "( this sequence is a random variable depending on the random choices made when choosing the random values and the events for resampling . ) * the number of resampling steps is the number of trees appearing in this sequence , therefore the expected number of steps is @xmath95\\ ] ] where @xmath96 includes all trees that may appear .",
    "( it is important here that a tree can not appear twice in the same run of the algorithm , see above . )",
    "* this sum is now estimated by splitting it accordingly to root labels of the trees .",
    "let @xmath97 be a set of trees in @xmath96 that have root label @xmath63 ( such a tree appears when @xmath63 is resampled ) .",
    "moser and tardos show that @xmath98\\le \\frac{z_i}{1-z_i};\\ ] ] this is done by comparing the probabilities in question to some other probabilities ( to appear in a process of galton  watson type , see below ) .",
    "then we sum these inequalities for all  @xmath44 .",
    "let us now go into the details .",
    "* the set @xmath96 contains finite rooted trees whose vertices are labeled by events @xmath99 , with the following restrictions : the sons of a vertex with label @xmath99 should be labeled by different neighbors of @xmath99 ( recall that @xmath99 is a neighbor of itself ) , and these neighbors should be disjoint events .",
    "* now we explain how trees are constructed .",
    "assume that the events @xmath100 are resampled ( in this order ) by the algorithm , and we now are at step @xmath19 and construct a tree @xmath101 that corresponds to @xmath102 ( = appears at step @xmath19 of the algorithm ) .",
    "we consider the resampling operations in the reverse order , starting from @xmath102 .",
    "initially the tree consists of a root vertex only ; the root is labeled by @xmath102 ( or just by @xmath103 ; we may identify events with their indices ) .",
    "then we consider events @xmath104 .",
    "if the next event @xmath105 in this sequence is not a neighbor of any current tree vertex ( its label ) , we skip it . if it is , we look at all these vertices ( labeled by neighbors ) , take one that is most distant from the root ( breaking the ties arbitrarily ) , and attach to it a new son labeled by @xmath105 ( by @xmath106 , if we use indices as labels ) .",
    "+    + an example : consider four events @xmath107 with neighbor pairs @xmath108 and @xmath109 , and assume that the sequence of resamplings is @xmath110 .",
    "then we start with root labeled @xmath111 , then skip @xmath112 ( since it is not a neighbor of @xmath111 ) , then add @xmath113 as a son of @xmath111 , then add @xmath17 as another son of @xmath111 ( note that @xmath17 and @xmath113 are not neighbors , so @xmath17 can not be attached to @xmath113 ) , and finally add first @xmath111 as a son of @xmath17 or @xmath113 ( the first possibility is shown ; note that @xmath111 is also a neighbor of the root , but we select a vertex on a maximal distance from the root ) . * the resulting tree belongs to @xmath96 . indeed ,",
    "* * each son is a neighbor of its father by construction ; * * different sons of the same father are not neighbors , otherwise the younger brother will become a son of the older one instead of becoming his brother . *",
    "the last argument shows in fact more : any two vertices of the same height ( at the same distance from the root ) are not neighbors .",
    "( this property will be used later . )",
    "* two trees that appears at different steps of the algorithm , are different .",
    "it is obvious if they have different root labels .",
    "if they both have some @xmath63 as the root label , then each tree includes all previous resamplings of @xmath63 , so the number of @xmath44-labels is different for both trees .",
    "our next goal : for a given @xmath101 we upperbound the probability of the event `` @xmath0 appears at some stage of moser  tardos algorithm '' .",
    "this bound is provided by the following lemma .",
    "[ treeprob ] for every tree , the probability of the event `` t appears at some stage of moser  tardos algorithm '' does not exceed of the product of @xmath78 $ ] for all labels in @xmath0 .",
    "( if the label @xmath63 appears several times as a label in @xmath0 , its probability appears several times in the product . )    to prove this lemma , it is convenient to specify more explicitly how the random values ( used as original values and for resampling ) are chosen .",
    "long ago people used printed tables of random numbers .",
    "these tables were prepared in advance by a random process ; when a fresh random number was needed , it was taken from the table and then crossed out ( to prevent its future use ) .",
    "in the same way we assume that for each variable @xmath55 a sequence of independent random values @xmath114 is prepared in advance .",
    "when a new random value is needed , we use the first unused value from this sequence .",
    "( so @xmath115 is used for the initialization , and @xmath116 are then used for resampling of events that involve  @xmath55 . )    now the crucial observation : _ the tree @xmath0 that appears at some step , determines uniquely which random values were used during the resampling operations corresponding to @xmath0 s vertices_. indeed , a given variable @xmath55 appears at most once at every height level of the tree ( as we have mentioned above ) , and the height ordering agrees with the temporal ordering of the corresponding resampling operations .",
    "no other resampling step ( in between the resampling operations included in the tree ) could involve @xmath55 due to tree construction ( such a resampling operation can not be skipped ) .",
    "therefore , the event `` @xmath0 appears '' is included in the intersection of the independent events of probability @xmath78 $ ] for all labels @xmath63 in @xmath0 .",
    "the lemma is proven .",
    "now we use the assumption of the finite lll , the upper bound for @xmath78 $ ] . using this bound ,",
    "we need to show that @xmath117\\le \\frac{z_i}{1-z_i}.\\ ] ] for every @xmath44 ( we have already noted that this gives the required bound for the expected number of steps . ) this is done by the following nice ( and mysterious ) trick .",
    "consider the following probabilistic process ( of galton  watson type ) that produces some tree in @xmath97 .",
    "the process starts with a tree that has only one vertex , the root , labeled by @xmath44 .",
    "then for each neighbor @xmath118 of @xmath63 ( including @xmath63 itself ) we decide whether the root will have a son labeled by @xmath119 .",
    "( only one son with a given label can appear . )",
    "namely , son with label @xmath119 appears with probability @xmath120 .",
    "then the same is done for each new vertex @xmath121 : each its neighbor @xmath99 is attached as a son of @xmath121 with probability @xmath122 , and so on .",
    "this process may never terminate ( then we get an infinite tree ) , but may also terminate and produce a finite tree .",
    "for example , if event @xmath63 has neighbors @xmath123 ( and no others ) , the probability to obtain a tree with only one vertex ( the root ) in this process is @xmath124 ( this tree appears when none of three possible sons are attached ) .",
    "and the probability to get a tree with root @xmath44 and its son @xmath119 ( and no other vertices ) is @xmath125 assuming that @xmath118 has no other neighbors except for @xmath63 and @xmath118 itself .",
    "now the galton  watson ( gw- ) process ( for a given @xmath44 ) is described , and we claim that for every tree @xmath126 ( with root label @xmath44 ) we have @xmath127\\le\\frac{z_i}{1-z_i}\\pr[\\text{$t$ appears in the gw - process}].\\ ] ] since only one tree can appear in gw - process , the sum of probabilities in the right hand side ( over all @xmath128 ) does not exceed  @xmath17 , and we get the promised bound .",
    "so it remains to prove our claim . according to the lemma  [ treeprob ] , the upper bound for the left - hand side",
    "can be obtained by multiplying the bounds for @xmath78 $ ] for all labels @xmath63 that appear in the tree . in our example , if the tree consists of root @xmath44 alone , we get ( using the assumption of lll ) @xmath129\\le",
    "z_i(1-z_j)(1-z_k)=\\\\     = \\frac{z_i}{1-z_i}[(1-z_i)(1-z_j)(1-z_k ) ] =     \\frac{z_i}{1-z_i}\\pr[\\text{$t$ appears in the gw - process } ]     \\end{gathered}\\ ] ] attaching the son @xmath119 to the root @xmath44 , we multiply the left hand side by @xmath130\\le z_j ( 1-z_i)=\\frac{z_j}{1-z_j}[(1-z_i)(1-z_j)];\\ ] ] in the right hand side we replace @xmath131 ( probability of not having the son @xmath132 by @xmath120 ( probability of having it ) and add new factors @xmath133 ( since @xmath119 has no sons in the tree ) , which gives exactly the same factor .",
    "the same happens when we add more vertices .",
    "this finishes the moser ",
    "tardos analysis .",
    "let us put all the steps together again : knowing that @xmath117\\le \\frac{z_i}{1-z_i},\\ ] ] we now sum these inequalities for all @xmath44 and get @xmath134=\\sum_{t\\in \\operatorname{\\mathcal{t } } } \\pr[\\text{$t$ appears during the algorithm}]\\le \\sum_i\\frac{z_i}{1-z_i},\\ ] ] as required .",
    "now we need to analyze the infinite case .",
    "we have already described the algorithm ; now we need to show that it indeed provides a layerwise computable mapping with required properties .",
    "this means that    * almost surely every variable @xmath55 is changed only finitely many times and , moreover , the probability of the event `` @xmath55 changes after first @xmath135 steps of the algorithm '' effectively converges to zero as @xmath136 ; * the final values of the variables avoid all @xmath63 ( make them false ) .",
    "to prove both statements , it is enough to show that @xmath137\\to 0\\ ] ] as @xmath138 , and the convergence is effective ( for every rational @xmath85 one can compute some @xmath0 such that this probability is less than @xmath88 when @xmath139 ) .",
    "indeed , every variable is involved in finitely many events ( and we can compute the list of these events ) ; note also that if some @xmath63 is false for the final values of the variables , first of these @xmath63 will be resampled infinitely many times ( and this happens with zero probability ) .",
    "we will show this effective convergence in two steps .",
    "first , consider some @xmath19 and the first @xmath19 events @xmath140 . while some of these events are true",
    ", the algorithm will never resample events @xmath118 with @xmath141 , so it behaves exactly as the finite moser ",
    "tardos algorithm applied to @xmath142 .",
    "so we can use the result proved earlier : if @xmath143 is the first moment when all @xmath142 are false , @xmath144 \\le \\sum_{i=1}^k \\frac{z_i}{1-z_i}\\ ] ] ( we do not need to use the additional factor @xmath145 yet ) .",
    "this means that @xmath143 is finite almost surely , and the probability of @xmath146 converges to @xmath47 effectively as @xmath136 ( due to tschebyshev inequality ) .",
    "however , it is not enough for our purposes . at the moment",
    "@xmath143 all the events @xmath142 are false , but some of the events @xmath118 with @xmath141 may be true .",
    "resampling such @xmath118 , we may change the variables that appear in @xmath142 , and this change may make some of these events true again , thus triggering further resampling operations .",
    "so we need a more detailed analysis .",
    "let us look how some @xmath63 among @xmath142 may become true again at some moment @xmath147 .",
    "this can happen only if some neighbor of @xmath63 , say , @xmath148 , was resampled between @xmath143 and @xmath135 . at that moment @xmath148 was true , so the are two possibilities :    * @xmath149 ( then @xmath148 can be true at the moment @xmath143 ) ; * @xmath150 , in this case @xmath148 was false at the moment @xmath143 and became true later .    in the second case ( @xmath148 was false and then became true )",
    "some neighbor of @xmath148 , say , @xmath151 , was resampled before @xmath148 became true .",
    "again , we have two cases @xmath152 and @xmath153 ; in the latter case @xmath151 became true because some neighbor @xmath154 of @xmath151 was resampled , etc .",
    "we come to the following crucial observation : _",
    "if @xmath63 is resampled after the moment @xmath143 , there is a chain of neighbors that starts with @xmath63 and ends with some @xmath105 with @xmath155 , and all elements of this chain appear in the tree for the @xmath63-resampling_. for fixed @xmath44 and very large @xmath19 the length of this chain ( and therefore the size of the tree ) is big , since all events that are close to @xmath63 are included in @xmath142 . and for big trees the additional factor @xmath145 decreases significantly the probability of their appearance .",
    "indeed , the inequality @xmath127\\le\\frac{z_i}{1-z_i}\\pr[\\text{$t$ appears in the gw - process}]\\ ] ] ( for every @xmath156 ) now gets an additional factor @xmath157 in the right hand side ( since we add factor @xmath145 for every vertex ) .",
    "we can now proceed as follows .",
    "fix some @xmath63 . for an arbitrary natural @xmath158 take @xmath19 large enough , so that @xmath142 contain all events that are at distance @xmath158 or less from @xmath63 in the neigborhood graph",
    ". then the event `` @xmath63 is resampled after time @xmath135 '' is covered by two events :    * @xmath159 ; * @xmath63 was resampled after @xmath143 .",
    "the probability of the first event ( @xmath160 ) effectively converges to @xmath47 as @xmath135 increases , so it remains to bound the probability of the second event .",
    "as we have seen , this event happens only if a large tree ( @xmath158 or more vertices ) with root @xmath44 appears during the algorithm , so this probability is bounded by @xmath161\\le\\\\ \\le \\sum_{t\\in\\operatorname{\\mathcal{t}}_i } \\alpha^m \\pr[\\text{$t$ appears during the gw - process}]\\le \\alpha^m,\\end{gathered}\\ ] ] so we get what we wanted .",
    "this finishes the proof of theorem  [ computablelll ] .",
    "we conclude the paper by showing some special cases where computable lll can be applied .",
    "a standard illustration for lll is the following result : _ a cnf where each clause contains @xmath158 different variables and has at most @xmath162 neighbors , is always satisfiable_. here neighbors are clauses that have common variables .",
    "this was about finite cnfs ; now we may consider _ effectively presented _ infinite cnfs .",
    "this means that we consider cnfs with countably many variables and clauses ( numbered by natural numbers ) ; we assume that for given @xmath44 we can compute the list of clauses where @xmath44th variable appears , and for given @xmath119 we can compute @xmath119th clause .",
    "similar argument can be applied in the case where there are clauses of different sizes .",
    "the condition now is as follows : for every variable there are at most @xmath168 clauses of size @xmath158 that involve this variable , where @xmath169 is some constant .",
    "note that now we do not assume that every variable appears in finitely many clauses , so the notion of effectively presented infinite cnf should be extended : we assume that for each @xmath44 and for each @xmath158 one can compute the list of clauses of size @xmath158 that include @xmath55 .",
    "[ variable - cnf ] for every @xmath169 there exists some @xmath50 such that every effectively presented infinite cnf where each variable appears in at most @xmath168 clauses of size @xmath158 ( for every @xmath158 ) and all clauses have size at least @xmath50 , has a computable satisfying assignment .",
    "let us consider first a special case when each variable appears only in finitely many clauses .",
    "then we are in the situation covered by theorem  [ computablelll ] , and we need only to choose the values of @xmath166 .",
    "these values will depend on the size of the clause : let us choose @xmath170 for clauses of size @xmath19 , where @xmath171 is some constant .",
    "in fact , any constant between @xmath172 and @xmath17 will work , so we can use , e.g. , @xmath173 .",
    "so we need to check ( for clause @xmath174 of some size  @xmath19 and for some constant @xmath77 ) that @xmath175 ( in fact we can omit the clause @xmath176 in the product , but this does not matter ) .",
    "note that for each of @xmath19 variables in @xmath174 there are at most @xmath168 clauses of size @xmath158 that involve it .",
    "so together @xmath174 has at most @xmath177 neighbors of size @xmath158 .",
    "so it is enough to show that @xmath178 taking @xmath19th roots ( we replace @xmath179{\\alpha}$ ] by @xmath145 , but this only makes the requirement stronger ) and using that @xmath180 , we see that it is enough to show that @xmath181 since the series @xmath182 is converging , this is guaranteed for large @xmath50 and for @xmath145 sufficiently close to @xmath17 .",
    "the general case is easily reducible to this special one .",
    "indeed , fix some @xmath183 and delete from each clause @xmath184-fraction of its variables with minimal indices .",
    "the cnf becomes only harder to satisfy .",
    "but if @xmath184 is small enough , the condition of the theorem ( the number of clauses with @xmath158 variables containing a given variable is bounded by @xmath168 ) is still true for some @xmath185 , because the deletion makes the size of clauses only slightly smaller and decreases the set of clauses containing a given variable . and",
    "in this modified cnf each variable appears only in clauses of limited size ( it is deleted from all large enough clauses ) .",
    "let us note an important special case .",
    "assume that @xmath49 is a set of binary strings that contains ( for some fixed @xmath186 and for every @xmath158 ) at most @xmath168 strings of length @xmath158 .",
    "then one can use lll to prove the existence of an infinite ( or bi - infinite ) sequence @xmath9 and a number @xmath50 such that @xmath9 does not have substrings in @xmath49 of length greater than @xmath50 .",
    "there are several proofs of this statement ; the most direct one is given in  @xcite ; one may also use lll or kolmogorov complexity , see  @xcite .",
    "joseph miller noted that his proof ( given in  @xcite ) can be used to show that for a decidable ( computable ) set @xmath49 with this property one can find a computable @xmath9 that avoids long substrings in @xmath49 .",
    "konstantin makarychev extended this argument to bi - infinite strings ( personal communication ) .",
    "now this result becomes a special case of corollary  [ variable - cnf ] : places in the sequence correspond to variables , each forbidden string gives a family of clauses ( one per each starting position ) , and there is at most @xmath187 clauses of size @xmath158 that involve a given position ( and this number is bounded by @xmath188 for slightly bigger @xmath189 and large enough @xmath158 ) .",
    "moreover , we can do the same for 2-dimensional case : having a decidable set @xmath49 of rectangular patterns that contains at most @xmath168 different patterns of size (=  area ) @xmath158 , one can find a number @xmath50 and a computable 2d configuration ( a mapping @xmath190 ) that does not contain patterns from @xmath49 of size @xmath50 or more .",
    "( it is not clear how to get this result directly , without using moser  tardos technique . )",
    "rumyantsev a. , forbidden substrings , kolmogorov complexity and almost periodic sequences , _",
    "stacs 2006 , 23rd annual symposium on theoretical aspects of computer science _ , marseille , france ,",
    "february 2325 , 2006 .",
    "lecture notes in computer science , 3884 , springer , 2006 , p.  396407 .",
    "zvonkin a.  k. , levin l.  a. , the complexity of finite objects and the development of the concepts of information and randomness by means of the theory of algorithms , uspekhi matematicheskikh nauk , 1970 , v.  25 , no .  6  ( 156 ) , p.  85127 ."
  ],
  "abstract_text": [
    "<S> a nonconstructive proof can be used to prove the existence of an object with some properties without providing an explicit example of such an object . </S>",
    "<S> a special case is a probabilistic proof where we show that an object with required properties appears with some positive probability in some random process . </S>",
    "<S> can we use such arguments to prove the existence of a _ </S>",
    "<S> computable _ infinite object ? </S>",
    "<S> sometimes yes : following  @xcite , we show how the notion of a layerwise computable mapping can be used to prove a computable version of lovsz local lemma . </S>"
  ]
}