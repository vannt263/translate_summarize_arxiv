{
  "article_text": [
    "an increasing number of databases are derived , extracted , or curated from disparate data sources .",
    "consequently , it becomes more and more important to provide data consumers with mechanisms that will allow them to gain an understanding of data that they are confronted with .",
    "an essential functionality towards this goal is the capability to provide meaningful explanations about why data is present or missing form the result of a query .",
    "explanations help data consumers gauge how much trust one can place on the result .",
    "perhaps more importantly , they provide useful information for debugging the query or data that led to incorrect results .",
    "this is particularly the case in scenarios where complex data analysis tasks are specified through large collections of nested views ( i.e. , views that may be defined in terms of other views ) .",
    "for example , schemas with nested view definitions and integrity constraints capture the core of logiql  @xcite ( where view definitions may , in general , involve not only relational operations , but also aggregation , machine learning and mathematical optimization tasks ) .",
    "logiql is a language developed and used at logicblox @xcite for developing data - intensive `` self service '' applications involving complex data analytics workflows .",
    "similar recent industrial systems include datomic and google s yedalog  @xcite . in each of these systems , nested view definitions ( or , datalog programs )",
    "are used to specify complex workflows to drive data - analytics tasks .",
    "explanations for unexpected query results ( such as an unexpected tuple or a missing tuple ) are very useful in such settings , since the source of an error can be particularly hard to track .",
    "there has been considerable research on the topic of deriving explanations for why a tuple belongs to the output of a query .",
    "early systems were developed in  @xcite to provide explanations for answers to logic programs in the context of a deductive database .",
    "the presence of a tuple in the output is explained by enumerating all possible derivations , that is , instantiations of the logic rules that derive the answer tuple . in  @xcite",
    ", the system also explains missing answers , by providing a partially instantiated rule , based on the missing tuple , and leaving the user to figure out how the rest of the rule would have to be instantiated . in the last decade or so",
    ", there has been significant efforts to characterize different notions of provenance ( or lineage ) of query answers ( see , e.g. ,  @xcite ) which can also be applied to understand why an answer is in the query result.=-1    there have also been extensive studies on the _ why - not problem _",
    "( e.g. , more recent studies include @xcite ) .",
    "the why - not problem is the problem of explaining why an answer is missing from the output . since  @xcite ,",
    "the _ why - not problem _ was also studied in  @xcite in the context of debugging results of data extracted via select - project - join queries , and , subsequently , a larger class of queries that also includes union and aggregation operators . unlike  @xcite which is geared towards providing explanations for answers and missing answers , the goal in  @xcite is to propose modifications to underlying database @xmath0 , yielding another database @xmath1 based on the provenance of the missing tuple , constraints , and trust specification at hand , so that the missing tuple appears in the result of the same query @xmath2 over the updated database @xmath1 .",
    "in contrast to the _ data - centric _ approach of updating the database to derive the missing answer , another line of research  @xcite follows a _ query - centric _ approach whereby the query @xmath2 at hand is modified to @xmath3 ( without modifying the underlying database ) so that the missing answer appears in the output of @xmath4 .    * a new take on why - not questions : * in this paper , we develop a novel foundational framework for why - not explanations that is principally different from prior approaches .",
    "our approach is neither data - centric nor query - centric .",
    "instead , we derive high - level explanations via an ontology that is either provided , or is derived from the data or schema .",
    "our immediate goal is not to compute repairs of the underlying database or query so that the missing answer would appear in the result .",
    "rather , as in  @xcite , our primary goal is to provide understandable explanations for why an answer is missing from the query result .",
    "as we will illustrate , explanations that are based on an ontology have the potential to be high - level and provide meaningful insight to why a tuple is missing from the result .",
    "this is because an ontology abstracts a domain in terms of concepts and relationships amongst concepts .",
    "hence , explanations that are based on concepts and relationships from an ontology will embody such high - level abstractions .",
    "as we shall describe , our work considers two cases .",
    "the first is when an ontology is provided externally , in which case explanations will embody external knowledge about the domain .",
    "the second is when an ontology is not provided . for the latter , we allow an ontology to be derived from the schema , and hence explanations will embody knowledge about the domain through concepts and relationships that are defined over the schema.=-1    formally , an explanation for why a tuple @xmath5 is not among the results of a query @xmath6 , in our framework , is a tuple of concepts from the ontology whose extension includes the missing tuple @xmath5 and , at the same time , does not include any tuples from @xmath6 .",
    "for example , a query may ask for all products that each store has in stock , in the form of ( product i d , store i d ) pairs , from the database of a large retail company .",
    "a user may then ask why is the pair _ ( p0034 , s012 ) _ not among the result of the query .",
    "p0034 _ refers to a bluetooth headset product and _ s012 _ refers to a particular store in san francisco . if _",
    "p0034 _ is an instance of a concept _ bluetooth headsets _ and _ s012 _ is an instance of a concept _ stores in san francisco _ , and suppose that no pair @xmath7 , where @xmath8 is an instance of _ bluetooth headset _ and @xmath9 is an instance of _ stores in san francisco _ , belongs to the query result .",
    "then the pair of concepts ( _ bluetooth headset _ , _ stores in san francisco _ ) is an explanation for the given why - not question .",
    "intuitively , it signifies the fact that `` _ none of the stores in san francisco has any bluetooth headsets on stock _ '' .    there may be multiple explanations for a given why - not question . in the above example",
    ", this would be the case if , for instance , _ s012 _ belongs also to a more general concept _ stores in california _ , and that none of the stores in california have bluetooth headsets on stock .",
    "our goal is to compute a _ most - general explanation _",
    ", that is , an explanation that is not strictly subsumed by any other explanation .",
    "we study the complexity of computing a most - general explanation to a why - not question .",
    "formally , we define a _ why - not instance _ ( or , _ why - not question _ ) to be a quintuple @xmath10 where @xmath11 is a _ schema _ , which may include integrity constraints ; @xmath0 is an instance of @xmath11 ; @xmath2 is a query over @xmath11 ; _ ans _ = @xmath6 ; and @xmath12 .    as mentioned earlier , a particular scenario where why - not questions easily arise is when querying schemas that include a large collection of views , and where each view may be nested , that is , defined in terms of other views .",
    "our framework captures this setting , since view definitions can be expressed by means of constraints .",
    "our framework supports a very general notion of an ontology , which we call _",
    "@xmath11-ontologies_. for a given relational schema @xmath11 , an @xmath11-ontology is a triple @xmath13 which defines the set of concepts , the subsumption relationship between concepts , and respectively , the extension of each concept w.r.t .",
    "an instance of the schema @xmath11 .",
    "we use this general notion of an @xmath11-ontology to formalize the key notions of _ explanations _ and _ most - general explanations _ , and we show that @xmath11-ontologies capture two different types of ontologies .    the first type of ontologies we consider are those that are defined externally , provided that there is a way to associate the concepts in the externally defined ontology to the instance at hand . for example , the ontology may be represented in the form of a ontology - based data access ( obda ) specification  @xcite . more precisely , an obda specification consists of a set of concepts and subsumption relation specified by means of a description logic terminology , and a set of _ mapping assertions _ that relates the concepts to a relational database schema at hand .",
    "every obda specification induces a corresponding @xmath11-ontology .",
    "if the concepts and subsumption relation are defined by a tbox in a tractable description logic such as _ _ dl - lite__@xmath14 , and the mapping assertions are global - as - view ( gav ) assertions , the induced @xmath11-ontology can in fact be computed from the obda specification in polynomial time .",
    "we then present an algorithm for computing all most - general explanations to a why - not question , given an external @xmath11-ontology .",
    "the algorithm runs in polynomial time when the arity of the query is bounded , and it executes in exponential time in general .",
    "we show that the exponential running time is unavoidable , unless p@xmath15np , because the problem of deciding whether or not there exists an explanation to a why - not question given an external @xmath11-ontology is np - complete in general .",
    "the second type of ontologies that we consider are ontologies that are derived either ( a ) from a schema @xmath11 , or ( b ) from an instance of the schema . in both cases ,",
    "the concepts of the ontology are defined through concept expressions in a suitable language @xmath16 that we develop .",
    "specifically , our concepts are obtained from the relations in the schema , through selections , projections , and intersection .",
    "the difference between the two cases lies in the way the subsumption relation @xmath17 is defined . in the former ,",
    "a concept @xmath18 is considered to be subsumed in another concept @xmath19 if the extension of @xmath18 is contained in the extension of @xmath19 over all instances of the schema . for the latter ,",
    "subsumption is considered to hold if the extension of @xmath18 is contained in the extension of @xmath19 with respect to the given instance of the schema .",
    "the @xmath11-ontology induced by a schema @xmath11 , or instance @xmath0 , denoted @xmath20 or @xmath21 , respectively , is typically infinite , and is not intended to be materialized .",
    "instead , we present an algorithm for directly computing a most - general explanation with respect to @xmath21 .",
    "the algorithm runs in exponential time in general . however",
    ", if the schema is of bounded arity , the algorithm runs in polynomial time . as for computing most - general explanations with respect to @xmath20 , we identify restrictions on the integrity constraints under which the problem is decidable , and we present complexity upper bounds for these cases",
    ".    * more related work : * the use of ontologies to facilitate access to databases is not new .",
    "a prominent example is obda , where queries are either posed directly against an ontology , or an ontology is used to enrich a data schema against which queries are posed with additional relations ( namely , the concepts from the ontology ) @xcite .",
    "answers are computed based on an open - world assumption and using the mapping assertions and ontology provided by the obda specification . as we described above",
    ", we make use of obda specifications as a means to specify an external ontology and with a database instance through mapping assertions .",
    "however , unlike in obda , we consider queries posed against a database instance under the traditional closed - world semantics , and the ontology is used only to derive why - not explanations .",
    "the problems of providing why explanations and why - not explanations have also been investigated in the context of obda in @xcite and @xcite , respectively .",
    "the why - not explanations of  @xcite follow the _ data - centric _ approach to why - not provenance as we discussed earlier where their goal is to modify the assertions that describe the extensions of concepts in the ontology so that the missing tuple will appear in the query result .",
    "there has also been prior work on extracting ontologies from data .",
    "for example , in @xcite , the authors considered heuristics to automatically generate an ontology from a relational database by defining project - join queries over the data .",
    "other examples on ontology extraction from data include publishing relational data as rdf graphs or statements ( e.g. , d2rq  @xcite , triplify  @xcite ) .",
    "we emphasize that our goal is not to extract and materialize ontologies , but rather , to use an ontology that is derived from data to compute why - not explanations .",
    "* outline : * after the preliminaries , in section  [ sec : thewhynotprovenanceproblem ] we present our framework for why - not explanations . in section  [ sec : ontology ] we discuss in detail the two ways of obtaining an @xmath11-ontology . in section  [ sec : algorithmsforwhynotexplanations ] we present our main algorithmic results . finally , in section  [ sec : variationsoftheframework ] , we study variatations of our framework , including the problem of producing _ short _ most - general explanations , and alternative notions of _ explanation _ , and of what it means to be _ most general_.",
    "a _ schema _ is a pair @xmath22 , where @xmath11 is a set @xmath23 of relation names , where each relation name has an associated arity , and @xmath24 is a set of first - order sentences over @xmath11 , which we will refer as _",
    "integrity constraints_. abusing the notation , we will write @xmath11 for the schema @xmath22 . a _ fact _ is an expression of the form @xmath25 where @xmath26 is a relation of arity @xmath27 , and for @xmath28 , we have @xmath29 , where @xmath30 is a countably infinite set of constants . we assume a dense linear order @xmath31 on @xmath30 .",
    "an _ attribute _",
    "@xmath32 of an @xmath27-ary relation name @xmath26 is a number @xmath33 such that @xmath28 .",
    "for a fact @xmath34 where @xmath35 , we sometimes write @xmath36 to mean the tuple consisting of the @xmath37th , ... , @xmath38th constants in the tuple @xmath39",
    ", that is , the value @xmath40 . an _ atom over @xmath11 _ is an expression @xmath41 , where @xmath42 and every @xmath43 is a variable or a constant .    a _ database instance _ , or simply an _ instance _ , @xmath0 over @xmath11 is a set of facts over @xmath11 satisfying the integrity constraints @xmath24 .",
    "equivalently , an instance @xmath0 is a map that assigns to each @xmath27-ary relation name @xmath26 a finite set of @xmath27-tuples over @xmath30 such that the integrity constraints are satisfied . by @xmath44",
    "we denote the set of these tuples .",
    "we write @xmath45 to denote the set of all database instances over @xmath11 , and @xmath46 to denote the active domain of @xmath0 , i.e. , the set of all constants occurring in facts of @xmath0 .",
    "* queries  * a _ conjunctive query _ ( cq ) over @xmath11 is a query of the form @xmath47 where @xmath48 is a conjunction of atoms over @xmath11 . given an instance @xmath0 and a cq @xmath2 , we write @xmath6 to denote the set of answers of @xmath2 over @xmath0 . in this paper",
    "we allow conjunctive queries containing comparisons to constants , that is , comparisons of the form @xmath49 , where @xmath50 and @xmath51 .",
    "we show that all upper bounds hold for the case of cqs with such comparisons , and all lower bounds hold without the use of comparisons ( unless explicitly specified otherwise ) .",
    "we do _ not _ allow comparisons between variables .",
    "* integrity constraints  * in this paper we consider different classes of integrity constraints , including functional dependencies and inclusion dependencies .",
    "we also consider @xmath52-view definitions and nested @xmath52-view definitions , which can be expressed using integrity constraints as well .    a _ functional dependency _",
    "( fd ) on a relation @xmath42 is an expression of the form @xmath53 where @xmath54 and @xmath55 are subsets of the set of attributes of @xmath56 .",
    "we say that an instance @xmath0 over @xmath11 satisfies the fd if for every @xmath57 and @xmath58 from @xmath59 if @xmath60 for every @xmath61 , then @xmath62 for every @xmath63 .    an _ inclusion dependency _",
    "( i d ) is an expression of the form @xmath64",
    "\\subseteq s[b_1 , \\ldots , b_n]\\ ] ] where @xmath65 , each @xmath66 and @xmath67 is an attribute of @xmath56 and @xmath68 respectively .",
    "we say that an instance @xmath0 over @xmath11 satisfies the i d if @xmath69    note that functional and integrity constraints can equivalently be written as first - order sentences  @xcite .    * view definitions * to simplify presentation , we treat view defintions as a special case of integrity constraints .",
    "a set of integrity constraints @xmath24 over @xmath11 is said to be a _ collection of @xmath52-view definitions _ if there exists a partition @xmath70 such that for every @xmath71 , @xmath24 contains exactly one first - order sentence of the form : @xmath72 where each @xmath73 is a conjunctive query ( with comparisons to constants ) over @xmath74 .",
    "similarly , a set of integrity constraints @xmath24 over @xmath11 is said to be a _ collection of nested @xmath52-view definitions _ if there exists a partition @xmath70 such that for every @xmath71 , @xmath24 contains exactly one first - order sentence of the form ( * ) , where each @xmath73 is now allowed to be a conjunctive query over @xmath75 , but subject to the following acyclicity condition .",
    "let us say that @xmath71 _ depends on _ @xmath76 , if @xmath56 occurs in the view definition of @xmath77 , that is , in the sentence of @xmath24 that is of the form ( * ) for @xmath77 .",
    "we require that the `` depends on '' relation is acyclic .",
    "if , in the view definition of every @xmath78 , each disjunct @xmath73 contains at most one atom over @xmath79 , then we say that @xmath24 is a collection of _ linearly _ nested @xmath52-view definitions .",
    "note that a collection of nested @xmath52-view definitions ( in the absence of comparisons ) can be equivalently viewed as a non - recursive datalog program and vice versa  @xcite .",
    "in particular , a collection of linearly nested @xmath52-view definitions corresponds to a linear non - recursive datalog program .",
    "[ ex : dws ] as an example of a schema , consider @xmath70 with the integrity constraints in figure  [ fig : example - dataworkspace ] .",
    "an instance @xmath0 of the schema @xmath11 is given in figure  [ fig : train - instance ] .",
    "@xmath80    @xmath81    @xmath82    @lll@ @xmath52-view definitions : +   + bigcity(@xmath8 ) & @xmath83 & cities(@xmath8,@xmath9,@xmath84,@xmath85 ) @xmath86 @xmath87 + europeancountry(@xmath84 ) & @xmath83 & cities(@xmath8,@xmath9,@xmath88,@xmath85 ) @xmath86 @xmath89 + reachable(@xmath8,@xmath9 ) & @xmath83 & train - connections(@xmath8,@xmath9 ) @xmath90 + & & ( train - connections(@xmath8,@xmath84 ) @xmath91 train - connections ( @xmath84,@xmath9 ) ) +    @xmath92 } & \\subseteq & \\text{train - connections[city\\_from ] } \\\\",
    "\\text{train - connections[city\\_from ] } & \\subseteq & \\text{cities[name ] } \\\\",
    "\\text{train - connections[city\\_to ] } & \\subseteq & \\text{cities[name ] }   \\end{array}$ ]    @ll@ * cities * & * train - connections * +    [ cols=\"<,<,<,<\",options=\"header \" , ]     thm [ th : table ] let @xmath93 be one of the different classes of schemas with integrity constraints listed in table  [ tbl : subsumption - complexity ] .",
    "the complexity of the problem to decide , given a schema @xmath94 in @xmath93 and two @xmath95 concept expressions @xmath96 , @xmath97 , whether @xmath98 , is as indicated in the second column of the corresponding row in table  [ tbl : subsumption - complexity ] .",
    "for example , given two concepts @xmath96 , @xmath97 , and a schema @xmath22 where @xmath24 is a collection of nested @xmath52-view definitions , the complexity of deciding @xmath98 is @xmath99-complete .",
    "the lower bound already holds for concepts specified in @xmath100 .",
    "we conclude this section with an analysis of the number of distinct concepts that can be formulated in a given concept language and an example that illustrates explanations that can be computed from such derived ontologies .",
    "propsizeconceptlanguage[size - concept - language ] given a schema @xmath94 and a finite set of constants @xmath101 , the number of unique concepts ( modulo logical equivalence )    * in @xmath102 $ ] is polynomial in the size of @xmath94 and @xmath103 , * in selection - free or intersection - free @xmath104 $ ] is single exponential in the size of @xmath94 and @xmath103 .",
    "* in @xmath104 $ ] is double exponential in the size of @xmath94 and @xmath103 .",
    "[ ex : explanationswithderived ] let @xmath94 and @xmath0 be the schema and instance from figure  [ fig : example - dataworkspace ] and figure  [ fig : train - instance ] .",
    "suppose the concept language @xmath95 is used to define among others the concepts from figure  [ fig : concept - examples ] .",
    "the following concept subsumptions can be derived from @xmath94 .",
    "note that subsumption @xmath105 implies @xmath106 .",
    "@xmath107 the first and second subsumptions follow from definitions .",
    "the third one holds because according to @xmath108 , a bigcity is a city with population more than 5 million .",
    "the fourth subsumption follows from the inclusion dependency that each bigcity must have a train departing from it .",
    "there are subsumptions that hold in @xmath21 but not in @xmath109 .",
    "for instance ,    @xmath110 + @xmath111    holds w.r.t .",
    "@xmath21 , where @xmath0 is the instance given in figure  [ fig : train - instance ] , but does not hold w.r.t @xmath109 , since one can construct an instance where not all cities that are reachable from amsterdam are reachable from berlin .",
    "we now give examples of most - general explanations w.r.t .",
    "@xmath109 and @xmath21 . as before ,",
    "let @xmath112 = @xmath113 train - connections(@xmath114 ) @xmath86 train - connections(@xmath115 ) be a query with @xmath6 = @xmath116 @xmath117 .",
    "we would like to explain why @xmath118amsterdam , new york@xmath119 using the derived ontologies @xmath109 and @xmath21 . note that if @xmath120 is an explanation w.r.t .",
    "@xmath109 , then it is also an explanation w.r.t .",
    "@xmath21 and vice versa .",
    "some possible explanations are : @xmath121 for example , @xmath122 states the reason is that amsterdam is a european city and new york is a city that has a train connection to san francisco , and there is no train connection between such cities via a city .",
    "the trivial explanation @xmath123 is less general than any other explanation w.r.t @xmath109 ( and @xmath21 too ) .",
    "it can be verified that @xmath124 and @xmath125 are most - general explanations w.r.t both @xmath109 and @xmath21 . in particular ,",
    "@xmath126 and @xmath127 , but @xmath128 and @xmath129 since there might be an instance of @xmath94 where netherlands is not in europe or where berlin is reachable from a non - european city .",
    "@xmath80    in general , if @xmath120 is an explanation w.r.t",
    ". @xmath21 then @xmath120 is also an explanation w.r.t .",
    "@xmath109 , and vice versa .",
    "the following proposition also describes the relationship between most - general explanations w.r.t @xmath109 and @xmath21 .",
    "propmgerelationships let @xmath94 be a schema , and let @xmath0 be an instance of @xmath94 .    *",
    "every explanation w.r.t .",
    "@xmath109 is an explanation w.r.t .",
    "@xmath21 and vice versa . * a most - general explanation w.r.t  @xmath109 is not necessarily a most - general explanation w.r.t .",
    "@xmath21 , and likewise vice versa .",
    "the statement @xmath130 follows from definition  [ dfn : explanation ] and the definition of @xmath131 for @xmath109 and @xmath21 .",
    "that is , @xmath131 is the same on the input instance @xmath0 for both @xmath109 and @xmath21 , and the conditions of definition  [ dfn : explanation ] use only the value of @xmath131 on @xmath0 .",
    "going back to example [ ex : explanationswithderived ] , @xmath122 is a most - general explanation w.r.t .",
    "@xmath109 , but it is not a most - general explanation w.r.t .",
    "@xmath21 ( since @xmath132 is a strictly more general explanation than @xmath122 w.r.t .",
    "@xmath21 ) .",
    "thus , the first direction of @xmath133 holds . for the other direction of @xmath133 ,",
    "consider @xmath134 which is a most - general explanation w.r.t .",
    "but it holds that @xmath135 and @xmath125 is an explanation . note that @xmath125 and @xmath134 are equivalent w.r.t .",
    "next , we formally introduce the ontology - based why - not problem , which was informally described in section  [ sec : thewhynotprovenanceproblem ] , and we define algorithms for computing most - general explanations .",
    "we start by defining the notion of a why - not instance ( or why - not question ) .",
    "let @xmath94 be a schema , @xmath0 an instance of @xmath94 , @xmath2 an @xmath136-ary query over @xmath0 and @xmath137 a tuple of constants such that @xmath138 .",
    "we call the quintuple @xmath139 , where @xmath140 , a _ why - not instance _ or a _ why - not question_.    in a why - not instance , the answer set _ ans _ of @xmath2 over @xmath0 is assumed to have been computed already .",
    "this corresponds closely to the scenario under which why - not questions are posed where the user requests explanations for why a certain tuple is missing in the output of a query , which is computed a priori .",
    "note that since _",
    "ans_=@xmath6 is part of a why - not instance , the complexity of evaluating @xmath2 over @xmath0 does not affect the complexity analysis of the problems we study in this paper .",
    "in addition , observe that although a query @xmath2 is part of a why - not instance , the query is not directly used in our derivation of explanations for why - not questions with ontologies .",
    "however , the general setup accomodates the possibility to consider @xmath2 directly in the derivation of explanations and this is part of our future work",
    ".    we will study the following algorithmic problems concerning most - general explanations for a why - not instance .",
    "the existence - of - explanationproblem is the following decision problem : given a why - not instance @xmath139 and an @xmath11-ontology @xmath141 consistent with @xmath0 , does there exist an explanation for @xmath142 w.r.t .",
    "@xmath141 ?",
    "the check - mgeproblem is the following decision problem : given a why - not instance @xmath139 , an @xmath11-ontology @xmath141 consistent with @xmath0 , and a tuple of concepts @xmath143 , is the given tuple of concepts a most - general explanation w.r.t .",
    "@xmath141 for @xmath144 ?",
    "the compute - one - mgeproblem is the following computational problem : given a why - not instance @xmath139 and an @xmath11-ontology @xmath141 consistent with @xmath0 , find a most - general explanation w.r.t .",
    "@xmath141 for @xmath142 , if one exists .",
    "note that deciding the existence of an explanation w.r.t .",
    "a finite @xmath11-ontology is equivalent to deciding existence of a most - general explanation w.r.t .",
    "the same @xmath11-ontology .",
    "thus , our approach to the why - not problem makes use of @xmath11-ontologies . in particular , our notion of a `` best explanation '' is a _ most - general explanation _ , which is defined with respect to an @xmath11-ontology .",
    "we study the problem in three flavors : one in which the @xmath11-ontology is obtained from an external source , and thus it is part of the input , and two in which the @xmath11-ontology is not part of the input , and is derived , respectively , from the schema @xmath94 , or from the instance @xmath0 .",
    "we start by studying the case of computing ontology - based why - not explanations w.r.t . an external @xmath11-ontology .",
    "we first study the complexity of deciding whether or not there exists an explanation w.r.t .",
    "an external @xmath11-ontology .",
    "thmnpcpdec[np - comp - decision ]     1 .",
    "the problem check - mgeis solvable in ptime .",
    "2 .   the problem existence - of - explanationis np - complete .",
    "it remains np - complete even for bounded schema arity .",
    "intuitively , to check if a tuple of concepts is a most - general explanation , we can first check in ptimeif it is an explanation . then , for each concept in the explanation , we can check in ptimeif it is subsumed by some other concept in @xmath141 such that by replacing it with this more general concept , the tuple of concepts remains an explanation . the membership in npis due to the fact that we can guess a tuple of concepts of polynomial size and verify in ptimethat it is an explanation .",
    "the lower bound is by a reduction from the set cover problem .",
    "our reduction uses a query of unbounded arity and a schema of bounded arity .",
    "as we will show in theorem  [ correct - running - naive ] , the problem is in ptimeif the arity of the query is fixed .    in light of the above result",
    ", we define an algorithm , called the @xmath145 , which is an exptimealgorithm for solving the compute - one - mgeproblem .",
    "let @xmath146 for all @xmath147    let @xmath148    return @xmath149 [ alg : computeall ]    this algorithm first generates the set of all possible explanations , and then iteratively reduces the set by removing the tuples of concepts that are less general than some tuple of concepts in the set . in the end , only most - general explanations are returned . at first , in line 1 , for each element of the tuple @xmath150 , we build the set @xmath151 containing all the concepts in @xmath152 whose extension contains @xmath153 .",
    "then , in line 2 , we build the set of all possible explanations by picking a concept in @xmath151 for each position in @xmath5 , and by discarding the ones that have a non empty intersection with the answer set @xmath154 . finally , in lines 3 - 5 , we remove from the set those explanations that have a strictly more general explanation in the set .",
    "we now show that exhaustive search algorithmis correct ( i.e. it outputs the set of all most - general explanations for the given why - not instance w.r.t . to the given @xmath11-ontology ) , and runs in exponential time in the size of the input .",
    "thmnaive [ correct - running - naive ] let the why - not instance @xmath139 and the @xmath11-ontology @xmath141 be an input to exhaustive search algorithmand let @xmath155 be the corresponding output .",
    "the following hold :    1 .",
    "@xmath149 is the set of all most - general explanations for @xmath142 ( modulo equivalence ) ; 2 .",
    "exhaustive search algorithmruns in exptimein the size of the input ( in ptimeif we fix the arity of the input query ) .",
    "theorem  [ correct - running - naive ] , together with theorem  [ dl - lite - gav - complexity ] , yields the following corollary ( recall that , by construction of @xmath156 , it holds that every input instance @xmath0 is consistent with @xmath156 ) .",
    "there is an algorithm that takes as input a why - not instance @xmath139 and an obda specification @xmath157 , where @xmath158 is a _ _ dl - lite__@xmath14 tbox and @xmath159 is a set of gav mappings , and computes all the most - general explanations for @xmath160 w.r.t .",
    "the @xmath11-ontology @xmath156 in exptimein the size of the input ( in ptimeif the arity of the @xmath2 is fixed ) .",
    "we now study the why - not problem w.r.t .",
    "an @xmath11-ontology @xmath161 that is derived from an instance .",
    "first , note that the presence of nominals in the concept language guarantees a trivial answer for the existence - of - explanation w.r.t .",
    "@xmath21 problem .",
    "an explanation always exists , namely the explanation with nominals corresponding to the constants of the tuple @xmath5 .",
    "in fact , a _ most - general explanation _ always exists , as follows from the results below .",
    "= -1    the compute - one - mge w.r.t .",
    "@xmath21 is the following computational problem : given a why - not instance @xmath139 , find a most - general explanation w.r.t .",
    "@xmath21 for @xmath142 , where @xmath21 is the @xmath11-ontology that is derived from @xmath0 , as defined in section  [ derivingontology ] .",
    "first , we state an important proposition , that underlies the correctness of the algorithms that we will present .",
    "the following proposition shows that , when we search for explanations w.r.t .",
    "@xmath21 , we can always restrict our attention to a particular finite restriction of this ontology .",
    "propactivedomain[prop - active - domain ] let @xmath139 be a why - not instance . if @xmath120 is an explanation for @xmath142 w.r.t .",
    "@xmath21 ( resp .",
    "@xmath109 ) , then there exists an explanation @xmath162 for @xmath142 such that @xmath163 } e'$ ] ( resp . @xmath164 } e'$ ] ) , where @xmath165 and each constant in @xmath162 belongs to @xmath166 .    in our proof , we iteratively reduce the number of constants occurring in the explanation .",
    "that is , for every explanation @xmath120 with concepts containing constants outside of @xmath167 , we produce a new explanation @xmath162 which is more general than @xmath120 and which contains less constants outside of @xmath168 .",
    "notice that since , in principle , it is possible to materialize the ontology @xmath169 $ ] ( i.e. , to explicitly compute all the concepts @xmath152 in the ontology , the subsumption relation @xmath106 , and the extension @xmath131 ) , the exhaustive search algorithm , together with proposition  [ prop - active - domain ] , give us a method for solving compute - one - mge w.r.t .",
    "in particular , given a schema , exhaustive search algorithmsolves compute - one - mge w.r.t .",
    "@xmath21 in 2exptime(in exptimeif the arity of @xmath2 is fixed ) .",
    "this is because to find a most - general explanation w.r.t @xmath21 , it is sufficient to restrict to the concept language @xmath104 $ ] and its fragments , where @xmath170",
    ". then compute - one - mge w.r.t .",
    "@xmath21 is solvable in 2exptime follows from the fact that the @xmath11-ontology @xmath169 $ ] is computable in at most 2exptime .",
    "we now present a more effective algorithm for solving compute - one - mge w.r.t .",
    "( see algorithm  [ alg : greedy ] . )",
    "we start by introducing the notion of a _",
    "least upper bound _ of a set of constants @xmath54 w.r.t .",
    "an instance @xmath0 , denoted by @xmath171 .",
    "this , intuitively , corresponds to the most - specific concept whose extension contains all constants of @xmath54 .",
    "we first consider the case in which @xmath171 is expressed using selection - free @xmath95 concepts .",
    "the following lemma states two important properties of @xmath171 that are crucial for the correctness of algorithm  [ alg : greedy ] .",
    "lemlubnosel[lub - no - selection ] given an instance @xmath0 of schema @xmath11 and a set of constants @xmath54 , we can compute in polynomial time a selection - free @xmath95 concept , denoted @xmath171 , that is the smallest concept whose extension contains all the elements in @xmath54 definable in the language . in particular , the following hold :    1 .",
    "@xmath172 , 2 .",
    "there is no concept @xmath19 in selection - free @xmath95 such that @xmath173 and @xmath174 .",
    "we are now ready to introduce the algorithm .",
    "we will start with a high - level description of the idea behind it .",
    "the algorithm navigates through the search space of possible explanations using an incremental search strategy and makes use of the above defined notion of @xmath175 .",
    "we start with an explanation that has , in each position , the @xmath175 of the constant ( i.e. , nominal ) that occurs in that position .",
    "then , we try to construct a more general explanation by expanding the set of constants considered by each @xmath175 .",
    "notice that incremental search algorithmproduces explanations which are tuples of conjunctions of concepts .",
    "therefore it produces an explanation whose concepts are concept expressions in the language @xmath95 or selection - free @xmath95 .",
    "we will study the behavior of the algorithm in each of these cases separately .",
    "[ alg : greedy ]    let @xmath170    let @xmath176 s.t . each @xmath177 . _",
    "_    let @xmath178 s.t .",
    "each @xmath179 .",
    "_ _    return @xmath120    first , we focus on the case in which incremental search algorithmproduces most - general explanations using selection - free @xmath95 concepts .",
    "we show that the algorithm is correct , i.e. , that it outputs an explanation for @xmath160 w.r.t .",
    "@xmath21 , and that it runs in polynomial time with selection - free @xmath95 .",
    "thmgreedynosel [ greedy - no - sel ] let the why - not instance @xmath139 be an input to incremental search algorithmand @xmath120 the corresponding output .",
    "the following holds :    1 .",
    "@xmath120 is a most - general explanation for @xmath142 w.r.t .",
    "@xmath180 , where @xmath152 is selection - free @xmath95 ; 2 .",
    "incremental search algorithmruns in ptimein the size of the input .",
    "now we extend our analysis of incremental search algorithmto the general case in which it works with @xmath95 .",
    "first , we state an analogue of lemma  [ lub - no - selection ] for @xmath95 .",
    "lemlubsel[lub - selection ] given an instance @xmath0 of @xmath11 and a set of constants @xmath54 , we can compute in exponential time a @xmath95 concept , denoted @xmath181 , that is the smallest concept whose extension contains all the elements in @xmath54 definable in the language .",
    "such concept is polynomial - time computable for bounded schema arity .",
    "in particular , the following hold :    1 .",
    "@xmath182 , 2 .",
    "there is no concept @xmath19 in @xmath95 such that @xmath183 and @xmath174 .    by incremental search algorithm with selectionswe",
    "will refer to the algorithm obtained from incremental search algorithmby replacing @xmath171 with @xmath181 in line 3 and line 7 .",
    "the following theorem shows that incremental search algorithm with selectionsis correct , i.e. , that it outputs an explanation for @xmath160 w.r.t .",
    "the @xmath11-ontology @xmath21 , and that it runs in exponential time ( in polynomial time for bounded schema arity ) .",
    "thmgreedysel [ greedy - sel ] let the why - not instance @xmath139 be an input to incremental search algorithm with selectionsand @xmath120 the corresponding output .",
    "the following hold :    1 .",
    "@xmath120 is a most - general explanation for @xmath142 w.r.t .",
    "@xmath180 , where @xmath152 is @xmath95 ; 2 .",
    "incremental search algorithmruns in exptimein the size of the input ( in ptimefor bounded schema arity ) .",
    "we close this section with the study of the following problem .",
    "the check - mge w.r.t .",
    "@xmath21 problem is the following decision problem : given a why - not instance @xmath139 and a tuple of concepts @xmath184 , is @xmath120 a most - general explanation w.r.t .",
    "@xmath21 for @xmath144 ?",
    "our next proposition states the running time of our algorithm for the check - mge w.r.t .",
    "@xmath21 for various fragments of our concept language .",
    "the algorithm operates very similarly to lines 4 - 11 of incremental search algorithm . given a tuple of concepts",
    ", we check whether that tuple of concepts can be extended to a more general tuple of concepts through ideas similar to lines 4 - 11 of incremental search algorithm .",
    "if the answer is `` no '' , then we return `` yes '' . otherwise , we return `` no '' .",
    "propcheckmgeoi[check - mge - o - i ] there is an algorithm that solves check - mge w.r.t .",
    "@xmath21 in :    * ptimefor selection - free @xmath95 , or for @xmath95 with bounded schema arity ; * exptimefor @xmath95 in the general case .",
    "we now study the case of solving the why - not problem w.r.t . to an @xmath11-ontology @xmath185 that is derived from a schema .",
    "as in the previous case , the presence of nominals in the concept language guarantees that the trivial explanation always exists .",
    "therefore we do not consider the decision problem existence - of - explanation w.r.t .",
    "@xmath109 .",
    "the compute - one - mge w.r.t .",
    "@xmath109 is the following computational problem : given a why - not instance @xmath139 , find a most - general explanation w.r.t .",
    "@xmath109 for @xmath142 , where @xmath109 is the @xmath11-ontology that is derived from @xmath94 , as defined in section  [ derivingontology ] .",
    "the complexity of compute - one - mge w.r.t .",
    "@xmath109 depends on the complexity of subsumption checking for @xmath95 .",
    "as seen in table  [ tbl : subsumption - complexity ] , subsumption checking with respect to arbitrary integrity constraints is undecidable . therefore , for the general case in which no restriction is imposed on the integrity constraints , compute - one - mge w.r.t .",
    "@xmath109 is unlikely to be decidable .",
    "the restrictions on the integrity constraints of @xmath94 allow for the definition of several variants of the problem that , under some restrictions , are decidable .",
    "we restrict now to the cases in which we are able to materialize the @xmath11-ontology @xmath186 $ ] , with @xmath187 .",
    "exhaustive search algorithmgives us a method for solving compute - one - mge w.r.t .",
    "the following proposition gives us a double exponential upper bound for compute - one - mge w.r.t .",
    "@xmath109 in the general case , and a polynomial case under specific assumptions ( cf .  table  [ tbl : subsumption - complexity ] ) .",
    "propwhynotontow [ prop : whynotow ] there is an algorithm that solves compute - one - mge w.r.t .",
    "@xmath109    * in 2exptimefor @xmath95 , provided that the input schema @xmath94 is from a class for which concept subsumption can be checked in @xmath188 , * in exptimefor selection - free @xmath95 , and projection - free @xmath95 , provided that the input schema @xmath94 is from a class for which concept subsumption can be checked in @xmath188 , * in ptimefor @xmath189 , if the arity of @xmath2 is fixed and provided that the input schema @xmath94 is from a class for which concept subsumption can be checked in @xmath190 .",
    "we end with the definition of check - mge w.r.t .",
    "@xmath109 .",
    "the check - mge w.r.t .",
    "@xmath109 problem is the following decision problem : given a why - not instance @xmath139 and a tuple of concepts @xmath191 , is @xmath120 a most - general explanation w.r.t .",
    "@xmath109 for @xmath144 ?    as for compute - one - mge w.r.t .",
    "@xmath109 , the undecidability of concept subsumption in the general case suggests that it is unlikely for check - mge w.r.t .",
    "@xmath109 to be decidable without imposing any restriction on @xmath108 and @xmath24 .",
    "however , also this problem allows for the characterization of several decidable variants .    in particular , since check - mgeis solvable in ptime(see theorem  [ np - comp - decision ] ) , by materializing @xmath186 $ ] we can derive some upper bounds for check - mge w.r.t .",
    "@xmath109 too .",
    "propmgeontow there is an algorithm that solves check - mge w.r.t .",
    "@xmath109    * in 2exptimefor @xmath95 concepts , provided that the input schema @xmath94 is from a class for which concept subsumption can be checked in @xmath188 , * in exptimefor selection - free @xmath95 , and projection - free @xmath95 , provided that the input schema @xmath94 is from a class for which concept subsumption can be checked in @xmath188 , * in ptimefor @xmath189 , provided that the input schema @xmath94 is from a class for which concept subsumption can be checked in @xmath190 .",
    "the proof is analogous to the one for proposition  [ prop : whynotow ] .",
    "we expect that the upper bounds for compute - one - mge w.r.t .",
    "@xmath109 and check - mge w.r.t .",
    "@xmath109 can be improved . pinpointing the complexity of these problems",
    "is left for future work .",
    "we consider several refinements and variations to our framework involving finding short explanations , and providing alternative definitions of _ explanations _ and of what it means to be _",
    "most general_.    * producing a short explanation . * a most - general explanation that is _ short",
    "_ may be more helpful to the user . to simplify our discussion ,",
    "we restrict our attention to ontologies that are derived from an instance and show that the problem of finding a most - general explanation of minimal length is @xmath192-hard in general , where the _ length _ of an explanation @xmath193 is measured by the total number of symbols needed to write out @xmath96 ,  , @xmath194 .",
    "[ sec : producingaminimalexplanation ]    propwhynotminproblem [ prop : whynotmin ] given a why - not instance @xmath139 , the problem of finding a most - general explanation to @xmath195 of minimal length is @xmath192-hard .    given that computing a shortest most - general explanation is intractable in general , we may consider the task of shortening a given most - general explanation .",
    "the incremental search algorithm produces concepts that may contain superfluous conjuncts .",
    "it is thus natural to ask whether the algorithm can be modified to produce a most - general explanation of a shorter length .",
    "this question can be formalized in at least two ways .",
    "let @xmath0 be an instance of a schema @xmath94 , and let @xmath196 be any @xmath95 concept expression .",
    "we may assume that each @xmath197 is intersection - free .",
    "we say that @xmath18 is _ irredundant _ if there is a no strict subset @xmath198 such that @xmath199 .",
    "we say that an explanation ( with respect to @xmath200 ) is irredundant if it consists of irredundant concept expressions .",
    "we say that explanations @xmath122 and @xmath124 are _ equivalent _ w.r.t .",
    "an ontology @xmath201 , denoted as @xmath202 , if @xmath203 and @xmath204 .",
    "propirredundunt [ prop : irredundant ] there is a polynomial - time algorithm that takes as input an instance @xmath0 of a schema @xmath94 , as well as an @xmath95 concept expression @xmath18 , and produces an irredundant concept expression @xmath19 such that @xmath205 .",
    "hence , by combining proposition  [ prop : irredundant ] with incremental search algorithm , we can compute an irredundant most - general explanation w.r.t .",
    "@xmath200 in polynomial time .",
    "we say that an explanation @xmath193 is _ minimized _ w.r.t .",
    "@xmath200 if there does not exist an explanation @xmath206 such that @xmath207 and @xmath162 is shorter than @xmath120 .",
    "every minimized explanation is irredundant , but the converse may not be true .",
    "for instance , let @xmath208 be an ontology with three atomic concepts @xmath209 such that @xmath210 and @xmath211",
    ". then the concept @xmath212 is irredundant with respect to @xmath208 .",
    "however , @xmath96 is an equivalent concept of strictly shorter length .",
    "propshortequiv given a why - not instance @xmath139 and an explanation @xmath120 to why @xmath195 , the problem of finding a minimized explanation equivalent to @xmath120 is @xmath192-hard .",
    "* cardinality based preference .",
    "* we have currently defined a _ most - general explanation _ to be an explanation @xmath120 such that there is no explanation @xmath162 with @xmath213 .",
    "a natural alternative is to define `` most general '' in terms of the cardinality of the extensions of the concepts in an explanation .",
    "formally , let @xmath214 be an @xmath11-ontology , and @xmath0 an instance .",
    "we define the _ degree of generality _ of an explanation @xmath215 with respect to @xmath216 and @xmath0 to be the ( possibly infinite ) sum @xmath217 . for two explanations , @xmath218 ,",
    "we write @xmath219 , if @xmath122 has a strictly higher degree of generality than @xmath124 with respect to @xmath216 and @xmath0 .",
    "we say that an explanation @xmath120 is @xmath220-maximal ( with respect to @xmath216 and @xmath0 ) if there is no explanation @xmath162 such that @xmath221 .",
    "propcardinality [ prop : card ] assuming p@xmath222np , there is no ptimealgorithm that takes as input a why - not instance @xmath139 and an @xmath11-ontology @xmath216 , and produces a @xmath220-maximal explanation for @xmath144 .",
    "this holds even for unary queries .",
    "in particular , this shows ( assuming p@xmath222np ) that computing @xmath220-maximal explanations is harder than computing most - general explanations .",
    "the proof of proposition  [ prop : card ] goes by reduction from a suitable variant of set cover .",
    "our reduction is in fact an @xmath223-reduction , which implies that there is no @xmath190 constant - factor approximation algorithm for the problem of finding a @xmath220-maximal explanation .",
    "* strong explanations .",
    "* we now examine an alternative notion of an explanation that is essentially independent to the instance of a why - not question .",
    "recall that the second condition of our current definition of an explanation @xmath215 requires that @xmath224 does not intersect with @xmath154 , where @xmath0 is the given instance .",
    "we could replace this condition by a stronger condition , namely that @xmath225 does not intersect with @xmath226 , for _ any _ instance @xmath1 of the given schema that is consistent with the ontology @xmath216 .",
    "if this holds , we say that @xmath120 is a _",
    "strong explanation_.    a strong explanation is also an explanation but not necessarily the other way round .",
    "when a strong explanation @xmath120 for @xmath144 exists , then , intuitively , the reason why @xmath5 does not belong to @xmath154 , is essentially independent from the specific instance @xmath0 , and has to do with the ontology @xmath216 and the query @xmath2 . in the case where the ontology @xmath216 is derived from a schema @xmath94 , a strong explanation may help one discover possible errors in the integrity constraints of @xmath94 , or in the query @xmath2 .",
    "we leave the study of strong why - not explanations for future work.=-1",
    "we have presented a new framework for why - not explanations , which leverages concepts from an ontology to provide high - level and meaningful reasons for why a tuple is missing from the result of a query . our focus in this paper was on developing a principled framework , and on identifying the key algorithmic problems .",
    "the exact complexity of some problems raised in this paper remains open .",
    "in addition , there are several directions for future work .",
    "recall that , in general , there may be multiple most - general explanations for @xmath12 . while we have presented a polynomial time algorithm for computing a most - general explanation to a why - not question w.r.t .",
    "@xmath21 for the case of selection - free @xmath95 , the most - general explanation that is returned by the algorithm may not always be the most helpful explanation . in future work",
    ", we plan to investigate whether there is a polynomial delay algorithm for enumerating all most - general explanations for such ontologies .",
    "although we only looked at _ why - not explanations _ , it will be natural to consider _ why explanations _ in the context of an ontology , and in particular , understand whether the notion of most - general explanations , suitably adapted , applies in this setting .",
    "in addition , roy and suciu  @xcite recently initiated the study of what one could call `` why so high '' and `` why so low '' explanations for numerical queries ( such as aggregate queries ) .",
    "again , it would be interesting to see if our approach can help in identifying high - level such explanations .",
    "we have focused on providing why - not explanations to missing tuples of queries that are posed against a database schema .",
    "however , our framework for answering the why - not question is general and could , in principle , be applied also to queries posed against the ontology in an obda setting .",
    "finally , we plan to explore ways whereby our high - level explanations can be used to complement and enhance existing data - centric and/or query - centric approaches .",
    "we illustrate this with an example .",
    "suppose a certain publication @xmath54 is missing from the answers to query over some publication database .",
    "a most - general explanation may be that x was published by springer ( supposing all springer publications are missing from the answers to the query ) .",
    "this explanation provides insight on potential high - level issues that may exist in the database and/or query .",
    "for example , it may be that all springer publications are missing from the database ( perhaps due to errors in the integration / curation process ) or the query has inadvertently omitted the retrieval of all springer publications .",
    "this is in contrast with existing data - centric ( resp .",
    "query - centric ) approaches , which only suggest fixes to the database instance ( resp .",
    "query ) so that the specific publication @xmath54 appears in the query result .",
    "* acknowledgements  * we thank vince brny , bertram ludscher and dan olteanu for motivating discussion during early stages of the research .",
    "ten cate is partially supported by nsf grant iis-1217869 .",
    "civili is partially supported by the eu under fp7 project optique ( grant n. fp7 - 318338 ) .",
    "sherkhonov is supported by the netherlands organization for scientific research ( nwo ) under project number 612.001.012 ( dex ) .",
    "tan is partially supported by nsf grant iis-1450560 .",
    "s.  roy and d.  suciu . a formal approach to finding explanations for database queries . in _ proceedings of the 2014 acm sigmod international conference on management of data _ , sigmod 14 , pages 15791590 , new york , ny , usa , 2014 ."
  ],
  "abstract_text": [
    "<S> we propose a novel foundational framework for _ why - not explanations _ , </S>",
    "<S> that is , explanations for why a tuple is missing from a query result . </S>",
    "<S> our why - not explanations leverage concepts from an ontology to provide high - level and meaningful reasons for why a tuple is missing from the result of a query .    </S>",
    "<S> a key algorithmic problem in our framework is that of _ computing a most - general explanation _ for a why - not question , relative to an ontology , which can either be provided by the user , or it may be automatically derived from the data and/or schema . </S>",
    "<S> we study the complexity of this problem and associated problems , and present concrete algorithms for computing why - not explanations . in the case where an external ontology is provided , </S>",
    "<S> we first show that the problem of deciding the existence of an explanation to a why - not question is np - complete in general . however , the problem is solvable in polynomial time for queries of bounded arity , provided that the ontology is specified in a suitable language , such as a member of the dl - lite family of description logics , which allows for efficient concept subsumption checking . </S>",
    "<S> furthermore , we show that a most - general explanation can be computed in polynomial time in this case . in addition , we propose a method for deriving a suitable ( virtual ) ontology from a database and/or a schema , and we present an algorithm for computing a most - general explanation to a why - not question , relative to such ontologies . </S>",
    "<S> this algorithm runs in polynomial - time in the case when concepts are defined in a selection - free language , or if the underlying schema is fixed . </S>",
    "<S> finally , we also study the problem of computing _ short _ most - general explanations , and we briefly discuss alternative definitions of what it means to be an explanation , and to be most general . </S>"
  ]
}