{
  "article_text": [
    "theoretical models for wireless sensor networks have received great attention over the past few years .",
    "recently , angluin _ et al . _",
    "@xcite proposed the _ population protocol _ ( _ pp _ ) model .",
    "their aim was to model sensor networks consisting of tiny computational devices with sensing capabilities that follow some unpredictable and uncontrollable mobility pattern . due to the minimalistic nature of their model ,",
    "the class of computable predicates was proven to be fairly small : it is the class of _ semilinear predicates _",
    ", thus , not including multiplication of variables , exponentiations , and many other important operations on input variables .",
    "moreover , delporte - gallet _ et al . _",
    "@xcite showed that pps can tolerate only @xmath18 crash failures and not even a single byzantine agent .",
    "the work of angluin _ et al . _ shed light and opened the way towards a brand new and very promising direction .",
    "the lack of control over the interaction pattern , as well as its inherent nondeterminism , gave rise to a variety of new theoretical models for wsns .",
    "those models draw most of their beauty precisely from their inability to organize interactions in a convenient and predetermined way .",
    "in fact , the population protocol model was the minimalistic starting - point of this area of research .",
    "most efforts are now towards strengthening the model of angluin _ et al . _ with extra realistic and implementable assumptions , in order to gain more computational power and/or speed - up the time to convergence and/or improve fault - tolerance @xcite , @xcite .    in this work ,",
    "we think of each agent as being a turing machine .",
    "in particular , we propose a new theoretical model for passively mobile sensor networks , called the _",
    "pm _ model .",
    "it is a model of passively mobile machines ( that we keep calling agents ) with sensing capabilities , equipped with two - way communication .",
    "we focus on pm protocols that use @xmath5 memory since , having _ logarithmic communicating machines _",
    "seems to be more natural than communicating automata of constant memory .",
    "first of all , the _ communicating machines _ assumption is perfectly consistent with current technology ( cellphones , ipods , pdas , and so on ) .",
    "moreover , _",
    "logarithmic _ is , in fact , _ extremely small_. in addition , we explore the computability of the pm model on different space bounds in order to get an insight of the trade - off between computational power and resource ( memory ) availability .",
    "as will shall see , in pm protocols that use @xmath19 space , agents can be organized into a distributed nondeterministic tm that makes use of all the available space . in the case , where @xmath20 however , we show that the pm protocols are computationally equal to population protocols .",
    "thus , we provide exact characterizations for the input symmetric computations performed by communicating tms using the above space bounds .      in @xcite ,",
    "the _ probabilistic population protocol _",
    "model was proposed , in which the scheduler selects randomly and uniformly the next pair to interact . some recent work has concentrated on performance , supported by this random scheduling assumption ( see e.g. @xcite ) .",
    "@xcite proposed a generic definition of probabilistic schedulers and a collection of new fair schedulers , and revealed the need for the protocols to adapt when natural modifications of the mobility pattern occur .",
    "@xcite considered a huge population hypothesis ( population going to infinity ) , and studied the dynamics , stability and computational power of probabilistic population protocols by exploiting the tools of continuous nonlinear dynamics .    in addition , several extensions of the basic model have been proposed in order to more accurately reflect the requirements of practical systems . the _ mediated population protocol _ ( _ mpp _ ) model of @xcite was based on the assumption that each edge of the communication graph can store a state .",
    "it has been recently proven @xcite that in the case of complete graphs the corresponding class is the symmetric subclass of @xmath21 , rendering the mpp model extremely powerful .",
    "guerraoui and ruppert @xcite made another natural assumption : each agent has its own unique i d and can store up to a constant number of other agents ids . in this model , which they named _ community protocol _",
    "model , the only permitted operation on ids is comparison .",
    "it was proven that the corresponding class consists of all symmetric predicates in @xmath8 . in @xcite ,",
    "angluin _ et al .",
    "_ studied what properties of restricted communication graphs are stably computable , gave protocols for some of them , and proposed an extension of the model with _",
    "stabilizing inputs_. in @xcite , mpp s ability to decide graph properties was studied and it was proven that connectivity is undecidable .",
    "some other works incorporated agent failures @xcite and gave to some agents slightly increased computational power @xcite ( heterogeneous systems ) .",
    "recently , bournez _ et al . _",
    "@xcite investigated the possibility of studying population protocols via game - theoretic approaches .",
    "for an excellent introduction to the subject of population protocols see @xcite and for some recent advances mainly concerning mediated population protocols see @xcite .",
    "in section [ sec : mod ] , we begin with a formal definition of the pm model .",
    "the section proceeds with a thorough description of the systems functionality and then provides definitions of _ configurations _ and _ fair executions_. in section [ sec : pred ] , first _ stable computation _ and then the complexity classes @xmath22 , @xmath23 ( symmetric predicates in @xmath24 and @xmath25 @xmath26 , respectively ) , and @xmath3 ( stably computable predicates by the pm model using @xmath4 space ) are defined , while in section [ exam ] we give two examples of pm protocols . in section [ sec : uids ] , we prove that pm protocols can assume the existence of unique consecutive ids and knowledge of the population size at the space cost of @xmath5 ( theorem [ the : iplm ] ) . in section [ plm ]",
    "we show how to exploit this knowledge in order for the system to simulate a non - deterministic tm ( theorem [ the : lowplm ] ) .",
    "this , along with theorem [ the : plmup ] provide an exact characterization of the plm : @xmath27 ( theorem [ plm_exact ] ) . based on the results of this section , we establish a space hierarchy theorem for the pm model , when the corresponding protocols use @xmath5 space ( theorem [ the : pmsh ] ) . in section [ threshold ]",
    "we examine the interesting case of the @xmath28 space bounded protocols , showing that it acts as a computability threshold of some sort .",
    "finally , in section [ sec : conc ] we conclude and discuss some future research directions .",
    "in this section , we formally define the pm model and describe its functionality . in what follows ,",
    "we denote by @xmath29 the ( directed ) communication graph : @xmath30 is the set of agents , or _ population _ , and @xmath31 is the set of permissible ordered pairwise interactions between these agents .",
    "we provide definitions for general communication graphs and unbounded memories , although in this work we deal with complete communication graphs only and are mainly interested in computations that are space - bounded by a logarithm of the population size .",
    "we generally denote by @xmath2 the population size ( i.e. @xmath32 ) .",
    "a _ pm _ protocol is a 6-tuple @xmath33 where @xmath34 , @xmath35 and @xmath36 are all finite sets and    1 .",
    "@xmath34 is the _ input alphabet _",
    ", where @xmath37 , 2 .",
    "@xmath35 is the _ tape alphabet _ , where @xmath38 and @xmath39 , 3 .",
    "@xmath36 is the set of _ states _ , 4 .",
    "@xmath40 is the _ internal transition function _ , 5 .",
    "@xmath41 is the _ external transition function _ ( or _ interaction transition function _ ) , and 6 .",
    "@xmath42 is the _",
    "initial state_.    each agent is equipped with the following :    * a _ sensor _ in order to sense its environment and receive a piece of the input . *",
    "four read / write _ tapes _ : the _ working tape _ , the _ output tape _ , the _ incoming message tape _ and the _ outgoing message tape_. we assume that all tapes are bounded to the left and unbounded to the right . * a _ control unit _ that contains the state of the agent and applies the transition functions .",
    "* four _ heads _",
    "( one for each tape ) that read from and write to the cells of the corresponding tapes and can move one step at a time , either to the left or to the right . *",
    "a binary _ working flag _ either set to @xmath43 meaning that the agent is _ working _ internally or to @xmath44 meaning that the agent is _ ready _ for interaction .",
    "initially , all agents are in state @xmath45 , their working flag is set to @xmath43 , and all their cells contain the _ blank symbol _",
    "we assume that all agents concurrently receive their sensed input ( different agents may sense different data ) as a response to a global start signal .",
    "the input to each agent is a symbol from @xmath34 and is written on the leftmost cell of its working tape .",
    "when its working flag is set to 1 we can think of an agent working as a usual multitape turing machine ( but it additionally writes the working flag ) .",
    "in particular , while the working flag is set to 1 the internal transition function @xmath47 is applied , the control unit reads the symbols under the heads and its own state , updates all of them , moves each head one step to the left or to the right , and sets the working flag to 0 or 1 , according to @xmath47 .    as it is common in the population protocol literature , a _",
    "fair adversary scheduler _ selects ordered pairs of agents ( edges from @xmath31 ) to interact .",
    "assume now that two agents @xmath48 and @xmath49 are about to interact with @xmath48 being the _ initiator _ of the interaction and @xmath49 being the",
    "_ responder_. let @xmath50 be a function returning the current value of each agent s working flag .",
    "if at least one of @xmath51 and @xmath52 is equal to @xmath43 , then nothing happens , because at least one agent is still working internally . otherwise ( @xmath53 ) , both agents are ready and an _ interaction _ is established . in the latter case ,",
    "the external transition function @xmath54 is applied , the states of the agents are updated accordingly , the outgoing message of the initiator is copied to the leftmost cells of the incoming message tape of the responder ( replacing its contents and writting @xmath46 to all other previously non - blank cells ) and vice versa ( we call this the _ message swap _ ) , and finally the working flags of both agents are again set to 1",
    ". these operations could be handled by the protocols themselves , but then protocol descriptions would become awkward .",
    "so , we simply think of them as automatic operations performed by the hardware .",
    "these operations are also considered as atomic , that is , the interacting agents can not take part in another interaction before the completion of these operations and , moreover , either all operations totally succeed or are all totally aborted ( in which case , the states of the interacting agents are restored ) .    note that the assumption that the internal transition function @xmath47 is only applied when the working flag is set to 1 is weak .",
    "in fact , an equivalent way to model this is to assume that @xmath47 is of the form @xmath55 , that it is always applied , and that for all @xmath56 and @xmath57 , @xmath58 is satisfied , where @xmath59 means that the corresponding head `` stays put '' .",
    "the same holds for the assumptions that @xmath54 is not applied if at least one of the interacting agents is working internally and that the working flags are set to @xmath43 when some established interaction comes to an end ; it is equivalent to an extended @xmath54 of the form @xmath60 , that is applied in every interaction , and for which @xmath61 if @xmath62 or @xmath63 , and @xmath64 if @xmath65 , hold for all @xmath66 , and we could also further extend @xmath47 and @xmath54 to handle the exchange of messages , but for sake of simplicity we have decided to leave such details out of the model .",
    "since each agent is a tm , we use the notion of a configuration to capture its `` state '' .",
    "an _ agent configuration _ is a tuple @xmath67 , where @xmath56 , @xmath68 , and @xmath69 .",
    "@xmath70 is the state of the control unit , @xmath71 ( @xmath72 ) is the string of the working ( output , incoming message , outgoing message ) tape to the left of the head ( including the symbol scanned ) , @xmath73 ( @xmath74 ) is the string of the working ( output , incoming message , outgoing message ) tape to the right of the head ( excluding infinite sequences of blank cells ) , and @xmath75 is the working flag indicating whether the agent is ready to interact ( @xmath76 ) or carrying out some internal computation ( @xmath77 ) .",
    "let @xmath78 be the set of all agent configurations .",
    "given two agent configurations @xmath79 , we say that @xmath80 _ yields _ @xmath81 if @xmath81 follows @xmath80 by a single application of @xmath47 .    a _ population configuration _",
    "is a mapping @xmath82 , specifying the agent configuration of each agent in the population .",
    "let @xmath83 , @xmath84 be population configurations and let @xmath85 .",
    "we say that @xmath83 _ yields _ @xmath84 via _ agent transition _ @xmath48 , denoted @xmath86 , if @xmath87 yields @xmath88 and @xmath89 , @xmath90 .",
    "denote by @xmath91 the state component of an agent configuration @xmath80 and similarly for the other components ( e.g. @xmath92 , @xmath93 , @xmath94 , and so on ) .",
    "let @xmath95 , that is , we obtain by concatenation the whole contents of tape @xmath96 .",
    "given a string @xmath97 and @xmath98 denote by @xmath99 $ ] its prefix @xmath100 and by @xmath101 $ ] its suffix @xmath102 . if @xmath103 then @xmath99=s\\sqcup^{i-|s|}$ ] ( i.e. @xmath104 blank symbols appended to @xmath97 ) and @xmath101=\\varepsilon$ ] .",
    "for any external transition @xmath105 define @xmath106 and @xmath107 .",
    "given two population configurations @xmath83 and @xmath84 , we say that @xmath83 _ yields _ @xmath84 via _ encounter _",
    "@xmath108 , denoted @xmath109 , if one of the following two cases holds : + case 1 ( only for this case , we define @xmath110 to avoid excessive number of parentheses ) :    * @xmath111 , which guarantees that both agents @xmath48 and @xmath49 are ready for interaction under the population configuration @xmath83 . * @xmath112,$ ] + @xmath113 , l_{om}(c^u ) , r_{om}(c^u ) , 1)$ ] , * @xmath114,$ ] + @xmath115 , l_{om}(c^\\upsilon ) , r_{om}(c^\\upsilon ) , 1)$ ] , and * @xmath89 , @xmath116 .    case 2 :    * @xmath117 or @xmath118 , which means that at least one agent between @xmath48 and @xmath49 is working internally under the population configuration @xmath83 , and * @xmath119 , @xmath120 . in this case",
    "no effective interaction takes place , thus the population configuration remains the same .",
    "generally , we say that @xmath83 _ yields _ ( or _ can go in one step to _ ) @xmath84 , and write @xmath121 , if @xmath109 for some @xmath122 ( via encounter ) or @xmath123 for some @xmath85 ( via agent transition ) , or both .",
    "we say that @xmath84 is _ reachable _ from @xmath83 , and write @xmath124 if there is a sequence of population configurations @xmath125 such that @xmath126 holds for all @xmath127 .",
    "execution _ is a finite or infinite sequence of population configurations @xmath128 , so that @xmath126 .",
    "an infinite execution is _ fair _ if for all population configurations @xmath83 ,",
    "@xmath84 such that @xmath121 , if @xmath83 appears infinitely often then so does @xmath84 .",
    "computation _ is an infinite fair execution .",
    "we assume that the input alphabet @xmath34 , the tape alphabet @xmath35 , and the set of states @xmath36 are all sets whose cardinality is fixed and independent of the population size ( i.e. all of them are of cardinality @xmath18 ) .",
    "thus , protocol descriptions have also no dependence on the population size and the pm model _ preserves uniformity_. moreover , pm protocols are _ anonymous _ , since there is no room in the state of the agents for unique identifiers ( though here there is plenty of room on the tapes to create such ids ) .",
    "uniformity and anonymity are two outstanding properties of population protocols @xcite .",
    "the predicates that we consider here are of the following form . the input ( also called an _ input assignment _ ) to the population is any string @xmath129 , with @xmath2 being the size of the population . in particular , by assuming an ordering over @xmath30 , the input to agent @xmath130 is the symbol @xmath131 , @xmath132 .",
    "any mapping @xmath133 is a _ predicate on input assignments_.    a predicate on input assignments @xmath134 is called _ symmetric _ if for every @xmath135 and any @xmath136 which is a permutation of @xmath137 s symbols , it holds that @xmath138    in words , permuting the input symbols does not affect the symmetric predicate s outcome . from each predicate @xmath134 a language @xmath139",
    "is derived that is the set of all strings that make @xmath134 true or equivalently , @xmath140 .",
    "if a predicate @xmath134 is symmetric , @xmath139 is a symmetric language , that is , _ for each input string",
    "@xmath141 any permutation of @xmath137 s symbols @xmath136 also belongs in @xmath139_.    a population configuration @xmath83 is called _ output stable _ if for every configuration @xmath84 that is reachable from @xmath83 it holds that @xmath142 for all @xmath85 , where @xmath143 .",
    "in simple words , no agent changes its output in any subsequent step and no matter how the computation proceeds . a predicate on input assignments",
    "@xmath134 is said to be _ stably computable _ by a pm protocol @xmath144 in a graph family @xmath145 if , for any input assignment @xmath135 , any computation of @xmath144 , on any communication graph from @xmath145 of order @xmath146 , contains an output stable configuration in which all agents have @xmath147 written on their output tape .",
    "in what follows , we always assume that the graph family under consideration contains only complete communication graphs .",
    "we say that a predicate @xmath134 over @xmath148 belongs to @xmath24 ( @xmath149 ) if there exists some deterministic ( nondeterministic , resp . )",
    "tm that decides @xmath139 using @xmath4 space .",
    "let @xmath22 and @xmath23 be @xmath24 s and @xmath149 s restrictions to symmetric predicates , respectively .",
    "let @xmath3 be the class of all predicates that are stably computable by some pm protocol that uses @xmath4 space in every agent ( and in all of its tapes ) .",
    "[ rem : sym ] all agents are identical and do not initially have unique ids , thus , stably computable predicates by the pm model on complete communication graphs have to be symmetric .",
    "in fact , although we provide general definitions , we are mainly interested in the class @xmath150 and we call a pm protocol a",
    "_ paloma _ protocol ( standing for passively mobile logarithmic space machines ) if it always uses @xmath5 space .",
    "our main result in this paper is the following exact characterization for @xmath151 : @xmath151 is equal to @xmath152 . in fact , the proof we give easily generalizes and also provides an exact characterization for @xmath3 , when @xmath9 : @xmath3 is equal to @xmath153 .",
    "we present now a pm protocol that stably computes the predicate @xmath154 using @xmath5 space ( on the complete communication graph of @xmath2 nodes ) that is , all agents eventually decide whether the number of @xmath155s in the input assignment is the product of the number of @xmath156s and the number of @xmath157s .",
    "we give a high - level description of the protocol .",
    "initially , all agents have one of @xmath156 , @xmath157 and @xmath155 written on the first cell of their working memory ( according to their sensed value ) .",
    "that is , the set of input symbols is @xmath158 .",
    "each agent that receives input @xmath156 goes to state @xmath156 and becomes ready for interaction ( sets its working flag to 0 ) .",
    "agents in state @xmath156 and @xmath157 both do nothing when interacting with agents in state @xmath156 and agents in state @xmath157 .",
    "an agent in @xmath155 initially creates in its working memory three binary counters , the @xmath156-counter that counts the number of @xmath156s , the @xmath157-counter , and the @xmath155-counter , initializes the @xmath156 and @xmath157 counters to 0 , the @xmath155-counter to 1 , and becomes ready .",
    "when an agent in state @xmath156 interacts with an agent in state @xmath155 , @xmath156 becomes @xmath159 to indicate that the agent is now sleeping , and @xmath155 does the following ( in fact , we assume that @xmath155 goes to a special state @xmath160 in which it knows that it has seen an @xmath156 , and that all the following are done internally , after the interaction ; finally the agent restores its state to @xmath155 and becomes again ready for interaction ) : it increases its @xmath156-counter by one ( in binary ) , multiplies its @xmath156 and @xmath157 counters , which can be done in binary in logarithmic space ( binary multiplication is in @xmath161 ) , compares the result with the @xmath155-counter , copies the result of the comparison to its output tape , that is , 1 if they are equal and 0 otherwise , and finally it copies the comparison result and its three counters to the outgoing message tape and becomes ready for interaction .",
    "similar things happen when a @xmath157 meets a @xmath155 ( interchange the roles of @xmath156 and @xmath157 in the above discussion ) .",
    "when a @xmath155 meets a @xmath155 , the responder becomes @xmath162 and copies to its output tape the output bit contained in the initiator s message .",
    "the initiator remains to @xmath155 , adds the @xmath156-counter contained in the responder s message to its @xmath156-counter , the @xmath157 and @xmath155 counters of the message to its @xmath157 and @xmath155 counters , respectively , multiplies again the updated @xmath156 and @xmath157 counters , compares the result to its updated @xmath155 counter , stores the comparison result to its output and outgoing message tapes , copies its counters to its outgoing message tape and becomes ready again .",
    "when a @xmath159 , @xmath163 or @xmath162 meets a @xmath155 they only copy to their output tape the output bit contained in @xmath155 s message and become ready again ( eg @xmath159 remains @xmath159 ) , while @xmath155 does nothing .",
    "note that the number of @xmath155s is at most @xmath2 which means that the @xmath155-counter will become at most @xmath164 bits long , and the same holds for the @xmath156 and @xmath157 counters , so @xmath5 memory is required in each tape .",
    "the above pm protocol stably computes the predicate @xmath154 using @xmath5 space .",
    "given a fair execution , eventually only one agent in state @xmath155 will remain , its @xmath156-counter will contain the total number of @xmath156s , its @xmath157-counter the total number of @xmath157s , and its @xmath155-counter the total number of @xmath155s . by executing the multiplication of the @xmath156 and @xmath157 counters and comparing the result to its @xmath155-counter",
    "it will correctly determine whether @xmath154 holds and it will store the correct result ( 0 or 1 ) to its output and outgoing message tapes .",
    "at that point all other agents will be in one of the states @xmath159 , @xmath163 , and @xmath162 .",
    "all these , again due to fairness , will eventually meet the unique agent in state @xmath155 and copy its correct output bit ( which they will find in the message they get from @xmath155 ) to their output tapes .",
    "thus , eventually all agents will output the correct value of the predicate , having used @xmath5 memory .",
    "the class of semilinear predicates is a proper subset of @xmath151 .",
    "paloma protocols simulate population protocols and @xmath165 , which is non - semilinear .      here , we present a pm protocol that , using @xmath5 memory , stably computes the predicate @xmath166 , where @xmath167 , on the complete communication graph of @xmath2 nodes , that is , all agents eventually decide whether the number of @xmath43s in the input assignment is a power of 2 .",
    "the set of input symbols is @xmath168 .",
    "all agents that receive 1 create a binary @xmath43-counter to their working tape and initialize it to @xmath43 .",
    "moreover , they create a binary @xmath169 block and set it to @xmath170 .",
    "finally , they write 1 ( which is interpreted as `` true '' ) to their output tape , and copy the @xmath43-counter and the output bit to their outgoing message tape before going to state 1 and becoming ready .",
    "agents that receive input 0 write 0 ( which is interpreted as `` false '' ) to their output tape , go to state 0 , and become ready .",
    "agents in state 0 do nothing when interacting with each other . when an agent in state 0 interacts with an agent in state 1 , then 0 simply copies the output bit of 1 .",
    "when two agents in state 1 interact , then the following happen : the initiator sets its @xmath43-counter to the sum of the responder s @xmath43-counter and its own @xmath43-counter and compares its updated value to @xmath169 .",
    "if it is less than @xmath169 then it writes 0 to the output tape .",
    "if it is equal to @xmath169 it sets @xmath169 to @xmath171 and sets its output bit ( in the output tape ) to 1 .",
    "if it is greater than @xmath169 , then it starts doubling @xmath169 until @xmath43-counter @xmath172 is satisfied . if it is satisfied by equality , then it doubles @xmath169 one more time and writes 1 to the output tape",
    "otherwise , it simply writes 0 to the output tape .",
    "another implementation would be to additionally send @xmath169 blocks via messages and make the initiator set @xmath169 to the maximum of its own and the responder s @xmath169 blocks .",
    "in this case at most one doubling would be required .",
    "finally , in both implementations , the initiator copies the output bit and the @xmath43-counter to its outgoing message tape ( in the second implementation it would also copy @xmath169 to the outgoing message tape ) , remains in state @xmath43 , and becomes ready .",
    "the responder simply goes to state @xmath173 and becomes ready .",
    "an agent in state @xmath173 does nothing when interacting with an agent in state 0 and vice versa . when an agent in state @xmath173 interacts with an agent in state 1 , then @xmath173 simply copies the output bit of 1 .",
    "note that @xmath169 can become at most 2 times the number of @xmath43s in the input assignment , and the latter is at most @xmath2 .",
    "thus , it requires at most @xmath174 bits of memory . either way",
    ", we can delay the multiplication until another 1 appears , in which case we need at most @xmath164 bits of memory for storing @xmath169 ( the last unnecessary multiplication will never be done ) .",
    "in this section , we first prove that pm protocols can assume the existence of unique consecutive ids and knowledge of the population size at the space cost of @xmath5 ( theorem [ the : iplm ] ) .",
    "in particular , we present a pm protocol that correctly assigns unique consecutive ids to the agents and informs them of the correct population size using only @xmath5 memory , without assuming any initial knowledge of none of them .",
    "we show that this protocol can simulate any pm protocol that assumes the existence of these ids and knows the population size . at the end of the section",
    ", we exploit this result to prove that @xmath175 .",
    "pick any @xmath176 .",
    "let @xmath144 be the ipm protocol that stably computes it in @xmath5 space .",
    "we now present a pm protocol @xmath177 , containing protocol @xmath144 as a subroutine ( see protocol [ prot : ids ] ) , that stably computes @xmath134 , by also using @xmath5 space .",
    "@xmath177 is always executed and its job is to assign unique ids to the agents , to inform them of the correct population size and to control @xmath144 s execution ( e.g. restarts its execution if needed ) .",
    "@xmath144 , when @xmath177 allows its execution , simply reads the unique ids and the population size provided by @xmath177 and executes itself normally .",
    "we first present @xmath177 and then prove that it eventually correctly assigns unique ids and correctly informs the agents of the population size , and that when this process comes to a successful end , it restarts @xmath144 s execution in all agents without allowing non - reinitialized agents to communicate with the reinitialized ones .",
    "thus , at some point , @xmath144 will begin its execution reading the correct unique ids and the correct population size ( provided by @xmath177 ) , thus , it will get correctly executed and will stably compute @xmath134 .",
    "we begin by describing @xmath177 s variables .",
    "@xmath178 is the variable storing the i d of the agent ( from which @xmath144 reads the agents ids ) , @xmath179 the variable storing the @xmath178 that an agent writes in its outgoing message tape in order to send it , and @xmath180 the variable storing the @xmath178 that an agent receives via interaction .",
    "recall the model s convention that all variables used for sending information , like @xmath179 , preserve their value in future interactions unless altered by the agent .",
    "initially , @xmath181 for all agents .",
    "all agents have an input backup variable @xmath182 which they initially set to their input symbol and make it read - only .",
    "thus , each agent has always available its input via @xmath182 even if the computation has proceeded .",
    "@xmath183 represents the block of the working tape that @xmath144 uses for its computation and @xmath184 represents the contents of the output tape .",
    "@xmath185 is a binary flag that after every interaction becomes true if the agent was the initiator of the interaction and false otherwise ( this is easily implemented by exploiting the external transition function ) .",
    "@xmath186 is the variable storing the population size , @xmath187 the one used to put it in a outgoing message , and @xmath188 the received one .",
    "initially , @xmath189 .",
    "we now describe @xmath177 s functionality .",
    "whenever a pair of agents with the same i d interact , the initiator increases its i d by one and both update their population size value to the greater i d plus one .",
    "whenever two agents with different ids and population size values interact , they update their population size variables to the greater size .",
    "thus the correct size ( greatest i d plus one ) is propagated to all agents . both interactions described above reinitialize the participating agents ( restore their input and erase all data produced by the subroutine @xmath144 , without altering their ids and population sizes ) .",
    "@xmath144 , runs as a subroutine whenever two agents of different ids and same population sizes interact , using those data provided by @xmath177 .",
    "@xmath190 , @xmath191 @xmath192 , @xmath193 @xmath194 , @xmath193 @xmath195 , @xmath196 @xmath195 , @xmath196 @xmath197 , @xmath193 @xmath144 for @xmath43 step    [ lem : ids1 ] ( i ) no agent @xmath178 will get greater than @xmath198 , and no @xmath186 variable will get greater than @xmath2 .",
    "( ii ) @xmath177 assigns the ids @xmath199 in a finite number of interactions .",
    "( iii ) @xmath177 sets the ps variable of each agent to the correct population size in a finite number of interactions .",
    "\\(i ) by an easy induction , in order for an @xmath178 to reach the value @xmath200 , there have to be at least @xmath201 agents present in the population .",
    "thus , whenever an @xmath178 gets greater than @xmath198 , there have to be more than @xmath2 agents present , which creates a contradiction .",
    "similar arguments hold for the @xmath186 variables + ( ii ) assume on the contrary that it does not .",
    "because of ( i ) , at each point of the computation there will exist at least two agents , @xmath48 , @xmath200 such that @xmath202 . due to fareness , an interaction between such agents shall take place infinitely many times , creating an arbitrarily large @xmath178 which contradicts ( i ) .",
    "+ ( iii ) the correctness of the i d assignment ( ( i),(ii ) ) guarantees that after a finite number of steps two agents , @xmath48 , @xmath200 will set their @xmath186 variables to the correct population size ( upon interaction in which @xmath203 ) .",
    "it follows from ( i ) that no agent will have its @xmath186 variable greater than @xmath2 .",
    "fareness guarantees that each other agent will interact with @xmath48 or @xmath200 , updating its @xmath186 to @xmath2 .",
    "[ lem : ids5 ] given that @xmath177 s execution is fair , @xmath144 s execution is fair as well .    due to the fact that the id - assignment process and the population size propagation are completed in a finite number of steps",
    ", it suffices to study fairness of @xmath144 s execution after their completion .",
    "the state of each agent may be thought of as containing an @xmath177-subcomponent and an @xmath144-subcomponent , with obvious contents .",
    "denote by @xmath204 the unique subconfiguration of @xmath83 consisting only of the @xmath144-subcomponents of all agents and note that some @xmath204 may correspond to many superconfigurations @xmath83 .",
    "assume that @xmath205 and that @xmath204 appears infinitely often ( since here we consider @xmath144 s configurations , this ` @xmath206 ' refers to a step of @xmath144 s execution ) .",
    "@xmath205 implies that there exist superconfigurations @xmath83 , @xmath84 of @xmath204 , @xmath207 , respectively , such that @xmath121 ( via some step of @xmath144 in the case that @xmath208 ) .",
    "due to @xmath177 s fairness , if @xmath83 appears infinitely often , then so does @xmath84 and so does @xmath207 since it is a subconfiguration of @xmath84 .",
    "thus , it remains to show that @xmath83 appears infinitely often .",
    "since @xmath204 appears infinitely often , then the same must hold for all of its superconfigurations .",
    "the reasoning is as follows .",
    "all those superconfigurations differ only in the @xmath177-subcomponents , that is , they only differ in some variable checks performed by @xmath177 ( after the id - assignment process and the population size propagation have come to an end , nothing else is performed by @xmath177 ) . but all of them are reachable from and can reach a common superconfiguration of @xmath204 in which no variable checking is performed by @xmath177 , thus , they only depend on which pair of agents is selected for interaction and they are all reachable from one another . since at least one of them appears infinitely often then , due to the fairness of @xmath177 s execution , all of them must also appear infinitely often and this completes the proof .    by combining the above lemmata we can prove the following :    [ the : iplm ] @xmath209 .",
    "@xmath210 holds trivially , so it suffices to show that @xmath211 .",
    "we have presented a @xmath151 protocol ( protocol [ prot : ids ] ) that assigns the agents unique consecutive ids after a finite number of interactions and informs them of the population size ( lemma [ lem : ids1 ] ) .",
    "it follows directly from the protocol that after that point , further fair execution of @xmath177 will result in execution of protocol @xmath144 which can take into account the existance of unique ids .",
    "moreover , execution of @xmath144 is guaranteed to be fair ( lemma [ lem : ids5 ] ) .",
    "we first prove that @xmath212 .    [",
    "the : plmup ] all predicates in @xmath151 are in the class @xmath8 .",
    "let @xmath144 be a pm protocol that stably computes such a predicate @xmath134 using @xmath5 memory .",
    "a population configuration can be represented as an @xmath213place vector storing an agent configuration per place , and thus uses @xmath6 space in total .",
    "the language @xmath139 derived from @xmath134 is the set of all strings that make @xmath134 true , that is , @xmath140 .",
    "we will now present a nondeterministic turing machine @xmath214 that decides @xmath139 in @xmath6 space . to accept the input ( assignment ) @xmath137 , @xmath214 must verify two conditions : that there exists a configuration @xmath83 reachable from the initial configuration corresponding to @xmath137 in which the output tape of each agent indicates that @xmath134 holds , and that there is no configuration @xmath84 reachable from @xmath83 under which @xmath134 is violated for some agent .",
    "the first condition is verified by guessing and checking a sequence of configurations .",
    "starting from the initial configuration , each time @xmath214 guesses configuration @xmath215 and verifies that @xmath216 yields @xmath215 .",
    "this can be caused either by an agent transition @xmath48 , or an encounter @xmath217 . in the first case ,",
    "the verification can be carried out as follows : @xmath214 guesses an agent @xmath48 so that @xmath216 and @xmath215 differ in the configuration of @xmath48 , and that @xmath218 yields @xmath219 .",
    "it then verifies that @xmath216 and @xmath215 differ in no other agent configurations .",
    "similarly , in the second case @xmath214 nondeterministically chooses agents @xmath48 , @xmath200 and verifies that encounter @xmath217 leads to @xmath84 by ensuring that : ( a ) both agents have their working flags cleared in @xmath83 , ( b ) the tape exchange takes place in @xmath84 , ( c ) both agents update their states according to @xmath54 and set their working flags to @xmath43 in @xmath84 and ( d ) that @xmath216 and @xmath215 differ in no other agent configurations . in each case , the space needed is @xmath6 for storing @xmath216 , @xmath215 , plus @xmath5 extra capacity for ensuring the validity of each agent configuration in @xmath215 .",
    "if the above hold , @xmath214 replaces @xmath216 with @xmath215 and repeats this step .",
    "otherwise , @xmath214 drops @xmath215 . any time a configuration @xmath83 is reached in which @xmath134 holds",
    ", @xmath214 computes the complement of a similar reachability problem : it verifies that there exists no configuration reachable from @xmath83 in which @xmath134 is violated .",
    "since @xmath220 is closed under complement for all space functions @xmath221 ( see immerman - szelepcsnyi theorem , @xcite , pages @xmath222 ) , this condition can also be verified in @xmath6 space .",
    "thus , @xmath139 can be decided in @xmath6 space by some nondeterministic turing machine , so @xmath223 .",
    "we now prove that @xmath152 is a subset of @xmath151 .",
    "we establish this result by first proving a weaker one , that is , that @xmath224 is a subset of @xmath151 .",
    "[ the : psize ] @xmath175 .",
    "let @xmath225 be any predicate in @xmath224 and @xmath226 be the deterministic tm that decides @xmath134 by using @xmath6 space .",
    "we construct a pm protocol @xmath144 that stably computes @xmath134 by exploiting its knowledge of the population size .",
    "let @xmath137 be any input assignment in @xmath148 .",
    "each agent receives its input symbol according to @xmath137 ( e.g. @xmath48 receives symbol @xmath227 ) .",
    "now the agents obtain unique ids according to protocol [ prot : ids ] .",
    "the agent that has obtained the unique i d @xmath44 starts simulating @xmath226 .",
    "assume that currently the simulation is carried out by an agent @xmath48 having the i d @xmath228 .",
    "agent @xmath48 uses its simulation tape to write symbols according to the transition function of @xmath226 .",
    "any time the head of @xmath226 moves to the left , @xmath48 moves the head of the simulation tape to the left , pauses the simulation , writes the current state of @xmath226 to its outgoing message tape , and passes the simulation to the agent @xmath200 having i d @xmath229 .",
    "similarly , any time the head of @xmath226 moves to the right , @xmath48 moves the head of the simulation tape to the right , pauses the simulation , writes the current state of @xmath226 to its outgoing message tape , and passes the simulation to the agent @xmath200 having i d @xmath230 . in both cases , agent @xmath200 copies the state of @xmath226 to its working tape , and starts the simulation .",
    "whenever , during the simulation , @xmath226 accepts , then @xmath144 also accepts ; that is , the agent that detects @xmath226 s acceptance , writes 1 to its output tape and informs all agents to accept .",
    "if @xmath226 rejects , it also rejects . finally , note that @xmath144 simulates",
    "@xmath226 not necessarily on input @xmath231 but on some @xmath136 which is a permutation of @xmath137 .",
    "the reason is that agent with i d @xmath130 does not necessarily obtain @xmath232 as its input .",
    "the crucial remark that completes the proof is that @xmath226 accepts @xmath137 if and only if it accepts @xmath136 , because @xmath134 is symmetric .    because of the above process , it is easy to verify that the @xmath233th cell of the simulation tape of any agent @xmath48 having the i d @xmath228 corresponds to the @xmath234th cell of @xmath226 .",
    "thus , whenever @xmath226 alters @xmath235 tape cells , any agent @xmath48 will alter @xmath236 cells of its simulation tape .",
    "we now show how the above approach can be generalized to include nondeterministic turing machines .",
    "[ the : lowplm ] @xmath237 .    by considering theorem [ the : iplm ] ,",
    "it suffices to show that @xmath152 is a subset of @xmath238 .",
    "we have already shown that the ipm model can simulate a deterministic tm @xmath226 of @xmath6 space by using @xmath5 space ( theorem [ the : psize ] ) .",
    "we now present some modifications that will allow us to simulate a nondeterministic tm @xmath239 of the same memory size .",
    "keep in mind that @xmath239 is a decider for some predicate in @xmath152 , thus , it always halts . upon initialization",
    ", each agent enters a reject state ( writes @xmath44 to its output tape ) and the simulation is carried out as in the case of @xmath226 .    whenever a nondeterministic choice has to be made , the corresponding agent gets ready and waits for participating in an interaction .",
    "the i d of the other participant will provide the nondeterministic choice to be made .",
    "one possible implementation of this idea is the following .",
    "since there is a fixed upper bound on the number of nondeterministic choices ( independent of the population size ) , the agents can store them in their memories .",
    "any time a nondeterministic choice has to be made between @xmath240 candidates the agent assigns the numbers @xmath241 to those candidates and becomes ready for interaction . assume that the next interaction is with an agent whose i d is @xmath130 .",
    "then the nondeterministic choice selected by the agent is the one that has been assigned the number @xmath242 .",
    "fairness guarantees that , in this manner , all possible paths in the tree representing @xmath239 s nondeterministic computation will eventually be followed .",
    "any time the simulation reaches an accept state , all agents change their output to 1 and the simulation halts .",
    "moreover , any time the simulation reaches a reject state , it is being reinitiated .",
    "the correctness of the above procedure is captured by the following two cases .    1 .   _",
    "if @xmath239 rejects then every agent s output stabilizes to @xmath44_. upon initialization , each agent s output is @xmath44 and can only change if @xmath239 reaches an accept state . but all branches of @xmath239 s computation reject , thus , no accept state is ever reached , and every agent s output forever remains to @xmath44 .",
    "if @xmath239 accepts then every agent s output stabilizes to @xmath43_. since @xmath239 accepts , there is a sequence of configurations @xmath59 , starting from the initial configuration @xmath83 that leads to a configuration @xmath84 in which each agent s output is set to @xmath43 ( by simulating directly the branch of @xmath239 that accepts ) .",
    "notice that when an agent sets its output to @xmath43 it never alters its output tape again , so it suffices to show that the simulation will eventually reach @xmath84 .",
    "assume on the contrary that it does not .",
    "since @xmath239 always halts the simulation will be at the initial configuration @xmath83 infinitely many times .",
    "due to fairness , by an easy induction on the configurations of @xmath59 , @xmath84 will also appear infinitely many times , which leads to a contradiction .",
    "thus the simulation will eventually reach @xmath84 and the output will stabilize to @xmath43 .    taking into consideration the above theorems we can conclude to the following exact characterization for the class @xmath151 :    [ plm_exact ] @xmath151 is equal to @xmath152 .",
    "follows from theorems [ the : psize ] , which establishes that @xmath243 , and [ the : plmup ] , which establishes that @xmath244 ; but for all @xmath245 , @xmath134 is symmetric ( remark [ rem : sym ] ) , thus , @xmath246 .      here",
    ", we generalize the preceding ideas to nondeterministic _ recognizers _ of @xmath6 space .",
    "there is a way to stably compute predicates in @xmath224 even when the corresponding tm @xmath247 might loop , by carrying out an approach similar to the one given above .",
    "however , since neither an accept nor a reject state may be reached , the simulation is nondeterministically reinitiated at any point that is not in such a state . this choice is also obtained by the nondeterministic interactions .",
    "for example , whenever the agent that carries out the simulation interacts with an agent that has an i d that is even , the simulation remains unchanged , otherwise it is reinitiated .",
    "notice however that during the simulation , any agent having i d @xmath130 may need to interact with those having neighboring ids , so those must not be able to cause a reinitiation in the simulation .",
    "correctness of the above procedure is captured by similar arguments to those in the proof of theorem [ the : lowplm ] .",
    "if @xmath239 never accepts , then no output tape will ever contain a @xmath43 , so the simulation stabilizes to @xmath44 .",
    "if @xmath239 accepts there is a sequence of configurations @xmath59 , starting from the initial configuration @xmath83 that leads to a configuration @xmath84 in which each agent s output is set to @xmath43 .",
    "observe that this is a `` good '' sequence , meaning that no reinitiations take place , and , due to fairness , it will eventually occur .",
    "in this section we study the behaviour of pm model for various space bounds .",
    "[ the : plmfn ] for any function @xmath248 , any predicate in @xmath3 is also in @xmath249 @xmath250 .",
    "take any @xmath251 .",
    "let @xmath144 be the pm protocol that stably computes predicate @xmath134 in space @xmath4 .",
    "@xmath252 @xmath253 is the language corresponding to @xmath134 ( @xmath254 is the set of input strings ) .",
    "we describe a ntm @xmath239 that decides @xmath139 in @xmath255 space .",
    "note that each agent uses memory of size @xmath4 .",
    "so , by assuming a binary tape alphabet @xmath256 ( the alphabet of the agents tapes ) , an assumption which is w.l.o.g . , there are @xmath257 different agent configurations ( internal configurations ) each of size @xmath4 .",
    "@xmath239 stores a population configuration by storing all these agent configurations , consuming for this purpose @xmath258 space , together with a number per agent configuration representing the number of agents in that agent configuration under the current population configuration .",
    "these numbers sum up to @xmath2 and each one of them requires @xmath5 bits , thus , @xmath259 extra space is needed , giving a total of @xmath260 space needed to store a population configuration .",
    "the reason that such a representation of population configurations suffices is that when @xmath240 agents are in the same internal configuration there is no reason to store it @xmath240 times .",
    "the completeness of the communication graph allows us to store it once and simply indicate the number of agents that are in this common internal configuration , that is , @xmath240 .",
    "now @xmath239 does what the deterministic tm of the theorem [ the : plmup ] does .",
    "the main difference is that it now store the population configurations according to the new representation we discussed above .",
    "[ symmetric space hierarchy theorem ] [ the : nsymsh ] for any function @xmath248 , a symmetric language @xmath261 exists that is decidable in @xmath4 ( non)deterministic space but not in @xmath262 ( non ) deterministic space",
    ".    follows immediately from the unary ( tally ) separation language presented in @xcite and the fact that any unary language is symmetric .    [ cor : ologn ] for any function @xmath263 it holds that @xmath264 .    by considering theorem [ the : plmfn ] , the symmetric space hierarchy theorem ( theorem [ the : nsymsh ] ) it suffices to show that @xmath265 for @xmath263 .",
    "we have that @xmath266 which obviously grows slower than @xmath267 .",
    "so , for example , if @xmath268 , then @xmath269 which is strictly smaller than @xmath270 by the symmetric space hierarchy theorem .",
    "another interesting example is obtained by setting @xmath271 . in this case",
    ", we obtain the @xmath272 ( for _ symmetric _",
    "@xmath273 ) upper bound for population protocols of angluin _ et al . _",
    "@xcite ( in @xcite they obtained a better bound which is the semilinear predicates and constitutes an exact characterization for population protocols ) .",
    "although the above upper bounds are relatively tight for @xmath274 space functions , the bounds for @xmath275 have worse behavior in relation to the @xmath276 . in the theorem below , tighter upper bounds are shown by working with a different representation of population configurations that holds each agent s internal configuration explicitly .",
    "[ the : ppm_upper ] for any function @xmath277 it holds that @xmath3 is a subset of @xmath153 .",
    "this proof is similar to the proof establishing that @xmath151 is a subset of @xmath278 in theorem [ the : plmup ] .",
    "it can be easily shown , using similar arguments to those of the previously stated proof , that all predicates in @xmath3 are also in @xmath153 .",
    "in particular , there is a nondeterministic @xmath279 @xmath226 of space @xmath280 that can decide a language corresponding to any predicate @xmath281 @xmath3 .",
    "@xmath226 holds the internal configurations of the @xmath2 agents each of which needs @xmath4 space and therefore each configuration ( of the entire population ) requires @xmath280 space in @xmath226 s tape .",
    "@xmath226 starts with the initial configuration @xmath83 , guesses the next @xmath84 and checks whether it has reached a configuration in which @xmath134 holds .",
    "when @xmath226 reaches such a configuration @xmath83 it computes the complement of a similar reachability problem : it verifies that there exists no configuration reachable from @xmath83 in which @xmath134 is violated .",
    "this condition can also be verified in @xmath280 space since @xmath220 is closed under complement for all space functions @xmath282 ( immerman - szelepcsnyi theorem @xcite , pages 151 - 153 ) .",
    "note that for any reasonable function @xmath277 , @xmath283 , as required by the immerman - szelepcsnyi theorem .",
    "the upper bounds shown above are obviously better for functions @xmath19 than those presented by theorem [ the : plmfn ] .",
    "note however , that theorem [ the : ppm_upper ] also holds for @xmath284 and for those space constructible functions the upper bounds are worse than those of theorem [ the : plmfn ] . in order to realize that consider the function @xmath285 ( the memory of each agent is independent of the population size , thus this is the basic pp model ) . according to theorem [ the : ppm_upper ]",
    "the upper bound is the trivial @xmath286 , whereas the theorem [ the : plmfn ] decreases the upper bound to @xmath287 .",
    "this behavior is expected due to the configuration representation of the population used by those theorems . when the configuration is stored as @xmath2-vector where each element of the vector holds the internal configuration of an agent ( representation used in theorem [ the : ppm_upper ] ) then as the memory size grows the additional space needed is a factor @xmath2 of that growth . on the other hand , when a configuration is represented as a vector of size equal to the number of all possible internal configurations where each element is the number of agents that are in the corresponding internal configuration ( as in theorem [ the : plmfn ] ) then the size of the vector grows exponentially to the memory growth .",
    "therefore tighter upper bounds are obtained by theorem [ the : ppm_upper ] for functions @xmath19 and by theorem [ the : plmfn ] for @xmath284 .",
    "note that for @xmath288 the bounds by both theorems are the same .",
    "the next theorem shows that for space functions @xmath19 , the pm model can simulate a nondeterministic tm of space @xmath280 using @xmath4 in each agent .",
    "the intuition here is that with at least @xmath1 memory in each agent we can always assign unique ids and propagate the size of the population , as shown in section [ sec : uids ] , and therefore we can always organize the population into a nondeterministic tm where each of the @xmath2 agents provides @xmath4 space for the simulation .",
    "[ the : ppm_lower ] for any @xmath9 it holds that @xmath153 is a subset @xmath3 .    in theorem [ the : lowplm ] a nondeterministic tm of @xmath289 space",
    "is simulated by a paloma protocol provided that all agents know the population size and have unique ids .",
    "in addition in section [ sec : uids ] a construction is provided that allows the paloma protocols to assume ids and population size knowledge .",
    "the same construction can be used for the pm protocols which use @xmath4 space for @xmath9 .",
    "the reason is that in this space every agent can store a unique i d as well as the population size .",
    "therefore the same protocol @xmath177 of theorem [ the : iplm ] can be used here .    from the previous two theorems we get a generalization of the exact characterization for all @xmath290 @xmath291 ,",
    "when @xmath19 .",
    "it is formally stated as :    [ the : wlogn ] for any @xmath9 it holds that @xmath292 .",
    "it holds from theorems [ the : ppm_upper ] and [ the : ppm_lower ] .",
    "thus , by considering together corollary [ cor : ologn ] and theorem [ the : wlogn ] we obtain the following corollary .",
    "[ cor : pm_thres ] @xmath293 acts as a threshold for the computational power of the pm model .    considering the above analysis and corollary [ cor : pm_thres ]",
    "it is worth noting that the paloma protocols , seem to belong to a golden section between realistic requirements , w.r.t .",
    "implementation , and computational power offered .",
    "[ the : pmsh ] for any two functions @xmath294 , where @xmath19 and @xmath295 there is a predicate @xmath134 in @xmath3 but not in @xmath296 .    from theorem [ the : nsymsh ] we have that for any such functions",
    "@xmath297 there is a language @xmath298 so that @xmath299 .",
    "from theorem [ the : wlogn ] we have that @xmath300 , therefore @xmath301 ( where @xmath302 is the symmetric predicate that corresponds to the symmetric language @xmath261 ) .",
    "we distinguish two cases . if @xmath282 then from theorem [ the : wlogn ] we have that @xmath303 and so @xmath304 or equivalently @xmath305 @xmath306 .",
    "if @xmath307 then from corollary [ cor : ologn ] we have that @xmath308 @xmath309 .",
    "in this section we explore the computability of the pm model when the protocols use @xmath310 space . we show that this bound acts as a threshold constraining the corresponding protocols to compute only semilinear predicates .",
    "let @xmath15 denote the class of the semilinear predicates .",
    "we will prove that @xmath13 when @xmath14 .",
    "moreover , we will prove that this bound is tight , so that @xmath16 when @xmath17 .",
    "let @xmath80 be a pm protocol executed in a population @xmath30 of size @xmath2 .",
    "define _ agent configuration graph _",
    ", @xmath311 , a graph such that :    * @xmath312 is the set of the agent configurations that can occur in any execution of @xmath80 such that the working flag is set to 0 .",
    "* @xmath313 is the set of edges @xmath314 so that an agent configuration @xmath200 can occur from a configuration @xmath48 via a single interaction .",
    "* @xmath315 so that when an agent @xmath240 being in configuration @xmath48 enters configuration @xmath200 via a single interaction with an agent being in configuration @xmath316 , and @xmath240 acts as @xmath317 ( initiator - responder ) in the interaction , then @xmath318 , while @xmath319 in any other case",
    ". @xmath320 is a function since we only deal with deterministic protocols .    in other words",
    ", @xmath312 contains the configurations that an agent may enter when we do nt take into consideration the ones that correspond to internal computation , while @xmath313 defines the transitions between those configuration through interactions defined by @xmath320 .",
    "notice that in general , @xmath321 depends not only on the protocol @xmath80 , but on the population @xmath30 .",
    "we call a @xmath322 _ initial node _ iff it corresponds to an initial agent configuration .    because of the uniformity property",
    ", we can deduce the following theorem :    [ the : subgraph ] let @xmath321 , @xmath323 be two agent configuration graphs corresponding in a protocol @xmath80 for two different populations @xmath30 , @xmath324 of size @xmath2 and @xmath325 respectively , with @xmath326 .",
    "then , there exists a subgraph @xmath327 of @xmath323 such that @xmath328 , which contains all the initial nodes of @xmath323    indeed , let @xmath329 , @xmath330 be a partitioning of @xmath324 such that @xmath331 , and observe the agent configuration graph that yielded by the execution of @xmath80 in @xmath329 . since both populations execute the same protocol @xmath80 , and @xmath331 , @xmath332 .",
    "moreover , since the initial nodes are the same for both populations , they must be in @xmath333 .",
    "finally , @xmath333 is a subgraph of @xmath323 , as @xmath334 , and the proof is complete .",
    "the above theorem states that while we explore populations of greater size , the corresponding agent configuration graphs are only enhnanced with new nodes and edges , while the old ones are preserved .",
    "given an agent configuration graph , we associate each node @xmath156 with a value @xmath335 inductively , as follows :    base case : :    for any initial node @xmath156 , @xmath336 .",
    "inductive step : :    for any other node @xmath156 , @xmath337    such that @xmath156 is reachable from @xmath157 through an    edge labeled as @xmath155 , and @xmath157 , @xmath155    have already been assigned an @xmath338 value .",
    "[ lem : rval ] let @xmath311 be an agent configuration graph .",
    "every node in @xmath321 get associated with an @xmath338 value .",
    "assume for the shake of the contradiction that there is a maximum , non empty set of nodes @xmath339 such that @xmath340 , @xmath200 does not get associated with an @xmath338 value .",
    "then @xmath341 , and @xmath342 defines a cut , with all the initial nodes being in @xmath343 .",
    "we examine any edge @xmath217 labeled as @xmath344 that crosses the cut .",
    "obviously @xmath345 and @xmath346 , and @xmath48 is associated with a value @xmath347 .",
    "since @xmath200 is not associated with any @xmath338 value , the same must hold for node @xmath316 ( otherwise @xmath348 ) .",
    "we now examine the first agent @xmath155 that enters a configuration corresponding to some @xmath346 . because of the above observation",
    ", this could only happen through an interaction with an agent being in a configuration that is also in @xmath349 which creates the contradiction .",
    "note that for any given protocol and population size , the @xmath338 values are _ unique _ since the agent configuration graph is unique .",
    "the following lemma captures a bound in the @xmath338 values when the corresponding protocol uses @xmath350 space .",
    "[ lem : rmax ] let @xmath351 be the @xmath352th greatest @xmath338 value associated with any node in an agent configuration graph . for any protocol @xmath80 that uses @xmath350 , there exists a @xmath353 such that for any population of size @xmath354 @xmath355 .    since @xmath350 , @xmath356",
    ", so @xmath357 and @xmath358 .",
    "it follows from the last equation that for any positive integer @xmath359 , there exists a fixed @xmath353 such that @xmath360 for any @xmath361 .",
    "fix any such @xmath2 and let @xmath362 in the corresponding agent configuration graph .",
    "since any node is associated with an @xmath338 value , there can be at most @xmath240 different such values .",
    "now observe that @xmath363{n } \\leq \\frac{n}{2}$ ] for @xmath364 and @xmath365 .",
    "the following lemma proves that the @xmath338 values correspond to some reachability properties in the agent configuration graph .",
    "[ lem : qprop ] let @xmath366 be the following property : _ given a node @xmath156 in an agent configuration graph , there exists a population of size @xmath335 and a fair execution of the corresponding protocol that will lead an agent to the configuration @xmath156_. @xmath366 holds for any node of the agent configuration graph .",
    "we prove the above lemma by generalized induction in the @xmath338 values .",
    "base case : : :    @xmath366 obviously holds for any initial node    @xmath48 , since @xmath367 .",
    "inductive step : : :    we examine any non initial node @xmath48 that has been    associated with a value @xmath368 , for some    @xmath156 , @xmath157 .",
    "the inductive hypothesis guarantees    that @xmath366 and @xmath369 hold",
    ". then , a    population of size @xmath370 can lead two agents to    configurations @xmath156 and @xmath157 independently .",
    "then    an interaction between those agents will take one of them to    configuration @xmath48 , so @xmath371 holds too .",
    "lemmata [ lem : rmax ] and [ lem : qprop ] lead to the following :    [ lem : inter ] for any protocol @xmath80 that uses @xmath350 there exists a fixed @xmath353 such that for any population of size @xmath354 and any pair of agent configurations @xmath372 , the interaction @xmath217 can occur .    indeed ,",
    "because of the lemma [ lem : rmax ] , there exists a @xmath353 such that for any @xmath354 , @xmath373 for any @xmath156 . with that in mind , lemma [ lem : qprop ] guarantees that in any such population any interaction @xmath217 since any of the agent configurations @xmath48 , @xmath200 can occur independently , by partitioning the population in two subpopulations of size @xmath374 each .",
    "we can complete our proof with the following theorem :    [ the : semil ] any pm protocol @xmath80 that uses @xmath350 can only compute semilinear predicates .",
    "because of the uniformity constraint , @xmath80 can be executed in any population of arbitrary size .",
    "we choose a fixed @xmath353 as defined in lemma [ lem : rmax ] and examine any population @xmath261 of size @xmath354 .",
    "let @xmath375 be the corresponding agent configuration graph .",
    "let @xmath376 be any population of size @xmath377 and @xmath378 the corresponding agent configuration graph .",
    "because of the theorem [ the : subgraph ] , @xmath378 contains a subgraph @xmath379 , such that @xmath380 , and the initial nodes of @xmath378 are in @xmath379 .",
    "let @xmath381 , and @xmath240 the first agent configuration that appears in @xmath376 such that @xmath382 through an interaction @xmath217(@xmath240 ca nt be an initial configuration , thus it occurs through some interaction ) .",
    "then @xmath383 , and the interaction @xmath217 can occur in the population @xmath261 too ( lemma [ lem : inter ] ) , so that @xmath384 , which refutes our choice of @xmath240 creating a contradiction .",
    "so , @xmath385 , and the set of agent configurations does not change as we examine populations of greater size .",
    "since the set of agent configurations remains unchanged , the corresponding predicate can be computed by the population protocol model , thus it is semilinear .    in practice",
    ", the above theorem guarantees that for any protocol that uses only @xmath350 space in each agent , there exists a population of size @xmath353 in which it stops using extra space .",
    "since @xmath353 is fixed , we can construct a protocol based on the agent configuration graph which uses constant space , and thus can be executed in the population protocols model .",
    "so far , we have stablished that when @xmath350 , @xmath386 .",
    "since the inverse direction holds trivially , we can conclude that @xmath387 .",
    "we will now present the non semilinear logarithmic predicate , and devise a pm protocol that computes it using @xmath388 space in each agent .",
    "we define the logarithmic predicate as follows : during the initialization , each agent receives an input symbol from @xmath389 , and let @xmath390 denote the number of agents that have received the symbol @xmath156 .",
    "we want to compute whether @xmath391 for some arbitrary @xmath392 .",
    "we give a high level protocol that computes this predicate , and prove that it can be correctly executed using @xmath388 space .",
    "each agent @xmath48 maintains a variable @xmath393 , and let @xmath394 be the variable that uses to write its output .",
    "initially , any agent @xmath48 that receives @xmath156 as his input symbol sets @xmath395 and @xmath396 , while any other agent @xmath200 sets @xmath397 and @xmath398 .",
    "our main protocol consists of two subprotocols , @xmath80 and @xmath343 , that are executed concurrently .",
    "protocol @xmath80 does the following : whenever an interaction occurs between two agents , @xmath48 , @xmath200 , with @xmath48 being the initiator , if @xmath399 , then @xmath400 and @xmath397 .",
    "otherwise , nothing happens .",
    "protocol @xmath343 runs in parallel , and computes the semilinear predicate of determining whether there exist two or more agents having @xmath401 .",
    "if so , it outputs @xmath44 , otherwise it outputs @xmath43 .",
    "observe that @xmath343 is executed on _ stasbilizing inputs _ , as the @xmath402variables fluctate before they stabilize to their final value .",
    "however , it is well known that the semilinear predicates are also computable under this constraint ( @xcite ) .",
    "the main protocol uses @xmath403 space .    as protocol @xmath343",
    "computes a semilinear predicate , it only uses @xmath404 space , with @xmath155 being a constant . to examine the space bounds of @xmath80 , pick any agent @xmath48 .",
    "we examine the greatest value that can be assigned to the variable @xmath393 .",
    "observe that in order for @xmath393 to reach value @xmath240 , there have to be at least @xmath170 pre - existsing @xmath402 variables with values @xmath405 . through an easy induction",
    ", it follows that there have to be at least @xmath406 pre - existing variables with the value @xmath43 . since @xmath407 , @xmath408 , so @xmath393 is upper bounded by @xmath1 , thus consuming @xmath403 space .",
    "[ lem : log_com ] for every agent @xmath48 , eventually @xmath396 if @xmath409 for some arbitrary @xmath392 , and @xmath410 otherwise .    indeed , the execution of protocol @xmath343 guarantees that all agents will set @xmath411 iff eventually there exists only one agent @xmath48 that has a non - zero value assigned in @xmath393 .",
    "assume that @xmath412 for some @xmath240 .",
    "then , because of the analysis of lemma [ lem : log_com ] during the initialization of the population will exist @xmath406 @xmath402variables set to @xmath43 .",
    "since each of those variables corresponds to one @xmath156 assignement , @xmath413 . on the other hand ,",
    "if the answer of the protocol is @xmath44 then it means that there are @xmath414 agents in the population with @xmath402variables set to different values @xmath415 otherwise they could have effective interactions with each other .",
    "therefore , there should have initially existed @xmath416 agents with input @xmath156 .",
    "this , however , means that @xmath417 for any @xmath240 since each number can be uniquely expressed as a sum of powers of @xmath170 .",
    "thus the protocol correctly outputs @xmath44 .",
    "thus , we have presented a non - semilinear predicate that can be computed by a pm protocol using @xmath403 space . combining this result with the one presente in the previous subsection",
    ", we obtain the following theorem :    [ the : logsemi ] @xmath418 when @xmath350 .",
    "moreover , @xmath16 when @xmath17 .",
    "we proposed the pm model , an extension of the pp model @xcite , in which the agents are communicating tms .",
    "we mainly focused on studying the computational power of the new model when the space used by each agent is bounded by a logarithm of the population size .",
    "although the model preserves uniformity and anonymity , interestingly , we have been able to prove that the agents can _ organize themselves into a nondeterministic tm _ that makes full use of the agents total memory ( i.e. of @xmath6 space ) .",
    "the agents are initially identical and have no global knowledge of the system , but by executing an _ iterative reinitiation process _",
    "they are able to assign _ unique consecutive ids _ to themselves and get informed of the population size . in this manner , we showed that @xmath151 , which is the class of predicates stably computable by the pm model using @xmath5 memory , contains all symmetric predicates in @xmath8 .",
    "moreover , by proving that @xmath151 is a subset of @xmath8 , we concluded that it is precisely equal to the class consisting of all symmetric predicates in @xmath8 .",
    "we then generalized this to @xmath153 when the agents use @xmath4 memory , for all space functions @xmath9 .",
    "we also explored the behavior of the pm model for space bounds @xmath263 and proved that @xmath13 when @xmath14 .",
    "finally , we showed that this bound is tight , that is , @xmath16 when @xmath17 .",
    "many interesting questions remain open .",
    "is the pm model _ fault - tolerant _ ?",
    "what preconditions are needed in order to achieve satisfactory fault - tolerance ? what is the behavior of the model when the agents use @xmath4 memory , where @xmath284 and @xmath419 .",
    "we wish to thank some anonymous reviewers for their very useful comments to a previous version of this work .",
    "d. angluin , j. aspnes , m. chan , m. j. fischer , h. jiang , and r. peralta .",
    "stably computable properties of network graphs . in _ proc .",
    "distributed computing in sensor systems : 1st ieee int .",
    "_ , pages 63 - 74 , 2005 .",
    "dana angluin , james aspnes , and david eisenstat .",
    "stably computable predicates are semilinear . in _",
    "podc 06 : proceedings of the 25th annual acm symposium on principles of distributed computing _ , pages 292299 , acm press , new york , ny , usa , 2006 .        j. aspnes and e. ruppert .",
    "an introduction to population protocols .",
    "_ bulletin of the european association for theoretical computer science _ , 93:98 - 117 , oct .",
    "col . : _ distributed computing _ , editor : m. mavronicolas .",
    "o. bournez , p. chassaing , j. cohen , l. gerin , and x. koegler . on the convergence of population protocols when population goes to infinity . in",
    "_ applied mathematics and computation _ , 215(4):1340 - 1350 , 2009 .",
    "i. chatzigiannakis , s. dolev , s. p. fekete , o. michail , and p. g. spirakis .",
    "not all fair probabilistic schedulers are equivalent . in _",
    "13th international conference on principles of distributed systems ( opodis ) _ , pages 33 - 47 , nimes , france , december 15 - 18 , 2009 .",
    "i. chatzigiannakis , o. michail , s. nikolaou , a. pavlogiannis , and p. g. spirakis .",
    "all symmetric predicates in @xmath21 are stably computable by the mediated population protocol model . in _",
    "35th international symposium on mathematical foundations of computer science(mfcs ) _ , brno , czech republic , aug .",
    "i. chatzigiannakis , o. michail , and p. g. spirakis .",
    "stably decidable graph languages by mediated population protocols . in _",
    "12th international symposium on stabilization , safety , and security of distributed systems ( sss ) _",
    ", new york city , usa , sep . 2010 .",
    "i. chatzigiannakis , o. michail , and p. g. spirakis .",
    "mediated population protocols . in _",
    "36th international colloquium on automata , languages and programming ( icalp ) _ , pages 363 - 374 , rhodes , greece , 2009 .",
    "i. chatzigiannakis and p. g. spirakis .",
    "the dynamics of probabilistic population protocols . in _ distributed computing _ , _",
    "22nd international symposium _ , _ disc _ , volume 5218 of _ lncs _ , pages 498 - 499 , 2008 .",
    "c. delporte - gallet , h. fauconnier , r. guerraoui , and e. ruppert . when birds die : making population protocols fault - tolerant . in _ proc .",
    "2nd ieee international conference on distributed computing in sensor systems _ , pages 51 - 66 , 2006 .",
    "r. guerraoui and e. ruppert .",
    "names trump malice : tiny mobile agents can tolerate byzantine failures . in _",
    "36th international colloquium on automata , languages and programming ( icalp ) _ , pages 484 - 495 , greece , 2009 ."
  ],
  "abstract_text": [
    "<S> we propose a new theoretical model for passively mobile wireless sensor networks , called @xmath0 ( standing for _ passively mobile machines _ ) . the main modification w.r.t . </S>",
    "<S> the population protocol model @xcite is that agents now , instead of being automata , are turing machines . </S>",
    "<S> we provide general definitions for unbounded memories , but we are mainly interested in computations upper - bounded by @xmath1 , with @xmath2 being the size of the population ( a space bound that clearly keeps our devices tiny ) . however , our results easily generalize to any space bound which is at least @xmath1 . </S>",
    "<S> we focus on _ complete communication graphs _ and define the complexity class @xmath3 consisting of all predicates on input assignments that are stably computable by some pm protocol that uses @xmath4 memory . </S>",
    "<S> we assume that the agents are initially _ identical _ and have _ no global knowledge _ of the system , which together with the completeness of the communication graph implies that all computable predicates have to be _ </S>",
    "<S> we show that there exists a pm protocol that _ can assign unique consecutive ids to the agents and inform them of the population size _ , only by using @xmath5 memory . </S>",
    "<S> this allows us to give a direct simulation of any _ deterministic _ turing machine of @xmath6 space by pm protocols using @xmath5 space . </S>",
    "<S> going one step further , we generalize the simulation of the deterministic tm to prove that the pm model can simulate any _ </S>",
    "<S> nondeterministic _ tm of @xmath6 space under the same space bounds . </S>",
    "<S> moreover , by showing that a nondeterministic tm of @xmath6 space decides any language in @xmath7 , we end up with an exact characterization for @xmath7 : _ it is precisely the class of all symmetric predicates in _ @xmath8 . </S>",
    "<S> all these results easily generalize to the following exact characterizations for the classes @xmath3 , for all @xmath9 : _ they are precisely the classes of all symmetric predicates in _ @xmath10 . in this way </S>",
    "<S> , we provide a space hierarchy for the pm model when the memory bounds are @xmath11 . </S>",
    "<S> finally , we explore the computability of the pm model when the protocols use @xmath12 space and prove that @xmath13 when @xmath14 , where @xmath15 denotes the class of the semilinear predicates . </S>",
    "<S> in fact , we prove that this bound is tight , so that @xmath16 when @xmath17 . </S>"
  ]
}