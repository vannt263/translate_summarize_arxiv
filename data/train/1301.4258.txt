{
  "article_text": [
    "several , if not most , mainstream languages include features to support object - oriented programming , yet most of these ( c++ , c # , java , python , etc . )",
    "lack any native language support for the specification and runtime checking of class invariants .",
    "while it is usually easy enough to implement the invariant predicates themselves , manual addition imposes further requirements in order to implement the operational requirements of invariant checking and to handle the interplay of invariant specification and inheritance .",
    "class invariants are further troublesome in that they involve direct access to an object s attributes .",
    "this makes manual addition particularly unappealing , as the available choices are invasive with respect to the original interface and implementation ( to which we may not have access ) , compromise encapsulation , and are error - prone if done manually .",
    "this paper presents a lightweight , non - invasive technique for automatically extending a collection of class definitions with a corresponding collection of structural invariant checks .",
    "the invariants are given as a stand- alone specification , which is woven together with the original source files to produce a new collection of drop- in replacement classes that are behaviorally indistinguishable from the originals in the absence of invariant- related faults but will expose such faults in a way that the original classes do not .",
    "each replacement is defined to be a subclass ( indeed , a _ subtype _",
    "@xcite ) of the original class whose functionality it extends , and it can thus be substituted in any context in which the original occurs .",
    "the generation is itself completely automatic , and the incorporation into a test harness or other program is nearly seamless .",
    "we focus here on the java language , a choice that complicates the overall strategy in some ways while simplifying it in others .",
    "a _ class invariant _ is a conjunction of predicates defined on the values of an object s individual attributes and on the relationships between them .",
    "it characterizes an object s `` legal '' states , giving the predicates that must hold if the object is to represent an instance of that abstraction . usually , a class invariant is given in conjunction with the _ contracts _ for each publicly - visible method of a class , _",
    "i.e. _ , the preconditions that must hold on arguments to each method call and the consequent guarantees that are made as postconditions upon the method s return . unlike the contracts , however , a class invariant is a property concerning only an object s _ data values _ , even ( especially ) when those values are not publicly visible .",
    "an invariant must hold at every point between the object s observable actions , _",
    "i.e. _  upon creation of any object that is an instance of this class and both before and after every publicly - visible method call @xcite . at other points ,",
    "including non - visible method calls , it need not hold , and runtime checks are disabled in this case .",
    "further , since runtime invariant checks can impose a non - trivial performance penalty on a system , in general , it is desirable to have a mechanism for leaving the checks in place during testing , while removing them from a final , production system",
    ". finally , there is an important interplay between the subtype relation ( which determines when one object can safely be substituted in a context calling for another @xcite ) and class invariants : if @xmath0 is a subtype of @xmath1 ( as well as a subclass ) then the invariant for @xmath0 must include all of the constraints in @xmath1 s invariant @xcite .",
    "some languages offer native support for invariant checking , but for java and other languages that lack this , including such checks is challenging . a common approach is to make use of the language s assertion mechanism , by including assertions of the invariant at the end of each constructor body and at the beginning and end of the body of each public method @xcite . if the language s assertions mechanism is used , disabling the checking functionality after testing is usually quite easy .",
    "however , this approach carries the disadvantage of requiring the class designer to code not only the predicates themselves but also an explicit handling of the inheritance requirements and the full execution model , discussed above .",
    "both of these tasks must be implemented for each invariant definition , in each class .    to avoid the implementation burden of the assertions approach",
    ", we can use a tool that generates the invariant checks from either specialized annotations of the source code @xcite or reserved method signatures @xcite .",
    "essentially , such tools offer language extensions to resemble native support for invariant definitions . in comparison to assertion - based approaches ,",
    "they eliminate the requirement of implementing the execution model , a clear advantage . as with the assertions approach ,",
    "annotation approaches are invasive , in that they require modification of the original source code .",
    "more substantially , the approach generally requires the use of a specialized , nonstandard compiler , whose development may not keep up with that of the language .",
    "instead , we can view the addition of runtime invariant checking across a class _ hierarchy _ as a kind of cross - cutting concern , _",
    "i.e. _ code that is defined across several classes and hence resists encapsulation . under this view",
    ", it is natural to approach this problem as one of aspect - oriented programming ( aop ) @xcite , in which we can use a tool such as aspectj @xcite to define the checks separately as aspects .",
    "the entry and exit points of each method become the join points , the point cuts are inferred from a class s method signatures , and the invariant check itself becomes the advice @xcite . unlike annotation - based approaches , aspect weaving can be done without the need for a non - standard compiler , either through source code transformation or byte code instrumentation @xcite .",
    "however , the aop approach also presents several difficulties .",
    "for example , balzer _ et al .",
    "_ note that mainstream tools such as aspectj lack a mechanism to enforce the requirement that the definition of a class s invariant include the invariant of its parent class @xcite .",
    "it is possible to write invariant checking `` advice '' so that it correctly calls the parent class s invariant check , but this must be done manually ( _ e.g. _ @xcite ) .",
    "a similar problem occurs in implementing the correct disabling of checks on non - public calls .",
    "lastly , because aspects can not in general be prevented from changing an object s state , the weaving of additional aspects may compose poorly with the aspect that provides the invariant check @xcite .",
    "it is possible that another aspect could break the class invariant , and since interleaving of multiple aspects is difficult to control , it is possible the two aspects could interleave in such a way as to make the invariant failure go undetected .",
    "the work closest in spirit to our own is the design pattern approach of gibbs , malloy , and power ( @xcite . targeting development in the c++ language , they present a choice of two patterns for weaving a separate specification of invariant checks into a class hierarchy , based on the well known _ decorator _ and _ visitor _",
    "patterns @xcite .",
    "however , the decorator approach involves a fairly substantial refactoring of the original source code .",
    "moreover , the authors note that this technique interacts poorly with the need to structure invariant checks across a full class hierarchy .",
    "the refactoring in this case is complex , and it requires the use of multiple inheritance to relate the decorated classes appropriately , making it unsuitable for languages such as java , which support only single inheritance .",
    "their alternative is an application of the visitor pattern , in which the invariant checks are implemented as the _ visit _ methods in a single _ visitor _ class .",
    "this pattern usually requires that the classes on the `` data side '' implement an _",
    "accept _ method , which is used to dispatch the appropriate _ visit _ method , but in their use of it , only the top of the class hierarchy is modified to be a subclass of an `` invariant facilitator '' , which handles all _ accept _ implementations .",
    "however , successful implementation of the _ visit _ methods rests on the assumption that all fields are either publicly visible or have their values readily available through the existence of accessor ( `` getter '' ) methods . unless the language simply lacks a mechanism to hide this representation ( _ e.g. _ python )",
    ", such exposure is unlikely to be the case , as it violates encapsulation , permitting uncontrolled manipulation of an object s parts , either directly or through aliasing @xcite .",
    "the central thesis of our work is that , under assumptions common to java and other statically - typed oo languages , these limitations  source code modification , multiple inheritance , and public accessibility of fields  are unnecessary for a design - pattern approach .",
    "the remainder of the present paper shows how to relax them .",
    "our approach draws from the gibbs / malloy / power design pattern efforts and from ideas in aop in the treatment of invariant specifications as a cross - cutting concern .",
    "we begin with an assumption that the class invariants are given in a single specification file , separate from classes that they document .",
    "each constraint is a boolean- valued java expression , with the invariant taken to be the conjunction of these expressions .",
    "we assume ( though do not hope to enforce ) that these expressions are free of side effects , and that the invariant given for a child class does not contradict any predicates in inherited invariants",
    ". otherwise , the particulars of the specification format are unimportant . the current version of our tool uses json @xcite , but any format for semi - structured data will do .",
    "we focus on the java programming language , which means that we assume a statically - typed , object - oriented language , with introspective reflection capabilities , support for type parameters in class definitions , single inheritance ( though implementation of multiple interfaces is possible ) , and a uniform model of virtual method dispatch .",
    "we make some simplifications of the full problem . specifically , we work only with synchronization- free , single - threaded , non-_final _ class definitions , and we consider only instance methods of a class that admit overriding , _",
    "i.e. _ , non-_static _ , non-_final _ method definitions .",
    "we do not consider anonymous inner class constructs nor the _ lambda expressions _ planned for java 8 @xcite .",
    "finally , we assume a class s field visibility grants at least access through inheritance ( _ i.e. _ _ protected _ accessbility or higher ) .",
    "this last is made purely for the sake of simplifying the technical presentation , since , as discussed in section [ concl ] , introspection makes it easy to handle variables of any accessibility .",
    "as a first effort , we will try an approach that leverages the mechanism of inheritance and the redefinition of inherited method signatures through subtyping polymorphism .",
    "the idea is to derive from a class and its invariant a subclass , in which we wrap the invariant in a new , non - public method ( perhaps with additional error reporting features ) , similar to the `` _ repok _ '' approach advocated by liskov and guttag @xcite . to this new subclass",
    ", we also add methods @xmath2 and @xmath3 to handle the checking tasks at ( respectively ) method entry and exit points , and we use these to define constructors and overridden versions of every public method .",
    "let @xmath1 be a class , with parametric type expression @xmath4 defined on type parameters @xmath5 , field declarations @xmath6 , invariant @xmath7 , constructor definition @xmath8 and public method @xmath9 .",
    "we extend @xmath1 with runtime checking of @xmath7 by generating the subclass in fig .",
    "[ fig : naive - inh ] , where @xmath10 and @xmath11 are identical to @xmath4 and @xmath12 ( respectively ) , except perhaps for renaming of type parameters ( _ i.e. _ , they are @xmath13-equivalent ) .",
    "l `` ` public `  ` class `  @xmath14`<`@xmath10 ` > `  ` extends `   @xmath1`<`@xmath11 ` > ` \\ { + ` private int \\delta = 0 ; ` + `` public  @xmath1`(`@xmath15 ` ) `  \\ { + ` super(\\overrightarrow{x } ) ; ` +   +   + ` } ` + `` public  @xmath16`(`@xmath17 ` ) `  \\ {   +    + ` return \\chi ; ` + ` } ` + ` private boolean inv ( ) { return  \\rho_a ; } ` + `` private void @xmath2 ( ) \\ { + ` if ( \\delta = = 0 & & ! inv ( ) ) ` +   +   + ` } ` + `` private void @xmath3 ( ) \\ { +   + ` if ( \\delta = = 0 & & ! inv ( ) ) ` +   + ` } ` + ` } ` +    for each constructor in @xmath14 , the body executes the `` real '' statements of the corresponding superclass constructor , followed by a check of @xmath7 , whose execution is itself controlled by the @xmath3 method .",
    "likewise , the body of each public method @xmath18 wraps a call to the superclass s version between checks of @xmath7 , with execution controlled by the @xmath2 and @xmath3 methods .",
    "if @xmath18 returns a value , then this value is captured in the overridden version in a `` result '' variable , @xmath19 . a method or",
    "constructor call is publicly - visible precisely when the call stack depth on a given @xmath14 object is 0 , and this value is tracked by the additional integer - valued field @xmath20 .",
    "the @xmath2 and @xmath3 methods increment / decrement @xmath20 as appropriate , evaluating @xmath7 only if @xmath21 .",
    "the inheritance - based approach suggests an easy mechanism for reusing code while adding the necessary invariant checks and capturing the distinction between publicly - visible and inner method calls . for the user ,",
    "the burden consists of replacing constructor calls to @xmath1 with the corresponding calls for @xmath14 .",
    "this may be an excessive requirement when @xmath1 objects are used in production - level code , but in many settings where invariant checking is desirable , such constructor calls are limited to only a handful of sites . in the junit framework , for example , integration of @xmath14 objects into unit tests for @xmath1 is likely quite simple , as object construction occurs mainly in the body of a single method , _",
    "setup_.    note the assumptions of uniform polymorphic dispatch and non-_final _ declarations here .",
    "if a class can not be extended ( _ e.g. _ _ string _ and other objects in the _ java.lang _ package ) , then construction of a subclass that implements the invariant checks is obviously impossible . similarly ,",
    "a method whose dispatch is statically determined can not be transparently overridden , and if declared _ final _ , it can not be overridden at all . in many languages (",
    "notably , c # and c++ ) the default convention is _ static _",
    "dispatch , with dynamic binding requiring an explicit _ virtual _ designation ; in such cases , the inheritance construction is far less convenient and may be impossible without some refactoring of the original source code .",
    "unfortunately , our first attempt fails in two critical ways , which becomes apparent when we attempt to construct the invariant - checking extension across a hierarchy of class definitions .",
    "first of all , the inheritance hierarchy of a collection of objects requires a corresponding structure in the composition of invariant checks .",
    "this problem is very similar to the one encountered in the `` decorator '' approach of @xcite , but the multiple - inheritance solution given there is unavailable in a single - inheritance language such as java .",
    "consider a class @xmath0 that is a subtype of @xmath1 ( written @xmath22 ) :        figure [ fig : naive - limit ] depicts the problem to denote the substitution of type expression @xmath23 for the type parameter @xmath24 in expression @xmath25 , and use the shorthand @xmath26 to denote the composition of type expressions @xmath27 . ] .",
    "the invariant for a @xmath0 object , @xmath28 , must include the @xmath1 invariant_i.e .",
    "_ , @xmath29 . however , a @xmath30 object can not access the fields of its associated @xmath0 object through inheritance and also reuse the functionality of the @xmath31 method .",
    "we might choose to have @xmath30 descend from @xmath14 instead , but this only works if all fields in @xmath0 are publicly accessible . as discussed above",
    ", this is unlikely to be the case .",
    "the second , related failure is that inheritance does not facilitate a correct binding of the type parameters .",
    "again , this is clear from fig .",
    "[ fig : naive - limit ] .",
    "an instantiation of @xmath0 supplies a type @xmath23 to the parameters @xmath32 , which is used in turn to bind the parameters @xmath33 with argument @xmath34 .",
    "when we instantiate @xmath30 instead , this same @xmath23 binds the parameters @xmath35 , with the resulting chain of arguments binding @xmath1 s parameters @xmath12 as @xmath36 . for correct use of the @xmath14 invariant check in this @xmath37 object , we would need to bind the type parameter of @xmath14 , @xmath11 , in the same way we do @xmath1 s parameter , @xmath5 ; _ i.e. _ with argument @xmath38 , a binding that can not be ensured , unless @xmath30 is a subclass of @xmath14 .      though unsuccessful on its own",
    ", we can use the inheritance approach of section [ invcheck : inh - approach ] as the basis for an auxiliary pattern , which we call an _ exposure pattern_. the idea is to construct from the original hierarchy a corresponding set of classes that offers the interface of the original collection and in addition , a controlled exposure of each object s representation . the machinery for checking the invariants is factored into separate classes , as discussed in section [ invcheck ] , below .    consider a class definition    we derive the _ exposure _ interface    and _ exposed _ class    where @xmath10 , @xmath39 and @xmath11 , @xmath40 are @xmath13-equivalent to @xmath41 and @xmath33 , as above .",
    "note that the fields @xmath42 include all of the original @xmath43 and perhaps others , as discussed on page , below .",
    "the constructors and public methods in @xmath44 are overridden in exactly the same manner as in the @xmath14 class of section [ invcheck : inh - approach ] , and likewise the implementation of the @xmath45 and @xmath46 methods .",
    "the representation exposure happens through the @xmath47 , a set of raw `` getter '' methods that expose each of the object s fields . in the presence of inheritance ,",
    "the corresponding structure is realized not in the derived class but in the derived _",
    "interfaces_. thus , for example ,    gives rise to the interface and class definitions    the construction is illustrated in fig .",
    "[ fig : exposure - pattern ] .          since the type expressions in a class definition are copied to its exposed class and interface ( perhaps with @xmath13-renaming of the parameters ) , it is easy to see that    [ prop : type - correctness ] for any type expression @xmath23 , an instance of a class @xmath1 has type @xmath48 if and only if @xmath44 and @xmath49 have types @xmath50 and @xmath51 , respectively .",
    "the construction of the accessor methods is less obvious .",
    "while we construct @xmath47 for each of the fields @xmath52 , we may need to construct others , as well , in case the invariant @xmath7 makes reference to any inherited fields for which we have not already constructed an interface .",
    "this can happen in the case of an incomplete specification of the class hierarchy and invariants . the simplest way to handle",
    "this is to include in the interface a @xmath47 for each declared field in the corresponding @xmath1 classes and also for each variable that occurs without explicit declaration in the the predicate @xmath7 .",
    "however , we can leverage the inheritance of interfaces to eliminate redundant declarations ( though not implementations , as discussed below ) .    to make the construction precise",
    ", we denote the _ free variables _ of the predicate @xmath7 by @xmath53 , _",
    "i.e. _ those variables that occur in @xmath7 without being explicitly declared in @xmath7 .",
    "conversely , the _ bound _",
    "variables in a class @xmath1 , @xmath54 , are the instance fields declared in @xmath1 .",
    "the following definition captures the notion of variables that are `` free '' in @xmath1 through inheritance :    [ defn : inh ] let @xmath55 be a specification of a collection of classes and their associated invariants . for a class @xmath1 , _ the set of fields exposed through inheritance in @xmath1 _ , @xmath56 ,",
    "is defined by    @xmath57    we use this to define the necessary method signatures in each exposure interface .",
    "[ defn : exp - interface ] given class @xmath1 and invariant @xmath7 , the body of @xmath49 consists of the the signatures @xmath58 where each @xmath59 is the declared type of @xmath60 .",
    "[ defn : succ - exposure ] for a field , @xmath61 , either declared in or inherited by a class @xmath1 , we say that @xmath60 is _ successfully exposed for a _ if either    * there is an interface @xmath49 and subclass + [ cols= \" < \" , ]    + and for every @xmath44 object @xmath62 , @xmath63 * @xmath1 is a subclass of @xmath64 , and @xmath60 is successfully exposed for @xmath64 .",
    "given @xmath1 and @xmath7 , the construction for @xmath49 in definition [ defn : exp - interface ] and the accompanying implementation @xmath44 combine to give us the representation exposure we need for @xmath7 .",
    "in particular ,    [ prop : exposure - correctness ] if @xmath65 , then @xmath66 is successfully exposed for @xmath1 .",
    "the primary difference between the exposure pattern construction and the inheritance - based effort of section [ invcheck : inh - approach ] lies in the construction of the exposure interfaces , whose inheritance structure is congruent to that of the original collection of classes . like the earlier attempt , however",
    ", the collection of exposed _ classes _ does not share this same relation , and as a consequence , both approaches are subject to some unfortunate redundancy consequences .",
    "in particular , we can not reuse code between distinct exposed classes , even when the classes they expose are related by inheritance .",
    "for example , if a class @xmath1 contains fields @xmath67 and @xmath68 and public method @xmath69 then the exposed class @xmath44 must override @xmath69 , and it must include exposure methods @xmath70 and @xmath71 , according to the interface @xmath49 .",
    "if @xmath22 contains fields @xmath72 , @xmath73 , and method @xmath74 , then it must override not only @xmath74 but also @xmath69 , with the body of the overridden @xmath69 identical to that in @xmath44 .",
    "likewise , it must implement not only the @xmath75 and @xmath76 methods from the @xmath77 interface , but also @xmath70 and @xmath71 .",
    "happily , all of this is easily automated , and it is reasonable to suppose the space overhead manageable .",
    "note first that , with the exception of classes at the top of a specified hierarchy , the size of the interface generated for a class is proportional to the number of fields in that class .",
    "recalling definitions [ defn : inh ] and [ defn : exp - interface ] , we can see that this is so because    [ prop : inh - trivial ] let @xmath64 be a class included in a specification @xmath55 . for every class @xmath78 , @xmath79 .",
    "in other words , only for classes specified at the top of an inheritance hierarchy will we ever need to generate additional @xmath80 declarations in the corresponding interfaces . in all other cases ,",
    "the accessor interfaces for inherited fields are inherited from the corresponding parent interfaces .",
    "hence , the space required to extend a collection of classes depends only on the size of each class and the depth of the inheritance relationship in the collection . specifically , if we assume a bound of @xmath81 new field and method definitions on each class and an inheritance depth of @xmath82 , then the overall space growth is given by    @xmath83    it is difficult to give a general characterization of either @xmath81 or @xmath82 , but there is reason to suspect that both are manageable values in practice .",
    "mcconnell recommends a limit of 7 new method definitions in a class @xcite .",
    "study @xcite finds no significant threshold value for @xmath82 .",
    "classes in the jdk s _ java .",
    "* _ and _ javax . *",
    "_ libraries implement anywhere from less than 10 to over 100 new methods , while the largest depth of any inheritance tree is 8 .      as in gibbs / malloy / power @xcite",
    ", we implement the runtime invariant checks themselves through an application of the _ visitor pattern _ @xcite , in which the methods implementing the invariant checks are aggregated into a single class ( the `` visitor '' ) , with the appropriate method called from within the class being checked ( the `` acceptor '' ) . unlike their approach , however , our exposure pattern allows us to do this without modification of any part of the original source files , not even at the top of the inheritance hierarchy .",
    "suppose we have a class @xmath84 , with invariant @xmath7 . from these",
    ", we generate the exposed class @xmath85 and the exposure interface @xmath86 , as in section [ ssec : exposure ] .",
    "the specification of @xmath7 and the access methods defined for @xmath49 are used to generate an invariant checking `` visitor '' class :    where @xmath87 and @xmath88 are equivalent to @xmath4 and its parameters @xmath33 , as above .",
    "runtime checking of @xmath7 is invoked in the @xmath44 methods through calls to that class s @xmath89 method , which serves as the `` accept '' method , handling dispatch of the appropriate invariant check :    note that each @xmath90 method in @xmath91 takes an argument of type @xmath49 and not @xmath44 .",
    "this is necessary , because of the need to compose an invariant check with that of the object s superclass in each invariant method .",
    "for example , if we have @xmath22 , we define @xmath92 as    since @xmath44 and @xmath93 are not related by inheritance , it would not be possible to directly cast ` obj ` to its superclass s exposed version . fortunately , the interface is all we need .    finally ,",
    "although we structure our solution here according to the traditional visitor pattern conventions , we do not really need the full generality of that pattern .",
    "in particular , it is unnecessary to support full double dispatch , as we only need one instance of @xmath91 , and no @xmath94 method will ever invoke a call back to the @xmath95 method of an object ( not even indirectly , since the @xmath2 and @xmath3 methods in a class prevent a call to @xmath95 if one is already running ) .",
    "our implementation of this approach as an eclipse plugin instead drops the @xmath91 parameter from every @xmath89 method , relying instead on a single , static instance of the invariant visitor :",
    "method contracts and class invariants are particularly useful in testing . in combination with test oracles ,",
    "the use of runtime invariant and pre / post - conditions checks improves the exposure of faults as well as the diagnosability of faults when they are detected @xcite .",
    "our implementation as an eclipse plug has proven useful in diagnosing invariant - related faults .    for example , a simple list interface provides an abstraction for the list data type . a standard way to implement",
    "this is with an underlying doubly - linked list , in which we keep a pair of `` sentinel '' head and tail nodes , with the `` real '' nodes in the list linked in between :    ....      public abstract class abstractlist < t > implements list < t > {          protected int size ;          ...      }           public class dlinkedlist < t > extends abstractlist < t > implements list < t > {          // inherited from abstractlist :   int size          protected dnode < t > head ,   tail ;   ...      } ....    among other predicates , the invariant for _ dlinkedlist _ requires that @xmath96 , @xmath97 .",
    "this was given as part of a project for the first author s data structures course , and among the student submissions received was this implementation of _ remove ( ) _ , in which the _ cur.prev _ pointer is not correctly updated :    ....      public boolean remove(t v ) {          dnode < t > cur = head.next ;                  while ( cur ! = tail ) {              if ( cur.data.equals(v ) ) {                  dnode < t > prev = cur.prev ;   cur = cur.next ;   prev.next = cur ;                  size-- ;                                  return true ;              } else                  cur = cur.next ;          }                     return false ;      } ....    a junit test suite failed to uncover this fault , passing this and the tests for 12 other methods :    ....      public void testremove ( ) {          ls.add(\"a \" ) ; ls.add(\"b \" ) ; ls.add(\"c \" ) ; ls.add(\"d \" ) ; ls.add(\"a \" ) ; ls.add(\"d \" ) ;           int sz = ls.size ( ) ;          asserttrue(ls.remove(\"a \" ) ) ;     asserttrue(ls.size ( ) = = sz - 1 ) ;          sz = ls.size ( ) ;                  asserttrue(!ls.remove ( \" * * \" ) ) ;     asserttrue(ls.size ( ) = = sz ) ;      } ....    from the original source code and a specification of invariants our tool generates the classes and interfaces    ....      public interface iexposedabstractlist < t > {          int _ getsize ( ) ;      }      public interface iexposeddlinkedlist < t > extends iexposedabstractlist < t > {          dnode < t > _ gethead ( ) ;          dnode < t > _ gettail ( ) ;      }           public abstract class exposedabstractlist",
    "< t >                             extends abstractlist < t > implements iexposedabstractlist < t > { ... }                           public class exposeddlinkedlist",
    "< t >                              extends dlinkedlist < t > implements iexposeddlinkedlist < t > { ... }                   public class repokvisitor {          ...          public < t > void visit(iexposedabstractlist < t > _ inst ) { ... }          public < t > void visit(iexposeddlinkedlist < t > _ inst ) { ... }          ...      } ....    objects in a junit test suite are constructed in the _ setup ( ) _ method , and a simple modification was all that was needed to cause _ testremove ( ) _ to fail appropriately :    ....      protected void setup ( ) {      //     ls = new dlinkedlist < string > ( ) ;          ls = new exposeddlinkedlist < string > ( ) ;      } ....",
    "the design pattern given here provides a fairly seamless approach for adding correct runtime invariant checking to a class hierarchy , through the construction of drop - in replacements that can be removed as easily as inserted .",
    "in addition to the core material presented here , there are a number of extensions possible .",
    "for example , the presentation in this paper relies on the assumption above that all fields in a class are accessible through inheritance .",
    "happily , this is an easy if tedious limitation to overcome .",
    "if instead the field is declared with only intra - object or intra - class access ( _ e.g. _ java s `` private '' ) , we can use the introspective capabilities of the language to manufacture a locally - visible _ get _ method . to access a ` private ` field @xmath66 , for example , our implementation generates a @xmath98 that handles the unwieldy details of java introspection :      finally , the work described here incorporates only the invariant checks , rather than full contracts , and it would clearly be useful to extend our design pattern to support this . while we conjecture that our technique is easily extendable to this purpose , the invariant checks present the most interesting problems , owing to their need for attribute access and hierarchical definition . philosophically",
    ", ordinary unit testing already performs at least the behavioral components of contract checking , _ i.e. _ the checks of pre and post - conditions .",
    "what unit testing can not do is determine whether the invariant continues to hold , as it is often impossible to access an object s fields .",
    "the difference lies in the fact that both pre and post conditions are inherently extensional specifications .",
    "they impose requirements on method arguments and return values , but on the object itself , all constraints are made upon the abstraction of the object , not the concrete implementation . that implementation whose consistency with the abstraction is the core assertion of a class invariant  is by definition opaque to an object s user .",
    "the ideas in this paper began with an assignment in the first author s spring 2010 software construction class , and the students there provided valuable feedback .",
    "our thanks also to prof .",
    "peter boothe of manhattan college , for help in analyzing the inheritance and method complexity of the jdk .",
    "klaeren , h. , pulvermller , e. , rashid , a. , speck , a. : aspect composition applying the design by contract principle . in butler , g. , jarzabek , s. , eds .",
    ": gcse 00 .",
    "volume 2177 of lncs . , springer ( 2000 ) 5769"
  ],
  "abstract_text": [
    "<S> we present a technique for automatically weaving structural invariant checks into an existing collection of classes . using variations on existing design patterns </S>",
    "<S> , we use a concise specification to generate from this collection a new set of classes that implement the interfaces of the originals , but with the addition of user - specified class invariant checks . </S>",
    "<S> our work is notable in the scarcity of assumptions made . </S>",
    "<S> unlike previous design pattern approaches to this problem , our technique requires no modification of the original source code , relies only on single inheritance , and does not require that the attributes used in the checks be publicly visible . </S>",
    "<S> we are able to instrument a wide variety of class hierarchies , including those with pure interfaces , abstract classes and classes with type parameters . </S>",
    "<S> we have implemented the construction as an eclipse plug - in for java development . </S>"
  ]
}