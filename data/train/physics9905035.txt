{
  "article_text": [
    "as it was shown in @xcite the application of recursion makes it possible to create compact , explicit and effective integration programs . in the mentioned papers the c++ version of such a routine",
    "is presented .",
    "however , it is historically formed that a large number of science and engineering fortran-77 codes have been accumulated by now in the form of applied libraries and packages .",
    "that is one of the reasons why fortran-77 is still quite popular in the applied programming . from this standpoint it seems to be very useful to use such an effective recursive integration algorithm in fortran-77 .",
    "there exist at least two possibilities to realize it .",
    "the first one is described in @xcite where the interface for calling mentioned c++ recursive integration function from ms fortran-77 is presented .",
    "the second possibility consist in constructing the recursive subroutine by means of fortran-77 only .",
    "this is the particular subject of the paper where the possibility and benefits of recursion strategy in ms fortran-77 is discussed .",
    "the direct transformation of the mentioned c++ code is not possible mainly due to the formal inhibition of the recursion in fortran-77 .",
    "however , microsoft extensions of fortran-77 ( e.g. ms fortran v.5.0 , fortran power station ) allow to make indirect recursive calls .",
    "it means that subprogram can call itself through intermediate subprogram .",
    "if anybody doubts he can immediately try :    = = + call rec(1.0 ) + end + subroutine rec(hh ) + integer i/0/ + i = i + 1 + h = 0.5*hh + write ( * , * ) i , h + if ( i.lt.3 ) call mediator(h ) + write ( * , * ) i , h + end + subroutine mediator(h ) + call rec(h ) + end    and get the following results :    = = + 1 5.000000e-01 + 2 2.500000e-01 + 3 1.250000e-01 + 3 1.250000e-01 + 3 1.250000e-01 + 3 1.250000e-01 +    but this is not a true recursion because no mechanism is supplied for restoring the values of the internal variables of the subroutine after its returning from recursion .",
    "the last requirement can be fulfilled by the forced storing of the internal variables into the program stack .",
    "the automatic description of variables provides such possibility in ms fortran-77 . taking this into account ,",
    "the above example can be rewritten :    = = + call rec(1.0 ) + end + subroutine rec(hh ) + integer i/0/ + automatic h , i + i = i + 1 + h = 0.5*hh + write ( * , * ) i , h + if ( i.lt.3 ) call mediator(h ) + write ( * , * ) i , h + end + subroutine mediator(h ) + call rec(h ) + end    that yields :    = = + 1 5.000000e-01 + 2 2.500000e-01 + 3 1.250000e-01 + 3 1.250000e-01 + 3 2.500000e-01 + 3 5.000000e-01 +    here the values of _ h _ are restored after each returning from recursion because it is saved in the stack before the recursive call . note , that although the _ i _ variable is described as automatic nonetheless its value is not saved .",
    "the described possibilities allow to employ effective recursion strategy for creating adaptive quadrature subroutine in ms fortran-77 .",
    "the presented algorithm consists of two independent parts : adaptive subroutine and quadrature formula .",
    "the adaptive subroutine uses recursive algorithm to implement standard bisection method ( see fig.[fig1 ] ) . for reaching desired relative accuracy @xmath0 of the integration the integral estimation @xmath1 over [ @xmath2,@xmath3 subinterval on the i - th step of bisection",
    "is compared with the sum of @xmath4 and @xmath5 integral values that are evaluated over left and right halves of the considered subinterval .",
    "the comparison rule was chosen in the form :    @xmath6    where @xmath7 denotes the integral sum over whole integration interval [ a , b ] .",
    "the value of @xmath7 is accumulated and adjusted on each step of bisection .",
    "should ( [ qrule ] ) be not fulfilled the adaptive procedure is called recursively for both ( left and right ) subintervals .",
    "evaluation of the integral sums on each step of bisection is performed by means of quadrature formula .",
    "there are no restrictions on the type of quadratures used during integration .",
    "this makes the code to be very flexible and applicable to a wide range of integration problems .",
    "the form ( [ qrule ] ) of the chosen comparison rule does not pretend on effectiveness rather on simplicity and generality .",
    "really it seems to be very common and does not depend on the integrand as well as quadrature type .",
    "at the same time the use of ( [ qrule ] ) in some cases can result in overestimation of the calculated integral that consequently leads to more integrand function calls .",
    "one certainly can get some gains using , for instance , definite quadratures with different number or / and equidistant points or gauss - kronrod quadrature @xcite etc .",
    "the comparison rule in the later cases becomes more effective but complex , intricate and sometimes less common .",
    "whatever the case , the choice of comparison rule as well as the problems connected with it lie outside the subject of the publication .",
    "let us note some advantages which the application of the recursive call ideology to numerical integration can reveal :    * very simple and evident algorithm that could result in extremely short as well as easy for further modifications and possible enhancements adaptive code . * because of the indicated shortness the adaptive procedure s own running time has to be diminutive .",
    "that could result in its better performance compared to the known programs especially in the cases when the integrand function calculations are not time consuming .",
    "* there is no need to store the integrand function values and pay attention on their correct usage . besides no longer the control of subinterval bounds is in need .",
    "indicated features permit utmost reduction of the efforts that one has to pay while creating the adaptive code . * nothing but program s stack size sets the restriction on the number of subintervals when the recursive procedure is used ( see next section ) . at the same time for the existing programs the crush level of the primary interval",
    "is strictly limited by the dimensions of the static arrays .",
    "fortran-77 version of adaptive subroutine practically coincides with the corresponding c++ quadrec ( quadrature used adaptively and recursively ) function @xcite :    .... subroutine quadrec(fun , left , right , estimation ) real*8 fun , left , right , estimation real*8 eps , result , section , sumleft , sumright , quadrule integer*4 recmax , reccur , rawint common /ip/ eps , result , recmax , rawint , reccur automatic sumleft , sumright , section external fun reccur = reccur+1 if ( reccur.le.recmax ) then    section = 0.5d0*(left+right )    sumleft = quadrule(fun , left , section )    sumright = quadrule(fun , section , right )    result = result+sumleft+sumright - estimation    if ( dabs(sumleft+sumright - estimation).gt.eps*dabs(result ) ) then      call mediator(fun , left , section , sumleft )      call mediator(fun , section , right , sumright )    end if else    rawint = rawint+1 end if reccur = reccur-1 return end ....",
    "note that subroutine contains only eleven executable statements .",
    "the integrand function name , left and right bounds of the integration interval as well as the initial estimation of the integral value are the formal arguments of the subroutine .",
    "the ip common block contains the following variables : desired relative accuracy ( _ eps _ ) , the result of the integration ( _ result _ ) , maximum and current levels of recursion ( _ recmax , reccur _ ) as well as raw ( not processed during integration ) subintervals ( _ rawint _ ) .    the _ section _ variable is used for storing a value of midpoint of the current subinterval .",
    "the integral sums over its left and right halves are estimated by _",
    "quadrule _ external function and stored in _",
    "leftsum _ and _ rightsum _ variables .",
    "the last three variables are declared as automatic allowing to preserve their values from changing and use them after returning from recursion .",
    "execution of the subroutine begins with increasing of recursion level counter .",
    "if its value does not exceed _ recmax _ , the integral sums over left and right halves of the current subinterval are evaluated , the integration result is updated and accuracy of the integration is checked .",
    "if achieved accuracy is not sufficient then subprogram calls itself ( with the help of mediator subroutine ) over left and right halves of subinterval . in the case",
    "the accuracy condition is satisfied the recursion counter decreases and subprogram returns to the previous level of recursion .",
    "the number of raw subintervals is increased when desired accuracy is not reached and _ reccur _ is equal to _",
    "the mediator subroutine has only one executable statement :    ....        subroutine mediator(fun , left , right , estimation )        real*8 estimation , fun , left , right        external fun        call quadrec(fun , left , right , estimation )        return        end ....    the main part of the integration program can be look like :    ....        common    /ip/ eps , result , recmax , rawint , reccur        common    /xw/ x , w , n        integer   recmax , rawint , reccur        real*8    x(100 ) , w(100 ) , left/0.0d0/ , right/1.0d0/        real*8    result , eps , quadrule        real*8    integrand        external integrand        eps = 1.0d-14        n = 10        reccur = 0        recmax = 10        call gauleg(-1.0d0,1.0d0,x , w , n )        result = quadrule(integrand , left , right )        call quadrec(integrand , left , right , result )        write ( * , * ) ' result = ' , result , '   rawint = ' , rawint        end ....    the common block _ xw _ contains gaussian abscissas and weights which are calculated with the help of _ gauleg _ subroutine for a given number of points _",
    "n_. the text of subroutine , reproduced from @xcite , is presented in appendix [ gl ] .",
    "the text of _ quadrule _ function is presented below :    ....        real*8 function quadrule(integrand , left , right )        common /xw/ x , w , n        real*8 x(100),w(100),intsum , abscissa , left , right , integrand        intsum = 0.0d0        do 1",
    "i = 1 , n        abscissa = 0.5d0*(right+left+(right - left)*x(i ) ) 1      intsum = intsum + w(i)*integrand(abscissa )        quadrule = 0.5d0*intsum*(right - left )        return        end ....    it is important to note that the number of recursive calls is limited by the size the program stack .",
    "this fact obviously sets the limit on the reachable number of the primary integration interval bisections and consequently restricts the integration accuracy .",
    "note that stack size of the program can be enlarged by using /fxxxx option of ms fortran-77 compiler .",
    "the program testing was performed on four different integrals . in each case",
    "the exact values can be found analytically . that made it possible to control the desired and reached accuracy of the integration .",
    "besides the same integrals were obtained with the help of well - known adaptive program quanc8 reproduced from @xcite .",
    "it allowed to compare the number of integrand function calls and the number of raw intervals for both programs .",
    "the presented comparison has merely the aim to show that the use of recursion allows to construct very short and simple adaptive quadrature code that is not inferior to such a sophisticated program as quanc8 .",
    "meanwhile the direct comparison of these programs seems to be incorrect because of a number of reasons .",
    "the newton - cotes equidistant quadrature formula which is used in quanc8 allows to make reuse of integrand function values calculated in the previous steps of bisection .",
    "that is the reason why quanc8 has to have higher performance in integrand function calls compared to adaptive programs that use quadratures with non - equidistant points . since quadrec is not oriented on the use of definite but any quadrature formula it can be specified as a program of the later type .    at the same time quanc8 gives bad results for functions with unlimitedly growing derivative and",
    "does not work at all for functions that go to infinity at the either of the integration interval endpoints .",
    "there are none of the indicated restrictions in quadrec .",
    "furthermore the opportunity of choosing of quadrature type makes it to be a very flexible tool for integration . here",
    "quadrec gives a chance to choose quadrature which is the most appropriate to the task ( see section [ optim ] ) .    for integrals in sections [ section4_1 ] and [ section4_2 ]",
    "the optimal numbers of quadrature points were found and used for integration .",
    "the 24-point quadrature was applied for integration in sections [ section4_3 ] and [ section4_4 ] .",
    "let us start with the calculation of the integral cited in @xcite : @xmath8    the integrand is the sum of two lorenz type peaks and a constant background . at the beginning",
    ", values of @xmath9 , @xmath10 , @xmath11 , @xmath12 and @xmath13 parameters were chosen to be the same as in the cited work",
    ". then test was conducted at decreasing values of @xmath10 and @xmath12 , which determine width of the peaks , while both programs satisfied desired accuracy and did not signal about raw subintervals .",
    "the results of the test when @xmath14 are presented in table [ tab : number2 ] .",
    "note that only the optimal values are given for quadrec program .",
    "the corresponding optimal numbers of gaussian quadrature points are indicated .",
    ".testing results for integral ( 2 ) . [ cols=\"^,^,^,^,^,^ \" , ]     [ tab : number6 ]",
    "here we want to take note of the possibility to minimize number of integrand calls by choosing the quadrature with optimal number of abscissas .",
    "the fig.[fig2 ] demonstrates such a possibility .",
    "particularly , circles present the number of integrand calls versus the number of gaussian abscissas used for the integration of [ pr:2 ] over [ 0,1 ] and desired relative accuracy of @xmath15 and @xmath16 , @xmath17 , @xmath18 , @xmath19 , @xmath20 . from the presented data",
    "one can see that the optimal number of gaussian abscissas ranges approximately from 7 to 17 .",
    "the use of more gaussian abscissas leads to the linear growth of the number of function calls , because it does not result in essential reduction of the integration interval fragmentation . from the other hand the use of less number of gaussian abscissas results in the significant growth of the number of function calls due to the extremely high fragmentation required .",
    "dependence of the maximum recursion level upon the number of abscissas , presented by triangles , confirms this consideration .    note that despite significant differences of the testing integrals ( [ pr:2],[pr:3 ] ) the optimal number of gaussian abscissas turned out to be in the above limits .",
    "thus , the indirect recursion combined with automatic variable description allow to employ true recursion mechanism in ms fortran-77 . in particular , the recursion strategy was applied to create effective adaptive quadrature code . despite the simplicity and extremely small program body it showed good results on rather complex testing integrals .",
    "the created subroutine is very flexible and applicable to a wide range of integration problems .",
    "in particular , it was applied for constructing effective hilbert transformation program .",
    "the last one was used to restore frequency dependence of refraction coefficient in analysis of optical properties of complex organic compounds .",
    "the subroutine can be easily incorporated into existing fortran programs .",
    "note that the coding trick , described in the paper , is very convenient for constructing multidimensional adaptive quadrature programs .",
    "we express our thanks to dr.v.k.basenko for stimulating and useful discussion of the problem .",
    "30 j.n.lynnes , comm .",
    "acm 13(1970 ) , p.260 .",
    "genz and j.s.chisholm , computer ph 4(1972 ) , p. 11 - 15 .",
    "kahaner and m.b .",
    "wells , siam rev 18(1976 ) , p. 811 .",
    "g.e.forsythe,m.a.malcolm,c.b.moler , computer methods for mathematical computations ( princeton hall inc .",
    "lewellen , computer physics communication 27(1982 ) , p. 167 - 178 .",
    "corliss and l.b rall , siam j sci 8(1987 ) , p.831 - 847 .",
    "kronrod a.s.,1964 .",
    "doklady akdemii nauk sssr , vol .",
    "154 , p. 283 - 286 .",
    "w.h.press , s.a.teukolsky , w.t.vetterling , b.p.flannery .",
    "numerical recipes in fortran .",
    "j.mathews , r.l.walker .",
    "mathematical methods of physics . w.a .",
    "benjamin , inc . 1964 .",
    "a.n.berlizov , a.a.zhmudsky .",
    "the recursive one - dimensional adaptive quadrature code .",
    "preprint institute for nuclear research .",
    "1998 . a.a.zhmudsky .",
    "one class of integrals evaluation in magnet solitons theory .",
    "preprint lanl .",
    "....        subroutine gauleg(x1,x2,x , w , n )        integer n        real*8 x1,x2,x(n),w(n )        real*8   eps        parameter ( eps=3.d-14 )        integer i , j , m        real*8   p1,p2,p3,pp , xl , xm , z , z1        m=(n+1)/2        xm=0.5d0*(x2+x1 )        xl=0.5d0*(x2-x1 )        do 12 i=1,m          z = cos(3.141592654d0*(i-.25d0)/(n+.5d0 ) ) 1        continue            p1=1.d0            p2=0.d0            do 11 j=1,n              p3=p2              p2=p1              p1=((2.d0*j-1.d0)*z*p2-(j-1.d0)*p3)/j 11         continue            pp = n*(z*p1-p2)/(z*z-1.d0 )            z1=z            z = z1-p1/pp          if(abs(z - z1).gt.eps)goto 1          x(i)=xm - xl*z          x(n+1-i)=xm+xl*z          w(i)=2.d0*xl/((1.d0-z*z)*pp*pp )          w(n+1-i)=w(i ) 12     continue        return        end ...."
  ],
  "abstract_text": [
    "<S> it is shown that ms fortran-77 compilers allow to construct recursive subroutines . </S>",
    "<S> the recursive one - dimensional adaptive quadrature subroutine is considered in particular . despite its extremely short body </S>",
    "<S> ( only eleven executable statements ) the subroutine proved to be very effective and competitive . </S>",
    "<S> it was tested on various rather complex integrands . </S>",
    "<S> the possibility of function calls number minimization by choosing the optimal number of gaussian abscissas is considered .    </S>",
    "<S> the proposed recursive procedure can be effectively applied for creating more sophisticated quadrature codes ( one- or multi - dimensional ) and easily incorporated into existing programs . </S>"
  ]
}