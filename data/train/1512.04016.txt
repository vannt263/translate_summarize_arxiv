{
  "article_text": [
    "when are quantum algorithms useful ? in general , quantum algorithms are believed to provide exponential speedups for certain structured problems , such as factoring @xcite , but not for unstructured problems like @xmath13-complete problems .    in this work ,",
    "we ask the question in a new way . given a problem for which quantum algorithms are not useful , can we nevertheless find a sub - problem on which they provide an exponential advantage over classical algorithms ?",
    "we call this the `` sculpting '' question : our goal is to sculpt the original intractable problem into a sub - problem that s still classically intractable , but for which there exists a fast quantum algorithm .",
    "the sculpting question arises , for example , in adiabatic quantum computation : while it is not believed that adiabatic quantum computing can solve np - complete problems in polynomial time , a widely discussed question is whether there is a sub - problem of sat on which adiabatic computing provides an exponential advantage over classical algorithms .",
    "we study the sculpting question primarily in the query complexity model .",
    "the utility of the model comes from its relative tractability : for example , in query complexity , shor s period finding algorithm provides a provable exponential speedup over any classical algorithm @xcite .    in query complexity",
    ", we re given a ( possibly partial ) function @xmath14 and an oracle access to a string @xmath15 .",
    "the goal is to evaluate @xmath16 using as few oracle calls to the entries of @xmath17 as possible .",
    "the minimum number of queries required by an algorithm for computing @xmath16 ( over the worst - case choice of @xmath17 ) is the query complexity of @xmath0 .",
    "if the algorithm in question is deterministic , we denote this by @xmath6 ; if it is ( bounded error ) randomized , we denote this by @xmath4 ; and if it is ( bounded error ) quantum , we denote it by @xmath7 .",
    "in this query complexity setting , the sculpting question can be phrased as follows : given a total function @xmath14 for which @xmath4 and @xmath7 are both large ( say , @xmath18 ) , is there a promise @xmath19 such that @xmath20 , the restriction of @xmath0 to @xmath1 , has @xmath2 and @xmath3 ?",
    "for example , if @xmath0 is the @xmath21 function , such sculpting is not possible , as follows from @xcite . as another example ,",
    "if @xmath0 is defined to be @xmath22 when simon s condition is satisfied and @xmath23 otherwise , then sculpting is possible : the promise will simply restrict to inputs that either satisfy simon s condition or are far from satisfying it ; this promise suffices for an exponential quantum speedup @xcite .",
    "we fully characterize the functions @xmath0 for which such a promise exists .",
    "in particular , we show that sufficiently `` rich '' functions , such as parity or majority , are sculptable .",
    "our sculpting construction uses communication complexity in a novel way . in the other direction , to prove non - sculptability , we prove new query complexity relationships . as a corollary",
    ", we get nearly quadratic relationships between classical and quantum query complexities for a wider class of functions than previously known .",
    "we introduce a new query complexity measure , @xmath25 , defined as the maximum number @xmath26 for which there are @xmath27 inputs to @xmath0 with certificate complexity at least @xmath26 .",
    "we call this the h - index of certificate complexity ( motivated by the citation h - index sometimes used to measure research productivity @xcite ) .",
    "this quantity measures the number of inputs there are to a function @xmath0 that have large certificate complexity .",
    "we prove various properties of @xmath25 ; most notably , we show that for total functions , it is nearly quadratically related to @xmath28 , the h - index of block sensitivity .",
    "this is analogous to the quadratic relationship between @xmath29 and @xmath30 .",
    "our main result is the following theorem , which neatly characterizes sculptability in the query complexity model in terms of the h - index of certificate complexity .",
    "[ thm : main0 ] let @xmath14 be a total function . then there is a promise @xmath19 such that @xmath3 and @xmath31 , if and only if @xmath32 .",
    "furthermore , in this case we also have @xmath33 .",
    "this theorem follows as an immediate corollary of the following more general characterization theorem .",
    "theoremmain[thm : main ] for all total functions @xmath14 and all promises @xmath19 , we have @xmath34 conversely , for all total functions @xmath14 , there is a promise @xmath19 such that @xmath35    we also prove an analogous theorem for @xmath36 vs.  @xmath37 , showing that the same @xmath32 condition also characterizes sculpting @xmath6 vs.  @xmath5 . on the other hand , we show that sculpting @xmath5 vs.  @xmath4 is _ always _ possible : for every total function @xmath0 with @xmath38 , there is a promise @xmath1 such that @xmath39 and @xmath40 .      on the way to proving , we prove the following theorem , providing a quadratic relationship between @xmath7 and @xmath6 when the domain of @xmath0 is small .",
    "this provides a ironic twist to the query complexity story : for a long time , it was believed that @xmath6 and @xmath7 are quadratically related when the domain of @xmath0 is very large ( in particular , for total functions ) .",
    "this conjecture was recently disproven by @xcite ( who showed a @xmath41 separation ) and by @xcite ( who showed an @xmath0 such that @xmath42 ) . instead",
    ", we now show that the quadratic relationship holds when the domain of @xmath0 is very _",
    "small_.    theoremsmall[thm : small ] let @xmath14 be a partial function , and let @xmath43 denote the domain of @xmath0 . then @xmath44      we show two relationships similar to that hold for functions whose domain is large , but which are unbalanced : they contain very few @xmath23-inputs compared to @xmath22-inputs , or vice versa .",
    "theorembal[thm : bal ] let @xmath14 be a partial function . define the measure @xmath45 $ ] as @xmath46 ( or @xmath23 if @xmath0 is constant ) . then @xmath47 @xmath48 a similar polynomial relationship between @xmath5 and @xmath4 does not hold in general .",
    "we prove the following new query complexity relationship for total functions , generalizing the known relationship @xmath49 .",
    "theoremtot[thm : tot ] let @xmath14 be a total function .",
    "then @xmath50    here @xmath51 denotes the h - index of the square root of certificate complexity ; this is the maximum number @xmath26 such that there are at least @xmath27 inputs to @xmath0 for which @xmath52 is at least @xmath26 .",
    "we note that @xmath53 for all total functions , so this is an improvement over the relationship @xmath49 .",
    "moreover , when @xmath54 , we have @xmath55 and @xmath56 , so this improvement is strict .",
    "we remark that this result could let us improve the relationship @xmath57 if we could show @xmath58 .",
    "therefore provides a new approach for this long - standing open problem .      in",
    ", we examine sculpting in the turing machine model .",
    "we say that a language @xmath59 is _ sculptable _ if there is a promise set @xmath1 such that the promise problem of deciding if an input from @xmath1 is in @xmath59 is in @xmath60 but not in @xmath61 .",
    "we prove two sculptability theorems , both of them providing evidence that most or all languages outside of @xmath8 are sculptable .",
    "theorempad[thm : pad ] assume @xmath60 is hard on average for @xmath12 .",
    "then every paddable language outside of @xmath8 is sculptable .",
    "theoremimmune[thm : immune ] assume there exists a @xmath8-bi - immune language in @xmath9 .",
    "then every language outside of @xmath8 is sculptable .    for the definitions of paddability and bi - immunity ,",
    "these theorems assume very little about @xmath9 and @xmath8 , and analogous statements hold for other pairs of complexity classes .",
    "for a ( possibly partial ) function @xmath14 , we use @xmath6 , @xmath5 , @xmath4 , and @xmath7 to denote the deterministic query complexity , zero - error randomized query complexity , bounded - error randomized query complexity , and bounded - error quantum query complexity of @xmath0 , respectively . for the definitions of these measures , see @xcite .",
    "a partial assignment is a string @xmath62 in @xmath63 that represents partial knowledge of a string in @xmath64 . for @xmath15",
    ", we say that @xmath62 is a partial assignment of @xmath17 if @xmath17 extends @xmath62 ; that is , if @xmath17 and @xmath62 agree on all the non-@xmath65 entries of @xmath62 . a partial assignment @xmath62 for @xmath17",
    "is called a _ certificate _ for @xmath17 if all strings that extend @xmath62 have that same value under @xmath0 as @xmath17 ; that is , if for all @xmath66 that extend @xmath62 , we have @xmath67 . the certificate complexity of @xmath0 on input @xmath17 , denoted by @xmath68 , is the minimum number of bits in any certificate of @xmath17 with respect to @xmath0 .",
    "the certificate complexity of @xmath0 , denoted by @xmath69 , is defined as the maximum of @xmath68 over all strings @xmath17 in the domain of @xmath0 .",
    "the certificate complexity @xmath68 can be thought of as the deterministic query complexity of @xmath0 given the promise that the input is either @xmath17 or else an input @xmath70 such that @xmath71 .",
    "motivated by this observation , aaronson @xcite defined the _",
    "randomized certificate complexity _ of @xmath17 , denoted by @xmath72 , to be the ( bounded - error ) randomized query complexity of @xmath0 on this promise .",
    "he defined the quantum certificate complexity @xmath73 analogously . as with @xmath29",
    ", we use @xmath74 to denote the maximum of @xmath72 over all @xmath17 in the domain of @xmath0 , and define @xmath75 similarly .    for",
    "any string @xmath15 and set of bits @xmath76 , denote by @xmath77 the string @xmath17 with the bits in @xmath76 flipped . for any @xmath14 , if @xmath78 , we say that @xmath76 is a",
    "_ sensitive block _ for @xmath17 with respect to @xmath0 .",
    "the _ block sensitivity _ of @xmath17 , denoted by @xmath79 , is the maximum number of disjoint sensitive blocks for @xmath17 .",
    "note that the block sensitivity is the packing number of the collection of sensitive blocks of @xmath17 .",
    "it can be seen that @xmath68 can be interpreted as the hitting number of that collection ( the minimum number of bits required to hit all the blocks ) .",
    "moreover , @xmath72 is simply the fractional packing number ( which equals the fractional hitting number ) . in other words , @xmath72 can be interpreted as the fractional block sensitivity ( or fractional certificate complexity ) .",
    "these observations are implicit in @xcite , and were made explicit in @xcite .",
    "actually , the fractional block sensitivity differs by a constant factor from aaronson s original definition of @xmath80 . in this work",
    "we will use @xmath80 to denote the fractional block sensitivity .",
    "another property of @xmath80 that we will need is that @xmath81 is equal to the minimum infinity - norm distance between @xmath17 and the convex hull of the set of inputs @xmath70 such that @xmath82 .",
    "that is , if @xmath83 and @xmath84 , we have @xmath85,\\ ] ] where @xmath86 is the set of all probability distributions over @xmath87 ( equivalently , the convex hull of @xmath87 ) . in particular , this minimum is attained , so there is a probability distribution @xmath88 over @xmath89 such that for all @xmath90 , if we sample @xmath91 we get @xmath92\\leq 1/\\operatorname{rc}_f(x)$ ] .",
    "clearly , for all @xmath14 we have @xmath93 with @xmath7 lying between @xmath75 and @xmath4 .",
    "aaronson @xcite showed that @xmath94 for all @xmath0 and @xmath17 , so in particular , @xmath95 .",
    "in addition , when @xmath0 is total , we can relate all these measures to each other : we have @xmath96      we will use @xmath43 to denote the domain of a partial function @xmath0 .",
    "we define @xmath97 to be @xmath23 if @xmath0 is constant , and otherwise , to be the minimum of @xmath98 and @xmath99 ( we use @xmath100 to denote logarithm base @xmath101 ) .",
    "note that since @xmath102 , we have @xmath103",
    ". thus @xmath45 $ ] .",
    "we will use a new set of query complexity measures called h - indices ( the name is motivated by the h - index measure of citations , a common metric for research output ) . for a given function @xmath104",
    ", we will define the h - index of @xmath105 , denoted by @xmath106 , as the maximum number @xmath26 such that there are at least @xmath27 inputs with @xmath107 .",
    "alternatively , the h - index of @xmath105 can be defined as the minimum number @xmath26 such that there are at most @xmath27 inputs with @xmath108 .",
    "it is not obvious that these definitions are equivalent ( or even that the minimum and maximum are attained ) ; we prove this in .",
    "note that @xmath109 $ ] , and @xmath110 . also , if @xmath111 for all @xmath15 , we have @xmath112 .",
    "we ll primarily be interested in measures like @xmath25 , @xmath113 , and @xmath28 .",
    "we have @xmath114 , @xmath115 , and @xmath116 .",
    "we also have @xmath117 the h - index of certificate complexity can be much smaller than the certificate complexity itself .",
    "for example , the @xmath21 function has only one certificate of size greater than @xmath22 , so @xmath118 , even though @xmath119 .    in we",
    "show that if @xmath120 is an increasing function , then @xmath121 in particular , this will imply @xmath122 .      for a set of indices @xmath123 , let @xmath124 be the set of restrictions of each string in @xmath87 to the indices in @xmath125 .",
    "we say @xmath125 is shattered by @xmath87 if @xmath126 . in other words , @xmath125 is shattered by @xmath87 if @xmath87 has all possible behaviors on @xmath125 .",
    "the sauer - shelah lemma @xcite is a classic result that upper - bounds the size of @xmath87 in terms of the size of @xmath125 .",
    "we will use the following corollary of it .",
    "lemmasauer [ lem : sauer ] let @xmath127 be a collection of strings .",
    "then there is a shattered set of indices of size at least @xmath128    follows straightforwardly from the sauer - shelah lemma , as we prove in .",
    "we will often use the weaker bound @xmath129 instead , which holds for @xmath130 .",
    "this will sometimes lead to simpler formulas .",
    "in this section , we prove the non - sculptability direction of .",
    "the proof has two parts : in , we prove a relationship between randomized and quantum query complexities for `` unbalanced '' functions , and in , we use this to prove a sculpting lower bound in terms of the h - index of certificate complexity .",
    "we wish to show a nearly - quadratic relationship between randomized and quantum query complexities for functions @xmath0 for which @xmath97 is small .",
    "note that this is a generalization of the relation @xmath131 from @xcite .",
    "that is , @xcite showed that for the task of distinguishing one input from a ( possibly large ) set of alternatives , randomized and quantum algorithms are quadratically related .",
    "we want a similar relationship for the task of distinguishing a _ small set _ of inputs from a ( possibly large ) set of alternatives .",
    "we start with the following lemma .",
    "[ lem : rvsqlemma ] let @xmath14 be a partial function .",
    "for @xmath132 , let @xmath133 be the problem of distinguishing @xmath134 from @xmath135 .",
    "that is , @xmath133 is the function @xmath136 with @xmath137 iff @xmath138 . for @xmath139 , define @xmath140 analogously .",
    "then for all @xmath141 , we have either @xmath142 or @xmath143 .    note that this holds even when @xmath134 is not in the promise of @xmath0 .",
    "the constant in the big-@xmath144 notation is a universal constant independent of @xmath134 , @xmath0 , and @xmath145 .",
    "let @xmath146 be the quantum algorithm that achieves @xmath7 quantum query complexity in determining the value of @xmath0 on a given input . when run on any @xmath147 , @xmath146 will output @xmath23 with probability at least @xmath148 , and when run on @xmath149 , it will output @xmath22 with probability at least @xmath148 .    consider running @xmath146 on an input @xmath150",
    ". then @xmath146 will output @xmath23 with some probability @xmath62 and output @xmath22 with probability @xmath151 .",
    "if @xmath152 , then @xmath146 distinguishes @xmath134 from @xmath89 with constant probability . if @xmath153 , then @xmath146 distinguishes @xmath134 from @xmath135 with constant probability",
    "thus for all @xmath141 , we have either @xmath154 or @xmath155 . from @xcite",
    ", we have @xmath156 for all functions",
    "@xmath105 , so we conclude that either @xmath157 or @xmath158 .",
    "finally , note that for a problem of distinguishing one input from the rest , randomized query complexity equals randomized certificate complexity .",
    "thus we get that for all @xmath141 , either @xmath142 and or @xmath143 .",
    "we re now ready to prove the desired relationship between @xmath159 and @xmath160 .",
    "[ thm : rvsq ] let @xmath161 be a partial function .",
    "then @xmath162    without loss of generality , assume @xmath163 .",
    "we use to construct a randomized algorithm for determining @xmath16 given oracle access to @xmath17 , assuming that @xmath135 is small .",
    "the idea is to keep track of the subset @xmath164 of strings that the input @xmath17 might feasibly be ( consistent with the queries seen so far ) .",
    "we then construct a string @xmath134 from a majority vote of the elements of @xmath165 ; that is , for each index @xmath166 $ ] , @xmath167 will be the majority of @xmath168 over all @xmath169 ( with ties broken arbitrarily ) .",
    "this string @xmath134 need not be in @xmath43 .",
    "the important property of it is that if we query an index @xmath170 of the input @xmath17 and discover that @xmath171 , we can eliminate at least half of the strings from @xmath165 , since they are no longer feasible possibilities for @xmath17 .",
    "we then get the following randomized algorithm for evaluating @xmath16 :    * initialize @xmath172 . * while @xmath173 : 1 .",
    "calculate @xmath134 from the entry - wise majority vote of @xmath165 .",
    "2 .   determine @xmath174 such that @xmath175 ( this exists by ) .",
    "3 .   run the randomized algorithm evaluating @xmath176 on @xmath17 with some amplification + ( to be specified later ) .",
    "4 .   if its output is @xmath22 ( i.e. the algorithm thinks @xmath138 rather than @xmath177 ) , + output @xmath178 and halt .",
    "if its output is @xmath23 , a bit @xmath170 was queried to reveal @xmath171 , so update @xmath165 + ( removing at least half its elements ) . * if @xmath179 , output @xmath22 .",
    "we note a few things about this algorithm .",
    "first , in step 3 , notice that @xmath17 need not be in the domain of @xmath176 . however , we may still run the randomized algorithm that evaluates @xmath176 , and use the fact that if @xmath17 does happen to be in the domain ( in particular , if @xmath177 ) , then the algorithm will work correctly .",
    "this is exactly what we use in step 4 : if the algorithm that distinguishes @xmath134 from @xmath180 says that @xmath17 is equal to @xmath134 , it need not mean that @xmath17 is in fact equal to @xmath134 , but it does mean that @xmath181 .    secondly , step 5 assumes that the randomized algorithm for evaluating @xmath176 will only conclude that an input @xmath17 is not equal to @xmath134 if it finds a disagreement with @xmath134 . this is a safe assumption , as argued in lemma 5 of @xcite .    finally , we determine the number of queries this algorithm uses .",
    "the outer loop happens at most @xmath182 times .",
    "step 3 in the loop is the only one which queries the input string .",
    "since the loop repeats at most @xmath97 times , we can safely amplify the algorithm in step 3 @xmath183 times .",
    "this gives a query complexity of @xmath184 for step 3 , so the overall number of queries is @xmath185 .",
    "we can get rid of the log factor by being more careful with the amplification . note that if we ever find a disagreement with @xmath134 when running the algorithm , we may immediately stop amplifying and proceed to step 5 .",
    "we keep a count @xmath186 of how many times we had to amplify in step 3 for functions of the form @xmath133 , and a count @xmath187 for functions of the form @xmath140 .",
    "if @xmath186 ever reaches @xmath188 , we output @xmath22 and halt . similarly ,",
    "if @xmath187 ever reaches @xmath188 , we output @xmath23 and halt .",
    "this ensures the total amplification is @xmath189 , so the total query complexity of the algorithm is @xmath190 .",
    "note that if @xmath83 and the output of the algorithm was @xmath22 , it means that we ran the algorithm evaluating @xmath133 ( for varying values of @xmath134 ) @xmath188 times , and at most @xmath97 of those times the algorithm said that @xmath191 . for each individual run ,",
    "the probability is at least @xmath148 that the algorithm would say that @xmath191 .",
    "an application of the chernoff bound shows that the probability of this happening is exponentially small .",
    "similarly , the probability of the algorithm giving @xmath23 when in actuality @xmath137 is also exponentially small .    we conclude that @xmath192 , as desired .",
    "immediately gives the following non - sculptability result , which says that unbalanced functions can not be sculpted .",
    "[ cor : bal_lower ] let @xmath14 be a total function . for any promise @xmath19 , we have @xmath193    note that @xmath194 for any @xmath0 and @xmath1 .",
    "then , by , we have @xmath195    we extend this result by showing that any function with a small number of large certificates also can not be sculpted .",
    "this gives us a non - sculptability result in terms of the h - index of certificate complexity .",
    "[ thm : nosculpting ] let @xmath161 be a total function .",
    "for any promise @xmath19 , we have @xmath196    we design a deterministic algorithm that reduces the set of possibilities for the input to an unbalanced set .",
    "specifically , the algorithm will reduce the possibilities for the input to a set @xmath127 such that @xmath197 .",
    "we then use to get the desired non - sculptability result .",
    "note that every @xmath22-certificate of @xmath0 must conflict with every @xmath23-certificate of @xmath0 in at least one bit .",
    "therefore , by querying all non-@xmath65 entries of a @xmath23-certificate , we reveal at least one entry of each @xmath22-certificate .",
    "we design a deterministic algorithm for computing @xmath0 on an input from @xmath1 .",
    "the algorithm proceeds as follows : it repeatedly picks a @xmath23-certificate @xmath62 for @xmath0 of size at most @xmath198 that is consistent with all the entries of the input that were revealed so far .",
    "it then queries all the non-@xmath65 entries of @xmath62 .",
    "this is repeated @xmath198 times , or until there are no @xmath23-certificates of size at most @xmath198 ( whichever happens first ) .",
    "finally , the algorithm returns the set @xmath87 of strings that are consistent with the revealed entries of the input .",
    "this algorithm uses at most @xmath199 queries .",
    "we check its correctness by examining the set @xmath87 .",
    "clearly , the input is in @xmath87 .",
    "furthermore , if any certificate of @xmath0 was revealed , then @xmath0 is constant on @xmath87 , so @xmath87 contains either no @xmath23-inputs or no @xmath22-inputs .",
    "there are at most @xmath200 inputs with certificate complexity larger than @xmath198 .",
    "if the algorithm terminated because there were no consistent @xmath23-certificates , then the only @xmath23-inputs in @xmath87 have certificates of size larger than @xmath198 .",
    "there are at most @xmath200 of them , so @xmath87 has at most @xmath200 @xmath23-inputs to @xmath0 .",
    "conversely , if the algorithm went through @xmath198 iterations of querying consistent @xmath23-certificates , then it must have revealed @xmath198 entries of each @xmath22-certificate to @xmath0 .",
    "if no @xmath22-certificate was discovered , it means the revealed entries contradicted all @xmath22-certificates of size at most @xmath198 .",
    "thus the only @xmath22-inputs in @xmath87 have certificate size greater than @xmath198 , from which it follows that there are less than @xmath200 of them .",
    "we conclude that @xmath87 contains either at most @xmath200 @xmath23-inputs to @xmath0 or at most @xmath200 @xmath22-inputs to @xmath0 .",
    "this gives @xmath201 .",
    "we design a randomized algorithm for @xmath20 as follows .",
    "first , we run the above deterministic algorithm to reduce the problem of computing @xmath20 to the problem of computing @xmath202 .",
    "this costs @xmath199 queries . by",
    ", there is a randomized algorithm that uses @xmath203 queries to compute @xmath202 .",
    "running this algorithm allows us to compute @xmath20 .",
    "the total number of queries used was @xmath204    note that completes the first part of the proof of , since @xmath122 .",
    "it is natural to wonder whether is always at least as strong as . in",
    ", we will show that it is , up to a quadratic factor and a @xmath205 factor .",
    "in this section , we show that if a function @xmath0 has many inputs with large randomized certificate complexity then it _ can _ be sculpted : there is a promise @xmath1 so that @xmath20 exhibits a large quantum speedup .",
    "this means that if @xmath113 is large , the function @xmath0 can be sculpted . in , we will relate @xmath113 to @xmath25 , thereby completing the proof of .",
    "our sculptability proof will rely on the solution to a problem we call the `` extended queries problem , '' which might be of independent interest .",
    "the solution to this problem will in turn use results from communication complexity .",
    "we usually let an algorithm for computing a ( possibly partial ) function @xmath14 query the bits of the input @xmath17 . but what happens if we let the algorithm make other types of queries ?",
    "for example , if @xmath17 is a boolean string , we can let the algorithm query the parity of @xmath17 .",
    "how does this extra power affect the query complexity of @xmath0 ?",
    "in particular , is there some special set of additional queries such that if a randomized algorithm is allowed to make the special queries , it can simulate _ any _ quantum algorithm ?",
    "if so , how many special queries suffice for this property to hold ?    to formalize this question , we need a few definitions .",
    "an _ extension function with extension @xmath206 _ is an injective total function @xmath207 ( in particular , we need @xmath208 ) .",
    "an extension function specifies , for each input @xmath15 , the types of queries an algorithm is allowed to make on @xmath17 . in other words",
    ", we will let algorithms query from @xmath209 instead of from @xmath17 .",
    "note that the extension function may provide easy access to information about @xmath17 that is hard to obtain otherwise ( such as its parity ) .",
    "let @xmath14 be a partial function , and let @xmath210 be an extension function .",
    "the _ extended version of @xmath0 with respect to @xmath210 _ is the partial function @xmath211 defined by @xmath212 .",
    "note that @xmath213 is a partial function from @xmath214 to @xmath215 .",
    "we can consider @xmath216 , @xmath217 , @xmath218 , and so on . to pose the extended queries problem , we will need a notion of the complexity of a set of functions , defined as the maximum complexity of any function in that set .    for any set of functions @xmath87 , we define @xmath219 .",
    "we define @xmath220 , @xmath221 , etc .  similarly .",
    "further , we define @xmath222 , the _ extended query complexity of @xmath87 with extension @xmath206 _ , to be the minimum , over all extension functions @xmath210 with extension @xmath206 , of @xmath223 .",
    "we define @xmath224 , @xmath225 , etc .  similarly .",
    "in other words , for any set of functions , the extended query complexity of the set with @xmath206 extension is the number of queries required to compute all functions in the set given the best possible extension .",
    "we observe that if @xmath226 , the extended query complexity @xmath222 is @xmath22 , since the extension @xmath209 for a given input @xmath17 could simply specify the values of all the functions in @xmath87 on @xmath17 .",
    "we also observe that for all @xmath208 , we have @xmath227 , since the identity function is always a valid extension function . moreover , the extended query complexity of a set is decreasing in @xmath206 .",
    "we now ask the following question .    * the extended queries problem .",
    "* is there a set of functions @xmath87 for which @xmath221 is small but @xmath224 is large , even when the extension @xmath206 is exponentially large in the input size @xmath145 ?",
    "we can also ask this question for other complexity measures , such as @xmath220 vs. @xmath228 or @xmath229 vs.  @xmath222 .",
    "it turns out that a negative solution to the extended queries problem implies a sculptability result in terms of @xmath113 , as the following theorem shows .",
    "theoremsculptingextension [ thm : sculpting_extension ] let @xmath14 be a total function .",
    "let @xmath230 , and let @xmath87 be any set of partial functions from @xmath231 to @xmath215 .",
    "then there is a promise @xmath19 such that @xmath232 analogous statements hold for other pairs of complexity measures , such as @xmath36 and @xmath37 or @xmath37 and @xmath159 .",
    "we delay the proof of to .",
    "first , we settle the extended queries problem for @xmath159 vs.  @xmath160 : will provide an exponential lower bound on @xmath206 by reducing the extended queries problem to a problem in communication complexity .      for a partial function @xmath233 , we will denote the communication complexities of @xmath0 by @xmath234 , @xmath235 , @xmath236 , and @xmath237 .",
    "we will use the following definition .",
    "let @xmath233 be a partial function .",
    "for any @xmath238 , we write @xmath239 , with @xmath240 and @xmath241 .",
    "let @xmath242 and @xmath243 .",
    "for any @xmath244 , we define the marginal of @xmath0 with respect to @xmath134 to be the partial function @xmath245 defined by @xmath246 for all @xmath247 such that @xmath248 .",
    "we define @xmath249 to be the set of all marginal functions for @xmath0 .",
    "we now connect communication complexity to the extended queries problem .",
    "[ thm : communication_extension ] let @xmath233 be a partial function . then @xmath250 similarly , we also have @xmath251 , @xmath252 , and @xmath253 .",
    "we prove the theorem for @xmath159 .",
    "the statements for @xmath36 , @xmath37 , and @xmath160 will follow analogously .",
    "let @xmath254 be the best possible extension function , so that @xmath255 .",
    "we now describe a randomized communication protocol for computing @xmath0 .",
    "alice receives a string @xmath134 , and must compute @xmath256 , where @xmath257 is bob s string .",
    "this is equivalent to computing @xmath258 .",
    "since alice knows @xmath259 , she also knows @xmath260 .",
    "let @xmath261 a randomized algorithm that computes @xmath260 using at most @xmath262 queries .",
    "alice will run this algorithm , and for each query , she will send the index of that query to bob ( as a number between @xmath22 and @xmath206 ) .",
    "bob will reply with the corresponding bit of @xmath263 ( as a bit in \\{0,1 } ) .",
    "this allows alice to compute @xmath264 .",
    "the total communication in this protocol is at most @xmath265 .",
    "since this upper - bounds the randomized communication complexity of @xmath0 ( using private coins ) , the desired result follows .    allows us to use communication complexity as a tool for lower - bounding the extended query complexity of certain sets of functions . to use it to solve the extended queries problem",
    ", we need a function @xmath0 that has large randomized communication complexity but for which @xmath266 is small . to construct such a function , we start from a simple function that was recently shown to separate randomized from quantum communication complexity , called the vector in subspace problem .",
    "* the vector in subspace problem . * in this problem , bob gets a unit vector @xmath267 , and alice gets a subspace @xmath268 of @xmath269 of dimension @xmath270 .",
    "it is promised that either @xmath271 or @xmath272 ; the task is to determine which is the case .",
    "we assume for simplicity that @xmath273 is a power of @xmath101 .",
    "this problem was first studied in @xcite and was also described in @xcite .",
    "klartag and regev @xcite showed that this problem has randomized communication complexity @xmath274 .",
    "in addition , it is easy to see that the one - way quantum communication complexity of the problem is at most @xmath275 : bob can send a superposition over @xmath275 bits with amplitudes determined by @xmath276 ; alice can then apply the projective measurement given by @xmath277 .    to apply this function to the extended queries problem , we need a few modifications .",
    "first , we need a discrete version of the problem .",
    "@xcite showed that a lower bound of @xmath274 for randomized communication complexity applies to a discrete version of the problem in which each real number is described using @xmath278 bits ; that is , alice s subspace is given using @xmath270 vectors of length @xmath273 , whose entries are specified using @xmath278 bits , and bob s vector is specified using @xmath273 real numbers of @xmath278 bits each .",
    "@xmath279 is the set of functions where we know alice s subspace @xmath268 , and are allowed to query from bob s input vector .",
    "however , phrased this way , it is not clear how to use a quantum algorithm to compute such functions using few queries . to solve this problem , we modify the way bob s input is specified .",
    "instead of specifying only the entries to the vector , bob s input string also lists some `` partial sums '' of the vector entries .",
    "the idea is for bob s vector to allow alice to use the following algorithm to construct the state with amplitudes specified by @xmath276 .",
    "we interpret @xmath276 as specifying a superposition over strings of length @xmath275 .",
    "alice starts by querying the probability @xmath62 that the first bit of this string is @xmath23 when this state is measured .",
    "alice will now place a @xmath280 amplitude on querying the probability that the second bit is @xmath23 conditioned on the first bit being @xmath23 , and a @xmath281 amplitude on querying the probability that the second bit is @xmath23 conditioned on the first bit being @xmath22 .",
    "alice keeps going in this way , until she gets to the final bit of the string of length @xmath275 , at which point she queries the phase .",
    "this allows her to construct the state determined by the amplitudes in @xmath276 .",
    "of course , for this to work , bob s input must provide all of these conditional probabilities .",
    "there is one such probability to specify for the first bit , two for the second , four for the third , and so on . since there are @xmath275 bits , bob s input needs to specify only @xmath282 probabilities .",
    "each can be specified with @xmath278 precision , so bob s total input size is @xmath283 .",
    "moreover , alice constructs the desired state after @xmath278 queries to the probabilities , or @xmath284 queries to the bits of bob s input .",
    "we thus get the following theorem .",
    "[ thm : qextension ] for all @xmath285 , there is a set @xmath87 of partial functions from @xmath231 to @xmath215 such that for all @xmath286 , @xmath287    let @xmath0 be the function described above with @xmath288 , and let @xmath289 . then @xmath290 and @xmath291 . by ,",
    "we get @xmath292 .    together with",
    ", this implies that any function with large @xmath113 can be sculpted , simply by plugging @xmath87 from into and setting @xmath293 .",
    "we now prove , restated here for convenience .",
    "there are at least @xmath294 inputs @xmath17 with @xmath295 .",
    "let the set of such inputs be @xmath296 . by ,",
    "if @xmath130 , there is a set @xmath76 of @xmath297 indices in @xmath298 that is shattered by the inputs in @xmath296 .",
    "we ll restrict @xmath76 to have size at most @xmath299 , so @xmath300 .",
    "let @xmath301 be defined by mapping each string @xmath302 to a string @xmath303 in @xmath296 such that restricting @xmath303 to @xmath125 gives @xmath17 .",
    "this is an injective mapping , so @xmath210 is an extension function with extension size @xmath145 .",
    "next , consider the set @xmath87 of partial boolean functions from @xmath231 to @xmath215 .",
    "let @xmath304 . then @xmath305 .",
    "it follows that there is some function @xmath306 such that @xmath307 .",
    "we will use the function @xmath308 to define the desired promise @xmath1 .",
    "the domain of @xmath308 is contained in @xmath296 .",
    "let @xmath17 be in this domain , so that @xmath309 .",
    "let @xmath310 be a distribution over inputs @xmath70 such that @xmath71 , with the property that for any bit @xmath170 , @xmath92\\leq1/\\operatorname{rc}_f(x)\\leq 1/(2a)$ ] .",
    "then for all @xmath311 , a randomized algorithm has a hard time distinguishing between @xmath17 and @xmath310 . for each such @xmath17 ,",
    "let @xmath312 be the distribution @xmath310 conditioned on the sampled input agreeing with @xmath17 on the bits in @xmath76 .",
    "since the probability of an input sampled from @xmath310 disagreeing with @xmath17 on @xmath76 is at most @xmath313 , the distribution @xmath314 is not too far from @xmath310 . in particular , any randomized algorithm that finds a disagreement with @xmath17 on an input sampled from @xmath314 with probability @xmath62",
    "will also find a disagreement with @xmath17 on an input sampled from @xmath310 with probability at least @xmath315 .",
    "it follows that a randomized algorithm must use @xmath316 queries to distinguish @xmath17 from @xmath314 .",
    "we construct the promise @xmath1 as follows .",
    "start with @xmath317 . for each @xmath318",
    ", we add @xmath17 to @xmath1 if @xmath319 ; otherwise , we add the support of @xmath314 to @xmath1 .",
    "it remains to lower - bound @xmath320 and to upper - bound @xmath321 .",
    "we start with the upper bound .",
    "let @xmath322 , and consider the value of @xmath70 on @xmath76 .",
    "if @xmath17 is an input of the domain of @xmath308 that caused @xmath70 to be added , then @xmath17 and @xmath70 agree on @xmath76 .",
    "further , the values of @xmath17 on @xmath76 are simply @xmath323 , and @xmath324 .",
    "this means @xmath325 .",
    "we now have the quantum algorithm work only with the bits of @xmath326 , ignoring the rest .",
    "the algorithm need only compute @xmath327 .",
    "since @xmath328 , we get @xmath329 , as desired . a similar argument",
    "would upper - bound other complexity measures , such as @xmath159 , @xmath37 , or @xmath36 .    for the lower bound , consider the hard distribution @xmath88 on inputs to @xmath308 obtained from yao s minimax principle @xcite .",
    "this distribution has the property that any randomized algorithm for @xmath308 that succeeds with probability at least @xmath148 on inputs sampled from @xmath88 must use @xmath330 queries .",
    "we construct a new distribution @xmath331 over @xmath1 by generating an element @xmath318 according to @xmath88 , and then outputting either @xmath17 or a sample from @xmath314 , depending on which of them was added to @xmath1 .",
    "we lower - bound the number of queries a randomized algorithm requires to compute @xmath0 on an input sampled from @xmath331 by a reduction from either computing @xmath308 on inputs sampled from @xmath88 , or else distinguishing @xmath17 from @xmath312 .",
    "let @xmath261 be a randomized algorithm for @xmath20 .",
    "let @xmath332 .",
    "we wish to compute @xmath333 .",
    "although @xmath17 may not be in @xmath1 , consider running @xmath261 on @xmath17 anyway .",
    "the algorithm will correctly output @xmath333 with some probability @xmath62 , depending on both the internal randomness of @xmath261 and on @xmath88 . if @xmath334 , we could amplify @xmath261 a constant number of times to turn it into an algorithm for @xmath105 that works on inputs sampled from the hard distribution @xmath88 , which means @xmath261 must use @xmath335 queries .",
    "so suppose that @xmath336 .",
    "next , given @xmath332 , we let @xmath337 be either @xmath17 or a sample from @xmath312 , as @xmath331 dictates .",
    "then running @xmath261 on @xmath337 gives @xmath338 with probability at least @xmath148 . on the other hand ,",
    "running @xmath261 on @xmath17 gives output @xmath333 with probability at most @xmath339 .",
    "that is , we have @xmath340      = \\operatorname*{\\mathbb{e}}_{x\\sim\\mu}\\left[\\pr_r[r(x)=g^\\phi(x)]\\right ]      \\leq 3/5\\ ] ] @xmath341      = \\operatorname*{\\mathbb{e}}_{x\\sim\\mu}\\left[\\pr_{r , y_x}[r(y_x)=g^\\phi(x)]\\right ]      \\geq 2/3\\ ] ] from which it follows that @xmath342-          \\pr_r[r(x)=g^\\phi(x)]\\right ]      \\geq 1/15.\\ ] ] this means there must be some specific input @xmath343 such that the probability of @xmath261 outputting @xmath344 when run on @xmath345 is at least @xmath346 more than the probability of @xmath261 outputting @xmath344 when run on @xmath343 . in particular , we must have @xmath347 , so @xmath345 is a sample from @xmath348 .",
    "therefore , @xmath261 distinguishes @xmath343 from @xmath348 with constant probability , so it uses at least @xmath316 queries .",
    "we conclude that @xmath349 .",
    "since the domain of the functions in @xmath87 is @xmath231 , their query complexity is at most @xmath125 .",
    "thus @xmath350 , as desired .",
    "a similar argument lower - bounds other complexity measures , such as @xmath37 or @xmath36 .",
    "this proof uses the fact that @xmath80 lower - bounds @xmath159 , so it would not work on complexity measures that are not lower - bounded by @xmath80 ( for example , @xmath351 ) . for @xmath160 , it might be possible to use a similar argument and suffer a quadratic loss , since @xmath160 is lower - bounded by @xmath352",
    ". however , since there is no hard distribution for a quantum query complexity problem , this might be trickier to prove ( we will not need it in this paper ) .",
    "we can use the previous theorems to get a sculptability result for @xmath159 vs.  @xmath160 in terms of the h - index of randomized certificate complexity .",
    "[ cor : sculpting_upper ] let @xmath14 be a total function . then there is a promise @xmath19 such that @xmath353 there is also a promise @xmath354 such that @xmath355    this follows from together with and .    to complete the proof of , all that remains is relating @xmath113 to @xmath25 .",
    "in this section , we relate @xmath25 to @xmath113 , completing the characterization of sculpting .",
    "actually , we will prove a relationship between @xmath25 and @xmath28 , which implies the desired relationship since @xmath356 .",
    "the proof is somewhat involved , but splits naturally into three parts . in ,",
    "we show a relationship between @xmath68 and @xmath72 in terms of the number of @xmath23- and @xmath22-inputs of @xmath0 . in , we show that @xmath357 .",
    "finally , gives the desired relationship between @xmath25 and @xmath28 .",
    "[ lem : cvsrc ] let @xmath161 be a partial function , and let @xmath238 . if @xmath83 , then @xmath358 and if @xmath137 , then @xmath359    for @xmath360 , we wish to upper - bound @xmath68 in terms of @xmath72 , assuming @xmath135 is small . a certificate for @xmath17 consists of a partial assignment of @xmath17 that contradicts all the elements of @xmath135 .",
    "consider the greedy strategy for certifying @xmath17 , which works by repeatedly choosing the bit of @xmath17 that contradicts as many of the @xmath23-inputs as possible , and adding it to the certificate . by definition ,",
    "this strategy produces a certificate for @xmath17 of size at least @xmath68 .",
    "let @xmath361 be the fraction of the remaining inputs which are contradicted by the @xmath170-th bit of the greedy algorithm .",
    "the number of remaining inputs during the run of the greedy algorithm is then @xmath362 and has ratio @xmath363 .",
    "such a sequence decreases to @xmath22 after at most @xmath364 steps .",
    "it follows that @xmath365    it remains to show that @xmath366 .",
    "let @xmath367 be the step of the greedy algorithm that achieves this minimum , i.e. @xmath368 . then before the @xmath367^th^ step of the algorithm , there is a non - empty set @xmath87 of @xmath23-inputs for @xmath0 such that for any bit of the input , at most a @xmath369 fraction of the elements of @xmath87 disagree with @xmath17 on that bit . in other words",
    ", @xmath17 is entry - wise very close to the `` average '' of the elements of @xmath87 .",
    "if we give each element of @xmath87 weight @xmath370 , we would get a feasible set of fractional blocks with total weight @xmath371 .",
    "thus @xmath372 , so @xmath373 . an analogous argument works when @xmath17 is a @xmath23-input to @xmath0 .",
    "[ thm : hbal ] let @xmath130 , and let @xmath161 be a total function .",
    "then @xmath374    without loss of generality , suppose @xmath163 .",
    "the number of @xmath23-inputs with large certificates is at most @xmath375 .",
    "let @xmath87 be the set of @xmath22-inputs with certificates of size greater than @xmath376 .",
    "we wish to show that @xmath87 is small .",
    "implies there is a set @xmath377 of indices of the input of size at least @xmath378 that is shattered by @xmath87 .",
    "therefore , to show that @xmath87 is small , it suffices to show that @xmath76 is small .",
    "from , we have @xmath379 for any @xmath22-input @xmath17 , so for all @xmath380 , we have @xmath381 .",
    "this means for all @xmath380 , there is a distribution @xmath310 over @xmath23-inputs such that for each @xmath170 , the probability that @xmath382 when @xmath70 is sampled from @xmath310 is less than @xmath383 .",
    "let @xmath384 be the uniform distribution over @xmath76 .",
    "let @xmath385 if @xmath386 and @xmath23 otherwise .",
    "we then write @xmath387 we can conclude that for any @xmath380 , there exists a @xmath23-input @xmath337 that differs from @xmath17 in less than one fifth of the bits of @xmath76 . in other words , the distance between @xmath388 and @xmath389 is less than @xmath390 .",
    "the idea is now to upper - bound @xmath391 by using the fact that for every string in @xmath392 there is a @xmath23 input @xmath70 such that @xmath326 is close to that string , and there are few @xmath23-inputs overall .",
    "indeed , the number of strings in @xmath392 is @xmath393 , and each @xmath23-input can only be of distance less than @xmath390 from @xmath394 of them ( where @xmath395 denotes the entropy of @xmath383 ) .",
    "therefore , to cover all the strings in @xmath392 , there must be more than @xmath396 @xmath23-inputs .",
    "then @xmath397 so @xmath398 this means there are less than @xmath399 @xmath22-inputs with certificate size at least @xmath376 .",
    "there are also at most @xmath400 @xmath23-inputs with certificate size at least @xmath376 ( because there are at most that many @xmath23-inputs in total ) .",
    "thus the log of the total number of inputs with certificates larger than @xmath376 is at most @xmath401 .",
    "it follows that @xmath402 .",
    "[ thm : hbs ] let @xmath14 be a total function .",
    "then @xmath403    let @xmath125 be the set of inputs that have certificate size more than @xmath25 .",
    "let @xmath404 be the set of @xmath23-inputs in @xmath125 , and let @xmath405 be the set of @xmath22-inputs in @xmath125 .",
    "let @xmath76 be the set of inputs that have block sensitivity more than @xmath257 , with @xmath406 .",
    "let @xmath407 be the set of @xmath23-inputs in @xmath76 , and let @xmath408 be the set of @xmath22-inputs in @xmath76 .",
    "without loss of generality , assume @xmath409 .",
    "since @xmath410 , we have @xmath411 .",
    "now , let @xmath412 be the total function defined by @xmath413 if and only if @xmath414 .",
    "suppose @xmath17 is an element of @xmath415 .",
    "consider certifying that @xmath17 is a @xmath23-input for @xmath105 ; let @xmath62 be the smallest such certificate .",
    "then @xmath62 is consistent with @xmath17 but inconsistent with all the strings in @xmath408 .",
    "we claim that this certificate must be large : its size must be greater than @xmath416 . to show this ,",
    "we show that we can turn @xmath62 into a certificate for @xmath17 with respect to @xmath0 ( instead of with respect to @xmath105 ) by adding only @xmath417 bits to it .",
    "let @xmath418 be a minimal sensitive block of @xmath17 ( with respect to @xmath0 ) that is disjoint from @xmath62 . since @xmath17 is a @xmath23-input for @xmath0",
    ", @xmath419 is a @xmath22-input for @xmath0 . since @xmath418 is disjoint from @xmath62 ,",
    "@xmath419 is consistent with @xmath62 , so @xmath420 .",
    "thus the block sensitivity of @xmath419 is at most @xmath257 .",
    "however , since @xmath418 was a minimal sensitive block , the sensitivity of @xmath419 is at least @xmath421 ; thus @xmath422 .",
    "it follows that all minimal sensitive blocks of @xmath17 that are disjoint from @xmath62 must have size at most @xmath257 .",
    "in addition , since @xmath423 , the block sensitivity of @xmath17 is at most @xmath257 . we can now construct a certificate for @xmath17 by taking a maximal set of minimal disjoint sensitive blocks for @xmath17 , all of which are disjoint from @xmath62 .",
    "there will be at most @xmath257 such blocks , and each will have size at most @xmath257 .",
    "therefore , this certificate for @xmath17 has size at most @xmath424 . since @xmath425",
    ", we must have @xmath426 , or @xmath427 .",
    "we have shown that the elements of @xmath415 all have certificate size greater than @xmath428 even with respect to @xmath105 .",
    "now , by , the number of inputs @xmath17 that have certificate size more than @xmath429 with respect to @xmath105 is at most @xmath430 .",
    "it follows that either @xmath431 ( so that the theorem does nt apply ) , or else @xmath432 .    in the former case , we have @xmath433 in the latter case",
    ", we have @xmath434 so in that case , @xmath435 thus , in both cases , @xmath436    this means there are @xmath437 inputs with block sensitivity more than @xmath438 .",
    "we thus have @xmath439    now follows from ( the non - sculptability theorem in terms of @xmath199 ) , ( the sculptability result in terms of @xmath113 ) , and ( relating @xmath28 to @xmath25 ) , together with the properties that @xmath122 and that @xmath356 .",
    "we restate here for convenience",
    ".    follows as a corollary .",
    "this completes the proof of our main result .",
    "now that we ve characterized sculpting quantum query complexity , we turn our attention to sculpting other measures . recall that @xmath440 we showed that sculpting @xmath4 vs.  @xmath7 is possible if and only if @xmath0 has a large number of large certificates .",
    "we now show that the exact same condition characterizes sculpting @xmath6 vs.  @xmath5 . on the other hand , we show that @xmath5 vs.  @xmath4 behaves differently : it s _ always _ possible to sculpt a function @xmath0 to a promise @xmath1 such that @xmath320 is constant and @xmath441 is almost as large as @xmath5 .",
    "we start by characterizing sculpting for @xmath36 vs.  @xmath37 .",
    "the proof of this characterization will follow that of .",
    "for the non - sculptability direction , we need an analogue of , relating deterministic and zero - error randomized query complexities in terms of @xmath97 .",
    "we prove the following theorem .",
    "[ thm : dvsr0 ] let @xmath161 be a partial function . then @xmath442    consider the zero - error randomized algorithm that takes @xmath5 expected queries to evaluate @xmath0 . by markov s inequality ,",
    "if we let this algorithm make @xmath443 queries on input @xmath17 , it will succeed in computing @xmath16 ( and provide a certificate for @xmath17 ) with probability at least @xmath444 .",
    "this gives us a probability distribution @xmath88 over deterministic algorithms , each of which makes @xmath443 queries , such that for each input @xmath17 the probability that an algorithm sampled from @xmath88 finds a certificate when run on @xmath17 is at least @xmath444 .    for a deterministic algorithm @xmath445 and an input @xmath17 ,",
    "let @xmath446 if @xmath445 finds a certificate for @xmath17 , and @xmath447 otherwise .",
    ". then @xmath449 = \\sum_{x\\in z}\\operatorname*{\\mathbb{e}}_{d\\sim\\mu}[c(d , x ) ] \\geq\\sum_{x\\in z}(1/2 ) = \\frac{|z|}{2}.\\ ] ] it follows that there is a deterministic algorithm @xmath450 that makes @xmath443 queries and finds a certificate when run on half the inputs in @xmath165 .",
    "suppose without loss of generality that @xmath451 .",
    "now , on input @xmath17 , set @xmath172 , and run @xmath450 on @xmath17 .",
    "if it fails to find a certificate , then we have eliminated half of @xmath165 as possibilities for the input . repeating this",
    "@xmath452 times suffices to eliminate all of @xmath135 as possibilities for @xmath17 , and hence to determine the value of @xmath16 .",
    "the total number of queries used is at most @xmath453 .",
    "note that and together complete the proof of .",
    "next , we turn into a non - sculptability theorem in terms of @xmath25 . the argument in follows verbatim , and we get the following sculpting lower bound .",
    "[ cor : r0h ] let @xmath14 be a total function .",
    "for any promise @xmath19 , we have @xmath454    we now prove the other direction : we show that sculpting is possible when @xmath113 is large . using the arguments from",
    ", it suffices to solve the extended queries problem for @xmath36 vs.  @xmath37 .",
    "we do this using the reduction to communication complexity in .",
    "[ thm : r0extension ] for all @xmath455 , there is a set of partial functions @xmath87 from @xmath64 to @xmath215 such that for all @xmath208 , @xmath456    we start with equality , in which alice and bob are each given an @xmath273-bit string and wish to know if their strings are equal .",
    "this problem has deterministic query complexity @xmath457 , but small randomized query complexity . to make the zero - error randomized query complexity small as well",
    ", we give alice and bob two strings each , with the promise that either their first strings are equal and the second strings are not , or vice versa . the goal will be to determine which is the case .",
    "it is not hard to see that the deterministic communication complexity of this problem is still @xmath457 .",
    "we need to get the zero - error randomized query complexity of the marginal functions to be small . to do this ,",
    "we introduce another modification : we encode each of bob s strings using a fixed random code of length @xmath458 .",
    "this code will have the property that the distance between any pair of codewords is @xmath457 . to compute a marginal function @xmath459 indexed by alice s strings",
    ", we can simply randomly sample from each of bob s strings ; after @xmath460 samples , we will discover which of his strings do not match the codeword corresponding to @xmath461 and @xmath462 .",
    "this construction gives us a function @xmath463 such that @xmath464 and @xmath465 .",
    "setting @xmath466 and using finishes the proof .    putting this together ,",
    "we get the following sculpting theorem which , together with , is analogous to .",
    "[ thm : r0main ] for all total functions @xmath14 , there is a promise @xmath19 such that @xmath467    this follows from together with and .",
    "we also get the following corollary , analogous to .    [ r0basic ]",
    "let @xmath14 be a total function .",
    "then there is a promise @xmath19 such that @xmath468 and @xmath469 , if and only if @xmath32 .",
    "futhermore , in this case we also have @xmath470 .",
    "while it is possible to use the above argument to get a sculptability result for @xmath37 vs.  @xmath159 , we can get a stronger result by a direct argument .",
    "in fact , unlike @xmath159 vs.  @xmath160 or @xmath36 vs.  @xmath37 , sculpting @xmath37 vs.  @xmath159 is _ always _ possible ( there is no dependence on any h - index ) .",
    "[ rsculpting ] let @xmath14 be a non - constant total function .",
    "then there is a promise @xmath19 such that @xmath471    we actually prove a stronger result , finding a promise @xmath1 such that @xmath472 and @xmath473 .",
    "we then use the known relationship @xmath474 for total functions to get the desired result . note that finding @xmath1 with @xmath472 and @xmath475 is trivial when @xmath476 ; thus we assume @xmath477 .",
    "let @xmath15 be such that @xmath478 .",
    "assume without loss of generality that @xmath83 .",
    "let @xmath479 be the set of all @xmath22-inputs with hamming distance at least @xmath480 from @xmath17 .",
    "for any partial assignment @xmath62 consistent with @xmath17 , let @xmath481 be the set of all inputs @xmath70 in @xmath479 that are consistent with @xmath62 .",
    "there are two cases .",
    "if @xmath482 is non - empty for all partial assignments @xmath62 consistent with @xmath17 of size less than @xmath483 , then we can pick the promise to be @xmath484 .",
    "it then follows that certifying that @xmath20 is @xmath23 on input @xmath17 takes at least @xmath483 queries , whence @xmath485 . on the other hand ,",
    "a randomized algorithm can make @xmath22 query to check if the input differs from @xmath17 .",
    "thus @xmath472 .",
    "the other case is that there is some partial assignment @xmath62 of size less than @xmath483 such that @xmath482 is empty .",
    "we restrict our attention to inputs consistent with @xmath62 .",
    "since @xmath17 has @xmath79 disjoint sensitive blocks , it has at least @xmath486 disjoint sensitive blocks that do not overlap with @xmath62 .",
    "we exclude blocks of size larger than @xmath487 .",
    "since there are at most @xmath101 such blocks , this leaves at least @xmath488 .",
    "let @xmath76 be the set of inputs we get by flipping one of these blocks of @xmath17 .",
    "then @xmath76 contains only @xmath22-inputs to @xmath0 that are consistent with @xmath62 , all of which have hamming distance at most @xmath487 from @xmath17 . since @xmath489",
    ", we have @xmath490 .",
    "let @xmath87 be the set of inputs consistent with @xmath62 that have hamming distance at least @xmath480 from @xmath17 .",
    "since @xmath482 is empty , @xmath87 contains only @xmath23-inputs to @xmath0 .",
    "let @xmath491 .",
    "now , consider certifying that an input @xmath70 to @xmath20 is a @xmath22-input .",
    "since all inputs of hamming distance at least @xmath480 from @xmath17 that are consistent with @xmath62 are @xmath23-inputs , this requires showing at least @xmath492 bits of @xmath70 . since @xmath493 ,",
    "this is at least @xmath494 .",
    "thus @xmath495 .",
    "on the other hand , a bounded - error randomized algorithm can simply query a bit of the input at random , and check for agreement with @xmath17 .",
    "if the bit agrees , the algorithm can output @xmath22 , and if the bit disagrees , the algorithm can output @xmath23 .",
    "this works because @xmath23-inputs have distance at least @xmath480 from @xmath17 , while all @xmath22-inputs have distance at most @xmath487 from @xmath17 ( since the sensitive blocks used to construct @xmath76 were of size at most @xmath487 ) .",
    "thus @xmath472 .",
    "we can use some of the tools introduced in the previous sections to prove some new relations in query complexity . in , we prove a quadratic relationship between @xmath6 and @xmath7 for partial functions @xmath0 that have small domain . in , we prove a quadratic relationship between @xmath6 and @xmath7 for total functions @xmath0 for which @xmath25 is small .",
    "we prove , which we restate for convenience .",
    "we follow the proof of .",
    "the randomized algorithm used in that proof relies only on the existence of a randomized algorithm distinguishing a string @xmath496 from either @xmath135 or @xmath89 , which is in turn guaranteed by . to make that algorithm deterministic",
    ", we only need to turn this distinguishing algorithm into a deterministic one . by , we have @xmath497 . on the task of distinguishing a single input from a set of inputs ,",
    "certificate complexity equals deterministic query complexity . using this observation",
    ", we can modify the proof of to get the result @xmath498 from which the desired result follows .",
    "we can use h - indices to improve some of the relationships between complexity measures on total functions , proving . recall that for total functions",
    ", we have @xmath499 and @xmath500 , from which we have @xmath49 .",
    "we strengthen this result to @xmath501 for total boolean functions .",
    "since @xmath502 , this result is always stronger .",
    "in addition , since @xmath119 and @xmath118 , this improvement is sometimes very strong .",
    "we restate for convenience .",
    "the proof follows the proof that @xmath503 @xcite .",
    "we start by reviewing this proof .",
    "the deterministic algorithm repeatedly picks possible @xmath23-certificates that are consistent with the input observed so far , and queries the entries of these certificates . if the queried entries match the @xmath23-certificate , the algorithm is done ( the value of @xmath16 is known to be @xmath23 ) .",
    "if ever there are no additional @xmath23-certificates consistent with the observed part of the input , the value of the function is known to be @xmath22 .",
    "the key insight is that if this process repeats @xmath504 times , then the block sensitivity of the function is at least @xmath504 .",
    "indeed , let @xmath62 be the partial assignment revealed after @xmath504 iterations .",
    "pick a @xmath22-input @xmath70 for @xmath0 that is consistent with @xmath62 .",
    "let @xmath505 be the set of entries queried in the @xmath170-th iteration of the algorithm .",
    "then for each @xmath170 , there is a way to change only the variables in @xmath505 to form a @xmath23-certificate for @xmath0 .",
    "it follows that each @xmath505 contains a sensitive block for @xmath70 .",
    "since the @xmath505 sets are disjoint , we get @xmath506 , so @xmath507 .",
    "we modify the algorithm as follows . in each step",
    ", we only allow the algorithm to pick @xmath23-certificates that are of size at most @xmath508 .",
    "thus the algorithm uses at most @xmath509 queries before it gets stuck . when it gets stuck , either the value of @xmath0 on the input is determined , or else there are no more @xmath23-certificates that are small enough .",
    "next , we repeat the same process with @xmath22-certificates instead of @xmath23-certificates . if the value of @xmath0 is not yet determined , it means that the input is not consistent with any small enough certificates , so the certificate complexity of the input @xmath17 is greater than @xmath508 .",
    "this gives @xmath510 .    by definition of the h - index , there are now at most @xmath511 possibilities for the input .",
    "we ve therefore restricted @xmath0 to a small domain @xmath1 .",
    "we now use to evaluate @xmath0 using @xmath512 deterministic queries .",
    "this is added to the @xmath509 queries from before .",
    "using @xmath500 , we get @xmath50",
    "in this section , we examine sculpting in the computational complexity model .",
    "we start with some notation . given a language @xmath513 ,",
    "we let @xmath514 be its characteristic function .",
    "also , given a language @xmath59 together with a promise @xmath515 , we let @xmath516 be the promise problem of distinguishing the set @xmath517 from the set @xmath518 .    now",
    ", we call the language @xmath59 _ sculptable _ if there exists a promise @xmath1 , such that the promise problem @xmath516 is in @xmath60 but not in @xmath61",
    ". we will use the following definition .",
    "[ def : pad ] a language @xmath59 is called _ paddable _ , if there exists a polynomial - time function @xmath519 such that    1 .",
    "@xmath0 is polynomial - time invertible , and 2 .   for all @xmath520",
    ", we have @xmath521 .    in other words , @xmath59 is paddable if it is possible to pad outany input @xmath17 with irrelevant information @xmath70 , in an invertible way , without affecting membership in @xmath59 .",
    "the paddable languages were introduced by berman and hartmanis @xcite , as part of their exploration of whether all @xmath13-complete languages are polynomial - time isomorphic : they showed that the answer was ` yes ' for all _ paddable _ @xmath13-complete languages . under strong cryptographic assumptions , we now know that there exist @xmath13-complete languages that are neither paddable nor isomorphic to each other @xcite .",
    "nevertheless , it remains the case that almost all the languages that naturally arise in complexity theory  are paddable .",
    "next , let us say that _",
    "@xmath60 is hard on average for @xmath12 _ if there exists a promise problem @xmath522 , as well as a family of distributions @xmath523 with support on the promise set @xmath87 , such that    1 .",
    "@xmath524 is samplable in classical @xmath525 time , and 2 .",
    "there is no family of classical circuits @xmath526 , of size @xmath525 , such that for all @xmath273 , @xmath527       \\geq\\frac{3}{4}.\\ ] ]    so for example , because of shor s algorithm @xcite , combined with the worst - case / average - case equivalence of the discrete log problem , we can say that _ if discrete log is not in @xmath12 _ _ , _ _ then @xmath60 is hard on average for @xmath12_.    we now prove , which we restate here for convenience .",
    "let @xmath59 be a paddable language , and let @xmath0  be the padding function for @xmath59 .",
    "also , let @xmath528 be any problem in @xmath60 that is hard on average for @xmath12 , and let @xmath523 be the associated family of hard distributions .",
    "then we need to construct a promise , @xmath515 , such that the promise problem @xmath529 is in @xmath60 but not in @xmath61 .",
    "our promise @xmath1 will simply consist of all inputs of the form @xmath530 such that @xmath531 and @xmath532 here @xmath533 is a single bit , which we think of as concatenated onto the end of @xmath70 .",
    "clearly , @xmath529 is in @xmath60 : just invert @xmath0 to extract the comment@xmath534 , then compute @xmath535 .    we need to show that @xmath529 is not in @xmath61 .",
    "suppose by contradiction that it was , and let @xmath536 be the algorithm such that @xmath537 for all @xmath538",
    ". then we ll show how to either    1 .",
    "decide @xmath59 in @xmath8 ( with no promise ) , or 2 .",
    "decide @xmath268 in @xmath12 , with high probability over @xmath539 .",
    "given an arbitrary input @xmath540 , imagine we do the following : first sample @xmath541 , then run @xmath536 on the inputs @xmath542 and @xmath543 .",
    "there are two cases : first suppose @xmath544 now ,",
    "_ one _ of the two inputs @xmath542 and @xmath543 must belong to @xmath1 .",
    "if @xmath545 , then @xmath546 , while if @xmath547 , then @xmath548 .",
    "either way , then , we have learned whether @xmath549 , and we know we have learned this .",
    "second , suppose @xmath550 then assuming @xmath531 : @xmath551 thus , regardless of whether @xmath549 , we have learned whether @xmath552 , and again we know we have learned this .",
    "now suppose there were an input @xmath540 , such that running @xmath536 as above told us whether @xmath552 with probability more than ( say ) @xmath444 over the choice of @xmath541 .",
    "then let @xmath553 be a polynomial - size circuit that hardwires @xmath17 , and that given an input @xmath531 :    * simulates both @xmath554 and @xmath555 . * outputs @xmath556 whenever it successfully learns the value of @xmath556 .",
    "* guesses a hardwired value for @xmath556 ( whichever of @xmath215 is more probable ) whenever it does not",
    ".    then @xmath557       \\geq\\frac{3}{4},\\ ] ] violating the assumption that no such circuit exists .",
    "so we conclude that for every @xmath540 , we must instead learn whether @xmath549 with probability at least @xmath444 over the choice of @xmath541 .",
    "this , in turn , means that by simply generating @xmath70 s randomly until we succeed , we can decide @xmath59 in @xmath61 .    next , given a language @xmath558 , we say @xmath268 is @xmath8__-bi - immune _",
    "_ if neither @xmath268 nor its complement @xmath559 has any infinite subset in @xmath8 .",
    "the notion of immunity was introduced by @xcite .",
    "here is a useful alternative characterization :    [ lem : biimmune]a language @xmath268 is @xmath8-bi - immune if and only if there is no infinite set @xmath560 , such that the promise problem @xmath561 is solvable in @xmath11 .",
    "first , suppose @xmath268 is not @xmath8-bi - immune , so that either @xmath268 or @xmath559 has an infinite subset @xmath560 .",
    "then clearly , @xmath87 itself is an infinite set in @xmath8 such that the promise problem @xmath561 is trivial ( the answer is either always @xmath23 or always @xmath22 ) .",
    "conversely , suppose there exists an infinite set @xmath560 such that @xmath561 is solvable in polynomial time .",
    "then clearly @xmath562 and @xmath563 are both in @xmath8 , and at least one of the two must be infinite .",
    "so @xmath268 is not @xmath8-bi - immune .",
    "we now suggest what , as far as we know , is a new conjecture in quantum complexity theory .",
    "[ conj : bqpimmune]there exists a @xmath8-bi - immune language in @xmath9 .    is extremely strong .",
    "note , in particular , that none of the standard@xmath9 languages , such as languages based on factoring or discrete log , will be @xmath8-bi - immune , because they all have infinite special cases that are classically recognizable and easy ( for example , the powers of @xmath101 , in the case of factoring ) .",
    "nevertheless , we believe is plausible . as a concrete candidate for a @xmath8-bi - immune language in @xmath9 , let @xmath564 be some strong pseudorandom generator .",
    "then consider the language @xmath565 we now prove , restated here for convenience .    assume .",
    "then every language outside of @xmath8 is sculptable .",
    "assume by way of contradiction that @xmath566 is non - sculptable .",
    "also , let @xmath268  be a @xmath8-bi - immune language in @xmath9 .",
    "then consider the set @xmath567 by our assumption , @xmath87 is a promise on which no superpolynomial quantum speedup is possible for @xmath59 , and @xmath568 is another such promise .",
    "hence , there must be a @xmath8 algorithm , call it @xmath569 , that solves the promise problem @xmath561 , which ( by the definition of @xmath87 ) is equivalent to solving @xmath570 .",
    "and there must be another polynomial - time classical algorithm , call it @xmath571 , that solves @xmath572 , which ( again by the definition of @xmath87 ) is equivalent to solving @xmath573 .",
    "now , given an input @xmath17 , suppose we run both @xmath569 and @xmath571 .",
    "then as in the proof of , there are two possibilities .",
    "if @xmath574 , then @xmath380 implies @xmath575 while @xmath576 implies @xmath577 , so either way we have learned @xmath578 ( and we know that we have learned it ) . on the other hand , if @xmath579 , then @xmath380 implies @xmath580 while @xmath576  implies @xmath581 .",
    "so , merely by seeing that @xmath582 and @xmath583 are different , we have learned @xmath584 ( and we know that we have learned it ) .    in summary",
    ", there is a @xmath8 algorithm @xmath585 that , for every input @xmath586 , correctly outputs either @xmath578 or @xmath584 , and that moreover tells us which one it output .",
    "now let @xmath146 be the set of all @xmath17 such that @xmath587 outputs @xmath578 .",
    "then there are two possibilities : if @xmath146 is finite , then @xmath585 decides @xmath59 on all but finitely many inputs .",
    "hence @xmath588 , contrary to assumption .",
    "if , on the other hand , @xmath146 is infinite , then @xmath589 is an infinite promise problem in @xmath61 .",
    "so @xmath268 was not @xmath8-bi - immune , again contrary to assumption .    in and",
    ", there is almost nothing specific to the complexity classes @xmath9 and @xmath8 , apart from some simple closure properties .",
    "thus , one can prove analogous sculpting theorems for many other pairs of complexity classes . in some cases",
    ", we do not even need an unproved conjecture .",
    "for example , we have :    [ expthm]for every language @xmath590 , there exists a promise @xmath87 such that @xmath570 is solvable in exponential time , but is not solvable in polynomial time .",
    "the proof of follows through for @xmath591 and @xmath592 instead of @xmath8 and @xmath9 .",
    "in addition , it is known that there is a @xmath591-bi - immune language in @xmath592 @xcite .",
    "the desired result follows .",
    "in this work , we gave a full characterization of the class of boolean functions @xmath0 that can be sculpted into a promise problem with an exponential quantum speedup in query complexity .",
    "we similarly characterized sculptability for @xmath37 vs.  @xmath159 and @xmath36 vs.  @xmath37 . along the way",
    ", we showed that @xmath160 is polynomially related ( indeed , _ quadratically _ related ) to @xmath36 and @xmath159 for a much wider set of promise problems than was previously known . finally , we studied sculpting in _ computational _ complexity , giving a strong conjecture under which every language outside @xmath8 is sculptable into a superpolynomial quantum speedup , and a weaker conjecture under which every _ paddable _ language outside @xmath8 is sculptable .    one might object that many of our sculpted promise problems are somewhat artificial .",
    "this is particularly clear in the case of paddable languages , where ( in essence ) one uses the paddability to append to each instance @xmath17 , as a `` comment , '' an instance of a hard @xmath9 problem ( such as factoring ) that is promised to have the same answer as @xmath17 . even in the query complexity",
    "setting , however , one can observe by direct analogy that _ the property of being sculptable is not closed under the removal of dummy variables_. so for example , we saw before that the @xmath145-bit @xmath21 function is not sculptable .",
    "by contrast , observe that the function @xmath593 _ is _ sculptable .",
    "this follows as an immediate consequence of : just by adding dummy variables to the @xmath21 function , we have vastly increased the number of inputs @xmath17 that have large certificate complexity , from @xmath22 to @xmath594 .",
    "however , an even simpler way to see why @xmath0 is sculptable , is that we can embed ( say ) simon s problem into the variables @xmath595 , and then impose the promise that @xmath596 ( in addition to the simon promise itself )",
    ".    of course , most boolean functions do _ not _ contain such dummy variables , so the problems of sculpting them , and deciding whether they are sculptable at all , are much more complicated , as we saw in this paper .",
    "now , it might feel like `` cheating '' to sculpt a promise problem with a large quantum / classical gap by using dummy variables to encode a different , unrelated problem .",
    "if so , however , that points to an interesting direction for future research : namely , can we somehow formalize what we mean by a `` natural '' special case of a problem , and can we then understand which problems are `` naturally '' sculptable ?    here",
    "are some more specific open problems .",
    "* some of our inequalities could be off by polynomial factors ; it would be nice to tighten them ( or prove separations ) . for example , it may be possible to improve to @xmath597 , quadratically improving the @xmath598 factor .",
    "* can our results  and specifically ,  be used to improve the relation @xmath57 due to beals et al .",
    "* can we give a characterization of the sculptable boolean functions in _ communication _ complexity  analogous to this paper s characterization of sculptability in query complexity ?",
    "* is there any natural pair of complexity classes @xmath599 , for which @xmath600 is known or believed to be strictly contained in @xmath601 , and yet it is plausible that no languages in @xmath601 are @xmath600-bi - immune , and ( related to that ) there exist languages @xmath602 that _ can not _ be sculpted into a promise problem in @xmath603 ? * one can , of course , consider sculpting for many other pairs of computational models , besides @xmath159 vs.  @xmath160 or @xmath37 vs.  @xmath159 or @xmath36 vs.  @xmath37 .",
    "one interesting case is sculpting versus certificate complexity  for example , @xmath36 vs.  @xmath29 .",
    "what is the correct characterization there ?",
    "we make some observations on the last problem .",
    "it s easy to see that @xmath604 for any promise @xmath1 , so sculpting @xmath36 vs.  @xmath29 is not always possible .",
    "on the other hand , sculpting @xmath36 vs.  @xmath29 is sometimes possible even when @xmath25 is small . to see this ,",
    "consider the function @xmath0 with @xmath137 if and only if the hamming weight of @xmath17 is @xmath22 , and the single ` 1 ' bit occurs on the left half of the input string .",
    "this function can be sculpted to @xmath605 and @xmath606 by setting @xmath1 to the set of inputs with hamming weight @xmath22 .",
    "however , @xmath607 for this function , since all inputs with hamming weight at least @xmath101 have small certificates ( just display two ` 1 ' bits ) .",
    "this means something qualitatively different happens with @xmath36 vs.  @xmath29 than what was found in this paper .",
    "we thank robin kothari for many helpful discussions .    supported by an nsf waterman award , under grant no .  1249349 .",
    "abb@xmath60815    scott aaronson .",
    "quantum certificate complexity .",
    ", 35(4):804824 , 2006 .",
    "andris ambainis , kaspars balodis , aleksandrs belovs , troy lee , miklos santha , and juris smotrovs .",
    "separations in query complexity based on pointer functions . , 2015 .",
    "scott aaronson , shalev ben - david , and robin kothari .",
    "separations in query complexity using cheat sheets . , 2015 .",
    "robert beals , harry buhrman , richard cleve , michele mosca , and ronald de  wolf .",
    "quantum lower bounds by polynomials .",
    ", 48(4):778797 , 2001 .",
    "harry buhrman and ronald de  wolf .",
    "complexity measures and decision tree complexity : a survey .",
    ", 288(1):21  43 , 2002 .",
    "harry buhrman , lance fortnow , ilan newman , and hein rhrig .",
    "quantum property testing .",
    ", 37(5):13871400 , 2008 .",
    "leonard berman and juris hartmanis . on isomorphisms and density of np and other complete sets .",
    ", 6(2):305322 , 1977 .",
    "richard cleve .",
    "the query complexity of order - finding .",
    ", 192(2):162171 , 2004 .",
    "philippe flajolet and jean - marc steyaert . on sets having only hard subsets . in _",
    "automata , languages and programming _ , pages 446457 .",
    "springer , 1974 .",
    "jorge  e hirsch .",
    "an index to quantify an individual s scientific research output . , 102(46):1656916572 , 2005 .",
    "stuart  a kurtz , stephen  r mahaney , and james  s royer .",
    "the isomorphism conjecture fails relative to a random oracle .",
    ", 42(2):401420 , 1995 .",
    "boaz klartag and oded regev .",
    "quantum one - way communication can be exponentially stronger than classical communication . in _ proceedings of the forty - third annual acm symposium on theory of computing _ , pages 3140 .",
    "acm , 2011 .",
    "ilan kremer . .",
    "phd thesis , citeseer , 1995 .",
    "raghav kulkarni and avishay tal .",
    "on fractional block sensitivity .",
    ", 2013 .    ran raz .",
    "exponential separation of quantum and classical communication complexity . in _ proceedings of the thirty - first annual acm symposium on theory of computing _ , pages 358367 .",
    "acm , 1999 .",
    "norbert sauer . on the density of families of sets .",
    ", 13(1):145147 , 1972 .",
    "saharon shelah .",
    "a combinatorial problem ; stability and order for models and theories in infinitary languages .",
    ", 41(1):247261 , 1972 .",
    "peter  w. shor .",
    "polynomial - time algorithms for prime factorization and discrete logarithms on a quantum computer .",
    ", 26(5):14841509 , 1997 .",
    "andrew chi - chih yao .",
    "probabilistic computations : toward a unified measure of complexity . in _",
    "annual symposium on foundations of computer science _ , volume  17 , page 222 .",
    "institute of electrical and electronics engineers , 1977 .",
    "[ hproperties ] let @xmath609 . define @xmath610 then    1 .",
    "@xmath611 $ ] 2 .",
    "@xmath612 3 .",
    "the number of @xmath540 for which @xmath613 is at most @xmath614 ( equivalently , the infimum in the definition of @xmath106 is actually a minimum ) 4 .   if @xmath615 is such that @xmath616 for all @xmath540 , then @xmath617 5 .   if @xmath120 is an increasing function , then @xmath618 .",
    "there are at least @xmath614 inputs @xmath540 with @xmath619    let @xmath620 and let @xmath621",
    ". then @xmath622 .",
    "part @xmath22 follows from noticing that for all @xmath26 , @xmath623 , so @xmath624 , whence @xmath625 .",
    "part @xmath101 follows from noticing that @xmath626 is empty , so @xmath627 .    to show @xmath628",
    ", we show that @xmath629 contains its infimum .",
    "consider an infinite decreasing sequence @xmath630 that converges to @xmath106 .",
    "then the sequence @xmath631 is a non - decreasing sequence of integers which is bounded above by @xmath632 .",
    "in addition , @xmath633 for all @xmath170 .",
    "it follows that there is some @xmath634 such that @xmath635 for all @xmath636 . for each @xmath637 , we have @xmath638 , and for each @xmath639 , we have @xmath640 for all @xmath170 .",
    "it follows that @xmath641 for each @xmath639 , so @xmath642 for all @xmath643 .",
    "finally , since @xmath644 for all @xmath170 , we have @xmath645 for all @xmath636 . from this",
    "it follows that @xmath646 , so @xmath647 .",
    "we now show @xmath648 . if @xmath649 is point - wise greater or equal to @xmath105 , then @xmath650 . since @xmath651 , we have @xmath652 , so @xmath653 .",
    "thus @xmath654 , so @xmath655",
    ".    we prove @xmath656 .",
    "let @xmath657 be an increasing function .",
    "we have @xmath658 thus @xmath659 so @xmath660 . hence @xmath661 .",
    "finally , we show @xmath662 .",
    "if it was false , there would be less than @xmath614 inputs with @xmath663 .",
    "thus there is some @xmath664 such that there are less than @xmath665 inputs with @xmath666 . but",
    "this implies @xmath667 , a contradiction .",
    "let @xmath668 be the size of the largest set that is shattered by @xmath87 . then the sauer - shelah lemma @xcite states @xmath669 a well - known bound states @xmath670 where @xmath671 is the binary entropy of @xmath672 . then @xmath673 @xmath674 ( if @xmath675 ) .",
    "thus @xmath676 unless @xmath677 .",
    "the sauer - shelah lemma implies @xmath678 when @xmath679 and @xmath680 when @xmath681 ( assuming @xmath130 ) .",
    "the only problematic case is @xmath682 and @xmath683 .",
    "thus , in all cases , we have @xmath684 , as desired ."
  ],
  "abstract_text": [
    "<S> given a problem which is intractable for both quantum and classical algorithms , can we find a sub - problem for which quantum algorithms provide an exponential advantage ? </S>",
    "<S> we refer to this problem as the `` sculpting problem . '' in this work , we give a full characterization of sculptable functions in the query complexity setting . </S>",
    "<S> we show that a total function @xmath0 can be restricted to a promise @xmath1 such that @xmath2 and @xmath3 , if and only if @xmath0 has a large number of inputs with large certificate complexity . </S>",
    "<S> the proof uses some interesting techniques : for one direction , we introduce new relationships between randomized and quantum query complexity in various settings , and for the other direction , we use a recent result from communication complexity due to klartag and regev . </S>",
    "<S> we also characterize sculpting for other query complexity measures , such as @xmath4 vs.  @xmath5 and @xmath5 vs.  @xmath6 .    along the way , we prove some new relationships for quantum query complexity : for example , a nearly quadratic relationship between @xmath7 and @xmath6 whenever the promise of @xmath0 is small . </S>",
    "<S> this contrasts with the recent super - quadratic query complexity separations , showing that the maximum gap between classical and quantum query complexities is indeed quadratic in various settings  just not for total functions !    </S>",
    "<S> lastly , we investigate sculpting in the turing machine model . </S>",
    "<S> we show that if there is any @xmath8-bi - immune language in @xmath9 , then _ every _ language outside @xmath8 can be restricted to a promise which places it in @xmath10 but not in @xmath11 . under a weaker assumption , that some problem in @xmath9 is hard on average for @xmath12 </S>",
    "<S> , we show that every _ paddable _ language outside @xmath8 is sculptable in this way . </S>"
  ]
}