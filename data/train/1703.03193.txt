{
  "article_text": [
    "in this paper , we propose a new linear algebraic approach to the computation of tarskian semantics , i.e. , the standard semantics for first - order logic .",
    "tarskian semantics determines the truth value @xmath6\\ ! ] } $ ] of first - order formulas @xmath4 in a model @xmath7 based on a relational structure comprised of a non - empty domain @xmath8 and relations over @xmath9 , using an interpretation associated with @xmath7 that maps constants to entities in @xmath8 and predicate symbols to the relations . @xmath6\\ ! ] } $ ] is step - by - step determined in @xmath7 along the syntactic structure of @xmath4 .",
    "what we propose here is to carry out this evaluation in another model isomorphically copied to the @xmath1-dimensional euclidean space @xmath2 , when the first - order language @xmath10 we use has only @xmath1 constants and correspondingly @xmath8 contains @xmath1 entities .    more precisely , given a finite model @xmath0 , we first encode entities in @xmath8 into vectors in @xmath2 where @xmath1 is the cardinality of @xmath9 and also encode @xmath3-ary relations in @xmath11 to order-@xmath3 adjacency tensors in multi - linear algebra . then to evaluate a logical formula @xmath4 in prenex normal form ,",
    "starting from atoms , we inductively derive a set @xmath5 of algebraic formulas in multi - linear algebra augmented with a nonlinear operation .",
    "evaluating @xmath5 in @xmath2 gives the truth value @xmath6\\ ! ] } $ ] in * m * , that is , @xmath6\\ ! ] }   = 1 $ ] if @xmath12 else @xmath6\\ ! ] } = 0 $ ] .",
    "+ our proposal is motivated by recent work on logical inference concerning knowledge graphs(kgs ) .",
    "kgs are graphs encoding rdf triples of the form @xmath13 and can be considered as a set of ground atoms of the form @xmath14 .",
    "there are huge kgs available such as freebase@xcite .",
    "the problem is that although they are good resources of the real world information and logically simple , they are huge , containing tens of millions of nodes and furthermore incomplete ; there are lots of inconsistent data and also lots of missing data . to carry out various kg tasks such as computing the truth value ( or more generally probability ) of @xmath14 while coping with the sheer amount of data and incompleteness , three major approaches are developed @xcite ; one that is based on probabilistic models , one that uses explicit features sampled from the graph and one that learns latent feature vectors from the graph .",
    "the last approach , latent feature approach , compiles entities and predicates in the domain into vectors and tensors@xcite respectively and apply various linear algebraic operations , with dimension reduction , to compute the probability of @xmath15 .    in the development of these approaches , formulas beyond ground atoms",
    "are introduced and investigated such as existentially quantified conjunctions as queries and definite clauses as constraints on kgs @xcite . however , from a logical point of view , their treatment was confined to propositional logic level and the evaluation of general first - order formulas is left untouched except for the work done by grefenstette @xcite .",
    "regrettably , while he succeeded in completely embedding the fragment of model theory , model theory of quantifier - free first - order logic , in tensor spaces , quantified formulas were excluded and had to be treated separately by another framework .",
    "nested quantification was not allowed either .",
    "so how to evaluate arbitrarily quantified formulas in a vector space still remains open .",
    "we solve this problem by introducing specific tensors for existential quantifiers together with a nonlinear operation .",
    "our contribution is two - fold .",
    "first we introduce a single framework for the evaluation of quantified first - order formulas in a vector space , assuming the domain is finite , thus solving the remaining problem .",
    "the second contribution is to present a concrete method , based on our framework , to compute the least model of datalog programs in a vector space , which opens up a completely new way of evaluating recursive programs , though we have to skip details due to page limitations and only sketch experimental result .    at this point",
    "it would be beneficial to ask why evaluating logical formulas in a vector space is an interesting idea .",
    "first , there are a rich family of algebraic operations available in a vector space such as inner product , outer product , projection , pca , svd and so on that helps analyzing and manipulating vector data .",
    "second , basically they are of polynomial time complexities , so we can expect efficient computation .",
    "last but not least , approximation through various matrix and tensor decomposition potentially leads to logical inference for web scale symbolic data .",
    "we assume the reader is familiar with basics of logic and linear algebra including matrices and tensors@xcite .",
    "we first review some terminology in logic .",
    "we assume our first order language @xmath10 contains @xmath1 constants @xmath16 and no function symbols .",
    "a model @xmath17 is a pair of domain , a nonempty set @xmath8 and an interpretation @xmath18 that maps constants @xmath19 to elements ( entities , individuals ) @xmath20 and k - ary predicate symbols @xmath21 to k - ary relations @xmath22 .",
    "an assignment @xmath23 is a mapping from variables @xmath24 to an element @xmath25 .",
    "it provides a way of evaluating formulas containing free variables .",
    "syntactically terms mean variables and/or constants and atomic formulas or atoms @xmath26 are comprised of a @xmath3-ary predicate symbol @xmath21 and @xmath3 terms @xmath27 some of which may be variables .",
    "formulas @xmath4 in @xmath28 are inductively constructed as usual from atoms using logical connectives ( negation @xmath29 , conjunction @xmath30 , disjunction @xmath31 ) and quantifiers ( @xmath32,@xmath33 ) .",
    "now we define free / bound occurrences of variables in @xmath4 .",
    "when @xmath4 is an atom , all variables in @xmath4 occur free in @xmath4 .",
    "when @xmath4 is a negation @xmath34 , disjunction @xmath35 or conjunction @xmath36 , free variables in @xmath37 and those in @xmath38 both occur free in @xmath4 and vice versa .",
    "when @xmath4 is an existentially quantified formula @xmath39 , free variables in @xmath37 except @xmath24 occur free in @xmath4 and vice versa .",
    "variables in @xmath4 that do not occur free in @xmath4 are said to be bound .",
    "a formula is closed if it has no free variable whereas it is open if it has no quantification .",
    "given a model @xmath17 and an assignment @xmath23 , the denotation @xmath40\\ ! ] } _ { i , a}$ ] in @xmath41 of an expression @xmath42 is inductively defined for terms @xmath43 and formulas @xmath4 as follows . @xmath44\\ ! ] } _ { i , a } = i(t )   \\;\\mbox{if $ t$ is a   constant , else}\\ ; a(t)$ ] .",
    "when @xmath21 is a @xmath3-ary relation symbol , @xmath45\\ ! ] } _ { i , a }      =      1({\\rm     true})$ ] if @xmath46\\ ! ] } _ { i , a},\\ldots , { [ \\ ! [ t_k ] \\ ! ] } _ { i , a } )    \\in     i(r)$ ] , else 0(false ) .",
    "let @xmath47 be formulas .",
    "for a negation @xmath48 , we define @xmath49\\ ! ] } _ { i , a }     = 1    -     { [ \\ ! [ f_1 ] \\ ! ] } _ { i , a}$ ] .",
    "@xmath50\\ ! ] } _ { i , a }    = 1 $ ] if @xmath51\\ ! ] } _ { i , a}=1 $ ] or @xmath52\\ ! ] } _ { i , a}=1 $ ] , else 0 . @xmath53\\ ! ] } _ { i , a } = 1 $ ] if there exists some @xmath54 such that @xmath51\\ ! ] } _ { i , a[x\\leftarrow   d]}=1 $ ] , else 0 . here",
    "$ ] is a new assignment that is the same as @xmath23 except that it assigns @xmath56 to the variable @xmath24 .",
    "finally @xmath57\\ ! ] } _ { i , a } = { [ \\ ! [ \\neg   ( \\neg   a \\vee   \\neg   b ) ] \\ ! ] } _ { i , a}$ ] and @xmath58\\ ! ] } _ { i , a }   =   { [ \\ ! [ \\neg \\exists   x   \\neg   f_1 ] \\ ! ] } _ { i , a}$ ] .",
    "for any formula @xmath4 , @xmath6\\ ! ] } _ { i , a } \\in \\{1,0\\}$ ] and when @xmath6\\ ! ] } _ { i , a } = 1 $ ] , we write @xmath59 .",
    "however when @xmath4 is closed , since @xmath6\\ ! ] } _ { i , a}$ ] does not depend on the assignment @xmath23 , we just write @xmath6\\ ! ] } $ ] and @xmath60 if @xmath4 is true in @xmath61 . for formulas",
    "@xmath62 , we say @xmath4 and @xmath63 are equivalent and write @xmath64 if @xmath6\\ ! ] } _ { i , a } = { [ \\ ! [ g ] \\ ! ] } _ { i , a}$ ] for any model @xmath65 , any interpretation @xmath18 and any assignment @xmath23 . in",
    "what follows , @xmath66 are omitted when they are clear from the context .",
    "then recall that a literal is an atom ( positive literal ) or its negation ( negative literal ) .",
    "suppose @xmath4 is an open formula .",
    "@xmath4 has an equivalent formula in disjunctive normal form ( dnf ) @xmath67 such that each disjunct @xmath68 is a monomial , i.e. , conjunction of literals .",
    "dually @xmath4 has an equivalent formula in conjunctive normal form ( cnf ) @xmath69 such that each conjunct @xmath68 is a clause , i.e. , disjunction of literals .",
    "it is known that every formula has an equivalent formula in prenex normal form @xmath70 where @xmath71 are quantifiers @xmath72 and @xmath63 is open .",
    "so to evaluate the truth value @xmath6\\ ! ] } $ ] of a given @xmath4 in @xmath73 , since @xmath63 is equivalent to dnf or cnf , we have only to evaluate a prenex normal form @xmath74 where @xmath63 is an open dnf or cnf .",
    "note the subformula @xmath75 .",
    "since dnf and cnf are convertible to each other , it is equivalent to @xmath32-dnf or @xmath33-cnf where @xmath32-dnf is a class of formulas @xmath4 such that @xmath4 is a disjunction of disjuncts @xmath76 comprised of literals @xmath77 , whereas @xmath33-cnf is a class of formulas @xmath4 such that @xmath4 is a conjunction of conjuncts @xmath78 .",
    "suppose @xmath79 is given .",
    "we may assume , without loss of generality , that if @xmath80 , @xmath75 is in @xmath32-dnf .",
    "otherwise @xmath75 is in @xmath33-cnf .",
    "now we turn to vector spaces .",
    "we consider tensors as multi - linear maps as mathematical objects and multi - way arrays as data structure depending on the context@xcite .",
    "although tensors are a generalization of vectors and matrices , we specifically say vectors and matrices when their shape needs to be distinguished .    in what follows ,",
    "scalars are denoted by lower case letters like @xmath23 .",
    "vectors mean column vectors and we denote them by boldface lower case letters like @xmath81 and @xmath81 s components by @xmath82 .",
    "@xmath83 stands for the standard basis of @xmath1-dimensional euclidean space @xmath2 where @xmath84 is a vector that has one at the @xmath85-th position and zeros elsewhere .",
    "such vectors are called one - hot vectors .",
    "@xmath86 is a vector of all ones .",
    "@xmath87 is the inner product of @xmath88 and @xmath89 whereas @xmath90 is their outer product .",
    "matrices are assumed to be square and written by boldface upper case letters like @xmath91 .",
    "in particular @xmath92 is an identity matrix .",
    "@xmath93 is a matrix of all ones .",
    "@xmath94 stands for the trace of @xmath91 .",
    "order-@xmath95 tensors @xmath96 are denoted by underlined matrices like @xmath97 or @xmath98 ( @xmath99 ) .",
    "@xmath97 s component @xmath100 is also written as @xmath101 .",
    "let @xmath102 and @xmath103 be tensors .",
    "the mode-(@xmath104,@xmath105 ) contracted product @xmath106 of @xmath107 and @xmath108 is defined by @xmath109 @xmath110 with the convention that the association is to the left , i.e. , @xmath111 .",
    "so @xmath112 , the contracted product of @xmath107 and vector @xmath113 , which is computed by @xmath114 is equal to @xmath115 and the usual @xmath104-mode product @xmath116 of @xmath117 and matrix @xmath118 is equal to @xmath119 .",
    "tensors can be constructed by outer products ; @xmath120 is an order-3 tensor and @xmath121 @xmath122 is the outer product of @xmath123 and @xmath124 .",
    "let @xmath125 be the set of constants in @xmath10 and @xmath126 a model where @xmath127 ( we here identify @xmath128 and @xmath129 in @xmath130 with @xmath131 and @xmath21 respectively to avoid notational complications ) .",
    "we show how to replace the evaluation @xmath6\\ ! ] } $ ] of a prenex formula @xmath4 in @xmath132 with the evaluation of @xmath5 , a set of tensors compiled from @xmath4 , in @xmath1-dimensional euclidean space @xmath2 .",
    "the compilation of @xmath4 into @xmath5 starts from literals then proceeds to compound formulas and quantifications .",
    "first we isomorphically map @xmath0 to a model @xmath133 in @xmath2 .",
    "we map entities @xmath134 to one - hot vectors @xmath135 .",
    "so @xmath8 is mapped to @xmath136 , the basis of @xmath2 .",
    "we next map a @xmath3-ary relation @xmath21 in @xmath132 to a @xmath3-ary relation @xmath137 over @xmath138 which is computed by an order-@xmath3 tensor @xmath139 .",
    "@xmath140 is designed to retain the truth value @xmath141\\ ! ] } $ ] in * m * and given by the equation    @xmath142\\ ! ] } } \\nonumber \\\\   & = &   \\underline { { { \\mathbf r } } } ( { { { \\mathbf e } } } _ { i_1},\\ldots , { { { \\mathbf e } } } _ { i_k } )          \\quad \\mbox{as multi - linear map } \\nonumber \\\\   & = &   \\underline { { { \\mathbf r } } } \\times_{1,1 } { { { \\mathbf e } } } _ { i_1 }                \\times_{1,2}\\cdots\\times_{1,i_k } { { { \\mathbf e } } } _ { i_k } \\nonumber \\\\   & = &   r_{i_1,\\ldots , i_k } \\in \\{1,0\\}\\;\\ ;      ( \\forall i_1,\\ldots , i_k \\in \\{1,\\ldots , n\\ } ) .",
    "\\label{tensor : atom}\\end{aligned}\\ ] ]    we identity @xmath137 with @xmath140 for simplicity and say @xmath140 encodes the * m*-relation @xmath21 .",
    "let @xmath133 be a model @xmath143 ) in @xmath2 such that @xmath144 interprets entities by @xmath145 @xmath146 and relations @xmath21 by @xmath147 introduced by ( [ tensor : atom ] ) .",
    "we next inductively define the evaluation @xmath6\\ ! ] } ' _ { i',a'}$ ] of a formula @xmath4 in @xmath133 .",
    "let @xmath23 be an assignment in @xmath7 and @xmath148 the corresponding assignment in @xmath149 , i.e. , @xmath150 if - and - only - if @xmath151 .",
    "for a ground atom @xmath152 , we define    @xmath153\\ ! ] } '    = \\underline { { { \\mathbf r } } } ( { { { \\mathbf e } } } _ { i_1},\\ldots , { { { \\mathbf e } } } _ { i_k } )    \\;(\\forall i_1,\\ldots , i_k \\in \\{1,\\ldots , n\\ } ) \\label{tensor : atom2}\\ ] ]    where @xmath154 is the tensor that encodes the * m*-relation @xmath21 in * m * ( see ( [ tensor : atom ] ) ) . by definition @xmath6\\ ! ] } ' _ { i',a ' } = { [ \\ ! [ f ] \\ ! ] } _ { i , a}$ ] holds for any atom @xmath4 .",
    "negative literals are evaluated specifically in @xmath133 using tensors @xmath155 introduced by    @xmath156\\ ! ] } ' & = & \\neg\\underline { { { \\mathbf r } } } ( { { { \\mathbf e } } } _ { i_1},\\ldots , { { { \\mathbf e } } } _ { i_k } )                 \\nonumber \\\\ & = & 1 - r_{i_1,\\ldots , i_k } \\nonumber \\\\ \\mbox{where}\\;\\ ; \\neg\\underline { { { \\mathbf r } } } & { \\stackrel{\\rm def}{= } } & \\overbrace { { { \\mathbf 1 } } \\circ\\cdots\\circ { { \\mathbf 1 } } } ^k        - \\underline { { { \\mathbf r } } }    \\label{tensor : negatom}\\end{aligned}\\ ] ]",
    "we say @xmath155 encodes an * m*-relation @xmath157 is an order-@xmath3 tensor .",
    "@xmath158 @xmath159 holds .",
    "negation other than negative literals and conjunction and disjunction are evaluated in @xmath133 as follows .",
    "@xmath160\\ ! ] } ' _ { i',a ' } & = & 1 - { [ \\ ! [ f ] \\ ! ] } ' _ { i',a ' }     \\label{tensor : negation } \\\\ { [ \\ ! [ f_1 \\wedge\\cdots\\wedge f_h ] \\ ! ] } ' _ { i',a ' } & = & { [ \\ ! [ f_1 ] \\ ! ] } ' \\cdots { [ \\ ! [ f_h ] \\ ! ] } ' _ { i',a ' }   \\label{tensor : and } \\\\ { [ \\ ! [ f_1 \\vee\\cdots\\vee f_h ] \\ ! ] } ' _ { i',a ' } & = & { \\rm min}_1 ( { [ \\ ! [ f_1 ] \\ ! ] } ' _ { i',a'}+\\cdots+ { [ \\ ! [ f_h ] \\ ! ] } ' _ { i',a ' } ) \\label{tensor : or } \\\\ { [ \\ ! [ \\exists y f ] \\ ! ] } ' _ { i',a ' } & = & { \\rm min}_1            ( \\sum_{i=1}^n { [ \\ ! [ { f}_{y\\leftarrow e_i } ] \\ ! ] } ' _ { i',a ' } )   \\label{tensor : exists}\\end{aligned}\\ ] ]    here @xmath161 and when applied to tensors , it means componentwise application .",
    "@xmath162 is a formula obtained from @xmath4 by replacing every free occurrence of @xmath163 in @xmath4 with @xmath131 .",
    "universal quantification is treated as @xmath164 .",
    "it is straightforward to check that the evaluation @xmath6\\ ! ] } ' _ { i',a'}$ ] of a formula @xmath4 in @xmath165 by ( [ tensor : atom2 ] ) , ( [ tensor : negatom ] ) , ( [ tensor : negation ] ) , ( [ tensor : and ] ) , ( [ tensor : or ] ) and ( [ tensor : exists ] ) coincides with @xmath6\\ ! ] } _ { i , a}$ ] in @xmath0 .",
    "however , although this evaluation is carried out in a vector space , i.e. @xmath2 , it is based on the reduction of quantification to the ground level as ( [ tensor : exists ] ) indicates and contains a lot of redundancy .",
    "we next show how to do the same thing without grounding quantifications .",
    "now we come to the crucial point of our proposal , evaluating quantified formulas without grounding .",
    "consider a prenex formula @xmath166 .",
    "for the moment we assume the inner most quantified subformula @xmath167 is in @xmath32-dnf .",
    "let @xmath168 be an arbitrary disjunct of @xmath167 where @xmath77 are literals .",
    "we further assume the _ variable condition _ that @xmath163 occurs once in each literal @xmath169 ( @xmath170 ) . here",
    "@xmath171 if @xmath172 is a positive literal else @xmath173 .",
    "@xmath174 in * m * is called the * m*-relation contained in @xmath172 .",
    "let @xmath175(@xmath176 ) be a tensor encoding the * m*-relation @xmath174 defined respectively by ( [ tensor : atom ] ) or ( [ tensor : negatom ] ) .",
    "so @xmath177 ] \\ ! ] } $ ] holds where @xmath178 ( @xmath179 ) range over the domain of constants @xmath180 while @xmath181 correspondingly range over the domain of the standard basis @xmath182 .",
    "the notation @xmath183 $ ] emphasizes that @xmath184 occur in @xmath172 .",
    "suppose @xmath185 ( @xmath176 ) has @xmath163 as the @xmath186-th argument .",
    "remove @xmath163 , the @xmath186-th argument , from @xmath187 .",
    "write the remaining arguments ( with order preserved ) collectively as @xmath188 and consider @xmath189\\ ! ] } = { [ \\ ! [ l_m[x^{(m)}_{-y } ] ] \\ ! ] } = \\underline { { { \\mathbf r } } } _ m^{\\circ } ( { { \\mathbf x } } ^{(m)}_{-y } ) $ ] as a function of @xmath188 or a function of the corresponding arguments @xmath190 over @xmath191 parameterized with @xmath163 .",
    "then consider @xmath192\\ ! ] } \\in \\{1,0\\}$ ] as a relation combined with arguments ( free variables , possibly duplicate ) @xmath193 over @xmath194 , or equivalently , a function applied to @xmath195 over @xmath196 .",
    "we seek a tensor @xmath197 that encodes this function , i.e. , @xmath197 such that @xmath192\\ ! ] } = \\underline { { { \\mathbf r } } } ^{\\rm new } ( { { \\mathbf x } } ^{(1)}_{-y},\\ldots , { { \\mathbf x } } ^{(m)}_{-y})$ ] holds .",
    "look at    @xmath198\\ ! ] } } \\nonumber\\\\ & = & { [ \\ ! [ \\exists\\,y ( r_1^\\circ(x^{(1 ) } ) \\wedge\\cdots\\wedge r_m^\\circ(x^{(m ) } ) ) ] \\ ! ] } \\nonumber\\\\ & = &   { \\rm min}_1 \\big (     \\sum_{k=1}^n \\prod_{m=1}^m      \\underline { { { \\mathbf r } } } _ m^{\\circ } ( { { \\mathbf x } } ^{(m)})_{y\\leftarrow { { \\mathbf e } } _ k }                       \\big )   \\nonumber\\\\ & = & { \\rm min}_1 \\big (         \\sum_{k=1}^n \\prod_{m=1}^m ( \\underline { { { \\mathbf r } } } _ m^{\\circ } \\bullet_{j_m } { { \\mathbf e } } _ k )              ( { { \\mathbf x } } ^{(m)}_{-y } ) \\big ) \\nonumber\\\\ & = &   { \\rm min}_1 \\big (          \\sum_{k=1}^n           \\left\\ { \\big ( ( \\underline { { { \\mathbf r } } } _ 1^{\\circ } \\bullet_{j_1 } { { \\mathbf e } } _ k )          \\circ\\cdots\\circ ( \\underline { { { \\mathbf r } } } _ m^{\\circ } \\bullet_{j_m } { { \\mathbf e } } _ k )   \\big )             ( { { \\mathbf x } } ^{(1)}_{-y},\\ldots , { { \\mathbf x } } ^{(m)}_{-y } )          \\right\\ }    \\big ) \\nonumber\\\\ & = &   { \\rm min}_1 \\big (         \\sum_{k=1}^n         \\big ( ( \\overbrace { { { \\mathbf e } } _ k\\circ\\cdots\\circ { { \\mathbf e } } _ k}^{m } )        \\times_{1,j_1 } \\underline { { { \\mathbf r } } } _ 1^{\\circ }               \\times_{1,j_2}\\cdots \\times_{1,j_m } \\underline { { { \\mathbf r } } } _ m^{\\circ }        \\big ) \\big ) \\nonumber\\\\ &    &   \\quad\\quad   ( { { \\mathbf x } } ^{(1)}_{-y},\\ldots , { { \\mathbf x } } ^{(m)}_{-y } ) \\nonumber\\\\ & = & { \\rm min}_1        \\big ( \\underline { { { \\mathbf q } } } ^{\\exists , m }        \\times_{1,j_1 } \\underline { { { \\mathbf r } } } _ 1^{\\circ } \\times_{1,j_2 } \\cdots",
    "\\times_{1,j_m }                   \\underline { { { \\mathbf r } } } _ m^{\\circ }                   \\big ) ( { { \\mathbf x } } ^{(1)}_{-y},\\ldots , { { \\mathbf x } } ^{(m)}_{-y } ) \\nonumber\\end{aligned}\\ ] ]    here @xmath199 is a tensor representing the existential quantifier @xmath200 .",
    "summing up , the * m*-relation extracted from @xmath168 , which solely depends on the free variables in it , is encoded by @xmath201 where @xmath202 encodes the * m*-relation contained in @xmath172 ( @xmath170 ) and the existential quantifier @xmath200 that quantifies @xmath203 free occurrences of @xmath163 in @xmath204 is encoded by an order-@xmath203 tensor @xmath205 introduced by ( [ quant : exists ] ) .",
    "we call the equation ( [ tensor : existsand ] ) a definition for @xmath197 .    similarly , if @xmath167 is a @xmath33-cnf formula @xmath206 , the relation in * m * extracted from @xmath206 is encoded by @xmath207 where @xmath202 encodes the * m*-relation contained in @xmath208 ( @xmath170 ) ( details omitted ) .",
    "we now compile a prenex formula @xmath209 , using ( [ tensor : existsand ] ) and ( [ tensor : forallor ] ) , into an associated set @xmath5 of tensor definitions which computes @xmath6\\ ! ] } $ ] without grounding .",
    "however there is one problem to solve before compilation ; ( [ tensor : existsand ] ) , for example , is derived from @xmath210 under the the variable condition .",
    "when this condition is violated , we need to somehow recover it .    ' '' ''     + [ -1em ]    * input : * : :    a model * m * for a first - order language @xmath28 with    finitely many constants and a first - order closed formula    @xmath211 in @xmath28 in    prenex normal form such that no atom has duplicate variables and g is    an open dnf or cnf +     + * procedure : * : : * [ step 1 ] * : :    set @xmath212 , @xmath213 and    @xmath214 ; * [ step 2 ] * : :     +    * for * i = m * down - to * 1 * do * +    write @xmath215 ; +    if @xmath216 then goto * [ step 2-b ] * ; +    * [ step 2-a ] * +    convert @xmath217 to @xmath32-dnf    @xmath218 ; +    * for each * disjunct @xmath219 * in * @xmath218 * do * +    write    @xmath220    where @xmath163 occurs once +    in each @xmath221 ( @xmath222 ) and has no    occurrence in @xmath223 ; +    let @xmath224 be an enumeration without duplication    of +    free variables in    @xmath225 ; +    define a new atom by    @xmath226 ; +    replace @xmath219 in @xmath218 with    @xmath227 ; +    introduce a new tensor    @xmath197 by    ( [ tensor : existsand ] ) encoding +    the new relation @xmath228 in * m * ; +    add to @xmath5 the tensor definition for    @xmath197 ; +     +    set @xmath229 ; +    * [ step 2-b ] * +    convert @xmath217 to @xmath33-cnf    @xmath230 ; +    ( the rest is dual to * [ step 2-a ] * and omitted ) +    * enddo * + * [ step 3 ] * : :    if @xmath231 then put    @xmath232 ; +    else @xmath233 and put    @xmath234 ; +    ( @xmath235 s are atoms with no arguments , equated with +    true or false , and hence with @xmath236 ) +     + * output : * : :    @xmath237 with a set @xmath5 of    tensor definitions .",
    "@xmath5 @xmath5    encodes new * m*-relations appearing in @xmath238 and    @xmath239 gives @xmath6\\ ! ] } $ ] in * m*.    ' '' ''",
    "+    there are two cases where the condition is violated .",
    "the first case is that some atom @xmath240 in @xmath63 has duplicate occurrences of variables in the arguments @xmath241 . in this case , let @xmath242 be a tensor encoding the * m*-relation @xmath243 which is given by ( [ tensor : atom ] ) .",
    "let @xmath244 be a new atom defined by @xmath245 where @xmath246 is an enumeration of @xmath241 without duplication .",
    "it is apparent that a new relation @xmath247 stands for in * m * is encoded by a tensor @xmath248 such that @xmath249 where variables @xmath250 and @xmath251 run over @xmath252 .",
    "we replace every atom in @xmath63 that violates the variable condition with a new atom @xmath253 described above so that @xmath254 encodes the new * m*-relation @xmath255 .",
    "let the result be @xmath256 and consider @xmath257 .",
    "obviously when evaluated in @xmath149 , @xmath258 and @xmath4 give the same result , i.e. , @xmath259\\ ! ] } ' = { [ \\ !",
    "[ f ] \\ ! ] } '   (= { [ \\ ! [ f ] \\ ! ] } ) $ ] holds .",
    "so in the first case , we compile @xmath258 instead of @xmath4 .",
    "the second case is that , for example , some @xmath221s in @xmath260 have no occurrence of @xmath163 . in this case",
    ", we just shrink the scope of @xmath200 and rewrite @xmath219 like @xmath261 .    taking these modifications into account ,",
    "we summarize our compilation procedure in figure  [ eval : tensor ] .",
    "when a model @xmath0 and a closed prenex formula @xmath4 are given , the compilation procedure returns an algebraic formula @xmath237 and a set @xmath5 of tensor definitions .",
    "evaluating @xmath262 using @xmath5 gives @xmath6\\ ! ] } $ ] , the truth value of @xmath4 in * m*.      let @xmath263 .",
    "we compile @xmath264 into a set @xmath265 of tensor definitions along the compilation procedure in figure  [ eval : tensor ] .",
    "let @xmath107 , @xmath108 , @xmath266 and @xmath267 respectively be tensors encoding @xmath7-relations @xmath268 , @xmath269 , @xmath270 and @xmath219 .",
    "set @xmath271 .",
    "first we convert @xmath264 s innermost subformula @xmath38 into @xmath32-dnf : @xmath272 next we introduce new atoms and rewrite @xmath38 to @xmath273 : @xmath274 correspondingly to these new atoms , we construct tensors below which encode the corresponding relations in * m * and add them to @xmath5 : @xmath275    we put @xmath276 and continue compilation .",
    "we convert @xmath37 to @xmath33-cnf : @xmath277 we introduce new atoms and rewrite @xmath37 to @xmath278 : @xmath279 we construct tensors ( scalars ) for @xmath280 and @xmath281 : @xmath282 and add them to @xmath265 .",
    "now @xmath283 .",
    "finally we put @xmath284    so @xmath285\\ ! ] } $ ] in * m * is evaluated without grounding by computing @xmath286 using @xmath287 .      the compilation procedure in figure  [ eval : tensor ] is general .",
    "it works for arbitrary prenex formulas @xmath4 with arbitrary predicates .",
    "however when @xmath21 is a binary predicate , the corresponding tensor @xmath140 is a bilinear map and represented by an adjacency matrix @xmath288 as follows .",
    "@xmath289\\ ! ] } & = & ( { { { \\mathbf e } } } _ i \\bullet { { { \\mathbf r } } } { { { \\mathbf e } } } _ j )      \\;=\\ ; { { { \\mathbf e } } } _ i^t { { { \\mathbf r } } } { { { \\mathbf e } } } _ j      \\;=\\ ; r_{ij }   \\in \\{1,0\\ }   \\label{tensor : biatom}\\end{aligned}\\ ] ]    in such binary cases , we can often `` optimize '' compilation by directly compiling @xmath4 using matrices without introducing @xmath5 .",
    "this is quite important in processing kgs logically as they are a set of ground atoms with binary predicates .",
    "hence we here derive some useful compilation patterns using matrices defined by ( [ tensor : biatom ] ) for formulas with binary predicates .",
    "we specifically adopt @xmath6\\ ! ] } _ { \\bf mat}$ ] to denote the result of compilation using matrices that faithfully follows ( [ tensor : atom2 ] ) , ( [ tensor : negatom ] ) , ( [ tensor : negation ] ) , ( [ tensor : and ] ) , ( [ tensor : or ] ) and ( [ tensor : exists ] ) in subsection  [ subsec : model ] .",
    "@xmath290\\ ! ] } _ { \\bf mat } }   \\nonumber\\\\    & = & { [ \\ ! [   ( r_1(x , e_1)\\wedge r_2(e_1,z))\\vee\\dots\\vee                ( r_1(x , e_n)\\wedge r_2(e_n , z ) )   ] \\ ! ] } _ { \\bf mat } \\nonumber\\\\    & = & { \\rm min}_1\\big(\\sum_{j=1}^n                  { [ \\ ! [   r_1(x , e_j)\\wedge r_2(e_j , z )   ] \\ ! ] } _ { \\bf mat}\\big ) \\nonumber\\\\    & = & { \\rm min}_1\\big ( \\sum_{j=1}^n             { { { { \\mathbf x } } } } ^t { { { \\mathbf r } } } _ 1 { { { \\mathbf e } } } _ { j }             { { { { \\mathbf e } } } _ { j}}^t { { { \\mathbf r } } } _ 2 { { { \\mathbf z } } } \\big ) \\nonumber\\\\    & = & { { { \\mathbf x } } } ^t             { \\rm min}_1\\big ( { { { \\mathbf r } } } _ 1            \\big ( \\sum_{j=1}^n { { { \\mathbf e } } } _ { j } { { { { \\mathbf e } } } _ { j}}^t \\big ) { { { \\mathbf r } } } _ 2 \\big )               { { { \\mathbf z } } } \\nonumber \\\\    & = &   { { { { \\mathbf x } } } } ^t              { \\rm min}_1\\big ( { { { \\mathbf r } } } _ 1 { { { \\mathbf r } } } _ 2 \\big ) { { { \\mathbf z } } }   \\label{matrix : ex24}\\end{aligned}\\ ] ]    here @xmath291 and @xmath292 run over @xmath293 .",
    "hence the synthesized relation @xmath294 is encoded by a matrix @xmath295 . what is important with this example , or with binary predicates in general , is the fact that @xmath296 , an identity matrix , holds .",
    "similarly by applying ( [ matrix : ex24 ] ) , we can compile a doubly quantified formula @xmath297 as follows is encoded by @xmath298 as @xmath299 , @xmath300 is encoded by @xmath301 because @xmath302 holds . ] .",
    "@xmath303\\ ! ] } _ { \\bf mat } } \\nonumber\\\\    & = & { [ \\ ! [   \\left(\\exists y\\,r_1(e_{1},y)\\wedge r_2(e_1,y)\\right)\\vee\\dots\\vee             \\left(\\exists y\\,r_1(e_{n},y)\\wedge r_2(e_n , y)\\right )   ] \\ ! ] } _ { \\bf mat } \\nonumber\\\\    & = & { \\rm min}_1 \\big ( \\sum_{i=1}^n             { { { { \\mathbf e } } } _ { i}}^t                 { \\rm min}_1 ( { { { \\mathbf r } } } _ 1 { { { \\mathbf r } } } _ 2^t ) { { { \\mathbf e } } } _ { i } \\big )   \\nonumber\\\\    & = &   { \\rm min}_1({\\rm tr } ( { { { \\mathbf r } } } _ 1 { { { \\mathbf r } } } _ 2^t ) ) \\label{matrix : ex2}\\end{aligned}\\ ] ]    hence , a horn formula @xmath304 is compiled into    @xmath305\\ ! ] } _ { \\bf mat } } \\\\    & = & { [ \\ ! [   \\neg\\ , \\exists x\\,\\exists y\\ , r_1(x , y)\\wedge \\neg r_2(x , y )   ] \\ ! ] } _ { \\bf mat } \\nonumber\\\\    & = & 1 - { \\rm min}_1 ( { \\rm tr } ( { { { \\mathbf r } } } _ 1{\\neg { { { \\mathbf r } } } _ 2}^t ) ) .",
    "\\label{matrix : horn1}\\end{aligned}\\ ] ]    note that @xmath306 gives the number of pairs @xmath307 that do not satisfy @xmath308 . consequently @xmath309 implies every pair @xmath307 satisfies @xmath308 and vice versa .",
    "our compilation is thus confirmed correct .",
    "another , typical , horn formula @xmath310 is compiled into    @xmath311\\ ! ] } _ { \\bf mat } } \\nonumber \\\\    & = & 1 - { \\rm min}_1\\big (        { \\rm tr } ( { \\rm min}_1 ( { { { \\mathbf r } } } _ 1 { { { { \\mathbf r } } } _ 2}){\\neg { { { \\mathbf r } } } _ 3}^t )                        \\big ) .",
    "\\label{matrix : horn2}\\end{aligned}\\ ] ]    again @xmath312 is the total number of @xmath313s that do not satisfy @xmath314 .",
    "so our compilation is correct .",
    "our non - grounding linear - algebraic approach yields tensor equations from logical equivalence , and this property provides a new approach to the evaluation of datalog programs .",
    "we sketch it using a small example .",
    "consider the following datalog program that computes the transitive closure r2 of a binary relation r1 .",
    "+    l +     + this program defines the least hearbrand model @xmath7 where r1 is interpreted as @xmath315 and r2 as @xmath315 .",
    "@xmath316 holds true if - and - only - if there is a chain @xmath317 ( @xmath318 ) such that @xmath319 are all true in * m*. then we see the logical equivalence    @xmath320    holds for all @xmath321 in * m*. that means @xmath322\\ ! ] }   & = & { [ \\ ! [   r_1(x , z ) \\vee \\exists y ( r_1(x , y ) \\wedge r_2(y , z ) )   ] \\ ! ] }      \\label{trcl : semeq}\\end{aligned}\\ ] ] also holds for any @xmath321 .",
    "let @xmath323 and @xmath324 be adjacency matrices encoding @xmath315 and @xmath325 in * m * respectively .",
    "we translate ( [ trcl : semeq ] ) in terms of @xmath323 and @xmath324 as follows .",
    "@xmath326\\ ! ] } \\\\    & = & { [ \\ ! [   r_1(x , z ) \\vee \\exists y ( r_1(x , y ) \\wedge r_2(y , z )   ] \\ ! ] } \\\\    & = & { \\rm min}_1 ( { { \\mathbf x } } ^t { { \\mathbf r } } _ 1 { { \\mathbf z } }           + { { \\mathbf x } } ^t{\\rm min}_1 ( { { \\mathbf r } } _ 1 { { \\mathbf r } } _ 2 ) { { \\mathbf z } } ) \\\\    & = & { { \\mathbf x } } ^t{\\rm min}_1 ( { { \\mathbf r } } _ 1 + { { \\mathbf r } } _ 1 { { \\mathbf r } } _ 2 ) { { \\mathbf z } } \\end{aligned}\\ ] ] since @xmath327 are arbitrary , we reach a recursive equation @xmath328    it is to be noted that when considered an equation for unknown @xmath324 , ( [ trcl : mateq ] ) may have more than one solution is a solution . ] but we can prove that the transitive closure is the `` least '' solution of ( [ trcl : mateq ] ) in the sense of matrix ordering and @xmath329 are ordered by @xmath330 : @xmath330 if - and - only - if @xmath331 for all @xmath332.](proof omitted ) .    since ( [ trcl : mateq ] ) is a nonlinear equation due to @xmath333 operation , it looks impossible to apply a matrix inverse to obtain @xmath324 .",
    "however we found a way to circumvent this difficulty and proved that it is possible to obtain @xmath324 by computing ( [ trcl : mateq_sol_1 ] ) and ( [ trcl : mateq_sol_2 ] ) as follows .",
    "@xmath334    here @xmath335 means to threshold all elements in @xmath324 at @xmath336 , i.e , positive ones are set to 1 , o.w . to 0",
    "we compared our linear algebraic approach to datalog evaluation with state - of - the - art symbolic approaches using two tabled prolog systems ( b - prolog @xcite and xsb @xcite ) and two asp systems ( dlv @xcite and clingo @xcite ) .",
    "although we conducted a number of experiments computing various programs with artificial and real data , due to space limitations , we here pick up one example that computes the transitive closure of random matrices . in the experiment",
    ", we generate random adjacency matrices by specifying the number of dimension @xmath1 and the probability @xmath337 of each entry being 1 and compute their transitive closure matrices using ( [ trcl : mateq_sol_1 ] ) and ( [ trcl : mateq_sol_2 ] ) .",
    "we set @xmath338 and vary @xmath337 from @xmath339 to @xmath340 and measure the average computation time over five runs ( details omitted ) .",
    ".average computation time for transitive closure computation ( sec ) [ cols=\">,>,>,>,>,>\",options=\"header \" , ]     table  [ tab : trcl ] shows the result .",
    "our approach is termed `` matrix '' in the table .",
    "two observations are clear .",
    "first the computation time of our approach , matrix , is almost constant while others seem linear w.r.t .",
    "second , when @xmath337 is small , @xmath341 and matrices are sparse , the matrix method takes more time than existing systems but when @xmath337 gets bigger , it runs orders of magnitude faster than them .",
    "the same observation is made with other programs ( details omitted ) .",
    "there is not much literature concerning first - order logic embedded in vector spaces .",
    "the most related work to ours is a formalization of first - order logic in tensor spaces by grefenstette@xcite .",
    "he actually proposed two formalizations .",
    "the first one represents entities by one - hot vectors , predicates by adjacency tensors and truth values by two - dimensional vectors ( true by @xmath342^t$ ] false by @xmath343^t$ ] ) . and and or",
    "are order-3 order tensors whereas not is a @xmath344 matrix that maps @xmath345 to @xmath346 and vice versa .",
    "the first formalization can completely formalize a quantifier - free fragment of first - order logic in finite domains .",
    "the second formalization represents a finite set by a vector of multiple ones ( and zeros ) and can deal with single quantification by @xmath32 and @xmath33 , but nested quantification is out of scope .",
    "the unification of the first and second formalizations remains an open problem to his tensor approach .",
    "krompass et al .",
    "@xcite proposed a way of answering existential queries of the form @xmath347 in the context of low - dimensional embeddings .",
    "their approach however does not assign an independent representation to existential quantifiers and is limited to a narrow class of the form @xmath348 .",
    "we found no literature on computing the least model of datalog programs via solving recursive matrix equations .",
    "so the transitive closure computation presented in this paper is possibly the first example of this kind .",
    "we proposed a general approach to evaluate first - order formulas @xmath4 in prenex normal form in vector spaces . given a finite model * m * with @xmath1 entities , we compile @xmath4 into a set @xmath5 of hierarchical tensor definitions ( equations ) with a nonlinear operation .",
    "computing @xmath5 in @xmath2 yields the truth value @xmath6\\ ! ] } $ ] in * m*. in this compilation process , tensor representation @xmath205 is introduced to existential quantifiers themselves for the first time as far as we know .",
    "since our approach does not rely on propositionalization of first - order formulas , it can derive tensor equations from logical equivalences .",
    "we exploited this property to derive recursive matrix equations to evaluated datalog programs .",
    "we empirically demonstrated the effectiveness of our linear algebraic approach by showing that it runs orders of magnitude faster than existing symbolic approaches when matrices are not too sparse .",
    "zhou , n .- f . ;",
    "kameya , y. ; and sato , t. 2010 .",
    "mode - directed tabling for dynamic programming , machine learning , and constraint solving . in _ proceedings of the 22th international conference on tools with artificial intelligence ( octal-2010 ) _ , 213218 ."
  ],
  "abstract_text": [
    "<S> we propose a new linear algebraic approach to the computation of tarskian semantics in logic . </S>",
    "<S> we embed a finite model @xmath0 in first - order logic with @xmath1 entities in @xmath1-dimensional euclidean space @xmath2 by mapping entities of @xmath0 to @xmath1 dimensional one - hot vectors and @xmath3-ary relations to order-@xmath3 adjacency tensors ( multi - way arrays ) . </S>",
    "<S> second given a logical formula @xmath4 in prenex normal form , we compile @xmath4 into a set @xmath5 of algebraic formulas in multi - linear algebra with a nonlinear operation . in this compilation , </S>",
    "<S> existential quantifiers are compiled into a specific type of tensors , e.g. , identity matrices in the case of quantifying two occurrences of a variable . </S>",
    "<S> it is shown that a systematic evaluation of @xmath5 in @xmath2 gives the truth value , 1(true ) or 0(false ) , of @xmath4 in @xmath0 . </S>",
    "<S> based on this framework , we also propose an unprecedented way of computing the least models defined by datalog programs in linear spaces via matrix equations and empirically show its effectiveness compared to state - of - the - art approaches . </S>"
  ]
}