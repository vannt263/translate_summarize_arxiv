{
  "article_text": [
    "as a well - known fact that two - wayness and alternation do not help to recognize a nonregular language for constant space turing machines ( finite state automata ) @xcite .",
    "when formally defined first time @xcite , one  way probabilistic finite automata ( pfas ) were also shown to recognize all and only regular languages with bounded error .",
    "on the other hand , in his seminal paper , freivalds @xcite showed that two - way pfas can recognize some nonregular languages with bounded error .",
    "but , it was shown that two ",
    "way pfas require exponential expected - time to recognize nonregular languages @xcite .",
    "the quantum counterpart of two  way pfas ( two  way qfas ) were defined in @xcite and it was shown that they can recognize nonregular languages with bounded - error , even with one  way head move in linear time @xcite . here",
    "the computational power comes from the input head being in a superposition called quantum head , which can be used to implement a counter in a very special way ( see @xcite ) .",
    "later , two ",
    "way qfas with classical head ( 2qcfas ) were defined @xcite and it was shown that they can recognize nonregular languages in polynomial expected time .",
    "it is obvious that there are countably many regular languages since the description of any one  way deterministic finite automaton , which defines a single regular language , is finite .",
    "similarly computable ( regular or not ) languages , the ones recognized by turing machines , form a countable set . on the other hand ,",
    "all languages form an uncountable set , which is an evidence of existing uncountably many nonregular languages .    on the other hand",
    ", a probabilistic or quantum model can be defined with uncomputable transiton values and so their cardinalities are uncountably many .",
    "then , it is natural to ask whether they define an uncountable class . with unbounded - error ( recognition with cutpoint ) , even unary 2-state qfas and unary 3-state pfas",
    "define the classes formed by uncountably many languages @xcite .",
    "( unary pfas with 2-states define only a finite number of regular languages @xcite ) .",
    "so , the interesting case is investigating both models with bounded error : _ what are the minimal bounded - error probabilistic and quantum classes that contain uncountably many languages ? _",
    "polynomial  time constant  space quantum turing machines ( qtms ) and logarithmic  space probabilistic turing machines ( ptms ) are known to recognize uncountably many languages @xcite . in this paper , we investigate more restricted cases for qtms and ptms , i.e. using less space , restricted memory types , and restricted input head moves .",
    "we show that double logarithmic space is enough for ptms on unary languages in sweeping reading mode or logarithmic space for one  way head . on unary languages , for quantum models ,",
    "we obtain middle logarithmic space for counter machines . for binary languages ,",
    "arbitrary small non - constant space is enough for ptms even using only counter as memory . for counter machines , when restricted to polynomial time , we can obtain the same result for linear space .",
    "for constant  space qtms , we follow the result for a restricted sweeping head , known as restarting realtime .    in the next section , we give the required background with a short introduction to quantum operators and then we present our results in section [ sec : main - results ] under four subsections .",
    "we first present the results for ptms that are pedagogically easy to follow ( section [ sec : ptm ] ) .",
    "then , we restrict the model to use counter as a memory ( section [ sec : pca ] ) . after this",
    ", we also check some restrictions on the head movement ( section [ sec:1ptm ] ) .",
    "lastly , we present our quantum results ( section [ sec : qcfa ] ) .",
    "we close the paper by listing all results with possible future directions in section [ sec : conc ] .",
    "we assume the reader is familiar with the basics of complexity theory and automata theory .",
    "we refer the reader to @xcite for a complete reference on quantum computation , to @xcite for a pedagogical introduction to qfas , and to @xcite for a comprehensive chapter on qfas .    throughout the paper , @xmath0 denotes the blank symbol , @xmath1 denotes the empty string , @xmath2 not containing @xmath3 ( the left end - marker ) and @xmath4 ( the right end - marker ) denotes the input alphabet , @xmath5 is the set @xmath6 , @xmath7 not containing @xmath0 denotes the work tape alphabet , @xmath8 is the set @xmath9 , and @xmath10 is set of all strings obtained from the symbols in @xmath11 including the empty string .",
    "we order the elements of @xmath10 lexicographically and then represent the @xmath12-th element by @xmath13 where the first value @xmath14 is the empty string .",
    "we fix @xmath15 as the length of any given input .",
    "each model has a read  only one  way infinite input tape with a single head , on which the given input @xmath16 is placed as @xmath17 .",
    "all the remaining tape cells are filled with blank symbols . at the beginning of the computation ,",
    "the input head is placed on the left end - marker .",
    "each machine is designed to guarantee that the input head never visits outside @xmath17 .",
    "a work tape is a two  way infinite tape with a single head , where each tape cell is indexed with an integer . at the beginning of the computation , all cells of a work tape",
    "are filled with symbols @xmath18 and the head is placed on the cell indexed by zero .",
    "a deterministic turing machine ( dtm ) @xmath19 having an input tape and a work tape is a 7-tuple @xmath20 where @xmath21 is the set of finite internal states , @xmath22 is the initial state , @xmath23 and @xmath24 ( @xmath25 ) are the accepting and rejecting states , respectively , and @xmath26 is the transition function    @xmath27 that governs the behaviours of @xmath28 as follows : when @xmath19 is in state @xmath29 , reads symbol @xmath30 on the input tape , and reads symbol @xmath31 on the work tape , it follows the transition @xmath32 and then the state becomes @xmath33 , @xmath34 is written on the cell under the work head , and then the positions of input and work heads are updated with respect to @xmath35 and @xmath36 , respectively , where `` @xmath37 '' ( `` @xmath38 '' and `` @xmath39 '' ) means the head is moved one cell to the left ( the head does not move and the head is moved one cell to the right ) .",
    "the computation starts in state @xmath40 , and the computation is terminated and the given input is accepted ( rejected ) if @xmath19 enters @xmath41 ( @xmath42 ) .",
    "the set of strings accepted by @xmath19 form a language , say @xmath43 , and it is said that @xmath44 is recognized by @xmath19 .",
    "the space used by @xmath19 on a given input is the number of all cells visited on the worktape during the computation .",
    "if the input head is not allowed to move to the left , then it is called `` one  way ''",
    "and then the model is denoted as 1dtm .",
    "if we remove the work tape ( and all related components in the formal definition and in the transition function ) of a dtm/1dtm , we obtain a two  way / one  way deterministic finite automaton ( 2dfa/1dfa ) .",
    "a counter is a special type of memory containing only the integers .",
    "its value is set to zero at the beginning . during the computation , its status ( whether its value is zero or not )",
    "can be read like reading blank symbol or not on the work tape , and then its value is incremented or decremented by 1 or not changed like the position update of work head .",
    "thus a deterministic counter automaton ( 2dca ) is a 2dfa with a counter .",
    "the space used ( on the counter ) by a 2dca is maximum value of the counter during the computation .",
    "remark that the value of the counter can be stored on a binary work tape with logarithmic amount of the space .",
    "moreover , counter can also be seen as a unary work tape with certain specifications .",
    "a probabilistic turing machine ( ptm ) is a generalization of a dtm such that it can make random choices according to some probability distributions and so a ptm can do more than one transition in each step . each choice can be realized only with some probabilities .",
    "the number of choices and their realization probabilities are determined by the current state and the symbols read on the tapes , and the summation of the probabilities must be 1 to have a well  formed probabilistic systems .",
    "thus , a ptm can follow different paths during the computation and so the input is accepted with some probabilities .",
    "remark that all probabilistic models in this paper halt either absolutely or with probability 1 . in the latter case ,",
    "we mention about expected running time .",
    "since the space usage of a ptm can be different on the different paths , we take the maximum value .",
    "the language @xmath45 is said to be recognized by ptm with error bound @xmath46 ( @xmath47 ) if every member of @xmath44 is accepted with probability at least @xmath48 and every non - member of @xmath45 ( @xmath49 ) is accepted with probability not exceeding @xmath46 .",
    "one - way ptm ( 1ptm ) is defined similar to 1dtm .",
    "if we remove the work tape of a ptm/1ptm , we obtain two  way / one  way probabilistic finite automaton ( 2pfa/1pfa ) .",
    "a probabilistic counter automaton ( 2pca ) is a 2pfa with a counter .",
    "an @xmath50-state ( @xmath51 ) quantum system forms an @xmath50-dimensional hilbert space ( @xmath52 ) , complex vector space with inner product , spanned by the set @xmath53 , where @xmath54 is a column vector with zero entries except the @xmath55-th entry that is 1 . a quantum state of the system is a norm-1 vector in @xmath56 : @xmath57 where @xmath58 is a complex number and represents the amplitude of the system being in @xmath54 , and the probability of system being in @xmath54 is given by @xmath59 .",
    "the quantum system evolves by unitary operators , also known as norm preserving operators , represented by unitary matrices .",
    "let @xmath60 be a unitary operator ( matrix ) .",
    "then its @xmath61-th entry represents the transition amplitude from @xmath54 to @xmath62 , where @xmath63 . after applying @xmath60 , the new state",
    "is @xmath64    in order to retrieve information from the system , measurement operators are applied .",
    "we use a simple one called projective measurement , say @xmath65 .",
    "formally @xmath65 is composed by @xmath66 elements @xmath67 .",
    "each @xmath68 is a zero - one diagonal ( nonzero ) matrix and @xmath69 .",
    "so @xmath65 is designed to decompose @xmath56 into @xmath70 orthogonal subspaces and @xmath71 projects any vector to its subspace , where @xmath72 . after applying @xmath65 to the system when in @xmath73 , the system collapses to one of the subspaces and",
    "so the new quantum state lies only in this subspace .",
    "the vector @xmath74 is the projection of the quantum state to the @xmath75-th space and so the probability of observing the system in this subspace is given by @xmath76 .",
    "if this happens ( @xmath77 ) , the new quantum state is @xmath78 the vector @xmath79 is called unnormalized state vector and tracing quantum systems by such vectors can make the calculations simpler .",
    "( keeping the conditional probabilities with normalized states may make the calculations harder to follow . )",
    "now we give the definition of two  way quantum finite automaton with classical head , known as two  way finite automaton with quantum and classical states ( 2qcfa ) @xcite , which can use unitary operators and projective measurements on the quantum part .",
    "formally , a 2qcfa @xmath80 is a 8-tuple @xmath81 where , different from a classical model , @xmath82 is the set of quantum states , @xmath83 is the initial state , and the transition function @xmath26 is composed by @xmath84 governing quantum part and @xmath85 governing the classical part .",
    "the computation is governed classically . at the beginning of the computation ,",
    "the classical part is initialized and the state of quantum part is set to @xmath86 . in each step , the current classical state and scanned symbol determines a quantum operator , either a unitary operator or a projective measurement , that is applied to the quantum register . after getting the new quantum state ,",
    "the classical part is updated .",
    "if the quantum operator is unitary , then classical part is updated like a 2dfa .",
    "if the quantum operator is a measurement , then the outcome is processed classically , that is , the next state and head movement is determined by the current classical state , the measurement outcome , and the scanned symbol .",
    "when entering @xmath41 ( @xmath42 ) , the computation halts and the input is accepted ( rejected ) .    a ( strict ) realtime version of 2qcfa ( rtqcfa ) @xcite moves its head one square to the right in each step , halts the computation after the reading the right end - marker , and applies one unitary operator and then measurement operator for the quantum part in each step .",
    "a 2qcfa with counter ( 2qcca ) is a 2qcfa augmented with a classical counter , where the classical part can access a counter .",
    "a two  way model is called sweeping if the direction of the head can be changed only on the end - markers .",
    "so , the input is read from left to the right , then right to left , and then left to right , and so on .",
    "a very restricted version of sweeping models are realtime restarting models ( see @xcite for the details of restarting concept ) : the models have an additional state @xmath87 such that immediately after entering @xmath88 the overall computation is terminated and all computations start from the initial configuration . in this paper , we focus on restarting rtqcfas .",
    "we denote the set of integers @xmath89 and the set of positive integers @xmath90 .",
    "the set @xmath91 is the set of all subsets of @xmath92 : @xmath93 remark that the cardinality of @xmath89 or @xmath92 is @xmath94 ( countably many ) and the cardinality of @xmath95 is @xmath96 ( uncountably many ) like the set of real numbers ( @xmath97 ) .",
    "the membership of each positive integer in any @xmath98 can be represented as a binary probability value : @xmath99 quantumly , we use a different technique , originally given in @xcite .",
    "the membership of each positive integer in any @xmath98 can be represented as a single rotation on @xmath100 with the angle : @xmath101",
    "we start with ptms",
    ". then we focus on 2pcas and ptms with restricted head movements .",
    "lastly , we present our quantum results .",
    "it is known that polynomial ",
    "time ptms can use uncomputable transition probabilities to recognize uncountably many languages with bounded error @xcite .",
    "the @xmath102-th bit in the decimal expansion of the probability that a given biased coin will land heads can be estimated by a procedure that involves tossing that coin for a number of times that is exponential in @xmath102 . given any unary language @xmath45 on the alphabet @xmath103 , and a coin which lands heads with probability @xmath104 , where @xmath105 is an infinite sequence of digits whose @xmath102-th member encodes whether the @xmath102-th unary string is in @xmath45 ,",
    "the language @xmath106 is recognized by ptm with bounded error .",
    "the machine in this construction uses logarithmic space .    in this section",
    ", we improve this result and show that bounded - error probabilistic models can recognize uncountably many languages with less resources .",
    "we start with a technical lemma .",
    "[ lem:64k ] let @xmath107 be an infinite binary sequence . if a biased coin lands on head with probability @xmath108 , then the value @xmath109 can be determined with probability @xmath110 after @xmath111 coin tosses .",
    "let @xmath112 be the random variable denoting the number of heads after @xmath111 coin flips .",
    "the expected value of @xmath112 @xmath113=p*64^k$ ] .",
    "the value of @xmath114 is equal to @xmath115-th bit in @xmath113 $ ] .",
    "if @xmath116| \\leq 8^k$ ] we still have the correct @xmath114 , because @xmath113=x_101x_201x_301 ...",
    "x_k01 ... $ ] and is followed by @xmath117 bits after @xmath118 , and : if we add up to @xmath119 to this number , we get at most @xmath120 , followed by @xmath117 bits after @xmath121 ; if we subtract up to @xmath119 from this number , we get at least @xmath122 , followed by @xmath117 bits after @xmath123 . in both mentioned cases",
    "the bit @xmath114 remains unchanged .",
    "this means that the probability of error does not exceed @xmath124| \\geq 8^k]$ ] . by chebyshev",
    "s inequality we can get that @xmath125| \\geq 8^k ] \\leq \\frac{p*(p-1)*64^k}{(8^k)^2}=\\frac{p*(p-1)*64^k}{64^k}=p*(p-1).\\ ] ] therefore , the probability of an error is at most @xmath126 .",
    "function @xmath126 is parabolic function and its global maximum is @xmath127 .",
    "that is , @xmath128 for any chosen probability @xmath129 .",
    "therefore , the procedure gives the correct answer with the probability at least @xmath130 .",
    "now , we show that @xmath131 space is enough to recognize uncountably many languages .    [ thm : poly - unary - ptm ] polynomial",
    " time bounded ",
    "error unary ptms can recognize uncountably many languages in @xmath131 space .    for our purpose , we define languages based on the following unary language given by alt and mehlhorn in 1975 @xcite : @xmath132 where @xmath133 . it is known that @xmath134-space dtms can recognize @xmath135 .",
    "it is clear that the following language @xmath136 can also be recognized by @xmath134-space dtms . for the sake of completeness",
    ", we provide the details of the algorithm ( see also @xcite ) .",
    "assume that the input is @xmath137 for some @xmath138 . in order to check",
    "if a number @xmath102 written in binary on the work tape divides @xmath139 , we can use @xmath140 space for binary values of @xmath70 that form a counter , and then we can check whether @xmath141 is equal to zero or not . in order to compute @xmath142 , we can check each @xmath143 in order to determine the first @xmath70 such that @xmath144 .",
    "it is known that ( see lemma 4.1.2(d ) in @xcite ) , @xmath145 for some constant @xmath146 .",
    "therefore , we use @xmath134 space to find @xmath147 .",
    "remark that when the number @xmath142 is found , it is written on the work tape , and it is easy to check whether this number is a power of 64 , i.e. , it must start with 1 and should be followed by only zeros and the number of zeros must be a multiple of 6 ( @xmath148 ) .    for any @xmath98 , we can define a corresponding language : @xmath149    for any input @xmath150 , we can deterministically check whether @xmath151 by using the above algorithm . if not , the input is rejected .",
    "otherwise , we continue with a probabilistic procedure . remark that the work tape can still contain the binary value of @xmath147 that is @xmath152 for some positive integers @xmath153 in the beginning of the probabilistic procedure .",
    "we use a biased coin landing on head with probability @xmath154 encoding the memberships of positive integers in @xmath155 as described before .    by definition we know that @xmath156 if and only if @xmath157 .",
    "so , if we compute the value of @xmath158 correctly , we are done .",
    "since the work tape contains the value of @xmath152 , we can toss this biased coin @xmath159 times and count the number of heads . due to lemma [ lem:64k ] , we know that we can correctly compute @xmath158 with probability at least @xmath110 . here the number of heads is kept in binary and we check the @xmath160-th bit of the result after finishing the all coin tosses . by executing the probabilistic procedure a few more times",
    ", the success probability can be increased .",
    "remark that the space used on the work tape does not exceed @xmath131 and so the running time is polynomial in @xmath15 .",
    "the cardinality of the set of all subsets of positive integers is uncountably many and so the cardinality of the following set @xmath161 is also uncountably many , each element of which is recognized by a polynomial - time bounded - error unary ptm using @xmath162 space .",
    "with polynomial expected time , we can not do better since it was proven that polynomial - time ptms using @xmath163 space can recognize only regular languages even with unrestricted transition probabilities @xcite .    on the other hand , a well - known fact is that with super - polynomial expected time ptms can recognize nonregular binary languages even with constant - space @xcite .",
    "remark that constant - space unary ptms can recognize only regular languages @xcite and regarding @xmath164 space , we only know that one - way unary ptms can not recognize any nonregular language @xcite",
    ". currently we leave open whether constant ",
    "space ptms can recognize uncountably many languages and we do not know whether ptms can recognize a unary nonregular language with @xmath164 space .",
    "but we show that ptms can recognize uncountably many ( binary ) languages with arbitrary small non - constant space . for this purpose ,",
    "we use a fact given by freivalds in @xcite . note that here we use a slightly modified version of the original language given in @xcite in order to keep the input alphabet binary .    for any binary language @xmath165",
    ", we define another language @xmath166 as follows : @xmath167    [ fact : fre81 ] @xcite if a binary language @xmath44 is recognized by a bounded - error ptm in space @xmath168 , then the binary language @xmath166 is recognized by a bounded - error ptm in space @xmath169 .",
    "[ thm : log - am75 ] for any @xmath98 , the language @xmath170 can be recognized by a bounded - error ptm in space @xmath171 .",
    "it follows from theorem [ thm : poly - unary - ptm ] and fact [ fact : fre81 ] .",
    "similarly we can follow that the language @xmath172 for @xmath173 can be recognized by a bounded - error ptm in space @xmath174 .",
    "[ cor : ptm - arbitrary - small ] the cardinality of languages recognized by bounded - error ptms with arbitrary small non - constant space bound is uncountably many .      in this section , we present some results for 2pcas .",
    "remark that any @xmath168-space counter can be simulated by @xmath175-space work tape .",
    "it is easy for a 2pcas to check whether any specific part of the input has length of @xmath176 for some @xmath177 , and so , they can easily toss a biased coin for @xmath176 times and then count the number of heads on the counter .",
    "however , it is not trivial to read some certain digits of the result on the counter and so we use a clever trick here .",
    "[ thm : linear-2pca ] bounded - error linear - time ( linear - space ) 2pcas can recognize uncountably many languages .",
    "we start with the definition of a new language : @xmath178 remark that each member is composed by @xmath179 zero - blocks separated by single 1s except two special separators 11 that are used as the marker to indicate the @xmath180-th block , the length of which is @xmath181 .",
    "the language @xmath182 can be recognized by a 2dca , say @xmath183 .",
    "first it checks that the input starts with a single 0 and then ends with some 0s , all separators are 1s except two of them , which are 11 and consecutive , and the number of zero - blocks is @xmath184 for some @xmath185 .",
    "for all these checks , @xmath19 can use only its internal states . and",
    "then by using its counter it can check the length of each zero - block ( except the first one ) is double of the length of previous block .",
    "similarly , it can check the equality of the number of zero - blocks before the first `` 11 '' and the number of zero - blocks after the first `` 11 '' plus 3 , i.e. @xmath186 versus @xmath187 .",
    "if one of these checks fails , then the input is rejected immediately .",
    "otherwise , it is accepted .",
    "remark that @xmath19 can finish its computation in linear time and the counter value never exceeds the input length .    for any @xmath98 , we define a new corresponding language : @xmath188 for any such @xmath189 , we can construct a 2pca recognizing @xmath190 , say @xmath191 , as desired .",
    "the machine @xmath192 checks whether any given input , say @xmath193 , is in @xmath182 deterministically by using @xmath183 .",
    "if the input is not rejected by @xmath183 , we continue with a probabilistic procedure .",
    "since the last zero - block has the length of @xmath194 , by reading this block @xmath192 can toss @xmath195 biased coins that land on head with probability @xmath154 . the number of heads are counted on the counter .",
    "similar to the proof of theorem [ thm : poly - unary - ptm ] , the only remaining task is to determine the @xmath196-th bit of the binary value of the counter , which is @xmath114 .",
    "the bit @xmath114 in @xmath113=p_i*64^k$ ] is followed by @xmath197 bits .",
    "the number of heads on the counter , say @xmath198 , can be written as a binary number as follows : @xmath199 where each @xmath200 .",
    "remark that @xmath201 , i.e. @xmath202 .",
    "we can rewrite @xmath203 as @xmath204 where @xmath205 and @xmath206 are integers , @xmath207 , and @xmath208 .    after tossing - coin part",
    ", @xmath192 moves its head to the second symbol of the first `` 11 '' and then the automaton enters a loop . in each iteration",
    ", the head moves to next separator on the right by reading @xmath181 @xmath209s and then comes back by reading the same amount of 0s . in each iteration",
    ", @xmath192 tries to subtract @xmath181 twice ( @xmath210 ) .    if @xmath211 , then @xmath192 hits to the zero value on the counter when the head is at the starting position of the loop .",
    "this means @xmath212 and so the input is rejected by the automaton @xmath192 . if @xmath213 , then @xmath192 hits to the zero value on the counter ( at some @xmath75-th iteration , @xmath214 when the head is not at the starting position of the loop .",
    "it is clear that the value of counter is @xmath215 before starting the @xmath75-th iteration .",
    "now , we have two cases , @xmath216 or @xmath217 . if @xmath216 , @xmath192 hits to the zero value on the counter only after finishing to read the first @xmath181 @xmath209s . in this case",
    ", the input is accepted .",
    "otherwise , @xmath192 hits to the zero value on the counter before finishing to read the first @xmath181 @xmath209s .",
    "then , the input is rejected .",
    "it is clear that the value of counter never exceeds length of the input .",
    "moreover , both deterministic and probabilistic parts finish in linear time .    by relaxing the linear - time",
    ", we follow similar results for arbitrary small non - constant space on the counter like ptms .",
    "[ thm : log - dima ] for any @xmath218 , the language @xmath219 can be recognized by a bounded - error 2pca that uses @xmath220 space on the counter .",
    "let @xmath221 be our desired 2pca .",
    "the definition of @xmath219 is @xmath222 the automaton can deterministically check the input of the form @xmath223 . if not , the input is rejected .",
    "if so , we can assume that the input is of the form @xmath224 and the computation continues .",
    "if we are sure that each zero block ( except the first one ) has double length of the previous zero block , @xmath221 executes @xmath225 on @xmath226 by giving the same answer as @xmath225 and so we are done .",
    "in such a case , @xmath225 uses linear space on the counter in @xmath153 , which is logarithm of the input length .",
    "it is clear that if we use the counter to compare the length of zero blocks in regular way , then the value of counter can not be sub - linear . on the other hand , as shown by freivalds @xcite , 2pfas can make such a sequence ( unary ) equality checks with high probability ( see lemma 2 in @xcite ) .",
    "( the only drawback is that 2pfas require exponential expected time for these checks @xcite ) .",
    "thus , after the first deterministic check , @xmath221 determines the well form of zero blocks with high probability without using its counter .",
    "if the zero blocks are well formed , it calls @xmath225 on @xmath16 .",
    "otherwise , the input is rejected .",
    "similarly we can follow that the language @xmath227 for @xmath173 can be recognized by a bounded - error 2pca that uses @xmath228 space on the counter .",
    "[ cor:2pca - arbitrary - small ] the cardinality of languages recognized by bounded - error 2pcas with arbitrary small non - constant space bound is uncountably many .",
    "here we present some results by assuming further restrictions .",
    "[ thm:1ptm - log ] linearithmic  time bounded ",
    "error 1-way unary ptms can recognize uncountably many languages in @xmath229 space .",
    "we start with the definition of language @xmath230 : @xmath231 this language is recognized by 1dtms in @xmath229 space , where @xmath139 is the length of the input",
    ". a binary counter on the work tape is used to count the number of zeros in the input .",
    "this can be done in a straightforward way . for each input symbol",
    ", the value of the counter is increased by 1 .",
    "remark that any update on the counter can be done in @xmath232 steps .",
    "once the whole input is read , the counter is checked whether it is a power of @xmath233 , i.e. it must start with 1 and should be followed by only zeros and the number of zeros must be a multiple of 6 ( @xmath148 ) .",
    "the overall running time is @xmath234 .    like in theorem",
    "[ thm : poly - unary - ptm ] , for any @xmath98 , we can define a corresponding language : @xmath235 we again use a biased coin landing on head with probability @xmath154 .",
    "when we read the input and count the number of zeros , we can in parallel toss the biased coin and count the number of heads in a second counter on the working tape . after reading the whole input , for the inputs in @xmath236 ,",
    "the decision is given by checking the @xmath160-th bit of the second counter .",
    "this additional probabilistic procedure does not change the runtime and space asymptotically .",
    "the algorithm given in the proof of theorem [ thm : poly - unary - ptm ] for the language @xmath237 does not need to change the direction of head on the @xmath238s .",
    "so , we can call that ptm sweeping .",
    "[ cor : sweep - ptm ] polynomial ",
    "time bounded  error sweeping unary ptms can recognize uncountably many languages in @xmath131 space",
    ".    bounded ",
    "error linear ",
    "space sweeping pcas can recognize uncountably many languages in subquadratic time .",
    "we modify the algorithms given in the proof of theorem [ thm : linear-2pca ] .",
    "remark that the algorithms given there run in linear time . here",
    "the algorithms run in super - linear time .",
    "first we show how to deterministically recognize the language @xmath182 in sweeping reading mode , i.e. , @xmath178    with one pass ( reading the input from the left end - marker to the right end - marker ) , the input is checked without using counter whether having the following form @xmath239 and the number of 0-blocks are @xmath184 for some @xmath240 .",
    "moreover , for a member , the number of 0-blocks before the first `` 11 '' is @xmath186 and the number of 0-blocks after the second `` 11 '' is @xmath241 .",
    "therefore , by using the counter , we can check that the number of 0-blocks before the first `` 11 '' is 4 more than the number of 0-blocks after the second `` 11 '' .",
    "if any of these checks fails , then the input is immediately rejected .    in the second pass ( reading input from the right end - marker to the left end - marker )",
    ", it is checked that , for each @xmath242 , @xmath243-th 0-block has twice more zeros than @xmath244-th 0-block .    in the third pass",
    "( reading input from the left end - marker to the right end - marker ) , it is checked that , for each @xmath242 , @xmath245-th 0-block has twice less zeros than @xmath244-th 0-block .",
    "thus , in three passes , @xmath182 can be recognized by a sweeping pca .",
    "then , as in the proof of theorem [ thm : linear-2pca ] , for any @xmath98 , now we focus on the language : @xmath188 if the given input is in @xmath182 , then we continue with the probabilistic procedure .",
    "( otherwise , the input is rejected . )",
    "we perform the same walk as in the proof of theorem [ thm : linear-2pca ] , but , due to sweeping reading mode , each walk can be done from one end - marker to the other end - marker .",
    "but the presence of symbols `` 11 '' allows us to follow the same procedure only with slowdown .",
    "the running time is @xmath246 and it is super - linear and subquadratic in the length of input . to be more precise , the running time is @xmath247 if the @xmath139 is the length of the input .",
    "for any @xmath98 , we can compute the membership of the positive integer @xmath55 in @xmath155 as described below @xcite .",
    "we call it procedure _ adh_.    the qubit spanned by @xmath248 is set to @xmath86 .",
    "then , it is rotated with angle @xmath249 @xmath250 times , which leaves the quantum state having angle @xmath251 from the initial position .",
    "after an additional rotation by @xmath252 , the final angle from @xmath86 is @xmath253 if @xmath254 ( @xmath255 ) and it is @xmath26 if @xmath256 ( @xmath257 ) , where @xmath26 is sufficiently small such that the probability of the qubit being in @xmath258 ( @xmath86 ) is bigger than @xmath259 if @xmath255 ( @xmath257 ) .    say and yakaryilmaz @xcite presented a bounded  error polynomial ",
    "time 2qcfa algorithm , say @xmath260 , for @xmath261 remark that every member has @xmath262 @xmath238s for some @xmath263 .",
    "it is clear that for any member of @xmath264 having @xmath262 @xmath238s and for any @xmath98 , @xmath80 can be modified , say @xmath265 , in order to determine whether @xmath15 is in @xmath189 or not by using procedure adh with high probability .",
    "so , @xmath266 can recognize the following language with bounded error @xcite @xmath267 then , we can follow that 2qcfas can recognize uncountably many languages with bounded error .",
    "procedure adh can be implemented by a rtqcfa having a single qubit trivially , say @xmath268 for @xmath98 .",
    "so , if we show that @xmath264 is recognized by a restarting rtqcfa , say @xmath269 , then , we can follow that rtqcfas can recognize uncountably many languages . since @xmath269 can execute @xmath225 in parallel to its original algorithm , i.e. @xmath269 and @xmath270 are tensorred such that if @xmath269 is in the restarting state , then all computation is restarted ; otherwise , the input is accepted if and only if both @xmath269 and @xmath225 give the decision of `` accepting '' . the obtained",
    "restarting rtqcfa gives its decisions with bounded error .",
    "we refer the reader to @xcite for the technical details to obtain a restarting bounded ",
    "error rtqcfa by tensorring two bounded  error restarting rtqcfas , where the results are given for general realtime qfa models but it can be followed for rtqcfas in the same way since general realtime qfa models and rtqcfas can simulate each other exactly .    [ thm : rtqcfa ] the language @xmath264 can be recognized by a restarting rtqcfa @xmath269 with bounded error .",
    "the quantum part of @xmath269 has 9 states ( @xmath271 ) but only the first three of them are used significantly . before each unitary operation",
    ", the quantum state has always zeros after the significant first three entries @xmath272 after we apply a unitary operator @xmath60 , we obtain a new quantum state . then , we make some measurements such that if the system is in @xmath273 , then the computation is always restarted .",
    "so , if the computation is not restarted , the new quantum state has always zeros for the last six entries .",
    "@xmath274 sometimes the measurement operator can also affect the first three states that will be specified later .",
    "each unitary operator is a @xmath275-dimensional unitary matrix .",
    "however , the significant parts are the top - left @xmath276-dimensional matrices due to the measurement operators .",
    "so , we can trace the computation only by a 3-dimensional vector and @xmath276-dimensional matrices .",
    "we describe our algorithm with integer matrices with a real coefficient @xmath277 : @xmath278 remark that @xmath279 is the top - left corner of a unitary matrix and all the other entries can be filled arbitrarily providing that the matrix is unitary . for our purpose , first we define our @xmath280-dimensional matrices @xmath281s , which do the main tasks , and then complete the missing parts of unitary matrices by selecting a fixed @xmath282 for all @xmath281s .",
    "we refer the reader to @xcite for the details of how to pick nonnegative real @xmath283 and fill the missing parts of unitary matrices .    after a measurement operator",
    ", we can obtain more than one unnormalized state vector having norm less than 1 . depending on the measurement outcome",
    ", the system collapses into one of them and then the corresponding unnormalized state vector is normalized ( norm-1 vector ) . on the other hand ,",
    "since the probabilities can be calculated directly from the entries of unnormalized state vectors , we trace the computation with unnormalized state vectors .",
    "after all these technical descriptions , we can give the details of our quantum algorithm .",
    "( qfa algorithms based on such assumptions have been presented before ( e.g. see @xmath284 ) . )",
    "the quantum part is in state @xmath285 at the beginning .",
    "if the input does not start with @xmath286 , then it is rejected deterministically .",
    "otherwise , by reading 7 @xmath238s , the quantum part is set to @xmath287 if the input is @xmath286 , then it is accepted deterministically .    in the remaining part",
    ", we assume that the input is of the form @xmath288 .",
    "otherwise , the input is rejected deterministically .",
    "remark that , after each quantum step , the computation is restarted with some probability and so the computation in a single round can reach to the end - marker only with a very small ( exponentially small in the input length ) probability .    at the beginning of each block of @xmath289s , say the @xmath12-th block , the quantum state is @xmath290 where    * @xmath291 is the non - halting _",
    "unnormalized _ quantum state vector , * the first block ( @xmath292 ) is the first @xmath289s after @xmath286 , * @xmath293 is the number of @xmath238s in the previous block with @xmath294 , and * @xmath295 is the number of unitary operators applied until that step , i.e. 7 unitary operators are applied on the input @xmath286 ( the others can be assumed as identity operator ) , and then for each symbol , a unitary operator is applied .",
    "remark that the expected number of @xmath238s in the @xmath12-th block is already written as the amplitude of the @xmath258 , i.e. , for any member , the number of @xmath238s in the @xmath12-th block is 8 times of the number of @xmath238s in the previous block .    during reading the @xmath12-th block ,",
    "the number of @xmath238s are counted and kept as the amplitude of @xmath296 : @xmath297 after reading the block , just before reading @xmath298 , the quantum state is @xmath299 then , we obtain the following vector after reading @xmath300 before the measurement : @xmath301 after this , the measurement operator , additional to its previously described standard behaviour , also checks whether the system is in @xmath302 or @xmath303 . in the latter case , the input is rejected , and the computation continues , otherwise .",
    "we have two cases :    * if @xmath304 , then @xmath305 is a nonzero integer , and so , the input is rejected with probability at least @xmath306 . *",
    "if @xmath307 , then the input is rejected with zero probability .",
    "that is , for any non - member , the input is rejected after a block with some nonzero probability . for each member , on the other hand , the input is never rejected until end of the computation .    at the end of the computation ,",
    "the state before reading the right end - marker is @xmath308 if there are @xmath70 blocks of @xmath238s .",
    "then , we obtain the following quantum state after reading the right end - marker @xmath309 and the input is accepted if @xmath86 is observed . then the input is accepted with probability @xmath310 , which is clearly at least @xmath311 times of any possible rejecting probability before .",
    "now , we can analyse a single round of @xmath269 , the period from the initial configuration to give a decision or to restart the computation , and then calculate the overall probabilities on the given input .",
    "any member is accepted with an exponentially small but non - zero probability ( @xmath310 ) and it is rejected with zero probability .",
    "so , in exponential expected time , the input is accepted with probability 1 .",
    "any non - member , on the other hand , is again accepted with a very small non - zero probability but it is also rejected with a probability sufficiently bigger than the accepting probability .",
    "so , in exponential expected time , the input is rejected with probability @xmath312 that is at least @xmath313 , where @xmath314 and @xmath269 are the accepting and rejecting probabilities , respectively , in a single round ( see @xcite for the details of calculating the overall rejecting probability ) . remark that @xmath282 can be picked arbitrarily small and so the rejecting probability can be arbitrarily close to 1 .",
    "exponential expected time restarting rtqcfas can recognize uncountably many languages with bounded error .",
    "it is still open whether rtqcfas can recognize a nonregular language with bounded error in polynomial time .",
    "some algorithms can be space sufficient only for the members .",
    "that is known as recognition with middle space @xcite .",
    "the standard space usage is known as recognition with strong space . until now ,",
    "we focus on strong space bounds . on the other hand , we know that 2qccas can recognize the following nonregular unary language with bounded error in middle logarithmic space @xcite :    @xmath315 here the base-2 is not essential and it can be replaced with any integer bigger than 2 .",
    "therefore , 2qccas can also recognize @xmath316 with bounded error in middle logarithmic space ( by slightly modifying the algorithm for @xmath317 ) .",
    "moreover , for any @xmath98 , 2qccas recognize the following language @xmath318 with bounded error in middle logarithmic space , i.e. we first determine whether the input is of the form @xmath319 with high probability .",
    "if so , we call procedure adh , which does not use the counter , to determine whether @xmath320 is in @xmath189 or not with high probability .    unary middle logarithmic  space 2qccas can recognize uncountably many languages with bounded error .",
    "in this paper , we identify some small space ( and time ) bounds for bounded  error probabilistic and quantum models that can recognize uncountably many languages .",
    "we list the positive cases that we obtain below .",
    "we also present the related open cases .    * unary languages : * * polynomial  time @xmath134space sweeping ptms ( open for @xmath163-space ) * * linearithmic  time @xmath321space 1ptms * * middle @xmath321space 2qccas ( open for better space bounds and/or polynomial  time ; open for 2pcas ) * binary languages : * * @xmath322space 2pcas ( open for @xmath323space ( or equivalently 2pfas ) ) * * polynomial ",
    "time @xmath324space 2pcas ( open for polynomial",
    " time @xmath325space ) * * restarting rtqcfas ( open for polynomial  time )    the above list can be extended with some other restricted models ( for example , pushdown finite automata , turing machines with limited reversal complexity , multihead automata , constant  space interactive proof systems ) , which we leave as future works .",
    "we thank to anonymous referees for their very helpful comments ."
  ],
  "abstract_text": [
    "<S> polynomial  time constant  space quantum turing machines ( qtms ) and logarithmic  space probabilistic turing machines ( ptms ) recognize uncountably many languages with bounded error ( say and yakaryilmaz 2014 , arxiv:1411.7647 ) . in this paper , we investigate more restricted cases for both models to recognize uncountably many languages with bounded error . we show that double logarithmic space is enough for ptms on unary languages in sweeping reading mode or logarithmic space for one - way head . on unary languages , for quantum models , we obtain middle logarithmic space for counter machines . for binary languages , </S>",
    "<S> arbitrary small non - constant space is enough for ptms even using only counter as memory . for counter machines , when restricted to polynomial time , we can obtain the same result for linear space . for constant  space qtms , </S>",
    "<S> we follow the result for a restricted sweeping head , known as restarting realtime . </S>"
  ]
}