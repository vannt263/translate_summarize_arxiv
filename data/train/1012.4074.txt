{
  "article_text": [
    "due to recent advances in bio technology ( bt ) , genome sequences of diverse organisms including human beings are collected into databases .",
    "the human genome project ( hgp ) , which had been initiated in 1990 , released the human dna sequences of approximately 3gbp size in 2003 . since the release , a lot of researches are under their way for harnessing the genome sequences .",
    "an essential research issue is about indexing large - scale genome sequences for efficient retrieving of genome subsequences of interest  @xcite .",
    "the suffix tree is most widely adopted for indexing genome sequences  @xcite . in general , a suffix tree is created for a given string ( or sequence ) @xmath0 and enables efficient exact matching and approximate matching on substrings of @xmath0  @xcite .",
    "we explain the suffix tree in more detail in section  [ sec : suffix ] .",
    "a lot of algorithms have been proposed for efficient construction of the suffix tree .",
    "algorithm  @xcite is the most famous one which , given a string of length @xmath1 , constructs the corresponding suffix tree in @xmath2 time .",
    "the algorithm implicitly assumes that @xmath1 is small enough so that the input string and the output suffix tree can be loaded in the main memory as a whole",
    ". however , genome sequences could be several million or billion times larger than the strings dealt with the traditional suffix tree construction algorithms such as ukkonen s algorithm .",
    "moreover , the suffix tree is about 10 @xmath3 60 times larger than the input sequence  @xcite .",
    "hence , the application of ukkonen s algorithm for large - scale genome sequences should cause severe disk swap in and out , which is generally called _ memory bottleneck problem _ or _ thrashing _",
    "@xcite . actually , top - q algorithm  @xcite , an extension of ukkonen s algorithm , took seven hours for constructing the suffix tree for genome sequences of 40mbp , which is much smaller than the human genome sequences , and it could not finish for genome sequences of 60mbp  @xcite .    for coping with the memory bottleneck problem , a few disk - based algorithms have been proposed for constructing the suffix tree  @xcite .",
    "disks have much larger size than main memory at the lower cost ; however , they require much longer access time up to several hundred times .",
    "hence , the disk - based algorithms are designed mainly to maximize the main memory utilization and the disk access efficiency . however , these algorithms have a common drawback that they incur random disk accesses .",
    "the disk access performance is dependent more on access patterns than access amount ; even for accessing the same amount , the random disk access requires much more time than the sequential disk access .",
    "thus , the disk - based algorithms have been improved in the way of decreasing the ratio of random disk accesses .",
    "another problem of the previous disk - based algorithms is that they do not fully utilize the most up - to - date cpu technologies . instead of raising the clock speed ,",
    "recent cpus are designed to have multiple , simultaneously running cores that enable intra - cpu parallel processing .",
    "however , some previous algorithms run mostly on a single core , and the others suffer from severe interference among the threads and hence have little gain by parallel processing .",
    "we explain the problems of the previous algorithms in more detail in section  [ sec : related ] .    in this paper , we propose a fast algorithm based on ` divide - and - conquer ' strategy for constructing the suffix tree for large - scale human genome sequences .",
    "the most significant difference from the previous algorithms is that the proposed algorithm almost eliminates random disk accesses by accessing the disk in the unit of contiguous chunks each of which stores an entire suffix subtree .",
    "in addition , our algorithm fully utilizes the multi - core cpus by dividing the genome sequences into multiple , independent partitions and then assigning each partition to a different core for parallel construction of suffix subtrees . as an experimental result , our algorithm finished construction of the suffix tree for the entire human genome sequences in 64 minutes and outperformed digest algorithm  @xcite , which had previously been the fastest disk - based algorithm , by up to 3.5 times .    this paper is organized as the following . in section  [ sec : suffix ] , we briefly explain on the suffix tree . in section",
    "[ sec : related ] , we explain on the previous disk - based suffix tree construction algorithms .",
    "we also explain the performance degradation by random disk accesses in the section . in section  [ sec :",
    "indexing ] , we propose a new disk - based suffix tree construction algorithm , and then in section  [ sec : eval ] , we evaluate the performance of our algorithm through a series of experiments .",
    "figure  [ fig01 ] shows the suffix tree for a short dna sequence @xmath0 = atagctagatcg$. the symbol ` $ ' is appended at the end of @xmath0 so as to prohibit any suffix in @xmath0 from being the prefix of any other suffix .",
    "given a query sequence @xmath4 , the search begins from the root node of the suffix tree . from the outbound edges of the root node ,",
    "an edge @xmath5 is chosen such that the label of @xmath5 is the prefix of @xmath4 .",
    "if no such edge is found , the search ends ; if found , the child node @xmath6 is visited by following the edge @xmath5 , i.e. , @xmath5 is the inbound edge of @xmath6 .",
    "let @xmath7 be the label length of @xmath5 , @xmath8 be the prefix of @xmath4 of length @xmath7 , and @xmath9 be the suffix of @xmath4 of length @xmath10 .",
    "then , it holds that @xmath11 , where @xmath12 is the sequence concatenation operator . the search for query subsequence",
    "@xmath9 begins recursively at the node @xmath6 in the same manner as the root node .",
    "the search goes on until a terminal node is reached in the suffix tree or there is no query ( sub)sequence to be searched for .",
    "= atagctagatcg$.,title=\"fig:\",width=240 ] + ( a ) edge labels are represented with subsequences .",
    "+   = atagctagatcg$.,title=\"fig:\",width=240 ] + ( b ) edge labels are represented with ( start , end ) positions in @xmath0 .",
    "let us take a query sequence @xmath4 = agatcg for example",
    ". in figure  [ fig01](a ) , from the outbound edges of the root node , the edge with label ` a ' is followed and then the node @xmath13 is visited .",
    "the search for query subsequence @xmath9 = gatcg is performed recursively at the node @xmath13 .",
    "the search continues until the terminal node with position 6 is reached ; it indicates that query sequence @xmath4 is found at position 6 in the sequence @xmath0 .",
    "figure  [ fig01](b ) shows the suffix tree whose edge labels are represented with ( start , end ) positions in @xmath0 . while the labels representation sizes in figure  [ fig01](a ) are arbitrary , those in figure  [ fig01](b ) are all identical .",
    "hunt et al .",
    "@xcite proposed the first disk - based suffix tree construction algorithm .",
    "hunt s algorithm excludes construction of suffix links , which caused severe memory bottleneck problem in ukkonen s algorithm  @xcite .",
    "hunt s algorithm divides the given genome sequences into partitions and then constructs a separate suffix subtree for each partition .",
    "although hunt s algorithm has @xmath14 complexity , it shows better indexing performance than ukkonen s algorithm by reducing disk accesses .",
    "however , hunt s algorithm incurs heavy random disk accesses since it stores each node in the suffix tree as a separate object using the persistent java object storage interface called pjama  @xcite . actually , the algorithm was successful in indexing genome sequences of up to 286mbp size , but it could not be used for indexing the human genome sequences  @xcite .",
    "tian et al .",
    "@xcite presented the top - down disk - based ( tdd ) approach for constructing disk - based suffix trees .",
    "tdd consists of two algorithms : partition and write only top down ( pwotd ) algorithm based on wotd - eager algorithm  @xcite for constructing suffix trees and a memory buffer management algorithm for maximizing the performance of pwotd algorithm .",
    "the performance of pwotd algorithm highly depend on the settings of the memory buffer management algorithm  @xcite .",
    "tian et al .",
    "@xcite showed that tdd incurred only one sixth of disk accesses than dynacluster algorithm  @xcite , an extension of hunt s algorithm , and that tdd constructed the suffix tree for the entire human genome sequences in 30 hours .",
    "however , the memory buffer management algorithm in tdd assigns only a small portion of memory for keeping the suffix tree in main memory , while it assigns the largest portion to input genome sequences .",
    "tdd uses least recently used ( lru ) policy for swapping out the memory buffers into disk while constructing the suffix tree .",
    "whenever pwotd algorithm creates a new node @xmath15 , it needs to access @xmath15 s parent node @xmath16 that could be previously stored far away from @xmath15 .",
    "this causes random disk accesses , and the larger genome sequences should cause more random accesses .",
    "phoophakdee and zaki  @xcite proposed an algorithm called trellis , which eliminated data skewness among suffix subtrees by dividing genome sequences according to variable - length prefixes .",
    "unlike hunt s algorithm  @xcite and tdd  @xcite , trellis can create suffix links optionally after the suffix tree is constructed .",
    "trellis consists of three phases : prefix creation , partitioning , and merging phases . in the prefix creation phase ,",
    "variable - length prefixes are created so that , for each prefix @xmath17 , the suffix subtree @xmath18 corresponding to the suffixes having the prefix @xmath17 can be loaded into main memory as a whole . in the partitioning phase ,",
    "the entire genome sequences are divided into partitions so that each partition @xmath19 and its corresponding suffix tree @xmath20 can be loaded into main memory as a whole .",
    "then , a suffix tree @xmath20 is constructed for each partition in this phase . in the merging phase , for each prefix @xmath17 created in the prefix creation phase",
    ", the suffix subtrees @xmath21 are extracted from the suffix trees @xmath20 and then merged into a single suffix subtree @xmath18 .",
    "phoophakdee and zaki  @xcite showed that trellis outperformed tdd by up to 4 times and that it constructed the suffix tree for the entire human genome sequences in 4.2 hours .",
    "however , since trellis extracts the suffix subtrees @xmath21 stored at random positions in the suffix trees @xmath20 in the merging phase , it incurs severe random disk accesses .",
    "actually , the merging phase requires the longest execution time  @xcite .",
    "ghoting and makarychev  @xcite proposed an algorithm called wavefront based on ` partition - and - merge ' strategy as trellis  @xcite .",
    "wavefront divides the entire data into i / o - efficient partitions and processes each partition independently . in  @xcite",
    ", wavefront was extended to be executed on a massively parallel system .",
    "the algorithm completed indexing the entire human genome sequences in 15 minutes on ibm blue gene / l system composed of 1024 processors  @xcite .",
    "however , wavefront executed on a single processor showed no noticeable performance improvement compared with trellis  @xcite .",
    "barsky et al .",
    "@xcite proposed an algorithm called digest which consists of two phases similar to the merge - sort algorithm . in the first phase",
    ", the entire genome sequence is divided into partitions of the same length so that each partition can be loaded into main memory .",
    "for each partition , the suffixes contained therein are sorted in main memory and then are stored in disk . in the second phase , the suffixes sorted separately in each partition are merge - sorted .",
    "suffix blocks from each partition are read sequentially one by one into main memory . the suffixes in different blocks",
    "are compared with each other , and the smallest one is extracted and then saved in the output block .",
    "when the output block becomes full , it is stored in disk .",
    "this continues until all the input blocks are empty .",
    "the sorted suffixes is called a _ suffix array _ , and it is known that a suffix array can be easily converted into a suffix tree  @xcite .",
    "barsky et al .",
    "@xcite showed that digest outperformed trellis+  @xcite , an extension of trellis  @xcite , by up to 40% and that the algorithm completed indexing the entire human genome sequences in about 85 minutes .",
    "however , digest should read suffix blocks from each partition stored at random positions in the second phase and hence suffers from severe random disk accesses .",
    "moreover , since the merging phases of trellis and digest can not be parallelized , they have little performance gain even by using recent multi - core cpus .    as explained so far ,",
    "the common drawback of the previous algorithms is the performance degradation due to random disk accesses .",
    "figure  [ fig02 ] shows an experimental result of reading / writing a disk volume of 100 mb size .",
    "the volume was read and written sequentially and at random in the unit of 512 kb and 4 kb . in the figure , the sequential read /",
    "write performed up to 112.1 and 47.7 times better than random read / write , respectively .",
    "the values in figure  [ fig02 ] should be different according to experimental environments , though it is always the case that sequential accesses have better performance than random accesses .",
    "in this section , we propose a new algorithm for indexing human genome sequences .",
    "the human genome is composed of 46 chromosomes : 22 chromosome pairs numbered 1 @xmath3 22 and x / y ( sex ) chromosomes . in this paper",
    ", we concatenate the entire genome sequences into a single long sequence and use this sequence as the input of our algorithm .",
    "this helps simplify indexing and searching algorithms .",
    "our algorithm is designed based on divide - and - conquer strategy : it divides the entire human genome sequence into multiple independent partitions and then constructs the suffix tree separately for each partition .",
    "the suffix tree for each partition is constructed in a contiguous chunk in main memory . when the construction is completed , the chunk image is stored sequentially into disk as it is .",
    "hence , unlike trellis and digest  @xcite , our algorithm has no performance degradation due to random disk accesses .",
    "moreover , since the suffix trees for different partitions are constructed independently and are not merged thereafter , their construction can be done in parallel by fully utilizing the most up - to - date multi - core cpus . according to these features ,",
    "our algorithm achieves dramatic performance improvement compared with the previous algorithms .",
    "our algorithm represents each base as a 2-bit code as in  @xcite ; a , c , g , and t are represented as 00 , 01 , 10 , and 11 , respectively . since the human genome sequence has the size of approximately 3gbp , the 2-bit coded sequence has the size of about 3gbp / 4 = 750 mb .",
    "actually , after removing unidentified base pairs , the 2-bit coded sequence has the size of about 700 mb and can be fully loaded in main memory .",
    "our algorithm assigns memory region for the full 2-bit coded genome sequence at the beginning and retains it to the end .",
    "our algorithm divides the human genome sequence into partitions according to prefixes , i.e. , the suffixes having the common prefix belong to the same partition .",
    "we explain how to determine the prefixes for partitioning at the end of this section .",
    "the partitions are not necessarily created by physically dividing the genome sequence , but only the suffix positions are managed for each partition . while scanning the entire genome sequence , our algorithm creates the lists of suffix positions simultaneously for every prefix determined earlier ; the list for a prefix @xmath22 contains the positions of suffixes having the prefix @xmath17 , where @xmath23 is the number of partitions .",
    "although each of these lists has a small size , the entire lists occupy a considerable amount of memory .",
    "hence , the lists are stored in disk right after their creation ; each list is retrieved from disk only once when the suffix tree is about to be constructed for the corresponding partition .",
    "our algorithm creates each list of suffix positions in a contiguous memory region to read / write the list with a single operation and hence to eliminate random disk accesses . to obtain the sizes of",
    "contiguous memory regions , our algorithm scans the human genome sequence to count the frequency of every prefix before creating the lists of suffix positions .",
    "when the creation of partitions ( i.e. , the lists of suffix positions in the human genome sequence ) is completed , our algorithm constructs the suffix tree separately for each partition . at first",
    ", our algorithm creates an empty suffix tree without any node and then adds suffixes one by one into the suffix tree while scanning the corresponding list of suffix positions .",
    "figure  [ fig03 ] shows an example of adding suffixes into a suffix tree .",
    "figure  [ fig03](a ) shows a suffix tree before addition .",
    "figure  [ fig03](b ) shows the result of adding a suffix @xmath24 = agtg$ into the suffix tree in figure  [ fig03](a ) .",
    "@xmath24 has the prefix @xmath25 = ag of length 2 which matches the label of the outbound edge of @xmath13 and then @xmath26",
    "= tg$ does not have common prefix with any label of the outbound edges of @xmath27 . in this case",
    ", our algorithm creates a new outbound edge @xmath5 of @xmath27 and labels it with @xmath26 = tg$. the edge @xmath5 is connected to a new terminal node @xmath28 , i.e. , @xmath5 becomes the inbound edge of @xmath28 .",
    "figure  [ fig03](c ) shows the result of adding a suffix @xmath29 = actg$ into the suffix tree in figure  [ fig03](a ) .",
    "the label of the outbound edge of @xmath13 partially matches the prefix @xmath30 = a of @xmath29 . in this case",
    ", our algorithm cuts the outbound edge of @xmath13 and adds a new internal node @xmath31 ; the inbound edge of @xmath31 has the label @xmath30 = a. a new outbound edge @xmath5 is added to node @xmath31 and is labeled with @xmath32 = ctg$. the edge @xmath5 is connected to a new terminal node @xmath28 , i.e. , @xmath5 becomes the inbound edge of @xmath28 .",
    "[ cols=\"^,^,^ \" , ]     figure  [ fig05 ] shows the data structure of our algorithm . as shown in the figure , the information on a node and its inbound edge is contained together in a single data structure .",
    "the fields @xmath33 and @xmath34 represent the start and end positions of the inbound edge in the human genome sequence as shown in figure  [ fig01](b ) . the field _",
    "right _ contains the pointer to the next sibling node , and _ foo _ represents either ( 1 )  a pointer to the leftmost child node in case of an internal node or ( 2 )  the suffix position in the genome sequence in case of a terminal node . the field _ misc _ contains miscellaneous information on the node .",
    "the fields @xmath33 , @xmath34 , _ right _ , and _ foo _ are 4-byte unsigned integers , while the field _",
    "misc _ is a 2-byte unsigned integer .",
    "hence , the data structure has the fixed length of 18 bytes . for distinguishing between the internal and terminal nodes ,",
    "the field @xmath34 is investigated .",
    "if @xmath35 , where @xmath1 is the length of genome sequence , it is a terminal node ; if @xmath36 , it is an internal node ( refer to figure  [ fig01](b ) ) .",
    "we can efficiently construct the suffix trees using the data structure in figure  [ fig05 ] .",
    "we explain this using figure  [ fig06 ] , which shows the representation of suffix trees in figure  [ fig04 ] using the data structure ; figures  [ fig06](a ) @xmath3 [ fig06](c ) correspond to figures  [ fig04](a ) @xmath3 [ fig04](c ) , respectively . in figure  [ fig06](a ) , the fields @xmath37 and @xmath38 represent the start and end positions of labels @xmath39 and @xmath40 , respectively . the fields with @xmath0 stand for `` do nt care '' fields , which are not used nor updated here .",
    "the arrow indicates a pointer to a possible distant node .",
    "the nodes @xmath41 and @xmath42 may not be adjacent as shown in the figure , though @xmath42 is easily accessed by following the pointer .",
    "figure  [ fig06](b ) shows the case a new terminal node @xmath43 is added .",
    "the node @xmath42 can be either an internal or a terminal node and is a sibling node of @xmath43 .",
    "in the figure , the leftmost child node of @xmath41 has been changed from @xmath42 to @xmath43 .",
    "this is because we can efficiently add @xmath43 as a new child node of @xmath41 without accessing @xmath42 and all its sibling nodes .",
    "figure  [ fig06](c ) shows the case a new internal node @xmath44 and a new terminal node @xmath43 are added .",
    "the field values of the @xmath42 are copied to the newly allocated node region , and then the field @xmath45 is adjusted ( @xmath46 is not changed ) .",
    "the field values of @xmath44 are set in the region previously used by @xmath42 as shown in the figure .",
    "the node @xmath43 is a sibling node of @xmath42 and is added as the leftmost child node of @xmath44 as in figure  [ fig06](b ) .",
    "the key idea we would like to show in figure  [ fig06 ] is that , when a suffix is added , there is only slight modification in the suffix tree constructed so far ; it can be done only by allocating new memory region(s ) for one or two nodes and then setting a few appropriate field values therein .",
    "this is one of the features providing the efficiency of our algorithm .",
    "+ ( a ) before adding a suffix .",
    "+   + ( b ) the case of adding a terminal node .",
    "+   + ( c ) the case of adding an internal node and a terminal node .",
    "+    our algorithm constructs a suffix tree in a main memory chunk .",
    "allocations of memory regions for new nodes ( and their inbound edges ) are made sequentially in the chunk .",
    "the pointers in figures  [ fig05 ] and [ fig06 ] are relative offset values from the beginning of the chunk .",
    "once the construction of a suffix tree is completed , our algorithm stores the chunk image into disk without any modification .",
    "when the chunk image is reloaded into main memory , the pointers are still valid regardless of where it is reloaded .",
    "since the chunk image is stored in and read from the disk sequentially , there is no performance degradation due to random disk accesses , and thus we have significantly improved performance . when multiple suffix trees are constructed in parallel ,",
    "our algorithm allocates a separate memory chunk for each suffix tree . even in this case , the human genome sequence is loaded only once into the memory region shared by the simultaneous processes of our algorithm .",
    "this parallel processing enables more significant performance improvement .",
    "we now explain how to determine the prefixes for dividing the human genome sequence into partitions .",
    "each suffix in the genome sequence is assigned to a partition according to its prefix ; every suffix in a partition has a common prefix .",
    "given a prefix length @xmath47 , our algorithm creates a partition for each possible prefix of length @xmath47 .",
    "the number of partitions is @xmath48 .",
    "a weakness of this scheme is that it causes data skewness among the partitions  @xcite ; there may be big differences among the sizes of partitions and hence the corresponding suffix trees .",
    "we tackle this weakness as follows . as @xmath47 increases",
    ", the number of suffixes in each partition decreases , and the size of corresponding suffix tree also decreases .",
    "we set @xmath47 to be large enough to make the suffix tree sizes smaller than the size @xmath49 of available main memory .",
    "then , the simultaneous processes of our algorithm choose the partitions so that the estimated sizes of their corresponding suffix trees sum up very close to @xmath49 .",
    "this can be done with simple computations . by fully utilizing main memory in this way",
    ", our algorithm achieves better indexing performance .",
    "the minimum length of prefixes is computed approximately using the following eq .",
    "( [ eq1 ] ) : @xmath50 where @xmath1 is the length of human genome sequence and @xmath51 is a multiplication factor to estimate the suffix tree size .",
    "@xmath49 represents the size of remaining main memory after loading the entire 2-bit coded human genome sequence .",
    "@xmath51 is defined as the maximum of @xmath52 , where @xmath53 is the length of a genome sequence and @xmath54 is the size of the corresponding suffix tree .",
    "we estimate the size of a big suffix tree by test construction of small suffix trees .",
    "the @xmath51 value greatly differs according to suffix tree construction algorithms and is about 30 @xmath3 32 in our algorithm .",
    "in this section , we show the superiority of our algorithm through a series of experiments .",
    "we use the same data sets as those in  @xcite .",
    "the first set is a short genome sequence of 110mbp size obtained from 6643 organisms .",
    "the second set is the entire human genome sequence of about 3gbp size .",
    "these data sets are denoted as vdb and hg18 , respectively .",
    "the hardware platform is a pc equipped with intel core2quad q9550 2.83ghz cpu , samsung ddr3 8 gb main memory , and a 500 gb 7200rpm hard disk .",
    "the software platforms are ubuntu 10.10 32bit linux and windows 7 64bit edition .",
    "the first experiment was performed on ubuntu as in  @xcite , and the second and third experiments were performed on windows 7 .",
    "the latter two experiments were also performed on ubuntu , though we had 10 @xmath3 15% better performance on windows 7 . as c / c++ compilers , we used gnu c++ 4.4.5 on ubuntu and visual c++ 2010 express edition on windows 7 .    in the first experiment , we compared the performance of our algorithm with digest  @xcite , which had been the fastest disk - based suffix tree construction algorithm .",
    "we downloaded the source code of digest from the author s web site . in this experiment",
    ", we ran our algorithm and digest on vdb data set and compared their elapsed time for constructing the suffix trees .",
    "figure  [ exp1 ] shows the result of experiment ; our algorithm outperformed digest by up to 3.5 times .",
    "we executed only one process of our algorithm in this experiment .",
    "if we had executed multiple parallel processes of our algorithm , we could have achieved higher performance improvement .        in the second experiment",
    ", we ran our algorithm on both vdb and hg18 data sets and compared the elapsed time for various numbers of parallel processes of our algorithm .",
    "figure  [ exp2 ] shows the experimental result .",
    "since the hardware platform has a four - core cpu , we increased the number of parallel processes up to four .",
    "actually , we could have almost no performance improvement by running more than four parallel processes on the same platform .",
    "note that the units of vertical axes are seconds and minutes in figures  [ exp2](a ) and [ exp2](b ) , respectively . as shown in the figures , we obtained performance improvement by up to 3.0 times by running four parallel processes compared with a single process . we could not obtain four times performance improvement mostly due to inter - process communication and synchronization .",
    "since our algorithm is designed to minimize the effect of disk accesses , it has high potential of more performance improvement by using the advanced cpus with more cores and faster clock speeds .      in the third experiment , we measured the elapsed time of our algorithm for various sizes of genome sequences .",
    "we ran four processes on the genome sequences consisting of the first 2 , 5 , 8 , 11 , 15 , and 24 chromosomes in the human genome sequence .",
    "figure  [ exp3 ] shows the result . as the result of regression analysis on the experimental result",
    ", we could find that the elapsed time is almost linearly correlated with the size of genome sequences .",
    "00 = 0.0 in = 0.0ex s. altschul , t. madden , a. schaffer , j. zhang , w. miller , and d. lipman , `` gapped blast and psi - blast : a new generation of protein database search programs , '' _ nucleic acids research _ ,",
    "vol 25 , no .",
    "3389 - 3402 , 1997",
    ". m. atkinson and m. jordan , `` providing orthogonal persistence for java , '' in _ proc .",
    "european conf . on object - oriented programming ( ecoop )",
    "_ , brussels , belgium , pp .",
    "383 - 395 , july 1998 .",
    "m. barsky , u. stege , a. thomo , and c. upton , `` a new method for indexing genomes using on - disk suffix trees , '' in _ proc .",
    "acm conference on information and knowledge management ( cikm ) _ , napa valley , california , pp .",
    "649 - 658 , oct . 2008 .",
    "s. j. bedathur and j. r. haritsa , `` engineering a fast online persistent suffix tree construction , '' in _ proc .",
    "intl conf . on data engineering ( icde )",
    "_ , ieee , boston , massachusetts , pp . 720 - 731 , mar .",
    "cheung , j. yu , and h. lu , `` constructing suffix tree for gigabyte sequences with megabyte memory , '' _ ieee transactions on knowledge and data engineering ( tkde ) _ , vol .",
    "90 - 105 , jan . 2005 .",
    "r. giegerich , s. kurtz , and j. stoye . `` efficient implementation of lazy suffix trees , '' _ software : practice and experience ( spe ) _ , vol .",
    "33 , no , 11 , pp . 1035 - 1049 , 2003 .",
    "a. ghoting and k. makarychev , `` serial and parallel methods for i / o efficient suffix tree construction , '' in _ proc . intl conf .",
    "on management of data _ , acm sigmod , providence , rhode island , pp . 827 - 840 , june 2009 .",
    "d. gusfield , _ algorithms on strings , trees , and sequences _ , cambridge university press , 1997 .",
    "e. hunt , m. p. atkinson , and r. w. irving , `` database indexing for large dna and protein sequence collections , '' _ the vldb journal _ ,",
    "256 - 271 , 2002 .",
    "s. kurtz , `` reducing the space requirement of suffix trees , '' _ software : practice and experience ( spe ) _ , vol .",
    "29 , no . 13 , pp . 1149 - 1171 , nov .",
    "b. phoophakdee and m. j. zaki , `` genome - scale disk - based suffix tree indexing , '' in _ proc .",
    "intl conf . on management of data",
    "_ , acm sigmod , pp .",
    "833 - 844 , beijing , china , june 2007 .",
    "b. phoophakdee and m. j. zaki , `` trellis+ : an effective approach for indexing genome - scale sequences using suffix trees , '' in _ proc .",
    "pacific symp . on biocomputing _",
    ", pp . 90 - 101 , kohala coast , hawaii , jan .",
    "r. sinha , s. puglisi , a. moffat , and a. turpin , `` improving suffix array locality for fast pattern matching on disk , '' in _ proc .",
    "intl conf . on management of data",
    "_ , acm sigmod , vancouver , canada , pp .",
    "661 - 672 , june 2008 .",
    "y. tian , s. tata , r. a. hankins , and j. m. patel , `` practical methods for constructing suffix trees , '' _ the vldb journal _ ,",
    "281 - 299 , 2005 .",
    "e. ukkonen , `` on - line construction of suffix trees , '' _ algorithmica _ , vol .",
    "249 - 260 , sept .",
    "i . won , s .- k .",
    "hong , j .- h .",
    "yoon , s. park , and s .- w .",
    "kim , `` a practical method for approximate subsequence search in dna databases , '' in _ proc .",
    "pacific - asia conf . on advances in knowledge discovery and data mining ( pakdd ) _ , nanjing , china , pp .",
    "921 - 931 , may 2007 ."
  ],
  "abstract_text": [
    "<S> since the release of human genome sequences , one of the most important research issues is about indexing the genome sequences , and the suffix tree is most widely adopted for that purpose . </S>",
    "<S> the traditional suffix tree construction algorithms have severe performance degradation due to the memory bottleneck problem . </S>",
    "<S> the recent disk - based algorithms also have limited performance improvement due to random disk accesses . moreover </S>",
    "<S> , they do not fully utilize the recent cpus with multiple cores . in this paper </S>",
    "<S> , we propose a fast algorithm based on ` divide - and - conquer ' strategy for indexing the human genome sequences . </S>",
    "<S> our algorithm almost eliminates random disk accesses by accessing the disk in the unit of contiguous chunks . </S>",
    "<S> in addition , our algorithm fully utilizes the multi - core cpus by dividing the genome sequences into multiple partitions and then assigning each partition to a different core for parallel processing . </S>",
    "<S> experimental results show that our algorithm outperforms the previous fastest digest algorithm by up to 3.5 times .    </S>",
    "<S> human genome sequences , indexing , suffix tree , memory bottleneck problem , divide - and - conquer , parallel processing </S>"
  ]
}