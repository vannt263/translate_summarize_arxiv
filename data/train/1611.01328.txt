{
  "article_text": [
    "the main aim in proof complexity is to understand the complexity of theorem proving .",
    "arguably , what is even more important is to establish techniques for lower bounds , and the recent history of computational complexity speaks volumes on how difficult it is to develop general lower bound techniques . understanding the size of proofs is important for at least two reasons .",
    "the first is its tight relation to the separation of complexity classes : np vs.  conp for propositional proofs , and np vs. pspace in the case of proof systems for quantified boolean formulas ( qbf ) .",
    "new superpolynomial lower bounds for specific proof systems rule out specific classes of non - deterministic poly - time algorithms for problems in co - np or pspace , thereby providing an orthogonal approach to the predominantly machine - oriented view of computational complexity .",
    "the second reason to study lower bounds for proofs is the analysis of sat and qbf solvers : powerful algorithms that efficiently solve the classically hard problems of sat and qbf for large classes of practically relevant formulas .",
    "modern sat solvers routinely solve industrial instances in even millions of variables for various applications .",
    "even though qbf solving is at a much earlier state , due to its power to express problems more succinctly , qbf even applies to further fields such as formal verification or planning  @xcite .",
    "each successful run of a solver on an unsatisfiable instance can be interpreted as a proof of unsatisfiability ; and many modern sat solvers based on conflict - driven clause learning ( cdcl ) are known to implicitly generate resolution proofs . thereby , understanding the complexity of resolution proofs directly translates into sharp bounds for the performance of cdcl - based sat solvers .",
    "the picture is more complex for qbf solving , as there exist two main , yet conceptually very different paradigms : cdcl - based and expansion - based solving .",
    "a variety of qbf resolution systems have been designed to capture the power of qbf solvers based on these paradigms .",
    "the core system of these is q - resolution ( ) , introduced by kleine bning et al .",
    "this has been augmented to capture ideas from cdcl solving , leading to long - distance resolution ( ) @xcite , universal resolution ( ) @xcite , or its combinations like @xcite .",
    "powerful proof systems for expansion - based solving were developed in the form of @xcite , and the stronger and @xcite .",
    "recent findings show that cdcl and expansion are indeed orthogonal paradigms as the underlying proof systems from the two categories are incomparable with respect to simulations @xcite .",
    "understanding which general techniques can be used to show lower bounds for proof systems is of paramount importance in proof complexity . for propositional proof systems we have a number of very effective techniques , most notably the size - width technique of ben - sasson and wigderson @xcite , deriving size from width bounds , game characterisations",
    "( e.g.  @xcite ) , the approach via proof - complexity generators ( cf .",
    "@xcite ) , and feasible interpolation .",
    "feasible interpolation , first introduced by  @xcite , is a particularly successful paradigm that transfers circuit lower bounds to size of proof lower bounds .",
    "the technique has been shown to be effective for resolution @xcite , cutting planes @xcite and even strong frege systems for modal and intuitionistic logics @xcite .",
    "however , feasible interpolation fails for strong propositional systems as frege systems under plausible cryptographic and number - theoretic assumptions @xcite .",
    "the situation is drastically different for qbf proof systems , where we currently possess a very limited bag of techniques . in particular",
    ", the classical size - width technique of ben - sasson and wigderson @xcite by which most resolution lower bounds are obtained drastically fails in @xcite . at present",
    "we only have the recent strategy extraction technique of beyersdorff et al .",
    "@xcite , which works for as well as for stronger qbf frege systems @xcite , a game characterisation of the very weak tree - like @xcite , and ad - hoc lower bound arguments for various systems @xcite .",
    "in addition , balabanov et al .",
    "@xcite develop methods to lift some previous lower bounds from to stronger systems .",
    "we now proceed to explain the main contributions of the article .",
    "we show that the feasible interpolation technique applies to all resolution - type qbf proof systems , whether expansion or cdcl based .",
    "this provides the first truly general lower bound technique for qbf proof systems , and  at the same time ",
    "hugely extends the scope of the feasible interpolation method .    in a nutshell",
    ", feasible interpolation works for true implications @xmath0 ( or , equivalently , false conjunctions @xmath1 ) , which by craig s interpolation theorem @xcite possess interpolants @xmath2 in the common variables @xmath3 .",
    "such interpolants , even though they exist , may not be of polynomial size @xcite .",
    "however , it may be the case that we can always efficiently extract such interpolants from a proof of the implication in a particular proof system @xmath4 , and in this case , the system @xmath4 is said to admit feasible interpolation . if we know that a particular class of formulas does not admit small interpolants ( either unconditional or under suitable assumptions ) , then there can not exist small proofs of the formulas in the system @xmath4 . here",
    "we show that this feasible interpolation theorem holds for arbitrarily quantified formulas @xmath5 and @xmath6 above , when the common variables @xmath3 are existentially quantified before all other variables .      as our second contribution we exhibit new hard formulas for qbf resolution systems .",
    "of course , exponential lower bounds for these systems follow immediately from the known lower bounds for resolution ( in these systems , refuting a totally quantified false sentence that uses only existential quantifiers degenerates to classical resolution ) . however , we can better understand the power of such systems to handle arbitrary qbfs if we have more examples of false qbfs that use existential and universal quantifiers in non - trivial ways and that are hard to refute in these systems . it is fair to say that we are currently quite short of hard examples : research so far",
    "has mainly concentrated on formulas of kleine bning et al .",
    "@xcite and their modifications @xcite , a principle by janota and marques - silva @xcite , and a class of parity formulas recently introduced by beyersdorff et al .",
    "this again is in sharp contrast with classical proof complexity where a wealth of different combinatorial principles as well as random formulas are known to be hard for resolution .",
    "our new hard formulas are qbf contradictions formalising the easy and appealing fact that a graph can not both have and not have a @xmath7-clique .",
    "the trick is that in our formulation , each interpolant for these formulas has to solve the @xmath7-clique problem . using our interpolation theorem together with the exponential lower bound for the monotone circuit complexity of clique @xcite",
    ", we obtain exponential lower bounds for the clique - no - clique formulas in all cdcl and expansion - based qbf resolution systems .",
    "we remark that conceptually our clique - no - clique formulas are different from and indeed simpler than the clique - colour formulas used for the interpolation technique in classical proof systems .",
    "this is due to the more succinct expressivity of qbf .",
    "indeed it is not clear how the clique - no - clique principle could even be formulated succinctly in propositional logic .      on a conceptual level",
    ", we uncover a tight relationship between feasible interpolation and strategy extraction .",
    "strategy extraction is a very desirable property of qbf proof systems and is known to hold for the main resolution - based systems . from a refutation of a false qbf , a winning strategy for the universal player can be efficiently extracted .    like feasible interpolation , the lower bound technique based on strategy extraction by beyersdorff et al .",
    "@xcite also transfers circuit lower bounds to proof size bounds . however , instead of monotone circuit bounds as in the case of feasible interpolation , the strategy extraction technique imports @xmath8 circuit lower bounds ( or further circuit bounds for circuit classes directly corresponding to the lines in the proof system @xcite )",
    "here we show that each feasible interpolation problem can be transformed into a strategy extraction problem , where the interpolant corresponds to the winning strategy of the universal player on the first universal variable .",
    "this clarifies that indeed feasible interpolation can be viewed as a special case of strategy extraction .",
    "the remaining part of this article is organised as follows . in section",
    "[ sec : prelim ] we review the definitions and relations of relevant qbf proof systems . in section  [ sec : interpolation ] we start by recalling the overall idea for feasible interpolation and show interpolation theorems for the strongest cdcl - based system as well as the strongest expansion - based proof system .",
    "this implies feasible interpolation for all qbf resolution - based systems .",
    "further we show that all these systems even admit monotone feasible interpolation . in section  [ sec : lower - bounds ] we obtain the new lower bounds for the clique - no - clique formulas .",
    "section  [ sec : strat - extraction ] reformulates interpolation as a strategy extraction problem .",
    "a literal is a boolean variable or its negation .",
    "we say a literal @xmath9 is complementary to the literal @xmath10 and vice versa .",
    "a _ clause _ is a disjunction of literals and a _ term _ is a conjunction of literals .",
    "the empty clause is denoted by  @xmath11 , and is semantically equivalent to false .",
    "a formula in _ conjunctive normal form _ ( cnf ) is a conjunction of clauses . for a literal @xmath12 or @xmath13",
    ", we write @xmath14 for  @xmath9 and extend this notation to @xmath15 for a clause @xmath16 .",
    "let @xmath17 be any partial assignment .",
    "for a clause @xmath16 , we write @xmath18 for the clause obtained after applying the partial assignment @xmath17 to @xmath16",
    ".    quantified boolean formulas ( qbfs ) extend propositional logic with boolean quantifiers with the standard semantics that @xmath19 is satisfied by the same truth assignments as @xmath20 and @xmath21 as @xmath22 .",
    "we assume that qbfs are in _ closed prenex form _ with a cnf matrix , i.e , we consider the form @xmath23 , where @xmath24 , @xmath25 , and @xmath26 are pairwise disjoint sets of variables .",
    "the formula @xmath27 is in cnf and is defined only on variables @xmath28 .",
    "the propositional part @xmath27 is called the _ matrix _ and the rest the",
    "if @xmath29 , we say that @xmath9 is at _ level _",
    "@xmath30 and write @xmath31 ; we write @xmath32 for @xmath33 .",
    "the _ index _",
    "@xmath34 provides the more detailed information on the actual position of @xmath9 in the prefix , i.e.  all variables are indexed by @xmath35 from left to right .",
    "often it is useful to think of a qbf as a _ game _ between the _ universal _ and the _ existential player_. in the @xmath30-th step of the game ,",
    "the player  @xmath36 assigns values to all the variables  @xmath26 .",
    "the existential player wins the game iff the matrix  @xmath27 evaluates to @xmath37 under the assignment constructed in the game .",
    "the universal player wins iff the matrix  @xmath27 evaluates to @xmath38 . given a universal variable  @xmath39 with index  @xmath30 , a _ strategy for @xmath39 _ is a function from all variables of index @xmath40 to @xmath41 .",
    "a qbf is false iff there exists a _ winning strategy _ for the universal player ,",
    "i.e.  if the universal player has a strategy for all universal variables that wins any possible game , irrespective of the strategy used by the existential player  ( @xcite , ( * ? ? ?",
    "* sec.4.2.2 ) , ( * ? ? ?",
    "* chap.19 ) ) .",
    "* resolution - based calculi for qbf . * we now give a brief overview of the main existing resolution - based calculi for qbf .",
    "for the technical proofs in this paper , full details are needed only for two systems ,  and , both of which are included in the overview .",
    "we start by describing the proof systems modelling _ cdcl - based qbf solving _ ; their rules are summarized in figure  [ fig : allrules ] .",
    "the most basic and important system is _ q - resolution ( ) _ by kleine bning et al.@xcite .",
    "it is a resolution - like calculus that operates on qbfs in prenex form with cnf matrix .",
    "the lines in a proof are clauses .",
    "in addition to the axioms , comprises the resolution rule s@xmath42r and universal reduction @xmath43-red ( cf .  figure  [ fig : allrules ] ) .",
    "_ long - distance resolution ( ) _ appears originally in the work of zhang and malik @xcite and was formalized into a calculus by balabanov and jiang @xcite .",
    "it merges complementary literals of a universal variable  @xmath39 into the special literal  @xmath44 . uses the rules l@xmath42r , @xmath43-red and @xmath43-red@xmath45 ( cf .",
    "figure  [ fig : allrules ] ) .    _ qu - resolution ( ) _ by van gelder @xcite",
    "removes the restriction from that the resolved variable must be an existential variable and allows resolution of universal variables .",
    "the rules of are s@xmath42r , s@xmath43r and @xmath43-red . _ _ by balabanov et al .",
    "@xcite extends by allowing short and long distance resolution pivots to be universal ; however , the pivot is never a merged literal @xmath46 . uses the rules l@xmath42r , l@xmath43r , @xmath43-red and @xmath43-red@xmath45 .",
    "the second type of calculi models _ expansion - based qbf solving_. these calculi are based on _ instantiation _ of universal variables : by janota and marques - silva @xcite , , and by beyersdorff et al .",
    "all these calculi operate on clauses that comprise only existential variables from the original qbf , which are additionally _ annotated _ by a substitution to some universal variables , e.g.  @xmath47 . for any annotated literal @xmath48 , the substitution @xmath49 must not make assignments to variables at a higher quantification level than @xmath50 , i.e.  if @xmath51 , then @xmath39 is universal and @xmath52 . to preserve this invariant",
    ", we use the _ auxiliary notation @xmath53}$ ] _ , which for an existential literal @xmath50 and an assignment @xmath49 to the universal variables filters out all assignments that are not permitted , i.e.  @xmath53}=l^{\\comprehension{c / u\\in\\sigma}{\\lev(u)<\\lev(l)}}$ ]",
    ".    as annotations can be partial assignments , we use auxiliary operations of _ completion _ and _",
    "instantiation_. for assignments @xmath54 and @xmath55 , we write @xmath56 for the assignment @xmath49 defined as follows : @xmath57 if @xmath58 , otherwise @xmath59 if @xmath60 .",
    "the operation @xmath56 is called _ completion _ because @xmath55 provides values for variables not defined in @xmath54 .",
    "the operation is associative and therefore we can omit parentheses .",
    "for an assignment @xmath54 and an annotated clause @xmath16 , the function @xmath61 returns the annotated clause @xmath62}}{l^\\sigma\\in c}$ ] .",
    "the system is defined in figure  [ fig : irc ] .",
    "the calculus further extends by enabling annotations containing @xmath63",
    ". the rules of the calculus are presented in figure  [ fig : irmc ] . the symbol @xmath63",
    "may be introduced by the merge rule , e.g.  by collapsing @xmath64 into @xmath65 .",
    "the simulation order of qbf resolution systems is shown in figure  [ fig : sim - structure ] .",
    "all proof systems have been exponentially separated ( cf .",
    "@xcite ) .",
    "[ def : preceq ] for clauses @xmath66 we write @xmath67 if for any literal @xmath68 we have @xmath69 or @xmath70 and for any @xmath71 we have @xmath70 .    for annotations @xmath54 and @xmath49",
    "we say that @xmath72 if @xmath73 and for any @xmath74 we have @xmath75 or @xmath76 and for any @xmath77 we have @xmath76 . if @xmath66 are annotated clauses , we write @xmath67 if there is an injective function @xmath78 such that for all @xmath79 we have @xmath80 with @xmath72 .",
    "in this section we show that feasible interpolation and feasible monotone interpolation hold for and .",
    "we adapt the technique first used by @xcite to re - prove and generalise the result of @xcite .",
    "consider a false qbf sentence @xmath81 of the form @xmath82,\\ ] ] where , @xmath3 , @xmath83 , and @xmath84 are mutually disjoint sets of propositional variables , @xmath85 is a cnf formula on variables @xmath3 and @xmath83 , and @xmath86 is a cnf formula on variables @xmath3 and @xmath84 .",
    "thus @xmath3 are the common variables between them .",
    "the @xmath83 and @xmath84 variables can be quantified arbitrarily , with any number of quantification levels .",
    "the sentence is equivalent to the following , not in prenex form @xmath87.\\ ] ]    let @xmath81 be a false qbf of the form @xmath88 $ ] .",
    "interpolation circuit _ for @xmath81 is a boolean circuit @xmath89 such that on every @xmath90 assignment @xmath91 for @xmath3 we have @xmath92 we say that a qbf proof system @xmath93 has _ feasible interpolation _ if for any @xmath93-proof @xmath94 of a qbf @xmath81 of the form above , we can extract from @xmath94 an interpolation circuit for @xmath81 of size polynomial in the size of @xmath94 .",
    "we say that @xmath93 has _",
    "monotone feasible interpolation _ if the following holds : in the same setting as above , if @xmath3 appears only positively in @xmath85 , then we can extract from @xmath94 a monotone interpolation circuit for @xmath81 .    as our main results , we show that both and have monotone feasible interpolation .    before proving the interpolation theorems , we first outline the general idea :      fix a proof system @xmath95 , @xmath96 and an @xmath93-proof @xmath94 of @xmath81 .",
    "consider the following definition of a @xmath83-clause and an @xmath84-clause .",
    "we call a clause @xmath16 in @xmath94 a @xmath83-clause ( resp",
    ".  @xmath84-clause ) , if @xmath16 contains only variables @xmath97 ( resp .",
    "@xmath98 ) .",
    "we also call @xmath16 a @xmath83-clause ( resp",
    ".  @xmath84-clause ) , if @xmath16 contains only @xmath3 variables , but all its descendant clauses in the proof @xmath94 ( all clauses with a directed path to @xmath16 in @xmath94 ) are @xmath83 ( resp .  @xmath84)-clauses . in the case of the annotations are not considered and can be from either set .    from @xmath94",
    "we construct a circuit @xmath99 with the @xmath3-variables as inputs : for each node @xmath39 with clause @xmath100 in the proof @xmath94 , associate a gate @xmath101 ( or a constant - size circuit ) in the circuit @xmath99 .",
    "next , we inductively construct , for any assignment @xmath91 to the @xmath3 variables , another proof - like structure @xmath102 . for each node @xmath39 with clause @xmath100 in the proof @xmath94 ,",
    "associate a clause @xmath103 in the structure @xmath102 .",
    "finally , we obtain @xmath104 from the structure @xmath102 by instantiating @xmath3 variables to the assignment @xmath91 ( that is , @xmath105 for each node @xmath39 ) and doing some pruning , and show that @xmath104 is a valid proof in @xmath93 .",
    "we then find that if @xmath106 , then @xmath104 uses only @xmath83-clauses and thus is a refutation of @xmath107 , and if @xmath108 , then @xmath104 uses only @xmath84-clauses and thus is a refutation of @xmath109 .",
    "thus @xmath99 is the desired interpolant circuit .",
    "more precisely , we show by induction on the height of @xmath39 in @xmath94 ( that is , the length of the longest path to @xmath39 from a source node in @xmath94 ) that :    1 .   @xmath110 .",
    "@xmath111 is a @xmath83-clause and can be obtained from the clauses of @xmath112 alone using the rules of @xmath93 .",
    "@xmath113 is an @xmath84-clause and can be obtained from the clauses of @xmath114 alone using the rules of @xmath93 .    from the above",
    ", we have the following conclusion .",
    "let @xmath115 be the root of @xmath94 . then on any assignment @xmath91 to the @xmath3 variables we have :    ( 1 ) : :    @xmath116 , so    @xmath117 .",
    "therefore ,    @xmath118 .",
    "( 2 ) : :    @xmath119 is a    @xmath83-clause and can be obtained from the clauses of    @xmath112 alone using the rules of system    @xmath93 .",
    "hence by soundness of @xmath93 ,    @xmath120 is false . ( 3 ) : :    @xmath121 is an    @xmath84-clause and can be obtained from the clauses of    @xmath114 alone using the rules of system    @xmath93 .",
    "hence by soundness of @xmath93 ,    @xmath122 is false .",
    "thus @xmath123 , the output gate of the circuit , computes an interpolant .",
    "when @xmath81 has only existential quantification , @xmath94 is a classical resolution proof , and this is exactly the interpolant computed by s method @xcite .",
    "the challenge here is to construct @xmath124 and @xmath125 appropriately when the stronger proof systems are used for general qbf , while maintaining the inductive invariants .",
    "we now implement the idea described above for .",
    "[ thm : lqup ] has feasible interpolation .",
    "as mentioned in the proof idea , for an proof @xmath94 of @xmath81 we first describe the circuit @xmath126 with input @xmath3 .    * construction of the circuit @xmath126 : * the dag underlying the circuit is exactly the same as the dag underlying the proof @xmath94 . for each node @xmath39 with clause @xmath100 in @xmath94",
    "we associate a gate @xmath101 as follows :    @xmath39 is a leaf node : : :    if @xmath127 then @xmath101 is    a constant @xmath38 gate . if    @xmath128 then @xmath101 is a    constant @xmath37 gate .",
    "* @xmath39 is an internal node : * we distinguish four cases .    1 .",
    "@xmath39 was derived by a universal reduction step . in this case",
    "put a no - operation gate for @xmath101 .",
    "2 .   @xmath39 corresponds to a resolution step with an existential variable @xmath129 as pivot .",
    "nodes @xmath130 and @xmath131 are its two children , i.e. @xmath132 in this case , put a selector gate @xmath133 for @xmath101 . here , @xmath134 , when @xmath135 and @xmath136 , when @xmath137 .",
    "that is , @xmath138 .",
    "note that all the variables in @xmath3 are existential variables without annotations .",
    "3 .   @xmath39 corresponds to a resolution step with an existential or universal variable @xmath139 as pivot .",
    "put an or gate for @xmath101 .",
    "4 .   @xmath39 corresponds to a resolution step with an existential or universal variable @xmath140 as pivot .",
    "put an and gate for @xmath101 .",
    "this completes the description of the circuit @xmath126 .    * construction of @xmath124 and @xmath125 : * following our proof idea",
    ", we now construct a proof - like structure @xmath102 , which depends on the assignment @xmath91 to the @xmath3 variables , the proof @xmath94 of @xmath81 , and the circuit @xmath126 .",
    "for each node @xmath39 in @xmath94 with clause @xmath100 , we associate a clause @xmath141 in @xmath102 .    from the structure @xmath102",
    ", we get another structure @xmath104 by instantiating @xmath3 variables by the assignment @xmath91 in each clause of @xmath102 , cutting away any edge out of a node where the clause evaluates to @xmath37 , and deleting nodes which now have no path to the root node .",
    "that is , for each survived node @xmath39 in @xmath104 , the associated clause @xmath142 is equal to @xmath143 .",
    "we show ( by induction on the height of @xmath39 in @xmath94 ) that :    1 .",
    "2 .   @xmath111 is a @xmath83-clause and can be obtained from the clauses of @xmath112 alone using the rules of system .",
    "3 .   @xmath113 is a @xmath84-clause and can be obtained from the clauses of @xmath114 alone using the rules of system .",
    "as described in the proof outline , this suffices to conclude that @xmath99 computes an interpolant .",
    "we now present the construction details .",
    "* at leaf level : * let node @xmath39 be a leaf in @xmath94 .",
    "then @xmath144 ; that is , we copy the clause as it is .",
    "trivially , we have @xmath110 . by construction of @xmath99 ,",
    "the conditions concerning @xmath145 and @xmath142 are satisfied .    at an internal node",
    "we distinguish four cases based on the rule that was applied .",
    "* at an internal node with universal reduction : * let node @xmath39 be an internal node in @xmath94 corresponding to a universal reduction step on some universal variable @xmath9 or @xmath146 .",
    "let node @xmath130 be its only child .",
    "here we consider only the case where the universal literal is @xmath9 .",
    "the case of @xmath146 is identical .",
    "we have @xmath147    in this case , define @xmath148 . by induction , @xmath149 . therefore , @xmath150 .",
    "if @xmath151 , then we know that @xmath152 as @xmath153 . by the induction hypothesis , we know that @xmath154 is a @xmath83-clause and can be derived using @xmath155 alone via .",
    "recall that @xmath156 in this case . since @xmath91 is an assignment to the @xmath3 variables and @xmath157",
    ", @xmath158 is a @xmath83-clause and can be derived using @xmath155 alone via .",
    "( either @xmath142 already equals @xmath159 , or @xmath9 needs to be dropped . in the latter case , the condition on @xmath160 is satisfied at @xmath142 because it is satisfied at @xmath161 in @xmath94 and @xmath162 .",
    "so we can drop @xmath9 from @xmath159 to get @xmath142 . )",
    "the situation is dual for the case when @xmath163 ; we get @xmath84-clauses .",
    "* at an internal node with @xmath3-resolution : * let node @xmath39 in the proof @xmath94 correspond to a resolution step with pivot @xmath129 .",
    "note that @xmath9 is existential , as @xmath3 variables occur only existentially in @xmath81 .",
    "we have @xmath164 in the assignment @xmath91 , if @xmath135 , then define @xmath165 and if @xmath166 then define @xmath167 . by induction , we have @xmath168 and @xmath169 .",
    "so , if @xmath135 , we have @xmath170 .",
    "if @xmath166 , we have @xmath171 . in this case",
    "@xmath101 is a selector gate . if @xmath135 in the assignment @xmath91 , then @xmath153 and @xmath172 .",
    "since the conditions concerning @xmath173 and @xmath159 are satisfied by induction , the conditions concerning @xmath145 and @xmath142 are satisfied as well . similarly , if @xmath174 , then @xmath175 and @xmath176 , and the statements that are inductively true at @xmath131 hold at @xmath39 as well .    * at an internal node with @xmath83-resolution : * let node @xmath39 in the proof @xmath94 correspond to a resolution step with pivot @xmath139 . note that @xmath9 may be existential or universal .",
    "we have @xmath177 in this case , we use the value of gate @xmath101 in circuit @xmath126 on input @xmath91 .    if @xmath178 then define @xmath179 . by induction",
    ", we know that @xmath180 is an @xmath84-clause . since @xmath9 is a @xmath83-variable and is not instantiated by @xmath91 , it must be the case that @xmath181 .",
    "thus @xmath182 .    else",
    "if @xmath183 , define @xmath184 . by a similar analysis as above , @xmath185 .",
    "if @xmath186 , and if @xmath187 , define @xmath179 . otherwise , if @xmath188 , define @xmath189 .",
    "it follows from induction that @xmath190 .",
    "else , define @xmath141 to be the resolvent of @xmath191 and @xmath192 on @xmath9 . by induction ,",
    "we know that @xmath193 and @xmath194 . hence @xmath195 .",
    "we need to verify the conditions on @xmath145 and @xmath142 .",
    "the case when @xmath196 is immediate , since @xmath142 copies a clause known by induction to be an @xmath84-clause .",
    "so now consider the case when @xmath197 . by induction ,",
    "we know that both @xmath198 and @xmath199 are @xmath83-clauses and can be derived using @xmath155 alone via .",
    "we have three cases . if @xmath179 or @xmath184 , then by induction we are done .",
    "otherwise , @xmath141 is obtained from @xmath191 and @xmath192 via a resolution step on pivot @xmath9 .",
    "since @xmath91 is an assignment to the @xmath3 variables and @xmath200 , @xmath142 can be derived from @xmath159 and @xmath201 via the same ( ld)-resolution step .",
    "* note : * a simple observation is that @xmath141 is always a subset of @xmath100 with only one exception , which is that some special symbol @xmath44 in @xmath100 may be converted into @xmath39 in @xmath141 .",
    "this leads us to define the relation @xmath202 .",
    "also , the resolution step in @xmath104 is applicable in because ( 1 )  every mergable universal variable in @xmath159 and @xmath203 was also mergable earlier in @xmath161 and @xmath204 in @xmath94 .",
    "( 2 )  every common non - mergable existential variable in @xmath159 and @xmath201 was also a non - mergable existential variable in @xmath161 and @xmath204 .",
    "( 3 )  every non - mergable universal variable in @xmath159 and @xmath201 was also a non - mergable universal pair in @xmath161 and @xmath204 .",
    "( 4 )  the operations do not disturb the levels of variables , therefore if variable @xmath9 satisfies the level condition in @xmath94 it satisfies it in @xmath104 as well .",
    "* at an internal node with @xmath84-resolution : * let node @xmath39 in @xmath94 correspond to a resolution step with pivot @xmath140 .",
    "this is dual to the case above .",
    "we now establish the interpolation theorem for the expansion - based calculi , following the same overall idea described in section  [ subsec : interpolation - setting ] .",
    "[ thm : irm ] has feasible interpolation .",
    "this proof closely follows that of theorem  [ thm : lqup ] , but with several changes in the proof details .",
    "we describe the changes here .",
    "* construction of the circuit @xmath126 : * the circuit construction is very similar to that for .",
    "leaves and resolution nodes are treated as before .",
    "instantiation and merging nodes are treated as the universal reduction nodes were ; that is , the corresponding gates are no - operation gates .    * construction of @xmath124 and @xmath125 : * as before we construct a proof - like structure @xmath102 , which depends on the assignment @xmath91 to the @xmath3 variables , the proof @xmath94 of @xmath81 , and the circuit @xmath126 . for each node @xmath39 in @xmath94 , with clause @xmath100 , we associate a clause @xmath141 in @xmath102 , and let @xmath142 be the instantiation of @xmath141 by the assignment @xmath91 .",
    "we show ( by induction on the height of @xmath39 in @xmath94 ) that :    1 .",
    "2 .   @xmath111 is a @xmath83-clause and can be obtained from the clauses of @xmath112 alone using the rules of system .",
    "@xmath113 is a @xmath84-clause and can be obtained from the clauses of @xmath114 alone using the rules of system .",
    "once again , as described in the proof outline , this suffices to conclude that the circuit @xmath99 computes an interpolant .",
    "recall that for annotated clauses , the meaning of @xmath202 is slightly different and is given in definition  [ def : preceq ] .",
    "* at a leaf level : * let node @xmath39 be a leaf in @xmath94 .",
    "then @xmath144 ; that is , copy the clause as it is .",
    "trivially , @xmath110 .",
    "the gates give the correct values by definition .",
    "* at an internal node with instantiation : * let node @xmath39 be an internal node in @xmath94 corresponding to an instantiation step by @xmath54 . and let node @xmath130 be its only child .",
    "we know @xmath205 .",
    "suppose @xmath206 .",
    "then for some @xmath207 , @xmath208 , and @xmath209}$ ] ; hence @xmath210 is a subset of @xmath207 completed with @xmath54 . by induction",
    "we know that @xmath211 .",
    "we have an injective function @xmath212 that demonstrates this .",
    "let @xmath213 .",
    "hence @xmath214 for some @xmath215 .",
    "so @xmath216}\\in c_u$ ] .",
    "since the annotations introduced by instantiation match , @xmath217 .",
    "we use this to define a function @xmath218 where @xmath219 .",
    "now we find any @xmath220 where @xmath221 and perform a merging step on @xmath222 and @xmath223 ; note that the resulting literal @xmath224 will still satisfy @xmath225 .",
    "eventually we get a clause which we define as @xmath226 where this function is injective .",
    "we will use this notation to refer to this process of instantiation and then deliberate merging to get @xmath227 .",
    "therefore @xmath228 .",
    "if the node @xmath39 is not pruned out in @xmath104 , then @xmath142 contains no satisfied @xmath3 literals ; hence neither does @xmath191 .",
    "therefore @xmath142 is derived from @xmath159 ; this is a valid step in the proof system .    because we only use instantiation and merging or a dummy step ,",
    "@xmath142 is a @xmath83-clause if and only if @xmath159 is a @xmath83-clause .",
    "therefore the no - operation gate @xmath101 gives a valid result by induction .",
    "* at an internal node with merging : * let node @xmath39 be an internal node in @xmath94 corresponding to a merging step .",
    "let node @xmath130 be its only child .",
    "we have @xmath229 where @xmath230 and @xmath231 is obtained by merging the annotations @xmath232 .",
    "that is , @xmath233 .",
    "note that @xmath234 .",
    "note that from the induction hypothesis , @xmath235 , so there is an injective function @xmath236 .",
    "suppose @xmath237 contains two distinct literals @xmath238 and @xmath239 where @xmath240 and @xmath241 .",
    "so @xmath242 .",
    "then let @xmath243 , where @xmath244 .",
    "otherwise let @xmath245 .",
    "we first observe whenever we do actual merging , if @xmath246 then one of the following holds :    1 .",
    ". then @xmath248 or @xmath76 , and so @xmath249 or @xmath250 .",
    "2 .   @xmath251",
    ". then @xmath252 or @xmath253 , and so @xmath254 or @xmath250 .",
    "3 .   @xmath255 , @xmath256 , @xmath257 , in which case @xmath250 .    since all other annotated literals are unaffected , @xmath228 .",
    "we never merge @xmath3 literals as they have no annotations , so if @xmath142 is not pruned away , then @xmath142 is derived from @xmath159 via merging .    in case",
    "we do not merge , there might be some @xmath258 with @xmath259 , which is not removed by merging .",
    "however @xmath260 , so @xmath261 . as @xmath262 , this is a valid inference step ( in fact , a dummy step ) .    because we only use merging or a dummy step ,",
    "@xmath142 is a @xmath83-clause if and only if @xmath159 is a @xmath83-clause , therefore the no - operation gate @xmath101 gives a valid result by induction .",
    "* at an internal node with @xmath3-resolution : * we do not have any annotations on @xmath3-literals .",
    "so in this case we construct @xmath263 and @xmath264 exactly as we would for an proof .",
    "* at an internal node with @xmath83-resolution : * when we have a resolution step between nodes @xmath130 and @xmath131 on a @xmath83 pivot to get node @xmath39 , we have @xmath265 where @xmath266 , @xmath267 and @xmath268 are mutually disjoint , and @xmath269 .",
    "in order to do dummy instantiations we will need to define a @xmath41 version of @xmath231 and @xmath49 .",
    "so we define @xmath270 , @xmath271 .",
    "this gives us the desirable property that @xmath215 , @xmath259 .    now resuming the construction of @xmath272",
    ", we use information from the circuit to construct this .",
    "if @xmath273 , then we define @xmath274 . otherwise , if @xmath275 , then we define @xmath276 . in these cases , we know by the inductive claim that @xmath141 does not contain any @xmath83 literals . therefore @xmath141 is the correct instantiation ( as @xmath215 , @xmath259 ) of some subset of @xmath277 or @xmath278 . hence @xmath228 .",
    "furthermore since @xmath101 is an or gate evaluating to 1 and since @xmath279 , an @xmath84-clause , can be obtained by an instantiation step , our inductive claim is true .",
    "now suppose @xmath280 and @xmath281 . if there is no @xmath282 such that @xmath283 , then define @xmath284 .",
    "else , if there is no @xmath285 such that @xmath286 , then define @xmath287 . in these cases",
    "we know that @xmath103 is the correct instantiation ( as @xmath215 , @xmath259 ) of some subset of @xmath277 or @xmath278 ; hence @xmath228 . furthermore ,",
    "since @xmath101 is an or gate evaluating to 0 , and since @xmath142 , a @xmath83-clause , can be obtained by an instantiation step , our inductive claim is true .",
    "the final case is when @xmath288 and @xmath289 for some @xmath290 and @xmath291 for some @xmath292 . here ,",
    "because @xmath266 , @xmath267 and @xmath268 are mutually disjoint , @xmath266 , @xmath293 and @xmath294 are also mutually disjoint .",
    "thus we can do the resolution step    @xmath295    since @xmath296 and @xmath297 , we can follow up @xmath298 with sufficient merging steps to get a clause @xmath299 ; we define this clause to be the clause @xmath141 . by the inductive claim , both @xmath159 and @xmath201 are @xmath83-clauses ; hence @xmath142 is also a @xmath83-clause and is obtained via a valid resolution step .",
    "* at an internal node with @xmath84-resolution : * when we have a resolution step between nodes @xmath39 and @xmath130 on an @xmath84-literal , this is the dual of the previous case .",
    "let @xmath91 be any assignment to the @xmath3 variables .",
    "following our proof idea , we now show the following :    [ lemma1 ] @xmath300 is a @xmath83-clause and can be obtained from the clauses of @xmath112 alone using the rules of system .",
    "we prove this by the induction on the height of @xmath39 in @xmath94 .",
    "suppose the leaves are at height @xmath38 .",
    "+ * base case : * node @xmath39 is a leaf node . if @xmath301 then by construction of the circuit we know that @xmath302 .",
    "hence @xmath303 . +",
    "* induction step : *    1 .",
    ": :    let node @xmath39 in @xmath94 corresponds to a    universal reduction step on some universal variable @xmath9 or    @xmath146 . and node @xmath130 be its only child . here",
    "we    see only for the case when universal variable is @xmath9 .",
    "the    case for @xmath146 is identical .",
    "we have ,    @xmath304    +    if @xmath301 , then we know that    @xmath305 as    @xmath306 . by induction",
    "hypothesis , we know that    @xmath307 is a    @xmath83-clause and can be derived using    @xmath155 alone via .",
    "recall that    @xmath308    in this case .",
    "since @xmath91 is an assignment to the    @xmath3 variables and @xmath157 , we    have @xmath309 is a    @xmath83-clause and can be derived using    @xmath155 alone via . 2 .",
    ": :    let node @xmath39 in the proof @xmath94 corresponds to    a resolution step with the pivot @xmath129 .",
    "note    that @xmath9 is existential , as @xmath3    variables occur existential in @xmath81 .",
    "we have ,    @xmath310    +    in this case @xmath101 is a selector gate . if    @xmath135 in the assignment @xmath91 , then    @xmath306 . hence if    @xmath311 then    @xmath312 . by induction",
    ", we know that    @xmath313 is a    @xmath83-clause and can be derived using    @xmath155 alone via .",
    "recall that in this case    @xmath314 .",
    "therefore    @xmath309 is a    @xmath83-clause and can be derived using    @xmath155 alone via .",
    "3 . : :    let node @xmath39 in the proof @xmath94 corresponds to    an ( ld)-resolution step with the pivot @xmath139 .",
    "@xmath9 may be existential or universal .",
    "we have in    @xmath94 ,    @xmath315    +    by construction of @xmath126 , we know that    @xmath101 is an @xmath316 gate . if    @xmath197 then both @xmath173    and @xmath317 must evaluate to @xmath38 . by    induction , we know that both    @xmath307 ,    @xmath318 are    @xmath83-clauses and can be derived using    @xmath155 alone via .",
    "+    we have three cases .",
    "if    @xmath314 or    @xmath319 , by induction    @xmath320 is a @xmath83-clauses and    can be derived using @xmath155 alone via .",
    "otherwise , @xmath321 is obtained from    @xmath237 and @xmath322 via an    ( ld)-resolution step on pivot @xmath9 .",
    "since    @xmath91 is an assignment to the @xmath3    variables and @xmath157 ,    @xmath320 can be derived from    @xmath323 and @xmath324 via    the same ( ld)-resolution step .",
    "4 . : :    let node @xmath39 in the proof @xmath94 corresponds to    a resolution step with the pivot @xmath140 .",
    "this is    just a dual of the above step .",
    "the proof of the claim @xmath325 of the proof idea is similar to the proof of lemma [ lemma1 ] .      to transfer known circuit lower bounds into size of proof bounds ,",
    "we need a monotone version of the previous interpolation theorems , which we prove next .",
    "[ theorem2 ] and have monotone feasible interpolation .    in previous subsections , we have shown that the circuit @xmath326 is a correct interpolant for the qbf sentence @xmath81 .",
    "that is , if @xmath327 then @xmath107 is false , and if @xmath328 then @xmath109 is false .",
    "however , if @xmath3 occurs only positively in @xmath85 then we construct a monotone circuit @xmath329 such that , on every @xmath90 assignment @xmath91 to @xmath3 we have @xmath330    we obtain @xmath329 from @xmath326 by replacing all selector gates @xmath331 by the following monotone ternary connective : @xmath332 where nodes @xmath130 and @xmath131 are the children of @xmath39 in @xmath94 .",
    "we also change the proof - like structure @xmath102 ; the construction is the same as before except that at @xmath3-resolution nodes , the rule for fixing @xmath141 is also changed to reflect the monotone function used instead .",
    "more precisely , the functions @xmath133 and @xmath332 differ only when @xmath135 , @xmath178 , and @xmath333 .",
    "we set @xmath141 to @xmath334 if @xmath174 or if @xmath335 , @xmath273 and @xmath281 , and to @xmath336 otherwise .",
    "we need to show that at the differing setting , the inductive statements relating the modified @xmath141 , @xmath145 and @xmath142 continue to hold .",
    "the relation @xmath337 holds by induction .",
    "now consider the gate values .    we know by induction that @xmath178 means that @xmath159 is an @xmath84-clause and",
    "can be derived from @xmath338 alone .",
    "when @xmath135 , @xmath179 and the selector gate will output the value of @xmath173 which is a @xmath37 . hence @xmath142 is an @xmath84-clause .",
    "however observe that at this setting , @xmath333 , which means by induction that @xmath201 is a @xmath83-clause and can be derived using @xmath155 clauses alone via the appropriate proof system .",
    "thus by our assumption about @xmath3 variables appearing only positively in @xmath339 , the clause @xmath192 does not contain @xmath10 .",
    "thus we can safely assign @xmath184 .",
    "this completes the proof .",
    "we now apply our interpolation theorems to obtain new exponential lower bounds for a new class of qbfs .",
    "the lower bound will be directly transferred from the following monotone circuit lower bound for the problem @xmath340 , asking whether a given graph with @xmath341 nodes has a clique of size @xmath7 .",
    "[ thm : raz ] all monotone circuits that compute @xmath342 are of exponential size .",
    "we now build the qbf .",
    "fix an integer @xmath341 ( indicating the number of vertices of the graph ) and let @xmath3 be the set of variables @xmath343 .",
    "an assignment to @xmath3 picks a set of edges , and thus an @xmath341-vertex graph .",
    "let @xmath83 be the set of variables @xmath344 , u \\in [ n ] \\}$ ] .",
    "we use the following clauses .",
    "@xmath345\\\\ d_{i , j , u}&=&\\neg q_{iu}\\vee \\neg q_{ju } & \\quad \\text{for } i , j \\in [ \\frac{n}{2 } ] , i < j \\text { and }   u\\in [ n]\\\\ e_{i , u , v}&=&\\neg q_{iu}\\vee \\neg q_{iv } & \\quad \\text{for } i\\in [ \\frac{n}{2 } ] \\text { and } u ,",
    "v\\in [ n ] , u < v\\\\ f_{i , j , u , v}&=&\\neg q_{iu}\\vee \\neg q_{jv}\\vee p_{uv } & \\quad \\text{for } i , j \\in [ \\frac{n}{2 } ] , i < j$ \\text { and } $ u\\neq v\\in [ n ] .",
    "\\end{array}\\ ] ] we can now express @xmath342 as a polynomial - size qbf @xmath346 , where @xmath347}c_i\\wedge",
    "\\bigwedge_{i < j , u\\in [ n]}d_{i , j , u}\\wedge \\bigwedge_{i\\in [ \\frac{n}{2}],u < v}e_{i , u , v}\\wedge \\bigwedge_{i < j , u\\neq v}f_{i , j , u , v}.\\ ] ] here the edge variables @xmath3 appear monotone in @xmath348 .    likewise no-@xmath342 can be written as a polynomial - size qbf @xmath349 . to construct this",
    "we use a polynomial - size circuit that checks whether the nodes specified by @xmath350 fail to form a clique in the graph given by @xmath3 .",
    "we then use existential variables @xmath351 for the gates of the circuit and can then form a cnf @xmath352 that represents the circuit computation .",
    "now we can form a sequence of false qbfs , stating that the graph encoded in @xmath3 both has a clique of size @xmath353 ( as witnessed by @xmath83 ) and likewise does not have such a clique as expressed in the @xmath354 part : @xmath355 this formula has the unique interpolant @xmath356 .",
    "but since all monotone circuits for this are of exponential size by theorem  [ thm : raz ] and monotone circuits of size polynomial in and proofs can be extracted by theorem  [ theorem2 ] , all such proofs must be of exponential size , yielding :    [ thm : lower - bound - clique ] the qbfs @xmath357 require exponential - size proofs in and .",
    "recall the two player game semantics of a qbf explained in section  [ sec : prelim ] .",
    "every false qbf has a winning strategy for the universal player , where the strategy for each variable depends only on the variables played before .",
    "we now explain the relation between strategy extraction  one of the main paradigms for qbf systems  and feasible interpolation . in section  [ sec : interpolation ] we studied qbfs of the form @xmath358.$ ] if we add a common universal variable @xmath359 we can change it to an equivalent qbf @xmath360.\\ ] ] if @xmath81 is false , then also @xmath361 is false and thus the universal player has a winning strategy , including a strategy for @xmath362 for the common universal variable @xmath359 .",
    "every winning strategy @xmath363 for @xmath359 is an interpolant for @xmath81 , i.e. , for every @xmath90 assignment @xmath91 of @xmath3 we have @xmath364    suppose not .",
    "then there are two possibilities .",
    "* there is some @xmath91 where @xmath365 and @xmath120 is true .",
    "then setting @xmath366 would satisfy @xmath367 .",
    "but @xmath368 is also satisfied .",
    "hence this can not be part of the winning strategy for the universal player .",
    "* there is some @xmath91 where @xmath369 and @xmath109 is true .",
    "this is the dual of the above .",
    "this observation means that every interpolation problem can be reformulated as a strategy extraction problem .",
    "we will now show that from proofs of these reformulated interpolation problems we can extract a ( monotone ) boolean circuit for the winning strategy on the new universal variable @xmath359 .",
    "strategy extraction was recently shown to be a powerful lower bound technique for qbf resolution systems . in strategy extraction , from a refutation of a false qbf , winning strategies for the universal player for all universal variables can be efficiently extracted .",
    "devising qbfs that require computationally hard strategies then leads to lower bounds for qbf proof systems .",
    "this technique applies both to @xcite , where lower bounds for e.g.  parity are used , as well as to much stronger qbf frege systems where the full spectrum of current ( and conjectured ) lower circuit bounds is employed @xcite .",
    "in fact , beyersdorff and pich @xcite show that lower bounds for qbf frege systems can only come either ( a ) from circuit lower bounds via the strategy extraction technique or ( b ) from lower bounds for classical proposition frege .",
    "this picture is reconfirmed here as well : qbf resolution lower bounds via feasible interpolation fall under paradigm ( a ) as they are in fact lower bounds via strategy extraction .    to show this we now prove how to extract strategies for interpolation problems , first for and then for .    [ thm : b - lqu ]    1 .   from each refutation @xmath94 of @xmath361",
    "we can extract in polynomial time a boolean circuit for @xmath363 , i.e. , the part of the winning strategy for variable @xmath359 .",
    "2 .   if in the same setting as above for @xmath361 , the variables @xmath3 appear only positively in @xmath85 , then we can extract a monotone boolean circuit for @xmath363 from a refutation @xmath94 of @xmath361 in polynomial time ( in the size of @xmath94 ) .",
    "as we can compute the ( monotone ) interpolant when @xmath359 is absent , we use the same proof with a few modifications for the new formula .",
    "we first change the definition of @xmath83 and @xmath84-clauses to allow for @xmath359 and @xmath370 literals .",
    "we call any clause in the proof a @xmath83-clause ( resp .",
    "@xmath84-clause ) if it contains only variables @xmath97 or literal @xmath359 ( resp .",
    "@xmath98 or literal @xmath370 ) .",
    "we retain the inheritance property for clauses only containing @xmath3 variables .    * construction of the circuit @xmath126 : * when constructing the circuit , we now also need to consider a resolution step on the common universal variable @xmath359 : @xmath371 here we can arbitrarily pick one of @xmath130 or @xmath131 . for example here we pick @xmath130 and let @xmath372 disregarding the input from @xmath373 .",
    "* construction of @xmath124 and @xmath125 : * we slightly modify the invariants to include the new definitions .",
    "additionally we make a small change to the first invariant .",
    "1 .   @xmath374 .",
    "2 .   @xmath111 is a @xmath83-clause and can be obtained from the clauses of @xmath112 alone using the rules of .",
    "3 .   @xmath113 is a @xmath84-clause and can be obtained from the clauses of @xmath114 alone using the rules of .",
    "notice also that @xmath375 as @xmath376 can only arise from a long distance resolution step on a @xmath3 variable but these are instantiated and so never occur as pivots in this proof assuming the induction hypothesis .",
    "we observe that the base cases work for the construction of @xmath124 and @xmath125 .",
    "the only new part of the inductive step is when we have @xmath371 to find @xmath141 we look at our choice of wiring in the circuit construction .",
    "if @xmath101 is wired to @xmath377 ( @xmath372 ) then we take @xmath141 to equal @xmath191 . since @xmath378 we get @xmath379 . since our choice of the clause is determined by our choice of wiring",
    ", then we retain our invariants in that way .",
    "notice that because of this case we never resolve a @xmath83-clause with a @xmath84 clause in @xmath124 so @xmath380 will always be retained in their respective type of clauses .    from the above , we have the following conclusion .",
    "let @xmath115 be the root of @xmath94 . then on any assignment @xmath91 to the @xmath3 variables we have :    ( 1 ) : :    @xmath381 .",
    "therefore ,    @xmath382 .",
    "but @xmath383 can contain    at most one of these literals , which can be universally reduced to    complete a refutation .",
    "( 2 ) : :    @xmath384 is a    @xmath83-clause and can be obtained from the clauses of    @xmath112 alone using the rules of system .",
    "hence by soundness of ,    @xmath120 is false .",
    "( 3 ) : :    @xmath385 is an    @xmath84-clause and can be obtained from the clauses of    @xmath114 alone using the rules of system .",
    "hence by soundness of ,    @xmath122 is false .",
    "thus @xmath123 , the output gate of the circuit , computes @xmath363 .",
    "an analogous result to theorem  [ thm : b - lqu ] also holds for .",
    "[ thm : b - irmc ]    1 .   from each refutation @xmath94 of @xmath361",
    "we can extract in polynomial time a boolean circuit for @xmath363 , i.e. , the part of the winning strategy for variable @xmath359 .",
    "2 .   if in the same setting as",
    "above for @xmath361 , the variables @xmath3 appear only positively in @xmath85 , then we can extract a monotone boolean circuit for @xmath363 from a refutation @xmath94 of @xmath361 in polynomial time ( in the size of @xmath94 ) .",
    "we can use exactly the same constructions as in theorem  [ thm : irm ] .",
    "the @xmath359 literals do not affect the argument .    as a corollary ,",
    "the versions @xmath386 of the formulas from section  [ sec : lower - bounds ] also require exponential - size proofs in and .",
    "we thank pavel and mikol janota for helpful discussions on the relation between feasible interpolation and strategy extraction during the dagstuhl seminar ` optimal agorithms and proofs ' ( 14421 ) .",
    "olaf beyersdorff , ilario bonacina , and leroy chew .",
    "lower bounds : from circuits to qbf proof systems . in _ proc .",
    "acm conference on innovations in theoretical computer science ( itcs16 ) _ , pages 249260 .",
    "acm , 2016 .",
    "olaf beyersdorff , leroy chew , meena mahajan , and anil shukla .",
    "feasible interpolation for qbf resolution calculi . in _ proc .",
    "international colloquium on automata , languages , and programming ( icalp15 ) _ , pages 180192 .",
    "springer , 2015 .",
    "olaf beyersdorff , leroy chew , meena mahajan , and anil shukla .",
    "are short proofs narrow ?",
    "qbf resolution is not simple . in _ proc .",
    "symposium on theoretical aspects of computer science ( stacs16 ) _ , pages 15:115:14 , 2016 .",
    "uwe egly , martin kronegger , florian lonsing , and andreas pfandler .",
    "conformant planning as a case study of incremental qbf solving . in _",
    "artificial intelligence and symbolic computation ( aisc14 ) _ , pages 120131 , 2014 ."
  ],
  "abstract_text": [
    "<S> in sharp contrast to classical proof complexity we are currently short of lower bound techniques for qbf proof systems . in this paper </S>",
    "<S> we establish the feasible interpolation technique for all resolution - based qbf systems , whether modelling cdcl or expansion - based solving . </S>",
    "<S> this both provides the first general lower bound method for qbf proof systems as well as largely extends the scope of classical feasible interpolation . </S>",
    "<S> we apply our technique to obtain new exponential lower bounds to all resolution - based qbf systems for a new class of qbf formulas based on the clique problem . </S>",
    "<S> finally , we show how feasible interpolation relates to the recently established lower bound method based on strategy extraction by beyersdorff et al .  </S>",
    "<S> @xcite . </S>"
  ]
}