{
  "article_text": [
    "the objective of swarm robotics is to program a huge number of simple , tiny robots to perform complex tasks collectively . a typical application scenario for a robot swarm may involve two phases : first , the robot swarm fills an environment as quickly as possible",
    "while keeping the swarm `` connected '' ( a term made more precise later ) .",
    "once the robots are distributed in the environment , the robots perform _ world - embedded _ computational tasks , such as computing distances and short paths between points in the environment , finding chokepoints , mapping the environment , and searching for intruders .",
    "this paper develops efficient algorithms for filling an environment with a swarm of robots , thus focusing on the first phase described above . because target applications require thousands to millions of robots and current demonstration scenarios have at most hundreds of robots , it is crucial to develop algorithms that have explicitly stated performance guarantees , thus ensuring scalability .",
    "there has already been work on dispersion algorithms , but most dispersion algorithms rely on greedy strategies such as _ go - for - free space _ , where robots move to fill unoccupied space , or _ artificial physics",
    "_ strategies , where neighboring robots exert `` forces '' on each other : repulsion forces if the robots are closer than the target separation , and attraction forces if the neighboring robots are too far away .",
    "although such robot behaviors often lead to reasonable dispersion , there are cases in which the swarm enters infinite loops , never filling the domain . even in artificial physics strategies , which seem to disperse robots most efficiently ,",
    "there are no guarantees on filling time .",
    "furthermore , the swarm behavior under artificial - physics rules results in dispersions that are more reminiscent of molecular dynamics simulations ( with large amounts of `` bouncing '' and `` jitter '' ) than of the ideal coordinated behavior of cooperating teams of robots .",
    "the dispersion algorithms in this paper represent a departure from previously studied dispersion strategies .",
    "first of all , we test our algorithms in arbitrary polygonal environments , rather than restricting ourselves to rectangles or the infinite plane .",
    "it is important to study the dispersion algorithms in complicated polygonal domains because the target domains may be bottleneck - filled indoor environments or systems of pipes or ductwork .",
    "our algorithms are based on follow - the - leader local rules , where the robots form chains of leaders and followers emanating from a central source of robots .",
    "( the `` doors '' ) .",
    "the emergent behavior of our main algorithm is a left - hand - on - the - wall strategy , where the entire robot swarm hugs the left wall of the domain as the filling proceeds .",
    "we provide matching lower and upper bounds on the amount of time to fill as a function of the total size of the source .",
    "the difficulty in dispersing efficiently is in sustaining a large flow of robots coming in through the doors ; the `` chains '' of robots coming in through the doors have a tendency to `` cut each other off '' ; see figure  [ fig : cut - off - domain - pixels](left ) .",
    "thus , we devise a set of local rules for splitting and splicing the robot chains .",
    "our experience with our robot simulator shows that unless the local rules are precisely implemented , the flow of robots out of the source diminishes and perhaps even grinds to a halt prematurely .",
    "[ fig : cut - off - domain - pixels ]      we develop and analyze algorithms for dispersing robot swarms in an unknown environment @xmath0 .",
    "the primary objective is to minimize the _",
    "makespan _ ,",
    "that is , the time to _ fill _ the entire region . an environment is composed of _ squares _ or _ pixels _ that form a connected subset of the integer grid ; such an environment is also called a _",
    "maze_. there is at most one robot per pixel and robots move horizontally or vertically at unit speed .",
    "there is a source of robots entering the environment through @xmath1 _ doors_. robots are primitive finite automata , only having local communication , local sensors , and a constant - sized memory .",
    "the challenge is in proving that purely local strategies distributed over a swarm of agents can result in a predictable and provable behavior for the collective .",
    "this paper presents the following results :    * we give filling algorithms for the single - door case ( i.e. , @xmath2 ) , analyzing the algorithms both theoretically and experimentally in terms of natural performance metrics , such as makespan and total traveled distance by all robots .",
    "our algorithms are based on leader - follower strategies that are adapted from depth - first and breadth - first search to apply to robot swarms .",
    "we prove that our algorithms have optimal makespan @xmath3 , where @xmath4 is the area ( number of pixels ) of  @xmath0 .",
    "* we give a filling algorithm for the multi - door case ( @xmath1 ) , also based on a leader - follower strategy . the emergent behavior of the swarm is a filling strategy , called _ laminar flow _ , that generalizes the `` left - hand - on - wall '' strategy to multiple streams of robots coming in through multiple doors .",
    "an important contribution of the algorithm is the formulation of splitting and splicing strategies that maintain a large flow of robots out of the doors .",
    "we prove that the laminar flow algorithm is @xmath5-competitive , that is , the ratio of the makespan of our algorithm to the optimal makespan is @xmath5 .",
    "* we give a matching lower bound of @xmath6 on the competitiveness of the natural class of `` simple - minded '' strategies that use only strictly local information .",
    "* we report on experiments with a java simulator that we built for swarms in grid environments .",
    "all of the algorithms in this paper are implemented in this simulator .",
    "while our results here are given purely in terms of robots moving synchronously on discrete grids , the results apply also to dispersing swarms of robots within an arbitrary connected planar domain , in the ideal setting in which the robots have perfect motion control and synchrony .",
    "more importantly , our results may form the foundation for theoretical work on more realistic models of swarm robotics in the continuum , with asynchronous motion , sensor errors , slippage , and hardware failures .",
    "there has been considerable study recently of distributed control and coordination of a set of autonomous robots .",
    "gage  @xcite has proposed the development of command and control tools for arbitrarily large swarms of microrobots and has proposed coverage paradigms in the context of robot dispersal in an environment .",
    "payton et al  @xcite propose the notion of `` pheromone robotics '' for world - embedded computation .",
    "wagner et al .",
    "@xcite developed multi - robot algorithms , directly inspired by ant behaviors , for searching and covering .",
    "principe et al  @xcite and suzuki et al  @xcite have studied algorithmic aspects of pattern formation in distributed autonomous robotics under various models of robots with minimal capabilities .",
    "the related flocking problem , which requires that a set of robots follow a leader while maintaining a formation , has been studied in several recent papers ; see , e.g. , @xcite .",
    "balch  @xcite has developed `` teambots '' , a java - based general - purpose multi - robot simulator .",
    "there is a vast literature on algorithms for one or several robots to explore unknown environments .",
    "the environments can be modeled as graphs ( directed or undirected ) , mazes , or geometric domains , and the robots can have a range of computing powers ; see , e.g. , @xcite .",
    "mitchell  @xcite includes a survey of many results on exploring and navigating in geometric environments .",
    "dispersion algorithms have been recently studied both in the context of multi - robot coverage and sensor network deployment ; see @xcite .",
    "methods include potential fields  @xcite , `` artifical physics ''  @xcite , attraction - repulsion  @xcite , and algorithms based on molecular dynamics  @xcite .",
    "while these studies have examined empirically the merits of heuristics , they have not addressed formally the algorithmic efficiency of the dispersion problem .",
    "for an arbitrary connected region @xmath7 in the plane , we let @xmath0 denote the set of _ pixels _ that lie entirely within @xmath7 .",
    "pixel _ is an axis - aligned unit square , @xmath8 , whose lower left corner is given by the integer grid point @xmath9 .",
    "two pixels are _ neighbors _ if they share a common edge ; thus , pixel @xmath9 has four neighbors , @xmath10 , @xmath11 , @xmath12 , and @xmath13 .",
    "we refer to @xmath0 as the _ environment _ , and we assume that it is connected",
    ". a subset , @xmath14 , of the pixels are _ doors _ , which serve as sources of incoming robots .",
    "see figure  [ fig : cut - off - domain - pixels](right ) .",
    "a _ robot _ @xmath15 is said to _ occupy _ a pixel @xmath16 when it is located in that pixel .",
    "we assume that at most one robot can occupy any one pixel at any given time @xmath17 .",
    "we let @xmath18 denote the pixel occupied by robot @xmath15 at time @xmath17 .",
    "we let @xmath19 denote the pixel _ previously _ occupied by robot  @xmath15 .",
    "time is discretized into steps @xmath20 .",
    "the positions of the robots at time @xmath17 are given by the set @xmath21 , where @xmath22 . at time",
    "@xmath23 , there is one robot in each door : @xmath24 .",
    "each pixel is in one of three states at time @xmath17 : ( 1 ) the pixel is an _ obstacle _ if it does not lie in @xmath0 ; ( 2 ) the pixel is _ occupied _ if it is in @xmath0 and a robot occupies it ; or ( 3 ) the pixel is _ unoccupied _ if it is in @xmath0 and no robot occupies it at time @xmath17 .",
    "an unoccupied pixel at time @xmath17 is classified as either _ previously occupied _",
    ", if it was occupied by some robot at some time prior to @xmath17 , or _",
    "frontier _ , if it has never been occupied .",
    "robots have _ sensors _ that detect information about the local environment .",
    "in particular , if a robot occupies pixel @xmath9 at time @xmath17 , then we assume that it can detect the state of each pixel within a distance @xmath25 of @xmath9 , where @xmath25 is the ( fixed ) _",
    "sensor radius_. robots have no global sensor ( e.g. , a gps ) and no knowledge of the coordinates of the pixels they occupy .",
    "we assume that each robot has a small finite memory that allows it to remember the sensor readings of the last @xmath26 time steps ; i.e. , a robot knows the sensor readings it has taken at time @xmath27 , @xmath28 . in particular , each robot knows which nearby pixels have been occupied recently by other robots .",
    "the algorithms in this paper have an @xmath29-bit memory ; thus , the robots have the computational power of finite automata .",
    "we assume that robots have a limited ability to communicate with nearby robots .",
    "in particular , at any given time step a robot is able to exchange a constant - size message with any robot that lies within a prescribed _ communication radius _ , @xmath30 , of the robot .",
    "the _ communication graph _",
    ", @xmath31 , of the swarm @xmath21 at time @xmath17 is defined to be the undirected graph whose nodes are the robots @xmath21 and whose edges link pairs of robots that communicate .",
    "the swarm is said to be _ connected _ at time @xmath17 if each connected component of @xmath31 contains at least one door pixel .",
    "robots move discretely on the grid of pixels . if at time",
    "@xmath17 a robot occupies pixel @xmath9 of @xmath0 , and a neighboring pixel ( say , @xmath32 ) of @xmath0 is unoccupied at time @xmath17 , then the robot may take a step to the right , so that at time @xmath33 it occupies pixel @xmath11 .",
    "naturally , no two robots can move into the same pixel , since no pixel can be occupied by more than one robot .",
    "thus , if two robots are occupying pixels that neighbor an empty pixel @xmath34 of @xmath0 , then the robots must _ negotiate _ which one of them will have the right of way to enter @xmath34 . a simple way to handle",
    "this negotiation is to establish a priority among the four directions , e.g. , north , south , east , west .",
    "the robot occupying the pixel with the highest priority with respect to @xmath34 has first rights for moving to @xmath34 .",
    "the above rules on occupying and vacating pixels force a constant _ delay _ in the motion .",
    "suppose that robot @xmath15 occupies pixel @xmath9 at time @xmath17 and vacates @xmath9 at time @xmath33 .",
    "no other robot @xmath35 can occupy pixel @xmath9 during time @xmath33 ; the earliest possible time that the pixel can be occupied is @xmath36 . in principal",
    ", we could vary these local rules .",
    "for example , we could allow robot @xmath35 to enter pixel @xmath9 at timestep @xmath33 , if it enters in one direction while the current robot @xmath37 leaves in the opposite direction .",
    "however , these rules would require a much higher degree of coordination among the robots , and the movement decisions of robots would have to be less local .",
    "specifically , whether a given robot can enter one pixel may depend on whether a different robot far away leaves another pixel .",
    "alternatively , we could build a longer delay into the movement rules , but the resulting filling algorithms would be essentially the same . note that the delay has an immediate impact on the necessary sensor range : if we require a delay of two time steps , robots need at least a sensor range of two , in order to be able to keep track of predecessors and successors .",
    "a similar issue arises in the way new robots enter through the door . for simplicity ,",
    "we assume that a door pixel is always occupied by a robot ; as soon as the robot occupying a door pixel moves to an adjacent pixel , a new robot materializes at the door .",
    "one can consider there to be an infinite supply of robots on the `` other side '' of a door pixel , so that a new robot steps into the door whenever the robot that was there previously moves to another pixel of @xmath0 .",
    "when a robot first appears at the door , we assume that the robot points north .",
    "we say that the robots _ have filled _ the region @xmath0 at time @xmath17 if @xmath38 ; in this case , the robots are _",
    "well dispersed_. a _",
    "strategy _ is a set of rules by which robots move , basing their movement decisions solely on the constant amount of information they sense and remember .",
    "the _ makespan _ of a strategy is the minimum time , @xmath39 , until the robots have filled the region  @xmath0 .",
    "we begin with the case of a single door pixel @xmath40 , which we call the _ source_. we describe strategies based on the notion of `` leaders '' and `` followers '' .",
    "a robot @xmath15 at time @xmath17 at position @xmath18 is classified as _ moving _",
    "( meaning that it is `` active '' ) or _ stopped _ ( meaning that it no longer moves ) .",
    "if @xmath15 is moving , it is classified as either a _ leader _ or a _",
    "follower_.    in our leader - follower strategies , each robot @xmath15 at time @xmath17 has a successor robot , @xmath41 , that is following @xmath15 and a predecessor robot , @xmath42 , that is leading @xmath15 .",
    "if robot @xmath15 is at the door at time @xmath17 ( @xmath43 ) , then we define @xmath41 to be nil ; if @xmath15 is a leader , then we define @xmath42 to be nil .    at time @xmath44 there is a robot at the door @xmath40 , which is designated as moving and as a leader .",
    "the depth - first leader - follower strategy ( dflf ) is inspired by depth - first search in a graph .",
    "specifically , at any given time @xmath45 , there is exactly one leader , @xmath15 , which is on pixel @xmath18 and @xmath15 is looking for a frontier pixel ( one that has never been occupied by a robot ) .",
    "( thus , necessarily the pixel from which the robot came , @xmath46 , is not frontier at time @xmath17 . )",
    "if there are two or more frontier pixels neighboring @xmath18 , the leader selects any one of them as its next destination .",
    "if the leader has no frontier pixel next to it , it stops ( its state changes to `` stopped '' ) , and it tells its successor , @xmath47 , to assume the leadership ( @xmath47 s state changes to `` leader '' ) at the conclusion of this time step .",
    "( the predecessor completes its move before taking over the leadership . )",
    "if the leader has no predecessor ( i.e. , it is a robot at the door ) , then the algorithm halts .",
    "( in this section , successors and ( non - nil ) predecessors are invariant over time , and thus @xmath17 is removed from the argument . )    any robot @xmath15 that is a follower ( i.e. , not the leader ) simply follows its predecessor : at time @xmath17 it steps next to @xmath48 , the pixel previously occupied by the predecessor of @xmath15 .",
    "note that once a robot stops , it never moves again .",
    "furthermore , at any point in time there is exactly one leader .",
    "when dealing with finite automata , we have to use particular care when implementing the leader - follower strategy . as each robot has only a finite number of states",
    ", it can not keep track of the identities of other robots , nor carry its own `` i d label '' .",
    "instead , we use spatial information to pursue the immediate predecessor .",
    "each robot @xmath15 has a `` heading '' , indicating the direction in which it is moving .",
    "the predecessor @xmath49 is the nearest robot in that direction .",
    "similarly , each robot keeps track of its `` tailing '' , the direction from which it came .",
    "thus , the successor is the nearest visible robot in that direction . whenever a robot is about to change its heading , it signals this turn to its immediate successor .",
    "heading and tailing are updated according to delay and sensor - range .",
    "this is reflected in the following lemma and corollary , which are proved by introduction on time .",
    "if @xmath15 is not the leader at time @xmath17 , then @xmath48 is an unoccupied pixel neighboring @xmath18 .",
    "furthermore , the maximum ( @xmath50 ) distance between @xmath15 and @xmath49 is 2 .",
    "if a pixel is not occupied in two consecutive time steps @xmath17 and @xmath33 , then it was never occupied before time @xmath17 .",
    "( i.e. , there are no `` large gaps '' of time in the occupation of a pixel . )",
    "a further consequence of the above lemma and corollary is that the dflf strategy can be implemented with a sensor radius of @xmath51 and a memory of @xmath52 ( i.e. , each robot recalls its previous sensor reading ) .",
    "now it is not hard to derive the following result :    [ th : dflf ] the dflf algorithm halts when all pixels are occupied by robots .",
    "the makespan of the dflf algorithm is @xmath3 , where @xmath4 is the number of pixels of the environment  @xmath0 .    at each time step",
    "there is exactly one leader and that leader will do one of two things : ( 1 ) move to a frontier pixel , or ( 2 ) change its status to stopped and transfer leadership to its predecessor .",
    "( if the leader has no predecessor , that is , it is at the door , the algorithm halts . ) since each non - door pixel can be changed from frontier to non - frontier at most once , and each pixel can have a robot `` park '' itself on top of it at most once , the number of steps before the algorithm halts is at most @xmath3 .",
    "the algorithm does not stop earlier since there is always a leader and the leader must do one of the two actions ( ( 1 ) or ( 2 ) ) above .",
    "note that the factor 2 is a result of using a delay of 2 .",
    "it is easy to see that this is best possible .",
    "the total distance traveled by all robots in a filling using dflf is at most @xmath53 , since each robot steps at most @xmath4 .",
    "we note that there are examples in which _ any _ dispersion strategy will require @xmath54 total travel .",
    "one trivial example is a @xmath55 rectangle , with the door pixel at one end .",
    "a trivial lower bound on the total travel for any given instance is the sum of the distances from each pixel of @xmath0 to the door .",
    "dflf may use substantially more total travel than an optimal ( minimum makespan ) strategy that minimizes total travel ; consider , for example , a square with side lengths @xmath56 , for which dflf requires total travel of @xmath53 while an optimal strategy achieves total travel @xmath57 .",
    "we now describe an alternative dispersion algorithm , the breadth - first leader - follower ( bflf ) strategy .",
    "bflf often has advantages over the dflf strategy in terms of other metrics of performance ( total travel of the robots , maximum travel of any one robot , total relative distance , etc ) , while still being optimal in terms of makespan ( @xmath3 ) .",
    "the bflf strategy is substantially more complex than the dflf , as it is not trivial to implement breadth - first search with local decision rules on ( finite - automata ) robots ; indeed , our strategy does not perform breadth - first search , but it `` approximates '' breadth - first search sufficiently well to have some similar properties .",
    "as before , a robot can be in a `` moving '' state or a `` stopped '' state ; however , we now introduce a third state , the _ waiting _ state , which is an interim state when a robot pauses temporarily and waits to be able to move . once a robot is in a stopped state , it never moves again .",
    "in the bflf strategy we can have multiple leaders , while in dflf we have only one .",
    "as described for dflf , we use a limited amount of spatial information to keep track of successors and predecessors .",
    "other local rules are more complex and are described in the following .",
    "initially , there is one leader robot  the robot at the door , @xmath40 .",
    "when a robot @xmath15 materializes at the door , it chooses to follow the previous robot that left the door .",
    "a leader always attempts to go to a neighboring frontier pixel , but makes sure it does not stray too far from its follower .",
    "if there are no neighboring frontier pixels , the leader waits for the immediate follower to catch up .",
    "as soon as the immediate follower catches up , the leader becomes stopped and passes on the leadership role to the immediate follower .",
    "if the leader @xmath15 at pixel @xmath58 has a choice among neighboring frontier pixels , it picks any one of them to be its heading .",
    "if other frontier pixels adjacent to @xmath58 remain unclaimed by other robots following different branches of dispersion , then the follower @xmath35 of @xmath15 will choose one of these pixels as its heading when it arrives at @xmath58 ; if there remains a frontier pixel adjacent to @xmath58 , then @xmath35 s follower @xmath59 chooses this pixel as its heading when it arrives at @xmath58 . here , @xmath35 and @xmath59",
    "are relabeled `` leaders '' and pixel @xmath58 is marked as a branching point .",
    "a robot @xmath15 is only allowed to move at time @xmath17 , if it satisfies the _ movement criterion _",
    "( mc ) : a robot currently occupies @xmath46 ( its `` parent '' position ) or a robot is currently _ heading for _ @xmath46 .",
    "if the mc is satisfied , the robot @xmath15 moves to its heading ; otherwise , it remains at its current position , @xmath18 but is still _ heading for _ its target pixel .",
    "as we will see below , a robot @xmath15 is never blocked by its immediate predecessor _ except _ for the time step at which @xmath15 first appears at the door or a time when its immediate predecessor is a leader with nowhere to go , meaning that the leadership will be passed to  @xmath15 .",
    "the bflf strategy tries to create as many paths as possible at all times .",
    "the visited pixels form a _ tree _ that guides the directions that robots move ; thus , pixels have _ parents _ and _ grandparents_. at branches in the tree ( pixels with @xmath60 children ) , robots alternate the direction that they travel . specifically , when a robot @xmath15 leaves a pixel at time @xmath17 , it tells its immediate follower @xmath61 what @xmath35 s immediate destination should be .",
    "branching enables robots arriving at the same pixel at different times to go in different directions , thereby balancing the flow .",
    "if not all pixels are occupied , then some robot can move .",
    "the following structural lemma shows that the bflf algorithm is nonblocking , i.e. , a robot @xmath15 is never `` delayed '' by its predecessors , only by its followers ; i.e. , only the mc holds a robot back , not temporary blockages downstream .",
    "correctness follows by induction on the height of the tree .",
    "if a robot is at pixel @xmath62 and a robot is at pixel @xmath58 , the non - root parent of @xmath62 , then the robot at @xmath62 is stopped .",
    "[ clm : stopped - condition ]    a robot moves from the root every other time step , until all pixels are occupied .",
    "i.e. , if a robot did not pop up at the root at time @xmath17 , then one must pop up at time @xmath33 , unless all pixels ( including the root ) are occupied .",
    "the robots maintain a communication distance of @xmath63 , meaning that the algorithm works for @xmath64 .",
    "the maximum @xmath50-distance from a robot to a follower is @xmath63 .",
    "furthermore , at least one of the following pixels is occupied when a robot is at pixel @xmath58 : ( 1 ) the parent of @xmath58 , ( 2 ) the grandparent of @xmath58 , or ( 3 ) the uncle of  @xmath58 .",
    "putting all the claims together and using similar reasoning as for theorem  [ th : dflf ] , we get the same kind of bound on the makespan :    [ th : bflf ] the bflf algorithm halts when all pixels are occupied by robots . the makespan of the bflf algorithm is @xmath3 , where @xmath4 is the number of pixels of the environment  @xmath0 .",
    "while the dflf and bflf strategies both have optimal makespan , they differ with respect to other performance metrics .",
    "we have implemented in java a simulator for testing our dispersion strategies , while measuring various performance measures , including : ( 1 ) the _ depth _ of the tree of all paths from the source ( i.e. , the length of the longest path of a robot ) ; ( 2 ) the average distance traveled by a robot during the dispersion ; and ( 3 ) the average of the ratios , @xmath65 , of the ( @xmath50 ) distance @xmath66 from the door to robot @xmath67 s final location to the total distance @xmath68 traveled by robot @xmath67 during the dispersion .",
    "we have compared the dflf and bflf strategies for the case of a single door , in a variety of different environments .",
    "our results show that the average depth of the tree grows substantially more rapidly , as a function of the number of pixels , for dflf than it does for bflf ; e.g. , for an @xmath69-by-@xmath69 square grid , bflf tree depth grows linearly in @xmath69 while dflf depth grows close to quadratically in @xmath69 .",
    "similarly , the average distance traveled by a robot using dflf grows more rapidly than using bflf .",
    "the average of the ratios @xmath65 decreases with increasing problem size for dflf , while it increases for bflf .",
    "details of the experimental results are deferred to the full paper .",
    "we now consider the case in which there are @xmath70 door pixels . in order to achieve rapid filling ,",
    "the objective is to maintain a flow of robots out of as many doors as possible .",
    "the difficulty is that one robot chain out of one door pixel may unnecessarily block the flow of robots out of other door pixels .",
    "( see the introduction and figure  [ fig : cut - off - domain - pixels](left ) for examples . )",
    "this section describes the _ laminar flow leader - follower ( lflf ) _ algorithm .",
    "the lflf algorithm maintains rapid flows by careful use of cutting and splicing .",
    "the emergent behavior of the swarm is a left - hand - on - wall strategy .",
    "the behavior of the algorithm is complex because bottlenecks in the environment may force the flow to divide into smaller flows that fill different regions and may merge and split",
    ".    in the lflf algorithm there are @xmath71 multiple door pixels , @xmath72 .",
    "note that lflf matches dflf algorithm if @xmath2 .",
    "as in the @xmath73 case , our dispersion strategies are based on leaders and followers .",
    "a robot @xmath37 at time @xmath17 at position @xmath74 is classified as _ active _ or _ inactive _ ( stopped ) .",
    "if @xmath37 is active , it is either a _ leader _ or a _",
    "follower_. however , unlike for @xmath75 , robots",
    "_ revert _ between leaders and followers .",
    "( in contrast , for @xmath73 a robot changes roles from follower to leader but only relinquishes the leader role by stopping and becoming inactive . )",
    "furthermore , in dflf once a robot stops , it becomes inactive .",
    "in contrast , in lflf a robot may temporarily stop while still remaining active .    in lflf ( as in dflf )",
    ", robots have successors and predecessors , but in lflf a robot s immediate successor or predecessor may change over time .",
    "thus , each robot @xmath37 at time @xmath17 has a predecessor robot denoted @xmath76 and a successor robot denoted @xmath77 . if robot @xmath15 is at a door pixel at time @xmath17 ( @xmath78 , for @xmath79 $ ] ) , then @xmath80 ; if @xmath15 is a leader at time @xmath17 , then @xmath81 .",
    "here we further refine the roles of the pixels .",
    "a pixel can be : ( 1 )  an _ obstacle _ , ( 2 )  a _ frontier _ pixel ( a pixel that has never been occupied ) , ( 3 )  an _ inactive _ pixel , that is , an ( occupied ) pixel that hosts an inactive robot , ( 4 )  an _ active _ pixel , ( which may be occupied or not ) . if a pixel is unoccupied but previously occupied , then it is always active ; if a pixel is occupied , then it is active if and only if the robot it hosts is active .",
    "note that door pixels may be active or inactive , as described later .",
    "active pixels play the role of transporting robots throughout the domain whereas inactive pixels are essentially obstacles .",
    "analogous to the definition of predecessor and successor robots , each active pixel has predecessor and successor pixels .",
    "in particular , pixel @xmath82 at time step @xmath83 has successor pixel @xmath84 and predecessor pixel @xmath85 . for door pixels @xmath86 at any time @xmath87 @xmath88 .",
    "a _ leader pixel _",
    "@xmath89 at time @xmath83 has @xmath90 . as we will see ,",
    "if a leader pixel contains a robot , then the robot is a leader , however the leader robot may not be on a leader pixel and the leader pixel may not contain robots .",
    "we call a chain of predecessor pixels starting from the door pixel @xmath86 and ending at a leader pixel , a _ flow line_.    we now define formally the _ left side _ and _ right side _ of the flow . to do so , we first present some intermediate definitions . consider a pixel @xmath91 at time @xmath17 , and let @xmath92 and @xmath93",
    ". let the _ incoming direction _ for @xmath91 at time @xmath17 be the vector @xmath94 and let the _ outgoing direction _ for @xmath91 at time @xmath17 be the vector @xmath95 .",
    "consider the ( vertical or horizontal ) neighboring pixels , when we start from the incoming direction @xmath94 and rotate _ clockwise _ until reaching the outgoing direction @xmath95 .",
    "those neighboring pixels at intermediate ( vertical or horizontal ) orientations are defined to be on the _ left - hand side _ of @xmath91 time @xmath17 .",
    "thus , the left - hand side may contain @xmath96 , @xmath97 , or @xmath98 pixels .",
    "any neighboring pixel that is _ not _ on the left - hand side , is on the _ right - hand side _ ; this includes the pixels at the incoming and outgoing directions .        the essential idea the lflf algorithm is to treat the left side of the flow line completely differently from the right side of the flow line .",
    "specifically , we splice into the left - hand side but we can not splice into the right .",
    "suppose that at time @xmath17 a leader robot @xmath99 reaches a pixel @xmath100 .",
    "if @xmath58 has an ( unoccupied ) predecessor pixel @xmath101 , then robot @xmath99 moves to this pixel .",
    "( since @xmath99 is a leader robot , it will never have an occupied predecessor pixel . )    otherwise , pixel @xmath102 is a leader pixel . if @xmath103 has no neighboring frontier pixels , then robot @xmath99 tries to pass on the leadership .",
    "robot @xmath99 first looks for a neighboring active pixel @xmath62 .",
    "if no such @xmath62 exists , then @xmath99 becomes inactive and passes the leadership to its successor robot @xmath104 .",
    "when @xmath99 becomes inactive , pixel @xmath58 also becomes inactive and its successor pixel becomes the new leader pixel .",
    "if robot @xmath99 looks for a neighboring active pixel @xmath62 , and such a @xmath62 exists , then @xmath99 checks whether @xmath102 is a left - hand neighbor of @xmath62 .",
    "if this is not the case for any possible @xmath62 , then again @xmath99 becomes inactive and passes the leadership to its successor robot @xmath104 .",
    "as before , when @xmath99 becomes inactive , pixel @xmath58 also becomes inactive and its successor pixel becomes the new leader pixel .",
    "if there exists such a @xmath62 , robot @xmath99 chooses the first such @xmath62 sweeping _ clockwise _ , starting from the incoming direction .",
    "we redefine the predecessor pixel @xmath105 and thus successor pixel @xmath106 .",
    "thus , the previous successor pixel of @xmath62 becomes a new leader pixel .",
    "( note that this new leader pixel may or may not have a robot on it . )",
    "now @xmath99 identifies its new leader ; it follows predecessor pixels starting at @xmath62 until it finds a robot @xmath107 and sets @xmath108 and @xmath109 .",
    "robot @xmath99 then passes the leadership to @xmath110 .",
    "we now show that lflf always fills an environment . during lflf",
    ", we claim that the following invariant is maintained : _ the left side of a flow line consists of visited pixels and obstacles .",
    "_ this follows from the fact that , whenever a robot enters a pixel , it turns as far left as it can ( left - hand - on - the - wall ) .",
    "the invariant implies the following lemma , which we use to show that the visited regions propagate out from obstacle pixels :              when a robot becomes inactive , it is a leader and its surrounding pixels must all not be frontier , for otherwise @xmath15 would advance to such a pixel and still be active .",
    "therefore , if an active pixel @xmath58 is next to a frontier pixel @xmath62 , any robot advancing into @xmath58 will not become inactive and some flow lines can advance into the empty region so it will be filled .",
    "note that the inherent delay of @xmath114 in robot movement means that @xmath112 is a highly erratic function , so that in one timestep @xmath115 robots might enter the doors , implying that in the next timestep no robots enter the doors . in lflf",
    "additional delays are caused by splicings , and therefore we can not even say that a robot enters an active door pixel every other timestep . to understand why , consider figure  [ fig : square ] .",
    "when one flow line splices into a different flow line , a robot may get delayed by one additional time step in order to obtain the required separation between robots .",
    "if many splicing are happening next to each other , this can cause an accumulated delay of up to @xmath115 time units , which causes a `` wave '' of packed robots that propagates back towards the door pixels .",
    "thus , a door pixel might temporarily hold off ejecting robots for many units without the door pixel becoming inactive . whenever an active door pixel does not eject a robot",
    "we say there is a _ door - pixel delay_.          consider the times @xmath116 , where @xmath117 is the latest timestep during which at least @xmath118 door pixels are active .",
    "we call times @xmath119 _ significant events_. consider the time interval from @xmath117 to @xmath120 , when at least @xmath121 door pixels are active .",
    "thus , the total number of robots leaving the door plus door - pixel delays during this interval is at least @xmath122 .",
    "now consider an optimal strategy @xmath123 , and consider the cut @xmath124 associated with the significant event @xmath117 of lflf .",
    "cut @xmath124 is the boundary between the occupied and frontier pixels and has size at most @xmath118 .",
    "a lower bound on the makespan of any strategy is the area `` behind '' @xmath124 ( i.e. , the side of @xmath124 not containing the doors ) divided by the length of @xmath124 plus the amount of time required to send the flow from the door to reach @xmath124 .",
    "thus , the makespan , @xmath125 , of @xmath123 satisfies @xmath126 summing over all significant events we obtain that the total filling time of lflf is @xmath127 .",
    "the above proof also implies the following ; quite clearly , this result still holds if we extend the notion of sensible strategies to allow for some delays , as long as these only add a constant factor to the filling times .",
    "right : a scenario in which any simple - minded strategy is @xmath131 competitive .",
    ", title=\"fig : \" ] competitive .",
    "right : a scenario in which any simple - minded strategy is @xmath131 competitive .",
    ", title=\"fig : \" ]      under certain natural assumptions that limit the power of strategies , it is possible to give matching lower bounds on the competitiveness . to give some intuition , consider first the class of examples shown in figure  [ fig : log - comp](left ) , which shows that the laminar flow algorithm may take as much as @xmath6 times @xmath125 .",
    "this lower bound can be generalized to a much larger class of strategies .",
    "we say that strategy @xmath111 is _ simple - minded _ if the following condition holds : _ there is a constant @xmath132 , such that we can only tell the number @xmath133 of pixels in a region @xmath134 when a set @xmath135 has been visited that has all pixels in @xmath136 within @xmath50 distance  @xmath132 .",
    "_    considering simple - minded strategies is quite natural in the context of robot swarms : if we assume we only `` know ''",
    "a region @xmath136 after each pixel has been seen by one of the robots , then the constant @xmath132 corresponds precisely to the sensor range .",
    "the example of figure  [ fig : log - comp](left ) can be generalized as shown schematically in figure  [ fig : log - comp](right ) , which forms the basis for the proof of the following theorem :      a particular subclass of simple - minded strategies is one that arises quite naturally in exploration problems : we say that a strategy is _ conservative _ if any pixel that has been `` discovered '' , i.e. , come within sensor range of a robot , must stay within sensor range of some robot . for a constant - size sensor range ,",
    "it is easy to prove the following statement , which has been claimed for a long time in a different context :          we thank n.  jovanovic and m.  sztainberg for contributions to this research .",
    "this reseearch was partially supported by hrl labs ( a darpa subcontract ) , honda fundamental research labs , nasa ames research ( nag2 - 1325 ) , nsf ( ccr-0098172 , eia-0112849 , ccr-0208670 ) , u.s .- israel binational science foundation , and sandia national labs .",
    "m.  a. batalin and g.  s. sukhatme . spreading out : a local approach to multi - robot coverage . in h.",
    "asama , t.  arai , t.  fukuda , and t.  hasegawa , editors , _ proc .",
    "6th international symposium on distributed autonomous robotic systems _ , fukuoka , japan , 2002 .",
    "springer - verlag .",
    "a.  dumitrescu , i.  suzuki , and m.  yamashita .",
    "high speed formations of reconfigurable modular robotic systems . in _ proc .",
    "ieee international conference on robotics and automation ( icra 02 ) _ , pages 123128 , 2002 .",
    "a.  howard , m.  j. mataric , and g.  s. sukhatme .",
    "mobile sensor network deployment using potential fields : a distributed scalable solution to the area coverage problem . in h.",
    "asama , t.  arai , t.  fukuda , and t.  hasegawa , editors , _ proc .",
    "6th international symposium on distributed autonomous robotic systems _ , fukuoka , japan , 2002 .",
    "springer - verlag .      j.  s.",
    "b. mitchell , geometric shortest paths and network optimization , in _ handbook of computational geometry _ ( j .- r .",
    "sack and j.  urrutia , editors ) , pages 633701 .",
    "elsevier science publishers b.v .",
    "north - holland , amsterdam , 2000 .",
    "g. prencipe .",
    "distributed coordination of a set of autonomous mobile robots .",
    "thesis dipartimento di informatica , universit degli studi di pisa , 2002.`http://www.di.unipi.it / phd / tesi / tesi_2002/phdthesis_prencipe.ps.gz ` .",
    "a.  winfield . distributed sensing and data collection via broken ad hoc wireless connected networks of mobile robots . in l.e .",
    "parker , g.w .",
    "bekey , and j.  barhen , editors , _ distributed autonomous robotic systems _ ,",
    "vol .  4 , pp .",
    "273282 , 2000 .",
    "springer - verlag ."
  ],
  "abstract_text": [
    "<S> we develop and analyze algorithms for dispersing a swarm of primitive robots in an unknown environment , @xmath0 . </S>",
    "<S> the primary objective is to minimize the _ makespan _ , </S>",
    "<S> that is , the time to _ fill _ the entire region . </S>",
    "<S> an environment is composed of _ pixels _ that form a connected subset of the integer grid . </S>",
    "<S> there is at most one robot per pixel and robots move horizontally or vertically at unit speed . </S>",
    "<S> robots enter @xmath0 by means of @xmath1 _ door pixels _ robots are primitive finite automata , only having local communication , local sensors , and a constant - sized memory .    </S>",
    "<S> we first give algorithms for the single - door case ( i.e. , @xmath2 ) , analyzing the algorithms both theoretically and experimentally we prove that our algorithms have optimal makespan @xmath3 , where @xmath4 is the area of  @xmath0 .    </S>",
    "<S> we next give an algorithm for the multi - door case ( @xmath1 ) , based on a wall - following version of the leader - follower strategy . </S>",
    "<S> we prove that our strategy is @xmath5-competitive , and that this bound is tight for our strategy and other related strategies . </S>"
  ]
}