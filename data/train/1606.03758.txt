{
  "article_text": [
    "tree transformations are widely used in functional programming and document processing .",
    "tree transducers are a general model for transforming structured data like a database in a structured or even unstructured way .",
    "consider the following internal representation of a client database that should be transformed to a table in html .",
    "top - down tree transducers can be seen as functional programs that transform trees from the root to the leaves with finite memory .",
    "transformations where the output is not produced in a structured way or where , for example , the output is a string , can be modeled by tree - to - word transducers .    in this paper , we study deterministic linear tree - to - word transducers ( ltws ) , a subset of deterministic tree - to - word transducers that are non - copying , but not necessarily order - preserving . processing the subtrees in an arbitrary order is important to avoid reordering of the internal data for different use cases . in the example of the client database",
    "the names may be needed in different formats , e.g.    .... < salutation > < name > < surname > < surname > , < name > < title > < surname > <",
    "surname > , < name > ....    the equivalence of unrestricted tree - to - word transducers was a long standing open problem that was recently shown to be decidable  @xcite . the algorithm by  @xcite provides an co - randomized polynomial algorithm for linear transducers .",
    "we show that the equivalence of ltwsis decidable in polynomial time and provide a partial normal form .",
    "to decide equivalence of ltws , we start in section  [ sec_transducer ] by extending the methods used for sequential ( linear and order - preserving ) tree - to - word transducers ( stws ) , discussed in  @xcite .",
    "the equivalence for these transducers is decidable in polynomial time  @xcite .",
    "moreover a normal form for sequential and linear tree - to - word transducers , computable in exponential time , is known  @xcite .",
    "two equivalent ltwsdo not necessarily transform their trees in the same order .",
    "however , the differences that can occur are quite specific and characterized in  @xcite .",
    "we show how they can be identified .",
    "we use the notion of _ earliest _ states , inspired by the existing notion of earliest sequential transducers  @xcite . in this earliest form ,",
    "two equivalent stwscan transform subtrees in different orders only if they fulfill specific properties pertaining to the periodicity of the words they create . computing",
    "this normal form is exponential in complexity as the number of states may increase exponentially . to avoid this size increase",
    "we do not compute these earliest transducers fully , but rather locally .",
    "this means we transform two ltwswith different orders to a",
    "_ partial normal form _ in polynomial time ( see section  [ sec_pnf ] ) where the order of their transformation of the different subtrees are the same .",
    "ltwsthat transform the subtrees of the input in the same order can be reduced to sequential tree - to - word transducers as the input trees can be reordered according to the order in the transformation .",
    "a short version of this paper will be published in the proceedings of the 20th international conference on developements in language theory ( dlt 2016 )",
    ".    * related work . * different other classes of transducers , such as tree - to - tree transducers  @xcite , macro tree transducers  @xcite or nested - word - to - word transducers  @xcite have been studied .",
    "many results for tree - to - tree transducers are known , e.g.  deciding equivalence  @xcite , minimization algorithms  @xcite and gold - style learning algorithms  @xcite .",
    "in contrast , transformations where the output is not generated in a structured way like a tree are not that well understood . in macro - tree transducers ,",
    "the decidability of equivalence is a well - known and long - standing question  @xcite .",
    "however , the equivalence of linear size increase macro - tree transducers that are equivalent to mso definable transducers is decidable  @xcite .",
    "let @xmath0 be a ranked alphabet with @xmath1 the symbols of rank @xmath2 .",
    "trees on @xmath3 ( @xmath4 ) are defined inductively : if @xmath5 , and @xmath6 , then @xmath7 is a tree .",
    "let @xmath8 be an alphabet .",
    "an element @xmath9 is a word . for two words @xmath10",
    "we denote the concatenation of these two words by @xmath11 .",
    "the length of a word @xmath12 is denoted by @xmath13 .",
    "we call @xmath14 the empty word .",
    "we denote @xmath15 the inverse of a symbol @xmath16 where @xmath17 .",
    "the inverse of a word @xmath18 is @xmath19 .",
    "a _ context - free grammar _ ( cfg ) is defined as a tuple @xmath20 , where @xmath8 is the alphabet of @xmath21 , @xmath22 is a finite set of _ non - terminal symbols _ , @xmath23 is the initial non - terminal of @xmath21 , @xmath24 is a finite set of rules of form @xmath25 , where @xmath26 and @xmath27 .",
    "a cfg is deterministic if each non - terminal has at most one rule .",
    "we define the language @xmath28 of a non - terminal @xmath29 recursively : if @xmath30 is a rule of @xmath24 , with @xmath31 words of @xmath32 and @xmath33 non - terminals of @xmath22 , and @xmath34 a word of @xmath35 , then @xmath36 is a word of @xmath28 .",
    "we define the context - free language @xmath37 of a context - free grammar @xmath21 as @xmath38 .    a _ straight - line program _ ( slp )",
    "is a deterministic cfg that produces exactly one word .",
    "the word produced by an slp @xmath20 is called @xmath39 .",
    "we denote the _ longest common prefix of all words _ of a language @xmath40 by @xmath41 .",
    "its _ longest common suffix _ is @xmath42 .",
    "a word @xmath43 is said to be _ periodic _ of period @xmath12 if @xmath12 is the smallest word such that @xmath44 .",
    "a language @xmath40 is said to be _ periodic _ of period @xmath12 if @xmath12 is the smallest word such that @xmath45 .",
    "a language @xmath40 is _ quasi - periodic _ on the left ( resp . on the right ) of handle @xmath43 and period @xmath12 if @xmath12 is the smallest word such that @xmath46 ( resp .",
    "if @xmath47 ) .",
    "a language is quasi - periodic if it is quasi - periodic on the right or left . if @xmath40 is a singleton or empty , it is periodic of period @xmath14 .",
    "iff @xmath40 is periodic , it is quasi - periodic on the left and the right of handle @xmath14 . if @xmath40 is quasi - periodic on the left ( resp .",
    "right ) then @xmath41 ( resp .",
    "@xmath42 ) is the shortest word of @xmath40 .",
    "a _ linear tree - to - word transducer _ ( ltw ) is a tuple @xmath48 where    @xmath0 is a ranked alphabet ,    @xmath49 is an alphabet of output symbols ,    @xmath50 is a finite set of states ,    the axiom @xmath51 is of the form @xmath52 , where @xmath53 and @xmath54 ,    @xmath55 is a set of rules of the form @xmath56 where @xmath57 , @xmath58 of rank @xmath2 , @xmath59 and @xmath60 is a permutation from @xmath61 to @xmath61 .",
    "there is at most one rule per pair @xmath62 .",
    "the partial function @xmath63 of a state @xmath64 on an input tree @xmath65 is defined inductively as    @xmath66 if @xmath67    undefined , if @xmath62 is not defined in @xmath68 .",
    "the partial function @xmath69 of an ltw@xmath70 with axiom @xmath52 on an input tree @xmath71 is defined as @xmath72 .",
    "two ltws@xmath70 and @xmath73 are equivalent if @xmath74 .    a _ sequential tree - to - word transducer _",
    "( stw ) is an ltwwhere for each rule of the form @xmath75 , @xmath60 is the identity on @xmath76 .",
    "we define _ accessibility _ of states as the transitive and reflexive closure of appearance in a rule .",
    "this means state @xmath64 is accessible from itself , and if @xmath77 , and @xmath64 is accessible from @xmath78 , then all states @xmath79 , @xmath80 , are accessible from @xmath78 .",
    "we denote by @xmath81 ( resp .",
    "@xmath82 ) the domain of an ltw@xmath70 ( resp .",
    "a state @xmath64 ) , i.e.  all trees @xmath83 such that @xmath84 is defined ( resp .",
    "@xmath85 ) .",
    "we only consider ltwswith non - empty domains and assume w.l.o.g . that no state @xmath64 in an ltwhas an empty domain by eliminating transitions using states with empty domain .",
    "we denote by @xmath86 ( resp .",
    "@xmath87 ) the range of @xmath69 ( resp .",
    "@xmath63 ) , i.e. the set of all images @xmath84 ( resp .",
    "@xmath85 ) . the languages @xmath86 and @xmath87 for each @xmath53 are all context - free languages .",
    "we call a state @xmath64 _ ( quasi-)periodic _ if @xmath87 is ( quasi-)periodic .    note that a word @xmath43 in a rule of an ltwcan be represented by an slp without changing the semantics of the ltw . therefore a set of slps can be added to the transducer and a word on the right - hand side of a rule can be represented by an slps .",
    "the decidability of equivalence of stwsin polynomial time still holds true with the use of slps .",
    "the advantage of slps is that they may compress the size of a word as the following example shows .",
    "[ ex_expsize ] we define an slp @xmath88 , where @xmath22 is a set @xmath89 , the initial non - terminal is @xmath90 , and @xmath24 is the set of rules @xmath91 , @xmath92 , @xmath93 , @xmath94 , and @xmath95 .",
    "this slp produces the word @xmath96 .",
    "@xmath21 has @xmath97 non - terminals and @xmath97 rules .",
    "thus , @xmath21 produces a word that is exponential in the size of @xmath21 .",
    "the results of this paper require slp compression to avoid exponential blow - up .",
    "slps are used to prevent exponential blow - up in  @xcite , where morphism equivalence on context - free languages is decided in polynomial time .    the equivalence problem for sequential tree - to - word transducer",
    "can be reduced to the morphism equivalence problem for context - free languages  @xcite .",
    "this reduction relies on the fact that stws transform their subtrees in the same order . as ltwsdo",
    "not necessarily transform their subtrees in the same order the result can not be applied on ltwsin general . however ,",
    "if two ltwstransform their subtrees in the same order , then the same reduction can be applied . to formalize that two ltwstransform their subtrees in the same order",
    "we introduce the notion of state co - reachability .",
    "two states @xmath98 and @xmath99 of ltws@xmath100 , @xmath101 , respectively , are co - reachable if there is an input tree such that the two states are assigned to the same node of the input tree in the translations of @xmath100 , @xmath101 , respectively .",
    "two ltwsare _ same - ordered _ if for each pair of co - reachable states @xmath102 and for each symbol @xmath103 , neither @xmath98 nor @xmath99 have a rule for @xmath104 , or if @xmath105 and @xmath106 are rules of @xmath98 and @xmath99 , then @xmath107 .",
    "if two ltwsare same - ordered the input trees can be reordered according to the order in the transformations .",
    "therefore for each ltwa tree - to - tree transducer is constructed that transforms the input tree according to the transformation in the ltw . then all permutations @xmath60 in the ltwsare replaced by the identity .",
    "thus the ltwscan be handled as stwsand therefore the equivalence is decidable in polynomial time .",
    "[ thm_eqsameorder ] the equivalence of same - ordered ltwsis decidable in polynomial time .      in this section",
    "we introduce the two key properties that are used to build a normal form for linear tree - to - word transducers , namely the _ earliest _ and _ erase - ordered _ properties .",
    "the earliest property means that the output is produced as early as possible , i.e.  the longest common prefix ( resp .",
    "suffix ) of @xmath87 is produced in the rule in which @xmath64 occurs , and as left as possible .",
    "the erase - ordered property means that all states that produce no output are ordered according to the input tree and pushed to the right in the rules .",
    "an ltwis in _",
    "earliest form _ if    each state @xmath64 is _ earliest _ , i.e.  @xmath108 ,    and for each rule @xmath77 , for each @xmath109 , @xmath110 .    in  ( * ? ? ?",
    "* lemma 9 ) it is shown that for each ltw@xmath70 an equivalent earliest ltw@xmath73 can be constructed in exponential time . intuitively , if @xmath111 ( resp .",
    "@xmath112 ) then @xmath78 is constructed with @xmath113 ( resp .",
    "@xmath114 ) and @xmath115 is replaced by @xmath116 ( resp .",
    "@xmath117 ) .",
    "if @xmath118 and @xmath119 is a prefix of @xmath120 then we push @xmath119 through @xmath87 by constructing @xmath78 with @xmath121 and replace @xmath122 by @xmath123 .",
    "note that the construction to build the earliest form @xmath73 of an ltw@xmath70 creates a same - ordered @xmath73 .",
    "furthermore , if a state @xmath64 of @xmath70 and a state @xmath78 of @xmath73 are co - reachable , then @xmath78 is an `` earliest '' version of @xmath64 , where some word @xmath43 was pushed out of the production of @xmath64 to make it earliest , and some word @xmath119 was pushed through the production of @xmath64 to ensure that the rules have the right property : there exists @xmath124 such that for all @xmath125 , @xmath126 .",
    "[ thm_earliestltw ] for each ltwan equivalent same - ordered and earliest ltwcan be constructed in exponential time .",
    "the exponential time complexity is caused by a potential exponential size increase in the number of states as it is shown in the following example .",
    "we call a state @xmath64 that produces only the empty word , i.e. @xmath127 , an _ erasing state_. as erasing states do not change the transformation and can occur at any position in a rule we need to fix their position for a normal form",
    ".    an ltw@xmath70 is _ erase - ordered _ if for each rule @xmath77  in @xmath70 , if @xmath79 is erasing then for all @xmath128 , @xmath129 is erasing , @xmath130 and @xmath131 .",
    "we test whether @xmath127 in polynomial time and then reorder a rule according to the erase - ordered property .",
    "if an ltwis earliest it is still earliest after the reordering .",
    "[ lem_eraseordered ] for each ( earliest ) ltwan equivalent ( earliest ) erase - ordered ltwcan be constructed in polynomial time .",
    "consider the rule @xmath132 where @xmath99 translates trees of the form @xmath133 to @xmath134 , @xmath135 translates trees of the form @xmath133 to @xmath136 , @xmath98 translates trees of the form @xmath133 to @xmath14 .",
    "thus the rule is not erase - ordered .",
    "we reorder the rule to the equivalent and erase - ordered rule @xmath137 .",
    "if two equivalent ltwsare earliest and erase - ordered , then they are not necessarily same - ordered .",
    "for example , the rule @xmath138 is equivalent to the rule in the above example but the two rules are not same - ordered .",
    "however , in earliest and erase - ordered ltws , we can characterize the differences in the orders of equivalent rules : just as two words @xmath43 , @xmath119 satisfy the equation @xmath139 if and only if there is a word @xmath12 such that @xmath140 and @xmath141 , the only way for equivalent earliest and erase - ordered ltwsto not be same - ordered is to switch periodic states .",
    "[ thm_coreachequiv ] let @xmath70 and @xmath73 be two equivalent erase - ordered and earliest ltwsand @xmath64 , @xmath78 be two co - reachable states in @xmath70 , @xmath73 , respectively .",
    "let    @xmath142 and @xmath143    be two rules for @xmath64 , @xmath78",
    ". then    for @xmath144 such that @xmath145 , all @xmath79 , @xmath146 , are periodic of the same period and all @xmath131 , @xmath147 ,    for @xmath148 such that @xmath145 , @xmath149 .",
    "as the subtrees that are not same - ordered in two equivalent earliest and erase - ordered states are periodic of the same period the order of these can be changed without changing the semantics .",
    "therefore the order of these subtrees can be fixed such that equivalent earliest and erase - ordered ltwsare same - ordered",
    ". then the equivalence is decidable in polynomial time , see theorem  [ thm_eqsameorder ] . however , building the earliest form of an ltwis in exponential time .    to circumvent this difficulty",
    ", we will show that the first part of theorem  [ thm_coreachequiv ] still holds even on a _ partial normal form _",
    ", where only quasi - periodic states are earliest and the longest common prefix of parts of rules @xmath122 with @xmath150 being quasi - periodic is the empty word .",
    "[ thm_periodic ] let @xmath70 and @xmath73 be two equivalent erase - ordered ltwssuch that    all quasi - periodic states @xmath64 are earliest , i.e.  @xmath151    for each part @xmath152 of a rule where @xmath150 is quasi - periodic , @xmath153    let @xmath64 , @xmath78 be two co - reachable states in @xmath70 , @xmath73 , respectively and    @xmath142 and @xmath143    be two rules for @xmath64 , @xmath78 .",
    "then for @xmath144 such that @xmath145 , all @xmath79 , @xmath146 , are periodic of the same period and all @xmath131 , @xmath147 .",
    "in this section we introduce a partial normal form for ltwsthat does not suffer from the exponential blow - up of the earliest form .",
    "inspired by theorem  [ thm_periodic ] , we wish to solve order differences by switching adjacent periodic states of the same period",
    ". remember that the earliest form of a state @xmath64 is constructed by removing the longest common prefix ( suffix ) of @xmath87 to produce this prefix ( suffix ) earlier .",
    "it follows that all non - earliest states from which @xmath64 can be constructed following the earliest form are quasi - periodic .",
    "we show that building the earliest form of a quasi - periodic state or a part of a rule @xmath122 with @xmath154 being quasi - periodic is in polynomial time . therefore building",
    "the following partial normal form is in polynomial time .",
    "[ def_partialnormalform ] a linear tree - to - word transducer is in _ partial normal form _",
    "if    all quasi - periodic states are earliest ,    it is erase - ordered and    for each rule @xmath77  if @xmath155 is quasi - periodic then @xmath156 is earliest and @xmath157 .      in this part",
    ", we show a polynomial time algorithm to build an earliest form of a quasi - periodic state .",
    "from which an equivalent ltwcan be constructed in polynomial time such that any quasi - periodic state is earliest , i.e.  @xmath108 .",
    "additionally , we show that the presented algorithm can be adjusted to test if a state is quasi - periodic in polynomial time .    as quasi - periodicity on the left and on the right",
    "are symmetric properties we only consider quasi - periodic states of the form @xmath158 ( quasi - periodic on the left ) .",
    "the proofs in the case @xmath159 are symmetric and therefore omitted here . in the end of this section",
    "we shortly discuss the introduced algorithms for the symmetric case @xmath159 .    to build the earliest form of a quasi - periodic state we use the property that each state accessible from a quasi - periodic state is as well quasi - periodic .",
    "however , the periods can be shifted as the following example shows .",
    "[ ex_qpstate ] consider states @xmath64 , @xmath98 and @xmath99 with rules @xmath160 , @xmath161 , @xmath162 , @xmath163 .",
    "state @xmath64 accepts trees of the form @xmath164 , @xmath165 , and produces the language @xmath166 , i.e.   @xmath64 is quasi - periodic of period @xmath167 .",
    "state @xmath98 accepts trees of the form @xmath164 , @xmath168 , and produces the language @xmath169 , i.e.   @xmath98 is quasi - periodic of period @xmath170 .",
    "state @xmath99 accepts trees of the form @xmath164 , @xmath171 and produces the language @xmath172 , i.e.   @xmath99 is ( quasi-)periodic of period @xmath167 .",
    "we introduce two definitions to measure the shift of periods .",
    "we denote by @xmath173}}$ ] the _ from right - to - left shifted word of @xmath43 of shift @xmath2 , @xmath174 _ ,",
    "i.e.   @xmath173 } } = u'^{-1}uu'$ ] where @xmath175 is the prefix of @xmath43 of size @xmath2 . if @xmath176 then @xmath177 = \\rho_{m}[u]$ ] with @xmath178 .    for two quasi - periodic states @xmath102 of period @xmath179 and @xmath180 , respectively ,",
    "we denote the _ shift in their period _ by @xmath181 .",
    "the size of the periods of a quasi - periodic state and the states accessible from this state can be computed from the size of the shortest words of the languages produced by these states .",
    "[ lem_quasi_period ] if @xmath64 is quasi - periodic on the left with period @xmath12 , and @xmath78 accessible from @xmath64 , then @xmath78 is quasi - periodic with period @xmath14 or a shift of @xmath12 .",
    "moreover we can calculate the shift @xmath182 in polynomial time .",
    "we now use these shifts to build , for a state @xmath64 in @xmath70 that is quasi - periodic on the left , a transducer @xmath183 equivalent to @xmath70 where each occurrence of @xmath64 is replaced by its equivalent earliest form , i.e.  a periodic state and the corresponding prefix .",
    "[ earliestalgo ]    let @xmath64 be a state in @xmath70 that is quasi - periodic on the left .",
    "@xmath183 starts with the same states , axiom , and rules as @xmath70 .",
    "* for each state @xmath184 accessible from @xmath64 , we add a copy @xmath185 to @xmath183 .",
    "* for each rule @xmath186 in @xmath70 with @xmath184 accessible from @xmath64 , we add a rule @xmath187 with @xmath188}}$ ] in @xmath183 .",
    "* we delete state @xmath64 in @xmath183 and replace any occurrence of @xmath115 in a rule or the axiom of @xmath183 by @xmath189 .",
    "note that @xmath190 is equivalent to deleting the prefix of size @xmath191 from the word @xmath192 .",
    "intuitively , to build the earliest form of a state @xmath64 that is quasi - periodic on the left we need to push all words and all longest common prefixes of states on the right - hand side of a rule of @xmath64 to the left . pushing a word to the left through a state needs to shift the language produced by this state .",
    "we explain the algorithm in detail on state @xmath64 from example [ ex_qpstate ] .",
    "[ ex_earliest ]    remember that @xmath64 produces the language @xmath193 and @xmath98 , @xmath99 accessible from @xmath64 produce languages @xmath194 and @xmath195 , respectively . therefore @xmath196 , @xmath197 and @xmath198 .",
    "we start with state @xmath64 .",
    "as there is only one rule for @xmath64 the longest common prefix of @xmath64 and the longest common prefix of this rule are the same and therefore eliminated .",
    "@xmath199q_1^e(x_1 ) \\\\      & \\rightarrow \\rho_{s(q , q)}[(aaaabcabc)^{-1 } a aaabcab c]q_1^e(x_1 ) \\\\      & \\rightarrow q_1^e(x_1 ) \\end{aligned}$ ]    as there is only one rule for @xmath98 the argumentation is the same and we get @xmath200 . for the rule @xmath201",
    "we calculate the longest common prefix of the right - hand side @xmath202 that is larger than the longest common prefix of @xmath99 .",
    "therefore we need to calculate the shift @xmath203 as @xmath98 is accessible from @xmath64 in rule @xmath204 and @xmath99 is accessible from @xmath98 in rule @xmath205 .",
    "this leads to the following rule .",
    "@xmath206 q_2^e(x_1 ) \\\\        & \\rightarrow \\rho_{3}[(abc)^{-1 } abcabc ] q_2^e(x_1 ) \\\\        & \\rightarrow abc q_2^e(x_1 ) \\end{aligned}$ ]    as the longest common prefix of @xmath99 is the same as the longest common prefix of the right - hand side of rule @xmath207 we get @xmath208 .",
    "the axiom of @xmath183 is @xmath209 .",
    "[ lem_partial_earliest ] let @xmath70 be an ltwand @xmath64 be a state in @xmath70 that is quasi - periodic on the left .",
    "let @xmath183 be constructed by algorithm  [ earliestalgo ] and @xmath185 be a state in @xmath183 accessible from @xmath210 .",
    "then @xmath70 and @xmath183 are equivalent and @xmath185 is earliest .    to replace all quasi - periodic states by their equivalent earliest form we need to know which states are quasi - periodic .",
    "algorithm  [ earliestalgo ] can be modified to test an arbitrary state for quasi - periodicity on the left in polynomial time .",
    "the only difference to algorithm  [ earliestalgo ] is that we do not know how to compute @xmath211 in polynomial time and @xmath212 does not exist .",
    "we therefore substitute @xmath211 by some smallest word of @xmath213 and we define a mock - shift @xmath214 as follows    @xmath215 for all @xmath64 ,    if @xmath77 , we say @xmath216 , where @xmath217 is a shortest word of @xmath87 ,    if @xmath218 and @xmath219 then @xmath220 .",
    "if several definitions of @xmath221 exist , we use the smallest . if @xmath184 is accessible from a quasi - periodic @xmath64 , then @xmath222 .",
    "[ algo_testqp ] let @xmath223 be an ltwand @xmath64 be a state in @xmath70 .",
    "we build an ltw@xmath224 as follows .    for each state @xmath184 accessible from @xmath64 ,",
    "we add a copy @xmath185 to @xmath225 .",
    "the axiom is @xmath226 where @xmath217 is a shortest word of @xmath87 .    for each rule @xmath186 in @xmath70 with @xmath184 accessible from @xmath64 ,",
    "we add a rule @xmath227 in @xmath225 , where @xmath228 is constructed as follows .",
    "we define @xmath229 , where @xmath34 is a shortest word of @xmath230 .",
    "then we remove from @xmath43 its prefix of size @xmath231 , where @xmath232 is a shortest word of @xmath213 .",
    "we obtain a word @xmath175 .    finally , we set @xmath233 $ ] .    as the construction of algorithms  [ earliestalgo ] and  [ algo_testqp ] are the same if the state @xmath64 is quasi - periodic , @xmath63 and @xmath234 are equivalent if @xmath64 is quasi - periodic .",
    "moreover , @xmath64 is quasi - periodic if @xmath63 and @xmath234 are equivalent .",
    "[ lem_proofalgoqp ] let @xmath64 be a state of an ltw@xmath70 and @xmath225 be constructed by algorithm  [ algo_testqp ] .",
    "then @xmath70 and @xmath225 are same - ordered and @xmath64 is quasi - periodic on the left if and only if @xmath235 and @xmath210 is periodic .    as @xmath70 and @xmath225",
    "are same - ordered we can test the equivalence in polynomial time , cf . theorem  [ thm_eqsameorder ] . moreover testing a cfg for periodicity is in polynomial time and therefore testing a state for quasi - periodicity is in polynomial time .",
    "algorithm  [ algo_testqp ] can be applied to a part @xmath122 of a rule to test @xmath150 for quasi - periodicity on the left . in this case for each rule @xmath77  a rule @xmath236 is added to @xmath70 and each occurrence of the part @xmath122 in a rule of @xmath70 is replaced by @xmath237 .",
    "we then apply the above algorithm to @xmath238 and test @xmath239 and @xmath240 for equivalence and @xmath241 for periodicity .",
    "let @xmath64 be a state with the rules @xmath242 , @xmath243 .",
    "thus , @xmath64 transforms trees of the form @xmath164 , @xmath171 to @xmath244 .",
    "we use algorithm [ algo_testqp ] to test @xmath245 for quasi - periodicity on the left .",
    "as explained above we introduce a state @xmath238 with the rules @xmath246 , @xmath247 .",
    "we now apply algorithm [ algo_testqp ] on @xmath238 .",
    "we build @xmath248 as follows .",
    "the axiom @xmath249 is @xmath250 as the shortest word of @xmath251 is @xmath252 . for the rule",
    "@xmath253 we build @xmath254 as @xmath252 is the shortest word of @xmath238 .",
    "then we obtain @xmath255 and @xmath256 = abc$ ] .",
    "thus we get @xmath257 . for the rule @xmath258 we build @xmath259 and obtain @xmath260 as the shortest word of @xmath238 is @xmath252 . thus we get @xmath261 .",
    "@xmath262 transforms trees of the form @xmath164 to @xmath263 and @xmath238 transforms trees of the form @xmath164 to @xmath264 .",
    "thus , they are equivalent . additionally @xmath241 is periodic with period @xmath167 .",
    "it follows that @xmath265 is quasi - periodic .",
    "we introduced algorithms to test states for quasi - periodicity on the left and to build the earliest form for such states .",
    "these two algorithms can be adapted for states that are quasi - periodic on the right .",
    "there are two main differences .",
    "first , as the handle is on the right the shortest word of a language @xmath40 that is quasi - periodic on the right is @xmath42 .",
    "second , instead of pushing words through a periodic language to the left we need to push words through a periodic language to the right .",
    "hence , we can test each state @xmath64 of an ltw@xmath70 for quasi - periodicity on the left and right .",
    "if the state is quasi - periodic we replace @xmath64 by its earliest form .",
    "algorithm  [ earliestalgo ] and  [ algo_testqp ] run in polynomial time if slps are used .",
    "this is crucial as the shortest word of a cfg can be of exponential size , cf .",
    "example  [ ex_expsize ] . however , the operations that are needed in the algorithms , namely constructing the shortest word of a cfg and removing the prefix or suffix of a word , are in polynomial time using slps , cf .  @xcite .",
    "[ lem_nomorequasi ] let @xmath70 be an ltw .",
    "then an equivalent ltw@xmath73 where all quasi - periodic states are earliest can be constructed in polynomial time .      in this part",
    "we obtain the partial normal form by ordering periodic states of an erase - ordered transducer where all quasi - periodic states are earliest .",
    "ordering means that if the order of the subtrees in the translation can differ , we choose the one similar to the input , i.e.   if @xmath266 and @xmath267 are equivalent , we choose the second order .",
    "we already showed how we can build a transducer where each quasi - periodic state is earliest and therefore periodic .",
    "however , we need to make parts of rules earliest such that periodic states can be switched as the following example shows .",
    "consider the rule @xmath268 where @xmath98 , @xmath99 have the rules @xmath269 , @xmath270 , @xmath271 , @xmath272 .",
    "states @xmath98 and @xmath99 are earliest and periodic but not of the same period as a subword is produced in between .",
    "we replace the non - earliest and quasi - periodic part @xmath273 by their earliest form .",
    "this leads to @xmath274 with @xmath275 , @xmath276 .",
    "hence , @xmath277 and @xmath99 are earliest and periodic of the same period and can be switched in the rule .    to build the earliest form of a quasi - periodic part of a rule @xmath122 each occurrence of this part",
    "is replaced by a state @xmath237 and for each rule @xmath56 a rule @xmath236 is added .",
    "then we apply algorithm  [ earliestalgo ] on @xmath238 to replace @xmath238 and therefore @xmath122 by their earliest form .",
    "iteratively this leads to the following theorem .",
    "[ earliestpart ] for each ltw@xmath70 where all quasi - periodic states are earliest we can build in polynomial time an equivalent ltw@xmath73 such that each part @xmath122 of a rule in @xmath70 where @xmath150 is quasi - periodic is earliest .",
    "in theorem [ thm_periodic ] we showed that order differences in equivalent erase - ordered ltwswhere all quasi - periodic states are earliest and all parts of rules @xmath122 are earliest are caused by adjacent periodic states .",
    "as these states are periodic of the same period and no words are produced in between these states can be reordered without changing the semantics of the ltws .",
    "[ lem_switch ] let @xmath70 be an ltwsuch that    @xmath70 is erase - ordered ,    all quasi - periodic states in @xmath70 are earliest and    each @xmath278 in a rule of @xmath70 that is quasi - periodic is earliest",
    ".    then we can reorder adjacent periodic states @xmath279 of the same period in the rules of @xmath70 such that @xmath280 in polynomial time . the reordering does not change the transformation of @xmath70 .",
    "we showed before how to construct a transducer with the preconditions needed in lemma  [ lem_switch ] in polynomial time .",
    "note that replacing a quasi - periodic state by its earliest form can break the erase - ordered property .",
    "thus we need to replace all quasi - periodic states by its earliest form _ before _ building the erase - ordered form of a transducer",
    ". then lemma  [ lem_switch ] is the last step to obtain the partial normal form for an ltw .",
    "[ thm_normalform ] for each ltwwe can construct an equivalent ltw that is in partial normal form in polynomial time .      it remains to show that the equivalence problem of ltwsin partial normal form is decidable in polynomial time .",
    "the key idea is that two equivalent ltwsin partial normal form are same - ordered .",
    "consider two equivalent ltws@xmath100 , @xmath101 where all quasi - periodic states and all parts of rules @xmath122 with @xmath281 is quasi - periodic are earliest .",
    "in theorem  [ thm_periodic ] we showed if the orders @xmath282 , @xmath283 of two co - reachable states @xmath98 , @xmath99 of @xmath100 , @xmath101 , respectively , for the same input differ then the states causing this order differences are periodic with the same period .",
    "the partial normal form solves this order differences such that the transducers are same - ordered .",
    "[ lem_subtreeorder ] if @xmath70 and @xmath73 are equivalent and in partial normal form then they are same - ordered .    as the equivalence of same - ordered ltwsis decidable in polynomial time ( cf .",
    "theorem  [ thm_eqsameorder ] ) we conclude the following .",
    "the equivalence problem for ltwsin partial normal form is decidable in polynomial time .    to summarize , the following steps run in polynomial time and transform a ltw@xmath70 into its partial normal form .",
    "test each state for quasi - periodicity .",
    "if it is quasi - periodic replace the state by its earliest form .",
    "build the equivalent erase - ordered transducer .",
    "test each part @xmath284 in each rule from right to left for quasi - periodicity on the left . if it is quasi - periodic on the left replace the part by its earliest form .    order adjacent periodic states of the same period according to the input order .",
    "this leads to our main theorem .",
    "[ thm_main ] the equivalence of ltwsis decidable in polynomial time .",
    "the equivalence problem for linear tree - to - word transducers can be decided in polynomial time . to prove this we used a reduction to the equivalence problem between sequential transducers @xcite , or more exactly , to an extension of this result to same - ordered transducers .",
    "this reduction hinges on two points .",
    "first , we showed that the only structural differences between two equivalent earliest linear transducers are caused by periodic languages which are interchangeable .",
    "the structural characteristic of periodic languages has been used in the normalization of stws@xcite .",
    "second , we showed that if building a fully earliest transducer is potentially exponential , our reduction only requires quasi - periodic states to be earliest , which can be done in polynomial time .",
    "the use of the equivalence problem for morphisms on a cfg @xcite and of properties on straight - line programs @xcite is essential here as it was in @xcite .",
    "this leads to further research questions , starting with generalization of this result to all tree - to - words transducers .",
    "furthermore , is it possible that these techniques can be used to decrease the complexity of some problems in other classes of transducer classes , such as top - down tree - to - tree transducers , where the equivalence problem is known to be between exptime - hard and nexptime",
    "?    10    adrien boiret .",
    "normal form on linear tree - to - word transducers . in _ language and automata theory and applications _",
    ", pages 439451 .",
    "springer , 2016 .",
    "joost engelfriet . some open question and recent results on tree transducers and tree languages . in",
    "formal language theory , perspectives and open problems _ , pages 241286 . academic press , 1980 .",
    "joost engelfriet and sebastian maneth .",
    "macro tree translations of linear size increase are mso definable .",
    ", 32(4):9501006 , 2003 .",
    "joost engelfriet and sebastian maneth .",
    "the equivalence problem for deterministic mso tree transducers is decidable .",
    ", 100(5):206212 , 2006 .",
    "joost engelfriet , grzegorz rozenberg , and giora slutzki .",
    "tree transducers , l systems and two - way machines . in _ proceedings of the tenth annual acm symposium on theory of computing _ , pages 6674 .",
    "acm , 1978 .",
    "joost engelfriet and heiko vogler .",
    "macro tree transducers . , 31(1):71146 , 1985 .",
    "grgoire laurence , aurlien lemay , joachim niehren , sawek staworko , and marc tommasi .",
    "normalization of sequential top - down tree - to - word transducers . in _ language and automata theory and applications _ , pages 354365 .",
    "springer , 2011 .",
    "grgoire laurence , aurlien lemay , joachim niehren , slawek staworko , and marc tommasi .",
    "learning sequential tree - to - word transducers . in _ language and automata theory and applications _ ,",
    "pages 490502 , 2014 .",
    "aurlien lemay , sebastian maneth , and joachim niehren .",
    "a learning algorithm for top - down xml transformations . in _ proceedings of the twenty - ninth acm sigmod - sigact - sigart symposium on principles of database systems _ ,",
    "pages 285296 , 2010 .",
    "markus lohrey .",
    "algorithmics on slp - compressed strings : a survey . , 4(2):241299 , 2012 .",
    "markus lohrey . .",
    "springer , 2014 .",
    "sebastian maneth and helmut seidl .",
    "deciding equivalence of top - down xml transformations in polynomial time . in _",
    "programming language technologies for xml _ , pages 7379 , 2007 .",
    "wojciech plandowski . .",
    "phd thesis , warsaw university , 1995 .",
    "helmut seidl , sebastian maneth , and gregor kemper .",
    "equivalence of deterministic top - down tree - to - string transducers is decidable . in _",
    "ieee 56th annual symposium on foundations of computer science _ , pages 943962 , 2015 .",
    "sawomir staworko , grgoire laurence , aurlien lemay , and joachim niehren .",
    "equivalence of deterministic nested word to word transducers . in",
    "_ fundamentals of computation theory _ , pages 310322 .",
    "springer , 2009 .",
    "let @xmath70 and @xmath73 be two equivalent erase - ordered ltwssuch that              let @xmath285 and @xmath286 be the equivalent earliest transducer of @xmath70 and @xmath73 , respectively , such that @xmath70 and @xmath285 as well as @xmath73 and @xmath286 are same - ordered ( cf . theorem [ thm_earliestltw ] ) .",
    "let @xmath291 be the first index such that @xmath292 .",
    "following theorem  [ thm_coreachequiv ] , we have @xmath293 such that @xmath294 and @xmath295 and all @xmath296 , @xmath297 are periodic with the same period .",
    "let @xmath64 and @xmath78 be the states in @xmath70 and @xmath73 , respectively , from which the co - reachable states @xmath210 and @xmath287 were constructed with the earliest construction proposed by @xcite . from the earliest construction",
    "it follows that @xmath64 and @xmath78 are co - reachable .",
    "since the construction preserves the rule structure , we have : @xmath298 @xmath299    the earliest construction gives us that for all @xmath300 , @xmath301 for some @xmath302 .",
    "this means that if @xmath296 is periodic , then @xmath303 is quasi periodic in its non - earliest form .",
    "the same is true for all @xmath304 .",
    "however , the first property we supposed of @xmath70 and @xmath73 implies that all those @xmath303 and @xmath304 that are quasi - periodic are not only quasi periodic , but periodic .",
    "consider a part of the rule @xmath305 that is periodic in the earliest form and therefore quasi - periodic in the non - earliest form .",
    "the first condition gives us that @xmath306 are periodic .",
    "however , then the words @xmath307 are not necessarily empty . as the part @xmath305 is quasi - periodic we know that each part @xmath308 , @xmath309 is quasi - periodic .",
    "then the second condition of this theorem guarantees that the parts @xmath308 , @xmath309 are not only quasi - periodic , but periodic .",
    "from which it follows that the words @xmath307 are empty .",
    "as the part @xmath305 is periodic and @xmath307 are empty we get that @xmath306 are periodic of the same period .",
    "the same holds true for states of a part of the rule @xmath310 that is periodic in the earliest form .",
    "this proof works by induction .",
    "we first show that if @xmath367 has @xmath2 , @xmath368 quasi - periodic states that are non - earliest , then we can build in polynomial time an equivalent ltw@xmath73 with @xmath369 non - earliest quasi - periodic states . using algorithm [ algo_testqp ]",
    "we choose @xmath64 as a non - earliest quasi - periodic state of @xmath50 .",
    "we apply algorithm  [ earliestalgo ] on state @xmath64 and get @xmath183 , whose set of state is of form @xmath370 , where @xmath371 is the set of states @xmath185 with @xmath184 accessible from @xmath64 that are created by algorithm  [ earliestalgo ] . according to lemma  [ lem_partial_earliest ]",
    "all the states of @xmath371 are periodic .",
    "this means that the non - earliest quasi - periodic states of @xmath183 are all in @xmath372 .",
    "since @xmath50 has @xmath2 non - earliest quasi - periodic states , including @xmath64 , @xmath183 has @xmath369 .",
    "now we can build @xmath100 equivalent to @xmath70 with @xmath369 non - earliest quasi - periodic states , then @xmath101 equivalent to @xmath100 ( hence to @xmath70 ) with @xmath373 non - earliest quasi - periodic states , and so on .",
    "finally we get @xmath374 equivalent to @xmath70 with no non - earliest quasi - periodic state .",
    "each step is in polynomial time and the number @xmath2 is smaller than the number of states in @xmath70 . for each occurence of a state on the right - hand side of a rule",
    "there is at most one new state needed in the construction .",
    "therefore the size increase of the transducer is only polynomial . to avoid the construction of equivalent states",
    "@xmath64 should be considered before @xmath78 if @xmath78 is accessible from @xmath64 .",
    "if @xmath64 is accessible from @xmath78 and @xmath78 is accessible from @xmath64 then @xmath64 is considered first if there is a acyclic way from the axiom to @xmath64 that contains @xmath78 .    in the above proof we assumed that algorithm [ algo_testqp ] and [ earliestalgo ] run in polynomial time . in both algorithms",
    "it is crucial that slps are used to represent the shortest words of the languages produced by the states of a transducer as these can be of exponential size , cf .",
    "example [ ex_expsize ] . instead of these uncompressed words nonterminals representing these words as",
    "slps are inserted in the transducers .",
    "all operations that are needed in the algorithms , namely constructing a slp for the shortest word of an cfg , concatenation of slps , shifting the word produced by an slp and removing the prefix or suffix of an slp are in polynomial time  @xcite .",
    "for each ltw@xmath70 where all quasi - periodic states are earliest we can build in polynomial time an equivalent ltw@xmath73 such that each part @xmath122 of a rule in @xmath70 where @xmath150 is quasi - periodic is earliest .",
    "first , we show that one part @xmath122 of a rule where @xmath154 is quasi - periodic on the left can be replaced by their earliest form",
    ". we can apply algorithm [ algo_testqp ] and [ earliestalgo ] on a part @xmath122 of a rule that is quasi - periodic by replacing @xmath122 by a new state @xmath238 .",
    "therefore each occurrence of @xmath122 in any rule is replaced by @xmath237 and for each rule @xmath56 a rule @xmath236 is added .",
    "then we can apply algorithm [ algo_testqp ] on @xmath238 to test @xmath122 for quasi - periodicity on the left .",
    "if @xmath375 is quasi - periodic on the left we apply algorithm [ earliestalgo ] on @xmath238 to replace @xmath122 by their earliest form .",
    "second , we show that for any rule of an ltwan equivalent rule can be constructed such that all parts @xmath122 in the rule where @xmath154 is quasi - periodic on the left are earliest .",
    "consider a rule @xmath77 .",
    "replacing a part @xmath122 with @xmath154 is quasi - periodic by their earliest form as described above means that all occurrences of @xmath237 are replaced by @xmath376 .",
    "thus , to replace all parts of a rule that produce quasi - periodic languages by their earliest form the testing and replacing should be done from right to left as the earliest form may introduce new words on the left of the replaced state . for a rule @xmath77we",
    "start by testing @xmath377 for quasi - periodicity on the left and replace the part if necessary as described above . if so , we obtain @xmath378 and continue with testing @xmath379 for quasi - periodicity on the left . if not , then we continue with testing @xmath380 for quasi - periodicity on the left . following this construction for the rule from right to left , i.e. from index @xmath2 to @xmath311 , leads to an equivalent rule where all parts @xmath122 with @xmath154 is quasi - periodic on the left are earliest .",
    "the construction runs in polynomial time as algorithm [ algo_testqp ] and [ earliestalgo ] run in polynomial time ( for details see the proof of theorem [ lem_nomorequasi ] ) and for each rule @xmath77the algorithms are applied at most @xmath2 times .",
    "let @xmath70 and @xmath73 be two linear tree - to - word transducers .",
    "we construct equivalent ltws@xmath100 and @xmath403 , respectively , such that @xmath100 and @xmath101 are in partial normal form following theorem [ thm_normalform ] .",
    "we then test if @xmath100 and @xmath403 are same - ordered .",
    "if they are same - ordered we test @xmath100 and @xmath403 for equivalence , see theorem  [ thm_eqsameorder ] . if @xmath100 and @xmath403 are not same - ordered we know following lemma [ lem_subtreeorder ] that @xmath100 and @xmath403 are not equivalent and therefore @xmath70 and @xmath73 are not equivalent .",
    "if @xmath64 is quasi - periodic on the left with period @xmath12 , and @xmath78 accessible from @xmath64 , then @xmath78 is quasi - periodic with period @xmath14 or a shift of @xmath12 .",
    "moreover we can calculate the shift @xmath182 in polynomial time .",
    "this is done as an iterative proof with the following elementary step : if @xmath56 , and @xmath64 is quasi - periodic on the left with handle @xmath43 and period @xmath12 , then for all @xmath291 between @xmath311 and @xmath2 , @xmath79 is quasi - periodic with period @xmath14 or a shift of @xmath12 .",
    "we pick @xmath312 a smallest word produced by state @xmath129 .",
    "we then have that for all @xmath313 , @xmath314 .",
    "if we call @xmath315 and @xmath316 , we obtain that @xmath317 .",
    "since @xmath318 , we can say @xmath319 . it is a classical result of regular languages that @xmath320 is either empty , a singleton , or a quasi - periodic language of period @xmath321 . by further removing a prefix to this language the period does not change .",
    "hence , we get that @xmath322 is also either empty , a singleton , or a quasi - periodic language of period @xmath321 .",
    "this means that @xmath79 is quasi - periodic , of period @xmath14 , or @xmath321 , which is a shift of @xmath64 .",
    "the size of @xmath323 can easily be computed from the sizes of the minimal productions of states @xmath129 .",
    "we build the cfg for @xmath324 .",
    "then , finding the smallest production of @xmath129 and their size is finding the smallest word of @xmath324 and their size , which is a polynomial problem on cfg .    to show that the shifts of the periods can be calculated in polynomial time",
    "we show that shifts are additive in nature : if @xmath98 has period @xmath12 , @xmath98 and @xmath99 are of shifted period , and @xmath99 and @xmath325 are of shifted period , then @xmath98 and @xmath325 are of shifted period , and @xmath326",
    ".    if @xmath98 is of period @xmath12 , then @xmath99 is of period @xmath327 , where @xmath232 is the suffix of @xmath12 of size @xmath328 .",
    "if @xmath99 is of period @xmath329 , then @xmath99 is of period @xmath330 , where @xmath331 is the suffix of @xmath329 of size @xmath332 .",
    "we then have that @xmath333 , where @xmath334 is of size @xmath335 .",
    "let @xmath70 be an ltwand @xmath64 be a state in @xmath70 that is quasi - periodic on the left .",
    "let @xmath183 be constructed by algorithm [ earliestalgo ] and @xmath185 be a state in @xmath183 accessible from @xmath210 .",
    "then @xmath70 and @xmath183 are equivalent and @xmath185 is earliest .    to show that @xmath70 and @xmath183 are equivalent",
    "we show that @xmath336 , for all @xmath337 . to show that @xmath336 we show that",
    ", for all states @xmath184 accessible from @xmath64 and all @xmath338 , @xmath339 and @xmath340}}$ ] are equivalent as then @xmath341 } } \\\\ & = { { \\sf lcp}}(q ) { { \\sf lcp}}(q)^{-1 } { \\llbracket m \\rrbracket}_{q}(t ) \\\\ & = { \\llbracket m \\rrbracket}_q(t).\\end{aligned}\\ ] ] to show that @xmath339 = @xmath340}}$ ] for all @xmath184 accessible from @xmath64 and all @xmath342 , we prove that @xmath339 is of the same period and of the same size as @xmath340}}$ ] . from lemma [ lem_quasi_period ]",
    "we know that all @xmath184 accessible from @xmath64 are quasi - periodic and therefore @xmath343 is periodic .",
    "hence , if @xmath339 and @xmath340}}$ ] are of the same period and of the same size then they are equivalent .    to show that @xmath339 and @xmath340}}$ ] have the same size , for all @xmath338 , we show that @xmath344 the proof is by induction on the input tree . for an input tree @xmath71 with no subtrees we have @xmath345| } }",
    "\\\\    & = { \\ensuremath{|u_0| } } + \\dots + { \\ensuremath{|u_n| } } - { \\ensuremath{|{{\\sf lcp}}(p)| } } \\\\    & = { \\ensuremath{|{\\llbracket m \\rrbracket}_{p}(t)| } } - { \\ensuremath{|{{\\sf lcp}}(p)| } } \\\\    & = { \\ensuremath{|{\\ensuremath{\\rho_{{\\ensuremath{s(q , p)}}}\\left[{{\\sf lcp}}(p)^{-1}{\\llbracket m \\rrbracket}_{p}(t)\\right]}}|}}.\\end{aligned}\\ ] ] thus , the base casef holds .",
    "consider an input tree @xmath346 .",
    "then @xmath339 is of size @xmath347 with @xmath348|}}$ ] . since shifting a word",
    "preserves its length , we have @xmath349 thus , we have to show that @xmath350}}|}}.\\ ] ] by induction we have @xmath351 .",
    "thus , we have @xmath352}}|}}.\\end{aligned}\\ ] ]    to show that @xmath339 and @xmath340}}$ ] have the same period , for all @xmath338 , we show that @xmath353 and @xmath340 } } \\in u^*$ ] where @xmath354 . from lemma [ lem_quasi_period ] it follows that @xmath340 } } \\in u^*$ ] .",
    "to proof that @xmath353 is by induction on the input tree . for an input tree @xmath71 with no subtrees we have @xmath355}}$ ] . from lemma [ lem_quasi_period ]",
    "we know that @xmath356 is quasi - periodic of period @xmath357 where @xmath358 and @xmath175 is of size @xmath212 .",
    "thus , @xmath359 and therefore @xmath360 } } \\in ( u'u'')^ * = u^*$ ] .",
    "hence , the base case holds .",
    "consider an input tree @xmath346 .",
    "then we have @xmath361 } } { \\llbracket m^q \\rrbracket}_{q_1^e}(s_{\\sigma(1 ) } ) \\dots { \\llbracket m^q \\rrbracket}_{q_n^e}(s_{\\sigma(n)})$ ] . by induction , @xmath362 . with the same argumentation as in the base case @xmath363 with @xmath358 and @xmath175",
    "is of size @xmath212 .",
    "thus , @xmath364 } } \\in ( u''u')^ * = u^*$ ] and therefore we get @xmath365 .",
    "let @xmath64 be a state of an ltw@xmath70 and @xmath225 be constructed by algorithm [ algo_testqp ] .",
    "then @xmath70 and @xmath225 are same - ordered and @xmath64 is quasi - periodic on the left if and only if @xmath235 and @xmath210 is periodic .",
    "we show that @xmath64 is quasi - periodic on the left if and only if @xmath235 and @xmath210 is periodic .",
    "if @xmath64 is quasi - periodic on the left the transformation in algorithm [ algo_testqp ] is the same as in algorithm [ earliestalgo ] .",
    "therefore @xmath235 and @xmath210 is periodic .",
    "the proof is by contradiction .",
    "suppose that @xmath381 are two equivalent ltwsin partial normal form that are not same - ordered .",
    "we consider co - reachable state @xmath64 and @xmath78 of @xmath70 and @xmath73 that are not same - ordered .",
    "then for @xmath77 and @xmath382 we choose @xmath383 , @xmath384 such that @xmath385 is minimal under the following constraints        as the set of indices of @xmath390 and @xmath391 between @xmath291 and @xmath392 is the same but in different orders there is @xmath393 , @xmath297 such that @xmath394 or @xmath395 . w.l.o.g .",
    "we assume that @xmath394 .",
    "additionally , from the above constraints it follows that there is @xmath396 , @xmath397 such that @xmath398 . as the partial normal form satisfies the preconditions of theorem  [ thm_periodic ] we get that @xmath399 are periodic with the same period and @xmath400 are empty .",
    "thus , @xmath401 is quasi - periodic",
    ". then it follows from the partial normal form that @xmath402 , a contradiction ."
  ],
  "abstract_text": [
    "<S> we show that the equivalence of deterministic linear top - down tree - to - word transducers is decidable in polynomial time . </S>",
    "<S> linear tree - to - word transducers are non - copying but not necessarily order - preserving and can be used to express xml and other document transformations . </S>",
    "<S> the result is based on a partial normal form that provides a basic characterization of the languages produced by linear tree - to - word transducers . </S>"
  ]
}