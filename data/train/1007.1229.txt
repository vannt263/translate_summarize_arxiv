{
  "article_text": [
    "let @xmath5 be a function of @xmath6 variables @xmath7 where @xmath8 ; thus @xmath9 .",
    "we call elements of @xmath10 _ labels _ , and the argument of @xmath0 a _",
    "labeling_. denote @xmath11 to be the set of nodes .",
    "we will consider functions @xmath0 satisfying @xmath12 where binary operations @xmath13 ( expressed component - wise via operations @xmath14 ) are defined below .",
    "there are several known cases in which function @xmath0 can be minimized in polynomial time in the value oracle model .",
    "the following two cases will be of particular relevance :    * _ @xmath4-convex functions _ : @xmath15 where @xmath16 is integer , @xmath17 , @xmath18 .",
    "property   is then called _ discrete midpoint convexity _  @xcite . * _ bisubmodular functions _ : @xmath19 , @xmath20 , @xmath21 .    in this paper",
    "we introduce a new class of functions which includes the two classes above as special cases .",
    "we assume that labels in each set @xmath10 are nodes of a tree @xmath22 with a designated root @xmath23 .",
    "define a partial order @xmath24 on @xmath10 as follows : @xmath25 if @xmath26 is an ancestor of @xmath27 , i.e.  @xmath26 lies on the path from @xmath27 to @xmath28 ( @xmath29 ) . for two labels @xmath29 let @xmath30 $ ] be unique path from @xmath26 to @xmath27 in @xmath22 , @xmath31 be the number of edges in this path , and @xmath32 $ ] for integer @xmath33 be the @xmath34-th node of this path so that @xmath35=a$ ] and @xmath36=b$ ] .",
    "if @xmath37 then we set by definition @xmath32=b$ ] .    with this notation , we can now define @xmath38 , @xmath39 as the unique pair of labels satisfying the following two conditions : ( 1 ) @xmath40,\\calp[a\\rightarrow b,\\lceil\\frac{d}{2}\\rceil]\\}$ ] where @xmath41 , and ( 2 ) @xmath42 ( figure  [ fig : trees](a ) ) .",
    "we call functions @xmath0 satisfying condition   with such choice of @xmath43 _ strongly tree - submodular_. clearly , if each @xmath22 is a chain with nodes @xmath44 and @xmath45 being the root ( figure  [ fig : trees](b ) ) then strong tree - submodularity is equivalent to @xmath4-convexity . furthermore , if each @xmath22 is the tree shown in figure  [ fig : trees](c ) then strong tree - submodularity is equivalent to bisubmodularity",
    ".    the main result of this paper is the following    if each tree @xmath22 is binary , i.e.  each node has at most two children , then a strongly tree - submodular function @xmath0 can be minimized in time polynomial in @xmath6 and @xmath46 .",
    "[ th : polynomiality ]    [ cols=\"^,^ \" , ]     * weak tree - submodularity  * we will also study alternative operations on trees , which we denote as @xmath47 and @xmath48 . for labels",
    "@xmath29 we define @xmath49 as their highest common ancestor , i.e.  the unique node on the path @xmath30 $ ] which is an ancestor of both @xmath26 and @xmath27 .",
    "the label @xmath50 is defined as the unique label on the path @xmath30 $ ] such that the distance between @xmath26 and @xmath50 is the same as the distance between @xmath49 and @xmath27 ( figure  [ fig : trees](a ) ) .",
    "we say that function @xmath0 is _ weakly tree - submodular _ if it satisfies @xmath51 we will show that strong tree - submodularity   implies weak tree - submodularity , which justifies the terminology .",
    "if all trees are chains shown in figure  [ fig : trees](b ) ( @xmath52 with @xmath45 being the root ) then @xmath47 and @xmath48 correspond to the standard operations `` meet '' and  join ",
    "( @xmath53 and @xmath54 ) on an integer lattice .",
    "it is well - known that in this case weakly tree - submodular functions can be minimized in time polynomial in @xmath6 and @xmath55  @xcite . in section  [ sec : weak ]",
    "we give a slight generalization of this result ; namely , we allow trees shown in figure  [ fig : trees](d ) .      studying operations @xmath56 that give rise to tractable optimization problems received a considerable attention in the literature .",
    "some known examples of such operations are reviewed below . for simplicity",
    ", we assume that domains @xmath10 ( and operations @xmath56 ) are the same for all nodes : @xmath57 for some finite set @xmath58 .    * submodular functions on lattices  * the first example that we mention is the case when @xmath58 is a distributive lattice and @xmath3 are the meet and joint operations on this lattice .",
    "functions that satisfy   for this choice of @xmath58 and @xmath3 are called _ submodular functions _ on @xmath58 ; it is well - known that they can be minimized in strongly polynomial time  @xcite .",
    "recently , researchers considered submodular functions on non - distributive lattices .",
    "it is known that a lattice is non - distributive if it contains as a sublattice either the pentagon @xmath59 or the diamond @xmath60 .",
    "krokhin and larose  @xcite proved tractability for the pentagon case , using nested applications of a submodular minimization algorithm .",
    "the case of the diamond was considered by kuivinen  @xcite , who proved pseudo - polynomiality of the problem .",
    "the case of general non - distributive lattices is still open .",
    "* @xmath4-convex functions  * the concept of @xmath4-convexity was introduced by fujishige and murota  @xcite as a variant of @xmath61-convexity by murota  @xcite .",
    "@xmath4-convexity is equivalent to the combination of submodularity and integral convexity  @xcite ( see @xcite for details ) .",
    "the fastest known algorithm for minimizing @xmath4-convex functions is the _ steepest descent _ algorithm of murota  @xcite .",
    "murota proved in  @xcite that algorithm s complexity is @xmath62 where @xmath63 and @xmath64 is the complexity of a submodular minimization algorithm for a function with @xmath6 variables .",
    "the analysis of kolmogorov and shioura  @xcite improved the bound to @xmath65 . in section  [ sec : alg ] we review murota s algorithm ( or rather its version without scaling that has complexity @xmath66 . )",
    "note , the class of @xmath4-convex functions is a subclass of submodular functions on a totally ordered set @xmath67 .    *",
    "bisubmodular functions  * bisubmodular functions were introduced by chandrasekaran and kabadi as rank functions of _ ( poly-)pseudomatroids _  @xcite .",
    "independently , bouchet  @xcite introduced the concept of @xmath68-matroids which is equivalent to pseudomatroids .",
    "bisubmodular functions and their generalizations have also been considered by qi  @xcite , nakamura  @xcite , bouchet and cunningham  @xcite and fujishige  @xcite .",
    "it has been shown that some submodular minimization algorithms can be generalized to bisubmodular functions .",
    "qi  @xcite showed the applicability of the ellipsoid method .",
    "fujishige and iwata  @xcite developed a weakly polynomial combinatorial algorithm for minimizing bisubmodular functions with complexity @xmath69 where @xmath70 is the number of calls to the evaluation oracle and @xmath71 is an upper bound on function values .",
    "mccormick and fujishige  @xcite presented a strongly combinatorial version with complexity @xmath72 , as well as a @xmath73 fully combinatorial variant that does not use divisions .",
    "the algorithms in @xcite can also be applied for minimizing a bisubmodular function over a _ signed ring family _ , i.e.  a subset @xmath74 closed under @xmath75 and @xmath76 .",
    "* valued constraint satisfaction and multimorphisms  * our paper also fits into the framework of _ valued constraint satisfaction problems _ ( vcsps )  @xcite . in this framework",
    "we are given a _ language _",
    "@xmath77 , i.e.  a set of cost functions @xmath78 where @xmath58 is a fixed discrete domain and @xmath0 is a function of arity @xmath79 ( different functions @xmath80 may have different arities ) .",
    "@xmath77-instance _ is any function @xmath81 that can be expressed as a finite sum of functions from @xmath77 : @xmath82 where @xmath83 is a finite set of terms , @xmath84 is a function of arity @xmath85 , and @xmath86 are indexes in @xmath87 .",
    "a finite language @xmath77 is called _ tractable _ if any @xmath77-instance can be minimized in polynomial time , and _ np - hard _ if this minimization problem is np - hard .",
    "these definitions are extended to infinite languages @xmath77 as follows : @xmath77 is called tractable if any finite subset @xmath88 is tractable , and np - hard if there exists a finite subset @xmath88 which is np - hard .",
    "classifying the complexity of different languages has been an active research area . a major open question in this line of research",
    "is the _ dichotomy conjecture _ of feder and vardi ( formulated for the _ crisp _ case ) , which states that every constraint language is either tractable or np - hard  @xcite .",
    "so far such dichotomy results have been obtained for some special cases , as described below .",
    "a significant progress has been made in the * crisp * case , i.e.  when @xmath77 only contains functions @xmath89 .",
    "the problem is then called _ constraint satisfaction _ ( csp ) .",
    "the dichotomy is known to hold for languages with a 2-element domain ( schaefer  @xcite ) , languages with a 3-element domain ( bulatov  @xcite ) , conservative languages is called conservative if it contains all unary cost functions @xmath90 @xcite . a general - valued language",
    "is called conservative if it contains all unary cost functions @xmath91 @xcite . ]",
    "( bulatov @xcite ) , and languages containing a single relation without sources and sinks ( barto  @xcite ) .",
    "all dichotomy theorems above have the following form : if all functions in @xmath77 satisfy a certain condition given by one or more _ polymorphisms _ then the language is tractable , otherwise it is np - hard .    for general vcsps the dichotomy has been shown to hold for boolean languages , i.e.  languages with a 2-element domain ( cohen  @xcite ) , conservative languages ( kolmogorov and ivn  @xcite , who generalized previous results by deineko  @xcite and takhanov @xcite ) , and @xmath92-valued languages with a 4-element domain ( jonsson  @xcite ) . in these examples tractable subclasses are characterized by one or more _ multimorphisms _ , which are generalizations of polymorphisms .",
    "a multimorphism of arity @xmath93 over @xmath58 is a tuple @xmath94 where @xmath95 is an operation @xmath96 .",
    "language @xmath77 is said to admit multimorphism @xmath94 if every function @xmath80 satisfies @xmath97 for all labelings @xmath98 with @xmath99 , @xmath100 , @xmath101 .",
    "( the pair of operations @xmath56 used in   is an example of a binary multimorphism . )",
    "the tractable classes mentioned above ( for @xmath102 ) are characterized by _",
    "complementary pairs of stp and mjn _",
    "multimorphisms  @xcite ( that generalized _ symmetric tournament pair ( stp ) _",
    "multimorphisms  @xcite ) , and _",
    "1-defect chain _",
    "multimorphisms  @xcite ( that generalized tractable weak - tree submodular functions in section [ sec : weak ] originally introduced in  @xcite ) .",
    "to make further progress on classifying complexity of vcsps , it is important to study which multimorphisms lead to tractable optimisation problems .",
    "operations @xmath56 and @xmath103 introduced in this paper represent new classes of such multimorphisms : to our knowledge , previously researchers have not considered multimorphisms defined on trees .    * combining multimorphisms  * finally , we mention that some constructions , namely _ cartesian products _ and _ maltstev products _ , can be used for obtaining new tractable classes of binary multimoprhisms from existing ones  @xcite .",
    "note , krokhin and larose  @xcite formulated these constructions only for lattice multimorphisms @xmath56 , but the proof in  @xcite actually applies to arbitrary binary multimorphisms @xmath56 .",
    "it is known that for @xmath4-convex functions local optimality implies global optimality  @xcite .",
    "we start by generalizing this result to strongly tree - submodular functions .",
    "let us define the following `` local '' neighborhoods of labeling @xmath104 : @xmath105 where @xmath106 means that @xmath107 for all @xmath108 , and @xmath109 is the @xmath110-distance between @xmath111 and @xmath112 .",
    "clearly , the restriction of @xmath0 to @xmath113 is a submodular function , and the restriction of @xmath0 to @xmath114 is bisubmodular assuming that each tree @xmath22 is binary has less than two children in @xmath22 then variable s domain after restriction will be a strict subset of @xmath115 .",
    "therefore , we may need to use a bisubmodular minimization algorithm over a signed ring familiy @xmath116  @xcite . ] .",
    "suppose that _",
    "_ then @xmath111 is a global minimum of @xmath0 .",
    "[ prop : local ]    first , let us prove that @xmath118 .",
    "let @xmath119 be a minimizer of @xmath0 in @xmath120 , and denote @xmath121 .",
    "we treat set @xmath122 as a tree with root @xmath123 .",
    "clearly , the restriction of @xmath0 to @xmath124 is an @xmath4-convex function under the induced operations @xmath75 , @xmath76 .",
    "it is known that for @xmath4-convex functions optimality of @xmath111 in sets @xmath125 and @xmath126 suffices for optimality of @xmath111 in @xmath124  ( * ? ? ?",
    "* theorem 7.14 ) , therefore @xmath127 .",
    "this proves that @xmath118 .",
    "let us now prove that @xmath111 is optimal in @xmath128 .",
    "suppose not , then there exists @xmath129 with @xmath130 . among such labelings ,",
    "let us choose @xmath112 with the minimum distance @xmath131 .",
    "we must have @xmath132 , so @xmath133 .",
    "clearly , @xmath134 and @xmath135 .",
    "strong tree - submodularity and the fact that @xmath130 imply that the cost of at least one of the labelings @xmath136 , @xmath137 is smaller than @xmath138 .",
    "this contradicts to the choice of @xmath112 .",
    "suppose that each tree @xmath22 is binary .",
    "the proposition shows that a greedy technique for computing a minimizer of @xmath0 would work .",
    "we can start with an arbitrary labeling @xmath104 , and then apply iteratively the following two steps in some order :    * compute minimizer @xmath139 by invoking a submodular minimization algorithm , replace @xmath111 with @xmath140 if @xmath141 . *",
    "compute minimizer @xmath142 by invoking a bisubmodular minimization algorithm , replace @xmath111 with @xmath143 if @xmath144 .",
    "the algorithm stops if neither step can decrease the cost .",
    "clearly , it terminates in a finite number of steps and produces an optimal solution .",
    "we will now discuss how to obtain a polynomial number of steps .",
    "we denote @xmath63 .      for @xmath4-convex functions the _ steepest descent _",
    "algorithm described above was first proposed by murota  @xcite , except that in step 2 a submodular minimization algorithm was used .",
    "algorithm actually computes both of @xmath140 and @xmath143 for the same @xmath111 and then chooses a better one by comparing costs @xmath145 and @xmath146 .",
    "a slight variation was proposed by kolmogorov and shioura  @xcite , who allowed an arbitrary order of steps .",
    "kolmogorov and shioura also established a tight bound on the number of steps of the algorithm by proving the following theorem .",
    "suppose that each tree @xmath22 is a chain .",
    "for a labeling @xmath147 define    @xmath148 \\ } , opt^-[{\\mbox{\\boldmath $ x$}}]\\!=\\!\\arg\\!\\min \\{f({\\mbox{\\boldmath $ y$ } } ) |{\\mbox{\\boldmath $ y$}}\\!\\in\\!\\d,{\\mbox{\\boldmath $ y$}}\\preceq{\\mbox{\\boldmath $ x$}}\\ } \\ ; ~ \\label{eq : rho : a } \\\\ ~\\!\\!\\!\\!\\!\\!\\!\\!\\rho^+({\\mbox{\\boldmath $ x$}})\\!=\\!\\min \\ { \\rho({\\mbox{\\boldmath $ x$}},{\\mbox{\\boldmath $ y$ } } )   |   { \\mbox{\\boldmath $ y$}}\\!\\in\\ ! opt^{+}[{\\mbox{\\boldmath $ x$ } } ] \\ } , opt^+[{\\mbox{\\boldmath $ x$}}]\\!=\\!\\arg\\!\\min \\{f({\\mbox{\\boldmath $ y$ } } ) |{\\mbox{\\boldmath $ y$}}\\!\\in\\!\\d,{\\mbox{\\boldmath $ y$}}\\succeq{\\mbox{\\boldmath $ x$}}\\ } \\ ; ~ \\label{eq : rho : b } \\else \\rho^-({\\mbox{\\boldmath $ x$}})=\\min \\ { \\rho({\\mbox{\\boldmath $ x$}},{\\mbox{\\boldmath $ y$ } } ) \\ : | \\ : { \\mbox{\\boldmath $ y$}}\\in opt^{-}[{\\mbox{\\boldmath $ x$ } } ] \\ } , \\quad opt^-[{\\mbox{\\boldmath $ x$}}]=\\arg \\min \\{f({\\mbox{\\boldmath $ y$ } } ) \\:|\\:{\\mbox{\\boldmath $ y$}}\\in\\d,{\\mbox{\\boldmath $ y$}}\\preceq{\\mbox{\\boldmath $ x$}}\\ } \\label{eq : rho : a } \\\\ \\rho^+({\\mbox{\\boldmath $ x$}})=\\min \\ { \\rho({\\mbox{\\boldmath $ x$}},{\\mbox{\\boldmath $ y$ } } ) \\ : | \\ : { \\mbox{\\boldmath $ y$}}\\in opt^{+}[{\\mbox{\\boldmath $ x$ } } ] \\ } , \\quad opt^+[{\\mbox{\\boldmath $ x$}}]=\\arg \\min \\{f({\\mbox{\\boldmath $ y$ } } ) \\:|\\:{\\mbox{\\boldmath $ y$}}\\in\\d,{\\mbox{\\boldmath $ y$}}\\succeq{\\mbox{\\boldmath $ x$}}\\ } \\label{eq : rho : b } \\fi\\end{aligned}\\ ] ]    [ eq : rho ]    * applying step ( 1 ) or ( 2 ) to labeling @xmath149 does not increase @xmath150 and @xmath151 . * if @xmath152 then applying step ( 1 ) to @xmath111 will decrease @xmath150 by 1 . *",
    "if @xmath153 then applying step ( 2 ) to @xmath111 will decrease @xmath151 by 1 .",
    "[ th : ks ]    in the beginning of the algorithm we have @xmath154 and @xmath155 , so the theorem implies that after at most @xmath55 calls to step ( 1 ) and @xmath55 calls to step ( 2 ) we get @xmath156 .",
    "the latter condition means that @xmath117 , and thus , by proposition  [ prop : local ] , @xmath111 is a global minimum of @xmath0 .",
    "we now show that the bound @xmath157 on the number of steps is also achievable for general strongly tree - submodular functions",
    ". we will establish it for the following version of the steepest descent algorithm :    * choose an arbitrary labeling @xmath158 and set @xmath159 . *",
    "compute minimizer @xmath160 .",
    "if @xmath141 then set @xmath161 and repeat step s1 , otherwise go to step s2 . *",
    "compute minimizer @xmath162 .",
    "if @xmath144 then set @xmath163 and repeat step s2 , otherwise terminate .",
    "note , one could choose @xmath164 to be the root of tree @xmath22 for each node @xmath108 , then step s1 would be redundant .",
    "\\(a ) step s1 is performed at most @xmath55 times .",
    "( b ) each step s2 preserves the following property : @xmath165 ( c ) step s2 is performed at most @xmath55 times .",
    "( d ) labeling @xmath111 produced upon termination of the algorithm is a minimizer of @xmath0 .",
    "[ th : complexity ]    for a labeling @xmath147 denote @xmath166=\\{{\\mbox{\\boldmath $ y$}}\\in\\d\\:|\\:{\\mbox{\\boldmath $ y$}}\\preceq{\\mbox{\\boldmath $ x$}}\\}$ ] .",
    "we will treat domain @xmath166 $ ] as the collection of chains with roots @xmath28 and leaves @xmath2 .",
    "let @xmath150 be the quantity defined in  .",
    "there holds @xmath167 indeed , this equivalence can be obtained by applying proposition  [ prop : local ] to function @xmath0 restricted to @xmath166 $ ] .    * ( a )  * when analyzing the first stage of the algorithm , we can assume without loss of generality that @xmath168 $ ] , i.e.  each tree @xmath22 is a chain with the root @xmath28 and the leaf @xmath164 .",
    "indeed , removing the rest of the tree will not affect the behaviour of steps s1 .",
    "with such assumption , function @xmath0 becomes @xmath4-convex . by theorem",
    "[ th : ks](b ) , steps s1 will terminate after at most @xmath55 steps .    * ( b , c )  * property   ( or equivalently @xmath169 ) clearly holds after termination of steps s1 .",
    "let @xmath170 be the labeling upon termination of steps s2 .",
    "when analyzing the second stage of the algorithm , we can assume without loss of generality that @xmath171 $ ] , i.e.  each tree @xmath22 is a chain with the root @xmath28 and the leaf @xmath172 .",
    "indeed , removing the rest of the tree will not affect the behaviour of steps s2 .",
    "furthermore , restricting @xmath0 to @xmath173 $ ] does not affect the definition of @xmath150 for @xmath174 $ ] .    by theorem",
    "[ th : ks](a ) , steps s2 preserve @xmath169 ; this proves part ( b ) .",
    "part ( c ) follows from theorem  [ th : ks](c ) .    *",
    "( d )  * when steps s2 terminate , we have @xmath175 .",
    "combining this fact with condition   and using proposition  [ prop : local ] gives that upon algorithm s termination @xmath111 is a minimizer of @xmath0 .",
    "in this section we derive an alternative definition of strongly tree - submodular functions . as a corollary",
    ", we will obtain that strong tree submodularity   implies weak tree submodularity  .",
    "let us introduce another pair of operations on trees .",
    "given labels @xmath29 and an integer @xmath33 , we define @xmath176\\wedge b \\qquad a \\downarrow_d b = \\calp[a\\rightarrow b,\\rho(a \\uparrow^d b , b)]\\ ] ] in words , @xmath177 is obtained as follows : ( 1 ) move from @xmath26 towards @xmath27 by @xmath34 steps , stopping if @xmath27 is reached earlier ; ( 2 ) keep moving until the current label becomes an ancestor of @xmath27 .",
    "@xmath178 is the label on the path @xmath30 $ ] such that the distances @xmath179 and @xmath180 are the same , as well as distances @xmath181 and @xmath182 .",
    "note , binary operations @xmath183 ( and corresponding operations @xmath184 ) are in general non - commutative .",
    "one exception is @xmath185 , in which case @xmath186 reduce to the commutative operations defined in the introduction : @xmath187 and @xmath188 .",
    "for fixed labels @xmath29 it will often be convenient to rename nodes in @xmath30 $ ] to be consecutive integers so that @xmath189 and @xmath190",
    ". then we have @xmath191 , @xmath192 and @xmath193    \\(a ) if @xmath0 is strongly tree - submodular then for any @xmath194 and integer @xmath33 there holds _ @xmath195 _ _ _ ( b ) if   holds for any @xmath194 and @xmath33 then @xmath0 is strongly tree - submodular .",
    "[ th : submodularity : dir ]    note , this result is well - known for @xmath4-convex functions  @xcite , i.e.  when all trees are chains shown in figure  [ fig : trees](b ) ; inequality   was then written as @xmath196 , and was called _ translation submodularity_. in fact , translation submodularity is one of the key properties of @xmath4-convex functions , and was heavily used , for example , in  @xcite for proving theorem  [ th : ks ] .    setting @xmath185 in theorem [ th : submodularity : dir](a )",
    "gives    a strongly tree - submodular function @xmath0 is also weakly tree - submodular , i.e.   implies .",
    "a proof of parts ( b ) and ( a ) of theorem  [ eq : submodularity : dir ] is given in sections [ ref : proof : partb ] and [ ref : proof : parta ] respectively . in both proofs we always implicitly assume that for each @xmath108 labels in @xmath197 $ ] are renamed to be consecutive integers with @xmath198 and @xmath199 .      we prove inequality for @xmath200 using induction on @xmath201 .",
    "the base case @xmath202 , or @xmath203 , is trivial ; suppose that @xmath204 .",
    "denote @xmath205 and @xmath206 .",
    "two cases are possible .",
    "*  * @xmath207 is even .",
    "we can assume without loss of generality that there exists @xmath208 such that @xmath209 and @xmath210 .",
    "( if there is no such @xmath93 , we can simply swap @xmath111 and @xmath112 ; inequality will be unaffected since operations @xmath3 are commutative , and @xmath131 , @xmath211 will not change . )",
    "consider labelings @xmath212 defined as follows : @xmath213 for each @xmath108 .",
    "we claim that @xmath214 indeed , for each node @xmath108 one of the following holds :    * @xmath215 .",
    "then @xmath216 , @xmath217 , so ( a ) and ( b ) hold for node @xmath218 .",
    "we also have @xmath219 , which implies ( c ) and ( d ) .",
    "* @xmath220 and @xmath221 .",
    "then @xmath216 , @xmath222 , @xmath223 ; as above , this implies ( a)-(d ) .",
    "* @xmath220 and @xmath224 .",
    "then @xmath225 , @xmath226 .",
    "checking that ( a)-(d ) hold is straightforward .",
    "we have @xmath227 , and so @xmath228 .",
    "therefore , @xmath229 where the first inequality follows from the induction hypothesis and the second one follows from .",
    "summing these inequalities and subtracting @xmath230 from both sides using ( a)-(d ) gives .",
    "*  * @xmath207 is odd . by swapping @xmath111 and @xmath112 , if necessary",
    ", we can assume without loss of generality that there exists @xmath208 such that @xmath209 and @xmath231 .",
    "( note , we can not have @xmath220 and @xmath232 since @xmath207 is odd ) .",
    "consider labelings @xmath212 defined as follows : @xmath233 for each @xmath108 .",
    "we claim that @xmath234 indeed , for each node @xmath108 one of the following holds :    * @xmath215",
    ". then @xmath235 , @xmath236 , so ( a ) and ( b ) hold for node @xmath218 .",
    "we also have @xmath237 , which implies ( c ) and ( d ) .",
    "* @xmath220 and @xmath238 .",
    "then @xmath235 , @xmath239 , so ( a ) and ( b ) hold for node @xmath218 .",
    "( c ) and ( d ) hold since @xmath240 .",
    "* @xmath220 and @xmath221 .",
    "then @xmath241 , @xmath242 .",
    "checking that ( a)-(d ) hold is straightforward .",
    "we have @xmath243 , and so @xmath244 .",
    "therefore , @xmath245 where the first inequality follows from the induction hypothesis and the second one follows from . summing these inequalities and subtracting @xmath230 from both sides using ( a)-(d ) gives .",
    "we say that the triplet @xmath246 is _ valid _ if @xmath247 and @xmath248 $ ] .",
    "we denote @xmath249 ; we have @xmath250 .",
    "let us introduce a partial order @xmath24 over valid triplets as the lexicographical order with variables @xmath251 .",
    "note , the last component @xmath252 is the least significant .",
    "we use induction on this partial order .",
    "the induction base is trivial : if the first @xmath6 components are zeros then @xmath203 so   is an equality , and if the last component is minimal ( i.e.  @xmath253 ) then @xmath254 and @xmath255 , so   is again an equality .",
    "suppose that @xmath256 and @xmath257 .",
    "consider integer @xmath258 , and denote @xmath259 and @xmath260 for @xmath108 .",
    "suppose that @xmath261 for all nodes @xmath108 .",
    "( this holds , for example , if @xmath262 . )",
    "denote @xmath263 , then @xmath264 .",
    "we claim that @xmath265 in order to prove it , let us consider node @xmath218 .",
    "property ( a ) follows from the fact that @xmath266 .",
    "property ( b ) is the definition of @xmath267 . to prove ( c ) , consider two possible cases :    * @xmath268 , so @xmath235 and @xmath269 .",
    "the latter condition and the fact @xmath270 imply that @xmath271 , therefore @xmath272 .",
    "this leads to ( c ) . *",
    "@xmath273 . if @xmath216 then condition ( c ) is straightforward ( it follows from @xmath274 ) .",
    "suppose that @xmath275 , then from definition of @xmath276 we have @xmath277 , or @xmath278 .",
    "this leads to ( c ) .",
    "finally , properties ( c ) and ( d ) are equivalent since @xmath279   & = & [ x_i + y'_i - ( x_i\\uparrow^d y'_i ) ] + y_i - y'_i - [ x_i + y_i - ( x_i \\uparrow^d y_i ) ] \\\\ & = & ( x_i\\uparrow^d y_i ) - ( x_i\\uparrow^d y'_i ) = 0\\end{aligned}\\ ] ] @xmath280   = [ x_i + y'_i - ( x_i\\uparrow^d y'_i ) ] + y_i - y'_i - [ x_i + y_i - ( x_i \\uparrow^d y_i ) ]   = ( x_i\\uparrow^d y_i ) - ( x_i\\uparrow^d y'_i ) = 0\\ ] ]    now suppose that in addition to conditions @xmath281 there holds @xmath282 and @xmath283",
    ". then we have @xmath284 and @xmath285 , so by the induction hypothesis @xmath286 summing these inequalities and subtracting @xmath230 from both sides using ( a)-(d ) gives .",
    "let us describe cases when the argument above can be applied ; such cases can be eliminated from consideration .",
    "first , suppose that @xmath287 for some node @xmath288 , then there exists @xmath258 such that the labeling @xmath259 has at least one node @xmath288 with @xmath289 $ ] .",
    "let us choose the minimum integer @xmath290 that has this property .",
    "then @xmath281 for all nodes @xmath108 , since @xmath291 would contradict to the minimality of chosen @xmath290 .",
    "we also have @xmath292 and @xmath293 ( since @xmath294 ) , so the conditions above are satisfied .",
    "therefore , from now on we assume without loss of generality that @xmath295 for all nodes @xmath108 .",
    "we can also take @xmath262 .",
    "condition @xmath281 is then satisfied for all nodes",
    ". therefore , we can assume without loss of generality that either @xmath296 or @xmath297 where @xmath298 , @xmath299 , otherwise the induction argument above could be applied .",
    "suppose that @xmath296 .",
    "this is equivalent to @xmath300 , or to the following condition for all nodes @xmath108 : either @xmath301 or @xmath302 .",
    "it can be checked that @xmath303 and @xmath304 .",
    "furthermore , @xmath305 , so   follows by the induction hypothesis .",
    "we thus assume from now on that @xmath297 .",
    "equations below summarize definitions and assumptions made so far :    @xmath306    let @xmath307 be the set of nodes",
    "@xmath108 with @xmath273 .",
    "it is straighforward to check that @xmath308    if @xmath307 is empty then @xmath309 , @xmath310 , so inequality   is trivial .",
    "thus , we can assume that @xmath307 is non - empty .",
    "suppose that @xmath307 contains two distinct nodes @xmath218 and @xmath311 .",
    "let us modify labelings @xmath267 and @xmath312 as follows : for node @xmath311 set @xmath313 , @xmath314 .",
    "it is straightforward to check that conditions   for @xmath262 still hold .",
    "furthermore , @xmath315 , @xmath316 , so @xmath284 and @xmath317 . applying the argument described above gives  .",
    "we are left with the case when @xmath307 contains a single node @xmath311 .",
    "we will consider 5 possible subcases . in 4 of them",
    ", we will do the following : ( i ) specify new labelings @xmath267 and @xmath312 with @xmath318 $ ] for each node @xmath218 ; ( ii ) specify four identities involving @xmath319 such that the right - hand sides contain expressions @xmath320 , and the left - hand sides contain expressions of the form @xmath321 , @xmath322 , @xmath323 , @xmath324 where @xmath325 is one of the operations @xmath326 and @xmath327 is the corresponding `` symmetric '' operation .",
    "this will describe how to prove  : we would need to sum two inequalities @xmath328 that hold either by strong tree - submodularity or by the induction hypothesis , then use provided identities to prove  .",
    "checking the identities and the applicability of the induction hypothesis in the case of operations @xmath329 , @xmath330 is mechanical , and we omit it .",
    "@xmath331 ( implying @xmath332 ) .",
    "the identities are @xmath333 and labelings @xmath334 are defined as follows :    * if @xmath335 set @xmath336 , @xmath337 ; * otherwise if @xmath338 set @xmath339 . * otherwise ( if @xmath340 or @xmath341 ) set @xmath342 .    the remainder is devoted to the case @xmath343 .",
    "note that we must have @xmath344 .",
    "@xmath345 , @xmath343 and there exists node @xmath346 with @xmath347 , @xmath348 .",
    "then @xmath349 @xmath267 , @xmath312 are defined as follows :    * if @xmath335 set @xmath313 , @xmath350 ; * otherwise if @xmath351 set @xmath352 ; * otherwise set @xmath353 .",
    "@xmath345 , @xmath343 and there is no node @xmath346 with @xmath347 , @xmath348 . the identities are @xmath354 @xmath267 , @xmath312 are defined as follows :    * if @xmath335 set @xmath355 , @xmath356 ; * otherwise if @xmath357 set @xmath358 ; * otherwise ( if @xmath359 ) set @xmath360 .    note , to verify identities   for node @xmath311 , one should consider cases @xmath361 and @xmath362 separately .",
    "@xmath185 ( implying @xmath363 , @xmath344 ) and there exists node @xmath346 with @xmath364",
    ". then @xmath365 @xmath267 , @xmath312 are defined as follows :    * if @xmath335 set @xmath366 , @xmath367 ; * otherwise if @xmath357 , @xmath340 set @xmath368 ; * otherwise ( if @xmath359 ) set @xmath360 .",
    "@xmath185 ( implying @xmath363 , @xmath344 ) and there is no node @xmath346 with @xmath364 . thus , @xmath359 for all @xmath369 .",
    "there holds @xmath370 , @xmath371 , so inequality   is trivial .",
    "in this section we consider functions @xmath0 that satisfy condition  , but not necessarily condition  .",
    "it is well - known  @xcite that such functions can be minimized efficiently if all trees @xmath22 are chains rooted at an endpoint and @xmath46 is polynomially bounded .",
    "the algorithm utilizes birkhoff s representation theorem  @xcite which says that there exists a _ ring family _ @xmath372 such that there is an isomorphism between sets @xmath128 and @xmath372 that preserves operations @xmath47 and @xmath48 .",
    "( a subset @xmath373 is a ring family if it is closed under operations @xmath47 and @xmath48 . )",
    "it is known that submodular functions over a ring family can be minimized in polynomial time , which implies the result .",
    "note that the number of variables will be @xmath374 .",
    "another case when @xmath0 satisfying   can be minimized efficiently is when @xmath0 is bisubmodular , i.e.  all trees are as shown in figure  [ fig : trees](c ) .",
    "indeed , in this case the pairs of operations @xmath56 and @xmath103 coincide .",
    "an interesting question is whether there exist other classes of weakly tree - submodular functions that can be minimized efficiently . in this section",
    "we provide one rather special example .",
    "we consider the tree shown in figure  [ fig : trees](d ) .",
    "each @xmath22 has nodes @xmath375 such that @xmath45 is the root , the parent of @xmath93 for @xmath376 is @xmath377 , and the parent of @xmath378 and @xmath379 is @xmath55 .    in order to minimize function @xmath0 for such choice of trees , we create @xmath380 variables @xmath381 for each original variable @xmath8 .",
    "the domains of these variables are as follows : @xmath382 , @xmath383 .",
    "each domain is treated as a tree with root @xmath45 and other nodes being the children of @xmath45 ; this defines operations @xmath47 and @xmath48 for domains @xmath384 . the domain @xmath385 is set as the cartesian product of individual domains over all nodes @xmath108 .",
    "note , a vector @xmath386 has @xmath387 components .    for",
    "a labeling @xmath104 let us define labeling @xmath388 as follows : @xmath389    it is easy to check that mapping @xmath390 is injective and preserves operations @xmath47 and @xmath48 . therefore , @xmath391 is a _ signed ring family _ ,",
    "i.e.  a subset of @xmath385 closed under operations @xmath47 and @xmath48 .",
    "it is known  @xcite that bisubmodular functions over ring families can be minimized in polynomial time , leading to    functions that are weakly tree - submodular with respect to trees shown in figure  [ fig : trees](d ) can be minimized in time polynomial in @xmath6 and @xmath46 .",
    "we introduced two classes of functions ( strongly tree - submodular and weakly tree - submodular ) that generalize several previously studied classes . for each class",
    ", we gave new examples of trees for which the minimization problem is tractable .",
    "our work leaves a natural open question : what is the complexity of the problem for more general trees ?",
    "in particular , can we minimize efficiently strongly tree - submodular functions if trees are non - binary , i.e.  if some nodes have three or more children ? note that the algorithm in section  [ sec : alg ] and its analysis are still valid , but it is not clear whether the minimization procedure in step s2 can be implemented efficiently .",
    "also , are there trees besides the one shown in figure  [ fig : trees](d ) for which weakly tree - submodular functions can be minimized efficiently ?    more generally , can one characterize for which operations @xmath56 the minimization problem is tractable ?",
    "currently known tractable examples are distributive lattices , some non - distributive lattices  @xcite , operations on trees introduced in this paper , and combinations of the above operations obtained via cartesian product and maltsev product  @xcite . are there tractable cases that can not be obtained via lattice and tree - based operations ?",
    "david cohen , martin cooper , and peter jeavons . a complete characterization of complexity for boolean constraint optimization problems . in _ principles and practice of constraint programming _ , number 3258 in lecture notes in computer science , pages 212226 , 2004 .",
    "david cohen , martin cooper , peter jeavons , and andrei krokhin .",
    "soft constraints : complexity and multimorphsims . in _ principles and practice of constraint programming _ , number 2833 in lecture notes in computer science , pages 244258 , 2003 .",
    "rustem takhanov . a dichotomy theorem for the general minimum cost homomorphism problem . in _ proceedings of the 27th international symposium on theoretical aspects of computer science ( stacs10 ) _ , pages 657668 , 2010 ."
  ],
  "abstract_text": [
    "<S> we introduce a new class of functions that can be minimized in polynomial time in the value oracle model . </S>",
    "<S> these are functions @xmath0 satisfying @xmath1 where the domain of each variable @xmath2 corresponds to nodes of a rooted binary tree , and operations @xmath3 are defined with respect to this tree . </S>",
    "<S> special cases include previously studied @xmath4-convex and bisubmodular functions , which can be obtained with particular choices of trees . </S>",
    "<S> we present a polynomial - time algorithm for minimizing functions in the new class . </S>",
    "<S> it combines murota s steepest descent algorithm for @xmath4-convex functions with bisubmodular minimization algorithms . </S>"
  ]
}