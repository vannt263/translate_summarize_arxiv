{
  "article_text": [
    "the comparison of protein structures has been an extremely important problem in computational biology for a long time @xcite , and has been employed in almost all branches of contemporary structural biology @xcite , where two categories of application can be achieved from the result of pairwise alignment of protein structures @xcite .",
    "the first category is derived from an exact alignment of residue - residue correspondences in order to identify the homologous core , which may be called _",
    "it can be applied to make the functional prediction @xcite , to construct benchmark datasets on which sequence alignment algorithms can be tested @xcite , to discover sequence - structure - motif that enables protein structure prediction @xcite . finding the optimal correspondences that are structurally similar between the two input proteins",
    "has been proved to be np - hard @xcite . however , a practical solution can be obtained by first finding the local similar fragment pairs ( sfps ) between two proteins with a certain similarity metric and then piling up those sfps with a certain consistency metric @xcite .",
    "for example , clepaps @xcite searches for sfps with conformational letters @xcite and afterwards applies a prosup - like @xcite procedure .",
    "these algorithms treat protein structures as _ rigid - bodies _ , while the followings treat them as _ flexible _ @xcite .",
    "proteins are flexible molecules that undergo significant structural changes as part of their normal function @xcite . however , for those current algorithms which introduce _ flexibility _ , the principal method is allowing twists ( bents ) , regardless of whether these bents are meaningful or meaningless @xcite .",
    "moreover , it has been demonstrated that for a certain case ( drawing roc curve ) , the rigid version of fatcat outperforms the flexible one @xcite .",
    "finally , it has been shown that the runtime of these algorithms is some bit slow @xcite .",
    "the second category is derived from a scoring function for the assessment of the pairwise protein structures similarity based on an exact or fuzzy alignment , which may be called _ assessment _ problem .",
    "it can be applied to give a yes / no answer to distinguish between alignable and non - alignable proteins @xcite , to classify the known protein structures into hierarchical system @xcite , to search the query protein structure against a target database @xcite .",
    "the classical geometric way is the length of alignment ( lali ) plus the root mean squared deviation ( rmsd ) .",
    "clearly , this is a bi - criteria optimization problem where the goal is to minimize the rmsd while maximizing the number of residues @xcite .",
    "however , since the rmsd weights the distances between all residue pairs equally , a small number of local structural deviations could result in a high rmsd , even when the global topologies of the compared structures are similar .",
    "more assessment functions have been suggested @xcite while these functions have only solved the first problem by providing a single assessment score while the other problem is the dependence of the score magnitudes on the evaluated proteins size @xcite .",
    "just as the user of a sequence alignment program can control the gappiness by adjusting gap penalties , changing parameters can make the structural alignment method handle different purposes , @xcite gave a suggestion for parameter settings to deal with distantly - related proteins , other algorithms optimize a best parameter set on a training group for general purposes @xcite .",
    "however , if the alignment task ( for example , the database search ) contains different types of proteins , such as closely - related , distantly - related , small size and large size , it will incur inaccuracy or ineffectiveness when assigning fixed parameters .",
    "we proposed a new approach called clefaps that introduces _ flexibility _ based on a _ rigid - body _",
    "framework , namely clepaps .",
    "the f in clefaps means , ( * a : self - adaptive strategy * ) flexiblization of the algorithm s main parameters through the incorporation of d@xmath0 factor from tm - score @xcite to associate four main parameters with the size of the input proteins ; moreover , combined with _",
    "seed - explosion _ strategy ( similar as blast @xcite ) for sfp generating , we self - adapted all six main parameters instead of fixing them to handle different types of proteins ; ( * b : fuzzy - add strategy * ) flexiblization in the pile - up of the alignment through enlargement of one - to - one correspondence set to one - to - multi which collects all afps while neglecting _ position conflict _ ( shown in fig .",
    "[ fuzzyaddfigure ] ) ; then applying dynamic programming which uses tm - score as the objective function to get an optimal alignment path .",
    "( the similar procedure is applied in tm - align through constructing the tm - score rotation matrix @xcite .",
    "however , such matrix is o(n@xmath1 ) space complexity and the following dynamic programming is again o(n@xmath1 ) time complexity , while clefaps is both o(n ) space and time complexity ) ; ( * c : vect - elong strategy * ) flexible fragment may be found through the elongation procedure based on the vect - score ( see eq .",
    "( [ vectscore ] ) ) to collect _ local flexible _ fragments ( shown in fig .",
    "[ vectelongfigure ] ) after we ve identified two proteins alignment core where all residue - residue pairs are within the final distance cutoff .",
    "in addition , the incorporation of tm - score is to solve the second problem talked above since tm - score is normalized in a way that the score magnitude relative to random structures is not dependent on the protein s size @xcite .    as a result , for those proteins which are distantly related ,",
    "the rigid - body based clefaps is competitive with those algorithms that allow twists ( bents ) while the running time is only one percent of them ( see table [ runtimeanalysis ] ) .",
    "moreover , the incorporation of tm - score has been demonstrated effective by comparing the result on the discrimination test with lali+rmsd , while the former got a nearly 10% higher true negative rate than the latter ( see table [ rmsdvstmscore ] ) .",
    "finally we compared clefaps with other three typical algorithms , namely clepaps , ce and matt , based on their performances on homstrad ( scop family level ) @xcite and sabmark ( scop superfamily level ) @xcite while the latter is also for the discrimination test described in @xcite .",
    "clefaps is open - source for academic users at [ http:// .... ] .",
    "let mol1 and mol2 be two input proteins and moln1 and moln2 be their length , respectively .",
    "we simultaneously transfer each structure to its conformational letter according to @xcite , and use cle1 and cle2 to indicate .",
    "the output of the pairwise alignment involves an one - to - one residue - residue correspondence set ( we ll call it ali1 and ali2 ) , an one - to - one afp correspondence set ( may be called cor ) , a rigid - body transformation ( comprising a rotation matrix r and a translation vector t , we ll call them rotmat ) , a geometric assessment ( i.e. , lali+rmsd ) and a similarity score ( i.e. , tm - score ) ( shown in supplementary fig .",
    "particularly , one - to - one residue - residue correspondence set means that , given one position in mol1 , say ii , there at most be one corresponding position , say jj in mol2 , and they have the structural similarity correspondence , then we record it as , ali1[ii]=jj and ali2[jj]=ii . given ali1 ( or ali2 ) , we can transfer it to cor by extracting every ungapped contiguous residue - residue pair ( we ll call it _ point - pair _ and use @xmath2ii , jj@xmath3 to indicate it ) and vice versa .    some algorithms , such as ce , use _ afp _ to describe all local similar fragment pairs between mol1 and mol2 in every case , including those in the final alignment path and those only having local similarity . in our algorithm",
    ", we divide the original _ afp _ into sfp and afp , where the former is the original meaning while the latter is a subset of sfp that each afp should satisfy the consistency metric , namely crms distance cutoff in clefaps . in details ,",
    "given ii in cle1 , jj in cle2 and a range length , we can calculate the clesum score @xcite of the ungapped fragment pair by the following equation : @xmath4\\,[\\,cle2[jj+k]]\\ ] ]    then we may define a sfp only when its clesum score is above a given threshold .",
    "we use sfp(ii , jj;len ) to indicate where ii , jj is the starting position in cle1 and cle2 and len is its range length .",
    "moreover , under a certain rotmat , a sfp may become a full_afp if every point - pair in the sfp is within a given distance cutoff , or may become a part_afp if there exists a maximal subset where every point - pair is within the given cutoff and the number of the subset is at least one .",
    "both full_afp and part_afp can be generally called afp , we may also use afp(ii , jj;len ) to indicate . finally , we ll use pivot_sfp to indicate the sfp that we use to determine the initial rotmat .",
    "the equation of tm - score @xcite is as follows : @xmath5    where l@xmath6 is the smaller length of the input structures , d@xmath7 is the distance between the k - th point - pair of aligned residues , lali is the length of the aligned residues and d@xmath0 is the factor associated with the protein size , where : @xmath8{l_n -15 } - 1.8\\ ] ]    * * association of d@xmath0 with the distance cutoff * +    first we set : @xmath9 } fin\\_{}cut = d_0 , \\nonumber\\\\ 5.0 \\le fin\\_{}cut \\le 15.0\\end{aligned}\\ ] ] because fin_cut is our distance cutoff for evaluating overall alignment , setting fin_cut equals to d@xmath0 and using such cutoff to calculate tm - score means the extraction of those point - pairs which contribute more than 0.5 to tm - score from the final aligned correspondence set , and eliminating the remaining .",
    "since we know when the alignments between two proteins get a tm - score more than 0.5 , can we say they belong to the same fold @xcite . actually , this procedure is similar to maxsub - score @xcite , only with the difference that maxsub uses a fixed distance cutoff d@xmath0 by users while ours uses a flexible one by the input structure s size .",
    "then we set : @xmath10 } ini\\_{}cut = 2*d_0 , \\nonumber\\\\ 5.0 \\le ini\\_{}cut \\le 15.0\\end{aligned}\\ ] ] the ini_cut is used to construct initial alignment similar as @xcite . at the beginning , clefaps only uses a single sfp ( i.e. , pivot_sfp ) to determine the initial rotmat , so there may exist some afps that are in the final alignment while under initial rotmat their point - pairs may still have a large distance . in order to add these afps , we have to use a larger distance cutoff at the beginning and the twofold scaling is well for different purposes ( see result  [ different ] ) . the similar strategy that using a larger ini_cut than fin_cut is also applied by @xcite .",
    "we set the lower limit to 5.0 for the reason that , if we set the lower limit below 5.0 , when dealing with small and distantly related proteins , the algorithms will miss some point - pairs which should be in the final alignment ( see result  [ smallprotein ] ) .",
    "while we set the lower limit at 5.0 to deal with closely related proteins , the result is still correct .",
    "we set the upper limit to 15.0 because , while d@xmath0=15.0 , the corresponding length is about 2500 residues ( see eq .",
    "( [ d0factor ] ) ) , this value is nearly the size limit of a single domain .",
    "moreover , the distance between two adjacent c@xmath11 atom is about 3.8 , so 15.0 is about four c@xmath11 s length that when a point - pair s distance is beyond this value may we basically say they do not have obvious structural correspondence .",
    "* * association of d@xmath0 with the average clesum score s threshold * +    compared to the above part , the association of d@xmath0 with clesum score s threshold is arbitrary , we use the following equation , @xmath12 } thres\\_l = d_0   - 5.0 , \\nonumber\\\\ 0 \\le thres\\_l \\le 10\\end{aligned}\\ ] ] @xmath13 } thres\\_{}h=15+thres\\_{}l\\ ] ]    particularly , we set the range of thres_l from 0 to 10 is reasonable , since the purpose to create sfp_l is for _ sensitivity _ which means the list will cover as many sfps as possible so that it wo nt exclude any one that should be in the final alignment @xcite .",
    "if one sfp gets a similarity score more than 0 , may we say they have the local similarity compared to the background .",
    "for large proteins , however , if we still fix the threshold at 0 , there ll be too many sfps that make the algorithm ineffective .",
    "when setting the boundary at 10 , we may get reasonable result while reducing 30% of the running time compared to fixing at 0 ( see result  [ largeprotein ] for details ) .",
    "the reason why we set the range of thres_h from 15 to 25 is as follows , since the purpose to create sfp_h is for _ specificity _ which means the list will contain sfps with high enough similarity for constructing an initial rotmat , while excluding many purely local coincident sfps @xcite .",
    "then , the average clesum score of 15 is high enough to collect highly similar sfps .",
    "for the same reason as thres_l , setting the boundary at 25 will gain effectiveness while retaining accuracy for large proteins .      * * fuzzy - add * +    suppose the afp list to add is all within the distance cutoff under a certain rotmat ( actually it contains full_afp and part_afp )",
    ". then at ali1 and ali2 , there will occur _ position conflict _ ( shown in fig . [ fuzzyaddfigure](a ) ) that one position in mol2 may have more than one corresponding positions in mol1 .    a reasonable solution is to extend our one - to - one correspondence set , say ali2 , to the one - to - multi set , say ali3 .",
    "the first dimension in ali3 is the same as in ali2 which is just the position index of mol2 , while at a given index , the second dimension is the corresponding position in mol1 ( shown in fig . [ fuzzyaddfigure](b ) ) . when adding afps , we just need to put all of them into ali3 , without having to consider their _",
    "position conflict_. this is the definition of fuzzy - add .",
    "in addition , the default value of the maximal number ( ali3_tot ) of the second dimension in ali3 is 6 , that is to say , given one position in mol2 , we only consider at most 6 corresponding positions in mol1 .",
    "when there appears more than 6 positions , we ll pop - out the position with maximal distance . during afp adding , there is only a very small proportion of positions in mol2 that will have more than 6 corresponding points .",
    "that is because the maximal distance cutoff in our algorithm is 15.0 ( average is about 8.0 ) , which is about 3 to 4 ( average is about 2 to 3 ) c@xmath11-c@xmath11 s distance .        * * ali3-dynaprog * +    the purpose of alignment is to get an one - to - one correspondence set between two proteins , and a natural method that converts one - to - multi to one - to - one is dynamic programming @xcite ( see fig . [ fuzzyaddfigure](c ) ) . in details",
    ", we design three temporary data structures , called sco3 , pos3 and pre3 , to record the best score through the dynamic programming path , the best position associated with null - state ( see below ) and the traceback pointer , respectively . their first dimension is just the same as ali3 , however the second dimension is one more than ali3 , the extra state is called null - state which deals with gaps ( shown in fig .",
    "[ fuzzyaddfigure](legend ) ) .    *",
    "ali3-dynaprog : + recursion : for(i=0 ; i@xmath2moln2 - 1 ; i++ ) + - + 01 ] for(x=0 ; x@xmath14n[i+1 ] ; x++)\\ { + 02 ]  if(x==0)\\ { // null - state + 03 ]  sco3[i+1][x ] = max(k=0 ; k@xmath14n[i ] ; k++)\\ { + 04 ]  sco3[i][k ] } ; + 05 ]  pos3[i+1][x ] = pos3[i][k_max ] ; + 06 ]  pre3[i+1][x ] = k_max ; } + 07 ]  else\\ {  // real - state + 08 ]  sco3[i+1][x ] = max(k=0 ; k@xmath14n[i ] ; k++)\\ { + 09 ]  sco3[i][k]+ + 10 ]  gap_function(i+1 , x ; i , k)+ + 11 ]  score_function(i+1 , x ) } ; + 12 ]  pos3[i+1][x ] = ali3[i+1][x ] ; + 13 ]  pre3[i+1][x ] = k_max ; } } +    n[k ] is the total corresponding points of ali3[k ] , less than ali3_tot .",
    "k_max is the k that maximizes the max function .",
    "this is the main dynamic programming function , where ,    * 01 ] gap_function(i+1 , x ; i , k)\\ { + 02 ]  cur_pos = ali3[i+1][x ] ;  // current position at mol1 + 03 ]  bak_pos = pos3[i][k ] ;  //",
    "last position at mol1 + 04 ]  if(cur_pos@xmath3bak_pos+1)\\ {  // sequential gap + 05 ]  return for_gap+(cur_pos - bak_pos)*extend ; } + 06 ]  else if(cur_pos==bak_pos+1)\\ { // no gap + 07 ]  return 0 ; } + 08 ]  else\\ {  // non - sequential gap + 09 ]  return bak_gap ; } } + 01 ] score_function(i+1 , x)\\ { + 02 ]  ii = ali3[i+1][x ] ;  //",
    "position at mol1 + 03 ]  jj = i+1 ;    //",
    "position at mol2 + 04 ]  score = + 05 ]  weight1*tm - score(ii , jj ) + + 06 ]  weight2*vect - score(ii , jj ) ; + 07 ]  return scale*score ; } +    there is an important result needed to point out , though dynamic programming is applied , we may still get non - sequential alignment .",
    "this is because the path of ali3-dynaprog is sequential to mol2 , regardless of the corresponding position in mol1 .",
    "however , we know that such situation will not often happen , so we set non - sequential gap penalty a relatively more negative value than sequential one , in order to punish the former .    *",
    "[ tmscore ] + tmscore(ii , jj ) + & + 01 ] p1 = mol1[ii ] ; + 02 ] p2@xmath15 = mol2[jj ] ; + 03 ] p2 = rotmat*p2@xmath15 ; + 04 ] tm_score = 1.0/(1.0+(@xmath16p1-p2@xmath16/d@xmath0)@xmath1 ) ;",
    "+ + [ vectscore ] + vectscore(ii , jj ) + & + 01 ] v1 = mol1[ii]-mol1[ii-1 ] ; + 02 ] v2@xmath15 = mol2[jj]-mol2[jj-1 ] ; + 03 ] v2 = rotmat*v2@xmath15 ; + 04 ] vect_score = 1.0*dot(v1,v2)/ ( @xmath16v1@xmath16 * @xmath16v2@xmath16 ) ; +    the range of tm - score(ii , jj ) is from 0.0 to 1.0 , while vect - score(ii , jj ) is from -1.0 to 1.0 .",
    "we arbitrarily set the ali3-dynaprog s parameters as follows : scale = 100 , bak_gap = 200 , for_gap = 50 , extend = 5 , and it works well .",
    "after we ve applied the ali3-dynaprog , the optimal path that maximize the score can be traced back , which is automatically transferred to an one - to - one correspondence set , that is ali1 and ali2 ( shown in fig .",
    "[ fuzzyaddfigure](d ) ) .",
    "the computation time of ali3-dynaprog grows as o(ali3_tot*moln2 ) .      * * vect - score *    1,1@xmath3 , @xmath22,2@xmath3 , @xmath23,3@xmath3 and @xmath24,4@xmath3 .",
    "( b ) the reasonable alignment , with point - pairs @xmath21,2@xmath3 , @xmath22,3@xmath3 and @xmath23,4@xmath3 . ]",
    "if we measure two protein structures alignment only rooted in its point - pair s euclidean distance , then the situation called _ fragment dislocation _ misalignment ( see fig . [ fragdislocation ] ) is likely to happen , where the fragment aligned by a certain algorithm does not stay at its best location , especially in beta - sheet , with one to four residues deviation .",
    "for example , even the alignment s rmsd may be relatively low in fig .",
    "[ fragdislocation](a ) , it s not as reasonable as the alignment illustrated in fig .",
    "[ fragdislocation](b ) , where the c@xmath17 residues are in the same orientation .",
    "such measuring method based on euclidean distance may be called dist - score ( e.g. , crms , tm - score , etc ) .",
    "an effective solution to the above problem is to introduce an extra measuring method , called vect - score ( see eq .",
    "( [ vectscore ] ) ) . based on vect - score , the alignment in fig .",
    "[ fragdislocation](b ) will certainly get a higher score than the alignment in fig . [",
    "fragdislocation](a ) .",
    "prosup also finds a similar example and applies a different strategy called c@xmath17 filter to eliminate such cases .",
    "* * vect - elong *        another important usage of vect - score is to deal with the _ local flexible _ situation ( fig .",
    "[ vectelongfigure ] ) defined as follows , when we have identified two proteins alignment core which all point - pairs in the core are within the distance cutoff , there may exist an afp ( full_afp or part_afp ) outside the core which meets the following two features : ( a ) one terminal of the afp , whose distance is within the distance cutoff , while the other terminal is beyond the cutoff ; ( b ) the afp s corresponding point - pairs are on basically the same direction .",
    "vect - elong is such a procedure to solve _ local flexible _ that based on vect - score .",
    "we starting from the refined correspondence set , checking one of these corresponding point - pairs ( for example , @xmath2ii , jj@xmath3 ) whether or not can be extended to blank portion ( i.e. , none of the position in point - pair @xmath2ii+1,jj+1@xmath3 has corresponding ones ) .",
    "if the point - pair to be tested is blank , and its vect - score is within a given threshold , we will add this point - pair to the correspondence set , and the extension continues .",
    "[ vectelongfigure ] for example , if we use an extension procedure simply based on dist - score , then for a given distance cutoff , @xmath23,3@xmath3 , @xmath24,4@xmath3 , @xmath25,5@xmath3 , these three point - pairs with obvious local similarity will not be added . while we apply vect - elong ( using angle cutoff ) , all these three point - pairs now can be added .",
    "an overview of clefaps is presented in fig .",
    "[ overviewfigure ] ( see supplementary table ii for default parameters ) .",
    "though the framework is similar as clepaps @xcite , the details of every step is totally different ( see supplementary for algorithmic comparison ) .",
    "we use _ seed - explosion _ strategy to generate two lists of sfps .",
    "the seed - explosion strategy is similar as blast @xcite , where we first seek short sfps at a given length ( len_l ) and a minimal threshold ( thres_l ) ( we may call these short sfps _ seed _ ) , then we extend the seed at both terminals .",
    "the similar strategy is also used by mustang and matt to create their sfps , while the difference is that mustang uses crms as their similarity metric and the extension ( only at the c - termini ) wo nt stop until the similarity metric is below the given threshold @xcite , matt also uses crms but their sfp s length is from 5 to 9 @xcite .",
    "we set an extension limit ( len_h ) and a threshold ( thres_l ) for sfp_l .",
    "then we check the extended sfp s average score is more than thres_h or not , if it passes the check , we start a second extension phase whose extension limit is 2*len_h and the threshold is thres_h to create sfp_h .",
    "the extension phase stops either the current sfp s average score is below the given threshold , or it s length is beyond the extension limit . after generating these two lists , we sort them by clesum score , respectively .",
    "this step grows o(w1*n@xmath1 ) , where n is the longer protein length , and w1=len_h+len_l . in real program",
    "we use redundancy shaving procedure that we only keep the sfp with the highest score among the nearby sfps @xcite .",
    "( for details of the pseudo code , see supplementary , the same as follows . )",
    "we recommend to set the parameters above as follows , len_l=6 , len_h=9 .",
    "so the sfp_l is from 6 to 8 , and the sfp_h is from 9 to 18 .",
    "length 6 - 8 is necessary for including most sfps with local similarity , while length 9 - 18 will exclude as many sfps that only have local coincidence as possible , especially in helix regions whose average length is about ten @xcite .",
    "we select the best pivot_sfp from topk of sfp_h according to its tm - score calculated by fuzzy - adding all afps from sfp_h . at the same time",
    ", we get the initial rotmat according to @xcite .",
    "this step grows o(topk * sfp_h s size ) , where the average space complexity of sfp_h s size is about one third of sfp_l s and its size is approximately o(1/len_h * n@xmath1 ) .",
    "( see time complexity analysis in supplementary . )",
    "we recommend the parameter topk be 10 , that is to say , we ll do at most 10 recursions to select the best pivot_sfp .",
    "this heuristics is greedy , but it is based on the fact that , if two proteins have global similarity , the chance that we can not find one sfp in the final alignment from the top ten of sfp_h is relatively small . actually , our result shows that , at the large database sabmark , the failure alignment because of this situation ( none of top 10 is in the final alignment ) is rare .",
    "we apply zoom_iter=3 zoom - in iterations to add afps from sfp_l .",
    "first , we use the initial rotmat from the upper step ; then at k - th iteration we check topnum of sfp_l for afps , where , @xmath18 meanwhile we gradually lower our distance cutoff by minus , where , @xmath19    for instance , at the first iteration , we check top 1/2 ( half ) of sfp_l and the distance cutoff is ini_cut - minus , while at the final iteration , we check all of sfp_l and the cutoff is fin_cut . at each iteration",
    ", we also use fuzzy - add to add afps , then use ali3-dynaprog to get cor which updates rotmat .",
    "moreover , we modify the _ marking _ procedure in @xcite slightly , if one sfp in sfp_l has none point - pairs within the distance cutoff , we mark it -1 , then in the later iteration we ll skip the sfp marked -1. this step grows o(zoom_iter*sfp_l s size ) as the worst complexity , however , the introducing of marking procedure reduces it to o(sfp_l s size ) .",
    "we apply an recursion of maximal refine_iter=10 iterations to refine our correspondence set under the final distance cutoff ( fin_cut ) , each iteration is constituted by the following three procedures :        * * dist - elong : * similar as vect - elong ( see  [ vectelongstrategy ] ) , with the different that the elongation metric is based on point - pair s distance instead of vect - score , and the threshold is fin_cut instead of ang_cut . * * partial - add : * if one afp(ii , jj;len ) satisfies the distance cutoff , its neighbor afp(ii , jj+k;len ) , ( where -1*range@xmath14k@xmath14range ) may also satisfy the cutoff ( we call such case _ partial - move _ , there is an excellent illustration in ce s testcase ( 1col : a with 1cpc : l ) @xcite that before and after optimization are obviously different ) .",
    "so when the cor has been identified , we may apply partial - add to find each afp s adjacent neighbors , then fuzzy - add all these afps to ali3 .",
    "we set range=4 as default for the reason that : first , the period of helix is about four c@xmath11 residues so it may help to deal with fragment dislocation at helix region ; second , for the other situations except helix , the maximal distance between four c@xmath11 s length is about 15.0 , which is near our maximal distance cutoff , beyond which may we basically say that the point - pair do not have obvious structural correspondence . * * ali3-dynaprog : * different from the above steps (  [ bestpivot ] and  [ zoomin ] ) which only use tm - score as its score_function , this step uses both tm - score and vect - score for the purpose to eliminate fragment dislocation , and setting equal weight works well .    at the end of each refinement iteration , we ll apply the following criteria to check whether to break or not .",
    "* break criteria : + 01 ] if(failure_count @xmath20 failure_cut)\\ { //failure count judge + 02 ]  break ; } + 03 ] if(tm_cur @xmath3 tm_max ) \\ {  //tm - score judge + 04 ]  failure_count=0 ; + 05 ]  tm_max = tm_cur ; + 06 ]  rotmax = rotcur ; } + 07 ] else if(tm_cur @xmath2 0.95 * tm_max)break ; + 08 ] else failure_count++ ; +    where failure_count is the counts of failure that the current tm - score ( tm_cur ) is less than the maximal tm - score ( tm_max ) , the default value for failure_cut is 2 , that is to say , if two continuous recursions can not make the tm - score better than the maximal one , we ll break the refinement recursion ( this made the average recursion to about 3 - 4 ) .",
    "the purpose of the refinement step in our algorithm is similar as in ce et al .",
    "( @xcite ) .",
    "while the main difference of ours and theirs is that , clefaps can be run in o(n ) time , however ce et al .",
    "use dynamic programming on the distance matrix calculated using every point - pairs from mol1 and mol2 under current rotmat so their time complexity is o(n@xmath1 ) .",
    "after refinement , we got the optimized cor where every point - pair is within the final distance cutoff .",
    "however , since we know that there may exist _ local flexible _ situation , it is recommended to apply vect - elong at the final stage with the parameter ang_cut to be 0.6 , which will lead to good result .",
    "here , we ll show the following two cases , with comparison of the four typical algorithms ( i.e. , clefaps , clepaps , ce and matt , the same as follows ) to show the usage of vect - score and vect - elong .",
    "1bxd(chain : a,290 - 450 ) and 1b3q(chain : a,355 - 540 ) are two protein domains in the _",
    "histidine_kinase _ family of homstrad .",
    "the fragment dislocation misalignment ( in beta - sheet ) of ce and clepaps are shown in fig . [ fragdislocationdisplay](c ) and fig .",
    "[ fragdislocationdisplay](b ) , respectively .",
    "clefaps employs tm - score plus vect - score as the score_function of ali3-dynaprog in the refinement step to eliminate such situation ( shown in fig .",
    "[ fragdislocationdisplay](a ) ) .",
    "the result is supported by matt ( shown in fig . [ fragdislocationdisplay](d ) ) .",
    "the adenylate kinase protein ( ake ) has a stable inactive conformation , in addition to an active form , i.e. , the open and closed forms @xcite .",
    "they are represented by pdb_id 4ake and 1ake , respectively .",
    "the protein can be cut into three parts according to @xcite , which may be called the rigid part ( core part ) , the lid domain ( right part ) and the nmp_bind domain ( left part ) , respectively ( shown in fig .",
    "[ localflexibledisplay](e ) ) .",
    "the result alignment of the four algorithms are shown in fig .",
    "[ localflexibledisplay](a ) to [ localflexibledisplay](d ) .",
    "clepaps found the core part , ce found both the core and the right part , while in right part , ce did nt give an accurate alignment .",
    "clefaps first found the core part similar as clepaps , then it applied vect - elong to find the left and the right part , though incompletely , for the reason that clefaps is based on the rigid - body framework .",
    "matt did the best job to find all three parts completely , however it cost the most runtime .",
    "we consider the following four different types of proteins , small size , large size , closely - related and distantly - related .",
    "we ll talk the former two types in this subsection while the latter two types will be discussed in the following subsection ",
    "[ homstrad ] and  [ sabmark ] .",
    "d1r5pa _ ( 90 residues ) and d1t4za _ ( 105 residues ) belong to the scop _ thioredoxin - like _ superfamily ( c.47.1 ) ( we use the structures in the astral(40% ) compendium @xcite ) .",
    "we ve tried different lower boundary for the association of d@xmath0 with the distance cutoff , from 3.0 , 4.0 to 5.0 ( shown in fig .",
    "[ lowerboundary ] ) .",
    "the d@xmath0 factor in this case is 3.4059 ( see eq .",
    "( [ d0factor ] ) ) , and the amino acid identity of this pair is 27.0% . if we set the lower boundary too small ( e.g. , 3.0 or 4.0 ) , the final distance cutoff ( fin_cut ) will directly be associated with d@xmath0 ( see eq .",
    "( [ assocd0[1 ] ] ) ) , and then we ll miss some obviously alignable regions when dealing with such small but distantly related proteins .",
    "however , if we set the lower boundary at a moderate value ( i.e. , 5.0 ) , then when dealing with proteins whose length is below 180 residues , the final distance cutoff is constant at 5.0 ( see eq .",
    "( [ d0factor],[assocd0[1 ] ] ) ) , and such value is tolerant for adding afps in small ( or moderate ) size but distantly related proteins .",
    "d1twfb _ ( 1094 residues ) and d2a69c1 ( 1119 residues ) belong to the scop _ beta and beta - prime subunits of dna dependent rna- polymerase _ superfamily ( e.29.1 ) .",
    "we ve tried self - adaptive strategy ( association of d@xmath0 with the average clesum score s threshold ) and constant values .",
    "the d@xmath0 factor in this case is 10.91 , using eq .",
    "( [ assocd0[3]],[assocd0[4 ] ] ) we get the self - adaptive threshold ( thres_l=5 and thres_h=20 ) , then the sfp lists size is 5635 of sfp_h and 63644 of sfp_l , respectively . using constant values ( thres_l=0 and thres_h=15 ) however ,",
    "the two sfp lists size is 10962 of sfp_h and 83737 of sfp_l . as a result we get the similar alignment with correspondence identity at 94.3% , while the running time of self - adaptive strategy is 30% faster than that of constant values .",
    "moreover , from the comparison of the four algorithms , clefaps gets the best tm - score 0.720 and the largest alignment length 851 while the other three get the similar tm - score ( about 0.61 ) and the similar alignment length ( about 700 ) .",
    "this is not surprising , because clefaps employs the final distance cutoff ( fin_cut ) at 10.91 so it will collect more alignable regions than the other algorithms which set their parameters constant for general purposes instead of such large proteins .",
    "homstrad is a database of protein structural alignments for homologous families @xcite .",
    "its alignments were generated using structural alignment programs , then followed by a manual scrutiny of individual cases .",
    "there are totally 1033 families ( 633 at pairwise level ) .",
    "we ll compare the four algorithms on these 633 families , and the alignment accuracy metric is :    * correct(algorithm)/loa(length of algorithm ) + calculated by comparing every pairwise alignment in a certain algorithm against the reference ( homstrad ) .",
    "all correctly aligned residue pairs in comparison with the reference are considered as correct and the total alignment length of the certain algorithm as loa .",
    "this is the same metric as acc used in mustang @xcite .",
    "* correct(algorithm)/lor(length of reference ) + all correctly aligned residue pairs in comparison with the reference are considered as correct and the length of alignment in reference is called lor .    the reason why we develop the second c",
    "/ lor metric is as follows , for instance , 1kxr ( chain : a,221 - 352 ) and 1kfu",
    "( chain : l,211 - 355 ) are two protein domains in the _",
    "peptidase_c2_d2 _ family of homstrad and reference length is 130 .",
    "matt got an alignment of 93 point - pairs with 93 correct , its c / loa is 1.0 while its c / lor is only 0.715 .",
    "clefaps , however , got an alignment of 123 point - pairs with 116 correct , its c / loa is 0.943 while its c / lor is 0.892 .",
    "c | c c c c accuracy metric   &  clefaps &  clepaps &   ce &   matt + c / loa@xmath21 & 0.929 & 0.916 & 0.911 & 0.948 +",
    "c / lor@xmath1 & 0.898 & 0.847 & 0.881 & 0.831 +   +   +    from the data in table [ accuracyofhomstrad ] , matt scored highest in c / loa but lowest in c / lor . on the contrary , clefaps scored highest in c / lor and second highest in c / loa .",
    "this is because matt allows local flexibilities ( or _ bent _ ) everywhere between short fragments ( i.e. , afps ) and then uses dynamic programming to assembly these _ bentable _ afps .",
    "however , matt did nt apply the final optimization procedure , which is used in ce and clefaps , so the alignment length of matt is relatively small while the precision is relatively high .",
    "clepaps , analogously , _ greedy - add _ all afps and then skip the final optimization procedure , get a relatively high c / loa and low c / lor as matt .",
    "the discrimination problem , takes as input a pair of protein structures , and is supposed to output a yes / no answer ( together with an assessment score ) as to whether a good alignment can be found for these two protein structures or not @xcite . in our article , we followed matt s method and take sabmark @xcite s superfamily as our test set , which is natural for the discrimination problem because : ( a ) it contains 3645 domains sorted into 425 subsets representing structures at scop superfamily level , each sabmark subset contains at most 25 structures , which can be regarded as _ plus _ set ; ( b ) it additionally provides a set of decoy structures for nearly all its 425 sets , each decoy s sequence is similar to its corresponding set while its structure is within a different scop fold , each decoy set contains at most 25 structures , which can be regarded as _ minus _ set .",
    "we constructed the following two decoy discrimination test , one is similar as matt that for each superfamily we choose a random pair of structures both from plus set ( can not be the same ) and a random pair from plus and minus set , we call such procedure random test . the other is that we conduct all - against - all within plus set and between plus and minus set , we call such procedure all - against - all test .",
    "when comparing the four algorithm s roc curves @xcite , sabmark now serves as the gold standard . for varying thresholds based on a certain assessment function , all pairs below the threshold are assumed positive , and all above it negative .",
    "the pairs that agree with the standard are called true positives ( tp ) while those that do not are false positives ( fp ) @xcite .",
    "c | c c true positive  &  lali+rmsd &  tm - score + 95.04 & 71.16 & 86.0 + 94.09 & 75.65 & 87.5 + 93.14 & 77.30 & 88.4 + 92.20 & 79.20 & 90.3 + 91.02 & 82.74 & 91.7 + 90.07 & 86.52 & 93.4 +   +   +   +   +    first , we compare the assessment function of tm - score and lali+rmsd based on the same algorithm ( matt ) and the same decoy discrimination test ( random test ) ( see table [ rmsdvstmscore ] ) @xcite , at each fixed true positive rate , tm - score got a nearly 10% higher true negative rate than lali+rmsd .",
    ".auc values based on tm - score from clefaps , clepaps , ce and matt [ cols=\"^,^,^,^,^\",options=\"header \" , ]     second , we compare roc curves and auc @xcite over the four algorithms ( shown in fig .",
    "[ roccurvefigure ] and table [ aucvalue ] ) , matt performs best in both tests and ce follows the second , while clefaps is comparable with ce and is better than clepaps . a notable result when comparing clepaps and clefaps is , in random test clepaps failed 9/425 in positive test and 49/425 negative test while clefaps only failed 1/425 in the former test ; in all - against - all test clepaps failed 1322/40676 in positive test and 4064/40066 negative test while clefaps failed 28/40676 in former and 75/40066 in latter .",
    "this result may be the demonstration that , clefaps employing the seed - explosion strategy to create sfp_h is more effective than clepaps employing fixed parameters .",
    "c | c c c c runtime ( sec )   &  clefaps &  clepaps &   ce &   matt + total runtime & 1259 & 1136 & 61669 & 172812 + average runtime & 0.01526 & 0.01377 & 0.74765 & 2.09510",
    "+    finally , we compare running ( see table [ runtimeanalysis ] ) using the windows xp operation system with 2 * 2.66-ghz dual - core intel core 2 dual processor and 2-gb 667 mhz memory .",
    "the result is on all - against - all test which contains 80742 pairs of proteins .",
    "we find that , though matt and ce perform best and second best ( comparable with clefaps ) on the discrimination problem , they are the slowest and the second slowest on running time , while clefaps and clepaps takes only about 1/50 of the running time used by ce and 1/150 of matt , and clefaps is only 10% more than clepaps .",
    "\\(a ) random discrimination test +   + ( b ) all - against - all discrimination test +   +",
    "we proposed the program called clefaps , which considers protein s flexibility based on a _ rigid - body _",
    "framework , instead of introducing twists ( bends ) .",
    "the result showed that when dealing with the structural distortion caused by distantly related proteins through evolution @xcite , clefaps is competitive with those algorithms that allow twists , and the reasons are as follows ,    * through the incorporation of d@xmath0 factor from tm - score to associate the main parameters of the pairwise alignment , including the similarity metric of sfp ( clesum score threshold ) and the consistency metric in pile - up of the alignment ( distance cutoff ) , with the size of the input proteins ( _ parameter self - adaptive _ ) .",
    "* through the enlargement of the one - to - one correspondence set to one - to - multi during the pile - up procedure , which collects all afps while neglecting their position conflict ( _ fuzzy - add _ ) . then applying dynamic programming , which uses tm - score ( or plus vect - score ) as the objective function , to get an optimal alignment path ( _ ali3-dynaprog _ ) .",
    "* through the elongation based on the vect - score to collect local flexible fragments , that the fragment s point - pairs are exceed the final distance cutoff while they share local structural similarity , after we ve identified two proteins alignment core ( _ vect - elong _ ) .",
    "furthermore , we employ tm - score as the assessment function to measure the structural similarity between two proteins , which has been demonstrated effective by comparing the result on the discrimination test .",
    "perhaps the most highlighted feature of clefaps is its fast speed , where the most important contribution is the topk(=10 ) cutoff in the step called _ select the best pivot_sfp _ ( see  [ bestpivot ] ) , where we ll do at most topk(=10 ) recursions .",
    "if all these topk(=10 ) sfps in sfp_h are far away from the final alignment , the algorithm will certainly end in failure . in the future work",
    ", we ll start a precise exploration on the accuracy of topk sfps in sfp_h through the statistics on some large databases .",
    "there is another structural distortion caused by conformational flexibility @xcite , say , domain motion @xcite . however , clefaps is ineffective to deal with such cases because of its rigid - body framework while it can only deal with _ local flexible _ fragments .",
    "when an entire domain undergoes a significant conformational change , we may use the _ multi - solution _ strategy @xcite to solve it .",
    "clefaps is a sequence - independent structural alignment algorithm , however if we consider the amino acid , the generalized conformational letter ( reduction of amino acid plus conformational letter ) @xcite may be employed to encode the input proteins and the generalized clesum @xcite be applied to generate the sfp list .",
    "it is expected that through this procedure may we get more accurate result as well as reduce the topk s failure rate .",
    "supplementary data are available at ....",
    "we are grateful to professor wei - mou zheng , drs . ming li , ai - ming xiong , kang li for their helpful discussions , and colleague hui zeng for drawing the roc curve .",
    "koehl , p . , 2006 ,",
    "protein structure classification , chapter 1 of reviews in computational chemistry , v .",
    "lipkowitz , tr .",
    "cundari , and vj .",
    "gillet , wiley - vch , john wiley and sons , inc . ,",
    "i eidhammer , i jonassen , wr taylor , structure comparison and structure patterns , j. comput .",
    "2000 ; 7:685 - 716 .",
    "irving ja , whisstock jc , lesk am ( 2001 ) protein structural alignments and functional genomics . proteins 42 : 378 - 382 .",
    "edgar r , batzoglou s ( 2006 ) multiple sequence alignment .",
    "curr opin struct bio 16 : 368 - 373 .",
    "dunbrack rl ( 2006 ) sequence comparison and protein structure prediction .",
    "curr opin struct biol 16 : 274 - 284 .",
    "chandonia , j .-",
    "m . , hon , g . ,",
    "walker , n.s . ,",
    "conte , l.l .",
    ", koehl , p . , levitt , m . and brenner , s.e .",
    "( 2004 ) the astral compendium in 2004 .",
    "nucleic acids res .",
    ", 32 ( database issue ) , d189-d192 .",
    "murzin , a.g . , brenner , s.e .",
    ", hubbard , t . and chothia , c .",
    "( 1995 ) scop : a structural classification of proteins database for the investigation of sequences and structures . j. mol .",
    "biol . , 247 , 536 - 540 .",
    "orengo , c.a . ,",
    "michie , a.d . ,",
    "jones , s . , jones , d.t . , swindells , m.b . and thornton , j.m .",
    "( 1997 ) cath - a hierarchic classification of protein domain structures .",
    "structure , 5 , 1093 - 1108 .",
    "holm , l. and sander , c. ( 1996 ) .",
    "the fssp database : fold classification based on structure - structure alignment of proteins .",
    "nar , 24 ( 1 ) , 206 - 209 .",
    "goldman d , istrail s , papadimitriou ch ( 1999 ) algorithmic aspects of protein structure similarity . in : beame p , editor .",
    "proceedings of the 40th annual symposium on foundations of computer science .",
    "los alamitos ( california ) : ieee computer society .",
    "512 - 522 .",
    "holm , l . and sander , c .",
    "( 1993 ) protein structure comparison by alignment of distance matrices .",
    "biol . , 233 , 123 - 138 .",
    "shindyalov , i.n . and bourne , p.e .",
    "( 1998 ) protein structure alignment by incremental combinatorial extension ( ce ) of the optimal path .",
    "protein eng . , 11 , 739 - 747 .",
    ", zheng , w.m . , clepaps : fast pair alignment of protein structures based on conformational letters",
    ". j. bioinform .",
    "comput . biol .",
    "2008 apr;6(2):347 - 66 .",
    "lackner , p .",
    ", koppensteiner , w.a . , sippl , m.j . , and domingues , f.s .",
    "prosup : a refined tool for protein structure alignment , protein engineering , 2000 ; 13 : 745 - 752 .",
    "ye y , godzik a ( 2003 ) flexible structure alignment by chaining aligned fragment pairs allowing twists . bioinformatics ( supplement 2 ) : ii246-ii255 .",
    "shatsky m , nussinov r , wolfson h ( 2002 ) flexible protein alignment and hinge detection .",
    "proteins 48 : 242 - 256 .",
    "menke m , berger b , cowen l ( 2008 ) matt : local flexibility aids protein multiple structure alignment . plos comput biol 4(1 ) : e10 .",
    "doi:10.1371/journal.pcbi.0040010 . konagurthu a , whisstock j , stuckey p , lesk a ( 2006 ) mustang : a multiple structural alignment algorithm .",
    "proteins 64 : 559 - 574 .",
    "zheng , w.m . and",
    "liu , x . a protein structural alphabet and its substitution matrix clesum .",
    "lecture notes in bioinformatics 3680 ( eds . c. priami and a. zelikovsky )",
    ", springer verlag , berlin , 2005 : 59 - 67 ; zheng , w.m . the use of a conformational alphabet for fast alignment of protein structures .",
    "zhang y , skolnick j. tm - align : a protein structure alignment algorithm based on tm - score .",
    "nucl acid res 2005;77(7):2302 - 2309 .",
    "zhang , y . and skolnick , j .",
    "( 2004 ) scoring function for automated assessment of protein structure template quality .",
    "proteins , 57 , 702 - 710 .",
    "kolodny r , koehl p , levitt m ( 2005 ) comprehensive evaluation of protein structure alignment methods : scoring by geometric measures .",
    "j mol biol 346 : 1173 - 1188 .",
    "gribskov , m . and robinson , n. l. ( 1996 ) .",
    "use of receiver operating characteristic ( roc ) analysis to evaluate sequence matching .",
    "20 , 25 - 33 .",
    "kleywegt , g. j. and jones , a. ( 1994 ) .",
    "ccp4/esf - eacbm newsletter protein crystallog .",
    "31,9 - 14 .",
    "levitt m , gerstein m ( 1998 ) a unified statistical framework for sequence comparison and structure comparison .",
    "proc natl acad sci u s a 95 : 5913 - 5920 .",
    "siew n , elofsson a , rychlewski l , fischer d. maxsub : an automated measure for the assessment of protein structure prediction quality .",
    "bioinformatics 2000;16(9):776 - 785 .",
    "altschul , s. f. , madden , t. l. , schaffer , a. a. , zhang , j. h. , zhang , z. , miller , w. and lipman , d. j. ( 1997 ) .",
    "gapped blast and psi - blast : a new generation of protein database search programs .",
    "acids res .",
    "25 , 3389 - 3402 .",
    "mizuguchi k , deane c , blundell tl , overington j ( 1998 ) homstrad : a database of protein structure alignments for homologous families .",
    "protein sci 11 : 2469 - 2471 .",
    "vanwalle i , lasters i , wyns l ( 2005 ) sabmark - a benchmark for sequence alignment that covers the entire known fold space .",
    "bioinformatics 21 : 1267 - 1268 .",
    "feng , z.k . and sippl , m.j .",
    "( 1996 ) optimum superimposition of protein structures : ambiguities and implications .",
    ", 1 , 123 - 132 .",
    "gnther , j. , bergner , a. , hendlich , m. and klebe , g. utilising structural knowledge in drug design strategies - applications using relibase .",
    "biol . 326 : 621 - 636 ."
  ],
  "abstract_text": [
    "<S> clefaps , a fast and flexible pairwise structural alignment algorithm based on a _ rigid - body _ framework , namely clepaps , is proposed . instead of allowing twists ( or bends ) , </S>",
    "<S> the _ flexible _ in clefaps means : ( a ) flexibilization of the algorithm s parameters through self - adapting with the input structures size , ( b ) flexibilization of adding the aligned fragment pairs ( afps ) into an one - to - multi correspondence set instead of checking their position conflict , ( c ) flexible fragment may be found through an elongation procedure rooted in a vector - based score instead of a distance - based score . </S>",
    "<S> we perform a comparison between clefaps and other popular algorithms including rigid - body and flexible on a closely - related protein benchmark ( homstrad ) and a distantly - related protein benchmark ( sabmark ) while the latter is also for the discrimination test , the result shows that clefaps is competitive with or even outperforms other algorithms while the running time is only 1/150 to 1/50 of them .    * contact * : * wangsheng@itp.ac.cn </S>"
  ]
}