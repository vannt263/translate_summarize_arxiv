{
  "article_text": [
    "in 1961 , spector @xcite presented an extension of gdel s system @xmath0 by a new schema of definition called bar recursion . with this new schema",
    ", he was able to give an interpretation of analysis , extending gdel s dialectica interpretation of arithmetic , and completing preliminary results of kreisel @xcite .",
    "tait proved a normalisation theorem for spector s bar recursion , by embedding it in a system with infinite terms @xcite . in @xcite , an alternative form of bar recursion",
    "was introduced .",
    "this allowed to give an interpretation of analysis by modified realisability , instead of dialectica interpretation .",
    "the paper @xcite presented also a normalisation proof for this new schema , but this proof , which used tait s method of introducing infinite terms , was quite complex .",
    "it was simplified significantly by u. berger @xcite , who used instead a modification of plotkin s computational adequacy theorem @xcite , and could prove _ strong _ normalisation . in a way",
    ", the idea is to replace infinite terms by elements of a domain interpretation .",
    "this domain has the property that a term is strongly normalisable if its semantics is @xmath1    the main contribution of this paper is to show that , using ideas from intersection types @xcite and martin - lf s domain interpretation of type theory @xcite , one can in turn simplify further u. berger s argument .",
    "contrary to @xcite , we build a domain model for an _ untyped _ programming language .",
    "compared to @xcite , there is no need of an extra hypothesis to deduce strong normalisation from the domain interpretation .",
    "a noteworthy feature of this domain model is that it is in a natural way a _",
    "complete _ lattice , and in particular it has a _ top _ element which can be seen as the interpretation of a top - level exception in programming languages . we think that this model can be the basis of _ modular _ proofs of strong normalisation for various type systems . as a main application , we show that martin - lf dependent type theory extended with a program for spector double negation shift @xcite .",
    "spector @xcite remarked that it is enough to add this schema to intuitionistic analysis in order to be able to interpret classical analysis via negative translation . ] , similar to bar recursion , has the strong normalisation property .",
    "our programming language is untyped @xmath2-calculus extended with constants , and has the following syntax .",
    "@xmath3 there are two kinds of constants : _ constructors _ @xmath4 and _ defined constants",
    "_ @xmath5 .",
    "we use @xmath6 to denote a constant which may be a constructor or defined .",
    "each constant has an _ arity _ , but can be partially applied .",
    "we write @xmath7 for the set of free variables of @xmath8 .",
    "we write @xmath9 the result of substituting the free occurences of @xmath10 by @xmath8 in @xmath11 and may write it @xmath12 $ ] if @xmath10 is clear from the context .",
    "we consider terms up to @xmath13-conversion .",
    "the computation rules of our programming language are the usual @xmath14-reduction and @xmath15-reduction defined by a set of rewrite rules of the form @xmath16 where @xmath17 is the arity of @xmath18 and @xmath19 . in this rewrite rule ,",
    "@xmath20 are _ constructor patterns _ _ i.e. _ terms of the form @xmath21 where @xmath22 is the arity of @xmath23 . like in @xcite , we assume our system of constant reduction rules to be _ left linear _ , i.e. a variable occurs at most once in the left hand side of a rule , and _ mutually disjoint _ ,",
    "i.e. the left hand sides of two disjoint rules are non - unifiable .",
    "we write @xmath24 if @xmath8 reduces in one step to @xmath25 by @xmath26-reduction and @xmath27 if @xmath8 , @xmath25 are convertible by @xmath26 conversion .",
    "it follows from our hypothesis on our system of reduction rules that @xmath26-reduction is confluent @xcite .",
    "we write @xmath28 for the set of terms @xmath25 such that @xmath24 .",
    "we work with a given set of constants , that are listed in section [ s : application ] , but our arguments are general and make use only of the fact that the reduction system is left linear and mutually disjoint .",
    "we call upl , for untyped programming language , the system defined by this list of constants and @xmath15-reduction rules",
    ". the goal of the next section is to define a domain model for upl that has the property that @xmath8 is strongly normalizing if @xmath29 .",
    "the _ formal neighbourhoods _ are given by the following grammar : @xmath30    on these neighbourhoods we introduce a _ formal inclusion _",
    "@xmath31 relation defined inductively by the rules of figure [ f : formalinclusion ] . in these rules",
    "we use the formal equality relation @xmath32 defined to be @xmath33 and @xmath34 .",
    "we let @xmath35 be the set of neighbourhoods quotiented by the formal equality .",
    "the terminology `` formal neighbourhoods '' comes from @xcite .",
    "[ formal ] the formal inclusion and equality are both _ decidable _ relations , and @xmath35 is a poset for the formal inclusion relation , and @xmath38 defines a binary meet operation on @xmath35 .",
    "we have @xmath39 if @xmath40 and @xmath41 if and only if @xmath42 . an element in @xmath35 is either @xmath43 or of the form @xmath44 or of the form @xmath45 and this defines a partition of @xmath35 .",
    "furthermore the following `` continuity condition '' holds : if @xmath46 is a ( nonempty ) finite set and @xmath47 then the set @xmath48 is not empty and @xmath49 . note that there is no maximum element , where there usually is one .",
    "this is linked to the fact that we are aiming to prove _ strong _ normalisation , not weak normalisation .",
    "similar results are proved in @xcite .",
    "we introduce the set of neighbourhoods in `` normal form '' by the grammar @xmath50 and define directly the operation @xmath38 and the relation @xmath31 on this set . an element in normal form",
    "@xmath51 is of the form @xmath43 or @xmath52 or is a finite formal intersection @xmath53 where @xmath54 is a nonempty finite set of elements of the form @xmath55 .",
    "the definition of @xmath38 and @xmath31 will be recursive , using the following complexity measure : @xmath56 and @xmath57 .",
    "we define    @xmath58    @xmath59    @xmath60    @xmath61    @xmath62 .",
    "notice that we have @xmath63    we have furthermore @xmath64 and @xmath65 iff @xmath66 for all @xmath67 and finally @xmath68 iff for all @xmath55 in @xmath69 there exists @xmath70 in @xmath54 such that @xmath71 and @xmath72 .",
    "this definition is well founded since @xmath73 and @xmath74 .",
    "one can then prove that relation @xmath31 and the operation @xmath38 satisfies all the laws of figure [ f : formalinclusion ] on the set of neighbourhoods of complexity @xmath75 by induction on @xmath76 .",
    "since all the laws of figure [ f : formalinclusion ] are valid for this structure we get in this way a concrete representation of the poset @xmath35 , and all the properties of this poset can be directly checked on this representation .",
    "we associate to @xmath35 a type system defined in figure [ f : typeinter ] ( when unspecified , @xmath17 is the arity of the related constant ) .",
    "it is a direct extension of the type systems considered in @xcite .",
    "the typing rules for the constructors and defined constants appear to be new however .",
    "notice that the typing of the function symbols is very close to a recursive definition of the function itself . also , we make use of the fact that , as a consequence of lemma [ formal ] , one can define when a constructor pattern matches an element of @xmath35",
    ".    @xmath77 \\infer{\\gamma \\vdash_\\mathcal{m } c : u_1\\rightarrow\\ldots\\rightarrow u_k\\rightarrow c\\ u_1\\ldots u_k }        { } \\\\[3 mm ] \\infer{\\gamma \\vdash_\\mathcal{m } { \\lambda x .",
    "m}:u\\rightarrow v }        { \\gamma , x{:}u \\vdash_\\mathcal{m } m : v } \\\\[3 mm ] \\infer{\\gamma \\vdash_\\mathcal{m } n\\ m : v }        { \\gamma \\vdash_\\mathcal{m } n : u\\rightarrow v & \\gamma\\vdash_\\mathcal{m } m : u } \\\\[3 mm ] \\infer{\\gamma \\vdash_\\mathcal{m } m : u\\cap v}{\\gamma\\vdash_\\mathcal{m } m : u & \\gamma\\vdash_\\mathcal{m }",
    "m : v}\\\\[3 mm ] \\infer{\\gamma \\vdash_\\mathcal{m } m : u } { \\gamma\\vdash_\\mathcal{m } m : v & v\\subseteq u } \\\\[3 mm ] \\infer{\\gamma \\vdash_\\mathcal{m } f : u_1\\rightarrow\\ldots\\rightarrow u_k \\rightarrow v }        { \\begin{array}{cc }          f\\ p_1\\ldots p_k = m & p_i(w_1,\\ldots , w_n)= u_i \\\\",
    "\\multicolumn{2}{c}{\\gamma , x_1{:}w_1,\\ldots , x_n{:}w_n \\vdash_\\mathcal{m } m : v }         \\end{array } } \\\\[3 mm ] \\infer{\\gamma \\vdash_\\mathcal{m } f : u_1\\rightarrow\\ldots\\rightarrow u_k\\rightarrow\\nabla }        { \\begin{array}{c }        \\textrm{for any $ u_1,\\dots , u_k$ such that }",
    "\\\\        \\textrm{no rewrite rule of $ f$ matches $ u_1,\\dots , u_k$ }         \\end{array } } \\end{array}\\ ] ]    [ inversion1 ] if @xmath78 then there exists a family @xmath79 such that @xmath80 and @xmath81 .",
    "direct by induction on the derivation .",
    "[ inversion ] if @xmath82 then @xmath83 .",
    "we have a family @xmath79 such that @xmath80 and @xmath84 . by lemma",
    "[ formal ] there exists @xmath85 such that @xmath86 and @xmath87 .",
    "this together with @xmath80 imply @xmath88 .",
    "[ nm ] if @xmath89 then there exists @xmath90 such that @xmath91 and @xmath92 .",
    "direct by induction on the derivation .",
    "@xmath93 ( the set of simple terms ) is the set of terms that are neither an abstraction nor a constructor headed term , nor a partially applied destructor headed term ( _ i.e. _ @xmath94 is simple if @xmath76 is greater or equal to the arity of @xmath18 ) .",
    "a _ reducibility candidate _",
    "@xmath54 is a set of terms with the following properties :    ( cr1 ) : :    @xmath95 ( cr2 ) : :    @xmath96 if @xmath97 ( cr3 ) : :    @xmath97 if @xmath98 and    @xmath96    it is clear that the reducibility candidates form a complete lattice w.r.t .",
    "the inclusion relation . in particular",
    ", there is a _ least _ reducibility candidate @xmath99 , which can be inductively defined as the set of terms @xmath98 such that @xmath100 .",
    "for instance , if @xmath8 is a variable @xmath10 , then we have @xmath101 since @xmath98 and @xmath102 .",
    "we define two operations on sets of terms , which preserve the status of candidates .",
    "if @xmath23 is a constructor of arity @xmath17 and @xmath103 are sets of terms then the set @xmath104 is inductively defined to be the set of terms @xmath8 of the form @xmath105 , with @xmath106 or such that @xmath98 and @xmath107 . if @xmath54 and @xmath69 are sets of terms , @xmath108 is the set of terms @xmath11 such that @xmath109 if @xmath97 .    if @xmath54 and @xmath69 are reducibility candidates then so are @xmath110 and @xmath108 .",
    "if @xmath111 are reducibility candidates then so is @xmath104 .",
    "the function @xmath112}$ ] associates a reducibility candidate to each formal neighbourhood .",
    "* @xmath113}{\\triangleq}r_0 $ ] * @xmath114}{\\triangleq}c\\ { [ u_1]}\\ldots{[u_k]}$ ] * @xmath115}{\\triangleq}{[u]}\\rightarrow { [ v]}$ ] * @xmath116}{\\triangleq}{[u]}\\cap{[v]}$ ]    [ inclusion ] if @xmath33 for the formal inclusion relation then @xmath117}\\subseteq { [ v]}$ ] as sets of terms .",
    "this follows from the fact that all the rules of figure [ f : formalinclusion ] are valid for reducility candidates .",
    "[ sninter]if @xmath118 then @xmath119}$ ] .",
    "in particular @xmath8 is strongly normalising .    as usual",
    ", we prove that if @xmath120 and @xmath121},\\dots , m_n\\in{[u_n]}$ ] then @xmath122}$ ] .",
    "this is a mild extention of the usual induction on derivations .",
    "we sketch the extra cases :    * subtyping : direct from lemma [ inclusion ] . *",
    "constructor : direct from the definition of @xmath114}$ ] . *",
    "defined constant ( case with a rewrite rule ) : we need a small remark : since @xmath123 for any @xmath22 , we have that @xmath124 implies @xmath125 and @xmath126 by definition of @xmath104 . knowing this we get that if @xmath127},\\ldots,{[w_n]}))$ ] , then @xmath128 can only interract with one rewrite rule ( remember that there is no critical pair ) .",
    "the definition of @xmath104 also tells us that if the @xmath129 are equal to @xmath130 , then @xmath131 . from this",
    "the result follows easily . *",
    "defined constant ( case with no rewrite rule ) : we need the same remark as in the previous case : @xmath124 implies that @xmath125 and @xmath126 .",
    "additionally , @xmath113}$ ] does not contain any constructor - headed term ( since @xmath113}\\subseteq \\mathcal{s}$ ] ) .",
    "a consequence of these two remarks is that there can not be any fully applied constructor - headed term in @xmath115}$ ] , by simple induction .",
    "in particular there is no term matched by a pattern in @xmath115}$ ] .",
    "thus , since there is no rule matching the @xmath132 , we know that for any @xmath133 } , \\ldots , n_k\\in { [ u_k]}$ ] , @xmath128 is not matched by any rewrite rule ; it is , however , a simple term .",
    "it follows easily that @xmath134}$ ] .",
    "an _ i - filter _ over @xmath35 is a subset @xmath135 with the following closure properties :    * if @xmath136 then @xmath137 * if @xmath138 and @xmath33 then @xmath139    it is clear that the set @xmath140 of all i - filters over @xmath35 ordered by the set inclusion is a complete algebraic domain .",
    "the finite elements of @xmath140 are exactly @xmath141 and the principal i - filters @xmath142 .",
    "the element @xmath143 is the greatest element of @xmath140 and the least element is @xmath144 .",
    "we can define on @xmath140 a binary application operation @xmath145 we have always @xmath146 and @xmath147 if @xmath148 .",
    "we write @xmath149 for @xmath150      as usual , we let @xmath151 range over _ environments _ , i.e. mapping from variables to @xmath140 .",
    "if @xmath8 is a term of upl , @xmath152 is the i - filter of neighbourhoods @xmath90 such that @xmath153 for some @xmath154 with @xmath155    a direct consequence of this definition and of theorem [ sninter ] is then    [ sn]if there exists @xmath156 such that @xmath157 then @xmath8 is strongly normalising .",
    "notice also that we have @xmath158 as soon as @xmath159 for all @xmath160 .",
    "because of this we can write @xmath161 for @xmath152 if @xmath8 is closed . if @xmath23 is a constructor , we write simply @xmath23 for @xmath162    [ partition ] we have @xmath163 if @xmath40 and @xmath164 if and only if @xmath165 , whenever @xmath166 .",
    "an element of @xmath140 is either @xmath167 , or @xmath168 or of the form @xmath169 with @xmath23 of arity @xmath17 and @xmath170 or is a sup of elements of the form @xmath171 .",
    "this defines a partition of @xmath140 .",
    "follows from lemma [ formal ] .    as a consequence of lemma [ partition ] , it is possible to define when a constructor pattern matches an element of @xmath140 .",
    "the next result expresses the fact that we have defined in this way a _ strict model _ of upl .",
    "[ model ] @xmath172 if @xmath173 and @xmath174 then @xmath175 . if there is no rule for @xmath18 which matches @xmath176 and @xmath176 are @xmath1 then @xmath177 finally , if for all @xmath178 we have @xmath179 then @xmath180    the second equality follows from lemma [ nm ] and the third equality follows from lemma [ inversion ] .    [ subst ]",
    "the goal of this section is to prove strong normalisation for dependent type theory extended with spector s double negation shift @xcite .",
    "the version of type theory we present is close to the one in @xcite : we have a type of natural numbers @xmath182 , where @xmath183 is an universe .",
    "it is shown in @xcite , using the propositions - as - types principle , how to represent intuitionistic higher - order arithmetic in type theory .",
    "it is then possible to formulate spector s double negation shift as @xmath184 where @xmath185 is an abreviation for @xmath186 and @xmath187 .",
    "spector showed @xcite that it is enough to add this schema ( axiom f in @xcite ) to intuitionistic analysis in order to be able to interpret classical analysis via a negative translation .",
    "we show how to extend dependent type theory with a constant of this type in such a way that strong normalisation is preserved .",
    "it follows then from @xcite that the proof theoretic strength of type theory is much stronger with this constant and has the strength of classical analysis .",
    "we have a constructor @xmath188 of arity 2 and we write @xmath189 instead of @xmath190 , and @xmath191 instead of @xmath190 if @xmath10 is not free in @xmath192 .",
    "we have a special constant @xmath183 for universe .",
    "( we recall that we consider terms up to @xmath13-conversion . )",
    "a _ context _ is a sequence @xmath193 , where the @xmath194 are pairwise distinct .",
    "they are three forms of judgements",
    "@xmath195    the last judgement @xmath196 expresses that @xmath197 is a well - typed context .",
    "we may write @xmath198 $ ] for @xmath199 .",
    "the typing rules are in figure [ f : tt ]    @xmath200 + @xmath201 + @xmath202}\\ ] ] + @xmath203 +   + we express finally that the universe @xmath183 is closed under the product operation . @xmath204 [ f : tt ]    the constants are the ones of our language upl , described in the next subsection .",
    "we describe here both the untyped language upl ( which will define the @xmath15 reduction ) and the fragment of type theory that we need in order to express a program for spector double negation shift .",
    "the constant of form @xmath205 are used as infix operators .",
    "the constructors are @xmath206 ( arity 0 ) , @xmath207 ( arity 1 ) and @xmath208 ( arity 2 ) . to define the domain @xmath140 as in the previous sections , it is enough to know these constructors .",
    "the defined constants of the language upl are @xmath209 , @xmath210 .",
    "the arities are clear from the given @xmath15-rules . from these @xmath15-rules",
    "it is then possible to interpret each of these constants as an element of the domain @xmath140 .    at the same time",
    "we introduce these constants ( constructors or defined constants ) we give their intended types .",
    "first we have the type of natural numbers @xmath211 with two constructors :    @xmath212    we also add the natural number recursor @xmath213 so that the language contains heyting airthmetic :    @xmath214 } \\\\    { \\mathsf{rec } } & p & q & { \\mathsf{0}}&= & n \\\\    { \\mathsf{rec } } & p & q & ( { \\mathsf{s}}\\ x ) & = & m\\ x\\ ( { \\mathsf{rec}}\\ n\\ m\\ x ) \\end{array } $ ]    in addition we add type connectives .",
    "@xmath215 stands for the type disjunction , and @xmath216 for the pair type :    @xmath217 \\\\ \\inr & : & b\\rightarrow a+b~[a , b:\\set ] \\\\",
    "\\multicolumn{3}{l}{}\\\\[-3 mm ] \\multicolumn{3}{l } { \\hspace{-2mm}(\\times ) : \\set\\rightarrow\\set\\rightarrow\\set } \\\\",
    "\\pair & : & a\\rightarrow b\\rightarrow a\\times b~[a , b:\\set ] \\end{array } $ ]    we write @xmath218 instead of @xmath219 , and @xmath220 for @xmath221 .",
    "we also need the empty type @xmath222 ( with no constructor ) :",
    "@xmath223    with which we can define @xmath224 , its elimination rule , also known as _ ex falsum quod libet _ and the negation @xmath225 :    @xmath226}\\\\[1 mm ] \\multicolumn{3}{l } { \\hspace{-2mm}\\neg:\\set\\rightarrow\\set}\\\\    \\neg~a & = & a\\rightarrow{\\hbox{\\sf n$_0$}}\\end{array } $ ]    notice that the constant @xmath224 has no computation rule .",
    "the last type we need to define is @xmath227 , the unit type ( _ i.e. _ with only one trivial constructor ) , in other word the type `` true '' :    @xmath228    notice that @xmath229 is polymorphic and is a constructor of both @xmath227 and @xmath211",
    ".    we can now start defining the more specific functions of our language .",
    "first comes @xmath230 .",
    "it decides if its first argument is less or equal to its second one .",
    "note that it returns either @xmath227 or @xmath222 which are types .",
    "this is an example of strong elimination , _",
    "i.e _ defining a predicate using a recursive function .",
    "@xmath231    consequently we have the function @xmath232 which proves essentially that @xmath230 is a total ordering :    @xmath233    in order to write the proof of the shifting rule it is convenient to have a type of vectors @xmath234 , which is intuitively @xmath235 and an access function of type    @xmath236    notice that this access function requires as an extra argument a proof that the index access is in the right range .",
    "to have such an access function is a nice exercise in programming with dependent types .",
    "this has to be seen as the type of finite approximations of proofs of @xmath237 .",
    "and the access function is the respective elimination rule ( _ i.e. _ a finite version of the forall elimination rule of natural deduction ) .",
    "the type of vectors @xmath238 is defined recursively    @xmath239    with @xmath238 come two simple functions @xmath240 and",
    "@xmath241 accessing respectively the two component of the pair ( any non-@xmath229-indexed vector is a pair of an `` element '' and a shorter vector ) :    @xmath242 \\multicolumn{5}{l } { \\hspace{-2mm}{\\mathsf{tail } } : \\pi x:{\\mathsf{nat}}.({\\mathsf{vec}}~b~({\\mathsf{s}}~x))\\rightarrow { \\mathsf{vec}}~b~x}\\\\    { \\mathsf{tail } } & x & ( v , u ) & = & v \\end{array } $ ]    in order to build the access function for type @xmath238 ( which is supposed to extract the element of type @xmath243 from a vector of a length longer than @xmath10 ) we introduce a function @xmath244 which shortens a vector of type @xmath234 into a vector of type @xmath245 by removing the @xmath246 first elements .",
    "the reason why such a function is useful is because we are trying to read the vector from the inside to the outside .",
    "@xmath247    @xmath248    as a consequence of the function @xmath244 we can define in a rather simple way the access function @xmath249 :    @xmath250    we need the following result on the domain interpretation of this function @xmath249 . to simplify the notations we write @xmath251 instead of @xmath252 if @xmath251 is a constant of the language .",
    "we also write @xmath253 for @xmath254 .",
    "[ extend ] let @xmath255 and @xmath192 such that for any @xmath22 , @xmath256 and @xmath257 ( in particular , @xmath258 ) . if @xmath259 with @xmath260 then @xmath261 . if @xmath262 with @xmath260 then @xmath263 .",
    "let us prove that if @xmath259 with @xmath260 then @xmath261 .",
    "the proof of the second part of the lemma is similar .",
    "it is proved by the following sequence of propositions    * if @xmath264 and @xmath265 for any @xmath266 , @xmath267 , @xmath268 , @xmath269 and @xmath270 for any @xmath22 ( in particular , @xmath271 ) , then @xmath272 .",
    "+ this is proved by simple induction on @xmath273 and @xmath274 . using the definition of @xmath244 together with theorem [ model ] and the fact that @xmath270 implies that @xmath275 for any @xmath22 .",
    "* @xmath276 and @xmath277 . by theorem [ model ] . * if @xmath256 and @xmath257 , then for all @xmath22 @xmath278 .",
    "it is direct by induction on @xmath22 using the definition of @xmath238 and theorem [ model ] . *",
    "finally @xmath279    we can now introduce two functions @xmath280 and @xmath281 , defined in a mutual recursive way .",
    "they define a slight generalisation of the double negation shift :    @xmath282    the program that proves spector s double negation shift @xmath283 is then @xmath284 .",
    "we let @xmath285 be the collection of all subsets of @xmath140 .",
    "if @xmath286 and @xmath287 we define @xmath288 by @xmath289 if and only if @xmath290 implies @xmath291 .",
    "a _ totality predicate _ on @xmath140 is a subset @xmath54 such that @xmath292 and @xmath293 .",
    "we let @xmath294 be the collection of all totality predicates .    if @xmath295 and @xmath296 then @xmath297 .",
    "we have @xmath293 . if @xmath289 then @xmath298 and so @xmath299 and @xmath300 hold . if @xmath290 then @xmath301 so that @xmath302 .",
    "this shows @xmath303 .",
    "[ modeldef ] a _ model _ of type theory is a pair @xmath304 with @xmath305 and @xmath306 satisfying the property : if @xmath307 and @xmath308 implies @xmath309 then @xmath310 .",
    "furthermore @xmath311 .",
    "if we have a collection of constants with typing rules @xmath312 we require also @xmath313 and @xmath314 .",
    "finally , for a model of type theory with universe @xmath183 we require also : @xmath315 , @xmath316 and @xmath317 if @xmath318 and @xmath319 for @xmath308 .",
    "the intuition is the following : @xmath320 is the collection of elements representing types and if @xmath307 the set @xmath321 is the set of elements of type @xmath322 .",
    "the first condition expresses that @xmath0 is closed under the dependent product operation .",
    "the last condition expresses that @xmath183 is a type and that @xmath323 is a subset of @xmath0 which is also closed under the dependent product operation .",
    "the next result states the soundness of the semantics w.r.t .",
    "the type system .",
    "[ sound ] let @xmath324 be a context .",
    "assume that @xmath325 and @xmath326 for @xmath327 in @xmath324 . if @xmath328 then @xmath325 . if @xmath329 then @xmath325 and @xmath330 .",
    "direct by induction on derivations , using theorem [ model ] and corollary [ subst ] .",
    "for instance , we justify the application rule .",
    "we have by induction @xmath331 and @xmath332 .",
    "it follows that we have @xmath333 since @xmath334 we have @xmath335 .",
    "hence by theorem [ model ] and corollary [ subst ] we have @xmath336 { \\rbrack\\!\\rbrack}_{\\rho}}\\ ] ] and so @xmath337 { \\rbrack\\!\\rbrack}_{\\rho}})$ ] as expected .",
    "[ total ] the filter model @xmath140 of upl can be extended to a model @xmath338 .",
    "the main idea is to define the pair @xmath304 in two inductive steps , using lemma [ partition ] to ensure the consistency of this definition .",
    "we define first @xmath339 .",
    "we have @xmath340 and @xmath341 if @xmath342 .",
    "furthermore , we have    * @xmath343 * @xmath344 and @xmath345 * @xmath346 and @xmath347 and @xmath348 if @xmath349 * @xmath350 if @xmath351 and @xmath352 if @xmath353 and @xmath354 if @xmath355 * @xmath356 if @xmath351 and @xmath357 if @xmath353 and @xmath355 * @xmath358 if @xmath342 and @xmath359 for @xmath353 .",
    "furthermore @xmath360 if @xmath361 whenever @xmath353    we can then define @xmath362 and the extension @xmath363 by the same conditions extended by one clause    * @xmath364 * @xmath365 and @xmath345 * @xmath366 and @xmath347 and @xmath348 if @xmath349 * @xmath367 if @xmath368 and @xmath352 if @xmath353 and @xmath354 if @xmath355 * @xmath369 if @xmath368 and @xmath357 if @xmath353 and @xmath355 * @xmath310 if @xmath307 and @xmath370 for @xmath353 .",
    "furthermore @xmath360 if @xmath361 whenever @xmath353 * @xmath315 and @xmath371    the definition of the pair @xmath304 is a typical example of an _ inductive - recursive _ definition : we define simulatenously the subset @xmath0 _ and _ the function @xmath372 on this subset .",
    "the justification of such a definition is subtle , but it is standard @xcite .",
    "it can be checked by induction that @xmath373 and @xmath374 if @xmath307 .",
    "the next subsection proves that @xmath375 if @xmath376 is a typing rule for a constant @xmath251 .",
    "it is rather straightforward to check that we have @xmath377 for all the constants @xmath378 that we have introduced except the last two constants @xmath280 and @xmath281 .",
    "for instance @xmath379 for any @xmath307 since @xmath380 and @xmath381 is in @xmath382 . to check @xmath377 is more complex for the last two functions .",
    "for all constants @xmath378 that we have introduced , we have @xmath377 .    to simplify the notations we write @xmath251 instead of @xmath252 if @xmath251 is a constant of the language , and we say simply that @xmath251 is total instead of @xmath383 .",
    "the only difficult cases are for the constants @xmath384 and @xmath385 .",
    "it is the only place where we use classical reasoning .",
    "we only write the proof for @xmath384 , the case of @xmath385 is similar .",
    "assume that @xmath384 is not total .",
    "we can then find total elements @xmath386 , @xmath387 , @xmath388 , @xmath389 and @xmath390 such that @xmath391 does not belong to @xmath392 .",
    "since @xmath393 and @xmath394 is total , there exists @xmath349 such that @xmath395 is not total at type @xmath243 .",
    "given the definition of @xmath281 this implies that @xmath396 is of the form @xmath397 .",
    "it follows from the definition of @xmath232 that @xmath76 is of the form @xmath398 .",
    "furthermore @xmath399 is not total .",
    "since @xmath400 is total , there exists @xmath401 such that @xmath402 is not total .",
    "reasoning in the same way , we see that there exists @xmath403 such that @xmath404 is not total .",
    "thus we build a sequence of elements @xmath405 for @xmath406 such that , for any @xmath407 @xmath408    consider now an element @xmath409 .",
    "for @xmath410 we have @xmath411 and we take @xmath412 to be @xmath413 .",
    "this is well defined since we have for @xmath414 by lemma [ extend ] @xmath415 we take also @xmath416 .",
    "this defines a total element @xmath18 in @xmath417 .",
    "since @xmath394 is total , @xmath418 is total and belongs to @xmath419 .",
    "hence @xmath420 . since @xmath421 is a finite element of @xmath140 we have by continuity @xmath422 for some finite approximation @xmath423 of @xmath18 .",
    "in particular there exists @xmath407 such that if @xmath424 and @xmath425 , for all @xmath426 , then @xmath427 .",
    "if we define @xmath428 we do have @xmath424 and @xmath425 for all @xmath426 .",
    "hence @xmath427 .",
    "but then @xmath429 which contradicts the fact that the element @xmath430 is _ not _ total .    like in @xcite",
    ", it is crucial for this argument that we are using a domain model .",
    "these constants make also the system proof - theoretically strong , at least the strength of second - order arithmetic .",
    "[ sem ] if @xmath431 then @xmath432 . if @xmath433 then @xmath434 .    if @xmath431 we have by theorem [ sound ] that @xmath313 .",
    "by theorem [ total ] we have @xmath305 .",
    "hence @xmath432 .",
    "similarly , if @xmath433 we have by theorem [ sound ] that @xmath313 and @xmath435 . by theorem [ total ] we have @xmath305 and @xmath436 .",
    "hence @xmath432 and @xmath434 .",
    "by combining corollary [ sem ] with theorem [ sn ] we get    if @xmath431 then @xmath322 is strongly normalisable",
    ". if @xmath433 then @xmath8 is strongly normalisable .",
    "we have built a filter model @xmath140 for an untyped calculus having the property that a term is strongly normalisable whenever its semantics is @xmath1 , and then used this to give various _",
    "modular _ proofs of strong normalization .",
    "while each part uses essentially variation on standard materials , our use of filter models seems to be new and can be seen as an application of computing science to proof theory .",
    "it is interesting that we are naturally lead in this way to consider a domain with a top element .",
    "we have shown on some examples that this can be used to prove strong normalisation theorem in a modular way , essentially by reducing this problem to show the soundness of a semantics over the domain @xmath140 .",
    "there should be no problem to use our model to give a simple normalisation proof of system f extended with bar recursion .",
    "it is indeed direct that totality predicates are closed under arbitrary non empty intersections . by working in the @xmath140-set model over @xmath140 @xcite ,",
    "one should be able to get also strong normalisation theorems for various impredicative type theories extended with bar recursion .    for proving normalisation for _ predicative _ type systems , the use of the model @xmath140 is proof - theoretically too strong : the totality predicates are sets of filters , that are themselves sets of formal neighbourhoods , and so are essentially third - order objects . for applications not involving strong schemas like bar recursion , it is possible however to work instead only with the definable elements of the set @xmath140 , and the totality predicates become second - order objects , as usual .",
    "it is then natural to extend our programming language with an extra element @xmath168 that plays the role of a top - level error .",
    "as suggested also to us by andreas abel , it seems likely that theorem [ sninter ] has a purely combinatorial proof , similar in complexity to the one for simply typed @xmath2-calculus .",
    "he gave such a proof for a reasonable subsystem in @xcite .",
    "a natural extension of this work would be also to state and prove a _ density _",
    "theorem for our denotational semantics , following @xcite .",
    "the first step would be to define when a formal neighbourhood is of a given type .    in @xcite , for untyped @xmath2-calculus without constants ,",
    "it is proved that a term @xmath8 is strongly normalizing if _ and only if _ @xmath434 .",
    "this does not hold here since we have for instance @xmath437 strongly normalizing , but @xmath438 . however , it may be possible to find a natural subset of terms @xmath8 for which the equivalence between @xmath8 is strongly normalizing and @xmath434 holds .",
    "additionally , colin riba showed this result for a system where the neighbourhoods are closed by union but were the rewrite rules are weaker @xcite .    most of our results hold without the hypotheses that the rewrite rules are mutually disjoint .",
    "we only have to change the typing rules for a constant @xmath18 in figure [ f : typeinter ] by the uniform rule : @xmath439 if _ for all _ rules @xmath440 and _ for all _ @xmath441 such that @xmath442 we have @xmath443 .",
    "( this holds for instance trivially in the special case where no rules for @xmath18 matches @xmath444 . ) for instance , we can add a constant @xmath445 with rewrite rules @xmath446 and theorem [ sn ] is still valid for this extension .",
    "thanks to mariangiola dezani - ciancaglini for the reference to the paper @xcite .",
    "the first author wants also to thank thomas ehrhard for reminding him about proofs of strong normalisation via intersection types ."
  ],
  "abstract_text": [
    "<S> ulrich berger presented a powerful proof of strong normalisation using domains , in particular it simplifies significantly tait s proof of strong normalisation of spector s bar recursion . </S>",
    "<S> the main contribution of this paper is to show that , using ideas from intersection types and martin - lf s domain interpretation of type theory one can in turn simplify further u. berger s argument . </S>",
    "<S> we build a domain model for an untyped programming language where u. berger has an interpretation only for typed terms or alternatively has an interpretation for untyped terms but need an extra condition to deduce strong normalisation . as a main application , we show that martin - lf dependent type theory extended with a program for spector double negation shift is strongly normalising . </S>"
  ]
}