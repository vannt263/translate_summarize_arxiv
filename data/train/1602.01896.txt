{
  "article_text": [
    "algorithms for computing game - theoretic solutions have long been of interest to ai researchers . in recent years",
    ", applications of these techniques to security have drawn particular attention .",
    "these applications include airport security  @xcite , the assignment of federal air marshals to flights  @xcite , scheduling coast guard patrols  @xcite , scheduling patrols on transit systems  @xcite , and the list goes on .",
    "game - theoretic techniques are natural in these domains because they involve parties with competing interests ( though the games are usually not zero - sum ) , and the use of mixed ( randomized ) strategies to avoid being predictable to one s opponent is desirable .",
    "these applications have typically used a _ stackelberg _",
    "model where one player ( the defender ) commits to a mixed strategy first and the other ( the attacker ) then optimally responds to this mixed strategy .",
    "formally , the defender ( player @xmath0 ) chooses a mixed strategy @xmath1 , where @xmath2 is the set of best responses to @xmath3 for player @xmath4 ( i.e. , the responses that maximize player @xmath4 s utility ) .",
    "this is in contrast to the more standard solution concept of _ nash equilibrium _",
    ", where both players play a mixed strategy in such a way that each plays a best response to the other  that is , a pair @xmath5 with @xmath6 and @xmath7 .",
    "arguably , the stackelberg solution is well motivated in contexts where the attacker can learn the defender s strategy over time by repeated observation , whereas if this is not the case perhaps the nash solution is better motivated .",
    "it is known that under certain conditions in security games , stackelberg strategies are also nash equilibrium strategies  @xcite .",
    "initial work in these domains modeled uncertainty over attacker preferences using the formalism of bayesian games , assigning probabilities to different types of attackers .",
    "this included the original work at the airport at los angeles  @xcite .",
    "however , subsequent research , which started to focus on compact representations of security games , mostly did not consider bayesian games . in this paper , we introduce a more general framework that can capture such bayesian security games , and study the computation of stackelberg and nash solutions in them ( which in such games generally do not coincide ) .",
    "our framework can also model certain types of _ test games _ in which a tester randomly chooses questions from a fixed database of questions  @xcite .",
    "we show that computing a stackelberg strategy is strongly np - hard , but give an algorithm for computing nash equilibria that combines and expands on earlier techniques in both security and test games .",
    "while we have been unable to show that our algorithm is guaranteed to require at most polynomially many iterations , it requires few iterations in experiments .",
    "more benefits of our framework are listed below : ( 1 ) our notation for catcher - evader games , once one becomes familiar with it , greatly simplifies analysis of those games , especially as it concerns utilities .",
    "for example , our notation expresses the utility delta of a target , which is often the crucial quantity , directly as @xmath8 , rather than as a difference ( e.g. , @xmath9 ) .",
    "( 2 ) our additional parameters @xmath10 allow richer utility functions that security games did not capture previously . for example , targets may have different costs to defend even if the attacker does not attack them .",
    "previous security game definitions always assumed no cost ( or the same cost ) if the attacker does not attack .",
    "( 3 ) it lets us swap the roles of defenders and attackers .",
    "therefore , we can also directly compute the attacker s strategy as well as the defender s strategy , an example of which is computing the tester s strategy in test games .",
    "( 4 ) its connection between security games and test games brings enormous convenience for algorithm design .",
    "previously , separate algorithms had to be designed for them , but now we can design a single algorithm for both .",
    "moreover , we can potentially apply known algorithms for each of these game families to the other . for example",
    ", the aforementioned nash equilibria algorithm combines techniques for security games ( progressively increasing defender or catcher resources ) and test games ( using network flow to reallocate attacker or evader resources ) . ( 5 ) besides security games and test games , it can also capture other interesting scenarios where resources must be assigned to different targets by two competing parties .",
    "for example , two companies , an incumbent and an entrant , might be allocating capital to different markets ; the entrant may wish to evade the incumbent and build up market share , while the incumbent wants to catch the entrant to drive the latter out of business .",
    "we model a catcher - evader game ( ce game ) as a game between one catcher and multiple evaders .",
    "since we assume that the evaders do not care about each other s actions , this is equivalent to a bayesian game between a single - typed catcher and an evader with multiple types .",
    "also , as we will show in section  [ subsection : swapping ] , the roles of catcher and evader can be swapped .",
    "hence , our model also captures games between one evader and multiple catchers .",
    "we represent a ce game by @xmath11 , where @xmath12 is the set of players and @xmath13 is the set of _ sites _",
    "( e.g. , the targets in a security game or the questions in a test game ) .",
    "we fix @xmath14 to be the catcher ( e.g. , the defender in a security game ) , and @xmath15 to be the set of evaders ( e.g. , the multiple types of attackers in a security game ) .",
    "player @xmath16 has available a total resource amount of @xmath17 .",
    "for example , we might set @xmath18 to indicate that @xmath19 has only one resource , or we might set @xmath20 to indicate that , in a bayesian game , a type @xmath19 that appears with probability @xmath21 has only a single resource , and therefore the expected number of resources that this type contributes is @xmath21 .",
    "this resource amount can be split fractionally across the sites , for example , @xmath22 could be assigned to one site and @xmath23 to another .",
    "( this would typically correspond to assigning a single resource to the former site with _ probability _ @xmath22 . )",
    "player @xmath19 can assign a resource amount of at most @xmath24 to site @xmath25 .",
    "for example , we might set @xmath26 to indicate that @xmath19 can assign at most a single resource to @xmath27 , or we might set @xmath28 to indicate that , in a bayesian game , a type @xmath19 that appears with probability @xmath21 can assign at most a single resource to @xmath27 if he appears , and therefore his marginal contribution of probability mass to @xmath27 is at most @xmath21 . generally ,",
    "@xmath29 so the player has to make a nontrivial decision about which site gets more of the resource amount and which one gets less .    finally , the utility is encoded by @xmath30 as follows .",
    "let @xmath31 be the strategy profile where @xmath32 is the resource amount that player @xmath19 puts on site @xmath27 . for convenience ,",
    "we denote @xmath33 as the combined resource amount that all @xmath34 evaders put on site @xmath27",
    ". then the utility is @xmath35 $ ] for the catcher and @xmath36 $ ] for evader @xmath19 .",
    "here , @xmath37 is the _ base utility _ for a player to put a resource at a site , and @xmath8 is the _ utility change _ that results from putting a resource at that site when the opponent puts a resource there as well . since @xmath38 ( _ constant utility _ ) is not affected by any player s strategy , we can ignore it ( or let @xmath39 ) without affecting our analysis of both stackelberg strategies and nash equilibrium .",
    "finally , @xmath40 ( for _ alternating utility _ ) is the utility that a player receives when the opponent puts a resource at that site ; the former player can not affect this .",
    "hence , for nash equilibrium ( but not for stackelberg strategies ) , we can simply drop @xmath40 ( or let @xmath41 ) .",
    "we require @xmath42 for feasibility , as well as @xmath43 and @xmath44 for @xmath45 so that the catcher wants to catch the evader while the evader wants to evade .    for convenience ,",
    "we define @xmath46 and @xmath47 for @xmath45 .",
    "then , we define @xmath48 as the _ per - resource utility _ of player @xmath19 on site @xmath27 . that is , it is the increase in utility she experiences from putting one more resource there .",
    "so , player @xmath19 s utility gained from site @xmath27 can be written as @xmath49 . in a best - response strategy ,",
    "player @xmath19 should have a utility threshold @xmath50 such that ( 1 ) for all @xmath27 with @xmath51 , the player maximizes the resource amount it puts there ( @xmath52 ) , and ( 2 ) for all @xmath27 with @xmath53 , the player puts no resource amount there ( @xmath54 ) .",
    "( there is no requirement for the case @xmath55 . )",
    "the value of @xmath50 is not necessarily unique , so for definiteness , let @xmath56 and @xmath57 for @xmath45 .",
    "incidentally , note that if we do not require @xmath58 and @xmath59 for @xmath45 , then @xmath30 can represent any utility function of the form @xmath60 where @xmath61 is a quadratic polynomial without factors @xmath62 or @xmath63 . in table  [",
    "table : symbols ] , we summarize all symbols for reference .",
    ".symbols used for ce games . [ cols=\"^,<\",options=\"header \" , ]      testing games were recently studied by  @xcite . in that work ,",
    "only test takers that do not fail any questions pass the test ; therefore , it does not matter whether a test taker fails @xmath0 question or @xmath64 .",
    "in contrast , we consider a variant  arguably more realistic  in which the losses and gains the players experience are additive across questions .",
    "we call this variant `` scored tests '' , which captures cases like the gre , the toefl , and most course exams at school .",
    "it allows us to bypass the ( co)np - hardness results for computing the best test strategies from  @xcite .",
    "on the other hand , the transformation to a zero - sum game described in that paper no longer works in this context .",
    "formally , a test game is a 2-player game between a tester and a test taker .",
    "the tester is uncertain about the test taker s type @xmath65 , but she knows that a test taker of type @xmath19 occurs with probability @xmath66 .",
    "the tester has a pool of questions @xmath67 , from which @xmath68 questions will be chosen to form a test @xmath69 ( @xmath70 ) . for a test taker of type @xmath19 ,",
    "a given subset @xmath71 of questions are hard and he will not be able to solve them unless he memorizes their answers ( or writes them on a cheat sheet ) .",
    "however , he can memorize at most @xmath72 questions , so if the tester randomizes over the choice of @xmath73 , there is a good chance that most questions in @xmath73 have not been memorized .",
    "we denote the set of questions @xmath19 chooses to memorized as @xmath74    so far , everything is identical to the games defined by  @xcite .",
    "now we introduce a question score @xmath75 for each @xmath76 .",
    "if a test taker fails to solve @xmath77 in the test , @xmath75 is deducted from his score .",
    "hence the test taker s utility is @xmath78 . can be added to @xmath79 to obtain the usual nonnegative test scores . ]",
    "we also introduce a weight @xmath80 for each question , representing how important the tester thinks it is to find out whether the test taker can solve @xmath77 .",
    "this may or may not be equal to @xmath75 .",
    "the tester s utility is then @xmath81 . here",
    ", @xmath82 denotes the tester s assessment of the importance of test taker type @xmath19 .",
    "for example , it might be more ( or less ) important to figure out the true score of a bad test taker ( with large @xmath83 ) than that of a good one .",
    "we reduce this game to the ce game @xmath84 where @xmath85 .    similar to security games , the resulting strategy profile @xmath86 denotes the marginal probability that a player puts @xmath77 on the test / memorizes @xmath77 ; again , the birkhoff - von neumann theorem allows us to obtain a strategy with these marginals .",
    "the reduction from test games has one issue : the utilities change at rates @xmath87 but ce games require @xmath88 . in a sense",
    ", the tester is an evader who wants to evade by asking questions that are not memorized by the test taker ; but as we have defined them , in ce games , player @xmath89 is a catcher .",
    "we handle this by redefining player @xmath89 s resources to their opposites .",
    "that is , we focus on which questions she does _ not _ test .",
    "hence , the modified @xmath90 will be the marginal probability that she does _ not _ test @xmath77 ( i.e. , @xmath91 ) . in general , we can swap roles between catchers and evaders ( i.e. , negate @xmath8 ) by rewriting ce game @xmath92 as ce game @xmath93 : @xmath94    the correctness of this transformation is the result of the following equations , letting @xmath95 ( note @xmath96 for @xmath45 ) : @xmath97\\\\      & = \\left [ ( b_{0,\\psi } + d_{0,\\psi } x_{\\sigma,\\psi})x_{0,\\psi }              + a_{0,\\psi } x_{\\sigma,\\psi } + c_{0,\\psi } \\right]\\\\      & \\left [ ( b'_{i,\\psi } + d'_{i,\\psi } x'_{0,\\psi})x'_{i,\\psi }              + a'_{i,\\psi}x'_{0,\\psi } + c'_{i,\\psi } \\right]\\\\      & = \\left [ ( b_{i,\\psi } + d_{i,\\psi } x_{0,\\psi})x_{i,\\psi }              + a_{i,\\psi } x_{0,\\psi } + c_{i,\\psi } \\right]\\\\\\end{aligned}\\ ] ]    hence , the utilities are exactly the same as in the original game .",
    "as previously mentioned , @xmath38 does not affect our game - theoretic analysis .",
    "however , it is essential for establishing these equations so we can swap roles . of course ,",
    "after the transformation , we can freely drop @xmath98 .",
    "table  [ table : swap ] shows an example of a test game and how we swap roles in it .",
    "[ theorem : p ] if there is only one evader who can put all resources on any single site ( @xmath99 ) , then catcher stackelberg strategies can be computed in polynomial time .",
    "the proof of theorem  [ theorem : p ]    ( in the full version of this paper )    uses a by now fairly standard linear program technique .",
    "there exists an optimal solution where the evader will assign all its resources to the same best - response site @xmath100 . for each such site @xmath100 , we can write a linear program that produces the optimal stackelberg strategy under the constraint of @xmath100 being a best response ; the best of these solutions overall will be the stackelberg strategy .",
    "( see also  @xcite . )    in contrast , it has been shown that computing stackelberg strategies in a multi - resource security game ( even with only a single type , i.e. , non - bayesian ) is ( weakly ) np - hard  @xcite .",
    "hence , by our reduction of such security games to ce games , even if the ce game has only one evader ( @xmath101 ) , it is ( weakly ) np - hard to compute stackelberg strategies if we allow @xmath102 ( so the evader / attacker will put resources on multiple sites ) .",
    "next , we show that even if @xmath103 for all @xmath104 , it is strongly np - hard to compute stackelberg strategies if we allow @xmath105",
    ". this corresponds to the case of a bayesian security game in which each attacker has only a single resource .",
    "note that the initial lax airport paper  @xcite assumed a bayesian security game with a single attacker resource . to our best knowledge",
    ", no hardness result has been given for computing stackelberg strategies of such games . also , unlike the known weak np - hardness result for multiple resources , this rules out pseudopolynomial - time algorithms .",
    "the proof is in the full version of this paper to save space .    [",
    "theorem : stackelberg ] computing stackelberg strategies in bayesian security games is strongly np - hard even if each attacker type has only a single resource .",
    "consequently , computing stackelberg strategies in a catcher - evader game is strongly np - hard ( if @xmath105 ) , even if @xmath103 for all @xmath45 .",
    "( this result is tight in the sense that this problem is also in np . )",
    "the reduction is from satisfiability . in a satisfiability instance",
    ", there are @xmath34 boolean variables and @xmath106 clauses .",
    "each clause includes a subset of the variables and/or their negations .",
    "the problem is to decide whether there is an assignment of true / false values to the variables such that each clause has at least one literal set to true .",
    "we reduce a satisfiability instance to a security game as follows .",
    "there are @xmath107 targets :    \\(a ) @xmath108 targets corresponding to the variables and their negations",
    ". we will call these _ variable - targets_. the defender gets a utility of @xmath89 if any of these targets is attacked , no matter if it is defended or not . + ( b ) one _ punishment - target_. the defender gets @xmath109 utility if this target is attacked , no matter if it is defended or not .",
    "+ ( c ) one _ bonus - target_. the defender gets a utility of @xmath0 if this target is attacked , no matter if it is defended or not .",
    "the defender has @xmath34 resources .",
    "the attacker types will be set up in such a way that if the satisfiability instance has a solution then the optimal defender strategy is to defend the targets which correspond to the negative - valued literals with probability @xmath0 , and the defender gets a utility of @xmath110 as a result .",
    "( the value of @xmath110 will be defined below . )",
    "if the satisfiability instance has no solution then the defender s stackelberg utility is necessarily below @xmath110 .",
    "there are @xmath111 attacker types :    \\(a ) @xmath108 attacker types whose job is to count how many of the variable - targets are covered with probability @xmath0 ( _ counting - types _ ) .",
    "each of these attacker types is interested in one variable - target and the bonus - target .",
    "if the variable - target is covered with probability @xmath0 then the attacker ( weakly ) prefers the bonus - target and the defender gets a utility of @xmath0 ; otherwise , the attacker prefers the variable - target and the defender gets a utility of @xmath89 .",
    "+ ( b ) @xmath34 attacker types which make sure that for literals @xmath112 and @xmath113 , no more than one corresponding target is covered with probability @xmath0 ( _ paired types _ ) .",
    "each of these attacker types is interested in one pair of variable - targets and in the punishment - target .",
    "if both variable - targets are defended with positive probability then the attacker chooses the punishment target , and the defender gets a utility of @xmath109 .",
    "otherwise , the attacker ( weakly ) prefers the variable - target with @xmath89 probability . + ( c ) @xmath106 attacker types which check whether the clauses are satisfied ( _ clause - types _ ) .",
    "each clause - type is interested in all targets corresponding to the variables in a clause and in the punishment target .",
    "if all the targets in the clause are defended with positive probability ( meaning their values are all false ) then the attacker chooses the punishment target and the defender gets a utility of @xmath109 .",
    "if there is any target defended with probability @xmath89 in the clause then the attacker ( weakly ) prefers that target and the defender gets @xmath89 ( meaning the clause is satisfied ) .",
    "the probability of each type is @xmath114 .",
    "we claim that the defender s optimal utility is @xmath115 if and only if the satisfiability instance has a solution .    *",
    "( satisfiable @xmath116 @xmath117 is feasible ) * the defender can defend , with probability @xmath0 , the targets that correspond to the literals set to false . all paired - types and clause - types will attack variable - targets , from which the defender gets @xmath89 utility .",
    "exactly @xmath34 of the counting - types will attack the bonus target ( each giving the defender a utility of @xmath0 ) and the remaining @xmath34 counting - types will attack variable - targets ( each giving the defender a utility of @xmath89 ) . hence , the defender s total utility will be @xmath118 .    *",
    "( @xmath117 is feasible @xmath116 satisfiable ) * note that only the bonus - target gives the defender positive utility , and only the counting - types are interested in the bonus - target . for the defender to get @xmath118 or more",
    ", there must be @xmath34 or more counting - types attacking the bonus target .",
    "that means there must be @xmath34 or more variable - targets defended with probability @xmath0 .",
    "since the defender has only @xmath34 resources , there must be exactly @xmath34 variable - targets defended with probability @xmath0 , and all the other targets must be defended with probability @xmath89 .",
    "the paired - types enforce that no two of those targets correspond to a variable and its negation .",
    "the clause - types enforce that each clause has at least one target defended with probability @xmath89 .",
    "hence , to get the satisfiability solution , we can set to true the variables corresponding to the targets defended with probability @xmath89 .",
    "we now move on to studying nash equilibria . in general",
    ", a downside of the nash equilibrium concept is that nash equilibria can fail _ interchangeability _ : if one player plays according to one nash equilibrium and the other according to another , the result may not be a nash equilibrium .",
    "however , it has been shown that interchangeability of nash equilibria is guaranteed in security games and test games under certain conditions  @xcite .",
    "we now show that this also holds for ce games .",
    "the key lemma and theorem are shown below .",
    "their proofs are in the full version to save space .",
    "[ lemma : same ] for each site @xmath27 , either @xmath119 is the same for all ne or @xmath120 is the same for all ne .    we first show that the lemma is equivalent to ( a ) there can not be two ne @xmath31 and @xmath121 and some @xmath27 such that @xmath122 and @xmath123 .    it is straightforward to see that the lemma implies ( a ) .",
    "now we prove that ( a ) implies the lemma .",
    "suppose that there exists a site @xmath27 that makes the lemma false .",
    "then pick any ne @xmath31 .",
    "there must be two nes @xmath124 such that @xmath125 and @xmath126 .",
    "if @xmath127 or @xmath128 , then ( a ) is false . if not , @xmath129 and @xmath130 , then ( a ) is still false using @xmath121 and @xmath131",
    "this completes the proof .",
    "we now define 4 possible cases that would contradict ( a ) : @xmath132    we prove that if any one of these 4 cases occurs , all 4 cases must all occur ( on some targets ) .",
    "this results in a contradiction , because the @xmath133 case implies @xmath134 while the @xmath135 case implies @xmath136 .",
    "hence none of the cases can occur , and our theorem holds .",
    "case @xmath133 implying case @xmath137 and case @xmath135 implying case @xmath138 can be proved in the same way as before  @xcite because the catcher is not bayesian .",
    "therefore , we focus on proving that case @xmath138 implies case @xmath133 .",
    "( the proof of case @xmath137 implying case @xmath135 is symmetric . ) assume that @xmath139 is of case @xmath138 .",
    "let @xmath140 and @xmath141 . then @xmath142 and @xmath143 .",
    "let @xmath144 .",
    "we have @xmath145 ( because of @xmath139 )",
    ". then @xmath146 must be true for some @xmath19 .",
    "let @xmath147 .",
    "we have @xmath148 because @xmath149 .",
    "therefore , there exist some @xmath150 and @xmath151 such that @xmath152 and @xmath153 .",
    "note that @xmath152 implies @xmath154 ( @xmath155 where the weak inequalities come from @xmath152 and the strict inequality comes from @xmath156 ) .",
    "then , we have @xmath157 , where the weak inequalities come from @xmath158 . from this",
    "it follows that @xmath159 .",
    "this then implies @xmath160 ( otherwise @xmath161 ) , which allows us to conclude that case @xmath133 holds for @xmath162 .",
    "the nash equilibria ( ne ) of a catcher - evader game are interchangeable .",
    "that is , if @xmath31 and @xmath121 are two nash equilibrium strategy profiles , then so is @xmath131 where @xmath163 and @xmath164 .",
    "the proof is similar to the one given by  @xcite for interchangeability in ( non - bayesian ) security games with multiple attacker resources .",
    "only the proof of lemma 4 in that paper needs to be modified to our lemma  [ lemma : same ] .",
    "the remaining reasoning is unchanged .",
    "the interchangeability established in the previous section provides good motivation for computing a nash equilibrium in this domain . in this section ,",
    "we provide an algorithm for doing so .",
    "the algorithm is significantly more involved than earlier algorithms , notably requiring a min - cost - flow subroutine .",
    "this is perhaps surprising as earlier algorithms  e.g . , the one by  @xcite for computing a nash equilibrium in non - bayesian security games with multiple attacker resources  do not need to do so .",
    "however , in the next subsection , we show it is possible to reduce the problem of finding a minimum - cost fractional matching to our games , suggesting that this complexity is inherent in the problem .",
    "we have been unable to either give a polynomial upper bound on the number of iterations of our algorithm ( each iteration takes polynomial time ) , or any class of instances that results in superpolynomially many iterations .",
    "we only give an exponential upper bound .",
    "however , as we will show , in experiments few iterations suffice .      we show that computing an ne in ce games ( even with single - resource evaders , i.e. , @xmath165 ) is as hard as computing minimum - cost fractional matchings  a common type of flow problem  suggesting that we are unlikely to find a linear - time algorithm .",
    "some of the ideas in the reduction , in particular having costs in the graphs corresponding to the logarithms of utility change rates @xmath8 , will also appear in the algorithm we present later .",
    "computing a nash equilibrium of a ce game is as hard as computing a minimum - cost fractional matching of a weighted bipartite graph .",
    "specifically , if there is a nash equilibrium finding algorithm that runs in @xmath166 time , where @xmath167 is the input size of the ce game , then we can solve the matching problem in @xmath168 time , where @xmath169 is the input size of the bipartite graph .",
    "so computing a ne is not possible in linear time unless there is a linear algorithm for matching .",
    "we reduce the matching instance to a ce game whose ne can be straightforwardly translated back to an optimal solution to the matching instance .",
    "the reduction takes linear time , resulting in the bound in the theorem .",
    "let the matching instance be on a bipartite graph with vertices @xmath170 and @xmath171 .",
    "each vertex @xmath172 has a capacity @xmath173 , with @xmath174 .",
    "each edge @xmath175 has a capacity @xmath176 and a cost @xmath177 .",
    "our goal is to saturate all the vertices capacities at minimum cost .",
    "equivalently , this is a flow problem where @xmath178 flow must be pushed across the bipartite graph at minimum cost .",
    "we construct a ce game @xmath84 where @xmath179 ( so @xmath180 ) , @xmath181 , @xmath182 and @xmath183 for all @xmath184 , @xmath185 and @xmath186 for all @xmath187 and @xmath188 , @xmath189 for all @xmath190 , @xmath191 and @xmath192 for all @xmath184 and @xmath188 .",
    "first , we note that the game has a feasible strategy for the evaders if and only if the matching problem has a feasible solution .",
    "this is because a feasible strategy @xmath193 corresponds exactly to a feasible matching solution .",
    "second , @xmath194 must hold for all @xmath172 . otherwise , because @xmath195 and @xmath196 , all evaders will strictly prefer targets with @xmath197 ; but then the catcher would not be best - responding , because @xmath198 and @xmath199 .    finally , we show that the ne @xmath31 must constitute an optimal solution to the matching problem .",
    "that is , if we let @xmath200 then @xmath201 is the minimum cost in the matching problem .",
    "suppose not ; then , when interpreting @xmath193 as a flow , in the residual graph of that flow , a negative cycle exists .",
    "let that cycle be @xmath202 with @xmath203 , @xmath204 , and @xmath205 for all @xmath206 ( letting @xmath207 ) . recall that @xmath208 is the _ per - resource utility _",
    "threshold for evader @xmath209 .",
    "so , @xmath210 and @xmath211 .",
    "equivalently , + @xmath212 and @xmath213 because @xmath196 .",
    "it then follows that @xmath214 which implies @xmath215 because @xmath194 for all @xmath172 and thus @xmath216 for all @xmath184 . taking the logarithm on both sides , we obtain @xmath217 , contradicting the negative cycle assumption @xmath218 .",
    "we now present our algorithm .",
    "the algorithm works by initializing the catcher s resource amount to @xmath89 and gradually increasing it to @xmath219 , maintaining the equilibrium throughout .",
    "the same high - level approach was used by an earlier paper  @xcite for the case of a single attacker type ( evader ) with multiple resources , obtaining an efficient algorithm there .",
    "however , the case with multiple evaders is significantly more involved .",
    "the ( polynomial - time ) algorithm given in  @xcite did not require anything like a network - flow subroutine , whereas the reduction in section  [ su : matching ] suggests that this is necessary when we have multiple evaders .",
    "our algorithm also incorporates ideas used in the context of test games  @xcite , specifically the binary search and max - flow techniques used there .",
    "we first introduce some notation .",
    "let @xmath220 be the _ boundary sites _ of player @xmath19 .",
    "let @xmath221 be evader @xmath222 s _ positive _ boundary sites , whose resource amount can be reduced .",
    "let @xmath223 be the catcher s _ open _ boundary sites , to which more resources could be assigned .",
    "let the _ active edges _",
    "be @xmath224 .",
    "the main algorithm is algorithm 1 .",
    "after initializing , the algorithm repeatedly loops through algorithms 2 , 3 , and 4 , which together provably ( eventually ) increase the catcher s ( allocated ) resource amount while maintaining equilibrium .",
    "algorithm 2 ensures that a `` no negative cycle '' property holds by solving a min - cost flow problem ( since the residual flow of a min - cost flow can not have a negative cycle ) . here",
    ", the relationship between the evaders best responses and the min - cost flow s `` no negative cycle '' property is similar to the reduction from min - cost matching that we gave earlier .",
    "given that no negative cycle remains , algorithm 3 then attempts to increase the catcher s resource amount  that is , for each @xmath27 it attempts to increase @xmath119without breaking the evaders best - response conditions .",
    "however , algorithm 3 can still fail to increase the catcher s resource amount even without negative cycles .",
    "if so , we call algorithm 4 , which will either allow the next run of algorithm 3 to strictly increase the catcher s resource amount , or change the open boundary sites @xmath225 ( which provably can not happen too often )",
    ". specifically , if algorithm 3 failed to increase the catcher s resource amount , we have to reroute evaders resources among their best - response sites , in a way that strictly decreases the catcher s utility threshold @xmath226 .",
    "such rerouting must also maintain the catcher s best - response condition .",
    "for this we use max - flow and binary search : first , we binary search on @xmath227 , the decrease in @xmath226 ; then , we calculate each edge s rerouting capacity using @xmath227 , and see whether a max - flow can saturate all capacities , thereby maintaining the best - response condition .    @xmath228 @xmath229    run algorithm  [ algorithm : min - cost - flow ] ( min - cost - flow ) run algorithm  [ algorithm : increase ] to weakly increase @xmath119 for all @xmath27 run algorithm  [ algorithm : max - flow ] ( max - flow ) if algorithm  [ algorithm : increase ] failed    @xmath230 @xmath231 initialize @xmath232 @xmath233 @xmath234 @xmath235 @xmath236 @xmath237 min - cost @xmath238-@xmath239 flow in the graph constructed above @xmath240 the reallocated @xmath31    @xmath241 none compute single - source shortest paths from @xmath27 let @xmath242 be the shortest distance from @xmath27 to @xmath172 @xmath243 @xmath244 @xmath245 * break *    failure    @xmath246 @xmath247    @xmath248 @xmath249 [ line : saturate - constraint ] @xmath250 [ line : new - active - constraint ] @xmath251 [ line : increase - delta ]    @xmath252    @xmath253    @xmath254 min - cost flow s residual graph in algorithm  [ algorithm : min - cost - flow ] remove the edges connected to @xmath238 or @xmath239 in @xmath255 add edge @xmath256 to @xmath255 capacity @xmath257 add edge @xmath258 to @xmath255 capacity @xmath259 @xmath260 [ line : decrease - kappa ] @xmath237 max @xmath238-@xmath239 flow of @xmath255 for max feasible @xmath227 @xmath261    [ lemma : no - change ] algorithm 2 maintains nash equilibrium without changing @xmath262 or @xmath50 for any @xmath45 and @xmath25 . as a result , the active edges @xmath263 are also unchanged .",
    "algorithm 2 only reallocates @xmath32 among @xmath263 , hence the evaders necessarily continue to best respond . both the original flow and the min - cost flow are required to saturate all edges @xmath258 .",
    "hence @xmath120 is unchanged for all @xmath264 and the catcher necessarily continues to best respond .",
    "each evader @xmath19 s @xmath262 is clearly unchanged as @xmath119 is untouched by algorithm 2 . by the definition of @xmath265 , the set of positive boundary sites",
    "@xmath266 must be non - empty , which means @xmath267 .",
    "so no matter how we reallocate , some @xmath268 must remain positive . hence , @xmath50 is unchanged because the @xmath262 are unchanged .",
    "[ lemma : rate ] in algorithm 3 , the evaders thresholds @xmath269 decrease at rate @xmath270 .",
    "that is , the algorithm decreases @xmath50 by @xmath271 .    throughout this proof , we require @xmath45 .",
    "we also denote by @xmath272 the values of @xmath273 before increasing @xmath119 . because by definition , @xmath265 , clearly @xmath50 is unaffected by sites @xmath27 for which @xmath274 , because @xmath54 by the best - response property .",
    "for @xmath27 where @xmath275 , it will not affect @xmath50 for small enough @xmath276 .",
    "therefore , for small enough @xmath227 , the threshold @xmath50 is only affected by sites @xmath27 where @xmath277 , or equivalently @xmath278 .",
    "thus , for small enough @xmath227 : @xmath279 note that @xmath280 means that a backward edge @xmath281 exists in the residual graph with weight @xmath282 .",
    "those are the only edges that lead to @xmath19 , hence @xmath283 . therefore , @xmath284 for small enough @xmath227 .",
    "all that remains to show is that @xmath227 is in fact small enough .",
    "this is so because line 25 of algorithm 3 ensures that we stop decreasing before any @xmath285 can affect @xmath50 .",
    "hence the lemma holds .",
    "[ lemma : increase - ne ] after algorithm 2 , if algorithm 3 successfully increases @xmath119 , it maintains nash equilibrium .",
    "the catcher s strategy remains a best response because algorithm 3 does not change any evader s strategy and the catcher only increases @xmath119 for which @xmath286 .",
    "thus we only have to check whether each evader s strategy remains a best response .    by lemma",
    "[ lemma : rate ] and the notation @xmath287 defined in its proof , evaders are best - responding if and only if : @xmath288    for @xmath289 , line 25 of algorithm 3 maintains the conditions above .",
    "now consider @xmath278 .",
    "there , we have @xmath277 , so we only need to check @xmath290    if @xmath291 , a backward edge @xmath281 with weight @xmath282 exists in the residual graph .",
    "hence @xmath292 , which implies @xmath293 .",
    "that is , @xmath294 , and therefore @xmath295 because @xmath296 .    if @xmath297 , a forward edge @xmath298 with weight @xmath299 exists in the residual graph .",
    "hence @xmath300 , which implies @xmath301 .",
    "@xmath302 , and therefore @xmath303 because @xmath296 , completing the proof .",
    "[ lemma : decrease - catcher ] if algorithm 3 fails , then algorithm 4 strictly decreases @xmath226 while maintaining nash equilibrium .",
    "if algorithm 3 fails , then for each @xmath304 , there must be another site @xmath305 .",
    "that is , for each site @xmath306 to which the catcher could increase resource assignment , there is a path in the residual graph that goes from @xmath27 to some site @xmath307 to which the catcher can not increase resource assignment .",
    "that site @xmath308 is , in contrast , a good site for evaders : if they put more resources there , the catcher can not penalize them ( because the catcher can not increase its resources there ) .",
    "formally , there are two cases for @xmath308 : 1 ) @xmath309 ; 2 ) @xmath310 . in the former case",
    ", evaders can increase their resource assignment there as much as possible because the catcher has hit the limit of what it can assign there . in the latter case",
    ", evaders can increase until @xmath311 meets @xmath226 .    therefore ,",
    "for each @xmath312 , evaders can move a positive amount of resource from that site @xmath27 to some @xmath313 using the corresponding residual graph path .",
    "the evaders continue to best - respond because the residual graph only includes active edges @xmath263 .",
    "the catcher s best - response condition is maintained by decreasing @xmath314 by the same positive amount @xmath227 ( the number found by the binary search in algorithm 4 ) for each @xmath315 ( saturating all edges leaving @xmath238 ) , and not letting @xmath316 decrease below @xmath317 ( line 14 of algorithm 4 ) .",
    "because @xmath314 has strictly decreased for each @xmath304 and has not become lower than any @xmath318 , @xmath226 must have strictly decreased ( by @xmath227 ) .",
    "[ lemma : fail - success ] after algorithm 4 , either a new site @xmath27 that previously had @xmath319 now has @xmath320 , or the next run of algorithm 3 will be successful .",
    "suppose that the next run of algorithm 3 fails .",
    "then for each @xmath312 , a path exists in the residual graph ( after the run of algorithm 4 ) from @xmath27 to some @xmath321 , as argued in the proof of lemma  [ lemma : decrease - catcher ] .",
    "suppose , for the sake of contradiction , that none of the edges entering @xmath239 were saturated during the run of algorithm 4 ( for the value of @xmath227 resulting from the binary search ) , i.e. , @xmath322 .",
    "then , in algorithm 4 , we could have increased @xmath227 further , resulting in a contradiction .",
    "therefore , there exists at least one @xmath321 for which the run of algorithm 4 made it the case that @xmath323 . for that @xmath308 , the total amount of evader resource @xmath324",
    "was increased by @xmath325 ( where superscript @xmath89 denotes the value prior to the run of algorithm 4 ) .",
    "it follows that @xmath326 , while @xmath327 .",
    "[ lemma : enter - once ] each site @xmath27 enters @xmath328 at most once ; hence , @xmath328 changes at most @xmath329 times .",
    "only algorithm 4 can change @xmath314 or @xmath226 .",
    "that algorithm ensures that @xmath314 decreases at the same rate for all @xmath312 , and stops decreasing if a new @xmath308",
    "@xmath330 enters @xmath331 .",
    "so a site @xmath27 can only leave @xmath328 by being saturated ( @xmath332 ) .",
    "since we never decrease @xmath119 during the algorithm , saturated sites @xmath27 can never enter @xmath328 again .",
    "[ lemma : bound ] algorithm 3 runs successfully at most @xmath333 times .    by lemma  [ lemma : enter - once ] , we only have to argue that there are at most @xmath334 successful runs before @xmath328 changes .",
    "now we assume that @xmath328 remains unchanged and check how many runs there can be .",
    "we classify an edge @xmath298 where @xmath335 into 3 cases : either ( 1 ) superior @xmath336 ( above threshold ) , or ( 2 ) inferior @xmath337 ( below threshold ) , or ( 3 ) active @xmath338 ( on threshold ) .",
    "let @xmath339 be a vector of length @xmath340 where each element @xmath341 denotes edge @xmath342 s case number .",
    "we will show that @xmath339 changes after each successful run , and it will not repeat if @xmath328 remains unchanged . hence the lemma holds .",
    "we first show that for a fixed @xmath339 , algorithm 4 always returns the same @xmath31 ( assuming that @xmath328 remains unchanged ) .",
    "recall that in algorithm 4 , we proved that if the final flow saturates any edge @xmath343 that enters sink @xmath239 , then @xmath308 will newly enter @xmath328 .",
    "hence if @xmath328 remains unchanged , we can ignore the capacity of those edges entering @xmath239 .",
    "also , with @xmath328 fixed , the set of edges leaving source @xmath238 and their capacities are fixed .",
    "therefore , the resulting @xmath31 of algorithm 4 is solely determined by the edges between @xmath344 and @xmath13 , which is fixed by @xmath339 . , depending on what the min - cost flow is ; but @xmath31 is the additional max - flow applied to the min - cost flow , so what really determines @xmath31 is @xmath339 . ]    we then conclude that if there were two algorithm 3 runs that have the same resulting @xmath339 , then between those two runs , there must be no algorithm 4 run that has positive @xmath227 which strictly decreases @xmath226 .",
    "otherwise , we would have two algorithm 4 runs ( after those two algorithm 3 runs ) with the same @xmath339 , where the latter run has strictly smaller @xmath226 ( note that @xmath226 never increases ) , contradicting that the returning @xmath31 of algorithm 4 is completely determined by @xmath339 .",
    "therefore , if there were two algorithm 3 runs that result in the same @xmath339 , all algorithm 4 runs between those two runs must do nothing ( @xmath345 ) .",
    "hence , @xmath120 is unchanged between those two runs for all @xmath27 , because only algorithm 4 can change @xmath120 .",
    "now consider graph @xmath346 which extends graph @xmath255 in the algorithm 2 by assuming that all edges are active ( @xmath347 ) .",
    "that is , for each edge leaving source @xmath238 , its capacity is @xmath348 ; for each edge entering sink @xmath239 , its capacity is @xmath349 ; the weight and capacity of edge @xmath298 is @xmath350 for all @xmath335",
    ".    then we consider the original set of active edges @xmath263 and make @xmath351 by revising the following edges in @xmath346 : for each edge @xmath352 that is not active , set its weight @xmath353 if @xmath342 is inferior , and @xmath354 if @xmath342 is superior .    clearly , running min - cost flow on @xmath351 would result in the same @xmath31 as running algorithm 2 because we fix non - active edges flow by setting their weights to @xmath355 or @xmath109 .",
    "moreover , for the same flow , the shortest path in the residual graph of @xmath351 is exactly the same as the residual graph of @xmath255 .",
    "hence when we talk about flow or distance , they could refer to either @xmath255 or @xmath351 .",
    "but when we talk about the total cost of the flow , we are referring to @xmath346 , as @xmath351 has infinity cost edges and @xmath255 only has active edges .",
    "that is , the cost of a flow @xmath31 is @xmath356    each time that algorithm 3 runs successfully but the algorithm 1 continues ( @xmath219 is not used up ) , some constraint of line 23 in algorithm 3 must be tight , which means that a new edge @xmath357 must be entering the active edge set @xmath263 ( otherwise we will either continue increasing @xmath119 or change @xmath328 ) .",
    "for that newly active edge , if @xmath358 , then @xmath359 must be true ( recall that @xmath360 is the shortest distance from @xmath100 in the residual graph ) because : @xmath262 s decrease rate @xmath361 must be slower than @xmath50 s decrease rate @xmath270 . similarly ,",
    "if @xmath362 , then @xmath363 must be true .",
    "hence by adding @xmath357 , either @xmath360 has to decrease or a negative cycle exists which leads to a decrease in flow cost ( w.r.t .",
    "@xmath346 ) .    also note that @xmath360 and flow cost are completely determined by @xmath339 if @xmath120 is fixed for all @xmath25 .",
    "hence @xmath339 can not repeat since each @xmath339 change has either to either decrease flow cost , or maintain the flow cost and decrease @xmath360 .",
    "this completes our proof .    with this",
    ", we obtain an exponential upper bound on the algorithm s runtime . because the algorithm only terminates when the number of catcher resources has reached @xmath219 , and we have shown that the algorithm maintains equilibrium throughout , this also establishes the algorithm s correctness .",
    "[ theorem : bound ] algorithm 1 computes a nash equilibrium of the given ce game in @xmath364 iterations .    because of lemmas  [ lemma : no - change ] ,",
    "[ lemma : increase - ne ] , and [ lemma : decrease - catcher ] , nash equilibrium is always maintained .",
    "so we only need to prove that the algorithm stops after at most @xmath365 iterations .",
    "we have at most @xmath366 iterations where algorithm 3 runs successfully , by lemma  [ lemma : bound ] .",
    "each failed iteration must either be followed by a successful iteration , or @xmath328 is changed ( by lemma  [ lemma : fail - success ] ) .",
    "lemma  [ lemma : enter - once ] ensures that @xmath328 can be changed at most @xmath329 times .",
    "so overall there can be at most @xmath367 iterations .",
    "although theorem  [ theorem : bound ] only gives an exponential bound on the number of iterations , the number of iterations in algorithm 1 grows much more slowly  about linearly  in our experiments , as shown in figure  [ fig : exp1 ] . in our experiments , parameters @xmath368 , @xmath37 , and @xmath8 are generated uniformly at random from @xmath369 ( or @xmath370 ) .",
    "each instance of size @xmath34 has @xmath34 evaders and @xmath34 sites ; for each @xmath34 we solved @xmath371 instances .",
    "the running time per iteration is provably polynomial and it grows about cubically as figure  [ fig : iter_time ] shows .",
    "that is consistent with how the network flow subroutine ( which is used in each of our iterations ) typically scales .    an alternative approach to solving",
    "for these nash equilibria would be to construct the normal form of the game and use a standard ne - finding algorithm .",
    "this approach , however , is doomed regardless of the precise choice of algorithm , because the size of the normal form blows up exponentially , as shown in figure  [ fig : exp2 ] .",
    "note that we implemented our algorithm completely in python ( including the min - cost network flow subroutine ) .",
    "hence there is room to further improve the performance by using c / c++ , and/or some optimized network flow libraries .",
    "the obvious direction for future research is resolving whether our algorithm in fact provably runs in polynomial time  and , if not , whether there is another algorithm that does . the algorithm s success in experiments gives us hope that the answer to at least one of these two questions is positive , but we have not been able to decisively answer them .",
    "there are several indications that the question is inherently difficult to answer .",
    "the earlier algorithm for multiple attacker resources in the non - bayesian case and the proof of the polynomial bound on its runtime  @xcite were already quite involved , and we showed that the bayesian case requires us to deal with additional challenging issues ( subsection `` reducing from min - cost matching '' ) .",
    "still , we believe that the importance of solving bayesian security games would justify the devotion of further effort to resolving this question , as well as to extending these techniques to related problems .",
    "we thank ronald parr for his contributions to our early discussions about bayesian security games .",
    "we are also thankful for support from aro under grants w911nf-12 - 1 - 0550 and w911nf-11 - 1 - 0332 , nsf under awards iis-0953756 , iis-1527434 , ccf-1101659 , and ccf-1337215 , and a guggenheim fellowship .",
    "part of this research was done while conitzer was visiting the simons institute for the theory of computing .",
    "b.  an , e.  shieh , m.  tambe , r.  yang , c.  baldwin , j.  direnzo , b.  maule , and g.  meyer . - a deployed game theoretic system for strategic security allocation for the united states coast guard .",
    ", 33(4):96110 , 2012 .          c.  kiekintveld , m.  jain , j.  tsai , j.  pita , f.  ordez , and m.  tambe",
    ". computing optimal randomized resource allocations for massive security games . in _ proceedings of the eighth international joint conference on autonomous agents and multi - agent systems ( aamas )",
    "_ , pages 689696 , budapest , hungary , 2009 .",
    "d.  korzhyk , v.  conitzer , and r.  parr .",
    "complexity of computing optimal stackelberg strategies in security resource allocation games . in _ proceedings of the national conference on artificial intelligence ( aaai ) _ , pages 805810 , atlanta , ga , usa , 2010 .",
    "d.  korzhyk , v.  conitzer , and r.  parr .",
    "security games with multiple attacker resources . in _ proceedings of the twenty - second international joint conference on artificial intelligence ( ijcai ) _ , pages 273279 , barcelona , catalonia , spain , 2011 .",
    "d.  korzhyk , z.  yin , c.  kiekintveld , v.  conitzer , and m.  tambe .",
    "tackelberg vs.  nash in security games : an extended investigation of interchangeability , equivalence , and uniqueness .",
    ", 41(2):297327 , 2011 .",
    "y.  li and v.  conitzer .",
    "game - theoretic question selection for tests . in _ proceedings of the twenty - third international joint conference on artificial intelligence ( ijcai ) _ , pages 254262 , beijing , china , 2013 .",
    "p.  paruchuri , j.  p. pearce , j.  marecki , m.  tambe , f.  ordez , and s.  kraus .",
    "playing games for security : an efficient exact algorithm for solving bayesian stackelberg games . in _ proceedings of the seventh international joint conference on autonomous agents and multi - agent systems ( aamas ) _ , pages 895902 ,",
    "estoril , portugal , 2008 .",
    "j.  tsai , s.  rathi , c.  kiekintveld , f.  ordez , and m.  tambe . - a tool for strategic security allocation in transportation networks . in _ proceedings of the eighth international joint conference on autonomous agents and multi - agent systems ( aamas ) _ , pages 3744 , budapest , hungary , 2009 .",
    "z.  yin , a.  x. jiang , m.  tambe , c.  kiekintveld , k.  leyton - brown , t.  sandholm , and j.  p. sullivan . : scheduling randomized patrols for fare inspection in transit systems using game theory .",
    ", 33(4):5972 , 2012 ."
  ],
  "abstract_text": [
    "<S> algorithms for computing game - theoretic solutions have recently been applied to a number of security domains . however , many of the techniques developed for compact representations of security games do not extend to _ bayesian _ security games , which allow us to model uncertainty about the attacker s type . in this paper </S>",
    "<S> , we introduce a general framework of _ catcher - evader _ games that can capture bayesian security games as well as other game families of interest . </S>",
    "<S> we show that computing stackelberg strategies is np - hard , but give an algorithm for computing a nash equilibrium that performs well in experiments . </S>",
    "<S> we also prove that the nash equilibria of these games satisfy the _ </S>",
    "<S> interchangeability _ property , so that equilibrium selection is not an issue . </S>"
  ]
}