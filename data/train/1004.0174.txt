{
  "article_text": [
    "we consider quantum error correction coding ( qecc ) models where quantum bits ( qubits ) and quantum errors are both modeled as linear combination of pauli matrices @xmath0 .",
    "an [ @xmath1 ( block ) stabilizer code to denote quantum stabilizer codes , ( ... ) to denote classical binary codes , and ( ... ) @xmath2 to denote classical quaternary codes . ] is defined as a codeword space @xmath3 which is _ non - trivially _ stabilized by a subgroup @xmath4 of @xmath5 , where @xmath5 is length-@xmath6 tensor product of pauli - operators @xmath7 , @xmath8 , @xmath9 , @xmath10 . by definition , the independent generators of @xmath4 commute to each other , and @xmath11 .",
    "the dichotomy between the unobservable state of a qubit and the observations we can make , lies at the heart of quantum computation including qecc . in classic error correction ,",
    "output from the channel is observed , measured and used directly in the decoding process .",
    "observation in quantum mechanics not only destroys the quantum state and makes restoration impossible , but the measurement does not tell the original quantum state either . the measured outcome is always one of the two basic states ,",
    "whose probability of occurring is proportional to the power projection of the original state on these two bases .",
    "for this reason , to decode a stabilizer code typically takes three steps : measuring the syndrome , identifying the error pattern based on the syndrome , and applying a corrective operation to reverse the error . the syndrome diagnosis and the error reversal",
    "are well - established quantum mechanical procedures , and operate the same way regardless of the stabilizer configuration . identifying error patterns , a process analogous to syndrome - decoding of classical codes , is most challenging .",
    "not only are the techniques used here specific to the code structure , but they generally involve tedious ( exhaustive ) search in the hilbert space . compared to stabilizer block codes , stabilizer convolutional codes enjoy the flexibility in codeword length and online encoding .",
    "the first comprehensive description of the general formalism of quantum convolutional codes appeared in @xcite , and a variety of quantum convolutional codes has since been proposed @xcite-@xcite .",
    "these studies focus on the code construction ( e.g. based on classical reed - solomon codes , classical low - density parity check codes , and concatenation of classical convolutional codes ) , and do not usually discuss feasible decoding algorithms .",
    "the first decoder for quantum convolutional codes appeared in @xcite , which developed a quantum viterbi algorithm ( qva ) close in spirit to the classical viterbi algorithm .",
    "simplification is made to this qva by attacking only a _",
    "unitary error per block ( and ignoring all the other possible error events ) @xcite .",
    "for quantum convolutional codes constructed from quasi - cyclic sparse matrices , a different type of decoder based on pipeline message passing is developed @xcite .",
    "since the decoder in @xcite tackles only single errors , and that in @xcite performs well only on sparse convolutional codes , the qva in @xcite is by far the only general and ml decoding method available for stabilizer convolutional codes . however , it requires a very high complexity , caused by a very large lookup table and many rounds of the conventional viterbi algorithm . the high complexity and the induced long delay",
    "make this algorithm very challenging to implement ( and it is for this practicality issue that @xcite proposed to simplify it at the cost of degraded performance ) .",
    "the contribution of this paper is the development of a new decoding algorithm which works for a general quantum convolutional code and which is drastically simpler than the existing one . not using lookup tables of any kind",
    ", the proposed algorithm exploits a simple linear - sequential - circuits based mechanism to map a length-@xmath12 ( binary ) syndrome to _ a _ length-@xmath6 ( quaternary ) candidate vector .",
    "this candidate vector is subsequently fed to a conventional viterbi decoder to help identify the mostly likely error pattern .",
    "the entire process is so cleverly engineered that a _ single _ candidate vector ",
    "any one among the pool of @xmath13 possible candidate vectors  suffices to locate _ the _ error pattern in the ml sense .",
    "the high efficiency of this algorithm enables us to , for the first time in quantum coding literature , simulate and present qubit error rate performance curves for a general quantum convolutional code .",
    "a stabilizer convolutional code may be viewed as an infinite version of a stabilizer block codes with repeated structure .",
    "the stabilizer group , @xmath14 , for an [ @xmath15 stabilizer convolutional code is given by @xcite : @xmath16 where @xmath17 is the so - called memory parameter , @xmath18 .",
    ", in @xcite was written as @xmath19 , which is either mistaken or a typo . ] and @xmath20 s are required to be independent and to commute with each other .",
    "like classical convolutional codes , quantum convolutional codes also have flexible and adjustable codeword lengths .",
    "the structure of the stabilizer group generators can also be characterized by a semi - infinite matrix @xmath21 .",
    "similar to the stabilizer block codes , each line in @xmath21 represents a generator ( some @xmath20 ) , and each column represents a qubit . as illustrated in fig .",
    "[ fig : semi_infinite ] , @xmath21 has a block - band structure , and two neighboring blocks of generators overlap by @xmath22 qubits , representing the `` actual memory '' of the quantum convolutional code .     of a quantum convolutional code.,width=316 ]",
    "[ fig : semi_infinite ]    similar to stabilizer block codes , we can label the polynomial generators consisting of pauli elements by @xmath23 polynomial vectors in @xmath24-domain .",
    "the commutation property of stabilizers translates to : @xmath25 where @xmath24 stands for the delay element , similar to that in classical convolutional codes , and @xmath26 denotes the @xmath23 polynomial vectors of a quantum stabilizer code .",
    "the quantum viterbi algorithm discussed in @xcite is the only known general decoder for quantum convolutional codes . a syndrome version of the classical viterbi decoder , the qva operates over pauli - operators ( non - binary input ) .",
    "it starts with a given list of syndromes , and searches for the candidate vectors , which are analogous to the `` received sequence ( codeword ) '' in classical viterbi decoding .",
    "the task is accomplished through table lookup , where the decoder examines the syndromes block by block .",
    "because of the convolutional nature , the output of two neighboring syndrome blocks overlap by @xmath27 qubits , and the table lookup procedure must compare and ensure the overlapping part of the candidate vectors match .",
    "the result is a very long list of candidate vectors all of which correspond to the given syndromes .",
    "every one of these candidate vectors will then be fed into a classical viterbi algorithm , and among them , the most - likely sequence , namely , the error pattern , will be identified .",
    "the overall complexity is rather prohibitive @xcite .",
    "to avoid such a high complexity and still be able to peek into the code s performance , @xcite proposed a simplified decoder that tackles only the most frequent ( but not necessarily the most detrimental ) error patterns , namely , no more than a single error per block .",
    "as such , the algorithm is able to inspect only two consecutive blocks at a time , and hence drastically reduces the size of the lookup table to only 9 terms , at the cost of a compromised decoder performance .",
    "the proposed decoding algorithm roots to the classical syndrome decoding approach for linear codes .",
    "in essence , syndrome decoding is minimum distance decoding , which is equivalent to the maximum likelihood decoding if the channel is discrete memoryless with error probability strictly less than 0.5 .",
    "the linearity of a code allows the code space to be arranged in a special way , termed the _ standard array _ in coding jargon . for an ( @xmath28 )",
    "classical linear block code , the standard array groups all the @xmath29 @xmath6-bit vectors into @xmath30 columns and @xmath31 rows , such that ( i ) the vectors in the same row corresponding to the same syndrome , ( ii ) the first row consists of the set of valid codewords ( starting with the all - zero codeword ) , and ( iii ) the first column consists of all the _ coset leaders _ ,",
    "i.e. correctable error vectors with hamming weights lower than @xmath32 .",
    "each row of the standard array is called a _",
    "coset_. in concept , the function of a syndrome decoder is to identify the coset leader , i.e. the minimum - weight vector , corresponding to a given syndrome , but this seemingly simple function can be extremely expensive to implement in practice .",
    "stabilizer codes in quantum coding are analogous to linear codes in classical coding , and may be tackled through a similar coset representation and syndrome decoding .",
    "the propose decoder here is not only a _",
    "conceptual _ quantum version of the syndrome decoder , but also a _",
    "practical _ mechanism that provides a systematic and concrete way and practical procedure to realize the syndrome decoder with manageable complexity .",
    "the proposed quantum syndrome decoding , which is a low - complexity ml decoding procedure , is depicted in fig .",
    "[ fig : system_model ] .",
    "below we explain why , how , and how efficiently the proposed algorithm works .",
    "we start by transforming the stabilizer generators to a binary polynomial form , and find its equivalent transfer polynomial .",
    "we then detail the step - by - step approach in fig .",
    "[ fig : system_model ] , and demonstrate examples to show how to decode without ( exhaustive ) lookup tables .",
    "[ ht ]        here are a few notations used in the discussion .",
    "a quantum convolutional code may be described by its _ semi - infinite stabilizer matrix @xmath21 _ , or _ stabilizer polynomial @xmath33_. the proposed decoding procedure involves the derivation of the equivalent @xmath23 or @xmath34 classical code from the stabilizer polynomial @xmath33 , which are termed the _ equivalent _ @xmath23 or @xmath34 ) _ transfer polynomial _ , and denoted by @xmath35 or @xmath36 , respectively .",
    "the decoding procedure also makes heavy use of useful concepts in classical coding : _",
    "syndrome former _ ( sf ) and _ inverse syndrome former _ ( isf ) . for a given @xmath37 linear code and hence a deterministic standard array",
    ", the sf finds the syndrome associated with a given sequence ( an error pattern ) , and the isf finds _",
    "one _ error pattern  any one of the @xmath30 possibilities  that associates with a given syndrome .",
    "* decoding algorithm : *    the `` syndrome decoder '' block ( dashed box ) in fig . [ fig : system_model ] illustrates the proposed quantum syndrome decoder , whose input is a binary syndrome sequence obtained from the syndrome measurement .    1 .",
    "represent the original quantum convolutional code using its equivalent @xmath23 transfer polynomial , which leads to an equivalent classical convolutional code .",
    "perform syndrome decoding on the equivalent classical convolutional code , through the following two substeps : 1 .",
    "compute the @xmath23 isf from the equivalent @xmath23 transfer polynomial . use the isf to locate an arbitrary candidate vector in the coset corresponding to the given syndrome",
    "2 .   compute the @xmath23 generator polynomial @xmath38 from the equivalent @xmath23 transfer polynomial . from the generator polynomial , implement a conventional trellis decoder ( such as the viterbi algorithm or the bcjr algorithm ) , and use it to decode the candidate vector into a valid codeword .",
    "exclusive - or ( xor ) the candidate vector and the valid codeword to get the error pattern .",
    "the output of the decoder is a @xmath39-bit binary sequence , which can be re - assembled to an @xmath6-qubit pauli - formed error pattern . this error pattern",
    "is then fed into the `` recovery '' block in fig .",
    "[ fig : system_model ] and counter - acted to recover the original quantum states . * step 1 : deriving equivalent @xmath23 transfer polynomial *    let @xmath33 be the stabilizer polynomial of a quantum convolutional code .",
    "recall that a stabilizer matrix can be described either in the binary @xmath23 form , @xmath40 , where @xmath41 and @xmath42 are symplectically orthogonal , or in a quaternary @xmath34 form , where pauli operators @xmath43 are represented by @xmath34 elements @xmath44 , respectively , conforming to the zero trace inner product ( @xmath45 is a primary element in @xmath34 ) .",
    "a stabilizer code in @xmath34 form takes a similar flavor as an @xmath34 classic code , but the syndrome takes a _ binary _ , rather than quaternary , value . let @xmath46 be a binary row in @xmath47 , and let @xmath48 be a binary error vector . without loss of generality , re - write @xmath49 and @xmath50 in @xmath34 as : @xmath51 , @xmath52 .",
    "the syndrome corresponding to @xmath49 is computed as @xmath53 an immediate and important implication of ( [ eqn : syndrome ] ) is    * lemma 1 : * @xcite an equivalent classical linear code to the quantum convolutional code with stabilizer generator @xmath54 has a binary ( @xmath23 ) transfer polynomial : @xmath55 . here equivalent is meant in terms of decoding capability promised by the code ( disregarding possible degeneracy ) .",
    "* step 2 : syndrome decoding for convolutional codes *    the problem now boils down to performing syndrome decoding for the equivalent classical convolutional codes .    for an ( @xmath56 ) linear code ,",
    "the function of the sf is to map a length-@xmath6 vector to a length-@xmath57 syndrome .",
    "the isf performs the opposite function of sf by locating a length-@xmath6 vector in the coset associated with a given syndrome .",
    "since each coset contains @xmath30 vectors , there are @xmath30 possible outputs an isf may produce , and the resultant vector can be any of the @xmath30 vectors depending on the specific inverse syndrome former being implemented . the choice of the isf will not affect the end - result of the proposed syndrome decoder . efficient and systematic ways exist to implement sf and isf , the simplest of which is through linear transformation or linear circuits . for a linear block code ,",
    "the parity check matrix can serve the role of sf , and the left inverse of the parity check matrix can serve as a matching isf .",
    "the proposed syndrome decoder makes essential use of the functions of sf and isf .",
    "the `` syndrome measurement '' block in fig .",
    "[ fig : system_model ] generates a measure of the syndrome , and the `` syndrome decoder '' block uses a matching isf to acquire a valid vector in the coset associated with that syndrome , and subsequently locates the coset leader after trellis decoding and an xor operation .",
    "finally , the odd - positioned bits and the even - positioned bit in the coset leader are paired up to obtain the tensor product form @xmath58 of the error pattern , which will then be applied to the received quantum sequence ( the `` recovery '' block in fig.[fig : system_model ] , a well - established quantum mechanics procedure ) to get the correct codeword .",
    "* lemma 2 : * the proposed syndrome decoding approach in fig.[fig : system_model ] is valid .    _",
    "proof : _ the validity of this decoder is warranted by the fact that the error pattern / coset leader is the minimum - weight vector inside each coset .",
    "suppose that the transmitter sends a valid binary codeword @xmath59 .",
    "the discrete memoryless channel adds some recoverable binary noise @xmath60 to @xmath59 to yield @xmath61 .",
    "that is , @xmath62 , and hence @xmath63 , where @xmath64 denotes binary addition ( xor ) .",
    "the quantum receiver collects @xmath61 , but instead of having a direct measurement of @xmath61 , it gets a measurement of the syndrome @xmath65 .",
    "we show the the combination of isf and trellis decoding in fig .",
    "[ fig : system_model ] successfully deduce @xmath60 .",
    "inverse syndrome former maps @xmath65 to an arbitrary vector @xmath66 in that coset . in the standard array",
    ", @xmath59 locates in the first row ( corresponding to the zero syndrome , @xmath61 , @xmath60 and @xmath66 all locate in the same row corresponding to the syndrome @xmath65 , @xmath60 is the coset leader ( because it is a recoverable error patten ) , and @xmath61 locates in the same column as @xmath59 ( because @xmath67 ) .",
    "hence , @xmath66 is in fact some codeword corrupted by error @xmath60 , namely , there exist some valid codeword @xmath68 such that @xmath69 .",
    "the vector @xmath66 at the output of the isf is fed to the ml trellis decoder .",
    "if the code can support this channel , then with a probability approaching 1 , the trellis decoder is able to deduce the valid codeword @xmath68 from @xmath66 . since @xmath70 , xoring @xmath68 ( output from trellis decoder ) and @xmath66 ( output from isf ) thus produces the target error pattern @xmath60 .",
    "@xmath71      as discussed before , the proposed syndrome decoder in fig .",
    "[ fig : system_model ] involves two key modules , the isf and a conventional trellis decoder for the equivalent classical convolutional code .",
    "the latter is a well - established procedure , given a generator polynomial .",
    "lemma 1 establishes the relation between a stabilizer polynomial @xmath33 of a quantum convolutional code and the transfer polynomial @xmath35 of its equivalent classical linear convolutional code , below we focus the discussion on the derivation of the isf and the generator polynomial for a given @xmath35 .",
    "there exists intrinsic connection between @xmath23 generator polynomial , transfer polynomial , sf and isf .",
    "specifically , consider a binary @xmath72 convolutional code with transfer polynomial @xmath35 .",
    "the transpose of the transfer polynomial , @xmath73 , which has dimension @xmath74 can serve as an sf .",
    "the generator polynomial can be implemented using a linear sequential circuit specified by @xmath75 transfer function @xmath76 with rank @xmath77 satisfying @xmath78 where @xmath79 is a @xmath77-by-@xmath12 all - zero matrix .",
    "the constraint in ( [ equ : sf2 g ] ) guarantees that all the valid codewords are associated with the length-@xmath12 all - zero syndrome @xmath80 and that a set of length-@xmath6 codewords / vectors have the same syndrome if and only if they belong to the same coset .",
    "inverse syndrome former can be obtained by taking the left inverse of the syndrome former , and is therefore denoted by @xmath81 : @xmath82 where @xmath83 is an identity matrix with rank @xmath84 .",
    "the inverse syndrome former may be derived using the partial gaussian elimination or the moore - penrose matrix inverse method .",
    "the latter states that the left inverse of a rectangular matrix @xmath85 , denoted as @xmath86 , takes the form of @xmath87 .",
    "although the moore - penrose matrix inverse was originally derived in real - valued matrix , it can be easily extended to binary matrix by with module-2 computation .",
    "this example illustrates how to obtain the isf and the generator polynomials from a given sf .",
    "supposed the given sf takes of the form of @xmath88 which corresponds to a rate 1/2 ( classical ) recursive convolutional code . using the moore - penrose procedure , a possible isf and generator polynomial",
    "may be obtained : @xmath89    for a given sf , matching isfs and generator polynomials are not unique .",
    "for instance , in the previous example , another possible choice for isf and generator polynomial are : @xmath90 it is desirable to choose a non - catastrophic generator polynomial , and an inverse syndrome former with a low complexity .",
    "* example 2 : * this example illustrates the entire decoding procedure .",
    "consider the quantum convolutional code in @xcite , which has a semi - infinite stabilizer matrix ( in pauli operator form ) : @xmath91 it represents a @xmath92=[3,1,1]$ ] quantum convolutional code with rate 1/3 .",
    "following the proposed syndrome decoding algorithm , the first step is to derive the equivalent @xmath23 transfer polynomials : @xmath93 whose matrix transpose , @xmath94 , represents the syndrome former of a ( @xmath95 ) @xmath23 ( classical ) convolutional code .",
    "the next step is to derive the isf @xmath96 and the generator polynomial @xmath38 matched to the given sf @xmath94 ( all in @xmath23 ) . following the moore - penrose procedure",
    ", we get @xmath97    the resultant decoder diagram is shown in fig .",
    "[ fig : qcc_decoder ] .",
    "the binary syndrome sequence @xmath98 is separated into two streams , and feeds into the inverse syndrome former , which , in this example , is like a recursive convolutional encoder with two streams in and three streams out .",
    "the output streams assemble to a sequence @xmath66 , passes through a bcjr decoder , and generates a sequence which is a valid codeword .",
    "the difference between the codeword sequence and @xmath66 is the error pattern sequence @xmath99 .",
    "@xmath99 is a binary sequence , and will be divided into 2 parts and packed back to pauli operators accordingly .",
    "[ ht ]       the proposed decoder is applicable to general quantum convolutional codes on a variety of quantum channel models characterized by memoryless independent pauli operators .",
    "the previous discussion and examples are centered around @xmath23 implementation .",
    "when the quantum convolutional code is derived from an @xmath34-linear codes , such as those proposed in @xcite , one may either find its equivalent binary convolutional code as discussed before , or explore syndrome decoding on its equivalent @xmath34 counterpart .",
    "the latter is possible , because the syndromes , which are typically @xmath57-bit binary sequences , may also be represented by a length @xmath101 @xmath34 sequences in this example .",
    "* example 3 : * consider the rate-1/3 [ @xmath102 quantum convolutional code from example 2 , whose equivalent @xmath34 convolutional code has a @xmath34 transfer polynomial @xmath36 @xmath103 the @xmath34 syndrome former is given by @xmath104",
    ".    the isf and the generator polynomial may also be derived in @xmath34 form : @xmath105 clearly , the trellis decoder ( viterbi / bcjr ) in fig .",
    "[ fig : system_model ] can be implemented based on @xmath34 generator polynomial .",
    "the entire syndrome decoding is carried out over a @xmath106 classical @xmath34 convolutional code .",
    "we demonstrate the proposed algorithm by simulation on a memoryless bi - polar pauli error channel , where @xmath8 and @xmath10 occur at probability @xmath107 , and @xmath9 occurs at probability @xmath108 .",
    "[ fig : performance ]    notice that the isf is essentially a recursive convolutional code , padding bits are necessary to generate correct @xmath66 for simulations .",
    "for an [ @xmath15 quantum convolutional code , the padding sequence should be a length-@xmath109 @xmath110 sequence .",
    "we simulated the [ 3,1,1 ] quantum convolutional code at a frame length of 900 qubits and tested 10000 frames .",
    "this is like a @xmath111 $ ] stabilizer block with an additional 6-bit padding ( overhead ) , so the exact code rate is @xmath112 .",
    "the resultant performance curve is shown in fig .",
    "[ fig : performance ] .",
    "we have developed a new syndrome decoding approach , which is applicable to a general stabilizer convolutional code on a general pauli - error channel model .",
    "comparing with the existing quantum viterbi decoder and its simplified version , the new algorithm enjoys significantly lower complexity ( no lookup table , and one - time viterbi ) without scarifying ml performance .",
    "the decoding algorithm roots to the classical syndrome decoding theory , and boasts provenly optimal performance .",
    "using this algorithm , we simulated and presented the first performance curve for a general quantum convolutional code ."
  ],
  "abstract_text": [
    "<S> a novel decoding algorithm is developed for general quantum convolutional codes . exploiting useful ideas from classical coding theory , the new decoder introduces two innovations that drastically reduce the decoding complexity compared to the existing quantum viterbi decoder . </S>",
    "<S> first , the new decoder uses an efficient linear - circuits - based mechanism to map a syndrome to a candidate vector , whereas the existing algorithm relies on a non - trivial lookup table . </S>",
    "<S> second , the new algorithm is cleverly engineered such that only one run of the viterbi algorithm suffices to locate the most - likely error pattern , whereas the existing algorithm must run the viterbi algorithm many times . </S>",
    "<S> the efficiency of the proposed algorithm allows us to simulate and present the first performance curve of a general quantum convolutional code . </S>"
  ]
}