{
  "article_text": [
    "cake cutting is a metaphor for the allocation of a heterogeneous divisible good among multiple agents with possibly different preferences over different parts of the cake .",
    "its main application is fair scheduling , resource allocation , and conflict resolution  @xcite and hence it has been extensively studied within computer science  @xcite and the social sciences  @xcite . since various important divisible resources such as time and land can be captured by cake cutting , the problem of fairly dividing the cake is a fundamental one within the area of fair division and multiagent resource allocation  @xcite .    formally speaking ,",
    "a cake is represented by an interval @xmath0 $ ] and each of the @xmath1 agents has a value function over pieces of the cake that specifies how much that agent values a particular subinterval .",
    "the main aim is to divide the cake fairly . in particular",
    ", an allocation should be envy - free so that no agent prefers to take another agent s allocation instead of his own allocation .",
    "although an envy - free allocation is guaranteed to exist even with @xmath2 cuts  @xcite , _ finding _ an envy - free allocation is a challenging problem which has been termed `` one of the most important open problems in 20th century mathematics '' by garfunkel  @xcite .",
    "[ [ motivation - and - contribution ] ] motivation and contribution + + + + + + + + + + + + + + + + + + + + + + + + + + +    unlike allocation of indivisible items  @xcite , the number of possible allocations in cake cutting is infinite .",
    "since the valuations of agents over the subsets of the cake can be complex , it is not practiceable to elicit each agent s complete valuations function over the cake .",
    "a natural approach in cake cutting protocols to query agents about their valuations of different portions of the cake and based on these queries , propose an allocation .",
    "a cake cutting protocol is _ envy - free _ if each agent is guaranteed an envy - free piece if he reports his real valuations .",
    "for the case of two agents , the problem has a well - known solution in the form of the _ divide and choose _ protocol : one agent is asked to cut the cake into equally preferred pieces and the other agent is asked to choose the preferred piece .",
    "the protocol even features in the book of genesis ( chapter 13 ) where abraham divides the land of canaan and lot chooses first . in modern times , the protocol has been enshrined in the convention of the law of the sea  ( page 10 , * ? ? ?",
    "for the case of three agents , an elegant and bounded protocol was independently discovered by john l. selfridge and john h. conway around 1960  ( page 116 , * ? ? ?",
    "* ) . since then , an efficient envy - free protocol for four or more agents has eluded mathematicians , economists , and computer scientists .    in 1995 ,",
    "brams and taylor  @xcite made a breakthrough by presenting an envy - free protocol for _ any _ number of agents  @xcite . although the protocol is guaranteed to terminate in finite time , there is one critical drawback of the protocol : the running time or number of queries and even the number of cuts required is unbounded even for four agents . in other words",
    ", the number of queries required to identify an envy - free allocation can be arbitrarily large for certain valuations functions .",
    "if a protocol is not bounded , then its practicality is compromised  @xcite .",
    "procaccia  @xcite terms unboundedness as a `` serious flaw '' .",
    "brams and taylor were cognizant of their protocol s drawback and explicitly mentioned the problem of proposing a bounded envy - free protocol even for @xmath3 .",
    "lindner and rothe  @xcite write that `` even for @xmath4 , the development of finite bounded envy - free cake - cutting protocols still appears to be out of reach , and a big challenge for future research . ''",
    "the problem has remained open and has been highlighted in several works  @xcite .",
    "saberi and wang  @xcite term the problem as `` one of the most important open problems in the field '' and lindner and rothe  @xcite mention the case for @xmath3 as `` the central open problem in the field of cake - cutting '' . in this paper , _ we present a discrete envy - free protocol for four agents that requires a bounded number of queries as well as cuts of the cake_. the maximum number of cuts required is 203",
    ". some of the techniques we use may be useful for cake cutting protocols with other properties or for more agents .",
    "in particular , we propose a new technique ( called _ permutation _ ) in which by suitably reallocating portions of a partial allocation that is envy - free , we ensure that some agent will not be envious of another agent _ even _ if the unallocated cake is given to the latter agent .",
    "[ [ related - work ] ] related work + + + + + + + + + + + +    cake cutting problems originated in the 1940 s when famous mathematicians such as banach , knaster , and steinhaus initiated serious mathematical work on the topic of fair division .",
    "since then , the theory of cake cutting algorithms has become a full - fledged field with at least three books written on the topic  @xcite .",
    "the central problem within cake cutting is finding an envy - free allocation  @xcite .    since the earliest works",
    ", mathematicians have been interested in the complexity of cake cutting .",
    "steinhaus  @xcite wrote that `` interesting mathematical problems arise if we are to determine the minimal number of cuts necessary for fair division . ''",
    "when formulating efficient cake cutting protocols , a typical goal is to minimize the number of cuts while ignoring the number of valuations queried from the agents . in principle , the actual complexity of a problem or a protocol depends on the number of queries . when considering how efficient a protocol is , it is useful to have a formal query model for cake - cutting protocols .",
    "robertson and webb  @xcite formalized a simple query model in which there are two kinds of queries : evaluate and cut . in an evaluate query , an agent is asked how much he values a subinterval . in a cut query",
    ", an agent is asked to identify an interval , with a fixed left endpoint , of a particular value .",
    "although , the query model of robertson and webb is very simple , it is general enough to capture all known protocols in the literature .",
    "note that if the number of queries is bounded , it implies that the number of cuts is bounded in the robertson and webb model .",
    "the protocol that we present in this paper uses a bounded number of queries in the robertson and webb model .",
    "cake cutting protocols also provide an interesting connection between the literature on fair division and the field of communication complexity  @xcite .",
    "there is not too much known about the existence of a bounded envy - free protocol for @xmath5 except that any envy - free cake - cutting algorithm requires @xmath6 queries in the robertson - webb model  @xcite .",
    "also , for @xmath7 , there exists no finite envy - free cake - cutting algorithm that outputs _ contiguous _ allocations  @xcite .",
    "brams et al .",
    "@xcite and barbanel and brams  @xcite presented envy - free protocols for four agents that require 13 and 5 cuts respectively . however , the protocols are not only unbounded but not even finite since they are _ continuous _ protocols that require the notion of a _ moving knife_. an alternative approach is to consider known bounded protocols and see how well they perform in terms of envy - freeness  @xcite .",
    "apart from the unbounded brams and taylor envy - free protocol for @xmath1 agents , there are other general envy - free protocols by robertson and webb  @xcite and pikhurko  @xcite that are also unbounded .",
    "there are positive algorithmic results concerning envy - free cake cutting when agents have restricted valuations functions  @xcite or when some part of the cake is left unallocated  @xcite .",
    "there has also been work on _ strategyproof _ cake cutting protocols for restricted valuation functions  @xcite as well as strategic aspects of protocols  @xcite .",
    "[ [ structure - of - the - paper ] ] structure of the paper + + + + + + + + + + + + + + + + + + + + + +    in section  [ prel ] , the formal model is presented . in section  [ section :",
    "warmup ] , we present an envy - free protocol for three agents that serves as a warm - up for the case of four agents . in section  [ section:4agents ] , we presents the main protocol .",
    "the section is divided into subsections in which three different protocols ( _ post double domination protocol _ , _ core protocol _ , and _ permutation protocol _ ) are described .",
    "these three protocols are used as building blocks to formulate the overall protocol .",
    "[ [ model ] ] model + + + + +    we consider a cake which is represented by the interval @xmath0 $ ] .",
    "a _ piece of cake _ is a finite union of disjoint subsets of @xmath0 $ ] .",
    "we will make the standard assumptions in cake cutting .",
    "each agent in the set of agents @xmath8 has his own valuation function over subsets of interval @xmath0 $ ] .",
    "the valuations are    _ defined on all finite unions of the intervals _ ;    _ non - negative _ : @xmath9 for all @xmath10 $ ] ;    _ additive _ : for all disjoint @xmath11 $ ] , @xmath12 ;    _ divisible _ i.e. , for every @xmath10 $ ] and @xmath13 , there exists @xmath14 with @xmath15",
    ".    we will call an allocation _ partial _ if there is some cake that is unallocated .",
    "a partial envy - free allocation is a partial allocation that is envy - free . in order to ascertain the complexity of a protocol , robertson and webb presented a computational framework in which agents are allowed to make two kinds of queries : ( 1 ) for given @xmath16",
    "$ ] and @xmath17 , cut query asks an agent to return a point @xmath18 $ ] such that @xmath19)=r$ ] ( 2 ) for given @xmath20 $ ] , evaluate query ask agent to return a value @xmath17 such that @xmath19)=r$ ] .",
    "a cake - cutting protocol specifies how agents interact with queries and cuts .",
    "a protocol is _ envy - free _ if no agent is envious if he follows the protocol truthfully .",
    "all well - known cake cutting protocols can be analyzed in terms of number of queries required to return a fair allocation .",
    "a cake cutting protocol is _ bounded _ if the number of queries required to return a solution is bounded by a function of @xmath1 _ irrespective _ of the valuations of the agents .",
    "[ [ terms - and - conventions ] ] terms and conventions + + + + + + + + + + + + + + + + + + + + +    we now define some terms and conventions that we will use in the paper . given a partial envy - free allocation of the cake and an unallocated residue @xmath21 , we say that agent @xmath22 _ dominates _ agent @xmath23 if @xmath22 does not become envious of @xmath23 even if all of @xmath21 were to be allocated to @xmath23 .",
    "this concept has been referred to as @xmath23 s _ irrevocable advantage _ in the cake cutting literature  @xcite .    in the cake cutting protocols , we will describe , an agent may be asked to trim a piece of cake so that its value equals the value of a less valuable piece .",
    "agents will be asked to trim various pieces of the cake so their remaining value is equal to the value of the third ( or in some cases their second ) most preferred complete piece . in figure",
    "[ fig : trim ] , we outline the idea of trimming a piece to equal the value of some other piece .",
    "when an agent trims a piece of cake , he will trim it from the left side : the main piece ( albeit trimmed ) will be on the the right side .",
    "the piece minus the trim will be called the partial main piece .",
    "the remainder will be referred to as the _ residue_. if an agent trims a piece , we say he is _ competing _ for the piece .",
    "when we say an agent is _ guaranteed _ to get his second / third / etc most favoured piece , this guarantee is based on the _ ordinal _ preferences of the agents over the pieces . by ordinal ,",
    "we mean that agents simply give a weak ordering over the pieces but do not tell the exact cardinal utility difference between two pieces .",
    "if an agent is indifferent between the top three pieces , then we will still say that the agent is guaranteed to get his third most valued piece .",
    "we introduce notation to represent which agents have trimmed which pieces .",
    "so for example @xmath24 represents the scenario where one piece has three trims ( by agents 1,2,3 ) in any possible order and the other three pieces have one trim each by one of the agents 1 , 2 , 3 .",
    "we may enrich this notation further as follows : @xmath25 which represents that all agents think that the piece with the three trim marks is their most preferred or equivalently highest valued piece .",
    "agent 3 divides the cake into 3 equally preferred pieces .",
    "give that complete piece to the agent who prefers it the most and give remaining piece to @xmath26 and return .",
    "1 and 2 trim their highest valued piece from the left side to make the right side of the trim equal to the value of second most preferred piece ( they simultaneously put trim marks ) .",
    "consider @xmath27 , the remainder from the left extreme of the piece to the leftmost trim .",
    "the partial piece @xmath28 which is the most preferred piece except @xmath27 is given to the agent @xmath29 who trimmed the piece more ( let the other agent be @xmath30 ) .",
    "let @xmath31 be the part between the two trims of agent 1 and 2 .",
    "agent @xmath30 gets his second highest valued complete piece @xmath32 .",
    "agent @xmath26 gets the remaining complete piece .",
    "the unallocated cake is @xmath27 .",
    "3 cuts @xmath27 into 3 equally preferred pieces .",
    "1 and 2 trim their highest valued piece from the left side to make it equal to the value of second best . give that complete piece to the agent who prefers it the most and give remaining piece to @xmath26 and return . , give @xmath30 the most preferred piece up till the leftmost trim , give @xmath23 a complete second most preferred piece , and give @xmath26 the remaining complete piece .",
    ", let @xmath33 be the remainder from the left hand side to the first trim in @xmath27 .",
    "the partial piece @xmath34 which is the most preferred piece except @xmath33 is given to the agent @xmath23 .",
    "let @xmath35 be the part between the two trims .",
    "agent @xmath30 gets his second highest valued complete piece @xmath36 .",
    "agent @xmath26 gets the remaining complete piece .",
    "the only unallocated cake left if any is @xmath33 .",
    "since @xmath23 again got a partial piece , @xmath23 is asked to identify the lesser preferred @xmath37 .",
    "then @xmath23 gives @xmath38 to agent @xmath30 and gets @xmath39 in return .",
    "if some cake is still unallocated , agent @xmath40 and @xmath41 perform divide and choose to allocate it .",
    "we warm - up by presenting a protocol ( algorithm  [ algo:3agents ] ) for @xmath42 which we will extend to @xmath3 .",
    "although the protocol requires more cuts than the selfridge - conway protocol , it bears similarities with it .",
    "it also depends on some ideas that we will exploit for our main protocol for four agents .",
    "the main idea of the protocol is that in each step , the cutter ( agent 3 ) cuts the unallocated cake into 3 equally preferred pieces and gets one of the complete pieces . in each step",
    ", a partial envy - free allocation is maintained and then the remainder is again allocated which results in the remainder being fully allocated or a smaller remainder left . note that when @xmath43 is given the partial cake piece , agent @xmath26 dominates @xmath23 . when the remainder @xmath27 in the first step is divided among the agents ,",
    "if now @xmath26 dominates @xmath30 , then @xmath26 does not care how @xmath27 is divided among @xmath23 and @xmath30 since he dominates both .",
    "so @xmath26 is in this sense ` eliminated ' from the protocol and we can perform divide and choose for 1 and 2 on the unallocated cake .",
    "if @xmath26 again dominates @xmath23 based on how @xmath27 is allocated , then we enforce a _ permutation _ or _ reallocation _ of some pieces of @xmath23 and @xmath30 , so that @xmath26 dominates @xmath30 ( see figure  [ fig3agents - perm ] ) .",
    "both the ideas of domination and permutation will feature prominently in our protocol for four agents .",
    "we now extend the ideas for the case of @xmath42 to @xmath3 .",
    "the general flavour of the protocol is similar to that of the protocol for 3 agents .",
    "a designated cutter is asked to cut into equally preferred pieces .",
    "based on some finer steps , we are able to achieve an envy - free allocation with possibly some cake still unallocated .",
    "we repeat the process on the remaining unallocated piece with the goal that the cutter dominates other agents just as we managed in the protocol for 3 agents .",
    "a few additional complications are introduced when dealing with 4 agents .",
    "eliminating an agent would require being able to ensure that we can make an agent dominate all 3 others .",
    "thankfully this is not necessary : we can show that we only need a protocol that ensures a given agent dominates 2 others .",
    "this is proved in the double domination lemma .",
    "we now present the post double domination protocol ( algorithm  [ algo : postdd ] ) that takes as input a partial envy - free allocation in which each agent dominates two agents and it returns a complete envy - free allocation .    a partial envy - free allocation and unallocated cake such that each agent dominates 2 other agents envy - free complete allocation .",
    "there exists some agent @xmath40 who dominates two other agents say @xmath26 and @xmath44 .",
    "@xmath26 and @xmath44 can divide the remainder by divide and choose .",
    "it dominates @xmath40 and one of @xmath26 and @xmath44 say @xmath44 . give all the remainder to @xmath44 ( since everyone dominates @xmath44 ) .",
    "then let @xmath44 cut the residue into four equally preferred pieces , and agents @xmath45 pick their most preferred remaining piece in that order .",
    "envy - free complete allocation .",
    "= [ ,draw ] = [ ->,>=angle 60 , shorten > = 1pt , draw ] = [ ]    node[circle , fill = white , draw](3)@xmath46 + + ( -45:4 ) node[circle , fill = white , draw](4)@xmath47 + + ( 45:4 ) node[circle , fill = white , draw](2)@xmath48 + + ( 135:4 ) node[circle , fill = white , draw](1)@xmath49 + + ( 225:4 ) ;    \\(1 )  ( 4 ) ; ( 1 )  ( 3 ) ; ( 2 )  ( 1 ) ; ( 2 )  ( 4 ) ; ( 3 )  ( 2 ) ;    [ lemma : dd ] suppose we have a bounded protocol which given a specified agent @xmath23 and an unallocated piece of cake returns a partial envy - free allocation such that @xmath23 dominates 2 other agents , then we can extend this into a 4 agent envy - free bounded protocol .    if we have a bounded protocol in which one agent can be made to dominate two other agents , then we simply run it at most 4 times on any unallocated cake to ensure that each agent dominates two other agents .",
    "if while doing this , the cake is completely allocated , we are already done .",
    "otherwise , we can run the post double domination protocol ( algorithm  [ algo : postdd ] ) .",
    "we now argue for the correctness of the protocol .",
    "assume @xmath40 dominates @xmath26 and @xmath44 .",
    "now if @xmath41 also dominates @xmath26 and @xmath44 , then there exists a partial envy - free allocation in which even if all the residue is given to @xmath26 or @xmath44 , then agent @xmath40 and @xmath41 will not be envious .",
    "all the residue can be divided among @xmath26 and @xmath44 using divide and choose .",
    "agents @xmath40 and @xmath41 do nt care because they dominate @xmath26 and @xmath44 .",
    "the other case is when @xmath41 does not dominate @xmath26 and @xmath44 . without loss of generality",
    "assume that @xmath41 dominates @xmath40 and @xmath44 .",
    "now if @xmath26 dominates @xmath44 , we are already done because the whole residue can be given to @xmath44 since everyone dominates @xmath44 .",
    "if @xmath26 does not dominate @xmath44 but dominates @xmath40 and @xmath41 , then the domination graph looks like in figure  [ fig : dgraph ] , an envy - free allocation can be found via the following method : agent @xmath44 cuts the residue into equally preferred four pieces , and agents @xmath45 pick their most preferred remaining piece in that order .",
    "agent @xmath41 dominates @xmath40 so does not care if @xmath40 chooses first ; agent @xmath26 dominates @xmath41 and @xmath40 so that he does not care if @xmath40 and @xmath41 choose before him .",
    "since we have shown that making an agent dominate two other agents is helpful , we will now explain how to achieve it .",
    "the overall protocol will first achieve double domination for each agent and if some cake is still unallocated , it will use the post double domination protocol . in order to get an agent to dominate other agents , we will repeat a _ core protocol _ multiple times which gives a partial envy - free allocation .",
    "the core protocol is explained in the next section .      in the core protocol ,",
    "a specified agent is asked to cut the cake into equally preferred pieces .",
    "the cutter gets a complete piece whereas the other agents may get partial pieces .",
    "the core protocol is recursively applied to the unallocated cake . after a bounded number of calls of the core protocol , we are in a position to do some reallocation so as to ensure that the specified cutter dominates two agents .",
    "we can then repeat this for another specified agent until each agent dominates two other agents .",
    "we now give a high level description of the _",
    "core protocol_. let us say that agent @xmath44 divides the unallocated cake into @xmath44 pieces .",
    "agents @xmath40 , @xmath41 , and @xmath26 are asked to trim the left hand side of their most preferred two pieces to make the right side of their trim equally valuable as their third most preferred cake piece .",
    "each agent in set @xmath50 trims at most two pieces . in case",
    "an agent is indifferent between two or more pieces , we will still assume that the agent trims one piece to make it equal to the other piece .",
    "the trim in this extreme case is a trivial trim that coincides with the left edge of the cake .",
    "hence the four pieces have a total of six trims . if an agent who trims a piece most is given that piece ( an agent who trims most two pieces can choose which piece to get ) , up to his trim point , then the agent is envy - free . in fact",
    "the agent is not envious even if each other agent who gets a piece is given the piece up till the second rightmost trim .",
    "this approach is useful to get a partial envy - free allocation with some cake unallocated . in the core protocol",
    ", we do some extra work so that apart from the cutter , at least one more agent is given a complete piece . in order to do this , in a couple of cases , we may ask one or two carefully identified agents to additionally trim their most preferred piece to the value of their second most preferred piece in which case the previous trims of these agents are ignored .",
    "this is helpful is ensuring that at least two agents get complete pieces",
    ". it may be the case that some cake is left unallocated in which case the core protocol may be implemented on the unallocated cake again .",
    "the main thing we will prove is that we do not need to implement the core protocol on the unallocated cake unbounded number of times . for this , we first show in the core protocol lemma that the core protocol returns a partial envy - free allocation with the additional useful property that the cutter and one other agent get complete pieces .",
    "specified cutter agent ( say agent 4 ) partial envy - free allocation .",
    "agent 4 is asked to cut the cake into 4 equal value pieces .",
    "agents @xmath45 are asked to give their values for the 4 pieces .",
    "allocate each agent in @xmath50 a most preferred ( complete ) piece and the remaining complete piece to the cutter ( agent 4 ) . the envy - free allocation .",
    "agents @xmath45 are asked to trim the left hand side of their most and second most preferred pieces to make them ( the right side of the trim ) equally valuable as their third most preferred cake piece .    since we have already covered the case in which each agent can be given a complete most preferred piece , we end up in situation @xmath51 .",
    "without loss of generality , the case is @xmath52 . in this case @xmath23 and @xmath53 are asked to trim their most preferred piece to their second most preferred piece whereas agent @xmath22 is asked to trim his two most preferred pieces to equal his third most preferred piece .",
    "agent @xmath23 and @xmath53 s trims up to their third most preferred piece are ignored .",
    "the effective trims look as follows now : @xmath54 .",
    "the right side of each piece with two trims is given to the agent who trimmed it the most .",
    "the piece is given up till the second rightmost trim .",
    "the remaining agent picks his most preferred complete unallocated piece and then 4 get the remaining unallocated piece .",
    "@xmath22 can choose which piece ( up till the second rightmost trim ) to get .",
    "the other piece with the trims is given to the agent with the second rightmost trim up till the second rightmost trim .",
    "the third non - cutter @xmath23 or @xmath53 gets his second most preferred piece completely . the last unallocated complete piece is given to agent 4 .",
    "ask each agent in @xmath50 to trim this first and second most preferred piece from the left side to make the right hand side to the value of his third most preferred piece . each agent",
    "is given the piece he trims the most up till the second rightmost trim .",
    "if the same agent has the rightmost trims for both pieces , he chooses which piece to get . the agent with second rightmost trim",
    "gets the other piece up till the second rightmost trim .",
    "the third non - cutter gets his third most piece completely . the last unallocated complete piece is given to agent 4 .    for @xmath3",
    ", there exists a discrete and bounded protocol which returns partial envy - free allocation in which one agent cuts the cake into four equally preferred pieces and the cutter as well as at least one other agent gets one of these four pieces .",
    "we argue that when agent 4 cuts the cake into equally preferred piece and then these pieces are partially allocated to the agents , then ( 1 ) the partial allocation is envy - free , and ( 2 ) the cutter and one other agent get complete pieces .",
    "if each agent in @xmath50 can be given a most preferred piece , then both conditions are trivially met .",
    "otherwise , the algorithm distinguishes between the following cases :    no piece has exactly one trim ;    exactly one piece has exactly one trim ;    exactly two pieces have exactly one trim ;    exactly three pieces have exactly one trim .    in each of the cases ,",
    "one non - cutter gets a complete piece and the cutter is also given an unallocated complete piece .",
    "it remains to be shown that the partial allocation is envy - free .",
    "when an agent @xmath23 gets a ( possibly partial ) piece @xmath55 , he was the one who trimmed that piece the most .",
    "for each other piece @xmath56 that is allocated , some other agent @xmath22 trimmed @xmath56 at least as much as agent @xmath23 , i.e. , @xmath22 s trim in @xmath56 was not left of @xmath23 s trim .",
    "hence @xmath23 is not envious of @xmath22 if @xmath22 gets @xmath56 up till @xmath22 s trim from the right hand side .",
    "the reason is that @xmath23 thinks that @xmath22 s piece has more value than @xmath23 s allocation only if @xmath22 gets the right side of @xmath56 beyond the trim of agent @xmath23 .",
    "thus , if @xmath23 has the second rightmost trim in @xmath56 , then @xmath23 is not envious of @xmath22 even if @xmath22 gets the right side of @xmath56 up till @xmath23 s trim ( e.g. , see figure  [ fig : trim2 ] ) .",
    "we note that in each of the four cases , when an agent @xmath23 get a piece , he is not envious of another agent @xmath22 because of the reason above . moreover , if in piece @xmath55 , the second rightmost trim is strictly to the left of @xmath23 s trim in @xmath55 or if there is no other trim in @xmath55 , then @xmath23 not only gets the right hand side of @xmath55 up to @xmath23 s trim but an additional bonus up till the second rightmost trim or the edge of the cake ( whichever comes first ) . hence , no agent @xmath23 is envious of another agent @xmath22 .",
    "as soon as the agents ordinal ranking of the four pieces cut by the cutter are known , it can be ascertained whether in the core protocol , an agent is guaranteed to get a piece of value equal to his third or second most preferred piece .",
    "each agent gets a piece that is of same value as his third most preferred piece .",
    "an agent is guaranteed to get a second most preferred piece during the core protocol , if he is asked in the worst case to trim his most preferred piece to his second most preferred piece .",
    "give the complete piece to him .",
    "ask him to trim his first most preferred to equal his second most preferred piece .",
    "the pieces are allocated up to the second rightmost trim to the agents who trimmed them most .",
    "if 2 pieces were trimmed most by the same agent , he decides which to get and the other is given to the agent who trimmed that piece second most . give the last unallocated piece completely to the cutter ( agent 4 ) .",
    "give those pieces with exactly one trim completely to the agents in @xmath50 who trimmed them if it is their most preferred .",
    "agents who trimmed a piece with a single trim but do not value that piece most are asked to re - trim their most preferred piece up to their second most preferred piece .",
    "their trims to make them equal to their third most preferred ignored from now on .",
    "the right hand side of the two pieces with the two trims are given to the agents with the rightmost trims .",
    "the pieces are allocated up till the second rightmost trim . if the 2 pieces were trimmed most by the same agent ( agent @xmath53 ) , he choses which to get and the other piece is given to whoever trimmed it second most .",
    "if one non - cutter has not been allocated a piece , he gets the most preferred piece among the two unallocated complete pieces .",
    "give the last unallocated piece completely to the cutter ( agent 4 ) .",
    "the trims look like @xmath57 .",
    "if an agent most prefers the piece where he made a single trim , give him that complete piece .",
    "the ones who most prefer the piece with the three trims ( call it @xmath55 ) compete for it by trimming up to their second most preferred piece .",
    "their trims to make them equal to their most preferred ignored from now on .    cut @xmath55 at the second rightmost trim , and then allocate @xmath55 to whichever agent trimmed it most .",
    "the other agents get their second most preferred complete piece",
    ". give the cutter ( agent 4 ) the remaining complete piece .",
    "envy - free allocation and any cake that is still not allocated .",
    "we make another observation about the outcome of the core protocol .",
    "[ lemma : completepiece ] during the core protocol , when an agent @xmath23 makes trims to equal his second or third most preferred piece respectively , @xmath23 either gets such a piece completely or some other agent gets such a piece completely that @xmath23 values as much as second or third most preferred piece respectively .",
    "assume agent @xmath23 is not the cutter in the core protocol and he was asked to trim his first and second most preferred pieces to equal his third most preferred piece . if agent @xmath23 gets the complete piece that is his third most preferred piece , we are already done .",
    "let us say that he got a partial piece .",
    "then , at most one other agent got a partial piece .",
    "this means that some other agent @xmath22 got a complete piece that is either agent @xmath23 first , second or third most preferred piece .",
    "assume agent @xmath23 is not the cutter in the core protocol and he was asked to trim his most preferred pieces to equal his second most preferred piece .",
    "this means that @xmath23 got either his most preferred piece up to the value of the second most preferred piece or he got the second most preferred piece completely .",
    "if he got the second most preferred piece completely , we are done .",
    "if @xmath23 got the most preferred piece up to the value of the second most preferred piece , then some other agent got a possibly partial piece from @xmath23 s most preferred piece . but note that since @xmath23 was asked to trim up to his second most piece in the protocol , only @xmath23 was competing for his second most preferred piece .",
    "hence , some other agent @xmath22 got @xmath23 s second most preferred piece completely .",
    "the core protocol for partial envy - free allocation can be extended to obtain protocol for partial envy - free allocation with a single domination .",
    "if the core protocol is run again on the unallocated cake , we show in lemma  [ lemma : single - domination - protocol ] that the cutter dominates at least one agent",
    ". when the core protocol is implemented , then the piece from which the highest valued ( from the perspective of the cutter ) residue is trimmed is called a _ significant piece_.",
    "we will show that the cutter can be made to dominate an agent who got the significant piece .",
    "if residues from both pieces that are partially allocated are of the same value to the cutter , then we say that both non - cutters who got partial pieces were given significant pieces . in this case , a second run of the core protocol is enough for the cutter to dominate two agents .",
    "[ lemma : single - domination - protocol ] for @xmath3 , there exists a discrete and bounded protocol which returns an envy - free partial allocation in which one agent dominates another agent .",
    "we run the core protocol a first time .",
    "this guarantees that the cutter ( say agent 4 ) gets a complete piece ( of value 1/4 of the whole cake ) and that the residue is composed from the trims of at most 2 pieces .",
    "since from the cutter s perspective all pieces were equal , the residue can not sum up to more than 1/2 of the cake for him .",
    "recall that the piece which agent 4 thinks was trimmed is the significant piece .",
    "the total residue is composed of the residue from the significant piece ( call the residue @xmath27 ) and the residue from the other trimmed piece ( let us call this residue @xmath33 ) .",
    "the cutter thinks that he got @xmath58 more value than the agent who got the significant piece . since @xmath59 ,",
    "the value of the total residue from the cutter s perspective is at most @xmath60 .",
    "if we run the core protocol again , at most two pieces are partial and hence the residue s value for the cutter is at most @xmath61 .",
    "this implies that even if the agent who got the significant piece gets all the residue which is of value @xmath58 to the cutter , the cutter would still not envy him .",
    "this implies the cutter dominates the agent who got the significant piece .",
    "although the core protocol can be easily used to enable the cutter to dominate one agent , dominating two agents is more challenging . in the next section , we show how to overcome this challenge .",
    "if we run the core protocol repeatedly on the remaining unallocated cake , it may be that the cutter keeps dominating the same agent .",
    "we show that we only need to run the core protocol 5 times in total to achieve double domination",
    ". it may be that each time , the core protocol is run , the same agent gets the significant piece and hence the cutter dominates the same agent .",
    "if a different agent gets a significant part of the residue in any of the iterations , then the double domination is already achieved with one more iteration since from the cutter s perspective we have 2 agents who may be given all that is left of the cake without him being envious of them . if not , then we have one agent who ends up with the piece from which a significant trim was obtained for all iterations .",
    "the permutation lemma tells us that it is possible to give one of the 4 significant pieces to another agent while still preserving envy - freeness .",
    "this ensures that agent 1 ends up dominating two agents .",
    "an outcome of a core protocol in which one agent ( say agent 4 ) is the cutter and another specified agent ( say agent 1 ) gets the significant piece .",
    "an allocation in which each agent gets a piece equal to the value he trimmed to in the core protocol and in which agent 2 or 3 gets the significant piece .    1 .",
    "if the agent who made the second rightmost trim on agent 2 s piece is agent 1 , then we can simply permute agents 1 and 2 i.e. , exchange their pieces . 2 .",
    "if the agent who made the second rightmost trim on agent 2 s piece is agent 3 , then we can move 3 to agent 2 s piece .",
    "agent 2 can be given 1 s ( trimmed ) piece .",
    "agent 1 can be given one of the complete pieces ( which was given to 3 or 4 ) .",
    "agent 4 can be given the remaining complete piece .    1 .",
    "if 2 s piece is the piece such that agent 1 trimmed up to that value in the core protocol , then simply permute 1 and 2 . 2 .",
    "if 4 is holding the piece such that agent 1 trimmed up to that value in the core protocol then we simply move 4 to 2 s piece since it is a complete piece and agent 1 gets 4 s piece .",
    "agent 2 is given 1 s piece .",
    "if 3 has a complete piece such that agent 1 trimmed up to that value in the core protocol and 3 is indifferent between two pieces among his top 3 pieces , then 3 can be given another complete piece ( such that he trimmed up to the value of that piece ) of either 2 and 4 .",
    "agent 1 can be given 3 s piece .",
    "agent 2 gets 1 s piece and 4 gets the remaining complete piece .",
    "we will use this idea in the argument of the permutation lemma . before presenting the permutation lemma",
    ", we present another lemma that is useful for the proof of the permutation lemma .",
    "[ lemma : wonkicow ] consider @xmath62 rows each with @xmath63 entries of positive reals .",
    "then there exists at least one row such that for each entry in the row , the sum of other entries in the column corresponding to that entry is greater than or equal to the entry in the row .",
    "it is sufficient to find a row in which each entry is not the unique maximum entry for that column .",
    "we go row by row and eliminate a row if it has at least one entry that is a maximal value among all entries in the corresponding column .",
    "even if @xmath63 rows are eliminated , we are left with one row in which each entry is not the unique maximum entry for that column .    we will rely on lemma  [ lemma : wonkicow ] while reasoning about when reallocating pieces does not cause any envy .",
    "in particular let us say that an agent gets slightly more than the value he wanted to guarantee .",
    "he may not want to let go of this extra value lest it leads to him being envious .",
    "however , let us say he gets similar extra values again , then we may ask the agent to choose which one of the extra values he rates least and give this extra value to some other agent .",
    "the other extra values , make up for this loss .",
    "intuitively , lemma  [ lemma : wonkicow ] will help identify that if we have enough subcases ( rows ) then there will be one row on which an agent will be happy to compromise .",
    "we are now in a position to present the permutation lemma .",
    "[ lemma : perm ] there exists a discrete and bounded protocol for 4 agents that returns a partial envy - free allocation in which one agent dominates two other agents .",
    "assume that agents 1 , 2 , 3 , 4 get pieces @xmath64 , @xmath65 , @xmath66 , and @xmath67 respectively with @xmath44 getting complete pieces .",
    "when @xmath44 cut the pieces , @xmath64 is a piece @xmath68 without the part left of the second rightmost trim .",
    "now , assume that in four iterations of the @xmath40 gets the significant piece and we want to reallocate so that some other agent among @xmath41 and @xmath26 gets the significant piece .",
    "we need to show that when the reallocation is done then barring the bonus part that agents get in the core protocol , the agents get at least as preferred a piece .",
    "if another agent aside from agent 1 gets the significant piece then we are done .",
    "if agent 1 is repeatedly getting it , then we zoom in to a case to permute it i.e. , reallocate some of the pieces so as to make sure that an agent other than 1 is dominated . if agent @xmath40 is repeatedly getting the significant piece and there is no reallocation in which instead of agent @xmath40 some other agent gets the significant piece , this means that either ( a ) agent @xmath40 likes the bonus from his significant piece so much that he is not willing to take some other piece or ( b ) for some other agent @xmath22 , the bonus corresponding to the significant piece is not enough for @xmath22 to be attracted towards the significant piece .",
    "[ claim : permutation ] for a partial allocation as a result of the core protocol in which agents make trims , a reallocation can be done in which some agent other than @xmath40 gets the significant piece and each agent gets a piece of value corresponding to his original trims but in which he may lose out on the additional bonus due to the second rightmost trims .",
    "the algorithm to perform the reallocation is stated as the permutation protocol  ( algorithm  [ algo : permutation ] ) .",
    "imagine that agent 1 is holding the significant piece .",
    "for the piece to be significant , another agent must have been competing with agent 1 for it .",
    "if no other agent was competing for the piece , then agent 1 would have got the whole piece and hence the piece would not be significant .",
    "let us say that the agent who competes for the same piece is agent 2 . since the piece was cut up to the second rightmost trim , agent 2 is not envious of any other agent if agent 2 gets the piece ( while not getting his trim ) .",
    "we now distinguish between 2 possibilities .",
    "we show how both cases can be handled .    1 .",
    "* agent 2 was competing with someone for the piece and therefore had a trimmed piece .",
    "* we distinguish between two subcases . 1 .",
    "if the agent who made the second rightmost trim on agent 2 s piece is agent 1 , then we can simply permute agents 1 and 2 i.e. , exchange their pieces . 2 .",
    "if the agent who made the second rightmost trim on agent 2 s piece is agent 3 , then we can move 3 to agent 2 s piece .",
    "notice that 3 must have been allocated a complete piece since only 2 pieces may be trimmed .",
    "this means that 1 did not compete with 3 for 3 s piece which implies that if 1 can get 4 or 3 s piece he will get the piece he was guaranteed before the order of the trim was determined ( either second most preferred or third most preferred ) .",
    "agent 2 can be given 1 s ( trimmed ) piece .",
    "agent 1 can be given one of the complete pieces ( which was given to 3 or 4 ) .",
    "agent 4 can be given the remaining complete piece .",
    "* agent 2 was in possession of a complete piece for which he was not competing with another agent .",
    "* let us focus on the piece agent 1 desires and was guaranteed to get a piece of that value ( either his second most preferred or third most preferred ) .",
    "we will use the fact that by lemma  [ lemma : completepiece ] , some other agent got a complete piece that was of at least as much value to agent 1 .",
    "we distinguish between three subcases",
    "if 2 s piece is the piece agent 1 desires , then simply permute 1 and 2 . 2 .",
    "if 4 is holding the piece to be freed then we simply move 4 to 2 s piece since it is a complete piece and agent 1 gets 4 s piece .",
    "agent 2 is given 1 s piece .",
    "3 .   let us assume that 3 is holding the piece to be freed and agent 1 is guaranteed to get a piece of a value as much as this complete piece ( which we refer to as @xmath55 ) .",
    "+ * if 3 is indifferent among any two of his most preferred three pieces * , then either he is indifferent among the top 2 or among the second and third . for the former ,",
    "if he got a top 2 piece , he will be willing to get another top 2 piece and if he got a third piece , he would certainly be happy to get one of the complete top 2 pieces .",
    "for the latter , if he got one of the second or third preferred pieces , he would be happy to get the other equally preferred one .",
    "if he had got the top piece , then this means that only 3 had a proper trim on @xmath55 . but",
    "this means that @xmath26 is willing to move to another complete piece with as much value barring the extra bonus he got in piece @xmath55 .",
    "hence in all the cases above , 3 can be given another complete piece , agent 1 can be given 3 s complete piece , and 2 can get 1 s partial piece .",
    "* we now assume that 3 is not indifferent among any of his 3 most preferred pieces*. we show that in this scenario , we would already be in one of the previous cases in which 1 is okay with taking 2 or 4 s piece .",
    "+ we first argue that agent @xmath26 s most preferred piece is the significant piece .",
    "piece @xmath55 can not be agent 3 s most preferred piece since otherwise @xmath40 would not be guaranteed to get it : if @xmath40 got it , 3 would be envious .",
    "neither can the piece held by 4 or 2 be 3 s most preferred piece since envy - freeness of the partial allocation will be violated .",
    "since the pieces allocated to 2 , 3 and 4 are not @xmath26 s most valued pieces , it implies that agent @xmath26 s most preferred piece is the significant piece .",
    "+ next , we argue that 3 was allocated his second most preferred piece in which had put a proper trim .",
    "first we assume that 3 trimmed up to his third most preferred piece .",
    "if @xmath55 is 3 s third most preferred piece , then @xmath26 would have been envious of either 2 or 4 whoever got 3 s most preferred piece .",
    "3 would have competed for such as piece and such a piece would not have been allocated completely .",
    "this means that 3 got his second most preferred piece .",
    "second , we assume that 3 trimmed unto his second most preferred piece , then this means 3 was allocated his second most preferred piece since he was guaranteed it . in both cases",
    "3 put a proper trim on @xmath55 .",
    "+ we now argue that @xmath55 ( 3 s piece ) is also agent 1 s second most preferred piece .",
    "if the piece allocated to 2 or 4 was agent 1 s second most preferred piece , we would be in a different case .",
    "+ therefore @xmath55 is agent 1 s and 3 s second most preferred piece .",
    "since @xmath40 is guaranteed to get a piece of value of @xmath55 and since @xmath55 is agent @xmath40 s second most preferred piece , it means that only @xmath40 has a proper trim on @xmath55 .",
    "but we have already shown that @xmath26 also put a proper trim on @xmath55 .",
    "but if two agents put a proper trim on a piece , the piece can not be completely allocated to an agent hence a contradiction .",
    "this complete the proof of the claim .",
    "we have shown that reallocation can be done in which each agent gets a piece of value corresponding the trims the agents made .",
    "note that in each iteration of protocol , each agent gets some ( possibly non - zero ) bonus . since agent @xmath40 gets a significant piece , he gets a non - zero bonus each time .",
    "although @xmath40 may object to any reallocation for a particular iteration of core protocol , we show that he will not envious if one particular iteration of the core protocol is identified in which corresponds to the row of entries in table  [ table : bonus ] in which for each entry in the row , the sum of other entries in the column corresponding to that entry is greater than or equal to the entry in the row . by lemma  [ lemma : wonkicow ] ,",
    "such a row exists .",
    "this means that even if each agent loses his bonus because of the permutation , he gets enough bonus in the other iterations to make for this loss so that there is no envy .",
    "we have shown so far that in four iterations of the core protocol , the partial envy - free allocation is such that two different agents got a significant piece in one of the calls of the core protocol .",
    "if the same agents get a significant piece in all the first four iterations of the core protocol , then we have shown above that the permutation protocol can implemented to give the significant piece to another agent and still not maintain envy - free across the four iterations of the core protocol .",
    "the fifth iteration of the core protocol ensures that the cutter dominates two agents and the partial allocation is envy - free .      in the previous sections",
    ", we built the building blocks for our overall protocol : post double domination protocol , core protocol , and permutation protocol .",
    "we are now in a position to formalize the protocol to compute a complete envy - free allocation and presents the main result .",
    "the protocol is formalized as algorithm  [ algo : ef4agents ] .",
    "run the core protocol ( algorithm  [ algo : core ] ) 4 times on the unallocated cake with @xmath23 as the cutter .",
    "return at any point if there is no cake left unallocated .",
    "identify in which call of the protocol , the non - cutter agents get less bonus than the sum of bonuses in the other calls of the core protocol .",
    "implement reallocation via the permutation protocol ( algorithm  [ algo : permutation ] ) for pieces allocated by this particular call of the core protocol where @xmath23 is the cutter and @xmath22 gets the significant piece .",
    "run core protocol in the unallocated cake if some cake is still unallocated .",
    "run post double domination protocol ( algorithm  [ algo : postdd ] ) on the remaining cake .",
    "envy - free complete allocation .",
    "[ th : finaltheorem ] for four agents , there exists a discrete and bounded envy - free protocol that requires constant number of queries in the robertson and webb model .",
    "the protocol is formalized as algorithm  [ algo : ef4agents ] .",
    "the theorem follows from lemmas  [ lemma : dd ] and [ lemma : perm ] .",
    "the protocol first ensures that there exists a partial envy - free allocation in which each agent dominates two other agents .",
    "the protocol then used the double domination protocol to obtain a complete envy - free allocation .",
    "we now argue in more detail that the protocol is bounded not only in terms of number of cuts but also in terms of robertson - webb queries .    in each run of the core protocol ,",
    "the cutter makes three cuts and then each non - cutter makes at most two trims .",
    "two agents may be asked to replace their cuts and make a cut to make their most preferred piece equal to their second most preferred piece or in another case agents perform divide and choose which requires 1 cut .",
    "hence , in the core protocol , there are at most 3 + 6 + 1=11 cuts .",
    "since we run 5 iterations of the core protocol to get one double domination , we need 50 cuts to get one double domination . since we need each agent to double dominate , we need @xmath69 cuts .",
    "after we achieve double dominations for all agents , we need at most three more cuts .",
    "so we need at most 203 cuts .",
    "we now count the maximum number of robertson - webb query operations required during the protocol .",
    "the cutter is asked the value of the whole cake ( @xmath40 query ) , and then made to cut to equal 1/4 of the value ( @xmath26 queries ) .",
    "the non - cutter agents are asked to give values of the pieces ( @xmath70 queries . )",
    "they are then asked to trim to equal the value of the third most preferred piece ( @xmath71 queries ) .",
    "two agents may be asked to make one additional cut to make their most preferred piece equal to their second most preferred piece ( @xmath72 queries ) or in another case , agents perform divide and choose which requires @xmath44 queries . hence the core protocol requires in total @xmath73 queries .",
    "the core protocol is run 5 times so that takes @xmath74 queries .",
    "in addition to running the core protocol 5 times , we also need to run permutation protocol four times to check which permutation to implement . in each call of the permutation protocol",
    ", agents are queried about the amount of bonus which they get in the core protocol which takes additional 3 queries so in total of 12 queries for the permutation protocol . in order to get all double dominations , we require @xmath75 queries . after we achieve double dominations , we require maximum 16 more queries .",
    "so the total number of queries is 584 .",
    "in this paper , we proposed the first bounded and envy - free protocol for four agents",
    ". some of our insights such as the one of exploiting the bonus cake given to the agents as well as analyzing the domination graph may be useful in attacking the problem for _ any _ number of agents . our protocol is based on three main ingredients : core protocol , permutational protocol , and post double domination protocol .",
    "the higher level ideas of our overall protocol could be applied to general problem for more number of agents .",
    "some of the proof ideas may be generalizable to more than four agents .",
    "for example , a suitable generalization of the core protocol is feasible . on the other hand",
    ", the permutation protocol appears to be challenging to extend to arbitrary number of agents and will require more interesting insights and techniques .",
    "there are also some other interesting directions for future research such as existence and properties of equilibria under our new protocol .",
    "data61 is funded by the australian government through the department of communications and the australian research council through the ict centre of excellence program .",
    "part of the research was carried out when the authors were visiting lamsade , university paris dauphine in may 2015 .",
    "the authors thank rediet abebe , steven brams , simina brnzei , ioannis caragiannis , katarna cechlrov , serge gaspers , david kurokawa , and ariel procaccia for useful comments .",
    "they also thank the reviewers of stoc 2016 for suggestions to improve the presentation .",
    "haris aziz thanks ulle endriss for introducing the subject to him at the cost - adt doctoral school on computational social choice , estoril , 2010 .      h.  aziz and c.  ye .",
    "cake cutting algorithms for piecewise constant and piecewise uniform valuations . in _ proceedings of the 10th international workshop on internet and network economics ( wine ) _ , pages 114 , 2014 .",
    "s.  branzei and p.  b. miltersen . a dictatorship theorem for cake cutting . in _ proceedings of the 23rd international joint conference on artificial intelligence ( ijcai ) _ , pages 482488 .",
    "aaai press , 2015 .",
    "c.  lindner and j.  rothe .",
    "degrees of guaranteed envy - freeness in finite bounded cake - cutting protocols . in _ proceedings of the 5th international workshop on internet and network economics ( wine ) _ , volume 5929 of _ lecture notes in computer science ( lncs ) _",
    ", pages 149159 .",
    "springer - verlag , 2009 .    c.  lindner and j.  rothe .",
    "cake - cutting : fair division of divisible goods . in j.",
    "rothe , editor , _ economics and computation : an introduction to algorithmic game theory , computational social choice , and fair division _ , chapter  7 .",
    "springer - verlag , 2015 .",
    "a.  maya and n.  nisan .",
    "incentive compatible two player cake cutting . in",
    "_ proceedings of the 8th international workshop on internet and network economics ( wine ) _ , volume 7695 of _ lecture notes in computer science ( lncs ) _ , pages 170183 .",
    "springer - verlag , 2012 .",
    "a.  d. procaccia .",
    "cake cutting algorithms . in f.",
    "brandt , v.  conitzer , u.  endriss , j.  lang , and a.  d. procaccia , editors , _ handbook of computational social choice _",
    ", chapter  13 .",
    "cambridge university press , 2016 .",
    "a.  saberi and y.  wang . cutting a cake for five people . in _ proceedings of the 5th international conference on algorithmic aspects in information and management ( aaim ) _ , lecture notes in computer science ( lncs ) , pages 292300 .",
    "springer - verlag , 2009 .",
    "e.  segal - halevi , a.  hassidim , and y.  aumann .",
    "waste makes haste : bounded time protocols for envy - free cake cutting with free disposal . in _ proceedings of the 14th international conference on autonomous agents and multi - agent systems ( aamas )",
    "_ , pages 901908 .",
    "ifaamas , 2015 ."
  ],
  "abstract_text": [
    "<S> we consider the well - studied cake cutting problem in which the goal is to identify an envy - free allocation based on a minimal number of queries from the agents . </S>",
    "<S> the problem has attracted considerable attention within various branches of computer science , mathematics , and economics . </S>",
    "<S> although , the elegant selfridge - conway envy - free protocol for three agents has been known since 1960 , it has been a major open problem to obtain a bounded envy - free protocol for more than three agents . </S>",
    "<S> the problem has been termed the central open problem in cake cutting . </S>",
    "<S> we solve this problem by proposing a discrete and bounded envy - free protocol for four agents . </S>"
  ]
}