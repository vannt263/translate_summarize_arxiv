{
  "article_text": [
    "the advent of ubiquitous wireless networks , from sensor networks tracking environmental patterns to metropolitan areas offering free wireless internet services to residents , upends classical means of routing and delivering information .",
    "the scale , volatility and dynamic nature of these networks present a formidable challenge .",
    "one of the simplest routing algorithms for wireless networks is _ controlled flooding _ where each device retransmits the message to all its neighbors .",
    "the device needs to store the information about the transmission to prevent duplicate message resents .",
    "flooding potentially involves all communication devices of the network and , therefore , does not scale well .",
    "early routing algorithms are typically routing - table based  @xcite .",
    "however , maintenance of these tables is resource intensive and is often infeasible .",
    "geometric routing offers more scalable and resource frugal solutions to wireless navigation . in _ geometric routing _ , message forwarding decisions are based on communication device coordinates .",
    "these may be physical coordinates obtained , for example , from gps , or virtual coordinates computed by devices themselves  @xcite .",
    "routing may be unicast , where message is to be delivered to a single target device , or multicast where there are several targets .",
    "geometric routing allows _ stateless _ communication where devices do not store any information about the transmitted message between transmissions .",
    "this is a particularly attractive property : it scales well since no multihop routing information need to be maintained by the communicating devices ; it is energy efficient since resources are not spent on topology updates ; and configuration change- and fault- tolerant as the system trivially adjusts to them .",
    "a number of unicast stateless geometric routing algorithms is presented in the literature  @xcite .",
    "_ geocasting _ is a particular variant of multicasting where the source device wishes to send the information to all devices located in a specific geographic region .",
    "for example , geocasting may be used to notify all households in a flood - risk area once the water level reaches some critical point ; or to locate a moving vehicle whose last known coordinates are available at the source .",
    "geometric routing may be particularly suitable for geocasting .     + * related work . *",
    "let us cover unicast geometric routing first .",
    "the simplest form of geometric routing is greedy . in",
    "_ greedy routing _",
    "each device selects the next hop neighbor with the closest euclidean distance to the target",
    ". however , greedy routing fails if some device is the closest to the destination in its immediate neighborhood .",
    "that is , this device is a _ local minimum_. face routing guarantees delivery by navigating around faces of a planarized communication graph @xcite .",
    "face routing may be inefficient if traversed faces are large .",
    "greedy - face - greedy  @xcite starts in greedy mode and switches to face routing only in case greedy fails",
    ". once recovered , it switches back to greedy .",
    "face traversal may be inefficient if its traversal direction is selected inopportunely : face traversal distance may be long in one direction and short in the other .",
    "goafr+@xcite finds the shorter traversal direction by switching it once the message reaches a pre - determined ellipse containing source and target devices .",
    "concurrent face routing  @xcite optimizes the speed of message delivery by sending two concurrent messages in the opposite traversal directions .",
    "let us now discuss existing geometric geocasting algorithms .",
    "geographic - forwarding - geocast  @xcite starts as a geometric unicast until it reaches the geocast region .",
    "once inside the region , the message is flooded .",
    "the flood messages that reach devices outside the geocast region are discarded .",
    "the flooding is stateful .",
    "moreover , as noted by casteigts et al .",
    "@xcite , geographic - forwarding - geocast may fail to deliver the message to all devices in the geocast region , if the region is disconnected and the only connectivity is through outside devices .",
    "virtual surrounding face @xcite avoids this problem by pre - computing in advance all planar faces that intersect the geocast region .",
    "the algorithm unicasts to the region and , upon reaching the geocast area , floods it inside and traverses all the precomputed surrounding faces on the outside .",
    "the algorithm is stateful .",
    "also , the pre - computation and maintenance of the virtual surrounding face is by nature stateful and may incur significant overhead in a dynamic wireless network .",
    "bose et al .",
    "@xcite propose gfg - based depth - first face exploration to implement geocasting . in principle , this solution is stateless , however casteigts et al .",
    "@xcite point out that it requires considerable message overhead and the only way to mitigate this overhead is to pre - process the network topology to give devices additional information .",
    "this preprocessing is stateful and may require significant communication resources .",
    "thus , existing geometric geocasting algorithms are either stateful or so inefficient that their statelessness is ineffectual .",
    "+ * our contribution .",
    "* we present new stateless geocasting routing algorithms .",
    "we describe a stateless controlled flooding algorithm , sf , which obviates the need for a locally stored information to prevent multiple retransmissions .",
    "this algorithm is of independent interest , as it allows to render existing work based on controlled flooding  @xcite stateless as well .",
    "then , we present a stateless concurrent geometric routing algorithm , spg , with better scalability and message overhead than sf . we explore combinations of these algorithms and greedy routing .",
    "we formally prove the algorithms correct , analyze their message complexity and evaluate their performance through simulation . from our analysis , it follows that the presented algorithms are message efficient , provide guaranteed delivery to the geocast region with low latency , and do not rely on computation intensive preprocessing .",
    "* wireless network , message transmission , routing algorithms . * a _ wireless network _ is a set of computer communication devices capable of exchanging messages .",
    "the network is represented as a graph @xmath0 , where @xmath1 is a set of devices , and @xmath2 is a set of edges that connect them .",
    "an edge exists between two devices if they can send messages directly .",
    "two such devices are called _",
    "neighbors_. the graph is _ fixed maximum degree _ if there is constant @xmath3 , independent of network parameters such that each device has at most @xmath3 neighbors .",
    "the communication is two - directional and the graph is undirected .",
    "a network is _ connected _ if there exists a path between any two devices .",
    "every device has unique planar coordinates which _ embeds _ the graph into the geometric plane .",
    "a _ dominating set _ is a subset of @xmath1 where every device in @xmath1 is a neighbor of at least one device in this subset . a _",
    "connected dominating set _ induces a subgraph that is connected .",
    "a _ routing algorithm _ ensures that a message is delivered from the _ source _ device to a _",
    "target _ device . if the source and the target are not neighbors , the routing algorithm is executed on intermediate devices to decide as how to route the messages to targets .    to help with routing ,",
    "a message carries routing information .",
    "we consider routing algorithms where the amount of information the message carries is independent of the network size .",
    "that is , we are interested in _ constant message size _ routing algorithms .",
    "this , for example , precludes a routing algorithm from requesting the message to carry a complete traveled route .",
    "each message carries two addresses : the ( immediate ) _ sender _ , i.e. the device transmitting the message , and the ( immediate ) _ receiver _ , i.e. the device the message is being sent to .     + * computations and fairness .",
    "* a _ step _ in a routing algorithm is the receipt of a message by the receiver device and local processing of the message according to the algorithm , which may result in further messages added to the send queue of the device .",
    "a step is _ atomic _ if it does not overlap with steps at this or other devices .",
    "every device has a _",
    "send queue _ @xmath4 that collects messages to be sent .",
    "a message is transmitted by taking it from the sender s send queue and transferring it to the receiver where it is processed according to the routing algorithm in a single atomic step .",
    "_ computation _ is a sequence of atomic steps that starts in an initial state of the algorithm .",
    "a computation is _ fair _ if every message that is in a send queue @xmath4 of some device is eventually either transmitted or removed from this queue during this computation .",
    "that is , a message may not `` get stuck '' in a send queue forever . to reason about a routing algorithm , we consider its fair computations .",
    "a computation is _ finite _ if it has a finite number of steps .",
    "a routing algorithm is _ terminating _ if all its computations are finite .",
    "a terminating routing algorithm never leaves messages indefinitely circulating in the network",
    ".     + * statelessness . *",
    "a routing algorithm is _",
    "stateless _ if it is designed such that devices store no information about messages between transmissions .",
    "it is _ stateful _ otherwise .",
    "+ * flooding .",
    "* one of the simplest routing algorithms is flooding . in _ flooding _ , the source device sends a message to all its neighbors .",
    "when a device receives this message , it subsequently sends the message to all its own neighbors . this simple algorithm guarantees delivery to all devices connected to the source .",
    "if a message is flooded , it may travel over multiple paths .",
    "thus , a single device may receive the same messages multiple times . to avoid endless retransmission of messages ,",
    "flooding must have a mechanism of eliminating duplicates .",
    "in classic flooding , each device maintains a flag for each transmitted message . if the message is already transmitted , and it is received again , the duplicate is discarded .",
    "that is , classic flooding is stateful . in this paper , we present a new stateless flooding algorithm .",
    "+ * planarity , face traversal , mates . * simple flooding requires all devices in the network to transmit the message .",
    "this may not be efficient .",
    "graph planarization offers a way to design more efficient algorithms .",
    "a graph embedding is _ planar _ if graph edges intersect only at vertices .",
    "connected planar subgraph _ is a subset of vertices and their induced edges such that the resultant graph is planar and connected . in general , finding a planar subgraph is a complex task .",
    "however , for certain graph classes it is relatively simple .",
    "a graph is _ unit - disk _ if a pair of vertices @xmath5 and @xmath6 are neighbors if and only if the distance between them is no more than @xmath7 .",
    "such graph approximates a wireless network .",
    "in such a graph , a connected planar subgraph may be found by local computation at every device using relative neighborhood or gabriel graph  @xcite .",
    "moreover , a local computation on a unit - disk graph may yield a fixed maximum degree connected dominating set subgraph  @xcite . in our message complexity estimations and in our simulation",
    ", we consider the original graph to be unit - disk .    _",
    "face _ is a region on the plane such that , for any two points in the region , there is a continuous line that connects them without intersecting graph edges .",
    "note , for example , faces @xmath8 and @xmath9 in figure  [ figspgexample ] .",
    "a planar embedding of a finite graph divides the plane into a finite set of faces .",
    "there areas of each face but one are finite .",
    "they are _ internal _ faces .",
    "one face is an infinite _ external _ face .    in a planar graph ,",
    "messages are routed by traversing such faces using right- or left - hand - rule . in",
    "the _ right - hand - rule",
    "_ , if device @xmath5 receives a message from device @xmath6 , device @xmath5 forwards the message to device @xmath10 that is nearest to @xmath6 clockwise . in the _ left - hand - rule _ ,",
    "the message is forwarded to the nearest counter - clockwise neighbor .",
    "two messages are _ mates _ if the sender of each message is the receiver of the other . for planar traversal algorithms ,",
    "mates also must have the opposite traversal direction : right- or left - hand - rule .",
    "+ * geocasting . *",
    "the problem of _ geocasting _ is communicating a message from a source device to all devices located in a designated _",
    "geocast region_. in other words , every device in the geocast region is a target .",
    "the geocast region is often a circle or rectangle .",
    "note that the source itself may be in the geocast region .",
    "the problem is complicated by the fact that devices in the geocast region may only be connected through the outside device .",
    "see , for example , devices @xmath11 and @xmath12 in figure  [ figspgexample ] .",
    "thus , message delivery to all devices in the geocast region requires exploring these outside connecting paths .    in this paper",
    ", we present a stateless geocasting algorithm and its combination with stateless flooding .",
    "1234123412341234123451234512345123451234512345=**device * * @xmath13 + * foreach * @xmath14 * do * + * add * @xmath15 to @xmath4 +   + * device * @xmath16 + * if * * receive * @xmath17 * then * + * if * @xmath18 * then * + / * found mate * / + * discard * @xmath19 * from * @xmath4 + * else * + * foreach * @xmath20 * do * + * add * @xmath21 to @xmath4 +    1234123412341234123451234512345123451234512345=**device * * @xmath13 + / * let @xmath8 be a face bordering @xmath13 + and intersecting the @xmath22-line * / + * add * @xmath23 to @xmath4 + * add * @xmath24 to @xmath4 +   + * device * @xmath16 + * if * * receive * @xmath23 * then * + * if * @xmath25 * then * + / * found mate * / + * discard * @xmath24 * from * @xmath4 + * else * + * if * @xmath8 is a juncture * then * + * foreach * @xmath26 that is + a juncture * do * + * add * @xmath27 to @xmath4 + * add * @xmath28 to @xmath4 + * add * @xmath23 to @xmath4 + * if * * receive * @xmath24 * then * + / * handle similar to @xmath23 * /    * sf . * the pseudcode for _ stateless flooding _ ( sf ) routing algorithm is shown in figure  [ figsfcode ] .",
    "the algorithm is as follows .",
    "the source device adds a message @xmath29 to its send queue @xmath4 to be sent to all devices in its neighbor set @xmath30 .",
    "when a device receives a message from neighbor @xmath5 , it first checks its send queue for a mate . if a mate exists , both messages are discarded .",
    "otherwise , the device sends the message to all neighbors except @xmath5 .     + *",
    "* _ stateless planar geocasting _",
    "( spg ) algorithm uses face traversal to limit the number of messages sent during mobile geocasting .",
    "let us start the algorithm description with a couple of definitions .",
    "every message carries the coordinates of the source and the parameters of the geocast region so it can compute the _ sr - line _  the source - region line that connects the source device with the center of the geocast region .",
    "a device is a _ juncture _ if it is incident to an edge which intersects the sr - line or the geocast region .",
    "note that all devices inside the geocast region are junctures .",
    "a juncture , as any device , is adjacent to a number of faces .",
    "the number of these faces is equal to the number of the neighbors .",
    "for example , in figure  [ figspgexample ] , device @xmath11 is adjacent to faces @xmath31 , @xmath32 , @xmath33 and @xmath34 .",
    "note that some of these local faces may globally be the same face .",
    "for example , @xmath35 , @xmath36 and @xmath37 are , in fact , the external face .",
    "when receiving a message traversing a face , a juncture device may determine which face the message is traversing if the message carries its sender and its traversal direction : right- or left - hand - rule .",
    "for example , if @xmath11 receives a right - hand - rule message from @xmath5 , then @xmath11 is able to determine that the message traverses face @xmath31 . to simplify the presentation of spg",
    ", we just refer to a particular face that the message is traversing . in spg , messages carry the source coordinates @xmath13 , region coordinates @xmath38 and the message traversal direction @xmath39 or @xmath40 .",
    "the pseudocode for spg is shown in figure  [ figspgcode ] .",
    "the spg algorithm operates as follows .",
    "the source device sends two messages in the opposite traversal directions along the face that intersects the sr - line .",
    "when a device receives a message , it checks its send queue for a mate .",
    "if a mate is present , both messages are discarded .",
    "otherwise , the device forwards the message along its current face .",
    "if the device is a juncture and the face intersects the sr - line or geocast region , then the device _",
    "splits _ the message by sending a pair of messages in every other face that intersects the sr - line / geocast region .",
    "we illustrate the operation of spg with an example shown in figure  [ figspgexample ] .",
    "device @xmath13 geocasts a message by sending a left - hand - rule message @xmath7 to device @xmath5 and right - hand - rule message @xmath41 to device @xmath6 .",
    "see figure  [ figspg1 ] .",
    "this initiates the traversal of face @xmath8 .",
    "both @xmath5 and @xmath6 are junctures .",
    "device @xmath5 has adjacent edges that intersect @xmath22-line and the geocast region .",
    "device @xmath6 has an adjacent edge intersecting @xmath22-line .",
    "once @xmath41 reaches @xmath6 , it forwards it to @xmath5 and splits it by sending messages @xmath42 and @xmath43 in face @xmath9",
    ". see figure  [ figspg2 ] .",
    "note that face @xmath44 does not intersect @xmath22-line or the geocast region so no messages are sent there . when @xmath7 reaches @xmath5 , it forwards it to @xmath6 by adding it to its send queue .",
    "device @xmath5 also splits @xmath7 by sending @xmath45 , @xmath46 , @xmath47 and @xmath48 .",
    "once @xmath41 is received by @xmath5 , it meets its mate in @xmath4 and both messages are discarded completing the traversal of face @xmath8 .",
    "this computation continues until all messages are delivered to targets .",
    "the result of the complete computation is shown in figure  [ figspg3 ] .     +",
    "* sf+spg . * for routing ,",
    "pure spg uses the planar subgraph .",
    "however , this eliminates the non - planar edges that might be effective in message transmission .",
    "this elimination is unavoidable outside the geocast region to guarantee delivery to all the targets .",
    "however , inside the geocast region , spg may be supplemented by stateless flooding .    combined algorithm , sf+spg , uses spg to route toward and around the geocast region , and sf to flood inside the region .",
    "each message carries a mode : flood or planar , and is routed using sf or spg , respectively .",
    "devices outside the geocast region receive and send messages only in planar mode .",
    "when a device inside the geocast region receives a message from neighbor @xmath6 , it sends a single flood message to all neighbors inside the region , and a pair of planar messages with opposite traversal directions to all neighbors outside the region , except @xmath6 .",
    "if the received message was in planar mode , it is sent back to @xmath6 , and discarded otherwise .",
    "+ * sf+spg+g*. algorithm sf+spg may be further combined with greedy routing to decrease the number of required message transmissions . rather than start spg at the source device",
    ", the message may be initially transmitted using greedy routing by transmitting a single message to the neighbor that is closest to the center of the geocast region .",
    "the algorithm switches to spg only when the greedy routing encounters local minimum : a device with no neighbors closer to the geocast region ; or when the greedy message actually reaches the geocast region .",
    "* correctness proofs . *",
    "we focus on sf first .",
    "let us introduce notation we use for the proofs .",
    "a device is _ visited _ if it receives the message at least once .",
    "an edge is _ used _ if the message was sent over it at least once .",
    "it is _ unused _ otherwise .",
    "a visited device is a _ border _ if it has an adjacent unused link .",
    "a visited device that is not a border is _ internal_.    [ lemsfborder ] in sf , every border device holds a message in @xmath4 to be sent over every unused link and it never holds a message to be send over a used link .",
    "we prove the lemma by induction .",
    "the source sends messages over the links to its neighbors .",
    "therefore , right before the transmission , the source is a border device with every link unused and a message to transmit over this link .",
    "therefore , the conditions of the lemma hold .",
    "assume the conditions hold at some step of a computation .",
    "let us consider the next step : a transmission of the message from device @xmath5 to device @xmath6 . device @xmath6 may be visited or not visited . if @xmath6 is not visited , then all its links , except for link to @xmath5 , are unused .",
    "when @xmath6 receives a message from @xmath5 , it becomes a border device and it sends messages to all neighbors except @xmath5 .",
    "this satisfies the conditions of the lemma .",
    "if @xmath6 is already visited , then it has a message to be sent to @xmath5 .",
    "this massage is a mate of the message received by @xmath6 from @xmath5 . by the algorithm ,",
    "these two messages are discarded .",
    "that is , once the message is transmitted to a visited device and uses the channel , there are no messages to be sent over this used channel .",
    "again , the conditions of the lemma hold .",
    "sf guarantees termination and delivery from the source to all target devices connected to the source .",
    "once the source device has a message to send , it sends to all its neighbors .",
    "that is , it becomes a border device .",
    "according to lemma  [ lemsfborder ] , every border device has a message to transmit over unused channels .",
    "since we consider fair computations of routing algorithms , this message is eventually going to be transmitted .",
    "if the receiver device is not visited , it becomes visited and sends messages to all its neighbors .",
    "eventually , all devices connected to the source will be visited , and all channels used .",
    "that is , sf delivers the message to all devices connected to the source .",
    "note that according to lemma  [ lemsfborder ] , once the channel is used , there are no messages to be sent across it .",
    "that is , sf terminates .",
    "we now prove correctness of spg .",
    "let us introduce additional terminology .",
    "a device is _ segment - visited _ if it was visited during the traversal of this face .",
    "a _ visited segment _ of a face is a sequence of neighbor devices that have been segment - visited .",
    "a _ segment - border _ of a visited segment is a segment - visited device that has an edge adjacent to this face that has not been used .",
    "note that an edge is adjacent to two faces .",
    "thus for spg , an edge may be used in one face and not used in the other . a visited device that is not a border is _ segment - internal_.",
    "two faces are _ adjacent _ if they share a common juncture device , and are _ juncture connected _ if there exists a sequence of adjacent faces from one to the other .",
    "[ lembordermessages ] in spg , every segment - border device always holds a message to be sent over unused adjacent edge .",
    "an internal device never holds such message .",
    "the proof is by induction on the devices of the face having the visited segment .",
    "a visited segment is created when a juncture device is visited",
    ". this juncture may be the source device @xmath13 or another juncture splitting the message when it is visited in an adjacent face .",
    "once the visited segment is created , it contains a single border device with two messages sent in the opposite traversal directions .",
    "this is our base case .",
    "let us consider a computation of spg where every segment of every face is as stated in the conditions of the lemma .",
    "let us focus on a particular face @xmath8 and a message transmission affecting its segments .",
    "first , let us consider a message transmission by a device adjacent to @xmath8 . it may only be a border device . the message recipient may be a non - visited device or a border of another visited segment",
    ". if the recipient is a non - visited device , once the message is received , the recipient forwards the message to its neighbor .",
    "that is , the recipient becomes a new border device with the sent message while the sender becomes an internal device without a message .",
    "thus , the conditions of the lemma are satisfied",
    ". if the recipient is a border device of an adjacent segment , by the induction hypothesis , the recipient holds a mate to be transmitted to the original sender .",
    "the two messages are discarded and the two adjacent segments merge preserving the conditions of the lemma .",
    "let us now contemplate a message transmission by the device that is not adjacent to @xmath8 .",
    "the only way it may affect @xmath8 is if the transmission is to a juncture of @xmath8 in an adjacent face .",
    "however , by the design of the algorithm , the juncture is instantly visited in every adjacent face .",
    "hence , the message transmission should encounter a border device with a mate and be eliminated .",
    "that is , regardless of the kind of message transmissions we consider , the conditions of the lemma are preserved .",
    "[ lemallfacevisited ] in spg , if a face has a visited segment , every device adjacent to this face is eventually visited .",
    "if a face contains a non - visited device , then at least one non - visited device is adjacent to a border device of a visited segment . according to lemma  [ lembordermessages ] , this border device has a message to be sent to the non - visited adjacent device .",
    "since we only consider fair computations of routing algorithms , this message is eventually transmitted .",
    "once the message is transmitted , the adjacent device becomes visited .",
    "this process continues until all devices are visited .",
    "[ lemallvisited ] in spg , every device in a face connected to the source device face is eventually visited .",
    "we start with the face that contains the source device @xmath13 .",
    "the source device is in a visited segment . according to lemma  [ lemallfacevisited ] , every device in this face",
    "is eventually visited . by the design of the algorithm ,",
    "a juncture device is instantaneously visited in all its adjacent faces .",
    "this means that visiting every device in the face that contains @xmath13 creates visited segments in every face that is adjacent to it .",
    "repeated application of lemma  [ lemallfacevisited ] proves this lemma .",
    "[ propallconnected ] in a planar graph , if a target device is connected to the source device , then this target device lies on a face connected to the source device face .",
    "the below theorem follows from proposition  [ propallconnected ] and lemma  [ lemallvisited ] .",
    "spg guarantees termination and delivery of a message from the source to all target devices connected to the source .",
    "* message costs . * in the case of stateless flooding ( sf ) , each device sends exactly one message .",
    "that is , the total number of messages is @xmath2 . in case of stateless planar geocasting ( spg ) , a message may be sent along each face .",
    "an edge may be adjacent to two faces .",
    "hence , spg may send @xmath49 messages .",
    "this estimate is tight .",
    "see , for example , figure  [ fig2e ] where sf sends @xmath2 messages while spg sends @xmath49 .",
    "that is , in the worst case , spg may be twice as costly as sf .",
    "[ fig2e ]    however , for most graphs , spg is significantly more efficient . to give a more realistic message cost estimate for spg",
    ", we make several assumptions about the network graphs .",
    "first , we assume that the geocast region is square .",
    "the graph is _ face smooth _ if there are two constants @xmath50 and @xmath51 that are independent of network parameters such that ( i ) for each face @xmath52 where @xmath53 is the perimeter of the face , and @xmath5 its area , and ( ii ) for any two points in the graph , @xmath54 where @xmath55 is the area of all internal faces that intersect the line between these two points and @xmath56 is the euclidean distance between them . for an internal face ,",
    "the area computation is straightforward ; for the external face , an area of an arbitrary figure enclosing the graph , for example convex hull , is considered .",
    "the first assumption places limits on how \" ragged  the perimeter of the face may be , while the second limits how `` uneven '' the faces may be in size by assuming that the area of all intersecting faces is included in a certain disk whose diameter is related to the distance between two devices .    [ lemfacesmoothbound ] for face smooth graphs , the message cost of spg+sf is less than @xmath57 where @xmath56 the length of @xmath22-line , @xmath58 and @xmath9 are the respective areas of the whole graph and the geocast region , @xmath3 is the maximum degree and @xmath50 and @xmath51 are constants independent of the graph parameters .",
    "we arrive at the estimate by bounding the number of messages it takes to carry out individual parts the algorithm : to traverse the faces ( both internal and external ) intersecting @xmath22-line , to flood the geocast region , and to traverse the faces that intersect it .",
    "note that due to the design of the algorithm , the external face is traversed only once .",
    "hence , we account for the messages it takes to traverse it only once as well .    for the @xmath22-line , combining the two assumptions for the face smooth graphs , we get : @xmath59 where @xmath60 is the sum of all perimeters of internal faces intersecting the @xmath22-line .",
    "if @xmath3 is the maximum degree of the graph , the maximum number of devices lying along the perimeter @xmath60 is @xmath61 .",
    "hence , the number @xmath62 of messages sent traversing these faces is : @xmath63    that is , @xmath64    similarly , if spg+sf intersects the external face , the number of messages @xmath65 it takes to traverse it can be bounded as follows : @xmath66    let us estimate the number of messages expended to deliver to all the devices in the geocast region @xmath9 .",
    "we first bound the number of messages sent by the flooding part of the algorithm .",
    "we completely cover the whole geocast region with unit - disks as shown in figure  [ figg ] . in this arrangement",
    ", each unit disk covers a square with side length of @xmath67 . with @xmath3 being the maximum device degree , the number of devices in the geocast region , and therefore ,",
    "the number of messages @xmath68 it takes to flood it , is : @xmath69    let us now estimate the number of messages sent across faces intersecting the geocast region .",
    "since the area is square , the length of its side is @xmath70 . by the second assumption of the face smooth graph ,",
    "the area of all internal faces that intersect this side is less than @xmath71 . by the first assumption , the perimeters of these faces is less than @xmath72 . taking into account that the geocast region has four sides and that the maximum device degree is @xmath3 , for the bound of the number of messages @xmath68 on the faces that intersect the geocast region is as follows :    @xmath73 adding the bounds for individual parts of the message estimate @xmath62 , @xmath65 , @xmath68 and @xmath74 , we obtain the bound of the lemma .",
    "the following theorem follows from lemma  [ lemfacesmoothbound ] .",
    "[ trmbound ] for face smooth graphs of bounded degree , if the geocast region size is constant , the message cost for spg+sf is in @xmath75 , where @xmath56 is the length of the @xmath22-line and @xmath58 is the area covered by the graph .",
    "let us compare this bound with the message complexity of ordinary flooding . if the number of devices in the graph is proportional to this area , the message cost of flooding is in @xmath76 .",
    "in other words , the message cost of spg+sf is proportional to the linear dimensions of the geocast region while the cost of flooding is quadratic .",
    "* setup . * in their classic study of unicast geometric routing algorithms ,",
    "kuhn et al  @xcite use a particular simulation setup to thoroughly evaluate the performance of their algorithms .",
    "we extend the setup similar to theirs to use in our simulation .    specifically , we populate a @xmath77 unit square field with devices placed uniformly at random to achieve a specific network density .",
    "the total number @xmath16 of devices is equal to the area of the field divided by area of the unit circle and multiplied by the required density @xmath56 .",
    "that is @xmath78 .",
    "we randomly pick the source device and randomly place a square geocast region so that it fits into the field completely .",
    "we then calculate each device s neighbors as follows .",
    "we first construct a unit - disk graph . for the planar geocasting algorithms",
    ", we also compute gabriel subgraph and connected dominating set on it .",
    "_ experiment _ is a single delivery of a message from a particular source to a particular geocast region . in other words",
    ", it is a single complete computation of an algorithm . for each experiment",
    ", we generate a new random graph with a randomly selected source and randomly placed geocast region . for each specific data point",
    ", we conduct 1000 experiments .     + * results . *",
    "we evaluate the algorithms on message cost and latency .",
    "_ message cost _ is the number of messages it takes to deliver to all devices in the geocast region .",
    "message cost quantifies the amount of network resources necessary to deliver the message .",
    "_ latency _ of message arrival is the shortest path taken by the algorithm to reach the device in the geocast region that is furthest away from the source .",
    "devices not connected to the source are not counted .",
    "_ path stretch _ is latency normalized to the optimal path to this device .",
    "latency quantifies the time it takes to deliver the message to every device in the geocast region .",
    "we estimate message cost by varying three parameters : network density , geocast region size and complete communication field size .",
    "when we vary one of the three parameters , the other two are held constant at : @xmath47 devices per unit square for density , @xmath79 units for geocast region size and @xmath80 units for field size .",
    "figure  [ figoverhead ] presents the simulation results .",
    "we study latency by varying network density and geocast region size .",
    "the results for latency are shown in figure [ figlatency ] .",
    "+ * analysis . *",
    "the results of the message cost study are intuitive .",
    "sf becomes comparatively costly as the density of the network increases ( see figure  [ figoverheadbydensity ] ) .",
    "indeed , sf delivers the message to every device in the whole network , regardless of whether they are inside or outside the geocast region .",
    "the delivery to the outside devices is overhead .",
    "as the density grows , the ratio of outside devices to inside devices also grows .",
    "the overhead grows with the increase of this ratio .",
    "sf+spg performs better than either of the two individual algorithms .",
    "the combined algorithm achieves message savings compared to pure spg since it floods the geocast region .",
    "when flooding , the algorithm sends only one message per edge , while spg may potentially send two messages . adding greedy to the combined algorithm helps further reduce message cost .",
    "let us consider geocast region variation .",
    "again , since sf sends one message per edge , while spg may potentially send two messages , sf outperforms spg as the geocast region size approaches field size ( see figure  [ figoverheadbyarea ] ) .",
    "the growth of the field size adversely affects sf s performance ( see figure  [ figoverheadbyscale ] ) .",
    "the results of the latency study are also intuitive for the most part .",
    "sf is always latency - optimal as all possible paths are traveled .",
    "the other algorithms achieve similar mean path stretch , whether under varied density or geocast region size .",
    "however , adding a greedy component dramatically worsens the algorithm s performance : greedy routing does not have the advantage of concurrently exploring multiple paths to find the faster one to deliver the message .",
    "in conclusion , we would like to point out several ways the algorithms presented in this paper may be extended .",
    "we assumed fault - free delivery for our geocasting algorithms .",
    "it would be interesting to incorporate fault - tolerance and message - loss resilience into them .",
    "other practical considerations enhance the applicability of our algorithms .",
    "for example , both sf and spg , upon arrival of a message to a device , require examination of the send queue at this device .",
    "this examination has to be implemented at all levels of the network stack of each device .",
    "such cross - stack queue examination presents an interesting implementation challenge .",
    "brad karp and hsiang - tsung kung .",
    "gpsr : greedy perimeter stateless routing for wireless networks . in _ proceedings of the 6th annual international conference on mobile computing and networking _ , pages 243254 .",
    "acm , 2000 .",
    "young - bae ko and nitin  h vaidya .",
    "geocasting in mobile ad hoc networks : location - based multicast algorithms . in _ mobile computing systems and applications , 1999 .",
    "wmcsa99 . second ieee workshop on _ , pages 101110 .",
    "ieee , 1999 .",
    "jie lian , kshirasagar naik , yunhao liu , and lei chen . virtual surrounding face geocasting with guaranteed message delivery for ad hoc and sensor networks . in _",
    "network protocols , 2006 .",
    "proceedings of the 2006 14th ieee international conference on _ , pages 198207 .",
    "ieee , 2006 .",
    "julio  c navas and tomasz imielinski .",
    "geocastgeographic addressing and routing . in _ proceedings of the 3rd annual acm / ieee international conference on mobile computing and networking _ , pages 6676 .",
    "acm , 1997 .",
    "peng - jun wan , khaled  m alzoubi , and ophir friede . distributed construction of connected dominating set in wireless ad hoc networks . in _",
    "infocom 2002 .",
    "twenty - first annual joint conference of the ieee computer and communications societies . proceedings .",
    "ieee _ , volume  3 , pages 15971604 .",
    "ieee , 2002 ."
  ],
  "abstract_text": [
    "<S> we present two stateless algorithms that guarantee to deliver the message to every device in a designated geographic area : flooding and planar geocasting . due to the algorithms statelessness , intermediate devices </S>",
    "<S> do not have to keep message data between message transmissions . </S>",
    "<S> we formally prove the algorithms correct , estimate their message complexity and evaluate their performance through simulation . </S>"
  ]
}