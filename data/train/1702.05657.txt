{
  "article_text": [
    "quantum computation can solve some problems that are intractable for classical computation , e.g.  the quantum shor s algorithm can solve the integer factorization problem in polynomial time while the best known classical algorithm runs in exponential time  @xcite . implementing such quantum algorithms ,",
    "we need a quantum computer that contains a plenty of qubits  @xcite with the noise suppressed to the sub - threshold regime  @xcite .",
    "these qubits must be coupled by controllable interactions to form a network .",
    "the connectivity of the network is higher , the quantum computer can tolerate more errors , i.e.  the noise threshold is higher .",
    "for example , when qubits form a one - dimensional ( 1d ) array with nearest - neighbouring ( nn ) interactions , the error - rate threshold is between @xmath1@xmath2 per gate  @xcite ; when qubits form a two - dimensional ( 2d ) array with nn interactions , the threshold is about @xmath3 per gate  @xcite . in this paper , we study the fault - tolerant quantum computing in a 1d array of qubit with short - range but more than nn interactions that exist in many quantum systems , and we show that the threshold could be higher than @xmath4 per gate with feasible interaction ranges .",
    "the advantage of using a 1d array of qubits as a quantum computer is that the system could be monolithic and embedded in a 2d surface .",
    "gate error rates lower than @xmath3 have been demonstrated in 1d qubit arrays using ion traps  @xcite and superconducting qubits  @xcite .",
    "these error rates are sub - threshold for the fault - tolerant quantum computing in a 2d qubit array  @xcite , therefore one way of building quantum computers is extending the qubit array to 2d and preserving low error rates at the same time . for ion traps ,",
    "an approach of scaling up the quantum computer is using the network paradigm , i.e.  ion traps are networked by using quantum communications via optical systems [ fig .",
    "[ fig : architectures](a ) ]  @xcite .",
    "the ion - trap network can also be integrated on a chip , in which communications are achieved by using ion transport through junction structures  @xcite . for superconducting qubits ,",
    "a 2d qubit array can be fabricated on a 2d surface , and then one can access qubits vertically from the third dimension [ fig .",
    "[ fig : architectures](b ) ]  @xcite . as we will show in this paper ,",
    "a 1d qubit array can also tolerate a high level of noise .",
    "therefore we can also build a quantum computer without optical communication channels , and qubits are accessed laterally using control and read - out lines in the same surface [ fig .",
    "[ fig : architectures](c ) ] .",
    "although 2d qubit arrays have some advantages , e.g.  a lower cost of communications within the qubit array , 1d qubit arrays may be more adaptable to harsh environments and easier to optimise to suppress noise because of their structural simplicity .",
    "medium - range interactions in a 1d array , as required by our architecture , do exist in many quantum systems . in ion traps , ions in the same trap",
    "are coupled to common phonon modes .",
    "mediated by such modes , an entangling two - qubit gate can be directly performed on any pair of qubits , i.e.  qubits in the same trap are all - to - all connected [ fig .",
    "[ fig : system](a ) ]  @xcite . using such ion traps as building blocks ,",
    "the quantum computer is formed by a series of ion traps , in which two nn traps can be coupled by shuttling an ion between two traps  @xcite . by a different physical mechanism",
    ", our requirement may also be achieve with superconducting qubits : when coupled to the same resonator they can also be all - to - all connected  @xcite , and two nn resonators can be coupled using a qubit interacting with both resonators  @xcite [ fig .",
    "[ fig : system](a ) ] . in both platforms ,",
    "the quantum computer is a chain of sub - systems , i.e.  segments .",
    "each segment is an ion trap or a resonator .",
    "qubits within a segment are all - to - all connected ; and two nn segments are coupled by a shared qubit , which is connected to all qubits in both segments .",
    "we find that , if there are enough qubits in each segment , a high level of noise is tolerable .",
    "the number of qubits in each segment , i.e.  the interaction range , is fixed and does not scale with the overall size of the quantum computer .",
    "our protocol for quantum error correction is based on the surface code  @xcite , with an optional additional level of encoding if the surface code alone proves insufficient . using the interaction structure in the segmented chain qubit array",
    ", the surface code can be efficiently implemented , but its code distance is limited by the number of qubits in each segment .",
    "note that because qubits in the same segment may need to be operated sequentially , a surface - code error detection cycle in the segmented chain qubit array may be slower ( in terms of the circuit depth ) than a 2d qubit array by a factor determined by the segment size .",
    "logical qubits encoded in the surface code form a 1d array with nn interactions , i.e.  each surface - code qubit can only directly talk to two nn surface - code qubits .",
    "error rates for logical gates on surface - code qubits are of course determined by error rates of physical qubits and the limited code distance . if error rates of surface - code qubits are low enough , a quantum algorithm can be directly implemented using surface - code qubits ; otherwise , we need to combine the surface code with another code above it to further correct errors .",
    "we choose the concatenated 1d four - qubit gauge code as the higher - level code  @xcite .",
    "the noise threshold of our protocol depends on the segment size .",
    "our numerical results suggest that given a physical error rate @xmath5 per gate , which has been demonstrated in ion traps  @xcite , and @xmath6 qubits in each segment , on average @xmath7 cnot gates can be performed on surface - code qubits before a logical error occurs , in which case the concatenation with the gauge code is not required for implementing many quantum algorithms .",
    "when the additional concatenation is indeed used then one can use segments of any size greater than 4 to suppress logical errors arbitrarily , provided that the physical error rate is below a certain threshold .",
    "we determine this threshold curve , finding for example the threshold error rate is @xmath0 when the segment size is 15 .",
    "the paper is organised as follows : in sec .",
    "[ sec : surface ] , we focus on the surface code . in sec .  [",
    "sec : gauge ] , we focus on the concatenation with the gauge code . in sec .  [ sec : ftqc ] , we discuss the performance of the whole error - correction protocol . in sec .",
    "[ sec : conclusions ] , we conclude results of this paper .",
    "these logical qubits form a one - dimensional quantum computer with nearest neighbouring interactions . ]    a surface - code logical qubit with the code distance @xmath8 is encoded in @xmath9 physical qubits , as shown in fig .",
    "[ fig : q_chain ] , in which the code distance is @xmath10 . in a 2d array of physical qubits ,",
    "implementing the surface code only requires interactions between neighbouring qubits  @xcite .    in a 1d array of physical qubits with the segmented chain structure , we allocate one segment to each column of physical qubits in the square array ( see fig .  [",
    "fig : q_chain ] ) : each physical qubit in the column maps to a data qubit in the segment ; intra - column gates are performed using interactions within the segment ; and gates between nn columns are realised via shuttle qubits .",
    "the code distance of the surface code depends on the size of segments .",
    "we define the size of segments @xmath11 as the number of data qubits plus two shuttle qubits . for ion traps ,",
    "this is the maximum number of ions in one trap ; for qubit - resonator systems , this is the total number of qubits coupled to one resonator  ( fig .",
    "[ fig : system ] ) . in fig .  [ fig : q_chain ] , the size of segments is @xmath12 .",
    "the number of qubits in a column is either @xmath8 or @xmath13 ( long or short column ) . limited by the segment size , the code distance @xmath14 . in order to utilise the full computational power provided by the machine",
    ", we always choose @xmath15 .    in each short column",
    ", one data qubit in the corresponding segment is not used in the surface - code encoding .",
    "these unused qubits are useful for suppressing logical memory errors and gating surface - code qubits , which will be discussed later .    in the following",
    ", we will show how to implement the surface code in the segmented chain qubit array .",
    "the surface code is a stabiliser code , which means that the code can be defined using stabilisers  @xcite . as the same as many other stabiliser codes",
    ", the surface code has two sets of stabilisers ( x and z ) .",
    "conventionally , stabilisers of the surface code are illustrated using the lattice in fig .",
    "[ fig : circuit](a ) : each edge represents a physical qubit , each vertex represents an x stabiliser , and each plaquette represents a z stabiliser  @xcite . typically a vertex is connected to four edges , and the corresponding x stabiliser is in the form @xmath16 , which is a tenser product of x - direction pauli operators of four qubits on these edges .",
    "it is similar for a plaquette , whose perimeter is typically formed by four edges , and the corresponding z stabiliser is in the form @xmath17 , which is a tenser product of z - direction pauli operators of four qubits on these edges .",
    "stabilisers on boundaries are special ; each vertex ( plaquette ) on the left - right ( top - bottom ) boundaries only has three edges , i.e.  the corresponding stabiliser is a tenser product of three pauli operators rather than four [ see fig .",
    "[ fig : circuit](a ) ] .",
    "errors in the quantum computation are unexpected operations on the quantum state .",
    "the task of quantum error correction is to detect errors and undo them . in stabiliser codes , errors are detected by repeatedly measuring stabilisers .",
    "x and z stabilisers are respectively used to detect phase and bit errors .",
    "for example if an error that is a phase - flip gate @xmath18 occurs on a qubit , the sign of @xmath19 ( the phase state ) of the qubit is flipped , then the sign of the x stabiliser ( @xmath16 or @xmath20 ) containing this qubit is also flipped for once .",
    "therefore , if we find that an x stabiliser is flipped , we can conclude that phase states of one or three qubits in this stabiliser have been flipped ; if an x stabiliser is not flipped , then the phase states of either no qubit or two or four qubits have been flipped . it is similar for z stabilisers .",
    "if a bit - flip error @xmath19 occurs , the sign of @xmath18 ( the bit state ) of the qubit is flipped , and all corresponding z stabilisers are flipped for once .",
    "an error changes either the phase state or the bit state or both them of a qubit , otherwise it is equivalent to an identity operation .",
    "we will discuss how to undo errors in sec .",
    "[ sec : error_rate ] .    the protocol for stabiliser measurements in the segmented chain qubit array is shown in fig .",
    "[ fig : circuit](b - d ) .",
    "each column of physical qubits corresponds to a segment , and each segment has two shuttle qubits ( fig .",
    "[ fig : q_chain ] ) .",
    "we call columns with @xmath8 qubits long columns and columns with @xmath13 qubits short columns .",
    "we use shuttle qubits as ancillaries to measure qubits as shown in circuits in fig .",
    "[ fig : circuit](c , d ) .",
    "stabilisers are measured row by row . in fig .",
    "[ fig : circuit](b ) , we take the top row of x stabilisers ( vertices ) in fig .  [",
    "fig : circuit](a ) as an example .",
    "firstly , shuttle qubits are initialised according to the circuit in fig .",
    "[ fig : circuit](c ) . in step-@xmath21 ,",
    "two shuttle qubits of each long - column segment are entangled using interactions within the segment , corresponding to the step-@xmath21 cnot gate in fig .",
    "[ fig : circuit](c ) . in step-@xmath22 ,",
    "shuttle qubits on the right side of long columns stay in long columns , shuttle qubits on the left side of long columns are _ moved _ leftward to short columns , and then each shuttle qubit interacts with a data qubit in the corresponding column to perform step-@xmath22 cnot gates in fig .",
    "[ fig : circuit](c ) . in step-@xmath23 ,",
    "all shuttle qubits are _ moved _ rightward and interact with data qubits to perform step-@xmath23 cnot gates in fig .",
    "[ fig : circuit](c ) .",
    "finally , shuttle qubits are measured to read stabiliser values according to the circuit in fig .  [",
    "fig : circuit](c ) .",
    "we would like to remark that , in ion traps , shuttle qubits are physically moved between nn traps ; but in qubit - resonator systems , moving shuttle qubits only means using different resonators . in five steps ( including shuttle - qubit initialisation and measurement and three rounds of interactions ) , one row of x stabilisers are measured . by measuring x stabilisers row by row",
    ", we need @xmath24 steps to complete the x - stabiliser measurements .",
    "z - stabiliser measurements are similar [ see fig .  [",
    "fig : circuit](d ) ] . to measure z stabilisers ,",
    "the roles of long columns and short columns are exchanged , i.e.  two shuttle qubits of each short - column segment are entangled at the beginning , and then shuttle qubits are _ moved _ and interact with data qubits in the similar way . by measuring z stabilisers row by row , we need @xmath25 steps to complete z - stabiliser measurements .",
    "therefore , a full round of stabiliser measurements needs @xmath26 steps .",
    "circuits for measuring three - qubit stabilisers can be obtained from circuits in fig .",
    "[ fig : circuit](c , d ) by removing a data qubit and corresponding gates .",
    "we can conclude that stabiliser measurements only require the initialisation and measurement operations on shuttle qubits and interactions involving shuttle qubits .",
    "interactions between data qubits are not required .",
    "single - qubit gates are not explicitly shown in the circuits , which may be needed for adjusting the initialisation / measurement basis . similarly , single - qubit gates on data qubits are also not required .",
    "these operations required by stabiliser measurements form a set of universal operations , all operations on data qubits can be realised using these operations : we can transfer the state of a data qubit to a shuttle qubit to realise initialisation , measurement and single - qubit gates on the data qubit and transfer states of two data qubits to two shuttle qubits to realise two - qubit gates on data qubits .",
    "realising data - qubit operations indirectly causes more errors , but because they are not used in stabiliser measurements , these extra errors will not change the performance of the quantum error correction significantly . in this paper",
    ", we assume that data qubits can be controlled directly , but the conclusion will be similar for systems without direct control on data qubits . as a remark ,",
    "we have assumed that only one cnot gate can be performed in a segment at a time .       as a function of the physical - qubit cnot - gate error rate @xmath27 and the code distance @xmath8 . when the physical error rate is lower than the threshold marked by the vertical gray line , the logical error rate decreases with the code distance .",
    "circles are data calculated numerically using the monte carlo method . dashed lines are obtained by fitting circles ( in the sub - threshold regime ) using eq .",
    "( [ eq : scaling ] ) .",
    "dotted lines are calculated using eq .",
    "( [ eq : ef ] ) .",
    "error bars show one standard deviation , and error bars smaller than the size of circles have been removed from the figure . ]",
    "stabiliser measurements provide us the information that we need for correcting errors .",
    "stabilisers only reveal the parity of any errors on each stabiliser : if a stabiliser is flipped due to an odd number of errors , the event is called an error syndrome , which is an evidence of the presence of errors .",
    "we remark that if a stabiliser is not flipped , either there is no error or an even number of errors .",
    "therefore , we need an algorithm to find out which qubits are affected by errors from error syndromes . such an algorithm is called a decoder and is implemented using classical computers .",
    "roughly speaking , the task of the decoder is to find out the most likely set of errors that can result in the given error syndromes ( i.e.  stabiliser - measurement outcomes ) . here",
    ", we outline the decoder used in this paper , and details can be found in ref .",
    "@xcite : the minimum - weight perfect matching algorithm is used to pair error syndromes  @xcite ; in the lattice representing potential errors , diagonal edges are introduced to represent correlated errors ; and the weight of an edge is determined by the rate of the corresponding error .",
    "once errors are determined , we can undo errors by performing the inverse operation , i.e.  if we find that a phase - flip error @xmath18 ( a bit - flip error @xmath19 ) is on a qubit , the error can be corrected by performing a @xmath18 ( @xmath19 ) gate on the qubit ; and we can record correction operations and only perform them until it is necessary , which is usually before a non - clifford gate .",
    "stabiliser - measurement outcomes themselves may be false due to errors in stabiliser measurement circuits , false outcomes can also be detected and corrected by the surface code  @xcite .",
    "two different sets of errors may result in the same error syndromes .",
    "therefore , given error syndromes , correction operations selected by the decoder may be different from the actual errors to be corrected , resulting in some remaining errors on the state .",
    "these errors after the error correction can not be detected by further stabiliser measurements , but frequently they are not harmful to the logical state .",
    "however , if the logical state is changed by a set of post - correction errors , the error correction has failed .",
    "the rate of error correction failures , i.e.  the logical - qubit error rate , depends on the rate of errors in each operation on the physical - qubit level and the code distance . for the surface - code , usually when the physical - qubit error rate is lower than a threshold value , the logical - qubit error rate decreases with the code distance .",
    "we numerically studied the performance of the surface code using the monte carlo method .",
    "the error - rate threshold is determined ; the logical - qubit error rate in the shallow sub - threshold regime ( the physical error rate is relatively high and the code distance is small ) is calculated directly , and the logical - qubit error rate in the deep sub - threshold regime is estimated using extrapolation .",
    "we model the noise in the quantum computer as depolarising errors .",
    "operations used in stabiliser measurements [ fig .",
    "[ fig : circuit](c , d ) ] include initialisations , measurements , hadamard gates and cnot gates ( hadamard gates are used for adjusting the initialisation / measurement basis ) .",
    "when a qubit is supposed to be initialised in the state @xmath28 , the qubit may be initialised in the incorrect state ( @xmath29 ) with the probability @xmath30 . when a qubit is measured in the @xmath31/@xmath32 basis , the measurement outcome is incorrect with the probability @xmath33 .",
    "initialisations and measurements in the @xmath34/@xmath35 basis are realised using initialisations and measurements in the @xmath31/@xmath32 basis and hadamard gates .",
    "a quantum gate with noise can be expressed as a superoperator @xmath36 $ ] , where @xmath37\\rho = u\\rho u^\\dag$ ] represents the unitary gate , and @xmath38 is a superoperator represents the noise .",
    "for single - qubit gates , the noise superoperator is @xmath39 + \\frac{\\varepsilon_1}{3}\\sum_{a=0}^{3}[{\\sigma^{(a ) } _ { } } ] .",
    "\\label{eq : n1}\\end{aligned}\\ ] ] for two - qubit gates , the noise superoperator is @xmath40 + \\frac{\\varepsilon_2}{15}\\sum_{a=0}^{3}\\sum_{b=0}^{3}[{\\sigma^{(a)}_{1}}{\\sigma^{(b)}_{2}}].\\end{aligned}\\ ] ] here , @xmath41 and @xmath27 are rates of errors per gate , @xmath42 is a pauli operator of qubit-@xmath21 , and @xmath43 respectively correspond to @xmath44 , @xmath19 , @xmath45 and @xmath18 .",
    "we assume that all these error rates are the same except the single - qubit error rate , which is assumed to be tenth of other error rates , i.e.  @xmath46 .",
    "the noise in the identity operation ( decoherence , memory errors ) is modelled as the same as the noise in single - qubit gates , i.e.  the noise superoperator is the same as @xmath47 [ see eq .",
    "( [ eq : n1 ] ) ] .",
    "we replace @xmath41 with @xmath48 to denote the rate of memory errors .",
    "the memory - error rate depends on the duration of the identity operation .",
    "we assume durations of initialisations , measurements and two - qubit gates are the same , and the duration of single - qubit gates is negligible compared with other operations .",
    "then , we specify that @xmath48 denotes the error rate during the time of a two - qubit gate . implementing the surface code in the segmented chain qubit array , the time to perform one round of stabiliser measurements increases with the code distance .",
    "if we assume @xmath48 is independent of the code distance , the error - rate threshold does not exist .",
    "therefore , we assume that the rate of memory errors during one round of stabiliser measurement is equivalent to the error rate of two - qubit gates , i.e.  @xmath48 depends on the code distance and @xmath49",
    ". we would like to remark that , in a segmented chain quantum computer , the scalability is achieved by using more segments in the chain instead of increasing the size of each segment .",
    "therefore , the code distance @xmath8 and the required memory error rate are always finite and do not scale with the computer size .",
    "we will show that the required memory error rate is realistic for today s technologies , e.g.  in ion traps  @xcite .    .",
    "parameters @xmath50 , @xmath51 , @xmath52 and @xmath53 and their standard deviations obtained by fitting data calculated using the monte carlo method , as shown in fig .",
    "[ fig : surface_code ] . [ cols=\"^,^,^,^\",options=\"header \" , ]     the error rate @xmath54 of cnot gates on gauge - code logical qubits increases with the surface - code error rate @xmath55 .",
    "this dependence can be described using the formula @xmath56 where parameters @xmath57 and @xmath58 depend on the concatenation level @xmath59 . by fitting data in fig  [ fig : gauge4 ] ,",
    "we obtain parameters @xmath57 and @xmath58 as given in table  [ gctable ] . for first two levels of concatenations , @xmath60 , which implies that the error correction does not work ( @xmath61 )",
    ". the first - level concatenation does not work because it can only detect errors .",
    "the second - level concatenation does not work because of two - qubit errors that can not be corrected by the code with distance @xmath62 .",
    "therefore , the third level is the minimum level of encoding in order to take the advantage of the four - qubit gauge code to reduce errors .",
    "and the segment size @xmath11 required to achieve the surface - code logical error rate @xmath55 .",
    "the red curve corresponds to @xmath63 , and the blue curve corresponds to @xmath64 .",
    "these two curves are calculated using eq .",
    "( [ eq : scaling ] ) with parameters given in table  [ table ] .",
    "results obtained using eq .",
    "( [ eq : ef ] ) are also plotted in the figure as dashed curves .",
    "errors are firstly corrected using the surface code . when the physical error rate is not low enough or segments are not large enough ( e.g.  to achieve @xmath64 ) , we need the concatenated code on top of the surface code to further correct errors .",
    "@xmath63 is the threshold of the regime that the concatenated code works , therefore the red curve is the threshold of the overall protocol . ]    in the segmented chain qubit array , the overall protocol for fault - tolerant quantum computing depends on the logical error rate required by the computing task , the rate of physical errors and the size of segments . if the surface code can not suppress the logical error rate to the level required by the task , we need to use the concatenated four - qubit gauge code to further reduce the logical error rate . in order to use the concatenated code , the surface code has to firstly suppress the logical error rate to be lower than @xmath63 , which leads to a threshold of the physical error rate . in fig .",
    "[ fig : surface_code_logical_error_rate ] , this threshold of the physical error rate is plotted as a function of the segment size .",
    "if the physical error rate is @xmath65 , we need segments with more than @xmath66 qubits to build a fault - tolerant quantum computer .",
    "if the physical error rate can be reduced to @xmath67 , the minimum size of segments can be reduced to @xmath68 .    when each segment is large enough ,",
    "the surface code itself is enough for many quantum - computing tasks . as shown in fig .",
    "[ fig : surface_code_logical_error_rate ] . given the physical error rate @xmath69 and segments with about @xmath6 qubits in each one of them , the surface - code cnot gate error rate is @xmath70 , which is enough for implementing the shor s algorithm with a thousand qubits  @xcite .",
    "similarly , if the physical error rate can be reduced to @xmath71 , the segment size only needs to be @xmath72 to achieve the same logical error rate .    .",
    "for the level-3 and level-4 encoding , the number of gates is @xmath73 .",
    "@xmath55 is calculated using eq .",
    "( [ eq : scaling ] ) , and @xmath54 is calculated using eq .",
    "( [ eq : gcscaling ] ) .",
    "parameters in these two equations are given in table  [ table ] and table  [ gctable ] . ]",
    "the performance of the overall protocol is plotted in fig .  [",
    "fig : gauge4_logical_error_rate ] .",
    "the level-0 encoding means that only the surface code is used to correct errors .",
    "the performance of the surface - code - only error correction , the third - level and fourth - level concatenated gauge codes are compared . given the gate error rate @xmath74 and using the fourth level concatenation , @xmath7 logical cnot gates can be achieved with @xmath75 qubits in each segment .",
    "the concatenation is expensive . using the four - qubit gauge code , to encode a higher - level qubit",
    ", we need six lower - level qubits .",
    "if we use only one in every four surface - code qubits as the information qubit , each logical qubit with the level-@xmath59 concatenation requires @xmath76 surface - code qubits , i.e.  the third - level ( fourth - level ) encoding needs @xmath77 ( @xmath78 ) surface - code qubits per gauge - code logical qubit . as shown in fig .",
    "[ fig : gauge4_logical_error_rate ] , using the concatenated code can reduce the required segment size but the effect is modest especially when the physical error rate is as low as @xmath79 .",
    "we have discussed fault - tolerant quantum computing in 1d quantum computers with the segmented chain structure . given the state - of - the - art error rate @xmath4 , the size of each segment must be at least @xmath66 qubits for fault - tolerance to be of benefit using the surface code concatenated with the 1d gauge code , and @xmath6 qubits for large scale algorithms such as shor s algorithm to be implemented only using the surface code .",
    "each segment is a small quantum processor with all - to - all connections among qubits .",
    "segments with @xmath62 or @xmath80 qubits have been demonstrated with ion traps  @xcite and superconducting qubits  @xcite , and the qubit number in each segment in these platforms can be extended to tens or even more qubits  @xcite .",
    "the disadvantage of the segmented chain structure is the computing speed . because the all - to - all connectivity within each segment is due to the coupling to the same phonon or photon modes , interactions between qubits in the same segment",
    "could not be switched on simultaneously . as a result ,",
    "segmented chain 1d quantum computers need more operation cycles than 2d quantum computers by a factor determined by the segment size .",
    "therefore , a longer coherence time is required . in ion traps ,",
    "the coherence time of qubits is about @xmath81 sec  @xcite , which is @xmath82 times longer than @xmath83 @xmath84s the time cost of a two - qubit gate  @xcite , i.e.  the memory error rate @xmath85 , which allows a segment size as large as about @xmath86 qubits for the gate error rate @xmath74 .",
    "this coherence time of ion qubits can be increased by a factor of @xmath87 by using dynamical decoupling  @xcite .",
    "such a ratio of coherence time to gate time is still a challenge for superconducting qubits  @xcite .",
    "some recent works have been focusing on increasing the coherence time of superconducting qubits  @xcite or coupling them to quantum memories , e.g. nitrogen - vacancy centres in diamond  @xcite .",
    "we remark that the computing speed also depends on the time cost of each operation cycle . as an alternative approach of building a quantum computer ,",
    "the segmented chain structure avoids the need to expand the qubit array to higher dimensions , which reduces the complexity of the quantum computer and allows us to design the quantum computer based on the well - developed 1d quantum technologies and on - chip integrated circuit manufacturing technologies .",
    "this work was supported by the epsrc national quantum technology hub in networked quantum information technology ( ep / m013243/1 ) .",
    "the authors would like to acknowledge the use of the university of oxford advanced research computing ( arc ) facility in carrying out this work .",
    "details of our protocols of the surface - code logical cnot gate , hadamard gate and state transfer are shown in fig .  [",
    "fig : cnot ] , fig .",
    "[ fig : hadamard ] and fig .",
    "[ fig : state_transfer ] , respectively .",
    "t. szkopek , p.o .",
    "boykin , h. fan , v. roychowdhury , e. yablonovitch , g. simms , m. gyure , and b. fong , _ threshold error penalty for fault - tolerant quantum computation with nearest neighbor communication _",
    ", ieee trans .",
    "nano . * 5 * , 42 ( 2006 ) .",
    "j. p. gaebler , t. r. tan , y. lin , y. wan , r. bowler , a. c. keith , s. glancy , k. coakley , e. knill , d. leibfried , and d. j. wineland , _ high - fidelity universal gate set for @xmath88be@xmath89 ion qubits _ ,",
    "lett . * 117 * , 060505 ( 2016 ) .",
    "r. barends , j. kelly , a. megrant , a. veitia , d. sank , e. jeffrey , t. c. white , j. mutus , a. g. fowler , b. campbell , y. chen , z. chen , b. chiaro , a. dunsworth , c. neill , p. omalley , p. roushan , a. vainsencher , j. wenner , a. n. korotkov , a. n. cleland , and j. m. martinis , _ superconducting quantum circuits at the surface code threshold for fault tolerance _",
    ", nature * 508 * , 500 ( 2014 ) .        c. monroe , r. raussendorf , a. ruthven , k. r. brown , p. maunz , l .- m .",
    "duan , and j. kim , _ large - scale modular quantum - computer architecture with atomic memory and photonic interconnects _ , phys .",
    "rev . a * 89 * , 022317 ( 2014 ) .",
    "j. h. bjanin , t. g. mcconkey , j. r. rinehart , c. t. earnest , c. r. h. mcrae , d. shiri , j. d. bateman , y. rohanizadegan , b. penava , p. breul , s. royak , m. zapatka , a. g. fowler , and m. mariantoni , _ three - dimensional wiring for extensible quantum computing : the quantum socket _ , phys .",
    "rev . applied * 6 * , 044010 ( 2016 ) .",
    "t. choi , s. debnath , t. a. manning , c. figgatt , z .- x .",
    "gong , l .- m .",
    "duan , and c. monroe , _ optimal quantum control of multimode couplings between trapped ion qubits for scalable entanglement _ , phys .",
    "* 112 * , 190502 ( 2014 ) .",
    "m. a. rowe , a. ben - kish , b. demarco , d. leibfried , v. meyer , j. beall , j. britton , j. hughes , w. m. itano , b. jelenkovic , c. langer , t. rosenband , and d. j. wineland , _ transport of quantum states and separation of ions in a dual rf ion trap _ , quantum inf . and comput . * 2 * , 257 ( 2002 ) .",
    "h. paik , a. mezzacapo , m. sandberg , d. t. mcclure , b. abdo , a. d. crcoles , o. dial , d. f. bogorin , b. l. t. plourde , m. steffen , a. w. cross , j. m. gambetta , and j. m. chow , _ experimental demonstration of a resonator - induced phase gate in a multiqubit circuit - qed system _ , phys .",
    "* 117 * , 250502 ( 2016 ) .",
    "m. takita , a. d. crcoles , e. magesan , b. abdo , m. brink , a. cross , j. m. chow , and j. m. gambetta , _ demonstration of weight - four parity measurements in the surface code architecture _ , phys .",
    "* 117 * , 210505 ( 2016 ) .",
    "t. p. harty , d. t. c. allcock , c. j. ballance , l. guidoni , h. a. janacek , n. m. linke , d. n. stacey , and d. m. lucas , _ high - fidelity preparation , gates , memory , and readout of a trapped - ion quantum bit _",
    "* 113 * , 220501 ( 2014 ) .",
    "r. islam , c. senko , w. c. campbell , s. korenblit , j. smith , a. lee , e. e. edwards , c .- c .",
    "j. wang , j. k. freericks , and c. monroe , _ emergence and frustration of magnetism with variable - range interactions in a quantum simulator _ , science * 340 * , 583 ( 2013 ) .",
    "k. kakuyanagi , y. matsuzaki , c. dprez , h. toida , k. semba , h. yamaguchi , w. j. munro , and s. saito , _ observation of collective coupling between an engineered ensemble of macroscopic artificial atoms and a superconducting resonator _ , phys .",
    "rev . lett . * 117 * , 210503 ( 2016 ) .",
    "s. gustavsson , f. yan , g. catelani , j. bylander , a. kamal , j. birenbaum , d. hover , d. rosenberg , g. samach , a. p. sears , s. j. weber , j. l. yoder , j. clarke , a. j. kerman , f. yoshihara , y. nakamura , t. p. orlando , w. d. oliver , _ suppressing relaxation in superconducting qubits by quasiparticle pumping _ , science * 354 * , 1573 ( 2016 ) .",
    "s. saito , x. zhu , r. amsss , y matsuzaki , k. kakuyanagi , t. shimo - oka , n. mizuochi , k. nemoto , w. j. munro , and k. semba , _ towards realizing a quantum memory for a superconducting qubit : storage and retrieval of quantum states _",
    "lett . * 111 * , 107008 ( 2013 ) ."
  ],
  "abstract_text": [
    "<S> in principle a 1d array of nearest - neighbour linked qubits is compatible with fault tolerant quantum computing . </S>",
    "<S> however such a restricted topology necessitates a large overhead for shuffling qubits and consequently the fault tolerance threshold is far lower than in 2d architectures . </S>",
    "<S> here we identify a middle ground : a 1d segmented chain which is a linear array of segments , each of which is a well - connected zone with all - to - all connectivity . </S>",
    "<S> the architecture is relevant to both ion trap and solid - state systems . </S>",
    "<S> we establish that fault tolerance can be achieved either by a surface code alone , or via an additional concatenated four - qubit gauge code . </S>",
    "<S> we find that the fault tolerance threshold is @xmath0 for 15-qubit segments , while larger segments are superior . for 35 or more qubits per segment </S>",
    "<S> one can achieve computation on a meaningful scale with today s state - of - the - art fidelities without the use of the upper concatenation layer , thus minimising the overall device size . </S>"
  ]
}