{
  "article_text": [
    "an important question in many classification problems is to find an order of a collection of objects respecting some given information about their pairwise ( dis)similarities . the classic seriation problem , introduced by robinson  @xcite for chronological dating , asks to order objects in such a way that similar objects are ordered close to each other , and it has many applications in different fields ( see  @xcite and references therein ) .    a symmetric matrix @xmath5 is a _ robinson similarity _ matrix if its entries decrease monotonically in the rows and columns when moving away from the main diagonal , i.e. , if @xmath6 for all @xmath7 . given a set of @xmath8 objects to order and a symmetric matrix @xmath9 which represents their pairwise correlations , the seriation problem asks to find ( if it exists ) a permutation @xmath10 of @xmath11 $ ] so that the permuted matrix @xmath12 is a robinson matrix .",
    "if such a permutation exists then @xmath4 is said to be a _",
    "robinsonian similarity _",
    ", otherwise we say that data is affected by noise .",
    "the definitions extend to dissimilarity matrices : @xmath4 is a robinson(ian ) dissimilarity preciely when @xmath13 is a robinson(ian ) similarity .",
    "hence results can be directly transferred from one class to the other one .",
    "robinsonian matrices play an important role in several hard combinatorial optimization problems and recognition algorithms are important in designing heuristic and approximation algorithms when the robinsonian property is desired but the data is affected by noise ( see e.g. @xcite ) . in the last decades , different characterizations of robinsonian matrices have appeared in the literature , leading to different polynomial time recognition algorithms .",
    "most characterizations are in terms of interval ( hyper)graphs .",
    "a graph @xmath14 is an _ interval graph _ if its nodes can be labeled by intervals of the real line so that adjacent nodes correspond to intersecting intervals .",
    "interval graphs arise frequently in applications and have been studied extensively in relation to hard optimization problems ( see e.g. @xcite ) .",
    "a binary matrix has the _ consecutive ones property ( c1p ) _ if its columns can be reordered in such a way that the ones are consecutive in each row .",
    "then a graph @xmath15 is an interval graph if and only if its vertex - clique incidence matrix has c1p , where the rows are indexed by the vertices and the columns by the maximal cliques of @xmath15 @xcite .",
    "a hypergraph @xmath16 is a generalization of the notion of graph where elements of @xmath17 , called _ hyperedges _ , are subsets of @xmath18 .",
    "the incidence matrix of @xmath19 is the @xmath20 matrix whose rows and columns are labeled , respectively , by the hyperedges and the vertices and with an entry 1 when the corresponding hyperedge contains the corresponding vertex .",
    "then @xmath19 is an _ interval hypergraph _ if its incidence matrix has c1p , i.e. , if its vertices can be ordered in such a way that hyperedges are intervals .    given a dissimilarity matrix @xmath21 and a scalar @xmath22 , the _ threshold graph _",
    "@xmath23 has edge set @xmath24 and , for @xmath25 , the ball @xmath26 consists of @xmath27 and its neighbors in @xmath28 .",
    "let @xmath29 denote the collection of all the balls of @xmath4 and @xmath30 denote the corresponding _ ball hypergraph _ , with vertex set @xmath31 $ ] and with @xmath29 as set of hyperedges .",
    "one can also build the intersection graph @xmath32 of @xmath29 , where the balls are the vertices and connecting two vertices if the corresponding balls intersect .",
    "most of the existing algorithms are then based on the fact that a matrix @xmath4 is robinsonian if and only if the ball hypergraph @xmath30 is an interval hypergraph or , equivalently , if the intersection graph @xmath32 is an interval graph ( see @xcite ) .",
    "testing whether an @xmath33 binary matrix with @xmath34 ones has c1p can be done in linear time @xmath35 ( see the first algorithm of booth and leuker @xcite based on pq - trees , the survey @xcite and further references therein ) .",
    "mirkin and rodin @xcite gave the first polynomial algorithm to recognize robinsonian matrices , with @xmath36 running time , based on checking whether the ball hypergraph is an interval hypergraph and using the pq - tree algorithm of @xcite to check whether the incidence matrix has c1p .",
    "later , chepoi and fichet @xcite introduced a simpler algorithm that , using a divide - an - conquer strategy and sorting the entries of @xmath4 , improved the running time to @xmath37 .",
    "the same sorting preprocessing was used by seston @xcite , who improved the algorithm to @xmath38 by constructing paths in the threshold graphs of @xmath4 .",
    "very recently , pra and fortin @xcite presented a more sophisticated @xmath39 algorithm , which uses the fact that the maximal cliques of the graph @xmath32 are in one - to - one correspondence with the row / column indices of @xmath4 .",
    "roughly speaking , they use the algorithm from booth and leuker  @xcite to compute a first pq - tree which they update throughout the algorithm .",
    "a numerical spectral algorithm was introduced earlier by atkins et al .",
    "@xcite for checking whether a similarity matrix @xmath4 is robinsonian , based on reordering the entries of the fiedler eigenvector of the laplacian matrix associated to @xmath4 , and it runs in @xmath40 time , where @xmath41 is the complexity of computing ( approximately ) the eigenvalues of an @xmath0 symmetric matrix .    in this paper",
    "we introduce a new combinatorial algorithm to recognize robinsonian matrices , based on characterizing them in terms of straight enumerations of unit interval graphs .",
    "unit interval graphs are a subclass of interval graphs , where the intervals labeling the vertices are required to have unit length .",
    "as is well known , they can be recognized in linear time @xmath42 ( see e.g. @xcite  and references therein ) .",
    "many of the existing algorithms are based on the equivalence between unit interval graphs and proper interval graphs ( where the intervals should be pairwise incomparable ) ( see @xcite ) .",
    "unit interval graphs have been recently characterized in terms of _ straight enumerations _",
    ", which are special orderings of the classes of the ` undistinguishability ' equivalence relation , calling two vertices undistinguishable if they have the same closed neighborhoods ( see @xcite ) .",
    "this leads to alternative unit interval graph recognition algorithms ( see @xcite ) , which we will use as main building block in our algorithm .",
    "our algorithm relies indeed on the fact that a similarity matrix @xmath4 is robinsonian if and only if its level graphs ( the analogues for similarities of the threshold graphs for dissimilarities ) admit pairwise compatible straight enumerations ( see theorem [ thm : robinsonian decomposition in uig ] ) .    our approach differs from the existing ones in the sense that it is not directly related to interval ( hyper)graphs , but it relies only on unit interval graphs ( which are a simpler graph class than interval graphs ) and on their straight enumerations .",
    "furthermore , our algorithm does not rely on any sophisticated external algorithm such as the booth and leuker algorithm for c1p and no preprocessing to order the data is needed . in fact , the most difficult task carried out by our algorithm is a lexicographic breadth - first search ( abbreviated lex - bfs ) , which is a variant of the classic breadth - first search ( bfs ) , where the ties in the search are broken by giving preference to those vertices whose neighbors have been visited earliest ( see @xcite and @xcite ) . following @xcite ,",
    "we in fact use the variant lex - bfs+ introduced by @xcite to compute straight enumerations .",
    "our algorithm uses a divide - and - conquer strategy with a merging step , tailored to efficiently exploit the possible sparsity structure of the given similarity matrix @xmath4 .",
    "assuming the matrix @xmath4 is given as an adjacency list of an undirected weighted graph , our algorithm runs in @xmath43 time , where @xmath8 is the size of @xmath4 , @xmath1 is the number of nonzero entries of @xmath4 and @xmath3 is the depth of the recursion tree computed by the algorithm , which is upper bounded by the number @xmath44 of distinct nonzero entries of @xmath4 ( see theorem [ thm : robinsonian_recognition_complexity ] ) .",
    "furthermore , we can return all the permutations reordering @xmath4 as a robinson matrix using a pq - tree data structure on which we perform only a few simple operations ( see section  [ secpermutations ] ) .",
    "our algorithm uncovers an interesting link between straight enumerations of unit interval graphs and robinsonian matrices which , to the best of our knowledge , has not been made before .",
    "moreover it provides an answer to an open question posed by m. habib at the prima conference in shanghai in june 2013 , who asked whether it is possible to use lex - bfs+ to recognize robinsonian matrices @xcite .",
    "alternatively one could check whether the incidence matrix  @xmath45 of the ball hypergraph of @xmath4 has c1p , using the lex - bfs based algorithm of @xcite , in time @xmath46 time if @xmath45 is @xmath47 with @xmath34 ones . as @xmath48 , @xmath49 and @xmath50 ,",
    "the overall time complexity is @xmath51 .",
    "interestingly , this approach is not mentioned by habib . in comparison ,",
    "an advantage of our approach is that it exploits the sparsity structure of the matrix @xmath4 , as @xmath3 can be smaller than @xmath44 .",
    "this paper is an extended version of the work @xcite , which appeared in the proceedings of the 9th international conference on algorithms and complexity ( ciac 2015 ) .",
    "section [ secpreliminaries ] contains preliminaries about weak linear orders , straight enumerations and unit interval graphs . in section [ secrobinson ]",
    "we characterize robinsonian matrices in terms of straight enumerations of unit interval graphs . in section [ secalgmain ]",
    "we introduce our recursive algorithm to recognize robinsonian matrices , and then we discuss the complexity issues and explain how to return all the permutations reordering a given similarity matrix as a robinson matrix .",
    "the final section [ secfinal ] contains some questions for possible future work .",
    "throughout @xmath52 denotes the set of symmetric @xmath0 matrices . given a permutation @xmath10 of @xmath11 $ ] and a matrix @xmath53 , @xmath54 is the matrix obtained by permuting both the rows and columns of @xmath4 simultaneously according to @xmath10 . for @xmath55 $ ]",
    ", @xmath56=(a_{ij})_{i , j\\in u}$ ] is the principal submatrix of @xmath4 indexed by @xmath57 . as we deal exclusively with robinson(ian ) similarities , when speaking of a robinson(ian ) matrix , we mean a robinson(ian ) similarity matrix .",
    "an ordered partition @xmath58 of a finite set @xmath18 corresponds to a _ weak linear order _ @xmath59 on @xmath18 ( and vice versa ) , by setting @xmath60 if @xmath61 belong to the same class @xmath62 , and @xmath63 if @xmath64 and @xmath65 with @xmath66 .",
    "then we also use the notation @xmath67 and @xmath68 .",
    "when all classes @xmath62 are singletons then @xmath59 is a linear order ( i.e. , total order ) of @xmath18 .",
    "the _ reversal _ of @xmath59 is the weak linear order , denoted @xmath69 , of the reversed ordered partition @xmath70 . for @xmath71 ,",
    "@xmath72 $ ] denotes the _ restriction _ of the weak linear order @xmath59 to @xmath57 .",
    "given disjoint subsets @xmath73 , we say @xmath74 if @xmath75 for all @xmath76 @xmath77 . if @xmath78 and @xmath79 are weak linear orders on disjoint sets @xmath80 and @xmath81 , then @xmath82 denotes their _ concatenation _ which is a weak linear order on @xmath83 .",
    "the following notions of compatibility and refinement will play an important role in our treatment .",
    "two weak linear orders @xmath78 and @xmath79 on the same set @xmath18 are said to be _ compatible _ if there do not exist elements @xmath84 such that @xmath85 and @xmath86 .",
    "hence , @xmath78 and @xmath79 are compatible if and only if there exists a linear order @xmath10 of @xmath18 which is compatible with both @xmath78 and @xmath79 then their _ common refinement _ is the weak linear order @xmath87 on @xmath18 defined by @xmath88 if @xmath89 for all @xmath90 , and @xmath91 if @xmath92 for all @xmath93 with at least one strict inequality .",
    "we will use the following fact , whose easy proof is omitted .",
    "[ thm : easy common refinement and pi ] let @xmath94 be weak linear orders on @xmath18 .",
    "hence , @xmath94 are pairwise compatible if and only if there exists a linear order @xmath10 of @xmath18 which is compatible with each of @xmath94 , in which case @xmath10 is compatible with their common refinement @xmath95 .    in what follows @xmath31=\\{1,\\ldots , n\\}$ ]",
    "is the vertex set of a graph @xmath14 , whose edges are pairs @xmath96 of distinct vertices @xmath84 . for @xmath25 , we denote by @xmath97 the _ neighborhood _ of @xmath27 .",
    "then , its _ closed neighborhood _ is the set @xmath98 =   \\{x\\}\\cup n(x)$ ] .",
    "two vertices @xmath84 are _ undistinguishable _ if @xmath98=n[y]$ ] .",
    "this defines an equivalence relation on @xmath18 , whose classes are called the _ blocks _ of @xmath15 .",
    "clearly , each block is a clique of @xmath15 .",
    "two distinct blocks @xmath99 and @xmath100 are said to be _ adjacent _ if there exist two vertices @xmath101 @xmath102 that are adjacent in @xmath15 or , equivalently , if @xmath103 is a clique of @xmath15 .",
    "a _ straight enumeration _ of @xmath15 is then a linear order @xmath104 of the blocks of @xmath15 such that , for any block @xmath62 , the block @xmath62 and the blocks @xmath105 adjacent to it are consecutive in the linear order ( see @xcite ) .",
    "the blocks @xmath106 and @xmath107 are called the _ end blocks _ of @xmath108 and @xmath62 ( with @xmath109 ) are its _",
    "inner blocks_. having a straight enumeration is a strong property , and not all graphs have one .",
    "in fact , this notion arises naturally in the context of unit interval graphs as recalled below .",
    "a graph @xmath110,e)$ ] is called an _ interval graph _ if its vertices can be mapped to intervals @xmath111 of the real line such that , for distinct vertices @xmath84 , @xmath112 if and only if @xmath113 .",
    "such a set of intervals is called a _ realization _ of @xmath15 , and it is not unique . if the graph g admits a realization by unit intervals , then @xmath15 is said to be a _ unit interval graph_.    interval graphs and unit interval graphs play an important role in many applications in different fields .",
    "many np - complete graph problems can be solved in polynomial time on interval graphs ( this holds e.g. for the bandwidth problem @xcite ) . however , there are still problems which remains np - hard also for interval graphs ( this holds e.g. for the minimal linear arrangement problem @xcite ) .",
    "it is well known that interval graphs and unit interval graphs can be recognized in @xmath42 time @xcite .",
    "for a more complete overview on linear recognition algorithms for unit interval graphs , see @xcite and references therein .",
    "most of the above mentioned algorithms are based on the equivalence between unit interval graphs and proper interval graphs ( i.e. , graphs admitting a realization by pairwise incomparable intervals ) or indifference graphs @xcite .",
    "furthermore , there exist several equivalent characterizations for unit interval graphs .",
    "the following one in terms of straight enumerations will play a central role in  our paper .",
    "[ thm : uig and straight enumeration ] @xcite a graph @xmath15 is a unit interval graph if and only if it has a straight enumeration .",
    "moreover , if @xmath15 is connected , then it has a unique ( up to reversal ) straight enumeration .",
    "on the other hand , if @xmath15 is not connected , then any possible linear ordering of the connected components combined with any possible orientation of the straight enumeration of each connected component induces a straight enumeration of @xmath15 .",
    "the next theorem summarizes several known characterizations for unit interval graphs , combining results from @xcite .",
    "recall that @xmath114 is the graph with one degree-3 vertex connected to three degree-1 vertices ( also known as _ claw _ ) .",
    "[ thm : unit graphs main theorem ] the following are equivalent for a graph @xmath14 .    1 .",
    "@xmath15 is a unit interval graph .",
    "@xmath15 is an interval graph with no induced subgraph @xmath114 .",
    "( 3-vertex condition ) * there is a linear ordering @xmath10 of @xmath18 such that , for all @xmath115 , @xmath116 4 .   *",
    "( neighborhood condition ) * there is a linear ordering @xmath10 of @xmath18 such that for any @xmath25 the vertices in @xmath98 $ ] are consecutive with respect to  @xmath10 .",
    "( clique condition ) * there is a linear ordering @xmath10 of @xmath18 such that the vertices contained in any maximal clique of  @xmath15 are consecutive with respect to @xmath10 .",
    "in this section we characterize robinsonian matrices in terms of straight enumerations of unit interval graphs .",
    "we focus first on binary robinsonian matrices .",
    "we may view any symmetric binary matrix with all diagonal entries equal to 1 as the _ extended _ adjacency matrix of a graph .",
    "the equivalence between binary robinsonian matrices and indifference graphs ( and thus with unit interval graphs ) was first shown by roberts @xcite . furthermore ,",
    "as observed , e.g. , by corneil et al .",
    "@xcite , the  neighborhood condition \" for a graph is equivalent to its extended adjacency matrix having c1p .",
    "hence we have the following equivalence between robinsonian binary matrices and unit interval graphs , which also follows as a direct application of theorem [ thm : unit graphs main theorem]_(iii)_.    [ thm : robinsonian matrices and 3-vertex condition ] let @xmath14 be a graph and @xmath117 be its extended adjacency matrix .",
    "then , @xmath117 is a robinsonian similarity if and only if @xmath15 is a unit interval graph .",
    "the next result characterizes the linear orders that reorder the extended adjacency matrix @xmath117 as a robinson matrix in terms of the straight enumerations of @xmath15 .",
    "it is simple but will play a central role in our algorithm for recognizing robinsonian similarities .",
    "[ thm : robinson reordering and straight enumeration ] let @xmath14 be a graph .",
    "a linear order @xmath10 of @xmath18 reorders @xmath117 as a robinson matrix if and only if there exists a straight enumeration of @xmath15 whose corresponding weak linear order @xmath59 is compatible with @xmath10 , i.e. , satisfies : @xmath118    assume that @xmath10 is a linear order of @xmath18 that reorders @xmath117 as a robinson matrix .",
    "then it is easy to see that the 3-vertex condition holds for @xmath10 and that each block of @xmath15 is an interval w.r.t .",
    "@xmath10 . therefore the order @xmath10 induces an order @xmath59 of the blocks : @xmath68 , with @xmath119 if and only if @xmath120 for all @xmath121 and @xmath122 .",
    "in other words , @xmath59 is compatible with @xmath10 by construction .",
    "moreover , @xmath59 defines a straight enumeration of @xmath15 . indeed , if @xmath123 and @xmath124 are adjacent then @xmath105 is adjacent to @xmath62 and @xmath125 , since this property follows directly from the 3-vertex condition for @xmath10 .",
    "conversely , assume that @xmath68 is a straight enumeration of @xmath15 and let @xmath10 be a linear order of @xmath18 which is compatible with @xmath59 , i.e. , satisfies ( [ eqequi ] ) .",
    "we show that @xmath10 reorders @xmath117 as a robinson matrix .",
    "that is , we show that if @xmath126 , then @xmath127 or , equivalently , that @xmath128 implies @xmath129 . if @xmath130 belong to the same block @xmath62 then @xmath131 ( using ( [ eqequi ] ) ) and thus @xmath132 since @xmath62 is a clique .",
    "assume now that @xmath121 , @xmath133 and @xmath134 .",
    "then , @xmath135 and @xmath62 , @xmath125 are adjacent blocks and thus @xmath136 is a clique . if @xmath131 then @xmath137 is adjacent to @xmath27 and @xmath138 ( since @xmath136 is a clique ) .",
    "analogously if @xmath139 .",
    "suppose now that @xmath122 .",
    "then , using ( [ eqequi ] ) , we have that @xmath140 .",
    "as @xmath59 is a straight enumeration with @xmath62,@xmath125 adjacent it follows that @xmath105 is adjacent to @xmath62 and to @xmath125 and thus @xmath137 is adjacent to @xmath27 and @xmath138 .",
    "hence , in order to find the permutations reordering a given binary matrix @xmath4 as a robinson matrix , it suffices to find all the possible straight enumerations of the corresponding graph @xmath15 .",
    "as is shown e.g. in @xcite , this is a simple task and can be done in linear time .",
    "this is coherent with the fact that c1p can be checked in linear time ( see @xcite and references therein ) .    we now consider a general ( nonbinary ) matrix @xmath4 .",
    "we first introduce its ` level graphs ' , the analogues for similarity matrices of the threshold graphs for dissimilarities .",
    "let @xmath141 denote the distinct values taken by the entries of @xmath4 .",
    "the graph @xmath142 , whose edges are the pairs @xmath96 with @xmath143 , is called the _",
    "@xmath144-th level graph _ of  @xmath4 .",
    "let @xmath145 be the all ones matrix .",
    "clearly , both @xmath145 and @xmath146 are robinson matrices .",
    "hence , we may and will assume , without loss of generality , that @xmath147 .",
    "then , @xmath4 is nonnegative and @xmath148 is its support graph .",
    "the level graphs can be used to decompose @xmath4 as a conic combination of binary matrices and , as already observed by roberts @xcite , @xmath4 is robinson precisely when these binary matrices are robinson .",
    "this is summarized in the next lemma , whose easy proof is omitted .",
    "[ thm : level graphs ] let @xmath149 with distinct values @xmath141 and with level graphs @xmath150 . then",
    ": @xmath151 moreover , @xmath4 is robinson if and only if @xmath152 is robinson for each @xmath153 $ ] .    clearly , if @xmath4 is a robinsonian matrix then the adjacency matrices of its level graphs @xmath154  ( @xmath155 $ ] ) are robinsonian too",
    "however , the converse is not true : it is easy to build a small example where @xmath4 is not robinsonian although the extended adjacency matrix of each of its level graphs is robinsonian .",
    "the difficulty lies in the fact that one needs to find a permutation that reorders _ simultaneously _ the extended adjacency matrices of all the level graphs as robinson matrices .",
    "roberts @xcite first introduced a characterization of robinsonian matrices in terms of indifference graphs ( i.e. unit interval graphs ) . rephrasing his result using the notion of level graphs",
    ", he showed that @xmath4 is robinsonian if and only if its level graphs have vertex linear orders that are compatible ( see ( * ? ? ? * theorem 4.4 ) ) .",
    "however , he does not give any algorithmic insight on how to find such orders .",
    "combining the links between binary robinsonian matrices and unit interval graphs ( lemma  [ thm : robinsonian matrices and 3-vertex condition ] ) and between reorderings of binary robinsonian matrices and straight enumerations of unit interval graphs ( theorem [ thm : robinson reordering and straight enumeration ] ) together with the decomposition result of lemma [ thm : level graphs ] , we obtain the following characterization of robinsonian matrices .    [",
    "thm : robinsonian decomposition in uig ] let @xmath156 with level graphs @xmath150 .",
    "then :    * @xmath4 is a robinsonian matrix if and only if there exist straight enumerations of @xmath157 @xmath158 @xmath159 whose corresponding weak linear orders @xmath160 are pairwise compatible . * a linear order @xmath10 of @xmath18 reorders @xmath4 as a robinson matrix if and only if there exist pairwise compatible straight enumerations of @xmath161 , whose corresponding common refinement is compatible with  @xmath10 .",
    "observe first that if assertion _",
    "( ii ) _ holds then _",
    "( i ) _ follows directly using the result of lemma [ thm : easy common refinement and pi ] .",
    "we now prove _",
    "( ii)_. assume that @xmath4 is robinsonian and let @xmath10 a linear order of @xmath18 that reorders @xmath4 as a robinson matrix .",
    "then @xmath162 is robinson and thus , by lemma [ thm : level graphs ] , each permuted matrix @xmath163 is a robinson matrix .",
    "then , applying theorem [ thm : robinson reordering and straight enumeration ] , for each @xmath153 $ ] , there exists a straight enumeration of @xmath154 whose corresponding weak linear ordering @xmath164 is compatible with  @xmath10 .",
    "we can thus conclude that the common refinement of @xmath160 is compatible in view of lemma [ thm : easy common refinement and pi ] .",
    "conversely , assume that there exist straight enumerations of @xmath161 whose corresponding weak linear orders @xmath160 are pairwise compatible with @xmath10 and their common refinement is compatible with @xmath10 .",
    "then , by theorem [ thm : robinson reordering and straight enumeration ] , @xmath10 reorders simultaneously each @xmath152 as a robinson matrix and thus @xmath162 is robinson , which shows that @xmath4 is robinsonian .",
    "we describe here our algorithm for recognizing whether a given symmetric nonnegative matrix @xmath4 is robinsonian .",
    "first , we introduce an algorithm which either returns a permutation reordering @xmath4 as a robinson matrix or states that  @xmath4 is not a robinsonian matrix .",
    "then , we show how to modify it in order to return all the permutations reordering @xmath4 as a robinson matrix .",
    "the algorithm is based on theorem [ thm : robinsonian decomposition in uig ] .",
    "the main idea is to find straight enumerations of the level graphs of @xmath4 that are pairwise compatible and to compute their common refinement .",
    "the matrix @xmath4 is not robinsonian precisely when these objects can not be found . as above",
    ", @xmath44 denotes the number of distinct nonzero entries of @xmath4 and throughout @xmath165,e_\\ell)$ ] is the @xmath144-th level graph , whose edges are the pairs @xmath96 with @xmath143 , for @xmath166 $ ]",
    ".    one of the main tasks in the algorithm is to find ( if it exists ) a straight enumeration of a graph @xmath15 which is compatible with a given weak linear order @xmath59 of @xmath18 . roughly speaking",
    ", @xmath15 will correspond to a level graph @xmath154 of @xmath4 ( in fact , to a connected component of it ) , while @xmath59 will correspond to the common refinement of the previous level graphs @xmath167 . hence , looking for a straight enumeration of @xmath15 compatible with @xmath59 will correspond to looking for a straight enumeration of @xmath154 compatible with previously selected straight enumerations of the previous level graphs @xmath167 .    since the straight enumerations of the level graphs might not be unique",
    ", it is important to choose , among all the possible straight enumerations , the ones that lead to a common refinement ( if it exists ) .    if @xmath15 is a connected unit interval graph , its straight enumeration @xmath108 is unique up to reversal ( see theorem  [ thm : uig and straight enumeration ] ) . on the other hand ,",
    "if @xmath15 is not connected then any possible ordering of the connected components induces a straight enumeration , obtained by concatenating straight enumerations of its connected components .",
    "this freedom in choosing the straight enumerations of the components is crucial in order to return _ all _ the robinson orderings of @xmath4 , and it is taken care of in section [ secpermutations ] using pq - trees .",
    "as we will see in section  4.1.4 , the choice of a straight enumeration of @xmath15 compatible with @xmath59 reduces to correctly orient straight enumerations of the connected components of @xmath15 .",
    "there are three main subroutines in our algorithm : _ co - lex - bfs _",
    "( see algorithm  [ alg : lex - bfsweak ] ) , a variation of lex - bfs , which finds and orders the connected components of the level graphs ; _ straight_enumeration _ ( see algorithm  [ alg : straght_enumeration ] ) , which computes the straight enumeration of a connected graph as in @xcite ; _ refine _ ( see algorithm  [ alg : refine ] ) , a variation of partition refinement , which finds the common refinement of two weak linear orders .",
    "these subroutines are used in the recursive algorithm _ robinson _ ( see algorithm [ alg : robinsonian recognition ] ) .",
    "our first subroutine is _ co - lex - bfs _",
    "( where co stands for ` component ordering ' ) in algorithm  [ alg : lex - bfsweak ] . given a graph @xmath14 and a weak linear order @xmath59 of @xmath18 , it detects the connected components of @xmath15 and orders them in a compatible way with respect to @xmath59 . according to lemma [ thm : order connected components ] below ,",
    "this is possible if @xmath15 admits a straight enumeration compatible with @xmath59 .",
    "[ thm : order connected components ] consider a graph @xmath14 and a weak linear order @xmath59 of @xmath18 .",
    "if @xmath15 has a straight enumeration @xmath108 compatible with @xmath59 then there exists an ordering @xmath168 of the connected components of @xmath15 which is compatible with @xmath59 , i.e. , such that @xmath169 .    if @xmath170 is the ordering of the components of @xmath15 which is induced by the straight enumeration @xmath108 , i.e. , @xmath171 , then @xmath172 as @xmath108 is compatible with @xmath59 .",
    "mark all the vertices as unvisited + @xmath173 + @xmath174 + let @xmath175 be a vertex in @xmath106 + @xmath176 + @xmath177 and @xmath178    algorithm  [ alg : lex - bfsweak ] is based on the following observations . when the vertex @xmath179 in the set @xmath180 at line  [ alg : slices ] ( which represents the current set of unvisited vertices with a tie , known as _ slice _ in lex - bfs ) has label @xmath181 , it means that @xmath179 is not contained in the current component @xmath182 , so a new component containing @xmath179 is opened .",
    "every time a connected component @xmath183 has been completed , we check if it can be ordered along the already detected components in a compatible way with  @xmath59 .",
    "we also do this for the last completed component @xmath184 , at the last iteration @xmath185 at line 9 of algorithm  [ alg : lex - bfsweak ] .",
    "let @xmath186 and  @xmath187 denote respectively the first and the last blocks of @xmath59 intersecting @xmath182 .",
    "we distinguish two cases :    1 .   if @xmath182 meets more than one block of @xmath59 ( i.e. , if @xmath188 ) , we check if all the inner blocks between @xmath189 and @xmath190 are contained in @xmath183",
    ". if this is not the case , then the algorithm stops .",
    "moreover the algorithm also stops if both @xmath183 and @xmath191 meet exactly the same two blocks , i.e. , @xmath192 and @xmath193 . in both cases",
    "it is indeed not possible to order the components in a compatible way with @xmath59 .",
    "if @xmath182 meets only one block @xmath125 of @xmath59 ( i.e. , @xmath194 ) and if this block @xmath125 is the first block of the previous connected component @xmath195 ( i.e. , @xmath196 ) , then we swap @xmath195 and @xmath182 in order to make the ordering of the components compatible with @xmath59 . the ordering @xmath178 is updated by setting , for each @xmath197 its new ordering as @xmath198 and for each @xmath199 as @xmath200 .",
    "observe that if we are in the case when both @xmath183 and @xmath195 are contained in @xmath125 , then we do not need to do this swap , i.e. , the two components @xmath183 and @xmath195 can be ordered arbitrarily .    the next lemma shows the correctness of algorithm [ alg : lex - bfsweak ] .",
    "[ thm : connected components ] let @xmath14 be a graph and let @xmath59 be a weak linear order of @xmath18 .    1 .",
    "if algorithm [ alg : lex - bfsweak ] successfully terminates then the returned order @xmath170 of the components satisfies + @xmath201 .",
    "if algorithm [ alg : lex - bfsweak ] stops then no ordering of the components exists that is compatible with @xmath59 .    _",
    "( i ) _ assume first that algorithm [ alg : lex - bfsweak ] successfully terminates and returns the linear ordering @xmath170 of the components .",
    "suppose for contradiction that @xmath202 for some @xmath203 $ ] with @xmath204 .",
    "then there exist @xmath205 and @xmath206 such that @xmath207 .",
    "let @xmath138 be the first vertex selected in the component @xmath195 .",
    "then , @xmath208 ( for if not the algorithm would have selected @xmath137 before @xmath138 when opening the component @xmath195 ) .",
    "let @xmath209 and denote by @xmath210 and @xmath211 , respectively , the first and last blocks of @xmath59 meeting @xmath182 ( @xmath212 and @xmath213 are analogously defined ) .",
    "say , @xmath214 , @xmath131 so that @xmath66 , and @xmath215 . as @xmath208 , we have @xmath216 .",
    "suppose first that @xmath217 .",
    "then , @xmath62 is an inner block between @xmath218 and @xmath219 which is not contained in @xmath195 ( since @xmath131 ) , yielding a contradiction since the algorithm would have stopped when dealing with the component @xmath195 .",
    "suppose now that @xmath220 .",
    "if @xmath221 $ ] has only one block @xmath99 , then @xmath222 and then the algorithm would have swapped @xmath183 and @xmath195 .",
    "hence @xmath221 $ ] has at least two blocks and @xmath223 , which is again a contradiction since the algorithm would have stopped . + _",
    "( ii ) _ assume now that the algorithm stops after the completion of the component @xmath183 . then @xmath221 $ ] has at least two blocks .",
    "suppose first that the algorithm stops because @xmath224 .",
    "then clearly one can not have @xmath225 .",
    "we show that we also can not have @xmath226 .",
    "for this assume for contradiction that @xmath226 .",
    "let @xmath137 be the first selected vertex in @xmath183 and let @xmath27 be the first vertex selected in @xmath195 .",
    "then , @xmath227 , @xmath75 ( for if not the algorithm would have considered the component @xmath183 before @xmath195 ) , and thus @xmath228 .",
    "if @xmath229 then the algorithm would have stopped earlier when examining @xmath195 , since @xmath230 and @xmath231 .",
    "hence , we have @xmath232 and , as @xmath221 $ ] has at least two blocks , there exists a vertex @xmath233 such that @xmath234 , which contradicts @xmath226 .",
    "suppose now that the algorithm stops because @xmath235 and @xmath236 .",
    "let @xmath237 and @xmath238 , and say @xmath239 .",
    "then we can not have @xmath240 since @xmath234 , and we also can not have @xmath241 since @xmath242 .",
    "hence the two components @xmath183 and @xmath243 can not be ordered compatibly with @xmath59 and this concludes the proof .",
    "once the connected components of @xmath15 are ordered , we need to compute a straight enumeration of each connected component @xmath244 $ ] .",
    "we do this with the routine _ straight_enumeration _ appplied to ( @xmath244,\\sigma_\\omega$ ] ) , where @xmath245 is a suitable given order of @xmath183 ( namely , @xmath246 $ ] , where @xmath178 is the vertex order returned by _ _ co - lex - bfs__@xmath247 ) .",
    "this routine is essentially the 3-sweep unit interval graph recognition algorithm of corneil @xcite which , briefly , computes three times a lex - bfs ( each is named a _ sweep _ ) and uses the vertex ordering coming from the previous sweep to break ties in the search for the next sweep . the only difference of _ _ straight_enumeration__@xmath248,\\sigma_\\omega)$ ] with respect to corneil s algorithm is that we save the first sweep , because we use the order @xmath245 returned by _ co - lex - bfs_. we now describe the routine _ straight_enumeration _ which is based on the algorithms of @xcite and @xcite .",
    "below , @xmath249 denotes the degree of the vertex @xmath250 in @xmath15 .",
    "@xmath251 = _ lex - bfs+_(@xmath252 ) + @xmath253 = _ lex - bfs+_(@xmath254 ) + @xmath255 ( index of the blocks of @xmath59 ) + @xmath256 ( dummy variables to record the current block @xmath62 ) + @xmath257    basically , after the last sweep of lex - bfs , for each vertex @xmath250 we define the leftmost vertex @xmath258 and the rightmost vertex @xmath259 , according to @xmath253 , that are adjacent to @xmath250 . checking whether @xmath260 corresponds exactly to checking whether the neighborhood condition holds for node @xmath250 .",
    "the vertices with the same leftmost and rightmost vertex are then indistinguishable vertices , and they form a block of @xmath15 .",
    "the order of the blocks follows the vertex order @xmath253 .",
    "given two weak linear orders @xmath59 and @xmath108 on  @xmath18 , our second subroutine _ refine _ in algorithm [ alg : refine ] computes their common refinement @xmath261 ( if it exists ) .",
    "@xmath262 is the last block of @xmath59 meeting @xmath263 + @xmath264 +    we show the correctness of algorithm [ alg : refine ] .",
    "[ thm : compatible refine ] if algorithm  [ alg : refine ] returns a weak linear order @xmath265 of @xmath18 , then @xmath265 is the common refinement of @xmath59 and @xmath108 . if algorithm  [ alg : refine ] returns @xmath264 , then  @xmath59 and  @xmath108 are not compatible .",
    "the proof is by induction on the number @xmath266 of blocks of @xmath108 .",
    "if @xmath267 then @xmath268 is clearly compatible with @xmath59 and the algorithm returns @xmath269 as desired .",
    "assume now @xmath270 .",
    "let @xmath271 .",
    "then we can apply the induction assumption to @xmath272 $ ] and @xmath273 $ ] ( which has @xmath274 blocks ) .",
    "assume first that the algorithm returns @xmath265 which is a weak linear order of @xmath18 .",
    "we show that @xmath275 , i.e. , that the following holds for all @xmath84 : @xmath276 if @xmath277 then @xmath278 and ( [ eq : phi ] ) holds since @xmath279=\\psi[c_1]$ ] . if @xmath280 , then  ( [ eq : phi ] ) holds by the induction assumption .",
    "suppose now @xmath281 and @xmath282 .",
    "then @xmath283 and @xmath284 .",
    "we show that @xmath75 holds . for this",
    "let @xmath62 ( resp .",
    ",  @xmath105 ) be the block of @xmath59 containing @xmath27 ( resp . , @xmath137 ) .",
    "then @xmath285 since @xmath106 meets  @xmath263 as @xmath281 .",
    "moreover , @xmath286 , which implies @xmath75 .",
    "indeed , if one would have @xmath287 , then we would have @xmath264 ( line [ alg : refine line 1 ] in algorithm  [ alg : refine ] ) , since @xmath288 as @xmath289 , and thus @xmath265 would not be a weak linear order of  @xmath18 .",
    "assume now that the returned @xmath265 is not a weak linear order of @xmath18 .",
    "if @xmath264 ( line  [ alg : refine line 1 ] in algorithm  [ alg : refine ] ) , then there is a block @xmath290 such that @xmath291 , and we can pick elements @xmath292 and @xmath293 so that @xmath294 and @xmath295 , which shows that @xmath59 and @xmath108 are not compatible",
    ". if @xmath265 is a weak linear order of a subset @xmath296 ( line  [ alg : refine line 2 ] in algorithm  [ alg : refine ] ) , then it means that the weak linear order returned by the recursive routine _ _",
    "refine__@xmath297 , \\phi[w])$ ] is not a weak linear order of @xmath298 ( but of a subset ) and thus , by the induction assumption , @xmath272 $ ] and  @xmath299 $ ] are not compatible and thus @xmath59 and @xmath108 neither .",
    "this concludes the proof .",
    "we can now describe our main algorithm _ _ robinson__@xmath300 . given a nonnegative matrix @xmath301 and a weak linear order @xmath59 of @xmath31",
    "$ ] , it either returns a weak linear order @xmath265 of @xmath18 compatible with @xmath59 and with straight enumerations of the level graphs of @xmath4 , or it indicates that such @xmath265 does not exist .",
    "the idea behind the algorithm is the following .",
    "we use the subroutines _ co - lex - bfs _ and _ straight_enumeration _ to order the components and compute the straight enumerations of the level graphs of @xmath4 , and we refine them using the subroutine _",
    "refine_. however , instead of refining the level graphs one by one on the full set @xmath18 , we use a recursive algorithm based on a divide - and - conquer strategy , which refines smaller and smaller subgraphs of the level graphs obtained by restricting to the connected components and thus working independently with the corresponding principal submatrices of @xmath4 . in this way we work with smaller subproblems and",
    "one may also skip some level graphs ( as some principal submatrices of @xmath4 may have fewer distinct nonzero entries ) .",
    "this recursive algorithm is algorithm [ alg : robinsonian recognition ] below .",
    "@xmath15 is the support of a + _ _ co - lex - bfs__@xmath247 returns a linear order @xmath177 of the connected components of @xmath15 compatible with @xmath59 ( if it exists ) and a vertex order @xmath178 + @xmath264 + : @xmath265    the algorithm _ _",
    "robinson__@xmath300 works as follows .",
    "we are given as input a symmetric nonnegative matrix @xmath21 and a weak linear order @xmath59 of @xmath31 $ ] .",
    "let @xmath15 be the support of @xmath4 .",
    "first , we find the connected components of @xmath15 and we order them in a compatible way with @xmath59 .",
    "if this is not possible , then we stop as there do not exist straight enumerations of the level graphs of @xmath4 compatible with @xmath59 ( theorem  [ thm : connected components ] ) .",
    "otherwise , we initialize the weak linear order @xmath265 , which at the end of the algorithm will represent a common refinement of the straight enumerations of the level graphs of @xmath4 . in order to find  @xmath265",
    ", we divide the problem over the connected components of @xmath15 .",
    "the idea is then to work independently on each connected component @xmath182 and to find its ( unique up to reversal ) straight enumeration @xmath302 and the common refinement @xmath303 of @xmath304 $ ] and  @xmath305 .    for each component @xmath182",
    ", we compute the straight enumeration @xmath302 of @xmath244 $ ] if it exists , else we stop ( theorem  [ thm : uig and straight enumeration ] ) . since @xmath302 is unique up to reversal , we check if either @xmath302 or @xmath306 is compatible with @xmath304 $ ] . specifically , we first compute the common refinement @xmath303 of @xmath304 $ ] and @xmath302 .",
    "if it is nonempty we continue ( lemma  [ thm : compatible refine ] ) , while if it is is empty we compute the common refinement @xmath303 of @xmath304 $ ] and @xmath306 .",
    "if such a common refinement is nonempty we continue  ( lemma  [ thm : compatible refine ] ) , while if it is again empty this time we stop , as no straight enumeration of @xmath307 compatible with @xmath304 $ ] exists .",
    "finally , we set to zero the smallest nonzero entries of @xmath308 $ ] , obtaining the new matrix @xmath309 $ ] ( whose nonzero entries take fewer distinct values than the matrix @xmath310 $ ] ) .",
    "now , if the matrix @xmath309 $ ] is diagonal , then we concatenate @xmath303 after @xmath311 in @xmath265 . otherwise , we make a recursive call , where the input of the recursive routine is the matrix @xmath309 $ ] and @xmath303 .",
    "if the algorithm successfully terminates , then the concatenation @xmath312 will represent a straight enumeration of @xmath15 , and @xmath313 will represent the common refinement of this straight enumeration with the given weak linear order @xmath59 and with the level graphs of @xmath4 .",
    "the final algorithm is algorithm [ alg : robinsonian_main ] below .",
    "@xmath314 +    roughly speaking , every time we make a recursive call , we are basically passing to the next level graph of @xmath4 .",
    "hence , each recursive call can be visualized as the node of a recursion tree , whose root is defined by the first recursion in algorithm [ alg : robinsonian_main ] , and whose leaves ( i.e. the pruned nodes ) are the subproblems whose corresponding submatrices are diagonal .",
    "the correctness of algorithm [ alg : robinsonian_main ] follows directly from the correctness of algorithm [ alg : robinsonian recognition ] , which is shown by the next theorem .",
    "indeed , assume that algorithm [ alg : robinsonian recognition ] is correct .",
    "then , if algorithm [ alg : robinsonian_main ] terminates then it computes a weak linear order @xmath265 compatible with straight enumerations of the level graphs of @xmath4 and thus the returned order @xmath10 orders @xmath4 as a robinson matrix in view of theorem [ thm : robinsonian decomposition in uig ] _",
    "( ii)_. on the other hand , if algorithm [ alg : robinsonian_main ] stops then algorithm [ alg : robinsonian recognition ] stops with the input @xmath315 . then no weak linear order @xmath265 exists which is compatible with straight enumerations of the level graphs of @xmath4 and thus , in view of theorem  [ thm : robinsonian decomposition in uig ] _ ( i ) _ , @xmath4 is not robinsonian .",
    "[ thm : correctness ] consider a weak linear order @xmath59 of @xmath31 $ ] and a nonnegative matrix @xmath301 ordered compatibly with   @xmath59 .    *",
    "if algorithm [ alg : robinsonian recognition ] terminates , then there exist straight enumerations @xmath316 of the level graphs @xmath150 of @xmath4 such that the returned weak linear order @xmath265 is compatible with each of them and with @xmath59 . *",
    "if algorithm [ alg : robinsonian recognition ] stops then there do not exist straight enumerations of the level graphs of @xmath4 that are pairwise compatible and compatible with @xmath59 .",
    "the proof is by induction on the number @xmath44 of distinct nonzero entries of the matrix @xmath4 .",
    "we first consider the base case @xmath317 , i.e. , when @xmath4 is ( up to scaling ) 0/1 valued .",
    "we first show _",
    "( i ) _ and assume that the algorithm terminates successfully and returns @xmath265 .",
    "then @xmath15 is the support of @xmath4 , _ _ co - lex - bfs__@xmath247 orders the components of @xmath15 as @xmath172 , and @xmath318 where each @xmath319 $ ] is build as the common refinement of  @xmath221 $ ] and a straight enumeration of  @xmath244 $ ] ( either @xmath302 or @xmath306 ) .",
    "hence @xmath15 has a straight enumeration @xmath108 and the returned  @xmath265 is compatible with @xmath108 and  @xmath59 .",
    "we now show _",
    "( ii ) _ and assume that algorithm [ alg : robinsonian recognition ] stops .",
    "if it stops when applying _ _ co - lex - bfs__@xmath247 , then no order of the components of @xmath15 exists that is compatible with @xmath59 and thus no straight enumeration of @xmath15 exists that is compatible with @xmath59 ( lemma  [ thm : order connected components ] ) . if the algorithm stops when applying _ straight_enumeration _ to @xmath320 $ ] then no straight enumeration of @xmath320 $ ] exists .",
    "else , if the algorithm stops at line [ alg : rob line ] in algorithm  [ alg : robinsonian recognition ] , then @xmath304 $ ] is not compatible with neither @xmath302 nor @xmath306 . because @xmath320 $ ] is connected , @xmath302 and @xmath306 are its unique straight enumerations ( see theorem  [ thm : uig and straight enumeration ] ) and",
    "therefore no straight enumeration of @xmath320 $ ] is compatible with @xmath304 $ ] . in both cases ,",
    "no straight enumeration of @xmath15 exists that is compatible with  @xmath59 .",
    "we now assume that theorem [ thm : correctness ] holds for any matrix whose entries take at most @xmath321 distinct nonzero values .",
    "we show that the theorem holds when considering @xmath4 whose nonzero entries take @xmath44 distinct values .",
    "we follow the same lines as the above proof for the case @xmath317 , except that we use recursion for some components .",
    "first , assume that the algorithm terminates and returns @xmath265 .",
    "then , @xmath322 after ordering the components compatibly with @xmath59 as @xmath172 , constructing the common refinement @xmath303 of @xmath304 $ ] and a straight enumeration ( say ) @xmath302 of @xmath320 $ ] , and having @xmath323 , \\phi_\\omega)$ ] , where @xmath324 $ ] is obtained from @xmath310 $ ] by setting to 0 its entries with smallest nonzero value . by the induction assumption ,",
    "@xmath325 is compatible with straight enumerations of the level graphs of the matrix @xmath324 $ ] and with @xmath326 .",
    "as @xmath325 is compatible with  @xmath326 , which refines both @xmath304 $ ] and  @xmath302 , it follows that @xmath325 is compatible with  @xmath221 $ ] and  @xmath305 .",
    "therefore , @xmath325 is compatible with straight enumerations of all the level graphs of  @xmath310 $ ] and thus @xmath322 is compatible with  @xmath59 and all level graphs of  @xmath4 , as desired .",
    "assume now that the algorithm stops .",
    "if the algorithm stops at _ _ co - lex - bfs__@xmath247 , then no linear order of the connected components of @xmath15 exists that is compatible with @xmath59 and then no straight enumeration of @xmath15 exists that is compatible with @xmath59 ( lemma  [ thm : order connected components ] ) , giving the desired conclusion .",
    "if the algorithm stops at line  [ alg : rob line ] , then a connected component @xmath182 is found for which @xmath304 $ ] is not compatible with any straight enumeration of @xmath320 $ ] , giving again the desired conclusion .",
    "assume now that the algorithm stops at line  [ alg : rob line 2 ] , i.e. , there is a component  @xmath182 for which the algorithm terminates when applying @xmath327 , \\phi_\\omega)$ ] .",
    "then , by the induction assumption , we know that : @xmath328 \\text { exist   } \\\\ \\text{that are pariwise compatible and compatible with   } \\phi_{\\omega } , \\end{array}\\ ] ]    where @xmath303 is the common refinement of  @xmath304 $ ] and a straight enumeration ( say )  @xmath302 of @xmath320 $ ] . assume , for the sake of contradiction , that there exist straight enumerations  @xmath329 of the level graphs  @xmath330 of @xmath4 , that are pairwise compatible and compatible with @xmath59 .",
    "in particular , @xmath331 $ ] is a straight enumeration of @xmath320 $ ] compatible with @xmath304 $ ] . if @xmath331",
    "= \\phi_{\\omega}$ ] , then the restrictions @xmath332 ( @xmath333 ) yield straight enumerations of the level graphs of @xmath309 $ ] that are pairwise compatible and compatible with @xmath302 and @xmath304 $ ] , and thus with their refinement @xmath334 \\wedge \\phi_{\\omega}$ ] , contradicting  ( [ eq : induction correctness ] ) .",
    "hence , @xmath331 = \\overline{\\phi}_{\\omega}$ ] , so that @xmath304 $ ] is compatible with both @xmath302 and its reversal @xmath306 .",
    "this implies that @xmath304 = ( v_{\\omega})$ ] .",
    "but then the reversals @xmath335 , \\dots , \\overline{\\varphi}^{(l)}[v_{\\omega}]$ ] provide straight enumerations of the level graphs of @xmath309 $ ] that are pairwise compatible and compatible with @xmath336 = \\phi_{\\omega } = \\phi_{\\omega}$ ] .",
    "this contradicts again  ( [ eq : induction correctness ] ) and concludes the proof .",
    "we now study the complexity of our main algorithm .",
    "first we discuss the complexity of the two subroutines _ co - lex - bfs _ and _ refine _ in algorithms 1 and 2 and then we derive the complexity of the final algorithm 4 . in the rest of the section",
    ", we let @xmath1 denote the number of nonzero ( upper diagonal ) entries of @xmath4 , so that @xmath1 is the number of edges of the support graph @xmath337 and @xmath338 for the level graphs of @xmath4 .",
    "we assume that @xmath4 is a nonnegative symmetric matrix , which is given as an adjacency list of an undirected weighted graph , where each vertex @xmath339 is linked to the list of vertex / weight pairs corresponding to the neighbors @xmath137 of @xmath27 in @xmath15 with nonzero entry  @xmath340 .",
    "a simple but important observation that we will repeatedly use is that , given a weak linear order @xmath59 of @xmath18 , we can assume the vertices @xmath18 to be ordered according to a linear order  @xmath341 of @xmath18 compatible with  @xmath59 .",
    "then , the blocks of @xmath59 are intervals of the order @xmath341 and thus one can check whether a given set @xmath342 is contained in a block @xmath99 of @xmath59 in @xmath343 operations ( simply by comparing each element of @xmath344 to the end points of the interval @xmath99 ) . furthermore , the size of any block of @xmath59 is simply given by the difference between its extremities ( plus one ) .    [",
    "thm : co - lex - bfs_complexity ] algorithm [ alg : lex - bfsweak ] runs in @xmath42 time .",
    "it is well known that lex - bfs can be implemented in linear time @xmath42 . in our implementation of algorithm",
    "[ alg : lex - bfsweak ] we will follow the linear time implementation of corneil @xcite , which uses the data structure based on the paradigm of  partitioning \" presented in @xcite . recall that the blocks of @xmath59 are intervals in @xmath341 , which is a linear order compatible with  @xmath59 . in order to carry out the other operations about the components of @xmath15 we maintain a doubly linked list , where each node of the list represents a connected component @xmath182 of @xmath15 and it has a pointer to the connected component @xmath195 ordered immediately before @xmath183 and to the connected component @xmath345 ordered immediately after  @xmath183 . then , swapping two connected components can be done simply by swapping the left and right pointers of the corresponding connected components in the doubly linked list .",
    "furthermore , each node in this list contains the set of vertices in @xmath182 , the first block @xmath346 and the last block @xmath347 in @xmath59 meeting @xmath182 .",
    "these two blocks @xmath189 and @xmath190 can be found in time @xmath348 as follows .",
    "first one finds the smallest element @xmath349 ( resp .",
    "the largest element @xmath350 ) of @xmath183 in the order @xmath341 , which can be done in @xmath348 .",
    "then , @xmath189 is the block of @xmath59 containing @xmath349 , which can be found in @xmath348 .",
    "analogously for @xmath190 , which is the block of @xmath59 containing @xmath350 .",
    "checking whether @xmath183 is contained in the block @xmath218 can be done in @xmath348 ( since @xmath218 is an interval ) . in order to check whether all the inner blocks between @xmath189 and @xmath190 are contained in @xmath183 we proceed as follows .",
    "let @xmath351 be the union of these inner blocks , which is an interval of @xmath341 .",
    "first we compute the sets @xmath352 and @xmath353 , which can be done in @xmath348 .",
    "then we need to check whether @xmath354 or , equivalently , whether the two sets @xmath355 and @xmath351 are equal . for this",
    "we check first whether @xmath355 is contained in @xmath351 ( in time @xmath348 ) and then whether these two sets have the same cardinality , which can be done in @xmath348 .",
    "hence , the complexity of this task is @xmath356 .",
    "therefore we can conclude that the overall complexity of algorithm [ alg : lex - bfsweak ] is @xmath42 .",
    "[ thm : refine_complexity ] algorithm [ alg : refine ] runs in @xmath357 time .",
    "we show the lemma using induction on the number @xmath266 of blocks of @xmath108 .",
    "recall that the blocks of @xmath59 are intervals in  @xmath341 , which is a linear order compatible with @xmath59 .",
    "if @xmath267 the result is clear since the algorithm returns @xmath358 without any work .",
    "assume @xmath270 .",
    "the first task is to compute the last block @xmath262 of @xmath59 meeting @xmath263 . for this , as in the proof of the previous lemma , one finds the largest element @xmath350 of @xmath263 in the order @xmath341 and one returns the block of @xmath59 containing @xmath350 , which can be done in @xmath359 .",
    "then let @xmath99 be the union of the blocks preceding @xmath262 .",
    "in order to check whether @xmath360 or , equivalently , whether @xmath361 , we proceed as in the previous lemma : we first check whether @xmath362 and then whether @xmath363 , which can be done in @xmath359 . hence , the running time is @xmath359 for this task which , together with the running time @xmath364 for the recursive application of _ refine _ to the restrictions of @xmath59 and @xmath108 to the set @xmath365 , gives an overall running time @xmath357 .",
    "we can now complete the complexity analysis of our algorithm .",
    "[ thm : robinsonian_recognition_complexity ] let @xmath4 be a nonnegative @xmath0 symmetric matrix given as a weighted adjacency list and let @xmath1 be the number of ( upper diagonal ) nonzero entries of @xmath4 .",
    "algorithm  [ alg : robinsonian_main ] recognizes whether @xmath4 is a robinsonian matrix in time @xmath2 , where @xmath3 is the depth of the recursion tree created by algorithm [ alg : robinsonian_main ] .",
    "moreover , @xmath366 , where @xmath44 is the number of distinct nonzero entries of @xmath4 .",
    "we show the result using induction on the depth @xmath3 of the recursion tree . in algorithm",
    "[ alg : robinsonian_main ] we are given a matrix @xmath4 and its support graph @xmath15 , and we set @xmath367)$ ] .",
    "first we run the routine _ _ co - lex - bfs__@xmath247 in @xmath368 time , in order to find and order the components of @xmath15 . for each component @xmath183 ,",
    "the following tasks are performed .",
    "we compute a straight enumeration @xmath305 of @xmath244 $ ] , in time @xmath369 where @xmath370 and @xmath371 is the number of edges of @xmath244 $ ] . the reversal @xmath306 can be computed in @xmath372 by simply reversing the ordered partition @xmath302 , which is stored in a double linked list .",
    "hence , we apply the routine _ refine _ to  @xmath221 $ ] and  @xmath305 ( or @xmath373 ) , which can be done in @xmath374 time .",
    "then we build the new matrix @xmath324 $ ] and checks whether it is diagonal , in time @xmath375 .",
    "finally , by the induction assumption , the recursion step _ _ robinson__@xmath376,\\phi_\\omega)$ ] is carried out in time @xmath377 , where @xmath378 denotes the depth of the corresponding recursion tree .",
    "as @xmath379 for each @xmath380 , after summing up , we find that the overall complexity is @xmath2 .",
    "the last claim : @xmath366 is clear since the number of distinct nonzero entries of the current matrix decreases by at least 1 at each recursion node .      in general , there might exist several permutations reordering a given matrix @xmath4 as a robinson matrix .",
    "we show here how to return all robinson orderings of a given matrix @xmath4 , using the pq - tree data structure of @xcite .",
    "a pq - tree @xmath381 is a special rooted ordered tree .",
    "the leaves are in one - to - one correspondence with the elements of the groundset @xmath18 and their order gives a linear order of @xmath18 .",
    "the nodes of @xmath382 can be of two types , depending on how their children can be ordered .",
    "namely , for a _",
    "p - node _ ( represented by a circle ) , its children may be arbitrary reordered ; for a _ q - node _ ( represented by a rectangle ) , only the order of its children may be reversed .",
    "moreover , every node has at least two children .",
    "given a node @xmath22 of @xmath382 , @xmath383 denotes the subtree of @xmath382 with root @xmath22 .",
    "a straight enumeration @xmath384 of a graph @xmath14 corresponds in a unique way to a pq - tree @xmath381 as follows .",
    "if @xmath15 is connected , then the root of @xmath382 is a q - node , denoted @xmath385 , and it has children @xmath386 ( in that order ) . for @xmath387 $ ] ,",
    "the node @xmath388 is a p - node corresponding to the block @xmath62 and its children are the elements of the set @xmath62 , which are the leaves of the subtree @xmath389 .",
    "if a block @xmath62 is a singleton then no node @xmath388 appears and the element of @xmath62 is directly a child of the root @xmath385 ( see the example in figure [ fig : example pq - tree contig ] ) .",
    "@xmath390     and the pq - tree corresponding to its straight enumeration ]    if @xmath15 is not connected , let @xmath391 be its connected components . for each connected component",
    "@xmath320 $ ] , @xmath392 is its pq - tree ( with root @xmath393 ) as indicated above .",
    "then , the full pq - tree @xmath381 is obtained by inserting a p - node @xmath22 as ancestor , whose children are the subtrees @xmath394 ( see figure [ fig : example pq - tree disconnected ] ) .",
    "we now indicate how to modify algorithms [ alg : robinsonian recognition ] and [ alg : robinsonian_main ] in order to return a pq - tree @xmath382 encoding all the permutations ordering @xmath4 as a robinson matrix .",
    "we modify algorithm [ alg : robinsonian recognition ] by taking as input , beside the matrix @xmath4 and the weak linear order @xmath59 , also a node @xmath22 .",
    "then , the output is a pq - tree @xmath383 rooted in @xmath22 , representing all the possible weak linear orders @xmath265 compatible with @xmath59 and with straight enumerations of all the level graphs of @xmath4 .",
    "it works as follows .",
    "let @xmath15 be the support of @xmath4 .",
    "the idea is to recursively build a tree @xmath392 for each connected component @xmath183 of @xmath15 and then to merge these trees according to the order of the components found by the routine _ co - lex - bfs_(@xmath395 ) . to carry out this merging step we classify the components into the following three groups :    1 .",
    "@xmath396 , which consists of all @xmath203 $ ] for which the connected component @xmath183 meets at least two blocks of @xmath59 .",
    "2 .   @xmath397 , which consists of all @xmath203 $ ] for which the component @xmath183 is contained in some block @xmath62 , which contains no other component .",
    "@xmath398 , where @xmath399 consists of all @xmath203 $ ] for which the component @xmath183 is contained in the block @xmath62 , which contains at least two components .    every time we analyze a new connected component @xmath400 $ ] in algorithm [ alg : robinsonian recognition ]",
    ", we create a q - node @xmath401 . after the common refinement @xmath303 ( of @xmath221",
    "$ ] and the straight enumeration @xmath305 of @xmath244 $ ] or its reversal ) has been computed , we have two possibilities . if @xmath324 $ ] is diagonal",
    ", then we build the tree @xmath402 rooted in @xmath401 and whose children are p - nodes corresponding to the blocks of @xmath303 ( and prune the recursion tree at this node ) .",
    "otherwise , we build the tree @xmath402 recursively as output of _",
    "_ robinson__@xmath376,\\phi_\\omega,\\gamma_\\omega)$ ] .",
    "+ after all the connected components have been analyzed , we insert the trees @xmath392 in the final tree @xmath403 in the order they appear according to the routine _ co - lex - bfs_(@xmath395 ) .",
    "the root node is @xmath22 and is given as input . for each component @xmath183 , we do the following operation to insert @xmath392 in @xmath383 , depending on the type of the component",
    "@xmath183 :    1 .",
    "if @xmath404 , then @xmath305 ( or @xmath306 ) is the only straight enumeration compatible with @xmath221 $ ] .",
    "then we delete the node @xmath393 and the children of @xmath393 become children of @xmath22 ( in the same order ) .",
    "2 .   if @xmath405 , then both @xmath305 and its reversal @xmath373 are compatible with @xmath304 $ ] . then @xmath393 becomes a child of @xmath22 .",
    "if @xmath406 for some @xmath387 $ ] , then both @xmath305 and @xmath373 are compatible with @xmath221 $ ] and the same holds for any @xmath407 .",
    "moreover , arbitrary permuting any two connected components @xmath408 with @xmath409 will lead to a compatible straight enumeration .",
    "then we insert a new node @xmath388 which is a p - node and becomes a child of @xmath22 and , for each @xmath407 , @xmath410 becomes a child of @xmath388 .    finally , we modify algorithm [ alg : robinsonian_main ] by just giving the node @xmath411 ( i.e. undefined ) as input to the first recursive call .",
    "the overall complexity of the algorithm after the above mentioned modifications is the same as for algorithm [ alg : robinsonian_main ] . indeed , determining the type of the connected components can be done in linear time , by just using the information about the initial and final blocks @xmath346 and @xmath347 already provided in algorithm [ alg : lex - bfsweak ] .",
    "furthermore , the operations on the pq - tree are basic operations that do not increase the overall complexity of the algorithm .",
    "@xmath314 + @xmath412 + @xmath15 is the support of a + @xmath381=_robinson_(@xmath413 ) +",
    "we introduced a new combinatorial algorithm to recognize robinsonian matrices , based on a divide - and - conquer strategy and on a new characterization of robinsonian matrices in terms of straight enumerations of unit interval graphs .",
    "the algorithm is simple , rather intuitive and relies only on basic routines like lex - bfs and partition refinement , and it is well suited for sparse matrices .",
    "the complexity depends on the depth @xmath3 of the recursion tree .",
    "an obvious bound on @xmath3 is the number @xmath44 of distinct entries in the matrix .",
    "a first natural question is to find other better bounds on the depth @xmath3 .",
    "is @xmath3 in the order @xmath414 , where @xmath8 is the size of the matrix ?",
    "the answer is no : some computational experiments carried out in @xcite show that , for some instances , the depth of the recursion tree is @xmath415 .",
    "this suggests that more sophisticated modifications might be needed to improve the complexity of the algorithm .",
    "a possible way to bound the depth is to find criteria to prune recursion nodes .",
    "one possibility would be , when a submatrix is found for which the current weak linear order consists only of singletons , to check whether the corresponding permuted matrix is robinson .",
    "another possible way to improve the complexity might be to compute the straight enumeration of the first level graph and then update it dynamically ( in constant time , using a appropriate data structure ) without having to compute every time the whole straight enumeration of the next level graphs ; this would need to extend the dynamic approach of @xcite , which considers the case of single edge deletions , to the deletion of sets of edges .",
    "other possible future work includes investigating how the algorithm could be used to design heuristics or approximation algorithm in the noisy case , when @xmath4 is not robinsonian , for example by using ( linear ) certifying algorithms as in @xcite to detect the edges and the nodes of the level graphs which create obstructions to being a unit interval graph .",
    "this work was supported by the marie curie initial training network",
    " mixed integer nonlinear optimization \" ( mino ) grant no .",
    "316647 .    10 j.e .",
    "atkins , e.g. boman , and b.  hendrickson . a spectral algorithm for seriation and the consecutive ones problem .",
    ", 28:297310 , 1998 .",
    "bodlaender , t.  kloks , and r.  niedermeier . for unit interval graphs and graphs with few @xmath416s .",
    ", 3:1926 , 1999 .",
    "k.s . booth and g.s .",
    "testing for the consecutive ones property , interval graphs , and graph planarity using pq - tree algorithms .",
    ", 13(3):335379 , 1976 .",
    "a.  brandstdt , f.f .",
    "dragan , and f.  nicolai .",
    "lexbfs - orderings and powers of chordal graphs . , 171(13):2742 , 1997 .",
    "v.  chepoi and b.  fichet .",
    "recognition of robinsonian dissimilarities .",
    ", 14(2):311325 , 1997 .",
    "v.  chepoi and m.  seston .",
    "seriation in the presence of errors : a factor 16 approximation algorithm for @xmath417-fitting robinson structures to distances . , 59(4):521568 , 2011 .",
    "j.  cohen , f.  fomin , p.  heggernes , d.  kratsch , and g.  kucherov . optimal linear arrangement of interval graphs . in _ mathematical foundations of computer science 2006 _ , volume 4162 of _ lecture notes in computer science _ , pages 267279 .",
    "springer berlin heidelberg , 2006 .",
    "corneil . a simple 3-sweep lbfs algorithm for the recognition of unit interval graphs .",
    ", 138(3):371379 , 2004 .",
    "corneil , h.  kim , s.  natarajan , s.  olariu , and a.p .",
    "simple linear time recognition of unit interval graphs .",
    ", 55(2):99104 , 1995 .",
    "corneil , s.  olariu , and l.  stewart . the ultimate interval graph recognition algorithm ? in _ proceedings of the 9th annual acm - siam symposium on discrete algorithms",
    "_ , soda 98 , pages 175180 .",
    "siam , 1998 .",
    "p.  crescenzi , d.g .",
    "corneil , j.  dusart , and m.  habib .",
    "new trends for graph search .",
    "prima conference in shanghai , june 2013 .",
    "available at http://math.sjtu.edu.cn/conference/bannai/2013/data/20130629b/slides1.pdf .",
    "c.m.h de  figueiredo , j.meidanis , and c.p de  mello . a linear - time algorithm for proper interval graph recognition .",
    ", 56(3):179184 , 1995 .",
    "x.  deng , p.  hell , and j.  huang .",
    "linear - time representation algorithms for proper circular - arc graphs and proper interval graphs .",
    ", 25(2):390403 , 1996 .",
    "algorithmic aspects of the consecutive - ones property .",
    ", 98:2759 , 2009 .",
    "f.  fogel , r.  jenatton , f.  bach , and a.  daspremont .",
    "convex relaxations for permutation problems . in _ advances in neural information processing systems _ , pages 10161024 , 2013 .",
    "fulkerson and o.a .",
    "incidence matrices and interval graphs . , 15(3):835855 , 1965 .",
    "gilmore and a.j .",
    "a characterization of comparability graphs and of interval graphs .",
    ", 16:539548 , 1964 .",
    "golumbic . .",
    "north - holland publishing co. , amsterdam , the netherlands , 2004 .",
    "m.  habib , r.  mcconnell , c.  paul , and l.  viennot . and partition refinement , with applications to transitive orientation , interval graph recognition and consecutive ones testing .",
    ", 234(12):5984 , 2000 .    p.  hell and j.  huang .",
    "certifying lexbfs recognition algorithms for proper interval graphs and proper interval bigraphs .",
    ", 18(3):554570 , 2005 .",
    "p.  hell , r.  shamir , and r.  sharan . a fully dynamic algorithm for recognizing and representing proper interval graphs .",
    ", 31(1):289305 , 2002 .",
    "j.bang-jensen , j.  huang , and l.  ibarra . recognizing and representing proper interval graphs in parallel using merging and sorting . , 155(4):442456 , 2007 .",
    "m.  laurent and m.  seminaroti .",
    "a lex - bfs - based recognition algorithm for robinsonian matrices . in _ algorithms and complexity : proceedings of the 9th international conference ciac 2015 _ , volume 9079 of _",
    "lecture notes in computer science _ , pages 325338 .",
    "springer - verlag , 2015 .",
    "m.  laurent and m.  seminaroti .",
    "the quadratic assignment problem is easy for robinsonian matrices with toeplitz structure .",
    ", 43(1):103109 , 2015 .",
    "i.  liiv .",
    "seriation and matrix reordering methods : an historical overview .",
    ", 3(2):7091 , 2010 .",
    "looges and s.  olariu .",
    "optimal greedy algorithms for indifference graphs .",
    ", 25(7):1525 , 1993 .",
    "r.  mahesh , c.p .",
    "rangan , and a.  srinivasan .",
    "on finding the minimum bandwidth of interval graphs . , 95(2):218224 , 1991 .",
    "mirkin and s.n . rodin . .",
    "biomathematics ( springer - verlag ) .",
    "springer , 1984 .",
    "s.  olariu .",
    "an optimal greedy heuristic to color interval graphs . , 37(1):2125 , 1991 .",
    "p.  pra and d.  fortin .",
    "an optimal algorithm to recognize robinsonian dissimilarities . , 31:135 , 2014 .",
    "indifference graphs .",
    "pages 139146 . academic press , 1969 .    f.s . roberts . on the compatibility between a graph and a simple order .",
    ", 11(1):2838 , 1971 .",
    "f.s . roberts . .",
    "society for industrial and applied mathematics , 1978 .",
    "robinson . a method for chronologically ordering archaeological deposits .",
    ", 16(4):293301 , 1951 .",
    "d.j rose and r.e .",
    "algorithmic aspects of vertex elimination . in _ proceedings of 7th annual acm symposium on theory of computing _ , stoc 75 , pages 245254 .",
    "acm , 1975 .",
    "m.  seminaroti . .",
    "phd thesis , tilburg university , 2016 .",
    "m.  seston . .",
    "phd thesis , universit de la mditerrane , 2008 .",
    "k.  simon . a new simple linear algorithm to recognize interval graphs . in h.",
    "bieri and h.  noltemeier , editors , _ computational geometry - methods , algorithms and applications _ , volume 553 of _ lecture notes in computer science _ , pages 289308 .",
    "springer berlin heidelberg , 1991 .",
    "we give a complete example of the algorithm .",
    "we consider the same matrix @xmath4 as the one used in the example in section 5 of @xcite . however , since @xcite handles robinsonian dissimilarities , we first transform it into a similarity matrix and thus we use instead the matrix @xmath418 , where @xmath419 denotes the largest entry in the matrix @xmath4 .",
    "if we rename such a new matrix as @xmath4 , it looks as follows :    @xmath420 here the red labels denote the original numbering of the elements . throughout we will use the fact that adding any multiple of the all - ones matrix @xmath145 to the matrix @xmath4 does not change the robinson(ian ) property .",
    "the recursion tree computed by algorithm [ alg : robinsonian_main ] is shown in figure [ fig : recursion tree ] at page .",
    "the weak linear order at each node represents the weak linear order @xmath59 given as input to the recursion node , while the number on the edge between two nodes denotes the minimum value in the current matrix @xmath4 , which is set to zero before making a new recursion call ( in this way , the reader may reconstruct the input given at each recursion node ) .",
    "* root node * + we set @xmath421 and invoke algorithm [ alg : robinsonian recognition ] .",
    "then , algorithm [ alg : lex - bfsweak ] would find two connected components : @xmath422 hence , we can split the problem into two subproblems , where we deal with each connected component independently . *",
    "1.0 connected component @xmath80 , level 0 * + the submatrix @xmath423 $ ] induced by @xmath80 is shown below ( after shifting the matrix by @xmath424 , i.e. , substracting @xmath425 from it ) .",
    "@xmath426= \\bordermatrix { ~ & \\textcolor{red}{1 } & \\textcolor{red}{2 } & \\textcolor{red}{3 } & \\textcolor{red}{5 } & \\textcolor{red}{7 } & \\textcolor{red}{8 } & \\textcolor{red}{9 } & \\textcolor{red}{11 } & \\textcolor{red}{13 } & \\textcolor{red}{14 } & \\textcolor{red}{17 } & \\textcolor{red}{19}\\cr \\textcolor{red}{1 }   & 9 & 0 & 7 & 3 & 3 & 3 & 0 & 3 & 3 & 4 & 0 & 3 \\cr \\textcolor{red}{2 }   & & 9 & 0 & 7 & 6 & 3 & 8 & 3 & 3 & 0 & 8 & 6 \\cr \\textcolor{red}{3 }   & & & 9 & 3 & 3 & 3 & 0 & 3 & 3 & 8 & 0 & 3 \\cr \\textcolor{red}{5 }   & & & & 9 & 6 & 5 & 7 & 5 & 5 & 3 & 7 & 8 \\cr \\textcolor{red}{7 }   & & & & & 9 & 5 & 6 & 5 & 5 & 3 & 6 & 7 \\cr \\textcolor{red}{8 }   & & & & & & 9 & 4 & 8 & 6 & 5 & 4 & 5 \\cr \\textcolor{red}{9 }   & & & & & & & 9 & 4 & 3 & 0 & 8 & 6 \\cr \\textcolor{red}{11 } & & & & & & & & 9 & 7 & 5 & 4 & 5 \\cr \\textcolor{red}{13 } & & & & & & & & & 9 & 5 & 3 & 5 \\cr \\textcolor{red}{14 } & & & & & & & & & & 9 & 0 & 3 \\cr \\textcolor{red}{17 } & & & & & & & & & & & 9 & 6 \\cr \\textcolor{red}{19 } & & & & & & & & & & & & 9 \\cr } \\ ] ]    if we invoke algorithm [ alg : straght_enumeration ] on the support @xmath427 $ ] , we get the following straight enumeration : @xmath428 note that since @xmath429 $ ] has only one block , we do not need to compute the partition refinement in algorithm [ alg : refine ] and then the common refinement is simply @xmath358 .",
    "the smallest nonzero value of the matrix in ( [ eq : a_1 ] ) is @xmath430 .",
    "hence , we compute @xmath431 $ ] by setting to zero the entries of the matrix in ( [ eq : a_1 ] ) with value equal to @xmath432 . since @xmath431 $ ] is not diagonal , we make a recursion call , and we set @xmath433 .",
    "to simplify notation , we shall rename @xmath431 $ ] as @xmath423 $ ] after every iteration .",
    "* 1.1 connected component @xmath80 , level 1 * + the input matrix @xmath423 $ ] is obtained by setting to zero the entries of the matrix in ( [ eq : a_1 ] ) with value at most 3 .",
    "the support of this matrix is still connected , and its straight enumeration is : @xmath434 if we invoke algorithm [ alg : refine ] , it is easy to see that the common refinement @xmath265 of @xmath59 and @xmath108 is exactly @xmath108 .",
    "the smallest nonzero value of @xmath423 $ ] is now @xmath435 .",
    "hence , we compute @xmath431 $ ] , which is not diagonal and thus we make a recursion call , setting @xmath433 and renaming @xmath431 $ ] as @xmath423 $ ] .    * 1.2 connected component @xmath80 , level 2 * + the input matrix @xmath423 $ ] is obtained by setting to zero the entries of the matrix in ( [ eq : a_1 ] ) with value at most 4 .",
    "the support of this matrix is still connected , and its straight enumeration is : @xmath436 the common refinement with @xmath59 is then given by : @xmath437 the smallest nonzero value of @xmath423 $ ] is now @xmath438 .",
    "hence , we compute @xmath431 $ ] , which is not diagonal and thus we make a recursion call , setting @xmath433 and renaming @xmath431 $ ] as @xmath423 $ ] .    *",
    "1.3 connected component @xmath80 , level 3 * + the input matrix @xmath423 $ ] is obtained by setting to zero the entries of the matrix in ( [ eq : a_1 ] ) with value at most 5 .",
    "the support of this matrix is not connected , and thus algorithm [ alg : lex - bfsweak ] will detect the following connected components : @xmath439 we analyze each connected component independently .",
    "* 1.3.1 connected component @xmath440 , level 4 * + the common refinement is @xmath441 and @xmath442 .",
    "we make a recursion call , finding two connected components @xmath443 and @xmath444 , and then we stop , because the first one has only one vertex , while the submatrix corresponding to the second one is diagonal ( after shifting ) .",
    "* 1.3.2 connected component @xmath445 , level 4 * + since @xmath446 , we first  shift \" the input submatrix . then , the common refinement is @xmath447 and @xmath442 ( i.e. = 1 after shifting ) .",
    "we make a recursion call , finding two connected components @xmath448 and @xmath449 , and then we stop , because the first one has only one vertex , while the submatrix corresponding to the second one is diagonal ( after shifting ) .",
    "* 1.3.3 connected component @xmath450 , level 4 * + since @xmath446 , we first  shift \" the input submatrix . then , the common refinement is @xmath451 and @xmath442 ( i.e. = 1 after shifting ) .",
    "we update @xmath431 $ ] , and we make a recursive call because it is not diagonal .",
    "the new input matrix is then given by the submatrix in ( [ eq : a_1 ] ) restricted to @xmath450 by setting to zero the entries with value at most 7 .",
    "the support of this matrix is not connected , and thus algorithm [ alg : lex - bfsweak ] will detect the following connected components : @xmath452 we then split the problem over the connected components .",
    "the first one has only one vertex while the second and the third one are diagonal ( after shifting ) .",
    "this was the last recursion node open .",
    "therefore , we get that the final common refinement of the level graphs of the matrix in ( [ eq : a_1 ] ) is : @xmath453 and the pq - tree @xmath454 computed by the algorithm is reported in figure [ fig : pq_example_1_7 ] at page  .",
    "@xmath457= \\bordermatrix { ~ & \\textcolor{red}{4 } & \\textcolor{red}{6 } & \\textcolor{red}{10 } & \\textcolor{red}{12 } & \\textcolor{red}{15 } & \\textcolor{red}{16 } & \\textcolor{red}{18 } \\cr \\textcolor{red}{4 }   & 8 & 0 & 0 & 0 & 7 & 0 & 6 \\cr \\textcolor{red}{6 }   & & 8 & 7 & 3 & 2 & 5 & 2 \\cr \\textcolor{red}{10 }   & & & 8 & 3 & 1 & 6 & 2 \\cr \\textcolor{red}{12 }   & & & & 8 & 6 & 3 & 7 \\cr \\textcolor{red}{15 }   & & & & & 8 & 1 & 7 \\cr \\textcolor{red}{16 }   & & & & & & 8 & 1 \\cr \\textcolor{red}{18 }   & & & & & & & 8 \\cr } \\ ] ]    if we invoke algorithm [ alg : straght_enumeration ] on the support @xmath458 $ ] , we get the following straight enumeration : @xmath459 note that since @xmath460 $ ] has only one block , we do not have to compute the partition refinement in algorithm [ alg : refine ] , and then the common refinement is simply @xmath358 .",
    "the smallest nonzero value of the matrix in ( [ eq : a_2 ] ) is @xmath461 .",
    "hence , we compute @xmath462 $ ] by setting to zero the entries of the matrix in ( [ eq : a_2 ] ) with value equal to @xmath432 . since @xmath462 $ ] is not diagonal , we make a recursion call , and we set @xmath433 . to simplify notation , we shall again rename @xmath462 $ ] as @xmath455 $ ] after every iteration .    *",
    "2.1 connected component @xmath81 , level 1 * + the input matrix @xmath455 $ ] is obtained by setting to zero the entries of the matrix in ( [ eq : a_2 ] ) with value at most 1 . the support of this matrix is still connected , and its straight enumeration is : @xmath463 if we invoke algorithm [ alg : refine ] , it is easy to see that the common refinement is @xmath464 the smallest nonzero value of @xmath455 $ ] is now @xmath465 .",
    "hence , we compute @xmath462 $ ] , which is not diagonal and thus we make a recursion call , setting @xmath433 and renaming @xmath462 $ ] as @xmath455 $ ] for the next iteration .",
    "* 2.2 connected component @xmath81 , level 2 * + the input matrix @xmath455 $ ] is obtained by setting to zero the entries of the matrix in ( [ eq : a_2 ] ) with value at most 2 .",
    "the support of this matrix is still connected , and its straight enumeration is : @xmath466 the common refinement is then simply : @xmath467 the smallest nonzero value of @xmath455 $ ] is now @xmath430 .",
    "hence , we compute @xmath462 $ ] , which is not diagonal and thus we make a recursion call , setting @xmath433 and renaming @xmath462 $ ] as @xmath455 $ ] for the next iteration .    *",
    "2.3 connected component @xmath81 , level 3 * + the input matrix @xmath455 $ ] is obtained by setting to zero the entries of the matrix in ( [ eq : a_2 ] ) with value at most 3 .",
    "the support of this matrix is still connected , and its straight enumeration is : @xmath468 which is equal to the given @xmath59 ( and thus will be the common refinement @xmath265 ) .",
    "the smallest nonzero value of @xmath455 $ ] is now @xmath438 .",
    "hence , we compute @xmath462 $ ] , which is not diagonal and thus we make a recursion call , setting @xmath433 and renaming @xmath462 $ ] as @xmath455 $ ] for the next iteration .    * 2.4 connected component @xmath81 , level 4 * + the input matrix @xmath455 $ ] is obtained by setting to zero the entries of the matrix in ( [ eq : a_2 ] ) with value at most 5 .",
    "the support of this matrix is not connected , and thus algorithm [ alg : lex - bfsweak ] will detect two connected components .",
    "@xmath469 we then split the problem over the connected components .",
    "* 2.4.1 connected component @xmath470 , level 5 * + the common refinement is @xmath471 and @xmath472 .",
    "we then make a recursion call and we find again a connected graph . again",
    "the common refinement does not change ( in fact the blocks are singletons ) and now @xmath442 .",
    "finally , the submatrix @xmath473 $ ] is diagonal , so we prune the node .",
    "* 2.4.2 connected component @xmath474 , level 5 * + the common refinement is @xmath475 ( again the blocks are singletons ) and @xmath472 .",
    "but now @xmath476 $ ] is diagonal , so we prune the node .",
    "this was the last recursion node open .",
    "finally , we can build the pq - tree representing the permutation reordering @xmath4 as a robinson matrix . since both @xmath80 and @xmath81 are contained in the same block of @xmath59 ( which at the beginning is @xmath479)$ ] ) , then we create a p - node ( named @xmath22 since it is the ancestor ) whose children are the subtrees @xmath454 and @xmath478 .",
    "the final pq - tree is shown in figure [ fig : pq_example_3_final ] at page , and is equivalent to the one returned by @xcite .",
    "note that , using the fact that a common refinement which is a linear order can not be refined anymore , the depth could be lowered to @xmath480 ( since the right branch would have depth @xmath481 ) . understanding this and other possible speed up will be the subject of future work ."
  ],
  "abstract_text": [
    "<S> robinsonian matrices arise in the classical seriation problem and play an important role in many applications where unsorted similarity ( or dissimilarity ) information must be reordered . </S>",
    "<S> we present a new polynomial time algorithm to recognize robinsonian matrices based on a new characterization of robinsonian matrices in terms of straight enumerations of unit interval graphs . </S>",
    "<S> the algorithm is simple and is based essentially on lexicographic breadth - first search ( lex - bfs ) , using a divide - and - conquer strategy . when applied to a nonnegative symmetric @xmath0 matrix with  @xmath1 nonzero entries and given as a weighted adjacency list , it runs in @xmath2 time , where @xmath3 is the depth of the recursion tree , which is at most the number of distinct nonzero entries of @xmath4 . + </S>",
    "<S> * keywords : * _ robinson ( dis)similarity ; unit interval graph ; lex - bfs ; seriation ; partition refinement ; straight enumeration _ </S>"
  ]
}