{
  "article_text": [
    "in primary schools pupils are taught how to multiply two integers .",
    "this algorithm has been implemented in the multiplication of multi - precision integers ( or called long integers ) , known as the schoolbook algorithm .",
    "it requires @xmath3 time and @xmath4 space . here",
    "@xmath5 is the length , i.e. , the number of limbs in the representation of the two equal - length integers for multiplication .",
    "karatsuba and ofman in @xcite noticed that using a divide - and - conquer technique , an @xmath0 sub - quadratic time complexity can be achieved , with the price being an additional @xmath1 memory space . aiming to remove the need of extra space , roche proposed in @xcite a space - efficient variant of the karatsuba algorithm .",
    "however , the description of the algorithm was mainly addressed to the multiplication of polynomials .",
    "the implementation of space - efficient karatsuba in multi - precision integers is not straightforward , as there are carries when adding or subtracting integers , even when we use a subtractive version of karatsuba .",
    "tricky issues resulting from the presence of carries need to be resolved .    this paper will give a detailed implementation of space - efficient karatsuba for multiplication of multi - precision integers .",
    "we follow the basic scheme of @xcite , but a few changes have been made , as listed below :    * a subtractive version is adopted instead of the additive version . *",
    "four separate variables for storing the carries are introduced , because the results of additions and subtractions may fall beyond the original representation . * for even length square multiplication , three cases are identified and are processed for obtaining correct results in all possible cases . this subdivision is not needed in polynomial multiplication but is unavoidable in long integer multiplication . * a different treatment for odd length is used , which is chosen for more efficient carry processing .",
    "the rest of the paper is organized as follows .",
    "section 2 gives the mathematical foundation for the space - efficient karatsuba for long integers .",
    "section 3 describes our c implementation of this algorithm .",
    "section 4 provides numerical results for performance comparison .",
    "we conclude the paper with section 5 .",
    "long integers are represented by _",
    "limbs_. let @xmath6 be the radix .",
    "then any integer @xmath7 can be represented uniquely with @xmath5 ordered limbs , each limb @xmath8 being an integer within @xmath9 .",
    "that is ,    @xmath10    for intermediate values in the algorithm , it is sometimes useful to store it with a carry .",
    "if @xmath11 falls ( not very far ) beyond the range @xmath12 , then we can represent it with @xmath5 limbs and a carry @xmath13 , which can be positive , zero , or negative .",
    "that is    @xmath14    in computers we can use an int variable to store the carry , and as the range of a 32-bit int variable is @xmath15 , it will be more than sufficient for our purposes here .      as in @xcite , we consider the following problem , which we call _ equal length additive multiplication problem _ here . given four multi - precision integers @xmath16 , to compute @xmath17 in this subsection we deal with the case when @xmath5 is even , i.e. , @xmath18 .",
    "let @xmath19 where @xmath20 .",
    "we then have @xmath21@xmath22\\rho^{k } + ( a^{(0)}_1-a^{(1)}_1)b_1.\\ ] ]    now define the following intermediate multi - precision integers : @xmath23    it is easy to see that @xmath24    for @xmath25 we divide three cases :      this case can be decided when the internal @xmath27 limbs and one carry representation of @xmath25 has a carry @xmath28 or @xmath29 , but @xmath30 .",
    "how do we know whether @xmath31 ?",
    "we note that @xmath31 if and only if it has carry @xmath29 and all @xmath28 limbs .    in this case , if @xmath32 , we can use the original equation ( 12 ) to compute @xmath33 , otherwise , use the mathematically equivalent equation @xmath34    by ( 8) , we have @xmath35    now suppose @xmath36 where @xmath37 .",
    "then @xmath38    the above four subsequences of limbs can be computed using a procedure very similar to ( * ? ? ?",
    "* section 2.2 ) , except that    * as here we use a subtractive version , we need to be careful about the signs . * four int variables",
    "@xmath39 are introduced , to store the carries resulting from addition and subtraction .",
    "the computation steps should be clear from table 1 .",
    "note that recursive calls take place in steps 3,5,8 .",
    ".snapshot of @xmath40 and the @xmath13 s through the steps for case 1 [ cols=\"^,^,^,^,^\",options=\"header \" , ]      in this case , we compute @xmath42    then @xmath43 @xmath44    the corresponding equation and table are similar to case 2 , with @xmath25 replaced with @xmath45 and @xmath46 replaced with @xmath47 .",
    "so they will not be reproduced here .",
    "it should be noted that when the steps in tables 1 and 2 are completed , @xmath48 is automatically ensured , and then we have @xmath49    we then need to do a final step of carry processing , so that finally @xmath50 , and    @xmath51      now consider the same problem as given in the previous subsection , but now with @xmath5 odd , i.e. @xmath52 .",
    "there are a number of possible expansions that can reduce this case to the even case .",
    "but we found the following expansion most convenient :    let @xmath53 where @xmath54 and @xmath55 .",
    "we have @xmath56 @xmath57    we then have @xmath58 + \\rho^{4k+1}c\\ ] ] @xmath59    on the right - hand side of ( 30 ) , the first term has already been computed using the algorithm of the previous section , and the second term is already present in the buffer to store the product , and only the latter two terms need to be computed and added to the product now .",
    "the advantage of this expansion is that the two remaining terms involve nonintersecting subsequences of the entire limbs sequence of the product , and therefore the carries can thus be processed most efficiently .",
    "we now come back to our original problem : suppose @xmath11 is a long integer of length @xmath5 , and @xmath60 is a long integer of length @xmath61 .",
    "we are to compute @xmath62    let @xmath63 , and suppose @xmath64    then we let @xmath65 where @xmath66 , and @xmath67 .",
    "this general length multiplication is done by a recursive routine . if @xmath68 , then no recursive call of itself is needed , but we need to fill the first @xmath61 limbs of the product buffer to zero .",
    "otherwise , the routine first calls itself to compute @xmath69 , which is stored in the leading @xmath70 limbs of the product buffer .",
    "let    @xmath71 where @xmath72 , and @xmath73 .",
    "then , we call the equal length additive routine to compute    @xmath74 and process the carry , so that @xmath75 is computed and stored in the buffer .",
    "go on with these steps repeatedly until the entire @xmath76 is computed .",
    "this requires @xmath77 calls of the equal length additive routine , and no heap memory allocation is needed here .",
    "the algorithm mathematically described above has been implemented in c. the implementation consists of two groups of functions : the primitive group , and the upper level group .",
    "the primitive group of functions include the following functions :    int mpiadd(uint @xmath6 , limb * a , const limb * b , int n ) ;    int mpisub(uint @xmath6 , limb * a , const limb * b , int n ) ;    int mpineg(uint @xmath6 , limb * a , int n ) ;    int mpiaddc(uint @xmath6 , limb * a , int n , int @xmath13 ) ;    here the type uint has been defined as unsigned int , and limb has been defined as unsigned short int .",
    "the mpiadd function adds long integer @xmath60 to long integer @xmath11 , and returns the carry . both @xmath11 and @xmath60",
    "are of length @xmath5 , that is , @xmath78 , and the carry can thus be 0 or 1 .",
    "the mpisub function subtracts long integer @xmath60 from long integer @xmath11 , and returns the carry .",
    "both @xmath11 and @xmath60 are of length @xmath5 , that is , @xmath78 , and the carry can thus be 0 or -1 .",
    "if @xmath79 , then mpineg does nothing but return 0 to indicate @xmath11 is zero . if @xmath80 , then mpineg replaces @xmath11 with @xmath81 , and returns 1 .",
    "the mpiaddc function adds input carry @xmath13 to long integer @xmath11 , and returns its output carry .",
    "this function is used in carry processing .",
    "the upper level group of functions include the following functions :    void mpimul_kr(uint @xmath6 , limb * d , const limb * a ,",
    "int n , const limb * b , int m ) ;    void krmpimul(uint @xmath6 , limb * d , const limb * a , int n , const limb * b , int m ) ;    int krmultop(uint @xmath6 , limb * d , const limb * a , const limb * b , int n ) ;    int krmul(uint @xmath6 , limb * d , const limb * a0 , const limb * a1 , const limb * b , int n ) ;    int krmulb1(uint @xmath6 , limb * d , const limb * a , const limb * b , int n ) ;    int krmulb2(uint @xmath6 , limb * d , const limb * a0 , const limb * a1 , const limb * b , int n ) ;    the mpimul_kr is the highest level function .",
    " kr \" stands for  karatsuba and roche \" .",
    "it computes the product of length-@xmath5 integer @xmath11 and length-@xmath61 integer @xmath60 , and stores it in the @xmath82 limbs buffer starting at @xmath40 .",
    "it calls krmpimul to do the actual work .",
    "the only thing that mpimul_kr does itself is to ensure that @xmath83 when calling krmpimul(@xmath6 , d , a , n , b , m ) .",
    "krmpimul actually computes the product of length-@xmath5 integer @xmath11 and length-@xmath61 integer @xmath60 , and stores it in the @xmath82 limbs buffer starting at @xmath40 .",
    "it assumes @xmath83 .",
    "when @xmath61 is smaller than a threshold for using karatsuba multiplication , it calls the schoolbook multiplication algorithm . otherwise , it computes the product using the algorithm described in section 2.4 .",
    "it calls krmultop to do equal length additive multiplication .",
    "krmultop computes @xmath84 , stores the result in the @xmath85 limbs buffer starting at @xmath40 and returns the carry , where the long integer @xmath86 is stored beforehand in the first @xmath5 limbs of @xmath40 .",
    "it is a recursive function , and may call itself , krmul , , krmulb1 , and krmulb2 .",
    "krmultop is based on a simplified version of the algorithm described in sections 2.2 and 2.3 .",
    "krmul computes @xmath87 and stores the result in the @xmath85 limbs buffer starting at @xmath40 and returns the carry , where the long integer @xmath86 is stored beforehand in the first @xmath5 limbs of @xmath40 .",
    "it is a recursive function , and may call itself and krmulb2 .",
    "krmul is based on the full algorithm described in sections 2.2 and 2.3 .",
    "krmulb1 serves the same purpose as krmultop , using a schoolbook algorithm .",
    "it is called when the length is less than the karatsuba threshold .",
    "krmulb2 serves the same purpose as krmul , using a schoolbook algorithm .",
    "it is called when the length is less than the karatsuba threshold .",
    "the mpimul_kr code has been thoroughly tested by the present author .",
    "it was found to produce exactly the same results as the schoolbook and the standard karatsuba algorithms . to show how efficient it is relative to the traditional algorithms",
    ", we also made a numerical experiment .",
    "the experimental setting was as follows :    * average time per multiplication for lengths @xmath88 were measured for the three algorithms : schoolbook ( sb ) , karatsuba standard ( ks ) , space - efficient karatsuba or karatsuba and roche ( kr ) . only square multiplications were considered in the experiment .",
    "* before the experiment was done , we found that the karatsuba divide - and - conquer technique begins to gain benefit when @xmath89 , so we have made the karatsuba threshold 128 .",
    "this number was chosen simply because it is a power of 2 .",
    "there will be no significant consequence if we choose a near but different threshold . * the pairs of long integers for multiplication were generated randomly .",
    "the number of pairs generated decreases as @xmath5 increases , since we wanted to finish the experiment in hours .",
    "* in coding karatsuba standard , we incorporated some speeding - up and memory saving techniques proposed in @xcite , so it is not purely conventional karatsuba . in our code",
    "each call of karatsuba recursive function consumes @xmath90 $ ] limbs of heap memory . * technical specifications of the computer running the experiment were as follows : windows 7 32-bit operating system , intel i3 - 2120 @3.30ghz cpu , and 4 gb memory .",
    "the results are visualized in figure 1 . from the results data and the figure we observe the following :    * the results seem to confirm the theoretical complexity results . from @xmath91 to @xmath92 , for sb , the average execution time grows 8678 times , close to the theoretical number 10000 ; for ks , the average execution time grows 1382 times , and for kr , average execution time grows 1622 times , both close to the theoretical number @xmath93 . *",
    "the second chart shows kr takes roughly 20% more time than ks .",
    "therefore , in terms of time efficiency , kr is roughly 20% less efficient than ks .",
    "this might be seen as a small price for kr s avoiding of heap memory .",
    "we have described in detail how to implement the space - efficient karatsuba algorithm for multiplication of long integers .",
    "issues resulting from carries , and other special issues for integers are resolved .",
    "numerical results show that the space - efficient karatsuba , while totally avoiding heap memory allocation , is slightly less time efficient than the standard karatsuba ."
  ],
  "abstract_text": [
    "<S> the traditional karatsuba algorithm for the multiplication of polynomials and multi - precision integers has a time complexity of @xmath0 and a space complexity of @xmath1 . </S>",
    "<S> roche proposed an improved algorithm with the same @xmath0 time complexity but with a much reduced @xmath2 space complexity . in roche s </S>",
    "<S> paper details were provided for multiplication of polynomials , but not for multi - precision integers . </S>",
    "<S> multi - precision integers differ from polynomials by the presence of carries , which poses difficulties in implementing roche s scheme in multi - precision integers . </S>",
    "<S> this paper provides a detailed solution to these difficulties . </S>",
    "<S> finally , numerical comparisons between the schoolbook , traditional karatsuba , and space - efficient karatsuba algorithms are provided . </S>"
  ]
}