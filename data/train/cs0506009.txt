{
  "article_text": [
    "in this paper we propose a new approximate map decoding technique on tail - biting trellises that exploits the subtrellis structure of the tail - biting trellis to compute approximate aposteriori probabilities ( apps ) of codeword symbols .",
    "our algorithm is best described as a best - search algorithm , meaning thereby , that the algorithm tries to track those subtrellises which are most likely to contain the transmitted codeword and computes marginals over these only .",
    "our approximate decoder works rather efficiently at higher values of signal to noise ratios .",
    "we compare our results with those obtained by the _ wrap _ version of anderson - hladik map decoder  @xcite , which we refer to as the ah - decoder .",
    "the rest of the paper is organized as follows .",
    "section  [ sec : background ] gives some background .",
    "section  [ sec : decoding ] describes the decoding algorithm .",
    "section  [ sec : modification ] describes a simple modification to the scheme .",
    "section  [ sec : simulations ] presents the results of simulations on an awgn channel on a @xmath3 state tail - biting trellis for the @xmath0 extended golay code and a @xmath4 state tail - biting trellis for a rate @xmath1 , memory @xmath2 , convolutional code .",
    "section  [ sec : conclusion ] concludes the paper .",
    "tail - biting trellises for convolutional codes were introduced in  @xcite and those for block codes in  @xcite .",
    "for ease of notation we view the tail - biting trellis @xmath5 , of depth @xmath6 , to be defined on a sequential time - axis with @xmath7 and all valid paths restricted to those that begin and end at the same state .",
    "we call @xmath8 and @xmath9 respectively the start and final states of @xmath10 . in  @xcite it was shown that a tail - biting trellis could be viewed as the superposition of subtrellises obtained from a coset decomposition of the code represented by it with respect to a subgroup . corresponding to each start state of the tail - biting trellis we define a subcode consisting of all codewords that begin and end at the same state . these subcodes",
    "all have identically structured subtrellises ( though with different labels ) , and share states at various time indices .",
    "this subtrellis structure is exploited to give an approximate map decoding algorithm .",
    "in order to explain the approximate map algorithm we define the weight of a subtrellis @xmath11 conditioned on the received vector @xmath12 as @xmath13 where @xmath14 is the subcode represented by @xmath11 . the weight of a subtrellis is the aposteriori probability that the transmitted codeword lies in the particular subtrellis .",
    "the weight of a subtrellis is also the maximum contribution a subtrellis can make to the decision sums for computing the app of any digit of the codeword .",
    "the basic idea in map approximate algorithm ( maa ) is to start off by obtaining initial estimates to the weights of the subtrellises .",
    "the initial estimates are all overestimates .",
    "we begin with the best subtrellis with respect to the current estimates and begin a forward pass on that subtrellis .",
    "we define our updating function for estimates as we progress along sections of the current trellis such that the overestimates become more and more accurate as we go along , always converging to the exact value at the end .",
    "each time we move from one section to the next , we check the updated estimate against those of other subtrellises and switch to another subtrellis if it appears more likely to be the correct one .",
    "thus the algorithm may switch from one subtrellis to another during the course of execution .",
    "however , it is always guaranteed to finish on the most likely subtrellis .",
    "the same is done for the backward pass .",
    "now after the two passes are over , there will be subtrellises for which certain sections have been opened only in the forward or backward pass but not both . in the final marginalization phase we ignore these sections of subtrellises which have not been opened by both the passes .      given a one - to - one tail - biting trellis @xmath15 of depth @xmath6 , we use the following notation .",
    "we denote the label of an edge @xmath16 by @xmath17 . for an edge @xmath18",
    "we define predecessor and successor operators as @xmath19 and @xmath20 . by nodes of @xmath10 we refer to the vertices of @xmath10 .",
    "the start node of a subtrellis @xmath11 is denoted by @xmath21 and the final node by @xmath22 .",
    "the set of all paths in the tail - biting trellis from node @xmath23 to node @xmath24 is denoted by @xmath25 .",
    "further let @xmath26 denote the set of paths from nodes in @xmath27 to nodes in @xmath28",
    ".    given a received vector @xmath12 we annotate the edges of the tail - biting trellis suitably using the channel information so that the codeword app gets decomposed along the edges of the codeword path .",
    "the weight of an edge is denoted by @xmath29 .",
    "we then define the weight of a path as the product of the weights of the edges constituting the path .",
    "the weight of a subtrellis @xmath11 , as defined previously , is then the sum of the weights of all paths in @xmath11 .",
    "the approximate algorithm computes a set of node - objective functions on the nodes of the tail - biting trellis .",
    "these function definitions are identical to the forward - backward passes defined in  @xcite .",
    "@xmath30 and @xmath31 are functions whose domain is the nodes of the tail - biting trellis @xmath10 .",
    "they are defined recursively as @xmath32 with @xmath33 .",
    "+ this is just a forward - backward pass on @xmath10 , initialized according to the boundary conditions .    also corresponding to each subtrellis @xmath11 we define two functions @xmath34 and @xmath35",
    "whose domain is the set of nodes belonging to @xmath11 .",
    "@xmath34 and @xmath36 at a node @xmath23 capture the computational effects of exclusive forward and backward passes respectively on @xmath11 at @xmath23 .",
    "@xmath34 at a node @xmath37 is defined inductively as @xmath38 with @xmath39 .",
    "+ similarly @xmath35 at a node @xmath37 is defined inductively as @xmath40 with @xmath41 .",
    "+ it can be seen that @xmath34 at a node @xmath37 is the sum of the weights of all paths in @xmath42 , while @xmath35 at @xmath23 is the sum of the weights of all paths in @xmath43 .",
    "similarly @xmath44 at a node @xmath45 gives the sum of the weights of all paths in @xmath46 whereas @xmath31 at @xmath23 gives the sum of the weights of all paths in @xmath47 .",
    "we now give an informal description of the map approximate algorithm ( maa ) .",
    "+ map - aa + input : a one - to - one tail - biting trellis @xmath15 of depth @xmath6 , with edge weights suitably defined using the received vector @xmath12 and channel information + output : a vector of approximations to @xmath48 for @xmath49 and @xmath50      this phase computes the node - objective functions @xmath44 and @xmath51 with respect to the tail - biting trellis @xmath10 by executing a forward - backward pass on @xmath10 with boundary conditions as suggested by recursion  [ eqn:1 ] .",
    "this phase computes a set of node - objective functions @xmath34 and @xmath35 with respect to the subtrellises that share the node .",
    "it consists of a forward and a backward pass .",
    "a node can be shared among many subtrellises and will belong to the domain of the functions defined with respect to these subtrellises .",
    "maa computes a subset of these functions either partially or completely .",
    "[ [ forward - pass ] ] forward pass + + + + + + + + + + + +    at each step in the forward pass the approximate algorithm first chooses a winning subtrellis @xmath52 .",
    "it then computes @xmath53 for the next section of @xmath52 using recursion  [ eqn:2 ] .",
    "the winning subtrellis is one at which a suitably defined heuristic function , @xmath54 , is maximized .",
    "we associate a working index with each subtrellis .",
    "the working index of a subtrellis @xmath11 gives the last section of the tail - biting trellis at which the node - objective function @xmath34 has been computed .",
    "the forward pass works along the following lines .",
    "the working indices are initialized to the start section and the boundary conditions of recursion  [ eqn:2 ] are enforced .",
    "we start by choosing a winning subtrellis @xmath52 from the set of @xmath55 subtrellises defined on @xmath10 such that @xmath54 is maximized at @xmath52 .",
    "the heuristic function at a subtrellis @xmath11 with a working index @xmath56 is a function of @xmath34 and @xmath31 at section @xmath56 in @xmath10 .",
    "we describe the heuristic function in detail later .",
    "if the working index of @xmath52 is the final section , we successfully exit from the forward pass .",
    "otherwise we increment the working index to the next section . using the values of @xmath53 at the nodes of previous working index of @xmath52 ,",
    "we then compute @xmath53 at the nodes of the current working index according to recursion  [ eqn:2 ] . after computing @xmath53 for the current working index , we re",
    "- evaluate the heuristic function at @xmath52 .",
    "we then go back to the process of choosing the winning subtrellis and computing the corresponding node - objective function at the next working index of the winning subtrellis .",
    "the heuristic function at @xmath11 with working index @xmath56 is defined as @xmath57 we now motivate this definition of the heuristic function .",
    "+ let @xmath58 be the set of paths in @xmath59 whose first @xmath56 edges lie in @xmath11 .",
    "it can be seen that @xmath60 is the sum of the weights of paths in @xmath58 .",
    "note that @xmath61 is the sum of weights of paths in @xmath62 . +",
    "now observe that @xmath63 .",
    "since the edge - weights are probabilities and therefore non - negative , this implies that @xmath64 also by definition @xmath65 and as a consequence @xmath66 .",
    "+ it follows that the heuristic for @xmath11 keeps falling after each revision and finally converges to the weight of @xmath11 .",
    "thus at any instant the heuristic for @xmath11 is an over - estimate to the weight of @xmath11 . if a forward pass has been completed on a subtrellis @xmath11 , the approximate algorithm guarantees that a forward pass will be completed on all subtrellises @xmath67 with @xmath68 .",
    "[ [ backward - pass ] ] backward pass + + + + + + + + + + + + +    in the backward pass we compute a set of node - objective functions @xmath35 with respect to subtrellises @xmath11 as dictated by recursion  [ eqn:3 ] .",
    "the backward pass is similar in spirit to the forward pass except for the definition of the heuristic function and the backward direction of computational flow on the trellis .",
    "the computation starts by initializing the working indices of subtrellises to the final section and ends when the working index of the winning subtrellis is the start section .",
    "the heuristic function at @xmath11 with working index @xmath56 for the backward pass is defined as @xmath69 it can be seen that @xmath70 is the sum of weights of all paths in @xmath59 whose last @xmath71 edges lie completely in @xmath11 .",
    "it follows that all the properties noted for the heuristic function along the forward pass carry over to the heuristic function for the backward pass .",
    "this phase computes the approximate marginals corresponding to each symbol @xmath72 and each position @xmath73 .",
    "we compute the approximate aposteriori probabilities @xmath48 as @xmath74 the product in the inner - sum is taken over only those node - objective functions which have been computed .",
    "by restricting the phase 2 of maa to work with a fixed number of subtrellises say @xmath75 , we can reduce the storage requirements of the algorithm at the cost of incurring a further penalty in the accuracy of the apps computed . in order to decide the @xmath75 subtrellises to work with , we evaluate @xmath76 at each subtrellis @xmath11 and choose the first @xmath75 subtrellises at which this quantity is the largest .",
    "+ the rationale behind this choice is that both @xmath77 and @xmath78 are overestimates to the @xmath79 and the minimum of the two is nearer to the true weight of @xmath11 .",
    "we call this modified scheme as the @xmath80 ( @xmath81 ) .",
    "surprisingly this scheme gives pretty good results for the codes on which we have run experiments .",
    "we have coded the maa , 4-maa and ah - decoder and shown the results of simulations on the minimal 16 state tail - biting trellis  @xcite for the extended ( 24,12,8 ) golay code and a 64 state tail - biting trellis for a rate 1/2 convolutional codes with memory 6 ( equivalent to the ( 554,744 ) convolutional code of  @xcite ) , with circle size 48 .",
    "this is the same code experimented on in  @xcite .",
    "the channel model used is an awgn channel with antipodal signaling .",
    "the source bits were assumed to be equally - likely .    for the convolutional code",
    "we show the variation of the average number of forward - backward updates with the signal to noise ratio for the maa and compare it with the number of forward - backward updates required by the ah - decoder .",
    "+ we also show the variation of average number of subtrellises explored by the phase 2 of maa with signal to noise ratio .",
    "the tail - biting trellis representing the code has @xmath82 states and @xmath4 subtrellises .",
    "each subtrellis has @xmath83 states .",
    "the result is displayed in table  [ tab : expansions2 ] .",
    "it can be seen that at moderate to high snr , the phase 2 of maa seems to work on only a single subtrellis .",
    "we also display the performance of the maa , 4-maa and ah - decoder in figures  [ fig : golay - ber ] and  [ fig : conv1-ber ] and find that there is virtually no difference in the bit error rates for the three algorithms for the convolutional code . for the golay code the maa and the 4-maa seem to do slightly better than the ah - decoder .",
    "subtrellises * + & * by maa * & * ah - decoder * & * examined by maa * + 0.0 & 91867 & 22528 & 7.60 + 0.5 & 53737 & 22528 & 4.04 + 1.0 & 34113 & 22528 & 2.16 + 1.5 & 25984 & 22528 & 1.38 + 2.0 & 23087 & 22528 & 1.11 + 2.5 & 22230 & 22528 & 1.02 + 3.0 & 22049 & 22528 & 1.00 + 3.5 & 22014 & 22528 & 1.00 + 4.0 & 22008 & 22528 & 1.00 + 4.5 & 22008 & 22528 & 1.00 + 5.0 & 22008 & 22528 & 1.00 +",
    "we have shown that at the expense of some extra space we can obtain approximate algorithms with good performance for map decoding on tail - biting trellises .",
    "simulations on tail - biting trellises for the ( 24,12 ) extended golay code and a rate @xmath1 , memory @xmath2 convolutional code used in  @xcite have been carried out and the results on an awgn channel are reported ."
  ],
  "abstract_text": [
    "<S> we propose two approximate algorithms for map decoding on tail - biting trellises . </S>",
    "<S> the algorithms work on a subset of nodes of the tail - biting trellis , judiciously selected . </S>",
    "<S> we report the results of simulations on an awgn channel using the approximate algorithms on tail - biting trellises for the @xmath0 extended golay code and a rate @xmath1 convolutional code with memory @xmath2 .    </S>",
    "<S> [ section ] </S>"
  ]
}