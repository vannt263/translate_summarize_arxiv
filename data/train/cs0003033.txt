{
  "article_text": [
    "the smodels  system is written in c++ and the source code , test cases and documentation are available at ` http://www.tcs.hut.fi/software/smodels/ ` . in order to compile the system a c++ compiler is needed as well as other standard tools such as make , tar , bison , and perl .",
    "the system has been developed under linux and should work as is on any platform having the appropriate gnu tools installed .",
    "it has been used on a wide range of hardware ( pc / sparc / alpha ) mostly running unix .",
    "the total number of lines of codes is about 20000 .",
    "the smodels  system implements the stable model semantics for normal logic programs extended by built - in functions as well as cardinality and weight constraints for domain - restricted programs . in this section",
    "we briefly discuss the syntax , implementation techniques and use of the system .",
    "more information can be found at the home page ` http://www.tcs.hut.fi/software/smodels/ ` .    as input the smodels  system takes logic program rules basically in prolog style syntax :    ....      ancestor(x , y ) : - ancestor(x , z ) ,                        parent(z , y ) ,                         person(x ) .",
    "ancestor(x , y ) : - parent(x , y ) .",
    "son(x , y ) : - parent(y , x ) , male(x ) .",
    "daughter(x , y ) : - parent(y , x ) , female(x ) .",
    "person(x ) : - male(x ) .",
    "person(x ) : - female(x ) .",
    "parent(jack , jill ) .",
    "parent(joan , jack ) .",
    "male(jack ) .",
    "female(jill ) .",
    "female(joan ) .   ....",
    "however , in order to support efficient implementation techniques and extensions the programs are required to be _ domain - restricted _ where the idea is the following .",
    "no proper function symbols are allowed ( but we do allow built - in functions ) and the predicate symbols in the program are divided into two classes , _ domain predicates _ and _ non - domain predicates_. domain predicates are predicates that are defined non - recursively . in the program above all predicates except ` ancestor ` are domain predicates .",
    "the predicate ` ancestor ` is not a domain predicate because it depends recursively on itself .",
    "the main intuition of domain predicates is that they are used to define the set of terms over which the variables range in each rule of a program @xmath0 .",
    "all rules of @xmath0 have to be domain - restricted in the sense that every variable in a rule must appear in a domain predicate which appears positively in the rule body .",
    "for instance , in the first rule of the program above all variables appear in domain predicates ` parent ` and ` person ` in the body of the rule .",
    "in addition to normal logic program rules , smodels   supports rules with cardinality and weight constraints .",
    "the idea is that , e.g. , a cardinality constraint @xmath1 holds in a stable model if at the least 1 but at most 2 of the literals in the constraint are satisfied in the model and a weight constraint @xmath2 20+\\ ] ] holds if the sum of weights of the literals satisfied in the model is between 10 and 20 ( inclusive ) . with built - in functions for integer arithmetic ( included in the system ) ,",
    "these kinds of rules allow compact and fairly straightforward encodings of many interesting problems .",
    "for example , the n queens problem can be captured using rules as a program ` queens.lp ` as follows :    ....      1 { q(x , y):d(x ) } 1 : - d(y ) .      1 { q(x , y):d(y ) } 1 : - d(x ) .",
    ": - d(x ) , d(y ) , d(x1 ) , d(y1 ) ,         q(x , y ) , q(x1,y1 ) ,         x !",
    "= x1 ,   y !",
    "= y1 ,          abs(x - x1 ) = = abs(y - y1 ) .",
    "d(1 .. n ) . ....",
    "where ` d(1 ..",
    "n ) ` is a domain predicate giving the dimension of the board ( from 1 to integer @xmath3 which can be specified during run time ) .",
    "the first rule says that for each row @xmath4 , a stable model contains exactly one atom @xmath5 where for @xmath6 , @xmath7 holds and similarly in the second rule for all columns .",
    "the third rule is an integrity constraint saying that there can not be two queens on the same diagonal .",
    "now each stable model corresponds to a legal configuration of @xmath3 queens on a @xmath8 board , i.e. , @xmath5 is in a stable model iff @xmath9 is a legal position for a queen .",
    "stable models of a domain - restricted logic program with variables are computed in three stages .",
    "first , the program is transformed into a ground program without variables .",
    "second , the rules of the ground program are translated into primitive rules , and third , a stable model is computed using a davis - putnam like procedure  @xcite .",
    "the first two stages have been implemented in the program , which functions as a front end to  which in turn implements the third stage .    in the first stage",
    "automatically determines the domain predicates and then using database techniques evaluates the domain predicates and creates a ground program which has exactly the same stable models as the original program with variables .",
    "then the rules are compiled into primitive rules  @xcite .",
    "the  procedure is a davis - putnam like backtracking search procedure that finds the stable models of a set of primitive rules by assigning truth values to the atoms of the program .",
    "moreover , it uses the properties of the stable model semantics to infer and propagate additional truth values .",
    "since the procedure is in effect traversing a binary search tree , the number of nodes in the search space is in the worst case on the order of @xmath10 , where @xmath3 can be taken to be the number of atoms that appear in a constraint in a head of a rule or that appear as a negative literal in a recursive loop of the program .",
    "hence , in order to compute stable models , one uses the two programs , which translates logic programs into an internal format , and , which computes the models , see figure  [ fig : architecture ] .",
    "( 100,15)(0,0 ) ( 0,10)(1,0)15 ( 7.5,12)(0,0)[b ] ( 7.5,8)(0,0)[t ] ( 20,5)(15,10 ) ( 40,10)(1,0)15 ( 47.5,12)(0,0)[b]internal ( 47.5,8)(0,0)[t]representation ( 60,5)(15,10 ) ( 80,10)(1,0)15 ( 87.5,12)(0,0)[b]stable ( 87.5,8)(0,0)[t]models    for instance , a solution to the 8 queens problem given the program ` queens.lp ` above , would be typically computed by a command line :    .... lparse -c n=8 -d none queens.lp | smodels ....    where ` -c n=8 ` option instructs to use the value 8 for the constant @xmath3 and ` -d none ` option instructs to remove all domain predicates from the rules as soon as they have been evaluated .",
    "the command line produces output :    .... answer : 1 stable model : q(4,1 ) q(2,2 ) q(7,3 ) q(5,4 )   q(1,5 ) q(8,6 ) q(6,7 ) q(3,8 )   ....      the graph coloring problem may be encoded to a program ` ncolor.lp ` using the following two smodels  rules :    ....    1 { col(n , c ) : color(c ) } 1 : - node(n ) .",
    ": - col(x , c ) , col(y , c ) , edge(x , y ) , color(c ) . ....    here the predicate ` col(n , c ) ` denotes that the color of the node ` n ` is ` c ` . the first rule states that each node has exactly one color and the second rule states that two adjacent nodes may not have the same color .",
    "suppose we have a fully connected three node graph and we want to find all 3-colorings of it where the first node is colored red .",
    "we can encode the problem instance to a program ` graph.lp ` :    ....    node(a ; b ; c ) .",
    "edge(a , b ) .",
    "edge(a , c ) .",
    "edge(b , c ) .",
    "color(red ; green ; blue ) .",
    "compute { col(a , red ) } . ....",
    "the first two lines define the graph and the third line defines the three colors .",
    "the ` compute ` statement tells smodels  that we are interested only in those models where ` col(a , red ) ` is true , i.e. , the node ` a ` has color ` red ` .",
    "we can find all stable models that satisfy the compute statement with the command line :    .... lparse -d none ncolor.lp graph.lp | smodels 0 ....    this input produces the output :    .... answer : 1 stable model : col(c , blue ) col(b , green ) col(a , red )   answer : 2 stable model : col(c , green ) col(b , blue ) col(a , red )   ....    more information about the syntax and use of the system can be found in the  user s manual at ` http://www.tcs.hut.fi/software/smodels/lparse/ ` and about the implementation in  @xcite .",
    "an interesting application methodology for smodels  is based on answer set programming  @xcite which has emerged as a viable approach to declarative logic - based knowledge representation .",
    "it is based on the stable model semantics of logic programs and can be seen as a novel form of constraint programming where constraints are expressed as rules .",
    "the underlying idea is to encode an application problem using logic program rules so that the solutions to the problem are captured by the stable models of the rules .",
    "the solution of the n queens problem in the previous section illustrates nicely main ideas of answer set programming .",
    "it is important that the system is based on an implementation - independent declarative semantics .",
    "this makes it much easier to develop applications because one does not have to worry too much about the internal implementation - specific aspects of the system .",
    "hence , the system is relatively easy to learn to use .",
    "on the other hand , declarative semantics provides much more flexibility in developing implementation approaches and in optimizing different parts of the implementation .",
    "we have taken advantage of this and developed methods which are substantially different from usual implementation methods for logic programming ( prolog ) but still work efficiently in new kinds of applications where prolog style systems are not appropriate .",
    "smodels  implements the stable model semantics for range - restricted function free normal programs .",
    "it can also compute well - founded models for these programs .",
    "smodels  supports built - in functions , e.g. , for integer arithmetic .",
    "basic smodels  extends normal logic programs with cardinality and weight constraints  @xcite . on top of this core engine",
    "more involved systems can be built .",
    "as an example , we have implemented total and partial stable model computation for disjunctive logic programs  @xcite .",
    "the semantics for logic programs with cardinality and weight constraints supported by the core engine is an interesting compromise : it is rather simple to learn , its complexity stays in np in the ground case ( like for propositional logic ) but it seems strictly more expressive than propositional logic ( or other standard constraint satisfaction formalisms ) .    with our work on smodels",
    "we hope to demonstrate that nonmonotonic reasoning techniques are useful conceptual tools as well as bring computational advantages which can lead to new interesting applications and to developments of novel implementation techniques and tools .",
    "the basic semantics of smodels  rules seems to be simple enough that it can be explained to a non - expert or a student in a relatively short amount of time sufficiently so that one can start using smodels .",
    "smodels  has been employed in a number of areas including planning  @xcite , model checking  @xcite , reachability analysis  @xcite , product configuration  @xcite , dynamic constraint satisfaction  @xcite , feature interaction  @xcite , and logical cryptanalysis  @xcite .    in order to make smodels  more flexible",
    "an api has been added to  and .",
    "hence , they can be used through the api and embedded into a c / c++ program as libraries .",
    "furthermore , it is possible to define new built - in functions for the front - end  in order to accommodate new applications .",
    "these new functions are written in c / c++ and they are dynamically linked to  when needed .    as a further usability feature ,  performs simple analysis of the program and warns about constructs that are often erroneous .",
    "for example ,  detects if a variable is accidentally mistyped as a constant or vice versa .",
    "these warnings can be enabled with command line options .",
    "we have compiled quite a large collection of families of benchmarks that we use to evaluate new developments and improvements in our system and which we can employ to compare our system to other competing ones and which can be used also by others ( see , ` http://www.tcs.hut.fi/software/smodels/tests/ ` ) .",
    "similar testing methodology ( e.g. , generating test cases from graph problems ) has also been used by the groups in kentucky ( deres / theorybase system  @xcite ) and in vienna ( dlv system  @xcite ) .",
    "these kinds of tests can be used for measuring the base level performance and to compare different systems .",
    "however , it is unclear what is a portable way of representing such benchmarks .",
    "we use prolog style syntax which is quite generally accepted but it seems that each system has its specialties .",
    "smodels  can already compete with special purpose systems and we have even cases where it outperforms commercial top edge tools , e.g. , in a verification application it has performance better than that of one of the most efficient commercial integer programming tools ( cplex ) @xcite .",
    "we believe that smodels  is no longer a mere prototype but it can handle realistic size problems .",
    "we have applications where programs with hundreds of thousands of non - trivial ground rules are treated efficiently , see e.g.  @xcite .",
    "dimopoulos , y. ; nebel , b. ; and koehler , j. 1997 .",
    "encoding planning problems in non - monotonic logic programs . in _ proceedings of the fourth european conference on planning _ , 169181 .",
    "toulouse , france : springer - verlag .",
    "eiter , t. ; leone , n. ; mateis , c. ; pfeifer , g. ; and scarnello , f. 1998 .",
    "the kr system dlv : progress report , comparisons and benchmarks . in _ proceedings of the 6th international conference on principles of knowledge representation and reasoning _ , 406417 .",
    "trento , italy : morgan kaufmann publishers .",
    "heljanko , k. 1999a . using logic programs with stable model semantics to solve deadlock and reachability problems for 1-safe petri nets . in _ proceedings of the 5th international conference on tools and algorithms for the construction and analysis of systems _ , 240254 .",
    "amsterdam , the netherlands : springer - verlag .",
    "hietalahti , m. ; massacci , f. ; and niemel , i. 2000 . : a challenge problem for nonmonotonic reasoning systems . in _ proceedings of the 8th international workshop on non - monotonic reasoning_. accepted for publication .",
    "janhunen , t. ; niemel , i. ; simons , p. ; and you , j. 2000 .",
    "unfolding partiality and disjunctions in stable model semantics . in cohn , a.",
    "; guinchiglia , f. ; and selman , b. , eds .",
    ", _ proceedings of the seventh international conference on principles of knowledge representation and reasoning_. breckenridge , colorado , usa : morgan kaufmann publishers . accepted for publication .",
    "liu , x. ; ramakrishnan , c. ; and smolka , s.  a. 1998 . fully local and efficient evaluation of alternating fixed points . in steffen , b. , ed .",
    ", _ proceedings of the 4th international conference on tools and algorithms for the construction and analysis of systems _ , 519 .",
    "lisbon , portugal : springer - verlag .",
    "niemel , i. ; simons , p. ; and soininen , t. 1999 .",
    "stable model semantics of weight constraint rules . in _ proceedings of the 5th international conference on logic programming and nonmonotonic reasoning _ , 317331 .",
    "el paso , texas , usa : springer - verlag .",
    "simons , p. 1999 . extending the stable model semantics with more expressive rules . in _ proceedings of the 5th international conference on logic programming and nonmonotonic reasoning _ , 305316 .",
    "el paso , texas , usa : springer - verlag .",
    "soininen , t. , and niemel , i. 1999 . developing a declarative rule language for applications in product configuration . in gupta , g. , ed . ,",
    "_ proceedings of the first international workshop on practical aspects of declarative languages _ , 305319 .",
    "san antonio , texas : springer - verlag .",
    "soininen , t. ; niemel , i. ; and gelle , e. 1999 . a fixpoint definition of dynamic constraint satisfaction . in jaffar , j. , ed . ,",
    "_ proceedings of the fifth international conference on principles and practice of constraint programming _ , 419433 .",
    "alexandria , virginia , usa : springer - verlag ."
  ],
  "abstract_text": [
    "<S> the smodels  system implements the stable model semantics for normal logic programs . </S>",
    "<S> it handles a subclass of programs which contain no function symbols and are domain - restricted but supports extensions including built - in functions as well as cardinality and weight constraints . on top of this core engine </S>",
    "<S> more involved systems can be built . </S>",
    "<S> as an example , we have implemented total and partial stable model computation for disjunctive logic programs . </S>",
    "<S> an interesting application method is based on answer set programming , i.e. , encoding an application problem as a set of rules so that its solutions are captured by the stable models of the rules . </S>",
    "<S> smodels  has been applied to a number of areas including planning , model checking , reachability analysis , product configuration , dynamic constraint satisfaction , and feature interaction . </S>"
  ]
}