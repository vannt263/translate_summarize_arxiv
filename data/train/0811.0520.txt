{
  "article_text": [
    "i gratefully acknowledge the assistance of * dr vasile palade * , oxford university computing laboratory , for his introducing me to the field of machine learning as well as his supervision of this project ; * dr somak raychaudhury * , school of physics and astronomy , university of birmingham , for his suggestions about photometric redshift estimation ; * mr andrew foster * , unc - chapel hill , for his useful contributions regarding the implementation of evolutionary algorithms and modelling techniques ; * dr daniel reichart * , department of physics and astronomy , unc - chapel hill , for his introducing me to astrophysical and statistical modelling and his providing me with initial ideas about the moons of jupiter ; * dr daniel vanden berk * , department of astronomy and astrophysics , penn state university , for his assistance in interpreting measurement errors in the sdss quasar dataset ; and * dr ani calinescu * , oxford university computing laboratory , for her attentive guidance throughout the year .",
    "i do not , of course , neglect to express my gratitude and indebtedness to my friends , my family , and especially my parents , without whose continuous support and encouragement the following dissertation could not have been written .     +",
    "ndk + oxford + september 2008",
    "one basic problem that has always confronted astrophysicists is that of coming to understand the physical dynamics behind a set of astronomical observations over time , i.e. , trying to learn what causes the behaviour we see from our telescopes on earth . on a superficial level , however , we often observe behaviour that is at best indirectly related to the actual dynamics of a system , or even seemingly counterintuitive .",
    "for example , we might observe a single pulsating beam of light in the sky , progressing from bright to very bright to dim to very bright , and so on : what we are actually seeing is two stars of unequal magnitude rotating around each other in our line of sight , eclipsing one another in turn as they progress .",
    "astrophysical modelling allows us to take theories of expected astrophysical behaviour , and , combining them with order - of - magnitude estimates , apply them to a particular phenomenon to determine whether our observations are consistent with our expectations .",
    "when we understand precisely the physical behaviour in an observed system ( e.g. , the simple orbit of a moon around a planet ) , we are able to determine specific parameters of the system ( say , the elements that completely specify the moon s orbit ) by modelling on our observations .",
    "a newer problem beginning to confront astronomers is the need to analyse and make sense of data obtained in large sky surveys such as the sloan digital sky survey ( sdss ) @xcite , the 2df qso redshift survey ( 2qz ) , and the forthcoming panoramic survey telescope and rapid response system ( pan - starrs ) and large synoptic survey telescope ( lsst ) .",
    "once in operation , these newer surveys will collect terabytes @xcite of data each night , orders of magnitude more than could be analysed by any team using traditional techniques .    in order to conduct useful science on these tera- and",
    "petascale survey databases , more efficient and accurate data mining techniques are needed  especially those that require little or no human intervention .",
    "as survey databases continue to grow by orders of magnitude , our analysis techniques will have to keep pace , and machine learning techniques are particularly well suited for the task .",
    "learning algorithms may be preferred for their accuracy , efficiency , and/or scalability .",
    "for example , linear or quadratic polynomial fitting or nonlinear regression may be straightforwardly used to model a system or estimate a relation , but can often lead to `` large systematic deviations '' @xcite . a nonlinear solution estimated with a learning technique",
    "may be harder for humans to make sense of ( as with ` black box ' techniques ) , but can be arbitrarily more complex  and thus sometimes arbitrarily more precise .",
    "the traditional method of photometric redshift estimation before learning techniques were introduced had been spectral energy distribution ( sed ) template - fitting : a theoretical composite sed is developed by averaging the spectra of hundreds or thousands of objects that are thought to be parametrically similar ( e.g. , high-@xmath0 quasars , seyfert galaxies , or type ia supernovae ) .",
    "absorption and emission lines are identified and shifted into place , and the resulting sed is then redshifted to several values to form a set of templates @xcite .",
    "photometric measurements are then compared to these templates , and a best - fit redshift is determined by minimisation over some chi - square distribution .",
    "unfortunately , this method requires a set of representative templates , and can not be reasonably utilised for astronomical objects that can not be safely classified ( e.g. , quasars , which were until recently not well understood , and which are difficult enough to distinguish from stars in colour - colour space @xcite ) .",
    "particularly useful also is the ability to adjust a learning algorithm to suit a particular problem - specific need ( say , for efficiency over accuracy , or for distributed computation over an unknown number of systems ) , which is often not possible with traditional statistical approaches .",
    "the aims of this project are two - fold : we aim firstly to demonstrate the applicability of learning techniques to two subsets of current astrophysical problems , and secondly to compare the advantages and disadvantages of each learning method considered .",
    "it is hoped that interdisciplinary investigations such as this will help further cooperation between those with domain - specific knowledge of astrophysical problems and those with a grasp of the theoretical foundations of machine learning techniques  a cooperation that is becoming increasingly important for the future of astrophysical research .",
    "this dissertation is divided into two parts : part i considers astrophysical modelling of orbiting satellites , and part ii considers the problem of photometric redshift estimation of quasars .",
    "within part i , chapter 2 deals with the fundamentals of orbital mechanics and the calculation of satellite position according to kepler s laws .",
    "chapter 3 discusses the genetic algorithm approach to this modelling problem , and chapter 4 compares this to an approach based on particle swarm optimisation .",
    "in part ii , chapter 5 presents the topic of redshift estimation of quasars .",
    "chapters 6 and 7 discuss artificial neural networks and radial basis function networks as techniques for redshift estimation and present analyses of the results , and chapter 8 is discussion .",
    "finally , by way of conclusion , chapter 9 elaborates on the implications of this research and on possible future directions .",
    "the galilean satellites of jupiter , so - called because of their discovery by galileo in 1610 , were some of the first subjects of astrophysical modelling .",
    "galileo could not directly observe the four moons orbits around the planet , but he observed their change in position around jupiter over the course of a month ( figure [ f : sidnunc ] ) . from these observations he was able to induce an elementary theory about what was causing the motions of the little ` stars '",
    ": they were actually orbiting around the major planet .",
    "this theory had implications that fit the observed evidence , and it was deemed to be the most likely explanation for the phenomenon .",
    "the problem undertaken here is , in principle , to determine all of the six orbital elements @xcite that precisely describe the orbit of a given satellite around jupiter , using only observations available from telescopes on earth . given the well defined keplerian theory of celestial mechanics , this problem is essentially one of function approximation in six dimensions . as such , it is similar in form to any other classical modelling problem in astrophysics , and demonstrates the applicability of learning techniques to the approximation of highly parametric models .",
    "more immediately , however , this solution of approximating celestial orbits can be used to study binary star systems , comets with highly eccentric orbits , and planetary star systems , as well as astrodynamical problems such as optical or lossy radar - based tracking of missiles and satellites .",
    "accurate ephemerides ( calculated positions of astronomical objects ) are available from the horizons system at nasa s jet propulsion laboratory .",
    "this system was used to simulate observations of jupiter and one of its moons from a ground - based optical telescope at oxford , england , over a period of 31 days , at intervals of 2 hours . for simplicity , observations were simulated during daylight as well as at night .",
    "the data provided were in the form of right ascension ( @xmath1 ) and declination ( @xmath2 ) coordinates  references to an astronomical coordinate system independent of the rotation of the earth @xcite .",
    "these two - dimensional coordinates essentially show the location of jupiter and one of its moons on an xy - plane , and , together with an arbitrary ) of the moon s orbit would vary linearly with distance .",
    "] distance , are sufficient to describe a satellite s orbit precisely over time .",
    "however , in order to save time and minimise computational rounding errors , we opted to use data describing the relative location of a moon to jupiter in three dimensions .",
    "while this is not just a simple geometric transformation of two - dimensional data into three - space ( it does contain more information per se ) , the techniques should be similarly effective on the 2-d data : they would simply take longer to converge in light of the additional ambiguity .",
    "we first used a test dataset with simple orbital elements to optimise the ga and pso parameters , and then we applied the techniques with these parameters to actual satellite ephemerides .",
    "six quantities @xcite are enough , using classical mechanics , to describe the orbit of a satellite around a major body :    1 .",
    "@xmath3 , _ semi - major axis _ ,",
    "half the length of the longest line that can be drawn across the orbital ellipse , 2 .",
    "@xmath4 , _ eccentricity _ , varying from 0 ( circular orbit ) to nearly 1 ( almost parabolic ) , 3 .",
    "@xmath5 , _ inclination _ , the angle at which the orbital plane is removed from the equatorial ( fundamental ) plane , 4 .",
    "@xmath6 , _ longitude of the ascending node _ , the angle at which the satellite ` ascends ' ( in a northerly direction ) across the equatorial plane measured anticlockwise from the reference direction ( @xmath7 , where @xmath8 ) when viewed from the north side of the major body , 5 .",
    "@xmath9 , _ argument of periapsis _ , the angle in the orbital plane between the ascending node and periapsis  the point at which the satellite is closest to the major body , and 6 .",
    "[ i : m0]@xmath10 , _ mean anomaly at epoch _ , , the _ time of periapsis passage_. @xmath10 can be derived from @xmath11 given the epoch , current time @xmath12 , current mean anomaly @xmath13 , and @xmath9 . ]",
    "roughly the angle the satellite has travelled about the centre of the major body at a predefined time _",
    ", measured anticlockwise from periapsis when viewed from the north .",
    "see figure [ f : orbitelem ] for an illustration of the angular elements . in the figure",
    ", true anomaly @xmath14 can be thought of as representing mean anomaly at a given time @xmath13 , although it is calculated according to .          the calculation of position in an orbit ( in terms of the orbital elements described in ",
    "[ s : orbitelem ] ) as a function of time is known as the kepler problem , as it requires the solution of kepler s equation @xcite : @xmath15 where @xmath16 is the _",
    "mean motion _ , , where the standard gravitational parameter @xmath17 , the gravitational constant times the mass of the major body .",
    "] @xmath18 is the time elapsed since the current epoch , @xmath19 is the _ eccentric anomaly _",
    "@xcite , another measure of progression in orbit , and @xmath10 and @xmath4 are as above .    beginning with hypothetical values of @xmath10 , @xmath16 , and @xmath18 that we want to test , we approximate @xmath19 ( as described below ) , and then solve for the _ true anomaly _ @xmath14 and _",
    "distance _ @xmath20 , simple polar coordinates representing the position of the satellite about the orbital plane :    [ e : nu - rho ] @xmath21 @xmath22    from @xmath14 and @xmath20 , a simple transformation into cartesian coordinates in 3-space  where the x - axis is aligned with the reference direction in the equatorial plane ( @xmath8 ) , the y - axis is positive at @xmath23 , and the z - axis is positive northwards  allows us to compare our calculation with our ` observational ' data .",
    "as we can not isolate the value of @xmath19 in kepler s equation ( it is ` transcendental ' in @xmath19 ) , we must use a numerical solution to approximate it .",
    "this we have done with nine iterations ( beginning with @xmath24 ) of @xmath25 .",
    "the inspiration for _ genetic algorithms _ ( gas ) comes from the biological processes of evolution and natural selection @xcite . in constructing a ga ,",
    "one first initialises a population of randomised _ organisms _ , each of which represents the set of parameters one wants to approximate .",
    "the population is then evolved through many generations wherein organisms are allowed to _ crossover _ with each other , thereby creating offspring organisms that take parameters from both parent organisms .    in each generation , given some definition of _ fitness _ , the healthier organisms are ( probabilistically ) more likely to survive , allowing the overall population to approach the desired characteristics .",
    "a fraction of organisms are _ mutated _ in each generation as well , to reduce the likelihood of convergence on a local ( rather than global ) minimum .",
    "a description of a standard ga is given in table [ t : gaalg ] .",
    "+      as gas are flexible and easily implemented , they provide a straight - forward solution to the modelling problem presented here .",
    "simple modification of the fitness function would allow us to encourage the ga to converge on some orbital elements more strictly than others , if desired ; additionally , incorporation of error margins into the fitness function would enable us to account for measurement errors and systematic deviations in our observational training data .",
    "stochastic elements in the ga induce a `` randomised , parallel beam search , '' @xcite which is important to keep in mind when approximating highly nonlinear functions .",
    "in particular , although the ga is not immune to the problem of local minima in the error function ( equivalent to local maxima in the fitness function ) , it avoids some types of local minima that afflict particle swarm optimisation ( see chapter [ c : pso ] ) , as its crossover behaviour tends to create hypotheses that are drastically different from those in the existing population .",
    "we also discuss some simple methods of parallelising gas (  [ ss : parallelising ] ) , for example , for use on high - performance computing clusters for terascale and larger astronomical applications .",
    "the ga was encoded for the relevant source . ] and parameterised as follows .",
    "an organism is simply a data structure representation of the six orbital elements described in  [ s : orbitelem ] .",
    "angular values are represented in radians , distance is represented in metres ( as a ` long long ` ) and ` long doubles ` are used whenever possible to minimise floating - point errors .",
    "initial values are selected uniformly at random from appropriate ranges , and population sizes from 100 to 100,000 are tested .",
    "crossover is handled more stochastically than in the canonical algorithmic implementation and is similar to a uniform crossover @xcite .",
    "first , from the pool of organisms that have been selected from the previous generation , two are chosen uniformly at random with replacement .",
    "a crossover probability @xmath26 in the interval @xmath27 $ ] is defined ( in our case as 0.25 ) , and two children organisms are created such that they are identical copies of their parents  except with the independent probability @xmath26 that any of their orbital elements have been swapped .",
    "that is , with probability @xmath26 , the two children have swapped their parents semi - major axis values , and with the same probability , they have swapped their parents inclination values , and so on .",
    "an overall mutation rate is defined ( for us , @xmath28 ) , and this percentage of organisms may be mutated after crossover . with another independent probability ( again @xmath29 ) , an individual orbital parameter",
    "is mutated : half of these are multiplied by a ` double ` selected uniformly from @xmath30 $ ] , and half of these are completely randomised , as at initialisation .",
    "this technique allows some values to be slightly adjusted after the population has begun to converge .",
    "also , note that the independent mutation rate for an individual parameter is @xmath31 , and the probability that one of the six parameters is changed is @xmath32 , a very high rate , which we have chosen in light of this problem s rapid convergence to local error minima and severe nonlinearities apparent in several dimensions .",
    "fitness of an organism is determined by calculating the estimated position of the satellite ( given its hypothetical orbital elements ) relative to jupiter at every time step @xmath33 for which there is an observational datum .",
    "the euclidean distance @xmath34 between the satellite s estimated position and its observed position is calculated : @xmath35 and the fitness of the organism is set to the inverse of this distance , @xmath36 , averaged over all time steps @xmath33 .",
    "thus , organisms that predict satellite positions closer to the relevant observations have higher fitness values , and all fitness values are in the set @xmath37 .      before crossover , a predefined percentage ( called the _ replacement _ or _ selection rate _ ) of organisms ( we use @xmath38 ) are probabilistically selected according to their fitness values ; specifically , an organism @xmath39 has probability @xmath40 of being selected to persist in the next generation @xcite , and this selection is repeated from the original population ( without replacement ) until @xmath41 elements have been chosen . note that , owing to the inverse linear relationship established for fitness in  [ ss : fitness ] , organisms with lower @xmath42 values are significantly more likely to be selected between generations , creating a greedier algorithm , as seen in table [ t : fitness ] .",
    ".fitnesses associated with declining @xmath42 values . [ cols=\">,^\",options=\"header \" , ]      +    looking at committee @xmath43 results , the rbfns with gaussian activations achieve consistently lower errors than those with tps activations over the @xmath44 and @xmath45 datasets .",
    "the opposite is true for the @xmath46 @xmath47 @xmath48 @xmath49 $ ] dataset , and comparable results are achieved with @xmath50 @xmath51 @xmath47 @xmath48 @xmath49 $ ] .",
    "curiously , over the @xmath46 @xmath47 @xmath48 @xmath52 @xmath53 @xmath54 @xmath55 $ ] dataset , gaussians yield significantly higher accuracies in 7:10:1 and 7:20:1 networks , but tps performs substantially better in 7:40:1 and 7:100:1 networks .",
    "in fact , the gaussian rbfns in the 7:100:1 networks produce outliers of sufficient magnitude to raise @xmath56 to 0.9940 , and one network failed to learn the data at all ( figure [ f : gauss100ugrizjhfail ] ) .",
    "the 5-committee for these networks , however , is seen to reduce rms~com~ to 0.8141 .",
    "( a 5-committee calculating the median instead of the mean over these networks outputs yielded an rms~com~ of 0.8263 ; some outliers  even @xmath57were consistently produced by committee members , as seen in figure [ f : gauss100ugrizjh ] . )     vs. @xmath58 for a 7:100:1 gaussian rbfn over @xmath46 @xmath47 @xmath48 @xmath52 @xmath53 @xmath54 @xmath55 $ ] .",
    "@xmath43 is only 1.0595not dissimilar to other networks in the same committee that converged but had large outliers.,width=476 ]     vs. @xmath59 for two individual 7:100:1 gaussian rbfns over @xmath46 @xmath47 @xmath48 @xmath52 @xmath53 @xmath54 @xmath55 $ ] .",
    "note the large outliers consistently predicted by both rbfns.,width=476 ]    all 80 rbfns produced failed to learn the @xmath60 dataset with its original training / test set distribution , which was left as - is .",
    "the tps rbfns with 100 hidden units ( see figure [ f : tps100ugriz6192 ] ) showed the most deviation from outputting only @xmath61 , and significantly more deviation than mlps showed in figure [ f : mlpugriz6192 ] .",
    "vs. @xmath58 for the 5-committee of 5:100:1 tps rbfns over @xmath60 .",
    "@xmath43 is 0.8441.,width=476 ]    finally , figures [ f : gauss100ugriz ] and [ f : tps100ugrizjh ] illustrate two rbfns that , while not as accurate as the anns of figures [ f : annzugriz1 ] and [ f : annzugrizjhk ] , are highly similar in form .",
    "this indicates that they suffer from the similar difficulties in learning and generalising on the @xmath45 data ; it also recalls their rough equivalence in representational capability .",
    "the general symmetry for mild outliers at @xmath62 $ ] about the line @xmath63 in figures [ f : tps100ugrizjh ] and [ f : annzugrizjhk ] brings more clearly to light the degeneracy suggested by richards et al .",
    "( 2001b ) @xcite and weinstein et al . ( 2004 ) @xcite : certain quasars are close matches for two or more redshifts , and the @xmath59-@xmath58 relation illustrates this confusion by plotting them symmetrically about @xmath63 .  [ s : czr ] discusses this degeneracy in detail .     vs. @xmath58 for the 5-committee of 5:100:1 gaussian rbfns over @xmath44 .",
    "@xmath43 is 0.5216.,width=476 ]     vs. @xmath58 for the 5-committee of 7:100:1 tps rbfns over @xmath46 @xmath47 @xmath48 @xmath52 @xmath53 @xmath54 @xmath55 $ ] .",
    "@xmath43 is 0.4014 , and 69.5% of objects are predicted to @xmath64.,width=476 ]",
    "in presenting a survey of network - based learning methods for photometric redshift estimation , we have done very little to minimise rms errors by way of parameter optimisation .",
    "still , we have achieved @xmath43 values of 0.3557 and 0.4014 with anns and rbfns , yielding @xmath65 values within 0.3 for 76.2% and 69.5% of quasars , respectively .",
    "these results are comparable to recent standard results in the literature ( @xcite , @xcite , @xcite , @xcite ) , but they do not compare to the latest results of ball et al .",
    "( to appear ) , who are able to select a subset of quasars whose redshifts may be estimated with significantly greater accuracy ( improving @xmath43 from 0.343 to 0.117 , and the percentage of quasars within @xmath66 from 79.8% to 99.3% . )",
    "@xcite .",
    "all published results suffer from the same systematic errors at certain values of @xmath58 , however .",
    "in fact , with hidden layers of up to 100 units , we were unable even to memorise our training sets after 3,000 training iterations : testing over our training sets yielded the same deviations and regions of catastrophic failure in our @xmath59-@xmath58 relation .",
    "this indicates some degeneracy inherent to the training sets ; i.e. , some sets of photometric magnitudes and colours correspond to multiple spectroscopic redshifts .      as discussed in  [ s : pre ] , the colour - redshift relation ( czr ) is of primary importance in estimating redshift from photometric measurements .",
    "figure [ f : gr01b ] @xcite plots the czr for the colours @xmath67 , @xmath68 , @xmath69 , and @xmath70 .",
    "richards et al .",
    "( 2001a ) describe in detail the features of the czr , and find that almost all of the structure can be attributed to emission lines moving in and out of the @xmath44 filter ranges at different redshifts @xcite .",
    "this is consistent with the observations of ball et al .",
    "( to appear ) who demonstrate that major deviations in the @xmath59-@xmath58 relation fall at redshifts where important emission lines cross sdss filter boundaries ( figure [ f : nb07b ] ) @xcite . transitions . ]",
    "-@xmath58 plots indicating where the five brightest emission lines cross @xmath44 filters . from ball et al .",
    "( to appear ) @xcite.,width=476 ]    further , as illustrated in figures [ f : gr01b ] and [ f : mw04 ] , there is significant degeneracy in the czr , indicating that it is impossible to predict redshift for all quasars as a function of four colours alone .",
    "note that higher - quality photometry will not solve the problem : while some level of photometric certainty is needed to approach the czr , recall from ",
    "[ ss : jacobian ] that we were able to deviate our inputs to an ann by the estimated photometric noise to find the resulting change @xmath71 in @xmath59 .",
    "as seen in figure [ f : annzugriz2 ] , photometric noise is not responsible for the majority of the error @xmath65 .",
    "therefore , as way & srivastava ( 2006 ) suggest for empirical reasons @xcite , photometry improvements alone will not overcome the czr degeneracy .        in order to break the degeneracy",
    ", we need additional input parameters .",
    "a demonstration of the improvement in accuracy were the degeneracy to be broken is shown in figure [ f : zsplit ] .",
    "if we had some way of segregating @xmath72 quasars , @xmath73 quasars , and @xmath74 quasars from each other ( say , by using non - photometric data or more specialised filters for detecting specific spectral lines as suggested in @xcite ) , a neural network training on this additional information might yield results around @xmath75 , with 97.4% of objects within @xmath64 .",
    "segregation at @xmath76 showed most of the usual systematic deviations ( figure [ f : zsplit2 ] ) , confirming that the major source of errors is a degeneracy in @xmath77 .",
    "vs. @xmath58 for three separate 5-committees of 4:10:1 mlps in netlab , trained on datasets segregated at @xmath78 and @xmath76 up to 500 iterations .",
    "@xmath43 is 0.1283 , and 97.4% of objects fall within @xmath64.,width=445 ]     vs. @xmath58 for two 5-committees of 4:10:1 mlps , segregated at @xmath76 .",
    "@xmath43 is 0.2857 , and 95.8% have @xmath64.,width=445 ]      other potential improvements to our methods could include the use of cross - variance to avoid overfitting a training set , or weighting in committees of networks @xcite .",
    "photometric redshift estimation has also been attempted using support vector machines ( svms ) ( @xcite and @xcite ) , gas @xcite , and random forests @xcite .",
    "we tested svms on our datasets using the svmtorch ii facility @xcite , but found higher errors in all tests . still , svms are attractive in that they can add extra input parameters with near - linear computational overhead @xcite and limited dilution of accuracy in the presence of irrelevant data with some svm algorithms @xcite .",
    "computational considerations should also be taken into account : hastie et al .",
    "( 2001 ) show that , for @xmath79 training data , @xmath80 input variables , @xmath81 weights , @xmath82 training iterations , @xmath13 basis functions , and @xmath83 support vectors , anns require @xmath84 operations @xcite , rbfns require @xmath85 @xcite , and svms tend to require @xmath86 @xcite .",
    "part i of this dissertation demonstrated that canonical machine learning techniques could be adapted to solve a non - trivial astrophysical problem with only minor modifications .",
    "the same techniques could be used in a reverse manner , to approximate the mechanical formulae governing the behaviour of an observed system with known physical parameters . alternatively , the problem solved could be generalised by using more precise , relativistic physical calculations to extend to the modelling of binary star systems and the search for other planetary star systems .",
    "another interesting extension would be to model simultaneously the orbits of several moons with gas and pso : in principle , not all moons would be visible within a certain window or from a certain point of view ( they would occasionally be obscured by or pass in front of the major planet ) , and the moons would not be ` labelled ' individually in each frame . ) to automatically determine the total number of moons and the orbital elements of each . ] still , a ga could begin to model the system by using a variable number of satellites ( represented in each organism ) equal to or greater than the maximum number of moons observed in any one frame , with the satellites ordered within the organism by their semi - major axis distance @xmath3 .",
    "crossover between two organisms with differing numbers of satellites could interact only those satellites whose @xmath3 values are most similar .",
    "mutation could also introduce or remove new satellites to an organism , and fitness could be measured at each time step by summing the minimum euclidean distances between estimated moon positions and observed locations , using the location of the major planet as a moon location if there are more satellites represented in the organism than observed in the frame .",
    "this would allow the inclusion of frames in which some moons are obscured , and would also penalise organisms that represented more satellites than were present in the physical system . for pso",
    ", multiple distinct swarms could be run simultaneously on the data , with some use of hyperspheres or hypercubes ( an enforced minimum distance ) in parameter space to prevent the swarms from converging on the same set of orbital elements .",
    "such an extension would require significantly greater computational resource , but this only recalls the growing need for more parallelisable and distributed algorithms for common problems in astrophysical research .",
    "part ii demonstrated that trivial applications of machine learning techniques can yield results comparable to the most advanced applications of traditional techniques in photometric redshift estimation .",
    "as mentioned in earlier chapters , the improvement of these learning techniques  for quasars in particular  will greatly assist research in cosmology @xcite and the large - scale structure of the universe @xcite .",
    "it would be useful to determine the relationship between photometric redshift accuracy and quasar magnitude , as the efficient estimation of faint quasar redshifts would assist in studying quasar evolution @xcite .",
    "it would also be interesting to investigate in more detail the statistical properties of the @xmath59-@xmath58 relation and the czr degeneracy .",
    "the impressive result of ball et al .",
    "( to appear ) @xcite in selecting quasars according to properties of their @xmath59 probability density functions indicates that there may well be more statistical learning techniques of use in solving the czr problem .",
    "improvements may also be made by calculating the jacobian matrix for rbfns as in  [ ss : jacobian ] and comparing its @xmath59 deviations @xmath71 with those obtained by ann__z _ _ , investigating the relationship between computational expense and @xmath65 error as regards partially unsupervised rbfns and ( fully supervised ) anns , incorporating x - ray and radio flux measurements , and experimenting with different activation functions and/or describing their distinct behaviours .",
    "however , aside from reducing @xmath65 error and ensuring predictable confidence intervals , as not all science applications require minimal redshift errors @xcite , serious consideration should also be given to the unsupervised learning properties of rbfns insofar as they may be of particular advantage in large sky survey science in the future .",
    ".... // mlastro.cpp    # include \" stdafx.h \" # include < stdlib.h > # include < iostream > # include < fstream > # include < string > # define _ use_math_defines # include < math.h > # include < vector > # include < time.h >    using namespace std ;    # include \" organism.h \" # include \" particle.h \"    const char * inputxyz = \" x:\\\\data\\\\2hatlasxyz.txt \" ; const double epoch = 2453006.0 ; //2451545 for j2000.0 ( himalia ) , 2450464.25 for 1997 jan 16.00 tt ( io ) , //2454600 for test , 2453006 for jan 1 04 ( atlas ) const bool log = true ; //to turn on or off logging of stdev for convergence const bool test = false ; //if using test set const bool taper = false ; //use tapered vmax for pso    class observ { public :      double time ;      vector < double > x ;      vector",
    "< double > y ;      vector < double > satpang ;      vector < char > visibility ; } ;    pair < double , double > keplerian(organism o , int sat , double timeindays ) {      pair < double , double > result ;      result.first=0 ;      result.second=0 ;         double timeelapsed = timeindays - epoch ; //in days from epoch      timeelapsed * = 86400 ; //now in seconds        double m ; //mean anomaly",
    "double n ; //mean motion , in radians / sec : this is an avg , for circular orbits           //unable to represent o.a[sat]^3 :      n = ( double)o.mu ;      n /= o.a[sat ] ;      n /= o.a[sat ] ;      n /= o.a[sat ] ;      n = sqrt(n ) ;      m = o.m0[sat ] + n*timeelapsed ;      //radians + ( radians / s)*s , from http://en.wikipedia.org/wiki/mean_anomaly        double e ; //eccentric anomaly      e = m ;      for ( int i=0;i<8;i++ ) {          e = m + o.e[sat]*sin(e ) ;          //from http://en.wikipedia.org/wiki/eccentric_anomaly      }        double nu ; //true anomaly , between -pi and pi      nu = atan(sqrt((1.+o.e[sat])/(1.-o.e[sat]))*tan(e/2.))*2 ;      if ( nu<0 ) nu + = 2*m_pi ;      //putting nu between 0 and 2*pi , for theta / phi calculations in keplerian ( )        double rho ; //distance from major body , in same units as a ( metres )      rho = o.a[sat]*((1.-pow(o.e[sat],2))/(1.+(o.e[sat]*cos(nu ) ) ) ) ;        result.first = rho/1000 . ; //this puts it in km for simplicity 's sake      result.second = nu ;        return result ; }    pair < pair < double , double>,double >    polartoxyz(organism o , int sat , pair < double , double > polar ) {      pair < double , double > xy ;      pair < pair < double , double>,double > result ;      double x = 0,y = 0,z = 0 ;           double rho , phi , theta , nu ;      rho = polar.first ;      nu = polar.second ;        double scaletheta , scalephi ;      scaletheta = cos(o.inclin[sat ] ) ;      scalephi = sin(o.inclin[sat ] ) ;        theta = scaletheta*(o.w[sat]+nu)+o.node[sat ] ; //should be 0 to 2*pi      phi = ( m_pi/2)-scalephi*(o.w[sat]+nu ) ; //should be 0 to 2*pi        //convert to xyz : in same units as rho ( metres , now km )      x = rho*sin(phi)*cos(theta ) ;      y = rho*sin(phi)*sin(theta ) ;      z = rho*cos(phi ) ;         xy.first = x ;      xy.second = y ;      result.first = xy ;      result.second = z ;        return result ;    }    void outputorganisms(vector < organism > & o ) {      ofstream orgs ;      orgs.open(\"x:\\\\data\\\\organisms.txt \" ) ;      char timestr[9 ] ;      _ strtime_s(timestr ) ;      orgs < < timestr < < endl < < endl ;      for ( unsigned int i=0;i < o.size();i++ ) {          orgs < < i+1 < < \" . \"",
    "< < o[i].satellites < < endl ;          orgs < < o[i].fitness < < endl ;          orgs < < o[i].a[0 ] < < \" , \" < < o[i].e[0 ] < < \" , \" < < o[i].inclin[0 ] < < endl ;          orgs",
    "< < o[i].node[0 ] < < \" , \" < < o[i].w[0 ] < < \" , \" < < o[i].m0[0 ] ;          orgs < < endl < < endl ;      }      orgs.close ( ) ; }    double rankfitnessxyz(vector < organism > & o , const int observations ) {      vector < pair < double , double > > x(observations),y(observations),z(observations ) ;      ifstream input ;      ofstream best ;      ofstream worst ;      string temp ;        input.open(inputxyz ) ;      while ( ! input.eof ( ) ) {          getline(input , temp ) ;          if ( temp.compare(\"$$soe\")==0 ) {              break ;          }      }      //file should be at eof or at $ $ soe here      int count = 0 ;      while ( ( ! input.eof())&&(input.peek()!='$ ' ) ) {          input > > x[count].first ;          if ( ! test ) getline(input , temp ) ;          input > > x[count].second > > y[count].second > > z[count].second ;          getline(input , temp ) ;          y[count].first = x[count].first ;          z[count].first = x[count].first ;          count++ ;      }      input.close ( ) ;      double timeindays ;      double bestfitness = 0 ;      double worstfitness = 1 ;      int b , w ;      char timestr[9 ] ;      for ( unsigned int i=0;i < o.size();i++ ) {          //iterating over all the organisms in the population          o[i].fitness = 0 ;          for ( int j=0;j <",
    "observations;j++ ) {                timeindays = x[j].first ;              pair < pair < double , double>,double >",
    "xyz=                polartoxyz(o[i],0,keplerian(o[i],0,timeindays ) ) ;              o[i].fitness + = pow(xyz.first.first - x[j].second,2 ) +                  pow(xyz.first.second - y[j].second,2 ) + pow(xyz.second - z[j].second,2 ) ;          }          o[i].fitness /= observations ; //to",
    "normalise          o[i].fitness = 1/o[i].fitness ;          if ( o[i].fitness > bestfitness ) {              bestfitness = o[i].fitness ;              b = i ;          }          if ( o[i].fitness < worstfitness ) {              worstfitness = o[i].fitness ;              w = i ;          }      }      _ strtime_s(timestr ) ;      ofstream genfitness ;      genfitness.open(\"x:\\\\data\\\\genfitness.txt \" , ios::app ) ;      genfitness.setf(ios::scientific ) ;      cout < < \" best fitness is \" < < bestfitness < < \" .\\t \" ;      if ( log ) genfitness < < bestfitness < < \" \\t \" ;      else genfitness < < \" best fitness is \" < < bestfitness < < \" .\\t \" ;      cout < < \" worst is \" < < worstfitness < < \" .\\t \" < < timestr < < endl ;      if ( log ) genfitness < < worstfitness < < \" \\t \" < < timestr < < \" \\t \" ;      else genfitness < < \" worst is \" < < worstfitness < < \" .\\t \" < < timestr < < endl ;      genfitness.close ( ) ;        best.open(\"x:\\\\data\\\\best.txt \" ) ;      worst.open(\"x:\\\\data\\\\worst.txt \" ) ;      best < < timestr < < endl < < \" best fitness = \" < < bestfitness < < endl ;      worst < < timestr < < endl < < \" worst fitness = \" < < worstfitness < < endl ;      //right now this only writes the first elements      best < < \" a:\\t \" < < o[b].a[0 ]",
    "< < \" \\ne:\\t \" < < o[b].e[0 ] < < \" \\ni:\\t \" ;      best < < o[b].inclin[0 ]",
    "< < \" \\nnode:\\t \" < < o[b].node[0 ] < < \" \\nw:\\t \" ;      best < < o[b].w[0 ] < < \" \\nm0:\\t \" < < o[b].m0[0 ] < < endl ;      worst < < \" a:\\t \" < < o[w].a[0 ] < < \" \\ne:\\t \" < < o[w].e[0 ] < < \" \\ni:\\t \" ;      worst < < o[w].inclin[0 ] < < \" \\nnode:\\t \" < < o[w].node[0 ] < < \" \\nw:\\t \" ;      worst < < o[w].w[0 ] < < \" \\nm0:\\t \" < < o[w].m0[0 ] < < endl ;      best.close ( ) ;      worst.close ( ) ;           return bestfitness ; }     pair < organism , organism > straightcrossover(organism o1 , organism o2 ) {      pair < organism , organism > o ;      o.first = o1 ;      o.second = o2 ;        double crossoverlevel = 0.25 ;        double ar , er , ir , noder , wr , m0r ; //these are randoms between 0 and 1      ar = ( double)rand()/32768 ;      er = ( double)rand()/32768 ;      ir = ( double)rand()/32768 ;      noder = ( double)rand()/32768 ;      wr = ( double)rand()/32768 ;      m0r = ( double)rand()/32768 ;        long long itemp ;      double dtemp ;        if ( ar < crossoverlevel ) {          itemp = o.first.a[0 ] ;          o.first.a[0 ] = o.second.a[0 ] ;          o.second.a[0 ] = itemp ;      }      else if ( er < crossoverlevel ) {          dtemp = o.first.e[0 ] ;          o.first.e[0 ] = o.second.e[0 ] ;          o.second.e[0 ] = dtemp ;      }      else if ( ir < crossoverlevel ) {          dtemp = o.first.e[0 ] ;          o.first.e[0 ] = o.second.e[0 ] ;          o.second.e[0 ] = dtemp ;      }      else if ( noder < crossoverlevel ) {          dtemp = o.first.inclin[0 ] ;          o.first.inclin[0 ] = o.second.inclin[0 ] ;          o.second.inclin[0 ] = dtemp ;      }      else if ( wr < crossoverlevel ) {          dtemp = o.first.node[0 ] ;          o.first.node[0 ] = o.second.node[0 ] ;          o.second.node[0 ] = dtemp ;      }      else if ( m0r < crossoverlevel ) {          dtemp = o.first.m0[0 ] ;          o.first.m0[0 ] = o.second.m0[0 ] ;          o.second.m0[0 ] = dtemp ;      }         return o ; }    void mutate(organism & o ) {      organism mutated ;      double mutatelevel = 0.15 ;      mutated.create(o.satellites ) ;      double ar , er , ir , noder , wr , m0r ; //these are randoms between 0 and 1      ar = ( double)rand()/32768 ;      er = ( double)rand()/32768 ;      ir = ( double)rand()/32768 ;      noder = ( double)rand()/32768 ;      wr = ( double)rand()/32768 ;      m0r = ( double)rand()/32768 ;        double mutatepercent ;      mutatepercent = ( double)rand()/32768/2 - 0.25 + 1 ;      //between -.25 + 1 and .25 + 1 = .75 and 1.25        if ( ar < mutatelevel ) o.a[0 ] * = mutatepercent ;      //a does n't have strict bounds ( besides > 0 )      if ( er < mutatelevel ) {          o.e[0 ] * = mutatepercent ;          while ( o.e[0]>=1 ) o.e[0]-- ;      }      if ( ir < mutatelevel ) {          o.inclin[0 ] * = mutatepercent ;          while ( o.inclin[0]>=2*m_pi ) o.inclin[0 ] -= 2*m_pi ;      }      if ( noder < mutatelevel ) {          o.node[0 ] * = mutatepercent ;          while ( o.node[0]>=2*m_pi ) o.node[0 ] -= 2*m_pi ;      }      if ( wr < mutatelevel ) {          o.w[0 ] * = mutatepercent ;          while ( o.w[0]>=2*m_pi ) o.w[0 ] -= 2*m_pi ;      }      if ( m0r < mutatelevel ) {          o.m0[0 ] * = mutatepercent ;          while ( o.m0[0]>=2*m_pi ) o.m0[0 ] -= 2*m_pi ;      }        if ( ar < mutatelevel/2 ) o.a[0 ] = mutated.a[0 ] ;      if ( er < mutatelevel/2 ) o.e[0 ] = mutated.e[0 ] ;      if ( ir < mutatelevel/2 ) o.inclin[0 ] = mutated.inclin[0 ] ;      if ( noder < mutatelevel/2 ) o.node[0 ] = mutated.node[0 ] ;      if ( wr < mutatelevel/2 ) o.w[0 ] = mutated.w[0 ] ;      if ( m0r < mutatelevel/2 ) o.m0[0 ] = mutated.m0[0 ] ;    }     pair < double , double > keplerian(particle p , double timeindays ) {      pair < double , double > result ;      result.first=0 ;      result.second=0 ;        double timeelapsed = timeindays - epoch ; //in days from epoch      timeelapsed * = 86400 ; //now in seconds        double m ; //mean anomaly      double n ; //mean motion , in radians / sec        //unable to represent p.a^3 :      n = ( double)p.mu ;      n /= p.a ;      n /= p.a ;      n /= p.a ;      n = sqrt(n ) ;      m = p.m0 + n*timeelapsed ;      //radians + ( radians / s)*s , from http://en.wikipedia.org/wiki/mean_anomaly        double e ; //eccentric anomaly      e = m ;        for ( int i=0;i<8;i++ ) {          e = m + p.e*sin(e ) ;          //from http://en.wikipedia.org/wiki/eccentric_anomaly      }         double nu ; //true anomaly , between -pi and pi      nu = atan(sqrt((1.+p.e)/(1.-p.e))*tan(e/2.))*2 ;      if ( nu<0 ) nu + = 2*m_pi ;      //putting nu between 0 and 2*pi , for theta / phi calculations in keplerian ( )         double rho ; //distance from major body , in same units as a ( metres )      rho = p.a*((1.-pow(p.e,2))/(1.+(p.e*cos(nu ) ) ) ) ;         result.first = rho/1000 . ; //this puts it in km for simplicity 's sake      result.second = nu ;        return result ; } pair < pair < double , double>,double >    polartoxyz(particle p , pair < double , double > polar ) {      pair < double , double > xy ;      pair < pair < double , double>,double > result ;      double x = 0,y = 0,z = 0 ;           double rho , phi , theta , nu ;      rho = polar.first ;      nu = polar.second ;        double scaletheta , scalephi ;      scaletheta = cos(p.inclin ) ;      scalephi = sin(p.inclin ) ;        theta = scaletheta*(p.w+nu)+p.node ; //should be 0 to 2*pi      phi = ( m_pi/2)-scalephi*(p.w+nu ) ; //should be 0 to 2*pi        //convert to xyz : in same units as rho ( km )      x = rho*sin(phi)*cos(theta ) ;      y = rho*sin(phi)*sin(theta ) ;      z = rho*cos(phi ) ;         xy.first = x ;      xy.second = y ;      result.first = xy ;      result.second = z ;        return result ;    } void outputswarm(vector < particle > & p ) {      ofstream swarm ;      swarm.open(\"x:\\\\data\\\\swarm.txt \" ) ;      char timestr[9 ] ;      _ strtime_s(timestr ) ;      swarm < < timestr < < endl < < endl ;      for ( unsigned int i=0;i <",
    "p.size();i++ ) {          swarm < < i+1 < < endl ;          swarm < < p[i].fitness < < endl ;          swarm < < p[i].a < < \" , \" < < p[i].e < < \" , \" < < p[i].inclin < < endl < < p[i].node ;          swarm < < \" , \" < < p[i].w < < \" , \" < < p[i].m0 < < endl < < endl ;      }      swarm.close ( ) ; } particle rankfitnessxyz(vector < particle > & p ,    const int observations , particle & pbest ) {      vector < pair < double , double > >",
    "x(observations),y(observations),z(observations ) ;      ifstream input ;      ofstream best ;      ofstream worst ;      string temp ;        input.open(inputxyz ) ;      while ( ! input.eof ( ) ) {          getline(input , temp ) ;          if ( temp.compare(\"$$soe\")==0 ) {              break ;          }      }      //file should be at eof or at $ $ soe here      int count = 0 ;      while ( ( ! input.eof())&&(input.peek()!='$ ' ) ) {          input > > x[count].first ;          if ( ! test ) getline(input , temp ) ;          input > > x[count].second > > y[count].second > > z[count].second ;          getline(input , temp ) ;          y[count].first = x[count].first ;          z[count].first = x[count].first ;          count++ ;      }      input.close ( ) ;      double timeindays ;      double bestfitness = 0 ;      double worstfitness = 1 ;      int b , w ;      char timestr[9 ] ;      for ( unsigned int i=0;i <",
    "p.size();i++ ) {      //iterating over all the particles in the swarm          p[i].fitness = 0 ;          for ( int j=0;j < observations;j++ ) {              timeindays = x[j].first ;              pair < pair < double , double>,double > xyz =                polartoxyz(p[i],keplerian(p[i],timeindays ) ) ;              p[i].fitness + = pow(xyz.first.first - x[j].second,2 )                  + pow(xyz.first.second - y[j].second,2 ) + pow(xyz.second - z[j].second,2 ) ;          }          p[i].fitness /= observations ;          p[i].fitness = 1/p[i].fitness ;          if ( p[i].fitness > bestfitness ) {              bestfitness = p[i].fitness ;              b = i ;          }          if ( p[i].fitness < worstfitness ) {              worstfitness = p[i].fitness ;              w = i ;          }      }      if ( bestfitness > pbest.fitness ) pbest = p[b ] ;      _ strtime_s(timestr ) ;      ofstream genfitness ;      if ( log ) {          genfitness.open(\"x:\\\\data\\\\genfitness.txt \" , ios::app ) ;          genfitness.setf(ios::scientific ) ;          genfitness < < bestfitness < < \" \\t \" ;          genfitness < < worstfitness < < \" \\t \" < < timestr < < \" \\t \" ;          genfitness.close ( ) ;      }        cout < < \" best fitness is \" < < bestfitness < < \" .\\t \" ;      cout < < \" worst is \" < < worstfitness < < \" .\\t \" < < timestr < < endl ;      best.open(\"x:\\\\data\\\\best.txt \" ) ;      worst.open(\"x:\\\\data\\\\worst.txt \" ) ;      best < < timestr < < endl < < \" best fitness = \" < < bestfitness < < endl ;      worst < < timestr < < endl < < \" worst fitness = \" < < worstfitness < < endl ;      best < <",
    "\" a:\\t \" < < p[b].a < < \" \\ne:\\t \" < < p[b].e < < \" \\ni:\\t \" ;      best < < p[b].inclin",
    "< < \" \\nnode:\\t \" < < p[b].node < < \" \\nw:\\t \" ;      best < < p[b].w",
    "< < \" \\nm0:\\t \" < < p[b].m0 < < endl ;      worst < < \" a:\\t \" < < p[w].a < < \" \\ne:\\t \" < < p[w].e < < \" \\ni:\\t \" ;      worst < < p[w].inclin < < \" \\nnode:\\t \" < < p[w].node < < \" \\nw:\\t \" ;      worst < < p[w].w < < \" \\nm0:\\t \" < < p[w].m0 < < endl ;           best < < endl < < \" best so far = \" < < pbest.fitness < < endl ;      best < < \" a:\\t \" < < pbest.a < < \" \\ne:\\t \" < < pbest.e < < \" \\ni:\\t \" ;      best < < pbest.inclin < < \" \\nnode:\\t \" < < pbest.node < < \" \\nw:\\t \" ;      best < < pbest.w",
    "< < \" \\nm0:\\t \" < < pbest.m0 < < endl ;        best.close ( ) ;      worst.close ( ) ;           return p[b ] ; //to aid selection process } int",
    "_ tmain(int argc , _ tchar * argv [ ] ) {        const int maxobservations = 31 * 12 + 1 ;      //42 for abbrev data sets , 51 for test , 31 * 12 + 1 for 2h sets      const int popsize = 100 ;        const double replacementrate = 0.7 ;      const double mutationrate = 0.15 ;      const int generations = 3000000 ;        const bool usepso = false ; //else use ga        int maxsatellites = 1 ;      //in a multiple - satellite implementation , this should be at least the length        //of the longest x / y vector        double bestfitness ;      particle pbest , lbest ;      int j ;        ofstream genfitness ;      //genfitness.open(\"x:\\\\data\\\\genfitness.txt \" ) ;      //genfitness.close ( ) ; //clears file contents        //creates a vector of _ observ _ 's of size _ maxobservations _",
    "vector < observ > data(maxobservations ) ;      cout.setf(ios::scientific ) ; //or fixed      srand((int)time(0 ) ) ; //randomise        vector < organism >",
    "pop(popsize ) ;      vector < particle >",
    "swarm(popsize ) ;          if ( usepso ) {          cout < < \" swarm of \" < < popsize < < \" created.\\n \" ;          for ( int i=0;i < popsize;i++ ) swarm[i].create ( ) ;          cout < < \" swarm initialised.\\n \" ;      }      else {          cout < < \" organisms created.\\n \" ;          for ( unsigned int i=0;i < popsize;i++ ) pop[i].create(maxsatellites ) ;          cout < < \" organisms initialised.\\n \" ;      }         pair < double , double > result ;      if ( usepso ) result = keplerian(swarm[0],2454600 ) ;      else result = keplerian(pop[0],0,2454600 ) ;        cout<<\"r : \" < < result.first<<endl<<\"v : \" < < result.second<<endl ;        pair < pair < double , double>,double > xyz ;      if ( usepso ) xyz = polartoxyz(swarm[0],result ) ;      else xyz = polartoxyz(pop[0],0,result ) ;      cout<<\"x : \" < < xyz.first.first<<endl ;      cout<<\"y : \" < < xyz.first.second<<endl ;      cout<<\"z : \" < < xyz.second<<endl ;        if ( usepso ) {          j = 0 ;          while ( j < generations ) { //and error criteria              cout < < j+1 < < \" . \" ;              if ( log ) {                  genfitness.open(\"x:\\\\data\\\\genfitness.txt \" , ios::app ) ;                  genfitness < < j+1 < < \" \\t \" ;                  genfitness.close ( ) ;              }              lbest = rankfitnessxyz(swarm , data.size ( ) , pbest ) ;                if ( log ) {                  genfitness.open(\"x:\\\\data\\\\genfitness.txt \" , ios::app ) ;                  genfitness.setf(ios::scientific ) ;                    double meanfitness = 0 . ;                  for ( unsigned int i=0;i <",
    "swarm.size();i++ ) {                      meanfitness + = swarm[i].fitness ;                  }                  meanfitness /=",
    "swarm.size ( ) ;                  //this is now the correct value of 1/meanfitness                       double stdev = 0.0 ;                  for ( unsigned int i=0;i <",
    "swarm.size();i++ ) {                      stdev + = pow(meanfitness - swarm[i].fitness,2 ) ;                  }                  stdev /= swarm.size ( ) ;                  stdev = sqrt(stdev ) ;                       genfitness < < meanfitness < < \" \\t \" < < stdev < < \" \\n \" ;                  //file now reads generation[\\t]bestfitness[\\t]worstfitness[\\t ]                    //time[\\t]meanfitness[\\t]stdev[\\n ]                  genfitness.close ( ) ;              }                outputswarm(swarm ) ;              for ( unsigned int i=0;i < swarm.size();i++ ) {                  swarm[i].update(pbest , lbest ) ;              }              //tapered vmax enforcement              if ( taper ) {                  if ( j==5000 ) for ( unsigned int i=0;i < swarm.size();i++ ) {                      swarm[i].newvmax(1.0 ) ;                  }                  else if ( j==10000 ) for ( unsigned int i=0;i < swarm.size();i++ ) {                      swarm[i].newvmax(0.75 ) ;                  }                  else if ( j==15000 ) for ( unsigned int i=0;i < swarm.size();i++ ) {                      swarm[i].newvmax(0.5 ) ;                  }                  else if ( j==20000 ) for ( unsigned int i=0;i < swarm.size();i++ ) {                      swarm[i].newvmax(0.25 ) ;                  }                  else if ( j==25000 ) for ( unsigned int i=0;i < swarm.size();i++ ) {                      swarm[i].newvmax(0.1 ) ;                  }                  else if ( j==30000 ) for ( unsigned int i=0;i < swarm.size();i++ ) {                      swarm[i].newvmax(0.05 ) ;                  }              }              j++ ;          }      }      else for ( j=0;j < generations;j++ ) { //begin ga loop          genfitness.open(\"x:\\\\data\\\\genfitness.txt \" , ios::app ) ;          cout <",
    "< j+1 < < \" . \" ;          if ( log ) genfitness < < j+1 < < \" \\t \" ;          else genfitness < < j+1 < < \" . \" ; //inserts generation count , e.g. , \" 1 . \"          genfitness.close ( ) ;            //get fitness of all organisms by measuring sse of xyz coords          bestfitness = rankfitnessxyz(pop , data.size ( ) ) ;          double totalfitness = 0 . ;          double probability ;          double selectrand ;          double mutaterand ;          int numselected = 0 ;               outputorganisms(pop ) ;            //evolve : select , crossover , mutate , update , then re - evaluate fitness          //select :          for ( unsigned int i=0;i <",
    "pop.size();i++ ) {                totalfitness+=pop[i].fitness ;              pop[i].selected = false ;          }            do { //new roulette wheel selection method              selectrand = ( ( double)rand()/32768)*totalfitness ;              for ( unsigned int i=0;i <",
    "pop.size();i++ ) {                  //probability = pop[i].fitness / totalfitness ;                  if ( ! pop[i].selected ) {                      selectrand -= pop[i].fitness ;                      if ( selectrand < = 0 ) {                          pop[i].selected = true ;                          numselected++ ;                          totalfitness -= pop[i].fitness ;                          //exclude this organism from future roulette selections                          break ;                      }                  }              }          } while ( numselected < replacementrate*pop.size ( ) ) ;          int numtocross = pop.size ( ) - numselected ; //numtocross must be even               //copy",
    "selected          vector < organism > popnew ;          for ( unsigned int i=0;i < pop.size();i++ ) {              if ( pop[i].selected ) popnew.push_back(pop[i ] ) ;          }    //at this point , popnew contains only selected orgs , not crossed - over ones //this is where we output to genfitness the stdev and mean of fitness          if ( log ) {              genfitness.open(\"x:\\\\data\\\\genfitness.txt \" , ios::app ) ;              genfitness.setf(ios::scientific ) ;                double meanfitness = 0 . ;              for ( unsigned int i=0;i <",
    "popnew.size();i++ ) {                  meanfitness + = popnew[i].fitness ;              }              meanfitness /= popnew.size ( ) ;              //this is now the correct value of 1/meanfitness                double stdev = 0.0 ;              for ( unsigned int i=0;i <",
    "popnew.size();i++ ) {                  stdev + = pow(meanfitness - popnew[i].fitness,2 ) ;              }              stdev /= popnew.size ( ) ;              stdev = sqrt(stdev ) ;",
    "genfitness < < meanfitness < < \" \\t \" < < stdev < < \" \\t \" ;              //file now reads generation[\\t]bestfitness[\\t]worstfitness[\\t ]                //time[\\t]meanfitness[\\t]stdev[\\t ]              genfitness.close ( ) ;          }            //crossover in popnew :          for ( int i=0;i <",
    "numtocross/2;i++ ) {              int t1,t2 ;              t1 = rand ( ) % numselected ;              //we use numselected",
    "so we 're only crossing over old organisms              t2 = rand ( ) % numselected ;              pair < organism , organism > neworg = straightcrossover(popnew[t1],popnew[t2 ] ) ;              popnew.push_back(neworg.first ) ;              popnew.push_back(neworg.second ) ;          }            //mutate in popnew :          for ( unsigned int i=0;i <",
    "popnew.size();i++ ) {              mutaterand = ( double)rand()/32768 ;              if ( mutaterand < mutationrate ) mutate(popnew[i ] ) ;          }    //here output to genfit the std , mean of fitness of the entire crossed - over pop .",
    "if ( log ) {              genfitness.open(\"x:\\\\data\\\\genfitness.txt \" , ios::app ) ;              genfitness.setf(ios::scientific ) ;                double meanfitness = 0 . ;              for ( unsigned int i=0;i < popnew.size();i++ ) {                  meanfitness + = popnew[i].fitness ;              }              meanfitness /= popnew.size ( ) ;              //this is now the correct value of 1/meanfitness                double stdev = 0.0 ;              for ( unsigned int i=0;i <",
    "popnew.size();i++ ) {                  stdev + = pow(meanfitness - popnew[i].fitness,2 ) ;              }              stdev /= popnew.size ( ) ;              stdev = sqrt(stdev ) ;                genfitness < < meanfitness < < \" \\t \" < < stdev < < endl ;              //file now reads generation[\\t]bestfitness[\\t]worstfitness[\\t]time[\\t ]                  //meanfitnessselected[\\t]stdevselected[\\t]meanfitnessall[\\t]stdevall[\\n ]              genfitness.close ( ) ;          }            //update population :          pop = popnew ;             } //end",
    "loop      //return organism with highest fitness         return 0 ; } ....      .... //",
    "organism.h    class organism { public :      organism ( ) ;      double fitness ;      bool selected ;      void create(int ) ;      int satellites ;      static const unsigned long long mu = 37931187000000000 ;      //standard g for jupiter ( 126686534000000000 ) in m^3/s^2      //test = 330531054456064      //saturn = 37931187000000000      //note that orbital period p = ( 2*pi)/sqrt(mu)*a^(3/2 ) ( in seconds )        long long a[1 ] ;      double e[1],inclin[1],node[1],w[1],m0[1 ] ; } ;    organism::organism ( ) {      fitness = -1 . ;      satellites = 0 ; }    void organism::create(int maxsize ) { //create random organism      satellites = rand ( ) % maxsize + 1 ;      double period ;      for ( int i=0;i < satellites;i++ ) {          a[0 ] = ( ( ( long long)rand()+1)*8000 ) ;          //io : 25000 , himalia : 700000 , test : 6000 , atlas : 8000          //a should be on the order of 421,800,000 for io 's orbit",
    ".          //a should be on the order of 11,461,000,000 for himalia 's orbit .",
    "e[0 ] = ( ( double)rand()/32768 ) ; //e should be between 0 and 1          inclin[0 ] = ( ( double)rand()/32768 * 2*m_pi ) ;          node[0 ] = ( ( double)rand()/32768 * 2*m_pi ) ;          w[0 ] = ( ( double)rand()/32768 * 2*m_pi ) ;          m0[0 ] = ( ( double)rand()/32768 * 2*m_pi ) ;        } } ....      .... // particle.h    class particle { public :      double c1 , c2 ; //learning factors      double vmax ; //set vmax below      double evmax ; //eccentricity maximum velocity      particle ( ) ;      void create ( ) ;      double fitness ;      static const unsigned long long mu = 37931187000000000 ;      //standard g for jupiter ( 126686534000000000 ) in m^3/s^2      //test = 330531054456064      //saturn = 37931187000000000           long long a ; //a could be unsigned as well      double e , inclin , node , w , m0 ;        long long av ;      double ev , iv , nv , wv , m0v ;        void update(particle , particle ) ;      void newvmax(double ) ; } ;    particle::particle ( ) {      vmax = 1.0 ;      evmax = 0.1 ;           fitness = -1 . ;",
    "c1 = 2 . ;      c2 = 2 . ;        //particle positions      a = 0 ;      e = 0 . ;      inclin = 0 . ;      node = 0 . ;      w = 0 . ;      m0 = 0 .",
    ";        //particle velocities      av = 0 ;      ev = 0 . ;      iv = 0 . ;      nv = 0 . ;      wv = 0 . ;      m0v = 0 . ; }    void particle::create ( ) {      a = ( ( long long)rand()+1)*8000 ;      e = ( double)rand()/32768 ;      inclin = ( double)rand()/32768 * 2*m_pi ;      node = ( double)rand()/32768 * 2*m_pi ;",
    "w = ( double)rand()/32768 * 2*m_pi ;      m0 = ( double)rand()/32768 * 2*m_pi ; }    void particle::update(particle pbest , particle lbest ) {        double delta[8 ] ;      delta[0 ] = pbest.inclin - inclin ;      delta[1 ] = lbest.inclin - inclin ;      delta[2 ] = pbest.node - node ;      delta[3 ] = lbest.node - node ;      delta[4 ] = pbest.w - w ;      delta[5 ] = lbest.w - w ;      delta[6 ] = pbest.m0 - m0 ;      delta[7 ] = lbest.m0 - m0 ;        for ( int i=0;i<8;i++ ) {          if ( delta[i]>m_pi ) delta[i ] -= 2*m_pi ;          if ( delta[i]<(-1.*m_pi ) ) delta[i ] + = 2*m_pi ;      }           //this moves the particles randomly - > one parameter but maybe not another      /*av + = c1*((double)rand()/32768)*((double)(pbest.a - a ) )          + c2*((double)rand()/32768)*((double)(lbest.a - a ) ) ;      ev + = c1*((double)rand()/32768)*(pbest.e - e )          + c2*((double)rand()/32768)*(lbest.e - e ) ;      iv + = c1*((double)rand()/32768)*delta[0 ]          + c2*((double)rand()/32768)*delta[1 ] ;      nv + = c1*((double)rand()/32768)*delta[2 ]          + c2*((double)rand()/32768)*delta[3 ] ;      wv + = c1*((double)rand()/32768)*delta[4 ]          + c2*((double)rand()/32768)*delta[5 ] ;      m0v + = c1*((double)rand()/32768)*delta[6 ]          + c2*((double)rand()/32768)*delta[7];*/        //this treats the entire vector as one : particles move towards best values        //across all parameters simultaneously      double rand1 , rand2 ;      rand1 = ( double)rand()/32768 ;      rand2 = ( double)rand()/32768 ;      av + = c1*rand1*((double)(pbest.a - a ) ) + c2*rand2*((double)(lbest.a - a ) ) ;      ev + = c1*rand1*(pbest.e - e ) + c2*rand2*(lbest.e - e ) ;      iv + = c1*rand1*delta[0 ] + c2*rand2*delta[1 ] ;      nv + = c1*rand1*delta[2 ] + c2*rand2*delta[3 ] ;      wv + = c1*rand1*delta[4 ] + c2*rand2*delta[5 ] ;      m0v + = c1*rand1*delta[6 ] + c2*rand2*delta[7 ] ;        ev = min(ev,(double)evmax ) ;      ev = max(ev,(double)(evmax*(-1 ) ) ) ;      iv = min(iv,(double)vmax ) ;      iv = max(iv,(double)(vmax*(-1 ) ) ) ;      nv = min(nv,(double)vmax ) ;      nv = max(nv,(double)(vmax*(-1 ) ) ) ;      wv = min(wv,(double)vmax ) ;      wv = max(wv,(double)(vmax*(-1 ) ) ) ;      m0v = min(m0v,(double)vmax ) ;      m0v = max(m0v,(double)(vmax*(-1 ) ) ) ;         a + = av ;      a = max(a,(long long)1 ) ;           e + = ev ;      e = min(e,0.999999 ) ;      e = max(e,0 . )",
    ";        inclin + = iv ;      while ( inclin > = 2*m_pi ) inclin -= 2*m_pi ;      while ( inclin < 0 ) inclin + = 2*m_pi ;           node + = nv ;      while ( node > = 2*m_pi ) node -= 2*m_pi ;      while ( node < 0 ) node + = 2*m_pi ;           w + = wv ;      while ( w > = 2*m_pi ) w -= 2*m_pi ;      while ( w < 0 ) w + = 2*m_pi ;           m0 + = m0v ;      while ( m0 > = 2*m_pi ) m0 -= 2*m_pi ;      while ( m0 < 0 ) m0 + = 2*m_pi ; }    void particle::newvmax(double newv ) {      vmax = newv ; } ....",
    "rmse = 0 ; del1 = 0 ; del2 = 0 ; del3 = 0 ; for i = 1:count      rmse = rmse + data(i,4 ) ;      if data(i,4 ) < = .01 , del1 = del1 + 1 ; end ;      if data(i,4 ) < = .04 , del2 = del2 + 1 ; end ;",
    "if data(i,4 ) < = .09 , del3 = del3 + 1 ; end ; end ;              figure('position ' , [ 20 540 560 420 ] ) ; a = plot(data(:,1),data(:,2),'o','markersize',2);line([0 6],[0 6],'color','r ' ) ; figure('position ' , [ 620 60 560 420 ] ) ; b = plot(data(:,1),data(:,3),'o','markersize',2 ) ; figure('position ' , [ 20 60 560 420 ] ) ; c = plot(data(:,1),abs(data(:,2)-data(:,1)),'o','markersize',2 ) ; ....          [ x4,t4 ] = datread('x:\\quasartrain - ugri.dat',4,1,37136 ) ; [ x4t , t4 t ] = datread('x:\\quasartest - ugri.dat',4,1,9284 ) ; [ x5,t5 ] = datread('x:\\quasartrain - ugriz.dat',5,1,37136 ) ; [ x5t , t5 t ] = datread('x:\\quasartest - ugriz.dat',5,1,9284 ) ; [ x6,t6 ] = datread('x:\\quasartrain - ugriz6192.dat',5,1,4954 ) ; [ x6t , t6 t ] = datread('x:\\quasartest - ugriz6192.dat',5,1,1238 ) ;    [ x7,t7 ] = datread('x:\\quasartrain - ugrizjh.dat',7,1,4954 ) ; [ x7t , t7 t ] = datread('x:\\quasartest - ugrizjh.dat',7,1,1238 ) ; [ x8,t8 ] = datread('x:\\quasartrain - ugrizjhk.dat',8,1,4954 ) ; [ x8t , t8 t ] = datread('x:\\quasartest - ugrizjhk.dat',8,1,1238 ) ;      [ x01,t01 ] = datread('x:\\trainz01.dat',4,1,10159 ) ; [ x01t , t01 t ] = datread('x:\\testz01.dat',4,1,2540 ) ; [ x12,t12 ] = datread('x:\\trainz12.dat',4,1,19166 ) ; [ x12t , t12 t ] = datread('x:\\testz12.dat',4,1,4792 ) ; [ x2,t2 ] = datread('x:\\trainz2.dat',4,1,7810 ) ; [ x2t , t2 t ] = datread('x:\\testz2.dat',4,1,1953 ) ; [ x02,t02 ] = datread('x:\\trainz02.dat',4,1,29325 ) ; [ x02t , t02 t ] = datread('x:\\testz02.dat',4,1,7332 ) ;    trainx = { x4 , x5 , x6 , x7 , x8 , x9 , x01 , x12 , x2 , x02 } ; traint = { t4 , t5 , t6 , t7 , t8 , t9 , t01 , t12 , t2 , t02 } ; testx = { x4 t , x5 t , x6 t , x7 t , x8 t , x9 t , x01 t , x12 t , x2 t , x02 t } ; testt = { t4 t , t5 t , t6 t , t7 t , t8 t , t9 t , t01 t , t12 t , t2 t , t02 t } ;          if skipactive==0      for j = 1:size(mlps,2 )          mlps{1,j } = mlp(4 , nhidden , nout , act ) ;          mlps{2,j } = mlp(5 , nhidden , nout , act ) ;          mlps{3,j } = mlp(5 , nhidden , nout , act ) ;          mlps{4,j } = mlp(7 , nhidden , nout , act ) ;          mlps{5,j } = mlp(8 , nhidden , nout , act ) ;          mlps{6,j } = mlp(9 , nhidden , nout , act ) ;          mlps{7,j } = mlp(4 , nhidden , nout , act ) ;          mlps{8,j } = mlp(4 , nhidden , nout , act ) ;          mlps{9,j } = mlp(4 , nhidden , nout , act ) ;          mlps{10,j } = mlp(4 , nhidden , nout , act ) ;      end ; end ;              y{i , j } = mlpfwd(mlps{i , j } , testx{i } ) ;          rms(i , j ) = sqrt(mean((y{i , j}-testt{i}).*(y{i , j}-testt{i } ) ) ) ;          fprintf(1 , ' mlp % d , member % d finished.\\n ' , i , j ) ;      end ;      comoutput{i } = 0 ;      for j = 1:comsize , comoutput{i } = comoutput{i } + y{i , j } ; end ;      comoutput{i } = comoutput{i } / comsize ;      comrms(i)=sqrt(mean((comoutput{i}-testt{i}).*(comoutput{i}-testt{i } ) ) ) ;      meanrms(i ) = mean(rms(i,1:size(mlps,2 ) ) ) ;      fprintf(1 , ' finished with mlp committee % d.\\n ' , i ) ; end ;            [ x4,t4 ] = datread('x:\\quasartrain - ugri.dat',4,1,37136 ) ; [ x4t , t4 t ] = datread('x:\\quasartest - ugri.dat',4,1,9284 ) ; [ x5,t5 ] = datread('x:\\quasartrain - ugriz.dat',5,1,37136 ) ; [ x5t , t5 t ] = datread('x:\\quasartest - ugriz.dat',5,1,9284 ) ; [ x6,t6 ] = datread('x:\\quasartrain - ugriz6192.dat',5,1,4954 ) ; [ x6t , t6 t ] = datread('x:\\quasartest - ugriz6192.dat',5,1,1238 ) ;    [ x7,t7 ] = datread('x:\\quasartrain - ugrizjh.dat',7,1,4954 ) ; [ x7t , t7 t ] = datread('x:\\quasartest - ugrizjh.dat',7,1,1238 ) ; [ x8,t8 ] = datread('x:\\quasartrain - ugrizjhk.dat',8,1,4954 ) ; [ x8t , t8 t ] = datread('x:\\quasartest - ugrizjhk.dat',8,1,1238 ) ;              if skipactive==0      for j = 1:size(rbfs,2 )          rbfs{1,j } = rbf(4 , nhidden , nout , act ) ;          rbfs{2,j } = rbf(5 , nhidden , nout , act ) ;          rbfs{3,j } = rbf(5 , nhidden , nout , act ) ;          rbfs{4,j } = rbf(7 , nhidden , nout , act ) ;          rbfs{5,j } = rbf(8 , nhidden , nout , act ) ;          rbfs{6,j } = rbf(9 , nhidden , nout , act ) ;      end ; end ;",
    "a{i , j } = rbffwd(rbfs{i , j } , testx{i } ) ;          rms(i , j ) = sqrt(mean((a{i , j}-testt{i}).*(a{i , j}-testt{i } ) ) ) ;          fprintf(1 , ' rbf % d , member % d finished.\\n ' , i , j ) ;      end ;      comoutput{i } = 0 ;      for j = 1:comsize , comoutput{i } = comoutput{i } + a{i , j } ; end ;      comoutput{i } = comoutput{i } / comsize ;      comrms(i)=sqrt(mean((comoutput{i}-testt{i}).*(comoutput{i}-testt{i } ) ) ) ;      meanrms(i ) = mean(rms(i,1:size(rbfs,2 ) ) ) ;      fprintf(1 , ' finished with rbf committee % d.\\n ' , i ) ; end ;      99 abazajian , kevork , et al . _ the first data release of the sloan digital sky survey _ , _ astron.j . _ 126 ( 2003 ) 2081 . .",
    "_ the third data release of the sloan digital sky survey _ , _ aj _ 129 ( 2005 ) 17551759 .",
    "aschenbach , b. , et al . _ the rosat mission _ , _ space science reviews _ , 30 ( 1981 ) 14 , 569573 .",
    "babbedge , t.s.r . ,",
    "m.  rowan - robinson , e.  gonzalez - solares , et al .",
    "_ impz : a new photometric redshift code for galaxies and quasars _ , _ mon.not.roy.astron.soc .",
    "_ 353 ( 2004 ) 654672 .",
    "ball , nicholas  m. , robert  j. brunner , adam  d. myers , et al .",
    "_ robust machine learning applied to astronomical datasets ii : quantifying photometric redshifts for quasars using instance - based learning _ , _ astrophys.j .",
    "_ , to appear .",
    "_ robust machine learning applied to astronomical datasets iii : probabilistic photometric redshifts for galaxies and quasars in the sdss and galex _ , _ apj _ , to appear .",
    "bate , roger  r. , donald  d. mueller , and jerry  e. white .",
    "_ fundamentals of astrodynamics _",
    ", new york : dover , 1971 .",
    "becker , robert  h. , richard  l. white , and david  l. helfand . _ the first survey : faint images of the radio sky at twenty centimeters _",
    ", _ apj _ 450 ( 1995 ) 559577 .",
    "bishop , christopher  m. _ neural networks for pattern recognition _",
    ", oxford : oup , 1995 . .",
    "_ pattern recognition and machine learning _ , new york : springer , 2006 .",
    "bolzonella , micol , joan - marc miralles , and roser pell .",
    "_ photometric redshifts based on standard sed fitting procedures _ ,",
    "_ astron.astrophys .",
    "_ 363 ( 2000 ) 476",
    ". carliles , samuel , tams budavri , sebastien heinis , et al .",
    "_ photometric redshift estimation on sdss data using random forests _ , .",
    "collister , adrian  a. , and ofer lahav .",
    "_ ann__z _ _ : estimating photometric redshifts using artificial neural networks _ , _ publ.astron.soc.pac .",
    "_ 16 ( 2004 ) 345 .",
    "collobert , ronan , and samy bengio . _",
    "svmtorch : support vector machines for large - scale regression problems _ , _ j.mach.learn.res .",
    "_ 1 ( 2001 ) 143 - 160 .",
    "firth , andrew  e. , ofer lahav , and rachel  s. somerville .",
    "_ estimating photometric redshifts with artificial neural networks _ , _ mnras _ 339 ( 2003 ) 1195 .",
    "fukugita , m. , t. ichikawa , j.e .",
    "gunn , et al .",
    "_ the sloan digital sky survey photometric system _ , _ aj _ 111 ( 1996 ) 1748 .",
    "gunn , james  e. , david hogg , doug finkbeiner , and david schlegel .",
    "a redefinition of the sdss photometric system i : principles and defining equations _ , .",
    "hastie , trevor , robert tibshirani , and jerome friedman . _ the elements of statistical learning : data mining , inference , and prediction _ , new york : springer , 2001 .",
    "hatziminaoglou , e. , g. mathez , and r. pell .",
    "_ quasar candidate multicolor selection technique : a different approach _ , _",
    "a&a _ 359 ( 2000 ) 917 .",
    "hopkins , philip  f. , michael  a. strauss , patrick  b. hall , et al . _",
    "dust reddening in sloan digital sky survey quasars _ , _ aj _ 128 ( 2004 ) 11121123 .",
    "hsieh , b.c .",
    "yee , h. lin , and m.d .",
    "gladders . _ a photometric redshift galaxy catalog from the red - sequence cluster survey _ , _ apjsupp .",
    "_ 158 ( 2005 ) 161 .",
    "ivezi ,  .",
    "lupton , d. schlegel , et al .",
    "_ sdss data management and photometric quality assessment _ , _ astronomische nachrichten _ , 325 ( 2004 ) 583 .",
    "ivezi ,  .",
    "tyson , r. allsman , et al .",
    "_ lsst : from science drivers to reference design and anticipated data products _ , .",
    "jacobson , r.a . _ the orbits of the outer jovian satellites _ , _ apj _ 120 ( 2000 ) 26792686 .",
    "jacobson , r.a .",
    ", j. spitale , c.c .",
    "porco , et al .",
    "_ revised orbits of saturn s small inner satellites _ , _ aj _ 135 ( 2008 ) 261263 .",
    "kennedy , james , and russell eberhart . _ particle swarm optimization _ , _",
    "proc.ieeeconf.neur.nets._ , piscataway , nj 4 ( 1995 ) 19421948 .",
    "kitsionas , s. , e. hatziminaoglou , a. georgakakis , et al .",
    "_ on the use of photometric redshifts for x - ray selected agns _ , _",
    "a&a _ 434 ( 2005 ) 475 .",
    "miles , nick , alex freitas , and stephen serjeant .",
    "_ estimating photometric redshifts with genetic algorithms _ , _",
    "proc.gen.evol.comp.conf._ , seattle , wa 8 ( 2006 ) 15931594 .",
    "mitchell , tom  m. _ machine learning _",
    ", singapore : mcgraw - hill , 1997 .",
    "negnevitsky , michael . _ artificial intelligence : a guide to intelligent systems _ ,",
    "essex , uk : pearson education , 2002 .",
    "richards , gordon  t. , xiaohui fan , donald  p. schneider , et al . _",
    "colors of 2625 quasars at 0 <  z <  5 measured in the sloan digital sky survey photometric system _ , _ aj _ 121 ( 2001a ) 2308 .",
    "richards , gordon  t. , michael  a. weinstein , donald  p. schneider , et al .",
    "_ photometric redshifts of quasars",
    "_ , _ aj _ 122 ( 2001b ) 11511162 .",
    "ripley , b.d .",
    "_ pattern recognition and neural networks _ , cambridge : cup , 1996 .",
    "russell , stuart , and peter norvig .",
    "_ artificial intelligence : a modern approach _ ,",
    ", upper saddle river , nj : pearson education , 2003 .",
    "schneider , d.p .",
    "hall , g.t .",
    "richards , et al . _ the sloan digital sky survey quasar catalog iii : third data release _ , _ aj _ 130 ( 2005 ) 367380 .",
    "spitale , j.n .",
    "jacobson , c.c .",
    "porco , and w.m .",
    "owen , jr .",
    "_ the orbits of saturn s small satellites derived from combined historic and _ cassini _ imaging observations _ , _ aj _ 132 ( 2006 ) 692710 .",
    "stoughton , chris , robert  h. lupton , et al . _",
    "sloan digital sky survey : early data release _ , _ aj _ 123 ( 2002 ) 485548 .",
    "skrutskie , m.f .",
    "cutri , r. stiening , et al .",
    "_ the two micron all sky survey ( 2mass ) _ , _ aj _ 131 ( 2006 ) 11631183 .",
    "tagliaferri , r. , g. longo , s. andreon , et al . _ neural networks and photometric redshifts _ , .",
    "vanzella , e. , s. cristiani , a. fontana , et al .",
    "_ photometric redshifts with the multilayer perceptron neural network : application to the hdf - s and sdss _ , _ aa _ 423 ( 2004 ) 761776 .",
    "wadadekar , yogesh .",
    "_ estimating photometric redshifts using support vector machines _ ,",
    "_ pasp _ 117 ( 2005 ) 79 .",
    "wang , dan , yan - xia zhang , and chao liu , et al .",
    "_ two novel approaches for photometric redshift estimation based on sdss and 2mass _ , _ chin.j.astron.astrophys .",
    "_ 8 ( 2008 ) 119126 .",
    "way , m.j . and a.n .",
    "srivastava . _ novel methods for predicting photometric redshifts from broad band photometry using virtual sensors _ , _ apj _ 647 ( 2006 ) 102115 .",
    "weinstein , michael  a. , gordon  t. richards , donald  p. schneider , et al . _ an empirical algorithm for broad - band photometric redshifts of quasars from the sloan digital sky survey _ ,",
    "_ apjs _ 155 ( 2004 ) 243256 .",
    "witten , ian  h. and eibe frank .",
    "_ data mining : practical machine learning tools and techniques _",
    ", 2nd . ed .",
    ", oxford : elsevier , 2005 .",
    "wu , xue - bing , wei zhang , and xu zhou .",
    "_ color - redshift relations and photometric redshift estimations of quasars in large sky surveys _ , _ chjaa _ 4 ( 2004 ) 1727 .",
    "york , donald  g. , et al . _",
    "the sloan digital sky survey : technical summary _ , _ aj _ 120 ( 2000 ) 15791587 ."
  ],
  "abstract_text": [
    "<S> machine learning techniques are utilised in several areas of astrophysical research today . </S>",
    "<S> this dissertation addresses the application of ml techniques to two classes of problems in astrophysics , namely , the analysis of individual astronomical phenomena over time and the automated , simultaneous analysis of thousands of objects in large optical sky surveys . </S>",
    "<S> specifically investigated are ( 1 ) techniques to approximate the precise orbits of the satellites of jupiter and saturn given earth - based observations as well as ( 2 ) techniques to quickly estimate the distances of quasars observed in the sloan digital sky survey . learning methods considered include genetic algorithms , particle swarm optimisation , artificial neural networks , and radial basis function networks .    </S>",
    "<S> the first part of this dissertation demonstrates that gas and pso can both be efficiently used to model functions that are highly non - linear in several dimensions . </S>",
    "<S> it is subsequently demonstrated in the second part that anns and rbfns can be used as effective predictors of spectroscopic redshift given accurate photometry , especially in combination with other learning - based approaches described in the literature . </S>",
    "<S> careful application of these and other ml techniques to problems in astronomy and astrophysics will contribute to a better understanding of stellar evolution , binary star systems , cosmology , and the large - scale structure of the universe . </S>"
  ]
}