{
  "article_text": [
    "we consider a new constraint on permutations that requires moving averages of symbols to be closely concentrated around the mean running average . this constraint and the resulting coding schemes aim to balance charges across cells in rank modulation systems for flash memories  @xcite",
    ". balanced codes may also potentially aid in detecting and correcting errors .",
    "this can be accomplished by monitoring whether the balancing constraint is satisfied during the decoding process .",
    "hence , the constraint complements existing constraints imposed so as to contain cross - leakage between neighboring cells  @xcite .",
    "the permutation balancing constraint may also be seen as a block - by - block extension of classical bounded running digital sum codes  @xcite , and some of the construction ideas pursued were inspired by the well known knuth s balancing algorithm  @xcite .",
    "the constraint may be succinctly described as follows .",
    "let @xmath0 be a fixed positive integer , and let @xmath1=\\{{1,2,\\ldots , n\\}}$ ] .",
    "for any two non - negative integers @xmath2 , we use @xmath3 $ ] to denote the set @xmath4 and we use @xmath5 to denote the set of permutations of length @xmath0 .",
    "we are concerned with studying codes @xmath6 , where @xmath7 $ ] , defined as follows : @xmath8 if and only if for every @xmath9 and @xmath10 , one has @xmath11 here , @xmath12 takes values in the interval @xmath13 $ ] and is allowed to be a function of @xmath14 and @xmath0 .",
    "we refer to the constraint in as a _ balancing constraint _ , as it requires any @xmath14-consecutive sum of elements in a permutation to stay close to the mean @xmath14-consecutive sum , which equals @xmath15 .",
    "a constraint related to the balancing constraint was studied under the name of _ low - discrepancy permutation constraint _ in a handful of papers  @xcite .",
    "the authors of  @xcite studied the problem of finding _ a smallest discrepancy permutation_. in particular , they defined the discrepancy of a permutation @xmath16 according to @xmath17 and focused their attention on computing @xmath18 they showed that @xmath19 for any choice of the parameters @xmath0 and @xmath20 .",
    "in contrast to the work pertaining to permutation discrepancy , our work is not concerned with finding the smallest discrepancy permutation but rather with _ constructing codes _ of relatively small discrepancies and of size as large as possible .",
    "furthermore , the discrepancy constraint places a constraint on substrings of fixed length @xmath14 , whereas the balancing constraint in  ( [ eq : constraints ] ) is more general as balancing is required for all blocks of length @xmath21 , where @xmath22 may contain more than one value .",
    "this code design approach offers certain advantages in terms or built - in error detection capabilities , and in addition , it covers the single blocklength @xmath14 balancing constraint by definition . to the best of the authors knowledge ,",
    "this coding problem has not been studied before in the literature .",
    "one use of the results of  @xcite allows us to show that for @xmath23 $ ] , @xmath24 is non - empty provided that @xmath25 . as an example , it is easy to see that the smallest discrepancy set of permutations for @xmath26 and @xmath27 equals : @xmath28 the discrepancy of the permutations is @xmath29 .",
    "allowing for a larger discrepancy clearly increases the size of the permutation code .    for simplicity",
    ", our focus will be on two special cases for the set @xmath22 , @xmath30 $ ] and @xmath31 , for some @xmath32 , such that @xmath33 , and their corresponding @xmath12 functions , @xmath34 where @xmath35 .",
    "these two constraints were selected to demonstrate that one can balance out the same set of permutations for almost all choices of @xmath14 simultaneously , although not with the same balancing function @xmath12 - the balancing function is weaker for smaller @xmath14 .",
    "for the first balancing constraint where @xmath36 and @xmath37 , the resulting permutation code has capacity one . on the other hand ,",
    "it is impossible to have the same permutation code have a discrepancy uniformly scaling with @xmath38 for all choices of @xmath39 $ ] .",
    "some divisibility properties on @xmath14 have to be imposed . at the same time",
    ", the code rate is strictly less than one , equal to @xmath40",
    ". codes @xmath24 with codewords satisfying ( [ eq : constraints ] ) and discrepancy @xmath41 and @xmath42 are referred to as a @xmath41- and @xmath42-balanced permutation codes .",
    "let @xmath43 for @xmath44 denote the capacity of a @xmath45-balanced permutation code expressed in bits .",
    "our main results demonstrate that when @xmath37 , @xmath46 . for @xmath47",
    ", we get that @xmath48 .",
    "we also provide a sampling of results for @xmath49 and @xmath50balanced codes that satisfy the two - neighbor constraint introduced in  @xcite .",
    "in this section , we present a construction for @xmath41-balanced permutation codes that achieve rate one . for simplicity of exposition , we suppose that @xmath0 is an even number .",
    "the idea behind the code construction is to partition the set @xmath1 $ ] into two subsets , @xmath51 $ ] and @xmath52 \\setminus [ n/2]$ ] .",
    "the symbols in the set @xmath53 are arranged according to a permutation @xmath54 , and the resulting sequence is denoted by @xmath55 .",
    "similarly , the symbols in the set @xmath56 are arranged according to a permutation @xmath57 , and the resulting sequence is denoted by @xmath58 .",
    "we form permutations @xmath59 , which we subsequently prove to be @xmath41-balanced as follows .",
    "we initialize the construction by choosing the first element of @xmath60 to be the first element of @xmath55 ; we consequently remove that element from @xmath55 .",
    "the second element of @xmath60 is set to the first element of @xmath58 and this element is subsequently removed from @xmath58 .",
    "suppose next that @xmath61 @xmath62 , symbols of @xmath60 have been selected . to determine the next symbol in @xmath60",
    ", we compute the accumulated average sum @xmath63 .",
    "if @xmath64 , we set the @xmath65-th element of @xmath60 to be equal to the first element of @xmath58 and remove the element from @xmath58 .",
    "if @xmath66 , then we set the @xmath65-th element of @xmath60 to be equal to the first element of @xmath55 and remove this element from @xmath55 .",
    "the procedure is illustrated via the example below .",
    "[ ex : d1encode ] let @xmath67 . in this",
    "setting , we have @xmath68 @xmath69 . by choosing @xmath70 and @xmath71 ,",
    "we arrive at @xmath72 and @xmath73 .",
    "for the given choice of @xmath74 we initialize @xmath60 as @xmath75 and obtain @xmath76 , @xmath77 .",
    "next , we evaluate @xmath78 , and subsequently select the first element from @xmath55 to obtain @xmath79 .",
    "we then compute @xmath80 and arrive at @xmath81 .",
    "continuing until all elements are used up , we obtain @xmath82 .",
    "it is straightforward to see that if @xmath60 is constructed according to the previous procedure using two permutations @xmath83 , while @xmath84 is constructed from @xmath85 where @xmath86 , then @xmath87 .",
    "therefore , the cardinality of @xmath88 equals the number of possible choices for the permutations @xmath89 i.e. , @xmath90 which implies that @xmath91 .",
    "note that the sequences @xmath92 are updated after each step , i.e. , after each extension of the permutation @xmath60 . for notational convenience ,",
    "we let @xmath93 denote the sequence @xmath55 after @xmath65 elements have been added to the permutation @xmath60 ; similarly , we let @xmath94 denote the sequence @xmath58 after @xmath65 elements have been added to the permutation @xmath60 .",
    "for ease of notation , we use @xmath95 to denote the length of the sequence @xmath96 .",
    "the next lemma establishes an important property of the encoding procedure described in example  [ ex : d1encode ] .",
    "[ lem : correctness ] for any @xmath59 constructed using two given permutations @xmath74 and any @xmath97 , @xmath98 implies that @xmath99 .",
    "similarly , @xmath100 implies that @xmath101 .",
    "suppose that @xmath102 and that on the contrary , @xmath103 .",
    "let @xmath104 represent the set of symbols in the sequence @xmath105 .",
    "the set @xmath104 , and the sets of elements contained in @xmath106 and @xmath107 form a partition of @xmath1 $ ] .",
    "clearly , the average symbol value of the set @xmath1 $ ] equals @xmath108 .",
    "hence , if @xmath103 , then @xmath109 which is a contradiction .",
    "the case where @xmath110 may be handled similarly .",
    "we have the following claim .",
    "[ cl : edges ] let @xmath59 be constructed according to the previously described running sums @xmath111 .",
    "for any integer @xmath112 , @xmath113    the proof proceeds by induction on @xmath65 .",
    "the result holds for @xmath114 , and this establishes the base case .",
    "suppose next that the result holds for all @xmath115 and consider the case @xmath116 .",
    "clearly , @xmath117 if @xmath118 then according to lemma  [ ex : d1encode ] , we have @xmath119 .",
    "furthermore , using the inductive hypothesis along with @xmath120 shows that @xmath121 which established the validity of the claim for the case that @xmath120 .",
    "the case where @xmath122 can be handled similarly .    from claim  [ cl : edges ] , we can prove that the code @xmath123 satisfies  ( [ eq : constraints ] ) .",
    "[ lem : ub ] for any @xmath124 and @xmath125 $ ] , @xmath126    clearly , @xmath127 using the result of claim  [ cl : edges ] , we obtain @xmath128 using the same approach , one may show that @xmath129 and this completes the proof .",
    "these results lead to the following theorem .",
    "the capacity of the @xmath41-constraint equals @xmath130 .    as a consequence of lemma  [ lem : ub ] ,",
    "we know that the code construction from example  [ ex : d1encode ] satisfies the @xmath41-constraint and given that there are @xmath131 choices for each of the two permutations @xmath132 and @xmath133 , it follows that @xmath46 .",
    "note that a naive implementation of the encoding procedure requires maintaining the sequences @xmath92 and roughly @xmath134 operations for re - computing the average values of the symbols @xmath0 times .",
    "clearly , significantly less complex implementations are possible .",
    "one approach would be to divide the input information sequence into two blocks of the same size or sizes that differ by one , and than use the two parts to `` encode '' for the permutations @xmath132 and @xmath133 . here , encoding may refer to generating a permutation at a given position in the lexicographical order of permutations , and efficient , straightforward algorithms for this and more general encodings are known  @xcite .",
    "this approach would remove the storage requirement for the permutation @xmath132 and @xmath133 , and subsequently only require transposing adjacent symbols in the permutations .",
    "the procedure , which we next illustrate with an example , may be seen as an extension of knuth s balancing principle , where complementation used for binary strings is replaced by transpositions in permutations may not result in a permutation . ] .",
    "suppose once more that @xmath67 , @xmath68 @xmath69 , @xmath135 and @xmath136 so that @xmath72 and @xmath73 .",
    "we form an auxiliary permutation @xmath137 by interleaving @xmath132 and @xmath133 , which in the above case leads to @xmath138 we maintain two pointers , each requiring @xmath139 bits .",
    "the initial positions of the pointers are at the location of the second element of @xmath55 and the first element of @xmath58 , as we would like to test if transposing these two elements will reduce the running sum .",
    "we also initialize the discrepancy to @xmath140 , and store @xmath141 , which requires @xmath142 bits of overhead .    in the second step of encoding ,",
    "since @xmath143 and @xmath144 , the pointer at @xmath145 is moved up to the position of the next element in @xmath58 which is @xmath146 as shown below @xmath147 the updated discrepancy is computed according to @xmath148 .",
    "note that if @xmath149 and @xmath144 , then the element pointed at by the second arrow would have been deleted from @xmath150 and reinserted back into the permutation at the position of the first arrow using a single adjacent transposition . at this point",
    ", @xmath151 would have had one arrow pointing at the element @xmath29 , the element following @xmath152 in @xmath55 , and another arrow pointing at @xmath145 , the first element in @xmath58 .    in the third step , since @xmath153 and @xmath154 , no transposition is performed , and we simply move the leftmost pointer to the next element in @xmath55 so that @xmath155 note that after three steps of encodings , the positions of three elements in @xmath60 are permanently fixed .",
    "we terminate after @xmath0 elements in @xmath60 have been fixed , in which case we obtain @xmath156 .",
    "we now consider the case where @xmath12 scales inversely both with @xmath14 and @xmath157 @xmath35 and where @xmath31 .",
    "the reason behind this choice of problem parameters is that we can not simultaneously satisfy a stringent discrepancy constraint with @xmath158 $ ] .",
    "such a constraint would require that for all @xmath159 $ ] , one has @xmath160 which is clearly impossible .",
    "a similar problem is encountered when @xmath22 contains two consecutively valued symbols .",
    "thus , we limit our attention to the case where @xmath22 contains elements which are multiples of two . the proof follows by noting the @xmath42-constraint requires that for every @xmath161 $ ] , @xmath162 is close in value to @xmath163 .",
    "[ lem : ub2 ] the capacity @xmath164 for @xmath165 , and @xmath166 for @xmath167 .    throughout the remainder of this section , we write @xmath168 to ease notational burden and for simplicity assume that @xmath169 and that @xmath170 is divisible by four .",
    "we focus our attention on deriving a lower bound on @xmath171 by constructing a balanced code @xmath172 , with @xmath173 and of rate @xmath174    we partition the set @xmath1 $ ] into @xmath170 subsets of equal size @xmath175 , comprising consecutive integers , subsequently denoted by @xmath53 , @xmath176 @xmath177 not satisfying the given divisibility properties , the sets @xmath178 may have different cardinalities . this small technical detail does not change the validity of the argument nor the claimed result . ] . for each @xmath179 $ ]",
    ", we order the elements of @xmath180 arbitrarily and denote the resulting sequence by @xmath181 .",
    "since there are @xmath182 ways to arrange each set @xmath180 , @xmath183 , and hence @xmath184 which implies the lower bound .",
    "figure  1 illustrates the encoding process .",
    "similar to what we did before , we incrementally build a permutation @xmath185 . each cell in the figure involves appending two elements to @xmath60 , chosen from one of two possible sets .",
    "for instance , based on figure  1 , visiting the first cell requires appending either a ) one element from @xmath58 and one element from @xmath186 or b ) appending one element from @xmath55 and one element from @xmath187 to @xmath60 .",
    "note that since each of our sets has size @xmath175 , each cell in figure  1 will be visited @xmath188 times .",
    "we next explain this outlined encoding process in more detail .",
    "the first @xmath189 symbols of @xmath60 are selected as follows .",
    "set the first element of @xmath60 to be the first element in @xmath55 and then remove this element from @xmath55 .",
    "set the second element of @xmath60 to be the first element of @xmath187 and remove the chosen element from @xmath187 .",
    "this selection process is captured by the first cell in figure  1 , indicating that the first element of the permutation is taken from @xmath55 or @xmath58 and the second element is from @xmath190 or @xmath187 .",
    "we next compute @xmath191 and if @xmath192 or @xmath193 , we revisit the first cell .",
    "if @xmath194 , we append the first element of the set @xmath195 followed by the first element of the set @xmath196 to @xmath60 and remove these elements from their respective sets . otherwise , if @xmath197 we append the first element from @xmath198 followed by the first element from @xmath187 to @xmath60 and remove these two elements from their respective sets",
    "we then consider @xmath199 , and if @xmath192 or @xmath193 , we revisit the first cell .",
    "if @xmath200 , we append the first element from @xmath195 followed by the first element from @xmath186 to @xmath60 and remove these elements from their respective sets . otherwise , we append the first element from @xmath198 followed by the first element from @xmath187 to @xmath60 and remove these elements from their respective sets .",
    "this process is continued until we have added @xmath201 elements to @xmath60 so that @xmath202 .",
    "notice that since two elements are appended at once , we have visited the first cell @xmath188 times .",
    "next , we again compute the running average of the elements fixed ( or appended ) to @xmath60 thus far . if the running average is less than @xmath108",
    ", then we choose the next two elements of @xmath60 to be the first elements of the sets @xmath203 , which we then remove from their respective sets .",
    "otherwise , the next two elements of @xmath60 are chosen from @xmath204 , added , and removed from their respective sets .",
    "afterwards , we repeatedly add elements from the sets @xmath205 until @xmath206 .",
    "this process is continued until @xmath60 has length @xmath0 .",
    "[ fig : encoding ] -balanced code , title=\"fig:\",scaledwidth=45.0% ]    we illustrate the procedure with an example .",
    "[ ex : smaller ] let @xmath207 , @xmath208 , and @xmath209 , and suppose that    @xmath210 @xmath211 , @xmath212 ,    @xmath213 , @xmath214 ,    @xmath215 , @xmath216 , and    @xmath217 .",
    "we set the first two elements of @xmath60 to be the first element from @xmath55 followed by the first element from @xmath218 so that @xmath219 and @xmath220 .",
    "since @xmath194 , we extend @xmath60 to @xmath221 .",
    "now , we compute @xmath222 which implies that @xmath60 should be extended to @xmath223 .    next , we find @xmath224 and arrive at @xmath225 in the next three steps , we compute @xmath226 , @xmath227 , @xmath228 , and @xmath229 . based on these values , the permutation @xmath60 is augmented recursively as @xmath230 @xmath231 @xmath232 @xmath233 at this point , we move onto the second cell in figure  1 . for clarity , we now write @xmath234 where @xmath235 in the next iteration of the algorithm , we compute @xmath236 and augment @xmath151 to @xmath237 . in the next four steps we compute @xmath238 , @xmath239 , @xmath240 , @xmath241 , @xmath242 , @xmath243 , and @xmath244 .",
    "the corresponding updates in @xmath151 result in @xmath245 @xmath246 @xmath247 @xmath248 @xmath249 @xmath250 @xmath251    next , we prove that the chosen balancing constraint is satisfied by the previously outlined encoding procedure .",
    "the first result in this direction is a generalization of claim  [ cl : edges ] from the previous section .",
    "it follows directly from the encoding procedure illustrated in example  [ ex : smaller ] , and its proof is henceforth omitted .",
    "[ cl : edges2 ] let @xmath252 where @xmath172 is constructed according to the described encoding algorithm .",
    "for any even integer @xmath253 , it holds that @xmath254    suppose now that @xmath255 . then , @xmath256 , and so if @xmath257 then @xmath258 thus , if the @xmath259-th element in a permutation is encoded according to cell index @xmath260 in figure  1 and @xmath255 , the @xmath261-st element in that permutation is encoded according to cell index @xmath260 or @xmath262 .",
    "suppose that @xmath255 . as a result of the next claim ,",
    "we know that any element encoded according to cell @xmath260 has a symbol value close to an element encoded according to cell @xmath263 .",
    "[ cl : edges3 ] let @xmath185 .",
    "suppose that @xmath264 are such that @xmath255 .",
    "then , @xmath265 for some positive integer @xmath266 , and @xmath267    the next lemma establishes that our balancing criteria is satisfied .",
    "[ lem : lower2 ] for any @xmath268 $ ] @xmath269 , @xmath270 , and @xmath185 , we have @xmath271    recall from equation  ( [ eq : balancingmub ] ) and claim  [ cl : edges3 ] that @xmath272 for some integer @xmath266 .",
    "since @xmath255 , @xmath273 is an even integer .",
    "thus , one of the values @xmath264 is even .",
    "suppose for now that @xmath65 is even .",
    "then using claim  [ cl : edges2 ] , we have @xmath274 otherwise , if @xmath65 is odd , we may write @xmath275 where the inequality follows from claims  [ cl : edges2 ] and  [ cl : edges3 ] .",
    "the inequality in the other direction for the case of @xmath65 even or @xmath65 odd can be proved using similar arguments .    as a consequence of lemmas  [",
    "lem : ub2 ] and [ lem : lower2 ] , the following theorem holds .    for @xmath35 , @xmath276",
    "we now turn our attention to a short treatment regarding combined balanced and constrained codes  @xcite . we will focus on the two - neighbor symmetric constraint coding as defined in  @xcite . for this purpose ,",
    "recall that a permutation @xmath16 satisfies the two - neighbor @xmath277-constraint if for all @xmath278 , either @xmath279 or @xmath280 .",
    "let @xmath281 be either a @xmath41- or a @xmath42-balanced permutation code that also satisfies the two - neighbor @xmath277-constraint .",
    "let @xmath282 where , similarly to the notation used in the previous sections , @xmath283 denotes the capacity of a @xmath45-balanced permutation code that satisfies the two - neighbor @xmath277-constraint .",
    "we consider the case for @xmath41-balanced permutation codes as defined in ( [ eq : constraints ] ) and ( [ eq : c1 ] ) .",
    "recall , for the @xmath41-constraint @xmath284 $ ] . in our derivations",
    ", we adopt the same scaling model as in  @xcite , for which @xmath285 for @xmath286 . in this case , the capacity is a function of @xmath287 .",
    "the discussion of the @xmath42-constrained codes is deferred to an extended version of this paper .        from  @xcite ,",
    "a trivial upper bound on @xmath289 is @xmath290 . using similar ideas as in section  [ sec : constructd1 ] and the construction from  @xcite",
    ", one can derive a matching lower bound . similarly to what was proposed in  @xcite , in our setting the @xmath277-constraint is imposed by selecting two elements at a time from a set with elements that differ by at most @xmath277 .",
    "these ideas are illustrated by the next example , while details of the proof are deferred to the full version of the paper .",
    "let @xmath291 and @xmath292 .",
    "we begin by partitioning the set @xmath293 $ ] into six sets of size four each , where @xmath294 , @xmath295 , @xmath296 , and @xmath297 , @xmath298 , @xmath299 .",
    "we choose an ordering for each of these sets to obtain @xmath300 we select the first two elements from @xmath55 , remove these elements from @xmath55 , and arrive at @xmath301 .",
    "next , we compute the running average of @xmath60 as @xmath302 . since @xmath303 , we choose one of the sets @xmath304 to select two additional elements from .",
    "suppose we pick @xmath305 so that @xmath306 and so that the symbols @xmath307 are subsequently removed from @xmath305 .",
    "then , since the symbol average @xmath308 , we choose elements from @xmath309 .",
    "suppose we pick @xmath310 so that @xmath311",
    ". then @xmath312 are removed from @xmath310 . in this case ,",
    "@xmath313 and so we pick the next two elements from one of the sets @xmath314 .",
    "suppose , we choose the set @xmath58 so that @xmath315 and so @xmath316 .",
    "suppose @xmath317 is chosen next and so @xmath318 .",
    "suppose we continue the same procedure and choose from the following sets ( in order ) : @xmath319 .",
    "the result is the permutation @xmath320",
    "@xmath321 @xmath322 @xmath323 ."
  ],
  "abstract_text": [
    "<S> motivated by charge balancing constraints for rank modulation schemes , we introduce the notion of balanced permutations and derive the capacity of balanced permutation codes . </S>",
    "<S> we also describe simple interleaving methods for permutation code constructions and show that they approach capacity . </S>"
  ]
}