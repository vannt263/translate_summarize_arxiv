{
  "article_text": [
    "classical planning and multi - agent planning based on classical planning are approaches to constructing autonomous agents and teams of agents , which attempt to achieve their objectives in an environment .",
    "the result of the planning process is traditionally a plan , a sequence of actions the agent should perform in order to achieve a given goal .",
    "when the agent is situated in a dynamic environment , occurrence of various unexpected events the environment generates might lead to the plan invalidation , a failure .",
    "a straightforward solution to this problem is to invoke a planning algorithm and compute a new plan from the state the agent found itself in after the failure to a state conforming with its original objective .",
    "planning , as well as replanning , in the case of a failure occurrence , is a costly procedure , especially in terms of its time complexity .",
    "it is relatively straightforward to see , that in many cases , however , a relatively minor fix to the original plan would resolve the failure possibly at a lower cost .",
    "because it is not clear what exactly are the planning domains and types of dynamic environments which would allow for such a repair approach , it can be argued that non - informed plan repair attempts can in many cases even raise the overall complexity of the approach in comparison to replanning .",
    "this would be due to futile attempts to repair the failed plan before inevitably falling back to replanning .",
    "in general , plan repair can be seen as planning with re - use of fragments of the old plan .",
    "there is a number of works , empirically demonstrating that plan repair in various domains performs better than replanning ( e.g. , @xcite ) .",
    "however , in  @xcite , nebel and koehler theoretically analyzed plan re - use ( plan repair ) , and conclude that in general it does not bring any benefit over replanning in terms of computational time complexity .    in situated multi - agent systems , however , the time complexity is often not of the primary importance . in such systems , often it is the communication complexity which is a higher priority concern .",
    "consider application domains , such as e.g. , undersea operations by teams of coordinated autonomous underwater vehicles . while the state - of - the - art technology allows to employ relatively powerful computers on board of such robots ,",
    "the communication links are extremely constrained and expensive ; wireless networks can not be deployed and communication is performed mostly using acoustic signaling . in such applications , it is the communication complexity of the distributed planning algorithms which matters more than time complexity . consequently , employment of multi - agent plain repair techniques can provide a tangible benefit over replanning for a team of robots whose multi - agent plan fails .",
    "the motivation for our research is the intuition that multi - agent plan repair , even though not always the fastest approach , should under specific conditions generate lower communication overheads in comparison to replanning .",
    "the conditions correspond to the level of required coordination and the types of failures the environment generates .",
    "while the hypothesis is rather intuitive , our approach is significant in that we give it a rigorous treatment . besides our preliminary approach in  @xcite , *",
    "* this aspect of multi - agent planning and plan repair , while obviously important with arrival of truly distributed algorithms for multi - agent planning , such as the one by nissim et al .",
    "@xcite did not witness considerable attention of the community yet .",
    "the contribution of the the presented paper is threefold .",
    "firstly , after introducing the general problem of multi - agent planning stemming from the formulation due to brafman and domshlak  @xcite in section  [ sec : multi - agent - planning ] , in subsequent section  [ sec : multi - agent - plan - repair ] we formally introduce the multi - agent plan repair problem and formally state the core hypothesis of the presented research .",
    "secondly , still in section  [ sec : multi - agent - plan - repair ] , we propose three algorithms for multi - agent plan repair reducing the problem to specialized instances of the multi - agent planning problem . finally , in section  [",
    "sec : evaluation ] we present experimental validation confirming the core hypothesis of the paper .",
    "section  [ sec : discussion ] concludes the paper by some final remarks regarding the shortcomings of our approach and future outlooks in the here described line of research .",
    "classical , single - agent planning problem is characterized by a set of states with a unique initial state , a final state ( a set of final states ) and a set of actions representing the transitions between these states that the system undertakes upon performing the actions .",
    "we define multi - agent planning problem as an extension of the classical single - agent planning .",
    "we consider a number of _ cooperative _ and _ coordinated _ actors featuring possibly distinct sets of capabilities ( actions ) , which concurrently plan and subsequently execute their local plans so that they achieve a joint goal .",
    "an instance of a multi - agent planning problem is defined by : i ) an environment characterized by a state space , ii ) a finite set of agents , each characterized by a set of primitive actions ( or capabilities ) it can execute in the environment , iii ) an initial state the agents start their activities in and",
    "iv ) a characterization of the desired goal states . before treating the problem of multi - agent planning and summarizing a state - of - the - art algorithm for solving it ,",
    "we first formally introduce the underlying concepts .",
    "consider a set of atoms @xmath0 .",
    "a _ state _ is a set of terms from a language @xmath1 where @xmath2 denotes a negation of @xmath3 .",
    "we also assume the standard tautology @xmath4 for every @xmath5 .",
    "furthermore , we require all states to be _ consistent _ , i.e. , for a state @xmath6 we have that @xmath7 if and only if @xmath8 .",
    "note , in general , the states do not have to be complete , i.e. , it might be that there is a @xmath5 , such that @xmath9 .",
    "@xmath10 denotes the set of all states and we assume there is a distinguished state @xmath11 denoting an undefined state in which the overall system can be in . to simplify the notation",
    ", we also extend the negation to states as follows @xmath12 .",
    "the set of atoms corresponding to a set of terms @xmath13 is denoted @xmath14 .    a _ primitive _ _ action _ , or simply an _ action _ , is a tuple @xmath15 , where @xmath16 is a unique action label and @xmath17 respectively denote the sets of preconditions and effects of @xmath16 .",
    "the preconditions and effects are assumed to be consistent sets of terms . whenever the context is clear",
    ", we simply write @xmath16 instead of @xmath15 .",
    "@xmath18 denotes the set of all actions and we furthermore assume there is a distinguished empty action @xmath19 with no preconditions and no effects .",
    "we say that an action @xmath15 is _ applicable _ in a state @xmath20 iff @xmath21 .",
    "an application of @xmath15 is defined by the state transformation operator @xmath22 defined as follows : @xmath23    note that given a consistent state @xmath20 and an action @xmath15 , the application of @xmath16 to @xmath20 results in either the undefined state @xmath24 , or , in the case @xmath16 was applicable in @xmath20 , a consistent state @xmath25 again .",
    "the application of @xmath15 to @xmath20 first enriches @xmath20 with all the effects of @xmath16 , however , in the case there exists some @xmath7 , s.t . , @xmath26 , the simple unification would make the resulting state inconsistent .",
    "the subsequent set subtraction of terms which were the source of such inconsistencies makes the resulting state consistent again , while at the same time preserving the effects of @xmath16 .",
    "furthermore , @xmath27 is associative , hence we can write @xmath28 .",
    "an _ agent _ @xmath29 is characterized precisely by its capabilities , a finite repertoire of actions it can preform in the environment . from now on , we assume that there exists a language @xmath30 giving rise to a state space @xmath10 .",
    "[ def : multi - agent - planning ] a _ multi - agent _ _ planning problem _ is a tuple @xmath31 , where @xmath32 is a set of _ agents _ @xmath33 , featuring mutually disjoint sets of actions , an initial state @xmath34 and a set of goal states @xmath35 .    before formally defining the notion of a solution to a multi - agent planning problem",
    ", we first introduce a sequel of auxiliary notions .    given an agent @xmath36 , a",
    "_ single - agent plan _ @xmath37 is a sequence of actions @xmath38 , s.t .",
    ", @xmath39 for every @xmath40 .",
    "@xmath41 $ ] denotes the @xmath40-th action in @xmath37 , or @xmath41=\\epsilon$ ] in the case @xmath40 is larger than the length of @xmath37 , which in turn will be denoted @xmath42 .",
    "a team of agents @xmath43 can act in the environment concurrently .",
    "a joint action @xmath44 of the team is specified by @xmath45 a tuple of actions corresponding to the individual agents , i.e. , @xmath46 for each @xmath40 , its preconditions @xmath47 and its effects @xmath48 .",
    "@xmath49 $ ] denotes the @xmath50-th action of @xmath51 .",
    "similarly to actions of individual agents , @xmath52 and @xmath53 are assumed to be consistent sets of terms .",
    "the notion of action applicability in a state @xmath20 , as well as application of @xmath51 to @xmath20 straightforwardly extend from the definitions for primitive actions .",
    "[ def : multi - agent - plan ] let @xmath31 be a multi - agent planning problem with @xmath43 .",
    "a _ synchronous multi - agent plan _ @xmath54 , consisting of single agent plans @xmath55 respectively constructed from actions of the agents @xmath33 is a solution to @xmath56 if the plan @xmath57 satisfies the following :    1 .",
    "@xmath57 is _ well - formed _ , i.e. , @xmath58 for all @xmath59 .",
    "@xmath60 , for some @xmath61 , denotes the length of the multi - agent plan @xmath57 ; 2 .",
    "@xmath57 is _ feasible _ , i.e. , there exists a sequel of states @xmath62 , s.t .",
    "@xmath63 and @xmath64 with @xmath65,\\ldots , p_{n}[i])$ ] for all @xmath66 ; and finally 3 .",
    "@xmath57 reaches the goal @xmath67 , i.e. , there exists @xmath68 , s.t .",
    "@xmath69 .",
    "we also say that @xmath57 solves the problem @xmath56 .",
    "finally , @xmath70 denotes the set of plans which are solutions to a given multi - agent planning problem @xmath56 .",
    "additionally , @xmath71 $ ] denotes the joint action of the team in the step @xmath50 and @xmath72 $ ] denotes the primitive action of the agent @xmath40 in the step @xmath50 .",
    "this notation allows us to introduce the following plan - matrix notation for a multi - agent plan @xmath57 , which provides a more visual understanding of multi - agent plans :    @xmath73 where @xmath74 $ ] .",
    "indices @xmath40 ( @xmath75 ) and @xmath76 ( @xmath77 ) denote the step of the plan @xmath57 and the agent which performs the primitive action , respectively .",
    "we say that two multi - agent plans @xmath78 , @xmath79 are equal ( @xmath80 ) iff they have the same length ( @xmath81 ) and for all @xmath40 and @xmath76 we have @xmath82=\\mathcal{p}_{2}[i , j]$ ] .",
    "a _ _ concatenation of two multi - agent plans @xmath78 and @xmath79 over the same agents @xmath33 is defined as a plan @xmath83 , where for each @xmath40 and @xmath76 we have @xmath84=\\mathcal{p}_{1}[i , j]$ ] if @xmath85 and @xmath84=\\mathcal{p}_{2}[i-|\\mathcal{p}_{2}|,j]$ ] for @xmath86 . in the plan - matrix notation",
    ", the concatenation would correspond to simple columns - appending operation .",
    "note , concatenation of multi - agent plans is an associative operation .",
    "given a multi - agent plan @xmath57 , @xmath87 $ ] denotes a fragment of @xmath57 from the step @xmath40 to the step @xmath76 .",
    "more precisely , @xmath87 $ ] is a fragment of @xmath57 iff there exist multi - agent plans @xmath88 and @xmath89 , such that @xmath90\\cdot\\mathcal{p}_{\\mathit{suffix}}=\\mathcal{p}$ ] . finally , @xmath91 $ ] denotes the @xmath40-th suffix of the plan @xmath57 , i.e. , @xmath91=\\mathcal{p}[i .. |\\mathcal{p}|]$ ] .",
    "@xmath92 is said to be a _ decomposition _ of a multi - agent plan @xmath57 iff @xmath83",
    ".    given two multi - agent plans @xmath78 and @xmath79 we can define how different they are .",
    "@xmath93 denotes the difference between @xmath78 and @xmath79 , that is the overall number of primitive actions in @xmath78 , which do not correlate with the corresponding primitive actions in @xmath79 and _ vice versa_. formally , @xmath94\\neq\\mathcal{p}_{2}[i , j]\\}|$ ] . in the case",
    "@xmath95 , @xmath96 , where @xmath97 is a plan padding of @xmath78 to the overall length @xmath98 and filled with empty actions , i.e , for each @xmath99 , we have @xmath100=\\epsilon$ ] .",
    "note that the measure @xmath101 is position agnostic , i.e. , we define @xmath102 in the case @xmath103 .",
    "the above formulation of the multi - agent planning problem is well in line with the original formulation of ma - strips planning due to brafman and domshlak  @xcite .",
    "the authors there additionally distinguish between the _ public _ and _ private _ actions of the individual agents .",
    "an action is public whenever its preconditions or effects involve atoms occurring in preconditions or effects of an action belonging to another agent of the team .",
    "formally , given a multi - agent team @xmath104 , the set of public actions is defined as @xmath105 .",
    "recall , @xmath106 denotes the set of non - negated atoms occurring in @xmath107 .",
    "@xmath108 , where @xmath109 is the set of all actions the team @xmath110 can perform .",
    "the distinction of actions to private and public turns out to be an important one .",
    "since private actions do not depend , nor are dependencies of other actions performable by the team , planning of sequences of private actions can be implemented strictly locally by the agent the actions belongs to . in effect , the public actions become points of coordination among the multi - agent team members and a truly decentralized multi - agent planning algorithm for a planning problem @xmath56 can be implemented in two interleaving stages until a suitable multi - agent plan is found : i ) a plan consisting exclusively of public actions of the agent team is calculated , and subsequently ii ) the sequences of private actions between the public actions of each individual agent are computed to fill in the gaps .",
    "the main contribution of the brafman and domshlak s paper lies in pointing out that the algorithms can be implemented by reduction of the first stage of the planning process to a constraint satisfaction problem ( csp ) corresponding to the multi - agent planning problem with public actions only .",
    "the second stage can be subsequently solved by any classical single - agent planning algorithm . in result , solving a given multi - agent planning problem can be loosely formulated as a csp with the following two types of constraints :    coordination  constraint : : :    a sequence of joint actions @xmath57 ( candidate    multi - agent plan ) satisfies the _ coordination constraint _",
    "iff for    every action @xmath111 $ ]    performed by the agent @xmath112 in the step    @xmath50 we have , that if @xmath16 is a public action ,    then    +    * for every @xmath113 , there must exist    @xmath114 $ ] ,    such that @xmath115 and @xmath116    ( there is some previous action which causes @xmath3 to hold ) ,    and    * for no @xmath117 ,    s.t .",
    ",  @xmath118 there exists    @xmath119 $ ] ,    such that @xmath120 ( @xmath3 wo nt    be invalidated between causing it in the step @xmath121 and    execution of @xmath16 in the step @xmath50 ) . internal  planning  constraint",
    ": : :    a sequence of joint actions @xmath57 satisfies the    _ internal planning constraint _",
    "iff for every agent , the corresponding    single - agent planning problem with landmarks    @xmath122\\in\\actions^{\\mathit{pub}}\\}$ ]    is solvable .",
    "i.e. , a single - agent planning algorithm is able to fill    in the gaps between the public actions in the candidate multi - agent    plan .    a multi - agent planning problem @xmath123 .",
    "a multi - agent plan @xmath57 solving @xmath56 , if such exists .",
    "@xmath124 construct @xmath125 reconstruct a plan @xmath57 from a solution for @xmath126 .",
    "@xmath57 @xmath127    algorithm  [ alg : ma - plan ] lists the original multi - agent planning algorithm by brafman and domshlak in  @xcite .",
    "the algorithm iterates through csp formulations of the planning problem according to @xmath128 , informally the number of coordination points between the agents in the multi - agent team .",
    "i.e. , @xmath128 determines the number of joint actions in a candidate multi - agent plan consisting of only public actions .",
    "filling the gaps between the individual single - agent public actions , if possible , then gives rise to the overall multi - agent plan . in the case such a plan completion does not exist , the process continues by testing longer candidate plans .",
    "the original multi - agent planning algorithm assumes a centralized planning architecture .",
    "i.e. , it is a centralized planning algorithm computing multi - agent plans for a team of agents which are supposed to be subsequently executed in a decentralized fashion .",
    "our motivation is however a decentralized planning / plan repair algorithm followed by a decentralized plan execution .",
    "nissim et al .  in  @xcite adapted the original blueprint algorithm described above to a distributed setting .",
    "the adaptation rests on formulating the multi - agent planning problem as a distributed constraint satisfaction problem instance ( ) and subsequently utilizing a a state - of - the - art solver for solving it , plus managing the overhead involved in the resulting distributed algorithm .",
    "the resulting algorithm , however , closely follows the scheme of the original algorithm as listed in algorithm  [ alg : ma - plan ] .",
    "from now on , whenever we speak about the implementation of the multi - agent planning algorithm , we have in mind its decentralized version due to nissim et al .  @xcite .",
    "consider a multi - agent planning problem @xmath31 and a plan @xmath57 solving @xmath56 .",
    "furthermore , consider an environment in which , apart from the actions performed by the agents of the team @xmath32 , no other exogenous events occur .",
    "we say that such an environment is _ ideal _ , or _",
    "non - dynamic_. the execution of @xmath57 in such an environment is uniquely determined by the set of states @xmath129 , such that @xmath130 $ ] ( cf .",
    "also definition  [ def : multi - agent - plan ] ) .    in dynamic environments ,",
    "however , it can occur that in the course of execution of @xmath57 , the environment interferes and the execution of some action @xmath131 $ ] from the plan @xmath57 does not result in precisely the state @xmath132 as defined above .",
    "we could say that at step @xmath40 an unexpected event occurred in the environment . for simplicity , we consider only unexpected events happening exclusively in the course of execution of some action ( as if it took a non - zero time ) , not such which could occur while the agent is deliberating the execution ( i.e. , as if the deliberation was instantaneous ) .",
    "note that not all unexpected events in a dynamic environment necessarily lead to problems with execution of the plan @xmath57 . however , there are at least two cases of such events , which can be considered a _ plan execution failure . _    a _ weak failure _ of execution of the plan @xmath57 at step @xmath40 w.r.t .",
    "the multi - agent planning problem @xmath56 is such , when the state @xmath133 resulting from an attempt to perform an action @xmath134 $ ] for some @xmath40 does not satisfy some of the postconditions of @xmath51 , i.e. , @xmath135 .",
    "a _ strong failure _ of execution of the plan @xmath57 at step @xmath40 w.r.t .",
    "the planning problem @xmath56 occurs whenever the @xmath40-th action of @xmath57 can not be executed due to its inapplicability .",
    "i.e. , the execution of the plan up to the step @xmath40 resulted in states @xmath136 , possibly with some weak failures occurring in the course of execution of the plan fragment and @xmath131 $ ] is not applicable in @xmath137 .",
    "the weak and the strong plan execution failures are , however , just two examples of a plan failure .",
    "there certainly are application domains in which weak failures can be tolerated as far as the goal state is reached after execution of the multi - agent plan .",
    "alternatively , there might be domains in which other types of plan execution failures can occur , e.g. ,  any change of the state not caused by the involved agents can be considered a failure as well . to account for the range of various types failures , from now on",
    ", we only require that a plan execution monitoring process determines some plan execution failure at a step @xmath40 which results in some failed state  @xmath133 .",
    "[ def : multi - agent - plan - repair ] let @xmath31 be a multi - agent planning problem .",
    "multi - agent _ _ plan repair problem _ is a tuple @xmath138 , where @xmath57 is a multi - agent plan solving the planning problem @xmath56 , @xmath50 is the step of @xmath57 in which its execution failed and @xmath139 is the corresponding failed state .    _ a solution to the plan repair problem _ @xmath140 is a multi - agent plan @xmath141 , such that @xmath141 is a solution to the planning problem @xmath142 .",
    "we say that @xmath141 _ repairs _",
    "@xmath57 in @xmath133 . in the case",
    "@xmath143 , we say that the plan is _ irreparable _ given the failure occurring at the state  @xmath133 .",
    "given two multi - agent plans @xmath78 and @xmath79 both repairing a multi - agent plan @xmath57 for a problem @xmath56 in a state @xmath133 , we say that @xmath78 is _ preserving @xmath57 more _ than @xmath79 iff @xmath144 and denote the relation by @xmath145 .",
    "the _ minimal repair of the multi - agent plan _ @xmath57 is such a plan @xmath146 , which is minimal w.r.t .  the mutual differences between the plans solving @xmath147",
    ". i.e. , @xmath148 .",
    "note , there might be several distinct minimal repairs of a given multi - agent plan .",
    "in general , the multi - agent plan repair problem can be reduced to solving a modified multi - agent planning problem and thus gives rise to a straightforward plan repair algorithm based on _ replanning _ in two steps : 1 ) construct the multi - agent replanning problem @xmath147 as prescribed in definition  [ def : multi - agent - plan - repair ] , and subsequently 2 ) utilize the algorithm ( algorithm  [ alg : ma - plan ] ) to solve the problem @xmath147 .",
    "the original motivation underlying this paper was the hypothesis that attempts to repair failed multi - agent plans lead to lower communication overhead than replanning .",
    "clearly , not all planning problems could benefit from such a mechanism . since we focus on multi - agent planning problems , which in a sense _ enforce _ _ coordination _ among the members of a multi - agent team , we firstly introduce the concept of @xmath50-coordinated multi - agent planning problems .",
    "[ def : k - tightness ] we say that a multi - agent plan @xmath57 is _ @xmath50-coordinated _ iff each fragment @xmath57 of length @xmath50 contains at least one joint action containing a public action . formally , for every @xmath141 , s.t .",
    "@xmath149 with @xmath150 , there exist @xmath40 and @xmath76 so that @xmath151\\in\\actions^{\\mathit{pub}}$ ] .",
    "we say that a multi - agent problem @xmath56 is _ @xmath50-coordinated _ iff all the plans @xmath152 solving @xmath56 , which can not be compressed are @xmath50-coordinated .",
    "a plan @xmath152 can be _ compressed _ iff it contains a fragment @xmath141 , s.t .",
    "@xmath149 and @xmath153 .",
    "we informally say that multi - agent planning problems leading to plans containing coordination points ( public actions ) placed relatively frequently throughout the plans are tightly coordinated .",
    "more formally , a multi - agent planning problem @xmath56 is _ tightly coordinated _",
    "if it is @xmath50-coordinated and @xmath50 is relatively low in comparison to the lengths of plans from @xmath70 . in the case",
    "@xmath50 is relatively high w.r.t .",
    "the plan lengths , we say that the problem is _ loosely coordinated _ and finally , if the plans do not involve public actions , i.e. , coordination is not needed at all , we say the problem is _",
    "uncoordinated_.    the core hypothesis of the paper can be then formulated as follows :    [ hyp : repair - lower - overhead ] multi - agent plan repair approaches producing more preserving repairs than replanning tend to generate _ lower communication overhead _ for tightly coordinated multi - agent problems .    a crisper , though perhaps a more challenging version of the hypothesis would express the communication overhead in terms of the average communication complexity :    [ hyp : repair - lower - comm - complexity ] when applied to tightly coordinated planning problems , multi - agent plan repair algorithms producing more preserving repairs than replanning feature a _ lower average communication complexity _ than replanning .    in the remainder of this paper , we approach resolution of hypothesis  [ hyp : repair - lower - overhead ] .",
    "treatment of hypothesis  [ hyp : repair - lower - comm - complexity ] is beyond the scope of this paper and is left for future work .",
    "unexpected event occurring in an environment can cause a failure in execution of a plan performed by some multi - agent team in that environment .",
    "the result is that the overall state of the system is not the one expected by the undisturbed plan execution at the particular time step .",
    "a straightforward idea to fix the problem is to utilize a multi - agent planner to produce a plan from the failed state to the originally expected state and subsequently follow the rest of the original multi - agent plan from the step in which the failure occurred .",
    "the following multi - agent plan repair approach , coined _ back - on - track _ ( bot ) _ _ repair , is inspired by this idea , in fact a slight generalization of it .",
    "[ def : back - on - track - repair]let @xmath138 be a multi - agent plan repair problem and @xmath154 being the corresponding modified multi - agent replanning problem .",
    "we say that a plan @xmath155 is a _ back - on - track _ _ repair _ of @xmath57 iff there is a decomposition of @xmath141 , such that @xmath156 $ ] for some @xmath157 .",
    "@xmath156 $ ] is said to be a _",
    "proper back - on - track _ _ repair _ iff @xmath158|>0 $ ] .",
    "i.e. , @xmath141 preserves some non - empty suffix of @xmath57 .",
    "informally , the back - on - track approach tries to preserve a suffix of the original plan and prefix it with a newly computed plan @xmath159 starting in @xmath133 and leading to some state along the execution of @xmath57 in the ideal environment .",
    "note , that all plans from @xmath160 are back - on - track repairs of the original plan .",
    "the length of the preserved suffix of the original plan provides a handle on the repair quality ordering of the plans .",
    "the longer the preserved suffix , the more preserving the plan is . on the other hand , even when the plan repair problem @xmath140 is indeed solvable , there might not be any valid proper back - on - track repair of the original planning problem .    algorithm  [ alg : ma - back - on - track - repair ] realizes a multi - agent plan repair procedure according to the back - on - track plan repair principle . since the algorithm searches for the shortest plan from the initial state to a goal state ,",
    "the computes plans which return back to the original one in the shortest possible way .    a multi - agent plan repair problem @xmath138 , with @xmath123 and a sequence of states @xmath161 execution of @xmath57 generates in the ideal environment .",
    "a multi - agent plan @xmath162 solving @xmath140 if a solution exists . construct @xmath163 retrieve the state @xmath164 of @xmath57 to which @xmath165 returns @xmath166 $ ]      the back - on - track multi - agent plan repair approach seeks to compute a new prefix to some suffix of the original plan and repair the failure by their concatenation .",
    "an alternative approach , coined _ lazy _ , attempts to preserve the remainder of the original multi - agent plan and close the gap between the state resulting from the failed plan execution and a goal state of the original planning problem .",
    "let @xmath133 be the state resulting from a failure in execution of a multi - agent plan @xmath57 in a step @xmath50 .",
    "we say that a sequence of joint actions @xmath141 is an _ executable remainder _ of @xmath57 from the step @xmath50 and the state @xmath133 iff there exists a sequence of states @xmath167 , such that @xmath168 , @xmath169 $ ] and for every step @xmath40 and every agent @xmath76 , we have that @xmath170=\\mathcal{p}[i , j]$ ] in the case @xmath84 $ ] is applicable in the state @xmath171 and @xmath170=\\epsilon$ ] otherwise .",
    "the following definition provides a formal definition of the lazy approach .",
    "[ def : lazy - repair ] let @xmath138 be a multi - agent plan repair problem and @xmath142 being the corresponding modified multi - agent replanning problem .",
    "we say that a plan @xmath155 is a _ lazy _ _ repair _ of @xmath57 iff there is a decomposition of @xmath141 , such that @xmath172}\\cdot\\mathcal{p}^{\\mathit{lazy}}$ ] , where @xmath173}$ ] is the executable remainder of @xmath57 from the step @xmath50 , execution of which results in the state @xmath174 when starting in @xmath133 , and @xmath175 is a solution to the multi - agent planning problem @xmath176",
    ".    algorithm  [ alg : ma - lazy - repair ] realizes multi - agent plan repair based on the lazy repair approach described above .",
    "a multi - agent plan repair problem @xmath138 , with @xmath123 and @xmath177 . a multi - agent plan @xmath162 solving the problem @xmath140 according to the lazy approach , if a solution exists .",
    "construct @xmath173}$ ] , the executable remainder of @xmath57 from the step @xmath50 and state @xmath133 construct @xmath178 let @xmath179 be a solution to @xmath180 if such exists .",
    "@xmath173}\\cdot\\mathcal{p}^\\mathit{lazy}$ ]    the back - on - track approach always succeeds to compute some multi - agent plan repairing the original plan from the failed state in the case the replanning form scratch would compute such a plan from that state as well .",
    "the lazy approach is in this sense incomplete , as it might happen that the execution of the executable remainder of the original plan diverges to a state from which no plan to some goal state exists . given that dynamic environment in general could generate irreparable failures , this incompleteness can not be considered a shortcoming of the lazy approach in general .",
    "of course in domains in which no irreparable unexpected event might occur , while at the same time the agents are allowed to perform actions potentially having irreversible and potentially harmful effects , the lazy approach has to be employed with caution",
    ".      in dynamic environment plan failures occur repeatedly , i.e. , even after a repair of a failed plan , it is possible for the repaired plan to fail again . in this situation both the back - on - track , as well as the lazy multi - agent plan repair algorithms",
    "lead to prolonging the really executed plan . in the case of the back - on - track approach ,",
    "this is inevitable , since upon the repair , the subsequent plan execution process immediately processes the newly added plan fragment . in the case of the lazy repair , however , upon occurrence of another failure during execution of the repaired plan , it is not always necessary to prolong the overall multi - agent plan .",
    "the intuition behind the _ repeated lazy plan repair _ approach is that a failure during execution of an already repaired plan makes the previous repair attempt irrelevant and its result can be discarded , unless the failure occurred already in the plan fragment appended by the previous repair .",
    "the following definition formally introduces the extension of the lazy multi - agent plan repair approach . for clarity , from now on",
    ", we refer to the lazy multi - agent plan repair approach introduced in definition  [ def : lazy - repair ] as _ simple lazy repair_.    [ def : repeated - lazy - repair]let @xmath31 be a multi - agent planning problem with a solution @xmath57 and @xmath181 be a multi - agent plan repair problem with a lazy repair solution @xmath182}\\cdot\\mathcal{p}_{\\mathit{suffix}}$ ] and @xmath183 be a multi - agent plan repair problem the system is currently facing .",
    "we say that @xmath141 is a _ repeated lazy repair _ of @xmath78 iff    1 .",
    "@xmath141 is a simple lazy repair solution to @xmath184 in the case @xmath185}|$ ] ; and 2 .",
    "@xmath141 is a simple lazy repair solution to @xmath186 otherwise .",
    "the repeated lazy repair leads to a straightforward extension of the lazy plan repair algorithm listed in algorithm  [ alg : ma - lazy - repair ] .",
    "note , that the repeated lazy repair algorithms enables a plan execution model which preserves significantly longer fragments of the original plan .",
    "that is , upon a failure , instead of trying to repair the failed plan right away , as both the back - on - track and simple lazy plan repair algorithms do , the system can simply proceed with execution of the remainder of the original plan and only after its complete execution the lazy plan repair is triggered .",
    "the approach simply ignores the plan failures during execution and postpones the repair the very end of the process , hence the `` _ _ lazy _ _ '' label for the two algorithms .    a multi - agent planning problem @xmath123 , a multi - agent plan @xmath187}\\cdot\\mathcal{p}_\\mathit{suffix}$ ] solving @xmath56 , and two multi - agent plan repair problems @xmath188 with a solution @xmath189 and @xmath190 . a multi - agent plan solving @xmath191 if a solution exists .",
    "construct @xmath192 @xmath193 a solution to if such exists",
    "to verify the hypothesis  [ hyp : repair - lower - overhead ] , we conducted a series of experiments with implementations of the multi - agent plan repair algorithms described in section  [ sec : multi - agent - plan - repair ] .",
    "below , we firstly describe the experimental setup used for the experiments and subsequently interpret the data collected and revisit hypothesis  [ hyp : repair - lower - overhead ] .",
    "the experiments were based on a two - stage algorithm . in the first phase , for a given domain a multi - agent plan",
    "was computed using the algorithm based on a distributed constraint satisfaction solver for computing the candidate coordination plans and implementation of a best - first - search action planning algorithm as part of  @xcite for computing the local , single - agent plans .",
    "we used the implementation of the distributed multi - agent planner authored by nissim et al .",
    "also used for the experiments conducted in their paper  @xcite . in the second phase , we executed the multi - agent plan .",
    "in the course of the plan execution , we simulated the environment dynamics by producing various plan failures according to a variable failure probability .",
    "the plan execution was monitored and upon a failure detection a plan repair algorithm was invoked .",
    "algorithm  [ alg : ma - monitor - exec ] lists the pseudo - code of the process .",
    "before execution of each plan step , the joint action is checked for applicability in the current state . in the case",
    "it is not applicable , a plan repair algorithm is invoked and the execution continues on the repaired plan .",
    "otherwise , the state is updated with the joint action .",
    "the function in the algorithm either updates the current state by the joint action provided as a parameter as if in the ideal environment , or to generate an unexpected event occurring in the simulated dynamic environment .    we distinguish two types of plan failures : _ action failures _ and _ state perturbations_. both failure types are parametrized by a uniformly distributed probability @xmath37 , which determines whether a simulation step fails , or not .",
    "both failure types are weak failures .",
    "that is , they are not handled immediately , but can preclude the plan execution and later result in a strong failure . upon detection , a strong failure",
    "is handled by one of the plan repairing algorithms .",
    "an initial multi - agent planning problem @xmath123 .",
    "@xmath194    @xmath195 ; @xmath196    @xmath197    @xmath196    @xmath198)$ ]    @xmath199    an _ action failure _ is simulated by not - executing some of the individual agent actions from the actual plan step .",
    "the individual action is chosen according to a uniformly distributed probability .",
    "the individual action is removed from the joint action and the current state is updated by the modified joint action .",
    "the other simulated failure type , _ state perturbation , _ is parametrized by a positive non - zero integer @xmath200 , which determines the number of state terms , which are removed from the current state , as well as the number of terms which are added to it . the terms to be added or removed are selected also randomly from the domain language according to a uniform distribution .    the experimental setup was implemented as a centralized simulator of the environment integrating a decentralized multi - agent domain - independent planner .",
    "the individual agents are initialized by a planning domain , together with a particular planning problem instance .",
    "each agent runs in its own thread and they deliberate asynchronously .",
    "the agents send peer - to - peer messages among themselves .",
    "message passing is mediated by the centralized simulator as well .",
    "the messages are sent in the phase by the integrated solver , which is a part of the planner .",
    "the experiments were performed on _ phenom quad core 9950 _ processor at 2.6ghz with _ java virtual machine _",
    "limited to 2.5 gb of ram .",
    "the individual measurements were parametrized by the plan failure probability @xmath37 and each problem instance was executed 610 with various value samples .",
    "the resulting data are , in the figures , presented with natural distribution .",
    "the candlestick charts depict the difference between the minimal and the maximal measurements , together with the standard deviation .",
    "the experiments were conducted on three planning domains .",
    "the domains originate in the standard benchmark single - agent icp planning domains published at  @xcite . similarly to  @xcite , we chose domains , which are straightforwardly modifiable to multi - agent planning problems : logistics ( 3 agents ) , rovers ( 3 agents ) , and satellites ( 25 agents ) .    the logistics domain is a tightly coordinated in that it requires relatively frequent coordination among the involved agents : airplanes and trucks need to wait for each other to load or unload the transported packages .",
    "the rovers domain is loosely coordinated in that it requires coordination only at the end of plans : there is a single shared communication channel between one of the rovers and the receiving station .",
    "finally , the satellites domain is uncoordinated in that it does not need any coordination between the satellites acquiring images individually .    to evaluate validity of hypothesis  [ hyp : repair - lower - overhead ]",
    ", the multi - agent planning problems were tested on the experimental setup against a plan repair algorithm implementing replanning from scratch and two of the repair algorithms ( algorithm  [ alg : ma - back - on - track - repair ] ) and ( algorithm  [ alg : ma - repeated - lazy - repair ] ) introduced in section  [ sec : multi - agent - plan - repair ] .",
    "efficiency problems of the implementation limited the experiments to plans with maximally two landmarks ( coordination points ) .",
    "the measurements of algorithm runs were negatively influenced by sensitivity of the planner implementation to the number of terms in the goal state .",
    "additionally , the algorithm could not leverage disjunctive goal form ( cf .  definition  [ def : back - on - track - repair ] ) and this was emulated by iterative process testing all term conjunctions in a sequence and thus resulting in multiple runs of the solver instead of a single run with disjunctive goal .",
    "we used three metrics to evaluate the measurements :    execution  length : :    is the overall number of joint actions the experimental setup    executed .",
    "planning  time : :    is the measured cumulative time consumed by the underlying planner    used for generating initial and repairing plans ; and finally communication : :    is measuring the number of messages passed between the agents during    the planning or plan repair process . that is messages generated by the    solver in the planner .",
    "experimental results for logistics domain with 3 agents and action failures . ]    experimental results for logistics domain with 3 agents and action failures . ]    experimental results for logistics domain with 3 agents and action failures . ]    experimental results for rovers domain with 3 agents and action failures ( top ) . experimental results for logistics domain with 3 agents and state perturbations with @xmath201 ( bottom ) . ]    experimental results for rovers domain with 3 agents and action failures ( top ) .",
    "experimental results for logistics domain with 3 agents and state perturbations with @xmath201 ( bottom ) . ]    experimental results for logistics domain with 3 agents and state perturbations with @xmath201 . ]",
    "the first batch of experiments directly targets validation of hypothesis  [ hyp : repair - lower - overhead ] : _ multi - agent plan repair is expected to generate lower communication overhead in tightly coordinated domains_. we used logistics as a tightly coordinated domain and dynamics of the simulated environment modeled as action failures .",
    "figure  [ fig : experimental - results - for-1 ] depicts the results of the experiment .",
    "the communication overhead generated by the algorithm is on average only 59% ( 36% at best ) of that generated by the replanning approach .",
    "furthermore , the algorithm performed even better and on average produced only 43% ( 11% at best ) of the communication overhead generated by the replanning algorithm . in result",
    ", the experiments _ strongly support _ our hypothesis .    additionally , the overall time spent in the planning phase ( used by the algorithm ) by the plan repair algorithms was 54% ( 34% at best ) and 51% ( 12% at best ) for and respectively .",
    "the execution length was lower in comparison the replanning approach as well being in average 96% ( 72% at best , 130% at worst ) by and lower being 81% ( 34% at best , 132% at worst ) for .    the second batch of experiments focused on boundaries of validity of the positive result presented above . in particular",
    ", we validated the condition on the coordination tightness and feasibility of failures .",
    "the auxiliary hypothesis we validated states : _ with decreasing coordination tightness of the domain , the communication efficiency gains of repairing techniques should decrease . for loosely coordinated domains",
    "the communication efficiency of plan repair should be on - par _ _ with that of the replanning approach_.    to validate the auxiliary hypothesis we ran experiments with the rovers as a loosely coordinated domain .",
    "figure  [ fig : experimental - log - sp-1 ]  ( top ) presents the results supporting the hypothesis .",
    "the third batch of experiments targeted the perturbation magnitude of the plan failures .",
    "the second auxiliary hypothesis we validated states : _ communication efficiency gain of plan repairing in contrast to replanning should decrease as the difference between a nominal and related failed state increases_. the underlying intuition is that , in the case the dynamic environment generates only relatively small state perturbations and the failed states are `` not far '' from the actual state , the plan repair should perform relatively well . on the other hand ,",
    "if the state essentially `` teleports '' the agents to completely different states , replanning tends to generate more efficient solutions than plan repair .    to answer this hypothesis ,",
    "we have prepared another logistics experiment employing state perturbations as the model of the environment dynamics .",
    "figure  [ fig : experimental - log - sp-1 ]  ( bottom ) depicts results of the experiment for @xmath201 .",
    "the perturbed state for @xmath201 is produced by removing one term from the actual state and adding another one . as the chart shows , under random perturbations the plan repairing technique lost its improvement against replanning .",
    "for stronger perturbations with @xmath202 , the ratio between plan repairing and replanning remained on average the same .",
    "the trend of the absolute numbers of messages , planning time and execution length was slightly decreasing , as the probability of opportunistic effects increased .",
    "finally , we conducted a series of experiments with a non - coordinated sattelites domain .",
    "the results depicted in figure  [ fig : experimental - log - sp-1 ] show the anticipated lower plan repair communication efficiency in contrast to replanning .",
    "in the presented paper , we formally introduced the problem of multi - agent plan repair , proposed three algorithms for solving it and experimentally validated the hypothesis stating that under certain conditions , multi - agent plan repair approach tends to be more efficient in terms of the communication overhead it generates in comparison to the replanning approach .",
    "our results well support the core hypothesis of the paper and we additionally performed a series of experiments validating its boundary conditions .",
    "the line of research underlying this paper well correlates with recent works on classical single - agent planning sub - domains , such as partial ordered plan monitoring and repairing  @xcite , conformant and contingency planning , plan re - use and plan adaptation .",
    "environment dynamics is also handled by approaches based on markov decision processes .",
    "the main difference to our approach is that the state perturbations utilized in our experiments have _ a priori _ unknown probabilities .",
    "our own recent approach to the problem of multi - agent plan repair in  @xcite can be seen only as a precursor to the formal and rigorous treatment of the problem in this paper .",
    "therein , we described the first steps towards formal treatment of the problem , as well as proposed two specific incomplete algorithms for solving the problem , very distinct from the ones presented here .",
    "there are several open challenges resulting from the presented work .",
    "firstly , the multi - agent planning framework ( ma - strips ) is not expressive enough to describe certain aspects of concurrent actions and should be extended to this end , what , we suspect , will also influence the multi - agent planning complexity analysis . in particular , there is no way to account for joint actions which have effects strictly different than the unity of the individual actions involved .",
    "another issue is that there is no way to enforce or forbid concurrent execution of certain individual actions .",
    "secondly , the framework is not able to describe concurrent resource consumption , which is not an issue in single - agent strips  @xcite planning , but in the multi - agent extension two individual concurrently executed actions might `` consume '' the same precondition , even though it is undesirable in the domain .",
    "thirdly , there is a need for more efficient implementations of multi - agent planners with more features as the gap between the state - of - the - art classical planners and multi - agent planners is enormous .",
    "fourthly , there is a lack of standardized planning benchmarks for multi - agent planning , especially considering tightly coordinated planning problems . such are needed to further evaluate the hypotheses presented in this paper .",
    "finally , we leave out the work towards resolving the validity of hypothesis  [ hyp : repair - lower - comm - complexity ] aiming at investigation of complexity issues of multi - agent plan repair to future work ."
  ],
  "abstract_text": [
    "<S> achieving joint objectives by teams of cooperative planning agents requires significant coordination and communication efforts . for a single - agent system facing a plan failure in a dynamic environment , arguably , attempts to repair the failed plan in general do not straightforwardly bring any benefit in terms of time complexity </S>",
    "<S> however , in multi - agent settings the communication complexity might be of a much higher importance , possibly a high communication overhead might be even prohibitive in certain domains . </S>",
    "<S> we hypothesize that in decentralized systems , where coordination is enforced to achieve joint objectives , _ attempts to repair failed multi - agent plans should lead to lower communication overhead than replanning from scratch_.    the contribution of the presented paper is threefold . </S>",
    "<S> firstly , we formally introduce the multi - agent plan repair problem and formally present the core hypothesis underlying our work . </S>",
    "<S> secondly , we propose three algorithms for multi - agent plan repair reducing the problem to specialized instances of the multi - agent planning problem . </S>",
    "<S> finally , we present results of experimental validation confirming the core hypothesis of the paper . </S>"
  ]
}