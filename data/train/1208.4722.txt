{
  "article_text": [
    "an access control mechanism is responsible within an information system of intercepting any access made by a user over a resource , deciding whether this access should be allowed or not , and enforcing the corresponding decision .",
    "most existing mechanisms rely on the definition of an _ access control policy _ , defined in a dedicated language ( e.g. , rbac  @xcite , xacml  @xcite ) , which can be roughly seen as a set of rules separating the set of accesses into the secure ones and the non - secure ones .",
    "we recently proposed in  @xcite to model an access control mechanism as a markov decision process ( mdp )  @xcite .",
    "the main strength of this approach is to account for uncertainty and probabilistic behaviour of the system directly into the decision mechanism . from a global point of view , such a modelling expresses the fact that making an access control decision can be done using tools from decision theory . by using an mdp instead of a traditional security mechanism",
    ", one can express an intuitive notion of _ utility _ rather than a standard classification between secure and non - secure situations .",
    "this is particularly useful in some critical environments , where at a given point in time , it might only be possible to choose between `` bad '' situations .",
    "for instance , a study  @xcite revealed that in a particular healthcare system , 74% of users have manual overriding permissions and 54% of records have been accessed at least once using an overriding permission .",
    "such situations are due to the conflicting choice between respecting the static policy and providing the best possible care to the patients .",
    "the typical example is that of a nurse , who is normally not authorized to access the medical record of a patient , and who needs to access it in order to deliver some treatment while no attending physician is available .",
    "the information system can only choose between two `` bad '' options : granting the access to the nurse , and therefore breaching patient confidentiality , or denying the access , and therefore risking the life of the patient .",
    "we present in this paper a detailed example of the implementation of an access control - markov decision process ( ac - mdp ) using glpk / gmpl .",
    "the objective of this paper is therefore to present a basic and simple guide of what to do and what to expect when implementing an ac - mdp . in order to do so",
    ", we introduce a simple running example , that we will tweak along the paper in order to illustrate how changing some parameters might change the results .",
    "we try to present our approach from the perspective of a security engineer responsible for implementing a security mechanism for a concrete problem , loosely inspired from the healthcare context .",
    "the rest of this paper is therefore organized as follows : in section  [ sec : problem ] , we state the concrete problem we want to implement and we recall the basic definition of an ac - mdp . in section  [ sec : general ] , we present the general implementation in glpk / gmpl of the ac - mdp for this concrete problem , and we instantiate this general model in section  [ sec : concrete ] .",
    "finally , we discuss the different results and the important points to extract from our approach in section  [ sec : discussion ] .      to the best of our knowledge ,",
    "our recent approach  @xcite was the first usage of markov decision processes in the context of access control systems .",
    "however , the problem of dealing with risk and uncertainty for access control systems has been already studied in the literature .",
    "for instance , aziz _ et al . _",
    "@xcite refine a policy to a more restrictive one , in order to deal with threats .",
    "risk is often considered as an input to the system , that must stay below a certain threshold .",
    "et al . _",
    "introduce in  @xcite the fuzzy multi - level security model , where each access is associated with a level of risk , and the final decision of the authorization mechanism is given according to some predefined risk thresholds .",
    "_  extend this approach in  @xcite by considering costs in terms of availability , integrity and confidentiality for each decision , and use thresholds for each corresponding risk .",
    "some approaches aim at calculating the risk from the environment .",
    "for instance ,",
    "_  introduce in  @xcite fuzzy security parameters that can be inferred from traditional parameters , hence introducing a notion of uncertainty directly into the parameters of the system , while chen and crampton present in  @xcite a way to calculate the risk for a rbac model , using intuitive notions of competence and distance between users , roles and permissions .",
    "the probabilistic change of security attributes is considered by krautsevich _",
    "_  in   @xcite , who model this change using a markov chain .",
    "dealing with uncertainty requires quantitative techniques , and therefore accesses must be associated with a utility value .",
    "some models use these notions , for instance krautsevich _",
    "_  extend in  @xcite the auto - delegation mechanism  @xcite with probabilistic availability , reusing some notions of utility functions previously introduced in  @xcite .",
    "similarly , molloy _ et al . _",
    "present in  @xcite a model to predict and make local decisions under uncertainty , where the system needs to choose between taking a decision locally or defer it to a central server , according to the utility of the access and the cost of communicating with the server .    beyond the scope of access control , several pieces of work use the concept of markov decision process ( mdp ) in the context of security .",
    "for instance , kreidl introduces in  @xcite a simple mdp with only three states ( normal , under attack and failure ) and three decisions ( wait , defend and reset ) , which analyses the cost of defending countermeasures against the cost of an intrusion .",
    "similarly , he _",
    "et al . _",
    "present in  @xcite an analysis of the operational costs and the negative and positive impact of security countermeasures using domain partitional markov decision processes , which partition the network into several security domains , each domain coming with its own mdp .",
    "this work , as the previous one , mostly focuses on the detection of intrusions and the decisions needed when some are discovered .",
    "finally , singh _ et al .",
    "_  use in  @xcite an mdp to make channel assignments for network devices .",
    "this problem can be considered as a special instance of an access control problem , where the devices ask to access channels , with a specific policy stating that any device can access a channel , but the more devices use a given channel , the lower is the utility for this channel .",
    "hence , our approach can be seen as a more general approach , where the policy is not constrained .",
    "as we said in the introduction , we present our approach from the perspective of security engineer , who is responsible for implementing a security mechanism for a concrete problem .",
    "let us first introduce this problem .",
    "let @xmath0 be a simple system such that :    1 .",
    "there are two users , and , such that ( for instance , a physician ) is more qualified than ( for instance , a nurse ) ; 2 .",
    "there are two resources , and , such that the resource ( for instance , one of s patient record ) is more sensitive than ( for instance , some indicates related to a drug ) ; 3 .",
    "is not normally qualified enough to access ; 4 .   in case of emergency ( for instance ,",
    "the patient is having a heart attack ) , the resource should be accessed .",
    "the role of the security engineer is therefore to define a mechanism that , given some the current state and an access @xmath1 , where @xmath2 is a user and @xmath3 a resource , returns a security decision , such as or .",
    "the traditional approach to do so is to define a security policy , that is , a set of rules describing what decision to make for each access , and then to define a simple program that checks if the given access satisfies the policy or not .",
    "for instance , we could define the following policy , for any access @xmath1 :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ if @xmath4 , @xmath5 and there is no emergency , then else .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    there exist many languages ( e.g. , xacml ) in which this policy can be defined .",
    "however , defining a `` static '' policy requires to resolve beforehand all possible situations . in our example",
    ", there is a clear conflict between rules 3 and 4 : in case of emergency , if is not accessing , then either we allow to access it , thus breaking rule 3 , or we do not , thus breaking rule 4 .",
    "note that there exist some approaches to deal with this particular problem of delegation ( in case of unavailability , should automatically delegate her right over to ) , such as  @xcite , however we want to illustrate a more general problem : the combination of rules might lead to conflicting situations .",
    "the resolution of such conflicts is usually addressed by considering composition operators , thus allowing some rules to take precedence over others .",
    "we propose here a different approach , where conflict resolution is obtained as the result of an optimization process .    indeed , we defined in  @xcite a novel approach , where the security policy is not defined , but _ derived _ from a decision process .",
    "intuitively , the responsibility of the security engineer is only to put some values on the different resource and/or states of the system , to describe the probabilistic behaviour of the system , and the optimal policy can be automatically defined .",
    "more precisely , the security engineer must defined an access control markov decision process ( ac - mdp ) , given by :    an ac - mdp is a tuple @xmath6 , where :    * @xmath7 is a set of access control states , such that @xmath8 represents the security information of the state and @xmath9 the access requests ( each state containing a request to control ) , * @xmath10 is a set of decisions , * @xmath11 $ ] is the probability function , such that @xmath12 , which , for the sake of exposition , we also write @xmath13 , stands for the probability of reaching the state @xmath14 by executing the decision @xmath15 from the state @xmath16 , * @xmath17 is the reward function , such that @xmath18 , also written as @xmath19 , stands for the reward associated with executing the decision @xmath15 from the state @xmath16 and arriving in the state @xmath14 .",
    "it is worth noting that we consider here that the reward is a _",
    "function , and that therefore the objective of the process is to eventually _ maximize _ the accumulated rewards .",
    "we could equivalently consider the reward as a _ cost _ , and in this case the objective would be to minimize it . in the following , for the sake of clarity , we associate gain with positive rewards , and cost with negative rewards , the important point being to _ compare _ two values between each other .",
    "we write @xmath20 for the immediate reward for executing the decision @xmath15 in the state @xmath16 : @xmath21 in this context , a security policy is a function @xmath22 , and the value @xmath23 of each state for this policy can be defined as : @xmath24 where @xmath25 is a discount factor , indicating how much weight is put on the value of future states .",
    "the optimal policy @xmath26 is the policy that maximizes the value function , that is , for any policy @xmath27 and any state @xmath28 , we have @xmath29 . more formally , given a state @xmath16 , the optimal policy @xmath26 is given by : @xmath30\\ ] ] clearly , this policy is not necessarily unique .",
    "for instance , in the degenerate case where all decisions are associated with the same reward , then any policy is optimal .",
    "this case would be equivalent to defining a policy for an access that has the same impact whether it is allowed or denied . in order to define the actual policy and to solve the non - determinism of choosing between several optimal policies",
    ", we could introduce an arbitrary ordering among decisions , such that if in a given state , two decisions maximize the value , we take the smallest .    with our approach , instead of defining directly the policy , the security engineer instantiates the ac - mdp ( and in particular the function @xmath31 and @xmath32 ) , and the optimal policy can be calculated as an optimization problem .",
    "we present in the following sections how to perform such instantiation for the concrete example .",
    "glpk is a piece of software intended for solving large - scale linear programming problems , and it supports the gmpl language for modeling problems , which is a subset of ampl .",
    "we now show how to implement an ac - mdp in gmpl . for the sake of exposition",
    ", we first present the `` model '' part of the implementation , that is , the part that does not depend on concrete values for the parameters , and we define in the following section some concrete values for these parameters .",
    "this implementation is directly inspired from that provided by vincent conitzer in his lecture on linear and integer programming .",
    "we first define the set @xmath8 of security information and the set @xmath9 of requests . based on the problem description ,",
    "we assume the qualifications of the entities to be fixed , thus not belonging to the state , and therefore we define the security information as a pair @xmath33 , where @xmath34 is a boolean indicating whether there is a current emergency and @xmath35 is the set of current accesses , such that an access is simply a pair @xmath1 .",
    "furthermore , we model a request directly as an access .    for the sake of generality , we define as parameters the number of users @xmath36@nu@}}$ ] and resources @xmath36@nr@}}$ ] , and we define the set of users and resources as indices .",
    "we also introduce the `` empty '' request ` ( eps , eps ) ` , that represents the fact that there is no access request to control .",
    "param nu default 2 ; set users : = 0 .. (nu-1 ) ;    param nr default 2 ; set resources : = 0 .. (nr-1 ) ;    set access : = users cross resources ;    param eps , symbolic ; set faccess : = access union ( eps , eps ) ;    the state should include all previous currently granted accesses , however gmpl does not natively support powersets .",
    "instead , we use a workaround by indexing each element of the powerset : we first associate each access @xmath1 with the index @xmath37@nr@ } } + r}$ ] ( e.g. , in our settings , the index of @xmath38 is @xmath39 , the index of @xmath40 is @xmath41 , etc ) ; we then create the set ` pa ` , which ranges from @xmath42 to @xmath43@nu*nr@}}}-1 $ ] ; finally , we define the set ` pow ` which is indexed by ` pa ` , such that , intuitively speaking , in the binary representation of ` k ` , the @xmath44-th bit is equal to 1 if , and only if , ` pow[k ] ` contains the access indexed by @xmath44 .",
    "for instance , for the index @xmath36@k@ } } = 5 $ ] , that is @xmath36@k@ } } = 101 $ ] in binary , we have that ` pow[5 ] ` contains exactly the accesses indexed by @xmath39 and @xmath45 , i.e. , the accesses @xmath46 and @xmath47 .",
    "this encoding is defined in gmpl as follows .",
    "param n : = ( nu)*(nr ) ; set pa : = 0 .. ( 2**n - 1 ) ; set pow k in pa : = setof(u , r ) in access : ( k div 2**(u * nr + r ) ) mod 2 = 1(u , r ) ;    note that the indexation of ` pow ` is done over ` access ` and not ` faccess ` , meaning that , by construction , the empty request can not belong to the set of previously granted accesses .",
    "a state is then given by an emergency status , a set of accesses and an access to control :    param calm , symbolic ; param alert , symbolic ; set emergency : = calm , alert ;    set states : = emergency cross pa cross faccess ;    for instance , the state ` [ calm , 1 , 1 , 0 ] ` represents the state of the system that is in a ` calm ` status , where the access ` [ 0,0 ] ` ( corresponding to ` pow[1 ] ` ) has been previously granted and where the current access to control is ` [ 1,0 ] ` ] ` , even though the access ` [ 1 , 0 ] ` is a pair itself .",
    "finally , we define the set of actions @xmath48 .",
    "param allow , symbolic ; param deny , symbolic ;    set actions : = allow , deny ;      we now show how to define the transition function @xmath31 , using three sub - functions , one for each component of a state .",
    "the probability of switching from one emergency status to another is given as a concrete parameter ( we actually study the behaviour of the model when this parameter is variating in section  [ sec : emvar ] ) and therefore only declared in the model .",
    "param transition_emergency e1 in emergency , e2 in emergency ;    concerning the set of current accesses , for the sake of simplicity , we do not consider here probabilistic modifications .",
    "in other words , whenever an access is allowed , the following state contains it .",
    "however , it would be straightforward to extend this transition function to also consider the possibility that an access granted is not added , or even that a denied access is in fact performed .",
    "we could also model here the fact that at any time , there is a risk of leakage of information , that is , there is a non - null probability that a non requested access will be added to the set of current accesses in the next state .",
    "param transition_access s1 in pa , ( u , r ) in faccess , a in actions , s2 in pa : = if ( a = deny or u = eps ) then ( if s1 = s2 then 1 else 0 ) else ( if ( ( pow[s2 ] within ( pow[s1 ] union ( u , r ) ) ) and ( ( pow[s1 ] union ( u , r ) ) within pow[s2 ] ) ) then 1 else 0 ) ;    an important point of our modelling is the fact that the state contains the request to control , and it follows that when defining the transition to the next state , we must also define what will be the next request to control .",
    "we first assume that it is always ` [ eps , eps ] ` ( i.e. , we only control one request at the time ) , and we release this assumption in section  [ sec : complexreq ] .",
    "param transition_req s1 in pa , ( u , r ) in faccess , a in actions , ( u2,r2 ) in faccess : = if ( u2 = eps and r2 = eps ) then 1 else 0 ;    finally , the transition probability is given by the product of the three previous sub - functions",
    ".    param transition ( e1 , s1 , u1 , r1 ) in states , a in actions , ( e2 , s2 , u2 , r2 ) in states : = transition_emergency[e1 , e2 ] * transition_access[s1 , u1 , r1 , a , s2 ] * transition_req[s1 , u1 , r1 , a , u2 , r2 ] ;      to some extent , defining the reward function corresponds to defining the policy , in the sense that instead of stating if an access is correct or not , the security engineer attaches a value to it , and this value will be later use to determine whether the access should be allowed or not . hence , we declare to basic reward functions : ` reward\\_access[u , r ] ` indicates the value gained by granting the access ` [ u , r ] ` , and ` reward\\_resources[r ] ` indicates the value of not accessing the resource ` r ` in case of emergency .",
    "we instantiate these functions in section  [ sec : concrete ] .",
    "param reward_access ( u , r ) in access ; param reward_resource r in resources ;    from the function ` reward\\_resource ` , we can define the reward associated with a state , which is , in case of emergency , the sum of the reward of each resource .",
    "param reward_emresource ( e , s , u , r ) in states : = if ( e = calm ) then 0 else sum r1 in resources : forallu1 in users ( u1,r1 ) not in pow[s ] reward_resource[r1 ] ;    finally , we can define the reward associated with an entire transition , thus corresponding to the function @xmath32 of the ac - mdp .",
    "param reward_transition ( e , s , u , r ) in states , a in actions , ( e2 , s2 , u2 , r2 ) in states : = ( if u = eps and r = eps then 0 ) else ( if a = allow then reward_access[u , r ] else 0 ) + ( reward_emresource[e2,s2,u2,r2 ] ) ;    it is worth noting that if the state contains the empty request to control , then regardless of the decision , the reward of the transition is null .",
    "we can now define the optimization problem , in order to calculate the maximal value function , and thus the optimal policy .",
    "we first introduce the immediate reward , as defined in equation  .",
    "param immediate_reward ( e , s , u , r ) in states , a in actions : = sum ( e2 , s2 , u2 , r2 ) in states ( transition[e , s , u , r , a , e2,s2,u2,r2 ] * reward_transition[e , s , u , r , a , e2,s2,u2,r2 ] ) ;    intuitively , we want to define the value function of the optimal policy @xmath49 , that is , for each state @xmath16 , we want to define the equation : @xmath50 \\label{eq : value_mdp}\\ ] ] in which case we would just need to solve the corresponding system of equations .",
    "however , we can not directly follow this approach , because the operator @xmath51 is not linear . as stated by conitzer in his lecture ,",
    "the typical solution for this kind of problem is to define the equations such that @xmath52 must be greater or equal to @xmath53 , for any decision @xmath15 , and to minimize the value of @xmath52 , which thus corresponds to the lowest greater bound . in order to minimize each @xmath52",
    ", we simply aim at minimizing the sum of all the values .",
    "var value(e , s , u , r ) in states ;    minimize total : sum(e , s , u , r ) in states value[e , s , u , r ] ; s.t .",
    "bellman(e , s , u , r ) in states , a in actions : value[e , s , u , r ] >",
    "= immediate_reward[e , s , u , r , a ] + sum(e2 , s2 , u2 , r2 ) in states(beta*transition[e , s , u , r , a , e2,s2,u2,r2]*value[e2,s2,u2,r2 ] ) ;",
    "the model presented in the previous section represents a `` general '' implementation of the problem the security engineer wants to address : the number of users and resources can easily be extended , the rewards for accesses and states are not precisely defined , the probability of changing the emergency status is not specified , neither is the discount factor @xmath54 .",
    "we show in this section how to define these particular values , and we describe the corresponding results .    in order to compare the different results obtained , we focus on the value , from the empty state ( i.e. , where no access has been previously granted ) , of allowing or denying each access .",
    "more precisely , given an emergency status @xmath34 and an access @xmath1 such that @xmath55 , and a decision @xmath15 , we define the decision value @xmath56 as : @xmath57 the security mechanism then selects the decision with the highest value .",
    "we first define a `` naive '' instantiation , somewhat equivalent to the static policy presented in section  [ sec : problem ] . in order to remove the values of the future states from the equation , we set the discount factor to 0 .",
    "we also assume that the emergency status can not change ( i.e. we should make the decision considering that the status will not change ) .",
    "param transition_emergency:= [ * , * ] : calm alert : = calm 1 0 alert 0 1 ;    we also give arbitrary values for the reward function , trying to keep the idea of the original policy ( for the sake of readability , we have used the names of the users and resources instead of their indices , as it is done in the actual implementation ) .",
    "param reward_access : = [ * , * ] : high low : = alice 6 10 bob 4 -10 ;    param reward_resource : = low 0 high -20 ;    as for the policy defined in section  [ sec : problem ] , we consider here that the reward for leaving the resource non accessed in case of emergency is worse than letting accessing .",
    "however , as we will see in the following , this does not necessarily imply that will always be able to access .    since the discount factor @xmath54",
    "is set to @xmath42 , the decision value is directly equal to the immediate reward .",
    "for instance , if we allow the access @xmath58 , we get an immediate reward of 6 , while allowing the access @xmath59 brings a reward of -10 .",
    "furthermore , if the reached state is in an emergency status , and the resource @xmath60 is not accessed , we also get a reward of -20 .",
    ".decision values for @xmath61 and emergency probability of @xmath42 [ cols=\"^,^,^,^,^,^\",options=\"header \" , ]     it is worth observing that the request transition has an important impact on the actual decision values , but the ordering is almost always preserved .",
    "indeed , the decision value of is always higher than that of for the accesses @xmath58 , @xmath62 and @xmath63 , and for the access @xmath59 when the state is known to be in the ` alert ` status .",
    "however , from a state in a ` calm ` status , for the behaviours and , it is better to deny the access @xmath59 while for the behaviour , it is better to allow it .",
    "this result is somewhat counter - intuitive , since one could expect that for and , if we deny the access , the probability that the resource will be accessed is quite low , while for , even if we deny the access to , we know that will ask for the access in the future , and therefore that will be eventually accessed . in fact , this result is due to the fact that we automatically associate the state containing the empty request with a null value . in other words , we do not take into account the fact that the system might stay forever in a state where is not accessed . on the other hand , for , we have somehow infinite sequences of requests , which automatically gives a high value to all states .",
    "we can modify the behaviour such that starting from state a containing the empty request takes the reward of the reached state ( i.e. , in our example , the same state ) into account :    param reward_transition ( e , s , u , r ) in states , a in actions , ( e2 , s2 , u2 , r2 ) in states : = ( if a = allow and u ! = eps then reward_access[u , r ] else 0 ) + ( reward_emresource[e2,s2,u2,r2 ] ) ;    in this case , the decision values for the behaviour do not change , on the contrary of the and behaviours , for which the ordering of the decisions for the access @xmath59 in the ` calm ` status actually change . indeed , for , denying this access leads to a value of -105.26 , while allowing it leads to -10 .",
    "similarly , for , denying it leads to a value of -32.35 , while allowing it leads to -1.59 .",
    "in other words , the values for allowing the accesses are identical to those in table  [ tab : complexvalues ] , but the values for denying are much lower , thus reflecting the idea that the state is likely to remain in a `` bad '' state , where is not accessed .    nonetheless , it is interesting to observe that although the ordering between the different behaviors is usually the same , meaning that we make decisions consistent with the original policy , the difference between the value of each decisions can significantly vary .",
    "for instance , consider the access @xmath58 for the behaviour in the ` calm ` status : denying it leads to a value of 34.80 , while allowing it `` only '' leads to a value of 40.80 .",
    "in other words , the gain of allowing versus denying it is quite low , relatively and absolutely speaking .",
    "if we were to attribute a priority for the treatment of this access , we could probably give it a low one .",
    "on the other hand , for , from the ` alert ` status , the differential for the access @xmath62 is very important : the value of denying it is 4.55 , while allowing it brings a value of 55 , i.e. , multiplying the value by a factor greater than 10 .",
    "in other words , there is no doubt at all that this access should be allowed in these conditions .",
    "it is therefore interesting to observe that in addition to the decision , our approach also provides the `` strength '' or `` confidence '' in the decision .",
    "finally , our last experiment consists in calculating how , for a given discount factor ( @xmath64 , the decision values vary when the emergency probability varies . intuitively , if the system is very stable ( i.e. , the probability equals 0 ) , then any transition from a calm state leads to a calm state , and the system does not need to care whether @xmath60 is accessed or not . on the other hand ,",
    "if the system is very unstable ( i.e. , the probability equals 1 ) , then any transition will lead to an emergency state , in which case the system has to ensure as much as possible that the resource @xmath60 is accessed .",
    "we show in figure  [ fig : variation ] these results , for each request behaviour .",
    "firstly , we can observe that for the resource , the value of denying an access to it , regardless of the user , is always lower than allowing it .",
    "it therefore fits with the intuition that whatever the emergency status , there is no gain in denying an access to the resource .",
    "we can similarly observe that for a given resource , the value of allowing the access for is always greater than allowing the access for , which is consistent with the requirement that is more qualified than .",
    "finally , it is interesting to see that the emergency probability required for the value of allowing @xmath59 to be higher than that of denying it changes according to the request behaviour : it is exactly 0.5 for , around 0.19 for and between 0.09 and 0.1 for .",
    "this observation means that in order to make the best decision , it is not enough to know the values for each access and the probability of emergency , one also needs to know what will be the future behaviour of the system and/or of the user .",
    "in this paper , we started from a very concrete problem , loosely inspired from the healthcare context , and we gradually implemented a security mechanism based on an access control markov decision process .",
    "we have shown how changing the different parameters can have an impact on the final decision values .",
    "it is worth mentioning that the computational complexity does not change when the parameters change : in other words , it takes the same time and the same memory to compute all decision values in table  [ tab : basicvalues ] than to compute those for a specific request behaviour as in table  [ tab : complexvalues ] .",
    "similarly , it could be possible to create more complex reward functions , the significant computational parameter being the number of states , not the way the reward function is calculated ( although these two notions can of course be related , i.e. , in order to have an expressive reward function , one might need to extend the state ) .",
    "we believe that this approach raises the following observations and questions :    @xmath65 it is possible to define an access control mechanism taking into account different reward functions using linear programming for two users and two resources .",
    "what about several dozens of users and several thousand of files ?",
    "it is probably not reasonable to expect to find the optimal policy at runtime , but it could be done at compile time , since we actually compute the values for _ all _ states .    @xmath66",
    "the ordering between the value of two decisions defines the policy ( i.e. , we pick the decision with the highest value ) , but the differential between these values is also significant , and could be used for instance to represent a notion of priority .",
    "can we use this difference as an intuitive idea of trust ?",
    "@xmath67 the future behaviour of the system has an impact : the best decision for a single access might be different whether another access will be submitted in the future , and we can calculate what this difference will be , but how reasonable is it to predict what will be the future behaviour ?",
    "@xmath68 our approach can also be used as an analysis tool , in order to understand the impact of changing one parameter , but how to define the initial parameters ? how to know whether the reward @xmath59 is -10 and not -42 ?",
    "clearly , we probably bring more questions than answers , but we believe that using quantitative tools can help the definition of security mechanisms , in particular by providing the security engineer with a new way of thinking her security problem , and we hope to pave the way towards a generalized usage of such tools .",
    "cheng , p.  rohatgi , c.  keser , p.  a. karger , g.  m. wagner , and a.  s. reninger .",
    "fuzzy multi - level security : an experiment on quantified risk - adaptive access control . in _ proceedings of the 2007 ieee symposium on security and privacy _ , pages 222230 , washington , dc , usa , 2007 .",
    "ieee .",
    "n.  n. diep , l.  x. hung , y.  zhung , s.  lee , y .- k .",
    "lee , and h.  lee .",
    "enforcing access control using risk assessment . in _ proceedings of the fourth european conference on universal multiservice networks _ , pages 419424 .",
    "ieee computer society , 2007 .",
    "h.  he , y.  shuping , and p.  wu .",
    "security decision making based on domain partitional markov decision process . in _ information engineering and computer science , 2009 .",
    "iciecs 2009 . international conference on _ , pages 1 4 , dec .",
    "l.  krautsevich , a.  lazouski , f.  martinelli , and a.  yautsiukhin .",
    "influence of attribute freshness on decision making in usage control . in _ proceedings of the 6th international workshop on security and trust management_. springer , 2010 .",
    "l.  krautsevich , a.  lazouski , f.  martinelli , and a.  yautsiukhin .",
    "risk - aware usage decision making in highly dynamic systems . in _ proceedings of the fifth international conference on internet monitoring and protection_. ieee , 2010 .",
    "o.  p. kreidl .",
    "analysis of a markov decision process model for intrusion tolerance . in _ proceedings of the 2010 international conference on dependable systems and networks workshops ( dsn - w ) _ , dsnw 10 , pages 156161 .",
    "ieee computer society , 2010 .          q.  ni , e.  bertino , and j.  lobo .",
    "risk - based access control systems built on fuzzy inferences . in _ proceedings of the 5th acm symposium on information , computer and communications security _ , pages 250260 , new york , ny , usa , 2010 ."
  ],
  "abstract_text": [
    "<S> in a recent approach , we proposed to model an access control mechanism as a markov decision process , thus claiming that in order to make an access control decision , one can use well - defined mechanisms from decision theory . </S>",
    "<S> we present in this paper an implementation of such mechanism , using the open - source solver glpk , and we model the problem in the gmpl language . </S>",
    "<S> we illustrate our approach with a simple , yet expressive example , and we show how the variation of some parameters can change the final outcome . in particular , we show that in addition to returning a decision , we can also calculate the value of each decision . </S>"
  ]
}