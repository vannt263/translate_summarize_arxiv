{
  "article_text": [
    "interval arithmetic is a mean to perform numerical computations and to get a guarantee on the computed result . in interval arithmetic ,",
    "one computes with intervals , not numbers .",
    "these intervals are guaranteed to contain the ( set of ) exact values , both input values and computed values , and this property is preserved throughout the computations .",
    "indeed , the fundamental theorem of interval arithmetic is the _ inclusion property _ : each computed interval contains the exact ( set of ) result(s ) . to learn more about interval arithmetic , see @xcite .",
    "the inclusion property is satisfied by the definition of the arithmetic operations , and other operations and functions acting on intervals .",
    "implementations of interval arithmetic on computers often rely on the floating - point unit provided by the processor .",
    "the inclusion property is preserved via the use of directed roundings .",
    "if an interval is given exactly for instance by its endpoints , the left endpoint of its floating - point representation is the rounding towards @xmath0 of the left endpoint of the exact interval .",
    "likewise , the right endpoint of its floating - point representation is the rounding towards @xmath1 of the right endpoint of the exact interval .",
    "similarly , directed roundings are used to implement mathematical operations and functions : in this way , roundoff errors are accounted for and the inclusion property is satisfied .    in this paper , the focus is on the problems encountered while implementing interval arithmetic , using floating - point arithmetic , on multicore architectures . in a sense",
    "these issues relate to issues known as problems of _ numerical reproducibility _ in scientific computing using floating - point arithmetic on emerging architectures .",
    "the common points and the differences and concerns which are specific to interval arithmetic will be detailed .",
    "the main contributions of this paper are * the identification of problems that cause numerical irreproducibility of interval computations , and recommendations to circumvent these problems*. the classification proposed here distinguishes between three categories . the first category , addressed in section [ sec.prec ] , concerns problems of variable computing precision that occur both in sequential and parallel implementations , both for floating - point and interval computations .",
    "these behaviours are motivated by the quest of speed , at the expense of accuracy on the results , be they floating - point or intervals results . however , even if these behaviours hinder numerical reproducibility , usually they do not threaten the validity of interval computations : interval results satisfy the inclusion property .",
    "the second category , developed in section [ sec.order ] , concerns the order of operations .",
    "due mainly to the indeterminism in multithreaded computations , the order of operations may vary .",
    "it is the most acknowledged problem .",
    "again , this problem is due to the quest of short execution time , again it hinders numerical reproducibility of floating - point or interval computations , but at first sight it does not invalidate the inclusion property .",
    "however , an interval algorithm will be presented , whose validity relies on an assumption on the order of operations .",
    "the problems of the third category , detailed in section [ sec.rndg ] , are specific to interval computations and have an impact on the validity of interval results .",
    "the question is whether directed rounding modes , set by the user or the interval library , are respected by the environment .",
    "these problems occur both for sequential and parallel computations .",
    "ignoring the rounding modes can permit to reduce the execution time .",
    "indeed , changing the rounding mode can incur a severe penalty : the slowdown lies between 10 and 100 on architectures where the rounding modes are accessed via global flags and where changing a rounding mode implies to flush pipelines .",
    "however , it seems that the most frequent motivation is either the ignorance of issues related to rounding modes , or the quest for an easier and faster development of the execution environment by overlooking these issues .    for each category , we give recommendations for the design of interval algorithms : numerical reproducibility is still not attained , but the impact of the problems identified is attenuated and the inclusion property is preserved . + before detailing our classification , numerical reproducibility is defined in section [ sec.pb ] and then an extensive bibliography is detailed in section [ sec.prev ] .",
    "in computing in general and in scientific computing in particular , the quest for speed has led to parallel or distributed computations , from multithreaded programming to high - performance computing ( hpc ) . within such computations ,",
    "contrary to sequential ones , the order in which events occur is not deterministic .",
    "events here is a generic term which covers communications , threads or processes , modification of shared data structures  .",
    "the order in which communications from different senders arrive at a common receiver , the relative order in which threads or processes are executed , the order in which shared data structures such as working lists are consulted or modified , is not deterministic .",
    "indeed , for the example of threads , the quest for speed leads a greedy scheduler to start a task as soon as it is ready , and not at the time or order at which it should start in a sequential execution .",
    "one consequence of this indeterminism is that speed is traded against numerical reproducibility of floating - point computations : computed results may differ , depending on the order in which events happened in one run or another . however , numerical reproducibility is a desirable feature , at least for debugging purposes : how is it possible to find and fix a bug that occurs sporadically , in an indeterministic way ?",
    "testing is also impossible without numerical reproducibility : when a program returns results which differ from the results of a reference implementation , nothing can be concluded in the absence of numerical reproducibility . to address the issue of numerical reproducibility , in @xcite , not only the use of higher computing precision",
    "is recommended , but also the use of interval arithmetic or of some variant of it in order to get numerical guarantees , and the use of tools that can diagnose sensitive portions of code and take corrective actions .",
    "we follow these tracks and we focus on interval arithmetic , the same conclusions can be drawn for its `` variants '' such as affine arithmetic or polynomial models , e.g. taylor models .",
    "first , let us introduce the problem of numerical reproducibility in floating - point arithmetic .",
    "floating - point arithmetic is standardised and the ieee-754 standard @xcite specifies completely the formats of floating - point numbers , their binary representation and the behaviour of arithmetic operations .",
    "one of the goals of this standardisation was to enable portability and reproducibility of numerical computations across architectures",
    ". however , several runs of the same code on different platforms , or even on the same platform when the code is parallel ( typically , multithreaded ) may yield different results . getting the same result on the same platform is sometimes called _",
    "repeatability_. only the word _",
    "reproducibility _ will be used throughout this paper .",
    "let us give a first explanation to the lack of numerical reproducibility . on some architectures , and with some programming languages and compilers , intermediate computations such as",
    "the intermediate sum in @xmath2 can take place with variable precision .",
    "this precision can depend on the availability of extended size registers ( such as 80-bits registers on x87 or ia64 architectures , when computing with 64-bit operands ) , on whether operations use registers or store intermediate results in memory , on data alignment or on the execution of other threads @xcite , on whether an intermediate computation is promoted to higher precision or not .",
    "the impact of the computing precision on numerical irreproducibility is discussed in details in section [ sec.prec ] .",
    "let us stick to our toy example @xmath2 to illustrate a second cause to numerical irreproducibility .",
    "as floating - point addition is not associative ( neither is multiplication ) , the order according to which the operations are performed matters .",
    "let us illustrate this with an example in double precision : @xmath3 ( where @xmath4 stands for _ rounding - to - nearest _ ) yields @xmath5 , since @xmath6 , whereas @xmath7 yields @xmath8 , since @xmath9 . the last result is called a _ catastrophic cancellation _ : most or all accuracy is lost when close ( and even equal in this example ) large numbers are subtracted and only roundoff errors remain , hiding the meaningful result .",
    "real - life examples of this problem are to be found in @xcite , where the results of computations for ocean - atmosphere simulation strongly depends on the order of operations .",
    "other examples are given in @xcite for the numerical simulation of punching of metal sheets .",
    "this lack of associativity of floating - point operations implies that the result of a reduction operation depends on the order according to which the operations are performed .",
    "however , with multithreaded or parallel or distributed implementations , this order is not deterministic and the computed result thus varies from one execution to the next .",
    "how the order of operations influences numerical computations and interval computations is detailed in section [ sec.order ] .",
    "a last issue , which is specific to the implementation of interval arithmetic on parallel environments , is the respect of rounding modes .",
    "as already mentioned , the implementation of interval arithmetic crucially requires directed rounding modes .",
    "however , it has been observed that rounding modes are not respected by numerical libraries such as blas @xcite , nor by compilers when default options are used , nor by execution environment for multithreaded computations , nor by parallel languages such as openmp or opencl . either this is not documented , or this is explicitly mentioned as being not supported , cf .",
    "section [ sec.rndg ] for a more detailed discussion .",
    "respecting the rounding modes is required by the ieee-754 standard for floating - point arithmetic and the behaviours just mentioned are either misbehaviours as in the example of section [ subsec.rndg.pbs ] , or are ( often undocumented ) features of the libraries , often `` justified '' by the quest of shorter execution times .",
    "+ these phenomena explain the lack of numerical reproducibility for floating - point computations , i.e. the fact that two different runs yield two different results , or the loss of the inclusion property in interval arithmetic , due to the non - respect of rounding modes .",
    "+ facing this lack of reproducibility , various reactions are possible .",
    "one consists in acknowledging the computation of differing results as an indication of a lack of numerical stability . in a sense ,",
    "a positive way of considering numerical irreproducibility is to consider it as useful information on the numerical quality of the code .",
    "however , for debugging and testing purposes , reproducibility is more than helpful . for such purposes , _",
    "numerical reproducibility means getting bitwise identical results from one run to the next_. indeed , this is the most common definition of numerical reproducibility .",
    "this definition is also useful for contractual or legal purposes ( architectural design , drug design are instances mentioned in the slides corresponding to @xcite ) , as long as a reference implementation , or at least a reference result , is given .",
    "however , this definition is not totally satisfactory as the result is not well - defined .",
    "in particular , it says nothing about the accuracy of the result .",
    "requiring the computed result to be the correct rounding of the exact result is a semantically meaningful definition of numerical reproducibility .",
    "the computed result is thus uniquely defined .",
    "the difficulty with this definition is to devise an algorithm that is efficient on parallel platforms and that computes the correct rounding of the exact result .",
    "this definition has been adopted in @xcite , for lhc computations of 600,000 jobs on 60,000 machines : efficient mathematical functions such as exponential and logarithm , with correct rounding , were available . however , in most cases it is not known how to compute efficiently the correctly rounded result . for this reason , this definition of numerical reproducibility as computing the correct rounding of the exact result may be too demanding .",
    "thus we prefer to keep separate the notions of numerical reproducibility ( i.e. getting bitwise identical results ) and of correct rounding .",
    "+ to sum up , numerical reproducibility can be defined as getting bitwise identical results , where these results have to been specified in some way , e.g. by a reference implementation which can be slow .",
    "we consider it is simpler not to mix this notion with the notion of correct rounding of the exact result , which is uniquely specified .",
    "our opinion has been reinforced by the results in @xcite : it is even possible to define several levels of numerical reproducibility , each one corresponding to a level of accuracy .",
    "one has thus a hierarchy of reproducibilities , corresponding to different tradeoffs between efficiency and accuracy , ranging from low numerical quality to correct rounding .",
    "in the previous section , we introduced various sources of numerical irreproducibility and we delineated their main features . more detailed and technical explanations are given in @xcite : implementation issues such as data race , out - of - order execution , message buffering with insufficient buffer size , non - blocking communication operations are also introduced .",
    "a tentative classification of indeterminism can be found in @xcite , it distinguishes between _ external determinism _ that roughly corresponds to getting the same results independently of the internal states reached during the computation , and _ internal determinism _ that requires that internal execution steps are the same from one run to the other .",
    "external indeterminism can be due to data alignment that varies from one execution to the next , order of communications with  wildcard receives \" of mpi , and other causes already mentioned . in what follows , only external indeterminism will be considered .",
    "+ numerical irreproducibility , in particular of summations of floating - point numbers , is cited as early as 1994 in @xcite for weather forecasting applications .",
    "more recently , it has been clearly put in evidence in @xcite where the application is the numerical simulation of a deep drawing process for deforming metal sheets : depending on the execution , the computed variations of the thickness of the metal sheet vary .",
    "other references mentioning numerical irreproducibility are for instance @xcite for an application in ocean - atmosphere simulation , @xcite and reference @xmath10 $ ] herein about digital breast tomosynthesis , or @xcite for power state estimation in the electricity grid .",
    "+      the non - associativity of floating - point operations is the major explanation to the phenomenon of numerical irreproducibility .",
    "the simplest problem that exemplifies the non - associativity is the summation of @xmath11 floating - point numbers .",
    "it is also called a reduction of @xmath11 numbers with the addition operation .",
    "not surprisingly , many efforts to counteract numerical irreproducibility focus on the summation problem , as accuracy can be lost due to catastrophic cancellation or catastrophic absorption in summation . let us list some of them in chronological order of publication .",
    "an early work @xcite on the summation uses and compares several techniques to get more accuracy on the result : the conclusion is that compensated summation and the use of double - double arithmetic give the best results . following this work , for physical simulations , in @xcite conservation laws",
    "were numerically enforced using compensated sums , either kahan s version or knuth s version , and implemented as mpi reduction operators .",
    "similarly , in @xcite , a simplified form of `` single - single '' arithmetic is employed on gpu to sum the energy and satisfy numerically the conservation law .",
    "bailey , the main author of qd , a library for double - double and quad - double arithmetic @xcite , also advocates the use of this higher - precision arithmetic in @xcite .",
    "however , even if the use of extra computing precision yields accurate results for more ill - conditioned summations , which means the obtention of results with more correct bits , it does not ensure numerical reproducibility , as solving even worse - conditioned problems shows . since the problem can be attributed to the variations in the summation order , a first approach to get reproducible results",
    "consists in fixing the reduction tree @xcite .",
    "more precisely , using a fixed integer @xmath12 , the array of summands is split into @xmath12 chunks of consecutive subarrays , each subarray ( or chunk ) being summed sequentially ( but each chunk can be summed independently of the other ones ) and then the order of the reduction of the @xmath12 partial sums is also sequential .",
    "another approach in @xcite consists in what is called _ pre - rounding_. even if the actual implementation is very different from the process explained here , it can be thought of as a sum in fixed - point , as learnt in elementary school .",
    "the mantissa of every summand is aligned with respect to the point , then a leftmost `` vertical slice '' is considered and added to produce a sum @xmath13 .",
    "the width of this slice is chosen in such a way that the sum @xmath13 can be performed exactly using the width of the mantissa of floating - point numbers ( e.g. 53 bits for the double precision format ) .",
    "as this sum @xmath13 is exact , it is independent of the order in which the additions are performed and is thus numerically reproducible on any platform . to get a more accurate result , a second vertical slice , just right to the first one , can be summed , again yielding an exact sum @xmath14 and the final result is the ( floating - point , thus inexact ) sum of @xmath13 and @xmath14 .",
    "an increase of the number @xmath12 of slices corresponds to an increase of the computing precision .",
    "however , for a fixed @xmath12 , each partial sum @xmath15 is exact and thus numerically reproducible .",
    "the details to determine the slices and to get @xmath16 are given in @xcite and a faster algorithm for exascale computing , i.e. for really large platforms , is provided in @xcite .      in @xcite a tool , called marmot , that detects and signals race conditions and deadlocks in mpi codes is introduced , but reduction operations are not handled .",
    "the original proposal for java by gosling @xcite included numerical reproducibility of floating - point computations . to reach reproducibility , it prohibited the use of any format different from binary32 and binary64 , the use of the fma as well as any optimisation based on the associativity of the operators .",
    "it also forbade changes of the rounding modes @xcite and the only rounding mode is to - nearest ( * ? ? ?",
    "* section 4.2.4 ) .",
    "it did not include the handling of exceptions via flags , as required by the ieee-754 standard .",
    "the seminal talk by kahan in 1998 @xcite has shaken these principles . actually kahan disputed mainly the lack of exception handling and the restriction to shorter ( thus , less precise ) formats even when longer ones are available .",
    "it seems that this dispute opened the door to variations around java .",
    "indeed java grande @xcite proposes to allow the use of longer formats and of fma .",
    "the use of the associativity of operations to optimise the execution time has been under close scrutiny for a longer lapse of time and remains prohibited ( * ? ? ?",
    "* section 15.7.3 ) , as explicit rules are given , e.g. left - to - right priority for @xmath17 , @xmath18 , @xmath19 .",
    "however , strict adherence to the initial principles of java can be enforced by using the ` strictfp ` keyword .",
    "for instance , the vseit environment for modelling complex systems , simulating them and getting a graphical view @xcite , uses the ` strictmath ` option in java as a way to get numerical reproducibility .",
    "however , the need for getting reproducibility is not explained in much details .",
    "finally , intel mkl ( math kernel library ) 11.0 introduces a feature called conditional numerical reproducibility ( cnr ) @xcite which provides functions for obtaining reproducible floating - point results . when using these new features , intel mkl functions are designed to return the same floating - point results from run - to - run , subject to the following limitations :    * calls to intel mkl occur in a single executable * input and output arrays in function calls must be aligned on 16 , 32 , or 64 byte boundaries on systems with sse / avx1 / avx2 instructions support ( resp . ) * the number of computational threads used by the library remains constant throughout the run .",
    "these conditions are rather stringent .",
    "another approach to numerical reproducibility consists in providing correctly rounded functions , at least for the mathematical library @xcite .",
    "the approaches presented here are not yet entirely satisfactory , either because they do not really offer numerical reproducibility or because they handle only summation , or because performances are too drastically slowed down .",
    "furthermore , none addresses interval computations . in what follows ,",
    "we propose a classification of the sources of numerical irreproducibility for interval computations and some recommendations to circumvent these problems , even if we do not have the definitive solution . in our classification ,",
    "a first source of problem is the variability of the employed computing precision .",
    "the computing precision used for floating - point computations depends on the employed format ( as defined by ieee-754 standard @xcite ) .",
    "the single precision corresponds to the representation of floating - point numbers on 32 bits , where 1 bit is used for the sign , 8 bits for the exponent and the rest for the significand .",
    "the corresponding format is called ` binary32 ` . the double precision uses 64 bits , hence the name `",
    "binary64 ` , with 1 bit for the sign and 11 for the exponent .",
    "the quadruple precision , also known as ` binary128 ` , uses 128 bits , with 1 bit for the sign and 15 bits for the exponent .",
    "the rest of section [ subsec.prec.pbsfp ] owes much to @xcite .    on some architectures ( ia32 / x87 )",
    ", registers have a longer format : 80 bits instead of 64 .",
    "the idea prevailing to the introduction of these long registers was to provide higher accuracy by computing , for a while , with higher precision than the binary64 format and to round the result into a binary64 number only after several operations .",
    "however it entailed the so - called `` double - rounding '' problem : an intermediate result is first rounded into a 80-bit number , then into a 64-bit number when it is stored , but these two successive roundings can yield a result different from rounding directly into a 64-bit number . from the point of view of numerical reproducibility , the use of extended precision registers is also troublesome , as the operations which take place within registers and the temporary storage into memory can occur at different stages of the computation , they may vary from run to run , depending for instance on the load of the current processor , on data alignment or on the execution of other threads @xcite .",
    "another issue is the format chosen for the intermediate result , say for the intermediate sums in the expression @xmath20 , where @xmath21 , @xmath22 , @xmath23 and @xmath24 are binary32 floating - point formats . notwithstanding the order in which the intermediate sums are computed , let us focus on the problem of the precision . if the architecture offers binary64 and if the language is c or python , then the intermediate sums may be promoted to binary64 .",
    "it will not be the case if the language is java with the ` strictfp ` keyword , or fortran . in c , it may or may not be the case , depending on the compiler and on the compilation options : the compiler may prefer to take advantage of a vectorised architecture like sse2 or avx , where two binary32 floating - point additions are performed in parallel , in the same amount of time as one binary64 floating - point addition . the compiler may thus choose to execute @xmath25 in ` binary32 ` , where the two additions @xmath26 and @xmath27 are performed in parallel , as it will execute faster than @xmath28 .",
    "the compiler may also decide to use more accurate registers ( 64 bits or 80 bits ) when such vectorised devices are not available .",
    "thus , depending on the programming language , on the compiler and its options and on the architecture , the intermediate results may vary , as does the final result . in some languages , it is possible to gain some a posteriori knowledge on the employed precision . in c99 , the value of `",
    "flt_eval_method ` gives an indication , at run - time , on the intermediate chosen format : indeterminate , double or long double .",
    "the notion of precision in interval arithmetic could be regarded as the radius of the input arguments .",
    "it is known that the overestimation of the result of a calculation is proportional to the radius of the input interval , with a proportionality constant which depends on the computed expression .",
    "more precisely ( * ? ? ?",
    "* section 2.1 ) , if @xmath29 is a lipschitz - continuous function : @xmath30 , then @xmath31 where boldface letters denote interval quantities , @xmath32 is the exact range of @xmath29 over the interval @xmath33 , @xmath34 is an overestimation of @xmath32 computed from an expression for @xmath29 using interval arithmetic in a straightforward way , and @xmath35 stands for the hausdorff distance .",
    "as the first interval here encloses the second , @xmath36 is simply @xmath37 . in this formula",
    ", @xmath38 can be considered as the precision .",
    "it is possible to improve this result by using more elaborate approaches to interval arithmetic , such as a taylor expansion of order 1 of the function @xmath29 .",
    "indeed , if @xmath29 is a continuously differentiable function then ( * ? ? ?",
    "* section 2.3 ) , @xmath39 where @xmath34 is computed using a so - called centered form . as @xmath29 is lipschitz",
    ", it holds that the radius of @xmath40 is also proportional to the radius of the input interval . in other words ,",
    "the accuracy on the result improves with the radius , or precision , of the input .",
    "these results hold for an underlying exact arithmetic . +",
    "this result in interval analysis can be seen as an equivalent to the rule of thumb in numerical floating - point analysis ( * ? ? ?",
    "* chapter 1 ) . considered with optimism",
    ", this means that it suffices to increase the computing precision  in floating - point arithmetic  or the precision on the inputs  in interval arithmetic  to get more accurate results . in interval arithmetic , this can be done through bisection of the inputs , to get tight intervals as inputs and to reduce @xmath38 in the formula above .",
    "the final result is then the union of the results computed for each subinterval .",
    "a more pragmatic point of view is first that , even if the results are getting more and more accurate as the precision increases , there is still no guarantee that the employed precision will allow to reach a prescribed accuracy for the result .",
    "second , reproducibility is still out of reach , as developed in section [ sec.order ] .",
    "+ in what follows , we consider interval arithmetic implemented using floating - point arithmetic .",
    "the aforementioned theorems , that bound @xmath41 , do not account for the limited precision of the underlying floating - point arithmetic . indeed",
    ", computed interval results also suffer from the problems of floating - point arithmetic , namely the possible loss of accuracy .",
    "even if directed roundings make it possible to ensure the inclusion property , there is no information about how much the exact interval is overestimated , and no guarantee about the tightness of the computed interval .",
    "we advocate the use of the mid - rad representation on the one hand , and the use of iterative refinement on the other hand .",
    "the mid - rad representation @xmath42 corresponds to the interval @xmath43 = \\ { x \\ : : \\ : |m - x| \\leq r \\}$ ] .",
    "an advantage of the mid - rad representation is that thin intervals are represented more accurately in floating - point arithmetic .",
    "for instance , let us consider @xmath44 a non - zero floating - point number and @xmath45 , i.e. @xmath38 is a power of 2 that corresponds , roughly speaking , to half the last bit in the floating - point representation of @xmath44 .",
    "( let us recall @xcite that for @xmath46 , if @xmath47 then @xmath48 in radix-2 floating - point arithmetic with @xmath49 bits used for the significand and that @xmath50 for negative @xmath51 . ) in this example , @xmath44 and @xmath38 are floating - point numbers .",
    "then the floating - point representation by endpoints of the interval is @xmath52 $ ] , ( where @xmath53 denotes the rounding mode towards @xmath0 or rounding downwards and @xmath54 denotes the rounding mode towards @xmath1 or rounding upwards ) , which is @xmath55 $ ] : in this example , the width of the interval is doubled with the representation by endpoints .",
    "the reader has to be aware that no representation , neither mid - rad nor by endpoints , always supersedes the other one .",
    "an example where the mid - rad representation is superior to the representation by endpoints has just been given .",
    "conversely , an unbounded interval can be represented by its endpoints , say @xmath56 , but the only enclosing mid - rad representation @xmath57 with @xmath58 , corresponds to @xmath59 .",
    "we also recommend the use of iterative refinement where applicable . indeed , even if the computations of the midpoint and the radius of the result suffer from the aforementioned lack of accuracy , iterative refinement ( usually a few iterations suffice ) recovers a more accurate result from this inaccurate one .",
    "let us illustrate this procedure on the example of square linear system solving @xmath60 ( cf .",
    "* chapter 4 ) , ( * ? ? ? * chapter 7 ) , @xcite for an introduction ) .",
    "once an initial approximation @xmath61 is computed , the residual @xmath62 is computed _ using twice the current precision _ ( and here we rejoin the solutions in @xcite already mentioned ) , as much cancellation occurs in this calculation .",
    "then , solve  again approximately  the linear system @xmath63 with the same matrix @xmath64 , and re - use every pre - computations done on @xmath64 , typically a factorisation such as lu . finally , correct the approximate solution : @xmath65 . under specific assumptions , but independently of the order of the operations , it is possible to relegate the effects of the intermediate precision and of the condition number after the significant bits in the destination format @xcite . in other words ,",
    "the overestimation due to the floating - point arithmetic is minimal : only one ulp ( or very few ulps ) on the precision of the interval result .",
    "another study @xcite also takes into account the effect of floating - point arithmetic .",
    "it suggests that the same approach applies to nonlinear system solving and that the iterative refinement , called in this case newton iteration , again yields fully accurate results , i.e. up to 1 ulp of the exact result .",
    "however , in both cases it is assumed that enough steps have been performed : if there is a limit on the number of steps , then one run could converge but not the other one and again numerical reproducibility would not be gained .    to conclude on the impact of the computing precision",
    ": it raises no problem for the validity of interval computations , i.e. the inclusion property is satisfied , but it influences the accuracy of the result and the execution time .",
    "it seems that the same could be said for the order of the operations , which is the issue discussed next , but it will be seen that the validity of interval computations can depend on it .",
    "as already abundantly mentioned , a main explanation to the lack of reproducibility of floating - point computations is the lack of associativity of floating - point operations ( addition , multiplication ) .",
    "interval arithmetic also suffers from a lack of algebraic properties . in interval arithmetic ,",
    "the square operation differs from the multiplication by the same argument , because variables ( @xmath51 and @xmath66 in the example ) are decorrelated : @xmath67 ^2 = \\ { x ^2 , \\ : x \\in [ -1,2 ] \\ } =   [ 0,4 ] } \\\\ \\neq & [ -1,2 ] \\cdot [ -1,2 ]   \\\\   & =   \\ { x \\cdot y , \\ : x \\in [ -1,2 ] , \\ : y \\in [ -1,2 ] \\ } \\\\   & =   [ -2,4 ] . \\end{array}\\ ] ] this problem is often called _",
    "variable dependency_.    in interval arithmetic , the multiplication is not distributive over the addition , again because of the decorrelation of the variables .    finally , interval arithmetic implemented using floating - point arithmetic suffers from all these algebraic features . in any case , the computed result contains the exact result .",
    "however , it is not possible to guarantee that one order produces tighter results than another one , as illustrated by the following example . in the binary64 format ,",
    "the smallest floating - point number larger than 1 is @xmath68 .",
    "let us consider three intervals with floating - point endpoints : @xmath69 $ ] , @xmath70 $ ] and @xmath71 $ ] . using the representation by endpoints and the implementation in floating - point arithmetic of @xmath72 + [ \\underline{b},\\bar{b}]$ ] as @xmath73 $ ]",
    ", one gets for @xmath74 : @xmath75 \\\\     & = & [ -1 - 2^{-52 } , 2^{-51 } ] \\\\",
    "\\multicolumn{3}{l}{\\mbox{and finally } } \\\\ \\mathbf{b}_1 & : = & \\mathbf{tmp}_1 + \\mathbf{a}_3 \\\\      & = & [ \\mathrm{rd } ( -1 - 2^{-52 } + 1 ) , \\mathrm{ru}(2^{-51 } + 2 ) ] \\\\      & = & [ -2^{-52 } , 2 + 2^{-51 } ] .",
    "\\end{array}\\ ] ] and one gets for @xmath76 : @xmath77 \\\\      & = & [ 0 , 2 + 2^{-51 } ] \\\\ \\multicolumn{3}{l}{\\mbox{and eventually } } \\\\ \\mathbf{b}_2 & : = & \\mathbf{a}_1 + \\mathbf{tmp}_2 \\\\ \\vspace*{-10pt } & & \\\\      & = & [ \\mathrm{rd } ( -2^{-53 } + 0 ) , \\mathrm{ru}(2^{-52 } + 2 + 2^{-51 } ) ] \\\\      & = & [ -2^{-53 } , 2 + 2^{-50 } ] .",
    "\\end{array}\\ ] ] the exact result is @xmath78 $ ] and this interval is representable using floating - point endpoints . it can be observed that both @xmath79 and @xmath80 enclose @xmath81 : the inclusion property is satisfied .",
    "another observation is that @xmath79 overestimates @xmath81 to the left and @xmath80 to the right .",
    "of course , one can construct examples where both endpoints are under- or over - estimated . +",
    "not only does the order in which non - associative operations such as additions are performed matter , but other orders do as well .",
    "let us go back to the bisection process mentioned in section [ subsec.prec.pbsia ] .",
    "indeterminism is present in the bisection process , and it introduces more sources of irreproducibility . indeed , with bisection techniques , one interval is split into 2 and one half ( or the two halves ) are stored in a list for later processing .",
    "the order in which intervals are created and processed is usually not deterministic , if the list is used by several threads .",
    "this can even influence the creation or bisection of intervals later in the computation .",
    "typically , in algorithms for global optimisation @xcite , the best enclosure found so far for the optimum can lead to the exploration or destruction of intervals in the list . as the order in which intervals are explored varies , this enclosure for the optimum varies and thus the content of the list varies  and not only the order in which its content is processed .",
    "as shown in the example of the sum of three intervals , even if the result depends on the order of the operations , the inclusion property holds and it always encloses the exact results .",
    "thus an optimistic view is that numerical reproducibility is irrelevant for interval computations , as the result always satisfies the inclusion property .",
    "an even more optimistic view could be that getting different results is good , since the sought result lies in their intersection . intersecting the various results would yield even more accuracy .",
    "indeed , with the example above , the exact result @xmath81 is recovered by intersecting @xmath79 and @xmath80 .",
    "unfortunately this is rarely the case , and usually no computation yields tighter results than the other ones .",
    "thus the order may matter .",
    "+ we have already mentioned the benefit of using the mid - rad representation in section [ subsec.prec.rec ] .",
    "another , much more important , advantage is to be able to benefit from efforts made in developing mathematical libraries .",
    "as shown by rump in his pioneering work @xcite , in linear algebra in particular , it is possible to devise algorithms that use floating - point routines .",
    "typically these algorithms compute the midpoint of the result using optimised numerical routines , and they compute afterwards the radius of the result using again optimised numerical routines .",
    "let us illustrate this approach with the product of matrices with interval coefficients , given in @xcite : @xmath82 and @xmath83 are matrices with interval coefficients , represented as matrices of midpoints and matrices of radii .",
    "the product @xmath84 is enclosed in @xmath85 where an interval enclosing @xmath86 is computed as @xmath87 $ ] using optimised blas3 routines for the product of floating - point matrices .",
    "then @xmath88 is computed using @xmath89 , again using optimised blas routines . in @xcite ,",
    "the main benefit which is announced is the gain in execution time , as these routines are really well optimised for a variety of architectures , e.g. in goto - blas or in atlas or in mkl , the library developed by intel for its architectures .",
    "we also foresee the benefit of using reproducible libraries , once they are developed , such as the cnr version of intel mkl , and once their usage and performance are optimised .    to sum up , so far only accuracy and speed of interval computations can be affected by the order of operations , but not the validity of the results .",
    "as discussed now , the order may also impact the validity of interval results , i.e. the inclusion property may not be satisfied .",
    "apart from their lack of numerical reproducibility , there is another limit to the current usability of floating - point blas routines for interval computations .",
    "this limit lies in the use of strong assumptions on the order in which operations are performed .",
    "let us again exemplify this issue on the product of matrices with interval coefficients .",
    "the algorithm given above reduces interval operations to floating - point matrices operations .",
    "however , it requires 4 calls to blas3 routines .",
    "an algorithm has recently been proposed @xcite that requires only 3 calls to floating - point matrix products .",
    "an important assumption to ensure",
    "the inclusion property is that two of these floating - point matrix products perform the basic arithmetic operations in the same order .",
    "namely , the algorithm relies on the following theorem ( * ? ? ?",
    "* theorem 2.1 ) : if @xmath90 and @xmath91 are two @xmath92 matrices with floating - point coefficients , if @xmath93 is computed in any order and if @xmath94 is computed _ in the same order _ , then the error between @xmath95 and the exact product @xmath96 satisfies @xmath97 where @xmath98 is the unit roundoff and @xmath99 is the smallest normal positive floating - point number ( @xmath100 and @xmath101 in binary64 ) .",
    "this assumption on the order is not guaranteed by any blas library we know , and the discussion above tends to show that this assumption does not hold for multithreaded computations .",
    "+ two solutions can be proposed to preserve the efficiency of this algorithm along with the inclusion property . a straightforward solution consists in using a larger bound for the error on the matrix product , a bound which holds whatever the order for the computations of @xmath95 and @xmath102 .",
    "following ( * ? ? ?",
    "* chapter 2 ) and barring underflow , a bound of the following form can be used instead @xcite : @xmath103    a more demanding solution , implemented in @xcite , consists in implementing simultaneously the two matrix products , in order to ensure the same order of operations",
    ". optimisations to get performances are done : block products to optimise the cache usage ( level 1 ) and hand - made vectorisation of the code yield performances , even if the performances of well - known blas are difficult to attain .",
    "furthermore , this hand - made implementation has a better control on the rounding modes than the blas routines , and this is another major point in satisfying the inclusion property , as discussed in the next section .",
    "the lack of respect of the rounding modes is another source of interval invalidity ( to paraphrase the term `` numerical reproducibility '' ) and it is specific to interval computations .",
    "directed rounding modes of floating - point arithmetic are crucial for a correct implementation of interval arithmetic , i.e. for an implementation that preserves the inclusion property .",
    "this is a main difference between interval computations and floating - point computations , that usually employ rounding - to - nearest only .",
    "it is also a issue not only for reproducibility , but even for correctness of interval computations , especially for parallel implementations , as it will be shown below .    for some floating - point computations that make extensive use of eft ( error - free transforms ) , such as compensated sums mentioned in section [ sec.prev ] , the already mentioned qd library @xcite , or for xblas , a library for blas with extended precision @xcite , the only usable rounding mode is rounding - to - nearest ,",
    "otherwise these libraries fail to deliver meaningful results in higher precision .    for interval arithmetic , both endpoints and mid - rad representations",
    "require directed rounding modes . however , many obstacles are encountered .",
    "first , it may happen that the compiler is too eager to optimise a code to respect the required rounding mode .",
    "for instance , let us compute the enclosure of @xmath104 where both @xmath21 and @xmath22 are floating - point numbers , using the following piece of pseudo - code :    .... set_rounding_mode ( downwards ) left : = a / b set_rounding_mode ( upwards ) right : = a / b ....    in order to spare a division which is a relatively expensive operation , a compiler may assign ` right : = left ` , but then the result is not what expected .",
    "this example is given in the gcc bug report # 34678 entitled _ optimization generates incorrect code with -frounding - math options_. even using the right set of compilation options does not solve the problem .",
    "usually these options , when doing properly the job , neutralise optimisations done by the compiler and the resulting code may exhibit poor performances .",
    "second , interval computations may rely on floating - point routines , such as the blas routines in our example of the product of matrices with interval coefficients . for interval computations ,",
    "it is desirable that the blas library respects the rounding mode set before the call to a routine .",
    "( however c99 seems to exclude that external libraries called from c99 respect the rounding mode in use , on the contrary c99 allows them to set and modify the rounding mode . )",
    "this desirable behaviour is not documented for the libraries we know of , as developed in @xcite .",
    "the opposite has been observed by a. neumaier and years later by f. goualard in matlab , as explained in his message to reliable_computing@interval.louisiana.edu on 29 march 2012 quoted below .",
    "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ in a 2008 mail from pr .",
    "neumaier to cleve moler forwarded to the ieee 1788 standard mailing list ( http://grouper.ieee.org/groups/1788/email/msg00204.html ) , it is stated that matlab resets the fpu control word after each external call , which would preclude any use of fast directed rounding through some c mex file calling , say , the fesetround ( ) function .    according to my own tests , the picture is more complicated than that . with matlab r2010b under linux/64 bits i am perfectly able to switch the rounding direction in some mex file for subsequent computation in matlab .",
    "the catch is that the rounding direction may be reset by some later events ( calling some non - existent function , calling an m - file function , ... ) .",
    "in addition , i can not check the rounding direction using fegetround ( ) in a c mex file because it always returns that the rounding direction is set to nearest / even even when i can check by other means that it is not the case in the current matlab environment . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    a more subtle argument against the naive use of mathematical libraries is based on the monotony of the operations .",
    "let us take again the example of a matrix product , with nonnegative entries , such as in @xmath102 introduced in section [ subsec.order.rec ] .",
    "if the rounding mode is set to rounding upwards for instance , then it suffices to compute @xmath105 as @xmath106 to get an overestimation of @xmath107 .",
    "however , if @xmath102 is computed using strassen s formulae , then terms of the form @xmath108 and @xmath109 are introduced . to get an upper bound on these terms",
    ", one needs an overestimation @xmath110 of @xmath51 , @xmath111 of @xmath66 and @xmath112 of @xmath113 , but also an underestimation @xmath114 of @xmath113 .",
    "the overestimation of @xmath115 can thus be computed as @xmath116 and the overestimation of @xmath117 as @xmath118 .",
    "in other words , one may need both over- and under - estimation of intermediate values , i.e. one may need to compute many intermediate quantities twice .",
    "this would ruin the fact that strassen s method is a fast method .",
    "anyway , if a library implementing strassen s product is called with the rounding mode set to @xmath119 and respects it , it simply performs all operations with this rounding mode and there is no guarantee that the result overestimates the exact result . to sum up , there is little evidence and little hope that mathematical libraries return an overestimation of the result when the rounding mode is set to @xmath119 .",
    "third , the programming language may or may not support changes of the rounding mode",
    ". opencl does not support it , as explicitly stated in the documentation ( from the opencl specification version : 1.2 , document revision : 15 ) : _ round to nearest even is currently the only rounding mode required by the opencl specification for single precision and double precision operations and is therefore the default rounding mode .",
    "in addition , only static selection of rounding mode is supported .",
    "dynamically reconfiguring the rounding modes as specified by the ieee 754 spec is unsupported . _ openmp does not support it either , as less explicitly stated in the documentation ( from openmp application program interface , version 4.0 - rc 2 - march 2013 , public review release candidate 2 ) : _ this openmp api specification refers to iso / iec 1539 - 1:2004 as fortran 2003 .",
    "the following features are not supported : ieee arithmetic issues covered in fortran 2003 section 14 [  ] _ which are the issues related to rounding modes .",
    "fourth , the execution environment , i.e. the support for multithreaded execution , usually does not document either how the rounding modes are handled . for architectures or instructions sets which have the rounding mode specified in the code for the operation , as cuda for gpu , or as ia64 processors but without access from a high - level programming language ,",
    "rounding modes are handled smoothly , even if they are accessed with more or less ease .",
    "for other environments where the rounding modes are set via a global flag , it is not clear how this flag is handled : it is expected that it is properly saved and restored when a thread is preempted or migrated , it is not documented whether concurrent threads on the same core `` share '' the rounding mode or whether each of them can use its own rounding mode .",
    "to quote @xcite : _ how a rounding mode change is propagated from one thread or node of a cluster to all others is unspecified in the c standard . in mkl",
    "the rounding mode can be specified only in the vml ( vector math library ) part and any multi - threading or clustering behavior is not documented .",
    "_ + after this discussion , it may appear utopian to rely too much on directed rounding modes to ensure that the inclusion property is satisfied .",
    "our main recommendation is to use bounds on roundoff errors rather than using directed rounding modes , _ when it is not safe to do so_. these bounds must be computable using floating - point arithmetic .",
    "they must be computed using rounding - to - nearest which is most likely to be in use .",
    "they are preferably independent of the rounding mode .",
    "for instance , the bound given in section [ subsec.order.damper ] can be made independent of the rounding mode by replacing @xmath98 , which is the roundoff unit for rounding - to - nearest , by @xmath120 which is an upper bound for any rounding mode @xcite .",
    "another example of this approach to floating - point roundoff errors is the fi_lib library @xcite .",
    "it was also adopted to account for roundoff errors by the cosy library @xcite .",
    "this approach is rather brute force , but it is robust to the change of rounding mode .",
    "furthermore , if the algorithm implemented in a numerical routine is known , it is possible to use this numerical routine and to get an upper bound on its result .",
    "for instance , the bound in section [ subsec.order.damper ] on the error of a matrix product can be obtained using any routine for the matrix product , as long as it does not use a fast method such as strassen s .",
    "as developed in the preceding sections , obtaining numerical reproducibility is a difficult task . getting it can severely impede performances in terms of execution time .",
    "it is thus worth checking whether numerical reproducibility is really needed , or whether getting guarantees on the accuracy of the results suffices .",
    "for instance , as stated in @xcite about climate models : _ it is known that there are multiple stable regions in phase space @xmath121 $ ] that the climate system could be attracted to . however , due to the inherent chaotic nature of the numerical algorithms involved , it is feared that slight changes during calculations could bring the system from one regime to another .",
    "_ in this example , qualitative information , such as the determination of the attractor for the system under consideration , is more important than reproducibility .",
    "this questioning goes further in a talk by dongarra , similar to @xcite , where he advocated the quest for a guaranteed accuracy and the use of small computing precision , such as single precision , rather than the quest for bit - to - bit reproducibility , for speed and energy - consumption reasons .",
    "+ however , numerical reproducibility may be mandatory .",
    "in such a case , our main recommendation to conclude this work is the following methodology .    *",
    "firstly , develop interval algorithms that are based on well - established numerical bricks , so as to benefit from their optimised implementation .",
    "* second , convince developers and vendors of these bricks to clearly specify their behaviour , especially what regards rounding modes . *",
    "if the second step fails , replicate the work done for the optimisation of the considered numerical bricks , to adapt them to the peculiarities and requirements of the interval algorithm . a precursor to this recommendation",
    "is the recommendation in @xcite that aims at easing such developments : _ in order to achieve near - optimal performance , library developers must be given access to routines or kernels that provide computational- and utility - related functionality at a lower level than the customary blas interface .",
    "_ this would make possible to use the lower level bricks used in high - performance blas , e.g. computations at the level of the blocks and not of the entire matrix . *",
    "get free from the rounding mode by bounding , roughly but robustly , errors with formulas independent of the rounding mode if needed .    eventually , let us emphasise that the problem of numerical reproducibility is different from the more general topic called _ reproducible research in computer science _ , which is for instance developed in a complete issue of the _ computing in science & engineering _ magazine @xcite .",
    "reproducible research corresponds to the possibility to reproduce computational results by keeping track of the code version , compiler version and options , input data  used to produce the results that are often only summed up , mostly as figures , in papers .",
    "a possible solution is to adopt a `` versioning '' system not only for code files , but also for compilation commands , data files , binary files ",
    "however , floating - point issues are usually not considered in the related publications ; they very probably should .",
    "this work is partly funded by the hpac project of the french agence nationale de la recherche ( anr 11 bs02 013 ) .",
    "chiang , g.  gopalakrishnan , z.  rakamaric , d.  h. ahn , and g.  l. lee . .",
    "in _ wodet 2013 - 4th workshop on determinism and correctness in parallel programming _ , washington , usa , march 2013 .",
    "j.  k. martinsen and h.  grahn . .",
    "aiccsa 2011 , 9th ieee / acs international conference on computer systems and applications _ , pages 241248 , december 2011 .",
    " r. moore . .",
    "prentice hall , englewood cliffs , 1966 .",
    "m.  philippsen , r.  f. boisvert , v.  s. getov , r.  pozo , j.  moreira , d.  gannon , and g.  c. fox . .",
    "in _ applied parallel computing .",
    "new paradigms for hpc in industry and academia _ , pages 2036 .",
    "springer , 2001 .",
    "n.  revol , y.  denneulin , j .- f .",
    "mhaut , and b.  planquelle .",
    "parallelization of continuous verified global optimization . in _",
    "19th ifip tc7 conf . on system modelling and optimization _ , cambridge , united kingdom , 1999 .",
    "v.  stodden , d.  h. bailey , j.  borwein , r.  j. leveque , w.  rider , and w.  stein . .",
    "report on icerm workshop _ reproducibility in computational and experimental mathematics _ , december 2012 .",
    "icerm , brown university , providence , ri , usa , 2013 .",
    "o.  villa , d.  chavarr  a miranda , v.  gurumoorthi , a.  mrquez , and s.  krishnamoorthy . .",
    "in _ cray user group _ ,",
    "atlanta , ga , usa , 2009 .",
    "authors/01 - 5monday/4c - villa / villa - paper.pdf    nathalie revol received her phd degree in applied mathematics from inpg ( grenoble , france ) in 1994 .",
    "she has been assistant professor at the university of sciences and technologies of lille , france , between 1995 and 2002 . since",
    "then she is an inria researcher at the lip laboratory , ens de lyon , france . since 2008",
    "she co - chairs the ieee p1788 working group for the standardization of interval arithmetic with r.  b. kearfott .",
    "her research interests include interval arithmetic , floating - point arithmetic , and numerical quality .",
    "philippe thveny earned a ms degree in computer sciences from universit de versailles saint - quentin - en - yvelines ( france ) in 2011 .",
    "he is now a phd candidate in cole normale suprieure de lyon ( france ) under the supervision of nathalie revol ."
  ],
  "abstract_text": [
    "<S> what is called _ numerical reproducibility _ is the problem of getting the same result when the scientific computation is run several times , either on the same machine or on different machines , with different types and numbers of processing units , execution environments , computational loads etc . </S>",
    "<S> this problem is especially stringent for hpc numerical simulations . in what follows , </S>",
    "<S> the focus is on parallel implementations of interval arithmetic using floating - point arithmetic . for interval computations , </S>",
    "<S> numerical reproducibility is of course an issue for testing and debugging purposes . </S>",
    "<S> however , as long as the computed result encloses the exact and unknown result , the inclusion property , which is the main property of interval arithmetic , is satisfied and getting bit for bit identical results may not be crucial . still , implementation issues may invalidate the inclusion property . </S>",
    "<S> several ways to preserve the inclusion property are presented , on the example of the product of matrices with interval coefficients .    </S>",
    "<S> interval arithmetic , numerical reproducibility , parallel implementation , floating - point arithmetic , rounding mode . </S>"
  ]
}