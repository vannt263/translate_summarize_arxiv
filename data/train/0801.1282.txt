{
  "article_text": [
    "iterative message passing algorithms for decoding low - density parity - check ( ldpc ) codes have been the focus of research over the past decade and most of their properties are well understood @xcite,@xcite .",
    "these algorithms operate by passing messages along the edges of a graphical representation of the code known as the tanner graph and are optimal when the underlying graph is a tree .",
    "message passing decoders perform remarkably well which can be attributed to their ability to correct errors beyond the traditional bounded distance decoding capability . however , in contrast to bounded distance decoders ( bdds ) , iterative decoders can not guarantee correction of a fixed number of errors at relatively short code lengths .",
    "this is due to the fact that the associated tanner graphs for short length codes have cycles and the decoding becomes suboptimal and there exist a few low - weight patterns ( termed as near codewords @xcite or trapping sets @xcite ) uncorrectable by the decoder .",
    "it is now well established that the trapping sets lead to the phenomenon of error floor . roughly , error floor is an abrupt change in the frame error rate ( fer ) performance of an iterative decoder in the high signal - to - noise ratio ( snr ) region .",
    "the error floor problem is well understood for iterative decoding over binary erasure channel ( bec ) @xcite .",
    "the decoder fails when the received vector contains erasures in locations corresponding to a stopping set .",
    "for the awgn channel , richardson in @xcite presented a numerical method to estimate error floors of ldpc codes .",
    "he established a relation between trapping sets and the fer performance of the code in the error floor region ( the necessary definitions will be given in the next section ) .",
    "the approach from @xcite was further refined by stepanov _",
    "et al _ in @xcite .",
    "vontobel and koetter @xcite established a theoretical framework for finite length analysis of message passing iterative decoding based on graph covers .",
    "this approach was used by smarandache _",
    "et al _ in @xcite to analyze performance of ldpc codes from projective and for ldpc convolutional codes @xcite .",
    "for the binary symmetric channel ( bsc ) , error floor estimation based on trapping sets was proposed in @xcite and we adopt the notation from @xcite .    in this paper , we make the following two fundamental contributions : ( a ) give necessary and sufficient conditions for a column - weight - three ldpc code to correct three errors , and ( b ) propose a construction method which results in a code satisfying the above conditions .",
    "we consider hard decision decoding for transmission over bsc .",
    "the bsc is a simple yet useful channel model used extensively in areas where decoding speed is a major factor .",
    "note that the problem of recovering from a fixed number of erasures is solved for the bec .",
    "if the tanner graph of a code does not contain any stopping sets up to size @xmath0 ( the size of minimum stopping set is @xmath1 ) , then the decoder is guaranteed to recover from any @xmath0 erasures .",
    "an analogous result for the bsc is still unknown .",
    "the problem of guaranteed error correction capability is known to be difficult and in this paper , we present a first step toward such result .",
    "previously , expansion arguments were used to show that message passing can correct a fixed fraction of errors @xcite . however , the code length needed to guarantee such correction capability is generally very large and to correct three errors , the length would be in the order of a few hundred thousand .",
    "also , these arguments can not be used for column - weight - three codes .",
    "column - weight - three codes are of special importance as their decoders have very low complexity and are used in a wide range of applications .",
    "we also show that the slope of the frame error rate ( fer ) is dependent on the critical number of the most relevant trapping sets and hence the slope can be improved by avoiding such trapping sets .",
    "we provide a technique to construct codes which outperform empirically best known codes of the same length .",
    "our method can be seen as a modification of the progressive edge growth ( peg ) technique proposed in @xcite .",
    "the rest of the paper is organized as follows . in section [ section2 ]",
    "we establish the notation , describe the gallager a algorithm and define trapping sets .",
    "in section [ section3 ] we present the main theorem which gives the necessary and sufficient conditions to correct three errors . in section [ section4 ]",
    "we describe a technique to construct codes satisfying the conditions of the theorem and provide numerical results .",
    "we conclude with a few remarks in section [ section5 ]",
    "in this section , we establish the notation and describe a hard decision decoding algorithm known as gallager a algorithm .",
    "we then characterize the failures of the gallager a decoder with the help of fixed points .",
    "we also introduce the notions of trapping sets and critical number .",
    "the tanner graph of an ldpc code , @xmath2 , is a bipartite graph with two sets of nodes : variable ( bit ) nodes and check ( constraint ) nodes .",
    "every edge @xmath3 in the bipartite graph is associated with a variable node @xmath4 and check node @xmath5 .",
    "the check nodes / variable nodes connected to a variable node / check node are referred to as its neighbors .",
    "the degree of a node is the number of its neighbors . in a @xmath6 regular ldpc code , each variable node has degree of @xmath7 and each check node has degree @xmath8 .",
    "the girth @xmath9 is the length of the shortest cycle in @xmath2 . in this paper , @xmath10 represents a variable node , @xmath11 represents an even degree check node and @xmath12 represents an odd degree check node .",
    "gallager in @xcite proposed two simple binary message passing algorithms for decoding over the bsc ; gallager a and gallager b. see @xcite for a detailed description of gallager b algorithm . for column - weight - three codes , which are the main focus of this paper , these two algorithms are the same .",
    "every round of message passing ( iteration ) starts with sending messages from variable nodes ( first half of the iteration ) and ends by sending messages from check nodes to variable nodes ( second half of the iteration ) .",
    "initially , the variable nodes send their received values to the neighboring checks . in the @xmath13 iteration @xmath14 , a variable node",
    ", @xmath4 sends the following message , @xmath15 , along edge @xmath3 to its neighboring check node @xmath5 ; if all incoming messages to @xmath4 other than the message from @xmath5 are equal to a certain value , it sends that value ; else , it sends the received value .",
    "a check node @xmath5 sends to a variable node @xmath4 , the modulo two sum of all incoming messages except the message from @xmath4 . at the end of each iteration ,",
    "an estimate of each variable node is made based on the incoming messages and possibly the received value .",
    "the decoder is run until a valid codeword is found or for a maximum number of iterations is reached , whichever is earlier .",
    "see @xcite for a detailed description of the messages passed in gallager a algorithm .    _ a note on the decision rule : _ different rules to estimate a variable node after each iteration are possible and it is likely that changing the rule after certain iterations may be beneficial . however , the analysis of various scenarios is beyond the scope of this paper .",
    "for column - weight - three codes only two rules are possible .",
    "* decision rule a : if all incoming messages to a variable node from neighboring checks are equal , set the variable node to that value ; else set it to received value * decision rule b : set the value of a variable node to the majority of the incoming messages ; majority always exists since the column - weight is three    we adopt decision rule a throughout this paper .",
    "we now characterize failures of the gallager a decoder using fixed points and trapping sets .",
    "much of the following discussion appears in @xcite,@xcite,@xcite,@xcite and we include it for sake of completeness .",
    "consider an ldpc code of length @xmath16 and let @xmath17 be the binary vector which is the input to the gallager a decoder .",
    "let @xmath18 be the support of @xmath17 .",
    "the support of @xmath17 is defined as the set of all positions @xmath19 where @xmath20 .",
    "@xcite a decoder failure is said to have occurred if the output of the decoder is not equal to the transmitted codeword .",
    "@xcite @xmath17 is called a _ fixed point _ if for every edge @xmath3 and its associated variable node @xmath4 @xmath21    that is , the message passed from variable nodes to check nodes along the edges are the same in every iteration .",
    "since the outgoing messages from variable nodes are same in every iteration , it follows that the incoming messages from check nodes to variable nodes are also same in every iteration and so is the estimate of a variable after each iteration .",
    "in fact , the estimate after each iteration coincides with the received value .",
    "it is clear from above definition that if the input to the decoder is a fixed point , then the output of the decoder is the same fixed point . without loss of generality , we assume that the all zero codeword is sent over bsc and the input to the decoder is the error vector .",
    "so , a fixed point with small weight means that few errors lead to decoder failure . a detailed discussion about different kinds of decoder failures is given in @xcite    @xcite the support of a fixed point is known as a trapping set .",
    "a @xmath22 trapping set @xmath23 is a set of @xmath24 variable nodes whose induced subgraph has @xmath25 odd degree checks .",
    "our definition of a trapping set gives necessary and sufficient conditions for a set of variable nodes to form a trapping set .",
    "we state the following theorem which is a consequence of fact 3 from @xcite .",
    "[ thm1]@xcite let @xmath23 be a set consisting of @xmath4 variable nodes with induced subgraph @xmath26 .",
    "let the checks in @xmath26 be partitioned into two disjoint subsets ; @xmath27 consisting of checks with odd degree and @xmath28 consisting of checks with even degree .",
    "let @xmath29 and @xmath30 .",
    "@xmath23 is a trapping set if : ( a ) every variable node in @xmath26 is connected to at least two checks in @xmath28 and at most one checks in @xmath27 and ( b ) no two checks of @xmath27 are connected to a variable node outside @xmath26 .",
    "see @xcite .    if the variable nodes corresponding to a trapping set are in error , then a decoder failure occurs . however , not all variable nodes corresponding to trapping set need to be in error for a decoder failure to occur .",
    "@xcite the minimal number of variable nodes that have to be initially in error for the decoder to end up in the trapping set @xmath23 will be referred to as _",
    "critical number _",
    "@xmath31 for that trapping set .",
    "@xcite a set of variable nodes which if in error lead to a decoding failure is known as a _ failure set_.    _ remarks _    1 .",
    "to `` end up '' in a trapping set @xmath23 means that , after a possible finite number of iterations , the decoder will be in error , on at least one variable node from @xmath32 at every iteration @xcite .",
    "the notion of a failure set is more fundamental than a trapping set .",
    "however , from the definition , we can not derive necessary and sufficient conditions for a set of variable nodes to form a failure set .",
    "3 .   a trapping set is a failure set .",
    "subsets of trapping sets can be failure sets . more specifically , for a trapping set of size @xmath24 , there exists at least one subset of size equal to the critical number which is a failure set .",
    "4 .   the critical number of a trapping set is not fixed .",
    "it depends on the outside connections of checks in @xmath28 .",
    "however , the maximum value of critical number of a @xmath22 trapping set is @xmath24 .",
    "in this section , we establish the necessary and sufficient conditions for a column - weight - three code to correct three errors .",
    "we first illustrate three trapping sets and show that the critical number of these trapping sets is three thereby providing necessary condition to correct three errors .",
    "we then prove that avoiding structures isomorphic to these trapping sets in the tanner graph is sufficient to guarantee correction of three errors .",
    "[ trappingsets ] shows three subgraphs induced by different number of variable nodes .",
    "let us assume that in all these induced graphs , no two odd degree checks are connected to a variable node outside the graph . by the conditions of theorem [ thm1 ] , all these induced subgraphs are trapping sets . fig .",
    "[ sixcycle ] is a @xmath33 trapping set , fig .",
    "[ 53trappingset ] is a @xmath34 trapping set and fig .",
    "[ weight8codeword ] is a @xmath35 trapping set .",
    "note that a @xmath33 is isomorphic to a six cycle .",
    "and the @xmath35 trapping set is a codeword of weight eight .",
    "[ sixcycle ]        [ 53trappingset ]        [ weight8codeword ]        the critical number for @xmath33 trapping set is three .",
    "there exist @xmath34 and @xmath35 trapping sets with critical number three .",
    "for the @xmath33 trapping set , the result follows from definition .",
    "we omit the proof for @xmath34 and @xmath35 trapping sets due to space considerations .",
    "detailed proofs can be found in the longer version of the paper @xcite .    to correct three errors in a column - weight - three ldpc code by gallager a algorithm ,",
    "it is necessary to avoid @xmath33 trapping sets and @xmath34 and @xmath35 trapping sets with critical number three in its tanner graph",
    ".    follows from the above discussion .",
    "we now state and prove the main theorem .",
    "if the tanner graph of a column - weight - three ldpc codes has girth eight and no set of variable nodes induces a subgraph isomorphic to @xmath34 trapping set or a subgraph isomorphic to @xmath35 trapping sets , then any three errors can be corrected using gallager a algorithm .",
    "_ sketch of proof : _ in a column - weight - three code three variable nodes can induce only one of the five subgraphs given in fig . [ errorconfigs ] and the proof proceeds by examining these subgraphs one at a time .",
    "the complete proof involves many arguments and here we just illustrate the methodology of the proof by considering two possible subgraphs .",
    "the proof for the remaining subgraphs appears in the longer version of the paper @xcite .",
    "* subgraph 1 : * since the girth of the code is eight , it has no six cycles and hence the configuration in fig .",
    "[ config1 ] is not possible .",
    "* subgraph 5 : * the three variable nodes in error induce a subgraph as shown in fig .",
    "[ config5 ] . in first half of first iteration @xmath36 and",
    "@xmath37 send incorrect messages . in the second half of first iteration , @xmath38 and",
    "@xmath19 send incorrect messages to neighboring variables except to @xmath36 and @xmath37 .",
    "if there is no variable node which receives three incorrect messages , a valid codeword is reached after first iteration . on the contrary ,",
    "assume there exists a variable node , say @xmath39 , which receives three incorrect messages ( w.l.o.g .",
    "we can assume that @xmath39 is connected to @xmath40 and @xmath9 ) .",
    "also , there can not be two such variable nodes as that would introduce a six cycle or a graph isomorphic to @xmath34 trapping set .",
    "also , there can be at most three variable nodes which receive two incorrect messages , say , @xmath41 and @xmath42 .",
    "let the other checks connected to these variables be @xmath43 and @xmath44 respectively . in the first half of second iteration , @xmath36 and",
    "@xmath37 send all correct messages , @xmath39 sends all incorrect messages , @xmath45 send incorrect messages to @xmath43 and @xmath44 respectively .",
    "in second half of second iteration , @xmath46 send incorrect messages to their neighbors except to @xmath39 .",
    "@xmath43 and @xmath44 send incorrect messages to neighboring variables except to @xmath41 and @xmath42 .",
    "there can not be a variable node which is connected to one check from @xmath47 and to one check from @xmath48 .",
    "also , there can not be a variable node which is connected to all the three checks @xmath43 and @xmath44 as this would introduce a graph isomorphic to @xmath35 trapping set .",
    "however , there can be at most two variable nodes which receive two incorrect messages from the checks @xmath43 and @xmath44 , say @xmath49 and @xmath50 .",
    "let the other checks connected to @xmath49 and @xmath50 be @xmath31 and @xmath51 . at the end of second iteration , @xmath36 and",
    "@xmath37 receive one incorrect message , @xmath49 and @xmath50 receive two incorrect messages . in the first half of third iteration , @xmath36 and",
    "@xmath37 send two incorrect messages each , @xmath49 and @xmath50 send one incorrect message each . in the second half of third iteration , @xmath52 and",
    "@xmath19 send incorrect messages to their neighbors except to @xmath36 and @xmath37 .",
    "@xmath31 and @xmath51 send incorrect messages to their neighbors except to @xmath49 and @xmath50 .",
    "it can be shown that there can not exist a variable node which receives three incorrect messages . at the end of third iteration , @xmath36 and",
    "@xmath37 receive all correct messages and no variable node receives all incorrect messages .",
    "so , if a decision is made , a valid codeword is reached and decoder is successful .    [ config1 ]     [ config2 ]     [ config3 ]        [ config4 ]        [ config5 ]     _",
    "remark : _ it is worth noting that the complete proof is more involved than the proofs which use expansion arguments",
    ". however , the result is also more precise and holds for codes of small lengths .",
    "in this section , we describe a technique to construct codes which can correct three errors .",
    "codes capable of correcting a fixed number of errors show superior performance on the bsc at low values of probability of transition @xmath53 .",
    "this is because the slope of the fer curve is related to the minimum critical number @xcite .",
    "a code which can correct @xmath19 errors has minimum critical number @xmath54 and the slope of fer curve is @xmath54 .",
    "we restate the arguments from @xcite to make this connection clear .",
    "let @xmath53 be the transition probability of bsc and @xmath55 be number of configurations of received bits for which @xmath56 channel errors lead to codeword ( frame ) error .",
    "the frame error rate ( fer ) is given by :    @xmath57 where @xmath19 is the minimal number of channel errors that can lead to a decoding error ( size of instantons ) and @xmath16 is length of the code .    on a semilog scale",
    "the fer is given by the expression    @xmath58    in the limit @xmath59 we note that @xmath60=0\\ ] ] and @xmath61\\!\\!=0\\ ] ] so , the behavior of the fer curve for small @xmath53 is dominated by @xmath62    the @xmath63 vs @xmath64 graph is close to a straight line with slope equal to @xmath65 the minimal critical number . if two codes @xmath66 and @xmath67 have minimum critical numbers @xmath68 and @xmath69 such that @xmath70 then the code @xmath67 will perform better than @xmath66 for small enough @xmath71 independent of the number of trapping sets .    from the discussion in section [ section3 ] and section [ section4 ] , it is clear that for a code to have a fer curve with slope at least @xmath39 , the corresponding tanner graph should not contain the trapping sets shown in fig . [ trappingsets ] as subgraphs .",
    "we now describe a method to construct such codes .",
    "the method can be seen as a modification of the peg construction technique used by hu _",
    "the algorithm is as follows :    note that checking for a graph isomorphic to @xmath35 trapping set at every step of code construction is computationally complex .",
    "since , the peg construction empirically gives good codes , it is unlikely that it introduces a weight - eight codeword .",
    "however , once the graph is grown fully , it can be checked for the presence of weight - eight codewords and these can be removed by swapping few edges .    using the above algorithm ,",
    "a column - weight - three code with @xmath72 variable nodes and @xmath73 check nodes was constructed .",
    "the code has slight irregularity in check degree .",
    "there is one check node degree five and one check node with degree seven , but the majority of them have degree six .",
    "the code has rate 0.5 . in the algorithm",
    ", we restrict maximum check degree to seven .",
    "the performance of the code on bsc is compared with the peg code of same length .",
    "the peg code is empirically the best known code at that length on awgn channel @xcite .",
    "however , it has fourteen @xmath34 trapping sets .",
    "[ pegnewvsold ] shows the performance comparison of the two codes .",
    "as can be seen , the new code performs better than the original peg code at small values of @xmath53 .",
    "in this paper , we have given conditions for a column - weight - three code to correct three errors .",
    "since , the check degree does not play any part in the proof , it follows that the result is independent of code rate .",
    "a direction for future work is extending the analysis to more number of errors and higher column weight codes .",
    "preliminary investigation shows a lot of promise .",
    "the complexity of the proof , even in the case of three errors , suggests that solving the problem for an arbitrary number of errors will be a challenge . on the code construction front",
    ", we have shown that avoiding trapping sets with minimum critical number is the criterion to suppress error floor . however , the conditions for correcting more errors could be more complicated thereby increasing the complexity of code construction . deriving bounds on lengths and minimum distance of codes which avoid certain structures also need to be investigated",
    "this work is funded by nsf under grant ccf-0634969 and insic - ehdr program .",
    "d.  j.  c. mackay and m.  j. postol , `` weaknesses of margulis and ramanujan  margulis low - density parity - check codes , '' in _ proceedings of mfcsit2002 , galway _ , ser .",
    "electronic notes in theoretical computer science , vol .",
    "74.1em plus 0.5em minus 0.4em elsevier , 2003 .",
    "[ online ] .",
    "available : http://www.inference.phy.cam.ac.uk/mackay/abstracts/margulis.html          p.",
    "o. vontobel and r.  koetter , `` graph - cover decoding and finite - length analysis of message - passing iterative decoding of ldpc codes , '' 2005 .",
    "[ online ] .",
    "available : http://www.citebase.org/abstract?id=oai:arxiv.org:cs/0512078        s.  k. chilappagari , s.  sankaranarayanan , and b.  vasic , `` error floors of ldpc codes on the binary symmetric channel , '' in _ international conference on communications _",
    ", vol .  3 , june 11 - 15 2006 , pp .",
    "10891094 .",
    "a.  shokrollahi , `` an introduction to low - density parity - check codes , '' in _ theoretical aspects of computer science : advanced lectures_.1em plus 0.5em minus 0.4emnew york , ny , usa : springer - verlag new york , inc . , 2002 , pp .",
    "175197 .",
    "s.  sankaranarayanan , s.  k. chilappagari , r.  radhakrishnan , and b.  vasic , `` failures of the gallager b decoder : analysis and applications , '' in _ ucsd center for information theory and its applications inaugural workshop _ , feb 6 - 9 2006 .",
    "[ online ] .",
    "available : htpp//ita.5i.net / papers/160.pdf    m.  ivkovic , s.  k. chilappagari , and b.  vasic , `` eliminating trapping sets in low - density parity check codes using tanner graph lifting , '' in _ international symposium on information theory _ , june 24 - 29 2007 , pp ."
  ],
  "abstract_text": [
    "<S> in this paper , we provide necessary and sufficient conditions for a column - weight - three ldpc code to correct three errors when decoded using gallager a algorithm . </S>",
    "<S> we then provide a construction technique which results in a code satisfying the above conditions . </S>",
    "<S> we also provide numerical assessment of code performance via simulation results . </S>"
  ]
}