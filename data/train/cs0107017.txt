{
  "article_text": [
    "this paper reports on the still preliminary , but already satisfying results of the learning computational grammars ( lcg ) project , a postdoc network devoted to studying the application of machine learning techniques to grammars suitable for computational use .",
    "the member institutes are listed with the authors and also included issco at the university of geneva .",
    "we were impressed by early experiments applying learning to natural language , but dissatisfied with the concentration on a few techniques from the very rich area of machine learning .",
    "we were interested in a more systematic survey to understand the relevance of many factors to the success of learning , esp .",
    "the availability of annotated data , the kind of dependencies in the data , and the availability of knowledge bases ( grammars ) .",
    "we focused on syntax , esp .",
    "noun phrase ( np ) syntax from the beginning .",
    "the industrial partner , xerox , focused on more immediate applications @xcite .",
    "the network was focused not only by its scientific goal , the application and evaluation of machine - learning techniques as used to learn natural language syntax , and by the subarea of syntax chosen , np syntax , but also by the use of shared training and test material , in this case material drawn from the penn treebank . finally , we were curious about the possibility of combining different techniques , including those from statistical and symbolic machine learning .",
    "the network members played an important role in the organisation of three open workshops in which several external groups participated , sharing data and test materials .",
    "this section starts with a description of the three tasks that we have worked on in the framework of this project .",
    "after this we will describe the machine learning algorithms applied to this data and conclude with some notes about combining different system results .",
    "in the framework of this project , we have worked on the following three tasks :    1 .   base phrase ( chunk ) identification 2 .",
    "base noun phrase recognition 3 .",
    "finding arbitrary noun phrases    text chunks are non - overlapping phrases which contain syntactically related words .",
    "for example , the sentence :    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ @xmath0 he @xmath1 $ ] @xmath2 reckons @xmath1 $ ] @xmath0 the current account deficit @xmath1 $ ] @xmath2 will narrow @xmath1 $ ] + @xmath3 to @xmath1 $ ] @xmath0 only @xmath4 1.8 billion @xmath1 $ ] + @xmath3 in @xmath1 $ ] @xmath0 september @xmath1 $ ] . _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _    contains eight chunks , four np chunks , two vp chunks and two pp chunks .",
    "the latter only contain prepositions rather than prepositions plus the noun phrase material because that has already been included in np chunks .",
    "the process of finding these phrases is called chunking .",
    "the project provided a data set for this task at the conll-2000 workshop @xcite .",
    "it consists of sections 15 - 18 of the wall street journal part of the penn treebank ii @xcite as training data ( 211727 tokens ) and section 20 as test data ( 47377 tokens ) .",
    "a specialised version of the chunking task is np chunking or basenp identification in which the goal is to identify the base noun phrases .",
    "the first work on this topic was done back in the eighties @xcite .",
    "the data set that has become standard for evaluation machine learning approaches is the one first used by ramshaw and marcus .",
    "it consists of the same training and test data segments of the penn treebank as the chunking task ( respectively sections 15 - 18 and section 20 ) .",
    "however , since the data sets have been generated with different software , the np boundaries in the np chunking data sets are slightly different from the np boundaries in the general chunking data .",
    "noun phrases are not restricted to the base levels of parse trees .",
    "for example , in the sentence _ in early trading in hong kong monday , gold was quoted at $ 366.50 an ounce .",
    "_ , the noun phrase @xmath0 $ 366.50 an ounce @xmath1 $ ] contains two embedded noun phrases @xmath0 $ 366.50 @xmath1 $ ] and @xmath0 an ounce @xmath1 $ ] . in the np bracketing task ,",
    "the goal is to find all noun phrases in a sentence .",
    "data sets for this task were defined for conll-99 .",
    "the data consist of the same segments of the penn treebank as the previous two tasks ( sections 15 - 18 ) as training material and section 20 as test material .",
    "this material was extracted directly from the treebank and therefore the np boundaries at base levels are different from those in the previous two tasks .    in the evaluation of all three tasks ,",
    "the accuracy of the learners is measured with three rates .",
    "we compare the constituents postulated by the learners with those marked as correct by experts ( gold standard ) .",
    "first , the percentage of detected constituents that are correct ( precision ) .",
    "second , the percentage of correct constituents that are detected ( recall ) . and third , a combination of precision and recall , the f@xmath5 rate which is equal to ( 2*precision*recall)/(precision+recall ) .",
    "this section introduces the ten learning methods that have been applied by the project members to the three tasks : lscgs , allis , lsommbl , maximum entropy , aleph , mdl - based dcg learners , finite state transducers , ib1ig , igtree and c5.0 .    *",
    "local structural context grammars * ( lscgs ) @xcite are situated between conventional probabilistic context - free production rule grammars and dop - grammars ( e.g. ,  bod and scha ) .",
    "lscgs outperform the former because they do not share their inherent independence assumptions , and are more computationally efficient than the latter , because they incorporate only subsets of the context included in dop - grammars .",
    "local structural context ( lsc ) is ( partial ) information about the immediate neighbourhood of a phrase in a parse . by conditioning bracketing probabilities on lsc , more",
    "fine - grained probability distributions can be achieved , and parsing performance increased .    given corpora of parsed text such as the wsj , lscgs",
    "are used in automatic grammar construction as follows .",
    "an lscg is derived from the corpus by extracting production rules from bracketings and annotating the rules with the type(s ) of lsc to be incorporated in the lscg ( e.g.  parent category information , depth of embedding , etc . ) .",
    "rule probabilities are derived from rule frequencies ( currently by maximum likelihood estimation ) . in a separate optimisation step",
    ", the resulting lscgs are optimised in terms of size and parsing performance for a given parsing task by an automatic method ( currently a version of beam search ) that searches the space of partitions of a grammar s set of nonterminals .",
    "the lscg research efforts differ from other approaches reported in this paper in two respects .",
    "firstly , no lexical information is used at any point , as the aim is to investigate the upper limit of parsing performance without lexicalisation .",
    "secondly , grammars are optimised for parsing performance _ and _ size , the aim being to improve performance but not at the price of arbitrary increases in grammar complexity ( hence the cost of parsing ) .",
    "the automatic optimisation of corpus - derived lscgs is the subject of ongoing research and the results reported here for this method are therefore preliminary .    * theory refinement * ( allis ) .",
    "allis ( @xcite , @xcite ) is a inductive rule - based system using a traditional general - to - specific approach @xcite . after generating a default classification rule ( equivalent to the n - gram model )",
    ", allis tries to refine it since the accuracy of these rules is usually not high enough .",
    "refinement is done by adding more premises ( contextual elements ) .",
    "allis uses data encoded in xml , and also learns rules in xml .",
    "from the perspective of the xml formalism , the initial rule can be viewed as a tree with only one leaf , and refinement is done by adding adjacent leaves until the accuracy of the rule is high enough ( a tuning threshold is used ) .",
    "these additional leaves correspond to more precise contextual elements . using the hierarchical structure of an xml document ,",
    "refinement begins with the highest available hierarchical level and goes down in the hierarchy ( for example , starting at the chunk level and then word level ) .",
    "adding new low level elements makes the rules more specific , increasing their accuracy but decreasing their coverage .",
    "after the learning is completed , the set of rules is transformed into a proper formalism used by a given parser .    * labelled som and memory based learning * ( lsommbl ) is a neurally inspired technique which incorporates a modified self - organising map ( som , also known as a ` kohonen map ' ) in memory - based learning to select a subset of the training data for comparison with novel items .",
    "the som is trained with labelled inputs . during training ,",
    "each unit in the map acquires a label .",
    "when an input is presented , the node in the map with the highest activation ( the ` winner ' ) is identified . if the winner is unlabelled , then it acquires the label from its input .",
    "labelled units only respond to similarly labelled inputs .",
    "otherwise training proceeds as with the normal som .",
    "when training ends , all inputs are presented to the som , and the winning units for the inputs are noted .",
    "any unused units are then discarded .",
    "thus each remaining unit in the som is associated with the set of training inputs that are closest to it .",
    "this is used in mbl as follows .",
    "the labelled som is trained with inputs labelled with the output categories .",
    "when a novel item is presented , the winning unit for each category is found , the training items associated with the winning units are searched for the closest item to the novel item and the most frequent classification of that item is used as the classification for the novel item .    *",
    "maximum entropy * when building a classifier , one must gather evidence for predicting the correct class of an item from its context .",
    "the maximum entropy ( maxent ) framework is especially suited for integrating evidence from various information sources .",
    "frequencies of evidence / class combinations ( called features ) are extracted from a sample corpus and considered to be properties of the classification process .",
    "attention is constrained to models with these properties .",
    "the maxent principle now demands that among all the probability distributions that obey these constraints , the most uniform is chosen . during training",
    ", features are assigned weights in such a way that , given the maxent principle , the training data is matched as well as possible . during evaluation",
    "it is tested which features are _ active _",
    "( i.e. , a feature is active when the context meets the requirements given by the feature ) .",
    "for every class the weights of the active features are combined and the best scoring class is chosen @xcite . for the classifier built here we use as evidence the surrounding words , their pos tags and basenp tags predicted for the previous words . a mixture of simple features ( consisting of one of the mentioned information sources ) and complex features ( combinations thereof ) were used .",
    "the left context never exceeded 3 words , the right context was maximally 2 words .",
    "the model was calculated using existing software @xcite .    * inductive logic programming ( ilp ) * aleph is an ilp machine learning system that searches for a hypothesis , given positive ( and , if available , negative ) data in the form of ground prolog terms and background knowledge ( prior knowledge made available to the learning algorithm ) in the form of prolog predicates .",
    "the system , then , constructs a set of hypothesis clauses that fit the data and background as well as possible . in order to approach the problem of",
    "np chunking in this context of single - predicate learning , it was reformulated as a tagging task where each word was tagged as being ` inside ' or ` outside ' a basenp ( consecutive nps were treated appropriately ) .",
    "then , the target theory is a prolog program that correctly predicts a word s tag given its context . the context consisted of pos tagged words and syntactically tagged words to the left and pos tagged words to the right , so that the resulting tagger can be applied in the left - to - right pass over pos - tagged text .    * minimum description length * ( mdl )",
    "estimation using the minimum description length principle involves finding a model which not only ` explains ' the training material well , but also is compact .",
    "the basic idea is to balance the generality of a model ( roughly speaking , the more compact the model , the more general it is ) with its specialisation to the training material .",
    "we have applied mdl to the task of learning broad - covering definite - clause grammars from either raw text , or else from parsed corpora @xcite .",
    "preliminary results have shown that learning using just raw text is worse than learning with parsed corpora , and that learning using both parsed corpora and a compression - based prior is better than when learning using parsed corpora and a uniform prior .",
    "furthermore , we have noted that our instantiation of mdl does not capture dependencies which exist either in the grammar or else in preferred parses .",
    "ongoing work has focused on applying random field technology ( maximum entropy ) to mdl - based grammar learning ( see osborne for some of the issues involved ) .    *",
    "finite state transducers * are built by interpreting probabilistic automata as transducers .",
    "we use a probabilistic grammatical algorithm , the ddsm algorithm @xcite , for learning automata that provide the probability of an item given the previous ones .",
    "the items are described by bigrams of the format feature : class . in the resulting automata",
    "we consider a transition labeled feature : class as the transducer transition that takes as input the first part ( feature ) of the bigram and outputs the second part ( class ) . by applying the viterbi algorithm on such a model",
    ", we can find out the most probable set of class values given an input set of feature values . as the ddsm algorithm has a tuning parameter",
    ", it can provide many different automata .",
    "we apply a majority vote over the propositions made by the so computed automata / transducers for obtaining the results mentioned in this paper .    * memory - based learning * methods store all training data and classify test data items by giving them the classification of the training data items which are most similar .",
    "we have used three different algorithms : the nearest neighbour algorithm ib1ig , which is part of the timbl software package @xcite , the decision tree learner igtree , also from timbl , and c5.0 , a commercial version of the decision tree learner c4.5 @xcite .",
    "they are classifiers which means that they assign phrase classes such as i ( inside a phrase ) , b ( at the beginning of a phrase ) and o ( outside a phrase ) to words . in order to improve the classification process we provide the systems with extra information about the words such as the previous _",
    "n _ words , the next _",
    "n _ words , their part - of - speech tags and chunk tags estimated by an earlier classification process .",
    "we use the default settings of the software except for the number of examined nearest neighbourhood regions for ib1ig ( k , default is 1 ) which we set to 3 .",
    "when different systems are applied to the same problem , a clever combination of their results will outperform all of the individual results @xcite .",
    "the reason for this is that the systems often make different errors and some of these errors can be eliminated by examining the classifications of the others .",
    "the most simple combination method is majority voting .",
    "it examines the classifications of the test data item and for each item chooses the most frequently predicted classification . despite its simplicity ,",
    "majority voting has found to be quite useful for boosting performance on the tasks that we are interested in .",
    "we have applied majority voting and nine other combination methods to the output of the learning systems that were applied to the three tasks .",
    "nine combination methods were originally suggested by van halteren et al . .",
    "five of them , including majority voting , are so - called voting methods .",
    "apart from majority voting , all assign weights to the predictions of the different systems based on their performance on non - used training data , the tuning data .",
    "totprecision uses classifier weights based on their accuracy .",
    "tagprecision applies classification weights based on the accuracy of the classifier for that classification .",
    "precision - recall uses classification weights that combine the precision of the classification with the recall of the competitors . and",
    "finally , tagpair uses classification pair weights based on the probability of a classification for some predicted classification pair @xcite .",
    "the remaining four combination methods are so - called stacked classifiers .",
    "the idea is to make a classifier process the output of the individual systems .",
    "we used the two memory - based learners ib1ig and igtree as stacked classifiers . like van halteren et al . , we evaluated two features combinations .",
    "the first consisted of the predictions of the individual systems and the second of the predictions plus one feature that described the data item .",
    "we used the feature that , according to the memory - based learning metrics , was most relevant to the tasks : the part - of - speech tag of the data item .",
    "in the course of this project we have evaluated another combination method : best - n majority voting @xcite .",
    "this is similar to majority voting except that instead of using the predictions of all systems , it uses only predictions from some of the systems for determining the most probable classifications .",
    "we have experienced that for different reasons some systems perform worse than others and including their results in the majority vote decreases the combined performance .",
    "therefore it is a good idea to evaluate majority voting on subsets of all systems rather than only on the combination of all systems .",
    "apart from standard majority voting , all combination methods require extra data for measuring their performance which is required for determining their weights , the tuning data .",
    "this data can be extracted from the training data or the training data can be processed in an n - fold cross - validation process after which the performance on the complete training data can be measured .",
    "although some work with individual systems in the project has been done with the goal of combining the results with other systems , tuning data is not always available for all results .",
    "therefore it will not always be possible to apply all ten combination methods to the results . in some cases we have to restrict ourselves to evaluating majority voting only .",
    "this sections presents the results of the different systems applied to the three tasks which were central to this this project : chunking , np chunking and np bracketing .",
    "chunking was the shared task of conll-2000 , the workshop on computational natural language learning , held in lisbon , portugal in 2000 @xcite .",
    "six members of the project have performed this task .",
    "the results of the six systems ( precision , recall and f@xmath5 can be found in table [ tab - chunking ] .",
    "belz used local structural context grammars for finding chunks .",
    "djean applied the theory refinement system allis to the shared task data .",
    "koeling evaluated a maximum entropy learner while using different feature combinations ( me ) .",
    "osborne used a maximum entropy - based part - of - speech tagger for assigning chunk tags to words ( me tag ) .",
    "thollard identified chunks with finite state transducers generated by a probabilistic grammar algorithm ( fst ) .",
    "tjong kim sang tested different configurations of combined memory - based learners ( mbl ) .",
    "the fst and the lscg results are lower than those of the other systems because they were obtained without using lexical information . the best result at the workshop was obtained with support vector machines @xcite .    .",
    "the chunking results for the six systems associated with the project ( shared task conll-2000 ) .",
    "the baseline results have been obtained by selecting the most frequent chunk tag associated with each part - of - speech tag .",
    "the best results at conll-2000 were obtained by support vector machines . a majority vote of the six lcg systems does not perform much worse than this best result .",
    "a majority vote of the five best systems outperforms the best result slightly ( @xmath6 error reduction ) . [ cols=\"<,^,^,^\",options=\"header \" , ]      finding arbitrary noun phrases was the shared task of conll-99 , held in bergen , norway in 1999 .",
    "three project members have performed this task .",
    "belz extracted noun phrases with local structural context grammars , a variant of data - oriented parsing ( lscg ) .",
    "osborne used a definite clause grammar learner based on minimum description length for finding noun phrases in samples of penn treebank material ( mdl ) .",
    "tjong kim sang detected noun phrases with a bottom - up cascade of combinations of memory - based classifiers ( mbl ) .",
    "the performance of the three systems can be found in table [ tab - npbracketing ] . for this task",
    "it was not possible to apply system combination to the output of the system .",
    "the mdl results have been obtained on a different data set and this left us with two remaining systems .",
    "a majority vote of the two will not improve on the best system and since there was no tuning data or development data available , other combination methods could not be applied .",
    "the project has proven to be successful in its results for applying machine learning techniques to all three of its selected tasks : chunking , np chunking and np bracketing .",
    "we are looking forward to applying these techniques to other nlp tasks .",
    "three of our project members will take part in the conll-2001 shared task , ` clausing ' , hopefully with good results .",
    "two more have started working on the challenging task of full parsing , in particular by starting with a chunker and building a bottom - up arbitrary phrase recogniser on top of that .",
    "the preliminary results are encouraging though not as good as advanced statistical parsers like those of charniak and collins .",
    "it is fair to characterise lcg s goals as primarily technical in the sense that we sought to maximise performance rates , esp .",
    "the recognition of different levels of np structure .",
    "our view in the project is certainly broader , and most project members would include learning as one of the language processes one ought to study from a computational perspective  like parsing or generation .",
    "this suggest several further avenues , e.g. , one might compare the learning progress of simulations to humans ( mastery as a function of experience )",
    ". one might also be interested in the exact role of supervision , in the behaviour ( and availability ) of incremental learning algorithms , and also in comparing the simulation s error functions to those of human learners ( wrt to phrase length or construction frequency or similarity ) .",
    "this would add an interesting cognitive perspective to the work , along the lines begun by brent , but we note it here only as a prospect for future work .",
    "r.  bod and r.  scha .",
    "data - oriented language processing . in s.",
    "young and g.  bloothooft , editors , _ corpus - based methods in language and speech processing _ , pages 137173 .",
    "kluwer academic publishers , boston .",
    "erik  f. tjong kim  sang , walter daelemans , herv djean , rob koeling , yuval krymolowski , vasin punyakanok , and dan roth .",
    "2000 . applying system combination to base noun phrase identification . in _ proceedings of the 18th international conference on computational linguistics ( coling 2000)_.",
    "saarbruecken , germany ."
  ],
  "abstract_text": [
    "<S> this paper reports on the learning computational grammars ( lcg ) project , a postdoc network devoted to studying the application of machine learning techniques to grammars suitable for computational use . </S>",
    "<S> we were interested in a more systematic survey to understand the relevance of many factors to the success of learning , esp . </S>",
    "<S> the availability of annotated data , the kind of dependencies in the data , and the availability of knowledge bases ( grammars ) . </S>",
    "<S> we focused on syntax , esp . </S>",
    "<S> noun phrase ( np ) syntax . </S>"
  ]
}