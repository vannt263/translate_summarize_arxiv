{
  "article_text": [
    "in this short note we study the semantics of two basic computational effects , exceptions and states , from a new point of view .",
    "exceptions are studied in section  [ sec : exceptions ] .",
    "the focus is placed on the exception `` flags '' which are set when an exception is raised and which are cleared when an exception is handled .",
    "we define the _ exception constructor _ operation which sets the exception flag , and the _ exception recovery _ operation which clears this flag .",
    "states are considered in the short section  [ sec : states ] . then in section  [ sec : dual ] we show that our point of view yields a surprising result : there exists a symmetry between the computational effects of exceptions and states , based on the categorical duality between sums and products . more precisely , the lookup and update operations for states are respectively dual to the constructor and recovery operations for exceptions .",
    "this duality is deeply hidden , since the constructor and recovery operations for exceptions are mixed with the control .",
    "this may explain that our result is , as far as we know , completely new .",
    "states and exceptions are _ computational effects _ : in an imperative language there is no type of states , and in a language with exceptions the type of exceptions which may be raised by a program is not seen as a return type for this program . in this note",
    "we focus on the denotational semantics of exceptions and states , so that the sets of states and exceptions are used explicitly .",
    "however , with additional logical tools , the duality may be expressed in a way which fits better with the syntax of effects @xcite .",
    "other points of view about computational effects , involving monads and lawvere theories , can be found in @xcite .",
    "however it seems difficult to derive from these approaches the duality described in this note .",
    "the syntax for exceptions heavily depends on the language . for instance in ml - like languages",
    "there are several exception _ names _ , and the keywords for raising and handling exceptions are ` raise ` and ` handle ` , while in java there are several exception _ types _ , and the keywords for raising and handling exceptions are ` throw ` and ` try - catch ` . in spite of the differences in the syntax ,",
    "the semantics of exceptions share many similarities .",
    "a major point is that there are two kinds of values : the ordinary ( i.e. , non - exceptional ) values and the exceptions .",
    "it follows that the operations may be classified according to the way they may , or may not , interchange these two kinds of values : an ordinary value may be `` tagged '' for constructing an exception , then the `` tag '' may be cleared in order to recover the value .",
    "first let us focus on the raising of exceptions .",
    "let @xmath0 denote the set of _ exceptions_. the `` tagging '' process can be modelled by injective functions @xmath1 called the _",
    "exception constructors _ , with disjoint images : for each index @xmath2 in some set of indices @xmath3 , the exception constructor @xmath1 maps a non - exceptional value ( or _ parameter _ ) @xmath4 to an exception @xmath5 .",
    "when a function @xmath6 _ raises _ ( or _ throws _ ) an exception of index @xmath2 , the following _ raising _ operation is called : @xmath7 the raising operation @xmath8 is defined as the exception constructor @xmath9 followed by the inclusion of @xmath0 in @xmath10 .    given a function @xmath6 and an element @xmath11 , if @xmath12 for some @xmath4 then one says that @xmath13 _ raises an exception of index @xmath2 with parameter @xmath14 into @xmath15_. one says that a function @xmath16 _ propagates exceptions _ when it is the identity on @xmath0 . clearly , any function @xmath6 can be extended in a unique way as a function which propagates exceptions .",
    "now let us study the handling of exceptions .",
    "the process of clearing the `` exception tags '' can be modelled by functions @xmath17 called the _ exception recovery _",
    "operations : for each @xmath18 and @xmath19 the exception recovery operation @xmath20 tests whether the given exception @xmath21 is in the image of @xmath9 .",
    "if this is actually the case , then it returns the parameter @xmath4 such that @xmath22 , otherwise it propagates the exception @xmath21 .    for handling exceptions of indices",
    "@xmath23 raised by some function @xmath6 , one provides a function @xmath24 , which may itself raise exceptions , for each @xmath25 in @xmath26 .",
    "then the handling process builds a function which propagates exceptions , it may be named @xmath27 or @xmath28 : @xmath29 using the recovery operations @xmath30 , the handling process can be defined as follows .",
    "999 = 999 = 999 = 999 = for each @xmath31 , @xmath32 is defined by : + // _ if @xmath33 was an exception before the @xmath34 , then it is just propagated _",
    "+ if @xmath35 then return @xmath36 ; + // _",
    "now @xmath33 is not an exception _ + compute @xmath37 ; + if @xmath38 then return @xmath39 ; + // _",
    "now @xmath40 is an exception _ + for @xmath41 repeat + compute @xmath42 ; + if @xmath43 then return @xmath44 ; + // _",
    "now @xmath40 is an exception but it does not have index @xmath45 , for any @xmath46 _ + return @xmath47 .",
    "given an exception @xmath21 of the form @xmath48 , the recovery operation @xmath49 returns the non - exceptional value @xmath14 while the other recovery operations propagate the exception  @xmath21 .",
    "this is expressed by the equations  ( [ eq : exceptions - explicit ] ) in figure  [ fig : exceptions ] . whenever @xmath50 with the @xmath9 s as coprojections , then equations  ( [ eq : exceptions - explicit ] ) provide a characterization of the operations  @xmath49 s .",
    "* for each index @xmath18 : * a set @xmath51 ( parameters ) * two operations @xmath1 ( exception constructor ) + and @xmath52 ( exception recovery ) * and two equations : @xmath53 which correspond to commutative diagrams , where @xmath54 and @xmath55 are the injections : @xmath56_{{\\mathit{m}}_i } \\\\ { \\mathit{exc}}\\ar[u]^{c_i } & { \\mathit{par}}_i \\ar[l]^{t_i } \\ar[u]_{{\\mathit{id } } } \\ar@{}[ul]|{= } \\\\ }   \\qquad \\qquad   \\xymatrix@r=1pc@c=2pc { { \\mathit{par}}_i+{\\mathit{exc } } & { \\mathit{exc}}\\ar[l]_(.3){{\\mathit{n}}_i }    & { \\mathit{par}}_j \\ar[l]_{t_j } \\\\ { \\mathit{exc}}\\ar[u]^{c_i } & & { \\mathit{par}}_j \\ar[ll]^{t_j } \\ar[u]_{{\\mathit{id } } } \\ar@{}[ull]|{= } \\\\ } \\ ] ]",
    "now let us forget temporarily about the exceptions in order to focus on the semantics of an imperative language .",
    "let @xmath57 denote the set of _ states _ and @xmath58 the set of _ locations _ ( also called _",
    "variables _ or _ identifiers _ ) . for each location @xmath2 ,",
    "let @xmath59 denote the set of possible _ values _ for @xmath2 .",
    "for each @xmath60 there is a _ lookup _",
    "operation @xmath61 for reading the value of location @xmath2 in the given state .",
    "in addition , for each @xmath60 there is an _ update _ operation @xmath62 for setting the value of location @xmath2 to the given value , without modifying the values of the other locations in the given state .",
    "this is summarized in figure  [ fig : states ] . whenever @xmath63 with the @xmath64 s as projections , two states @xmath65 and @xmath66 are equal if and only if @xmath67 for each @xmath2 , and equations  ( [ eq : states - explicit ] ) provide a characterization of the operations @xmath68 s .",
    "* for each location @xmath60 : * a set @xmath59 ( values ) * two operations @xmath69 ( lookup ) + and @xmath62 ( update ) * and two equations : @xmath70 which correspond to commutative diagrams , where @xmath71 and @xmath72 are the projections : @xmath73^{{\\mathit{p}}_i } \\ar[d]_{u_i } & { \\mathit{val}}_i \\ar[d]^{{\\mathit{id } } } \\\\ { \\mathit{st}}\\ar[r]_{l_i } & { \\mathit{val}}_i \\ar@{}[ul]|{= } \\\\ }   \\qquad\\qquad   \\xymatrix@r=1pc@c=2pc { { \\mathit{val}}_i\\times{\\mathit{st}}\\ar[r]^(.7){{\\mathit{q}}_i } \\ar[d]_{u_i } &     { \\mathit{st}}\\ar[r]^{l_j } & { \\mathit{val}}_j \\ar[d]^{{\\mathit{id } } } \\\\ { \\mathit{st}}\\ar[rr]_{l_j } & & { \\mathit{val}}_j \\ar@{}[ull]|{= } \\\\ } \\ ] ]",
    "our main result is now clear from figures  [ fig : exceptions ] and  [ fig : states ] .",
    "[ theo : duality ] the duality between categorical products and sums can be extended as a duality between the semantics of the lookup and update operations for states on one side and the semantics of the constructor and recovery operations for exceptions on the other side .    in @xcite an equational presentation of states is given , with seven families of equations .",
    "these equations can be translated in our framework , and it can be _ proved _ that they are equivalent to equations  ( [ eq : states - explicit ] ) @xcite",
    ". then by duality we get for free seven families of equations for exceptions .",
    "for instance , it can be proved that for looking up the value of a location  @xmath2 only the _ previous _ updating of this location  @xmath2 is necessary , and dually , when throwing an exception constructed with @xmath9 only the _ next _ recovery operation @xmath49 , with the same index  @xmath2 , is necessary ."
  ],
  "abstract_text": [
    "<S> * abstract . * in this short note we study the semantics of two basic computational effects , exceptions and states , from a new point of view . in the handling of exceptions </S>",
    "<S> we dissociate the control from the elementary operation which recovers from the exception . in this way </S>",
    "<S> it becomes apparent that there is a duality , in the categorical sense , between exceptions and states . </S>"
  ]
}