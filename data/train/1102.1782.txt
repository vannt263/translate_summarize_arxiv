{
  "article_text": [
    "network coding was introduced in @xcite as a means to improve the rate of transmission in networks .",
    "linear network coding was introduced in @xcite and it was found to be sufficient to achieve the maxflow - mincut capacity in certain scenarios such as multicast . the linear network coding problem on a network with given sink demands",
    "can be considered to have three major subproblems .    *",
    "existence of a network code that satisfies the demands ( called a _",
    "feasible network code _ ) .",
    "* efficient construction of such a network code . * minimum field size for the existence of such a network code .    an algebraic theory of network coding was developed in @xcite , which converted the existence problem of network coding into a problem in algebraic geometry .",
    "as for the latter two subproblems , most of the literature in network coding has focused on the multicast problem , i.e. , where all sinks demand the information generated by all the sources in the network . a polynomial - time algorithm for designing a multicast network code on a single - source acyclic instantaneous ( zero - delay ) network",
    "was presented in @xcite .",
    "this algorithm was further generalized in @xcite and @xcite for the case of multicast on networks with cycles .",
    "note that the notion of delays in the network is inherent to any algorithm on cyclic networks .",
    "delays are therefore assumed either on the edges of the networks that contribute to the cycles alone , or throughout the network .",
    "an information flow decomposition based approach to the problem of network code construction was discussed in @xcite .",
    "computing the minimum field size required to solve a network coding problem is known @xcite to be np - hard . however , for the multicast case on acyclic networks and certain kinds of cyclic networks , it is known @xcite @xcite that a field size larger than the number of sinks in the network is sufficient .",
    "further results on the field size issue can be found in @xcite@xcite @xcite . in certain networks ,",
    "linear network coding itself is found to be insufficient to achieve the given demands @xcite .",
    "the case of acyclic networks with delays was abstracted in @xcite as acyclic networks where each edge in the network has an integer delay associated with it . with this setting ,",
    "the authors of @xcite presented the framework for the problem of the existence of a linear network code on such networks .",
    "according to the framework of @xcite , a feasible network code on an acyclic network has to satisfy two conditions at every sink , which we refer to as @xmath0 _ invertibility _ conditions , which have to be satisfied to recover the information sequences demanded at each sink , and @xmath1 _ zero - interference _ conditions , which have to be satisfied so that information sequences not needed at a sink do not interference with those that are demanded ( a formal description of these conditions are given in section [ sec3 ] ) .",
    "the behavioral difference between an acyclic instantaneous network and its delay counterpart arises because the network nodes can mix differently delayed source symbols in the delay network .",
    "it has been noted ( see @xcite@xcite , for example ) that such delay disparity can be nulled in integer delay networks and instantaneous behavior can be effectively simulated by synchronizing transmissions at the intermediate nodes using enough memory . simulating instantaneous behavior in the network",
    "clearly reduces the decoding complexity at the sinks compared to operating the network without memory .",
    "however , besides this obvious utility , other advantages or disadvantages of nulling the inherent delays in the network using memory have not been studied .",
    "we investigate these issues in the present work .",
    "in particular , we will demonstrate that utilizing the inherent delays in the network as is ( without using memory at the intermediate nodes ) turns out to be advantageous , disadvantageous or immaterial depending on the network topology and the network coding subproblem considered .",
    "we illustrate this using the following two examples . in the following examples and throughout this paper , given an acyclic network @xmath5 with certain demands at each sink , we refer to the instantaneous ( zero - delay ) version of @xmath5 as @xmath6 and its corresponding unit - delay version as @xmath7 in which a single unit of delay denoted by the parameter @xmath8 is associated with each edge .",
    "example [ exm1 ] shows a network @xmath5 for which there exists feasible network codes in @xmath6 but none for @xmath9 example [ exm2 ] illustrates a network @xmath10 in which feasible network codes exist over a smaller field for @xmath11 compared to @xmath12 note that both these examples indicate the non - triviality of the delay disparity problem in networks with delay . simulating instantaneous",
    "performance using memory at the intermediate nodes of the network of example [ exm1 ] renders a feasible network coding solution , while doing so for example [ exm2 ] necessitates an increase in the field size .    [ exm1 ]",
    "consider the network @xmath5 shown in fig .",
    "let the field under consideration be @xmath13 source @xmath14 has a sequence @xmath15 ( @xmath8 denoting the time index ) , which has to be conveyed to sink @xmath16 while the sequence @xmath17 at source @xmath18 has to be conveyed to sink @xmath19 in both @xmath20 and @xmath7 the topology of the network demands that the linear combination of the two incoming sequences at node @xmath21 should be such that both the local encoding coefficients are non - zero .    in @xmath6",
    "the information sequence @xmath15 is cancelled out at node @xmath22 to enable sink @xmath23 to receive @xmath24 and similarly cancellation of @xmath17 happens at node @xmath25 for sink @xmath26 in @xmath7 this cancellation , while being necessary for the network code to be feasible , can not happen at the nodes @xmath22 and @xmath25 because of the disparity in the delays of the flows at their incoming edges .",
    "since the choice of our finite field was arbitrary , it is therefore clear that unless memory is used at some of the intermediate nodes , there exists no feasible network code for this network considered with delays over any finite field .     where zero - interference conditions fail to hold in @xmath11,width=240 ]    [ exm2 ] consider the network @xmath5 shown in fig .",
    "the source @xmath27 has two sequences @xmath15 and @xmath17 to be transmitted to the six sinks @xmath28 this network is clearly a cascaded version of the usual butterfly network and the @xmath29 network . as in the case of the @xmath29 network ,",
    "a feasible network coding solution for this network ( either in @xmath20 or in @xmath11 ) implies that any two of the four global encoding vectors on the edges @xmath30 should be linearly independent .",
    "therefore , for @xmath6 a minimum field size of @xmath31 is required to construct a feasible network code .    however , for @xmath7 a binary field is sufficient .",
    "consider the usual network code over @xmath32 in the butterfly subnetwork of the given network , where the global encoding vectors at the node @xmath22 are @xmath33 and @xmath34 while those at node @xmath25 are @xmath35 and @xmath36 then the vectors @xmath37 @xmath38 @xmath39 and @xmath40 can be chosen as global encoding vectors for the edges @xmath30 respectively , which render the network code feasible for @xmath9 therefore , even in a multicast situation , the minimum field size requirement of the unit - delay network can be smaller than that of the corresponding instantaneous network .",
    "note that such a situation is made possible because of the difference in the delays between the incoming symbols at the two edges of @xmath41     where minimum field size requirement decreases in @xmath11 compared to @xmath10,width=288 ]    table [ tab1 ] summarizes the relationships obtained in this paper between some of the network coding problems for instantaneous and unit - delay networks .",
    "the contributions of our work are as follows .    [",
    "cols=\"^,^,^ \" , ]     [ tab1 ]    * we prove that the solvability of @xmath20 preserves the invertibility conditions ( proposition [ prop1 ] ) in @xmath11 , but not necessarily zero - interference conditions ( example [ exm1 ] ) . on the other hand",
    ", we prove that if @xmath11 is solvable , then @xmath20 is always solvable ( proposition [ prop2 ] ) , and thereby proving that if @xmath20 is not solvable , then so is @xmath11 ( corollary [ cornonsolvability ] ) .",
    "these results on the relationship between the solvability and non - solvability of @xmath20 and @xmath11 are tabulated in the first two rows of table [ tab1 ] .",
    "* we show that whenever there is a polynomial - time algorithm for constructing a feasible network code for @xmath11 , then there is a polynomial - time algorithm for constructing a feasible network code for @xmath20 ( corollary [ corollaryconstruction ] ) .",
    "the third row of table [ tab1 ] captures these results .",
    "* we prove that under certain conditions on the topology of the network there exists an equivalence between a network code over any particular field constructed on @xmath20 and @xmath11 ( proposition [ prop3 ] ) .",
    "thus , for networks obeying the constraints given in proposition [ prop3 ] , the minimum field size for constructing a feasible network code for @xmath20 and @xmath11 is the same .",
    "we also prove that under such constraints on topology , the non - solvability of @xmath11 implies the non - solvability of @xmath6 over a particular field ( corollary [ cor3 ] ) . the last two rows of table [ tab1 ] lists these results .",
    "* we prove that there exist networks for which the delays prove useful for the field size problem , i.e. , feasible network codes can be constructed over a smaller field size for @xmath11 compared to @xmath6 and also show a construction of such networks ( corollary [ cor4 ] ) .",
    "these results are also tabulated in the last two rows of table [ tab1 ] . in the process",
    ", we prove the feasibility of two multicast algorithms , one of which works for acyclic networks ( instantaneous and with delays ) and was conjectured in @xcite based on the multicast algorithm of @xcite , and the other works for certain special acyclic networks ( proposition [ prop4 ] and proposition [ prop5 ] ) .",
    "these modified algorithms employ low - complexity encoding at the intermediate nodes over @xmath32 using memory elements , while possibly demanding a larger complexity of decoding at the sinks compared to traditional network coding schemes .",
    "the rest of this work is organized as follows . in section [ sec2 ]",
    ", we set up the model and the terminology for acyclic networks with delays .",
    "in section [ sec3 ] , we explore the relationship between the network code existence problem in @xmath11 and @xmath20 for an acyclic network @xmath5 with given set of demands , and also present examples where having delays prevent the existence of any solution for @xmath11 while solutions exist for @xmath12 in subsection [ subsec4b ] , we analyze the conditions on topology which result in an equivalence of network coding solutions between @xmath11 and @xmath12 after briefly reviewing the lif algorithm of @xcite in subsection [ lifalg ] , in subsection [ delayandcode ] we use a modified version of this algorithm to obtain a class of networks in which delays prove beneficial in the minimum field size problem , i.e. , where feasible binary network codes always exist for @xmath11 irrespective of the field size required for @xmath12 we conclude the paper in section [ sec5 ] with remarks and directions for further research . _ the proofs of all the propositions , lemmas , theorems and other claims are made available in the appendices at the end of the paper . _",
    "following the terminology of @xcite , an acyclic network is modeled as an acyclic graph @xmath10 with @xmath42 being the set of nodes and @xmath43 the set of edges in the network .",
    "let @xmath44 be the set of source nodes ( generating i.i.d .",
    "information sequences ) and @xmath45 be the set of sinks .",
    "we assume that the sources have no incoming edges in the network , while the sinks have no outgoing edges .",
    "the time unit under consideration shall imply one use of the channels in the network .",
    "each source @xmath46 generates @xmath47 information sequences at the rate of @xmath47 @xmath48 symbols per every time unit , @xmath48 being the finite field with @xmath49 symbols . for each source @xmath50",
    "we introduce @xmath47 imaginary edges ( denoted by @xmath51 ) incoming at @xmath52 which carry the @xmath47 information sequences to the source @xmath53 let @xmath54    assuming an ordering on the set of information sequences available at the sources , let @xmath55 denote an indicator function for a sink @xmath56 defined as @xmath57 such that , @xmath58 if sink @xmath59 demands the @xmath60 information sequence , and @xmath61 otherwise .",
    "let @xmath62 denote the collection of the functions @xmath63    each sink node @xmath64 demands some subset of size @xmath65 of the @xmath66 information sequences generated at the sources .",
    "let @xmath67 for each sink @xmath68 we assume @xmath65 imaginary outgoing edges from @xmath68 denoted by @xmath69 we represent a network @xmath70 with a set of sources @xmath71 and a set of sinks @xmath72 with a set of demands given by @xmath73 as @xmath74    every edge in the directed graph representing the network has a capacity of one @xmath48 symbol .",
    "we abstract the case of networks with delay by assuming a unit - delay associated with edges of the graph @xmath10 , represented by the parameter  @xmath8 .",
    "we denote the graph @xmath70 along with the delays as @xmath7 the unit - delay version of @xmath10 or simply the _ unit - delay network _ @xmath11 . note that network links with integer delays greater than unit are modeled as serially concatenated edges in the directed multi - graph .",
    "because of this reason , we view networks with integer delays and those with unit - delays equivalently .",
    "the set of symbols generated at the sources at any particular instant of time is called a _ generation _ of symbols .",
    "any node in a unit - delay network may receive information of different generations on its incoming edges at any particular time instant .",
    "except for the discussion in subsection [ delayandcode ] , we assume that the intermediate ( non - sink , non - source ) nodes are memory - free and merely transmit a @xmath48 linear combination of the incoming sequences on their outgoing edges . also , the zero - delay version of @xmath75 referred to as the _ instantaneous network _ ,",
    "is denoted by @xmath12 the following notations will be used throughout the paper .",
    "@xmath76 for an edge @xmath77 we define the _ local encoding vector _ as a @xmath78-length vector , @xmath79 where @xmath80 the field of rational functions over @xmath13 the local encoding vector determines the sequence @xmath81 being the symbol at @xmath60 time index@xmath82 flowing on edge @xmath83 based on the sequences incoming at @xmath84 i.e. , @xmath85 note that as the intermediate nodes are allowed to take only @xmath48 linear combinations of the incoming sequences , we have for an edge @xmath86 ( for any @xmath87 ) , @xmath88 where @xmath89 and the parameter @xmath8 denotes the delay incurred during the transmission through edge @xmath90 for an edge @xmath91 of some source @xmath92 we have @xmath93 where @xmath94",
    "as we let the sources take arbitrary combinations over @xmath95 the additional @xmath8 again denotes the delay incurred on the edge @xmath90 for @xmath6 note that @xmath96 for any pair of edges @xmath83 and @xmath97 and therefore the corresponding input - output relationship for any edge @xmath83 is given independent of the time index as @xmath98 where @xmath99    let @xmath100 denote the set of all _ local encoding coefficients _ ( all taking values from @xmath48 ) , i.e. , for @xmath11 @xmath100 is the set of all components of the local encoding vectors at all intermediate nodes and the coefficients of the numerator and denominator polynomials of the local encoding vectors at the sources , while for @xmath6 @xmath100 denotes the set of all @xmath101 the difference between the two will be clear from the context .",
    "the network coding problem implies a choice of the local encoding coefficients @xmath102 such that each sink can recover the information it demands . because of the linearity of ( [ eqn4 ] )",
    ", we can associate with every edge @xmath83 a @xmath66-length _ global encoding vector _ over @xmath95 the global encoding vector @xmath103 of edge @xmath104 indicates the particular @xmath105 linear combination of the @xmath66 information sequences , flowing in @xmath90 naturally , @xmath106,$ ] with @xmath107 at the @xmath60 position . by ( [ eqn4 ] )",
    ", the vector @xmath103 can be recursively calculated from the global encoding vectors of the edges incoming at @xmath108 the global encoding vectors are well defined because of the acyclicity of the network .",
    "having ordered the @xmath66 input sequences and the @xmath109 output sequences , the input - output relationship of @xmath11 can be represented as a @xmath110 matrix over @xmath105 called the _ overall transfer matrix _ @xcite , @xmath111 of the network , the columns of which are the global encoding vectors of the imaginary outgoing edges from the sinks .",
    "the transfer matrix corresponding to a particular sink @xmath68 is the @xmath112 matrix @xmath113 the columns of which are the global encoding vectors of the imaginary outgoing edges from the sink @xmath114 therefore , for @xmath115 being the @xmath66-length input vector and @xmath116 being the @xmath65-length output vector at sink @xmath68 we have @xmath117 for @xmath6 the components of the global encoding vectors and network transfer matrices are all elements from @xmath13 for more details on the structure of these matrices , we refer the reader to @xcite .",
    "the problem of network code existence was presented from an algebraic geometry point of view in @xcite .",
    "the local encoding coefficients @xmath100 are assumed to be variables which can take values from a large enough finite field .",
    "a network code , i.e. , a particular choice of the set of all local encoding coefficients @xmath118 is defined to be _ feasible _ , i.e. , it achieves the given set of demands at the sinks , if the following two conditions are satisfied .    * _ invertibility conditions : _ for each sink @xmath68 the @xmath119 submatrix @xmath120 of @xmath113 the rows of which corresponding to the inputs demanded at sink @xmath68 is invertible over @xmath95 * _ zero - interference conditions : _ for each sink @xmath68 the elements of the matrix @xmath121 which are not part of @xmath120 are zero .",
    "note that if the mincut between any source @xmath27 and any sink @xmath59 is less than the number of information sequences demanded by @xmath59 from @xmath52 then the network coding problem is clearly not solvable .",
    "besides the mincut conditions , the topology of the network also affects the ability to satisfy the demands in the network .    for each sink",
    "@xmath68 some elements of @xmath121 are not a part of the @xmath120 matrix .",
    "let @xmath122 be all such elements , for all possible sinks @xmath123 note that each @xmath124 for any particular choice of @xmath100 , hence we represent each @xmath125 as @xmath126 similarly , let @xmath127 be the determinants of the @xmath120 matrices .",
    "let @xmath128 the invertibility and zero - interference conditions then imply that the assignment of @xmath100 should satisfy @xmath129 and @xmath130 respectively .",
    "similar conditions ( except for the delay parameter @xmath8 ) for feasibility hold good for the @xmath20 also .",
    "note that for certain network topologies or sink demands , the invertibility conditions alone will suffice for feasibility , while the zero - interference conditions might not arise at all @xcite .",
    "the multicast case , where all sinks demand all the information sequences , is one such example .",
    "we now provide some results regarding the question of whether the solvability of @xmath11 implies the solvability of @xmath20 also , and vice versa .",
    "the following proposition is a generalized version of proposition 1 of @xcite , where the statement was proved only for a multicast case .",
    "[ prop1 ] let @xmath131 be an acyclic , unit - delay network with a given set of sink demands and @xmath132 be the corresponding instantaneous network .",
    "let @xmath133 be a set of local encoding kernels which result in a network code for @xmath20 , satisfying the invertibility conditions",
    ". then @xmath133 continues to satisfy the invertibility conditions for @xmath9    for the multicast case , which has no zero - interference conditions , we then have the following corollary , which was proved in @xcite .    [ cor1 ] let @xmath131 be an acyclic , unit - delay network with multicast demands , i.e. , all sinks require all the information sequences , and @xmath132 be the corresponding instantaneous network .",
    "then a feasible network code for @xmath20 continues to be feasible for @xmath9    in a general non - multicast network coding problem , it might not be possible to satisfy the zero - interference conditions in the network @xmath7 though they can be satisfied in the network @xmath12 this is because of the fact that different flows which cancelled out the interference in @xmath20 can take paths of different delays in the corresponding acyclic network with delays , thereby preventing the cancelling effect .",
    "example [ exm1 ] illustrated one such network , for which there exists solutions in @xmath6 but none for @xmath9 in light of proposition [ prop1 ] and example [ exm1 ] , it can be observed that the solvability of a network coding problem for @xmath20 need not imply solvability for @xmath9 the following proposition answers the reverse problem , i.e. , that solvability of a given @xmath134 for @xmath11 always implies its solvability for @xmath12    [ prop2 ] let @xmath131 be an acyclic , unit - delay network with a given set of sink demands and @xmath20 be the corresponding instantaneous network .",
    "if there exists a feasible network code for @xmath135 then there exists a feasible network code for @xmath136    proposition [ prop2 ] leads to the following corollary , about the relationship between the non - solvability of the @xmath20 and that of @xmath11 for a network coding problem on an acyclic network @xmath137    [ cornonsolvability ] let @xmath131 be an acyclic , unit - delay network with a given set of sink demands and @xmath20 be the corresponding instantaneous network .",
    "if there exists no feasible network code for @xmath138 then there exists no feasible network code for @xmath139    note that the proof of proposition [ prop2 ] involved an actual construction of a feasible network code for @xmath20 starting from a feasible network code for @xmath9 such a construction implies the following corollary on a polynomial - time construction for a feasible network coding solution for @xmath12    [ corollaryconstruction ] let @xmath131 be an acyclic , unit - delay network with a given set of sink demands and @xmath20 be the corresponding instantaneous network .",
    "if there exists a polynomial - time construction algorithm for a feasible network coding solution on @xmath7 then there exists a polynomial - time construction algorithm for a feasible network coding solution on @xmath12",
    "in this section , we discuss the effect of considering delays in the network on the field size over which a valid network code can be designed for an acyclic network @xmath137 we assume that @xmath11 is solvable , which mean that @xmath20 is also solvable , according to proposition [ prop2 ] . note that proposition [ prop1 ] already gives a small insight into the field size issue , showing that for a multicast network , the minimum field size that satisfies the invertibility conditions in @xmath11 is at most as large as the minimum field size for @xmath12 it is not difficult to observe that in some of the usual examples in network coding literature such as the butterfly network and combination networks , the feasibility of a given network code is preserved between the unit - delay network and the corresponding instantaneous network , because the topology of these networks prevents the mixing of information symbols from different generations at the intermediate nodes . in the forthcoming subsection , we formalize such a topological constraint for networks with general demands and",
    "thereby obtain sufficient conditions on the equivalence of network coding solutions between @xmath11 and @xmath20 for an acyclic network @xmath5 with given demands .",
    "the following proposition gives a class of networks for which the minimum field size is equal for both @xmath20 and @xmath7 by demonstrating a sufficient condition under which certain network coding solutions remain feasible for both @xmath20 and @xmath11 .",
    "we define for a node @xmath140 a set @xmath141 which consists of all possible paths ( a path being a sequence of edges following an ancestral order ) from the source nodes to @xmath142 such that any two paths differ by at least one edge .",
    "we also define for a node @xmath143 a @xmath144-length _ depth vector _ @xmath145",
    "each component ( in @xmath146 ) of which indicates the total delay incurred in the corresponding path of @xmath141 from some source @xmath27 to node @xmath147    [ prop3 ] let @xmath131 be an acyclic , unit - delay network with a given set of sink demands and @xmath132 be the corresponding instantaneous network .",
    "suppose the topology of @xmath11 is such that for any @xmath143 the components of the depth vector @xmath148 are all equal .",
    "let @xmath149 be the set of all feasible solutions for @xmath131 such that the sources combine information symbols without using memory , i.e. , the symbols only from the current generation , and @xmath150 be the subset of @xmath149 with solutions from the field @xmath13 then the following statements are true .    1 .",
    "any solution from @xmath149 for @xmath11 is also a feasible solution for @xmath12 2 .",
    "any feasible solution for @xmath20 is a feasible solution for @xmath9 3 .",
    "if @xmath151 is the minimum field size for which a feasible network code exists for @xmath11 and the subset @xmath152 of @xmath149 is non - empty , then @xmath151 is the minimum field size required for a feasible solution for @xmath20 too .",
    "proposition [ prop3 ] leads to the following corollary on the relationship between non - solvability of @xmath20 and that of @xmath11 for an acyclic network @xmath5 with given demands over any particular field .",
    "[ cor3 ] let @xmath131 be an acyclic , unit - delay network with a given set of sink demands and @xmath132 be the corresponding instantaneous network .",
    "suppose the topology of @xmath11 is such that for any @xmath143 the components of the depth vector @xmath148 are all equal .",
    "if @xmath11 has no feasible solutions over some particular field @xmath153 then neither does @xmath12",
    "proposition [ prop3 ] illustrates some network conditions which lead to the equivalence between finding the minimum required field size for a given set of demands on @xmath11 and @xmath20 of a given acyclic network @xmath5 .",
    "example [ exm1 ] illustrated a situation where the disparity in the delays of the symbols arriving at a node prevented the possibility of obtaining a feasible network code .",
    "however , such delay disparity can also be useful .",
    "in particular , because of this delay disparity , there exist networks in which the feasible network codes exist over a smaller field for @xmath11 compared to @xmath12 one such network was already seen in example [ exm2 ] .",
    "we now present another network with non - multicast demands , which demonstrates a similar situation .",
    "[ exm3 ] consider the network @xmath10 shown in fig .",
    "[ fig3 ] . for @xmath154 each source @xmath155 has an information sequence @xmath156 this network has non - multicast demands , with sinks @xmath157 requiring all three information sequences , while sink @xmath158 requires @xmath159 and @xmath160 demands @xmath161 we show that no feasible network code exists for @xmath20 over @xmath162 while such a code exists for @xmath9    we now argue that we can not obtain a feasible network code for @xmath20 over @xmath163 the sinks @xmath164 have direct paths from the source(s ) @xmath165 and @xmath166 respectively . as the sinks @xmath167 require information sequences from all three sources , the edge @xmath168 should carry a coded version of all three information sequences for the network code to be feasible at sinks @xmath169 thus , over @xmath162 the global encoding vector for edge @xmath168 should be @xmath170 as sink @xmath160 has a direct path from source @xmath171 the edge @xmath172 should carry a linear combination of both @xmath17 and @xmath173 thus the global encoding vector of edge @xmath172 over @xmath32 must be @xmath174 now , as sink @xmath158 has a direct path from source @xmath171 the edge @xmath175 should carry a linear combination of both @xmath15 and @xmath176 i.e. , @xmath177 however , the global encoding vectors of the incoming edges at node @xmath21 are @xmath178 and @xmath179 using which the vector @xmath180 can not be obtained .",
    "thus no feasible network code can be found for @xmath20 over @xmath163 a feasible network code can be found for this network over any field with size @xmath181    now we prove by argument that there exists a code for @xmath11 over @xmath163 because @xmath168 should carry a linear combination of all three information sequences , let its global encoding vector be @xmath182 after accounting for the delays incurred in the transmission . accounting for the disparity in the delays at the node @xmath183 let the global encoding vector of edge @xmath172 be @xmath184 thus the global encoding vectors of the incoming edges at node @xmath21 are @xmath185 and @xmath186 node @xmath21 can then simply send a sum of two incoming symbols on edge @xmath187 in which case the global encoding vector of edge @xmath175 is @xmath188 accounting for all the direct paths in the network , it can be seen that all sink demands are satisfied , i.e. , the invertibility conditions hold over @xmath189 and so do the zero - interference conditions . thus there is a feasible network code for @xmath11 over @xmath163 as in the previous example , the delay disparity at node @xmath22 is what makes this possible .",
    "[ fig3 ]    in the remainder of this section , we show that there exist several networks for which a binary field is sufficient for constructing a feasible network code .",
    "we concentrate only on the single - source multicast case . as the results in this section",
    "are all centered on the deterministic version of the _ linear information flow _ ( lif ) algorithm in @xcite , we briefly discuss the terminology and lemmas related to the lif algorithm before proving our results .",
    "the steps of the lif algorithm for constructing a multicast network code in a single source acyclic instantaneous network @xmath20 with @xmath190 sinks are as follows .    1 .",
    "identify the @xmath47 edge - disjoint paths from the source to the sinks , where @xmath47 is the number of information symbols at the source .",
    "note that @xmath47 can be at most equal to the minimum of the mincuts between source and each sink and not more , otherwise the multicast problem is infeasible .",
    "let @xmath191 be the subnetwork of @xmath5 consisting of the nodes and edges on these edge - disjoint paths alone .",
    "the rest of the algorithm works only with @xmath192 as a feasible network code for @xmath193 can be converted to a feasible network code for @xmath5 by simply assigning zeros for any other local encoding coefficients .",
    "2 .   for a sink @xmath194 let @xmath195 denote the set of @xmath47 edge - disjoint paths from the source to @xmath114 for each sink",
    "@xmath56 the algorithm maintains for each sink a set @xmath196 which consists of the @xmath47 most recently processed edges ( one from every path in @xmath195 ) and a @xmath197 matrix @xmath198 which has the global encoding vectors of the edges in @xmath199 the set @xmath200 is initialized with the set @xmath201 ( the @xmath47 imaginary edges at the source ) , while the columns of the matrix @xmath202 is initialized with the @xmath47-length global encoding vectors @xmath203 respectively . for every sink @xmath68",
    "the algorithm maintains the full - rank property of @xmath202 by an appropriate choice of the local encoding coefficients at @xmath84 @xmath204 being the most recently processed edge as @xmath200 is incremented in some ancestral ordering .",
    "the algorithm also maintains another @xmath197 matrix @xmath205 which has the inverse vectors of @xmath202 at every step of the algorithm .",
    "3 .   for an edge @xmath206 ,",
    "let @xmath207 denote the predecessor edge of @xmath83 on some flow path from the source @xmath27 to sink @xmath114 note that there can be at most one flowpath from @xmath27 to any sink through @xmath90 after processing any edge @xmath83 , the lif algorithm updates the set @xmath200 and the matrices @xmath202 and @xmath208 the updated values for @xmath209 and @xmath205 are denoted by @xmath210 and @xmath211 and are obtained as follows . 1 .",
    "@xmath212 2 .",
    "@xmath213 3 .",
    "@xmath214 4 .   for all @xmath215 @xmath216 4 .",
    "ultimately the algorithm ends with the matrix @xmath202 equal to the network transfer matrix @xmath217 of the sink @xmath68 whose full - rank property is guaranteed by the algorithm , therefore rendering a feasible network code .",
    "let @xmath218 be the number of sinks which have a flow path through @xmath104 and let @xmath219 the set of all predecessor edges of @xmath90 the only non - zero local encoding coefficients to be chosen for the edge @xmath83 by the algorithm are @xmath220 at every step of the algorithm where the global encoding vector of the next edge ( according to a chosen ancestral order ) @xmath83 is selected , the set @xmath202 has to be kept linearly independent , i.e. , the choice of @xmath102 should be such that @xmath221 is linearly independent .",
    "the following lemma proved in @xcite gives a fast way to test this linear independence based on the dot product in @xmath13 in the following lemma , we have @xmath222 if @xmath223    [ lemma1 ] consider a basis @xmath224 of @xmath225 and vectors @xmath226 @xmath227 such that @xmath228 then , any vector @xmath229 is linearly dependent on @xmath230 if and only if @xmath231    given the full - rank matrix @xmath202 of global encoding vectors @xmath232 we will denote the corresponding columns of the inverse matrix @xmath205 of @xmath198 as @xmath233 then the linear independence condition to be checked in the lif algorithm takes the following form due to lemma [ lemma1 ] : @xmath234 lemma [ lemma2 ] , proved in @xcite , gives the sufficient field size for the construction of a feasible network code for multicast on a single source acyclic network .    [ lemma2 ]",
    "let @xmath235 consider pairs @xmath236 with @xmath237 for @xmath238 there exists a linear combination @xmath239 of @xmath240 such that @xmath241 for @xmath242    _ outline of proof : _ we provide only an outline here in order that we might use similar proof ideas later in subsection [ delayandcode ] . for the complete proof ,",
    "the reader is referred to @xcite .",
    "the proof involves the iterative construction of vectors @xmath243 ( each @xmath244 ) such that for any @xmath245 @xmath246 is some linear combination of the vectors @xmath247 and for any @xmath248 such that @xmath249 @xmath250 as long as the field size is more than @xmath251 the vectors @xmath246 can always be found , with the final vector @xmath252 being the desired @xmath253    with @xmath83 being the edge under consideration , let @xmath254 in lemma [ lemma2 ] .",
    "then the vector @xmath239 found using lemma [ lemma2 ] satisfies ( by invoking lemma [ lemma1 ] ) the requirements for the global encoding vector @xmath103 of edge @xmath104 i.e. , ( [ eqn17 ] ) .",
    "the particular linear combination of the vectors @xmath255 used to obtain @xmath239 gives the local encoding coefficients at @xmath84 i.e. , @xmath256 by lemma [ lemma2 ] , a field size @xmath49 such that @xmath257 @xmath218 being the number of sinks which have flow paths through @xmath104 is always sufficient for constructing a multicast network code for @xmath258 according to the lif algorithm .",
    "therefore , for constructing a multicast network code in any single source acyclic network with @xmath190 sinks , @xmath259 is sufficient .",
    "note that although the lif designs a feasible network code for @xmath6 the extension of the lif algorithm ( and the associated lemmas ) to @xmath11 is straightforward . while the local encoding coefficients ( picked according to lemma [ lemma2 ] ) continue to be over @xmath153 the matrices",
    "@xmath205 and @xmath202 are over @xmath105 for @xmath11 according to ( [ eqn4 ] ) . therefore , the dot product involved in the lemma [ lemma1 ] and lemma [ lemma2 ] are the standard dot product in @xmath260 and full - rank property of @xmath202 is checked over @xmath95 by corollary [ cor1 ] , ( [ eqn9 ] ) holds for multicast network code construction for @xmath261 too .",
    "as discussed in subsection [ lifalg ] , the lif algorithm uses lemma [ lemma2 ] together with lemma [ lemma1 ] for constructing a multicast network code in a given instantaneous network @xmath6 or the corresponding unit - delay network @xmath9 based on the lif algorithm , we now present another network coding scheme called a _",
    "delay - and - code _ scheme , which reduces the complexity of encoding at the intermediate nodes at the cost of potentially increased complexity of decoding at the sink nodes .",
    "the finite field under consideration is always @xmath163 as a theoretical by - product of this scheme , we show that there exist networks for which the binary field is sufficient for constructing a multicast network code in @xmath7 irrespective of the field size requirement in @xmath12    we assume that each node is equipped with memory elements and a linear combination of the stored symbols is then transmitted on the outgoing edges . abusing the definition of the delay parameter @xmath262 we also denote a memory element by @xmath263 we however do not allow all possible @xmath189-linear combinations of the incoming symbols that is possible using the memory elements available at the node under consideration . in other words , the input - output relationship of the edge @xmath83 given by ( [ eqn4 ] )",
    "is restricted to be of the form @xmath264 where @xmath265 and @xmath266 in general ( for both @xmath20 and @xmath11 ) . for @xmath7 @xmath267 to account for mandatory delay incurred in the transmission through edge @xmath90    if a delay - and - code scheme on @xmath10 is such that for any node @xmath268 and for any @xmath269 @xmath270 then we refer to the delay - and - code scheme as a _ uniform delay - and - code _ scheme .",
    "otherwise , we refer to it as a _ non - uniform delay - and - code _ scheme . in other words , in the uniform delay - and - code scheme , an intermediate node is not allowed to code differently delayed versions of the symbols arriving from any particular edge . in the non - uniform case",
    ", this is permitted .",
    "note that we consider only intermediate nodes in the network , i.e. , the non - source non - sink nodes .",
    "the non - uniform delay - and - code technique was already mentioned in @xcite for acyclic and cyclic networks .",
    "it was however only conjectured that a feasible multicast network code can be designed using the non - uniform delay - and - code scheme . in this work",
    ", we prove that conjecture for the case of acyclic networks .",
    "similar to the usual network coding formulation , such linear combinations also result in a network transfer matrix at each sink , which should be full - rank over @xmath189 for the network code to be feasible for that particular sink .",
    "the algorithm for constructing a delay - and - code scheme for any given acyclic single - source network with multicast demands follows that of the lif algorithm , with the change that the local encoding coefficients are based on the formulation of ( [ eqn10 ] ) .",
    "the following proposition shows that any acyclic network with multicast demands can be solved using the non - uniform delay - and - code scheme .",
    "[ prop4 ] let @xmath271 be an acyclic single - source network with multicast demands with the mincut between @xmath27 and any @xmath272 being at least @xmath273 the number of information sequences generated at @xmath53 then a feasible network code can be designed for @xmath20 ( or @xmath11 ) using the non - uniform delay - and - code scheme provided the total number of memory elements present at each node for each incoming edge is at least @xmath274    we now deal with the uniform delay - and - code scheme .",
    "we consider only the special case of those networks in which the paths from the source to each sink are not only edge - disjoint but also node - disjoint , i.e. , the @xmath47 paths from the source to any sink do not have any common node except the source and that particular sink itself .",
    "the general case , where paths are not necessarily node - disjoint , is more difficult and might not be solvable because of the following reason .",
    "consider a network with paths that are not node - disjoint .",
    "because of the formulation specified by ( [ eqn11 ] ) , for any given intermediate node @xmath275 all the priorly processed outgoing edges of @xmath142 should be considered when processing any particular @xmath276 let @xmath277 and suppose @xmath278 suppose the global encoding vector of @xmath83 has been decided before @xmath279 once edge @xmath280 has been processed ( @xmath281 has been decided ) , note that the elements of the set @xmath282 which was used to determine @xmath283 would have been updated according to ( [ eqn15 ] ) .",
    "thereby @xmath103 might no longer satisfy the required properties of maintaining the ranks of the @xmath202 matrices of some @xmath284 now if a new global encoding vector @xmath103 was chosen for edge @xmath104 then the set @xmath285 might change , and @xmath281 might no longer be a valid global encoding vector for @xmath279 because of such a see - saw effect , it might not be possible to design a feasible network code using the uniform delay - and - code scheme .",
    "now suppose the @xmath47 edge - disjoint paths to each sink from @xmath27 are also node - disjoint , i.e. , at any intermediate node in the network , there exists at most one incoming - outgoing edge pair which lies on any path from the source to any particular sink .",
    "therefore , for any @xmath286 being the currently processed edge , any @xmath287 for any @xmath288 is such that @xmath289 in other words , there are no @xmath277 such that @xmath278 thus , fixing the global encoding vector for any @xmath290 does not affect the sets @xmath291 for any other edge @xmath292 for this reason , we focus on networks with node - disjoint paths for the uniform delay - and - code case .",
    "[ prop5 ] let @xmath271 be an acyclic single - source network with multicast demands with at least @xmath47 node - disjoint paths between @xmath27 and any @xmath293 @xmath47 being the number of information sequences generated at @xmath53 let @xmath294 then a feasible network code can be designed for @xmath20 ( or @xmath11 ) using the uniform delay - and - code scheme provided the total number of memory elements present at each node for each incoming edge is at least @xmath295    the following corollary to proposition [ prop5 ] shows that there exist several unit - delay networks for which a binary field is sufficient for constructing a feasible network code , irrespective of the field size required for their instantaneous counterparts .",
    "[ cor4 ] there exist acyclic networks for which a feasible binary network code exists for the unit - delay networks as a result of differently delayed information available at the coding nodes ( where paths to different sinks intersect ) in the network , irrespective of the minimum field size required to design a feasible network code for the corresponding instantaneous networks .",
    "in particular , given a single - source acyclic network @xmath10 with multicast demands and with at least @xmath47 node - disjoint paths ( @xmath47 being the number of information symbols at source ) from the source to each sink , it is always possible to construct a modified network @xmath296 such that @xmath297 has the same minimum field size requirement as @xmath6 but a binary field size would suffice to obtain a feasible network code for @xmath298    although the delay - and - code scheme can be used to construct feasible network codes in the multicast situation , for a network with more general demands , it might not be prove useful .",
    "we now present an example where it is not possible to design a network code using the delay - and - code scheme .",
    "consider the network @xmath10 shown in fig .",
    "[ fig4 ] , with sources @xmath299 and sinks @xmath300 the source @xmath301 generates the information sequence @xmath302 .",
    "the subnetwork of @xmath10 consisting of all nodes and edges of @xmath10 except the nodes @xmath303 and sink @xmath304 is derived from the @xmath305 combination network , i.e. , for every possible three - combination of the nodes @xmath306 there exists a sink to which there is precisely one edge incoming from the three nodes , each of which demands all three of the information sequences .",
    "there are therefore @xmath307 such sinks , and the bolded arrows indicate the ten outgoing edges from each node @xmath308 and the three incoming edges from @xmath309 to each sink @xmath310 each of these @xmath311 sinks demand all three information sequences .",
    "the additional sink @xmath304 demands the information sequence @xmath312 note that there exists a solution to this network ( for both @xmath20 and @xmath11 ) if the field size @xmath313    we now attempt to obtain a delay - and - code scheme on this network ( in either @xmath20 or @xmath11 ) . because each node @xmath314 is only connected to the source @xmath301 for @xmath315 each of the global encoding vectors of the outgoing edges from the nodes @xmath316",
    "has one component of the form @xmath317 @xmath318 being some non - negative integer , with the other two components being zero . also , the three global encoding vectors of the outgoing edges from the nodes @xmath319 have to be linearly independent and of the form @xmath320 because each of these three vectors have to be linearly independent with any two of the three global encoding vectors of the outgoing edges from @xmath321 for @xmath322 let the global encoding vector of node @xmath314 be @xmath323 for some non - negative integers @xmath324 and @xmath325    to satisfy the requirements for sink @xmath326 a delay - and - code based linear combination of the vectors @xmath327 should generate a vector of the form @xmath328 for some non - negative integer @xmath329 in other words , for some non - negative integers @xmath330 and @xmath331 and for some @xmath332 we want @xmath333 note that @xmath334 and @xmath335 can not all be @xmath336 they can not all be @xmath337 as it is not possible to find non - negative integers @xmath330 and @xmath338 such that @xmath339 or such that @xmath340    now , suppose two of @xmath334 and @xmath335 are non - zero , then this means that the global encoding vector of the outgoing edge from node @xmath21 lies in the space spanned by two of the global encoding vectors of the outgoing edges from @xmath341 but this contradicts our original choice of these global encoding vectors , according to which any two are linearly independent with the global encoding vector of the outgoing edge from node @xmath342 therefore , a delay - and - code based scheme can not satisfy the requirements of all sinks in this network , in either @xmath20 or @xmath9",
    "we have discussed the consequences of using the delay inherent in the network in problems related to network code existence and designs .",
    "the delay - and - code algorithms presented in this paper enable low - complexity encoding at the intermediate nodes at the cost of using large memories for decoding at the sinks .",
    "a simple upper bound for the maximum number of memory elements required at any sink to decode the information sequences which are encoded using a delay - and - code scheme can be obtained without much difficulty .",
    "similar algorithms can be found in @xcite .",
    "also , while the equivalence between memory elements and delays might not in practice make sense as the actual value of the delay incurred in the two might not be equal , the parameter @xmath8 used can be equivalently used to express both and therefore corollary [ cor4 ] still holds .",
    "the results obtained in this work indicate that using delays in the network might be beneficial in certain situations , while being not useful in others . in any case",
    ", the delays in the network can not be ignored for analyzing any network coding problem .",
    "subsequent work might include the analysis of random network coding in unit - delay networks and the study of cyclic networks in a similar manner .",
    "this work was supported partly by the drdo - iisc program on advanced research in mathematical engineering through a research grant and partly by the inae chair professorship grant to b.  s.  rajan",
    ".    160    r. ahlswede , n. cai , r. li and r. yeung , `` network information flow '' , ieee transactions on information theory , vol.46 , no.4 , july 2000 , pp . 1204 - 1216 .",
    "n. cai , r. li and r. yeung , `` linear network coding '' , ieee transactions on information theory , vol .",
    "2 , feb . 2003 , pp .",
    "371 - 381 .",
    "r. koetter and m. medard , `` an algebraic approach to network coding '' , ieee / acm transactions on networking , vol .",
    "2003 , pp .",
    "782 - 795 .",
    "s. jaggi , p. sanders , p.a .",
    "chou , m. effros , s. egner , k. jain , and l.m.g.m .",
    "tolhuizen , `` polynomial - time algorithms for multicast network code construction '' , ieee transactions on information theory , vol .",
    "51 , no . 6 , june 2005 , pp.1973 - 1982 .",
    "e. erez and m. feder ,  efficient network codes for cyclic networks  , isit , 4 - 9 sept . 2005 , adelaide , australia , pp .",
    "1982 - 1986 .",
    "a. i. barbero and o. ytrehus , `` cycle - logical treatment for cyclopathic networks '' , ieee transactions on information theory , vol .",
    "6 , june 2006 .",
    "c. fragouli and e. soljanin `` information flow decomposition for network coding '' , ieee transactions on information theory , vol .",
    "3 , march 2006 .",
    "a. lehman and e. lehman , `` complexity classification of network information flow problems '' , soda , 2004 , new orleans , usa , pp .",
    "142 - 150 .",
    "a. tavory , m. feder , and d. ron , `` bounds on linear codes for network multicast '' , technical report tr03 - 033 , electronic colloquium on computational complexity , 2003 .",
    "c. chekuri , c. fragouli , and e. soljanin , `` on average throughput and alphabet size in network coding '' , ieee transactions on information theory , vol .",
    "6 , june 2006 .",
    "a. lehman and e. lehman , `` network coding : does the model need tuning ? '' , soda , 2005 , vancouver , canada , pp .",
    "499 - 504 .",
    "r. dougherty , c. freiling , and k. zeger , `` insufficiency of linear coding in network information flow '' , ieee transactions on information theory , vol .",
    "51 , no . 8 , august 2005 .",
    "x. wu , c. zhao and x. you , `` generation - based network coding over networks with delay '' , ifip international conference on network and parallel computing , shangai , china , oct .",
    "18 - 21 2008 , pp .",
    "365 - 368 .",
    "k. prasad and b. sundar rajan , `` single - generation network coding for networks with delay '' , arxiv:0909.1638v1[cs.it ] , september 2009 , available at : http://arxiv.org/abs/0909.1638 .",
    "k. prasad and b. sundar rajan , `` network error correction for unit - delay , memory - free networks using convolutional codes '' , arxiv:0903.1967v3[cs.it ] , september 2009 , available at : http://arxiv.org/abs/0903.1967 .",
    "a. i. barbero and o. ytrehus , `` an efficient centralized binary multicast network coding algorithm for any cyclic network '' , arxiv:0705.0085v1[cs.it ] , may 2007 , available at http://arxiv.org/abs/0705.0085v1 .",
    "h. lu , `` binary linear network codes '' , ieee itw on information theory for wireless networks , 1 - 6 july 2007 , solstrand , norway .",
    "a. keshavarz - haddad and m.a .",
    "khojastepour , `` rotate - and - add coding : a novel algebraic network coding scheme '' , ieee itw 2010 , aug . 30 - sept .",
    "3 , dublin , ireland .",
    "t. mulders and a. storjohann , `` on lattice reduction for polynomial matrices '' , journal of symbolic computation , vol .",
    "35 , issue 4 , april 2003 , pp .",
    "377 - 401 .",
    "a. borodin and i. munro , `` the computational complexity of algebraic and numeric problems '' , american elsevier pub .",
    "co. , 1975 .",
    "let @xmath343 be the @xmath119 submatrix of the network transfer matrix of any particular sink node @xmath344 in @xmath20 , involving the @xmath65 information symbols to be inverted .",
    "let @xmath120 be the corresponding matrix of the same sink @xmath59 in @xmath9 we first note that the matrix @xmath343 can be obtained from @xmath120 by substituting @xmath345 , i.e. , @xmath346 given that @xmath343 is of full rank over @xmath48 , we prove that @xmath120 is of full rank over @xmath105 by contradiction .",
    "suppose that @xmath120 was not of full rank over @xmath105 , then we have @xmath347 where @xmath348 is the @xmath60 column of @xmath120 and @xmath349 $ ] @xmath350 @xmath351 are such that @xmath352 and @xmath353 for at least one @xmath354 , and @xmath355 we have the following two cases    _ case 1 _ : @xmath356 @xmath357    substituting @xmath358 in ( [ eqn1 ] ) , we have @xmath359 where @xmath360 and @xmath361 is the @xmath60 column of @xmath362    clearly @xmath363 since @xmath343 is of full rank , and hence the left hand side of ( [ eqn3 ] ) can not be zero . therefore , some non - zero linear combination of the first @xmath364 columns of @xmath343 is equal to its @xmath365 column , which contradicts the given statement that @xmath343 is of full rank over @xmath13 therefore , @xmath120 must be of full rank over @xmath95    _ case 2 _ : @xmath366 for at least one @xmath367    let @xmath368 such that @xmath369 for some positive integer @xmath370 let @xmath371 be an integer such that @xmath372 now , from ( [ eqn1 ] ) we have @xmath373 let @xmath374 such that @xmath375 @xmath350 @xmath376 then , we must have that @xmath377 @xmath350 @xmath378 since @xmath379 also , let @xmath380 $ ] @xmath350 @xmath376 hence we have @xmath381 where @xmath382 , since @xmath383 substituting @xmath384 in ( [ eqn2 ] ) , we have @xmath385 i.e. , a non - zero linear combination of the columns of @xmath343 is equal to zero , which contradicts the full - rankness of @xmath343 , thus proving that @xmath120 has to be of full rank over @xmath95 as the choice of the sink @xmath59 was arbitrary , this completes the proof .",
    "let @xmath133 be a set of local encoding coefficients taking values from some field @xmath48 which result in a feasible network code for @xmath11 , satisfying the invertibility and zero - interference conditions , i.e. , @xmath386 and the product of the determinants @xmath387 where @xmath388,$ ] the ring of polynomials in variable @xmath8 over @xmath389,$ ] are the numerator and denominator polynomials corresponding to @xmath390    note that , if we assign some appropriate value in @xmath48 for the parameter @xmath8 in ( [ eqn4 ] ) , we get a well - defined network code for @xmath20 . in other words , if throughout the network , we let @xmath391 such that @xmath392 does not divide any numerator polynomial of @xmath393 corresponding to any pair of edges @xmath83 and @xmath97 then the unit - delay equation @xmath394 reduces to the instantaneous form , without the time index , as @xmath395 where @xmath396 for all pairs of edges @xmath83 and @xmath371 in the network .",
    "the new set of local encoding coefficients , denoted by @xmath397 is a well - defined network code for @xmath20 ( although this might not be feasible ) . using this technique",
    ", we now show that given a feasible network code ( @xmath133 ) for @xmath11 over some field @xmath153 we can obtain a feasible network code for @xmath6 over a possibly larger field @xmath398    given that @xmath399 let @xmath400 be extension of @xmath401 such that @xmath402 as @xmath403 we can view the coefficients @xmath133 to be elements of @xmath404 which we shall now refer to as @xmath405 we now choose some @xmath406 such that @xmath407 and @xmath408 such a choice is possible because the polynomial @xmath409 can have at most @xmath410 zeros in @xmath411 therefore , with @xmath412 we have a well - defined network code for @xmath20 with @xmath413 satisfying the invertibility condition in @xmath20 .",
    "let the set of local encoding coefficients obtained for @xmath20 by assuming @xmath414 be @xmath415    as for the zero - interference conditions , @xmath416 all being zero polynomials implies that any choice of @xmath8 does not alter their value",
    ". therefore the network code defined by @xmath417 is a feasible network code for @xmath136 this completes the proof .      consider a feasible network coding solution from @xmath149 for @xmath9 because of the conditions on the topology of the network , the columns of the @xmath112 ( following the notations in section [ sec2 ] ) network transfer matrix @xmath121 of a sink @xmath344 are of the form @xmath433 where @xmath434 is the @xmath60 column of @xmath113 @xmath435 and @xmath436 we also have @xmath437 the network transfer matrix of the sink @xmath59 in @xmath6 the @xmath60 column of which is @xmath438 let @xmath120 be the @xmath439 submatrix of @xmath113 involving those rows ( say , those indexed by @xmath440 ) of @xmath121 which correspond to the information sequences that need to be inverted at @xmath68 and let @xmath343 be the corresponding matrix for @xmath12 because of ( [ eqn6 ] ) , the determinant of @xmath120 is of the form @xmath441 thus , if @xmath442 then @xmath443 which means @xmath343 is invertible . also , any zero element of @xmath121 is also zero in @xmath444 as the choice of the sink @xmath59 was arbitrary , both the invertibility and the zero - interference conditions are satisfied for all sinks in @xmath6 thus proving claim ( 1 ) .",
    "we now prove claim ( 2 ) .",
    "suppose there is a feasible solution in place for @xmath12 because of the condition on the network topology , the network transfer matrices in @xmath11 is of the form ( [ eqn6 ] ) .",
    "then , by ( [ eqn8 ] ) the corresponding invertible @xmath119 submatrix @xmath120 of the network transfer matrix @xmath121 of sink @xmath59 in @xmath11 with the same local encoding coefficients as @xmath20 has a non - zero determinant and is thus full - rank",
    ". thus the invertibility conditions for sink @xmath59 are carried over to @xmath9 to prove the zero - interference conditions , suppose @xmath445 is the element @xmath446 of @xmath217 which is zero .",
    "then the corresponding element of @xmath113 @xmath447 is such that @xmath448 or @xmath449 with @xmath450 ( as @xmath451 ) .",
    "however , because of ( [ eqn6 ] ) , @xmath452 which means that @xmath453 thus @xmath454 the zero - interference conditions are also satisfied for @xmath59 in @xmath9 again , as the choice of sink @xmath59 was arbitrary , any solution for @xmath20 is also a solution for @xmath9    to prove claim ( 3 ) , we first note that , by claim ( 2 ) , the minimum field size requirement for a feasible solution for @xmath11 is not larger than that of @xmath12 also , by claim ( 1 ) , any solution for @xmath11 from any non - empty @xmath150 is feasible for @xmath6 which holds for @xmath455 too .",
    "this fact along with claim ( 2 ) proves claim ( 3 ) .      throughout this proof , we assume that the network we are working with is @xmath457 the subnetwork of @xmath5 consisting only of the nodes and edges on the @xmath47 edge - disjoint paths from the source @xmath27 to each sink @xmath64 . just as lemma [ lemma2 ] together with lemma [ lemma1 ]",
    "justifies the maintenance of the rank of the matrices @xmath458 in every step of the lif algorithm , we prove this proposition by showing a variant of lemma [ lemma2 ] which will maintain the rank of the matrices @xmath458 according to the delay - and - code schemes .",
    "let @xmath83 be the edge whose global encoding vector is to be decided in the current step of the non - uniform delay - and - code lif algorithm , and let @xmath459 .",
    "we have sets of ordered pairs ( elements from @xmath460 ) as in lemma [ lemma2 ] , @xmath461 such that @xmath462 @xmath463 being the cardinality of the set in the rhs .",
    "we seek to iteratively construct the vectors @xmath243 ( each @xmath464 ) such that the following conditions hold for each @xmath465 .",
    "if such vectors can be found , then we fix @xmath468 as the global encoding vector of @xmath83 as it can be seen using lemma [ lemma1 ] that such a choice preserves the necessary requirements for the current step of the non - uniform delay - and - code lif algorithm .",
    "the vectors @xmath243 are constructed as follows .",
    "let @xmath469 where @xmath470 and @xmath471 as we need @xmath472 now suppose for some @xmath473 we have @xmath246 such that @xmath474 then we will show that we can get @xmath475 such that @xmath476 as long as the total number of memory elements present at each node for each incoming edge is at least @xmath274    suppose @xmath477 then we choose @xmath478 which then satisfies our requirements .",
    "else , we choose @xmath479 again , we have @xmath480 and @xmath481 as we want @xmath482 .",
    "@xmath483 is the number of memory elements used to delay the symbols on that particular incoming edge .",
    "thus @xmath484    now suppose for some choice of @xmath485 and for some @xmath486 we have @xmath487 i.e. , @xmath488 then @xmath489 is not a valid choice for @xmath490 as ( [ eqn13 ] ) should not hold for any @xmath491 note that there are at most @xmath354 choices for @xmath248 at which ( [ eqn13 ] ) will hold .",
    "there are therefore at most @xmath354 choices for @xmath492 that can not be used . as @xmath493",
    "if we have at least @xmath463 choices for @xmath490 then we can always choose one value such that ( [ eqn13 ] ) does not hold for any @xmath494 for any given @xmath495 with @xmath496 memory elements for each incoming edge at node @xmath275 we have @xmath190 choices for any particular @xmath497 this , coupled with lemma [ lemma1 ] and the fact that @xmath498 ensures that a non - uniform delay - and - code scheme can be constructed for the given multicast problem .",
    "as in proposition [ prop4 ] , we prove the proposition using a variant of the proof for lemma [ lemma2 ] .",
    "we again assume that the network we are working with is @xmath457 the subnetwork of @xmath5 consisting only of the nodes and edges on the @xmath47 edge - disjoint paths from the source @xmath27 to each sink @xmath64 .",
    "we follow an ancestral ordering which enables us to process all outgoing edges of a particular intermediate node before moving to the next . as the uniform delay - and - code technique",
    "is defined only for the intermediate nodes , we use the non - uniform delay - and - code technique at the source node to preserve the ranks of the matrices @xmath202 for each sink @xmath68 until all the edges in @xmath499 have been processed .    now for the intermediate nodes .",
    "let @xmath142 be the intermediate node whose outgoing edges are to be processed together .",
    "as in the proof of proposition [ prop4 ] , for each @xmath500 we have the set @xmath291 as defined in ( [ eqn14 ] ) , and we seek to iteratively construct @xmath501 such that conditions @xmath502 and @xmath456 ( as in the proof of proposition [ prop4 ] ) are satisfied . also , ( [ eqn11 ] ) needs to be satisfied because we seek to design a uniform delay - and - code .    in the process of choosing each @xmath246 for any particular @xmath503 the local encoding coefficient @xmath102 and the delay @xmath504 ( @xmath102 and @xmath504 are as in ( [ eqn10 ] ) ) corresponding to @xmath83 and",
    "some @xmath505 has to be chosen .",
    "based on the arguments developed in the proof of proposition [ prop4 ] , the choices for @xmath102 and @xmath504 are restricted . for any particular @xmath506 and for any edge @xmath507 for which @xmath508 it was shown that there are at most @xmath496 choices that are not allowed for @xmath504 in the non - uniform delay - and - code case .    for the uniform delay - and - code case , we need @xmath509 such that @xmath510 thus the number of choices of @xmath511 that can not be allowed for any edge @xmath506 is at most @xmath512 in the case of @xmath513 if @xmath514 for any @xmath503 this number of disallowed choices for @xmath504 can only reduce .",
    "therefore if every node in the given network has @xmath515 memory elements for each incoming edge , then there exists at least one choice for @xmath511 such that the conditions on the invertibility of the @xmath202 matrices ( again by invoking lemma [ lemma1 ] ) and the uniformity of the delay - and - code scheme given by ( [ eqn11 ] ) are satisfied .",
    "note that the proof hinges on the fact that the network has node - disjoint paths , as we have seen in subsection [ delayandcode ] , that a feasible uniform delay - and - code scheme might not be possible to design in a general network with only edge - disjoint paths .",
    "this concludes the proof .",
    "suppose there are no feasible network codes for @xmath6 but there is a feasible network code for @xmath9 however , by proposition [ prop2 ] , this means that there is indeed a feasible network code for @xmath6 giving a contradiction",
    ". therefore there can be no feasible network codes for @xmath11 either .",
    "let @xmath133 be a set of local encoding coefficients taking values from some field @xmath48 which result in a feasible network code for @xmath11 , satisfying the invertibility and zero - interference conditions .",
    "let the resulting network transfer matrix of any particular sink @xmath64 in @xmath11 be @xmath121 and let @xmath120 be the @xmath119 submatrix of @xmath121 which involves those rows of @xmath121 that correspond to the information sequences to be obtained by sink @xmath114 although @xmath120 involves rational functions in @xmath262 the denominators can be factored out to obtain a matrix of the form @xmath418 where @xmath419 $ ] and @xmath420 is a matrix consisting of bounded - degree polynomials in @xmath263 it is known ( see @xcite , for example ) that the determinant of a polynomial matrix of size @xmath421 and degree at @xmath422 can be calculated with complexity @xmath423 the determinant of @xmath120 can thus be calculated with polynomial complexity .",
    "thus , following the notations from the proof of proposition [ prop2 ] , it is therefore clear that the product @xmath424 of the determinants of all the sinks can also be calculated in polynomial - time .",
    "the next step in the construction of a feasible network code for @xmath20 according to the proof of proposition [ prop2 ] is to pick a value @xmath425 from a large enough field @xmath400 so that @xmath426 finding such a @xmath425 involves at most @xmath410 evaluations of the polynomial @xmath427 such polynomial evaluations can be performed with complexity linear in the degree of the polynomial concerned ( see @xcite , for example ) .",
    "therefore , identifying an appropriate @xmath428 takes @xmath429 operations over the field concerned .",
    "once such a @xmath425 has been identified , the local encoding coefficients @xmath417 for @xmath20 can be obtained can be obtained by evaluating the local encoding coefficients @xmath430 of @xmath11 at @xmath431 all the elements of @xmath430 are rational functions and there are at most @xmath432 of them , thus the total complexity involved in these evaluations is also polynomial .",
    "once these evaluations have been obtained , we have a feasible network code for @xmath12 the complexity of obtaining such a feasible network code for @xmath20 at each step has been polynomial including that of the obtaining a feasible network code for @xmath7 as assumed .",
    "this proves the corollary .",
    "suppose there exists a feasible solution for @xmath20 over some field @xmath153 but no feasible solutions for @xmath11 over the same field .",
    "however , by claim @xmath456 of proposition [ prop3 ] , any feasible solution for @xmath20 is a feasible solution for @xmath9 this contradicts our original assumption and therefore proves the corollary .",
    "proposition [ prop5 ] shows that a feasible network code based on the uniform delay - and - code scheme can be constructed for a multicast situation on networks with node - disjoint paths .",
    "note that given such a network , all that the uniform delay - and - code scheme effectively does is introduce different delays on the incoming edges . because of the uniformity of the delay - and - code scheme , i.e. , the formulation given by ( [ eqn11 ] ) , the @xmath516 memory elements used for each edge @xmath505 at some intermediate node @xmath142 can be viewed as @xmath516 additional delays on edge @xmath97 or equivalently as additional forwarding nodes with @xmath511 forwarding edges . in other words , given an acyclic network @xmath5 with multicast demands and node - disjoint paths , and a feasible uniform delay - and - code scheme was obtained for the unit delay network @xmath11",
    ". then the unit - delay network @xmath11 along with the uniform delay - and - code network code naturally invokes the unit - delay network @xmath517 on which there exists a feasible network code over @xmath162 by using the equivalence between the memory elements and delays ."
  ],
  "abstract_text": [
    "<S> problems related to network coding for acyclic , instantaneous networks ( where the edges of the acyclic graph representing the network are assumed to have zero - delay ) have been extensively dealt with in the recent past . </S>",
    "<S> the most prominent of these problems include @xmath0 the existence of network codes that achieve maximum rate of transmission , @xmath1 efficient network code constructions , and @xmath2 field size issues . in practice </S>",
    "<S> , however , networks have transmission delays . in network coding theory , </S>",
    "<S> such networks with transmission delays are generally abstracted by assuming that their edges have integer delays . using enough memory at the nodes of an acyclic network with integer delays </S>",
    "<S> can effectively simulate instantaneous behavior , which is probably why only acyclic instantaneous networks have been primarily focused on thus far . </S>",
    "<S> however , nulling the effect of the network delays are not always uniformly advantageous , as we will show in this work . </S>",
    "<S> essentially , we elaborate on issues ( @xmath3 and @xmath2 above ) related to network coding for acyclic networks with integer delays , and show that using the delay network as is ( without adding memory ) turns out to be advantageous , disadvantageous or immaterial , depending on the topology of the network and the problem considered i.e. , @xmath3 or @xmath4 in the process , we also show that for a single source multicast problem in acyclic networks ( instantaneous and with delays ) , the network coding operations at each node can simply be limited to storing old symbols and coding them over a binary field . </S>",
    "<S> therefore , operations over elements of larger fields are unnecessary in the network , the trade - off being that enough memory exists at the nodes and at the sinks , and that the sinks have more processing power . </S>"
  ]
}