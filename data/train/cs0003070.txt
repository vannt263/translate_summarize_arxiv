{
  "article_text": [
    "the possibility of translating logic programs into functional ones has long been a subject of investigation . among the different proposals @xcite .",
    "such systems are usually devised for one of the following purposes : for proving program properties , for providing better insight on the relation between functional and logic languages , or  to a minor extent  for improving program performance .",
    "common to all the approaches mentioned is that the original logic program , in order to be translated , needs to be _ well - moded _ and this has led to the common understanding that these programs can be considered to be the `` functional part '' of logic programs .",
    "this is confirmed by the following statement in @xcite : `` @xmath0 the class of functionally moded ( well - moded and simply moded ) programs can be rightly considered _ the _ functional core of logic programs '' .",
    "well - moded programs have , among other features , a straightforward left - to - right dataflow model ( see @xcite ) and prohibit the use of _ logical variables _ to their full potential such as in complex logical data structures like difference - lists . as a consequence of this",
    "it is now widely accepted that `` complex '' logical variables , the possibility of a dynamic selection rule , and general properties of non - well - moded programs are exclusive features of logic programs .",
    "this is not quite right .",
    "at least , not to the extent that one is brought to think .    in this paper",
    "we show , among other things , that logical structures such as difference lists have a natural counterpart in _ lazy _ functional programs ; i.e. that most programs using difference - lists are functional in nature .",
    "this shows immediately that many common non - well - moded programs are functional in nature and that well - modedness is thus not a necessary attribute of those logic programs behaving functionally .",
    "we do this by employing a straightforward  literal  translation of moded logic programs into haskell , a lazy functional language .",
    "furthermore , we use the same translation system to show that some programs requiring a dynamic scheduling mechanism are also intrinsically functional .    summarizing , in this paper we readdress the old question of what features are exclusive to the logic programming paradigm and demonstrate that the current circumscription is unreasonably restrictive .",
    "due to space constraints we omit preliminaries and assume that the reader is acquainted with the terminology and the main results of logic programming theory ( see @xcite ) . in this paper",
    "we use over - lined characters to indicate ( a possibly empty ) sequence of objects , so @xmath1 can denote a sequence @xmath2 of terms , @xmath3 a sequence of variables and @xmath4 a sequence of atoms ( i.e.  a query ) . to avoid confusion with built - in symbols , we use @xmath5 to indicate syntactic equivalence .    in what follows",
    "we study logic programs executed by means of the _ ld - resolution _ , which consists of the sld - resolution combined with the leftmost selection rule .",
    "an sld - derivation in which the leftmost selection rule is used is called an _",
    "ld - derivation_.      this section is partially borrowed from @xcite , we refer to the appendix and to @xcite for further information over well - moded logic programs .",
    "[ def : mode ] consider an @xmath6-ary relation symbol @xmath7 . by a _ mode _ for @xmath7 we mean a function @xmath8 from @xmath9 to the set @xmath10 . if @xmath11 , we call @xmath12 an _ input position _ of @xmath13 and if @xmath14 , we call @xmath12 an _ output position _ of @xmath7 ( both w.r.t",
    ". @xmath8 ) .",
    "an @xmath6-ary relation @xmath15 with a mode @xmath8 will be denoted by @xmath16 for example , for programs ` member ` and ` append ` we typically have the following listings and modes :    mode member(in , in ) .",
    "+ member(el , [ el| _ ] ) .",
    "+ member(el , [ _ |rest ] ) @xmath17member(el , rest ) .",
    "+ mode append(in , in , out ) .",
    "+ append ( [ ] , _ , [ ] ) .",
    "+ append([h|tail ] , list , [ h|tail ] ) @xmath17append(tail , list , tail ) .",
    "modes indicate how the arguments of a relation should be used .",
    "we assume that to each relation symbol is associated a unique mode .",
    "multiple modes can be obtained by simply renaming the relations .    in presence of modes",
    ", we require the programs and the queries to be somehow naturally _ consistent _ wrt them . before we introduce the notion of consistency we have to provide some further notation .",
    "when writing an atom as @xmath18 we now assume that @xmath19 is a sequence of terms filling in the input positions of @xmath7 and @xmath20 is a sequence of terms filling in the output positions .",
    "thus , for notational simplicity , we assume that the input positions come first .    let us call _ producing _ the input position of the head and the output positions of the body atoms , and _ consuming _ the other positions of a clause , we have the following definition    a clause ( query ) is _ consistent _ iff every variable occurs in at least one producing position .",
    "the last lp notion we need is the one of _ plain _ program . here and in the sequel , a set of terms",
    "is called _ linear _ if every variable occurs at most once in it . in other words ,",
    "a sat of terms is linear iff no variable has two distinct occurrences in any of the terms and no two terms have a variable in common .",
    "[ def : plain ] a clause @xmath21 is called _ plain _ if    1 .",
    "@xmath22 is a linear family of variables ; 2 .",
    "@xmath23 is linear .",
    "a query @xmath24 is called _ plain _ iff the clause @xmath25 is , where ` q ` is any ( dummy ) atom of zero arity .",
    "a program is called _ plain _ if every clause of it is .",
    "thus a plain program is a program in which producing positions are filled in by variables and in which a variable occurs in at most one producing position .    condition ( i ) is similar to , though less restrictive , than the one of simply moded programs as defined in  @xcite ( as we do not impose an ordering constraint ) .",
    "our translation requires programs to be consistent and plain .",
    "this is far less restrictive than well - modedness plus simple - modedness , and as we shall see allows us to capture a broader segment of functional behaviour found in logic programs .",
    "indeed , it is now perhaps _ too _ lenient , but suffices for the goals of this paper to broaden the characterization of logic programs .",
    "regarding the ( non ) restrictiveness of the concepts of plain and consistent programs , we have the following :    [ rem : sm ] it is important to realize that most programs are plain , and that non plain programs can naturally be transformed into equivalent plain ones , virtually all consistent programs are either plain or safely translatable into a plain form .",
    "this is also practically demonstrated by the fact that the language mercury employs a pre - processing phase in which all programs are translated into a _ superheterogeneous _",
    "form ( which is very similar to the form of plain programs ) . concerning ( ii ) , we can always transform a consistent program @xmath26 into an equivalent consistent program @xmath27 which satisfies it .",
    "for instance , for the member program defined above , we can transform its first clause into member(el , [ head|rest ] ) @xmath17el = = head .",
    "it is also worth noticing that append is already input - linear .      our translation system maps logic programs into lazy functional programs , which are written in ( a subset of ) haskell  @xcite .",
    "the subset we use includes the proposed extension of _ pattern guards _",
    "@xcite , which we describe below .",
    "the programs we are going to generate are built as sets of _ equations _ , each of the following form :    f s@xmath28 @xmath0 s@xmath29 @xmath30 guard@xmath31 , @xmath0 , guard@xmath32 = result@xmath28 + @xmath33 + @xmath30 guard@xmath34 , @xmath0 , guard@xmath35 = result@xmath34 + @xmath30 otherwise = result@xmath36    where is a function symbol , are _ parameters _ and @xmath37 are _ guard qualifiers_. the ` @xmath30 ' introduces a guard , and the ` @xmath38 ' acts as a logical conjunctive .",
    "pattern matching may take place on the parameters . without pattern guards ,",
    "the guard qualifiers would have to be boolean expressions ; that is , we would only return @xmath39 if the associated guards @xmath40 all evaluate to true .",
    "the semantics of haskell dictates that definitions and guards are tried in sequential order .",
    "the situation with pattern guards is somewhat different .",
    "in fact , _ patterns guards _ can also contain _ let - expressions _ ( which are defined as usual ) and _ pattern - matching expressions _ which are expressions of the form , and whose semantics is the following : if matches with then the variables in are appropriately instantiated , and the pattern - matching guard returns true , otherwise it return false .",
    "consider :    f z @xmath30 let x = g z + @xmath38 [ y ] @xmath17x + @xmath38 y @xmath41 10 = ( true,1 ) + @xmath30 otherwise = ( false,0 )    here , the tuple will only be returned if the two qualifiers in the first guard succeed .",
    "that is , 1 ) the argument can be pattern matched to a list of one element ( denoted by , which also binds to this element ) , and 2 ) the boolean condition is true . in all this ,",
    "the value of @xmath42 is determined by @xmath43 .",
    "if any of these fail , then the second guard is tried . in this case , the special guard will be tried , which always succeeds",
    ". a qualifier can also be introduce recursive bindings ; this will become clear in the sequel .",
    "a more detailed example is presented in appendix [ app : more ] .",
    "as explained below , we need to capture the fact that a predicate might succeed ( possibly returning a computed answer substitution ) , or fail .",
    "to do so , we introduce a new datatype @xmath44 in our haskell programs by :    data result @xmath45 = suc @xmath45 @xmath30 fail    that is , the datatype @xmath44 has two constructors , @xmath46 and @xmath47 , the latter of which can be applied to some term .",
    "note that the haskell programs which we generate are not the obvious programs that a functional programmer would write  this is not the intention .",
    "they do , however , do what the logic programmer intended .",
    "all of the programs given in this paper can be compiled by any haskell compiler supporting pattern guards .",
    "we also want to mention that despite the fact that pattern guards are an important feature of our translation , we could do without them  at the price of less elegant translation .",
    "a haskell compiler will usually regard these as syntactic sugar anyway , and compile them into more basic primitives already found in haskell .",
    "this implies that all the statements we are going to give in the sequel are true regardless of the availability of a pattern guard construct in the target language .",
    "in logic programming , queries can succeed , loop or fail .",
    "this third possibility is of crucial importance , since it is often used as a control mechanism . as an example",
    ", one can consider the following programming scheme :    p(x ) @xmath17generate(x ) , test(x ) .",
    "where ` test ` verifies that the value produced by ` generate ` is appropriate , and failure and backtracking take care of the ill - formed terms .",
    "another common scheme is the following one :    p(x ) @xmath17test_a , x = 1 .",
    "+ p(x ) @xmath17test_b , x = 2 .    where @xmath48 and @xmath49 model a typical ` case ` statement , and the selection of the right branch is done via the failure and backtracking mechanism .",
    "nevertheless , relations which are `` not supposed to fail '' are quite common in logic programming .",
    "we say that a relation is `` not supposed to fail '' if  when called in a `` correct '' way  produces at least one answer .",
    "examples of such relations are ` sort ` , ` flatten ` and ` append ` , ( this latter , for calls of the form @xmath50 , where @xmath51 and @xmath52 are lists , and @xmath53 is a new variable will always produce one answer ) .    the ubiquity of predicates which are not supposed to fail is confirmed by the fact that mercury requires the programmer to specify for each relation symbol , whether it might fail or not .",
    "this information is then used to generate optimized code .",
    "we do the same thing for our translation , and from now on we assume that the set of predicate symbols is partitioned into two disjoint sets , namely    non - test : :    predicates , which , when called , are expected to produce at least one    answer ( such as append ) , and test : :    predicates , which when called are allowed to report no answer , i.e. ,    to fail immediately or succeed ( such as member and    @xmath54 ) .",
    "thus , we have the following definition .",
    "[ def : partitioning ] a _ partitioning _ is a map from the set of predicate symbols into the set @xmath55 .",
    "let @xmath26 be a program and @xmath56  be a set of queries , we say that @xmath26 is _ correct _ wrt .",
    "@xmath56  iff for every @xmath57 every , time that a non - test atom @xmath58 is selected in a ld - derivation of @xmath4 in @xmath26 then @xmath58 has at least one successful ld - derivation .",
    "thus every program is correct wrt .",
    "the trivial partitioning in which all predicates are _",
    "test_. checking correctness is orthogonal to the purposes of this paper , but we should mention that it can be done either using abstract interpretation @xcite or on modes and types @xcite ; also mercury employs a system based on modes and types in order to check that the programs are consistent ( modulo non - termination ) wrt .",
    "the partitioning provided by the programmer .",
    "the partition into test and non - test predicates exposes the implicit failure mechanism present in logic programs .",
    "our translation will transform non - test predicates as ordinary functions , but transform test predicates by returning something of the type , allowing us to indicate failure .",
    "essentially if a function fails in the logic programming sense , then a value of @xmath59 will be returned .",
    "each `` value '' returned from a test predicate is only every used in a function if it is successfully matched against @xmath60 indicating that no failure occurred(it was not @xmath59 ) .",
    "the combination of plain programs with a partition makes it easy to identify the logic programs that can be mapped to functions , and which functions to enhance by mimicking the implicit failure mechanism .",
    "now , let @xmath7 be a predicate symbol with mode @xmath61 then @xmath7 can naturally be translated into a function of type @xmath62 where @xmath63 and @xmath64 are appropriate haskell types . here",
    "we will not bother further with the type that the translated predicate has : the haskell compiler will be able to infer it autonomously ; what it is important to see is that the haskell counterpart of ` p ` is a function which maps a tuple with @xmath12 elements into a tuple containing @xmath65 elements , possibly embedded in the @xmath66 datatype depending on whether ` p ` is a non - test predicate or not .",
    "we shall employ the value @xmath46 to denote the functional counterpart of failure , where @xmath67 looks like an empty tuple but which is in actual fact the only element in the unit type . ] .",
    "our translation method requires the program to be translated to be _ consistent _ and _ plain_. of these conditions , _ consistency _ is the only crucial one , in fact as stated in remark [ rem : sm ] it is ( virtually ) always possible to transform a consistent program into an equivalent program which is plain ; moreover , most programs are plain already .",
    "now , we can transform the logic program into a haskell one via a simple syntactic transformation .",
    "first , we have to translate variables , terms and predicate symbols ; this is done in a straightforward way : one just has to respect the syntactic conventions of the two languages ( uppercase and lowercases , and built - in predicates ) .",
    "of course , predicate symbols are transformed into non - constructor function symbols . in the sequel we use sans - serif characters for haskell constructs and typewriter font for logic programming ones , for instance ,",
    "@xmath68 denote the haskell counterpart of the lp terms @xmath69 .",
    "[ def : translation ] let @xmath70 be a logic program , and + @xmath71 + be the set of clauses of @xmath70 defining predicate ` p ` , where the predicates @xmath72 are test predicates and the predicates @xmath73 are the non - test ones .",
    "here we assume that the clauses had been renamed apart , i.e. , that they share no variables .",
    "* if @xmath7 is a _",
    "predicate , then the _ translation _ of the above section into haskell is the following script ( for the moment the underlined parts have to be treated as if the underline was nt there ) : + pro1pro1pro1pro1pro1= p ( @xmath74 ) @xmath30 ( t@xmath28 ) @xmath17(x ) , + suc ( o@xmath31 ) @xmath17p@xmath31(i@xmath31 ) , + @xmath33 + suc(o@xmath75 ) @xmath17p@xmath75(i@xmath75 ) , + let ( v@xmath31 ) = q@xmath31(u@xmath31 ) , + @xmath33 + let ( v@xmath76 ) = q@xmath76(u@xmath76 )   = + = ( s@xmath28 ) + @xmath30 ( t@xmath77 ) @xmath17(x ) , + @xmath33 + = ( s@xmath77 ) + @xmath33 + + if one of the clauses of the above section is a unit clause , ( i.e.   @xmath78 ) or if its body contains no test predicates then the corresponding line has the trivial guard .",
    "+ note that sequences may be empty , so if the predicate had no output positions , then @xmath79 would be the term @xmath80 . * if @xmath7 is a _ non - test _ predicate , then translation of the above section corresponds to the above script _ after removal _ of the underlined parts ; namely we have to eliminate from it the otherwise statement and the s from the return values .    clearly ,",
    "list constructions and built - in predicates need to be handled separately , in particular , a test predicate of the form @xmath81 will be transformed to the term which returns either @xmath82 on success and @xmath46 on failure .",
    "we will abuse the notation and also call this function @xmath83 .",
    "[ exa : append ] let us now consider the program append .",
    "it is already plain , so , assuming ` append ` to be non - test predicate , its translation is :    append ( x1,x2 ) @xmath30 ( [  ] , list ) @xmath17(x1 , x2 ) + = list + @xmath30 ( ( x : xs ) , list ) @xmath17(x1 , x2 ) + @xmath38 let tail = append ( xs , list ) + = x : tail    notice that nothing prohibits us from declaring ` append ` as a _ test _ predicate , if we do so we , the result of the translation is :    append ( x1,x2 ) @xmath30 ( [  ] , list ) @xmath17(x1 , x2 ) + = suc list + @xmath30 ( ( x : xs ) , list ) @xmath17(x1 , x2 ) + @xmath38 suc tail @xmath17append ( xs , list ) + = suc ( x : tail ) + @xmath30 otherwise  = fail    in practice , the first program is more efficient than the second one ( though , this can differ per compiler ) , and it is more lazy than the second one .",
    "this is further explained in the following _",
    "[ rem : strictness ] the adopted partitioning has a natural influence on the strictness of the resulting haskell code . consider the differences in the above translations of : if is declared as non - test then its translation will contain a let - expression in the guard    while if it is declared as test then , in its place , we will find the guard    now , while ( 1 ) is a let expression whose bound expression will only be invoked if ( and to the extent that ) the value of is demanded , the second is a guard , which has to be satisfied in order for the function it appears in to return a value . indeed , in ( 2 ) the term will always be reduced until it is completely computed , i.e.  until it either reaches either `` success '' or `` failure '' . in this sense ( 2 ) is strict , while ( 1 ) is lazy .",
    "this behaviour is quite natural if one considers the following : since test atoms might fail , we can not trust their partial answers until we have computed whether they ll succeed or not .",
    "this implies that they always have to be fully `` computed '' , therefore forcing a strict computation . on the other hand non - test predicates",
    "are guaranteed to eventually succeed , so their computation might be stopped at the moment that we have reached a partial result which is `` sufficient for our purposes '' .",
    "therefore the non - test predicates naturally fit the lazy model of computation .",
    "we are at last in a position to demonstrate our thesis that the set of logic programs considered as functional needs to be expanded . as issues ,",
    "we consider logic variables , dynamic scheduling and backtracking in turn .",
    "the dynamics of some of the programs we are going to present in this section is unavoidably rather complex , we apologize for the inconvenience and ask the reader to resort to patience and understanding .",
    "_ logical variables _ are one of the peculiarities of logic programming .",
    "most of the time , they are used in a standard way , that is just as variables in an imperative language  this is the case for instance when the program is well - moded .",
    "nevertheless there are many important situations in which logical variables are exploited in all their power .",
    "a typical such case is in the presence of _ difference structures _ such as _ difference lists_. here we show that even when used in a truly `` logical '' way , logical variables are in many cases not an exclusive feature of logic programs .",
    "the following polish flag problem example ( incidentally , a simplified version of dijkstra s dutch flag problem ) , reads as follows : given a list of objects which are either red or white , rearrange it in such a way that the red elements appear first and the white ones appear after them .",
    "the following program is inspired by @xcite , we have replaced `` @xmath84 '' by `` , '' , thus splitting a position filled in by a difference - list into two positions . because of this change in some relations , additional arguments are introduced .",
    "polish(inlist , redwhites ) @xmath17 + distribute(inlist , redwhites , whites , whites , [ ] ) .",
    "+ distribute ( [ ] , reds , reds , whites , whites ) .",
    "+ distribute([x|xs ] , [ x|reds0 ] , reds , whites0 , whites ) @xmath17red(x ) , + distribute(xs , reds0 , reds , whites0 , whites ) .",
    "+ distribute([x|xs ] , reds0 , reds , [ x|whites0 ] , whites ) @xmath17white(x ) , + distribute(xs , reds0 , reds , whites0 , whites ) .",
    "+ mode polish(in , out ) : non - test .",
    "+ mode distribute(in , out , in , out , in ) : non - test .",
    "where we assume that predicates red and white are appropriately defined elsewhere in the program and have mode ` red(in ) : test ` .",
    "this program is plain and consistent , and by translating it we obtain    polish inlist @xmath30 t @xmath17inlist , + let ( redwhites , whites ) = distribute(t , whites , [  ] ) + = redwhites + distribute(is , rstail , wstail ) @xmath30 ( [  ] , rs , ws ) @xmath17(is , rstail , wstail ) + = ( rs , ws ) + @xmath30 ( x : xs , rs , ws ) @xmath17(is , rstail , wstail ) + , let ( rshead , wshead ) = distribute(xs , rs , ws ) + , suc ( ) @xmath17red x + = ( x : rshead , wshead ) + @xmath30 ( x : xs , rs , ws ) @xmath17(is , rstail , wstail ) + , let ( rshead , wshead ) = distribute(xs , rs , ws ) + , suc ( ) @xmath17white x + = ( rshead , x : wshead ) +    where and are again defined elsewhere in the program .",
    "this program runs perfectly well .",
    "notice that the definition of employs a _",
    "circular data structure _ : in fact the variable appears both on the left hand side and on the right hand side of the expression @xmath85)$ ] , in the guard .",
    "circular data structures were first advocated by bird @xcite in order to avoid multiple traversal of data structures , and since then have become a standard tool of _ lazy _ functional languages .",
    "it is worth remarking that the above program ( and most other programs employing circular structures ) would not function properly if we had used a _",
    "strict _ functional language .",
    "it is important to notice that the original logic program employs logical variables in a highly non - trivial way .",
    "this is confirmed by the fact that the program is not well - moded .",
    "the fact that a program using difference - lists actually presents a functional behaviour is not incidental .",
    "consider an atom containing a difference - list @xmath86 ( for the sake of simplicity , we assume that it does not have any other argument ) , as above , we split this position in two , and obtain @xmath87 .",
    "now , the whole idea of having difference lists , is that when a computation starting in ( an instance of ) @xmath87 will succeed , it will report a computed answer substitution ( c.a.s . )",
    "@xmath88 such that @xmath89 is ( `` points to '' ) the tail of @xmath90 .",
    "this implies that for all @xmath91 if @xmath92 is ground , then @xmath93 is ground as well . typically , after @xmath86 has succeeded with c.a.s .",
    "@xmath88 , @xmath89 will eventually be unified with a ground ( classical ) list ( or with the head of another difference - list , in which case the reasoning continues by considering the tail of this second difference - structure ) .",
    "after this unification has taken place , @xmath90 is going to be a classical list , which can be employed as normal . in this sense",
    "we have that @xmath94 depends on @xmath95 , therefore @xmath94 has to be considered output and @xmath95 input , and the above atom should be translated into ; the only problem is that @xmath95 is an input in disguise , in the sense that when @xmath96 is called , @xmath95 is typically not ( yet ) ground ( in other words , it is not yet known ) .",
    "however , this is hardly a problem when we consider _ lazy _ functional languages ( at the same time , it is the reason why programs with difference lists can not be easily translated into a strict functional language ) .",
    "one could argue that the above reasoning could be completely reversed , starting by saying that `` @xmath0 for all @xmath91 if @xmath97 is ground , then @xmath92 is ground as well , @xmath0 , thus if @xmath90 is unified to a ground list , then @xmath98 will become a ground list , and this shows that @xmath95 depends on @xmath94 , and that therefore the above atom should be translated into '' ( which would fail to function ) .",
    "this is in principle true ( dependencies in lp are always bidirectional ) , however , this property is never used , indeed it can not be used in practice for the following simple reason : after succeeding with c.a.s .",
    "@xmath88 , we typically have that @xmath99 $ ] and that @xmath100 . now , while it is always possible to unify @xmath89 with any ground list @xmath101 , trying to do this with @xmath90 will almost certainly lead to failure ( unless @xmath102 $ ] is a prefix of @xmath103 ) .",
    "therefore difference - lists are virtually always employed in a _ directional _ fashion .",
    "another example of a program using logical variables which can be safely translated into haskell is given in the following section .",
    "of course , one can find an example of a program using difference - lists which would not work in haskell ; actually , counterexamples are extremely easy to contrive : variables in lp are always adirectional , and if one fully exploits this will always obtain a program which has no functioning functional counterpart .",
    "we do nt want to deny this , on the contrary : here we are interested in how programs are _ usually _ used , and in pointing out that some standard methodologies which are normally considered as applicable only to lp , are actually not so .",
    "of course not all programs using logical variables are translated correctly : typical such examples are the programs which incrementally fill in a data structures such as in the _ eight queen _ example and in the ` sequence ` example in appendix [ sec : sequence ] ( these programs use unification in a crucial way , and this is confirmed by the fact that they are not _ consistent _ ) .",
    "other examples are circular programs such as the following one    p(x ) @xmath17eq(x , x ) .",
    "+ eq(x , x ) .",
    "moded as follows : ` p(in : ground):non - test ` and ` eq(out : ground , out : ground):non - test ` .",
    "this program is circular in a non - well - founded way , and this , when translated , yields a program which is not _",
    "productive_.    we can safely conclude that difference lists have a natural counterpart in the circular structures of lazy functional programming .",
    "another prominent property of logic programming is the possibility of having a dynamic selection rule , possibly guided by appropriate _ delay declarations_. let us consider the following example , which , given the list xs of integer values , del_max(xs , zs ) produces the list zs by deleting all the occurrences of its maximum element .",
    "del_max(xs , zs ) @xmath17find_max_and_del(xs , max , zs , max ) .",
    "+ % find_max_and_del(inlist , el , outlist , max ) + % max is the maximum element of the list inlist , and + % outlist is obtained from inlist by deleting all the occurrences of el from it + find_max_and_del ( [ ] , _ , [ ] , 0 ) .",
    "+ find_max_and_del([x | xs ] , el , ys , max ) @xmath17 + find_max_and_del(xs , el , zs , max ) , + sup(x , max , max ) , + del_if_first([x | zs ] , el , ys )",
    ". + del_if_first([el | zs ] , el , zs ) .",
    "+ del_if_first([x | zs ] , el , [ x|zs ] ) @xmath17x @xmath104 el . + mode del_max(in : list[int ] , out : list[int ] ) : non - test .",
    "+ mode find_max_and_del(in : list[int],in : int , out : list[int],out : int):non - test .",
    "+ mode sup(in : int , in : int , out : int ) : non - test .",
    "% defined in the obvious way + mode del_if_first(in : list[int ] , in : int , out : list[int ] ) : non - test .",
    "it is worth noticing that the program uses logical variables in a nontrivial way .",
    "this is confirmed by the fact that it is not well - moded .",
    "specifically , the variable ` max ` in the first clause is used as an asynchronous communication channel between processes , as the atom find_max_and_del(xs , max , max , zs ) uses ` max ` as input value that it has to produce itself .",
    "furthermore , the program requires an appropriate _",
    "dynamic scheduling_. in fact , when run with a standard left - to - right selection rule , the query del_max(ts , zs ) ( @xmath105 being a list of natural numbers ) leads to a run - time error ( or to an incorrect answer ) , and , provided that we fix this problem , to a very inefficient computation .",
    "the first problem ( concerning the runtime error ) is due to the fact that the computation will soon a goal of the form ` del_if_first(ts , el , zs ) ` , where ` ns ` @xmath106)$ ] is a non - empty list of integers , and ` el ` and ` zs ` are distinct variables .",
    "at that point the interpreter will proceed and might reach the call @xmath107 , which ",
    "being ` el ` a variable  will flounder`== ` in order to implement @xmath104 .",
    "for instance in eclipse and swi - prolog the call ` n = = el ` fails , and a subsequent call ` n \\backslash== el ` succeeds ( ! ) in eclipse by returning the empty c.a.s .  and in swi - prolog by instantiating ` el ` to an apparently random numeric value .",
    "of course , this behaviours lead to solutions which are almost always incorrect . ] . in other words",
    ", this program can not be run with the normal leftmost selection rule .",
    "the second problem ( concerning program s inefficiency ) is due to the fact that the query del_max(xs , zs ) could return the list @xmath108 in linear time ( scanning @xmath109 only once ) , however , it is easy to see that if we employ any fixed selection rule , the program has to go through a remarkable amount of backtracking , which makes it run in quadratic time on the length of the input list , where @xmath110 is still a variable .",
    "for this reason @xmath111 will take a guess and delete an element which will usually turn out not to be the correct one , and this will eventually produce backtracking . since the number of needed backtracking steps is linear in the size of the input list , this decreases the performance of the program from linear to quadratic time . in order to avoid this problem",
    ", we have to make sure that an atom of the form @xmath112 will be selected in the derivation _ only when _",
    "@xmath110 will be instantiated to a ground term .",
    "we can do this by employing the above delay declarations . ] .",
    "both problems can be solved by employing a _ dynamic selection rule _ and by prohibiting the selection of certain atoms until their arguments are sufficiently instantiated using for instance the following _ delay declarations _",
    "@xcite :    delay sup(x , y , _ ) until ground(x ) @xmath113 ground(y ) .",
    "+ delay @xmath104(x , y ) until ground(x ) @xmath113 ground(y ) .",
    "+ delay del_if_first([x|xs ] , el , _ ) until ground(x ) @xmath113 ground(el )    for instance , the first declaration will suspend any call to ` sup(t , s , v ) . ` until ` t ` and ` s ` are ground terms .",
    "delay declarations have become an important standard control tool and are implemented in various versions of prolog ( for instance in sixtus prolog and in eclipse @xcite ) and in the language gdel @xcite .",
    "now , let us for a moment not bother about the delay declarations and translate this program into haskell .",
    "we obtain the following script .",
    "del_max as @xmath30 xs @xmath17as + , let ( zs , maxel ) = find_max_and_del ( xs , maxel ) + = zs + find_max_and_del ( x1,x2 ) @xmath30 ( [ ] , el ) @xmath17(x1 , x2 ) + = ( [ ] , 0 ) + @xmath30 ( x : xs , el )",
    "@xmath17(x1,x2 ) + , let ( zs , maxel ) = find_max_and_del ( xs , el ) + , let maxel = max x maxel + , let ys = del_if_first ( x : zs , el ) + = ( ys , maxel ) + del_if_first ( x1 , x2 ) @xmath30 ( [ ] , el ) @xmath17(x1 , x2 ) + = [ ] + @xmath30 ( x : xs , el ) @xmath17(x1,x2 ) + , x = = el + = zs + @xmath30 ( x : xs , el ) @xmath17(x1,x2 ) + , x /= el + = x : zs    this program works fine , and his runtime complexity is linear in the size of the input .",
    "we can therefore state that the lazy computational mechanism compensates for the lack of control over dynamic scheduling , without which the above logic program could not be run or would have a quadratic complexity .",
    "thus although the mechanism of lazy evaluation and delay declarations are quite different ( actually , they are the opposite : the call - by - need mechanism determines which term _ has _ to be reduced , while delay declarations determine which atoms _ should not _ be resolved ) , they often accomplish the same thing .    the fact that lazy evaluation here plays a crucial role is confirmed by the fact that , if we had declared all predicates to be test predicates ( thus forcing strictness , as explained in the remark [ rem : strictness ] ) the translated program would not function properly . thus again we are in presence of a program exploiting logical variables in a complex way which nevertheless has a natural translation into haskell .",
    "another outstanding feature of logic programs is their backtracking mechanism , which virtually implements a _ do nt know _ nondeterministic system .    in the light of the above examples , we believe that nondeterminism is by far the most important and the mostly used peculiar feature of the logic programming paradigm .",
    "we do nt want to challenge this , on the contrary . at the same time",
    ", it is important for us to show to which extent a ( lazy ) functional program can mimic a logic program which uses backtracking .",
    "consider the following program .",
    "backtracker(x ) : - producer_a(y ) , picky_modifier(y , x ) .",
    "+ backtracker(x ) : - producer_b(y ) , picky_modifier(y , x ) .",
    "+ producer_a(``a '' ) .",
    "+ producer_b(``b '' ) .",
    "+ picky_modifier(``b '' , `` c '' ) .    the adopted mode and partitioning is    backtracker(out ) : non - test + producer_a(out ) : non - test ( and the same for producer_b + picky_modifier(in , out ) :",
    "test    its translation is the following :    backtracker @xmath30 let y = producer_a + , suc x @xmath17picky_modifier y + = x + @xmath30 let y = producer_b + , suc x @xmath17picky_modifier y + = x + producer_a = `` a '' + producer_b = `` b '' + picky_modifier x @xmath30 x = = `` b '' + = suc `` c '' + @xmath30 otherwise  = fail +    the haskell translation is able to report all the correct answers , even though in lp for the query @xmath114 in order to return the answer x = `` a '' , the interpreter has to go through some backtracking .",
    "notice in fact that the above logic program is not deterministic .",
    "consider now the following program scheme :    p(x ) @xmath17generate(x ) , test(x ) .",
    "it is immediate to translate it and to check that if ` generate ` has more than one solution then the translation does not behave as the logic program does : while the query : - p(x ) succeeds provided that one of the solutions of ` generate(x ) ` satisfies ` test(x ) ` , the haskell translation manages to report one answer only so in the unlikely case that the first solution founded by ` generate(x ) ` satisfies ` test(x ) ` ; in all other cases @xmath115 reduces to @xmath46 .    the key factor for the translation to work correctly we need to avoid logic programs in which consistent queries might originate sld trees with more than one successful ( sub- ) branch .",
    "there exists techniques based on list - comprehension in order to translate logic programs into functional programs in such a way that the resulting program will ( eventually , lazily ) report the list of all the answers that the initial logic program would . in those cases ,",
    "however , one can clearly not talk of a _ literal _ translation , which is the starting point of our research ( programs able to return more than one answer are in our opinion intrinsically logic programs , and therefore do not belong to our target ) .    to be precise",
    ", a non - deterministic logic program can be safely translated onto haskell provided it is _ input discriminative _ , as defined as follows :    [ def : id2 ] let @xmath70 be a program , @xmath116 be its least herbrand model , and    p@xmath28(i@xmath28 , o@xmath28 ) = @xmath17@xmath117@xmath28 , @xmath118@xmath28 .",
    "+  @xmath33 + p@xmath119(i@xmath119 , o@xmath119 ) @xmath17@xmath117@xmath119 , @xmath118@xmath119 .",
    "be the complete set of the rules of @xmath70 ( where the conjunction @xmath117@xmath120 contains only test predicates and @xmath118@xmath120 contains only non - test predicates ) .",
    "we say that @xmath70 is _ input discriminative _ if for each @xmath121 $ ] , such that @xmath122 we have that    * for each ground @xmath88 such that @xmath123 we have that @xmath124 .",
    "it is worth noticing that this concept of input discriminative program is rather less restrictive than the concept of _ deterministic _ program , and that input - discrimitative programs might still require non - trivial ( non - shallow , see ( * ? ? ?",
    "* ch .  6 ) ) backtracking .",
    "we could say that these programs admit some _",
    "shallow nondeterminism_.    summarizing , there is a point to be remarked , that  strictly speaking  the haskell translation of a program",
    "can _ always _ mimic the backtracking taking place in the original logic program .",
    "what the haskell translation can__not _",
    "_ do is report multiple answers .",
    "the feature of logic programs of being able of reporting more than answer , and how this is handled in the different translation systems is a topic which deserves a separate discussion .    regarding this issue ,",
    "the literature on papers presenting a translation from logic to functional programs can be divided in two main groups .",
    "on one side we find papers which are not concerned with the nondeterminism ( or the backtracking ) mechanism of logic languages @xcite , these papers are usually mainly concerned in providing a transformation system which allows one to prove program properties such as termination of the original logic program . for this reason they focus on obtaining a translation which maps only the non - failing computations correctly . in these papers the failure and backtracking mechanism are disregarded during the translation .    on the other side ,",
    "we find @xcite , in which the authors propose a translation in which the full ( prolog - like ) computational mechanism is preserved , including the possibility of having multiple answer for the same query and the possibility of failure .",
    "this is achieved by letting a query return the _ list _ of computed answer substitutions , where the empty list corresponds to the failing case , in the same way advocated by wadler @xcite .",
    "the lazy computational mechanism then takes care of computing only those answers which are necessary , and backtracking is faithfully rendered by a standard list - comprehension schema .",
    "the translation system we have employed lies somewhere in the middle between those two methods . our goal was to take also failure into account , yet retaining a literal translation system , in which the computational mechanism of the resulting functional program is as similar as possible to the one of the original logic program .    of course we can only correctly translate programs which do not return more than one answer for the same query ( at the same time , it is important to notice that these programs do nt have to be deterministic ; for instance ` member ` is nondeterministic ) .    in our opinion ,",
    "the possibility of returning more than one answer is to be considered a _ peculiar",
    "_ one of the lp paradigm , and the fact that it can be emulated by functional programs does not obliterate our position .",
    "the goal of our research was to investigate to which extent some features considered peculiar of the logic programming paradigm are really so . for this purpose",
    "we have devised a simple  literal  system which enabled us to translate logic programs into the lazy functional language haskell .    it is known ( see also @xcite ) that _ if we restrict our attention to non - failing , non - backtracking computation _ then well - moded simply moded programs have a natural counterpart in a functional language .",
    "the properties of being well - moded and simply moded indicates a manner of use of variables in logic programming which is undoubtedly `` functional '' . to this statement",
    "we want to add that well- and simply moded programs can be considered as _ strictly _ functional , as they can be safely translated into a",
    "_ strict _ functional language .",
    "in this paper we have shown that in a _ lazy _ functional language , this picture broadens significantly , and some of the features that were  in the light of the results above  commonly considered as exclusive of the logic programming paradigm , can be naturally found in a lazy functional language such as haskell .",
    "in particular , we have shown that the use of complex logical variables in data structures such as difference lists ( or such as in program in ` del_max ` ) find a natural counterpart in the circular structures @xcite of lazy functional programs .",
    "these structures that were commonly considered as `` structurally logical '' are thus not so .",
    "we can then attempt a rough classification of logic programs according to the level of complexity at which they employs their variables ( backtracking and nondeterminism is not considered here ) .",
    "we then have the following division .    1 .",
    "_ strictly functional _ programs which use variables in a standard ( imperative - like ) way .",
    "these are characterized by being _",
    "well - moded _ ( or by being so after permutation of the clause s body atoms ) .",
    "2 .   _ lazy functional _ programs which admit a safe translation into haskell : i.e.  programs which can be translated into haskell ( via the syntactic translation ) and whose operational behaviour is isomorphic to the one of their functional counterpart .",
    "intrinsically logical _ programs which do not admit a safe translation into haskell with our translation scheme .",
    "this raises the interesting question of how large is the class of intrinsically logical programs . without pretending to be able to characterize extensively this limit ,",
    "it is interesting to notice that programs which are plain and consistent and which either admit a layered mode @xcite , or are s - well - typed programs @xcite are safely translatable into haskell ( modulo the possibility of backtracking , which is discussed in the sequel ) .",
    "as argued in @xcite , we believe that these programs actually encompass the majority of actual programs which use logical variables in a non - elementary way .",
    "we think that a classification and understanding of these levels might be useful both to enhance the performance of logic languages ( as already done to some extent in the language mercury ) and to prove more precise program properties .",
    "furthermore , we have also addressed another logical feature : the possibility of dynamic scheduling . in theory in lp _ any _ atom is selectable as all selection rules yield the same successful derivations . in practice",
    "this does not work , and adopting a random selection rule would in the best case yield to an explosion of the search space ; for this reason prolog uses a fixed left - to - right selection rule , a feature which is either explicitly or implicitly always exploited by the programmers .",
    "however , some programs ( like ` delmax ` above , or concurrent - like programs ) are not correct under a fixed search rule . in these cases",
    "the `` right '' selection strategy is enforced by the use of appropriate delay declarations ( d.d . ) , which serve to indicate which atoms in a query should not be resolved . the implementation of d.d .",
    "is rather costly , as atoms are continuously being suspended and forced .",
    "here we have seen one example in which the lazy evaluation mechanism of haskell achieves the same effect of the use of d.d .. as we have pointed out , call - by - need can be regarded as a dynamic selection strategy , which is however based on an principle opposite to the one of d.d .  in the sense that call - by need determines which term has to be reduced , while delay declarations determine which atoms should _ not _ be resolved .",
    "a naturally arising question here is whether it is possible to implement in logic programming languages a selection rule which is `` driven '' by a call - by - need mechanism , instead of `` restricted '' by the use of delay declarations .",
    "this could possibly lead to reduction of the suspension overhead and thus to performance improvements .",
    "the difficulty in implementing such a search rule lies in the fact that in lp it is not clear which output values depend on which input values ( actually , it is not clear what is input and what it is output to start with ) , so in order to implement such an intelligent selection strategy , one would need some sophisticated analysis tools which might either be based on abstract interpretation ( with tools similar to the ones of @xcite ) , or on refined versions of modes such as the ones described in @xcite .",
    "other works related to this subjects are @xcite .",
    "we have also discussed the fact that logic programs allow backtracking .",
    "we have seen that  strictly speaking  backtracking computations can be easily mimicked by the functional language by an appropriate use of the guards ; what can not be ( easily ) mimicked in haskell is the possibility of returning multiple answers , at least not unless one uses additional constructs such as the list - of - successes method @xcite .",
    "an interesting research direction might be to define appropriate monadic structures ( such as those in @xcite ) to capture the failure or success and returning of multiple arguments .",
    "this would broaden the set of logical programs which we can capture with our simple translation scheme , without adding signifant complexity to it .",
    "in conclusion , we have demonstrated with a simple , literal translation scheme that several features considered as belonging specifically to logic programming are found naturally in lazy functional programming , dismissing the folklore that the functional core of logic programming is contained in the set of well- and simple moded programs .",
    "dlgh97    k.  r. apt and s.  etalle . on the unification",
    "free prolog programs . in a.",
    "borzyszkowski and s.  sokolowski , editors , _ proceedings of the conference on mathematical foundations of computer science ( mfcs 93 ) _ , lecture notes in computer science , pages 119 , berlin , 1993 .",
    "springer - verlag .",
    "apt and e.  marchiori .",
    "reasoning about prolog programs : from modes through types to assertions .",
    ", 6(6a):743765 , 1994 .",
    "k.  r. apt .",
    "introduction to logic programming . in j.",
    "van leeuwen , editor , _ handbook of theoretical computer science _",
    ", volume b : formal models and semantics , pages 495574 .",
    "elsevier , amsterdam and the mit press , cambridge , 1990 .",
    "r.  s. bird . .",
    ", 21:239250 , 1984 .",
    "j.  boye and j.  mauszyski .",
    "directional types and the annotation method . , 33:179220 , 1997 .",
    "h.  coelho and j.  c. cotta . .",
    "springer - verlag , berlin , 1988 .",
    "m.  codish , s.  k. debray , and r.  giacobazzi . compositional analysis of modular logic programs . in acm ,",
    "editor , _ twentieth annual acm sigplan - sigact symposium on principles of programming languages _ , pages 451464 .",
    "acm press , 1993 .",
    "s.  debray , p.  lpez - garca , and m.  hermenegildo . .",
    "in lee naish , editor , _ proceedings of the 14th international conference on logic programming _",
    ", pages 4862 , cambridge , 1997 .",
    "mit press .",
    "p.  dembinski and j.  maluszynski .",
    "-parallelism with intelligent backtracking for annotated logic programs . in _ proceedings of the international symposium on logic programming _ , pages 2938 , boston , 1985 .",
    "s.  etalle and m.  gabbrielli .",
    "layered modes . in f.",
    "de  boer and m.  gabbrielli , editors , _ proc . jicslp96 post - conference workshop on verification and analysis of logic programs _ , 1996 .",
    "tehcnical report tr-96 - 31 , dipartimento di informatica di pisa .",
    "s.  etalle and f.  van raamsdonk . beyond success and failure . in j.",
    "jaffar , editor , _ proceedings of the 1998 joint international conference and symposium on logic programming ( jicslp-98 ) _ , pages 190204 . mit press , june1519   1998 .",
    "h.  ganzinger and u.  waldmann . .",
    "in michal rusinowitch and jean - luc rmy , editors , _ conditional term rewriting systems , third international workshop _ , lncs 656 , pages 430437 .",
    "springer - verlag , 1992 .",
    "p.  m. hill and j.  w. lloyd . .",
    "the mit press , 1994 .",
    "p.  hudak ( ed ) , s.  l. peyton jones ( ed ) , and p.  l. wadler ( ed ) .",
    "report on the programming language haskell  a non - strict purely functional language , version 1.2 .",
    ", 27(5):1162 , may 1992 .",
    "s.  lttringhaus - kappel . .",
    "phd thesis , friedrich - wilhelms - universitt bonn , 1992 .",
    "j.  w. lloyd . .",
    "symbolic computation  artificial intelligence .",
    "springer - verlag , berlin , 1987 .",
    "second edition .",
    "m.  marchiori . .",
    "in giorgio levi and mario rodrguez - artalejo , editors , _ algebraic and logic programming , 4th international conference , alp94 _ , volume 850 of _ lncs _ , pages 223241 .",
    "springer - verlag , 1994 .",
    "m.  marchiori . .",
    "in _ proceedings of the seventh international conference on functional programming languages and computer architecture ( fpca95 ) _ , pages 5565 , la jolla , california , 1995 .",
    "acm press .",
    "l.  naish .",
    "an introduction to mu - prolog .",
    "technical report 82/2 , the university of melbourne , 1982 .",
    ". mit press , 1990 .",
    "s.  l. peyton jones . a new view of guards .",
    "http://www.dcs.gla.ac.uk/@xmath125simonpj/ , 1997 .",
    "d.  pedreschi and s.  ruggieri . .",
    "technical report tr-97 - 21 , dipartimento di informatica , 1997 .",
    "u.  s. reddy .",
    "transformation of logic programs into functional programs . in _ international symposium on logic programming _ , pages 187198 , silver spring , md , february 1984 .",
    "atlantic city , ieee computer society .",
    "m.  r. k.  krishna rao , d.  kapur , and r.  k. shyamasundar . .",
    ", 34(1):141 , 1998 .",
    "using program transformation to obtain methods for eliminating backtracking in fixed - mode logic programs . technical report  7 , universidad nacional autonoma de mexico , instituto de investigaciones en matematicas aplicadas y en sistemas , 1991 .",
    "l.  sterling and e.  shapiro . .",
    "mit press , 1986 .    f.  van raamsdonk . .",
    "in lee naish , editor , _ proceedings of the 14th international conference on logic programming _ , pages 168182 . mit press , 1997 .",
    "p.  wadler . .",
    "in _ proceedings of the second conference on functional programming languages and computer architecture _ , lecture notes in computer science , pages 113128 .",
    "springer - verlag , 1985 .",
    "p.  wadler .",
    "the essence of functional programming . in _",
    "19th annual symposium on principles of programming languages ( popl ) _ , santa fe , new mexico , 1992 .",
    "mark wallace and andr veron .",
    "two problems  two solutions : one system  eclipse . in _ proceedings iee colloquium on advanced software technologies for scheduling _ , london , april 1993 .",
    "the following concept is essentially due to dembinski and maluszynski @xcite ; we use here an elegant formulation due to rosenblueth @xcite .",
    "[ def : wm ] a clause @xmath126 is called _ well - moded _",
    "if for @xmath127 $ ] @xmath128    a query @xmath129 is called _ well - moded _ iff the clause @xmath130 is , where @xmath131 is any ( dummy ) atom of zero arity .",
    "a program is called _ well - moded _ if every clause of it is .",
    "it is important to notice that the first atom of a well - moded goal is ground in its input positions and a variant of a well - moded clause is well - moded .",
    "furthermore , the notion of of well - modedness , is `` persistent '' , as shown by the following lemma .",
    "recall that a ld - resolvent is a resolvent in which the leftmost atom per the query is the selected one , and that an ld - derivation is a derivation obtained employing the leftmost selection rule ,    [ lem : wm - persist ] an ld - resolvent of a well - moded goal and a well - moded clause that is variable - disjoint with it , is well - moded .",
    "the next result is originally due to dembinski and maluszynski and follows directly from the definition of well - moded program .",
    "[ cor : wm ] let @xmath26 and @xmath129 be well - moded , and let @xmath132 be an ld - derivation of @xmath129 in @xmath26 .",
    "all atoms selected in @xmath132 contain ground terms in their input positions .",
    "that is , in presence of well - moded programs and queries , if we use a left - to - right computation schema we are sure that every time that we select an atom , the `` value '' of his input arguments has already been fully computed .",
    "this shows that well - moded programs have a straightforward left - to - right data - flow .    under certain conditions well - moded programs",
    "are also _ unification - free_. to show this , we need a definition first .",
    "the following notion was first defined in @xcite .",
    "[ def : sm ] a clause @xmath133 is called _ simply moded _",
    "if if @xmath134 is a linear family of variables and for @xmath135 $ ] @xmath136    a query @xmath129 is called _ simply moded _ iff the clause @xmath137 is , where @xmath131 is any ( dummy ) atom of zero arity .",
    "a program is called _ simply moded _ if every clause of it is .",
    "thus , assuming that in every atom the input positions occur first , a clause is simply moded if all output positions of every body atom are filled in by distinct variables , which do not occur earlier in the body nor in an input position of the head .",
    "it is worth noticing that  as shown by the little survey in @xcite  most programs are already simply - moded and that often non simply - moded programs can naturally be transformed into simply - moded ones , for instance the non - simply - moded clause @xmath138).$ ] can be transformed into @xmath139 = list'$ ] .",
    "the property of being simply moded is also `` persistent '' in the sense that the resolvent of a simply moded query with a simply moded clause is simply moded .",
    "in @xcite it is proven that if the program and the query are simply moded , then they generate an ld - derivation which is _ unification - free _ ,",
    "i.e.  that each time an atom @xmath140 is selected and resolved in it via a clause @xmath141 , then the unification of @xmath140 and @xmath142 does not really require a full unification algorithm , but can always be reduced to a",
    "_ double matching : _ one ( `` from '' @xmath140 `` to '' @xmath142 ) for the input positions and a second one ( `` from '' @xmath142 `` to '' @xmath140 ) for the output ones .",
    "this result clearly shows that simply and well - moded logic programs are functional in nature ( besides for the possibility of reporting multiple answers , of course ) .",
    "the following ( nonsense ) program embodies most of the concepts we use :    append ( [  ] , x ) = suc x + append ( x1,x2 ) @xmath30 ( x : xs ) @xmath17x1 + @xmath38 suc tail @xmath17append ( xs , x2 ) + @xmath38 let newtail = ( x : tail ) + = suc newtail + @xmath30 otherwise  = fail    in a call of , the first equation will be tried first . here , will be pattern matched to the empty list .",
    "if this succeeds , then is matched to ( since both are variables , this will always succeed ) , and finally is returned .",
    "if the pattern match above failed , then the first guard will be tried , which tries to pattern match the first element of the tuple to a list with at least one element .",
    "should this succeed , the result of a recursive call to is matched against , and if successful is bound to the variable @xmath143 , followed by the returning of @xmath144 .",
    "if either of the pattern matches failed , then the second guard will be tried .",
    "this example is provided by the prolog formalization of a problem from coelho and cotta ( * ? ? ? * pag .",
    "193 ) : arrange three 1 s , three 2 s , ... , three 9 s in sequence so that for all @xmath145 $ ] there are exactly @xmath12 numbers between successive occurrences of @xmath12 .",
    "sublist(xs , ys ) @xmath17  xs is a sublist of the list ys .",
    "+ sublist(xs , ys ) @xmath17  app ( _ , zs , ys ) , app(xs , _ , zs ) .",
    "+ sequence(xs ) @xmath17   xs is a list of 27 elements .",
    "+ sequence ( [ _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ , _ ] ) .",
    "+ question(ss ) @xmath17   ss is a list of 27 elements forming the desired sequence .",
    "+ question(ss ) @xmath17 + sequence(ss ) , + sublist([1,_,1,_,1 ] , ss ) , + sublist([2,_,_,2,_,_,2 ] , ss ) , + sublist([3,_,_,_,3,_,_,_,3 ] , ss ) , + sublist([4,_,_,_,_,4,_,_,_,_,4 ] , ss ) , + sublist([5,_,_,_,_,_,5,_,_,_,_,_,5 ] , ss ) , + sublist([6,_,_,_,_,_,_,6,_,_,_,_,_,_,6 ] , ss ) , + sublist([7,_,_,_,_,_,_,_,7,_,_,_,_,_,_,_,7 ] , ss ) , + sublist([8,_,_,_,_,_,_,_,_,8,_,_,_,_,_,_,_,_,8 ] , ss ) , + sublist([9,_,_,_,_,_,_,_,_,_,9,_,_,_,_,_,_,_,_,_,9 ] , ss ) ."
  ],
  "abstract_text": [
    "<S> the possibility of translating logic programs into functional ones has long been a subject of investigation . </S>",
    "<S> common to the many approaches is that the original logic program , in order to be translated , needs to be _ well - moded _ and this has led to the common understanding that these programs can be considered to be the `` functional part '' of logic programs . as a consequence of this it has become widely accepted that `` complex '' logical variables , the possibility of a dynamic selection rule , and general properties of non - well - moded programs are exclusive features of logic programs .    </S>",
    "<S> this is not quite true , as some of these features are naturally found in _ </S>",
    "<S> lazy _ functional languages .    </S>",
    "<S> we readdress the old question of what features are exclusive to the logic programming paradigm by defining a simple translation applicable to a wider range of logic programs , and demonstrate that the current circumscription is unreasonably restrictive .    _ </S>",
    "<S> keywords : _ logic programming , functional programming , lazy evaluation .    </S>",
    "<S> _ acm computing classification system : _ d.1.1 ( applicative  functional  programming ) ; d.1.6 ( logic programming ) ; d.3.2 ( language classifications ) f.3.3 ( studies of program constructs ) programs ) </S>"
  ]
}