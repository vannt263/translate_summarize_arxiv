{
  "article_text": [
    "consistency techniques are widely used for solving finite constraint satisfaction problems ( csp ) .",
    "these techniques have been integrated in logic programming , resulting in finite domain constraint logic programming @xcite . in this paradigm ,",
    "a program typically creates a data structure holding the variables of the csp to be solved , sets up the constraints and uses a labelling technique to assign values to the variables",
    ". the constraint solver uses consistency techniques @xcite to prune the search .",
    "solutions are given by an answer substitution to a goal .",
    "this leads to a rather procedural programming style . moreover , the problem description is not very declarative because the mapping between domain variables and their value has an indirect representation in a term structure",
    ". a more detailed discussion for representing and solving csp in different logical systems , following this approach , can be found in @xcite .",
    "an alternative representation of a csp can be given in a first - order logic setting , where instead of using variables , one can define the problem in a more natural way by using constant and function symbols and specify the constraints as logic formulae . a solution is then given by a model of the theory , and in particular by the interpretation of the function symbols .",
    "we argue that representing a problem in this way tends to be more declarative . to achieve a similar declarative representation in a logic programming system",
    ", the functions should be replaced with predicates and then an answer of a csp is given by a table of facts .",
    "abduction @xcite is one framework which allows such reasoning .",
    "the relation between the variables of the csp and their values is declared as an abducible and solution of the problem is given by a set of abduced atoms .",
    "more recently , a logic programming paradigm based on stable model semantics @xcite has emerged and niemel @xcite proposes it as a constraint solving paradigm . in this approach",
    "a solution is given by a stable model of the program .",
    "in this paper , we use two typical csp problems to compare the merits of the various approaches .",
    "one is graph coloring where the domain size is constant but the number of constraints increases with increasing problem size ; the other is the n - queens problem where both the domain size and the number of constraints increases with increasing problem size . for both problems",
    "we show the representation in the various approaches , comment on the declarativity of the representation and briefly describe the basic principles behind the implementation .",
    "we also compare the performance of different systems and show how it scales by increasing the problem size .",
    "first , we give some basic notions about constraint satisfaction and logic programming .",
    "then we discuss the classical representation of csp as a logic and constraint logic program .",
    "the next section gives a different representation of a csp and shows how it can be translated to an equivalent logic program which then can be solved by abductive reasoning or by computing stable models of the program .",
    "finally , we give the results of solving some well - known problems with several systems and the last section gives a summary of our research and some directions for future research .",
    "a _ constraint satisfaction problem _ is usually defined as a finite set of _ constraint variables _ @xmath0 , a finite domain @xmath1 of possible values for each variable @xmath2 , and a finite set of _ constraint relations _",
    "@xmath3 , where @xmath4 for @xmath5 are the indices of the variables which are constrained by @xmath6 .",
    "solution _ is an instantiation of the variables @xmath7 which satisfies all the constraints in @xmath8 .",
    "a logic program is defined for a fixed language @xmath9 of function and predicate symbols and an infinite set of variables @xmath7 .",
    "we assume that our language always contains the equality predicate @xmath10 .",
    "terms and atoms are defined as usual .",
    "literal _ is either an atom @xmath11 or a negation of an atom @xmath12 .",
    "clause _ has the form @xmath13 where @xmath11 is an atom and is called _ head _ and @xmath14 are literals and @xmath15 is called _",
    "body_. a clause is called definite if all @xmath14 are positive .",
    "a ( definite ) logic program @xmath16 is a set of ( definite ) clauses .",
    "a herbrand interpretation and herbrand model are again defined as usual ( cf .",
    "a definite logic program always has a unique least herbrand model which will be denoted with @xmath17 .",
    "a csp can be easily represented as a definite logic program .",
    "the domains of the variables are defined by unary predicates . a constraint relation @xmath18",
    "is defined by a predicate @xmath19 such that @xmath20 .",
    "then a csp can be defined by a clause of the form :    csp(x_1, ",
    ",x_n ) d_1(x_1), ",
    ",d_n(x_n ) , p_1(x_s_1 ) ,  , p_t(x_s_t ) .",
    "a computed answer substitution @xmath21 for the goal @xmath22 using sld resolution will be a solution to the csp since @xmath23 and in particular @xmath24 .",
    "it is also easy to see that the least model of the @xmath25 predicate will contain all solutions to the problem .",
    "so , to compute all solutions to a given problem one can use a bottom - up fix - point operator to compute the least model of a program .    to give an example",
    "let us consider the problem for finding the positions of @xmath26 queens on a @xmath27 chess board such that no two queens attack each other .",
    "one way of formalizing this problem is by using @xmath28 boolean variables which indicate whether a queen is placed on a particular square .",
    "however , by taking into account the fact that no two queens can be placed on the same column , we can use only @xmath26 variables which give the positions of the queens for each column .",
    "then for all pairs of queens we should state the constraint that they can not attack each other by being on a same row or diagonal .",
    "this constraint can be defined with the following predicate which is parameterized by the distance @xmath29 between the columns of the two queens :    safe(x_1,x_2,d)x_1x_2 , abs(x_1-x_2)d .",
    "then the 4-queens problem can be defined as :    csp(x_1,x_2,x_3,x_4 ) d(x_1),d(x_2),d(x_3),d(x_4 ) , safe(x_1,x_2,1),safe(x_2,x_3,1 ) , safe(x_1,x_3,2),safe(x_1,x_4,3 ) , safe(x_2,x_4,2),safe(x_3,x_4,1 ) .    here",
    "we exploit another particularity of the n - queens problem , that the @xmath30 constraint is symmetric for the first two arguments .",
    "hence it is enough to only check queens such that the column of the first one is less than the column of the second one .",
    "executing the query @xmath31 under the top - down left - to - right strategy of prolog will result in solving the problem by a generate and test approach . by interleaving the calls to the domain",
    "predicates @xmath32 and the constraint predicates will result in a standard backtracking :    csp(x_1,x_2,x_3,x_4 ) d(x_1),d(x_2 ) , safe(x_1,x_2,1 ) , d(x_3 ) , safe(x_2,x_3,1),safe(x_1,x_3,2 ) , d(x_4),safe(x_1,x_4,3),safe(x_2,x_4,2 ) , safe(x_3,x_4,1 ) .",
    "a lot of research has been done to improve the execution strategy of standard prolog .",
    "for example , a technique known as _ co - routing _ uses a literal selection strategy which selects a constraint as soon as all its arguments become ground .",
    "this allows a generate and test program to be executed with standard backtracking .",
    "another technique known as _ intelligent backtracking _",
    "@xcite does a failure analysis and backtracks only to variable assignments which are actually responsible for the failure .",
    "csp(n , l)make_vars(l , n ) , constrain_all(l ) .",
    "make_vars([],0 ) .",
    "make_vars([ht],n ) n > 0 , d(h ) , n1 is n - 1 , make_vars(t , n1 ) .",
    "constrain_all ( [ ] ) .",
    "constrain_all([xxs ] ) constrain_all(xs ) , constrain_between(x , xs,1 ) .",
    "constrain_between(x,[],n ) .",
    "constrain_between(x,[yys],n ) safe(x , y , n ) , n_1 is n+1 , constrain_between(x , ys , n_1 ) .",
    "an important problem with this representation of a csp is that it has to be defined specifically for a given number of queens .",
    "if we want to parameterize the problem with respect to the number of queens then we should use some data structure ( usually a list ) to store the constraint variables .",
    "figure [ fig : queen ] shows a typical specification of the problem .",
    "the @xmath33 predicate constructs a list of @xmath26 variables and uses backtracking to enumerate all possible solutions .",
    "however this way of representing the problem is even less declarative than before .",
    "first of all , the column number of each queen is implicitly defined by the position of the corresponding variable in the list .",
    "then , in order to add constraints only between queens such that the column of the first one is less than the column of the second one we have to use two nested recursive predicates .",
    "graph_coloring(vert , edges , vars)make_vars(vert , vars ) , add_constr(edges , vars ) .",
    "make_vars ( [ ] , [ ] ) .",
    "make_vars([vvert],[assoc(v , x)vars])color(x ) , make_vars(vert , vars ) .",
    "add_constr([],vars ) .",
    "add_constr([edge(v_1,v_2)edges],vars)member(assoc(v_1,x_1),vars ) , member(assoc(v_2,x_2),vars ) , x_1 x_2 , add_constr(edges , vars ) .",
    "another typical csp problem is that of graph coloring . the goal is to color all the vertices of a graph in such a way that no two adjacent vertices have the same color .",
    "the graph can be represented by a list of vertices and a list of terms @xmath34 describing the edges .",
    "the problem can be expressed as a csp by associating a different variable for each vertex and restricting its domain to all possible colors .",
    "then for each edge in the graph we put a disequality constraint between the variables corresponding to the vertices of the edge .",
    "figure [ fig : gcp ] shows a sample formulation of this problem as a logic program . here the correspondence between a vertex and the color assigned to it is made explicit by means of an association list .",
    "constraint logic programming ( clp ) @xcite is an extension of logic programming where some of the predicate and function symbols have a fixed interpretation .",
    "this interpretation is dependent on a particular constraint domain @xmath35 ( e.g. finite trees or real numbers ) and this allows for a much more natural representation of problems from this particular domain . besides its better declarative semantics for expressing problems , an implementation of a clp(@xmath35 ) system also includes an efficient domain specific solver @xmath36 for checking satisfiability of a set of constraints .",
    "a proof procedure for clp is defined as an extension of standard resolution .",
    "a state is defined as a pair @xmath37 of a goal and a set of constraints . at each step of the computation , some literal @xmath11",
    "is selected from the current goal according to some selection function .",
    "if @xmath11 is a constraint predicate then the next state is @xmath38 if @xmath39 or @xmath40 otherwise .",
    "if @xmath11 is a normal atom then the next state is @xmath41 for some clause @xmath42 where @xmath11 is of the form @xmath43 and @xmath44 is of the form @xmath45 .",
    "a well suited constraint domain for representing csps is that of finite domain integer arithmetic @xmath46 @xcite .",
    "it includes standard arithmetic relations like @xmath47 and functions @xmath48 with their usual interpretation .",
    "the implementation of @xmath46 is based on consistency @xcite algorithms .",
    "a csp represented as a logic program can be translated to a clp(fd ) program in a straightforward way .",
    "first , the domains of the variables are declared by a special clp predicate ( for example @xmath49 ) and the constraints are defined using the clp predicates and functions .",
    "then the execution of the goal @xmath22 by a constraint proof procedure will result in a set of constraints which are then solved efficiently by consistency techniques .",
    "from the examples and the discussion in the previous section , the following general methodology can be given for representing a parameterized csp as a ( constraint ) logic program .",
    "first , we create some data structure where each value of the parameter of the problem ( e.g. the number of queens , or the number of vertices ) is associated with a different variable .",
    "then we define some recursive predicates which iterate over this data structure and define constraints between the variables whose corresponding parameters satisfy certain conditions .",
    "it seems natural to represent the mapping between parameter and variable with a function .",
    "first let us introduce a new domain @xmath50 which includes all values of the parameter .",
    "for example , for the n - queens problem @xmath50 is the set of columns and for the graph coloring problem @xmath50 will contain all vertices .",
    "then a solution to a csp can be represented by a function @xmath51 , where @xmath29 is the domain of the constraint variables .",
    "the use of functions for representing csps can be realized in a first - order logic setting where a solution of a problem can be given by an interpretation of a function symbol in a model of the theory describing the problem .",
    "also the constraints are expressed more naturally by using function symbols .",
    "a definition of the n - queens problem in first - order logic could be the following :    c_1,c_2 .",
    "c_1<c_2 safe(pos(c_1),pos(c_2),c_2-c_1 ) .",
    "safe(x_1,x_2,d)x_1x_2 , abs(x_1-x_2)d .",
    "the function symbol @xmath52 represents the mapping from columns to rows .",
    "a model of this theory based on a domain with @xmath26 elements will consist of an interpretation of the function @xmath52 and will be a solution of the problem with @xmath26 queens .",
    "if we want to work with several domains with different sizes then we may use a many sorted first - order logic where the arguments of the function and predicate symbols are assigned ( possibly different ) sorts . then in an interpretation of our theory for each sort we can assign a domain with the appropriate size .",
    "the full specification of the graph coloring problem in many sorted logic is given below .",
    "s = \\{s_v , s_c } f = \\{col : s_vs_c }   v_1,v_2 .",
    "col(v_1)col(v_2)edge(v_1,v_2 ) .   edge(1,2 ) .",
    "    here we use two sorts - @xmath53 for vertices , and @xmath54 for colors and a function @xmath55 which maps vertices to colors",
    ". the edges of the graph are described as a set of facts @xmath34 .",
    "an interpretation of this theory should associate the set with all vertices of the graph with the sort @xmath53 and a set with possible colors with the sort @xmath54 .",
    "several systems for generation of finite models of many sorted first - order logic theories are available ( e.g.  finder @xcite and sem @xcite ) and thus can be used for solving csps .",
    "using functions for representing csps in a logic programming setting is not possible .",
    "the reason is that the domain of the computation is the herbrand domain ( or comes from the constraint domain ) and that the interpretation of the function symbols is fixed . to overcome this restriction",
    ", one can introduce unary predicates @xmath56 and @xmath32 defining the domain and the range of the functions and encode a unary function @xmath57 as a binary predicate @xmath58 with domain defined by @xmath56 and range by @xmath32 .",
    "the following axioms establish that the interpretation of @xmath59 corresponds to a function : @xmath60 the formula states that the predicate @xmath58 is defined for all @xmath35 in the domain @xmath61 and that the value of @xmath62 is in the range @xmath63 .",
    "the formula enforces that the predicate @xmath64 is false for all values of @xmath35 not in the domain @xmath61 and ensures that the predicate @xmath58 defines a function from @xmath35 to @xmath62 . by introducing an auxiliary predicate @xmath65 , can be rewritten as : @xmath66    formula [ eq : aux1 ] is the completion of the predicate @xmath65 .",
    "writing it as a logic program clause , the only - if part can be dropped .",
    "however , the other three axioms , , and do not define any predicates but are just formulae which should be true in models of the program . in logic programming , such clauses are known as _ integrity constraints _ and we will denote them with the symbol @xmath67 . figure [ fig : pred - func ] shows the resulting logic program .",
    "@xmath68   has\\_p(x)&{\\leftarrow}d_p(x ) .         &",
    "& \\qquad \\text{from \\eqref{eq : aux2 } } \\\\",
    "d_p(x)&{\\leftarrow}p_f(x , y ) .",
    "& & \\qquad \\text{from \\eqref{eq : pred - nout } } \\\\   y = z & { \\leftarrow}p_f(x , y),p_f(x , z ) .   & & \\qquad \\text{from \\eqref{eq : pred - func}}\\end{aligned}\\ ] ]    a solution to a csp problem is then given by an interpretation of the predicate @xmath59 in a model of the logic program obtained by replacing the functions @xmath69 with the predicates @xmath59 and adding the theory defining @xmath59 .",
    "different models give rise to different solutions.applying this transformation on the n - queens problem , one obtains the specification given in figure [ fig : lp - queens ] where @xmath70 is the predicate which gives the row @xmath71 of a queen at a column @xmath72 .",
    "@xmath73    @xmath74    @xmath75      abductive logic programming @xcite is a form of reasoning in which an answer to a query is a set of facts .",
    "more formally , an abductive framework is defined as a triple @xmath76 where @xmath16 is a logic program , @xmath77 is a set of predicates called _ abducibles _ and @xmath78 is a set of integrity constraints .",
    "a solution is a set @xmath79 to indicate both the set of abducible predicates and the set of all their ground instances . ]",
    "such that @xmath80 for some canonical model @xmath81 of @xmath82 .",
    "if one is interested in a query , then it can be put as part of the integrity constraints .",
    "different choices for the type of canonical model have been considered in the literature . in @xcite ,",
    "@xmath81 must be a stable model of @xmath82 which is also called _",
    "generalized stable model _",
    "@xmath83 of @xmath16 . in @xcite three valued models of the completion of the program",
    "are considered and the abductive predicates must have a two - valued interpretation .    a problem defined as in figure [ fig : lp - queens ] can be given directly to an abductive procedure by declaring the predicate @xmath84 as abducible .",
    "proof procedures for abduction are defined in a similar way @xcite to , or as an extension @xcite of sldnf resolution . in each state of the derivation",
    "they also maintain a set @xmath85 of already abduced atoms .",
    "when an abductive atom is selected in the current goal , it is checked if it can be resolved with an atom from @xmath85 .",
    "if this is not the case then the selected atom is added to the set of abducibles and a consistency derivation is started which checks the integrity constraints to see if this assumption does not lead to a contradiction . if the abducible atoms contain variables then during an abductive step these variables are replaced with skolem constants and the unification algorithm is extended to deal with them @xcite .",
    "we have already discussed the problems of the sld resolution for efficiently solving csps thus we can expect that the performance of such more complex proof procedures will be even worse .    recently , abduction has been extended to constraint logic programs .",
    "one of the main ideas is that the skolem constants which are added as arguments of the abduced predicates are in fact existentially quantified constraint variables and their values can be computed by a constraint solver .",
    "this allows us to have a more declarative representation of csps and still use efficient techniques for computing their solution .",
    "the first such integration is the aclp system of kakas @xcite which is based on the proof procedure of @xcite .",
    "originally , aclp was defined only for definite programs and integrity constraints and in @xcite it was extended to deal with negation as failure through abduction in a similar way as in @xcite .",
    "a more recent integration of abduction and clp is the sldnfac system @xcite which is based on the abductive procedure sldnfa @xcite .",
    "another way of using `` open '' predicates in a logic program is to use the stable model semantics @xcite .",
    "a predicate @xmath86 can be defined as having an open interpretation by the following two rules : @xmath87 where @xmath88 is a new predicate symbol .",
    "this program has two stable models - @xmath89 and @xmath90 .",
    "if @xmath77 is a set of predicates then we define with @xmath91 the following set of clauses @xmath92 then to compute a stable model of a csp as represented in section [ fig : lp - queens ] , one only needs to add to the program the clauses @xmath91 , where @xmath77 is the set of predicates which are the result of the transformation of the function symbols .",
    "in fact , there is a very strong relation between the semantics of an abductive framework and the stable models of an equivalent logic program .",
    "it has been shown in @xcite that @xmath93 is a generalized stable model of an abductive framework @xmath76 iff there exists a stable model @xmath94 of @xmath95 such that @xmath96 where @xmath97 .    the rules declaring the open predicates can be combined with some of the integrity constraints to obtain a more compact representation of the problem . for example , the integrity constraint stating that the open predicate @xmath64 should be false for all values not in the domain @xmath98 @xmath99 can be omitted by using the rule @xmath100 the reason is that in the stable model semantics an atom can be true only if it is a head of some clause .",
    "the full specification of the n - queens problem is given in figure [ fig : sm - queens ] .",
    "pos(x , y)d_col(x ) , not(x , y ) .",
    "( x , y)notpos(x , y ) .",
    "safe(x_1,x_2,d)x_1x_2 , abs(x_1-x_2)d .",
    "has_pos(x)d_row(y),pos(x , y ) .   has_pos(x)d_col(x ) .",
    "y = z pos(x , y),pos(x , z ) .",
    "safe(r_1,r_2,c_2-c_1)pos(c_1,r_1),pos(c_2,r_2),c_1<c_2 .",
    "an efficient implementation of the stable model semantics is the _ smodels _  system @xcite .",
    "it works with propositional rules and a special pre - processing program is used for grounding function - free range - restricted logic programs .",
    "the implementation of the system combines bottom - up inference with backtracking search and employs powerful pruning methods .      in @xcite",
    "is presented a language called datalog@xmath101   which is an extension of datalog  where only some of the predicates are minimized and the interpretation of the others is left open .",
    "the semantics of the language originates from the nonmonotonic formalism of _ circumscription _ and is defined as the minimal herbrand model of the program w.r.t .  a fixed interpretation of the open predicates .",
    "it is proven in @xcite that the data complexity of deciding whether a query is not entailed by the program is np - complete which means that one can express any csp in this formalism . however , as the language does not contain negation , one can not use directly the methodology discussed above for representing csps .    in @xcite",
    "is defined the language np - spec  which is an extension of datalog@xmath101  and allows a more natural representation of problems .",
    "the main difference is that it supports special meta - declarations , called _ tailoring predicates _ , restricting the domain and the interpretation of the open predicates .",
    "the most simple one is of the form @xmath102 which defines @xmath103 to be an open predicate and its interpretation should be a subset of the interpretation of the predicate @xmath104 . another declaration is @xmath105 which states that the predicate @xmath103 should be partitioned in @xmath106 sets which is , in fact , equivalent to a function with domain @xmath104 and a range @xmath107 .",
    "the two other tailoring predicates are @xmath108 and @xmath109 which express respectively that @xmath103 is a bijection from @xmath104 to @xmath110 and @xmath103 is a function with a range @xmath111 .",
    "another extension of np - spec  is the support of a predefined arithmetic functions and predicates .",
    "the formulation of the graph coloring problem in the np - spec  language is given below .",
    "the input of the program consists of facts @xmath112 and @xmath113 describing the graph .",
    "@xmath114 & { \\leftarrow}edge(v_1,v_2),color(v_1,c_1),color(v_2,c_2).\\end{aligned}\\ ] ]",
    "the finite domain clp package is the one provided with sicstus version 3.7 .",
    "given the reputation of sicstus and of finite domain clp , one can assume it offers state of the art technology for csp solving and it is a good yardstick to judge the performance of other systems .",
    "the abductive system aclp @xcite is a meta interpreter written in prolog , runs on eclipse version 4.2 and makes use of its finite domain package .",
    "the abductive system sldnfac @xcite is also a meta interpreter written in prolog but runs on sicstus version 3.7 and makes use of the sicstus finite domain package .",
    "the model generator sem @xcite version 1.7 is a fine tuned package written in c. _ smodels _",
    "@xcite version 2.25 , the system for computing stable models is implemented in c++ and the associated program used grounding is _ lparse _ version 0.99.48 .",
    "all experiments have been done on the same hardware , namely pentium ii .",
    "all systems based on a finite domain constraint solver used a labeling strategy which first selects variables with the smallest domain and then the ones which participate in the highest number of constraints . ] .",
    "figure [ fig : q ] gives the running times for the different systems and figure [ fig : back ] gives the number of backtracks .",
    "the two abductive systems ( aclp and sldnfac ) do not introduce any extra choice points compared to clp and hence are not plotted in figure [ fig : back ] .",
    "not surprisingly , clp gives the best results .",
    "sldnfac is second best and , although meta - interpretation overhead increases with problem size , deteriorates very slowly .",
    "sem is third but runs out of memory for large problems ( it needs about 120 mb for 27 queens ) .",
    "this is probably caused by a not very good techniques for grounding the problem and exploring the search space .",
    "the times given for sem do not include time spend by the operating system in managing the memory which becomes considerable for the larger instances of the problem .",
    "aclp performs substantially worse than sldnfac and degrades more quickly for the larger problems .",
    "it can likely be attributed to the more experimental nature of the implementation .",
    "_ smodels _  performs very poorly on this problem , in particular when compared with its performance on the graph coloring problem .",
    "as can be seen from figure [ fig : back ] the main reason seems to be the large number of backtracks it does .",
    "the clp consistency techniques seem to be much less sensitive to the domains size , and this carries over to the abductive systems which reduce the problem to a clp problem and then use the clp solver to search for the solution .",
    "we used a graph generator program which is available from address http://web.cs.ualberta.ca/~joe/coloring/generators/generate.html .",
    "we did our experiments with planar undirected graphs which are known to be 4-colorable .",
    "the graphs were generated using a 20% probability of assigning arcs .",
    "this results in dense graphs with a stable behavior . for this problem ,",
    "the domain of the solution variables ( the number of colors ) remained the same and we have modified only the parameter of the problem ( the number of vertices ) and consequently the number of constraints ( arcs ) .",
    "figure [ fig : gc ] gives the results of solving the problem with the different systems .",
    "both axes are plotted in a logarithmic scale . on the x - axis",
    "we have put the number of arcs ( constraints ) instead of the number of vertices .    not surprisingly , clp is the fastest system .",
    "_ smodels _  is second best on this problem . we assume it is in part because of the very concise formulation .",
    "using the so called technique of rules with exceptions @xcite , the two rules needed to describe the space of candidate solutions also encode the constraint that the color is a function of the vertex .",
    "hence there is only one other rule , namely the constraint that two adjacent vertices must have a different color .",
    "the difference with clp is almost two orders of magnitude for the largest problems .",
    "sldnfac is slightly worse than _",
    "smodels_. although meta - interpretation overhead tends to increase with problems size , the difference with _ smodels",
    "_  grows very slowly .",
    "the model generator sem deteriorates much faster and runs out of memory for the larger problems .",
    "the fact that it grounds the whole theory is a likely explanation .",
    "the difference with _ smodels",
    "_  supports the claim that _ smodels _  has better techniques for grounding .",
    "aclp performs substantially worse than sldnfa and also deteriorates faster .",
    "the examples which we have considered in this paper are by no ways representative",
    ". however we think that they still show some interesting features and limitations of the considered systems .",
    "consistency algorithms are a very efficient way for solving csp .",
    "constraint logic programming allows this techniques to be integrated in a natural and clear way to logic programs .",
    "however , as argued parameterized csps can not be represented in a declarative way as clp(fd ) programs . using abduction or stable models as the basis for logic programming allows the problems to be represented in a more declarative way and the recent integration of abduction with clp allows the same consistency techniques to be used for solving the problems . at the moment ,",
    "such systems are implemented as meta - interpreters on top of prolog and they essentially reduce a problem to the same set of constraints ( in many cases without backtracking ) which would be produced by the corresponding constraint logic program .",
    "our experiments suggest that the overhead of an abductive system is small and acceptable .",
    "moreover they can also solve other classes of problems which require non - monotonic reasoning like planning problems .",
    "we also showed that there is a very close relation between the semantics and the problem representation of abduction and logic programming with stable model semantics .",
    "the only difference is in the reasoning techniques - abduction is usually done by a top - down proof procedure , while a stable model is usually computed by a bottom - up procedure .",
    "however , the techniques used to compute a stable model of a program do not seem to be so well suited for solving csps .",
    "one reason could be that they work on a ground propositional programs which tend to be large and grow fast as the parameter of the problem increases .",
    "this suggests that an interesting area for further research would be a framework for computing stable models of constraint logic programs with the help of constraint solving techniques . some work has already been done in this direction @xcite .",
    "we argued earlier in the paper that the most natural way for representing csps is with functions with open interpretation . hence it would be interesting to consider extensions of the clp scheme which directly support such form of reasoning .",
    "some work in this area is done in @xcite .",
    "we want to thank the members of the dtai group at k.u.leuven and anonymous referees for their useful comments .",
    "this research is supported by the goa project lp+ .",
    "the third author is supported by fwo - vlaanderen .",
    "bruynooghe , m. ; pelov , n. ; and denecker , m. 1999 . towards a more declarative language for solving finite domain problems . in apt , k. ;",
    "kakas , a. ; monfroy , e. ; and rossi , f. , eds . , _ proceedings of the ercim / compulog workshop on constraints_. paphos , cyprus : university of cyprus .",
    "cadoli , m. ; palopoli , l. ; schaerf , a. ; and vasile , d. 1999 .",
    "np - spec : an executable specification language for solving all problems in np . in gupta , g. ,",
    "1st international workshop on practical aspects of declarative languages _ ,",
    "volume 1551 of _ lecture notes in computer science _ , 1630 .",
    "san antonio , texas , usa : springer - verlag .",
    "denecker , m. , and van  nuffelen , b. 1999 .",
    "experiments for integration clp and abduction . in apt , k. ;",
    "kakas , a. ; monfroy , e. ; and rossi , f. , eds . , _ proceedings of the 1999 ercim / compulog workshop on constraints_. paphos , cyprus : university of cyprus .",
    "eiter , t. ; lu , j.  j. ; and subrahmanian , v.  s. 1997 . computing non - ground representations of stable models . in dix ,",
    "j. ; furbach , u. ; and nerode , a. , eds .",
    ", _ proceedings of the fourth international conference on logic programming and non - monotonic reasoning _ , volume 1265 of _ lecture nortes in computer science _ , 198217 .",
    "dagstuhl , germany .",
    "eshghi , k. , and kowalski , r. 1989 . abduction compared with negation by failure . in levi , g. , and martelli , m. , eds .",
    ", _ proceedings of the sixth international conference on logic programming _ , 234254 .",
    "lisbon , portugal .",
    "gelfond , m. , and lifschitz , v. 1988 .",
    "the stable model semantics for logic programming . in kowalski , r.  a. , and bowen , k.  a. , eds .",
    ", _ logic programming , proceedings of the fifth international conference and symposium _ , 10701080 .",
    "seattle , washington : mit press .",
    "kakas , a.  c. , and michael , a. 1995 . integrating abductive and constraint logic programming . in sterling , l. , ed . ,",
    "_ proceedings of the 12th international conference on logic programming _ , 399413 .",
    "tokyo , japan .",
    "niemel , i. , and simons , p. 1996 .",
    "efficient implementation of the well - founded and stable model semantics . in maher , m. , ed .",
    ", _ logic programming , proceedings of the 1996 joint international conference and syposium _ , 289303 .",
    "bonn , germany : mit press .",
    "zhang , j. , and zhang , h. 1995 . : a system for enumerating models . in mellish , c.  s. , ed .",
    ", _ proceedings of the fourteenth international joint conference on artificial intelligence _ , 298303 .",
    "san mateo : morgan kaufmann ."
  ],
  "abstract_text": [
    "<S> many logic programming based approaches can be used to describe and solve combinatorial search problems . on the one hand </S>",
    "<S> there are definite programs and constraint logic programs that compute a solution as an answer substitution to a query containing the variables of the constraint satisfaction problem . </S>",
    "<S> on the other hand there are approaches based on stable model semantics , abduction , and first - order logic model generation that compute solutions as models of some theory . </S>",
    "<S> this paper compares these different approaches from point of view of knowledge representation ( how declarative are the programs ) and from point of view of performance ( how good are they at solving typical problems ) . </S>"
  ]
}