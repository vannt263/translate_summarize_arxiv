{
  "article_text": [
    "automated reasoning in description logics ( dls ) has been an active research area for more than two decades .",
    "it is useful , for example , for the semantic web in engineering and querying ontologies  @xcite .",
    "one of basic reasoning problems in dls is to check satisfiability of a knowledge base in a considered dl .",
    "most of other reasoning problems in dls are reducible to this one  @xcite . in this paper",
    "we study the problem of checking satisfiability of a knowledge base in the dl @xmath0 , which extends the basic dl @xmath1with transitive roles , hierarchies of roles , inverse roles and quantified number restrictions .",
    "tobies in his phd thesis  @xcite proved that the problem is exptime - complete ( even when numbers are coded in binary ) .",
    "on page  127 of  @xcite he wrote : _",
    "`` the previous exptime - completeness results for @xmath0rely on the highly inefficient automata construction of definition  4.34 used to prove theorem  4.38 and , in the case of knowledge base reasoning , also on the wasteful pre - completion technique used to prove theorem  4.42 .",
    "thus , we can not expect to obtain an implementation from these algorithms that exhibits acceptable runtimes even on relatively `` easy '' instances .",
    "this , of course , is a prerequisite for using shiq in real - world applications . '' _    together with horrocks and sattler ,",
    "tobies therefore developed a tableau decision procedure for @xmath0  @xcite .",
    "later , in  @xcite horrocks and sattler gave a tableau decision procedure for @xmath2 , and in  @xcite horrocks et al .",
    "gave a tableau decision procedure for @xmath3 .",
    "both the logics @xmath2and @xmath3are more expressive than @xmath0 , but they also have higher complexity ( @xmath2is nexptime - complete and @xmath3is n2exptime - complete ) . according to the recent survey  @xcite , the third generation ontology reasoners that support @xmath0or @xmath3are fact , fact++ , racer , pellet , kaon2 and hermit .",
    "the reasoners fact , fact++ , racer and pellet are based on tableaux like the ones in  @xcite , kaon2 is based on a translation into disjunctive datalog  @xcite , and hermit is based on hypertableaux  @xcite .",
    "traditional tableau decision procedures like the ones in  @xcite can be implemented with various optimization techniques to increase efficiency .",
    "however , such procedures use backtracking to deal with disjunction ( @xmath4 ) and `` or''-branching ( e.g. , the `` choice '' operation  @xcite ) and despite advanced blocking techniques ( e.g. , pairwise anywhere blocking  @xcite ) , their complexities are non - optimal . in particular , the decision procedure for @xmath0given in  @xcite has complexity nexptimewhen unary representation is used for numbers , and has complexity n2exptimewhen binary representation is used .    by applying global caching  @xcite , together with colleagues (",
    "gor , szaas and dunin - kplicz ) we have developed complexity - optimal ( exptime ) tableau decision procedures for several modal and description logics with exptimecomplexity  @xcite . in  @xcite analytic cuts",
    "are used to deal with inverse roles and converse modal operators . as cuts",
    "may be not efficient in practice , gor and widmann developed the first cut - free exptimetableau decision procedures , based on global state caching , for the dl @xmath5(for the case without aboxes ) @xcite and cpdl  @xcite .",
    "we have applied global state caching for the modal logic cpdl@xmath6  @xcite and the dls @xmath5",
    "@xcite and @xmath7  @xcite for the case with aboxes to obtain cut - free exptimetableau decision procedures for them .    as @xmath0is a well - known and useful dl , developing a complexity - optimal tableau decision procedure for checking satisfiability of a knowledge base in @xmath0is very desirable .",
    "the lack of such a procedure in a relatively long period up to the current work suggests that the problem is not easy at all .",
    "for example , in  @xcite gor and widmann wrote _",
    "`` the extension to role hierarchies and transitive roles should not present difficulties , but the extension to include nominals and qualified number restrictions is not obvious to us . '' . _    in this paper",
    "we give the first exptimetableau decision procedure for checking satisfiability of a knowledge base in the dl @xmath0 .",
    "the complexity is measured using binary representation for numbers .",
    "our procedure is based on global state caching and integer linear feasibility checking .",
    "both of them are essential for our procedure in order to have the optimal complexity .",
    "global state caching can be replaced by global caching plus cuts , which still guarantee the optimal complexity .",
    "however , we choose global state caching to avoid inefficient cuts although it makes our procedure more complicated .",
    "we are aware of only farsiniamarj s master thesis  @xcite ( written under supervision of haarslev ) as a work that directly combines tableaux with integer programming",
    ". some related works  @xcite are discussed in that thesis and we refer the reader there for details . in  @xcite farsiniamarj presented a hybrid tableau calculus for the dl @xmath8(a restricted version of @xmath0without inverse roles ) , which is based on the so - called atomic decomposition technique and combines arithmetic and logical reasoning .",
    "he stated that _",
    "`` the most prominent feature of this hybrid calculus is that it reduces reasoning about qualified number restrictions to integer linear programming . [  ] in comparison to other standard description logic reasoners , our approach demonstrates an overall runtime improvement of several orders of magnitude . '' _  @xcite . on the complexity matter ,",
    "farsiniamarj wrote _ `` the complexity of the algorithm seems to be characterized by a double - exponential function '' _ @xcite .",
    "that is , his algorithm for @xmath8is not complexity - optimal .    combining global ( state ) caching and integer linear feasibility checking to obtain a complexity - optimal ( exptime ) tableau decision procedure for @xmath0is not a simple exercise as one might think .",
    "integer linear programming using the branch and bound method  @xcite is known since 1960 , pratt s idea on global caching for pdl  @xcite is known since 1980 ( the term `` global caching '' is absent in  @xcite ) , a formal formulation of global caching for some modal and description logics  @xcite is known since 2007 ( if not earlier  @xcite ) , but the first complexity - optimal ( exptime ) tableau decision procedure for @xmath0is only proposed now , in the current paper .",
    "as for experts on tableaux with global caching , it took us a few months to make the idea of the combination precise and one year since our paper on @xmath7  @xcite to the current paper ( on @xmath0 ) .",
    "our method of exploiting integer linear programming is different from farsiniamarj s one  @xcite : in order to avoid nondeterminism , we only check feasibility but do not find and use solutions of the considered set of constraints as in  @xcite .",
    "the rest of this paper is structured as follows . in section  [ section : prel ]",
    "we recall the notation and semantics of @xmath0and introduce an integer feasibility problem for dls . in section",
    "[ section : calculus ] we present our tableau decision procedure for @xmath0 .",
    "we start by introducing data structures and the tableau framework . we then present illustrative examples .",
    "after that we specify our tableau rules in detail . at the end of the section we present theoretical results about our tableau decision procedure .",
    "those results are proved in section  [ section : proofs ] .",
    "we conclude this work in section  [ section : conc ] .",
    "our language uses a finite set @xmath9 of _ concept names _ , a finite set @xmath10 of _ role names _ , and a finite set @xmath11 of _ individual names_. we use letters like @xmath12 and @xmath13 for concept names , @xmath14 and @xmath15 for role names , and @xmath16 and @xmath17 for individual names .",
    "we refer to @xmath12 and @xmath13 also as _ atomic concepts _ , and to @xmath16 and @xmath17 as _",
    "individuals_.    for @xmath18 ,",
    "let @xmath19 be a new symbol , called the _",
    "inverse _ of @xmath14 .",
    "let @xmath20 @xmath21 be the set of _ inverse roles_. for @xmath18 , define @xmath22 .",
    "a _ role _ is any member of @xmath23 .",
    "we use letters like @xmath24 and @xmath25 to denote roles .",
    "an ( @xmath0 ) _ rbox _ @xmath26 is a finite set of role axioms of the form @xmath27 or @xmath28 .",
    "by @xmath29 we denote the least extension of @xmath26 such that :    * @xmath30 for any role @xmath24 * if @xmath31 then @xmath32 * if @xmath33 then @xmath34 * if @xmath31 and @xmath35 then @xmath36 .    by @xmath37 we mean @xmath38 , and by @xmath39 we mean @xmath40 .",
    "if @xmath37 then @xmath24 is a  _ subrole _ of @xmath25 ( w.r.t .",
    "@xmath26 ) . if @xmath39 then @xmath24 is a  _ transitive role _",
    "( w.r.t .",
    "@xmath26 ) .",
    "a  role is _ simple _",
    "( w.r.t .",
    "@xmath26 ) if it is neither transitive nor has any transitive subroles ( w.r.t .",
    "@xmath26 ) .",
    "_ concepts _ in @xmath0  are formed using the following bnf grammar , where @xmath41 is a nonnegative integer and @xmath25 is a simple role : @xmath42    we use letters like @xmath43 and @xmath44 to denote arbitrary concepts .",
    "a _ tbox _ is a  finite set of axioms of the form @xmath45 or @xmath46 .",
    "an _ abox _ is a  finite set of _ assertions _ of the form @xmath47 , @xmath48 or @xmath49 .",
    "a _ knowledge base _ in @xmath0  is a tuple @xmath50 , where @xmath26 is an rbox , @xmath51 is a  tbox and @xmath52 is an abox .",
    "we say that a role @xmath25 is _ numeric _ w.r.t .",
    "a knowledge base @xmath53 if :    * it is simple w.r.t .",
    "@xmath26 and occurs in a concept @xmath54 or @xmath55 in @xmath56 , or * @xmath57 and @xmath24 is numeric w.r.t .",
    "@xmath56 , or * @xmath58 is numeric w.r.t .",
    "@xmath56 .",
    "we will simply call such an @xmath25 a numeric role when @xmath56 is clear from the context .    a _ formula _ is defined to be either a concept or an abox assertion .",
    "we use letters like @xmath59 , @xmath60 and @xmath61 to denote formulas .",
    "let @xmath62 stand for @xmath43 .",
    "we use @xmath63 to denote either an individual or @xmath64 .",
    "thus , @xmath65 is a formula of the form @xmath47 or @xmath62 ( which means @xmath43 ) .    an _ interpretation _ @xmath66 consists of a  non - empty set @xmath67 , called the _",
    "domain _ of @xmath68 , and a  function @xmath69 , called the _ interpretation function _ of @xmath68 , that maps each concept name @xmath12 to a  subset @xmath70 of @xmath67 , each role name @xmath14 to a  binary relation @xmath71 on @xmath67 , and each individual name @xmath16 to an element @xmath72 .",
    "the interpretation function is extended to inverse roles and complex concepts as follows , where @xmath73 denotes the cardinality of a set  @xmath74 : @xmath75 ( \\lnot c)^{\\mathcal{i}}= \\delta^{\\mathcal{i}}- c^{\\mathcal{i}}\\quad\\quad       ( c { \\sqcap}d)^{\\mathcal{i}}= c^{\\mathcal{i}}\\cap d^{\\mathcal{i}}\\quad\\quad       ( c { \\sqcup}d)^{\\mathcal{i}}= c^{\\mathcal{i}}\\cup d^{\\mathcal{i}}\\\\[1.0ex ] ( { \\exists}r.c)^{\\mathcal{i}}=          \\big\\ { x \\in \\delta^{\\mathcal{i}}\\mid { \\exists}y\\big [ \\tuple{x , y } \\in r^{\\mathcal{i}}\\textrm { and } y \\in c^{\\mathcal{i}}\\big]\\big\\ } \\\\[1.0ex ] ( { \\forall}r.c)^{\\mathcal{i}}=          \\big\\ { x \\in \\delta^{\\mathcal{i}}\\mid { \\forall}y\\big [ \\tuple{x , y } \\in r^{\\mathcal{i}}\\textrm { implies } y \\in c^{\\mathcal{i}}\\big]\\big\\ } \\\\[1.0ex ] ( \\geq\\!n\\,r.c)^{\\mathcal{i}}=          \\big\\ { x \\in \\delta^{\\mathcal{i}}\\mid \\sharp\\{y \\mid \\tuple{x , y } \\in r^{\\mathcal{i}}\\textrm { and } y \\in c^{\\mathcal{i}}\\ } \\geq n \\big\\ } \\\\[1.0ex ] ( \\leq\\!n\\,r.c)^{\\mathcal{i}}=          \\big\\ { x \\in \\delta^{\\mathcal{i}}\\mid \\sharp\\{y \\mid \\tuple{x , y } \\in r^{\\mathcal{i}}\\textrm { and } y \\in c^{\\mathcal{i}}\\ } \\leq n \\big\\}. \\end{array}\\ ] ]    note that @xmath76 and this is compatible with @xmath77 .",
    "for a set @xmath78 of concepts , define @xmath79 .",
    "the relational composition of binary relations @xmath80 , @xmath81 is denoted by @xmath82 .",
    "an interpretation @xmath68 is a  _ model of an rbox _",
    "@xmath26 if for every axiom @xmath27 ( resp .",
    "@xmath28 ) of @xmath26 , we have that @xmath83 ( resp .",
    "@xmath84 ) .",
    "note that if @xmath68 is a model of @xmath26 then it is also a model of @xmath29 .",
    "an interpretation @xmath68 is a  _ model of a  tbox _",
    "@xmath51 if for every axiom @xmath85 ( resp .",
    "@xmath46 ) of @xmath51 , we have that @xmath86 ( resp .",
    "@xmath87 ) .",
    "an interpretation @xmath68 is a  _ model of an abox _",
    "@xmath52 if for every assertion @xmath47 ( resp .",
    "@xmath48 or @xmath49 ) of @xmath52 , we have that @xmath88 ( resp .",
    "@xmath89 or @xmath90 ) .",
    "an interpretation @xmath68 is a  _ model of a  knowledge base _",
    "@xmath50 if @xmath68 is a  model of all @xmath26 , @xmath51 and  @xmath52 .",
    "a knowledge base @xmath50 is _ satisfiable _ if it has a  model .",
    "an interpretation @xmath68 _ satisfies _ a concept @xmath43 ( resp .  a set @xmath91 of concepts ) if @xmath92 ( resp .",
    "@xmath93 ) . a set @xmath91 of concepts is _",
    "satisfiable w.r.t .",
    "an rbox @xmath26 and a tbox @xmath51 _ if there exists a model of @xmath26 and @xmath51 that satisfies @xmath91 . for @xmath94 , where @xmath52 is an abox and",
    "@xmath95 is a set of assertions of the form @xmath96 or @xmath97 , we say that @xmath91 is _",
    "satisfiable w.r.t .",
    "an rbox @xmath26 and a tbox @xmath51 _ if there exists a  model @xmath68 of @xmath50 such that : @xmath98 for all @xmath99 , and @xmath100 for all @xmath101 . in that case",
    ", we also say that @xmath68 is a model of @xmath102 .      for dealing with number restrictions in @xmath0 , we consider the following integer feasibility problem : @xmath103 x_j \\geq 0,\\       \\textrm { for } 1 \\leq j \\leq m ; \\end{array}\\ ] ] where each @xmath104 is either 0 or 1 , each @xmath105 is a variable standing for a natural number , each @xmath106 is either @xmath107 or @xmath108 , each @xmath109 is a natural number encoded by using no more than @xmath41 bits ( i.e. , @xmath110 ) .",
    "we call this an @xmath111-problem ( a  problem of integer feasibility for description logics with size specified by @xmath112 ) . the problem is _ feasible _ if it has a solution , and is _ infeasible _ otherwise . by solving an @xmath111-problem we mean checking its feasibility .",
    "[ lemma : ifdl ] if @xmath113 and @xmath114 are ( at most ) exponential in @xmath41 then every @xmath111-problem can be solved in ( at most ) exponential time in  @xmath41.@xmath115    assume that @xmath116 and @xmath114 are ( at most ) exponential in @xmath41 and consider any @xmath111-problem .",
    "let @xmath117 there exists @xmath118 with @xmath119 and @xmath120`@xmath107'@xmath121 . for each @xmath122",
    ", let @xmath123 and @xmath124 and we have that @xmath125 .",
    "for any @xmath126 , if @xmath119 then @xmath106 is @xmath108 and @xmath105 can be as big as we want .",
    "thus , without affecting feasibility of the problem we can delete constraint number @xmath127 if it uses some @xmath128 with @xmath129 .",
    "so , we assume that @xmath130 , which means we have a constraint @xmath125 for every variable  @xmath105 , where @xmath131 .",
    "now we can check feasibility of the problem by using the branch and bound method  @xcite .",
    "one round for branching and bounding runs in polynomial time in @xmath132 .",
    "each round reduces the sum of lengths of intervals for variables by 1 . as variables are bounded by @xmath133 and @xmath116 and @xmath114",
    "are ( at most ) exponential in @xmath41 , the checking can be done in ( at most ) exponential time in  @xmath41 . @xmath115",
    "we assume that concepts and abox assertions are represented in negation normal form ( nnf ) , where @xmath134 occurs only directly before atomic concepts .",
    "we use @xmath135 to denote the nnf of @xmath136 , and for @xmath137 , we use @xmath138 to denote @xmath139 . for simplicity ,",
    "we treat axioms of @xmath51 as concepts representing global assumptions : an axiom @xmath85 is treated as @xmath140 , while an axiom @xmath46 is treated as @xmath141 .",
    "that is , we assume that @xmath51 consists of concepts in nnf . thus , an interpretation @xmath68 is a  model of @xmath51 iff @xmath68 validates every concept @xmath142 . as this way of handling the tbox is not efficient in practice , the absorption technique like the one discussed in  @xcite can be used to improve the performance of our algorithm .",
    "we define tableaux as rooted graphs .",
    "such a graph is a tuple @xmath143 , where @xmath144 is a set of nodes , @xmath145 is a set of edges , @xmath146 is the root , and each node @xmath147 has a number of attributes .",
    "if there is an edge @xmath148 then we call @xmath149 a _ predecessor _ of @xmath150 , and call @xmath150 a _ successor _ of  @xmath149",
    ". attributes of tableau nodes are :    * @xmath151 .",
    "if @xmath152 then we call @xmath149 a _ state _ , else we call @xmath149 a _ non - state _ ( or an _ internal _ node ) . if @xmath152 and @xmath148 then @xmath153 . if @xmath148 and @xmath154 then @xmath149 has only @xmath150 as a successor .",
    "* @xmath155 is called the subtype of @xmath149 .",
    "if @xmath156 then we call @xmath149 a _ complex node _ , else we call @xmath149 a _ simple node_. the graph never contains edges from a simple node to a complex node . if @xmath157 is an edge from a complex node @xmath149 to a simple node @xmath150 then @xmath152 and @xmath153 . if @xmath152 and @xmath148 then @xmath158",
    ". the root of the graph is a complex node .",
    "* @xmath159 , @xmath160 , @xmath161 , @xmath162 , @xmath163 , @xmath164 , where @xmath160 and @xmath161 mean `` partially expanded '' and `` fully expanded '' , respectively .",
    "@xmath165 may be @xmath160 or @xmath162 only when @xmath152 .",
    "the status of a node may only be changed : * * from @xmath166 to any other status ; or * * from @xmath160 to @xmath161 , @xmath162 or @xmath163 ; or * * from @xmath161 to @xmath162 , @xmath163 or @xmath167 .",
    "+ the values @xmath162 , @xmath163 and @xmath167 are thus `` final '' . roughly speaking",
    ", @xmath163 means `` unsatisfiable '' and @xmath167 means `` satisfiable '' in a certain sense .",
    "* @xmath168 is a finite set of formulas , called the label of @xmath149 .",
    "the label of a complex node consists of abox assertions , while the label of a simple node consists of concepts .",
    "* @xmath169 is a finite set of formulas , called the set of reduced formulas of  @xmath149 .",
    "* @xmath170 is called the state - predecessor of @xmath149 .",
    "it is available only when @xmath171 . if @xmath149 is a non - state and @xmath172 has no paths connecting a state to @xmath149 then @xmath173",
    "otherwise , @xmath172 has exactly one state @xmath174 that is connected to @xmath149 via a path not containing any other states , and we have that @xmath175 .",
    "* @xmath176 is called the after - transition - predecessor of  @xmath149 .",
    "it is available only when @xmath171 and @xmath177 . in that case , if @xmath178 ( @xmath179 ) then there is exactly one successor @xmath180 of @xmath181 such that every path connecting @xmath181 to @xmath149 must go through @xmath180 , and we have that @xmath182 .",
    "we define @xmath183 .",
    "if @xmath184 holds then @xmath149 has exactly one predecessor @xmath174 and @xmath174 is a state .",
    "* @xmath185 is a tuple @xmath186 called the coming edge label of @xmath149 .",
    "it is available only when @xmath184 holds . in that case : * * @xmath187 ( the letter @xmath188 stands for `` type '' ) , * * @xmath189 ( is a set of roles ) , * * @xmath190 ( for @xmath191 being the only predecessor of  @xmath149 , if @xmath192 then @xmath193 is an individual , else @xmath194 ) .",
    "* @xmath195 is a set of formulas , called the set of formulas required by converse ( inverse ) for  @xmath149 .",
    "it is available only when @xmath152 .",
    "* @xmath196 is a formula , called the formula for branching on at @xmath149 .",
    "it is available only when @xmath152 and @xmath197 .",
    "* @xmath198 is a set of integer linear constraints .",
    "it is available only when @xmath152 .",
    "the constraints use variables @xmath199 indexed by successors @xmath150 of @xmath149 with @xmath200 .",
    "such a variable @xmath199 specifies how many copies of @xmath150 will be used as successors of  @xmath149 .",
    "we will use also new concept constructors @xmath201 and @xmath202 , where @xmath24 is a numeric role .",
    "the difference between @xmath201 and @xmath203 is that , for checking @xmath201 , we do not have to look to predecessors of the node .",
    "the aim for @xmath202 is similar .",
    "we use @xmath201 and @xmath202 only as syntactic representations of some expressions , and do not provide semantics for them .",
    "we define @xmath204    by the",
    "_ local graph _ of a state @xmath149 we mean the subgraph of @xmath172 consisting of all the paths starting from @xmath149 and not containing any other states .",
    "similarly , by the local graph of a non - state @xmath149 we mean the subgraph of @xmath172 consisting of all the paths starting from @xmath149 and not containing any states .",
    "we give here a further description / intuition about the structure of @xmath172 :    * if @xmath174 is a state of @xmath172 and @xmath205 are all successors of @xmath174 then : * * the local graph of each @xmath206 is a directed acyclic graph , * * if @xmath207 and @xmath208 then the local graphs of @xmath206 and @xmath209 are disjoint , * * the local graph of @xmath174 is a graph rooted at @xmath174 and consisting of the edges from @xmath174 to @xmath205 and the local graphs of @xmath205 , * * if @xmath150 is a node in the local graph of some @xmath206 then @xmath210 and @xmath211 .",
    "* if @xmath174 is a state of @xmath172 then : * * each edge from outside the local graph of @xmath174 to the local graph of @xmath174 must end at  @xmath174 , * * each edge outgoing from the local graph of @xmath174 must start from a non - state and is the only outgoing edge of that non - state .",
    "* @xmath172 consists of : * * the local graph of the root @xmath212 , * * the local graphs of states , * * edges coming to states . *",
    "each complex node of @xmath172 is like an abox ( more formally : its label is an abox ) , which can be treated as a graph whose vertices are named individuals . on the other hand , a simple node of @xmath172 stands for an unnamed individual . if there is an edge from a simple non - state @xmath149 to ( a simple node ) @xmath150 then @xmath149 and @xmath150 stand for the same unnamed individual .",
    "an edge from a complex node @xmath149 to a simple node @xmath150 with @xmath213 can be treated as an edge from the named individual @xmath16 ( an inner node of the graph representing @xmath149 ) to the unnamed individual corresponding to @xmath150 , and that edge is via the roles from @xmath214 .",
    "* @xmath172 consists of two layers : the layer of complex nodes and the layer of simple nodes .",
    "the former layer consists of the local graph of the root @xmath212 together with a number of complex states and edges coming to them .",
    "the edges from the layer of complex nodes to the layer of simple nodes are exactly the edges outgoing from those complex states .",
    "there are no edges from the layer of simple nodes to the layer of complex nodes .",
    "we apply global state caching : if @xmath180 and @xmath215 are different states then @xmath216 . if @xmath149 is a non - state such that @xmath184 holds then we also apply global caching for the local graph of @xmath149 : if @xmath217 and @xmath218 are different nodes of the local graph of @xmath149 then @xmath219 .",
    "creation of a new node or a new edge is done by procedures @xmath220 ( connect to a successor ) or @xmath221 ( new successor ) given on page  .",
    "these procedures create a connection from a node @xmath149 given as the first parameter to a node with attributes @xmath222 , @xmath223 , @xmath224 , @xmath225 , @xmath226 specified by the remaining parameters .",
    "the difference between these procedures is that @xmath221 always creates a new node and a new connection , while @xmath220 first checks whether there exists a node that can be used as a proxy for the successor to be created .",
    "@xmath221 is called outside @xmath220 only when @xmath149 ( the first parameter ) is a state .",
    "create a new node @xmath150 ,   @xmath227 ,     @xmath228 ,   @xmath229 ,   @xmath230 @xmath231 ,   @xmath232    @xmath233 +    from now on , let @xmath50 be a knowledge base in nnf of the logic @xmath0 , with @xmath234.@xmath235 is empty , we can add @xmath236 to it , where @xmath16 is a special individual . ] in this section we present a tableau calculus @xmath237for checking satisfiability of @xmath50 .",
    "a  @xmath237-tableau for @xmath50 is a rooted graph @xmath143 constructed as follows :      at the beginning , @xmath238 , @xmath239 , and @xmath212 is the root with @xmath240 , @xmath241 , @xmath242 , @xmath243 and @xmath16 is an individual occurring in @xmath244 , @xmath245 , @xmath246 .",
    "the graph is then expanded by the following rules , which will be specified shortly :    [ cols=\"^ , < \" , ]     each of the rules is parametrized by a node @xmath149 .",
    "we say that a rule is _ applicable _ to @xmath149 if it can be applied to @xmath149 to make changes to the graph . the rules ( ) , ( ) , ( ) ( in the first three items of the above list ) have highest priorities , and are ordered decreasingly by priority .",
    "if none of them is applicable to any node , then choose a node @xmath149 with status @xmath166 or @xmath160 , choose the first rule applicable to @xmath149 among the rules in the last four items of the above list , and apply it to @xmath149 .",
    "any strategy can be used for choosing @xmath149 , but it is worth to choose @xmath149 for expansion only when @xmath149 could affect the status of the root @xmath212 of the graph , i.e. , only when there may exist a path from @xmath212 to @xmath149 without any node of status @xmath162 , @xmath163 or @xmath167 .",
    "note that the priorities of the rules are specified by the order in the above list , but the rules ( ) , ( ) , ( ) are checked globally ( technically , they are triggered immediately when possible ) , while the remaining rules are checked for a chosen node .",
    "the construction of the graph ends when the root @xmath212 receives status @xmath163 or @xmath167 or when every node that may affect the status of @xmath212 ( i.e. , reachable from @xmath212 via a path without nodes with status @xmath162 , @xmath163 or @xmath167 ) has been fully expanded ( i.e. , has status @xmath161 ) .    [",
    "remark : main intuition ] to give a deeper intuition behind the structure of a @xmath237-tableau @xmath172 constructed for a knowledge base @xmath53 , assume that the knowledge base is satisfiable and let us briefly describe how a model @xmath68 for @xmath56 can be constructed from @xmath172 .",
    "a precise description will be given in the proof of completeness of the calculus .",
    "as we will see , the root @xmath212 must have status different from @xmath163 and there exists a complex state @xmath247 with status different from @xmath163 .",
    "@xmath248 is an abox that forms the base for the constructed model @xmath68 .",
    "each named individual @xmath16 occurring in that abox is used as an element of the domain of @xmath68 ; role assertions in that abox specify edges between those elements in @xmath68 ; concept assertions in that abox specify whether a named individual @xmath16 is an instance of a given atomic concept in @xmath68 .",
    "the rest of @xmath68 consists of disjoint trees rooted at those named elements , which may be infinite .",
    "each element of the domain of @xmath68 corresponds either to one of those named individuals or to a simple state of @xmath172 with status different from @xmath163 .",
    "it is possible that only a number of simple states of @xmath172 are used for constructing @xmath68 , and each simple state of @xmath172 may correspond to many elements of the domain of  @xmath68 ( due to global state caching ) .",
    "let @xmath249 be an element of the domain of @xmath68 .",
    "how successors of @xmath249 in @xmath68 can be constructed ?",
    "if @xmath249 corresponds to a named individual @xmath16 then let @xmath250 be the set of successors @xmath150 of @xmath247 such that : either @xmath251 and we set @xmath252 ; or @xmath200 , @xmath213 and the value of @xmath199 in a fixed solution for @xmath253 , denoted by @xmath254 , is greater than  0 .",
    "if @xmath249 corresponds to a simple state @xmath174 of @xmath172 then let @xmath250 be the set of successors @xmath150 of @xmath174 such that : either @xmath251 and we set @xmath252 ; or @xmath200 and the value of @xmath199 in a fixed solution for @xmath255 , denoted by @xmath254 , is greater than  0 .    for each @xmath256",
    ", there must exist a path in @xmath172 starting from ( the non - state ) @xmath150 , going through some or zero other non - states and ending at a state @xmath257 with status different from @xmath163 . for each @xmath256",
    ", we create @xmath254 successors for @xmath249 ( in @xmath68 ) that correspond to @xmath257 , using edges labeled by the roles from @xmath214 .",
    "roughly speaking , all nodes in the path from @xmath150 to @xmath257 are stitched together to make a successor for @xmath249 , which is then cloned @xmath254 times .",
    "the set of atomic concepts such a successor must be an instance of in @xmath68 consists of the atomic concepts in @xmath258 .",
    "notice that non - states are like `` or''-nodes , while states are more sophisticated than `` and''-nodes .",
    "the transitional partial - expansion rule deals with non - numeric roles , while the transitional full - expansion rule deals with numeric roles .",
    "@xmath115      before specifying the tableau rules in detail , we present simple examples to illustrate some ideas ( but not all aspects ) of our method . despite",
    "that these examples refer to the tableau rules , we choose this place for presenting them because the examples are quite intuitive and the reader can catch the ideas of our method without knowing the detailed rules .",
    "he or she can always consult the rules in the next subsection .",
    "c    c@c ( a ) & ( b ) +   + &    c    [ ex : andorgraph ] this example is based on an example in the long version of our paper  @xcite on @xmath7 .",
    "let @xmath259 in figures  [ fig : example0 ] and [ fig : example0-ii ] we illustrate the construction of a @xmath237-tableau for the knowledge base @xmath50 . at the end the root @xmath212 receives status @xmath163 . by theorem  [ theorem : s - c ] given later in this paper",
    ", @xmath50 is unsatisfiable . as a consequence ,",
    "@xmath260 is also unsatisfiable .",
    "@xmath115    [ example2 ]",
    "let us construct a @xmath237-tableau for @xmath50 , where @xmath261 , @xmath262 and @xmath263    .",
    "the marked nodes @xmath264 , @xmath265 , @xmath266 , @xmath267 are states . [ fig-2 ] ]    an illustration of the tableau is given in figure  [ fig-2 ] .    at the beginning",
    ", the graph has only the root @xmath212 which is a complex non - state with .    since @xmath268 ,",
    "applying the unary static expansion rule to @xmath212 , we connect it to a new complex non - state @xmath180 with @xmath269 .    since @xmath270 ,",
    "applying the non - unary static expansion rule to @xmath180 , we connect it to two new complex non - states @xmath215 and @xmath271 with @xmath272    since both @xmath273 and @xmath274 belong to @xmath275 , the node @xmath215 receives status @xmath163 .    applying the forming - state rule ( ) to @xmath271 , we connect it to a new complex state @xmath264 with @xmath276 the assertion @xmath277 is due to @xmath278 and the fact that @xmath279 , @xmath280 .",
    "the assertion @xmath281 is due to @xmath282 and the fact that @xmath283 .",
    "similarly , the assertion @xmath284 is due to @xmath285 and the fact that @xmath286 . when realizing the requirements for @xmath16 at @xmath264 , we will not have to pay attention to the relationship between @xmath16 and @xmath17 .    applying the transitional partial - expansion rule to @xmath264",
    ", we change its status to @xmath160 .",
    "after that , applying the transitional full - expansion rule to @xmath264 , we connect it to new simple non - states @xmath287 , @xmath288 and @xmath289 with @xmath290 equal to @xmath291 , @xmath292 equal to @xmath293 , @xmath294 equal to @xmath16 , @xmath295 , @xmath296 and @xmath297 .",
    "the creation of @xmath287 is caused by @xmath281 , while the creation of @xmath288 is caused by .",
    "the node @xmath289 results from merging @xmath287 and @xmath288 .",
    "furthermore , @xmath298 consists of @xmath299 , for @xmath300 , and @xmath301    the set @xmath298 is feasible , e.g. , with @xmath302 and @xmath303 .    applying the forming - state rule ( ) to @xmath287 ( resp .",
    "@xmath288 , @xmath289 ) , we connect it to a new simple state @xmath265 ( resp .",
    "@xmath266 , @xmath267 ) with the same label .    expanding the nodes @xmath265 , @xmath266 and @xmath267 , their statuses change to @xmath160 and then to @xmath161 .",
    "the graph can not be modified anymore and becomes a @xmath237-tableau for @xmath50 , with @xmath304 . by theorem  [ theorem : s - c ] ( given later in this paper )",
    ", the considered knowledge base @xmath50 is satisfiable . using the solution @xmath302 , @xmath303 for @xmath298",
    ", we can extract from the graph a model @xmath68 for @xmath50 with @xmath305 , @xmath306 , @xmath307 , @xmath308 , @xmath309 , @xmath310 and @xmath311 .",
    "@xmath115    [ example1 ] let us construct a @xmath237-tableau for @xmath50 , where @xmath261 , @xmath262 and @xmath312    an illustration of the tableau is given in figure  [ fig-1 ] .    .",
    "]    at the beginning , the graph has only the root @xmath212 which is a complex non - state with @xmath313 . applying the forming - state rule ( ) to @xmath212",
    ", we connect it to a new complex state @xmath180 with @xmath314    applying the transitional partial - expansion rule to @xmath180 , we change its status to @xmath160 . after that , applying the transitional full - expansion rule to @xmath180 , connect it to new simple non - states @xmath315 with @xmath290 equal to @xmath291 , @xmath292 equal to @xmath293 , @xmath294 equal to @xmath16 , and @xmath316 note that @xmath317 is the nnf of @xmath318 .",
    "the nodes @xmath215 and @xmath271 are created due to @xmath319 . the nodes @xmath264 and @xmath287 are created due to @xmath320 .",
    "the node @xmath288 results from merging @xmath215 and @xmath264 .",
    "the node @xmath289 results from merging @xmath271 and @xmath287 .",
    "furthermore , @xmath321 consists of @xmath299 , for @xmath322 , and @xmath323    applying the unary static expansion rule to @xmath271 , we connect it to a new simple non - state @xmath265 with @xmath324 .",
    "the status of @xmath265 is then updated to @xmath163 and propagated back to make the status of @xmath271 also become @xmath163 , which causes addition of the constraint @xmath325 into the set @xmath321 .    similarly , applying the unary static expansion rule to @xmath287 ,",
    "we connect it to a new simple non - state @xmath266 with @xmath326 . the status of @xmath266 is then updated to @xmath163 and propagated back to make the status of @xmath287 also become @xmath163 , which causes addition of the constraint @xmath302 into the set @xmath321 .    applying the non - unary static expansion rule to @xmath288 ,",
    "we connect it to new simple non - states @xmath267 and @xmath327 with @xmath328 and @xmath329 .",
    "the statuses of @xmath267 and @xmath327 are then updated to @xmath163 and propagated back to make the status of @xmath288 also become @xmath163 , which causes addition of the constraint @xmath330 into the set @xmath321 .    applying the unary static expansion rule to @xmath289 ,",
    "we connect it to a new simple non - state @xmath331 with @xmath332 .",
    "the status of @xmath331 is then updated to @xmath163 and propagated back to make the status of @xmath289 also become @xmath163 , which causes addition of the constraint @xmath333 into the set @xmath321 .    with @xmath334 ,",
    "@xmath321 becomes infeasible , and @xmath335 becomes @xmath163 . consequently , @xmath212 receives status @xmath163 . by theorem  [ theorem : s - c ] ( given later in this paper )",
    ", the considered knowledge base @xmath50 is unsatisfiable .",
    "@xmath115      in this section",
    "we formally specify the tableau rules of our calculus @xmath237 .",
    "we also give explanations for them .",
    "they are informal and should be understood in the context of the described rule .",
    "( ): :    the first rule is as follows :    +    1 .   if there exists    @xmath336 or    @xmath337    then @xmath338    2 .",
    "else if there exists    @xmath339 then    @xmath338    3 .   else if    @xmath171 ,    @xmath156 ,    @xmath340 and there    are @xmath341 such that , for all    @xmath342 with @xmath208 , we have    that @xmath343 and    @xmath344    then @xmath338    4 .   else if @xmath152 ,    @xmath345    and @xmath198 is infeasible then    @xmath338    5 .   else",
    "if @xmath152 ,    @xmath345    and @xmath149 has no successors then    @xmath346 .",
    "+    this rule is applied to @xmath149 only when @xmath149 was    created or modified in the previous step .",
    "+    as stated earlier , informally , @xmath163 means    `` unsatisfiable '' and @xmath167 means    `` satisfiable '' in a certain sense .",
    "the above rule is thus intuitive .    for a formal characterization of statuses , we refer the reader to    lemma  [ lemma : shqwd ] ( given on page  ) .",
    "@xmath115 ( ): :    the second rule states that , if @xmath149 is a predecessor of a    node @xmath150 then , whenever the status of @xmath150    changes to @xmath163 or    @xmath167 , the status of @xmath149 should be    updated ( as soon as possible by using a priority queue of tasks ) . the    update is done as follows :    +    1 .   if    @xmath171 then    1 .",
    "[ item : iuqkd ] if some successor of @xmath149 received status    @xmath167 then    @xmath346    2 .   else",
    "if all successors of @xmath149 have status    @xmath163 then    1 .   [ item : oiwgs ]    @xmath338    2 .",
    "[ item : ofdsh ] if @xmath184 holds ,    @xmath347 ,    @xmath175 then add the constraint    @xmath348 into the set    @xmath255    2 .",
    "else    1 .",
    "[ item : yuwqp ] if some successor @xmath150 of @xmath149    with    @xmath251    received status @xmath163 then    @xmath338    2 .",
    "[ item : hruia ] else if some successor @xmath150 of    @xmath149 with    @xmath200    received status @xmath163 and    @xmath198 is infeasible then    @xmath338    3 .   [",
    "item : hfdde ] else if    * @xmath345 ,    * all successors @xmath150 of @xmath149 with    @xmath251    have status @xmath167 , and    * @xmath349    @xmath148 ,    @xmath200    and @xmath350 is    feasible    +    then @xmath346 .",
    "+       +    * a non - state is like an `` or''-node , whose status is the disjunction    of the statuses of its successors , treating    @xmath167 as @xmath351 and    @xmath163 as @xmath352 .",
    "this explains the items [ item : iuqkd ] and [ item : oiwgs ] .    *",
    "a state @xmath149 is more sophisticated than an `` and''-node .",
    "its status is different from @xmath163 iff the    following conditions hold :    * * all of its successors with @xmath290 equal    to @xmath353 have status different    from @xmath163 ,    * * @xmath349    @xmath148 ,    @xmath200    and @xmath354 is    feasible .    +    the first condition explains the item  [ item : yuwqp ] .",
    "the second    condition explains the item  [ item : hruia ] because , whenever a    successor @xmath150 of @xmath149 with    @xmath290 equal to    @xmath291 receives status    @xmath163 , the constraint @xmath355    is added into @xmath198 ( see the    item  [ item : ofdsh ] ) .",
    "the item  [ item : hfdde ] is justifiable since the    premises of the rule expressed by that item are stronger than the    conditions listed above .",
    "@xmath115      ( ): :    if @xmath171    and @xmath356 then    +    1 .",
    "let    @xmath357 is    of the form @xmath358 or @xmath359    or @xmath360    2 .",
    "let    @xmath361 +    @xmath362 +    @xmath363 +    @xmath364 +    @xmath365 +    @xmath366 +    @xmath367 +    @xmath368    3 .   if @xmath369 then    1 .   @xmath370    2 .",
    "@xmath371 .",
    "+    this rule makes a necessary expansion for a non - state @xmath149    by connecting it to only one successor @xmath150 which is a copy    of @xmath150 with intuitive changes like :    +    * if @xmath372    then @xmath373 in    @xmath374 is replaced by    @xmath375 and @xmath376 and we    remember this by adding it into @xmath377 ;    * if    @xmath378    then we add @xmath379 into    @xmath374 ; and so on .    +    note that    @xmath380 .",
    "that is , @xmath150 contains some `` new '' formulas .",
    "this is to    guarantee that the local graph of any non - state is acyclic",
    ".    @xmath115      rules of this kind are listed below in the decreasing order w.r.t .",
    "priority :    ( ): :    if @xmath381 and    @xmath197 then    +    1 .",
    "( we must have that    @xmath152 and    @xmath382 )    2 .",
    "delete the edge @xmath383 from @xmath384 and    re - expand @xmath174 as follows    3 .   if @xmath385 then    1 .   @xmath386    2 .",
    "@xmath387    4 .",
    "else    1 .",
    "@xmath388    2 .   @xmath389    3 .",
    "@xmath390    4 .",
    "@xmath391 .",
    "+    we have that @xmath149 is a state with status    @xmath162 and it is the only successor of    @xmath174 .",
    "the first expansion of @xmath174 ( by connecting    to @xmath149 ) was not a good move and we re - expand    @xmath174 ( only once ) as follows .",
    "we first delete the edge    @xmath383 .",
    "next , if    @xmath385 ( i.e. , there are    formulas that should be added into @xmath149 ) , then we connect    @xmath174 to a node with label equal to    @xmath392 ( this node    is a replacement for @xmath149 ) .",
    "if    @xmath393 then the reason of    @xmath197 is that we    wanted to have either @xmath196 or its    negation in @xmath168 .",
    "so , in that case we    connect @xmath174 to two successors , one with label    @xmath394 and the    other with label    @xmath395 .",
    "the node @xmath149 is useful for later : whenever we expand a    node @xmath396 using the forming - state rule by connecting it to    @xmath149 we know immediately that we should re - expand it .",
    "the    other nodes in the local graph of @xmath149 can be deleted to    save memory .",
    "however , we keep them for our presentation to make the    proofs easier .",
    "@xmath115 ( ): :    if @xmath152 ,    @xmath397    and only the rules for updating status and the unary static rule were    applied to the nodes in the local graph of @xmath149 that are    different from @xmath149 then    +    1 .   @xmath398    2 .   for each node @xmath150 in the local graph of    @xmath149",
    "do    1 .",
    "let @xmath399 and    @xmath400    2 .",
    "@xmath401 there exist    @xmath402 ,    @xmath403 and    @xmath404    3 .",
    "@xmath405    @xmath402 ,    @xmath39 ,    @xmath403 and    @xmath406    3 .   if @xmath407 then set    @xmath408 and    @xmath409 .",
    "+    [ exp : hgrew ] assume that the considered knowledge base is satisfiable    and has a model @xmath68 that satisfies    @xmath168 .",
    "consider the following cases :    +    * case @xmath149 is a simple state and    @xmath410 : thus , @xmath149    corresponds to an unnamed individual    @xmath411 , while @xmath150    corresponds to an @xmath24-successor @xmath412 of    @xmath413 in @xmath68 .",
    "if    @xmath403 then :    @xmath414 and hence    @xmath415 , and for that reason we want to    have @xmath43 in @xmath416 as a requirement    to be realized ; so , if @xmath417 then the    status of @xmath149 becomes @xmath162    and we add @xmath43 into @xmath195 as    a concept required for @xmath149 for converse compatibility .",
    "if    @xmath403 and    @xmath24 is a transitive role then : @xmath418 is also    transitive and we also have    @xmath419 ; so , analogously ,    if @xmath420 then the status    of @xmath149 becomes @xmath162 and we    add @xmath421 into    @xmath195 .",
    "* case @xmath149 is a complex state and    @xmath422 : thus , @xmath149 corresponds to an abox    with that individual  @xmath16 .",
    "the node @xmath150    corresponds to an @xmath24-successor @xmath412 of    @xmath423 in @xmath68 .",
    "if    @xmath403 then :    @xmath414 and hence    @xmath88 , and for that reason    we want to have @xmath47 in @xmath416    as a requirement to be realized ; so , if    @xmath424 then the status of    @xmath149 becomes @xmath162 and we add    @xmath47 into @xmath195 as an    assertion required for @xmath149 for converse compatibility .",
    "if    @xmath425 and    @xmath24 is a transitive role then : @xmath418 is also    transitive and we also have    @xmath426 ; so ,    analogously , if    @xmath427 then the    status of @xmath149 becomes @xmath162    and we add @xmath428 into    @xmath195 .",
    "@xmath115 ( ): :    if @xmath429 ,    @xmath181 is a successor of @xmath174 with    @xmath430 and    @xmath431 , and @xmath149 is a    node in the local graph of @xmath181 with    @xmath432 and    @xmath433 then    +    1 .   if @xmath434 then    @xmath338    2 .   else if @xmath39 and    @xmath435    then",
    "@xmath338    3 .",
    "else if @xmath436 and    @xmath437 ,    @xmath438 then    @xmath439 and    @xmath440    4 .   else if @xmath39 and    @xmath441 and    @xmath437 ,    @xmath438 then set    @xmath439 and    @xmath442 .",
    "+    assume that the considered knowledge base is satisfiable and has a    model @xmath68 that satisfies    @xmath443 .",
    "we consider here only the case when    @xmath174 is a simple state and    @xmath410 .",
    "( the case when @xmath174    is a complex state and @xmath63 is a named individual is    similar , cf .",
    "explanation  [ exp : hgrew ] . )",
    "thus , @xmath174    corresponds to an unnamed individual    @xmath444 . in the constructed    tableau",
    ", there is an expansion path from @xmath174 via    @xmath181 to @xmath149 .",
    "the question is : whether that    expansion path should be taken into account , and if we should consider    that expansion path , what should be done for converse compatibility .",
    "note that : if    @xmath445    and @xmath446 then    @xmath181 is not used for the construction of    @xmath68 ; and if the path from @xmath181 to    @xmath149 uses some non - unary static expansions then    @xmath149 is just one of possible `` expansions '' of    @xmath181 .",
    "+    * if @xmath149 corresponds to an @xmath24-successor    @xmath413 of @xmath447 in @xmath68    then @xmath419 ( since    @xmath432 ) and hence    @xmath448 , which means we should require    @xmath449 .",
    "so , if    @xmath450 then the expansion path    from @xmath174 via @xmath181 to @xmath149 can not    be used and we set    @xmath338 to mark that    @xmath149 can not be used to realize the requirements of    @xmath174 .    * if @xmath24 is a transitive role and @xmath149    corresponds to an @xmath24-successor @xmath413 of    @xmath447 in @xmath68 then we also have    @xmath451 , which means we    should require @xmath452 .",
    "so , if    @xmath24 is transitive and    @xmath453 ( note that    @xmath454 is the negation of    @xmath421 ) then the expansion path from    @xmath174 via @xmath181 to @xmath149 can not be    used and we set    @xmath338 to mark that    @xmath149 can not be used to realize the requirements of    @xmath174 .    * in the other case ,",
    "if    @xmath432 and    @xmath455 then    we would like to have either @xmath43 or    @xmath456 in @xmath443 and    therefore set    @xmath439 and    @xmath457 ( as a concept for branching on    at @xmath174 ) .",
    "* in the other case , if @xmath24 is transitive ,    @xmath432 and    @xmath458    then we would like to have either @xmath421 or    @xmath454 in    @xmath443 and therefore set    @xmath439 and    @xmath459 ( as a concept for    branching on at @xmath174 ) .",
    "@xmath115 ( ): :    if @xmath174 is a state with    @xmath437 ,    @xmath438 , @xmath181 is a    successor of @xmath174 with    @xmath430 and    @xmath431 , @xmath149 is a    node in the local graph of @xmath181 such that    @xmath433 and    +    * either @xmath168 contains    @xmath460 ,    * or @xmath168 contains    @xmath461 or @xmath462 , where    @xmath24 is a numeric role ,    +    and    @xmath463 +    then set @xmath439    and @xmath440 .",
    "+    [ exp : jhres ] this rule deals with the case when there lacks    information at @xmath174 for deciding how to satisfy the number    restrictions of @xmath149 .",
    "we want to have either    @xmath65 or @xmath464    in @xmath465 .",
    "so , we set    @xmath439 and    @xmath440 ( as a formula for    branching on at @xmath174 ) .",
    "@xmath115 ( ): :    if @xmath174 is a state with    @xmath466 ,    @xmath181 is a successor of @xmath174 with    @xmath445 ,    @xmath431 and    @xmath430 , and @xmath149    is a node in the local graph of @xmath181 such that    +    * @xmath433 ,    @xmath168 contains    @xmath467 as well as @xmath468    or @xmath469 ,    * @xmath57 ,    @xmath470 ,    @xmath471 ,    @xmath472 ,    * @xmath473    +    then set @xmath439    and    @xmath474 . +    ( here , @xmath475 is @xmath476 annotated by    @xmath24 .",
    "semantically , @xmath475 is equivalent to    @xmath476 , i.e. ,    @xmath477    for every interpretation  @xmath68 .",
    "besides , let    @xmath478 and hence    @xmath479 . )",
    "+    [ exp : iusds ] assume that @xmath168 contains    @xmath59 which is either @xmath468    ( with @xmath480 ) or @xmath469 . to    realize the requirement @xmath59 at @xmath149 we    want to know whether @xmath174 can be used for that purpose .",
    "that is , we want ( @xmath481 and    @xmath482 ) or    @xmath470 or    @xmath483 . if    @xmath481 then the will to have    either @xmath375 or    @xmath484 in @xmath465    can be realized by the rule @xmath485 .",
    "if @xmath486    @xmath465 then @xmath174 can not be used to    realize the requirement @xmath59 at @xmath149 .",
    "consider the case when @xmath470    and @xmath472 .",
    "if    @xmath149 was treated as a state then to realize the requirement    @xmath59 at @xmath149 we would create an    @xmath58-successor @xmath150 of @xmath149 and put    @xmath44 to @xmath374 . as    @xmath57 , the node @xmath150    is also an @xmath418-successor of @xmath149 . since    @xmath487 and    @xmath471 , there may be the need to    merge @xmath150 to @xmath174 .",
    "such merging would add    @xmath25 into @xmath488 .",
    "however ,    our method does not merge nodes explicitly .",
    "roughly speaking , we want    to decide whether to add @xmath25 into    @xmath488 or not . to solve the problem ,    we set @xmath439 and    @xmath474 .",
    "later , if a state @xmath396 is a `` completion '' of    @xmath174 , then either    @xmath489 or    @xmath490 . if    @xmath490 then    @xmath396 will not have any @xmath25-successor . if    @xmath489    then @xmath396 will have some @xmath25-successor    @xmath491 with @xmath492 ,    and the occurrence of @xmath475 in    @xmath493 guarantees that the possibility of    merging @xmath491 to any @xmath24-successor of    @xmath396 will be considered by the transitional full - expansion    rule .",
    "@xmath115      ( ): :    if @xmath171    and @xmath356 then    +    1 .   [ item : jhrea ] if    @xmath494 and    @xmath495    then    1 .",
    "let    @xmath496    2 .",
    "let    @xmath497    3 .",
    "@xmath498    4 .",
    "@xmath499    5 .",
    "@xmath371    +    this subrule deals with syntactic branching on    @xmath494 .",
    "we    expand @xmath149 by connecting it to two successors    @xmath217 and @xmath218 , whose labels are the label of    @xmath149 with @xmath500 replaced    by @xmath65 or @xmath375 ,    respectively .",
    "the formula @xmath500 is    put into both @xmath501 and    @xmath502 .",
    "the expansion is done only when    both @xmath217 and @xmath218 have a larger    @xmath503 than @xmath149 .",
    "@xmath115    2 .",
    "[ item : hgw3a ] else if    @xmath156 ,    @xmath504 and    * either @xmath168 contains    @xmath505 ,    * or @xmath168 contains    @xmath506 or    @xmath507 , where @xmath24 is a numeric    role ,    +    and    @xmath508    then    1 .   @xmath509    2 .",
    "@xmath510    3 .",
    "@xmath371    +    this subrule deals with the case when there lacks information about    @xmath17 for deciding how to satisfy the number restrictions    about @xmath16 ( cf .",
    "explanation  [ exp : jhres ] ) .",
    "we want to have    either @xmath511 or @xmath512 in    @xmath416 .",
    "so , we expand @xmath149 by semantic    branching : we connect it to two successors , one with label    @xmath513 and the other with    label @xmath514 .    the expansion is done only when both the successors have a larger    @xmath503 than  @xmath149 .",
    "@xmath115    3 .   [ item : jheaa ] else if    @xmath156 ,    @xmath515 , @xmath48 ,    @xmath516 , @xmath511 ,    @xmath517 @xmath416 ,    @xmath518 and    @xmath519    then    1 .   let @xmath91 be the set obtained from    @xmath168 by replacing every occurrence of    @xmath520 by @xmath17    2 .",
    "let @xmath521 be the set obtained from    @xmath169 by replacing every occurrence of    @xmath520 not in @xmath522  expressions by    @xmath17    3 .",
    "[ item : hjsda ]    @xmath523    4 .",
    "@xmath524 ,    @xmath525 ,    @xmath526 ,    @xmath527 ,    @xmath169 , @xmath528    5 .",
    "@xmath371    +    this subrule deals with the case when there lacks information about    whether @xmath17 and @xmath520 denote the same    individual for deciding how to satisfy the number restrictions about    @xmath16 .",
    "we expand @xmath149 by semantic branching :    either @xmath17 and @xmath520 denote the same individual    or they do not .",
    "technically , we connect @xmath149 to two    successors with appropriate contents .",
    "the presence of    @xmath529 at the step  [ item : hjsda ] is just for making    the proofs easier and is not needed for correctness and completeness    of our @xmath237calculus .",
    "@xmath115    4 .",
    "[ item : osjrs ] else if    @xmath156 ,    @xmath530 ,    @xmath531 ,    @xmath168 contains or    @xmath532 with    @xmath57 , and    @xmath533    then    1 .",
    "@xmath534    2 .",
    "@xmath535    3 .",
    "@xmath371 .",
    "+    this subrule deals with the case when there lacks information for    deciding how to satisfy the number restrictions about @xmath16    ( cf .",
    "the rule  ( ) and explanation  [ exp : iusds ] ) .",
    "we want to decide    whether @xmath17 is an @xmath25-successor of    @xmath16 or not .",
    "so , we expand @xmath149 by semantic    branching : we connect it to two successors , one with label containing    @xmath536 and the other with @xmath225    containing @xmath537 . the expansion is done only when    both the successors have a larger @xmath503    than  @xmath149 . @xmath115      ( ): :    if @xmath171 ,    @xmath177 and    @xmath356 then    +    1 .",
    "let @xmath191 ,    @xmath538 and    @xmath539    2 .   set @xmath540    3 .",
    "for each @xmath541 do    1 .   if @xmath542 and    @xmath543 then add    @xmath544 into @xmath91    2 .   else add @xmath545 into @xmath91    4 .   for each @xmath546 with    @xmath547",
    "do    1 .",
    "if @xmath542 and    @xmath543 then add    @xmath548 into @xmath91    2 .   else add @xmath549 into @xmath91    5 .   for each @xmath550 or    @xmath551 from @xmath168 ,    where @xmath24 is a numeric role , do    1 .",
    "if @xmath552 or    @xmath553 then add    @xmath554 into @xmath91    6 .",
    "@xmath555    7 .",
    "@xmath371 .",
    "+    when the rules ( ) , ( ) and ( ) are not applicable ( to any node ) and the    rule ( ) is not applicable to @xmath149 , we apply this    forming - state rule to @xmath149 by connecting it to a simple    state @xmath150 .",
    "assume that the considered knowledge base is    satisfiable and has a model @xmath68 such that the    nodes @xmath149 and @xmath150 are used for the    construction of @xmath68 .",
    "in the constructed graph ,    such a state @xmath150 is globally cached and may have many    predecessors",
    ". however , the elements @xmath412 of the domain of    @xmath68 that correspond to @xmath150 are    nodes in disjoint trees ( cf .",
    "remark  [ remark : main intuition ] ) , and    each of them has only one predecessor @xmath447 , which    corresponds to @xmath174 . when computing contents for    @xmath150 we put into @xmath374 the    requirements from @xmath168 after an    appropriate modification that takes into account the relationship    between @xmath412 and @xmath447 , i.e. , the    relationship between @xmath149 and @xmath174 via    @xmath181 .",
    "for example , if    @xmath541 ,    @xmath542 and    @xmath543 then    @xmath556 ( which corresponds to all    @xmath150 , @xmath149 , @xmath181 ) already has the    @xmath24-successor @xmath557 , and    we have to guarantee only that @xmath412 has @xmath558    other @xmath24-successors satisfying @xmath44 ( i.e. ,    belonging to @xmath559 ) , and that is why we add    into @xmath374 the requirement    @xmath544 .",
    "notice the use of    @xmath560 instead of @xmath107 . also note that we    can assume    @xmath561    ( otherwise , there is no sense for expanding  @xmath149 ) and , as    the rule for keeping converse compatibility is not applicable , in that    case either @xmath375 or    @xmath484 belongs to    @xmath465 .",
    "@xmath115 ( ): :    if @xmath171 ,    @xmath156 and    @xmath356 then    +    1",
    ".   set @xmath540    2 .",
    "for each    @xmath562 do    1 .",
    "let    @xmath563    2 .",
    "add @xmath564 into @xmath91    3 .   for each @xmath565 , where    @xmath43 is @xmath566 or    @xmath551 and @xmath24",
    "is a numeric role , do    1 .",
    "if @xmath567 then let @xmath568    2 .   let    @xmath563    3 .   if @xmath569 then add    @xmath570 into @xmath91    4 .",
    "@xmath571    5 .   @xmath371 .",
    "+    when the rules ( ) , ( ) , ( ) and ( ) are not applicable to the complex    non - state @xmath149 , we apply this forming - state rule to    @xmath149 by connecting it to a complex state @xmath150 .    when computing contents for @xmath150 we put into    @xmath374 the requirements from    @xmath168 after an appropriate modification    that takes into account the assertions in    @xmath168 that represent the relationship    between named individuals .",
    "for example , if    @xmath562 and there    are @xmath114 pairwise different individuals    @xmath572 such that    @xmath573    then we add into @xmath374 the requirements    @xmath564 .",
    "notice the use of    @xmath560 instead of @xmath107 .",
    "note that , since    the rule ( ) is not applicable to @xmath149 , we must have that    @xmath574 for any    pair @xmath208 , and for any individual @xmath17    such that @xmath504 , either    @xmath379 or @xmath575 must    belong to @xmath416 .",
    "when expanding @xmath150    we will not have to pay attention to the relationship between the    individuals occurring in @xmath374 .",
    "@xmath115      ( ): :    if @xmath152 and    @xmath356 then    +    1 .   for each    @xmath576 , where    @xmath24 is a non - numeric role , do    1 .",
    "@xmath577 +    @xmath578    and    @xmath579    2 .   @xmath580    3 .",
    "@xmath581    2 .",
    "@xmath582 .    +    to realize a requirement @xmath583 at    @xmath149 , where @xmath24 is a non - numeric role , we    connect @xmath149 to a new simple non - state @xmath150 with    appropriate contents as shown in the rule .",
    "@xmath115      ( ): :    if @xmath152 and    @xmath397    then    +    1 .",
    "@xmath584 ,    @xmath585    2 .",
    "[ item : hjfdu ] for each    @xmath586 do    1 .",
    "@xmath587    2 .",
    "@xmath588 +    @xmath578    and    @xmath579    3 .   @xmath589    3 .",
    "[ item : hgdfw ] for each    @xmath590 do    1 .   for each @xmath591 do    1 .",
    "if @xmath592 and    @xmath593 then    @xmath594 +    ( i.e. , @xmath595 is replaced by    @xmath596 and    @xmath597 )    2 .",
    "else    @xmath598    2 .",
    "@xmath599 ,    @xmath585    4 .",
    "[ item : hmfhs ] repeat    1 .   for each    @xmath590 ,    @xmath591 and    @xmath600 such that    @xmath592 , @xmath601 , @xmath602 ,    @xmath603",
    ",    @xmath604    and @xmath605 does not contain any pair of the form    @xmath59 , @xmath138 do add    @xmath606 into    @xmath607 ( i.e. , the merger of    @xmath595 and    @xmath608 is added into    @xmath607 )    2 .   [ item : ydmat ] for each    @xmath591 ,    @xmath600 and    @xmath609 such that    @xmath610 ,    @xmath604    and @xmath605 does not contain any pair of the form    @xmath59 , @xmath138 do add    @xmath606 into    @xmath607    +    until no tuples were added into @xmath607 during the    last iteration    5 .",
    "[ item : jhfsa ] for each    @xmath591 do    1 .",
    "@xmath611    6 .",
    "[ item : jhdsa ] let    @xmath612    7 .",
    "@xmath613    8 .",
    "[ item : jeros ] for each    @xmath614 do    1 .",
    "if @xmath43 is of the form @xmath549    then add into @xmath198 the    constraint +    @xmath615    2 .",
    "if @xmath43 is of the form @xmath545    then add into @xmath198 the    constraint +    @xmath616    9 .   @xmath371 .",
    "+    to satisfy a requirement    @xmath617 ,    one can first create a successor @xmath618 of    @xmath149 specified by the tuple    @xmath595 computed at the step  [ item : hjfdu ] ,    where @xmath91 presents    @xmath619 , @xmath521 presents    @xmath620 and @xmath63    presents @xmath621 , and then clone    @xmath618 to create @xmath41 successors for    @xmath149 ( or only record the intention somehow ) .",
    "the label of    @xmath618 contains only formulas necessary for realizing    the requirement @xmath622 and related ones    of the form @xmath623 at    @xmath149 . to satisfy requirements of the form    @xmath624 at @xmath149 , where    @xmath625 , we tend to use only    copies of @xmath618 extended with either    @xmath626 or @xmath627 ( for easy counting )    as well as the mergers of such extended nodes .",
    "so , we first start with    the set @xmath607 constructed at the step  [ item :    hjfdu ] , which consists of tuples with information about successors to    be created for @xmath149 . we then modify    @xmath607 by taking necessary extensions of the    nodes ( see the step  [ item : hgdfw ] ) .",
    "after that we continue modifying    @xmath607 by adding to it also appropriate mergers    of nodes ( see the step  [ item : hmfhs ] ) .",
    "the merging specified at the    step  [ item : ydmat ] corresponds to the rule  ( ) with explanation  [ exp :    iusds ] .",
    "successors for @xmath149 are created at the step  [ item :    jhfsa ] . the number of copies of a node @xmath150 that are    intended to be used as successors of @xmath149 is represented by    a variable @xmath199 ( we will not actually create such    copies ) .",
    "the set @xmath198 consisting    of appropriate constraints about such variables are set at the steps    [ item : jhdsa]-[item : jeros ] .",
    "@xmath115      define the size of a knowledge base @xmath53 to be the number of bits used for the usual sequential representation of @xmath56 .",
    "it is greater than the number of symbols occurring in @xmath56 .",
    "if @xmath628 is the size of @xmath56 and @xmath203 or @xmath629 is a number restriction occurring in @xmath56 then @xmath630 .",
    "[ lemma : complexity ] let @xmath50 be a knowledge base in nnf of the logic @xmath0and let @xmath628 be the size of @xmath50 .",
    "then a @xmath237-tableau for @xmath50 can be constructed in ( at most ) exponential time in  @xmath628.@xmath115    [ theorem : s - c ] let @xmath50 be a knowledge base in nnf of the logic @xmath0and @xmath143 be an arbitrary @xmath237-tableau for @xmath50",
    ". then @xmath50 is satisfiable iff @xmath304 .",
    "@xmath115    see the next section for the proofs of the above lemma and theorem .    to check satisfiability of @xmath50 one",
    "can construct a @xmath237-tableau for it , then return `` no '' when the root of the tableau has status @xmath163 , or `` yes '' in the other case . we call this the _",
    "@xmath237-tableau decision procedure_. the corollary given below immediately follows from theorem  [ theorem : s - c ] and lemma  [ lemma : complexity ] .",
    "the @xmath237-tableau decision procedure has exptimecomplexity .",
    "define @xmath631 to be the smallest set @xmath78 of formulas such that :    * all concepts ( and subconcepts ) used in @xmath50 belong to @xmath78 , * if @xmath24 , @xmath25 are numeric roles and @xmath57 then @xmath632 , @xmath633 , @xmath475 and @xmath634 belong to @xmath78 , * if @xmath635 and @xmath37 then @xmath636 , * if @xmath637 then @xmath638 , * if @xmath639 and @xmath43 is not of the form @xmath201 nor @xmath202 then @xmath640 , * if @xmath641 and @xmath24 is a numeric role then @xmath642 , * if @xmath643 and @xmath644 then @xmath645 , * if @xmath646 and @xmath647 then @xmath648 , * all assertions of @xmath52 belong to @xmath78 , * if @xmath639 and @xmath16 is an individual occurring in @xmath78 then @xmath649 , * if @xmath17 and @xmath520 are individuals occurring in @xmath78 then @xmath529 and @xmath650 belong to @xmath78 , * if @xmath651 then @xmath652 and @xmath96 belong to @xmath78 , * if @xmath651 and @xmath37 then @xmath653 , * if @xmath651 and @xmath57 then @xmath653 .",
    "the number of formulas of @xmath631 is of rank @xmath654 , where @xmath628 is the size of @xmath50 . @xmath115",
    "the proof of this lemma is straightforward .",
    "we recall below lemma  [ lemma : complexity ] before presenting its proof .",
    "* lemma  [ lemma : complexity ] . *",
    "_ let @xmath50 be a knowledge base in nnf of the logic @xmath0and let @xmath628 be the size of @xmath50 . then a @xmath237-tableau for @xmath50 can be constructed in ( at most ) exponential time in  @xmath628 .",
    "_    let s construct any @xmath237-tableau @xmath143 for @xmath50 .",
    "let @xmath655 be the number of formulas of @xmath631 .",
    "we have @xmath656 . for each @xmath147 ,",
    "since states of @xmath172 are cached , it follows that @xmath172 has no more than @xmath658 states .",
    "each state has no more than @xmath659 successors .",
    "if @xmath149 is a successor of a state , then nodes in the local graph of @xmath149 are cached and hence there are no more than @xmath658 of them .",
    "therefore , @xmath172 has @xmath660 nodes , where @xmath661 is a polynomial of @xmath628 .",
    "checking feasibility of @xmath198 for a state @xmath149 is an @xmath662-problem , and by lemma  [ lemma : ifdl ] , can be solved in ( at most ) exponential time in @xmath628 .",
    "thus , checking whether a rule is applicable and applying a rule can be done in time @xmath663 , where @xmath664 is a polynomial of @xmath628 .    choosing a node to expand",
    "can be done in polynomial time in the size of the graph .",
    "as each node is re - expanded at most once ( for converse compatibility ) , we conclude that the graph @xmath172 can be constructed in ( at most ) exponential time in  @xmath628 . @xmath115",
    "[ lemma : uydhw ] let @xmath143 be a @xmath237-tableau for @xmath50 .",
    "then , for every simple node @xmath147 , @xmath416 is equivalent to @xmath168 .",
    "that is , for any interpretation @xmath68 , @xmath665 .",
    "@xmath115    the proof of this lemma is straightforward .",
    "let @xmath172 be a @xmath237-tableau for @xmath50 .",
    "for each node @xmath149 of @xmath172 with @xmath666 , @xmath163 , @xmath164 , let @xmath667 be the moment at which @xmath165 was changed to its final value ( i.e. , determined to be @xmath162 , @xmath163 or @xmath167 ) .",
    "@xmath668 stands for `` determined - status time - stamp '' . for each non - state @xmath149 of @xmath172 ,",
    "let @xmath669 be the moment at which @xmath149 was expanded the last time .    for a simple non - state @xmath149 with @xmath670 , @xmath175 and @xmath671 ,",
    "we define @xmath672 to be @xmath673 extended with all @xmath674 such that :    * @xmath675 and @xmath57 for some @xmath676 , * some node @xmath150 in the local graph of @xmath149 has @xmath374 containing @xmath467 as well as @xmath469 or @xmath468 with @xmath677 , * @xmath471 and @xmath472 .    for @xmath678 ,",
    "let @xmath679 .",
    "[ lemma : shqwd ] let @xmath143 be a @xmath237-tableau for @xmath50 .",
    "for every @xmath680    1 .",
    "if @xmath681 then 1 .   case @xmath152 and @xmath682 for any predecessor @xmath174 of @xmath149 and for @xmath683 , @xmath684 , we have that : 1 .",
    "[ ass : hgdso ] if @xmath685 and @xmath686 then there do not exist any model @xmath68 of both @xmath26 and @xmath51 and any elements @xmath687 such that @xmath688 , @xmath689 , @xmath690 for all @xmath691 , and @xmath692 for all @xmath693 , 2 .",
    "[ ass : hadso ] if @xmath685 and @xmath694 then there do not exist any model @xmath68 of @xmath695 and any element @xmath696 such that : @xmath689 , and for @xmath697 , @xmath690 for all @xmath691 , and @xmath692 for all @xmath693 , 2 .",
    "[ ass : jhdsm ] case @xmath152 and @xmath698 @xmath416 is unsatisfiable w.r.t .",
    "@xmath26 and  @xmath51 , 3 .",
    "[ ass : jhwaq ] case @xmath171 and @xmath699 @xmath416 is unsatisfiable w.r.t .",
    "@xmath26 and  @xmath51 , 4 .",
    "[ ass : uieal ] case @xmath171 , @xmath700 and @xmath701 if @xmath538 then there do not exist any model @xmath68 of both @xmath26 and @xmath51 and any elements @xmath687 such that @xmath702 , @xmath689 , @xmath690 for all @xmath431 , and @xmath692 for all @xmath703 , 5 .",
    "[ ass : ksrlw ] case @xmath171 , @xmath700 and @xmath704 if @xmath538 then there do not exist any model @xmath68 of @xmath705 and any element @xmath696 such that : @xmath689 , and for @xmath706 , @xmath690 for all @xmath431 , and @xmath692 for all @xmath703 , 2 .   if @xmath197 , @xmath152 and @xmath385 then @xmath707 is unsatisfiable w.r.t .",
    "@xmath26 and  @xmath51 , 3 .   if @xmath171 and @xmath708 are all the successors of @xmath149 then , for every model @xmath68 of @xmath26 and every @xmath709 , 1 .",
    "case @xmath682 @xmath710 iff there exists @xmath711 such that @xmath712 , 2 .   case @xmath698 @xmath68 is a model of @xmath416 iff there exists @xmath711 such that @xmath68 is a model of @xmath713 .",
    "we prove this lemma by induction on both @xmath667 and @xmath669 .",
    "consider the case  [ ass : hgdso ] when @xmath149 gets status @xmath163 because @xmath198 is infeasible .",
    "for this case , we prove the contrapositive .",
    "suppose that : @xmath714 we show that @xmath198 is feasible .",
    "without loss of generality , assume that @xmath68 is finitely - branching .",
    "thus , the set @xmath715 , @xmath716 for some @xmath717 is finite .",
    "let us compute a solution @xmath718 for @xmath198 as follows .    1 .   for each successor @xmath150 of @xmath149 , set @xmath719",
    "2 .   for each @xmath720",
    "[ item : ghsdo ] let @xmath708 be all the successors of @xmath149 such that , for each @xmath721 : 1 .   [",
    "item : jdjap ] @xmath722 , 2 .",
    "[ item : jdyts ] @xmath723 , 3 .",
    "[ item : jpwbp ] @xmath716 for all @xmath724 , 4 .",
    "@xmath725 is `` maximal '' in the sense that there does not exist any successor @xmath726 of @xmath149 such that * @xmath727 and @xmath728 , * @xmath729 , * @xmath730 , * @xmath716 for all @xmath731 ; 2 .",
    "[ item : jriah ] for each @xmath711 , set @xmath732 .",
    "@xmath733 is a successor of @xmath734 .",
    "[ item : hwuzs ] let @xmath708 be all the successors of @xmath149 defined as in the step  [ item : ghsdo ] for the case @xmath735 .",
    "5 .   for each @xmath711",
    "do : 1 .   if there exists @xmath736 such that @xmath737 , @xmath738 , @xmath739 and @xmath740 then 1 .",
    "[ item : hgres ] set @xmath732 . 6 .",
    "@xmath741 is a successor of @xmath734 .",
    "we prove that @xmath718 is a solution for @xmath198 .",
    "we first show that , for any @xmath725 at the step  [ item : ghsdo ] or  [ item : hwuzs ] , @xmath742 for all @xmath743 .",
    "let @xmath743 .",
    "thus , there exist @xmath24 , @xmath257 , @xmath114 , @xmath43 , @xmath41 , @xmath44 such that : @xmath57 , @xmath724 , @xmath257 is a node in the local graph of @xmath725 , @xmath258 contains @xmath467 as well as @xmath469 or @xmath468 with @xmath677 , @xmath744 and @xmath745 .",
    "as @xmath746 and the rule @xmath747 was not applicable to @xmath257 , either @xmath632 or @xmath633 must belong to @xmath168 .",
    "if @xmath748 then , since @xmath689 , we have that @xmath749 and therefore @xmath742 .",
    "suppose @xmath750 .",
    "if @xmath751 then , by the nature of the transitional full - expansion rule and the maximality of @xmath725 , we have that @xmath752 and @xmath737 , which contradicts the assumption @xmath743",
    ". therefore , @xmath742 .",
    "we now show that if a constraint @xmath355 was added into @xmath198 because @xmath150 got status @xmath163 then @xmath254 was not increased and hence must be 0 . for the contrary , suppose the constraint @xmath355 was added into @xmath198 ( because @xmath150 got status @xmath163 ) and @xmath254 was increased at least once .",
    "thus , there exists @xmath753 such that @xmath754 and @xmath716 for all @xmath755 . by the assertion stated in the above paragraph",
    ", we also have that @xmath742 for all @xmath756 . by",
    ", we have that @xmath689 and @xmath177 , and by lemma  [ lemma : uydhw ] , it follows that @xmath757 .",
    "this situation contradicts the inductive assumption  [ ass : uieal ] ( with @xmath149 , @xmath181 , @xmath174 , @xmath758 , @xmath249 replaced by @xmath150 , @xmath150 , @xmath149 , @xmath249 , @xmath759 , respectively ) .",
    "therefore , every constraint @xmath355 from @xmath198 is satisfied by the solution  @xmath718 .",
    "consider a concept @xmath736 and the corresponding constraint @xmath760 , @xmath761 of @xmath198 .",
    "there are the following cases :    * case @xmath762 , @xmath763 and @xmath764 : by  , we have that @xmath765 , @xmath766 and @xmath767 .",
    "hence , @xmath74 contains pairwise different @xmath768 such that @xmath769 and @xmath770 for all @xmath771 .",
    "each @xmath772 makes @xmath254 increased by  1 for some successor @xmath150 of @xmath149 with @xmath773 and @xmath774 .",
    "it follows that the considered constraint is satisfied by the solution  @xmath718 .",
    "* case ( @xmath775 or ( @xmath776 and @xmath777 ) ) and @xmath778 : by  , we have that @xmath779 and @xmath780 .",
    "analogously to the above case , the considered constraint is satisfied by the solution  @xmath718 .",
    "* case ( @xmath775 or ( @xmath776 and @xmath777 ) ) , @xmath740 and @xmath763 : by the rule ( ) , @xmath764 , which implies that .",
    "thus , this case is reduced to the first one .",
    "* case ( @xmath775 or ( @xmath776 and @xmath777 ) ) , @xmath740 and @xmath739 : by  , we have that @xmath779 .",
    "if @xmath781 or @xmath780 then , analogously to the first case , the considered constraint is satisfied by the solution  @xmath718 .",
    "assume that @xmath766 and @xmath767 .",
    "we have that @xmath782 contains pairwise different @xmath783 such that @xmath769 and @xmath770 , for @xmath771 .",
    "each @xmath772 makes @xmath254 increased by  1 for some successor @xmath150 of @xmath149 with @xmath773 and @xmath774 .",
    "it follows that the considered constraint is satisfied by the solution  @xmath718 .",
    "consider a concept @xmath784 and the corresponding constraint @xmath785 , @xmath786 of @xmath198 .",
    "there are two cases : @xmath787    consider the first case , i.e. , assume that   holds . by  , we have that @xmath788 . hence , @xmath782 contains no more than @xmath114 elements @xmath759 such that @xmath716 and @xmath789 . due to the `` maximality '' of @xmath150 and the nature of the transitional full - expansion rule , for such a  @xmath759 there exists at most one successor @xmath150 of @xmath149 such that @xmath755 , @xmath790 and the consideration of @xmath759 causes @xmath254 to be increased by  1 .",
    "( also , such an @xmath254 is increased only due to such a @xmath759 . ) therefore , the considered constraint is satisfied by the solution  @xmath718 .",
    "consider the second case ,",
    "i.e. , assume that   holds .",
    "by  , we have that , @xmath791 and @xmath792 .",
    "hence , @xmath74 contains no more than @xmath114 elements @xmath759 such that @xmath716 and @xmath789 . due to the `` maximality '' of @xmath150 and the nature of the transitional full - expansion rule , for such a  @xmath759 there exists at most one successor @xmath150 of @xmath149 such that @xmath755 , @xmath790 and the consideration of @xmath759 causes @xmath254 to be increased by  1 .",
    "( also , such an @xmath254 is increased only due to such a @xmath759 . ) therefore , the considered constraint is satisfied by  @xmath793 . to prove that it is also satisfied by  @xmath718",
    ", it suffices to show that if @xmath794 was increased at the step  [ item : hgres ] ( in the construction of  @xmath718 ) then @xmath795 or @xmath796 .",
    "for the contrary , suppose that @xmath794 was increased at the step  [ item : hgres ] and @xmath797 as the condition of the step  [ item : hgres ] , @xmath798    since @xmath739 ( by  ) and @xmath799 ( by  ) , we have that @xmath800 .",
    "consider the case @xmath801 . since both @xmath25 and @xmath24 belong to @xmath802 ( by   and  ) , there exist roles @xmath803 such",
    "that , for every @xmath804 : @xmath805 for each @xmath806 from 1 to @xmath807 , observe that :    * since @xmath808 , by the step  [ item : hwuzs ] and the step  [ item : jpwbp ] ( with @xmath735 ) in the construction of the solution  @xmath718 , we have that @xmath809 * if @xmath810 then * * @xmath811 because one can apply the definition of @xmath812 ( with @xmath174 , @xmath149 , @xmath150 , @xmath63 , @xmath25 , @xmath24 , @xmath114 , @xmath43 , @xmath41 , @xmath44 replaced , respectively , by @xmath813 , @xmath814 , @xmath174 , @xmath64 , @xmath815 , @xmath816 , @xmath817 , @xmath818 , @xmath819 , @xmath820 ) due to the following reasons : * * * by  , @xmath821 and @xmath822 , * * * @xmath810 ( by the premise of the above `` if '' clause ) , * * * @xmath823 ( by  ) * * * @xmath824 since * * * * if @xmath825 then @xmath826 ( by ) and @xmath799 ( by  ) , * * * * if @xmath827 then @xmath824 by induction of   as shown below , * * * by  , @xmath174 is a node in the local graph of @xmath814 and , since @xmath381 and @xmath149 is a state , like @xmath168 , @xmath443 contains @xmath828 ( by   and  , using @xmath829 and @xmath830 ) as well as @xmath831 or @xmath832 with @xmath833 ( by  ) , * * * since @xmath824 ( as above ) , @xmath834 ( as above ) and @xmath685 ( by  ) , by the rule ( ) , either @xmath818 or @xmath835 belongs to @xmath836 , * * * if @xmath837 then , since @xmath838 ( by  ) , by the step  [ item : hwuzs ] and the step  [ item : jdyts ] ( with @xmath735 ) in the construction of the solution  @xmath718 , we have that @xmath839 , hence , by  , @xmath840 , and by the assertion in the above item , @xmath841 , * * * if @xmath842 then , since @xmath843 ( by  ) , for @xmath829 we have that @xmath841 , * * * since @xmath844 ( by  ) , by the step  [ item : hwuzs ] and the step  [ item : jdyts ] ( with @xmath735 ) in the construction of the solution  @xmath718 , we have that @xmath845 , hence , by  , @xmath846 ; * * since @xmath811 ( shown above ) , by  , @xmath847 , which contradicts  ; * hence @xmath848 , and by  , it follows that @xmath849    as a consequence , for @xmath850 , we have that @xmath851 . since @xmath852 ( by  ) and @xmath853 ( by  ) , it follows that @xmath763 , which contradicts  .",
    "now consider the case @xmath57 .",
    "one can derive @xmath854 by applying the definition of @xmath812 ( with @xmath174 , @xmath149 , @xmath150 , @xmath63 , @xmath25 , @xmath24 , @xmath114 , @xmath41 replaced , respectively , by @xmath813 , @xmath814 , @xmath174 , @xmath64 , @xmath58 , @xmath418 , @xmath855 , and some @xmath856 ) due to the following reasons :    * by  , @xmath821 and @xmath822 , * @xmath739 ( by  ) , @xmath857 ( since @xmath57 ) , @xmath799 ( by  ) , * by  , @xmath174 is a node in the local graph of @xmath814 and , since @xmath381 and @xmath149 is a state , like @xmath168 , @xmath443 contains @xmath858 ( by  ) as well as @xmath859 or @xmath860 for some @xmath861 ( since @xmath736  by  ) , * @xmath843 ( by  ) and @xmath740 ( by  ) .    by",
    ", it follows that @xmath781 , which contradicts  .    we have proved the induction step for the case  [ ass : hgdso ] when @xmath149 gets status @xmath163 because @xmath198 is infeasible .",
    "the case  [ ass : hadso ] when @xmath149 gets status @xmath163 because @xmath198 is infeasible can be dealt with in a similar way , using the following modifications , with @xmath862 ( and thus @xmath863 ) :    * the assumption   is modified by changing `` @xmath686 '' to `` @xmath694 '' and changing `` @xmath68 is a model of both @xmath26 and @xmath51 , @xmath864 '' to `` @xmath68 is a model of @xmath695 '' . *",
    "`` @xmath764 '' is replaced by `` @xmath865 '' , and similarly for other cases with another concept in the place of @xmath44 and/or with @xmath866 instead of @xmath867 .",
    "* the phrase `` either @xmath818 or @xmath835 belongs to @xmath836 '' is replaced by `` either @xmath868 or @xmath869 belongs to @xmath836 '' . * the phrase `` @xmath174 , @xmath64 '' is replaced by `` @xmath174 , @xmath16 '' .",
    "now consider the case  [ ass : jhdsm ] when @xmath149 gets status @xmath163 because @xmath198 is infeasible .",
    "for this case , we prove the contrapositive .",
    "suppose that @xmath152 , @xmath156 and @xmath416 is satisfiable w.r.t .",
    "@xmath26 and @xmath51 .",
    "we show that @xmath198 is feasible .",
    "let @xmath68 be a finitely - branching model of @xmath26 , @xmath51 and @xmath416 .",
    "we compute a solution @xmath718 for @xmath198 as follows .    1 .   for each successor @xmath150 of @xmath149 , set @xmath719 .",
    "2 .   for each individual @xmath16",
    "occurring in @xmath52 and each @xmath870 such that @xmath871 for some @xmath872 do : 1 .",
    "[ item : xhsdo ] let @xmath708 be all the successors of @xmath149 such that , for each @xmath721 : 1 .   [ item : xdjap ] @xmath722 and @xmath873 , 2 .   [ item : xdyts ] @xmath723 , 3 .   [ item : xpwbp ] @xmath871 for all @xmath724 , 4 .",
    "@xmath725 is `` maximal '' in the sense that there does not exist any successor @xmath726 of @xmath149 such that * @xmath727 and @xmath728 , * @xmath729 and @xmath874 , * @xmath730 , * @xmath871 for all @xmath731 ; 2 .   [ item : xriah ] for each @xmath711 do 1 .",
    "[ item : xriyh ] if @xmath875 for all @xmath17 occurring in @xmath52 then @xmath732 ; 2 .",
    "[ item : xrixh ] else if @xmath876 for some @xmath17 occurring in @xmath52 and there exists @xmath877 such that @xmath737 , @xmath738 and @xmath878 then @xmath732 .",
    "3 .   @xmath741 is a successor of @xmath734 .",
    "we prove that @xmath718 is a solution for @xmath198 .",
    "we first show that , for any @xmath725 at the step  [ item : xhsdo ] , @xmath879 for all @xmath743 .",
    "let @xmath743 .",
    "thus , there exist @xmath24 , @xmath257 , @xmath114 , @xmath43 , @xmath41 , @xmath44 such that : @xmath57 , @xmath724 , @xmath257 is a node in the local graph of @xmath725 , @xmath258 contains @xmath467 as well as @xmath469 or @xmath468 with @xmath677 , @xmath880 and @xmath881 .",
    "as @xmath746 and the rule @xmath747 was not applicable to @xmath257 , either @xmath882 or @xmath883 must belong to @xmath168 . if @xmath884 then @xmath885 and therefore @xmath879 .",
    "suppose @xmath886 .",
    "if @xmath887 then , by the nature of the transitional full - expansion rule and the maximality of @xmath725 , we have that @xmath752 and @xmath737 , which contradicts the assumption @xmath743",
    ". therefore , @xmath879 .",
    "we now show that if a constraint @xmath355 was added into @xmath198 because @xmath150 got status @xmath163 then @xmath254 was not increased and hence must be 0 . for the contrary , suppose the constraint @xmath355 was added into @xmath198 ( because @xmath150 got status @xmath163 ) and @xmath254",
    "was increased at least once .",
    "thus , there exists @xmath870 such that @xmath754 and @xmath871 for all @xmath755 . by the assertion stated in the above paragraph",
    ", we also have that @xmath879 for all @xmath756 .",
    "this situation contradicts the inductive assumption  [ ass : ksrlw ] ( with @xmath149 , @xmath181 , @xmath174 , @xmath758 , @xmath249 replaced by @xmath150 , @xmath150 , @xmath149 , @xmath423 , @xmath759 , respectively ) .",
    "therefore , every constraint @xmath355 from @xmath198 is satisfied by the solution  @xmath718 .",
    "consider a concept @xmath888 and the corresponding constraint @xmath889 , @xmath773 , @xmath761 of @xmath198 .",
    "let @xmath890 .",
    "we have that @xmath891 .",
    "since @xmath68 is a model of @xmath416 , there exist pairwise different @xmath892 such that @xmath893 and @xmath770 for all @xmath894 .",
    "note that , if @xmath895 then , by the rule @xmath485 , either @xmath896 or @xmath897 . since @xmath770 and @xmath68 is a model of @xmath416 ,",
    "if @xmath898 then @xmath899 . therefore , for every @xmath894 ,",
    "if @xmath898 and @xmath895 then @xmath896 .",
    "let @xmath900 .",
    "we have that @xmath901 .",
    "each @xmath759 from @xmath74 makes @xmath254 increased by  1 for some successor @xmath150 of @xmath149 with @xmath213 , @xmath773 and @xmath774 .",
    "it follows that the considered constraint is satisfied by the solution  @xmath718 .",
    "consider a concept @xmath902 and the corresponding constraint @xmath889 , @xmath755 , @xmath903 of @xmath198 .",
    "let @xmath904 .",
    "we have that @xmath905 .",
    "since @xmath68 is a model of @xmath416 , it follows that @xmath906 .",
    "let @xmath907 .",
    "due to the subrule  [ item : jheaa ] of  ( ) , we have that @xmath908 .",
    "note that if @xmath150 is a successor of @xmath149 , @xmath213 , @xmath755 and @xmath790 then @xmath254 is increased only due to some @xmath759 such that @xmath871 and @xmath789 .",
    "due to the `` maximality '' of @xmath150 and the nature of the transitional full - expansion rule , for such a  @xmath759 there exists at most one successor @xmath150 of @xmath149 such that @xmath213 , @xmath755 , @xmath790 and the consideration of @xmath759 causes @xmath254 to be increased by  1 . since @xmath906 , to prove that the considered constraint is satisfied by the solution  @xmath718 , it suffices to show that if @xmath909 causes @xmath794 to be increased by  1 at the step  [ item : xrixh ] then @xmath795 or @xmath796 .",
    "suppose the contrary .",
    "we have that : @xmath910    since both @xmath25 and @xmath24 belong to @xmath802 ( by   and  ) , there exist roles @xmath911 such that , for every @xmath804 : @xmath912    note that the subrule  [ item : osjrs ] of ( ) was not applicable to @xmath149 . having , , and , we derive that @xmath913 or @xmath914 .",
    "since   and  , @xmath915 .",
    "since @xmath68 is a model of @xmath416 , it follows that @xmath916 , and hence @xmath913 . since @xmath917 ( by  )",
    ", by the rule ( ) , we also have that @xmath918 .",
    "analogously , using also  , for every @xmath806 from 1 to @xmath807 , we can derive that @xmath919 and @xmath920 .",
    "since @xmath921 , it follows that @xmath895 , which contradicts  .",
    "this completes the induction step for the case  [ ass : jhdsm ] when @xmath149 gets status @xmath163 because @xmath198 is infeasible .",
    "the induction steps for the other cases are straightforward .",
    "@xmath115    if @xmath143 is a @xmath237-tableau for @xmath50 and @xmath922 then @xmath50 is unsatisfiable .",
    "@xmath115    this corollary follows from the assertion  [ ass : jhwaq ] of lemma  [ lemma : shqwd ] .      we prove completeness of @xmath237via model graphs . the technique has been used for other logics ( e.g. , in  @xcite ) . a _ model graph _ ( also known as a _ hintikka structure _ ) is a tuple @xmath923 , where :    * @xmath924 is a non - empty and finite set , * @xmath925 is a mapping that associates each individual name with an element of @xmath924 , * @xmath926 is a mapping that associates each element of @xmath924 with a set of concepts , * @xmath927 is a mapping that associates each role with a binary relation on @xmath924 .",
    "a model graph @xmath923 is _ consistent _ and _ @xmath26-saturated _ if every @xmath928 satisfies : @xmath929    given a  model graph @xmath930 , the _",
    "@xmath26-model corresponding to  @xmath931 _ is the interpretation @xmath932 where :    * @xmath933 for every individual name  @xmath16 , * @xmath934 for every concept name @xmath12 , * @xmath935 for every role name @xmath18 , where @xmath936 for @xmath937 are the smallest binary relations on @xmath924 such that : * * @xmath938 , * * if @xmath37 then @xmath939 , * * if @xmath39 then @xmath940 .    note that the smallest binary relations mentioned above always exist : for each @xmath937 , initialize @xmath936 with @xmath941 ; then , while one of the above mentioned condition is not satisfied , extend the corresponding @xmath936 minimally to satisfy the condition .",
    "[ lemma : model graph ] if @xmath68 is the @xmath26-model corresponding to a consistent @xmath26-saturated model graph @xmath923 , then @xmath68 is a model of @xmath26 and , for every @xmath928 and @xmath942 , we have that @xmath792 .",
    "@xmath115    the first assertion of this lemma clearly holds .",
    "the second assertion can be proved by induction on the structure of  @xmath43 in a straightforward way .",
    "let @xmath143 be a @xmath237-tableau for @xmath50 and @xmath147 be a non - state with @xmath433 .",
    "a _ saturation path _ of @xmath149 is a sequence @xmath943 , @xmath180 ,  , @xmath247 of nodes of @xmath172 , with @xmath944 , such that @xmath945 and    * for every @xmath946 , @xmath947 , @xmath948 and @xmath949 , * @xmath950 .",
    "observe that each saturation path of @xmath149 is finite .",
    "is a successor of a non - state @xmath206 then @xmath951 and either @xmath952 or @xmath953 .",
    "recall also that @xmath954 and @xmath955 are subsets of @xmath631 . ]",
    "furthermore , if @xmath206 is a non - state with @xmath948 then @xmath206 has a successor @xmath956 with @xmath957 ; if @xmath206 is a non - state with only one successor @xmath956 which is a state then @xmath958 , because after a state gets status @xmath162 all edges coming to its are deleted .",
    "therefore , @xmath149 has at least one saturation path .",
    "[ lemma : completeness ] let @xmath143 be a @xmath237-tableau for @xmath50 .",
    "suppose @xmath304 .",
    "then @xmath50 is satisfiable .",
    "let @xmath959 be a saturation path of @xmath212 .",
    "we define a model graph @xmath930 as follows :    1 .",
    "[ item : jrosa ] let @xmath960 be the set of all individuals occurring in @xmath248 and set @xmath961 . for @xmath962 , define @xmath963 .",
    "extend @xmath925 to other individuals from @xmath11 so that : if @xmath964 @xmath965 then @xmath966 ; if @xmath967 does not occur in @xmath50 then @xmath968 is some individual occurring in @xmath248 .",
    "for each @xmath962 , mark @xmath16 as _ unresolved_@xmath235 will be marked either as unresolved or as resolved .",
    "] and set @xmath969 . for each role @xmath24 , set @xmath970 .",
    "[ item : jhres ] for every unresolved node @xmath971 do : 1 .",
    "if @xmath972 then let @xmath973 and @xmath974 and @xmath975 .",
    "else let @xmath976 ( @xmath977 is a constructed mapping that associates each node of @xmath931 not belonging to @xmath960 with a simple state of @xmath172 ; as a maintained property of @xmath977 , @xmath978 ) and let @xmath979 .",
    "3 .   fix a solution of @xmath255 , and for each @xmath256 : * if @xmath251 then let @xmath252 , * else let @xmath254 be the value of @xmath199 in that solution .",
    "4 .   delete from @xmath250 elements @xmath150 with @xmath980 .",
    "5 .   for each @xmath981",
    "do : * let @xmath982 , ",
    ", @xmath983 be a saturation path of @xmath982 in @xmath172 .",
    "* for @xmath984 to @xmath985 do : * * add a new element @xmath759 into @xmath924 .",
    "* * for each @xmath402 , add @xmath986 into @xmath941 and @xmath987 into @xmath988 .",
    "* * set @xmath989 to the set of concepts belonging to @xmath990 and set @xmath991 .",
    "mark @xmath249 as _ resolved_.    the defined model graph @xmath931 may be infinite .",
    "it consists of a finite base created at the step  [ item : jrosa ] and disjoint trees ( with backward edges to predecessors ) created at the step  [ item : jhres ] .",
    "it is straightforward to prove that @xmath931 is a consistent @xmath26-saturated model graph .    by the definition of @xmath237-tableaux for @xmath50 and the construction of @xmath931 : if @xmath992 then @xmath993 ; if @xmath994 then @xmath995 ; if @xmath996 then @xmath997 ; and @xmath998 for all @xmath972 .",
    "we also have that @xmath999 for all @xmath1000 .",
    "hence , by lemma  [ lemma : model graph ] , the interpretation corresponding to @xmath931 is a model of @xmath50 .",
    "we have developed the first exptimetableau decision procedure for checking satisfiability of a knowledge base in the dl @xmath0 .",
    "the complexity is measured using binary representation for numbers .",
    "our procedure has been designed to increase efficiency of reasoning :    * we use global state caching but not global caching plus inefficient cuts although the latter approach is much simpler and still guarantees the optimal complexity .",
    "* we use global state caching but not `` pairwise '' global state caching , cf .  the lift from anywhere blocking to pairwise anywhere blocking  @xcite .",
    "this is a good optimization technique , as such a lift would make the graph larger and significantly reduce the chance of getting cache hits .",
    "it is a new technique for dealing with both inverse roles and quantified number restrictions . * similarly to our previous works  @xcite , but in contrast to  @xcite , if @xmath149 is a non - state such that @xmath184 holds then we also apply global caching for the local graph of @xmath149 . * using rules with the highest priority for updating statuses of nodes means that the final statuses @xmath163 , @xmath167 and @xmath162 of nodes are propagated `` on - the - fly '' . *",
    "in contrast to farsiniamarj s method of exploiting integer programming for tableaux  @xcite , in order to avoid nondeterminism we only check feasibility and do not find and use solutions of the considered set of constraints .",
    "thus , as far as we know , we are the first one who applied integer linear _ feasibility _ checking to tableaux . in the current presentation of our procedure , feasibility checking is done `` on - the - fly '' . however ,",
    "when it turns out that such checks would better be done not `` on - the - fly '' , they can be delayed and executed occasionally without affecting soundness and completeness of the calculus ( like checking fulfillment of eventualities in the tableau decision procedure for cpdl@xmath6 in  @xcite ) .",
    "* we do not use pre - compilation techniques .",
    "our operations are direct and natural .",
    "( of course , not all pre - compilation techniques are bad . )",
    "the use of nnf for formulas is also natural and can be efficiently handled  @xcite .",
    "treating tbox axioms as global assumptions is just for making the presentation simple . in practice ,",
    "the absorption technique like the one discussed in  @xcite can be used to deal with tbox axioms .    our tableau decision procedure for @xmath0is a framework , which can be implemented with various optimization techniques  @xcite . in  @xcite we established a set of optimizations that co - operates very well with global caching and various search strategies for the dl @xmath1 , including formulas normalization , formulas caching , literals elimination , propagation of unsat ( closedness ) for parent and sibling nodes , as well as cutoffs and compacting the graph .",
    "efficiently , in  @xcite we used hashing , which is very practically efficient . besides , even in the case the cost of that procedure is polynomial in the size of the graph , the complexity of our tableau decision procedure is still exptime . ]",
    "all of these optimization techniques can be adapted for @xmath0 , and probably , new ones can be found .    implementing an efficient tableau reasoner for @xmath0is time - consuming .",
    "a preliminary implementation of our tableau decision procedure for @xmath0will be done first by our master student in the coming academic year . by the preliminary experimental results of @xcite ( on global caching for @xmath1 ) and @xcite ( on exploiting integer programming for @xmath8 )",
    ", one can hope that our framework allows to create good reasoners for @xmath0 .",
    "our work provides not only techniques for increasing efficiency of reasoning and making it scalable w.r.t .",
    "quantified number restrictions .",
    "it does provide also the first method for developing exptimetableau decision procedures instead of n2exptimeones  @xcite for exptimedescription logics with quantified number restrictions .",
    "the method is also applicable to graded modal logics .",
    "this work was supported by polish national science centre grant 2011/01/b / st6/02759 .",
    "b.  glimm , i.  horrocks , and b.  motik .",
    "optimized description logic reasoning via core blocking . in j.",
    "giesl and r.  hhnle , editors , _ proceedings of ijcar2010 _ , volume 6173 of _ lncs _ , pages 457471 .",
    "springer , 2010 .",
    "r.  gor and l.a .",
    "nguyen . a tableau system with automaton - labelled formulae for regular grammar logics . in b.",
    "beckert , editor , _ proceedings of tableaux 2005 _ , volume 3702 of _ lnai _ , pages 138152 .",
    "springer , 2005 .",
    "r.  gor and l.a .",
    "tableaux with global caching for description logics with transitive roles , inverse roles and role hierarchies . in n.",
    "olivetti , editor , _ proceedings of tableaux 2007 _ , volume 4548 of _ lnai _ , pages 133148 .",
    "springer , 2007 .",
    "r.  gor and l.a .",
    "analytic cut - free tableaux for regular modal logics of agent beliefs . in f.",
    "sadri and k.  satoh , editors , _ proceedings of clima viii _ , volume 5056 of _ lnai _ , pages 268287 .",
    "springer , 2008 .",
    "r.  gor and l.  postniece .",
    "an experimental evaluation of global caching for alc ( system description ) . in p.",
    "baumgartner , editor , _ proc .",
    "ijcar2008 _ , volume 5195 of _ lncs _ , pages 299305 .",
    "springer , 2008 .",
    "r.  gor and f.  widmann .",
    "sound global state caching for @xmath1 with inverse roles . in m.",
    "giese and a.  waaler , editors , _ proceedings of tableaux 2009 _ , volume 5607 of _ lncs _ , pages 205219 .",
    "springer , 2009 .",
    "r.  gor and f.  widmann .",
    "optimal and cut - free tableaux for propositional dynamic logic with converse . in j.",
    "giesl and r.  hhnle , editors , _ proceedings of ijcar 2010 _ , volume 6173 of _ lncs _ , pages 225239 .",
    "springer , 2010 .",
    "b.  motik and u.  sattler .",
    "a comparison of reasoning techniques for querying large description logic aboxes . in m.",
    "hermann and a.  voronkov , editors , _ proceedings of lpar2006 _ , volume 4246 of _",
    "lncs_. springer , 2006 .",
    "cut - free exptime tableaux for checking satisfiability of a knowledge base in the description logic @xmath5 . in _ proceedings of ismis2011",
    "_ , volume 6804 of _ lnai _ , pages 465475 .",
    "springer , 2011 .",
    "nguyen . a cut - free exptime tableau decision procedure for the description logic shi . in _ proceedings of iccci2011 ( 1 )",
    "_ , volume 6922 of _ lncs _ , pages 572581 .",
    "springer , 2011 ( see also the long version http://arxiv.org/abs/1106.2305v1 ) .    l.a .",
    "nguyen and a.  szaas .",
    "tableaux for checking satisfiability of a knowledge base in the description logic alc . in n.t .",
    "nguyen , r.  kowalczyk , and s .- m .",
    "chen , editors , _ proceedings of iccci2009 _ , volume 5796 of _ lnai _ , pages 437448 .",
    "springer , 2009 .",
    "nguyen and a.  szaas . an optimal tableau decision procedure for converse - pdl . in n .-",
    "nguyen , t .- d .",
    "bui , e.  szczerbicki , and n .- b .",
    "nguyen , editors , _ proceedings of kse2009 _ , pages 207214 .",
    "ieee computer society , 2009 ."
  ],
  "abstract_text": [
    "<S> we give the first exptime(complexity - optimal ) tableau decision procedure for checking satisfiability of a knowledge base in the description logic @xmath0 . </S>",
    "<S> the complexity is measured using binary representation for numbers . </S>",
    "<S> our procedure is based on global state caching and integer linear feasibility checking .    * keywords : * automated reasoning , description logics , global state caching , integer linear feasibility </S>"
  ]
}