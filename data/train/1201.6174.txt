{
  "article_text": [
    "multiplying two boolean matrices , where addition is interpreted as a logical or and multiplication as a logical and , is a fundamental problem that has found applications in many areas of computer science ( for instance , computing the transitive closure of a graph @xcite or solving all - pairs path problems @xcite ) .",
    "the product of two @xmath0 boolean matrices can be trivially computed in time @xmath5 .",
    "the best known algorithm is obtained by seeing the input matrices as integer matrices , computing the product , and converting the product matrix to a boolean matrix . using the algorithm by coppersmith and winograd  @xcite for multiplying integer matrices ( and",
    "more generally for multiplying matrices over any ring ) , or its recent improvements by stothers @xcite and vassilevska williams  @xcite , this gives a classical algorithm for boolean matrix multiplication with time complexity @xmath6 .",
    "this algebraic approach has nevertheless many disadvantages , the main being that the huge constants involved in the complexities make these algorithms impractical . indeed , in the classical setting",
    ", much attention has focused on algorithms that do not use reductions to matrix multiplication over rings , but instead are based on search or on combinatorial arguments .",
    "such algorithms are often called _ combinatorial algorithms _ , and the main open problem in this field is to understand whether a @xmath7-time combinatorial algorithm , for some constant @xmath4 , exists for boolean matrix multiplication .",
    "unfortunately , there has been little progress on this question .",
    "the best known combinatorial classical algorithm for boolean matrix multiplication , by bansal and williams @xcite , has time complexity @xmath8 .    in the quantum setting",
    ", there exists a straightforward @xmath9-time suppresses @xmath10 factors . ]",
    "algorithm that computes the product of two @xmath0 boolean matrices @xmath11 and  @xmath12 : for each pair of indexes @xmath13 , check if there exists an index @xmath14 such that @xmath15=b[k , j]=1 $ ] in time @xmath16 using grover s quantum search algorithm  @xcite .",
    "buhrman and palek @xcite observed that a similar approach leads to a quantum algorithm that computes the product @xmath17 in @xmath18 time , where @xmath2 denotes the number of non - zero entries in @xmath17 .",
    "since the parameter @xmath19 represents the sparsity of the output matrix , such an algorithm will be referred as _ output - sensitive_. classical output - sensitive algorithms for boolean matrix multiplication have also been constructed recently : amossen and pagh  @xcite constructed an algorithm with time complexity @xmath20 , while lingas @xcite constructed an algorithm with time complexity @xmath21 .",
    "the above @xmath18-time quantum algorithm beats both of them when @xmath22 .",
    "note that these two classical algorithms are based on the approach by coppersmith and winograd @xcite and are thus not combinatorial .",
    "le gall @xcite has recently shown that there exists an output - sensitive quantum algorithm that computes the product of two @xmath0 boolean matrices with time complexity @xmath23 if @xmath24 and @xmath25 if @xmath26 .",
    "this algorithm , which improves the quantum algorithm by buhrman and palek @xcite , was constructed by combining ideas from works by vassilevska williams and williams  @xcite and lingas  @xcite .",
    "several developments concerning the quantum query complexity of this problem , where the complexity under consideration is the number of queries to the entries of the input matrices @xmath11 and @xmath12 , have also happened .",
    "output - sensitive quantum algorithms for boolean matrix multiplication in the query complexity setting were first proposed in  @xcite , and then improved in  @xcite .",
    "very recently , jeffery , kothari and magniez  @xcite significantly improved those results : they showed that the quantum query complexity of computing the product of two @xmath0 boolean matrices with  @xmath2 non - zero entries is @xmath27 , and gave a matching ( up to polylogarithmic factors ) lower bound @xmath28 .",
    "the quantum query complexity of boolean matrix multiplication may thus be considered as settled .",
    "can the quantum time complexity of boolean matrix multiplication can be further improved as well ?",
    "the most fundamental question is of course whether there exists a quantum algorithm that uses only quantum search or similar techniques with time complexity @xmath3 , for some constant @xmath4 , when @xmath29 .",
    "this question is especially motivated by its apparently deep connection to the design of subcubic - time classical combinatorial algorithms for boolean matrix multiplication : a @xmath3-time quantum algorithm would correspond to an amortized cost of @xmath30 per entry of the product , which may provides us with a new approach to develop a subcubic - time classical combinatorial algorithm , i.e. , an algorithm with amortized cost of @xmath31 per entry of the product . studying quantum algorithms for boolean matrix multiplication in the time complexity setting",
    "can then , besides its own interest , be considered as a way to gain new insight about the optimal value of the exponent of matrix multiplication in the general case ( i.e. , for dense output matrices ) . in comparison , when the output matrix is dense , the classical and the quantum query complexities of matrix multiplication are both trivially equal to @xmath32 .      in this paper",
    "we build on the recent approach by jeffery , kothari and magniez  @xcite to construct a new time - efficient output - sensitive quantum algorithm for boolean matrix multiplication .",
    "our main result is stated in the following theorem .",
    "[ theorem_1 ] there exists a quantum algorithm that computes the product of two @xmath0 boolean matrices with time complexity @xmath1 , where @xmath2 denotes the number of non - zero entries in the product .",
    "[ fig ]     ( in solid line ) .",
    "the horizontal axis represents the logarithm of @xmath2 with respect to basis @xmath33 ( i.e. , the value @xmath34 ) .",
    "the vertical axis represents the logarithm of the complexity with respect to basis @xmath33 .",
    "the dashed line represents the upper bounds on the time complexity obtained in @xcite , and the dotted line represents the upper bounds obtained in @xcite . ]",
    "the upper bounds of theorem [ theorem_1 ] are illustrated in figure 1 .",
    "our algorithm improves the quantum algorithm by le gall  @xcite for any value of  @xmath2 other than @xmath35 ( we obtain the same upper bound @xmath36 for @xmath29 )",
    ". it also beats the classical algorithms by amossen and pagh  @xcite and lingas @xcite mentioned earlier , which are based on the algebraic approach , for any value @xmath37",
    "( i.e. , whenever @xmath38 ) .",
    "as will be explained in more details below , for @xmath39 our result can be seen as a time - efficient version of the quantum algorithm constructed for the query complexity setting in @xcite .",
    "the query complexity lower bound @xmath28 proved in @xcite shows that the time complexity of our algorithm is optimal , up to a possible polylogarithmic factor , for @xmath39 .",
    "the most interesting part of our results is perhaps the upper bound @xmath40 we obtain for @xmath41 , which corresponds to the case where the output matrix is reasonably dense and differs from the query complexity upper bounds obtained in @xcite .",
    "we additionally show that , for values @xmath41 , no quantum algorithm based on search can perform better than ours unless there exists a quantum algorithm based on search that computes the product of two arbitrary @xmath0 boolean matrices with time complexity significantly better that @xmath42 .",
    "the formal statement follows .",
    "[ theorem2 ] let @xmath43 be any function such that @xmath44 for all @xmath45 .",
    "suppose that , for some value @xmath46 , there exists a quantum algorithm @xmath47 that , given as input any @xmath0 boolean matrices @xmath11 and @xmath12 such that the number of non - zero entries in the product @xmath17 is at most @xmath48 , computes @xmath17 in @xmath49 time . then there exists an algorithm using @xmath47 as a black - box that computes the product of two @xmath0 boolean matrices with overall time complexity @xmath50 .",
    "the reduction stated in theorem [ theorem2 ] is actually classical and combinatorial : the whole algorithm uses only classical combinatorial operations and calls to @xmath47 .",
    "thus theorem  [ theorem2 ] implies that , if for a given value @xmath41 the complexity of theorem  [ theorem_1 ] can be improved to @xmath51 , for some constant @xmath4 , using techniques similar to ours ( i.e. , based on quantum search ) , then there exists an algorithm based on quantum search ( and classical combinatorial operations ) that computes the product of two @xmath0 boolean matrices with time complexity @xmath52 .",
    "the main tool used to obtain our improvements is the new approach by jeffery , kothari and magniez @xcite to find collisions in the graph associated with the multiplication of two @xmath0 boolean matrices .",
    "more precisely , it was shown in @xcite how to find up to @xmath53 collisions in this graph , on a quantum computer , using @xmath54 queries , where @xmath2 is the number of non - zero entries in the product .",
    "we construct ( in section [ sec_coll ] ) a time - efficient version of this algorithm that finds one collision in @xmath55 time .",
    "we then use this algorithm to design a quantum algorithm that computes the matrix product in time @xmath27 when @xmath56 , which proves theorem [ theorem_1 ] for @xmath56 .",
    "our key technique is the introduction of a small data structure that is still powerful enough to enable time - efficient access to exactly all the information about the graph needed by the quantum searches .",
    "more precisely , while the size of the graph considered is @xmath57 , we show that the size of this data structure can be kept much smaller  roughly speaking , the idea is to keep a record of the non - edges of the graph .",
    "moreover , the data structure is carefully chosen so that constructing it , at the beginning of the algorithm , can be done very efficiently ( in @xmath58 time ) , and updating it during the execution of the algorithm can be done at a cost less than the running time of the quantum searches .",
    "we then prove that the ability of finding up to @xmath33 non - zero entries of the matrix product is enough by showing ( in section [ sec_red ] ) a classical reduction , for @xmath59 , from the problem of computing the product of two @xmath0 boolean matrices with at most @xmath2 non - zero entries in the product to the problem of computing @xmath60 separate products of two boolean matrices , each product having at most @xmath61 non - zero entries .",
    "the idea is to randomly permute the rows and columns of the input matrices in order to make the output matrix homogeneous ( in the sense that the non - zero entries are distributed almost uniformly ) , in which case we can decompose the input matrices into smaller blocks and ensure that each product of two smaller blocks contains , with non - negligible probability , at most @xmath61 non - zero entries .",
    "this approach is inspired by a technique introduced by lingas  @xcite and then generalized in @xcite .",
    "the main difference is that here we focus on the number of non - zero entries in the product of each pair of blocks , while @xcite focused mainly on the size of the blocks .",
    "the upper bounds of theorem [ theorem_1 ] for @xmath41 follow directly from our reduction , and a stronger version of this reduction leads to the proof of theorem  [ theorem2 ] .",
    "in this paper we suppose that the reader is familiar with quantum computation , and especially with quantum search and its variants .",
    "we present below the model we are considering for accessing the input matrices on a quantum computer , and computing their product .",
    "this model is the same as the one used in @xcite .",
    "let @xmath11 and @xmath12 be two @xmath0 boolean matrices , for any positive integer @xmath33 ( the model presented below can be generalized to deal with rectangular matrices in a straightforward way ) .",
    "we suppose that these matrices can be accessed directly by a quantum algorithm .",
    "more precisely , we have an oracle  @xmath62 that , for any @xmath63 , any @xmath64 and any @xmath65 , performs the unitary mapping @xmath66 \\rangle}{\\vert z \\rangle } , $ ] where @xmath67 denotes the bit parity ( i.e. , the logical xor ) .",
    "we have a similar oracle @xmath68 for @xmath12 .",
    "since we are interested in time complexity , we will count all the computational steps of the algorithm and assign a cost of one for each call to @xmath62 or @xmath68 , which corresponds to the cases where quantum access to the inputs @xmath11 and @xmath12 can be done at unit cost , for example in a random access model working in quantum superposition ( we refer to @xcite for an extensive treatment of such quantum random access memories )",
    ".    let @xmath69 denote the product of the two matrices @xmath11 and @xmath12 .",
    "given any indices @xmath63 such that @xmath70=1 $ ] , a witness for this non - zero entry is defined as an index @xmath14 such that @xmath15=b[k , j]=1 $ ] .",
    "we define a quantum algorithm for boolean matrix multiplication as follows .",
    "a quantum algorithm for boolean matrix multiplication is a quantum algorithm that , when given access to oracles @xmath62 and @xmath68 corresponding to boolean matrices @xmath11 and @xmath12 , outputs with probability at least @xmath71 all the non - zero entries of the product @xmath17 along with one witness for each non - zero entry .",
    "the complexity of several algorithms in this paper will be stated using an upper bound @xmath48 on the number @xmath2 of non - zero entries in the product @xmath17 . the same complexity , up to a logarithmic factor ,",
    "can actually be obtained even if no nontrivial upper bound on @xmath2 is known a priori .",
    "the idea is , similarly to what was done in @xcite , to try successively @xmath72 ( and find up to 2 non - zero entries ) , @xmath73 ( and find up to 4 non - zero entries ) ,  and stop when no new non - zero entry is found .",
    "the complexity of this approach is , up to a logarithmic factor , the complexity of the last iteration ( in which the value of @xmath48 is @xmath74 if @xmath2 is a power of two , and @xmath75 otherwise ) . in this paper",
    "we will then assume , without loss of generality , that a value @xmath48 such that @xmath76 is always available .",
    "let @xmath11 and @xmath12 be the two @xmath0 boolean matrices of which we want to compute the product . in this section",
    "we define , following @xcite , a graph collision problem and use it to show how to compute up to @xmath61 non - zero entries of @xmath17 . let @xmath77 be a bipartite undirected graph over two disjoint sets  @xmath78 and  @xmath79 , each of size  @xmath33 .",
    "the edge set @xmath80 is then a subset of @xmath81 . when there is no ambiguity it will be convenient to write @xmath82 and @xmath83 .",
    "we now define the concept of a collision for the graph @xmath84 .    for any index @xmath85 ,",
    "a @xmath86-collision for @xmath84 is an edge @xmath87 such that @xmath15=b[k , j]=1 $ ] .",
    "a collision for @xmath84 is an edge @xmath87 that is a @xmath86-collision for some index @xmath85 .",
    "we suppose that the graph @xmath84 is given by a data structure @xmath88 that contains the following information :    * for each vertex @xmath89 in @xmath78 , the degree of @xmath89 ; * for each vertex @xmath89 in @xmath78 , a list of all the vertices of @xmath79 not connected to @xmath89 .",
    "the size of @xmath88 is at most @xmath90 , but the key idea is that its size will be much smaller when @xmath84 is `` close to '' a complete bipartite graph . using adequate data structures to implement  @xmath88 ( e.g. , using self - balancing binary search trees )",
    ", we can perform the following four access operations in @xmath10 time .",
    "* ` get - degree(u ) ` : get the degree of a vertex @xmath91 * ` check - connection(u , v ) ` : check if the vertices @xmath91 and @xmath92 are connected * ` get - vert_{i}(r , d ) ` : get the @xmath93-th smallest vertex in @xmath78 that has degree at most @xmath94 * ` get - vert_{j}(r , u ) ` : get the @xmath93-th smallest vertex in @xmath79 not connected to @xmath91    for the latter two access operations , the order on the vertices refer to the usual order @xmath95 obtained when seeing vertices in @xmath78 and @xmath79 as integers in @xmath96 .",
    "we assume that these two access operations output an error message when the query is not well - defined ( i.e , when @xmath93 is too large ) .",
    "similarly , we can update @xmath88 in @xmath10 time to take in consideration the removal of one edge @xmath97 from @xmath80 ( i.e. , update the degree of @xmath89 and update the list of vertices not connected to  @xmath89 ) .",
    "this low complexity will be crucial since our main algorithm ( in proposition [ proposition_2 ] below ) will remove successively edges from  @xmath80 .",
    "let @xmath98 be an integer such that @xmath99 .",
    "we will define our graph collision problem , denoted @xmath100 , as the problem of finding a collision for @xmath84 under the promise that @xmath101 , i.e. , there are at most @xmath98 missing edges in @xmath84 .",
    "the formal definition is as follows .",
    "@xmath100 @xmath102 here @xmath103 and @xmath99 @xmath104 $ ] + two @xmath0 boolean matrices @xmath11 and @xmath12 a bipartite graph @xmath105 , with @xmath106 , given by @xmath88 an index @xmath85 @xmath107 one @xmath86-collision if such a collision exists    the following proposition shows that there exists a time - efficient quantum algorithm solving this problem .",
    "the algorithm is similar to the query - efficient quantum algorithm given in  @xcite , but uses the data structure @xmath88 in order to keep the time complexity low .",
    "[ prop ] there exists a quantum algorithm running in time @xmath108 that solves , with high probability , the problem @xmath100 .",
    "we will say that a vertex @xmath109 is marked if @xmath15=1 $ ] , and that a vertex @xmath110 is marked if @xmath111=1 $ ] .",
    "our goal is thus to find a pair @xmath87 of marked vertices .",
    "the algorithm is as follows .",
    "we first use the minimum finding quantum algorithm from @xcite to find the marked vertex @xmath89 of largest degree in @xmath78 , in @xmath16 time using ` get - degree(\\cdot ) ` to obtain the order of a vertex from the data structure  @xmath88 .",
    "let @xmath94 denote the degree of @xmath89 , let @xmath112 denote the set of vertices in @xmath78 with degree at most @xmath94 , and let @xmath113 denote the set of vertices in @xmath79 connected to @xmath89 .",
    "we then search for one marked vertex in @xmath113 , using grover s algorithm @xcite with ` check - connection(u,\\cdot ) ` , in @xmath16 time .",
    "if we find one , then this gives us a @xmath86-collision and we end the algorithm .",
    "otherwise we proceed as follows .",
    "note that , since each vertex in @xmath112 has at most @xmath94 neighbors , by considering the number of missing edges we obtain : @xmath114 also note that @xmath115 .",
    "we do a quantum search on @xmath116 to find one pair of connected marked vertices in time @xmath117 , using ` get - vert_{i}(\\cdot , d ) ` to access the vertices in @xmath112 and ` get - vert_{j}(\\cdot , u ) ` to access the vertices in @xmath118 .",
    "we now show how an efficient quantum algorithm that computes up to @xmath61 non - zero entries of the product of two @xmath0 matrices can be constructed using proposition [ prop ] .",
    "[ proposition_2 ] let @xmath48 be a known value such that @xmath119 .",
    "then there exists a quantum algorithm that , given any @xmath0 boolean matrices @xmath11 and @xmath12 such that the number of non - zero entries in the product @xmath17 is at most @xmath48 , computes @xmath17 in time @xmath120 .",
    "let @xmath11 and @xmath12 be two @xmath0 boolean matrices such that the product @xmath17 has at most @xmath48 non - zero entries .",
    "we associate with this matrix multiplication the bipartite graph @xmath121 , where @xmath122 with @xmath123 , and define the edge set as @xmath124 .",
    "the two components @xmath78 and @xmath79 of @xmath84 are then fully connected : there is no missing edge .",
    "it is easy to see that computing the product of @xmath11 and @xmath12 is equivalent to computing all the collisions , since a pair @xmath125 is a collision if and only if the entry in the @xmath126-th row and the @xmath127-th column of the product @xmath17 is 1 .    to find all the collisions",
    ", we will basically repeat the following approach : for a given @xmath86 , search for a new @xmath86-collision in @xmath84 and remove the corresponding edge from @xmath80 by updating the data structure @xmath88 corresponding to @xmath84 . since we know that there are at most @xmath48 non - zero entries in the matrix product @xmath17 , at most @xmath48 collisions will be found ( and then removed ) .",
    "we are thus precisely interested in finding collisions when @xmath128 , i.e. , when there are at most @xmath48 missing edges in @xmath84 .",
    "we can then use the algorithm of proposition [ prop ] .",
    "the main subtlety is that we can not simply try all the indexes @xmath86 successively since the cost would be too high .",
    "instead , we will search for good indexes in a quantum way , as described in the next paragraph .",
    "we partition the set of potential witnesses @xmath129 into @xmath130 subsets @xmath131 , each of size at most @xmath132 . starting with @xmath133",
    ", we repeatedly search for a pair  @xmath125 that is a @xmath86-collision for some @xmath134 .",
    "this is done by doing a grover search over @xmath135 that invokes the algorithm of proposition  [ prop ] . each time a new collision @xmath125 is found ( which is a @xmath86-collision for some @xmath134 ) , we immediately remove the edge @xmath125 from @xmath80 by updating the data structure @xmath88 . when no other collision is found , we move to @xmath136 .",
    "we end the algorithm when the last set @xmath137 has been processed .",
    "this algorithm will find , with high probability , all the collisions in the initial graph , and thus all the non - zero entries of @xmath17 .",
    "let us examine its time complexity .",
    "we first discuss the complexity of creating the data structure @xmath88 ( remember that updating @xmath88 to take in consideration the removal of one edge from @xmath80 has polylogarithmic cost ) .",
    "initially @xmath138 , so each vertex of @xmath78 has the same degree  @xmath33 .",
    "moreover , for each vertex @xmath91 , there is no vertex in @xmath79 not connected to  @xmath89 .",
    "the cost for creating @xmath88 is thus @xmath58 time .",
    "next , we discuss the cost of the quantum search .",
    "let @xmath139 denote the number of collisions found when examining the set @xmath135 .",
    "note that the search for collisions ( the grover search that invokes the algorithm of proposition [ prop ] ) is done @xmath140 times when examining @xmath135 ( we need one additional search to decide that there is no other collision ) .",
    "moreover , we have @xmath141 .",
    "the time complexity of the search is thus @xmath142 the overall time complexity of the algorithm is thus @xmath143 .",
    "suppose that we have a randomized ( or quantum ) algorithm @xmath144 that , given any @xmath145 boolean matrix @xmath11 and any @xmath146 boolean matrix @xmath12 such that the number of non - zero entries in the product @xmath17 is known to be at most @xmath98 , computes @xmath17 with time complexity @xmath147 .",
    "for the sake of simplicity , we will make the following assumptions on @xmath144 :    * the time complexity of @xmath144 does not exceed @xmath147 even if the input matrices do not satisfy the promise ( i.e. , if there are more than @xmath98 non - zero entries in the product ) ; * the algorithm @xmath144 never outputs that a zero entry of the product is non - zero ; * if the matrix product has at most @xmath98 non - zero entries , then with probability at least @xmath148 all these entries are found .",
    "these assumptions can be done without loss of generality when considering quantum algorithms for boolean matrix multiplication as defined in section  [ prelim ] .",
    "assumption ( 1 ) can be guaranteed simply by supposing that the algorithm systematically stops after @xmath147 steps .",
    "assumption  ( 2 ) can be guaranteed since a witness is output for each potential non - zero entry found ( the witness can be used to immediately check the result )",
    ". assumption  ( 3 ) can be guaranted by repeating the original algorithm ( which has success probability at least 2/3 ) a logarithmic number of times .",
    "the goal of this section is to show the following proposition .",
    "[ prop_dec ] let @xmath98 be a known value such that @xmath149 .",
    "then , for any value @xmath150 , there exists an algorithm that , given any @xmath0 boolean matrices @xmath11 and @xmath12 such that the number of non - zero entries in the product @xmath17 is at most  @xmath98 , uses algorithm @xmath144 to compute with high probability the product @xmath17 in time @xmath151    we will need a lemma in order to prove proposition [ prop_dec ] . let @xmath152 be an @xmath0 boolean matrix with at most @xmath98 non - zero entries .",
    "let @xmath93 be a positive integer such that @xmath153 .",
    "we choose an arbitrary partition @xmath154 of the set of rows of @xmath152 into  @xmath93 blocks in which each block has size at most @xmath155 .",
    "similarly , we choose an arbitrary partition @xmath156 of the set of columns of  @xmath152 into @xmath93 blocks in which each block has size at most @xmath155 .",
    "these gives a decomposition of the matrix  @xmath152 into  @xmath157 subarrays ( each of size at most @xmath158 ) .",
    "we would like to say that , since @xmath152 has @xmath98 non - zero entries , then each subarray has at most @xmath159 non - zero entries .",
    "this is of course not true in general , but a similar statement will hold with high probability for a given subarray if we permute the rows and the columns of @xmath152 randomly .",
    "we formalize this idea in the following lemma , which can be seen as an extension of a result proved by lingas ( lemma 2 in @xcite ) .",
    "[ lemma_subarray ] let @xmath152 be an @xmath0 boolean matrix with at most @xmath98 non - zero entries .",
    "assume that @xmath160 and @xmath161 are two permutations of the set @xmath96 chosen independently uniformly at random .",
    "let @xmath70 $ ] be any non - zero entry of @xmath152 . then , with probability",
    "at least @xmath162 , after permuting the rows according to @xmath160 and the columns according to @xmath161 , the subarray containing this non - zero entry ( i.e. , the subarray containing the entry in the @xmath163-th row and the @xmath164-th column ) has at most @xmath165 non - zero entries .",
    "since the permutations @xmath160 and @xmath161 are chosen independently uniformly at random , we can consider that the values @xmath163 and @xmath164 are first chosen , and that only after this choice the @xmath166 other values ( i.e. , @xmath167 for @xmath168 and @xmath169 for @xmath170 ) are chosen .",
    "assume that the values @xmath163 and @xmath164 have been chosen .",
    "consider the subarray of @xmath152 containing the entry in the @xmath163-th row and the @xmath164-th column .",
    "let @xmath113 denote the set of all the entries of the subarray , and let @xmath171 denote the set of all the entries of the subarray that are in the @xmath163-th row or in the @xmath164-th column . note that @xmath172 and @xmath173 .",
    "let @xmath174 , for each @xmath175 , denote the random variable with value one if the entry @xmath176 of the subarray is one , and value zero otherwise .",
    "the random variable representing the number of non - zero entries in the subarray is thus @xmath177 .",
    "the expectation of @xmath178 is @xmath179=\\sum_{s\\in s } e[x_s]=\\sum_{s\\in s\\backslash t } e[x_s]+\\sum_{s\\in t } e[x_s ] & \\le & |s\\backslash t|\\times \\frac{l}{(n-1)^2}+|t|\\\\ & \\le&\\frac{l{\\lceil n / r \\rceil}^2}{(n-1)^2}+2{\\lceil",
    "n / r \\rceil}-1.\\end{aligned}\\ ] ] the first inequality is obtained by using the inequality @xmath180\\le 1 $ ] for each entry @xmath181 , and by noting that each of the non - zero entries of @xmath152 that are neither in the @xmath126-th row nor in the @xmath127-th column has probability exactly @xmath182 to be moved into a given entry in @xmath183 by the permutations of the remaining @xmath184 rows and @xmath184 columns . from markov",
    "s inequality we obtain : @xmath185\\le \\frac{1}{10}.\\ ] ]    the statement of the lemma follows from the observation that the above inequality holds for any choice of @xmath163 and @xmath164 .",
    "take two arbitrary partitions @xmath186 of the set @xmath96 into @xmath93 blocks in which each block has size at most @xmath155 .",
    "let us write @xmath187 it is easy to show that @xmath188 when @xmath189 .",
    "we will repeat the following procedure @xmath190 times , for some large enough constant @xmath191 :    * permute the rows of @xmath11 randomly and denote by @xmath192 the resulting matrix ; + permute the columns of @xmath12 randomly and denote by @xmath193 the resulting matrix ; * decompose @xmath192 into @xmath93 smaller matrices @xmath194 of size at most @xmath195 by partitioning the rows of @xmath192 according to @xmath154 ; + decompose @xmath193 into @xmath93 smaller matrices @xmath196 of size at most @xmath197 by partitioning the columns of @xmath193 according to @xmath156 ; * for each @xmath198 and each @xmath199 , compute up to @xmath200 non - zero entries of the product @xmath201 using the algorithm @xmath144 .",
    "the time complexity of this procedure is @xmath202 , where the additive term @xmath58 represents the time complexity of dealing with the permutations of rows and columns ( note that @xmath192 , @xmath193 , the @xmath203 s and the @xmath204 s have not to be computed explicitly ; we only need to be able to recover in polylogarithmic time a given entry of these matrices ) .",
    "we now show the correctness of the algorithm .",
    "first , the algorithm will never output that a zero entry of @xmath17 is non - zero , from our assumption on the algorithm  @xmath144 .",
    "thus all the entries output by the algorithm are non - zero entries of @xmath17 .",
    "the question is whether all the non - zero entries are output .",
    "let @xmath125 be a fixed non - zero entry of @xmath17 . note that each matrix product @xmath201 corresponds to a subarray of @xmath205 . from our assumptions on algorithm @xmath144 , this entry will be output with probability @xmath206 at step 3 of the procedure if the entry ( after permutation of the rows and the columns ) is in a subarray of @xmath205 containing at most @xmath200 non - zero entries . from lemma [ lemma_subarray ]",
    ", this happens with probability at least @xmath162 .",
    "with probability at least @xmath207 this case will happen at least once during the @xmath190 iterations of the procedure . by choosing the constant @xmath191 large enough , we have @xmath208 , and then the algorithm outputs this non - zero entry with probability at least @xmath209 . by",
    "the union bound we conclude that the probability that the algorithm outputs all the non - zero entries of @xmath17 is at least @xmath210 .",
    "in this section we give the proofs of theorems [ theorem_1 ] and [ theorem2 ] .",
    "let @xmath11 and @xmath12 be two @xmath0 boolean matrices such that the product @xmath17 has @xmath2 non - zero entries .",
    "remember that , as discussed in section  [ prelim ] , an integer @xmath211 such that @xmath212 is known .    if @xmath213 then the product @xmath17 can be computed in time @xmath214 by the algorithm of proposition [ proposition_2 ] . now consider the case @xmath215 . by proposition  [ prop_dec ] ( with the value @xmath216 )",
    ", the product of @xmath11 and @xmath12 can be computed with complexity @xmath217 where @xmath218 .",
    "combined with proposition  [ proposition_2 ] , this gives a quantum algorithm that computes the product @xmath17 in @xmath219 time .",
    "suppose the existence of a quantum algorithm that computes in time @xmath220 the product of any two @xmath0 boolean matrices such that the number of non - zero entries in their product is at most  @xmath48 .",
    "let @xmath191 be a positive constant .",
    "using proposition  [ prop_dec ] with the values @xmath221 and @xmath222 , we obtain a quantum algorithm that computes the product of two @xmath0 boolean matrices in time @xmath223 by choosing the constant @xmath191 large enough , we can rewrite this upper bound as @xmath224 which concludes the proof of the theorem .",
    "the author is grateful to stacey jeffery , robin kothari and frdric magniez for helpful discussions and comments , and for communicating to him preliminary versions of their works .",
    "he also acknowledges support from the jsps and the mext , under the grant - in - aids nos .  24700005 , 24106009 and 24240001 ."
  ],
  "abstract_text": [
    "<S> this paper presents a quantum algorithm that computes the product of two @xmath0 boolean matrices in @xmath1 time , where  @xmath2 is the number of non - zero entries in the product . </S>",
    "<S> this improves the previous output - sensitive quantum algorithms for boolean matrix multiplication in the time complexity setting by buhrman and palek ( soda06 ) and le gall ( soda12 ) . </S>",
    "<S> we also show that our approach can not be further improved unless a breakthrough is made : we prove that any significant improvement would imply the existence of an algorithm based on quantum search that multiplies two @xmath0 boolean matrices in @xmath3 time , for some constant @xmath4 . </S>"
  ]
}