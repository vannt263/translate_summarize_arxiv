{
  "article_text": [
    "the problem of index coding with side information was introduced by birk and kol @xcite and bar - yossef _ et al . _",
    "@xcite studied the class of index coding problems in which each receiver demands only one single message and the number of receivers equals number of messages . ong and ho @xcite classify the binary index coding problem depending on the demands and the side information possessed by the receivers .",
    "an index coding problem is unicast if the demand sets of the receivers are disjoint .",
    "if the problem is unicast and if the size of each demand set is one , then it is said to be single unicast .",
    "any unicast index problem can be equivalently reduced to an single unicast problem discussed in @xcite . for this canonical unicast index coding problem",
    ", it was shown that the length of the optimal linear index code is equal to the minrank of the side information graph of the index coding problem but finding the minrank is np hard .",
    "+ maleki _ et al .",
    "_ @xcite found the capacity of symmetric multiple unicast index problem with neighboring antidotes ( side information ) . in a symmetric multiple unicast index coding problem with equal number of @xmath0 messages and source - destination pairs , each destination has a total of @xmath6 antidotes , corresponding to the @xmath7 messages before (  up \" from ) and @xmath8 messages after (  down \" from ) its desired message . in this",
    "setting , the @xmath9 receiver @xmath10 demands the message @xmath11 having the antidotes @xmath12 the symmetric capacity @xmath13 of this index coding problem setting is shown to be as follows :    @xmath14 @xmath15 + @xmath16 , + @xmath6 , + @xmath17per",
    "message.@xmath18     + the above expression for capacity per message can be equivalently expressed as : @xmath19 in the setting of @xcite with one sided antidote cases , i.e. , the cases where @xmath7 or @xmath8 is zero , without loss of generality , we can assume that @xmath20 and @xmath21 ( all the results hold when @xmath22 ) . in this setting , the @xmath9 receiver @xmath10 demands the message @xmath11 having the antidotes , @xmath23 for which reduces to @xmath24 symbols per message .",
    "+      in the capacity expression given in if @xmath25 divides @xmath26 , capacity can be achieved by using scalar linear codes . in the scalar linear coding one packs @xmath0 messages in @xmath27 dimensions ( code symbols ) .",
    "if @xmath25 does not divide @xmath26 , vector linear coding can only achieve capacity . in the vector linear code",
    ", one needs to pack @xmath28 message symbols corresponding to @xmath0 users in @xmath29 dimensions .",
    "+ in @xcite maleki @xmath30 proved that vector linear coding exists for any arbitrary @xmath7 and @xmath8 over a sufficiently large field size by imposing conditions on encoding and decoding matrices @xmath31 and @xmath32 . in section",
    "ii we prove that vector linear solution exists for a two - sided symmetric antidote problem with @xmath7 antidotes above and @xmath8 antidotes below if a scalar linear solution exists for one - sided antidote problem with same number of messages and number of one - sided antidotes @xmath33 .",
    "we give a construction procedure which constructs a sequence of multiple unicast index problems with two - sided antidotes starting from a given multiple unicast index coding problem of one - sided antidote .",
    "it is shown that if there is an optimal scalar linear index code for the starting problem then this code can be used to construct an optimal vector linear index code for all the extended problems . in @xcite",
    "the authors proposed optimal scalar linear index codes for ten classes of one sided ( not necessarily adjacent ) symmetric multiple unicast index coding problems with optimal scalar linear index codes .",
    "the antidotes assumed in this work is a proper subset of for eight classes .",
    "these optimal codes continue to be optimal if the antidotes are taken to be adjacent as given in .",
    "we illustrate our construction to some of the ten cases of the symmetric multiple unicast problems studied in @xcite and demonstrate the new classes of symmetric multicast problems created for all of which an optimal vector linear code is exhibited .",
    "+ in @xcite , we proposed a lifting construction which constructs a sequence of multiple unicast index problems with one - sided antidotes with a scalar linear index code starting from a given multiple unicast index coding problem with a known scalar linear index code .",
    "the construction in this paper is different in the following two respects :    1 .",
    "the construction in @xcite starts from a problem with @xmath0 messages and gives a sequence of problems with @xmath34 number of messages for @xmath35 i.e. , the number of messages goes on increasing as the index @xmath2 moves .",
    "whereas in this work the number of messages remains @xmath0 and only the size of the antidote sets increase .",
    "2 .   in @xcite new scalar linear index codes",
    "are obtained starting from a scalar linear index code for problems of different source sizes whereas in this paper new vector linear index codes are obtained starting from a scalar linear index code for the problem with the same source size .",
    "+ 3 .   the lifting construction in @xcite results in index coding problems with one sided antidotes where as the construction in this paper results in index coding problems with two sided antidotes .    throughout the paper wlog we consider the case @xmath36 .",
    "all the codes discussed in this paper also applicable for @xmath37 .",
    "the decoding procedure in this paper is considered for the binary field .",
    "however the index codes considered in this paper works for any finite field .",
    "let the messages symbols be @xmath38 for every @xmath39 when we deal with vector linear index codes the different messages symbols corresponding to @xmath40 are denoted by @xmath41 etc .",
    "if @xmath42 do not divide @xmath29 , scalar linear codes can not achieve capacity . in this case capacity",
    "can be achieved by using vector linear coding . in the vector linear code , we require to pack @xmath28 message symbols corresponding to @xmath0 users in @xmath43 dimensions .",
    "we prove that we can pack @xmath28 message symbols into @xmath0 symbols @xmath44 and then convert these @xmath0 symbols into @xmath45 code symbols by using one side adjacent antidote scalar linear code .",
    "define the symbol @xmath46 for @xmath47 as @xmath48 the symbol @xmath46 comprises of @xmath49 message symbols and each of the @xmath28 message symbols appear exactly once in one of the @xmath46 . in the symbol @xmath46",
    ", there exists @xmath49 message symbols and these @xmath49 message symbols are required by the receivers @xmath50 , for @xmath51 +     [ fig : ifgraphexampletheorem ]    [ thm1 ] for a multiple unicast index coding problem with @xmath0 messages @xmath52 and the same number of receivers with the receiver @xmath53 wanting the message @xmath54 and having a symmetric antidote pattern @xmath55 given by @xmath56 let @xmath57 be a scalar linear code of length @xmath58 define @xmath59 as @xmath9 vector message symbol for @xmath47 . for an arbitrary positive integer @xmath7 consider the index coding problem with @xmath0 number of messages @xmath60 and the number of receivers being @xmath61 and receiver @xmath53 ( @xmath62 ) having antidote pattern given by @xmath63 for this index coding problem the code @xmath64 is obtained by replacing every message symbol @xmath54 in the code symbols of @xmath1 with @xmath65 for @xmath66 i.e. , by making the substitution @xmath67    the given scalar linear code @xmath57 of length @xmath68 for a multiple unicast index coding problem with @xmath0 messages @xmath52 and the same number of receivers with the receiver @xmath53 wanting the message @xmath54 and having a symmetric antidote pattern @xmath55 given in enables the decoding of @xmath0 messages @xmath52 .",
    "that is , with linear decoding there exist combination of code symbols @xmath69 to get the sum of the form given in @xmath70 for @xmath71 such that @xmath72 are in antidotes of receiver @xmath10 .",
    "since @xmath73 are less than or equal to @xmath8 for @xmath47 from the sum @xmath74 , receiver @xmath10 can decode its wanted message @xmath46 .",
    "given an arbitrary positive integer @xmath7 consider the index coding problem with @xmath0 number of vector message symbols @xmath60 and the number of receivers being @xmath61 and the receiver @xmath53 ( @xmath62 ) having antidote pattern given by .",
    "the code @xmath64 is the index code obtained by making the substitution @xmath75 in the available code @xmath1 .",
    "we prove that the receiver @xmath10 can decode its wanted message set @xmath76 ( @xmath42 message symbols @xmath77 ) by using the code @xmath64 . for the code @xmath64",
    ", the sum in can be written by + @xmath78 we describe the entire decoding process in the following three steps .",
    "the fig.1 will be helpful to trace these steps .",
    "+ _ step 1 .",
    "decoding of @xmath79 message symbol by receiver @xmath10 _ +   + the sum @xmath80 similar to can be written as    @xmath81    in @xmath80 , only one message symbol is present which is required by @xmath82 we have @xmath83 and thus all other message symbols present in @xmath80 are in antidotes of receiver @xmath10 according to antidote pattern as in .",
    "( note that if @xmath84 comprise @xmath85 message symbols which belong to @xmath86 and @xmath10 requires at least two of them , then messages interfere and @xmath10 can not decode any of them ) .",
    "thus by using @xmath80 , receiver @xmath10 can decode its @xmath79 message symbol @xmath87 .",
    "the code @xmath1 enables the decoding of @xmath44 from the sums @xmath88 , which implies that code @xmath64 enables the the decoding of @xmath89 +   + _ step 2 .",
    "decoding of @xmath90 message symbol by receiver @xmath10 _",
    "+   + receiver @xmath10 uses sum @xmath91 to decode its @xmath90 message symbol @xmath92 .",
    "the sum @xmath91 similar to can be written as +    @xmath93     + where @xmath94 if @xmath95 , else @xmath96 . that is , depending on the value of @xmath97 , sum @xmath91",
    "comprises of either one message symbol or two message symbols belongs to vector message symbol @xmath86 .",
    "+ if @xmath98 , @xmath91 comprises only one message symbol ( @xmath92 ) which belongs to @xmath99 .",
    "all other messages present in @xmath91 are antidotes to @xmath10 .",
    "thus receiver @xmath10 can decode message symbol @xmath92 .",
    "+ if @xmath95 , @xmath91 comprises two message symbols ( @xmath100 ) belongs to vector message symbol @xmath101 receiver @xmath10 has already decoded the message symbol @xmath87 and all other messages present in @xmath91 are antidotes to @xmath10 .",
    "thus receiver @xmath10 can decode message symbol @xmath92 .",
    "+   + _ step l. decoding of @xmath102 message symbol by receiver @xmath10 _",
    "+   + receiver @xmath10 uses sum @xmath103 to decode its @xmath104 message symbol @xmath105 .",
    "the sum @xmath103 similar to can be written as +    @xmath106    where @xmath107 is the indicator function such that @xmath108 if @xmath109 , else it is zero .",
    "@xmath110 if @xmath111 , else @xmath112 for @xmath113 . in the above sum @xmath105",
    "is the required message . + the quantity @xmath114 for @xmath113 is the interference to the receiver @xmath10 from its wanted vector message symbol @xmath86 .",
    "receiver @xmath10 already knows the @xmath115 message symbols @xmath116 and thus the interference from the wanted message symbol @xmath86 in the sum @xmath103 can be canceled .",
    "+ the message symbols in the terms @xmath117 for @xmath113 is in antidotes for receiver @xmath10 .",
    "thus receiver @xmath10 can decode @xmath105 from @xmath103 .",
    "+ this procedure continued until all receiver @xmath10 decode its @xmath42 wanted messages @xmath118 .",
    "thus receiver @xmath10 decodes its wanted vector message symbol @xmath86 .",
    "this completes the proof for decoding .",
    "[ thm2 ] in the construction of theorem [ thm1 ] , if the given code @xmath1 has optimal length @xmath119 then all extended vector linear codes of given code are of optimal length and hence capacity achieving .",
    "the number of code symbols in the extended code is equal to the number of code symbols in @xmath1 which is equal to @xmath45 = @xmath29 . by using @xmath29 code symbols",
    ", every receiver gets @xmath42 of its wanted messages .",
    "the capacity achieved by this code is @xmath120 per message , which is equal to the capacity mentioned in .",
    "it follows that the extended vector linear codes are of optimal length .",
    "the following examples illustrates theorem [ thm1 ] and theorem [ thm2 ]    @xmath121 +   + we have one - sided antidote scalar code @xmath1=@xmath122 .",
    "+   + @xmath123 : @xmath124 +   + @xmath125 , capacity=@xmath126 .",
    "define @xmath127 for @xmath128 we have +   +    @xmath129 , + @xmath130 , + @xmath131 , + @xmath132 , + @xmath133 , + @xmath134 , + @xmath135 , + @xmath136 , + @xmath137 , + @xmath138 .",
    "+ we get the code @xmath139 given by + @xmath140 .",
    "+   + @xmath141 : @xmath142 +   + @xmath125 , capacity=@xmath143 . defining @xmath144 for @xmath145",
    "we get +   +    @xmath146 , + @xmath147 , + @xmath148 , + @xmath149 , + @xmath150 , + @xmath151 , + @xmath152 , + @xmath153 , + @xmath154 , + @xmath155 . + for this case we get the extended code @xmath156 to be + @xmath157 .",
    "+   + @xmath158 : @xmath159 +   + @xmath125 , capacity=@xmath143 . with defining @xmath160 for @xmath161 we end with +   +    @xmath162 , + @xmath163 , + @xmath164 , + @xmath165 , + @xmath166 , + @xmath167 , + @xmath168 , + @xmath169 , + @xmath170 , + @xmath171 .",
    "+ the resulting extended vector linear code is + @xmath172 .",
    "[ thm3 ] consider a multiple unicast index coding problem with @xmath0 messages and the same number of receivers with the receiver @xmath53 wanting the message @xmath40 and having a symmetric antidote pattern @xmath55 given in .",
    "for this index coding problem vector linear solution exists if scalar linear solution exists for one - sided antidote problem as mentioned in with same number of messages and number of one - sided antidotes @xmath33 . the vector linear index code is optimal if the scalar linear code is optimal .",
    "+    proof follows from theorem [ thm1 ] and theorem [ thm2 ] .",
    "[ thm4 ] proposed codes in @xcite can be extended for all @xmath7 and @xmath8 with @xmath173 = @xmath174 for the following problem instances :    1 .",
    "@xmath173 divides @xmath0 2 .",
    "@xmath45 divides @xmath0 3 .",
    "@xmath175 divides @xmath173 4 .",
    "@xmath176 divides @xmath177 5 .",
    "@xmath173 divides @xmath178 and @xmath179 divides @xmath173 where @xmath179 is an integer 6 .",
    "@xmath45 divides @xmath178 and @xmath179 divides @xmath45 7 .",
    "@xmath180 divides @xmath0 and @xmath179 divides @xmath173 8 .",
    "@xmath181 divides @xmath0 and @xmath179 divides @xmath45 9 .",
    "@xmath173 divides @xmath182 and @xmath179 divides @xmath173 10 .",
    "@xmath45 divides @xmath182 and @xmath179 divides @xmath45    in @xcite codes for symmetric instances of one side antidote problem for a given @xmath0 and @xmath8 satisfying the above mentioned conditions with @xmath173 replaced with @xmath8 were proposed .",
    "the proposed codes in @xcite can also be used for the one - sided adjacent antidotes as given in and these codes achieve the capacity in .",
    "then the proof follows from theorem [ thm1 ] .",
    "_ corollary 1 .",
    "_ if @xmath8 divides @xmath0 then the proposed optimal length scalar linear code is @xmath183    @xmath142 +   + @xmath184 , capacity=@xmath143 .",
    "+ let @xmath144 for @xmath128 +   +    @xmath146 , + @xmath147 , + @xmath148 , + @xmath149 , + @xmath150 , + @xmath151 , + @xmath152 , + @xmath153 , + @xmath154 , + @xmath155 .",
    "+    the proposed code is @xmath185 .",
    "@xmath186 .",
    "_ corollary 2 .",
    "_ if divides @xmath0 , then the proposed code is @xmath187 where @xmath188 and .",
    "+    @xmath189 .",
    "+   + @xmath190 , capacity=@xmath191 .",
    "+ let @xmath127 for @xmath128 +   + @xmath129 , + @xmath130 , + @xmath131 , + @xmath132 , + @xmath133 , + @xmath134 , + @xmath135 , + @xmath136 , + @xmath137 , + @xmath138 .",
    "+    the proposed code is , + @xmath192 +   + @xmath193 +    _ corollary 3 .",
    "_ for the case @xmath194 divides @xmath8 , the proposed scalar linear code is , + @xmath195 where @xmath196 , @xmath197 and @xmath198 .",
    "+    @xmath199 .",
    "+   + @xmath200 , capacity=@xmath201 .",
    "+ let @xmath127 for @xmath128 +   + @xmath202 , + @xmath203 + @xmath204 + @xmath205 + @xmath206 , + @xmath207 , + @xmath208 .",
    "+   + the proposed code is @xmath209 + @xmath210 .",
    "+ @xmath211    _ corollary 4 . _",
    "if @xmath8 divides @xmath178 and @xmath179 divides @xmath8 , then the scalar linear code is given by @xmath212 } for @xmath213 and @xmath214 .",
    "@xmath215 +   + @xmath216 , capacity=@xmath217 .",
    "+ let @xmath144 for @xmath218 +   +    @xmath219 , + @xmath220 , + @xmath148 , + @xmath149 , + @xmath150 , + @xmath151 , + @xmath152 , + @xmath153 , + @xmath154 , + @xmath155 , + and @xmath221 + the proposed code is @xmath222 +   + @xmath223    _ corollary 5 . _",
    "if @xmath224 divides @xmath225 @xmath179 divides @xmath226 , then the proposed scalar linear code is @xmath227 .",
    "+   + @xmath229  capacity=@xmath191 .",
    "+ let @xmath127 for @xmath218 +   +    @xmath230 , + @xmath130 , + @xmath131 , + @xmath132 , + @xmath133 , + @xmath134 , + @xmath135 , + @xmath136 , + @xmath137 , + @xmath138 , + and @xmath231 +   + the proposed code is @xmath232 +   + @xmath233 +    _ corollary 6 . _ for the case @xmath234 divides @xmath61 @xmath179 divides @xmath8 , the scalar linear code is + @xmath235 } where @xmath236 and @xmath237    @xmath238 +   + @xmath239 , capacity=@xmath240 .",
    "+ let @xmath127 for @xmath241 +   +    @xmath242 , + @xmath243 , + @xmath244 , + @xmath245 , + @xmath246 , + @xmath247 , + @xmath248 , + @xmath249 , + @xmath250 , +   + the proposed code is @xmath251 .",
    "+   +    @xmath252    _ corollary 7 . _",
    "if divides @xmath0 and @xmath179 divides , then the scalar linear code is given by @xmath253 } where @xmath254 and @xmath255 .",
    "@xmath256 +   + @xmath257 , capacity=@xmath191 .",
    "+ let @xmath127 for @xmath258 +   +   +    @xmath259 , + @xmath260 , + @xmath261 , + @xmath262 , + @xmath263 , + @xmath264 , + @xmath265 , + @xmath266 , + @xmath267 , + @xmath268 , + @xmath269 , + @xmath270 .",
    "+   + the proposed code is @xmath271 .",
    "+   + @xmath272 +    _ corollary 8 .",
    "_ if @xmath8 divides @xmath182 and @xmath179 divides @xmath8 , then the scalar linear code is given by @xmath273 where @xmath274 , @xmath275 mod @xmath8 = @xmath276 .",
    "@xmath277 +   + @xmath278 , capacity=@xmath279 .",
    "+ let @xmath144 for @xmath280 +   +    @xmath281 , + @xmath147 , + @xmath148 , + @xmath149 , + @xmath150 , + @xmath151 , + @xmath152 , + @xmath153 , + @xmath154 , + @xmath282 +   + the proposed code is @xmath283 @xmath284    _ corollary 9 .",
    "_ if @xmath224 divides @xmath182 and @xmath179 divides @xmath224 , then the scalar linear code + @xmath1=@xmath285 + where @xmath188 , @xmath286 , @xmath287 and .",
    "@xmath288 +   + @xmath289 , capacity=@xmath290 .",
    "+ let @xmath127 for @xmath291 +   + @xmath292 , + @xmath293 , + @xmath294 , + @xmath295 , + @xmath296 , + @xmath297 , + @xmath298 , + @xmath299 , + @xmath300 , + @xmath301 , + @xmath302 , + @xmath303 , + @xmath304 , + @xmath305 .",
    "+   + the proposed code is @xmath306 +   + @xmath307 +",
    "in this paper a construction is given for vector linear index codes of multiple unicast index problems from scalar linear codes which results in a sequence of index coding problems with same number of messages and receivers and two sided antidote patterns .",
    "moreover , it is shown that if the problem with which the construction begins has an optimal linear index code then it induces an optimal linear index code for the vector index coding problem .",
    "this construction has been used on few classes of index coding problems given in @xcite for which optimal linear index codes are known and new classes codes have been obtained starting from these classes of codes .",
    "+ another interesting direction of further research is to study the suitability of the new classes of codes presented in this paper for application to noise broadcasting problem .",
    "recently , it has been observed that in a noisy index coding problem it is desirable for the purpose of reducing the probability of error that the receivers use as small a number of transmissions from the source as possible and linear index codes with this property have been reported in @xcite , @xcite . while the report @xcite considers fading broadcast channels , in @xcite awgn channels",
    "are considered and it is reported that linear index codes with minimum length ( capacity achieving codes or optimal length codes ) help to facilitate to achieve more reduction in probability of error compared to non - minimum length codes for receivers with large amount of side - information .",
    "these aspects remain to be investigated for the new classes of sequences of vector codes presented in this paper .",
    "l ong and c k ho , `` optimal index codes for a class of multicast networks with receiver side information '' , in _ proc .",
    "ieee icc _ , 2012 , pp .",
    "2213 - 2218 .",
    "roop kumar bhattaram , mahesh babu vaddi and b. sundar rajan , `` a lifting construction for scalar linear index codes , '' arxiv:1510.08592 [ cs.it ] 29 , oct 2015 .",
    "anoop thomas , kavitha radhakumar , attada chandramouli and b. sundar rajan , `` optimal index coding with min - max probability of error over fading , '' pimrc 2015 , hong kong , august 2015 ."
  ],
  "abstract_text": [
    "<S> this paper deals with vector linear index codes for multiple unicast index coding problems where there is a source with @xmath0 messages and there are @xmath0 receivers each wanting a unique message and having symmetric ( with respect to the receiver index ) two - sided antidotes ( side information ) . optimal scalar linear index codes for several such instances of this class of problems for one - sided antidotes(not necessarily adjacent ) have been reported in @xcite . </S>",
    "<S> these codes can be viewed as special cases of the symmetric unicast index coding problems discussed in @xcite with one sided adjacent antidotes . in this paper , starting from a given multiple unicast index coding problem with with @xmath0 messages and one - sided adjacent antidotes for which a scalar linear index code @xmath1 is known , we give a construction procedure which constructs a sequence ( indexed by @xmath2 ) of multiple unicast index problems with two - sided adjacent antidotes ( for the same source ) for all of which a vector linear code @xmath3 is obtained from @xmath4 also , it is shown that if @xmath1 is optimal then @xmath3 is also optimal for all @xmath5 we illustrate our construction for some of the optimal scalar linear codes of @xcite though the construction is applicable for all the codes of @xcite . </S>"
  ]
}