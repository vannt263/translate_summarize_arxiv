{
  "article_text": [
    "the scale and complexity of machine learning ( ml ) algorithms are becoming increasingly large .",
    "almost all recent imagenet challenge  @xcite winners employ neural networks with very deep layers , requiring billions of floating - point operations to process one single sample .",
    "the rise of structural and computational complexity poses interesting challenges to ml system design and implementation .",
    "most ml systems embed a domain - specific language ( dsl ) into a host language ( e.g. python , lua , c++ ) .",
    "possible programming paradigms range from _ imperative _ , where the user specifies exactly `` how '' computation needs to be performed , and _ declarative _ , where the user specification focuses on `` what '' to be done .",
    "examples of imperative programming include numpy and matlab , whereas packages such as caffe , cxxnet program over layer definition which abstracts away and hide the inner - working of actual implementation .",
    "the dividing line between the two can be muddy at times .",
    "frameworks such as theano and the more recent tensorflow can also be viewed as a mixture of both , they declare a computational graph , yet the computation within the graph is imperatively specified .",
    "related to the issue of programming paradigms is how the computation is carried out .",
    "execution can be _ concrete _ , where the result is returned right away on the same thread , or _",
    "asynchronize _ or _ delayed _ , where the statements are gathered and transformed into a dataflow graph as an intermediate representation first , before released to available devices .",
    "these two execution models have different implications on how inherent parallelisms are discovered .",
    "concrete execution is restrictive ( e.g. parallelized matrix multiplication ) , whereas asynchronize / delayed execution additionally identified all parallelism within the scope of an instance of dataflow graph automatically .",
    "the combination of the programming paradigm and execution model yields a large design space , some of which are more interesting ( and valid ) than others .",
    "in fact , our team has collectively explored a number of them , as does the rest of the community .",
    "for example , minerva  @xcite combines imperative programming with asynchronize execution . while theano takes an declarative approach , enabling more global graph - aware optimization .",
    "similar discipline was adopted in purine2  @xcite .",
    "instead , cxxnet adopts declarative programming ( over tensor abstraction ) and concrete execution , similar to caffe  @xcite .",
    "table  [ tab : dsl ] gives more examples .",
    "our combined new effort resulted in _ mxnet _ ( or `` mix - net '' ) , intending to blend advantages of different approaches .",
    "declarative programming offers clear boundary on the global computation graph , discovering more optimization opportunity , whereas imperative programs offers more flexibility . in the context of deep learning , declarative programming is useful in specifying the computation structure in neural network configurations , while imperative programming are more natural for parameter updates and interactive debugging .",
    "we also took the effort to embed into multiple host languages , including c++ , python , r , go and julia .    despite the support of multiple languages and combination of different programming paradigm , we are able to fuse the execution to the same backend engine",
    ". the engine tracks data dependencies across computation graphs and imperative operations , and schedules them efficiently jointly .",
    "we aggressively reduce memory footprint , performing in - place update and memory space reuse whenever possible . finally , we designed a compact communication api so that a mxnet program runs on multiple machines with little change .    comparing to other open - source ml systems , mxnet provides a superset programming interface to torch7  @xcite , theano  @xcite , chainer  @xcite and caffe  @xcite , and supports more systems such as gpu clusters .",
    "besides supporting the optimization for declarative programs as tensorflow  @xcite do , mxnet additionally embed imperative tensor operations to provide more flexibility .",
    "mxnet is lightweight , e.g.  the prediction codes fit into a single 50k lines c++ source file with no other dependency , and has more languages supports .",
    "more detailed comparisons are shown in table  [ tab : comp ] .",
    "r.3      execute @xmath0 & eagerly compute and store the results on @xmath1 as the same type with @xmath2 . & return a computation graph ; bind data to @xmath2 and do the computation later .",
    "+ advantages & conceptually straightforward , and often works seamless with the host language s build - in data structures , functions , debugger , and third - party libraries . & obtain the whole computation graph before execution , beneficial for optimizing the performance and memory utilization . also convenient to implement functions such as load ,",
    "save , and visualization .",
    "+    .compare to other popular open - source ml libraries [ cols=\"<,<,<,<,^,^,^,^ \" , ]",
    "mxnet uses multi - output symbolic expressions , ` symbol ` , declare the computation graph .",
    "symbols are composited by operators , such as simple matrix operations ( e.g. `` + '' ) , or a complex neural network layer ( e.g. convolution layer ) .",
    "an operator can take several input variables , produce more than one output variables , and have internal state variables .",
    "a variable can be either free , which we can bind with value later , or an output of another symbol .",
    "figure  [ fig : julia ] shows the construction of a multi - layer perception symbol by chaining a variable , which presents the input data , and several layer operators .    to evaluate a symbol we need to bind the free variables with data and declare the required outputs . beside evaluation",
    "( `` forward '' ) , a symbol supports auto symbolic differentiation ( `` backward '' ) .",
    "other functions , such as load , save , memory estimation , and visualization , are also provided for symbols .    .... using mxnet mlp = @mx.chain mx.variable(:data ) = >    mx.fullyconnected(num_hidden=64 ) = >    mx.activation(act_type=:relu )     = >    mx.fullyconnected(num_hidden=10 ) = >    mx.softmax ( )       ....    .... > > > import mxnet as mx > > > a = mx.nd.ones((2 , 3 ) , ...",
    "mx.gpu ( ) ) > > > print ( a * 2).asnumpy ( ) [ [ 2 .   2 .   2 . ]",
    "[ 2 .   2 .   2 . ] ]       ....      mxnet offers ` ndarray ` with imperative tensor computation to fill the gap between the declarative symbolic expression and the host language .",
    "figure  [ fig : python ] shows an example which does matrix - constant multiplication on gpu and then prints the results by ` numpy.ndarray ` .    `",
    "ndarray ` abstraction works seamlessly with the executions declared by ` symbol ` , we can mix the imperative tensor computation of the former with the latter .",
    "for example , given a symbolic neural network and the weight updating function , e.g.  @xmath3 . then we can implement the gradient descent by    .... while(1 ) { net.foward_backward ( ) ; net.w -= eta * net.g } ; ....    the above is as efficient as the implementation using a single but often much more complex symbolic expression .",
    "the reason is that mxnet uses lazy evaluation of ` ndarray ` and the backend engine can correctly resolve the data dependency between the two .",
    "the ` kvstore ` is a distributed key - value store for data synchronization over multiple devices .",
    "it supports two primitives : _ push _ a key - value pair from a device to the store , and _ pull _ the value on a key from the store .",
    "in addition , a user - defined updater can specify how to merge the pushed value .",
    "finally , model divergence is controlled via consistency model  @xcite .",
    "currently , we support the sequential and eventual consistency .",
    "the following example implements the distributed gradient descent by data parallelization .    ....",
    "while(1 ) { kv.pull(net.w ) ; net.foward_backward ( ) ; kv.push(net.g ) ; } ....    where the weight updating function is registered to the ` kvstore ` , and each worker repeatedly pulls the newest weight from the store and then pushes out the locally computed gradient .",
    "the above mixed implementation has the same performance comparing to a single declarative program , because the actual data push and pull are executed by lazy evaluation , which are scheduled by the backend engine just like others .",
    "mxnet ships with tools to pack arbitrary sized examples into a single compact file to facilitate both sequential and random seek .",
    "data iterators are also provided .",
    "data pre - fetching and pre - processing are multi - threaded , reducing overheads due to possible remote file store reads and/or image decoding and transformation .",
    "the training module implements the commonly used optimization algorithms , such as stochastic gradient descent .",
    "it trains a model on a given symbolic module and data iterators , optionally distributedly if an additional ` kvstore ` is provided .",
    "r[0pt].35     a binded symbolic expression is presented as a computation graph for evaluation .",
    "figure  [ fig : graph ] shows a part of the graph of both forward and backward of the mlp symbol in figure  [ fig : julia ] . before evaluation",
    ", mxnet transforms the graph to optimize the efficiency and allocate memory to internal variables .",
    "* graph optimization .",
    "* we explore the following straightforward optimizations .",
    "we note first that only the subgraph required to obtain the outputs specified during binding is needed .",
    "for example , in prediction only the forward graph is needed , while for extracting features from internal layers , the last layers can be skipped .",
    "secondly , operators can be grouped into a single one .",
    "for example , @xmath4 is replaced by a single blas or gpu call .",
    "finally , we manually implemented well - optimized `` big '' operations , such as a layer in neural network .",
    "* memory allocation . *",
    "note that each variable s life time , namely the period between the creation and the last time will be used , is known for a computation graph .",
    "so we can reuse memory for non - intersected variables .",
    "however , an ideal allocation strategy requires @xmath5 time complexity , where @xmath6 is the number of variables .",
    "we proposed two heuristics strategies with linear time complexity .",
    "the first , called _ inplace _ , simulates the procedure of traversing the graph , and keeps a reference counter of depended nodes that are not used so far .",
    "if the counter reaches zero , the memory is recycled .",
    "the second , named _ co - share _ , allows two nodes to share a piece of memory if only if they can not be run in parallel .",
    "exploring co - share imposes one additional dependency constraint .",
    "in particular , each time upon scheduling , among the pending paths in the graph , we find the longest path and perform needed memory allocations .      in mxnet , each source units , including ` ndarray ` ,",
    "random number generator and temporal space , is registered to the engine with a unique tag .",
    "any operations , such as a matrix operation or data communication , is then pushed into the engine with specifying the required resource tags .",
    "the engine continuously schedules the pushed operations for execution if dependencies are resolved .",
    "since there usually exists multiple computation resources such as cpus , gpus , and the memory / pcie buses , the engine uses multiple threads to scheduling the operations for better resource utilization and parallelization .",
    "different to most dataflow engines  @xcite , our engine tracks mutation operations as an existing resource unit .",
    "that is , ours supports the specification of the tags that a operation will _ write _ in addition to _",
    "read_. this enables scheduling of array mutations as in numpy and other tensor libraries .",
    "it also enables easier memory reuse of parameters , by representing parameter updates as mutating the parameter arrays .",
    "it also makes scheduling of some special operations easier .",
    "for example , when generating two random numbers with the same random seed , we can inform the engine they will write the seed so that they should not be executed in parallel .",
    "this helps reproducibility .",
    "r.3     we implemented ` kvstore ` based on the parameter server  @xcite(figure  [ fig : ps ] ) .",
    "it differs to previous works in two aspects : first , we use the engine to schedule the ` kvstore ` operations and manage the data consistency .",
    "the strategy not only makes the data synchronization works seamless with computation , and also greatly simplifies the implementation .",
    "second , we adopt an two - level structure .",
    "a level-1 server manages the data synchronization between the devices within a single machine , while a level-2 server manages inter - machine synchronization .",
    "outbound data from a level-1 server can be aggregated , reducing bandwidth requirement ; intra- and inter - machine synchronization can use different consistency model ( e.g. intra- is sequential and inter- is eventual ) .",
    "[ [ raw - performance ] ] raw performance + + + + + + + + + + + + + + +    we fist compare mxnet with torch7 , caffe , and tensorflow on the popular `` convnet - benchmarks ''  @xcite .",
    "all these systems are compiled with cuda 7.5 and cudnn 3 except for tensorflow , which only supports cuda 7.0 and cudnn 2 .",
    "we use batch size 32 for all networks and run the experiments on a single nvidia gtx 980 card .",
    "results are shown in figure  [ fig : conv_time ] . as expected that mxnet has similar performance comparing to torch7 and caffe , because most computations are spent on the cuda / cudnn kernels .",
    "tensorflow is always 2x slower , which might be due its use of a lower cudnn version .",
    "[ [ memory - usage ] ] memory usage + + + + + + + + + + + +    figure  [ fig : conv_mem ] shows the memory usages of the internal variables excepts for the outputs .",
    "as can be seen , both `` inplace '' and `` co - share '' can effective reduce the memory footprint . combing them",
    "leads to a 2x reduction for all networks during model training , and further improves to 4x for model prediction .",
    "for instance , even for the most expensive vgg net , training needs less than _ 16 mb _ extra .",
    "r6 cm     [ [ scalability ] ] scalability + + + + + + + + + + +    we run the experiment on amazon ec2 g2.8x instances , each of which is shipped with four nvidia gk104 gpus and 10 g ethernet .",
    "we train googlenet with batch normalization  @xcite on the ilsvrc12 dataset  @xcite which consists of 1.3 million images and 1,000 classes .",
    "we fix the learning rate to @xmath7 , momentum to @xmath8 , weight decay to @xmath9 , and feed each gpu with @xmath10 images in one batch .",
    "the convergence results are shown in figure  [ fig : dist_converge ] . as can be seen , comparing to single machine",
    ", the distributed training converges slower at the beginning , but outperforms after 10 data passes .",
    "the average cost of a data pass is 14k and 1.4k sec on a single machine and 10 machines , respectively .",
    "consequently , this experiment reveals a super - linear speedup .",
    "mxnet is a machine learning library combining symbolic expression with tensor computation to maximize efficiency and flexibility .",
    "it is lightweight and embeds in multiple host languages , and can be run in a distributed setting .",
    "experimental results are encouraging . while we continue to explore new design choices , we believe it can already benefit the relevant research community .",
    "the codes are available at http://dmlc.io .",
    "frdric bastien , pascal lamblin , razvan pascanu , james bergstra , ian goodfellow , arnaud bergeron , nicolas bouchard , david warde - farley , and yoshua bengio .",
    "theano : new features and speed improvements . , 2012 .",
    "j.  dean , g.  corrado , r.  monga , k.  chen , m.  devin , q.  le , m.  mao , m.  ranzato , a.  senior , p.  tucker , k.  yang , and a.  ng .",
    "large scale distributed deep networks . in _ neural information processing systems _ , 2012 .",
    "yangqing jia , evan shelhamer , jeff donahue , sergey karayev , jonathan long , ross girshick , sergio guadarrama , and trevor darrell .",
    "caffe : convolutional architecture for fast feature embedding . in _ proceedings of the acm international conference on multimedia _ , pages 675678 .",
    "acm , 2014 .",
    "abadi martn , ashish agarwal , paul barham , eugene brevdo , zhifeng chen , craig citro , greg corrado , andy davis , jeffrey dean , matthieu devin , sanjay ghemawat , ian goodfellow , andrew harp , geoffrey irving , michael isard , yangqing jia , rafal jozefowicz , lukasz kaiser , manjunath kudlur , josh levenberg , dan mane , rajat monga , sherry moore , derek murray , chris olah , mike schuster , jonathon shlens , benoit steiner , ilya sutskever , kunal talwar , paul tucker , vincent vanhoucke , vijay vasudevan , fernanda viegas , oriol vinyals , pete warden , martin wattenberg , martin wicke , yuan yu , and xiaoqiang zheng .",
    "tensorflow : large - scale machine learning on heterogeneous systems .",
    "olga russakovsky , jia deng , hao su , jonathan krause , sanjeev satheesh , sean ma , zhiheng huang , andrej karpathy , aditya khosla , michael bernstein , alexander  c. berg , and li  fei - fei . . ,",
    "115(3):211252 , 2015 .",
    "olga russakovsky , jia deng , hao su , jonathan krause , sanjeev satheesh , sean ma , zhiheng huang , andrej karpathy , aditya khosla , michael bernstein , et  al . imagenet large scale visual recognition challenge . , pages 142 , 2014 ."
  ],
  "abstract_text": [
    "<S> mxnet is a multi - language machine learning ( ml ) library to ease the development of ml algorithms , especially for deep neural networks . </S>",
    "<S> embedded in the host language , it blends declarative symbolic expression with imperative tensor computation . </S>",
    "<S> it offers auto differentiation to derive gradients . </S>",
    "<S> mxnet is computation and memory efficient and runs on various heterogeneous systems , ranging from mobile devices to distributed gpu clusters .    </S>",
    "<S> this paper describes both the api design and the system implementation of mxnet , and explains how embedding of both symbolic expression and tensor operation is handled in a unified fashion . </S>",
    "<S> our preliminary experiments reveal promising results on large scale deep neural network applications using multiple gpu machines . </S>"
  ]
}