{
  "article_text": [
    "the performance guarantee of local search and greedy algorithms for scheduling problems is well studied and understood . for most algorithms , matching upper and lower bounds on their approximation ratio are known .",
    "the lower bounds are often somewhat contrived , however , and it is questionable whether they resemble typical instances in practical applications . for that reason , we study these algorithms in the framework of smoothed analysis , in which instances are subject to some degree of random noise . by doing so , we find out for which heuristics and scheduling variants the lower bounds are robust and for which they are fragile and not very likely to occur in practical applications . since pure nash equilibria can be seen as local optima , our results also imply a new bound on the smoothed price of anarchy , showing that known worst - case results are too pessimistic in the presence of noise .",
    "let us first describe the scheduling problems that we study .",
    "we assume that there is a set @xmath3 of jobs each of which needs to be processed on one of the machines from the set @xmath4 .",
    "all jobs and machines are available for processing at time  @xmath5 .",
    "the goal is to schedule the jobs on the machines such that the _ makespan _ ,",
    "i.e. , the time at which the last job is completed , is minimized .",
    "each machine  @xmath6 has a speed  @xmath7 and each job  @xmath8 has a processing requirement  @xmath9 .",
    "the time  @xmath10 it takes to fully process job  @xmath11 on machine  @xmath12 depends on the machine environment .",
    "we consider two machine environments .",
    "the first one is the one of _ uniform parallel machines _ , also known as _ related machines _ : @xmath13 .",
    "the second machine environment that we consider is the one of _ restricted related machines _ : a job  @xmath11 is only allowed to be processed on a subset @xmath14 of the machines .",
    "the processing time is therefore @xmath13 if @xmath15 and @xmath16 if @xmath17 .",
    "an instance  @xmath18 of a scheduling problem consists of the machine speeds @xmath19 , the processing requirements @xmath20 , and in the restricted case the allowed machine set  @xmath14 for every job  @xmath11 .",
    "a special case for both machine environments is when all speeds are equal , i.e. , @xmath21 for all @xmath6 . in this case",
    ", we say that the machines are identical . in the notation of graham et al .",
    "@xcite these problems are denoted by @xmath22 and @xmath23 for the related machine problems and @xmath24 and @xmath25 in case of identical machines . in these problems , makespan minimization is equivalent to minimizing the maximum machine finishing time .",
    "once the assignment of the jobs to the machines is known , the order in which the jobs are processed is of no importance to determine the machine finishing times , as long as the jobs are processed without any idle time in between .",
    "therefore , we assume that the jobs that are scheduled on a machine @xmath12 share this processor in such a way that they all finish at the same time .    even in the case that all speeds are equal , the problems under consideration are known to be strongly np - hard when @xmath26 is part of the input ( see , e.g. , garey and johnson  @xcite ) .",
    "this has motivated a lot of research in the previous decades on approximation algorithms for scheduling problems .",
    "since some of the theoretically best approximation algorithms are rather involved , a lot of research has focused on simple heuristics like _ greedy algorithms _ and _ local search algorithms _ which are easy to implement . while greedy algorithms make reasonable ad hoc decisions to obtain a schedule , local search algorithms start with some schedule and iteratively improve the current schedule by performing some kind of local improvements until no such is possible anymore . in this article",
    ", we consider the following algorithms that can be applied to all scheduling variants that we have described above :    * _ list scheduling _ is a greedy algorithm that starts from an empty schedule and a list of jobs .",
    "then , it repeatedly selects the next unscheduled job from the list and assigns it to the machine on which it will be completed the earliest with respect to the current partial schedule .",
    "we call any schedule that can be generated by list scheduling a _ list schedule_. * the _ jump _ and the _ lex - jump _ algorithms are local search algorithms that start with an arbitrary schedule and iteratively perform a local improvement step . in each improvement step ,",
    "one job is reassigned ( jumped ) from a machine  @xmath12 to a different machine  @xmath27 where it finishes earlier . in the jump algorithm , only jobs on _ critical _ machines  @xmath12 , i.e. , machines that have maximum finishing time , are considered to be improving . in the lex - jump algorithm , the jobs can be arbitrary .",
    "note that a local step is lex - jump improving if and only if the sorted vector of machine finishing times decreases lexicographically , hence the term lex - jump . a schedule",
    "for which there is no jump improvement step or no lex - jump improvement step is called _ jump optimal _ or _ lex - jump optimal _ , respectively .    for each of these three algorithms",
    ", we are interested in their performance guarantees , i.e. , the worst case bound on the ratio of the makespan of a schedule to be returned by the algorithm over the makespan of an optimal schedule . the final schedule returned by a local search algorithm",
    "is called a _",
    "local optimum_. usually , there are multiple local optima for a given scheduling instance both for the jump and the lex - jump algorithm with varying quality . as we do not know which local optimum",
    "is found by the local search , we will always bound the quality of the worst local optimum . since local optima for lex - jump and pure nash equilibria are the same , see e.g.  @xcite",
    ", this corresponds to bounding the price of anarchy in the scheduling game that is obtained if jobs are selfish agents trying to minimize their own completion time and if the makespan is considered as the welfare function .",
    "similarly , list scheduling can produce different schedules depending on the order in which the jobs are inserted into the list . also for list scheduling we will bound the quality of the worst schedule that can be obtained .",
    "[ [ notation . ] ] notation .",
    "+ + + + + + + + +    consider an instance  @xmath18 for the scheduling problem and a schedule  @xmath28 for this instance . by  @xmath29",
    "we denote the set of jobs assigned to machine  @xmath12 according to  @xmath28 . the _ processing requirement on a machine  @xmath6 _",
    "is defined as @xmath30 and the _ load _ of a machine is defined by @xmath31 .",
    "the makespan  @xmath32 of  @xmath28 can be written as @xmath33 .",
    "the optimal makespan , i.e. , the makespan of an optimal schedule is denoted by  @xmath34 . by  @xmath35 , @xmath36 , and  @xmath37",
    "we denote the set of all feasible jump optimal schedules , lex - jump optimal schedules , and list schedules , respectively , according to instance  @xmath18 .",
    "if the instance  @xmath18 is clear from the context , we simply write  @xmath38 instead of  @xmath39 , @xmath40 instead of @xmath32 , and  @xmath41 instead of  @xmath34 . if the schedule  @xmath28 is clear as well ,",
    "we simplify our notation further to  @xmath42 and  @xmath43 and we write  @xmath44 instead of  @xmath45 . by appropriate scaling , we may assume w.l.o.g.that the slowest machine has speed  @xmath46 and that all processing requirements are bounded by @xmath47 . in appendix",
    "[ sec : appendix - table ] , the notation is summarized in a table .",
    "[ [ smoothed - analysis . ] ] smoothed analysis .",
    "+ + + + + + + + + + + + + + + + + +    as can be seen in table  [ tab : results ] , the worst - case approximation guarantee of jump and lex - jump is known for all scheduling variants and it is constant only for the simplest case with unrestricted and identical machines . in all other cases it increases with the number  @xmath26 of machines . for list scheduling",
    ", the case with unrestricted and related machines has been considered .",
    "cho and sahni  @xcite and aspnes et al .",
    "@xcite showed that the performance guarantee of list scheduling is @xmath48 in this case .    in order to analyze the robustness of the worst - case bounds , we turn to the framework of smoothed analysis , introduced by spielman and teng  @xcite to explain why certain algorithms perform well in practice in spite of a poor worst - case running time .",
    "smoothed analysis is a hybrid of average - case and worst - case analysis : first , an adversary chooses an instance .",
    "second , this instance is slightly randomly perturbed .",
    "the smoothed performance is the expected performance , where the expectation is taken over the random perturbation .",
    "the adversary , trying to make the algorithm perform as bad as possible , chooses an instance that maximizes this expected performance .",
    "this assumption is made to model that often the input an algorithm gets is subject to imprecise measurements , rounding errors , or numerical imprecision .",
    "if the smoothed performance guarantee of an algorithm is small , then bad worst - case instances might exist , but one is very unlikely to encounter them if instances are subject to some small amount of random noise .",
    "we follow the more general model of smoothed analysis introduced by beier and vcking  @xcite . in this model ,",
    "the adversary is even allowed to specify the probability distribution of the random noise .",
    "the influence he can exert is described by a parameter  @xmath49 denoting the maximum density of the noise .",
    "this model is formally defined as follows .",
    "[ def : phi - smooth ] in a _ @xmath50-smooth _",
    "instance  @xmath51 , the adversary chooses the following input data :    * the number  @xmath26 of machines ; * arbitrary machine speeds @xmath52 , in the case of non - identical machines ; * the number  @xmath53 of jobs ; * an arbitrary set @xmath14 for each job  @xmath54 , in the case of restricted machines ; * for each  @xmath9 , a probability density @xmath55\\to[0,\\phi]$ ] according to which @xmath9 is chosen independently of the processing requirements of the other jobs .",
    "note that the only perturbed part of the instance are the processing requirements .",
    "formally , a @xmath50-smooth instance is not a single instance but a distribution over instances .",
    "we write @xmath56 to denote that the instance @xmath18 is drawn from the @xmath50-smooth instance @xmath51 .",
    "the parameter  @xmath50 specifies how close the analysis is to a worst case analysis .",
    "the adversary can , for example , choose for every  @xmath9 an interval of length  @xmath2 from which @xmath9 is drawn uniformly at random .",
    "for  @xmath57 , every processing requirement is uniformly distributed over  @xmath58 $ ] , and hence the input model equals the average case for uniformly distributed processing times . when  @xmath50 gets larger , the adversary can specify the processing requirements more and more precisely , and for  @xmath59 the smoothed analysis approaches a worst - case analysis .    in this article",
    ", we analyze the _ smoothed performance guarantee _ of the jump , the lex - jump , and the list scheduling algorithm . as mentioned above , to define the approximation guarantee of these algorithms on a given instance , we consider the worst local optimum ( for the jump and the lex - jump algorithm ) or the worst order in which the jobs are inserted into the list ( for the list scheduling algorithm ) . now",
    ", the smoothed performance is defined to be the worst expected approximation guarantee of any @xmath50-smooth instance .",
    "[ [ our - results . ] ] our results",
    ". + + + + + + + + + + + +     & jump & lex - jump & jump & lex - jump +    .worst - case and smoothed performance guarantees for jump and lex - jump optimal schedules . here , @xmath60 , and",
    "we assume w.l.og .  that @xmath61 . with [ x.y ]",
    "we refer to the section in this article where the bound is shown .",
    "[ tab : results ] [ cols= \" < \" , ]",
    "on several occasions in this paper we use hoeffding s bound  @xcite to bound tail probabilities . for completeness , we state the bound in the following theorem .",
    "[ thm : app : hoeffding ] let @xmath62 be independent random variables . define @xmath63 and @xmath64}\\xspace}$ ] . if each @xmath65 $ ] for some constants @xmath66 and @xmath67 , @xmath68 , then for any @xmath69 @xmath70}\\xspace } - t\\right]}\\xspace } & \\leq \\exp\\left ( \\frac{-2t}{\\sum_j ( b_j - a_j)^2 } \\right ) , \\quad \\text { and , } \\\\ { \\ensuremath{{\\ensuremath{\\mathop{\\mathbf{pr}}}\\xspace}\\limits_{}\\left[x \\geq { \\ensuremath{{\\ensuremath{\\mathop{\\mathbf{e}}}\\xspace}[x]}\\xspace } + t\\right]}\\xspace } & \\leq \\exp\\left ( \\frac{-2t}{\\sum_j ( b_j - a_j)^2 } \\right ) .",
    "\\end{aligned}\\ ] ]"
  ],
  "abstract_text": [
    "<S> we study popular local search and greedy algorithms for standard machine scheduling problems . </S>",
    "<S> the performance guarantee of these algorithms is well understood , but the worst - case lower bounds seem somewhat contrived and it is questionable whether they arise in practical applications . to find out how robust these bounds are , we study the algorithms in the framework of smoothed analysis , in which instances are subject to some degree of random noise .    while the lower bounds for all scheduling variants with restricted machines are rather robust , we find out that the bounds are fragile for unrestricted machines . </S>",
    "<S> in particular , we show that the smoothed performance guarantee of the jump and the lex - jump algorithm are ( in contrast to the worst case ) independent of the number of machines . </S>",
    "<S> they are  @xmath0 and  @xmath1 , respectively , where  @xmath2 is a parameter measuring the magnitude of the perturbation . </S>",
    "<S> the latter immediately implies that also the smoothed price of anarchy is  @xmath1 for routing games on parallel links . </S>",
    "<S> additionally , we show that for unrestricted machines also the greedy list scheduling algorithm has an approximation guarantee of  @xmath1 .    </S>",
    "<S> [ theorem]lemma [ theorem]corollary [ theorem]proposition    [ theorem]definition </S>"
  ]
}