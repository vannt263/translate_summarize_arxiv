{
  "article_text": [
    "standard big - step semantics and hoare logics do not support reasoning about nonterminating runs of programs .",
    "essentially , they ignore them .",
    "but of course nonterminating runs are important .",
    "not only need we often program a partial function whose domain of definedness we can not decide or is undecidable , e.g. , an interpreter , but we also have to program functions that are inherently partial . in programming with interactive input / output , for example , diverging runs are often what we really want .    in search for a foundational framework for reasoning about possibly nonterminating programs",
    "constructively ( intuitionistically ) and intrigued by attempts in this direction in the literature , we have previously devised a big - step semantics for while based on traces @xcite . in this",
    "semantics , traces are possibly infinite sequences of states that a program run goes through .",
    "they are defined coinductively , as is the evaluation relation , relating initial states of program runs to traces they produce . on terminating runs ,",
    "this nonstandard semantics agrees with the standard , inductive state - based big - step semantics .    in this paper , we put forward a hoare logic to match this big - step semantics . in this new trace - based logic ,",
    "program runs are reasoned about in terms of assertions on states and traces .",
    "more precisely , our hoare triple @xmath0 is given by a statement @xmath1 , a state assertion @xmath2 ( a condition on the initial state of a run of @xmath1 ) and a trace assertion @xmath3 ( a condition on the trace produced by the run ) .",
    "in the presentation we have chosen for this paper , assertions are nothing but predicates expressible in the meta - logic , i.e. , we do not confine ourselves to a particular language of state and trace assertions .",
    "nonetheless , we do not want to downplay the question of what makes a good assertion language for traces .",
    "we are after a set of connectives that allows for a concise formulation of a sound and complete hoare logic over state and trace predicates and logical entailment as given by the constructive meta - logic .",
    "we adopt a solution that is reminiscent of interval temporal logic @xcite , with a chop - connective .",
    "this gives us a set of connectives that is spartan in terms of convenience of expression , but suffices for our meta - theoretical study .",
    "our logic is intended foundational framework into which more specialized and more applied logics with more limited assertion languages can be embedded .    besides being deterministic , the while language is also total as soon as we accept that traces of program runs",
    "can be infinite .",
    "this allows our logic to conservatively extend both the standard , state - based partial - correctness hoare logic as well as the state - based total - correctness hoare logic . on the level of derivability alone",
    "this can be proved semantically by going through the soundness and completeness results .",
    "but we go one step further : we show that derivations in these two state - based logics are directly transformable into derivations in our logic , yielding embeddings on the level of derivations , not just mere derivability .",
    "the transformations are relatively straightforward and do not require invention of new invariants or variants , demonstrating that our logic incurs no undue proof burden in comparison to the standard hoare logics . in the converse direction , we can project derivations in our trace - based logic into derivations in the state - based logics : a derivation of a hoare triple in the trace - based logic is translated into a derivation in the state - based logics with a translated , weaker postcondition .",
    "however , the power of our logic goes beyond that of the state - based partial - correctness and total - correctness hoare logics .",
    "the assertions have access to traces . as suggested by the similarity of our ( open ) assertion language to the that of interval temporal logic , this allows us to specify liveness properties of diverging runs .",
    "we will demonstrate this extra expressiveness of our logic by a series of examples . also , interpreted into a constructive underlying logic , our assertion language becomes quite discerning .",
    "in particular we can distinguish between termination and nondivergence , e.g. , unbounded classically total ( constructively nonpartial ) search fails to be terminating , but is nonetheless nondivergent .",
    "we do not discuss this in the paper , but our logic can be adjusted to deal with exceptions and nondeterminism .    the paper is organized as follows . in section  [ sec : sem ] , we present our trace - based big - step semantics . in section",
    "[ sec : hoare ] , we proceed to the question of a corresponding hoare logic .",
    "we explain our design considerations and then present our hoare logic and the soundness and completeness proofs . in section  [ sec : hoare ] , we show the embeddings of the state - based partial - correctness and total - correctness hoare logics into our logic and the projections back . in section",
    "[ sec : examples ] , we consider examples . in section  [ sec : related ] , we discuss the related work , to conclude in section  [ sec : concl ] .",
    "we have formalized the development fully constructively in coq version 8.1pl3 using the syntax extension library .",
    "the coq development is available at http://cs.ioc.ee/~keiko/code/abyss.tgz .    both the paper and the accompanying coq code use coinductive types , corecursion and coinduction extensively . for an introduction",
    ", we can refer the reader to the exposition of bertot and castran ( * ? ? ?",
    "13 ) . in the paper , we have sought to abstract over the more bureaucratic aspects involved in the coq formalization ( e.g. , working with coq s restricted guardedness condition on cofix definitions , i.e. , definitions by corecursion , proofs by coinduction ) .",
    "we start with our big - step semantics .",
    "this is defined in terms of states and traces .",
    "the notion of a state is standard .",
    "a state @xmath4 is an assignment of integer values to the variables .",
    "traces @xmath5 are defined coinductively by the rules @xmath6 so a trace is a non - empty colist ( possibly infinite sequence ) of states .",
    "we also define ( strong ) bisimilarity of two traces , @xmath7 , coinductively by @xmath8 bisimilarity is straightforwardly seen to be an equivalence .",
    "we think of bisimilar traces as equal , i.e. , type - theoretically we treat traces as a setoid with bisimilarity as the equivalence relation .",
    "is bisimilar to either a trace of the form of @xmath9 or one of the form @xmath10 . ]",
    "accordingly , we have to make sure that all functions and predicates we define on traces are setoid functions and predicates ( i.e. , insensitive to bisimilarity ) .",
    "we define the initial state @xmath11 of a trace @xmath12 by case distinction by @xmath13 .",
    "the function @xmath14 is a setoid function .",
    "we also define finiteness of a trace ( with a particular final state ) and infiniteness of a trace inductively resp .",
    "coinductively by @xmath15 finiteness and infiniteness are setoid predicates .",
    "it should be noticed that infiniteness is defined positively , not as negation of finiteness .",
    "constructively , it is not the case that @xmath16 , which amounts to asserting that finiteness is decidable . in particular",
    ", @xmath17 is constructively provable , but @xmath18 is not .    the statements of the while",
    "language are given by the following grammar where @xmath19 ranges over ( integer ) variables and @xmath20 over ( arithmetic ) expressions built over variables .",
    "@xmath21 the integer value of an expression @xmath20 in a state @xmath22 is denoted @xmath23 .",
    "we also interpret expressions as booleans ; @xmath24 stands for @xmath20 being true in @xmath22 .",
    "evaluation @xmath25 , expressing that running a statement @xmath1 from a state @xmath22 produces a trace @xmath12 , is defined coinductively by the rules in figure  [ fig : sem ] .",
    "the rules for sequence and while implement the necessary sequencing with the help of extended evaluation @xmath26 , also defined coinductively , as the coinductive prefix closure of evaluation : @xmath26 expresses that running a statement @xmath1 from the last state ( if it exists ) of an already accumulated trace @xmath12 results in a total trace @xmath27 .",
    "a remarkable feature of the definition of @xmath26 is that it does not hinge on deciding whether the trace @xmath12 is finite or not , which is constructively impossible .",
    "a proof of @xmath26 simply traverses the already accumulated trace @xmath12 : if the last element is hit , which is the case when @xmath12 is finite , then the statement is run , otherwise the traversal goes on forever .",
    "we look closer at the sequence rule .",
    "we want to conclude that @xmath28 from the premise @xmath29 .",
    "classically , either the run of @xmath30 terminates , i.e. , @xmath31 for some @xmath32 , or it diverges , i.e. , @xmath33 . in the first case , we would like to additionally use that @xmath12 is a finite prefix of @xmath27 and that @xmath34 , where @xmath35 is the rest of @xmath27 .",
    "in the second case , it should be case that @xmath7 . in both cases ,",
    "the desirable condition is equivalent to @xmath36 , which is the second premise of our rule .",
    "the use of extended evaluation , defined as the coinductive ( rather than inductive ) prefix closure of evaluation , allows us to avoid the need to decide whether the run of @xmath30 terminates or not .",
    "@xmath37}}\\rangle } } } } } { } \\quad \\infer= {    { ( { \\ensuremath{\\mathsf{skip}}},{\\sigma } ) \\rightarrow { \\langle{\\sigma}\\rangle } } } { } \\quad \\infer= {    { ( { \\ensuremath{s_0;s_1}},{\\sigma } ) \\rightarrow { \\ensuremath{\\tau } } ' } } {    { ( s_0,{\\sigma } ) \\rightarrow { \\ensuremath{\\tau } } }    & { ( s_1,{\\ensuremath{\\tau } } ) \\stackrel{*}{\\rightarrow } { \\ensuremath{\\tau } } ' } } \\\\[1ex ] \\infer= {    { ( { \\ensuremath{\\mathsf{if~ } e \\mathsf{~then~ } s_t \\mathsf{~else~ } s_f}},{\\sigma } ) \\rightarrow { \\ensuremath{\\tau } } } } {    { \\ensuremath{{\\sigma}\\models e } }    & { ( s_t,{\\ensuremath{{\\sigma}::{\\langle{\\sigma}\\rangle } } } ) \\stackrel{*}{\\rightarrow } { \\ensuremath{\\tau } } } } \\quad \\infer= {    { ( { \\ensuremath{\\mathsf{if~ } e \\mathsf{~then~ } s_t \\mathsf{~else~ } s_f}},{\\sigma } ) \\rightarrow { \\ensuremath{\\tau } } } } {    { \\ensuremath{{\\sigma}\\not\\models e } }    & { ( s_f,{\\ensuremath{{\\sigma}::{\\langle{\\sigma}\\rangle } } } ) \\stackrel{*}{\\rightarrow } { \\ensuremath{\\tau } } } } \\\\[1ex ] \\infer= {    { ( { \\ensuremath{\\mathsf{while~ } e \\mathsf{~do~ } s_t}},{\\sigma } ) \\rightarrow { \\ensuremath{\\tau } } ' } } {    { \\ensuremath{{\\sigma}\\models e } }    & { ( s_t,{\\ensuremath{{\\sigma}::{\\langle{\\sigma}\\rangle } } } ) \\stackrel{*}{\\rightarrow } { \\ensuremath{\\tau } } }    & { ( { \\ensuremath{\\mathsf{while~ } e \\mathsf{~do~ } s_t}},{\\ensuremath{\\tau } } ) \\stackrel{*}{\\rightarrow } { \\ensuremath{\\tau } } ' } } \\quad \\infer= {    { ( { \\ensuremath{\\mathsf{while~ } e \\mathsf{~do~ } s_t}},{\\sigma } ) \\rightarrow { \\ensuremath{{\\sigma}::{\\langle{\\sigma}\\rangle } } } } } {    { \\ensuremath{{\\sigma}\\not\\models e } } } \\\\[2ex ] \\infer= {    { ( s,{\\langle{\\sigma}\\rangle } ) \\stackrel{*}{\\rightarrow } { \\ensuremath{\\tau } } } } {    { ( s,{\\sigma } ) \\rightarrow { \\ensuremath{\\tau } } } } \\quad \\infer= {    { ( s,{\\ensuremath{{\\sigma}::{\\ensuremath{\\tau } } } } ) \\stackrel{*}{\\rightarrow } { \\ensuremath{{\\sigma}::{\\ensuremath{\\tau } } ' } } } } {    { ( s,{\\ensuremath{\\tau } } ) \\stackrel{*}{\\rightarrow } { \\ensuremath{\\tau } } ' } } \\end{array}\\ ] ]    [ fig : sem ]    evaluation is a setoid predicate .    for any @xmath1 , @xmath22 , @xmath12 and @xmath27 , if @xmath25 and @xmath7 , then @xmath38 .",
    "the trace produced from a state begins with this state .",
    "for any @xmath1 , @xmath22 and @xmath12 , if @xmath25 , then @xmath39 .",
    "moreover , for while , evaluation is deterministic ( up to bisimilarity , as is appropriate for our notion of trace equality ) .",
    "[ prop : determ ] for any @xmath1 , @xmath22 , @xmath12 and @xmath27 , if @xmath25 and @xmath38 , then @xmath7 .    and",
    "it is also total .",
    "[ prop : total ] for any @xmath1 and @xmath22 , there exists @xmath12 such that @xmath25 .    in our definition ,",
    "we have made a choice as regards to what grows the trace of a run .",
    "we have decided that assignments and testing of guards of if- and while - statements augment the trace by a state ( but @xmath40 does not ) , e.g. , we have @xmath41}}\\rangle}}}}$ ] , @xmath42 and @xmath43 .    this is good for several reasons .",
    "first , @xmath40 becomes the unit of sequential composition , i.e. , the semantics does not distinguish @xmath1 , @xmath44 and @xmath45 .",
    "second , we get a notion of small steps that fully agrees with a very natural coinductive trace - based small - step semantics arising as a straightforward variation of the textbook inductive state - based small - step semantics .",
    "the third and most important outcome is that any while - loop always progresses , because testing of the guard is a small step .",
    "for instance , in our semantics @xmath46 can only derive @xmath43 ( up to bisimilarity ) . as we discuss below , giving up insisting on progress in terms of growing the trace would introduce some semantic anomalies .",
    "it also ensures that evaluation is total  as we should expect .",
    "given that it is also deterministic , we can thus equivalently turn our relational big - step semantics into a functional one : the unique trace for a given statement and initial state is definable by corecursion .",
    "( for details , see our previous paper @xcite . )",
    "the coinductive trace - based semantics agrees with the inductive state - based semantics .    for any @xmath1 , @xmath22 , @xmath32 , existence of @xmath12 such that @xmath25 and @xmath31 is equivalent to @xmath47 .",
    "we notice that the inductive state - based semantics can not be made total constructively .",
    "it is unproblematic to complement the inductively defined terminating evaluation relation with a coinductively defined diverging evaluation relation , but this does not help , as we can not decide the halting problem .",
    "we look at several seemingly not so different but problematic alternatives that we reject , thereby revealing some subtleties in designing coinductive big - step semantics and motivating our design choices .",
    "since progress of loops is not required for wellformedness of the definitions of @xmath48 and @xmath49 , one might be tempted to regard guard testing to be instantaneous and modify the rules for the while - loop to take the form @xmath50 this leads to undesirable outcomes .",
    "we can derive @xmath51 , which means that the non - terminating @xmath46 is considered semantically equivalent to the terminal ( immediately terminating ) @xmath40 .",
    "worse , we can also derive @xmath52}}\\rangle}}}}$ ] , which is even more inadequate : a sequence can continue to run after the non - termination of the first statement .",
    "yet worse , inspecting the rules closer we discover we are also able to derive @xmath53 for any @xmath12 .",
    "mathematically , giving up insisting on progress in terms of growing the trace has also the consequence that the relational semantics can not be turned into a functional one , although while should intuitively be total and deterministic .",
    "in a functional semantics , evaluation must be a trace - valued function and in a constructive setting such a function must be productive .",
    "another option , where assignments and test of guards are properly taken to constitute steps , could be to define @xmath49 by case distinction on the statement by rules such as @xmath54 here , @xmath55 , defined corecursively , traverses @xmath12 and duplicates its last state , if it is finite .",
    "similarly , @xmath56 and @xmath57 traverse @xmath12 and evaluate @xmath20 in the last state , if it is finite : @xmath58 ( the rules for @xmath40 and sequence are very simple and appealing in this design . )",
    "the relation @xmath48 would then be defined uniformly by the rule @xmath59 it turns out that we can still derive @xmath53 for any @xmath12 .",
    "we can even derive @xmath60 for any @xmath12 .",
    "the third alternative ( leroy and grall use this technique in @xcite ) is most close to ours .",
    "it introduces , instead of our @xmath49 relation , an auxiliary relation @xmath61 , defined coinductively by @xmath62 so that @xmath63 expresses that the trace @xmath27 can be split into a concatenation of traces @xmath64 and @xmath65 glued together at a mid - state @xmath32 .",
    "then the evaluation relation is defined by replacing the uses of @xmath49 with @xmath61 , e.g. , the rule for the sequence statement would be : @xmath66 this third alternative does not cause any outright anomalies for while .",
    "but alarmingly @xmath67 has to be run from some ( underdetermined ) state within a run of @xmath68 even if the run of @xmath30 does not terminate . in a richer language with abnormal terminations ,",
    "we get a serious problem : no evaluation is derived for @xmath69 although the @xmath70 statement should not be reached .",
    "we now proceed to the hoare logic and its soundness and completeness proof .",
    "we base our consequence rule on semantic entailment rather than derivability in some fixed proof system .",
    "this allows us to sidestep the problem of its unavoidable incompleteness due to the impossibility of complete axiomatization of any theory containing arithmetic . by identifying assertions with state and trace predicates ( more precisely , predicates expressible in the meta - logic )",
    ", we also avoid the risk of possible incompleteness due to a chosen narrower assertion language not being closed under weakest preconditions / strongest postconditions . to formulate the rules of the hoare logic",
    ", we introduce a small set of assertion connectives , i.e. , operations on predicates . to be able to express the strongest postcondition of any precondition",
    ", we need a few additional connectives .",
    "our assertions are predicates over states and traces .",
    "a state predicate",
    "@xmath2 is any predicate on states ( in particular , it need not be decidable ) . from a trace predicate @xmath3 , we require additionally that it is a setoid predicate , i.e.",
    ", it must be unable to distinguish bisimilar traces .",
    "although we refrain from introducing a language of assertions , we introduce a number of connectives for our assertions , which are operations on predicates .",
    "all trace predicate connectives yield setoid predicates",
    ". the inference rules of the hoare logic make use of these connectives .",
    "indeed , it was an intriguing exercise for us to come up with connectives that would be small but expressive enough for practical specification purposes and at the same time allow us to prove the hoare logic sound and complete in our constructive setting .",
    "the definitions of these connectives are given in figure  [ fig : assert ] . to highlight application of a predicate to a state or trace .",
    "we are not defining a single satisfaction relation @xmath71 for some assertion language , but a number of individual state / trace predicates and operations on such predicates .",
    "some of these operations are defined inductively , some coinductively , some definitions are not recursive at all . ]",
    "@xmath72 \\infer {    { \\ensuremath{\\tau}}\\models { \\ensuremath{\\mathsf{true } } } } { } \\qquad \\infer {    { \\ensuremath{\\tau}}\\models \\neg p } { \\neg ( { \\ensuremath{\\tau}}\\models p ) } \\qquad \\infer {    { \\ensuremath{\\tau}}\\models p \\wedge q } { { \\ensuremath{\\tau}}\\models p & { \\ensuremath{\\tau}}\\models q } \\qquad \\ldots \\\\[2ex ] \\infer {    { { \\langle{\\sigma}\\rangle } \\models { \\langleu\\rangle } } } {    { { \\sigma}\\models u } } \\qquad \\infer {    { { \\ensuremath{\\tau } } ' \\models { p \\mathbin{\\ast\\ast } q } } } {    { { \\ensuremath{\\tau}}\\models p }    & { { \\ensuremath{\\tau } } ' \\models_{{\\ensuremath{\\tau } } } q } } \\qquad   \\infer={{{\\ensuremath{\\tau}}\\models { p^\\dagger } } } {    { { \\ensuremath{\\tau}}\\models { \\langle{\\ensuremath{\\mathsf{true}}}\\rangle } } } \\quad \\infer={{{\\ensuremath{\\tau } } ' \\models { p^\\dagger } } } {    { { \\ensuremath{\\tau}}\\models p }    &    { { \\ensuremath{\\tau } } ' \\models_{{\\ensuremath{\\tau } } } { p^\\dagger } }    } \\\\[2ex ] \\infer {    { { \\ensuremath{{\\sigma}::({\\ensuremath{{\\sigma}[x\\mapsto { \\ensuremath{\\llbracket e \\rrbracket { \\sigma } } } ] } } ) } } \\models { \\ensuremath{u[x\\mapsto e ] } } } } {    { { \\sigma}\\models u } } \\qquad \\infer {    { { \\ensuremath{{\\sigma}::{\\langle{\\sigma}\\rangle } } } \\models { \\langle u \\rangle^2 } } } {    { { \\sigma}\\models u } } \\\\[2ex ] \\infer {    { { \\sigma}\\models { \\mathit{last } ~p } } } {    { { \\ensuremath{\\tau}}\\models p }    &    { { \\ensuremath{\\tau}}\\mathbin{\\downarrow } { \\sigma } } } \\qquad \\infer{{{\\ensuremath{\\tau}}\\models { \\mathit{finite } } } } {    { { \\ensuremath{\\tau}}\\mathbin{\\downarrow } { \\sigma } } } \\qquad \\infer{{{\\ensuremath{\\tau}}\\models { \\mathit{infinite } } } } {    { { \\ensuremath{\\tau}}^{\\shortuparrow } }   } \\\\[2.5ex ] \\infer=[\\mathsf{[flw\\mbox{-}nil ] } ] {    { { \\ensuremath{\\tau}}\\models_{{\\langle{\\sigma}\\rangle } } q } } {    { \\mathit{hd}}~{\\ensuremath{\\tau}}= { \\sigma}&{{\\ensuremath{\\tau}}\\models q } } \\quad \\infer=[\\mathsf{[flw\\mbox{-}delay ] } ] {    { { \\ensuremath{{\\sigma}::{\\ensuremath{\\tau } } ' } } \\models_{{\\ensuremath{{\\sigma}::{\\ensuremath{\\tau } } } } } q } } {    { { \\ensuremath{\\tau } } ' \\models_{{\\ensuremath{\\tau } } } q } } \\\\[2.5ex ] \\infer{u \\models v } {    \\forall { \\sigma}.\\ ,   { { \\sigma}\\models u } \\to { { \\sigma}\\models v } } \\qquad \\infer{p \\models q } {    \\forall { \\ensuremath{\\tau}}.\\ , { { \\ensuremath{\\tau}}\\models p } \\to { { \\ensuremath{\\tau}}\\models q } }    \\end{array}\\ ] ]    the two most primitive state ( resp .  trace ) predicates are @xmath73 and @xmath74 , which are respectively true and false for any state ( resp.trace ) .",
    "we can also use the standard connectives @xmath75 and quantifiers @xmath76 to build state and trace predicates .",
    "the context disambiguates the overloaded notations for these state and trace predicates .    for a state predicate @xmath2 ,",
    "the singleton @xmath77 is a trace predicate that is true of singleton traces given by a state satisfying @xmath2 .",
    "in particular @xmath78 is true of any singleton trace .    for a state predicate @xmath2 ,",
    "the doubleton @xmath79 is true of a doubleton trace whose two states are identical and satisfy @xmath2 .    for a state predicate @xmath2 ,",
    "the update @xmath80}}$ ] is the strongest postcondition of the statement @xmath81 for the precondition @xmath2 .",
    "it is true of a doubleton trace whose first state @xmath22 satisfies @xmath2 and second state is obtained from the first by modifying the value of @xmath19 to become @xmath82 .    for trace",
    "predicates @xmath3 and @xmath83 , the chop @xmath84 is a trace predicate that is true , roughly speaking , of a trace @xmath27 that has a prefix @xmath12 satisfying @xmath3 , with the rest of @xmath27 satisfying @xmath83 .",
    "( to be more precise , the prefix and the rest overlap on a mid - state which is the last state of the prefix and the first state of the suffix . ) but its definition is carefully crafted , so that @xmath83 is not checked , if @xmath12 is infinite ( in which case necessarily @xmath85 , and this happens without case distinction on whether @xmath12 is finite .",
    "this effect is achieved with the premise @xmath86 .",
    "the relation @xmath86 is defined coinductively .",
    "it traverses all of @xmath12 , making sure that it is a prefix of @xmath27 ( rule @xmath87 ) , and , upon possible exhaustion of @xmath12 in a finite number of steps , checks @xmath83 against the rest of @xmath27 ( rule @xmath88 ) . this way the problem of deciding whether @xmath12 is finite is avoided , basically by postponing it , possibly infinitely .",
    "our chop operator is classically equivalent to the chop operator from interval temporal logic @xcite ( cf .",
    "also the separating conjunction of separating logic ) .",
    "indeed , classically , @xmath89 holds iff    * either , for some finite prefix @xmath12 of @xmath27 , we have @xmath90 and @xmath91 , where @xmath35 is the rest of @xmath27 , * or @xmath27 is infinite and @xmath92 .",
    "this is how the semantics of chop is defined in interval temporal logic .",
    "but it involves an upfront decision of whether @xmath3 will be satisfied by a finite or an infinite prefix of @xmath27 .",
    "our definition is fine - tuned for constructive reasoning .    for a trace predicate @xmath3 ,",
    "its iteration @xmath93 is a trace predicate that is true of a trace which is a concatenation of a possibly infinite sequence of traces , each of which satisfies @xmath3 .",
    "( this is modulo the overlap of the last and first states of consecutive traces in the sequence and the empty concatenation being a singleton trace . )",
    "it is reminiscent of the kleene star operator .",
    "it is defined by coinduction and takes into account possibilities of both infiniteness of some single iteration and infinite repetition .",
    "for a trace predicate @xmath3 , @xmath94 is a state predicate that is true of states that can be the last state of a finite trace satisfying @xmath3 .",
    "trace predicates @xmath95 and @xmath96 are true of finite and infinite traces , respectively .    for state predicates @xmath2 and @xmath97 ( resp .",
    "trace predicates @xmath3 and @xmath83 ) , @xmath98 ( resp .",
    "@xmath99 ) denotes entailment .",
    "[ prop : asserts_setoid ] for any @xmath2 , @xmath77 , @xmath80}}$ ] and @xmath79 are setoid predicates .",
    "for any setoid predicates @xmath3 , @xmath83 , @xmath84 is a setoid predicate . for any setoid predicate @xmath3 ,",
    "@xmath93 is a setoid predicates .",
    "moreover , @xmath95 and @xmath96 are setoid predicates .    that @xmath77 , @xmath80}}$ ] and @xmath79 are setoid predicates follows from the definition .",
    "we prove that @xmath84 and @xmath93 are setoid predicates when @xmath3 and @xmath83 are by coinduction . that @xmath95 and @xmath96 are setoid predicates is proved by induction and by coinduction respectively .",
    "[ prop : asserts_monotone ] for any @xmath2 and @xmath97 , if @xmath98 , then @xmath100 , @xmath80 } } \\models { \\ensuremath{v[x\\mapsto e]}}$ ] and @xmath101 .",
    "for any setoid predicates @xmath102 and",
    "@xmath83 , if @xmath103 , then @xmath104 and @xmath105 . for any setoid predicates @xmath3 and @xmath83 , if @xmath99 , then @xmath106 and @xmath107 .    that @xmath77 , @xmath80}}$ ] , @xmath79 are monotone follows from the definition",
    "we prove that @xmath84 and @xmath93 are monotone and that @xmath94 is monotone by coinduction and by induction respectively .",
    "a number of logical consequences and equivalences hold about these connectives , to be proved in lemma  [ lemma : misc_asserts ] .",
    "we have the trivial equivalence : @xmath108 .",
    "the chop operator is associative : @xmath109 .",
    "the iterator operator @xmath93 repeats @xmath3 either zero times or once followed by further repetitions : @xmath110 .",
    "a trace is infinite if and only if @xmath74 holds for any last state : @xmath111 . if every trace satisfying @xmath3 is infinite , i.e. , if @xmath112 , then any trace satisfying @xmath3 has no last state , i.e. , @xmath113 .",
    "we have @xmath114 , so that if a trace satisfies @xmath3 , then its last state , if exists , satisfies @xmath94 .",
    "the last state of a singleton trace @xmath9 is @xmath22 , therefore we have @xmath115 .",
    "we also have @xmath116 , but the converse does not hold . e.g. , @xmath117 . instead , we have @xmath118",
    ". finally we have @xmath119 .",
    "namely , a state satisfies @xmath2 and can be the last state of a finite trace satisfying @xmath3 if and only if it can be the last state of a finite trace satisfying @xmath120 .",
    "we define the concatenation of traces @xmath12 and @xmath27 , @xmath121 , by replacing the last state of @xmath12 by @xmath27 .",
    "formally , it is defined by corecursion by @xmath122    we first observe three results , which are useful for later proofs .",
    "[ lemma : follows_true ] for any @xmath12 , @xmath123 .    by coinduction and case analysis on @xmath12 .",
    "the case of @xmath124 follows from @xmath125 .",
    "the case of @xmath126 : we get @xmath127 from the coinduction hypothesis , from which we obtain @xmath123 .",
    "[ lemma : follows_singleton ] for any @xmath2 and @xmath128 , if @xmath129 , then @xmath7 .    by coinduction and inversion on @xmath129 .",
    "[ lemma : conv_last ] for any @xmath2 and @xmath12 , if for any @xmath22 , @xmath130 implies @xmath131 , then @xmath132 .    by coinduction with case analysis on @xmath12 .    the case of @xmath133 :",
    "we have @xmath130 , hence @xmath134 by our hypothesis .",
    "we conclude @xmath132 .",
    "the case of @xmath135 : since @xmath136 implies @xmath130 , we have that , for any @xmath22 , @xmath136 implies @xmath131 .",
    "we get @xmath137 by the coinduction hypothesis , from where we conclude @xmath132 .",
    "[ lemma : misc_asserts ] for any @xmath138 and setoid predicates @xmath139 and @xmath140 , we have    1 .   [ lemma : sglt_dup ] @xmath141 2 .   [ lemma : sglt_chop]@xmath142 3 .   [ lemma : sglt_true_chop]@xmath108 4 .   [ lemma : chop_assoc ] @xmath109 5 .   [ lemma : rep_unfold ] @xmath110 6 .",
    "[ lemma : rep_idem]@xmath143 7 .",
    "@xmath111 8 .",
    "if @xmath144 , then @xmath113 . 9 .",
    "@xmath145    1 .",
    "[ lemma : last_sglt]@xmath115 2 .",
    "[ lemma : last_chop]@xmath116 3 .",
    "[ lemma : last_last]@xmath118 4 .",
    "[ lemma : last_chop_sglt ] @xmath146 5 .",
    "[ lemma : last_rep ] @xmath147    1",
    ".   follows from the definition .",
    "2 .   follows from the definition .",
    "@xmath148 follows from the definition .",
    "@xmath149 holds by lemma  [ lemma : follows_true ] .",
    "suppose @xmath150 .",
    "there exists @xmath12 such that @xmath90 and @xmath151 . by lemma  [ lemma : follows_singleton ] @xmath7 holds , so we must have @xmath92 since @xmath3 is a setoid predicate .",
    "this proves @xmath152 .",
    "4 .   suppose @xmath153 .",
    "there exist @xmath12 and @xmath27 such that @xmath90 and @xmath86 and @xmath154 .",
    "we prove , for any @xmath155 and @xmath156 , @xmath157 and @xmath158 imply @xmath159 by coinduction and inversion on @xmath157 . this yields @xmath160 therefore @xmath161 .",
    "+ the converse is more subtle . given @xmath161 , we have to find a prefix @xmath27 of @xmath35 that satisfies @xmath84 while @xmath154 . to do so",
    ", we define a function @xmath162 by corecursion ( we take @xmath64 and @xmath65 to be implicit parameters of @xmath163 , inferred from the proof argument ) . below ; @xmath164 is for an anonymous dummy argument .",
    "@xmath165 is the constructor of sigma - types in coq . ]",
    "@xmath166 { \\mathit{midp}}~(\\mathsf{flw\\mbox{-}delay }   ~{\\sigma}~{\\ensuremath{\\tau}}_0~{\\ensuremath{\\tau}}_1~(h:{{\\ensuremath{\\tau}}_1 \\models_{{\\ensuremath{\\tau}}_0 } p_0{\\mathbin{\\ast\\ast}}q_0 } ) ) = { \\ensuremath{{\\sigma}::{\\mathit{midp}}~h } } \\end{array}\\ ] ] we then prove that , for any @xmath155 and @xmath167 , @xmath168 and @xmath169 hold by coinduction and inversion on @xmath170 . + now assume @xmath161 .",
    "there exists @xmath12 such that @xmath90 and @xmath171 .",
    "we have @xmath172 , since @xmath173 .",
    "this together with @xmath174 proves @xmath175 , as required .",
    "5 .   follows from the definition .",
    "suppose @xmath176 .",
    "we have to prove @xmath177 . from lemma  [ lemma : follows_true ] and ( 5 ) , we deduce @xmath178 , which gives us @xmath177 .",
    "conversely , suppose @xmath177 .",
    "there exists @xmath27 such that @xmath179 and @xmath180 .",
    "we close the case by proving the following two conditions by mutual coinduction : 1 .",
    "@xmath181 2 .",
    "+ ( a ) : we perform inversion on @xmath176 . the case of @xmath183 , i.e. , @xmath124 : from @xmath184 , we conclude @xmath179 .",
    "the case of @xmath185 and @xmath186 : we get @xmath187 by ( b ) , from where we conclude @xmath179 .",
    "+ ( b ) : we perform inversion on @xmath184 . the case of @xmath124 and @xmath188 and @xmath179 follows from ( a ) .",
    "the case of @xmath189 and @xmath190 and @xmath191 : we must have @xmath192 and @xmath193 . the coinduction hypothesis ( b ) gives us @xmath194 , from which we conclude @xmath186",
    "we prove an auxiliary condition : for any @xmath12 , @xmath195 iff @xmath196 by coinduction .",
    "@xmath197 follows from the condition .",
    "@xmath198 follows from the condition and lemma  [ lemma : follows_singleton ] .",
    ".   follows from @xmath199 .",
    "suppose @xmath90 . by the definition of @xmath94",
    ", we have for any @xmath22 , @xmath130 implies @xmath200 .",
    "we then deduce @xmath201 by lemma  [ lemma : conv_last ] , thus conclude @xmath202 .",
    "+ conversely , suppose that @xmath203 , i.e. , @xmath90 and @xmath204 for some @xmath12 .",
    "by lemma  [ lemma : follows_singleton ] , @xmath7 holds , so we must have @xmath92 since @xmath3 is a setoid predicate .    1",
    ".   follows from the definition .",
    "2 .   suppose @xmath205 .",
    "there exist @xmath12 and @xmath27 such that @xmath136 and @xmath90 and @xmath86 .",
    "we have to prove @xmath206 .",
    "we do so by proving an auxiliary condition : for any @xmath207 and @xmath64 , if @xmath208 , then for any @xmath65 , @xmath209 implies @xmath210 by induction on the derivation of @xmath208 .",
    "3 .   suppose @xmath211 .",
    "there exist @xmath12 and @xmath27 such that @xmath90 , @xmath212 , @xmath213 and @xmath136 .",
    "we then have that the concatenation of @xmath12 and @xmath27 has the desired properties .",
    "namely , @xmath214 and @xmath215 .",
    "this proves @xmath205 as we wanted .",
    "+ conversely , suppose @xmath205 .",
    "there exist @xmath12 and @xmath27 such that @xmath90 , @xmath86 and @xmath136 .",
    "the finiteness of @xmath27 implies that of @xmath12 , i.e. , we have @xmath31 for some @xmath32 .",
    "we can therefore find the suffix @xmath35 of @xmath27 such that @xmath216 and @xmath217 .",
    "( basically , we drop the first @xmath218 elements from @xmath27 to obtain @xmath35 , where @xmath218 is the length of @xmath12 . since @xmath12 is finite ,",
    "its length is defined . ) together @xmath86 and @xmath31 proves @xmath91 .",
    "this concludes @xmath211 , as we wanted .",
    "4 .   by the monotonicity of the last and chop operators , it suffices to prove @xmath219 .",
    "suppose @xmath220 .",
    "there exists @xmath12 such that @xmath130 and @xmath221 .",
    "we now prove @xmath222 by induction on the proof of @xmath130 , from where @xmath134 follows .",
    "5 .   by ( 13 ) and the monotonicity of the chop and iterator operators , it suffices to prove @xmath223 .",
    "suppose @xmath224 .",
    "there exists @xmath27 such that @xmath225 and @xmath226 , which give us @xmath227 and @xmath228 .",
    "we want to prove @xmath132 .",
    "we do so by proving the following conditions by mutual coinduction",
    "@xmath229 2 .",
    "+ ( a ) : we perform inversion on @xmath227 . the case of @xmath183 : we have @xmath124 .",
    "this and @xmath228 prove @xmath132 .",
    "the case of @xmath231 and @xmath226 : the former gives us @xmath232 for some @xmath35 .",
    "we therefore conclude @xmath132 by ( b ) .",
    "+ ( b ) : we perform inversion on @xmath233 : the case of @xmath124 and @xmath188 and @xmath234 : we have @xmath235 , therefore @xmath192 for some @xmath236 with @xmath237 , and @xmath238 . from ( a ) , we obtain @xmath239 , which yields @xmath240 , as required . the case of @xmath190 and @xmath189 and",
    "@xmath241 : we have @xmath192 and @xmath242 . by ( b ) , we get @xmath239 , which yields @xmath240 .",
    "the derivable judgements of the hoare logic are given by the inductively interpreted inference rules in figure  [ fig : hoare ] .",
    "the proposition @xmath0 states derivability of the judgement .",
    "the intent is that @xmath0 should be derivable precisely when running a statement @xmath1 from an initial state satisfying @xmath2 is guaranteed to produce a trace satisfying @xmath3 .",
    "the rules for assignment and @xmath40 are self - explanatory .",
    "the rule for sequence is defined in terms of the chop operator .",
    "the precondition @xmath97 for the second statement @xmath67 is given by those states in which a run of the first statement @xmath30 may terminate . in particular ,",
    "if @xmath243 and @xmath144 , i.e. , @xmath30 is necessarily diverging for the precondition @xmath2 , then we have @xmath244 . in this case , from the derivability of @xmath245 for any @xmath83 , we get @xmath246 for any @xmath83 . but",
    "this makes sense , since @xmath247 as soon as @xmath144 .",
    "the rule for if - statement uses the doubleton operator in accordance with the operational semantics where we have chosen that testing the boolean guard grows the trace .",
    "the rule for while - statement is inspired by the corresponding rule of the standard , state - based partial - correctness hoare logic .",
    "it uses a loop invariant @xmath248 .",
    "this is a state predicate that has to be true each time the boolean guard is about to be ( re-)tested in a run of the loop . accordingly , the precondition @xmath2 should be stronger then @xmath248 . also , @xmath248 must hold each time an iteration of @xmath249 has finished , as enforced by having @xmath250 as the postcondition of @xmath249 .",
    "the postcondition @xmath251 of the loop consists of three parts .",
    "@xmath79 accounts for the first test of the guard ; @xmath252 accounts for iterations of the loop body in alternation with re - tests of the guard ( notice that that we are again using the doubleton operator ) ; @xmath253 accounts for the state in which the last test of the guard is finished .",
    "we have chosen to introduce a separate rule for instantiating auxiliary variables .",
    "alternatively , we might have stated the consequence rule in a more general form , as suggested by kleymann  @xcite ; yet the separation facilitates formalization in coq .",
    "the various logical consequences and equivalences about the connectives suggest also further alternative and equivalent formulations .",
    "for instance , we could replace the rule for the while - statement by @xmath254 if we strengthened the consequence rule to @xmath255 with our chosen rule for while , this strengthened version of consequence is admissible :    [ lemma : semax_hd ] for any @xmath2 , @xmath1 and @xmath3 , if @xmath0 , then @xmath256 .",
    "we prove the following more general statement by induction on the derivation of @xmath0 : for any @xmath2 , @xmath1 and @xmath3 , if @xmath0 , then for any @xmath97 , @xmath257 .",
    "we do not attempt to argue that our formulation is the best choice ; yet we found that the present formulation is viable from the points - of - view of both the meta - theory and applicability of the logic .",
    "@xmath258}}\\ } } } { } \\quad \\infer {    { \\{u\\}~{\\ensuremath{\\mathsf{skip}}}~\\{{\\langleu\\rangle}\\ } } } { } \\quad \\infer {    { \\{u\\}~{\\ensuremath{s_0;s_1}}~\\{{p \\mathbin{\\ast\\ast } q}\\ } } } {      { \\{u\\}~s_0~\\{{p \\mathbin{\\ast\\ast } { \\langlev\\rangle}}\\ } }      & { \\{v\\}~s_1~\\{q\\ } } } \\\\[2ex ] \\infer {    { \\{u\\}~{\\ensuremath{\\mathsf{if~ } e \\mathsf{~then~ } s_t \\mathsf{~else~ } s_f}}~\\{{{\\langle u \\rangle^2 } \\mathbin{\\ast\\ast } p}\\ } } } {    { \\{{e \\wedge u}\\}~s_t~\\{p\\ } }    &    { \\{{\\neg e \\wedge u}\\}~s_f~\\{p\\ } } } \\\\[2ex ] \\infer {    { \\{u\\}~{\\ensuremath{\\mathsf{while~ } e \\mathsf{~do~ } s_t}}~\\ {    { \\langle u \\rangle^2 } { \\mathbin{\\ast\\ast } } { ( { } p { \\mathbin{\\ast\\ast}}{\\langle i \\rangle^2})^\\dagger }                      { \\mathbin{\\ast\\ast}}{\\langle { } \\neg e\\rangle}\\ } } } {    u \\models i    &    { \\{{e \\wedge i}\\}~s_t~\\{{p \\mathbin{\\ast\\ast } { \\langlei\\rangle}}\\ } } } \\\\[2ex ] \\infer {    { \\{u\\}~s~\\{p\\ } } } {   u \\models u '   & { \\{u'\\}~s~\\{p'\\ } }   &   p ' \\models p } \\quad \\infer {    { \\{\\exists z.\\ , u\\}~s~\\{\\exists z.\\ , p\\ } } } {    \\forall z.\\ , { \\{u\\}~s~\\{p\\ } } } \\end{array}\\ ] ]      the soundness result states that any derivable hoare triple is semantically valid in the sense that , if the precondition holds of the initial state of an evaluation , then the postcondition is true of the trace produced .    [",
    "prop : sound ] for any @xmath1 , @xmath2 and @xmath3 , if @xmath0 , then , for all @xmath22 and @xmath12 , @xmath131 and @xmath25 imply @xmath259 .    by induction on the derivation of @xmath0 .",
    "we show the main cases of sequence and while .",
    "* @xmath260 : we are given as the induction hypothesis that , for any @xmath261 , @xmath29 and @xmath131 imply @xmath262 , and that , for any @xmath261 , @xmath263 and @xmath264 imply @xmath265 .",
    "we have to prove @xmath266 , given @xmath131 and @xmath267 and @xmath268 . the induction hypothesis for @xmath30",
    "gives us @xmath269 .",
    "by lemma  [ lemma : follows_singleton ] and that @xmath3 is a setoid predicate , we derive @xmath270 and @xmath271 .",
    "we prove by coinduction an auxiliary lemma : for any @xmath12 , @xmath27 , @xmath272 and @xmath36 give @xmath86 , using the induction hypothesis for @xmath67 .",
    "the lemma gives us @xmath273 .",
    "we can now close the case by @xmath274 and @xmath275 .",
    "* @xmath276 : we are given as the induction hypothesis that for any @xmath22 and @xmath12 , @xmath277 and @xmath278 imply @xmath279 .",
    "we also have @xmath280 .",
    "we have to prove @xmath281 , given @xmath131 and @xmath282 .",
    "we prove that , for any @xmath22 and @xmath12 , @xmath282 implies @xmath283 by coinduction .",
    "it remains to prove @xmath284 . by inversion on @xmath282",
    ", we learn that @xmath135 for some @xmath32 and @xmath27 such that @xmath285 .",
    "so , we close the case by proving the following conditions by mutual coinduction : * * for any @xmath22 and @xmath12 , if @xmath286 and @xmath287 , then @xmath288 * * for any @xmath12 and @xmath27 , if @xmath289 and @xmath290 , then @xmath291 .",
    "thanks to proposition  [ prop : total ] ( totality of evaluation ) , as an immediate corollary of proposition  [ prop : sound ] ( soundness ) we learn that , if a state satisfies the precondition of a derivable hoare triple , then there exists an evaluation producing a trace satisfying the postcondition .",
    "[ coro : semax_satisfiable ] for any @xmath1 , @xmath2 and @xmath3 , if @xmath0 , then , for any @xmath22 such that @xmath134 , there exists @xmath12 such that @xmath25 and @xmath90 .",
    "the completeness result states that any semantically valid hoare triple is derivable . following the standard approach ( see , e.g. ,  @xcite ) we define , for a given statement @xmath1 and a given precondition @xmath2 , a trace predicate @xmath292the candidate strongest postcondition .",
    "then we prove that @xmath292 is a postcondition according to the logic ( i.e. , @xmath293 is derivable ) and that @xmath292 is semantically stronger than any other trace predicate that is a postcondition semantically .",
    "completeness follows .",
    "the trace predicate @xmath292 is defined by recursion on @xmath1 in figure  [ fig : sp ] .",
    "the definition is mostly self - explanatory , as it mimics the inference rules of the logic , except that we need the loop - invariant @xmath294 .",
    "@xmath294 characterizes the set of states that are reachable by some run of @xmath295 from a state satisfying @xmath2 and where the boolean guard is tested in that run . and",
    "@xmath292 , we have used impredicativity in our coq development . ]    @xmath296}}\\\\ { \\mathit{sp}({\\ensuremath{\\mathsf{skip } } } , u ) } =   { \\langleu\\rangle}\\\\ { \\mathit{sp}({\\ensuremath{s_0;s_1 } } , u ) } =      p { \\mathbin{\\ast\\ast}}{\\mathit{sp}(s_1 , { \\mathit{last } ~p } ) } \\mathit{~where~ } p = { \\mathit{sp}(s_0 , u ) }   \\\\ { \\mathit{sp}({\\ensuremath{\\mathsf{if~ } e \\mathsf{~then~ } s_t \\mathsf{~else~ } s_f } } , u ) }   =    { \\langle u \\rangle^2 } { \\mathbin{\\ast\\ast}}({{\\mathit{sp}(s_t , { e \\wedge u } ) } \\vee { \\mathit{sp}(s_f , { \\neg e \\wedge u } ) } } ) \\\\ { \\mathit{sp}({\\ensuremath{\\mathsf{while~ } e",
    "\\mathsf{~do~ } s_t } } , u ) } =     { \\langle u \\rangle^2 } { \\mathbin{\\ast\\ast}}{({\\mathit{sp}(s_t , { e \\wedge i } ) } { \\mathbin{\\ast\\ast}}{\\langle i \\rangle^2})^\\dagger } { \\mathbin{\\ast\\ast}}{\\langle\\neg e\\rangle}\\\\ \\hspace*{2 cm } \\mathit{~where~ } i = { \\mathit{inv}(e , s_t , u ) } \\\\ \\\\[2ex ] \\infer { { { \\sigma}\\models { \\mathit{inv}(e , s , u ) } } } {    { { \\sigma}\\models u } } \\quad \\infer { { { \\sigma}\\models { \\mathit{inv}(e , s , u ) } } } {    v \\models { \\mathit{inv}(e , s , u ) }    &    { { \\sigma}\\models { \\mathit{last } ~({\\langle{\\mathit{inv}(e , s , u ) } \\wedge e\\rangle } { \\mathbin{\\ast\\ast}}{\\mathit{sp}(s , v ) } ) } } } \\end{array}\\ ] ]    for any @xmath1 and @xmath2 , the predicate @xmath292 is a monotone setoid predicate .",
    "[ lemma : sp_setoid ] for any @xmath1 , @xmath2 , @xmath12 , @xmath27 , if @xmath297 and @xmath7 , then @xmath298 .    by induction on the structure of @xmath1 .",
    "[ lemma : sp_cont ] for any @xmath1 , @xmath2 , @xmath299 , if @xmath300 , then @xmath301 .    by induction on the structure of @xmath1 .",
    "the following lemma states that any trace which satisfies @xmath292 has its first state satisfying @xmath2 .",
    "[ lemma : sp_hd ] for any @xmath1 , @xmath2 , @xmath12 , if @xmath297 , then @xmath302 .    by induction on the structure of @xmath1 .",
    "the next lemma states a crucial property of @xmath294 .",
    "[ lemma : inv_correct ] for any @xmath1 , @xmath20 , @xmath2 , @xmath303 .",
    "( @xmath304 ) : suppose @xmath305 .",
    "it suffices to prove @xmath306 .",
    "we have @xmath307 by lemma  [ lemma : sp_hd ] , and @xmath308 by lemma  [ lemma : sp_cont ] and @xmath309 .",
    "these give us @xmath310 . by the definition of _ inv",
    "_ , we have for any @xmath22 , @xmath130 implies @xmath311 .",
    "therefore we conclude @xmath306 by lemma  [ lemma : conv_last ] .",
    "( @xmath312 ) : suppose @xmath313 .",
    "we then have some @xmath27 such that @xmath314 and @xmath315 .",
    "the latter proves @xmath7 by lemma  [ lemma : follows_singleton ] .",
    "we conclude @xmath305 by lemma  [ lemma : sp_setoid ] .",
    "we are now ready to establish that @xmath292 is a postcondition according to the hoare logic .",
    "[ lemma : a ] for any @xmath1 , @xmath2 , we have @xmath293 .    by induction on @xmath1 .",
    "we show the main cases of sequence and while .",
    "* @xmath260 : we are given as the induction hypotheses that , for any @xmath316 , @xmath317 and @xmath318 .",
    "we have to prove @xmath319 where @xmath320 . by the induction hypothesis , we have @xmath243 , thus @xmath321 by ( 9 ) of lemma  [ lemma : misc_asserts ] and the consequence rule .",
    "we therefore close the case with @xmath322 given by the induction hypothesis . *",
    "@xmath276 : we are given as the induction hypothesis that @xmath323 , for any @xmath316 .",
    "we have to prove @xmath324 where @xmath325 .",
    "it is sufficient to prove @xmath326 , which follows from the induction hypothesis and lemma  [ lemma : inv_correct ] .",
    "following the standard route , it remains to prove the following condition : for any @xmath1 , @xmath2 , @xmath3 , if for all @xmath261 , @xmath131 and @xmath25 imply @xmath259 , then @xmath327 .",
    "this will be an immediate corollary from lemma  [ lemma : sp_hd ] and the following lemma , stating that any trace satisfying @xmath292 is in fact produced by a run of @xmath1 .",
    "[ lemma : b ] for any @xmath1 , @xmath2 , @xmath12 , if @xmath297 then @xmath328 .    by induction on @xmath1 .",
    "we show the main cases of sequence and while .",
    "* @xmath260 : we are given as the induction hypotheses that , for any @xmath329 , @xmath330 ( resp .",
    "@xmath331 ) implies @xmath332 ( resp .",
    "@xmath333 ) . we have to prove @xmath334 , given @xmath335 , which unfolds into @xmath336 and @xmath337 . by the induction hypothesis for @xmath30",
    ", we have @xmath338 . using the induction hypothesis for @xmath67 , we prove by coinduction that , for any @xmath339 , @xmath340 implies @xmath341 , thereby we close the case .",
    "* @xmath276 : we are given as the induction hypothesis that , for any @xmath329 , @xmath342 implies @xmath343 .",
    "we have to prove @xmath344 , given @xmath345 where @xmath325 .",
    "we do so by proving the following two conditions simultaneously by mutual coinduction : * * for any @xmath12 , @xmath346 implies @xmath347 , * * for any @xmath12 and @xmath27 , @xmath348 implies @xmath290 .",
    "[ cor ] for any @xmath1 , @xmath2 and @xmath3 , if for all @xmath22 and @xmath12 , @xmath131 and @xmath25 imply @xmath259 , then @xmath327 .",
    "completeness is proved as a corollary of lemma  [ lemma : a ] and corollary  [ cor ] .",
    "[ prop : complete ] for any @xmath1 , @xmath2 and @xmath3 , if for all @xmath22 and @xmath12 , @xmath131 and @xmath25 imply @xmath259 , then @xmath0 .",
    "assume that for all @xmath261 , @xmath131 and @xmath25 imply @xmath259 .",
    "by corollary  [ cor ] , we have that @xmath327 . by lemma",
    "[ lemma : a ] , we have @xmath293 .",
    "applying consequence , we get @xmath0 .    combining propositions  [ prop : determ ] ( determinacy of evaluation ) and [ prop : complete ] ( completeness ) , we immediately get completeness for total correctness .    for any @xmath1 , @xmath2 and @xmath3 , if , for all @xmath22 such that @xmath131 , there is @xmath12 such that @xmath25 and @xmath259 , then @xmath0 .",
    "it is easy to see , by going through the soundness and completeness results , that our trace - based hoare logic is a conservative extension of the standard , state - based partial - correctness and total - correctness hoare logics .",
    "but more can be said .",
    "the derivations in these two logics are directly transformable into derivations in our logic , preserving their structure , without invention of new invariants or variants . and in the converse direction , derivations in our logic are transformable into derivations into the standard logics in a way that removes from postconditions information about intermediate states .",
    "in this direction , the variant for a while - loop is obtained by bounding the length of traces satisfying the trace invariant of the loop .",
    "concerning total correctness , we use two variations of the while - rule . in the forward transformation ,",
    "we use a version of the while - rule with a dedicated variant ( a natural - valued _ function _ on states ) whereas , in the backward transformation , we work with a version where the invariant ( a state predicate ) is made dependent on a natural number ( i.e. , becomes a _ relation _ between states and naturals ; crucially , there is no functionality requirement : in the same state , the invariant can be satisfied by zero or one or several naturals ) . the two alternative while - rules for total correctness are : @xmath349 {    { \\{i \\wedge t = m\\}~{\\ensuremath{\\mathsf{while~ } e \\mathsf{~do~ } s_t}}~\\{i \\wedge t \\leq m \\wedge \\neg e\\ } } } {    \\forall n:\\mathit{nat}.    ~{\\{e \\wedge",
    "i \\wedge t = n\\}~s_t~\\{i \\wedge t < n\\ } } } \\ ] ] and @xmath350 {    { \\{j\\ , m\\}~{\\ensuremath{\\mathsf{while~ } e \\mathsf{~do~ } s_t}}~\\{\\exists k.\\ , k \\leq m \\wedge j\\ , k \\wedge \\neg e\\ } } } {    \\forall n:\\mathit{nat}.    ~{\\{e \\wedge j\\ , n\\}~s_t~\\{\\exists k.\\ , k < n \\wedge j\\ , k\\ } } } \\ ] ] there is a reason for this discrepancy , which reflects our compromise between pursuing a constructive approach and striving for purely syntactic translations .",
    "we will discuss it in section  [ sec : hoare : discussion ] after having presented the transformations .",
    "we have tried to fine - tune the inference rules in the different hoare logics and the transformations between them for smoothness .",
    "there is some room for variations in them .",
    "the transformations are quite sensitive to the exact division of labor in the source and target hoare logics between the rules for the statement constructors and the consequence rule , but the effects of the possible variations are mostly inessential .    for reference , the inference rules of the state - based logics appear in the appendix .",
    "notice that also here we use predicates as assertions and entailment as consequence , so there is no dedicated assertion language or proof system for assertions .",
    "we formalize our claim of embeddability of the standard hoare logics in the following two propositions , whose direct proofs are algorithms for the transformations .",
    "proposition  [ prop : partial_hoare ] states that , if @xmath351 is a derivable partial - correctness judgement , then @xmath352 is derivable in our logic .",
    "the trace predicate @xmath353 indicates that @xmath354 holds of any state that is reachable by traversing , in a finite number of steps , the whole trace @xmath12 produced by running @xmath1 .",
    "classically , this amounts to @xmath354 being true of the last state of @xmath12 , if @xmath12 is finite and hence has one ; if @xmath12 is infinite , then nothing is required .",
    "proposition  [ lemma : total_hoare ] states that , if @xmath351 is a derivable total - correctness judgement , then @xmath355 is derivable in our logic ( in fact , it states a little more ) .",
    "the trace predicate @xmath356 expresses that the trace @xmath12 produced by running @xmath1 is finite and @xmath354 holds of the last state of @xmath12 ; the finiteness of @xmath12 guarantees the existence of this last state .",
    "[ prop : partial_hoare ] for any @xmath1 , @xmath2 and @xmath354 , if @xmath351 is derivable in the partial - correctness hoare logic , then @xmath352 is derivable in the trace - based hoare logic .    by induction on the derivation of @xmath351 .",
    "we show the main cases of sequence and while .",
    "* @xmath260 : we are given as the induction hypotheses @xmath357 and @xmath358 .",
    "we have to prove @xmath359 , which is derived by @xmath360 { { \\{u\\}~{\\ensuremath{s_0;s_1}}~\\{{\\ensuremath{\\mathsf{true}}}{\\mathbin{\\ast\\ast}}{\\langlez\\rangle}\\ } } } {    \\infer { { \\{u\\}~{\\ensuremath{s_0;s_1}}~\\{{\\ensuremath{\\mathsf{true}}}{\\mathbin{\\ast\\ast}}{\\ensuremath{\\mathsf{true}}}{\\mathbin{\\ast\\ast}}{\\langlez\\rangle}\\ } } } {      \\infer*[{\\mathrm{ih}}_0]{{\\{u\\}~s_0~\\{{\\ensuremath{\\mathsf{true}}}{\\mathbin{\\ast\\ast}}{\\langlev\\rangle}\\ } } } {      }      &      \\infer*[{\\mathrm{ih}}_1]{{\\{v\\}~s_1~\\{{\\ensuremath{\\mathsf{true}}}{\\mathbin{\\ast\\ast}}{\\langlez\\rangle}\\ } } } {      }    } } \\ ] ] 1 .",
    "we have @xmath361 * @xmath276 : we are given as the induction hypothesis @xmath362 .",
    "we have to prove @xmath363 , which is derived by @xmath360 {    { \\{i\\}~{\\ensuremath{\\mathsf{while~ } e \\mathsf{~do~ } s_t}}~\\{{\\ensuremath{\\mathsf{true}}}{\\mathbin{\\ast\\ast}}{\\langlei \\wedge \\neg e\\rangle}\\ } } } {    \\infer {       { \\{i\\}~{\\ensuremath{\\mathsf{while~ } e \\mathsf{~do~ } s_t}}~\\{{\\langle i \\rangle^2 } { \\mathbin{\\ast\\ast } } { ( { } { \\ensuremath{\\mathsf{true}}}{\\mathbin{\\ast\\ast}}{\\langle i \\rangle^2})^\\dagger } { \\mathbin{\\ast\\ast}}{\\langle { } \\neg e\\rangle}\\ } }    } {      \\infer*[{\\mathrm{ih}}_t]{{\\{e \\wedge i\\}~s_t~\\{{\\ensuremath{\\mathsf{true}}}{\\mathbin{\\ast\\ast}}{\\langlei\\rangle}\\ } } } {      }    } } \\ ] ] 1 .",
    "we have @xmath364    for the embedding of total - correctness derivations , we prove a slightly stronger statement to have the induction go through .",
    "[ lemma : total_hoare ] for any @xmath1 , @xmath2 and @xmath354 , if @xmath351 is derivable in the total - correctness hoare logic with @xmath365 , then for any @xmath366 , @xmath367 is derivable in the trace - based hoare logic .    by induction on the derivation of @xmath351 .",
    "we show the main cases of sequence and while .",
    "* @xmath260 : we are given as the induction hypotheses that , for any @xmath368 , @xmath369 and , for any @xmath370 , @xmath371 .",
    "we have to prove that , for any @xmath366 , @xmath372 .",
    "this is done by the derivation @xmath360 { { \\{u \\wedge w\\}~{\\ensuremath{s_0;s_1}}~\\{{\\langlew\\rangle } { \\mathbin{\\ast\\ast}}{\\mathit{finite}}{\\mathbin{\\ast\\ast}}{\\langlez\\rangle}\\ } } } {    \\infer{{\\{u \\wedge w\\}~{\\ensuremath{s_0;s_1}}~\\{{\\langlew\\rangle } { \\mathbin{\\ast\\ast}}{\\mathit{finite}}{\\mathbin{\\ast\\ast}}{\\langlev\\rangle } { \\mathbin{\\ast\\ast}}{\\mathit{finite}}{\\mathbin{\\ast\\ast}}{\\langlez\\rangle}\\ } } } {      \\infer*[{\\mathrm{ih}}_0\\ , w]{{\\{u \\wedge",
    "w\\}~s_0~\\{{\\langlew\\rangle } { \\mathbin{\\ast\\ast}}{\\mathit{finite}}{\\mathbin{\\ast\\ast}}{\\langlev\\rangle}\\ } } } {      }      &      \\infer{{\\{v\\}~s_1~\\{{\\langlev\\rangle } { \\mathbin{\\ast\\ast}}{\\mathit{finite}}{\\mathbin{\\ast\\ast}}{\\langlez\\rangle}\\ } } } {        \\infer*[{\\mathrm{ih}}_1\\ , v]{{\\{v \\wedge   v\\}~s_1~\\{{\\langlev\\rangle } { \\mathbin{\\ast\\ast}}{\\mathit{finite}}{\\mathbin{\\ast\\ast}}{\\langlez\\rangle}\\ } } } {        }      }    } } \\ ] ] 1 .",
    "we have @xmath373 * @xmath276 : we are given as the induction hypothesis that , for all @xmath374 and @xmath375 , @xmath376 .",
    "we have to prove that , for any @xmath366 , @xmath377 .",
    "this is accomplished by the derivation @xmath360 {    { \\{i \\wedge t = m \\wedge w\\}~{\\ensuremath{\\mathsf{while~ } e \\mathsf{~do~ } s_t}}~\\{{\\langlew\\rangle } { \\mathbin{\\ast\\ast}}{\\mathit{finite}}{\\mathbin{\\ast\\ast}}{\\langlei \\wedge \\neg e \\wedge t \\leq m\\rangle}\\ } } } {    \\infer {      { \\begin{array}{l}\\{i \\wedge t = m \\wedge w\\ } ~{\\ensuremath{\\mathsf{while~ } e \\mathsf{~do~ } s_t } } \\\\",
    "\\quad \\{{\\langle i \\wedge t = m \\wedge w \\rangle^2 } { \\mathbin{\\ast\\ast}}{((\\exists n. { \\langlet = n\\rangle } { \\mathbin{\\ast\\ast}}{\\mathit{finite}}{\\mathbin{\\ast\\ast}}{\\langlet < n\\rangle } ) { \\mathbin{\\ast\\ast}}{\\langle i \\wedge t \\leq m \\rangle^2})^\\dagger }              { \\mathbin{\\ast\\ast}}{\\langle\\neg e\\rangle}\\ } \\end{array } }      } {      \\infer {        { \\{e \\wedge",
    "i \\wedge t \\leq m\\}~s_t~\\{(\\exists n. { \\langlet = n\\rangle } { \\mathbin{\\ast\\ast}}{\\mathit{finite}}{\\mathbin{\\ast\\ast}}{\\langlet < n\\rangle } )               { \\mathbin{\\ast\\ast}}{\\langlei \\wedge t \\leq m\\rangle}\\ } }      } {        \\infer {        { \\{\\exists n.\\ , e \\wedge i \\wedge t = n \\wedge t \\leq m\\}~s_t~\\{\\exists n.\\ , { \\langlet = n\\rangle } { \\mathbin{\\ast\\ast}}{\\mathit{finite}}{\\mathbin{\\ast\\ast}}{\\langlei \\wedge t <",
    "n \\wedge t \\leq m\\rangle}\\ } }       } {        \\infer[(2 ) ] {         \\forall n.\\ ,         { \\{e \\wedge",
    "i \\wedge t = n \\wedge t \\leq m\\}~s_t~\\{{\\langlet = n\\rangle } { \\mathbin{\\ast\\ast}}{\\mathit{finite}}{\\mathbin{\\ast\\ast}}{\\langlei \\wedge",
    "t < n \\wedge t \\leq m\\rangle}\\ } } } {         \\infer*[\\forall n.\\ , { \\mathrm{ih}}_t\\ , n\\ , ( t = n \\wedge t \\leq m)]{\\forall n.\\ ,          { \\{e \\wedge i \\wedge t = n \\wedge t = n \\wedge t \\leq m\\}~s_t~\\{{\\langlet =",
    "n \\wedge t \\leq m\\rangle } { \\mathbin{\\ast\\ast}}{\\mathit{finite}}{\\mathbin{\\ast\\ast}}{\\langlei \\wedge t < n \\rangle}\\ } } } {         }    } } } } } \\ ] ] 1 .",
    "the repetition gives rise to a non - empty colist of values of @xmath378 , which is strictly decreasing and must hence be of finite length .",
    "the concatenation of a finite colist of finite traces is finite .",
    "2 .   if @xmath379 and @xmath380 in the first state of a trace , then @xmath381 ( everywhere ) , so in the last state @xmath382 gives @xmath383 , which can be weakened to @xmath380 .",
    "[ prop : total_hoare ] for any @xmath1 , @xmath2 and @xmath354 , if @xmath351 is derivable in the total - correctness hoare logic with @xmath365 , then @xmath355 is derivable in the trace - based hoare logic .",
    "immediate from proposition  [ lemma : total_hoare ] by choosing @xmath384 .",
    "given that derivations in the standard hoare logics can be transformed into derivations in the trace - based hoare logic , it is natural to wonder , if it is also possible to translate derivations in the converse direction .",
    "in this direction we would expect some loss ( or displacement ) of information . reducing a condition on traces into a condition on those last states that happen to exist or into a condition that also requires their existence",
    "must lose or displace the constraints on the intermediate states .",
    "we now proceed to demonstrating that meaningful transformations ( `` projections '' ) from the trace - based logic to the standard logics are indeed possible .",
    "we will show that , if @xmath0 is derivable in the trace - based hoare logic , then so are @xmath385 in the partial - correctness hoare logic and @xmath386 in the total - correctness hoare logic .",
    "we will shortly define @xmath387 formally , but intuitively , the total - correctness judgement states that @xmath1 terminates in a state satisfying @xmath388 from any initial state @xmath22 such that @xmath2 holds in @xmath22 and any @xmath22-headed trace satisfying @xmath3 has length at most @xmath389 . since @xmath389 is universally quantified on the top level , we can actually derive @xmath390 , stating that @xmath1 terminates in a state satisfying @xmath388 from any initial state @xmath22 such that @xmath2 holds and the length of @xmath22-headed traces satisfying @xmath3 is bounded .",
    "[ lemma : back_hoare ] for any @xmath1 , @xmath2 and @xmath3 , if @xmath0 in the trace - based hoare logic , then for any @xmath366 , @xmath391 is derivable in the partial - correctness hoare logic .",
    "by induction on the derivation of @xmath0 .",
    "we show the main cases of sequence and while .",
    "* @xmath260 : we are given as the induction hypotheses that @xmath392 , for any @xmath368 , and @xmath393 , for any @xmath370 .",
    "we have to show that , for any @xmath366 , @xmath394 .",
    "let @xmath395 .",
    "we have the derivation @xmath360{{\\{u \\wedge w\\}~{\\ensuremath{s_0;s_1}}~\\{{\\mathit{last } ~({\\langlew\\rangle } { \\mathbin{\\ast\\ast}}p { \\mathbin{\\ast\\ast}}q)}\\ } } } {    \\infer{{\\{u \\wedge w\\}~{\\ensuremath{s_0;s_1}}~\\{{\\mathit{last } ~({\\langlev'\\rangle } { \\mathbin{\\ast\\ast}}q)}\\ } } } {      \\infer*[{\\mathrm{ih}}_0\\ , w]{{\\{u \\wedge w\\}~s_0~\\{v'\\ } } } {      }      &         \\infer[(2)]{{\\{v'\\}~s_1~\\{{\\mathit{last } ~({\\langlev'\\rangle } { \\mathbin{\\ast\\ast}}q)}\\ } } } {         \\infer*[{\\mathrm{ih}}_1\\ , v']{{\\{v \\wedge v'\\}~s_1~\\{{\\mathit{last } ~({\\langlev'\\rangle } { \\mathbin{\\ast\\ast}}q)}\\ } } } {         }      }    } } \\ ] ] 1 .   recalling that @xmath396 is monotone",
    ", we have @xmath397 2 .   by lemma  [ lemma : misc_asserts ] ( 10 ) and ( 11 ) , @xmath398 , therefore @xmath399 . * @xmath276 : we are given as the induction hypothesis that , for any @xmath375 , @xmath400 .",
    "we now have to prove that , for any @xmath366 , @xmath401 , given @xmath280 .",
    "let @xmath402 .",
    "we close the case by the derivation @xmath360 { { \\{u \\wedge w\\}~{\\ensuremath{\\mathsf{while~ } e \\mathsf{~do~ } s_t}}~\\{{\\mathit{last } ~({\\langlew\\rangle } { \\mathbin{\\ast\\ast}}{\\langle u \\rangle^2 } { \\mathbin{\\ast\\ast}}{(p { \\mathbin{\\ast\\ast}}{\\langle i \\rangle^2})^\\dagger } { \\mathbin{\\ast\\ast}}{\\langle\\neg e\\rangle})}\\ } } } {    \\infer {      { \\{i'\\}~{\\ensuremath{\\mathsf{while~ } e \\mathsf{~do~ } s_t}}~\\{i ' \\wedge \\neg e\\ } } } {    \\infer[(2 ) ] {    { \\{e \\wedge i'\\}~s_t~\\{i'\\ } }    } {      \\infer*[{\\mathrm{ih}}_t\\ , i']{{\\{e \\wedge",
    "i \\wedge i'\\}~s_t~\\{{\\mathit{last } ~({\\langlei'\\rangle } { \\mathbin{\\ast\\ast}}p { \\mathbin{\\ast\\ast}}{\\langlei\\rangle})}\\ } } } {      }    } } } \\ ] ] 1 .",
    "we have @xmath403 2 .",
    "we have @xmath404    [ prop : back_hoare ] for any @xmath1 , @xmath2 and @xmath3 , if @xmath0 , then @xmath405 is derivable in the partial correctness hoare logic .",
    "immediate from proposition  [ lemma : back_hoare ] and lemma  [ lemma : misc_asserts ] ( 3 ) by instantiating @xmath384 .    to define the assertion translation for the projection of the trace - based hoare logic into the total - correctness hoare logic , we introduce two new connectives .",
    "the inductively defined trace predicate @xmath406 is true of finite traces with length at most @xmath218 ( we take the singleton trace to have length 0 ) . given a trace predicate @xmath3 , the state predicate @xmath407 is defined to be true of a state @xmath22 , if every trace headed by @xmath22 and satisfying @xmath3 also satisfies @xmath406 .",
    "@xmath408 \\infer{{\\sigma}\\models { \\lceil p \\rceil",
    "n } } { \\forall { \\ensuremath{\\tau}}.\\ , { \\mathit{hd}}~{\\ensuremath{\\tau}}= { \\sigma}\\wedge { \\ensuremath{\\tau}}\\models p \\to { \\ensuremath{\\tau}}\\models { \\mathit{len}\\ , n } } \\end{array}\\ ] ]    [ lemma : ceil_antimonotone ] for any @xmath218 , @xmath3 and @xmath83 , if @xmath409 then @xmath410 .    for setoid predicates @xmath3 and @xmath83 , we say @xmath83 _ extends _",
    "@xmath3 , written @xmath411 , if , whenever @xmath90 , there exists @xmath27 such that @xmath86 , i.e. , @xmath412 .",
    "[ lemma : after_monotone ] for any @xmath413 and @xmath414 , if @xmath415 and @xmath416 then @xmath417",
    ".    follows from the definition .",
    "[ lemma : after_chop ] for any @xmath139 and @xmath140 , @xmath418 .",
    "suppose @xmath419 .",
    "there exists @xmath65 such that @xmath420 and @xmath421 .",
    "we then have @xmath422 .",
    "the hypothesis gives us that there exists @xmath156 such that @xmath423 .",
    "we then build a trace @xmath424 such that @xmath425 from @xmath156 by dropping the first @xmath218 elements , where @xmath218 is the length of @xmath65 .",
    "( @xmath218 is welldefined because @xmath65 is finite . )",
    "[ lemma : after_last ] for any @xmath3 and @xmath83 , @xmath426 .",
    "suppose @xmath90 . from the hypothesis",
    ", we know that , for any @xmath22 , if @xmath130 , then there exists @xmath27 such that @xmath427 and @xmath213 . using this , we build a trace @xmath27 such that @xmath86 , by traversing @xmath12 and invoking the hypothesis when the last state of @xmath12 is hit .",
    "[ prop : back_hoaretotal ] for any @xmath1 , @xmath2 and @xmath3 , if @xmath0 in the trace - based hoare logic , then for any @xmath428 and @xmath140 such that @xmath429 , @xmath430 is derivable in the total - correctness hoare logic with @xmath431 .",
    "by induction on the derivation of @xmath0 .",
    "we show the main cases of sequence and while .",
    "* @xmath260 : we are given as the induction hypotheses that , for any @xmath432 and @xmath433 such that @xmath434 , we have that @xmath435 and , for any @xmath436 and @xmath437 such that @xmath438 , we have that @xmath439 we have to prove that , for any @xmath440 and @xmath140 such that @xmath441 we have that @xmath442 + let @xmath443 .",
    "we close the case by the derivation @xmath444{{\\{u \\wedge w \\wedge { \\lceil p { \\mathbin{\\ast\\ast}}q { \\mathbin{\\ast\\ast}}r \\rceil m}\\}~{\\ensuremath{s_0;s_1}}~\\{{\\mathit{last } ~({\\langlew\\rangle } { \\mathbin{\\ast\\ast}}p { \\mathbin{\\ast\\ast}}q ) } \\wedge { \\lceil r \\rceil m}\\ } } } {   \\infer{{\\{u \\wedge w \\wedge { \\lceil p { \\mathbin{\\ast\\ast}}q { \\mathbin{\\ast\\ast}}r \\rceil m}\\}~{\\ensuremath{s_0;s_1}}~\\{{\\mathit{last } ~({\\langlev'\\rangle } { \\mathbin{\\ast\\ast}}q ) } \\wedge { \\lceil r \\rceil m}\\ } } } {    \\infer[(3)]{{\\begin{array}{l}\\{u \\wedge w \\wedge { \\lceil p { \\mathbin{\\ast\\ast}}q { \\mathbin{\\ast\\ast}}r \\rceil m}\\ }            s_0 \\\\ \\quad \\{v ' \\wedge { \\lceil q { \\mathbin{\\ast\\ast}}r \\rceil m}\\ } \\end{array } } } {       \\infer*[(1)~{\\mathrm{ih}}_0\\ , m , w , q { \\mathbin{\\ast\\ast}}r]{{\\begin{array}{l}\\{u \\wedge w \\wedge { \\lceil p { \\mathbin{\\ast\\ast}}{\\langlev\\rangle } { \\mathbin{\\ast\\ast}}q { \\mathbin{\\ast\\ast}}r \\rceil m}\\ }             s_0 \\\\ \\quad \\{v ' \\wedge { \\lceil q { \\mathbin{\\ast\\ast}}r \\rceil m}\\ } \\end{array } } } {       }    }    &    \\infer[(4)]{{\\begin{array}{l}\\ {             v ' \\wedge { \\lceil q { \\mathbin{\\ast\\ast}}r \\rceil m}\\}s_1 \\\\",
    "\\quad \\{{\\mathit{last } ~({\\langlev'\\rangle } { \\mathbin{\\ast\\ast}}q ) } \\wedge { \\lceil r \\rceil m}\\ } \\end{array } }   } {       \\infer*[(2)~{\\mathrm{ih}}_1\\ , m , v ' , r]{{\\begin{array}{l}\\{v \\wedge v ' \\wedge { \\lceil q { \\mathbin{\\ast\\ast}}r \\rceil m}\\}s_1 \\\\ \\quad \\{{\\mathit{last } ~({\\langlev'\\rangle } { \\mathbin{\\ast\\ast}}q ) } \\wedge { \\lceil r \\rceil m}\\ } \\end{array } } } {         }    }   } } \\ ] ] 1 .   to invoke the induction hypothesis",
    ", we have to prove @xmath445 . by corollary  [ coro : semax_satisfiable ] and the hypothesis @xmath446 , we have that , for any @xmath22 such that @xmath447 , there exists @xmath12 such that @xmath448 and @xmath449 .",
    "this gives us @xmath450 . by lemmata  [ lemma : misc_asserts ] ( 11 ) and",
    "[ lemma : after_monotone ] , we have @xmath451 , therefore @xmath452 by lemma  [ lemma : after_last ] . now , for any @xmath12 , suppose @xmath453 .",
    "there exists @xmath27 such that @xmath86 .",
    "we deduce @xmath454 . from the hypothesis @xmath455 , we know that there exists @xmath35 such that @xmath154 , therefore @xmath160 , as required .",
    "2 .   to invoke the induction hypothesis",
    ", we have to prove @xmath456 , namely @xmath457 . by lemma",
    "[ lemma : after_chop ] , it suffices to show @xmath458 , which follows from the hypothesis ( @xmath455 ) , @xmath459 and lemma  [ lemma : after_monotone ] .",
    "3 .   @xmath460 follows from lemma  [ lemma : ceil_antimonotone ] and @xmath461 .",
    "4 .   @xmath399 holds because @xmath462 from lemmata  [ lemma : misc_asserts ] ( 10 ) and ( 11 ) .",
    "we have @xmath463 * @xmath276 .",
    "we are given as the induction hypothesis that , for any @xmath464 , @xmath375 and @xmath465 such that @xmath466 , @xmath467 we also know @xmath280 and @xmath468 , the latter of which gives us @xmath469 we have to prove that , for any @xmath440 and @xmath140 such that @xmath470 we have that @xmath471 let @xmath472 and @xmath473 and @xmath474 we first prove that , for all @xmath218 , @xmath475 holds by case analysis on @xmath218 .",
    "* * @xmath476 .",
    "we prove @xmath477 .",
    "then , by the derivability of @xmath478 for any @xmath1 and @xmath2 in the total correctness hoare logic , we obtain ( [ eq : back_hoare : while_body ] ) .",
    "suppose @xmath479 holds . from @xmath480",
    ", there exists a trace @xmath64 such that @xmath481 and @xmath208 . by lemma  [ lemma : misc_asserts ]",
    "( 14 ) , @xmath480 and @xmath482 give us @xmath483 .",
    "applying corollary  [ coro : semax_satisfiable ] to ( [ eq : back_hoare : whilei ] ) , we know that there exists a trace @xmath65 such that @xmath484 and @xmath485 . hence , we have @xmath486 . we deduce @xmath487 where @xmath488 was defined by corecursion by @xmath489",
    "the assumption @xmath455 gives us a trace @xmath156 such that @xmath490 .",
    "since @xmath64 is finite , we find the suffix @xmath424 of @xmath156 such that @xmath491 by dropping the first @xmath218 elements from @xmath156 , where @xmath218 is the length of @xmath64 .",
    "we also have @xmath492 by construction .",
    "the trace @xmath424 can not be a singleton @xmath493 , which would imply @xmath494 and @xmath495 .",
    "contradiction by @xmath496 . * * @xmath497 .",
    "we invoke the induction hypothesis @xmath498 on @xmath218 , @xmath499 and @xmath83 .",
    "to do so , we have to prove @xmath500 by lemma  [ lemma : after_chop ] , it suffices to prove @xmath501 . from corollary  [ coro : semax_satisfiable ] and",
    "( [ eq : back_hoare : whilei ] ) , we deduce @xmath502 , hence @xmath503 by lemma  [ lemma : after_last ] .",
    "this together with the hypothesis ( @xmath455 ) proves ( [ eq : back_hoare : ih_cond ] ) .",
    "+ we have now proved @xmath504 we close the case by invoking the consequence rule with @xmath505 and @xmath506 + \\(1 ) given a trace @xmath507 and a state @xmath22 satisfying @xmath508 and @xmath509 , we have @xmath510 and @xmath511 .",
    "+ \\(2 ) from lemma  [ lemma : misc_asserts ] ( 14 ) and @xmath280 , we know , for any @xmath22 , if @xmath512 , namely @xmath513 , then @xmath514 .",
    "suppose @xmath515 .",
    "it suffices to prove that , for any @xmath12 , if @xmath448 and @xmath516 , then @xmath517 . we have @xmath518 , which together with @xmath519 yields @xmath520 .",
    "this gives us @xmath517 .",
    "+ by the rule for the while - statement by taking @xmath521 to be @xmath522 , we deduce @xmath523 we have @xmath524 and @xmath525 so , by consequence , we have @xmath526 as we wanted .",
    "[ cor : back_hoaretotal ] for any @xmath1 , @xmath2 and @xmath3 , if @xmath0 in the trace - based hoare logic , then @xmath527 is derivable in the total - correctness hoare logic with @xmath431 .    from proposition  [ prop : back_hoaretotal ] by taking @xmath384 , @xmath528 and then invoking the consequence rule and the admissible rule @xmath529 of the total - correctness hoare logic .",
    "let us now discuss the transformations from and to the total - correctness hoare logic .",
    "we used two different rules for while . in the forward direction ( the embedding ) , we used @xmath365 , whereas in the backward direction ( the projection ) , we used @xmath431 .    with @xmath431 ,",
    "the total - correctness hoare logic is complete , constructively . in particular",
    ", @xmath365 is weaker and straightforwardly derivable from @xmath431 by instantiating @xmath530 .    in the converse direction , attempts to derive @xmath365 from @xmath431 constructively meet several problems .",
    "it is natural to define the invariant @xmath248 as @xmath531 .",
    "the variant @xmath378 should then be defined as @xmath532 this is a sensible classical definition .",
    "but constructively , there are two issues with it .",
    "first , in the first case , we must be able to find the least @xmath533 such that @xmath534 .",
    "we have a bound for this search , which is given by the witness @xmath535 of @xmath536 .",
    "but in order to search , we must be able to decide where @xmath534 or @xmath537 for each @xmath538 , which requires @xmath539 to be decidable .",
    "second , in order to choose between the two cases , we must be able to decide whether @xmath536 or @xmath540 , which is generally impossible .",
    "these issues show that @xmath365 is not fine - tuned for constructive reasoning . to formulate a more sensitive rule",
    ", we may notice that we only ever need @xmath378 in contexts where @xmath531 can be assumed to hold .",
    "so instead of @xmath541 we could use @xmath542 making the variant @xmath378 depend on the proof of the invariant .",
    "the corresponding modified rule is @xmath543 {    { \\{\\sigma p : i.\\ ,   t\\ , p = m\\}~{\\ensuremath{\\mathsf{while~ } e \\mathsf{~do~ } s_t}}~\\{\\sigma p : i.\\ ,   t\\ , p \\leq m \\wedge \\neg e\\ } } } {    \\forall n:\\mathit{nat }    ~{\\{e \\wedge \\sigma p : i.\\ ,   t\\ , p   = n\\}~s_t~\\{\\sigma p : i.\\ ,   t\\ , p < n\\ } } } \\ ] ]    ideally , we would like to use @xmath431 ( or some interderivable rule ) both in the transformations to and from the trace - based hoare logic .",
    "but in the forward direction we have been unable to do it .",
    "we conjecture the reason to be that the state - based total - correctness triples and trace - based ( partial - correctness ) triples express different types of propositions about the underlying evaluation relations : total - correctness triples are about existence of a final state satisfying the postcondition , whereas partial - correctness triples are about all traces produced satisfying the postcondition .",
    "this discrepancy shows itself also in our backward transformation : we need to invoke the totality of the trace - based evaluation relation .",
    "propositions  [ prop : partial_hoare ] and  [ lemma : total_hoare ] show that our trace - based logic is expressive enough to perform the same type of analyses that the state - based partial or total correctness hoare logics can perform .",
    "however , the expressiveness of our logic goes beyond that of the partial and the total correctness hoare logics . in this section",
    ", we demonstrate this by a series of examples .",
    "we adopt the usual notational convention that any occurrence of a variable in a state predicate represents the value of the variable in the state , e.g. , a state predicate @xmath544 abbreviates @xmath545 .",
    "since we work in a constructive underlying logic , we can distinguish between termination of a run , @xmath95 , and nondivergence , @xmath546 .",
    "for instance , any unbounded nonpartial search fails to be terminating but is nonetheless nondivergent .",
    "this example is inspired by markov s principle : @xmath547 for any decidable predicate @xmath548 on natural numbers , i.e. , a predicate satisfying @xmath549 .",
    "markov s principle is a classical tautology , but is not valid constructively .",
    "this implies we can not constructively prove a statement @xmath1 that searches a natural number @xmath218 satisfying @xmath548 by successively checking whether @xmath550 to be terminating . in other words , we can not constructively derive a total correctness judgement for @xmath1 .",
    "the assumption @xmath551 only guarantees that @xmath548 is not false everywhere , therefore the search can not diverge ; indeed , we can constructively prove that @xmath1 is nondivergent in our logic .",
    "we assume given a decidable predicate @xmath548 on natural numbers and an axiom : @xmath552 stating that @xmath548 is not false everywhere . therefore running the statement @xmath553 can not diverge",
    ": this would contradict _ b_noncontradictory_. in proposition  [ prop : markov ] we prove that any trace produced by running @xmath554 is nondivergent and @xmath555 holds of the last state .",
    "we define a family of trace predicates @xmath556 coinductively as follows : @xmath557 @xmath558 is a setoid predicate .",
    "a crucial observation is that , in the presence of _",
    "b_noncontradictory _ , @xmath559 is stronger than nondivergent :    [ lemma : cofinally_not_infinite ] @xmath560 .",
    "it is sufficient to prove that , for any @xmath12 , @xmath561 and @xmath562 are contradictory .",
    "suppose there is a trace @xmath12 such that @xmath561 and @xmath562 .",
    "then by induction on @xmath218 we can show that , for any @xmath218 , there is a trace @xmath27 such that @xmath563 and @xmath564 .",
    "but whenever this holds for some @xmath27 and @xmath218 , then @xmath565 .",
    "hence we also have @xmath566 . but",
    "this contradicts @xmath567 .",
    "it is straightforward to prove that , if @xmath12 satisfies @xmath559 , then its last state ( if exists ) satisfies @xmath548 at @xmath19 .",
    "( we refer to the program variable @xmath19 in the statement @xmath554 . )",
    "[ lemma : cofinally_colast ] @xmath568 .",
    "we prove the following condition by coinduction , from which the lemma follows : for any @xmath569 , if @xmath570 , then @xmath571 .    [ prop : markov ] @xmath572 .",
    "a sketch of the derivation is given in figure  [ fig : markov ] .",
    "( at several places we have applied the consequence rule silently . )    1 .",
    "we use lemmata  [ lemma : cofinally_not_infinite ] and  [ lemma : cofinally_colast ] .",
    "@xmath19 is incremented by one in every iteration until @xmath548 holds at @xmath19 .",
    "@xmath573}}{\\mathbin{\\ast\\ast}}{\\langle { \\ensuremath{\\mathsf{true}}}\\rangle^2})^\\dagger } { \\mathbin{\\ast\\ast}}{\\langleb~x\\rangle } \\models { { \\it cofinally}}~0 $ ] follows from the definition of @xmath574 .",
    "( it is proved by coinduction . )",
    "we take @xmath73 as the loop invariant .        as the similarity of our assertion language to the interval temporal logic suggests",
    ", we can specify and prove liveness properties . in proposition",
    "[ prop : liveness ] , we prove that the statement @xmath576 eventually sets the value of @xmath19 to @xmath218 for any @xmath577 at some point .",
    "the example is simple but sufficient to demonstrate core techniques used to prove liveness properties of more practical examples .",
    "for instance , imagine that assignment to @xmath19 involves a system call , with the assigned value as the argument .",
    "it is straightforward to enrich traces to record such special events , and we can then apply the same proof technique to prove the statement eventually performs the system call with @xmath218 as the argument for any @xmath218 .    for every @xmath218 ,",
    "we define inductively a trace predicate @xmath578 stating that a state @xmath22 in which the value of @xmath19 is @xmath218 is eventually reached by finitely traversing @xmath12 : @xmath579 if @xmath12 satisfies @xmath580 , then it has a finite prefix followed by a state that maps @xmath19 to @xmath218 .",
    "[ lemma : eventually_finite ] for any @xmath569 , if @xmath581 then @xmath582 .    by induction on the derivation of @xmath580 .",
    "[ prop : liveness ] for any @xmath577 , @xmath583 .",
    "a sketch of the derivation is given in figure  [ fig : liveness ] .    1",
    ".   we use lemma  [ lemma : eventually_finite ] .",
    "@xmath19 is incremented by one in every iteration , starting from zero .",
    "each iteration is finite : the length of the trace of each iteration is invariably two .",
    "@xmath19 must eventually become @xmath218 after a finite number of iterations for any @xmath218 .",
    "we take @xmath73 as the invariant .",
    "@xmath575 {    { \\{{\\ensuremath{\\mathsf{true}}}\\}~{\\ensuremath{{\\ensuremath{x : = 0}};{\\ensuremath{\\mathsf{while~ } { \\ensuremath{\\mathsf{true}}}\\mathsf{~do~ } { \\ensuremath{x : = x+1}}}}}}~\\{{\\mathit{finite}}~{\\mathbin{\\ast\\ast}}{\\langlex = n\\rangle } { \\mathbin{\\ast\\ast}}{\\ensuremath{\\mathsf{true}}}\\ } } } { \\infer {    { \\{{\\ensuremath{\\mathsf{true}}}\\}~{\\ensuremath{{\\ensuremath{x : = 0}};{\\ensuremath{\\mathsf{while~ } { \\ensuremath{\\mathsf{true}}}\\mathsf{~do~ } { \\ensuremath{x : = x+1}}}}}}~\\{{\\ensuremath{{\\ensuremath{\\mathsf{true}}}[x\\mapsto 0 ] } } { \\mathbin{\\ast\\ast}}{\\mathit{eventually}}~n\\ } } } {    { \\{{\\ensuremath{\\mathsf{true}}}\\}~{\\ensuremath{x : = 0}}~\\{{\\ensuremath{{\\ensuremath{\\mathsf{true}}}[x\\mapsto 0]}}\\ } }    &    \\infer[(2)]{{\\{x=0\\}~{\\ensuremath{\\mathsf{while~ } { \\ensuremath{\\mathsf{true}}}\\mathsf{~do~ } { \\ensuremath{x : = x+1}}}}~\\{{\\mathit{eventually}}~n\\ } } } {    { \\hspace*{2 mm } \\deduce{\\line(-1,6){2}}{\\makebox[0 cm ] {    \\hspace{-4 cm }      \\infer[(3 ) ] {      { \\begin{array}{l}\\{x=0\\ }               ~{\\ensuremath{\\mathsf{while~ } { \\ensuremath{\\mathsf{true}}}\\mathsf{~do~ } { \\ensuremath{x : = x+1 } } } } \\\\",
    "\\quad \\{{\\langle x=0 \\rangle^2 } { \\mathbin{\\ast\\ast}}{({\\ensuremath{{\\ensuremath{\\mathsf{true}}}[x\\mapsto x+1 ] } } { \\mathbin{\\ast\\ast}}{\\langle { \\ensuremath{\\mathsf{true}}}\\rangle^2})^\\dagger } { \\mathbin{\\ast\\ast}}{\\langle{\\ensuremath{\\mathsf{false}}}\\rangle}\\ } \\end{array } }      } {      { \\{{\\ensuremath{\\mathsf{true}}}\\}~{\\ensuremath{x : = x+1}}~\\{{\\ensuremath{{\\ensuremath{\\mathsf{true}}}[x\\mapsto x+1]}}\\ } } } } } \\hspace*{2 mm } } } } } \\end{array}\\ ] ]      the last example is inspired by a notion of weak trace equivalence : two traces are weakly equivalent if they are bisimilar by identifying a finite number of consecutive identical states with a single state .",
    "it is conceivable that ( strong ) bisimilarity is too strong for some applications and one needs weak bisimilarity .",
    "for instance , we may want to prove that the observable behavior , such as the colist of i / o events of a potentially diverging run , is bisimilar to a particular colist of i / o events",
    ". then we must be able to collapse a finite number of non - observable internal steps .",
    "we definitely should not collapse an infinite number of internal steps , otherwise we would end up concluding that a statement performing an i / o operation after a diverging run , e.g. , @xmath584 , is observably equivalent to a statement immediately performing the same i / o operation , e.g. , @xmath585 .    in this subsection , we prove that the trace produced by running the statement @xmath586 is weakly bisimilar to the ascending sequence of natural numbers @xmath587 , by projecting the value of @xmath19 , assuming that @xmath19 is initially 0 .",
    "the statement differs from that of the previous subsection in that it `` stutters '' for a finite but unbounded number of steps , i.e. , @xmath588 , before the next assignment to @xmath19 happens .",
    "this exercise is instructive in that we need to formalize weak trace equivalence in our constructive underlying logic .",
    "we do so by supplying an inductive predicate @xmath589 stating that @xmath27 is obtained from @xmath12 by dropping finitely many elements from the beginning , until the first state with a different value of @xmath19 is encountered , and a coinductive trace predicate @xmath590 stating that the given trace is weakly bisimilar to the ascending sequence of natural numbers starting at @xmath218 , by projecting the value of @xmath19 .",
    "formally : @xmath591    @xmath592 these definitions are tailored to our example . but a more general weak trace equivalence can be defined similarly  @xcite .",
    "we note that our formulation is not the only one possible nor the most elegant .",
    "in particular , with a logic supporting nesting of induction into coinduction as primitive  @xcite , there is no need to separate the definition into an inductive part , @xmath589 , and a coinductive part , @xmath590 . yet",
    "our formulation is amenable for formalization in coq .",
    "we also use an auxiliary trace predicate @xmath593 that is true of a finite trace in which the value of @xmath19 does not change and is non - negative at the end and hence everywhere .",
    "it is defined inductively as follows : @xmath594    [ prop : wkbism ] @xmath595 where @xmath596 .",
    "a sketch of the derivation is given in figure  [ fig : wstream ] .",
    "@xmath19 is incremented by one in every iteration , starting from zero , and the loop is iterated forever .",
    "each iteration is finite , although globally unbounded .",
    "so @xmath19 must increase forever .",
    "we take @xmath597 as the invariant .",
    "@xmath598 is decremented by one in every iteration , starting from a non - negative number .",
    "it must become zero after a finite number of iterations .",
    "@xmath19 does not change .",
    "we take @xmath599 as the invariant .",
    "coinductive big - step semantics for nontermination have been considered by cousot and cousot @xcite and by leroy and grall @xcite ( in the context of the compcert project , which is a major demonstration of feasibility of certified compilation ) .",
    "cousot and cousot @xcite study fixpoints on bi - semantic domains , partitioned into domains of terminating and diverging behaviors ; they prove a specific fixed - point theorem for such domains ( bi - induction ) , and then produce a bi - inductive big - step semantics for lambda - calculus ( avoiding some duplication of rules between what would otherwise be distinct inductive and coinductive definitions of terminating resp .  diverging evaluation ) .",
    "leroy and grall @xcite investigate two big - step semantics approaches for lambda - calculus .",
    "the first , based on cousot and cousot @xcite , has different evaluation relations for terminating and diverging runs , one inductive ( with finite traces ) , the other coinductive ( with infinite traces ) . to conclude that any program either terminates or diverges",
    ", they need the law of excluded middle ( amounting to decidability of the halting problem ) , and , as a result , can not prove the standard small - step semantics sound wrt .",
    "the big - step semantics constructively .",
    "the second approach , applied in @xcite , uses a coinductively defined evaluation relation with possibly infinite traces .",
    "while - loops are not ensured to be progressive in terms of growing traces ( an infinite number of consecutive silent small steps may be collapsed ) and this leads to problems .",
    "some other works on coinductive big - step semantics include glesner  @xcite and nestra  @xcite .",
    "in these it is accepted that a program evaluation can somehow continue after an infinite number of small steps . with glesner",
    ", this seems to have been a curious unintended side - effect of the design , which she was experimenting with just for the interest of it .",
    "nestra developed a nonstandard semantics with transfinite traces on purpose in order to obtain a soundness result for a widely used slicing transformation that is unsound standardly ( can turn nonterminating runs into terminating runs ) .",
    "our trace - based coinductive big - step semantics  @xcite was heavily inspired by capretta s",
    "@xcite modelling of nontermination in a constructive setting similar to ours . rather than using coinductive",
    "possibly infinite traces , he works with a coinductive notion of a possibly infinitely delayed value ( for statements , this corresponds to delaying the final state ) .",
    "the categorical basis appears in rutten s work  @xcite .",
    "but rutten only studied the classical setting ( any program terminates or not ) , where a delayed state collapses to a choice of between a state or a designated token signifying nontermination .",
    "a general categorical account of small - step trace - based semantics has been given by hasuo et al .",
    "@xcite .",
    "while hoare logics for big - step semantics based on inductive , finite traces have been considered earlier ( to reason about traces of terminating runs ) , hoare or vdm - style logics for reasoning about properties of nonterminating runs do not seem to have been studied before , with one exception , see below .",
    "neither do we in fact know about dynamic logic or kat ( kleene algebra with tests ) approaches that would have assertions about possibly infinite traces .",
    "rather , nonterminating runs have been typically reasoned about in temporal logics like ltl and ctl@xmath601 or in interval temporal logic @xcite .",
    "these are however essentially different in spirit by their `` endogeneity '' : assertions are made about traces in a fixed transition system rather than traces of runs of different programs .",
    "notably , however , interval temporal logic has connectives similar to ours  in fact they were a source of inspiration for our design .",
    "hofmann and pavlova  @xcite consider a vdm - style logic with finite trace assertions that are applied to all finite prefixes of the trace of a possibly nonterminating run of a program .",
    "this logic allows reasoning about safety , but not liveness .",
    "we expect that we should be able to embed a logic like this in ours .",
    "we have presented a sound and complete hoare logic for the coinductive trace - based big - step semantics of while .",
    "the logic naturally extends both the standard state - based partial and total correctness hoare logics .",
    "its design may be exploratory at this stage  in the sense that one might wish to consider alternative choices of primitive connectives .",
    "we see our logic as a viable unifying foundational framework facilitating translations from more applied logics .",
    "we are grateful to martin hofmann , thierry coquand and adam chlipala for discussions .",
    "our anonymous reviewers provided very detailed and useful feedback .",
    "20    y.  bertot , p.  castran .",
    "_ interactive theorem proving and program development : coqart : the calculus of inductive constructions _ , _ texts in theoretical computer science : an eatcs series_. springer , 2004 .",
    "s.  blazy , x.  leroy .",
    "mechanized semantics for the clight subset of the c language . _ j.  of autom .  reasoning _ , 43(3):263288 , 2009",
    ".    v.  capretta .",
    "general recursion via coinductive types .",
    "methods in comput .",
    "_ , 1(2:1 ) , 2005 .    p.",
    "cousot , r.  cousot .",
    "inductive definitions , semantics and abstract interpretation . in _ conf .",
    "record of 19th acm sigplan - sigact symp .  on principles of programming languages , popl  92 ( albuquerque , nm , jan.1992 )",
    "_ , pp .  8394 .",
    "acm press , 1992 .",
    "p.  cousot , r.  cousot .",
    "bi - inductive structural semantics . _ inform .  and comput .",
    "_ , 207(2):258283 , 2009 .",
    "n.  a. danielsson , t. altenkirch .",
    "subtyping , declaratively . in c.  bolduc , j.  desharnais , b.  ktari , eds . , _ proc .  of 10th int .",
    "conf .  on mathematics of program construction , mpc 2000 ( qubec city , june 2010 )",
    "_ , vol .",
    "6120 of _ lect .",
    "notes in comput .",
    "_ , pp .  100118 .",
    "springer , 2010 .",
    "s.  glesner . a proof calculus for natural semantics based on greatest fixed point semantics . in j.",
    "knoop , g.  c. necula , w. zimmermann , eds . , _ proc . of 3rd int .",
    "wksh .  on compiler",
    "optimization meets compiler verification , cocv  2004 ( barcelona , apr .",
    "2004 ) _ , vol .",
    "132(1 ) of _ electron .",
    "notes in theor .",
    "_ , pp .  7393 .",
    "elsevier , 2004 .",
    "j.  halpern , z.  manna , b.  moszkowski . a hardware semantics based on temporal intervals . in j.",
    "daz , ed .",
    ", _ proc .  of 10th int .",
    "on automata , languages and programming , icalp  83 ( barcelona , july 1983 ) _ , vol .",
    "154 of _ lect .",
    "notes in comput .",
    "_ , pp .  278191 .",
    "springer , 1983 .",
    "i.  hasuo , b.  jacobs , a.  sokolova .",
    "generic trace semantics via coinduction .",
    "methods in comput .",
    "_ , 3(4:11 ) , 2007 .",
    "m. hofmann , m. pavlova .",
    "elimination of ghost variables in program logics . in g.",
    "barthe , c.  fournet , eds . , _ revised selected papers from 3rd symp .  on trustworthy global computing , tgc  2007 ( sophia antipolis , nov .",
    "2007 ) _ , vol .",
    "4912 of _ lect .",
    "notes in comput .",
    "_ , pp .  120 .",
    "springer , 2008 .",
    "x.  leroy .",
    "coinductive big - step operational semantics . in p.",
    "sestoft , ed . , _ proc .  of 15th europ .",
    "symp . on programming ,",
    "esop 2006 ( vienna , march 2006 ) _ , vol .",
    "3924 of _ lect .",
    "notes in comput .",
    "_ , pp . 5468 .",
    "springer , 2006 .",
    "x.  leroy , h.  grall .",
    "coinductive big - step operational semantics .",
    "_ inform .  and comput .",
    "_ , 207(2):285305 , 2009 .",
    "t.  kleymann .",
    "hoare logic and auxiliary variables .",
    "_ formal asp .  in comput .",
    "_ 11(5):541566 , 1999",
    ".    b.  moszkowski . a temporal logic for reasoning about hardware .",
    "_ computer _ , 18(2):1019 , 1985 .",
    "k.  nakata , t.  uustalu . a hoare logic for the coinductive trace - based big - step semantics of while . in a.",
    "d. gordon , ed .",
    ", _ proc .  of 19th european symp .  on programming , esop 2010 ( paphos , march 2010 )",
    "_ , vol .",
    "6012 of _ lect .",
    "notes in comput .",
    "_ , pp .  488506 .",
    "springer , 2010 .",
    "k.  nakata , t.  uustalu .",
    "resumptions , weak bisimilarity and big - step semantics for while with interactive i / o : an exercise in mixed induction - coinduction . in l.",
    "aceto , p.  sobocinski , eds .",
    ", _ proc .  of 7th wksh .  on structural operational semantics , sos 2010 ( paris , aug .",
    "2010 ) _ , vol .",
    "32 of _ electron .",
    "proc .  in theor .",
    "_ , pp .  5775 .",
    "open publishing assoc . , 2010 .",
    "k.  nakata , t.  uustalu .",
    "trace - based coinductive operational semantics for while : big - step and small - step , relational and functional styles . in s.",
    "berghofer , t.  nipkow , c.  urban , m.  wenzel , eds .",
    ", _ proc .  of 22nd int .",
    "conf .  on theorem proving in higher order logics , tphols 2009 ( munich , aug .",
    "2009 ) _ , vol .",
    "5674 of _ lect .",
    "notes in comput .",
    "_ , pp .  375390 .",
    "springer , 2009 .",
    "h.  nestra .",
    "fractional semantics . in m.",
    "johnson , v.  vene , eds .",
    ", _ proc .  of 11th int .",
    "conf . on algebraic methodology and software technology ,",
    "amast  2006 ( kuressaare , july 2006 ) _ , vol .  4019 of _ lect .",
    "notes in comput .",
    "_ , pp .  278292 .",
    "springer , 2006 .    h.  nestra .",
    "transfinite semantics in the form of greatest fixpoint .",
    "_ j.  of log .  and algebr",
    ".  program .",
    "_ , 78(7):574593 , 2009 .",
    "h.  riis nielson , f.  nielson .",
    "_ semantics with applications : a formal introduction_. wiley , 1992 .",
    "j.  rutten . a note on coinduction and weak bisimilarity for while programs .",
    "_ theor .",
    "inform .  and appl .",
    "_ , 33(45):393400 , 1999 .",
    "the figures below give the rules of the standard , state - based partial correctness and total correctness hoare logics in the form used in section  [ sec : hoare ] .",
    "@xmath602\\}~{\\ensuremath{x : = e}}~\\{u\\ } } } { } \\quad \\infer {    { \\{u\\}~{\\ensuremath{\\mathsf{skip}}}~\\{u\\ } } } { } \\quad \\infer{{\\{u\\}~s_0;s_1~\\{z\\ } } } {    { \\{u\\}~s_0~\\{v\\ } }    &    { \\{v\\}~s_1~\\{z\\ } } } \\\\[2ex ] \\infer {    { \\{u\\}~{\\ensuremath{\\mathsf{if~ } e \\mathsf{~then~ } s_t \\mathsf{~else~ } s_f}}~\\{z\\ } } } {    { \\{e \\wedge u\\}~s_t~\\{z\\ } }    & { \\{\\neg e \\wedge u\\}~s_f~\\{z\\ } } } \\quad \\infer {    { \\{i\\}~{\\ensuremath{\\mathsf{while~ } e \\mathsf{~do~ } s_t}}~\\{i \\wedge \\neg e\\ } } } {    { \\{e \\wedge i\\}~s_t~\\{i\\ } } } \\\\[2ex ] \\infer {    { \\{\\exists z.\\ , u\\}~s~\\{\\exists z.\\ , v\\ } } } {    \\forall z.\\ , { \\{u\\}~s~\\{v\\ } } } \\quad \\infer {    { \\{u\\}~s~\\{z\\ } } } {    u \\models u '    & { \\{u'\\}~s~\\{z'\\ } }    & z ' \\models z } \\end{array}\\ ] ]    @xmath602\\}~{\\ensuremath{x : = e}}~\\{u\\ } } } { } \\quad \\infer {    { \\{u\\}~{\\ensuremath{\\mathsf{skip}}}~\\{u\\ } } } { } \\quad \\infer{{\\{u\\}~s_0;s_1~\\{z\\ } } } {    { \\{u\\}~s_0~\\{v\\ } }    &    { \\{v\\}~s_1~\\{z\\ } } } \\\\[2ex ] \\quad \\infer {    { \\{u\\}~{\\ensuremath{\\mathsf{if~ } e \\mathsf{~then~ } s_t \\mathsf{~else~ } s_f}}~\\{z\\ } } } {    { \\{e \\wedge u\\}~s_t~\\{z\\ } }    & { \\{\\neg e \\wedge u\\}~s_f~\\{z\\ } } } \\\\[2ex ] \\infer[{\\textrm{while - fun } } ] {    { \\{i \\wedge t = m\\}~{\\ensuremath{\\mathsf{while~ } e \\mathsf{~do~ } s_t}}~\\{i \\wedge t \\leq m \\wedge \\neg e\\ } } } {    \\forall n:\\mathit{nat }    ~{\\{e \\wedge i \\wedge t = n\\}~s_t~\\{i \\wedge t < n\\ } } } \\\\[2ex ] \\mathrm{alt . }",
    "\\\\[2ex ] \\infer[{\\textrm{while - rel } } ] {    { \\{j\\ , m\\}~{\\ensuremath{\\mathsf{while~ } e \\mathsf{~do~ } s_t}}~\\{\\exists k.\\ , k \\leq m \\wedge j\\ , k",
    "\\wedge \\neg e\\ } } } {    \\forall n:\\mathit{nat }    ~{\\{e \\wedge j\\ , n\\}~s_t~\\{\\exists k.\\ , k < n \\wedge j\\ , k\\ } } }    \\\\[2ex ] \\infer {    { \\{\\exists z.\\ , u\\}~s~\\{\\exists z.\\ , v\\ } } } {    \\forall z.\\ , { \\{u\\}~s~\\{v\\ } } } \\quad \\infer {    { \\{u\\}~s~\\{z\\ } } } {    u \\models u '    & { \\{u'\\}~s~\\{z'\\ } }    & z ' \\models z } \\end{array}\\ ] ]"
  ],
  "abstract_text": [
    "<S> in search for a foundational framework for reasoning about observable behavior of programs that may not terminate , we have previously devised a trace - based big - step semantics for while . in this </S>",
    "<S> semantics , both traces and evaluation ( relating initial states of program runs to traces they produce ) are defined coinductively . on terminating runs </S>",
    "<S> , this semantics agrees with the standard inductive state - based semantics . here </S>",
    "<S> we present a hoare logic counterpart of our coinductive trace - based semantics and prove it sound and complete . </S>",
    "<S> our logic subsumes the standard partial - correctness state - based hoare logic as well as the total - correctness variation : they are embeddable . in the converse direction </S>",
    "<S> , projections can be constructed : a derivation of a hoare triple in our trace - based logic can be translated into a derivation in the state - based logic of a translated , weaker hoare triple . </S>",
    "<S> since we work with a constructive underlying logic , the range of program properties we can reason about has a fine structure ; in particular , we can distinguish between termination and nondivergence , e.g. , unbounded classically total search fails to be terminating , but is nonetheless nondivergent . </S>",
    "<S> our metatheory is entirely constructive as well , and we have formalized it in coq . </S>"
  ]
}