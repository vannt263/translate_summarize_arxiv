{
  "article_text": [
    "in this paper , we investigate classes of systems based on different asynchronous interaction patterns with the aim of achieving distributability , i.e.  the possibility to execute a system on spatially distributed locations , which do not share a common clock . as our system model",
    "we use petri nets .",
    "the main reason for this choice is the detailed way in which a petri net represents a concurrent system , including the interaction between the components it may consist of . in an interleaving based model of concurrency such as labelled transition systems modulo bisimulation semantics , a system representation as such can not be said to display synchronous or asynchronous interaction ; at best these are properties of composition operators , or communication primitives , defined in terms of such a model .",
    "a petri net on the other hand displays enough detail of a concurrent system to make the presence of synchronous communication discernible .",
    "this makes it possible to study asynchronous communication without digressing to the realm of composition operators .    in a petri net ,",
    "a transition interacts with its preplaces by consuming tokens .",
    "an inherent concept of simultaneity is built in , since when a transition has more than one preplace , it can be crucial that tokens are removed instantaneously , depending on the surrounding structure or  more elaborately  the behaviour of the net .    when modelling a distributed system by a petri net , this built - in concept of synchronous interaction",
    "may become problematic .",
    "assume a transition @xmath1 on a location @xmath2 models an activity involving another location @xmath3 , for example by receiving a message .",
    "this can be modelled by a preplace @xmath4 of @xmath1 such that @xmath4 and @xmath1 are situated in different locations .",
    "we assume that taking a token can in this situation not be considered as instantaneous ; rather the interaction between @xmath4 and @xmath1 takes time .",
    "we model this effect by inserting silent ( unobservable ) transitions between transitions and their preplaces .",
    "we call the effect of such a transformation of a net @xmath5 an _ asynchronous implementation _ of @xmath5 .",
    "( 13,4.5 ) (2,4):p1 ; (4,4):p2 ; ( 2,1):t1:a ; ( 4,1):t2:b ; p1->t1 ; p1->t2 ; p2->t2 ; p2->n1 ;    ( 6,2)@xmath6    (8,4):p1b ; (11,4):p2b ; ( 11,3):p2btt:@xmath7 ; ( 11,2):p2btp ; ( 10,3):p1bt2t:@xmath7 ; ( 10,2):p1bt2p ; ( 8,1):t1b : a ; ( 11,1):t2b : b ; p1b->t1b ; p2b->p2btt ; p2btt->p2btp ; p2btp->t2b ; p1b->p1bt2 t ; p1bt2t->p1bt2p ; p1bt2p->t2b ; p2b->n1b ;    an example of such an implementation is shown in figure  [ fig - sym - transform ] .",
    "note that @xmath8 can be disabled in the implementation before any visible behaviour has taken place .",
    "this difference will cause non - equivalence between the original and the implementation under branching time equivalences .",
    "our asynchronous implementation allows a token to start its journey from a place to a transition even when not all preplaces of the transition contain a token .",
    "this design decision is motivated by the observation that it is fundamentally impossible to check in an asynchronous way whether all preplaces of a transition are marked  it could be that a token moves back and forth between two such places .",
    "we investigate different interaction patterns for the asynchronous implementation of nets . the simplest pattern ( _ full asynchrony _ )",
    "assumes that every removal of a token from a place is time consuming . for the next pattern ( _ symmetric asynchrony _ ) , tokens are only removed slowly when they are consumed by a backward branched transition , hence where the concept of simultaneous removal actually occurs .",
    "finally we consider a more intricate pattern by allowing to remove tokens from preplaces of backward branched transitions asynchronously in sequence ( _ asymmetric asynchrony _ ) .    given a choice of interaction pattern , we call a net @xmath5 _ asynchronous",
    "_ when there is no essential behavioural difference between @xmath5 and its asynchronous implementation @xmath9 .",
    "in order to formally define this concept , we wish to compare the behaviours of @xmath5 and @xmath9 using a semantic equivalence that fully preserves branching time , causality and their interplay , whilst of course abstracting from silent transitions . by choosing the most discriminating equivalence possible",
    ", we obtain the smallest possible class of asynchronous nets , thus excluding nets that might be classified as asynchronous merely because a less discriminating equivalence would fail to see the differences between such a net and its asynchronous implementation . to simplify the exposition",
    ", here we merely compare the behaviours of @xmath5 and @xmath9 up to _ failures equivalence _ @xcite .",
    "this interleaving equivalence abstracts from causality and respects branching time only to some degree .",
    "however , we conjecture that our results are in fact largely independent of this choice and that more discriminating equivalences , such as the history preserving st - bisimulation of @xcite , would yield the same classes of asynchronous nets .",
    "using a linear time equivalence would give rise to larger classes ; this possibility is investigated in @xcite .",
    "thus we investigate the effect of our three transformations of instantaneous interaction into asynchronous interaction patterns by comparing the behaviours of nets before and after insertion of the silent transitions up to failures equivalence .",
    "we show that in the case of full asynchrony , we obtain equivalent behaviour exactly for conflict - free petri nets .",
    "further we establish that symmetric asynchrony is a valid concept for @xmath10-free petri nets and asymmetric asynchrony for @xmath11-free petri nets , where @xmath10 and @xmath11 stand for certain structural properties ; the reachability of such structures is crucial . for symmetric asynchrony we obtain a precise characterisation of the class of nets which is asynchronously implementable . for asymmetric asynchrony",
    "we obtain lower and upper bounds .    in the concluding section ,",
    "we discuss the use of our results for message sequence charts , as an example how they may be useful for other models than petri nets .",
    "when interpreting basic message sequence chart as petri nets , the resulting petri nets lie within the class of conflict - free and hence @xmath10-free petri nets .",
    "the more expressive classes give insights in the effect of choices in non - basic mscs .",
    "this is an extended abstract ; for sake of brevity most proofs are omitted .",
    "they are contained in the full version of this paper @xcite , as well as in @xcite .",
    "the paper is structured as follows . in section [ sec - notions ]",
    "we establish the necessary basic notions . in section [ sec - fsa ]",
    "we introduce the fully asynchronous transformation and give a semi - structural characterisation of the resulting net class .",
    "in section [ sec - sa ] we repeat those steps for the symmetrically asynchronous transformation .",
    "furthermore we describe how the resulting net class relates to the classes of free - choice and extended free choice nets . in section [ sec - aa ]",
    "we introduce the asymmetrically asynchronous transformation .",
    "we give semi - structural upper and lower bounds for the resulting net class and relate it to simple and extended simple nets . in the conclusion in section  [ sec - conclusion ]",
    "we compare our findings to similar results in the literature .",
    "an extended abstract of this paper will be presented at the first _ interaction and concurrency experience _",
    "( ice08 ) on _ synchronous and asynchronous interactions in concurrent distributed systems _ , and will appear in _ electronic notes in theoretical computer science _ , elsevier .",
    "we consider here 1-safe net systems , i.e.  places never carry more than one token , but a transition can fire even if pre- and postset intersect . to represent unobservable behaviour , which we use to model asynchrony , the set of transitions is partitioned into observable and silent ( unobservable ) ones .",
    "nst a _ net with silent transitions _ is a tuple @xmath12 where    * @xmath13 is a set ( of _ places _ ) , * @xmath14 is a set ( of _ observable transitions _ ) , * @xmath15 is a set ( of _ silent transitions _ ) , * @xmath16 ( the _ flow relation _ ) with @xmath17 ( _ transitions _ ) and * @xmath18 ( the _ initial marking _ ) .",
    "petri nets are depicted by drawing the places as circles , the transitions as boxes , and the flow relation as arrows ( _ arcs _ ) between them .",
    "when a petri net represents a concurrent system , a global state of such a system is given as a _ marking _ , a set of places , the initial state being @xmath19 .",
    "a marking is depicted by placing a dot ( _ token _ ) in each of its places .",
    "the dynamic behaviour of the represented system is defined by describing the possible moves between markings .",
    "a marking @xmath20 may evolve into a marking @xmath21 when a nonempty set of transitions @xmath22",
    "_ fires_. in that case , for each arc @xmath23 leading to a transition @xmath1 in @xmath22 , a token moves along that arc from @xmath4 to @xmath1 .",
    "naturally , this can happen only if all these tokens are available in @xmath20 in the first place .",
    "these tokens are consumed by the firing , but also new tokens are created , namely one for every outgoing arc of a transition in @xmath22 .",
    "these end up in the places at the end of those arcs .",
    "a problem occurs when as a result of firing @xmath22 multiple tokens end up in the same place . in that case",
    "@xmath21 would not be a marking as defined above . in this paper",
    "we restrict attention to nets in which this never happens .",
    "such nets are called _",
    "1-safe_. unfortunately , in order to formally define this class of nets , we first need to correctly define the firing rule without assuming 1-safety .",
    "below we do this by forbidding the firing of sets of transitions when this might put multiple tokens in the same place .",
    "steps let @xmath12 be a net .",
    "let @xmath24 .",
    "we denote the preset and postset of a net element @xmath25 by @xmath26 and @xmath27 respectively .",
    "a nonempty set of transitions @xmath28 , is called a _ step from @xmath29 to @xmath30 _ , notation @xmath31 , iff    * all transitions contained in @xmath22 are _ enabled _ , that is @xmath32 * all transitions of @xmath22 are _ independent _ , that is _ not conflicting _ : @xmath33 * in @xmath30 all tokens have been removed from the _ preplaces _ of @xmath22 and new tokens have been inserted at the _ postplaces _ of @xmath22 : @xmath34    to simplify statements about possible behaviours of nets , we use some abbreviations .",
    "steprellet @xmath12 be a net with silent transitions .",
    "* @xmath35 is defined by @xmath36 * @xmath37 is defined by @xmath38 * @xmath39 is defined by @xmath40_n m_2 \\equivalent\\\\[3pt ]        \\hphantom{m_1 \\production{\\sigma}_n m_2 \\equivalent }        m_1        \\production{\\tau}^*_n \\production{\\{t_1\\}}_n        \\production{\\tau}^*_n \\production{\\{t_2\\}}_n        \\production{\\tau}^*_n \\cdots",
    "\\production{\\tau}^*_n \\production{\\{t_n\\}}_n        \\production{\\tau}^*_n        m_2 $ ] + where @xmath41 denotes the reflexive and transitive closure of @xmath42 .",
    "we write @xmath43 for @xmath44 , @xmath45 for @xmath46 and similar for the other two relations .",
    "a marking @xmath29 is said to be _",
    "reachable _ iff there is a @xmath47 such that @xmath48 .",
    "the set of all reachable markings is denoted by @xmath49 .",
    "we omit the subscript @xmath5 if clear from context .    as said before , here we only want to consider 1-safe nets .",
    "formally , we restrict ourselves to _ contact - free nets _ where in every reachable marking @xmath50 for all @xmath51 with @xmath52    @xmath53    for such nets , in definition  [ df - steps ] we can just as well consider a transition @xmath1 to be enabled in @xmath20 iff @xmath54 , and two transitions to be independent when @xmath55 . in this paper",
    "we furthermore restrict attention to nets for which @xmath56 , and @xmath57 and @xmath58 are finite for all @xmath59 .",
    "we also require the initial marking @xmath19 to be finite .",
    "a consequence of these restrictions is that all reachable markings are finite , and it can never happen that infinitely many independent transitions are enabled .",
    "henceforth , we employ the name _",
    "@xmath7-nets _ for nets with silent transitions obeying the above restrictions , and _ plain nets _ for @xmath7-nets without silent transitions , i.e.  with @xmath60 .",
    "plain nets have the nice property of being deterministic , i.e.  the marking obtained after firing a sequence of transitions is uniquely determined by the sequence of transitions fired .",
    "determ let @xmath61 be a plain net , @xmath62 and @xmath63 .",
    "if @xmath64 then @xmath65 .",
    "let @xmath66 , @xmath62 and @xmath67 .",
    "+ then @xmath68 and @xmath69 implies @xmath70 .",
    "+ hence @xmath71 implies @xmath65 .",
    "+ the result follows for a trace @xmath72 by induction on the length of @xmath72 .",
    "our nets with silent transitions can be regarded as special _ labelled nets _ , defined as in definition  [ df - nst ] , but without the split of @xmath73 into @xmath14 and @xmath15 , and instead equipped with a _ labelling function _",
    "@xmath74 , where _ act _ is a set of _ visible actions _ and @xmath75 an invisible one . nets with silent transitions correspond to labelled nets in which no two different transitions are labelled by the same visible actions , which can be formalised by taking @xmath76 for @xmath77 and @xmath78 for @xmath79 .    to describe which nets are `` asynchronous '' , we will compare their behaviour to that of their asynchronous implementations using a suitable equivalence relation .",
    "as explained in the introduction , we consider here branching time semantics . technically , we use failures equivalence , as defined below .",
    "failurepair let @xmath12 be a @xmath7-net , @xmath47 and @xmath80 .",
    "@xmath81 is a _ failure pair _ of @xmath5 iff @xmath82 we define @xmath83 .",
    "two @xmath7-nets @xmath5 and @xmath84 are _ failures equivalent _ , @xmath85 , iff @xmath86 .",
    "a @xmath7-net @xmath12 is called _ divergence free _ iff there are no infinite chains of markings @xmath87 with @xmath88 .",
    "as explained in the introduction , we will examine in this paper different possible assumptions of how asynchronous interaction between transitions and their preplaces takes place . in this section ,",
    "we start with the simple and intuitive assumption that the removal of any token by a transition takes time . this is implemented by inserting silent transitions between visible ones and their preplaces .",
    "fsi let @xmath61 be a plain net . the _ fully asynchronous implementation _ of @xmath5 is defined as the net + @xmath89 with @xmath90    for better readability we will use the abbreviations @xmath91 and @xmath92 instead of @xmath93 or @xmath94 when making assertions about the flow relation of an implementation .",
    "the following lemma shows how the fully asynchronous implementation of a plain net @xmath5 simulates the behaviour of @xmath5 .",
    "fsisim let @xmath61 be a plain net , @xmath95 , @xmath96 and @xmath24 .",
    "if @xmath97 then @xmath98 .    if @xmath99 then @xmath100 .",
    "assume @xmath101 .",
    "then , by construction of @xmath102 , @xmath103 the first part of that execution can be split into a sequence of singletons .",
    "+ the second statement follows by a straightforward induction on the length of @xmath72 .",
    "this lemma uses the fact that any marking of @xmath5 is also a marking on @xmath102 .",
    "the reverse does not hold , so in order to describe the degree to which the behaviour of @xmath102 is simulated by @xmath5 we need to explicitly relate markings of @xmath102 to those of @xmath5 .",
    "this is in fact not so hard , as any reachable marking of @xmath102 can be obtained from a reachable marking of @xmath5 by moving some tokens into the newly introduced buffering places @xmath104 . to establish this formally ,",
    "we define a function which transforms implementation markings into the related original markings , by shifting these tokens back .",
    "tauback let @xmath61 be a plain net and let @xmath105 .",
    "@xmath106 is the function defined by @xmath107    where necessary we extend functions to sets elementwise .",
    "so for any @xmath108 we have @xmath109 .",
    "in particular , @xmath110 when @xmath111 .",
    "we now introduce a predicate @xmath112 on the markings of @xmath102 that holds for a marking iff it can be obtained from a reachable marking of @xmath5 ( which is also a marking of @xmath102 ) by firing some unobservable transitions .",
    "each of these unobservable transitions moves a token from a place @xmath4 into a buffering place @xmath104.later , we will show that @xmath112 exactly characterises the reachable markings of @xmath102 .",
    "furthermore , as every token can be moved only once , we can also give an upper bound on how many such movements can still take place .",
    "fsivalidmarking let @xmath61 be a plain net and @xmath113 .",
    "the predicate @xmath114 is given by @xmath115 the function @xmath116 is given by @xmath117 , where we choose not to distinguish between different degrees of infinity .",
    "note that @xmath118 implies @xmath119 , and reachable markings of @xmath5 are always finite ( thanks to our definition of a plain net ) .",
    "hence @xmath118 implies @xmath120 .",
    "the following lemma confirms that our informal description of @xmath121 matches its formal definition .",
    "fsivalidmarking let @xmath5 and @xmath102 be as above and @xmath122 , with @xmath20 finite",
    ". then @xmath123 iff @xmath124 .",
    "given that @xmath125 , `` if '' follows directly from the construction of @xmath102 .",
    "+ for `` only if '' , assume @xmath123",
    ". then @xmath126 .",
    "now we can describe how any net simulates the behaviour of its fully asynchronous implementation .",
    "fsiworking let @xmath5 and @xmath102 be as above , @xmath127 , @xmath96 and @xmath128 .",
    "[ fsiinvarstart ] @xmath129 .",
    "[ fsiimplstep ] if @xmath130 then @xmath131 .",
    "[ fsiimpltaustep ] if @xmath132 then @xmath133 .",
    "[ fsiimpllongstep ] if @xmath134 then @xmath135 .",
    "( [ fsiinvarstart ] ) : @xmath136 and @xmath137 .",
    "( [ fsiimplstep ] ) : suppose @xmath118 and @xmath138 with @xmath127 .",
    "so @xmath139 is a reachable marking of @xmath5 .",
    "let @xmath140 .",
    "since @xmath1 is enabled in @xmath20 , we have @xmath141 and hence @xmath142 . by construction",
    ", @xmath143 so @xmath144 .",
    "given that @xmath5 is contact - free , it follows that @xmath1 is enabled in @xmath139",
    ".    now let @xmath145 with @xmath146 .",
    "if @xmath147 then @xmath148 and @xmath149 , so @xmath150 .",
    "however , @xmath151 , contradicting @xmath118 . hence @xmath152 . given that @xmath153 and @xmath5 is contact - free , it follows that also @xmath154 and hence @xmath1 and @xmath155 are independent .",
    "we will now show that @xmath156 . @xmath157 therefore @xmath158 .",
    "take any @xmath140 and any @xmath159 .",
    "then @xmath160 and @xmath118 implies @xmath161 .",
    "hence @xmath162 .",
    "thus we find @xmath163 and conclude that @xmath164 .",
    "next we establish @xmath165 . to this end",
    ", we may assume that @xmath22 is a singleton set , for @xmath22 must be finite  this follows from our definition of a plain net  and when @xmath166 for some @xmath167 then there are @xmath168 with @xmath169 , allowing us to obtain the general case by induction .",
    "so let @xmath170 with @xmath171 .",
    "above we have shown that @xmath172 . we still need to prove that @xmath173 .",
    "assume the contrary , i.e.  there are @xmath174 with @xmath175 .",
    "since @xmath118 , at least one of @xmath176 and @xmath177say @xmath176must not be present in @xmath20 . then @xmath178 .",
    "as @xmath179 and @xmath180 , it must be that @xmath181 .",
    "hence @xmath182 , so @xmath183 , and @xmath184 .",
    "as shown above , @xmath1 is enabled in @xmath139 . by the contact - freeness of @xmath5 , @xmath185 , so @xmath186 .",
    "hence @xmath187 . as by construction @xmath188",
    ", we have @xmath189 , so @xmath190 . yet",
    "@xmath191 , contradicting @xmath118 .",
    "( [ fsiimpltaustep ] ) : let @xmath192 such that @xmath193 . then , by construction of @xmath102 , @xmath194 .",
    "hence @xmath195 and @xmath196 .",
    "moreover , @xmath197 .",
    "( [ fsiimpllongstep ] ) : using ( [ fsiinvarstart][fsiimpltaustep ] ) , this follows by a straightforward induction on the number of transitions in the derivation @xmath198 .",
    "it is not hard to see that implementations of contact - free nets are contact - free and implementations are always divergence free ; in fact an implementation of a plain net is always a divergence free @xmath7-net .",
    "it follows that @xmath121 exactly characterises the reachable markings of @xmath102 . using this",
    "it is not hard to check that implementations of contact - free nets are contact - free , and hence @xmath7-nets .",
    "fsionesafe let @xmath5 and @xmath102 be as before and @xmath108 .",
    "@xmath199 iff @xmath118 .",
    "[ fsi1 ]    @xmath102 is contact - free .",
    "[ fsiimplstep2 ]    @xmath102 is a @xmath7-net .",
    "[ fsi3 ]    ( [ fsi1 ] ) : `` only if '' follows from lemma  [ lem - fsiworking]([fsiimpllongstep ] ) , and `` if '' follows by lemmas  [ lem - fsisim ] and  [ lem - fsivalidmarking ] .",
    "( [ fsiimplstep2 ] ) : let @xmath200 .",
    "then @xmath118 , and hence @xmath201 .",
    "consider any @xmath202 with @xmath203 .",
    "assume @xmath204 . since @xmath205 let @xmath206 be such that @xmath207 and @xmath208 .",
    "as @xmath5 is contact - free we have @xmath209 , so since @xmath210 it must be that @xmath186 . hence @xmath211 and we have @xmath212 yet @xmath213 , violating @xmath118 .",
    "now consider any @xmath214 with @xmath215 . as @xmath216 and @xmath217",
    "we have that @xmath218 only if @xmath219 .",
    "however , @xmath220 which would violate @xmath118 .",
    "( [ fsi3 ] ) : by construction , @xmath19 is finite , @xmath221 , and @xmath222 and @xmath223 are finite for all @xmath224 .    by lemma  [ lem - fsiworking]([fsiimpltaustep ] )",
    "implementations are always divergence free :    fsidivfreelet @xmath5 be a plain net .",
    "then @xmath102 is divergence free .",
    "@xmath225    0.25 cm    whereas in a plain net @xmath5 for any sequence of observable transitions @xmath96 there is at most one marking @xmath20 with @xmath226 m$ ] , in its fully asynchronous implementation @xmath102 there can be several such markings .",
    "these markings @xmath21 differ from @xmath20 in that some tokens may have wandered off into the added    invisible transitions on the incoming arcs of visible ones .",
    "buffer places on the incoming arcs of visible transitions .    as a consequence ,",
    "a visible transition @xmath1 that is enabled in @xmath20 need not be enabled in @xmath21we say that in @xmath102 @xmath1 _ can be refused after @xmath72_. this may occur for instance for the net @xmath5 of figure  [ fig - fsi - fail ] , namely with @xmath227 ( the empty sequence ) , @xmath20 the initial marking of @xmath5 , @xmath21 the marking of @xmath102 obtained by firing the rightmost invisible transition , and @xmath228 .",
    "( 11,5.5 ) ( 1,3)@xmath229    (3,5):np1 ; ( 2,1):nt1:a ; ( 4,1):nt2:b ; np1->nt1 ; np1->nt2 ;    ( 6,3)@xmath230    (9,5):fsip1 ; ( 8,3):fsit1p1:@xmath7 ; ( 8,2):fsip1t1 ; ( 8,1):fsit1:a ;    ( 10,3):fsit2p1:@xmath7 ; ( 10,2):fsip1t2 ; ( 10,1):fsit2:b ;    fsip1->fsit1p1 ; fsit1p1->fsip1t1 ; fsip1t1->fsit1 ; fsip1->fsit2p1 ; fsit2p1->fsip1t2 ; fsip1t2->fsit2 ;    when this happens , we have @xmath231 , so the nets @xmath5 and @xmath102 are not failures equivalent .",
    "the direction from implementation to original is nicer however as every transition enabled in the implementation must also have been enabled in the original net .",
    "hence the only difference in behaviour between original and implementation can consist of additional failures in the implementation .",
    "fsiorigfailsub let @xmath5 and @xmath102 be as before",
    ". then @xmath232 .",
    "let @xmath233 .",
    "applying lemma  [ lem - determ ] , let @xmath234 be the unique marking of @xmath5 such that @xmath235 .",
    "by lemma  [ lem - fsisim ] also @xmath236 .",
    "so @xmath237 .",
    "as @xmath238 we have @xmath239 . by proposition  [ pr - fsidivfree ] there",
    "exists a marking @xmath30 with [ 0pt][0pt]@xmath240 .",
    "lemma  [ lem - fsiworking]([fsiimpltaustep ] ) yields @xmath241 .",
    "suppose @xmath242 .",
    "then [ 0pt][0pt]@xmath243 for some @xmath244 and marking @xmath245 of @xmath102 .",
    "lemma  [ lem - fsiworking]([fsiimplstep ] ) yields @xmath246 , which is a contradiction .",
    "if    , on the other hand ,    the wandering off of tokens into @xmath7-transitions never disables a transition that would be enabled otherwise , then there is no essential behavioural difference between @xmath5 and @xmath102 , and they are equivalent in any reasonable behavioural equivalence that abstracts from silent transition firings . in that case ,",
    "@xmath5 could be called _ fully asynchronous_.    fsa the class of _ fully asynchronous nets respecting branching time equivalence _ is defined as     +    @xmath247 .",
    "as for any plain net @xmath5 we have @xmath248    @xcite    , the class of nets @xmath249 can equivalently be defined as @xmath250 .",
    "it turns out that there exists a quite structural characterisation of those nets which are failures equivalent to their fully asynchronous implementation .",
    "reachableconflict a plain net @xmath61 _ has a partially reachable conflict _",
    "iff @xmath251    t \\ne u \\wedge \\precond{t } \\cap \\precond{u } \\ne \\varnothing$ ] and @xmath252 .",
    "reachableconflictlet @xmath61 be a plain net @xmath5 _ has a partially reachable conflict _",
    "iff @xmath251    t \\ne u \\wedge \\precond{t }",
    "\\cap \\precond{u } \\ne \\varnothing$ ] and @xmath253 .",
    "the nets @xmath5 of figures  [ fig - fsi - fail ] and  [ fig - si - deadlock ] , for instance , have a partially reachable conflict .",
    "rcfreeequalsfsa a plain net @xmath5 is in @xmath249 iff @xmath5 has no partially reachable conflict .",
    "see @xcite or @xcite .",
    "let @xmath61 and @xmath254 .",
    "`` @xmath6 '' : assume @xmath5 has a partially reachable conflict .",
    "then there exist @xmath255 , @xmath256 , @xmath62 and @xmath234 such that @xmath257 , @xmath258 and @xmath52 . by lemma  [ lem - determ ] we know that @xmath259 .    on the other hand , @xmath236 by lemma  [ lem - fsisim ] .",
    "let @xmath260 .",
    "then , by construction of @xmath102 , there exists an @xmath261 with @xmath262 , @xmath263 and since @xmath256 also @xmath264 .",
    "now let @xmath265 such that [ 0pt][0pt]@xmath266 ( which exists according to proposition  [ pr - fsidivfree ] ) .",
    "since @xmath267 we know that @xmath268 .",
    "thus @xmath269 and there exists a failure pair @xmath270 .",
    "hence @xmath271 , so @xmath272 .",
    "`` @xmath273 '' : assume @xmath272 .",
    "then @xmath274 and hence @xmath275 by proposition  [ pr - fsiorigfailsub ] .",
    "let @xmath276 .",
    "then there exists an @xmath277 such that @xmath278 . by lemma  [ lem - fsiworking]([fsiimpllongstep ] )",
    "we have @xmath279 .",
    "+ let @xmath280 such that @xmath281 ( which exists , otherwise @xmath282 ) .",
    "let @xmath283 such that @xmath284 ( such @xmath285 exists , otherwise [ 0pt][0pt]@xmath286 ) .",
    "since [ 0pt][0pt]@xmath281 it follows that @xmath287 . but",
    "@xmath288 , for otherwise @xmath289 , which would be a contradiction .",
    "hence there must exists some @xmath290 with @xmath291 and @xmath292 . by construction of @xmath102",
    "we have @xmath293 .",
    "thus @xmath294    \\precond{t } \\cap \\precond{u } \\ne \\varnothing    \\wedge \\tb(m_1 ) \\in [ m_0\\rangle_n \\wedge \\precond{t } \\subseteq \\tb(m_1)$ ] and @xmath5 has a partially reachable conflict .",
    "for investigating the next interaction pattern , we change our notion of asynchronous implementation of a net .",
    "we only insert silent transitions wherever a transition has multiple preplaces .",
    "these are the situations where the synchronous removal of tokens is really essential .",
    "si let @xmath61 be a net .",
    "let @xmath295 . the _ symmetrically asynchronous implementation _ of @xmath5",
    "is defined as the net + @xmath296 with @xmath297    an example is shown in figure  [ fig - si - deadlock ] .",
    "( 13,4.5 ) ( 1,2.5)@xmath5 :    (2,4):p1 ; ( 4,4):p2 ; ( 2,1):t1:a ; ( 4,1):t2:b ; p1->t1 ; p1->t2 ; p2->t2 ; p2->n1 ;    ( 6,2.5)@xmath298 :    (8,4):p1b ; ( 11,4):p2b ; ( 11,3):p2btt:@xmath7 ; ( 11,2):p2btp ; ( 10,3):p1bt2t:@xmath7 ; ( 10,2):p1bt2p ; ( 8,1):t1b : a ; ( 11,1):t2b : b ; p1b->t1b ; p2b->p2btt ; p2btt->p2btp ; p2btp->t2b ; p1b->p1bt2 t ; p1bt2t->p1bt2p ; p1bt2p->t2b ; p2b->n1b ;    similar to section [ sec - fsa ] , we use @xmath299 and @xmath300 when describing the flow relation of the implementation .    as definition  [ df - si ] is only a slight variation of definition  [ df - fsi ] , the lemmas and propositions about @xmath301 in section [ sec - fsa ] apply to @xmath302 as well , with minimal changes in the proofs",
    ". we will again begin with how the implementation can simulate the original net .",
    "sisim let @xmath61 be a plain net , @xmath95 , @xmath96 and @xmath24 .    if @xmath97 then @xmath303 .    if @xmath99 then @xmath304 .",
    "let @xmath295 .",
    "assume @xmath101 .",
    "then , by construction of @xmath298 , @xmath305 the rest of the proof is identical to the proof of lemma  [ lem - fsisim ] .",
    "also similar to the fully asynchronous case , we wish to undo the effect of firing extraneous @xmath7-transitions .",
    "the function doing so is the same @xmath306 defined earlier .",
    "we also reuse the predicate @xmath121 and the distance function @xmath307 .",
    "however , @xmath308 is no longer a _ strict _ upper bound , or exact measure , on the number of silent transitions that need to be fired from the marking @xmath20 before no further silent transitions are possible .",
    "optionally , strictness can be ensured by replacing it by the function @xmath309 , defined by @xmath310    again @xmath118 implies @xmath311 .",
    "sivalidmarking let @xmath5 and @xmath298 be as above and @xmath122 , with @xmath20 finite . then @xmath123 iff @xmath312 .",
    "this is lemma  [ lem - fsivalidmarking ] applied to @xmath298 rather than @xmath102 .",
    "the proof is identical .",
    "siworking let @xmath5 and @xmath298 be as above , @xmath127 , @xmath96 and @xmath128 .",
    "[ siinvarstart ] @xmath129 .",
    "[ siimplstep ] if @xmath313 then @xmath131 .",
    "[ siimpltaustep ] if @xmath314 then @xmath133 .",
    "[ siimpllongstep ] if @xmath315 then @xmath316 .",
    "this is lemma  [ lem - fsiworking ] applied to @xmath298 rather than @xmath102 ; the proofs of ( [ fsiinvarstart ] ) , ( [ siimpltaustep ] ) and ( [ siimpllongstep ] ) are identical .",
    "( [ siimplstep ] ) : suppose @xmath118 and @xmath317 with @xmath127 .",
    "so @xmath139 is a reachable marking of @xmath5 .    for any @xmath77 and @xmath159 we set @xmath318 if @xmath319 and @xmath320 otherwise .",
    "let @xmath140 .",
    "since @xmath1 is enabled in @xmath20 , we have @xmath141 and hence @xmath142 . by construction",
    ", @xmath321 so @xmath144 .",
    "given that @xmath5 is contact - free , it follows that @xmath1 is enabled in @xmath139 .",
    "now let @xmath145 with @xmath146 . if @xmath147 then @xmath322 and @xmath323 , so @xmath324 .",
    "as @xmath1 and @xmath155 are independent in @xmath298 , we have @xmath325 .",
    "however , @xmath326 , contradicting @xmath118 . hence @xmath152 . given that @xmath153 and @xmath5 is contact - free , it follows that also @xmath154 and hence @xmath1 and @xmath155 are independent .",
    "we will now show that @xmath156 .",
    "@xmath327 therefore @xmath328 .    take any @xmath329 and any @xmath330 .",
    "then @xmath331 , @xmath332 and @xmath118 implies @xmath333 .",
    "hence @xmath334 .",
    "thus we find @xmath163 and conclude that @xmath164 .    that @xmath165 holds is established in exactly the same way as in the proof of lemma  [ lem - fsiworking]([fsiimplstep ] ) , noting that in deriving @xmath187 we use @xmath335 and @xmath336 .",
    "sionesafe let @xmath5 and @xmath298 be as before and @xmath108 .",
    "@xmath337 iff @xmath118 .",
    "[ si1 ]    @xmath298 is contact - free .",
    "[ siimplstep2 ]    @xmath298 is a @xmath7-net .",
    "[ si3 ]    identical to the proof of proposition  [ pr - fsionesafe ] , using the lemmas of section [ sec - sa ] .",
    "sidivfreelet @xmath5 be a plain net .",
    "then @xmath298 is divergence free .",
    "this follows immediately from lemma  [ lem - siworking]([fsiimpltaustep ] ) .    as for the fully asynchronous case ,",
    "an implementation of a plain net is always a divergence - free @xmath7-net .",
    "siorigfailsub let @xmath5 and @xmath298 be as before .",
    "then @xmath338 .",
    "identical to that of proposition  [ pr - fsiorigfailsub ] , using the lemmas of section [ sec - sa ] .",
    "again , the only difference in behaviour between the original net and its implementation is that observable transitions can potentially be refused in the implementation , as in figure  [ fig - si - deadlock ] .",
    "this yields a concept of a _ symmetrically asynchronous _",
    "sa the class of _ symmetrically asynchronous nets respecting branching time equivalence _ is defined as @xmath339 .",
    "again we have @xmath338 for any plain net @xmath5 @xcite .",
    "we now show that plain nets can be implemented symmetrically asynchronously with respect to failure equivalence exactly when they do not contain reachable structures of the form shown in figure  [ fig - si - deadlock ] .",
    "reachablen a plain net @xmath61 _ has a partially reachable _",
    "@xmath340    \\wedge \\precond{t } \\cap \\precond{u } \\ne    \\varnothing\\linebreak[1 ] \\wedge |\\precond{u}| > 1 \\wedge    \\exists m \\in [ m_0\\rangle_n . \\precond{t } \\subseteq m \\vee \\precond{u } \\subseteq m$ ] .",
    "rnfreeequalssaa plain net @xmath5 is in @xmath341 iff @xmath5 has no partially reachable .",
    "see @xcite or @xcite .",
    "let @xmath61 and @xmath342 .",
    "`` @xmath6 '' : assume @xmath5 has a partially reachable . then there exist @xmath255 , @xmath256 , @xmath62 and @xmath234 such that @xmath257 , @xmath258 , @xmath343 and @xmath344 .",
    "we will show that @xmath345 .",
    "there are two cases :    case 1 , @xmath346 : we will show that @xmath347 but @xmath348 .",
    "as @xmath5 has no silent transitions , by lemma  [ lem - determ ] we have @xmath349 only if @xmath350 . since @xmath351 it follows that @xmath352 .    on the other hand , @xmath353 by lemma  [ lem - sisim ]",
    "let @xmath260 .",
    "then , by construction of @xmath298 , there exists an @xmath261 with @xmath262 , @xmath263 and since @xmath256 also @xmath354 .",
    "now let @xmath265 such that [ 0pt][0pt]@xmath355 ( which exists according to proposition  [ pr - sidivfree ] ) .",
    "since @xmath356 we have @xmath357 .",
    "thus @xmath269 and @xmath358 .",
    "case 2 , @xmath359 : then @xmath360 .",
    "thus @xmath361 , so @xmath362 .",
    "this case proceeds as case 1 with the roles of @xmath1 and @xmath155 exchanged .",
    "`` @xmath273 '' : assume @xmath363 .",
    "then @xmath364 and hence @xmath365 by proposition  [ pr - siorigfailsub ] .",
    "let @xmath366 .",
    "then there exists an @xmath277 such that @xmath367 , @xmath368 and @xmath369 . by lemma  [ lem - siworking]([siimpllongstep ] ) we have @xmath279 .",
    "+ let @xmath280 such that @xmath281 ( which exists , otherwise @xmath282 ) .",
    "let @xmath283 such that @xmath370 ( such a @xmath176 exists , otherwise [ 0pt][0pt]@xmath371 ) .",
    "since [ 0pt][0pt]@xmath281 it follows that @xmath287 . but",
    "@xmath288 , for otherwise @xmath372 and @xmath373 , which would be a contradiction .",
    "hence there must exists some @xmath290 with @xmath291 and @xmath292 . by construction of @xmath298",
    "we have @xmath293 and @xmath343 . thus @xmath294    \\precond{t } \\cap \\precond{u } \\ne \\varnothing \\wedge |\\precond{u}| > 1    \\wedge \\tb(m_1 ) \\in [ m_0\\rangle_n \\wedge \\precond{t } \\subseteq \\tb(m_1)$ ] , so @xmath5 has a partially reachable .",
    "the following proposition shows that the current class of nets strictly extends the one from the previous section .",
    "fsabltsab@xmath374 .    a net without partially reachable conflict surely has no partially reachable .",
    "the inequality follows from the example in figure  [ fig - fsi - fail ] .",
    "it turns out that our class of nets @xmath341 is strongly related to the following established net classes @xcite .",
    "fcetc let @xmath61 be a plain net .    1 .",
    "@xmath5 is _ free choice _",
    ", @xmath375 , iff @xmath376 .",
    "2 .   @xmath5 is _ extended free choice _ , @xmath377 , iff @xmath378 .",
    "@xmath5 is _ behaviourally free choice _",
    ", @xmath379 , iff @xmath380 .",
    "the above definition of a free choice net is in terms of places , but the notion can equivalently be defined in terms of transitions : @xmath381 both conditions are equivalent to the requirement that @xmath5 must be @xmath10-free , where @xmath10 is defined as in definition  [ df - reachablen ] but without the reachability clause . also",
    "the notion of an extended free choice net can equivalently be defined in terms of transitions : @xmath382 this condition says that @xmath5 may not contain what we call a _ pure _ @xmath10 : places @xmath383 and transitions @xmath384 such that @xmath385 , @xmath386 and @xmath387 .",
    "in @xcite it has been established that @xmath388 .",
    "in fact , the inclusions follow directly from the definitions , and figure  [ fig - counterexamplefcsal_efc ] displays counterexamples to strictness .    the class of free choice nets is strictly smaller than the class of symmetrically asynchronous nets respecting branching time equivalence , which in turn is strictly smaller than the class of behavioural free choice nets .",
    "the class of extended free choice nets and the class of symmetrically asynchronous nets respecting branching time equivalence are incomparable .",
    "fcltsab @xmath389 , @xmath390 and @xmath391 .",
    "the first inclusion follows because a partially reachable @xmath10 is surely an @xmath10 , and also the second inclusion follows directly from the definitions .",
    "the four inequalities follow from the examples in figure  [ fig - counterexampleefc_sab ] .",
    "the first net is unmarked and thus trivially in @xmath341 .",
    "the second ones symmetrically asynchronous implementation has the additional failure @xmath392 and hence this net is not in @xmath341 .    in figure  [ fig - symmetricasynorder ] the relations between our semantically defined net class @xmath341 , the structurally defined classes @xmath393 , @xmath394 , and the more behaviourally defined class @xmath395 are summarised .",
    "these relations may be interpreted as follows .",
    "starting at the top of the diagram , free choice nets are characterised structurally , enforcing that for every place , a token therein can choose freely ( i.e.  without inquiring about the existence of tokens in any other places ) which outgoing arc to take .",
    "this property makes it possible to implement the system asynchronously .",
    "in particular , the component which holds the information represented by a token can choose arbitrarily when and into which of multiple asynchronous output channels to forward said information , without further knowledge about the rest of the system .",
    "as this decision is solely in the discretion of the sending component and not based upon any knowledge of the rest of the system , no synchronisation with other components is necessary .",
    "( 6,5.2 ) ( 3,5 ) ( 1,3 ) ( 5,3 ) ( 3,1 )    the difference between @xmath341 and @xmath393 is that in @xmath341 the quantification over the places is dropped , making the requirement more straightforward : every token can choose freely which outgoing arc to follow . thus , @xmath341 allows for non - free - choice structures as long as these never receive any tokens .",
    "this also explains why @xmath395 includes @xmath341 .",
    "since @xmath341 guarantees that all transitions of a problematic structure are never enabled , transitions in such structures are never enabled while others are disabled .",
    "the incomparability between the left and the right side of the diagram stems from the conceptual allowance of slight transformations of the net before evaluating whether it is free choice or not .",
    "extended free choice nets and behavioural free choice nets were proposed as nets that are easily seen to be behaviourally equivalent to free choice nets , and hence share some of their desirable properties : in @xcite constructions can be found to turn any extended free choice net into an equivalent free choice net , and any behavioural free choice net into an extended free choice net . applied on the last two nets in figure  [ fig - counterexamplesal_bfc ] these constructions yield :    ( 4,3.4 ) (0,3):p1 ; ( 2,3):t3:@xmath7 ; (4,3):p2 ; ( 0,1):t1:a ; ( 2,1):p3 ; ( 4,1):t2:b ;    p1->t3 ; p2->t3 ; t3->p3 ; p3->t1 ; p3->t2 ;    ( 6,4 ) ( 2,3):p1:p ; ( 4,3):p2:q ; ( 1,1):t1:a ; ( 3,1):t2:b ; ( 5,1):t3:c ;    p1->t2 ; p2->t2 ; p1->t1 ; t1->p1 ; p2->t1 ; t1->p2 ; p1->t3 ; t3->p1 ; p2->t3 ; t3->p2 ;    for the second net of figure  [ fig - counterexamplesal_bfc ] , a @xmath7-transition is introduced , which collects both tokens and then marks a single postplace from which the two original transitions are enabled .",
    "hence the choice between the two transitions is centralised in the newly introduced place and thus free again . in the definition of our symmetrically asynchronous implementation @xmath302",
    ", we do not allow any insertion of such `` helping '' @xmath7-transitions , as it seems unclear to us how much computing power should be allowed in possibly larger networks of such transitions .",
    "this becomes especially problematic if these networks somehow track part of the global status of the net inside themselves and thus make quite informed decisions about what outgoing transition to enable .",
    "as seen in the previous section , the class of symmetrically asynchronous nets is quite small .",
    "it precludes the implementation of many real - world behaviours , like waiting for one of multiple inputs to become readable , a petri net representation of which will always include non free - choice structures .",
    "therefore we propose a less strict definition of asynchrony such that actions may depend synchronously on a single predetermined condition . in a hardware implementation the places which earlier could always forward a token into some silent transitions must now wait until they receive an explicit token removal signal from their posttransitions .    to this end",
    "we introduce a static priority over the preplaces of each transition .",
    "every transition first removes the token from the most prioritised preplace and then continues along decreasing priority . to formalise this behaviour in a petri net",
    "we insert a silent transition for each incoming arc of every transition .",
    "these silent transitions are forced to execute in sequence by newly introduced buffer places between them . in the final position of this chain ,",
    "the original visible transition is executed .",
    "an example of this transformation is given in figure  [ fig - asym - transform ] .",
    "( 14,7.5 ) ( 1,7):p1:p ; ( 3,7):p2:q ; ( 5,7):p3:s ; ( 3,1):p4 ; ( 1,4):t1:a ; ( 3,4):t2:b ; p1->t1 ; p1->t2 ; p2->t2 ; p3->t2 ; t2->p4 ;    ( 6.25,5)@xmath6    ( 8,7):p1c : p ; ( 11,7):p2c : q ; ( 14,7):p3c : s ; ( 11,6):p2ctt:@xmath7 ; ( 11,5):p2ctp ; ( 8,4):t1c : a ; ( 11,4):t2c:@xmath7 ; ( 11,3):p3ctp ; ( 11,2):t3ctt : b ; ( 11,1):p4b ; p1c->t1c ; p2c->p2ctt ; p2ctt->p2ctp ; p2ctp->t2c ; p1c->t3ctt ; t2c->p3ctp ; p3ctp->t3ctt ; t3ctt->p4b ; p3c->t2c ;    ai let @xmath61 be a plain net .",
    "let @xmath396 be a relation on @xmath397 such that for each @xmath202    we have that    @xmath398 is a total order on @xmath399 .",
    "let @xmath400 be the total order on @xmath57 given by @xmath401 iff @xmath402 .",
    "we write @xmath403 for the @xmath400-minimal element of @xmath57 and @xmath404 for the next place in @xmath57 that is @xmath400-smaller than @xmath4 .",
    "we define a set of silent transitions as @xmath405 .",
    "let @xmath406 be the function @xmath407 the _ asymmetrically asynchronous implementation with respect to @xmath408 _ of @xmath5 is defined as the net @xmath409 with @xmath410    as before , we are interested in the relationship between nets and their possible implementations .",
    "the definition of asymmetric asynchrony however allows different implementations for the same net .",
    "we show that the lemmas and propositions from the previous sections carry over for all possible implementations . as in the earlier sections , we start by showing how the implementation simulates the original .",
    "aisim let @xmath61 be a plain net , @xmath95 , @xmath96 , @xmath24 and @xmath408 as above .",
    "if @xmath97 then @xmath411 .    if @xmath99 then @xmath412 .",
    "let @xmath413 .",
    "assume @xmath101 .",
    "then , due to the restrictions on @xmath408 , there exists a sequence of pairwise disjoint nonempty sets @xmath414 such that @xmath415 and @xmath416 . by the construction of @xmath417",
    "then @xmath418 all non - final steps of that execution can be split into a sequence of singletons .",
    "+ the second statement follows by a straightforward induction on the length of @xmath72 .",
    "as for the symmetrical case , we wish to push back all tokens on @xmath419 in a marking to their roots in @xmath13 .",
    "this time , however , multiple silent transitions need to be undone .",
    "taucompl let @xmath61 be a plain net and let @xmath413 .",
    "@xmath420 is the function defined by @xmath421    given a reachable marking @xmath20 of the implementation , @xmath422 will produce a reachable marking of the original net , which by lemma  [ lem - aisim ] is also a reachable marking of the implementation , from which @xmath20 could have arisen by firing some of the added unobservable transitions .",
    "note that @xmath423  for any @xmath66 .",
    "the application of @xmath422 is only meaningful for markings where no two elements of @xmath419 have originated from the same transition .",
    "however , implementations of contact - free nets produce only reachable markings which fulfil this condition , as we will show below .",
    "we now give the invariant predicate @xmath424 that characterises the markings of an implementation that can be obtained from a reachable marking of the original net by firing some unobservable transitions .",
    "aivalidmarking let @xmath61 be a plain net and @xmath425 .",
    "the predicate @xmath426 is given by @xmath427    note that @xmath428 implies @xmath429 .",
    "aivalidmarking let @xmath5 and @xmath417 be as above and @xmath122 , with @xmath20 finite",
    ". then @xmath430 iff @xmath431 .",
    "given that @xmath432 , `` if '' follows directly from the construction of @xmath417 .",
    "+ for `` only if '' , assume @xmath433 .",
    "let @xmath434 and @xmath435 for @xmath436 .",
    "the assumption guarantees that all @xmath437 are disjoint .",
    "since @xmath20 is finite , and @xmath57 is finite for all @xmath66 , there must be an @xmath167 such that @xmath438 iff @xmath439 .",
    "now @xmath440 .",
    "aiworking let @xmath5 and @xmath417 be as above , @xmath127 , @xmath441 and @xmath128 .",
    "[ aiinvarstart ] @xmath442 .",
    "[ aiimplstep ] if @xmath443 then @xmath444 .",
    "[ aiimpltaustep ] if @xmath445 then @xmath446 .",
    "[ aiimpllongstep ] if @xmath447 then @xmath448 .",
    "( [ aiinvarstart ] ) : @xmath136 and @xmath449 .",
    "( [ aiimplstep ] ) : suppose @xmath428 and @xmath450 with @xmath451 .",
    "so @xmath452 is a reachable marking of @xmath5 .",
    "let @xmath140 . since @xmath1 is enabled in @xmath20 , we have @xmath453 and hence @xmath454 . by construction , @xmath423 .",
    "given that @xmath5 is contact - free it follows that @xmath1 is enabled in @xmath452 .",
    "now let @xmath455 with @xmath256 . if @xmath456 then @xmath457 but since @xmath455 , @xmath458 and @xmath459 , contradicting @xmath428 .",
    "hence @xmath460 .",
    "given that @xmath461 and @xmath5 is contact - free , it follows that also @xmath462 and hence @xmath1 and @xmath155 are independent .",
    "we will now show that @xmath463 .",
    "by definition  [ df - taucompl ] we have @xmath464 for any @xmath122 .",
    "moreover , when @xmath20 satisfies @xmath428 this union is disjoint . in that case , for any set @xmath465 we have @xmath466 .",
    "@xmath467 therefore @xmath468    next we establish @xmath469 . as in the proof of lemma  [ lem - fsiworking]([fsiimplstep ] ) we may assume that @xmath22 is a singleton set @xmath470 .",
    "above we have shown that @xmath471 . we still need to prove that @xmath472 for all @xmath174 .",
    "assume the contrary , i.e. there are @xmath473 with @xmath474 but @xmath475 . since @xmath428 , at least one of @xmath176 and @xmath177say @xmath176must not be present in @xmath20 . then @xmath476 .",
    "as @xmath477 , @xmath478 and @xmath479 it must be that @xmath480 .",
    "hence @xmath481 , so @xmath482 , and @xmath483 .",
    "as shown above , @xmath1 is enabled in @xmath452 . by the contact - freeness of @xmath5 , @xmath484 , so @xmath186 . since @xmath485 , there exists a place @xmath486 with @xmath487 . by construction , @xmath488",
    ", so we have @xmath489 , hence @xmath490 .",
    "however , @xmath491 , contradicting @xmath428 .    (",
    "[ aiimpltaustep ] ) : let @xmath192 such that @xmath492 . then @xmath493 and @xmath494 . as @xmath495 , no element of @xmath496 contributes to @xmath497 and hence @xmath498 .    if @xmath499 then @xmath500 . otherwise let @xmath206 such that @xmath501",
    ". then @xmath502 .",
    "moreover , @xmath503 .",
    "( [ aiimpllongstep ] ) : as in lemma  [ lem - fsiworking ] .",
    "aionesafe let @xmath5 and @xmath417 be as before and @xmath108 .",
    "@xmath504 iff @xmath428 .",
    "[ ai1 ]    @xmath417 is contact - free .",
    "[ aiimplstep2 ]    @xmath417 is a @xmath7-net .",
    "[ ai3 ]    ( [ ai1 ] ) : identical to the proof of proposition  [ pr - fsionesafe]([fsi1 ] ) , using the lemmas of section [ sec - aa ] .",
    "( [ aiimplstep2 ] ) : let @xmath505 .",
    "then @xmath428 , and hence @xmath506 .",
    "consider any @xmath202 with @xmath203 .",
    "assume @xmath204 . since @xmath205 let @xmath206 be such that @xmath207 and @xmath208 .",
    "as @xmath5 is contact - free we have @xmath507 , so since @xmath508 it must be that @xmath186 .",
    "hence , using that @xmath208 there must be an @xmath509 with @xmath510 , and hence @xmath511 .",
    "we have @xmath512 yet @xmath513 , violating @xmath428 .",
    "now consider any @xmath214 with @xmath215 .",
    "as @xmath514 and @xmath217 we have that @xmath218 only if @xmath219 .",
    "however , @xmath515 which would violate @xmath428 .",
    "( [ ai3 ] ) : identical to the proof of proposition  [ pr - fsionesafe]([fsi3 ] ) .",
    "aidivfreelet @xmath5 be a plain net and @xmath408 as before .",
    "then @xmath417 is divergence free .",
    "this follows immediately from lemma  [ lem - aiworking]([aiimpltaustep ] ) .",
    "aiorigfailsublet @xmath5 and @xmath417 as before",
    ". then @xmath516 .",
    "identical to that of proposition  [ pr - fsiorigfailsub ] , using the lemmas of section [ sec - aa ] .",
    "we define a net to be _ asymmetrically asynchronous _ if any of the possible implementations simulates the net sufficiently .",
    "aa the class of _ asymmetrically asynchronous nets respecting branching time equivalence _ is defined as @xmath517 .    as before ,    we have @xmath516 for any plain net @xmath5 and any priority relation @xmath408 @xcite .",
    "additionally    we would like to obtain a semi - structural characterisation of @xmath518 in the spirit of theorems  [ thm - rcfreeequalsfsa ] and  [ thm - rnfreeequalssa ] .",
    "unfortunately we did nt succeed in this , but we obtained structural upper and lower bounds for this net class .",
    "reachablem a net @xmath61 _ has a left and right reachable _",
    "iff @xmath519\\ ; \\exists q { \\mathbin\\in}\\precond{u } \\cap \\precond{v}.\\ , t \\ne u \\wedge u \\ne v \\wedge p \\ne q \\wedge    \\exists m_1 , m_2 { \\mathbin\\in}[m_0\\rangle .",
    "\\precond{t } \\cup \\precond{u } \\subseteq m_1 \\wedge    \\precond{v } \\cup \\precond{u } \\subseteq m_2 $ ] .",
    "a net @xmath61 _ has a left and right border reachable _",
    "iff @xmath520 \\;\\exists p { \\mathbin\\in}\\precond{t } \\cap \\precond{u }    \\linebreak[2]\\ ; \\exists q { \\mathbin\\in}\\precond{u } \\cap \\precond{v}.\\ , t \\ne",
    "u \\wedge u \\ne v \\wedge p \\ne q \\wedge    \\exists m_1 , m_2 { \\mathbin\\in}[m_0\\rangle .",
    "\\precond{t } \\subseteq m_1 \\wedge    \\precond{v } \\subseteq m_2 $ ] .",
    "aahbimplieslrmfree a plain net @xmath5 in @xmath518 has no left and right reachable .",
    "+ a plain net @xmath5 which has no left and right border reachable is in @xmath518 .     see @xcite or @xcite .",
    "aahbimplieslrmfree a plain net @xmath5 in @xmath518 has no left and right reachable .",
    "let @xmath61 .",
    "assume @xmath5 has a left and right reachable .",
    "then there exist @xmath521 and @xmath522 such that @xmath523 , @xmath524 , @xmath256 , @xmath525 , @xmath526 and there are reachable markings @xmath527 such that @xmath528 and @xmath529 .",
    "we will show that @xmath530 , regardless of the choice of @xmath408 .    the problematic transition will be @xmath155 . either @xmath531 or @xmath532 . due to symmetry",
    "we can assume the former without loss of generality .",
    "so @xmath533 . we know that there is some @xmath62 such that [ 0pt][0pt]@xmath534 . by lemma  [ lem - determ ]",
    "it follows that @xmath535 .    by lemma  [ lem - aisim ]",
    "also @xmath536 .",
    "let @xmath537 such that @xmath538 with @xmath539 and @xmath540 for @xmath541 .",
    "since @xmath542 there thus exists an @xmath543 with @xmath544 .",
    "note that @xmath545 . by propositions [ pr - aidivfree ]",
    "there exists an @xmath546 with @xmath547 , and proposition  [ pr - aionesafe]([ai1 ] ) yields @xmath548 .    from the construction of @xmath417 , using that @xmath545 , it follows that @xmath549 .",
    "moreover , @xmath550 .",
    "we also have @xmath551 , so @xmath552 . as @xmath553",
    ", we have @xmath554 , and thus @xmath555 . therefore @xmath556 .",
    "hence @xmath5 is not in @xmath518 .",
    "weaklrmfreeimplesaahb a plain net @xmath5 which has no left and right border reachable is in @xmath518 .",
    "let @xmath61 . given a transition @xmath557 , we say that a _ @xmath155-conflict occurs _ in a preplace @xmath558 when @xmath559 .",
    "assume @xmath5 has no left and right border reachable .",
    "this means that every @xmath290 has at most one preplace where an @xmath155-conflict occurs .",
    "now choose @xmath396 such that for all @xmath560 , @xmath561 is that single place , if it exists .",
    "let @xmath413 .",
    "we prove that @xmath562 . from proposition  [ pr - aiorigfailsub ]",
    "we already have that @xmath516 .",
    "therefore consider a failure pair @xmath563 .",
    "we need to show that @xmath282 .",
    "there exists some @xmath564 with [ 0pt][0pt]@xmath565 . by lemma  [ lem - aiworking ] @xmath566 .",
    "now take any @xmath280 .",
    "assume [ 0pt][0pt]@xmath567 . then @xmath568 but @xmath569 . by construction of @xmath422",
    "we have @xmath570 . +",
    "now suppose we had @xmath571 .",
    "then @xmath572 , using [ 0pt][0pt]@xmath368 . @xmath573",
    "hence @xmath574 .",
    "but then @xmath575 , so a @xmath155-conflict occurs in @xmath558 .",
    "yet @xmath576 implies that @xmath577 and hence @xmath533 , by the construction of @xmath417 .",
    "this however contradicts our construction for @xmath408 given above .",
    "hence [ 0pt][0pt]@xmath578 . applying this argument for all @xmath579 yields @xmath580 and thereby @xmath581 .",
    "thus @xmath582 .    figure  [ fig - counterexampleaahb_nolrm ] shows two nets , each with a left and right border reachable but no left and right reachable , that thus fall in the grey area between our structural upper and lower bounds for the class @xmath518 . in this case",
    "the first net falls outside @xmath518 , whereas the second net falls inside .",
    "the crucial difference between these two examples is the information available to @xmath155 about the execution of @xmath583 .",
    "there exists an implementation for the right net , namely by @xmath155 taking the tokens from @xmath584 , @xmath177 and @xmath4 in that order .",
    "the first token ( from @xmath584 ) conveys the information that @xmath583 was executed , and thus @xmath1 is not enabled . collecting the last token ( from @xmath4 )",
    "could fail , due to @xmath585 removing it earlier .",
    "even so , removing the tokens from @xmath584 and @xmath177 did not disable any transition that could fire in the original net . in the left net",
    "such an implementation will not work .",
    "the following proposition says that our class of symmetrically asynchronous nets strictly extends the corresponding class of asymmetrically asynchronous nets .",
    "sabltaab @xmath586 .",
    "a net which has no partially reachable also has no left or right border reachable .",
    "the inequality follows from the example in figure  [ fig - si - deadlock ] .    as before ,",
    "our class @xmath518 is related to some known net classes @xcite .",
    "simpleetc let @xmath61 be a plain net .    1 .   @xmath5 is _ simple _ , @xmath587 , iff @xmath588 .",
    "@xmath5 is _ extended simple _ , @xmath589 , iff @xmath590 .",
    "extended simple nets appear in @xcite under the name _",
    "asymmetric choice systems_. note that simple is equivalent to @xmath11-free , where @xmath11 is as in definition  [ df - reachablem ] but without the reachability clauses .",
    "clearly , we have @xmath591 and @xmath592 , whereas @xmath593 and @xmath594 : the inclusions follow immediately from the definitions , and the first two nets of figure  [ fig - counterexamplesal_bfc ] provide counterexamples to the inequalities .",
    "the class of asymmetrically asynchronous nets respecting branching time equivalence strictly extends the class of simple nets , whereas it is incomparable with the class of extended simple nets .",
    "( 6,3 ) ( 2,2.5):p1 ; ( 4,2.5):p2 ; ( 1,1):t1:a ; ( 3,1):t2:b ; ( 5,1):t3:c ; p1->t1 ; p1->t2 ; p2->t2 ; p2->t3 ;    ( 6,3 ) ( 2,2.5):p1 ; ( 4,2.5):p2 ; ( 1,1):t1:a ; ( 3,1):t2:b ; ( 5,1):t3:c ; p1->t1 ; p1->t2 ; p2->t2 ; p2->t3 ;    aahbincompespl@xmath595 , @xmath596 and @xmath597 .",
    "the inclusion is straightforward , and the inequalities follow from the counterexamples in figure  [ fig - counterexamplefcsal_efc ] ( the second one ) and figure  [ fig - counterexampleespl_aahb ] .",
    "the missing tokens in the latter example are intended .",
    "as no action is possible there will not be any additional implementation failures .",
    "the relations between the classes @xmath598 , @xmath599 and @xmath518 are summarised in figure  [ fig - asymmetricasynorder ] . similarly to what we did in section [ sec - sa ] , we now try to translate figure  [ fig - asymmetricasynorder ] into an intuitive description .",
    "( 5,3.2 ) ( 2.5,3 ) ( 1,1 ) ( 4,1 )    ( 5,3.2 ) ( 2.5,3 ) ( 1,1 ) ( 4,1 )    the basic intuition behind @xmath598 is that for every transition there is only one preplace where conflict can possibly occur .",
    "whereas in @xmath598 that possibility is determined by the static net structure , in @xmath518 reachability is also considered .",
    "similar to the difference between @xmath600 and @xmath601 there exists a difference between @xmath599 and @xmath598 which originates from the fact that @xmath599 allows small transformations to a net before testing whether it lies in @xmath598 .",
    "again our class @xmath518 does not allow such `` helping '' transformations .",
    "we have investigated the effect of different types of asynchronous interaction , using petri nets as our system model .",
    "we propose three different interaction patterns : fully asynchronous , symmetrically asynchronous and asymmetrically asynchronous .",
    "an asynchronous implementation of a net is then obtained by inserting silent ( unobservable ) transitions according to the respective pattern .",
    "the pattern for asymmetric asynchrony is parametric in the sense that the actual asynchronous implementation of a net depends on a chosen priority function on the input places of a transition . for each of these cases",
    ", we investigated for which types of nets the asynchronous implementation of a net changes its behaviour with respect to failures equivalence ( in the case of asymmetric asynchrony , the ` best ' priority function may be used ) .",
    "it turns out that we obtain a hierarchy of petri net classes , where each class contains those nets which do not change their behaviour when transformed into the asynchronous version according to one of the interaction patterns .",
    "this is not surprising because later constructions allow a more fine - grained control over the interactions than earlier ones .",
    "we did not consider connections from transitions to their postplaces as relevant to determine asynchrony and distributability .",
    "this is because we only discussed contact - free nets , where no synchronisation by postplaces is necessary . in the spirit of definition  [ df - fsi ]",
    "we could insert @xmath7-transitions on any or all arcs from transitions to their postplaces , and the resulting net would always be equivalent to the original .",
    "although we compare the behaviour of a net and its asynchronous implementations in terms of failures equivalence , we believe that the very same classes of nets are obtained when using any other reasonable behavioural equivalence that respects branching time to some degree and abstracts from silent transitions  no matter if this is an interleaving equivalence , or one that respects causality .",
    "we would get larger classes of nets , for example for the case of full asynchrony including the net of figure  [ fig - fsi - fail ] , if we merely required a net @xmath5 and its implementation to be equivalent under a suitably chosen linear time equivalence .",
    "this option is investigated in @xcite .",
    "the central results of the paper give semi - structural characterisations of our semantically defined classes of nets .",
    "moreover , we relate these classes to well - known and well - understood structurally defined classes of nets , like free choice nets , extended free choice nets and simple nets .",
    "_ message sequence charts _ ( mscs ) , also contained in uml 2.0 under the name sequence diagrams , are a model for specifying interactions between components ( _ instances _ ) of a system .",
    "a simple kind are _ basic message sequence charts _ ( bmscs ) as defined in @xcite , where choices are not allowed .",
    "a petri net semantics of bmcss with asynchronous communication and a unique sending and receiving event for each message will yield petri nets with unbranched places ( see for instance @xcite ) .",
    "hence in this case the resulting petri nets are conflict - free and therefore fully asynchronously implementable according to theorem  [ thm - rcfreeequalsfsa ] .",
    "however in extended versions of mscs , e.g.  in uml 2.0 or in live sequence charts ( lscs , see @xcite ) , inline expressions allow to describe choices between possible behaviours in mscs .",
    "consider for example the msc given in figure  [ fig - msc - example ] and a naive petri net representation .",
    "the instances i1 and i2 can either communicate or execute their local actions .",
    "obviously , this requires some mechanism in order to make sure that the choice is performed in a coherent way ( see e.g.  @xcite for a discussion of this type of problem ) . in the petri net representation ,",
    "we find a reachable , hence with theorem  [ thm - rnfreeequalssa ] the net does not belong to the class @xmath341 of symmetrically asynchronously implementable nets .",
    "however , the net is -free , and thus does belong to the class @xmath518 of asymmetrically asynchronously implementable nets . by giving priority to the collection of the message token ( choosing the appropriate function @xmath408 in our notion of implementation )",
    ", it can be assured that instance i2 does not make the wrong choice and gets stuck ( however it is still not clear whether the message will actually be consumed ) .",
    "the obvious question is whether the naive petri net interpretation we have given is conform with the intended semantics of the _ alt_-construct ( according to the informal uml semantics the alternatives always have to be executed completely ; in lscs it is specified explicitly whether messages are assured to arrive ) .",
    "however , on basis of a maybe more elaborate petri nets semantics , it could be discussed what types of mscs can be used to describe physically distributed systems , in particular which type of construct for choices is reasonable in this case .",
    "another model of reactive systems where we can transfer our results to are process algebras .",
    "when giving petri net semantics to process algebras , it is an interesting question to investigate which classes of nets in our classification are obtained for certain types of operators or restricted languages , and to compare the results with results on language hierarchies ( as summarised below ) .",
    "the structural net classes we compare our constructions to were all taken from @xcite , where eike best and mike shields introduce various transformations between free choice nets , simple nets and extended variants thereof .",
    "they use `` essential equivalence '' to compare the behaviour of different nets , which they only give informally .",
    "this equivalence is insensitive to divergence , which is also relied upon in their transformations .",
    "as observed in footnote  [ bfc ] , it also does not preserve concurrency .",
    "they continue to show conditions under which liveness can be guaranteed for some of the classes .",
    "in @xcite , wil van der aalst , ekkart kindler and jrg desel introduce two extensions to extended simple nets , by allowing self - loops to ignore the discipline imposed by the -requirement .",
    "this however assumes a kind of `` atomicity '' of self - loops , which we did not allow in this paper .",
    "in particular we do not implicitly assume that a transition will not change the state of a place it is connected to by a self - loop , since in case of deadlock , the temporary removal of a token from such a place might not be temporary indeed .    in @xcite wolfgang",
    "reisig introduces a class of systems which communicate using buffers and where the relative speeds of different components are guaranteed to be irrelevant .",
    "the resulting nets are simple nets .",
    "he then proceeds introducing a decision procedure for the problem whether a marking exists which makes the complete system live .    the most similar work to our approach we have found is @xcite , where richard hopkins introduces the concept of _ distributable _ petri nets .",
    "these are defined in terms of _ locality functions _ , which assign to every transition @xmath1 a set of possible machines or locations @xmath602 on which @xmath1 may be executed , subject to the restriction that a set of transitions with a common preplace must share a common machine .",
    "a plain net @xmath5 is distributable iff for every locality function @xmath603 that can be imposed on it , it has a `` distributed implementation '' , a @xmath7-net @xmath84 with the same set of visible transitions , in which each transition is assigned a specific location , subject to three restrictions :    * the location of a visible transition @xmath1 is chosen from @xmath602 , * transitions with a common preplace must have the same location * and there exists a weak bisimulation between @xmath5 and @xmath84 , such that all @xmath7-transitions involved in simulating a transition @xmath1 from @xmath5 reside on one of the locations @xmath602 .",
    "the last clause enforces both a behavioural correspondence between @xmath5 and @xmath84 and a structural one ( through the requirement on locations ) .",
    "thus , as in our work , the implementation is a @xmath7-net that is required to be behaviourally equivalent to the original net .",
    "however , whereas we enforce particular implementations of an original net , hopkins allows implementations which are quite elaborate and make informed decisions based upon global knowledge of the net .",
    "consequently , his class of distributable nets is larger than our asynchronous net classes . as hopkins notes , due to his use of interleaving semantics",
    ", his distributed implementations do not always display the same concurrent behaviour as the original nets , namely they add concurrency in some cases .",
    "this does not happen in our asynchronous implementations .",
    "another branch of related work is in the context of distributed algorithms . in @xcite luc boug",
    "considers the problem of implementing symmetric leader election in the sublanguages of csp obtained by either allowing all guards , only input guards or no communication guards at all in guarded choice .",
    "he finds that the possibility of implementing it depends heavily on the structure of the communication graphs , while truly symmetric schemes are only possible in csp with input and output guards .",
    "quite a number of papers consider the question of synchronous versus asynchronous interaction in the realm of process algebras and the @xmath604-calculus . in @xcite",
    "frank de boer and catuscia palamidessi consider various dialects of csp with differing degrees of asynchrony .",
    "in particular , they consider csp without output guards and csp without any communication based guards .",
    "they also consider explicitly asynchronous variants of csp where output actions can not block , i.e.  asynchronous sending is assumed .",
    "similar work is done for the @xmath604-calculus in @xcite by catuscia palamidessi , in @xcite by uwe nestmann and in @xcite by dianele gorla .",
    "a rich hierarchy of asynchronous @xmath604-calculi has been mapped out in these papers .",
    "again mixed - choice , i.e. the ability to combine input and output guards in a single choice , plays a central role in the implementation of truly synchronous behaviour",
    ". it would be interesting to explore the possible connections between these languages and our net classes .    in @xcite ,",
    "peter selinger considers labelled transition systems whose visible actions are partitioned into input and output actions .",
    "he defines asynchronous implementations of such a system by composing it with in- and output queues , and then characterises the systems that are behaviourally equivalent to their asynchronous implementations .",
    "the main difference with our approach is that we focus on asynchrony within a system , whereas selinger focusses on the asynchronous nature of the communications of a system with the outside world .",
    "finally , there are approaches on hardware design where asynchronous interaction is an intriguing feature due to performance issues . for this",
    ", see the papers @xcite and @xcite by leslie lamport .",
    "in @xcite he considers arbitration in hardware and outlines various arbitration - free `` wait / signal '' registers .",
    "he notes that nondeterminism is thought to require arbitration , but no proof is known .",
    "he concludes that only marked graphs can be implemented using these registers .",
    "lamport then introduces `` or - waiting '' , i.e.  waiting for any of two signals , but has no model available to characterise the resulting processes .",
    "the used communication primitives bear a striking similarity to our symmetrically asynchronous nets .",
    "( 2006 ) : in l.  aceto & a.  inglfsdttir , editors : proceedings 9th international conference on _ foundations of software science and computation structures _ ( fossacs 06 ) , _ lncs _ 3921 , springer , pp . 4762 ."
  ],
  "abstract_text": [
    "<S> we investigate classes of systems based on different interaction patterns with the aim of achieving distributability . as our system model </S>",
    "<S> we use petri nets . in petri nets , </S>",
    "<S> an inherent concept of simultaneity is built in , since when a transition has more than one preplace , it can be crucial that tokens are removed instantaneously . when modelling a system which is intended to be implemented in a distributed way by a petri net , this built - in concept of synchronous interaction may be problematic . to investigate the problem we assume that removing tokens from places can no longer be considered as instantaneous . </S>",
    "<S> we model this by inserting silent ( unobservable ) transitions between transitions and their preplaces . </S>",
    "<S> we investigate three different patterns for modelling this type of asynchronous interaction . </S>",
    "<S> _ full asynchrony _ assumes that every removal of a token from a place is time consuming . for _ symmetric asynchrony _ , tokens are only removed slowly in case of backward branched transitions , hence where the concept of simultaneous removal actually occurs . </S>",
    "<S> finally we consider a more intricate pattern by allowing to remove tokens from preplaces of backward branched transitions asynchronously in sequence ( _ asymmetric asynchrony _ ) .    </S>",
    "<S> we investigate the effect of these different transformations of instantaneous interaction into asynchronous interaction patterns by comparing the behaviours of nets before and after insertion of the silent transitions . </S>",
    "<S> we exhibit for which classes of petri nets we obtain equivalent behaviour with respect to failures equivalence .    it turns out that the resulting hierarchy of petri net classes can be described by semi - structural properties . in case of full asynchrony and symmetric asynchrony </S>",
    "<S> , we obtain precise characterisations ; for asymmetric asynchrony we obtain lower and upper bounds .    </S>",
    "<S> we briefly comment on possible applications of our results to message sequence charts .    </S>",
    "<S> @xmath0reactive systems , petri nets , distributed systems , asynchronous interaction , equivalence notions </S>"
  ]
}