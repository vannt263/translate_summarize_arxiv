{
  "article_text": [
    "a _ cylindrical algebraic decomposition _ ( cad ) is : a _ decomposition _ of @xmath0 , meaning a collection of cells which do not intersect and whose union is @xmath0 ; _ cylindrical _ , meaning the projections of any pair of cells with respect to a given variable ordering are either equal or disjoint ; and , _",
    "( semi)-algebraic _ , meaning each cell can be described using a finite sequence of polynomial relations .",
    "cad is best known for quantifier elimination over the reals , but has also found diverse applications such as motion planning @xcite and reasoning with multi - valued functions @xcite .    the regularchains library @xcite in maple contains procedures to build cad by first building a _ complex cylindrical decomposition _ ( ccd ) of @xmath1 using triangular decomposition by regular chains , then refining to a cad of @xmath0 .",
    "the core algorithm was developed in @xcite with improvements detailed in @xcite and @xcite .",
    "these cad algorithms are in contrast to the traditional approach of projection and lifting followed since collins original work @xcite . here , a _ projection _",
    "phase repeatedly applies an operator to a set of polynomials ( starting with those forming the input ) each time producing another set in one fewer variables .",
    "then the _ lifting _ phase builds cads of @xmath2",
    ". @xmath3 is decomposed into points and intervals corresponding to the real roots of the univariate polynomials .",
    "@xmath4 is decomposed by repeating the process over each cell in @xmath5 using the bivariate polynomials at a sample point .",
    "the output over each cell consists of _ sections _ ( where a polynomial vanishes ) and _ sectors _ ( the regions between ) which together form a _",
    "stack_. the union of these stacks gives the cad of @xmath4 and the process is repeated until a cad of @xmath0 is produced .",
    "collins defined the projection operator so the cad of @xmath0 produced using sample points this way could be concluded _ sign - invariant _ for the input polynomials : each polynomial has constant sign on each cell .",
    "the key tool in the proof was showing polynomials to be _",
    "delineable _ in a cell , meaning the zero set of individual polynomials are disjoint sections and the zero sets of different polynomials are identical or disjoint . for developments to collin",
    "s algorithm see for example the introduction of @xcite .",
    "we use ` pl - cad ` for cads built by projection and lifting and ` rc - cad ` for cads built via ccds .",
    "we will discuss a freely available maple package projectioncad which builds ` pl - cad`s by utilising routines developed for ` rc - cad ` .",
    "we continue in section [ section : why ] by describing the motivation for coupling these approaches before explaining the workings of the package in section [ section : how ] and describing the current functionality in section [ section : func ] .",
    "earlier versions of the package can be downloaded alongside @xcite @xcite , with the latest version available from the authors .",
    "there are plans for its integration into the regularchains library @xcite itself .",
    "projectioncad uses routines in the regularchains library to build cells in the lifting phase .",
    "the advantages of utilising the routines are multiple :    it avoids many costly algebraic number calculations by using efficient algorithms for triangular decomposition .",
    "when algebraic numbers are required ( as sample points for lower dimension cells ) they are represented as the unique root of a regular chain in a bounding box .",
    "it ensures ` projectioncad ` will always use the best available sub - algorithms in maple , such as the recently improved routines for real root isolation .",
    "it allows ` projectioncad ` to match output formats with the ` rc - cad ` algorithms .",
    "in particular , it allows for the use of the sophisticated _ piecewise _ interface @xcite which highlights the tree - like structure of a cad .",
    "the projectioncad package was developed to implement new theory for ` pl - cad ` , most notably the work in @xcite , @xcite , @xcite and @xcite .",
    "more details of the functionality are given in section [ section : func ] .",
    "however , it has also allowed for easy comparison of ` pl - cad ` and ` rc - cad ` , leading to new developments for ` rc - cad ` @xcite @xcite .",
    "a future aim is identification of problem classes suitable for one approach or the other .",
    "the pseudo code in algorithm [ alg : plcad ] describes the framework which all algorithms to build cads within projectioncad follow .",
    "they apply to either polynomials or formulae . if the former then the cad produced is sign - invariant for each polynomial .",
    "if the latter then the cad is such that each formula has constant boolean truth value on each cell , said to be _ truth - invariant _ for the formula ( _ truth table invariant _ for the sequence of formulae ) .",
    "depending on the algorithm used the user may also have to supply additional information ( such as which projection operator to use or which equational constraint to designate @xcite ) .",
    "all algorithms require a specified variable ordering , which can have a significant affect on the tractability of using cad @xcite .",
    "we use ordered variables @xmath6 and say the _ main variable _ is the highest ordered variable present .    run the projection phase using an appropriate projection operator on @xmath7 .",
    "[ step : proj ] set @xmath8 to be a cad of @xmath5 formed by the decomposition of the real line according to the real roots of the polynomials in @xmath9 .",
    "[ step : r1 ] @xmath10 .",
    "[ step : returnrn ]    all algorithms in projectioncad start with a projection phase ( step [ step : proj ] ) which uses a projection operator appropriate to the input to derive a set of projection polynomials . in steps [",
    "step : pp1]-[step : pp2 ] we sort these into sets @xmath11 according to their main variable .",
    "the remainder of the algorithm defines the lifting phase .",
    "we start by decomposing @xmath5 into cells according to the real roots of @xmath11 ( step [ step : r1 ] ) and then repeatedly lift by generating stacks over cells until we have a cad of @xmath0 .",
    "all cells are equipped with a _ sample point _ and a _",
    "cell index_. the index is an @xmath12-tuple of positive integers that corresponds to the location of the cell relative to the rest of the cad .",
    "cells are numbered in each stack during the lifting stage ( from most negative to most positive ) , with sectors having odd numbers and sections having even numbers .",
    "therefore the dimension of a given cell can be easily determined from its index : simply the number of odd indices in the @xmath12-tuple .    before lifting over a cell",
    "we first check for the satisfaction of any conditions necessary to conclude the correctness of the theoretical algorithm being implemented ( step [ step : wocheck ] ) .",
    "these conditions are collectively refereed to as the input being _ well - oriented _ and involve ensuring that projection polynomials are not _ nullified _ ( meaning a polynomial with main variable @xmath13 is not identically zero over a cell in @xmath14 ) . which polynomials must be checked varies with the algorithm ( see @xcite , @xcite , @xcite , @xcite for details ) . if the conditions are not satisfied then an error message is returned in step [ step : fail ] , unless the cell in question is zero - dimensional when correctness can be restored by generating the stack with respect to minimal delineating polynomials ( see @xcite ) as well as the projection polynomials in @xmath11 ( step [ step : mdp ] ) .",
    "note that input not well - oriented for one operator may be for another , and that collins operator is always successful ( given sufficient resources ) .",
    "building the stack is passed to algorithm [ alg : cadgeneratestack ] by step [ step : gs ] .",
    "the stacks are collected together in step [ step : collectstacks ] to form a cad of @xmath15 and the final cad of @xmath0 returned in step [ step : returnrn ] .",
    "the correctness of algorithm [ alg : plcad ] follows from the correctness of algorithm [ alg : cadgeneratestack ] and the correctness of the various `",
    "pl - cad ` theories implemented proved in their respective papers ( for which see the citations in section [ section : func ] ) .",
    "stacks are generated following algorithm [ alg : cadgeneratestack ] .",
    "it finishes in step [ step : rcgs ] with a call to ` regularchains :- generatestack ` , an algorithm described in section 5.2 of @xcite ( and implemented in maple s ` regularchains ` library ) .",
    "algorithm [ alg : cadgeneratestack ] requires the input be projection polynomials : implying they satisfy the delineability conditions necessary for the cells produced when lifting to have the required invariance condition .",
    "the regular chains algorithm has stricter criteria , requiring in addition that the polynomials _ separate above the cell _ , meaning they are coprime and squarefree throughout .",
    "hence algorithm [ alg : cadgeneratestack ] must first pre - process to meet this condition .",
    "in steps [ step : extract1 ] and [ step : extract2 ] we simply extract information from the cell @xmath16 to be lifted over .",
    "we identify those dimensions of the cell which are restricted to a point by consulting the cell index ( those indices with even integers ) and collect together the equations defining these restrictions in steps @xmath17 .",
    "note that there is no ambiguity in the ordering of the polynomials in @xmath18 since a regular chain is defined by polynomials of different main variables @xcite . if the cell is of full dimension then there is no need to process since the polynomials are delineable and taken from a squarefree basis .",
    "otherwise , we process using algorithms [ alg : makecoprime ] and [ alg : makesquarefree ] in steps [ step : mkcp ] and [ step : mksf ] .",
    "the restriction is identified using a regular chain @xmath19 ( step [ step : rcdash ] ) together with the original bounding box .",
    "we can be certain that @xmath20 defines a single regular chain since the equations were extracted from one .      in order to make the polynomials coprime we use repeated calls to a triangular decomposition algorithm in step [ step : tri ] ( described in @xcite and part of the ` regularchains ` library ) .",
    "given lists of polynomials @xmath21 and @xmath22 and a regular chain , it returns a decomposition of the zeros of @xmath21 which are also also zeros of the regular chain but not zeros of @xmath22 .",
    "we use @xmath19 for the regular chain , so we work on the restriction , and build up a list of coprime polynomials by ensuring existing ones ( @xmath22 ) are not zeros in decompositions of the next one ( @xmath21 ) . each time the decomposition is a list of either regular chains or",
    "_ regular systems _ ( a regular chain and an inequality regular with respect to the chain @xcite ) .",
    "we consider each of these components in turn .",
    "if the main variable is lower then the solution is discarded .",
    "otherwise we check if the component has a solution compatible with the sample point for the cell ( as it may be a solution of @xmath19 other than one isolated by @xmath23 ) .",
    "this means isolating the real solutions ( of the component excluding the top dimension ) and refining their bounding boxes until they are either within @xmath23 or do not intersect at all .",
    "it is achieved using the ` realrootisolate ` command in the ` regularchains ` library ( see @xcite ) . finally if the component passes these tests then the polynomial in the main variable is extracted and added to the set returned from algorithm [ alg : makecoprime ] in steps @xmath24 .      in order to make the polynomials squarefree we use repeated calls to an algorithm which does this modulo a regular chain ( @xmath19 : so that we are working on the restriction ) .",
    "it is an analogue of musser s @xcite with the gcd calculations performed modulo the regular chain as described in @xcite .",
    "it assumes the polynomial is regular modulo the chain and so we first test for this .",
    "if not regular ( the leading coefficient vanishes ) then we consider the ` tail ` ( polynomial minus the leading term ) in step [ step : tail ] , if still in the main variable .",
    "the output of the factorization is either : @xmath25 and a list of polynomials forming a squarefree decomposition of @xmath26 modulo @xmath25 ; or a list of pairs of regular chains and squarefree decompositions where the regular chains are a decomposition of @xmath25 . in the latter case",
    "only one will be relevant for the root isolated by @xmath23 and we identify which using the ` realrootisolate ` command , similarly to algorithm [ alg : makecoprime ] .",
    "set @xmath27 and @xmath28 to be the cell index and sample point of @xmath16 .",
    "[ step : extract1 ] set @xmath25 and @xmath23 to be the regular chain and bounding box encoding @xmath28 .",
    "[ step : extract2 ] set @xmath18 to be the set of @xmath29 polynomials whose zeros define @xmath25 , ordered by increasing main variable .",
    "[ step : collect1 ] set @xmath30 . @xmath31 [ step : rcgs ] @xmath32 .    set @xmath33 .",
    ".    set @xmath33 .",
    "we finish by listing some of the functionality of within projectioncad , focusing on aspects not usually found in other cad implementations :    * sign - invariant cads can be built using the collins @xcite or mccallum @xcite projection operators .",
    "* cads can be built with the stronger property of _ order - invariance _",
    "( where each polynomial has constant order of vanishing on each cell ) @xcite .",
    "* _ equational constraints _ ( ecs ) are equations logically implied by the formula .",
    "they can be utilised via mccallum s reduced projection @xcite and a more efficient lifting phased ( detailed in section 5 of @xcite ) .",
    "* tticads can be built for sequences of formulae , making use of ecs in each @xcite @xcite .",
    "tticad can be both a desired structure for applications @xcite and an efficient way to build a truth - invariant cad ( allowing savings from ecs for conjunctive sub - formulae , not ecs of the whole formula ) . *",
    "minimal delineating polynomials @xcite are built automatically , avoiding unnecessary failure declarations ( which can occur in qepcad ) .",
    "see @xcite for an example of this . * user commands for stack generation and the construction of _ induced cads _",
    "( a cad of @xmath35 produced en route to a cad of @xmath0 ) , allowing for easy experimentation with the theory .",
    "* _ layered cads",
    "_ contain cells of only a certain dimension or higher .",
    "they can be produced ( more efficiently than a full cad ) @xcite .",
    "* _ variety cads",
    "_ contain only those cells that lie on the variety defined by an ec .",
    "they can be produced ( more efficiently than a full cad ) @xcite . *",
    "layered and manifold tticads as well as layered - manifold cads can be produced @xcite ( combining the savings from the different theories ) .",
    "* heuristics are available to help with choices such as variable ordering , ec designation and breaking up parent formulae for tticad @xcite .",
    "this work was supported by the epsrc ( grant number ep / j003247/1 ) .",
    "we thank the developers of the regularchains library , especially changbo chen and marc moreno maza , for access to their code and assistance working with it .",
    "r.  bradford , c.  chen , j.h .",
    "davenport , m.  england , m.  moreno maza , and d.  wilson .",
    "truth table invariant cylindrical algebraic decomposition by regular chains . .",
    "preprint : http://opus.bath.ac.uk/38344/ , 2014 .",
    "r.  bradford , j.h .",
    "davenport , m.  england , and d.  wilson . optimising problem formulations for cylindrical algebraic decomposition . in _",
    "intelligent computer mathematics _ ( lncs 7961 ) , pages 1934 .",
    "springer berlin heidelberg , 2013 .",
    "c.  chen , j.h .",
    "davenport , j.  may , m.  moreno maza , b.  xia , r.  xiao , and y.  xie .",
    "user interface design for geometrical decomposition algorithms in maple . in _ proc . mathematical user - interface workshop _",
    ", 12 pages , 2009 .",
    "quantifier elimination for real closed fields by cylindrical algebraic decomposition . in _ proc .",
    "2nd gi conference on automata theory and formal languages _ , pages 134183 .",
    "springer - verlag , 1975 .",
    "m.  england .",
    "an implementation of cad in maple utilising problem formulation , equational constraints and truth - table invariance . technical report , uni . of bath ,",
    ", 2013 - 04 .",
    "available at http://opus.bath.ac.uk/35636/ , 2013 .",
    "m.  england , r.  bradford , c.  chen , j.h .",
    "davenport , m.  moreno maza , and d.  wilson .",
    "problem formulation for truth - table invariant cylindrical algebraic decomposition by incremental triangular decomposition .",
    "cicm 14 ( lnai 8543 ) , pages 4560 , 2014 .          s.  mccallum .",
    "an improved projection operation for cylindrical algebraic decomposition . in _",
    "quantifier elimination and cylindrical algebraic decomposition _ , texts & monographs in symbolic computation , pages 242268 .",
    "springer - verlag , 1998 ."
  ],
  "abstract_text": [
    "<S> cylindrical algebraic decomposition ( cad ) is an important tool , both for quantifier elimination over the reals and a range of other applications . </S>",
    "<S> traditionally , a cad is built through a process of projection and lifting to move the problem within euclidean spaces of changing dimension . </S>",
    "<S> recently , an alternative approach which first decomposes complex space using triangular decomposition before refining to real space has been introduced and implemented within the regularchains library of maple . we here describe a freely available package ` projectioncad ` which utilises the routines within the regularchains library to build cads by projection and lifting . </S>",
    "<S> we detail how the projection and lifting algorithms were modified to allow this , discuss the motivation and survey the functionality of the package . </S>"
  ]
}