{
  "article_text": [
    "if we abstractly consider the human genome as a string over the nucleotide alphabet @xmath0 , it is widely known that the genomes of any two humans have at more than 99% of the sites the same nucleotide .",
    "the sites at which variability is observed across the human population are called _ single nucleotide polymorphisms _ ( snps ) , which are formally defined as the sites on the human genome where , across the human population , two or more nucleotides are observed and each such nucleotide occurs in at least 5% of the population .",
    "these sites , which occur ( on average ) approximately once per thousand bases , capture the bulk of human genetic variability ; the string of nucleotides found at the snp sites of a human - the _ haplotype _ of that individual - can thus be thought of as a `` fingerprint '' for that individual . +   + it has been observed that , for most snp sites , only two nucleotides are seen ; sites where three or four nucleotides are found are comparatively rare .",
    "thus , from a combinatorial perspective , a haplotype can be abstractly expressed as a string over the alphabet @xmath1 .",
    "indeed , the biologically - motivated field of snp and haplotype analysis has spawned a rich variety of combinatorial problems , which are well described in surveys such as @xcite and @xcite .",
    "+   + we focus on two such combinatorial problems , both variants of the _ single individual haplotyping problem _ ( sih ) , introduced in @xcite .",
    "sih amounts to determining the haplotype of an individual using ( potentially ) incomplete and/or imperfect fragments of sequencing data .",
    "the situation is further complicated by the fact that , being a _ diploid _ organism , a human has two versions of each chromosome ; one each from the individual s mother and father . hence , for a given interval of the genome , a human has two haplotypes .",
    "thus , sih can be more accurately described as finding the two haplotypes of an individual given fragments of sequencing data where the fragments potentially have read errors and , crucially , where it is _ not _ known which of the two chromosomes each fragment was read from .",
    "we consider two well - known variants of the problem : _ minimum error correction _",
    "( mec ) , and _ longest haplotype reconstruction _ ( lhr ) .",
    "+   + the input to these problems is a matrix @xmath2 of snp fragments .",
    "each column of @xmath2 represents an snp site and thus each entry of the matrix denotes the ( binary ) choice of nucleotide seen at that snp location on that fragment .",
    "an entry of the matrix can thus either be ` 0 ' , ` 1 ' or a _ hole _ , represented by ` - ' , which denotes lack of knowledge or uncertainty about the nucleotide at that site .",
    "we use @xmath3 $ ] to refer to the value found at row @xmath4 , column @xmath5 of @xmath2 , and use @xmath6 $ ] to refer to the @xmath4th row .",
    "two rows @xmath7 of the matrix _ conflict _ if there exists a column @xmath5 such that @xmath8 \\neq m[r_2 , j]$ ] and @xmath9 , m[r_2 , j ] \\in \\{0,1\\}$ ] .",
    "+   + a matrix is _ feasible _ iff the rows of the matrix can be partitioned into two sets such that all rows within each set are pairwise non - conflicting .",
    "+   + the objective in mec is to `` correct '' ( or `` flip '' ) as few entries of the input matrix as possible ( i.e. convert 0 to 1 or vice - versa ) to arrive at a feasible matrix .",
    "the motivation behind this is that all rows of the input matrix were sequenced from one haplotype or the other , and that any deviation from that haplotype occurred because of read - errors during sequencing .",
    "+   + the problem lhr has the same input as mec but a different objective .",
    "recall that the rows of a feasible matrix @xmath2 can be partitioned into two sets such that all rows within each set are pairwise non - conflicting .",
    "having obtained such a partition , we can reconstruct a haplotype from each set by merging all the rows in that set together .",
    "( we define this formally later in section [ sec : lhr ] . ) with lhr the objective is to remove _ rows _ such that the resulting matrix is feasible and such that the sum of the lengths of the two resulting haplotypes is maximised .",
    "+   + in the context of haplotyping , mec and lhr have been discussed - sometimes under different names - in papers such as @xcite , @xcite , @xcite and ( implicitly ) @xcite .",
    "one question arising from this discussion is how the distribution of holes in the input data affects computational complexity . to explain ,",
    "let us first define a _",
    "( in a string over the alphabet @xmath10 ) as a maximal contiguous block of holes that is flanked on both sides by non - hole values .",
    "for example , the string ` 0010 ` has no gaps , ` -010 - 111 ` has two gaps , and ` -01 ` has one gap .",
    "two special cases of mec and lhr that are considered to be practically relevant are the ungapped case and the 1-gap case .",
    "the ungapped variant is where every row of the input matrix is ungapped , i.e. all holes appear at the start or end . in the 1-gap case",
    "every row has at most one gap .",
    "+ in section [ subsec : umec ] we offer what we believe is the first proof that ungapped - mec ( and hence 1-gap mec and also the general mec ) is np - hard .",
    "we do so by reduction from max - cut .",
    "( as far as we are aware , other claims of this result are based explicitly or implicitly on results found in @xcite ; as we discuss in section [ subsec : bmec ] , we conclude that the results in @xcite can not be used for this purpose . ) +   + the np - hardness of 1-gap mec ( and general mec ) follows immediately from the proof that ungapped - mec is np - hard .",
    "however , our np - hardness proof for ungapped - mec is not approximation - preserving , and consequently tells us little about the ( in)approximability of ungapped - mec , 1-gap mec and general mec . in light of this we provide ( in section [ subsec : gmec ] ) a proof that 1-gap mec is apx - hard , thus excluding ( unless p = np ) the existence of a _ polynomial time approximation scheme _ ( ptas ) for 1-gap mec ( and general mec . ) +   + we define ( in section [ subsec : bmec ] ) the problem _ binary - mec _ , where the input matrix contains no holes ; as far as we know the complexity of this problem is still - intriguingly - open .",
    "we also consider a parameterised version of binary - mec , where the number of haplotypes is not fixed as two , but is part of the input .",
    "we prove that this problem is np - hard in section [ subsec : pbmec ] .",
    "( in the appendix we also prove an `` auxiliary '' lemma which , besides being interesting in its own right , takes on a new significance in light of the open complexity of binary - mec . )",
    "+   + in section [ subsec : lhrpoly ] we show that _ ungapped - lhr _ is polynomial - time solvable and give a dynamic programming algorithm for this which runs in time @xmath11 for an @xmath12 input matrix .",
    "this improves upon the result of @xcite which also showed a polynomial - time algorithm for ungapped - lhr but under the restricting assumption of non - nested input rows .",
    "+   + we also prove , in section [ subsec : lhrhard ] , that lhr is apx - hard ( and thus also np - hard ) in the general case , by proving the much stronger result that 1-gap lhr is apx - hard .",
    "this is the first proof of hardness ( for both 1-gap lhr and general lhr ) appearing in the literature .",
    "for a length-@xmath13 string @xmath14 , and a length-@xmath13 string @xmath15 , we define @xmath16 as the number of _ mismatches _ between the strings i.e. positions where @xmath17 is 0 and @xmath18 is 1 , or vice - versa ; holes do not contribute to the mismatch count .",
    "recall the definition of _ feasible _ from earlier ; an alternative , and equivalent , definition ( which we use in the following proofs ) is as follows .",
    "an @xmath19 snp matrix @xmath2 is _ feasible _ iff there exist two strings ( haplotypes ) @xmath20 , such that for all rows r of m , @xmath21 or @xmath22 .",
    "+   + finally , a _",
    "flip _ is where a 0 entry is converted to a 1 , or vice - versa .",
    "flipping to or from holes is not allowed and the haplotypes @xmath23 and @xmath24 may not contain holes .",
    "* problem : * _ ungapped - mec _ + * input : * an ungapped snp matrix @xmath2 + * output : * ungapped - mec(m ) , which we define as the smallest number of flips needed to make @xmath2 feasible . on input @xmath25 . ]",
    "+    [ lem : mechard ] ungapped - mec is np - hard .",
    "+    we give a polynomial - time reduction from max - cut , which is the problem of computing the size of a maximum cardinality cut in a graph .",
    "let @xmath26 be the input to max - cut , where @xmath27 is undirected .",
    "( we identify , wlog , @xmath28 with @xmath29 . )",
    "we construct an input matrix @xmath2 for ungapped - mec with @xmath30 rows and @xmath31 columns where @xmath32 .",
    "we use @xmath33 to refer to the first @xmath34 rows of @xmath2 , @xmath35 to refer to the second @xmath34 rows of @xmath2 , and @xmath36 to refer to the remaining @xmath37 rows .",
    "@xmath33 consists of @xmath38 consecutive blocks of @xmath39 identical rows .",
    "each row in the @xmath4-th block ( for @xmath40 ) contains a @xmath41 at columns @xmath42 and @xmath43 and holes at all other columns .",
    "@xmath35 is defined similar to @xmath33 with @xmath44-entries instead of @xmath41-entries .",
    "each row of @xmath36 encodes an edge from @xmath27 : for edge @xmath45 ( with @xmath46 ) we specify that columns @xmath42 and @xmath43 contain 0s , columns @xmath47 and @xmath48 contain 1s , and for all @xmath49 , column @xmath50 contains 0 and column @xmath51 contains 1 .",
    "( see figures [ fig : mecgraph ] and [ fig : mecmatrix ] for an example of how @xmath2 is constructed . )",
    "+    @xmath52     + suppose @xmath53 is the largest cut possible in @xmath54 and @xmath55 is the minimum number of flips needed to make @xmath2 feasible .",
    "we claim that the following holds : @xmath56 from this @xmath53 , the optimal solution of max - cut , can easily be computed .",
    "first , note that the solution to ungapped - mec(m ) is trivially upperbounded by @xmath57 .",
    "this follows because we could simply flip every 1 entry in @xmath36 to 0 ; the resulting overall matrix would be feasible because we could just take @xmath23 as the all-0 string and @xmath24 as the all-1 string .",
    "now , we say a haplotype @xmath58 has the _ double - entry _ property if , for all odd - indexed positions ( i.e. columns ) @xmath5 in @xmath58 , the entry at position @xmath5 of @xmath58 is the same as the entry at position @xmath59 .",
    "we argue that a minimal number of feasibility - inducing flips will _ always _ lead to two haplotypes @xmath60 such that both haplotypes have the double - entry property and , further , @xmath23 is the bitwise complement of @xmath24 .",
    "( we describe such a pair of haplotypes as _ partition - encoding_. ) this is because , if @xmath60 are not partition - encoding , then at least @xmath61 ( in contrast with zero ) entries in @xmath33 and/or @xmath35 will have to be flipped , meaning this strategy is doomed to begin with .",
    "+   + now , for a given partition - encoding pair of haplotypes , it follows that - for each row in @xmath36 - we will have to flip either @xmath62 or @xmath38 entries to reach its nearest haplotype .",
    "this is because , irrespective of which haplotype we move a row to , the @xmath62 pairs of columns _ not _ encoding end - points ( for a given row ) will always cost 1 flip each to fix . then either 2 or 0 of the 4 `` endpoint - encoding '' entries will also need to be flipped ; 4 flips will never be necessary because then the row could move to the other haplotype , requiring no extra flips .",
    "ungapped - mec thus maximises the number of rows which require @xmath62 rather than @xmath38 flips .",
    "if we think of @xmath23 and @xmath24 as encoding a partition of the vertices of @xmath28 ( i.e. a vertex @xmath4 is on one side of the partition if @xmath23 has 1s in columns @xmath42 and @xmath43 , and on the other side if @xmath24 has 1s in those columns ) , it follows that each row requiring @xmath62 flips corresponds to a cut - edge in the vertex partition defined by @xmath23 and @xmath24 .",
    "the expression ( [ maxcut ] ) follows .",
    "+      * problem : * _ 1-gap mec _ + * input : * snp matrix @xmath2 with at most 1 gap per row + * output : * the smallest number of flips needed to make @xmath2 feasible .",
    "+   + to prove that 1-gap mec is apx - hard ( and therefore also np - hard ) we will give an l - reduction from cubic - min - uncut , which is the problem of finding the minimum number of edges that have to be removed from a 3-regular graph in order to make it bipartite .",
    "our first goal is thus to prove the apx - hardness of cubic - min - uncut , which itself will be proven using an l - reduction from the apx - hard problem cubic - max - cut .",
    "+   + to aid the reader , we reproduce here the definition of an l - reduction . +    ( papadimitriou and yannakakis @xcite ) let a and b be two optimisation problems .",
    "l - reduction _ from a to b is a pair of functions r and s , both computable in polynomial time , such that for any instance i of a with optimum cost opt(i ) , r(i ) is an instance of b with optimum cost opt(r(i ) ) and for every feasible solution s of r(i ) , s(s ) is a feasible solution of i such that : @xmath63 for some positive constant @xmath64 and : @xmath65 , where c(s(s ) ) and c(s ) represent the costs of s(s ) and s , respectively .",
    "+    [ obs : mincuthard ] cubic - min - uncut is apx - hard .",
    "+    we give an l - reduction from cubic - max - cut , the problem of finding the maximum cardinality of a cut in a 3-regular graph .",
    "( this problem is shown to be apx - hard in @xcite ; see also @xcite . )",
    "let @xmath26 be the input to cubic - max - cut .",
    "+   + note that cubic - min - uncut is the `` complement '' of cubic - max - cut , as expressed by the following relationship : @xmath66 to see why this holds , note that for every cut @xmath67 , the removal of the edges @xmath68 will lead to a bipartite graph . on the other hand , given a set of edges @xmath69 whose",
    "removal makes @xmath54 bipartite , the complement is not necessarily a cut .",
    "however , given a bipartition induced by the removal of @xmath69 , the edges from the original graph that cross this bipartition form a cut @xmath70 , such that @xmath71 .",
    "this proves ( [ eq : duality ] ) , and the mapping ( just described ) from @xmath69 to @xmath70 is the mapping we use in the l - reduction .",
    "+   + now , note that property ( [ eq : l1 ] ) of the l - reduction is easily satisfied ( taking @xmath72 ) because the optimal value of cubic - min - uncut is always less than or equal to the optimal value of cubic - max - cut .",
    "this follows from the combination of ( [ eq : duality ] ) with the fact that a maximum cut in a 3-regular graph always contains at least @xmath73 of the edges : if a vertex has less than two incident edges in the cut then we can get a larger cut by moving this vertex to the other side of the partition . +   + to see that property ( [ eq : l2 ] ) of the l - reduction is easily satisfied ( taking @xmath74 ) ,",
    "let @xmath69 be any set of edges whose removal makes @xmath54 bipartite .",
    "property ( [ eq : l2 ] ) is satisfied because @xmath69 gets mapped to a cut @xmath70 , as defined above , and combined with ( [ eq : duality ] ) this gives : @xmath75 this completes the l - reduction from cubic - max - cut to cubic - min - uncut , proving the apx - hardness of cubic - min - uncut .",
    "+    we also need the following observation .",
    "+    [ obs : orient ]",
    "let @xmath76 be an undirected , 3-regular graph .",
    "then we can find , in polynomial time , an orientation of the edges of @xmath54 so that each vertex has either in - degree 2 and out - degree 1 ( `` in - in - out '' ) or out - degree 2 and in - degree 1 ( `` out - out - in '' ) .",
    "+    ( we assume that @xmath54 is connected ; if @xmath54 is not connected , we can apply the following argument to each component of @xmath54 in turn , and the overall result still holds . ) every cubic graph has an even number of vertices , because every graph must have an even number of odd - degree vertices .",
    "we add an arbitrary perfect matching to the graph , which may create multiple edges .",
    "the graph is now 4-regular and therefore has an euler tour .",
    "we direct the edges following the euler - tour ; every vertex is now in - in - out - out . if we remove the perfect matching edges we added , we are left with an oriented version of @xmath54 where every vertex is in - in - out or out - out - in .",
    "this can all be done in polynomial time .",
    "+    [ apxhard ] 1-gap mec is apx - hard +    we give a reduction from cubic - min - uncut . consider an arbitrary 3-regular graph @xmath76 and orient the edges as described in observation [ obs : orient ] to obtain an oriented version of @xmath54 , @xmath77 , where each vertex is either in - in - out or out - out - in .",
    "we construct an latexmath:[$|e| \\times    of @xmath2 correspond to the vertices of @xmath79 and every row of @xmath2 encodes an oriented edge of @xmath79 ; it has a @xmath41 in the column corresponding to the tail of the edge ( i.e. the vertex from which the edge leaves ) , a @xmath44 in the column corresponding to the head of the edge , and the rest holes . +   + we prove the following : @xmath80 we first prove that : @xmath81 to see this , let @xmath69 be a minimal set of edges whose removal makes @xmath54 bipartite , and let @xmath82 .",
    "let @xmath83 be the bipartite graph ( with bipartition @xmath84 ) obtained from @xmath54 by removing the edges @xmath69 .",
    "let @xmath23 ( respectively , @xmath24 ) be the haplotype that has 1s in the columns representing vertices of @xmath85 ( respectively , @xmath86 ) and 0s elsewhere .",
    "it is possible to make @xmath2 feasible with @xmath39 flips , by the following process : for each edge in @xmath69 , flip the 0 bit in the corresponding row of @xmath2 to 1 .",
    "for each row r of m it is now true that @xmath87 or @xmath88 , proving the feasibility of @xmath2 .",
    "+   + the proof that , @xmath89 is more subtle .",
    "suppose we can render @xmath2 feasible using @xmath5 flips , and let @xmath23 and @xmath24 be any two haplotypes such that , after the @xmath5 flips , each row of @xmath2 is distance 0 from either @xmath23 or @xmath24 .",
    "if @xmath23 and @xmath24 are bitwise complementary then we can make @xmath54 bipartite by removing an edge whenever we had to flip a bit in the corresponding row .",
    "the idea is , namely , that the 1s in @xmath23 ( respectively , @xmath24 ) represent the vertices @xmath85 ( respectively , @xmath86 ) in the resulting bipartition @xmath90 .",
    "+   + however , suppose the two haplotypes @xmath23 and @xmath24 are not bitwise complementary . in this case it is sufficient to demonstrate that there also exists bitwise complementary haplotypes @xmath91 and @xmath92 such that , after @xmath5 ( or fewer ) flips , every row of @xmath2 is distance 0 from either @xmath91 or @xmath92 .",
    "consider thus a column of @xmath23 and @xmath24 where the two haplotypes are not complementary .",
    "crucially , the orientation of @xmath79 ensures that every column of @xmath2 contains _ either _ one @xmath44 and two @xmath41s _ or _ two @xmath44s and one @xmath41 ( and the rest holes ) .",
    "a simple case analysis shows that , because of this , we can always change the value of one of the haplotypes in that column , without increasing the number of flips .",
    "( the number of flips might decrease . ) repeating this process for all columns of @xmath23 and @xmath24 where the same value is observed thus creates complementary haplotypes @xmath91 and @xmath92 , and - as described in the previous paragraph - these haplotypes then determine which edges of @xmath54 should be removed to make @xmath54 bipartite .",
    "this completes the proof of ( [ eq : uncutmec ] ) .",
    "+   + the above reduction can be computed in polynomial time and is an l - reduction . from ( [ eq : uncutmec ] ) it follows directly that property ( [ eq : l1 ] ) of an l - reduction is satisfied with @xmath72 .",
    "property ( [ eq : l2 ] ) , with @xmath93 , follows from the proof of ( [ eq : uncutmec3 ] ) , combined with ( [ eq : uncutmec ] ) .",
    "namely , whenever we use ( say ) @xmath53 flips to make @xmath2 feasible , we can find @xmath94 edges of @xmath54 that can be removed to make @xmath54 bipartite .",
    "combined with ( [ eq : uncutmec ] ) this gives : @xmath95      from a mathematical point of view it is interesting to determine whether mec stays np - hard when the input matrix is further restricted .",
    "let us therefore define the following problem . +   + * problem : * _ binary - mec _ + * input : * an snp matrix @xmath2 that does not contain any holes + * output : * as for ungapped - mec +   + like all optimisation problems , the problem binary - mec has different variants , depending on how the problem is defined .",
    "the above definition is technically speaking the _ evaluation _ variant of the binary - mec problem .",
    "consider the closely - related _ constructive _ version : +   + * problem : * _ binary - constructive - mec _ + * input : * an snp matrix @xmath2 that does not contain any holes + * output : * for an input matrix @xmath2 of size @xmath19 , two haplotypes @xmath20 minimizing : @xmath96 in the appendix , we prove that binary - constructive - mec is polynomial - time turing interreducible with its evaluation counterpart , binary - mec .",
    "this proves that binary - constructive - mec is solvable in polynomial - time iff binary - mec is solvable in polynomial - time .",
    "we mention this correspondence because , when expressed as a constructive problem , it can be seen that mec is in fact a specific type of _ clustering _ problem , a topic of intensive study in the literature .",
    "more specifically , we are trying to find two representative `` median '' ( or `` consensus '' ) strings such that the sum , over all input strings , of the distance between each input string and its nearest median , is minimised .",
    "this interreducibility is potentially useful because we now argue , in contrast to claims in the existing literature , that the complexity of binary - mec / binary - constructive - mec is actually still open .",
    "+   + to elaborate , it is claimed in several papers ( e.g. @xcite ) that a problem equivalent to binary - constructive - mec is np - hard .",
    "such claims inevitably refer to the seminal paper _ segmentation problems _ by kleinberg , papadimitriou , and raghavan ( kpr ) , which has appeared in multiple different forms since 1998 ( e.g. @xcite , @xcite and @xcite . )",
    "however , the kpr papers actually discuss two superficially similar , but essentially different , problems : one problem is essentially equivalent to binary - constructive - mec , and the other is a more general ( and thus , potentially , a more difficult ) problem .. this extra degree of freedom - particularly the ability to simultaneously use positive , negative and zero values in the input matrix - is what ( when coupled with a dot product distance measure ) provides the ability to encode np - hard problems . ]",
    "communication with the authors @xcite has confirmed that they have no proof of hardness for the former problem i.e. the problem that is essentially equivalent to binary - constructive - mec .",
    "+   + thus we conclude that the complexity of binary - constructive - mec / binary - mec is still open . from an approximation viewpoint",
    "the problem has been quite well - studied ; the problem has a _ polynomial time approximation scheme _ ( ptas ) because it is a special form of the _ hamming 2-median clustering problem _ , for which a ptas is demonstrated in @xcite .",
    "other approximation results appear in @xcite , @xcite , @xcite , @xcite and a heuristic for a similar ( but not identical ) problem appears in @xcite .",
    "we also know that , if the number of haplotypes to be found is specified as part of the input ( and not fixed as 2 ) , the problem becomes np - hard ; we prove this in the following section .",
    "finally , it may also be relevant that the `` geometric '' version of the problem ( where rows of the input matrix are not drawn from @xmath97 but from @xmath98 , and euclidean distance is used instead of hamming distance ) is also open from a complexity viewpoint @xcite .",
    "( however , the version using euclidean - distance - squared _ is _ known to be np - hard @xcite . )",
    "let us now consider a generalisation of the problem binary - mec , where the number of haplotypes is not fixed as two , but part of the input .",
    "+   + * problem : * _ parameterised - binary - mec ( pbmec ) _ + * input : * an snp matrix @xmath2 that contains no holes , and @xmath99 + * output : * the smallest number of flips needed to make @xmath2 feasible under @xmath39 haplotypes .",
    "+ the notion of _ feasible _ generalises easily to @xmath100 haplotypes : an snp matrix @xmath2 is _ feasible _ under @xmath39 haplotypes if @xmath2 can be partitioned into @xmath39 segments such that all the rows within each segment are pairwise non - conflicting .",
    "the definition of @xmath101 also generalises easily to @xmath39 haplotypes ; we define @xmath102 as : @xmath103 we define @xmath104 as the set of unordered optimal @xmath39-tuples of haplotypes for @xmath2 i.e. those @xmath39-tuples of haplotypes which have a @xmath105 score equal to pbmec@xmath106 .",
    "+    [ lem : pbmechard ] pbmec is np - hard +    we reduce from the np - hard problem minimum - vertex - cover .",
    "let @xmath26 be an undirected graph .",
    "a subset @xmath107 is said to _ cover _ an edge @xmath108 iff @xmath109 or @xmath110 .",
    "vertex cover _ of an undirected graph @xmath76 is a subset @xmath111 of the vertices such that every edge in @xmath27 is covered by @xmath111 .",
    "minimum - vertex - cover is the problem of , given a graph @xmath54 , computing the size of a minimum cardinality vertex cover @xmath111 of @xmath54 .",
    "+   + let @xmath76 be the input to minimum - vertex - cover .",
    "we construct an snp matrix @xmath2 as follows .",
    "@xmath2 has @xmath38 columns and @xmath112 rows .",
    "we name the first @xmath113 rows @xmath33 and the remaining @xmath37 rows @xmath114 .",
    "@xmath33 is the matrix obtained by taking the @xmath115 identity matrix ( i.e. 1s on the diagonal , 0s everywhere else ) and making @xmath116 copies of each row . each row in @xmath36 encodes an edge of @xmath54 : the row has 1-entries at the endpoints of the edge , and the rest of the row is 0 .",
    "we argue shortly that , to compute the size of the smallest vertex cover in @xmath54 , we call pbmec(@xmath117 ) for increasing values of @xmath39 ( starting with @xmath118 ) until we first encounter a @xmath39 such that : @xmath119 once the smallest such @xmath39 has been found , we can output that the size of the smallest vertex cover in @xmath54 is @xmath120 .",
    "( actually , if we havent yet found a value @xmath121 satisfying the above equation , we can check by brute force in polynomial - time whether @xmath54 has a vertex cover of size @xmath122 , @xmath62 , @xmath123 , or @xmath38 .",
    "the reason for wanting to ensure that pbmec(@xmath117 ) is not called with @xmath124 is explained later in the analysis . ) +   + it remains only to prove that ( for @xmath121 ) ( [ eq : kmed ] ) holds iff @xmath54 has a vertex cover of size @xmath120 .",
    "+   + to prove this we need to first analyze @xmath125 .",
    "recall that @xmath33 was obtained by duplicating the rows of the @xmath126 identity matrix .",
    "let @xmath127 be shorthand for the @xmath115 identity matrix .",
    "given that @xmath33 is simply a `` scaled up '' version of @xmath127 , it follows that : @xmath128 now , we argue that all the @xmath39-tuples in @xmath129 ( for @xmath121 ) have the following form : one haplotype from the tuple contains only 0s , and the remaining @xmath120 haplotypes from the tuple each have precisely one entry set to 1 .",
    "let us name such a @xmath39-tuple a _ candidate _ tuple .",
    "+    @xmath130     + first , note that @xmath131 , because @xmath132 is the value of the @xmath133 measure - defined in ( [ eq : kmedsum ] ) - under any candidate tuple .",
    "secondly , under an arbitrary @xmath39-tuple there can be at most @xmath39 rows of @xmath127 which contribute 0 to the @xmath133 measure .",
    "however , if precisely @xmath39 rows of @xmath127 contribute 0 to the @xmath133 measure ( i.e. every haplotype has precisely one entry set to 1 , and the haplotypes are all distinct ) then there are @xmath134 rows which each contribute 2 to the @xmath133 measure ; such a @xmath39-tuple can not be optimal because it has a @xmath133 measure of @xmath135 .",
    "so we reason that at most @xmath120 rows contribute 0 to the @xmath133 measure .",
    "in fact , _ precisely _ @xmath120",
    "rows must contribute 0 to the @xmath133 measure because , otherwise , there would be at least @xmath136 rows contributing at least 1 , and this is not possible because @xmath131 .",
    "so @xmath120 of the haplotypes correspond to rows of @xmath127 , and the remaining @xmath132 rows of @xmath127 must each contribute 1 to the @xmath133 measure .",
    "but the only way to do this ( given that @xmath137 ) is to make the @xmath39th haplotype the haplotype where every entry is 0 .",
    "hence : @xmath138 and : @xmath139 @xmath129 ( @xmath140 ) is , by extension , precisely the set of candidate @xmath39-tuples . +   + the next step is to observe that @xmath141 . to see this , suppose ( by way of contradiction ) that it is not true , and there exists a @xmath39-tuple @xmath142 that is not in @xmath143 .",
    "but then replacing @xmath144 by any @xmath39-tuple out of @xmath143 would reduce the number of flips needed in @xmath33 by at least @xmath116 , in contrast to an increase in the number of flips needed in @xmath114 of at most @xmath145 , thus leading to an overall reduction in the number of flips ; contradiction !",
    "( the @xmath145 figure is the number of flips required to make all rows in @xmath36 equal to the all-0 haplotype . ) +   + because @xmath146 , we can restrict our attention to the @xmath39-tuples in @xmath143 .",
    "observe that there is a natural 1 - 1 correspondence between the elements of @xmath143 and all size @xmath120 subsets of @xmath28 : a vertex @xmath147 is in the subset corresponding to @xmath148 iff one of the haplotypes in @xmath144 has a 1 in the column corresponding to vertex @xmath149 .",
    "+   + now , for a @xmath39-tuple @xmath150 we let @xmath151 be the set of edges in @xmath54 which are covered by the subset of @xmath28 corresponding to @xmath144 .",
    "( thus , @xmath152 iff @xmath144 represents a vertex cover of @xmath54 . )",
    "it is easy to check that , for @xmath150 : @xmath153 hence , for @xmath150 , @xmath154 equals @xmath155 iff @xmath144 represents a size @xmath120 vertex cover of @xmath54 .",
    "suppose an snp matrix @xmath2 is feasible .",
    "then we can partition the rows of @xmath2 into two sets , @xmath156 and @xmath157 , such that the rows within each set are pairwise non - conflicting .",
    "( the partition might not be unique . ) from @xmath158 ( @xmath159 ) we can then build a haplotype @xmath160 by combining the rows of @xmath158 as follows : the @xmath5th column of @xmath160 is set to 1 if at least one row from @xmath158 has a 1 in column @xmath5 , is set to 0 if at least one row from @xmath158 has a 0 in column @xmath5 , and is set to a hole if all rows in @xmath158 have a hole in column @xmath5 . note that , in contrast to mec , this leads to haplotypes that potentially contain holes .",
    "for example , suppose one side of the partition contains rows ` 10 , -0 ` and ` 1 ` ; then the haplotype we get from this is ` 10 - 1 ` .",
    "we define the _ length _ of a haplotype @xmath58 , denoted as @xmath161 , as the number of positions where it does not contain a hole ; the haplotype ` 10 - 1 ` thus has length 3 , for example .",
    "now , the objective with lhr is to remove _ rows _ from @xmath2 to make it feasible but also such that the sum of the lengths of the two resulting haplotypes is maximised .",
    "we define the function lhr(m ) ( which gives a natural number as output ) as the largest value this sum - of - lengths value can take , ranging over all feasibility - inducing row - removals and subsequent partitions .",
    "+   + in section [ subsec : lhrpoly ] we provide a polynomial - time dynamic programming algorithm for the ungapped variant of lhr , ungapped - lhr . in section [ subsec : lhrhard ]",
    "we show that lhr becomes apx - hard and np - hard when at most one gap per input row is allowed , automatically also proving the hardness of lhr in the general case .",
    "* problem : * _ ungapped - lhr _ + * input : * an ungapped snp matrix @xmath2 + * output : * the value lhr(m ) , as defined above +   + the lhr problem for ungapped matrices was proved to be polynomial - time solvable by lancia et .",
    "al in @xcite , but only with the genuine restriction that no fragments are included in other fragments .",
    "our algorithm improves this in the sense that it works for all ungapped input matrices ; our algorithm is similar in style to the algorithm that solves mfr in the ungapped case by bafna et .",
    "al . in @xcite .",
    "note that our dynamic - programming algorithm computes ungapped - lhr(m ) but it can easily be adapted to generate the rows that must be removed ( and subsequently , the partition that must be made ) to achieve this value . +    ungapped - lhr can be solved in time @xmath162 +    let @xmath2 be the input to ungapped - lhr , and assume the matrix has size @xmath19 .",
    "for row @xmath4 define @xmath163 as the leftmost column that is not a hole and define @xmath164 as the rightmost column that is not a hole .",
    "the rows of @xmath2 are ordered such that @xmath165 if @xmath46 .",
    "define the matrix @xmath166 as the matrix consisting of the first @xmath4 rows of @xmath2 and two extra rows at the top : row @xmath41 and row @xmath167 , both consisting of all holes .",
    "define @xmath168 as the set of rows @xmath169 that are not in conflict with row @xmath4 .",
    "+   + for @xmath170 and @xmath171 and @xmath172 define @xmath173 $ ] as the maximum sum of lengths of two haplotypes such that :    * each haplotype is built up as a combination of rows from @xmath158 ( in the sense explained above ) ; * each row from @xmath166 can be used to build at most one haplotype ( i.e. it can not be used for both haplotypes ) ; * row @xmath39 is one of the rows used to build a haplotype and among such rows maximises @xmath174 ; * row @xmath175 is one of the rows used to build the haplotype for which @xmath39 is not used and among such rows maximises @xmath176 .",
    "+    the optimal solution of the problem , @xmath177 , is given by : @xmath178.\\ ] ] this optimal solution can be calculated by starting with @xmath179=0 $ ] for @xmath180 and using the following recursive formulas .",
    "we distinguish three different cases , the first is that @xmath181 . under these circumstances : @xmath182=d[h , k;i-1].\\ ] ] this is because :    * if @xmath183 : row @xmath4 can not be used for the haplotype that row @xmath39 is used for , because row @xmath39 has maximal @xmath176 among all rows that are used for a haplotype ; * if @xmath184 : row @xmath4 can not increase the length of the haplotype that row @xmath39 is used for ( because also @xmath185 ) ; * the same arguments hold for @xmath175 .",
    "+    the second case is when @xmath186 ; @xmath187 $ ] is equal to : @xmath188+f(i , j).\\ ] ] where @xmath189 is the increase of the haplotype s length .",
    "equation ( [ eq : lhr ] ) results from the following .",
    "the definition of @xmath187 $ ] says that row @xmath190 has to be used for the haplotype for which @xmath39 is not used and amongst such rows maximises @xmath176 .",
    "therefore , the optimal solution is achieved by adding row @xmath4 to some solution that has a row @xmath5 as the most - right - ending row , for some @xmath5 that agrees with @xmath4 , is not equal to @xmath39 and ends before @xmath4 . adding row @xmath4 to the haplotype leads to an increase of its length of @xmath189 .",
    "this term is fixed , for fixed @xmath4 and @xmath5 and therefore we only have to consider extensions of solutions that were already optimal .",
    "note that this reasoning does not hold for more general , `` gapped '' , data .",
    "+   + the last case is when @xmath191 ; @xmath192 $ ] is equal to : @xmath193+f(i , j)\\text { if } r(h)\\geq r(j),\\\\ d[h , j;i-1]+f(i , j)\\text { if } r(h)<r(j).% \\end{array}% \\right . \\nonumber\\ ] ] the above algorithm can be sped up by using the fact that , as a direct consequence of ( [ eq : lhr1 ] ) , @xmath173=d[h , k;max(h , k)]$ ] for all @xmath194 .",
    "it is thus unnecessary to calculate the values @xmath173 $ ] for @xmath181 .",
    "+   + the time for calculating all the @xmath168 is @xmath195 .",
    "when all the @xmath168 are known , it takes @xmath196 time to calculate all the @xmath197 $ ] .",
    "this is because we need to calculate @xmath198 values @xmath187 $ ] and also @xmath198 values @xmath192 $ ] that take @xmath199 time each .",
    "this leads to an overall time complexity of @xmath11 .",
    "+      * problem : * _ 1-gap lhr _ + * input : * snp matrix @xmath2 with at most one gap per row + * output : * the value lhr(m ) , as defined earlier +   + in this section we prove that 1-gap lhr is apx - hard ( and thus also np - hard . )",
    "we prove this by demonstrating ( indirectly ) an l - reduction from the problem cubic - max - independent - set - the problem of computing the maximum cardinality of an independent set in a cubic graph - which is itself proven apx - hard in @xcite .",
    "+   + we do this in several steps .",
    "we first show an l - reduction from _ single haplotype _",
    "lhr ( sh - lhr ) , the version of lhr where only one haplotype is used must be removed until the remaining rows are mutually non - conflicting .",
    "the length of the resulting single haplotype , which we seek to maximise , is the number of columns ( amongst the remaining rows ) that have at least one non - hole entry .",
    "] , to lhr , such that the number of gaps per rows is unchanged .",
    "we then show an l - reduction from cubic - max - independent - set to 2-gap sh - lhr .",
    "then , using an observation pertaining to the structure of cubic graphs , we show how this reduction can be adapted to give an l - reduction from cubic - max - independent - set to 1-gap sh - lhr .",
    "this proves the apx - hardness of 1-gap sh - lhr and thus ( by transitivity of l - reductions ) also 1-gap lhr .",
    "+    [ lem : shequiv ] sh - lhr is l - reducible to lhr , such that the number of gaps per row is unchanged .",
    "+    let @xmath2 be the @xmath19 input to sh - lhr .",
    "we may assume that @xmath2 contains no duplicate rows , because duplicate rows are entirely redundant when working with only one haplotype .",
    "we map the sh - lhr input , @xmath2 , to the @xmath200 lhr input , @xmath201 , by taking each row of @xmath2 and making a copy of it .",
    "informally , the idea is that the influence of the second haplotype can be neutralised by doubling the rows of the input matrix .",
    "note that this construction clearly preserves the maximum number of gaps per row . +   + now , let @xmath202 be the set that contains all pairs of haplotypes @xmath203 that can be induced by removing some rows of @xmath201 , partitioning the remaining rows of @xmath201 into two mutually non - conflicting sets , and then reading off the two induced haplotypes .",
    "similarly , let @xmath204 be the set that contains all haplotypes @xmath58 that can be induced by removing some rows of @xmath2 ( such that the remaining rows are mutually non - conflicting ) and then reading off the single , induced haplotype . note the following pair of observations , which both follow directly from the construction of @xmath201 : @xmath205 @xmath206 to satisfy the l - reduction we need to show how elements from @xmath202 are mapped back to elements of @xmath204 in polynomial time .",
    "so , let @xmath207 be any pair from @xmath202 . if @xmath208 map the pair @xmath203 to @xmath23 , otherwise to @xmath24 .",
    "this completes the l - reduction , and we now prove its correctness .",
    "central to this is the proof of the following : @xmath209 the fact that sh - lhr(m ) @xmath210 follows immediately from ( [ eq : shl1 ] ) and the mapping described above .",
    "( this lets us fulfil condition [ eq : l1 ] ) of the l - reduction definition , taking @xmath211 . )",
    "the fact that sh - lhr(m ) @xmath212 follows because , by ( [ eq : shl2 ] ) , every element in @xmath204 is guaranteed to have a counterpart in @xmath202 which has a total length twice as large . +   + we can fulfil condition ( [ eq : l2 ] ) of the l - reduction by taking @xmath213 . to see this ,",
    "let @xmath207 be any pair from @xmath202 , and ( wlog ) assume that @xmath214 .",
    "let @xmath215 , the distance of @xmath203 from optimal is then : @xmath216 let @xmath217 , then : @xmath218 thus , taking @xmath219 satisfies condition ( [ eq : l2 ] ) of the l - reduction .",
    "+    [ lem:2gapapx ] 2-gap sh - lhr is apx - hard +    we reduce from cubic - max - independent - set .",
    "let @xmath76 be the undirected , cubic input to cubic - max - independent - set .",
    "we direct the edges of @xmath54 in the manner described by observation [ obs : orient ] , to give @xmath220 .",
    "thus , every vertex of @xmath79 is now out - out - in or in - in - out .",
    "a vertex @xmath221 is a _ child _ of a vertex @xmath149 if there is an edge leaving @xmath149 in the direction of @xmath221 i.e. @xmath222 , and in this case @xmath149 is said to be the _ parent _ of @xmath221 .",
    "+   + let @xmath223 be the number of vertices in @xmath79 that are in - in - out , and @xmath224 be the number of vertices that are out - out - in .",
    "we build a matrix @xmath2 , to be used as input to 2-gap sh - lhr , which has @xmath38 rows and @xmath225 columns .",
    "the construction of @xmath2 is as follows .",
    "( each row of @xmath2 will represent a vertex from @xmath28 , so we henceforth index the rows of @xmath2 using vertices of @xmath28 . ) now , to each in - in - out vertex of @xmath79 , we allocate two _ adjacent _ columns of @xmath2 , and for each out - out - in vertex , we allocate one column of @xmath2 .",
    "( a column may not be allocated to more than one vertex . )",
    ", the ordering is crucial . ] for simplicity , we also impose an arbitrary total order @xmath226 on the vertices of @xmath28 . +   + now , for each vertex @xmath147 , we build row @xmath149 as follows .",
    "firstly , we put 1(s ) in the column(s ) representing @xmath149 .",
    "secondly , consider each child @xmath221 of @xmath149 .",
    "if @xmath221 is an out - out - in vertex , we put a @xmath41 in the column representing @xmath221 .",
    "alternatively , @xmath221 is an in - in - out vertex , so @xmath221 is represented by two columns ; in this case we put a 0 in the left such column ( if @xmath149 comes before the other parent of @xmath221 in the total order @xmath226 ) or , alternatively , in the right column ( if @xmath149 comes after the other parent of @xmath221 in the total order @xmath226 ) .",
    "the rest of the row is holes .",
    "+    l @xmath227 +    [ cols= \" < , < \" , ]      + indeed , from a complexity perspective , the most intriguing open problem is to ascertain the complexity of the `` re - opened '' problem binary - mec .",
    "it would also be interesting to study the approximability of ungapped - mec .",
    "+   + from a more practical perspective , the next logical step is to study the complexity of these problems under more restricted classes of input , ideally under classes of input that have direct biological relevance .",
    "it would also be of interest to study some of these problems in a `` weighted '' context i.e. where the cost of the operation in question ( row removal , column removal , error correction ) is some function of ( for example ) an _ a priori _ specified confidence in the correctness of the data being changed .",
    "we thank leen stougie and judith keijsper for many useful conversations during the writing of this paper .",
    "77 paola alimonti , vigo kann , hardness of approximating problems on cubic graphs , _ proceedings of the third italian conference on algorithms and complexity _ , 288 - 298 ( 1997 ) noga alon , benny sudakov , on two segmentation problems , _ journal of algorithms _ 33 , 173 - 184 ( 1999 ) g. ausiello , p. crescenzi , g. gambosi , v. kann , a. marchetti - spaccamela , m. protasi , complexity and approximation - combinatorial optimization problems and their approximability properties , springer verlag ( 1999 ) vineet bafna , sorin istrail , giuseppe lancia , romeo rizzi , polynomial and apx - hard cases of the individual haplotyping problem , _ theoretical computer science _ , 335(1 ) , 109 - 125 ( 2005 ) piotr berman , marek karpinski , on some tighter inapproximability results ( extended abstract ) , proceedings of the 26th international colloquium on automata , languages and programming , 200 - 209 ( 1999 ) paola bonizzoni , gianluca della vedova , riccardo dondi , jing li , the haplotyping problem : an overview of computational models and solutions , _ journal of computer science and technology _ 18(6 ) , 675 - 688 ( november 2003 ) p. drineas , a. frieze , r. kannan , s. vempala , v. vinay , clustering in large graphs via singular value decomposition , _ journal of machine learning _ 56 , 9 - 33 ( 2004 ) harvey j. greenberg , william e. hart , giuseppe lancia , opportunities for combinatorial optimisation in computational biology , _ informs journal on computing _ , 16(3 ) , 211 - 231 ( 2004 ) bjarni v. halldorsson , vineet bafna , nathan edwards , ross lippert , shibu yooseph , and sorin istrail , a survey of computational methods for determining haplotypes , _ proceedings of the first recomb satellite on computational methods for snps and haplotype inference _ , springer lecture notes in bioinformatics , lnbi 2983 , pp .",
    "26 - 47 ( 2003 ) hoogeveen , j.a . ,",
    "schuurman , p. , and woeginger , g.j .",
    ", non - approximability results for scheduling problems with minsum criteria , _ informs journal on computing _ , 13(2 ) , 157 - 168 ( spring 2001 ) yishan jiao , jingyi xu , ming li , on the k - closest substring and k - consensus pattern problems , _ combinatorial pattern matching : 15th annual symposium _ ( cpm 2004 ) 130 - 144 jon kleinberg , christos papadimitriou , prabhakar raghavan , segmentation problems , _ proceedings of stoc 1998 _ , 473 - 482 ( 1998 ) jon kleinberg , christos papadimitriou , prabhakar raghavan , a microeconomic view of data mining , _ data mining and knowledge discovery _ 2 , 311 - 324 ( 1998 ) jon kleinberg , christos papadimitriou , prabhakar raghavan , segmentation problems , _ journal of the acm _",
    "51(2 ) , 263 - 280 ( march 2004 ) note : this paper is somewhat different to the 1998 version .",
    "giuseppe lancia , vineet bafna , sorin istrail , ross lippert , and russel schwartz , snps problems , complexity and algorithms , _ proceedings of the 9th annual european symposium on algorithms _ , 182 - 193 ( 2001 ) giuseppe lancia , maria christina pinotti , romeo rizzi , haplotyping populations by pure parsimony : complexity of exact and approximation algorithms , _ informs journal on computing _ , vol . 16 , no.4 , 348 - 359 ( fall 2004 ) giuseppe lancia , romeo rizzi , a polynomial solution to a special case of the parsimony haplotyping problem , to appear in _",
    "operations research letters _ rafail ostrovsky and yuval rabani , polynomial - time approximation schemes for geometric min - sum median clustering , _ journal of the acm _",
    "49(2 ) , 139 - 156 ( march 2002 ) alessandro panconesi and mauro sozio , fast hare : a fast heuristic for single individual snp haplotype reconstruction , _ proceedings of 4th workshop on algorithms in bioinformatics _",
    "( wabi 2004 ) , lncs springer - verlag , 266 - 277 personal communication with christos h. papadimitriou , june 2005 c.h .",
    "papadimitriou and m. yannakakis , optimization , approximation , and complexity classes , _ journal of computer and system sciences _ 43 , 425 - 440 ( 1991 ) romeo rizzi , vineet bafna , sorin istrail , giuseppe lancia : practical algorithms and fixed - parameter tractability for the single individual snp haplotyping problem , _",
    "2nd workshop on algorithms in bioinformatics _",
    "( wabi 2002 ) 29 - 43    rudi cilibrasi received his bachelor s degree at caltech in 1996 .",
    "he spent several years in industry doing network programming , linux kernel programming , and a variety of software development work until returning to academia with cwi in 2001 .",
    "he is now nearing completion of his doctoral work that has been largely concerned with robust methods of approximating bioinformatics and related clustering problems .",
    "he currently maintains complearn ( http://complearn.org/ ) , an open - source data - mining package that can be used for phylogenetic tree construction .",
    "leo van iersel received in 2004 his master of science degree in applied mathematics from the universiteit twente in the netherlands .",
    "he is now working as a phd student at the technische universiteit eindhoven , also in the netherlands .",
    "his research is mainly concerned with the search for combinatorial algorithms for biological problems .",
    "steven kelk received his phd in computer science in 2004 from the university of warwick , in england .",
    "he is now working as a postdoc at the centrum voor wiskunde en informatica ( cwi ) in amsterdam , the netherlands , where he is focussing on the combinatorial aspects of computational biology .",
    "john tromp received the bachelor s and phd degrees in computer science from the university of amsterdam in 1989 and 1993 respectively , where he studied with paul vitnyi .",
    "he then spent two years as a postdoctoral fellow with ming li at the university of waterloo in canada . in 1996",
    "he returned as a postdoc to the centre for mathematics and computer science ( cwi ) in amsterdam .",
    "he spent 2001 working as software developer at bioinformatics solutions inc . in waterloo , to return once more to cwi , where he currently holds a permanent position .",
    "he is the recipient of a canada international fellowship .",
    "see http://www.cwi.nl/  tromp/ for more information .",
    "[ lem : int ] mec and constructive - mec are polynomial - time turing interreducible .",
    "( also : binary - mec and binary - constructive - mec are polynomial - time turing interreducible . )",
    "+    we show interreducibility of mec and constructive - mec in such a way that the interreducibility of binary - mec with binary - constructive - mec also follows immediately from the reduction .",
    "this makes the reduction from constructive - mec to mec quite complicated because we must thus avoid the use of holes .",
    "reducing mec to constructive - mec is trivial because , given an optimal haplotype pair @xmath207 , @xmath228 can easily be computed in polynomial - time by summing @xmath229 over all rows @xmath230 of the input matrix @xmath2 .",
    "reducing constructive - mec to mec is more involved . to prevent a particular special case which could complicate our reduction",
    ", we first check whether every row of @xmath2 ( i.e. the input to constructive - mec ) is identical .",
    "if this is so , we can complete the reduction by simply returning @xmath231 where @xmath23 is the first row of @xmath2 .",
    "hence , from this point onwards , we assume that @xmath2 has at least two distinct rows .",
    "+   + let @xmath232 be the set of all unordered optimal haplotype pairs for @xmath2 i.e. the set of all @xmath207 such that @xmath233 .",
    "given that all rows in @xmath2 are not identical , we observe that there are no pairs of the form @xmath231 in @xmath232 .",
    "is always larger than @xmath234 for any row @xmath230 in @xmath2 that is not equal to @xmath23 .",
    "] let @xmath235 be those elements @xmath236 such that @xmath237 or @xmath238 .",
    "let @xmath239 be defined as @xmath240 .",
    "+   + consider the following two subroutines : +   + * subroutine : * _ dfn _ ( `` distance from nearest optimal haplotype pair '' ) + * input : * an @xmath19 snp matrix @xmath2 and a vector @xmath241 . +",
    "* output : * the value @xmath242 which we define as follows : @xmath243 + * subroutine : * _ anchored - dfn _ ( `` anchored distance from nearest optimal haplotype pair '' ) + * input : * an @xmath19 snp matrix @xmath2 , a vector @xmath244 , and a haplotype @xmath245 such that @xmath246 for some @xmath24 . + * output : * the value @xmath247 , defined as : @xmath248 + we assume the existence of implementations of dfn and anchored - dfn which run in polynomial - time whenever mec runs in polynomial - time .",
    "we use these two subroutines to reduce constructive - mec to mec and then , to complete the proof , demonstrate and prove correcteness of implementations for dfn and anchored - dfn .",
    "+   + the general idea of the reduction from constructive - mec to mec is to find some pair @xmath249 by first finding @xmath23 ( using repeated calls to dfn ) and then finding @xmath24 ( by using repeated calls to anchored - dfn with @xmath23 specified as the `` anchoring '' haplotype . ) throughout the reduction , the following two observations are important .",
    "both follow immediately from the definition of @xmath133 - i.e. ( [ eq : witsum ] ) .",
    "+        to begin the reduction , note that , for an arbitrary haplotype @xmath17 , dfn@xmath254 iff @xmath255 for some haplotype @xmath24 .",
    "our idea is thus that we initialise @xmath17 to be all-0 and flip one entry of @xmath17 at a time ( i.e. change a 0 to a 1 or vice - versa ) until dfn@xmath254 ; at that point @xmath256 ( for some @xmath249 . )",
    "more specifically , suppose dfn@xmath257 where @xmath258 .",
    ", because all @xmath249 are of the form @xmath259 , and if @xmath259 we know that @xmath260 . ]",
    "if we define @xmath261 as the haplotype obtained by flipping the entry in the @xmath4th column of @xmath17 , then we know that there exists @xmath4 ( @xmath262 ) such that dfn@xmath263 .",
    "such a position must exist because we can flip some entry in @xmath17 to bring it closer to the haplotype ( which we know exists ) that it was distance @xmath264 from .",
    "it is clear that we can find a position @xmath4 in polynomial - time by calling dfn@xmath265 for @xmath266 until it is found .",
    "having found such an @xmath4 , we set @xmath267 .",
    "+   + clearly this process can be iterated , finding one entry to flip in every iteration , until dfn@xmath254 and at this point setting @xmath268 gives us the desired result .",
    "given that dfn@xmath269 decreases by at least 1 every iteration , at most @xmath270 iterations are required .",
    "+   + thus , having found @xmath23 , we need to find some @xmath24 such that @xmath207 is in @xmath232 .",
    "+   + first , we initialise @xmath17 to be the complement of @xmath23 ( i.e. the row obtained by flipping every entry of @xmath23 ) .",
    "now , observe that if @xmath271 and anchored - dfn@xmath272 then @xmath273 and we are finished .",
    "the tactic is thus to find , at each iteration , some position @xmath4 of @xmath17 such that anchored - dfn@xmath274 is less than anchored - dfn@xmath275 , and then setting @xmath17 to be @xmath261 . as before we repeat this process until our call to anchored - dfn returns zero .",
    "the `` trick '' in this case is to prevent @xmath17 converging on @xmath23 , because ( knowing that @xmath2 has at least two different types of row ) @xmath276 .",
    "the initialisation of @xmath17 to the complement of @xmath23 guarantees this . to see why this is ,",
    "observe that , if @xmath17 is the complement of @xmath23 , @xmath277 .",
    "thus , we would need at least @xmath13 flips to transform @xmath17 into @xmath23 .",
    "however , if @xmath17 is the complement of @xmath23 , then - because we have guaranteed that @xmath232 contains no pairs of the form @xmath278 - we know that anchored - dfn@xmath279 . given that we can guarantee that anchored - dfn@xmath280 can be reduced by at least 1 at every iteration , it is clear that we can find an @xmath17 such that anchored - dfn@xmath281 after making no more than @xmath270 iterations , which ensures that @xmath17 can not have been transformed into @xmath23 .",
    "once we have such an @xmath17 we can set @xmath282 and return @xmath207 .",
    "+   + to complete the proof of lemma [ lem : int ] it remains only to demonstrate and prove the correctness of algorithms for dfn and anchored - dfn , which we do below .",
    "note that both dfn and anchored - dfn run in polynomial - time if mec runs in polynomial - time .",
    "+   + * subroutine : * _ dfn _ ( `` distance from nearest optimal haplotype pair '' ) + * input : * an @xmath19 snp matrix @xmath2 and a vector @xmath241 . + * output : * the value @xmath242 which we define as follows : @xmath243 the following is a three - step algorithm to compute dfn(m , r ) which uses an oracle for mec . +   + 1 .",
    "compute @xmath283mec@xmath284 .",
    "let @xmath201 be the @xmath285 matrix obtained from @xmath2 by making @xmath286 copies of every row of @xmath2 .",
    "return mec@xmath287 where @xmath288 is the matrix obtained by adding the single row @xmath230 to the matrix @xmath201 .",
    "+   + to prove the correctness of the above we first make a further observation , which ( as with the two previous observations ) follows directly from ( [ eq : witsum ] ) .",
    "+      by the above observation we know that mec@xmath293 and @xmath294 .",
    "now , we argue that @xmath295 . to see why this is ,",
    "suppose there existed @xmath296 such that @xmath297 but @xmath298 .",
    "this would mean @xmath299 where @xmath283mec@xmath284 .",
    "now : @xmath300 however , if we take any @xmath249 , we see that : @xmath301 now , @xmath302 so @xmath296 could not possibly be in @xmath303 - contradiction ! the relationship @xmath304 thus follows .",
    "it further follows , from observation [ obs : expand ] , that the members of @xmath303 are precisely those pairs @xmath249 that minimise the expression @xmath305 .",
    "the minimal value of @xmath239 has already been defined as @xmath242 , so we have : @xmath306 this proves the correctness of step 3 of the subroutine .",
    "+   + * subroutine : * _ anchored - dfn _ ( `` anchored distance from nearest optimal haplotype pair '' ) + * input : * an @xmath19 snp matrix @xmath2 , a vector @xmath244 , and a haplotype @xmath245 such that @xmath246 for some @xmath24 . +",
    "* output : * the value @xmath247 , defined as : @xmath248 given that @xmath245 is one half of some optimal haplotype pair for @xmath2 , it can be shown that anchored - dfn@xmath307 = dfn@xmath308 , thus demonstrating how anchored - dfn can be easily reduced to dfn in polynomial - time . to prove the equation it is sufficient to demonstrate that @xmath309 , which we do now",
    "let @xmath310mec@xmath284 .",
    "it follows that mec@xmath311 . in fact , mec@xmath312 because @xmath313 for all @xmath314 .",
    "hence @xmath315 . to prove the other direction ,",
    "suppose there existed some pair @xmath316 such that @xmath317 and @xmath318 .",
    "but then , from observation [ obs : expand ] , we would have : @xmath319 thus , @xmath207 could not have been in @xmath320 in the first place , giving us a contradiction .",
    "thus @xmath321 and hence @xmath322 , proving the correctness of subroutine anchored - dfn ."
  ],
  "abstract_text": [
    "<S> we present several new results pertaining to haplotyping . </S>",
    "<S> these results concern the combinatorial problem of reconstructing haplotypes from incomplete and/or imperfectly sequenced haplotype fragments . </S>",
    "<S> we consider the complexity of the problems _ minimum error correction _ </S>",
    "<S> ( mec ) and _ longest haplotype reconstruction _ ( lhr ) for different restrictions on the input data . </S>",
    "<S> specifically , we look at the _ gapless _ case , where every row of the input corresponds to a gapless haplotype - fragment , and the _ 1-gap _ case , where at most one gap per fragment is allowed . we prove that mec is apx - hard in the 1-gap case and still np - hard in the gapless case . </S>",
    "<S> in addition , we question earlier claims that mec is np - hard even when the input matrix is restricted to being completely binary . concerning lhr , </S>",
    "<S> we show that this problem is np - hard and apx - hard in the 1-gap case ( and thus also in the general case ) , but is polynomial time solvable in the gapless case .    </S>",
    "<S> combinatorial algorithms , biology and genetics , complexity hierarchies </S>"
  ]
}