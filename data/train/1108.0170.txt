{
  "article_text": [
    "in safety - critical systems implement complex algorithms and feedback laws that control the interaction of physical devices with their environments .",
    "examples of such systems are abundant in aerospace , automotive , and medical applications .",
    "the range of theoretical and practical issues that arise in analysis , design , and implementation of safety - critical software systems is extensive , see , e.g. , @xcite , @xcite , and @xcite .",
    "while safety - critical software must satisfy various resource allocation , timing , scheduling , and fault tolerance constraints , the foremost requirement is that it must be free of run - time errors .",
    "formal verification methods are model - based techniques @xcite , @xcite , @xcite for proving or disproving that a mathematical model of a software ( or hardware ) satisfies a given _ specification , _",
    "i.e. , a mathematical expression of a desired behavior .",
    "the approach adopted in this paper too , falls under this category .",
    "herein , we briefly review _ model checking _ and _ abstract _ _ interpretation_.    [ [ model - checking ] ] model checking + + + + + + + + + + + + + +    in _ model checking _",
    "@xcite the system is modeled as a finite state transition system and the specifications are expressed in some form of logic formulae , e.g. , temporal or propositional logic .",
    "the verification problem then reduces to a graph search , and symbolic algorithms are used to perform an exhaustive exploration of all possible states .",
    "model checking has proven to be a powerful technique for verification of circuits @xcite , security and communication protocols @xcite , @xcite and stochastic processes @xcite . nevertheless , when the program has non - integer variables , or when the state space is continuous , model checking is not directly applicable . in such cases ,",
    "combinations of various abstraction techniques and model checking have been proposed @xcite ; scalability , however , remains a challenge .",
    "[ [ abstract - interpretation ] ] abstract interpretation + + + + + + + + + + + + + + + + + + + + + + +    is a theory for formal approximation of the _ operational semantics _ of computer programs in a systematic way @xcite .",
    "construction of abstract models involves abstraction of domains****typically in the form of a combination of sign , interval , polyhedral , and congruence abstractions of sets of data****and functions .",
    "a system of fixed - point equations is then generated by symbolic forward / backward executions of the abstract model .",
    "an iterative equation solving procedure , e.g. , newton s method , is used for solving the nonlinear system of equations , the solution of which results in an inductive invariant assertion , which is then used for checking the specifications . in practice , to guarantee finite convergence of the iterates , narrowing ( outer approximation ) operators are used to estimate the solution , followed by widening ( inner approximation ) to improve the estimate @xcite .",
    "this compromise can be a source of conservatism in analysis .",
    "nevertheless , these methods have been used in practice for verification of limited properties of embedded software of commercial aircraft @xcite .",
    "alternative formal methods can be found in the computer science literature mostly under _ deductive verification _",
    "@xcite , _ type inference _",
    "@xcite _ _ , _ _ and _ data flow analysis _ @xcite .",
    "these methods share extensive similarities in that a notion of program abstraction and symbolic execution or constraint propagation is present in all of them .",
    "further details and discussions of the methodologies can be found in @xcite , and @xcite .",
    "while software analysis has been the subject of an extensive body of research in computer science , treatment of the topic in the control systems community has been less systematic .",
    "the relevant results in the systems and control literature can be found in the field of hybrid systems @xcite .",
    "much of the available techniques for safety verification of hybrid systems are explicitly or implicitly based on computation of the reachable sets , either exactly or approximately .",
    "these include but are not limited to techniques based on quantifier elimination @xcite , ellipsoidal calculus @xcite , and mathematical programming @xcite .",
    "alternative approaches aim at establishing properties of hybrid systems through barrier certificates @xcite , numerical computation of lyapunov functions @xcite , or by combined use of bisimulation mechanisms and lyapunov techniques @xcite .    inspired by the concept of lyapunov functions in stability analysis of nonlinear dynamical systems @xcite , in this paper we propose lyapunov invariants for analysis of computer programs . while lyapunov functions and similar concepts have been used in verification of stability or temporal properties of system level descriptions of hybrid systems @xcite , @xcite , @xcite , to the best of our knowledge",
    ", this paper is the first to present a systematic framework based on lyapunov invariance and convex optimization for verification of a broad range of code - level specifications for computer programs .",
    "accordingly , it is in the systematic integration of new ideas and some well - known tools within a unified software analysis framework that we see the main contribution of our work , and not in carrying through the proofs of the underlying theorems and propositions .",
    "the introduction and development of such framework provides an opportunity for the field of _ control _ to systematically address a problem of great practical significance and interest to both computer science and engineering communities .",
    "the framework can be summarized as follows:@xmath0    1 .",
    "dynamical system interpretation and modeling ( section [ modeling ] ) .",
    "we introduce generic dynamical system representations of programs , along with specific modeling languages which include mixed - integer linear models ( milm ) , graph models , and mil - over - graph hybrid models ( mil - ghm ) .",
    "lyapunov invariants as behavior certificates for computer programs ( section [ chapter : lyapunovinvs ] ) .",
    "analogous to a lyapunov function , a lyapunov invariant is a real - valued function of the program variables , and satisfies a _ difference inequality _  along the trace of the program .",
    "it is shown that such functions can be formulated for verification of various specifications .",
    "3 .   a computational procedure for finding the lyapunov invariants ( section [ chapter : computation ] ) . the procedure is standard and constitutes  these steps : ( i ) restricting the search space to a linear subspace .",
    "( ii ) using convex relaxation techniques to formulate the search problem as a convex optimization problem , e.g. , a linear program @xcite , semidefinite program @xcite , or a sos program @xcite . (",
    "iii ) using convex optimization software for numerical computation of the certificates.@xmath1",
    "we interpret computer programs as discrete - time dynamical systems and introduce generic models that formalize this interpretation .",
    "we then introduce milms , graph models , and mil - ghms as structured cases of the generic models .",
    "the specific modeling languages are used for computational purposes.@xmath3        we will consider generic models defined by a finite state space set @xmath4 with selected subsets @xmath5 of initial states , and @xmath6 of terminal states , and by a set - valued state transition function @xmath7 , such that @xmath8 we denote such dynamical systems by @xmath9    [ concreterepdef]the dynamical system @xmath10 is a @xmath11-representation of a computer program @xmath12 if the set of all sequences that can be generated by @xmath13 is equal to the set of all sequences @xmath14 of elements from @xmath15 satisfying@xmath16 the uncertainty in @xmath17 allows for dependence of the program on different initial conditions , and the uncertainty in @xmath18 models  dependence on parameters , as well as the ability to respond to real - time inputs .",
    "[ integerdiv - ex]*integer division * ( adopted from @xcite ) :  the functionality of program 1 is to compute the result of the integer division of @xmath19 ( dividend ) by @xmath20 ( divisor ) .",
    "a @xmath11-representation of the program is displayed alongside .",
    "note that if @xmath21 and @xmath22 then the program never exits the while  loop and the value of @xmath23 keeps increasing , eventually leading to either an overflow or an erroneous answer .",
    "the program terminates  if @xmath19 and @xmath20 are positive .    @xmath24{cl}% \\begin{tabular } [ c]{|l|}\\hline $ % \\begin{array } [ c]{l}% \\mathrm{int~integerdivision~(~int~dd , int~dr~)}\\\\ \\vspace*{-0.46in}\\\\ \\mathrm{\\{int~q=\\{0\\};~int~r=\\{dd\\};}\\\\ \\vspace*{-0.46in}\\\\ \\mathrm{{while}\\text { } { ( r>=dr)}}\\\\ \\vspace*{-0.46in}\\\\ \\mathrm{{{{\\{\\hspace{0.13in}q = q+1;}}}}\\\\ \\vspace*{-0.46in}\\\\ \\mathrm{{{\\hspace{0.24in}r = r - dr;\\}}}}\\\\ \\vspace*{-0.46in}\\\\ \\mathrm{return~r;\\}}% \\end{array } $ \\\\\\hline \\end{tabular } & \\hspace*{-0.05in}% \\begin{tabular } [ c]{|l|}\\hline $ % \\begin{array } [ c]{l}% \\underline{\\mathbb{z}}=\\mathbb{z\\cap}\\left [   -32768,32767\\right ] \\\\",
    "\\vspace*{-0.46in}\\\\ x=\\underline{\\mathbb{z}}^{4}\\\\ \\vspace*{-0.46in}\\\\ x_{0}=\\left\\ {   ( \\mathrm{dd},\\mathrm{dr},\\mathrm{q},\\mathrm{r})\\in x~|~\\mathrm{q}=0,\\text { } \\mathrm{r}=\\mathrm{dd}\\right\\ } \\\\ \\vspace*{-0.46in}\\\\ x_{\\infty}=\\left\\ {   ( \\mathrm{dd},\\mathrm{dr},\\mathrm{q},\\mathrm{r})\\in x~|~\\mathrm{r}<\\mathrm{dr}\\right\\ }",
    "\\\\ \\vspace*{-0.35in}\\\\ f:(\\mathrm{dd},\\mathrm{dr},\\mathrm{q},\\mathrm{r})\\mapsto\\left\\ { \\begin{array } [ c]{l}% \\vspace*{-0.44in}\\\\ ( \\mathrm{dd},\\mathrm{dr},\\mathrm{q}+\\mathrm{1},\\mathrm{r}-\\mathrm{dr}),\\\\ \\vspace*{-0.44in}\\\\ ( \\mathrm{dd},\\mathrm{dr},\\mathrm{q},\\mathrm{r } ) , \\end{array } \\right .",
    "\\begin{array } [ c]{l}% \\vspace*{-0.44in}\\\\ ( \\mathrm{dd},\\mathrm{dr},\\mathrm{q},\\mathrm{r})\\in x\\backslash x_{\\infty}\\\\ \\vspace*{-0.44in}\\\\ ( \\mathrm{dd},\\mathrm{dr},\\mathrm{q},\\mathrm{r})\\in x_{\\infty}% \\end{array } \\end{array } $ \\\\\\hline \\end{tabular } \\end{array } \\\\",
    "\\text{{program 1 : the integer division program ( left ) and its dynamical system model ( right)\\vspace*{-0.2in}}}%\\end{gathered}\\ ] ]      in a @xmath11-representation , the elements of the state space @xmath4 belong to a finite subset of the set of rational numbers that can be represented by a fixed number of bits in a specific arithmetic framework , e.g. , fixed - point or floating - point arithmetic . when the elements of @xmath4 are non - integers , due to the quantization effects , the set - valued map @xmath18 often defines very complicated dependencies between the elements of @xmath15 even for simple programs involving only elementary arithmetic operations .",
    "an abstract model over - approximates the behavior set in the interest of tractability .",
    "the drawbacks are conservatism of the analysis and ( potentially ) undecidability .",
    "nevertheless , abstractions in the form of formal over - approximations make it possible to formulate computationally tractable , sufficient conditions for a verification problem that would otherwise be intractable .",
    "[ def : abst]given a program @xmath13 and its @xmath25-representation @xmath10 , we say that @xmath26 is an @xmath27-representation , i.e. , an _ abstraction _ of @xmath13 , if @xmath28 , @xmath29 , and @xmath30  for all @xmath31 and the following condition holds:@xmath32    thus , every trajectory of the actual program is also a trajectory of the abstract model .",
    "the definition of @xmath33 is slightly more subtle . for proving finite - time termination ( ftt ) , we need to be able to infer that if all the trajectories of @xmath34 eventually enter @xmath35 then all trajectories of @xmath36 will eventually enter @xmath37 it is tempting to require that @xmath38 , however , this may not be possible as @xmath39 is often a discrete set , while @xmath33 is dense in the domain of real numbers .",
    "the definition of @xmath33 as in ( [ terminalabstract ] ) resolves this issue .",
    "construction of @xmath40 from @xmath10 involves abstraction of each of the elements @xmath41 in a way that is consistent with definition [ def : abst ] .",
    "abstraction of the state space @xmath4 often involves replacing the domain of _ floats _ or integers or a combination of these by the domain of real numbers .",
    "abstraction of @xmath42 or @xmath39 often involves a combination of domain abstractions and abstraction of functions that define these sets .",
    "semialgebraic set - valued abstractions of some commonly - used nonlinearities are presented in appendix i. interested readers may refer to @xcite for more examples including abstractions of fixed - point and floating point operations .",
    "specific modeling languages are particularly useful for automating the proof process in a computational framework . here , three specific modeling languages are proposed : _ mixed - integer linear models ( milm ) , _ _ graph models _ , and _ mixed - integer linear over graph hybrid models ( mil - ghm ) .",
    "_      proposing milms for software modeling and analysis is motivated by the observation that by imposing linear equality constraints on boolean and continuous variables over a quasi - hypercube , one can obtain a relatively compact representation of arbitrary piecewise affine functions defined over compact polytopic subsets of euclidean spaces ( proposition [ milm - prop ] ) . the earliest reference to the statement of universality of milms appears to be @xcite , in which a constructive proof is given for the one - dimensional case . a constructive proof for the general case is given in @xcite .",
    "[ milm - prop]*universality of mixed - integer linear models .",
    "* let @xmath43 be a piecewise affine map with a closed graph , defined on a compact state space @xmath44   ^{n},$ ] consisting of a finite union of compact polytopes .",
    "that is:@xmath45 where , each @xmath46 is a compact polytopic set .",
    "then , @xmath18 can be specified precisely , by imposing linear equality constraints on a finite number of binary and continuous variables ranging over compact intervals .",
    "specifically , there exist matrices @xmath47 and @xmath48 such that the following two sets are equal:@xmath49{cccc}% \\hspace*{-0.04in}\\vspace*{0.04in}x\\hspace*{-0.02 in } & \\hspace*{-0.02in}% w\\hspace*{-0.02 in } & \\hspace*{-0.02in}v\\hspace*{-0.02 in } & \\hspace * { -0.02in}1\\hspace*{-0.04in}% \\end{array } ] ^{^{t}}=y,\\text { } h[% \\begin{array } [ c]{cccc}% \\hspace*{-0.04in}\\vspace*{0.04in}x\\hspace*{-0.02 in } & \\hspace*{-0.02in}% w\\hspace*{-0.02 in } & \\hspace*{-0.02in}v\\hspace*{-0.02 in } & \\hspace * { -0.02in}1\\hspace*{-0.04in}% \\end{array } ] ^{^{t}}=0,\\text { } \\left (   w , v\\right )   \\in\\left [   -1,1\\right ]   ^{n_{w}}% \\times\\left\\ {   -1,1\\right\\ }   ^{n_{v}}\\}\\end{aligned}\\ ] ]    mixed logical dynamical systems ( mlds ) with similar structure were considered in @xcite for analysis of a class of hybrid systems .",
    "the main contribution here is in the application of the model to software analysis . a mil model of a computer program",
    "is defined via the following elements :    1 .",
    "the state space @xmath50   ^{n}$ ] .",
    "2 .   letting @xmath51 the state transition function @xmath7  is defined by two matrices @xmath52  and @xmath53  of dimensions @xmath54-by-@xmath55  and @xmath56-by-@xmath55  respectively , according to : @xmath57{cccc}% \\hspace*{-0.04in}\\vspace*{0.04in}x\\hspace*{-0.02 in } & \\hspace*{-0.02in}% w\\hspace*{-0.02 in } & \\hspace*{-0.02in}v\\hspace*{-0.02 in } & \\hspace * { -0.02in}1\\hspace*{-0.04in}% \\end{array } ] ^{^{t}}~|~~h[% \\begin{array } [ c]{cccc}% \\hspace*{-0.04in}\\vspace*{0.04in}x\\hspace*{-0.02 in } & \\hspace*{-0.02in}% w\\hspace*{-0.02 in } & \\hspace*{-0.02in}v\\hspace*{-0.02 in } & \\hspace * { -0.02in}1\\hspace*{-0.04in}% \\end{array } ] ^{^{t}}=0,\\text { } \\left (   w , v\\right )   \\in\\left [   -1,1\\right ]   ^{n_{w}}% \\times\\left\\ {   -1,1\\right\\ }   ^{n_{v}}\\right\\ }   .\\vspace*{-0.2in}\\label{milm1}%\\ ] ] 3 .",
    "the set of initial conditions is defined via either of the following : 1 .",
    "if @xmath42  is finite with a small cardinality , then it can be conveniently specified by its elements .",
    "we will see in section [ chapter : computation ] that per each element of @xmath58  one constraint needs to be included in the set of constraints of the optimization problem associated with the verification task .",
    "if @xmath42  is not finite , or @xmath59  is too large , an abstraction of @xmath42  can be specified by a matrix @xmath60  which defines a union of compact polytopes in the following way:@xmath61{cccc}% \\hspace*{-0.04in}\\vspace*{0.04in}x\\hspace*{-0.02 in } & \\hspace*{-0.02in}% w\\hspace*{-0.02 in } & \\hspace*{-0.02in}v\\hspace*{-0.02 in } & \\hspace * { -0.02in}1\\hspace*{-0.04in}% \\end{array } ] ^{^{t}}=0,~\\left (   w , v\\right )   \\in\\left [   -1,1\\right ]   ^{n_{w}}\\times\\left\\ { -1,1\\right\\ }   ^{n_{v}}\\}.\\vspace*{-0.1in}\\label{milm2}%\\ ] ] 4 .",
    "the set of terminal states @xmath39  is defined by@xmath62{cccc}% \\hspace*{-0.04in}\\vspace*{0.04in}x\\hspace*{-0.02 in } & \\hspace*{-0.02in}% w\\hspace*{-0.02 in } & \\hspace*{-0.02in}v\\hspace*{-0.02 in } & \\hspace * { -0.02in}1\\hspace*{-0.04in}% \\end{array } ] ^{^{t}}\\neq0,~\\forall w\\in\\left [   -1,1\\right ]   ^{n_{w}},~\\forall v\\in\\left\\ { -1,1\\right\\ }   ^{n_{v}}\\}.\\vspace*{-0.2in}\\label{milm3}%\\ ] ]    therefore , @xmath10 is well defined .",
    "a compact description of a milm of a program is either of the form @xmath63 or of the form @xmath64 .",
    "the milms can represent a broad range of computer programs of interest in control applications , including but not limited to control programs of gain scheduled linear systems in embedded applications .",
    "in addition , generalization of the model to programs with piecewise affine dynamics subject to quadratic constraints is straightforward .",
    "a milm of an abstraction of the integerdivision program ( program 1 : section [ sec : genrep])@xmath65 with all the integer variables replaced with real variables , is given by @xmath66 where@xmath67@xmath68{lll}%",
    "h_{0}= & h= & f=\\\\ \\left [ \\begin{array } [ c]{rrrrrrrr}% \\vspace*{-0.42 in } &   &   &   &   &   &   & \\\\ 1 & 0 & 0 & -1 & 0 & 0 & 0 & 0\\vspace*{-0.12in}\\\\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\vspace*{-0.12in}\\\\ 0 & -2 & 0 & 0 & 0 & 1 & 0 & 1\\vspace*{-0.12in}\\\\ -2 & 0 & 0 & 0 & 0 & 0 & 1 & 1\\vspace*{-0.07in}% \\end{array } \\right ]   , & \\left [   \\hspace*{-0.05in}% \\begin{array } [ c]{rrrrrrrr}% \\vspace*{-0.42 in } &   &   &   &   &   &   & \\\\ 0 & 2 & 0 & -2 & 1 & 0 & 0 & 1\\vspace*{-0.12in}\\\\ 0 & -2 & 0 & 0 & 0 & 1 & 0 & 1\\vspace*{-0.12in}\\\\ -2 & 0 & 0 & 0 & 0 & 0 & 1 & 1\\vspace*{-0.07in}% \\end{array } \\hspace*{-0.05in}\\right ]   , & \\left [ \\begin{array } [ c]{rrrrrrrr}% \\vspace*{-0.42 in } &   &   &   &   &   &   & \\\\ 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\vspace*{-0.12in}\\\\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\vspace*{-0.12in}\\\\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1/m\\vspace*{-0.12in}\\\\ 0 & -1 & 0 & 1 & 0 & 0 & 0 & 0\\vspace*{-0.07in}% \\end{array } \\right ] \\end{array}\\ ] ] here , @xmath69 is a scaling parameter used for bringing all the variables within the interval @xmath70",
    ".\\vspace*{-0.05in}$ ]      practical considerations such as universality and strong resemblance to the natural flow of computer code render graph models an attractive and convenient model for software analysis . before we proceed , for convenience , we introduce the following notation : @xmath71 denotes the projection operator defined as @xmath72 for all @xmath73 and all @xmath74    a graph model is defined on a directed graph @xmath75 with the following elements :    1 .   a set of nodes @xmath76 these can be thought of as line numbers or code locations .",
    "nodes @xmath77 and @xmath78 are starting and terminal nodes , respectively .",
    "the only possible transition from node @xmath78 is the identity transition to node @xmath79 2 .   a set of edges @xmath80 where the _ outgoing set _",
    "@xmath81 is the set of all nodes to which transition from node @xmath82 is possible in one step .",
    "definition of the _ incoming set _",
    "@xmath83 is analogous .",
    "the third element in the triplet @xmath84 is the index for the @xmath85th edge between @xmath82 and @xmath86 and @xmath87 3 .",
    "a set of program variables @xmath88 @xmath89 given @xmath90 and @xmath54 , the state space of a graph model is @xmath91 .",
    "the state @xmath92 of a graph model has therefore , two components : the discrete component @xmath93 and the continuous component @xmath94 .",
    "4 .   a set of _ transition _ labels",
    "@xmath95 assigned to every edge @xmath96 , where @xmath97 maps @xmath98 to the set @xmath99 where @xmath100   ^{n_{w}}\\times\\left\\ {   -1,1\\right\\ } ^{n_{v}},$ ] and @xmath101 is a polynomial function and @xmath102 is a semialgebraic set@xmath103 if @xmath95 is a deterministic map , we drop @xmath102 and define @xmath104 .",
    "a set of _ passport _ labels @xmath105 assigned to all edges @xmath96 , where @xmath105 is a semialgebraic set . a state transition along edge @xmath84 is possible if and only if @xmath106 6 .",
    "a set of semialgebraic invariant sets @xmath107 @xmath108 are assigned to every node on the graph , such that @xmath109 equivalently , a state @xmath110 satisfying @xmath111 is unreachable .",
    "therefore , a graph model is a well - defined specific case of the generic model @xmath112 with @xmath113 @xmath114 @xmath115 and @xmath7 defined as:@xmath116    conceptually similar models have been reported in @xcite for software verification , and in @xcite for modeling and verification of hybrid systems .",
    "interested readers may consult @xcite for further details regarding treatment of graph models with time - varying state - dependent transitions labels which arise in modeling operations with arrays .",
    "* * remarks**@xmath117    1 .",
    "the invariant set of node @xmath77 contains all the available information about the initial conditions of the program variables : @xmath118 2 .",
    "multiple edges between nodes enable modeling of logical `` or '' or `` xor '' type conditional transitions .",
    "this allows for modeling systems with nondeterministic discrete transitions.@xmath119 3 .",
    "the transition label @xmath95  may represent a simple update rule which depends on the real - time input .",
    "for instance , if @xmath120  and @xmath121   , $ ]  then @xmath122 \\right\\ }   .$ ]  in other cases , @xmath95  may represent an abstraction of a nonlinearity .",
    "for instance , the assignment @xmath123  can be abstracted by @xmath124 ( see eqn .",
    "( [ sinabst ] ) in appendix i).@xmath125",
    "before we proceed , we introduce the following notation :  given a semialgebraic set @xmath126 and a polynomial function @xmath127 we denote by @xmath128 the set : @xmath129    [ [ construction - of - simple - invariant - setssecconstabst ] ] construction of simple invariant sets[sec : constabst ] + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    simple invariant sets can be included in the model if they are readily available or easily computable .",
    "even trivial invariants can simplify the analysis and improve the chances of finding stronger invariants via numerical optimization .    1 .",
    "simple invariant sets may be provided by the programmer .",
    "these can be trivial sets representing simple algebraic relations between variables , or they can be more complicated relationships that reflect the programmer s knowledge about the functionality and behavior of the program .",
    "2 .   invariant propagation : assuming that @xmath130 are deterministic and invertible , the set@xmath131 is an invariant set for node @xmath132 furthermore , if the invariant sets @xmath133 are strict subsets of @xmath134  for all @xmath135 then ( [ constraint prop ] )  can be improved .",
    "specifically , the set@xmath136 is an invariant set for node @xmath132 note that it is sufficient that the restriction of @xmath130 to the lower dimensional spaces in the domains of @xmath137 and @xmath133 be invertible .",
    "3 .   preserving equality constraints :  simple assignments of the form @xmath138 result in invariant sets of the form @xmath139 at node @xmath140 provided that @xmath130 does not simultaneously update @xmath141 formally , let @xmath130 be such that @xmath142 is non - zero for at most one element @xmath143 and that @xmath144 is independent of @xmath145 then , the following set is an invariant set at node @xmath146 @xmath147   x=0\\right\\ }   \\vspace*{-0.15in}%\\ ] ]      the mil - ghms are graph models in which the effects of several lines and/or _ functions _ of code are compactly represented via a milm . as a result ,",
    "the graphs in such models have edges ( possibly self - edges ) that are labeled with matrices @xmath47 and @xmath53 corresponding to a milm as the transition and passport labels .",
    "such models combine the flexibility provided by graph models and the compactness of milms .",
    "an example is presented in section [ sec : casestudy ] .",
    "the specification that can be verified in our framework can generically be described as unreachability and finite - time termination .",
    "[ unreachability]a program @xmath148 is said to satisfy the unreachability property with respect to a subset @xmath149 if for every trajectory @xmath150 of ( [ softa1 ] ) , and every @xmath151 @xmath152 does not belong to @xmath153 a program @xmath148 is said to _ terminate in finite time _",
    "if every solution @xmath154 of ( [ softa1 ] ) satisfies @xmath155 for some @xmath156    several critical specifications associated with runtime errors are special cases of unreachability .",
    "absence of overflow can be characterized as a special case of unreachability by defining:@xmath157 where @xmath158 is the overflow limit for variable @xmath159      an out - of - bounds array indexing error occurs when a variable exceeding the length of an array , references an element of the array .",
    "assuming that @xmath160 is the corresponding integer index and @xmath161 is the array length , one must verify that @xmath160 does not exceed @xmath161 at location @xmath140 where referencing occurs .",
    "this can be accomplished by defining @xmath162 over a graph model and proving that @xmath163 is unreachable .",
    "this is also similar to assertion checking  defined next .",
    "an _ assertion _ is a mathematical expression whose validity at a specific location in the code must be verified .",
    "it usually indicates the programmer s expectation from the behavior of the program .",
    "we consider _ assertions _ that are in the form of semialgebraic set memberships .",
    "using graph models , this is done as follows:@xmath164{llccl}% \\text{at location } i : & \\text{assert } x\\in a_{i } & \\rightarrow & \\text{define } & x_{-}=\\left\\ {   \\left (   i , x\\right )   \\in x~|~x\\in x\\backslash a_{i}\\right\\ } , \\\\[-0.05in]% \\text{at location } i : & \\text{assert } x\\notin a_{i } & \\rightarrow & \\text{define } & x_{-}=\\left\\ {   \\left (   i , x\\right )   \\in x~|~x\\in a_{i}\\right\\ } .",
    "\\end{array } \\vspace*{-0.1in}%\\ ] ] in particular , safety assertions for division - by - zero or taking the square root ( or logarithm ) of positive variables are standard and must be automatically included in numerical programs ( cf .",
    "[ sec : bc ] , table [ table ii ] ) .",
    "a program invariant is a property that holds throughout the execution of the program .",
    "the property indicates that the variables reside in a semialgebraic subset @xmath165 .",
    "essentially , any method that is used for verifying unreachability of a subset @xmath149 can be applied for verifying invariance of @xmath166 by defining @xmath167 and vice versa .      for mathematical correctness",
    ", we must show that if an @xmath168-representation of a program satisfies the unreachability and ftt specifications , then so does the @xmath11-representation , i.e. , the actual program .",
    "this is established in the following proposition .",
    "the proof is omitted for brevity but can be found in @xcite .",
    "[ abstraction]let @xmath169 be an @xmath27-representation of program @xmath13 with @xmath11-representation @xmath9 let @xmath170 and @xmath171 be such that @xmath172 assume that the unreachability property w.r.t .",
    "@xmath173 has been verified for @xmath34 .",
    "then , @xmath13 satisfies the unreachability property w.r.t .",
    "@xmath153 moreover , if the ftt property holds for @xmath34 , then @xmath13 terminates in finite time .",
    "since we are not concerned with undecidability issues , and in light of proposition [ abstraction ] , we will not differentiate between abstract or concrete representations in the remainder of this paper .",
    "analogous to a lyapunov function , a lyapunov invariant is a real - valued function of the program variables satisfying a _ difference inequality _ along the execution trace .",
    "[ def : lyapinv]a @xmath174__-lyapunov invariant _ _ for @xmath10 is a function @xmath175 such that@xmath176 where @xmath177 .",
    "thus , a lyapunov invariant satisfies the _ difference inequality _ ( [ softa2 ] ) along the trajectories of @xmath36 until they reach a terminal state @xmath39 .",
    "it follows from definition [ def : lyapinv ] that a lyapunov invariant is not necessarily nonnegative , or bounded from below , and in general it need not be monotonically decreasing .",
    "while the zero level set of @xmath178 defines an invariant set in the sense that @xmath179 implies @xmath180 , for all @xmath181 monotonicity depends on @xmath182 and the initial condition .",
    "for instance , if @xmath183 @xmath184 then ( [ softa2 ] ) implies that @xmath185 along the trajectories of @xmath186 however , @xmath187 may not be monotonic if @xmath188 though it will be monotonic for @xmath189 furthermore , the level sets of a lyapunov invariant need not be bounded closed curves .",
    "proposition [ prop : milmlyap ]  ( to follow ) formalizes the interpretation of definition [ def : lyapinv ] for the specific modeling languages .",
    "natural lyapunov invariants for graph models are functions of the form@xmath190@xmath191 which assign a polynomial lyapunov function to every node @xmath108 on the graph @xmath192    [ prop : milmlyap]let @xmath193 and properly labeled graph @xmath194 be the mil and graph models for a computer program @xmath195 the function @xmath196   ^{n}\\mapsto\\mathbb{r}$ ] is a @xmath197-lyapunov invariant for @xmath13 if it satisfies:@xmath198   ^{n}\\times\\xi,\\vspace*{-0.2in}%\\ ] ] where@xmath199{cccc}% \\hspace*{-0.04in}\\vspace*{0.04in}x\\hspace*{-0.02 in } & \\hspace*{-0.02in}% w\\hspace*{-0.02 in } & \\hspace*{-0.02in}v\\hspace*{-0.02 in } & \\hspace * { -0.02in}1\\hspace*{-0.04in}% \\end{array } ] ^{^{t}}=0,\\text { } \\left (   w , v\\right )   \\in\\left [   -1,1\\right ]   ^{n_{w}}% \\times\\left\\ {   -1,1\\right\\ }   ^{n_{v}}\\}.\\vspace*{-0.17in}%\\ ] ] the function @xmath200 satisfying ( [ nodewiselyap ] ) is a @xmath201-lyapunov invariant for @xmath13 if@xmath202 @xmath203 note that a generalization of ( [ softa2 ] ) allows for @xmath182 and @xmath204 to depend on the state @xmath205 although simultaneous search for @xmath206 and @xmath187 leads to non - convex conditions , unless the dependence of @xmath182 on @xmath98 is fixed a - priori .",
    "we allow for dependence of @xmath182 on the discrete component of the state in the following way:@xmath207@xmath208        the following proposition is applicable to ftt analysis of both finite and infinite  state models .",
    "[ ftt2]*finite - time termination . *",
    "consider a program @xmath12 and its dynamical system model @xmath209 .",
    "if there exists a @xmath201-lyapunov invariant @xmath210 uniformly bounded on @xmath211 satisfying ( [ softa2 ] ) and the following conditions@xmath212@xmath213 where @xmath214 then @xmath13 terminates in finite time , and an upper - bound on the number of iterations is given by@xmath215{lcl}% \\displaystyle\\frac{\\log\\left (   \\mu+\\left (   \\theta-1\\right )   \\left\\vert v\\right\\vert _ { \\infty}\\right )   -\\log\\left (   \\mu\\right )   } { \\log\\theta } & , & \\theta\\neq1,~\\mu>0\\vspace*{0.1in}\\\\ \\displaystyle\\frac{\\log\\left (   \\left\\vert v\\right\\vert _ { \\infty}\\right ) -\\log\\left (   \\eta\\right )   } { \\log\\theta } & , & \\theta\\neq1,~\\mu=0\\\\ \\left\\vert v\\right\\vert _ { \\infty}/\\mu & , & \\theta=1 \\end{array } \\right .",
    "\\label{bnd on no .",
    "itrn.}%\\]]@xmath216    the proof is presented in appendix ii .",
    "when the state - space @xmath4 is finite , or when the lyapunov invariant @xmath178 is only a function of a subset of the variables that assume values in a finite set , e.g. , integer counters , it follows from proposition [ ftt2 ] that @xmath178 being a @xmath201-lyapunov invariant for any @xmath217 and @xmath218 is sufficient for certifying ftt , and uniform boundedness of @xmath178 need not be established a - priori .    consider the integerdivision program presented in example [ integerdiv - ex ] .",
    "the function @xmath210 defined according to @xmath219 is a @xmath220-lyapunov invariant for integerdivision :  at every step , @xmath178 decreases by @xmath221 since @xmath4 is finite , the program integerdivision terminates in finite time .",
    "this , however , only proves absence of infinite loops . the program could terminate with an overflow .",
    "let @xmath178 be a lyapunov invariant satisfying ( [ softa2 ] ) with @xmath222 the level sets of @xmath223 defined by @xmath224 are invariant with respect to ( [ softa1 ] ) in the sense that @xmath225 whenever @xmath226 .",
    "however , for @xmath227 the level sets @xmath228 remain invariant with respect to ( [ softa1 ] ) for any nonnegative @xmath229 this is an important property with the implication that @xmath230 ( i.e. , monotonicity ) is not necessary for establishing a separating manifold between the reachable set and the unsafe regions of the state space ( cf .",
    "theorem [ bddness ] ) .",
    "[ bddness]*lyapunov invariants as separating manifolds .",
    "* let @xmath231 denote the set of all @xmath201-lyapunov invariants satisfying ( [ softa2 ] ) for  program @xmath232 let @xmath233 be the identity map , and for @xmath234 define@xmath235 a subset @xmath149 where @xmath236 can never be reached along the trajectories of @xmath12 if there exists @xmath237 satisfying@xmath238 and either @xmath239 or one of the following two conditions hold:@xmath240    the proof  is presented in appendix ii .",
    "the following corollary  is based on theorem [ bddness ] and proposition [ ftt2 ]  and presents computationally implementable criteria for simultaneously establishing ftt and absence of overflow .",
    "[ bddness and ftt]*overflow and ftt analysis * consider a program @xmath12 and its dynamical system model @xmath209 .",
    "let @xmath241 be a diagonal matrix specifying the overflow limit@xmath65 and let @xmath242 let @xmath243 @xmath244 and let the function @xmath175 be a @xmath201-lyapunov invariant for @xmath36 satisfying@xmath245 v\\left (   x\\right )    &   \\geq\\sup\\left\\ {   \\left\\vert \\alpha^{-1}h\\left ( x\\right )   \\right\\vert _ { q}-1\\right\\ }   \\text{\\hspace{0.2in}}\\forall x\\in x.\\vspace*{-0.3in}\\label{three3}%\\end{aligned}\\]]@xmath246 then , an _ overflow runtime error _ will not occur during any execution of @xmath195 in addition , if @xmath218 and @xmath247 then , @xmath13 terminates in at most @xmath248 iterations where @xmath249 if @xmath239 and for @xmath250 we have:@xmath251 where @xmath252@xmath216    the proof  is presented in appendix ii .",
    "application of corollary [ bddness and ftt ] with @xmath253 typically leads to much less conservative results compared with @xmath254 , though the computational costs are also higher .",
    "see @xcite for remarks on variations of corollary [ bddness and ftt ] to trade off conservativeness and computational complexity .",
    "[ [ general - unreachability - and - ftt - analysis - over - graph - models ] ] general unreachability and ftt analysis over graph models + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the results presented so far in this section ( theorem [ bddness ] , corollary [ bddness and ftt ] , and proposition [ ftt2 ] ) are readily applicable to milms .",
    "these results will be applied in section [ chapter : computation ] to formulate the verification problem as a convex optimization problem .",
    "herein , we present an adaptation of these results to analysis of graph models .    a cycle @xmath255 on a graph @xmath256 is an ordered list of @xmath257 triplets @xmath258 @xmath259  @xmath260 where @xmath261 and @xmath262 @xmath263 a simple cycle is a cycle with no strict sub - cycles .    [ safetygraphcor1]*unreachability and ftt  analysis of graph models*. consider a program @xmath13 and its graph model @xmath264 let @xmath265 be a lyapunov invariant for @xmath266 satisfying ( [ arcwiselyap ] ) and@xmath202@xmath267 and either of the following two conditions:@xmath202@xmath268 where@xmath269 then , @xmath13 satisfies the unreachability property w.r.t .",
    "the collection of sets @xmath270 @xmath271 in addition , if for every simple cycle @xmath272 we have:@xmath273@xmath274 where@xmath273 @xmath275 then @xmath13 terminates in at most @xmath248 iterations where@xmath276    the proof  is presented in appendix ii .    for verification against an overflow violation specified by a diagonal matrix @xmath277 corollary [ safetygraphcor1 ] is applied with @xmath278 hence , ( [ sgc2 ] ) becomes @xmath279@xmath280 @xmath281 where @xmath282 .",
    "user - specified assertions , as well as many other standard safety specifications such as absence of division - by - zero can be verified using corollary [ safetygraphcor1 ] ( see table i ) .",
    "[ [ identification - of - dead - code ] ]  identification of dead code + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    suppose that we wish to verify that a discrete location @xmath283 in a graph model @xmath284 is unreachable .",
    "if a function satisfying the criteria of corollary [ safetygraphcor1 ] with @xmath285 can be found , then location @xmath82 can never be reached .",
    "condition ( [ sgc2 ] ) then becomes @xmath286,@xmath287    @xmath288{clcl } &   &   & \\\\ &   &   & \\\\\\cline{4 - 4 } &   &   & \\multicolumn{1}{|l|}{apply corollary \\ref{safetygraphcor1 } with:}\\\\\\hline \\multicolumn{1}{|c}{at location $ i$ : } & \\multicolumn{1}{|l}{assert $ x\\in x_{a}$ } & \\multicolumn{1}{|c}{$% \\begin{array } [ c]{c}% \\vspace*{-0.12in}\\\\ \\rightarrow\\\\ \\vspace*{-0.12in}% \\end{array }",
    "$ } & \\multicolumn{1}{|l|}{$x_{i-}:=\\left\\ {   x\\in\\mathbb{r}^{n}~|~x\\in \\mathbb{r}^{n}\\backslash x_{a}\\right\\ }   $ } \\\\\\hline \\multicolumn{1}{|c}{at location $ i$ : } & \\multicolumn{1}{|l}{assert $ x\\notin x_{a}$ } & \\multicolumn{1}{|c}{$% \\begin{array } [ c]{c}% \\vspace*{-0.12in}\\\\ \\rightarrow\\\\ \\vspace*{-0.12in}% \\end{array } $ } & \\multicolumn{1}{|l|}{$x_{i-}:=\\left\\ {   x\\in\\mathbb{r}^{n}~|~x\\in x_{a}\\right\\ }   $ } \\\\\\hline",
    "\\multicolumn{1}{|c}{at location $ i$ : } & \\multicolumn{1}{|l}{(expr.)/$x_{o}$ } & \\multicolumn{1}{|c}{$% \\begin{array } [ c]{c}% \\vspace*{-0.12in}\\\\ \\rightarrow\\\\ \\vspace*{-0.12in}% \\end{array } $ } & \\multicolumn{1}{|l|}{$x_{i-}:=\\left\\ {   x\\in\\mathbb{r}^{n}~|~x_{o}% = 0\\right\\ }   $ } \\\\\\hline \\multicolumn{1}{|c}{at location $ i$ : } & \\multicolumn{1}{|l}{$\\sqrt[2k]{x_{o } } $ } & \\multicolumn{1}{|c}{$% \\begin{array } [ c]{c}% \\vspace*{-0.12in}\\\\ \\rightarrow\\\\ \\vspace*{-0.12in}% \\end{array }",
    "$ } & \\multicolumn{1}{|l|}{$x_{i-}:=\\left\\ {   x\\in\\mathbb{r}^{n}~|~x_{o}% < 0\\right\\ }   $ } \\\\\\hline \\multicolumn{1}{|c}{at location $ i$ : } & \\multicolumn{1}{|l}{$\\log\\left ( x_{o}\\right )   $ } & \\multicolumn{1}{|c}{$% \\begin{array } [ c]{c}% \\vspace*{-0.12in}\\\\ \\rightarrow\\\\ \\vspace*{-0.12in}% \\end{array } $ } & \\multicolumn{1}{|l|}{$x_{i-}:=\\left\\ {   x\\in\\mathbb{r}^{n}~|~x_{o}% \\leq0\\right\\ }   $ } \\\\\\hline \\multicolumn{1}{|c}{at location $ i$ : } & \\multicolumn{1}{|l}{dead code } & \\multicolumn{1}{|c}{$% \\begin{array } [ c]{c}% \\vspace*{-0.12in}\\\\ \\rightarrow\\\\ \\vspace*{-0.12in}% \\end{array } $ } & \\multicolumn{1}{|l|}{$x_{i-}:=r^{n}$}\\\\\\hline \\end{tabular } $ ]    consider the following program note that @xmath289 can be zero right after the assignment @xmath290 however , at location @xmath291 , @xmath289 can not be zero and division - by - zero will not occur .",
    "the graph model of an abstraction of program 3 is shown next to the program and is defined by the following elements : @xmath292 and @xmath293   .$ ] the rest of the transition labels are identity .",
    "the only non - universal passport labels are @xmath294 and @xmath295 as shown in the figure .",
    "define@xmath296 \\sigma_{0}\\left (   \\mathrm{x}\\right )    & = \\sigma_{1}\\left (   \\mathrm{x}\\right ) = \\sigma_{4}\\left (   \\mathrm{x}\\right )   = \\sigma_{8}\\left (   \\mathrm{x}\\right ) = -\\mathrm{x}^{2}+2\\mathrm{x}-3.\\vspace*{-0.1in}%\\end{aligned}\\ ] ] it can be verified that @xmath297 is a @xmath298-lyapunov invariant for program 3 with variable rates : @xmath299 and @xmath300 @xmath301 .",
    "since@xmath302 the state @xmath303 can not be reached .",
    "hence , a division by zero will never occur .",
    "we will show in the next section how to find such functions in general.@xmath202",
    "it is well known that the main difficulty in using lyapunov functions in system analysis is finding them . naturally , using lyapunov invariants in software analysis",
    "inherits the same difficulties .",
    "however , the recent advances in hardware and software technology , e.g. , semi - definite programming @xcite , @xcite , and linear programming software @xcite present an opportunity for new approaches to software verification based on numerical optimization .",
    "the chances of finding a lyapunov invariant are increased when ( [ softa2 ] ) is only required on a subset of @xmath305 .",
    "for instance , for @xmath306 it is tempting to replace ( [ softa2 ] ) with@xmath307 in this formulation @xmath178 is not required to satisfy ( [ softa2 ] ) for those states which can not be reached from @xmath308 however , the set of all functions @xmath175 satisfying ( [ softa4 ] ) is not convex and finding a solution for ( [ softa4 ] ) is typically much harder than ( [ softa2 ] ) .",
    "such non - convex formulations are not considered in this paper .",
    "the first step in the search for a function @xmath175 satisfying ( [ softa2 ] ) is selecting a finite - dimensional linear parameterization of a candidate function @xmath178:@xmath309 where @xmath310 are fixed basis functions .",
    "next , for every @xmath311 let @xmath312 ( assuming for simplicity that the maximum does exist ) . since @xmath313 is a maximum of a family of linear functions , @xmath313 is a convex function .",
    "if minimizing @xmath314 over the unit disk yields a negative minimum , the optimal @xmath315 defines a valid lyapunov invariant @xmath316 .",
    "otherwise , no linear combination ( [ softa7 ] ) yields a valid solution for ( [ softa2 ] ) .",
    "the success and efficiency of the proposed approach depend on computability of @xmath317 and its subgradients .",
    "while @xmath317 is convex , the same does not necessarily hold for @xmath318 .",
    "in fact , if @xmath305 is non - convex , which is often the case even for very simple programs , computation of @xmath313 becomes a non - convex optimization problem even if @xmath319 is a nice ( e.g. linear or concave and smooth ) function of @xmath320 to get around this hurdle , we propose using convex relaxation techniques which essentially lead to computation of a convex upper bound for @xmath321 .",
    "such techniques constitute a broad class of techniques for constructing finite - dimensional , convex approximations for difficult non - convex optimization problems . some of the results most relevant to the software verification framework presented in this paper can be found in @xcite  for sdp relaxation of binary integer programs , @xcite and @xcite for sdp relaxation of quadratic programs , @xcite  for @xmath322-procedure in robustness analysis , and @xcite,@xcite for sum - of - squares relaxation in polynomial non - negativity verification .",
    "we provide a brief overview of the latter two techniques .",
    "[ [ the - mathcals - procedure - sections - procedure ] ] the @xmath36-procedure [ section : s - procedure ] + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the @xmath36-procedure is commonly used for construction of lyapunov functions for nonlinear dynamical systems .",
    "let functions @xmath323 @xmath324 and @xmath325 @xmath326 be given , and suppose that we are concerned with evaluating the following assertions:@xmath327    the implication ( ii )  @xmath328 ( i ) is trivial .",
    "the process of replacing assertion ( i ) by its _ relaxed _ version ( ii ) is called the @xmath36-procedure .",
    "note that condition ( ii ) is convex in decision variables @xmath329 and @xmath330 the implication ( i ) @xmath328 ( ii ) is generally not true and the @xmath36-procedure is called lossless for special cases where ( i ) and ( ii ) are equivalent .",
    "a well - known such case is when @xmath331 @xmath332 and @xmath333 @xmath334 are quadratic functionals@xmath103 a comprehensive discussion of the @xmath36-procedure as well as available results on its losslessness can be found in @xcite .",
    "other variations of @xmath36-procedure with non - strict inequalities exist as well .    [",
    "[ sum - of - squares - sos - relaxation - sectionsos - relaxation ] ] sum - of - squares ( sos ) relaxation [ section : sos - relaxation ] + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the sos  relaxation technique can be interpreted as the generalized version of the @xmath36-procedure and is concerned with verification of the following assertion:@xmath335 where @xmath336 are polynomial functions .",
    "it is easy to see that the problem is equivalent to verification of emptiness of a semialgebraic set , a necessary and sufficient condition for which is given by the positivstellensatz theorem @xcite . in practice ,",
    "sufficient conditions in the form of nonnegativity of polynomials are formulated .",
    "the non - negativity conditions are in turn relaxed to sos conditions .",
    "let @xmath337   $ ] denote the set of sos polynomials in @xmath257 variables @xmath338 , i.e. the set of polynomials that can be represented as @xmath339 @xmath340 where @xmath341 is the polynomial ring of @xmath257 variables with real coefficients .",
    "then , a sufficient condition for ( [ semialgformulae ] ) is that there exist sos  polynomials @xmath342   $ ] and polynomials @xmath343 such that@xmath344 matlab toolboxes sostools @xcite , or yalmip @xcite automate the process of converting an sos problem to an sdp , which is subsequently solved by available software packages such as lmilab @xcite , or sedumi @xcite .",
    "interested readers are referred to @xcite for more details .",
    "natural lyapunov invariant candidates for milms are quadratic and affine functionals .",
    "the linear parameterization of the space of quadratic functionals mapping @xmath345 to @xmath346 is given by : where @xmath347 is the set of @xmath54-by-@xmath54 symmetric matrices .",
    "we have the following lemma .",
    "[ mipl_invariance_lemma]consider a program @xmath13 and its milm @xmath348 the program admits a quadratic @xmath201-lyapunov invariant @xmath349 if there exists a matrix @xmath350 @xmath51 a diagonal matrix @xmath351 a positive semidefinite diagonal matrix @xmath352 and a symmetric matrix @xmath353 satisfying the following lmis : [ milp_invariance_lmi ] @xmath354 \\lambda & = \\operatorname{trace}d_{xw}+\\operatorname{trace}d_{v}\\vspace*{-1in}%\\end{aligned}\\ ] ] where    the proof is presented in appendix ii    the following theorem summarizes our results for verification of absence of overflow and/or ftt for milms .",
    "the result follows from lemma [ mipl_invariance_lemma ] and corollary [ bddness and ftt ] with @xmath355 , @xmath356 though the theorem is presented without a detailed proof .",
    "[ milp_correctness_theorem]*optimization - based milm  verification .",
    "* let @xmath357 be a diagonal positive definite matrix specifying the overflow limit .",
    "an overflow runtime error does not occur during any execution of @xmath13 if there exist matrices @xmath358 diagonal matrices @xmath359 positive semidefinite diagonal matrices @xmath360 and a symmetric matrix @xmath361 satisfying the following lmis : [ milp_thm ] @xmath362{cc}% x_{0 } & 1 \\end{array } ] p[% \\begin{array } [ c]{cc}% x_{0 } & 1 \\end{array } ] ^{t }   & \\leq0,\\text{\\qquad}\\forall x_{0}\\in x_{0}\\label{milp_thm_a}% \\\\[-0.06 in ] l_{1}^{t}pl_{1}-\\theta l_{2}^{t}pl_{2 }   & \\preceq\\operatorname{he}\\left ( y_{1}h\\right )   + l_{3}^{t}d_{1xw}l_{3}+l_{4}^{t}d_{1v}l_{4}-\\left (   \\lambda _ { 1}+\\mu\\right )   l_{5}^{t}l_{5}\\label{milp_thm_b}\\\\[-0.06 in ] l_{1}^{t}\\lambda l_{1}-l_{2}^{t}pl_{2 }   & \\preceq\\operatorname{he}\\left ( y_{2}h\\right )   + l_{3}^{t}d_{2xw}l_{3}+l_{4}^{t}d_{2v}l_{4}-\\lambda_{2}% l_{5}^{t}l_{5}\\label{milp_thm_c}%\\end{aligned}\\]]@xmath246 where @xmath363 @xmath364 and @xmath365 @xmath366 in addition , if @xmath247 then @xmath13 terminates in a most @xmath248 steps where @xmath248 is given in ( [ upperboundontu ] ) .",
    "affine lyapunov invariants can often establish strong properties , e.g. , boundedness , for  variables with simple uncoupled dynamics ( e.g. counters ) at a low computational cost . for variables with more complicated dynamics , affine invariants may simply establish sign - invariance ( e.g. , @xmath367 ) or more generally , upper or lower bounds on some linear combination of certain variables . as we will observe in section [ sec : casestudy ] , establishing these simple behavioral properties is important as they can be recursively added to the model ( e.g. , the matrix @xmath53 in a milm , or the invariant sets @xmath46 in a graph model ) to improve the chances of success in proving stronger properties via higher order invariants .",
    "the linear parameterization of the subspace of linear functionals mapping @xmath345 to @xmath368is given by:@xmath369   ^{t},~k\\in\\mathbb{r}^{n+1}\\right\\ }   .\\vspace * { -0.12in}\\label{milp_linear_fctn}%\\ ] ] it is possible to search for the affine invariants via semidefinite programming or linear programming .    [ mipl_linearinvariance_lemma]*sdp characterization of linear invariants : * there exists a @xmath201-lyapunov invariant @xmath370 for a program @xmath371 if there exists a matrix @xmath372 a diagonal matrix @xmath373 a positive semidefinite diagonal matrix @xmath374 and a matrix @xmath375 satisfying the following lmi:@xmath376 where @xmath377 and @xmath378    [ mipl_linearinvariance_lemma_lp]*lp characterization of linear invariants : * there exists a @xmath201-lyapunov invariant for a program @xmath379 in the class @xmath380 if there exists a matrix @xmath381 and nonnegative matrices @xmath382  @xmath383 and a matrix @xmath384 satisfying :    [ milp - lp - lp]@xmath385    @xmath213 where @xmath386 is either @xmath387 or @xmath388 as a special case of ( [ milp - lp - lp ] ) ,  a subset of all the affine invariants is characterized by the set of all solutions of the following system of linear equations : @xmath389    when the objective is to establish properties of the form @xmath390 for a fixed @xmath391 ( e.g. , when establishing sign - invariance for certain variables ) , matrix @xmath392 in ( [ milp - li - sdp])@xmath393([milp - lp - lp - simple ] ) is fixed and thus one can make @xmath182 a decision variable subject to @xmath394 exploiting this convexity is extremely helpful for successfully establishing such properties .",
    "the advantage of using semidefinite programming is that efficient sdp relaxations for treatment of binary variables exists , though the computational cost is typically higher than the lp - based approach .",
    "in contrast , linear programming relaxations of the binary constraints are more involved than the corresponding sdp relaxations .",
    "two extreme remedies can be readily considered .",
    "the first is to relax the binary constraints and treat the variables as continuous variables @xmath395   .$ ] the second is to consider each of the @xmath396 different possibilities ( one for each vertex of @xmath397 ) separately .",
    "this approach can be useful if @xmath398 is small , and is otherwise impractical .",
    "more sophisticated schemes can be developed based on hierarchical linear programming relaxations of binary integer programs @xcite .",
    "a linear parameterization of the subspace of polynomial functionals with total degree less than or equal to @xmath399 is given by:@xmath400 where @xmath401 is a vector of length @xmath402 consisting of all monomials of degree less than or equal to @xmath399 in @xmath54 variables @xmath403 a linear parametrization of lyapunov invariants for graph models is defined according to ( [ nodewiselyap ] ) , where for every @xmath93 we have @xmath404 where @xmath405 is a selected degree bound for @xmath406 depending on the dynamics of the model , the degree bounds @xmath407 and the convex relaxation technique , the corresponding optimization problem will become a linear , semidefinite , or sos optimization problem .",
    "we present generic conditions for verification over graph models using sos  programming .",
    "although lmi  conditions for verification of _ linear graph models _ using quadratic invariants and the @xmath36-procedure for relaxation of non - convex constraints can be formulated , we do not present them here due to space limitations .",
    "such formulations are presented in the extended report @xcite , along with executable matlab code in @xcite .",
    "the following theorem follows from corollary [ safetygraphcor1 ] .",
    "[ thm : graphnodepoly]*optimization - based graph model verification . *",
    "consider a program @xmath13 , and its graph model @xmath408 let @xmath409 be given by ( [ nodewiselyap ] ) , where @xmath410 then , the functions @xmath411 @xmath108 define a lyapunov invariant for @xmath12 if for all @xmath96 we have:@xmath412   \\text { subject to } \\left ( x , w\\right )   \\in\\left (   \\left (   x_{i}\\cap\\pi_{ji}^{k}\\right )   \\times \\lbrack-1,1]^{n_{w}}\\right )   \\cap s_{ji}^{k}\\vspace*{-0.2in}\\label{d1d1}%\\ ] ] furthermore , @xmath13 satisfies the unreachability property w.r.t .",
    "the collection of sets @xmath270 @xmath413 if there exist @xmath414 @xmath281 such that@xmath415   \\text { subject to } x\\in x_{\\emptyset}\\vspace*{-0.2in}\\label{d1d0}\\\\ \\sigma_{i}\\left (   x\\right )   -\\varepsilon_{i }   & \\in\\sigma\\left [   x\\right ] \\text { subject to } x\\in x_{i}\\cap x_{i-},\\ i\\in\\mathcal{n}\\backslash\\left\\ { \\emptyset\\right\\ }   \\vspace*{-0.25in}\\label{d1d3}%\\end{aligned}\\]]@xmath416 as discussed in section [ section : sos - relaxation ] , the sos relaxation techniques can be applied for formulating the search problem for functions @xmath417 satisfying ( [ d1d1])([d1d3 ] ) as a convex optimization problem .",
    "for instance , if @xmath418^{n_{w}% } \\right )   \\cap s_{ji}^{k}=\\left\\ {   \\left (   x , w\\right )   ~|~f_{p}\\left ( x , w\\right )   \\geq0,\\text { } h_{l}\\left (   x , w\\right )   = 0\\right\\ }   , \\vspace * { -0.2in}%\\ ] ] then , ( [ d1d1 ] ) can be formulated as an sos optimization problem of the following form : @xmath419   , \\text { s.t . }",
    "\\tau_{p}% , \\tau_{pq}\\in\\sigma\\left [   x , w\\right ]   .\\vspace*{-0.2in}%\\ ] ] software packages such as sostools @xcite or yalmip @xcite can then be used for formulating the sos optimization problems as semidefinite programs .",
    "in this section we apply the framework to the analysis of program 4 displayed below.program 4 takes two positive integers @xmath420   $ ] and @xmath421   $ ] as the input and returns their greatest common divisor by implementing the euclidean division algorithm .",
    "note that the main function in program 4 uses the integerdivision program ( program 1 ) .",
    "a global model can be constructed by embedding the dynamics of the integerdivision program within the dynamics of main .",
    "a labeled graph model is shown alongside the text of the program .",
    "this model has a state space @xmath422 ^{7},$ ] where @xmath90 is the set of nodes as shown in the graph , and the global state @xmath423   $ ] is an element of the hypercube @xmath424",
    "^{7}.$ ] a _ reduced _ graph model can be obtained by combining the effects of consecutive transitions and relabeling the reduced graph model accordingly . while analysis of the full graph model is possible , working with a _ reduced _ model is computationally advantageous . furthermore , mapping the properties of the reduced graph model to the original model is algorithmic .",
    "interested readers may consult @xcite for further elaboration on this topic .",
    "for the graph model of program 4 , a reduced model can be obtained by first eliminating nodes @xmath425 @xmath426 @xmath427 @xmath428 @xmath429 @xmath430 @xmath431",
    "@xmath432 and @xmath433 ( figure [ fig : redmodel ] left ) and composing the transition and passport labels . node @xmath434 can be eliminated as well to obtain a further reduced model with only three nodes : @xmath435 @xmath436 @xmath437 ( figure [ fig : redmodel ] right ) .",
    "this is the model that we will analyze .",
    "the passport and transition labels associated with the reduced model are as follows :    [ tbh ]    eucdivfigreducednew.pdf    @xmath438{rllcrrll}% \\overline{t}_{\\mathrm{f}2\\mathrm{f}2}^{1 } & \\hspace*{-0.06in}:\\hspace * { -0.06 in } & \\mathrm{x}\\mapsto\\left [ \\mathrm{x,\\ y,\\ rem,\\ dd,\\ dr,\\ q+1,\\ r - dr}\\right ]   & \\vspace*{-0.05 in } &   & \\overline{t}_{\\mathrm{f}2\\mathrm{f}2}^{2 } & \\hspace*{-0.06in}:\\hspace * { -0.06 in } & \\mathrm{x}\\mapsto\\left [   \\mathrm{y,\\ r,\\ r,\\ y,\\ r,\\ 0,\\ y}% \\right ] \\\\",
    "\\overline{t}_{\\mathrm{l}0\\mathrm{f}2 } & \\hspace*{-0.06in}:\\hspace*{-0.06 in } & \\mathrm{x}\\mapsto\\left [   \\mathrm{x,\\ y,\\ 0,\\ x,\\ y,\\ 0,\\ x}\\right ]   & \\vspace*{-0.05 in } &   & \\overline{t}_{\\mathrm{f}2\\mathrm{l}\\join } & \\hspace*{-0.06in}:\\hspace*{-0.06 in } & \\mathrm{x}\\mapsto\\left [ \\mathrm{y,\\ r,\\ r,\\ dd,\\ dr,\\ q,\\ r}\\right ] \\end{array } \\\\ & \\begin{array } [ c]{rllcrrlllllll}% \\pi_{\\mathrm{f}2\\mathrm{f}2}^{2 } & \\hspace*{-0.06in}:\\hspace*{-0.06 in } & \\left\\ {   \\mathrm{x~|~1\\leq r\\leq dr-1}\\right\\ }   &   &   & \\pi_{\\mathrm{f}% 2\\mathrm{f}2}^{1 } & \\hspace*{-0.06in}:\\hspace*{-0.06in}\\vspace*{-0.05 in } & \\left\\ {   \\mathrm{x~|~r\\geq dr}\\right\\ }   &   &   & \\pi_{\\mathrm{f}2\\mathrm{l}% \\join } & \\hspace*{-0.06in}:\\hspace*{-0.06 in } & \\left\\ {   \\mathrm{x~|~r\\leq dr-1,}\\text { } \\mathrm{r\\leq0}\\right\\ } \\end{array}\\end{aligned}\\ ] ]    finally , the invariant sets that can be readily included in the graph model ( cf . section [ sec : constabst ] ) are:@xmath439 we are interested in generating certificates of termination and absence of overflow .",
    "first , by recursively searching for linear invariants we are able to establish simple lower bounds on all variables in just two rounds ( the properties established in the each round are added to the model and the next round of search begins ) .",
    "for instance , the property @xmath440 is established only after @xmath441 is established .",
    "these results , which were obtained by applying the first part of theorem [ thm : graphnodepoly ] ( equations ( [ d1d1])-([d1d0 ] ) only )  with linear functionals are summarized in table  ii .",
    "@xmath442{|r|c|c|c|c|c|c|c|}\\hline $ \\text{property}$ & $ \\mathrm{q}\\geq\\mathrm{0}$ & $ \\mathrm{y}\\geq\\mathrm{1}$ & $ \\mathrm{\\mathrm{dr}}\\geq\\mathrm{\\mathrm{1}}$ & $ \\mathrm{\\mathrm{rem}}% \\geq\\mathrm{0}$ & $ \\mathrm{\\mathrm{dd}}\\geq\\mathrm{\\mathrm{1}}$ & $ \\mathrm{x}\\geq\\mathrm{1}$ & $ \\mathrm{r}\\geq\\mathrm{0}$\\\\\\hline $ \\text{proven in round}$ & $ \\mathrm{\\mathrm{i}}$ & $ \\mathrm{\\mathrm{i}}$ & $ \\mathrm{\\mathrm{i}}$ & $ \\mathrm{\\mathrm{i}}$ & $ \\mathrm{\\mathrm{ii}}$ & $ \\mathrm{\\mathrm{ii}}$ & $ \\mathrm{\\mathrm{ii}}$\\\\\\hline $ \\sigma_{\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   = $ & $ -\\mathrm{q}$ & $ \\mathrm{1}-\\mathrm{y}$ & $ \\mathrm{1}-\\mathrm{dr}$ & $ -\\mathrm{\\mathrm{rem}}$ & $ \\mathrm{1}-\\mathrm{dd}$ & $ \\mathrm{1}-\\mathrm{x}$ & $ -\\mathrm{r}$\\\\\\hline $ \\left",
    "(   \\theta_{\\mathrm{f}2\\mathrm{f}2}^{1},\\mu_{\\mathrm{f}2\\mathrm{f}2}% ^{1}\\right )   $ & $ \\left (   1,1\\right )   $ & $ \\left (   1,0\\right )   $ & $ \\left ( 1,0\\right )   $ & $ \\left (   1,0\\right )   $ & $ \\left (   0,0\\right )   $ & $ \\left ( 0,0\\right )   $ & $ \\left (   0,0\\right )   $ \\\\\\hline $ \\left (   \\theta_{\\mathrm{f}2\\mathrm{f}2}^{2},\\mu_{\\mathrm{f}2\\mathrm{f}2}% ^{2}\\right )   $ & $ \\left (   0,0\\right )   $ & $ \\left (   0,0\\right )   $ & $ \\left ( 0,0\\right )   $ & $ \\left (   0,0\\right )   $ & $ \\left (   0,0\\right )   $ & $ \\left ( 0,0\\right )   $ & $ \\left (   0,0\\right )   $ \\\\\\hline \\end{tabular}\\end{gathered}\\ ] ] we then add these properties to the node invariant sets to obtain stronger invariants that certify ftt and boundedness of all variables in @xmath443   $ ] . by applying theorem [ thm : graphnodepoly ] and sos programming using yalmip @xcite ,",
    "the following invariants are found and different rounding schemes lead to different invariants .",
    "note that rounding is not essential . ]",
    "( after post - processing , rounding the coefficients , and reverifying ) : @xmath164{llll}% \\sigma_{1\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   = 0.4\\left (   \\mathrm{y}% -\\mathrm{m}\\right )   \\left (   2+\\mathrm{m}-\\mathrm{r}\\right )   &   &   & \\sigma_{2\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   = \\left (   \\mathrm{q}% \\times\\mathrm{y}+\\mathrm{r}\\right )   ^{2}-\\mathrm{m}^{2}\\\\ \\sigma_{3\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   = \\left (   \\mathrm{q}% + \\mathrm{r}\\right )   ^{2}-\\mathrm{m}^{2 } &   &   & \\sigma_{4\\mathrm{f}_{2}% } \\left (   \\mathrm{x}\\right )   = 0.1\\left (   \\mathrm{y}-\\mathrm{m}+5\\mathrm{y}% \\times\\mathrm{m}+\\mathrm{y}^{2}-6\\mathrm{m}^{2}\\right ) \\\\",
    "\\sigma_{5\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   = \\mathrm{y}+\\mathrm{r}% -2\\mathrm{m}+\\mathrm{y}\\times\\mathrm{m}-\\mathrm{m}^{{\\normalsize 2 } } &   &   & \\sigma_{6\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   = \\mathrm{r}\\times \\mathrm{y}+\\mathrm{y}-\\mathrm{m}^{2}-\\mathrm{m}% \\end{array}\\ ] ] the properties proven by these invariants are summarized in the table iii .",
    "the specifications that the program terminates and that @xmath444   ^{7}$ ] for all initial conditions @xmath445   , $ ] could not be established in one shot , at least when trying polynomials of degree @xmath446 for instance , @xmath447 certifies boundedness of all the variables except @xmath448 while @xmath449 and @xmath450 which certify boundedness of all variables including @xmath23 do not certify ftt .",
    "furthermore , boundedness of some of the variables is established in round ii , relying on boundedness properties proven in round i. given @xmath451 ( which is found in round i ) , second round verification can be done by searching for a strictly positive polynomial @xmath452 and a nonnegative polynomial @xmath453 satisfying:@xmath454 where the inequality ( [ eq : roundii ] ) is further subject to boundedness properties established in round i , as well as the usual passport conditions and basic invariant set conditions .",
    "@xmath455{|r|c|c|c|c|}\\hline invariant $ \\sigma_{\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   = \\hspace * { -0.02in}$ & $ \\sigma_{1\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   $ & $ \\hspace*{-0.02in}\\sigma_{2\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right ) , \\sigma_{3\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   \\hspace*{-0.02in}$ & $ \\sigma_{4\\mathrm{f}_{2}}\\left (   \\mathrm{x}\\right )   $ & $ \\sigma_{5\\mathrm{f}% _ { 2}}\\left (   \\mathrm{x}\\right )   , \\sigma_{6\\mathrm{f}_{2}}\\left ( \\mathrm{x}\\right )   $ \\\\\\hline $ % \\begin{array } [ c]{c}% \\left (   \\theta_{\\mathrm{f}2\\mathrm{f}2}^{1},\\mu_{\\mathrm{f}2\\mathrm{f}2}% ^{1}\\right )   \\smallskip \\end{array } \\hspace*{-0.02in}$ & $ \\left (   1,0\\right )   $ & $ \\left (   1,0\\right )   $ & $ \\left (   1,0\\right )",
    "$ & $ \\left (   1,1\\right )   $ \\\\\\hline $ % \\begin{array } [ c]{c}% \\left (   \\theta_{\\mathrm{f}2\\mathrm{f}2}^{2},\\mu_{\\mathrm{f}2\\mathrm{f}2}% ^{2}\\right )   \\smallskip \\end{array } \\hspace*{-0.02in}$ & $ \\left (   1,0.8\\right )   $ & $ \\left (   0,0\\right )   $ & $ \\left (   1,0.7\\right )   $ & $ \\left (   1,1\\right )   $ \\\\\\hline \\multicolumn{1}{|l|}{round i : $ % \\begin{array } [ c]{c}% \\mathrm{x}_{i}^{2}\\leq\\mathrm{m}^{2}\\text { for } \\mathrm{x}_{i}\\mathrm{=}% \\smallskip\\hspace*{-0.08in}% \\end{array } \\hspace*{-0.02in}$ } & $ \\hspace*{-0.02in}\\mathrm{y , x , r , dr , rem , dd}% \\hspace*{-0.02in}$ & $ \\hspace*{-0.02in}\\mathrm{q , y , dr , rem}\\hspace*{-0.02in}$ & $ \\hspace*{-0.02in}\\mathrm{y , x , r , dr , rem , dd}\\hspace*{-0.02in}$ & $ \\hspace * { -0.02in}\\mathrm{y , dr , rem}\\hspace*{-0.02in}$\\\\\\hline \\multicolumn{1}{|l|}{round ii:$% \\begin{array } [ c]{c}% \\mathrm{x}_{i}^{2}\\leq\\mathrm{m}^{2}\\text { for } \\mathrm{x}_{i}\\mathrm{=}% \\smallskip\\hspace*{-0.08in}% \\end{array } \\hspace*{-0.02in}$ } &   & $ \\mathrm{x , r , dd}$ &   & $ \\mathrm{x , r , dd}$\\\\\\hline certificate for ftt$\\hspace*{-0.02in}$ & no & no & no & yes , $ t_{u}% = 2\\mathrm{m}^{2}$\\\\\\hline \\end{tabular}\\end{gathered}\\ ] ] in conclusion , @xmath456 or @xmath457 in conjunction with @xmath458 or @xmath459 prove finite - time termination of the algorithm , as well as boundedness of all variables within @xmath443   $ ] for all initial conditions @xmath460   , $ ] for any @xmath461 the provable bound on the number of iterations certified by @xmath458 and @xmath459 is @xmath462 ( corollary [ safetygraphcor1])@xmath103 if we settle for more conservative specifications , e.g. , @xmath463 ^{7}$ ] for all initial conditions @xmath464   $ ] and sufficiently large @xmath465 then it is possible to prove the properties in one shot .",
    "we show this in the next section .      for comparison , we also constructed the mil - gh model associated with the reduced graph in figure [ fig : redmodel ] .",
    "the corresponding matrices are omitted for brevity , but details of the model along with executable matlab verification codes can be found in  @xcite .",
    "the verification theorem used in this analysis is an extension of theorem [ milp_correctness_theorem ] to analysis of mil - ghm for specific numerical values of @xmath466 though it is certainly possible to perform this modeling and analysis exercise for parametric bounded values of @xmath467 the analysis using the mil - ghm is in general more conservative than sos optimization over the graph model presented earlier .",
    "this can be attributed to the type of relaxations proposed ( similar to those used in lemma [ milp_invariance_lmi ] ) for analysis of milms and mil - ghms .",
    "the benefits are simplified analysis at a typically much less computational cost .",
    "the certificate obtained in this way is a single quadratic function ( for each numerical value of @xmath468 ) , establishing a bound @xmath469 satisfying @xmath470 table iv summarizes the results of this analysis which were performed using  both sedumi 1_3 and lmilab solvers .",
    "@xmath471{|r|c|c|c|c|c|}\\hline $ \\mathrm{m}$ & $ 10^{2}$ & $ 10^{3}$ & $ 10^{4}$ & $ 10^{5}$ & $ 10^{6}$\\\\\\hline solver : lmilab \\cite{gahinetlmilab } : $ \\gamma\\left (   \\mathrm{m}\\right )   $ & $ 5.99\\mathrm{m}$ & $ 6.34\\mathrm{m}$ & $ 6.43\\mathrm{m}$ & $ 6.49\\mathrm{m}$ & $ 7.05\\mathrm{m}$\\\\\\hline solver : sedumi \\cite{strum1999 } : $ \\gamma\\left (   \\mathrm{m}\\right )   $ & $ 6.00\\mathrm{m}$ & $ 6.34\\mathrm{m}$ & $ 6.44\\mathrm{m}$ & $ 6.49\\mathrm{m}$ & nan\\\\\\hline $ % \\begin{array } [ c]{c}% \\left (   \\theta_{\\mathrm{f}2\\mathrm{f}2}^{1},\\mu_{\\mathrm{f}2\\mathrm{f}2}% ^{1}\\right )   \\smallskip \\end{array } \\hspace*{-0.02in}$ & $ \\left (   1,10^{-3}\\right )   $ & $ \\left (   1,10^{-3}\\right ) $ & $ \\left (   1,10^{-3}\\right )   $ & $ \\left (   1,10^{-3}\\right )   $ & $ \\left ( 1,10^{-3}\\right )   $ \\\\\\hline $ % \\begin{array } [ c]{c}% \\left (   \\theta_{\\mathrm{f}2\\mathrm{f}2}^{2},\\mu_{\\mathrm{f}2\\mathrm{f}2}% ^{2}\\right )   \\smallskip \\end{array } \\hspace*{-0.02in}$ & $ \\left (   1,10^{-3}\\right )   $ & $ \\left (   1,10^{-3}\\right ) $ & $ \\left (   1,10^{-3}\\right )   $ & $ \\left (   1,10^{-3}\\right )",
    "$ & $ \\left ( 1,10^{-3}\\right )   $ \\\\\\hline upperbound on iterations$\\hspace*{-0.02in}$ & $ t_{u}=2$e$4 $ & $ t_{u}=8$e$4 $ & $ t_{u}=8$e$5 $ & $ t_{u}=1.5$e$7 $ & $ t_{u}=3$e$9$\\\\\\hline \\end{tabular}\\end{gathered}\\ ] ]      the preceding results were obtained by analysis of a global model which was constructed by embedding the internal dynamics of the program s functions within the global dynamics of the main function .",
    "in contrast , the idea in _ modular analysis _ is to model software as the interconnection of the program s `` building blocks '' or `` modules '' , i.e. , functions that interact via a set of _ global _ variables .",
    "the dynamics of the functions are then abstracted via input / output behavioral models , typically constituting equality and/or inequality constraints relating the input and output variables . in our framework , the invariant sets of the terminal nodes of the modules ( e.g. , the set @xmath472 associated with the terminal node @xmath473 in program 4 ) provide such i / o model .",
    "thus , richer characterization of the invariant sets of the terminal nodes of the modules are desirable .",
    "correctness of each sub - module must be established separately , while correctness of the entire program will be established by verifying the unreachability and termination properties w.r.t .",
    "the global variables , as well as verifying that a terminal global state will be reached in finite - time .",
    "this way , the program variables that are _ private _ to each function are abstracted away from the global dynamics .",
    "this approach has the potential to greatly simplify the analysis and improve the scalability of the proposed framework as analysis of large size computer programs is undertaken . in this section ,",
    "we apply the framework to modular analysis of program 4 .",
    "detailed analysis of the advantages in terms of improving scalability , and the limitations in terms of conservatism the analysis is an important and interesting direction of future research .",
    "the first step is to establish correctness of the integerdivision module , for which we obtain@xmath474 the function @xmath475 is a @xmath476-invariant proving boundedness of the state variables of integerdivision .",
    "subject to boundedness , we obtain the function@xmath477 which is a @xmath478-invariant proving termination of integerdivision .",
    "the invariant set of node @xmath473 can thus be characterized by@xmath479   ^{4}~|~\\mathrm{r\\leq dr-1}\\right\\ }   \\vspace*{-0.15in}%\\ ] ] the next step is construction of a global model .",
    "given @xmath472 , the assignment at @xmath480 : @xmath481 can be abstracted by @xmath482 , \\text{~}\\mathrm{w}\\leq\\mathrm{y-1,}\\vspace*{-0.2in}%\\ ] ] allowing for construction of a global model with variables @xmath483and @xmath484 and an external state - dependent input @xmath485   \\mathrm{,}$ ] satisfying @xmath486 finally , the last step is analysis of the global model .",
    "we obtain the function @xmath487 which is @xmath478-invariant proving both ftt and boundedness of all variables within @xmath488   .$ ]",
    "we took a systems - theoretic approach to software analysis , and presented a framework based on convex optimization of lyapunov invariants for verification of a range of important specifications for software systems , including finite - time termination and absence of run - time errors such as overflow , out - of - bounds array indexing , division - by - zero , and user - defined program assertions .",
    "the verification problem is reduced to solving a numerical optimization problem , which when feasible , results in a certificate for the desired specification .",
    "the novelty of the framework , and consequently , the main contributions of this paper are in the systematic transfer of lyapunov functions and the associated computational techniques from control systems to software analysis . the presented work can be extended in several directions .",
    "these include understanding the limitations of modular analysis of programs , perturbation analysis of the lyapunov certificates to quantify robustness with respect to round - off errors , extension to systems with software in closed loop with hardware , and adaptation of the framework to specific classes of software .",
    "1 .   trigonometric functions :    abstraction of trigonometric functions can be obtained by approximation of the taylor series expansion followed by representation of the absolute error by a static bounded uncertainty .",
    "for instance , an abstraction of the @xmath489 function can be constructed as follows:@xmath490{|l|l|l|}\\hline abstraction of $ \\sin\\left (   x\\right )   $ & $ x\\in\\lbrack-\\frac{\\pi}{2},\\frac { \\pi}{2}]$ & $ x\\in\\lbrack-\\pi,\\pi]$\\\\\\hline $ \\overline{\\sin}\\left (   x\\right )   \\in\\left\\ {   x+aw~|~w\\in\\left [   -1,1\\right ] \\right\\ }   $ & $ a=0.571 $ & $ a=3.142$\\\\\\hline $ \\overline{\\sin}\\left (   x\\right )   \\in\\{x-\\frac{1}{6}x^{3}+aw~|~w\\in\\left [ -1,1\\right ]   \\}$ & $ a=0.076 $ & $ a=2.027$\\\\\\hline \\end{tabular}\\ ] ] abstraction of @xmath491 is similar .",
    "it is also possible to obtain piecewise linear abstractions by first approximating the function by a piece - wise linear ( pwl ) function and then representing the absolute error by a bounded uncertainty .",
    "section [ section : specmodels ] ( proposition [ milm - prop ] ) establishes universality of representation of generic pwl functions via binary and continuous variables and an algorithmic construction can be found in @xcite .",
    "for instance , if @xmath492 $ ] then a piecewise linear approximation with absolute error less than @xmath493 can be constructed in the following way :    [ sinabst]@xmath494   , \\hspace*{-0.02 in } \\left (   w , v\\right ) \\in\\left [ -1,1\\right ]   ^{2}\\times\\left\\ {   -1,1\\right\\ }   \\right\\ } \\label{sinabsta}\\\\[-0.05 in ] \\hspace*{-0.1in}\\overline{\\sin}\\left (   x\\right )   \\hspace{-0.02 in } & \\in\\hspace{-0.02in}\\left\\ {   tx_{e}~|~x_{e}\\in s\\right\\ }   , \\text{\\ } % t : x_{e}\\mapsto0.45\\left (   1+v\\right )   x+\\left (   1-v\\right )   \\left ( 0.2x+0.2\\right )   + 0.06w_{1}%\\end{aligned}\\ ] ]    1 .   the sign function ( @xmath495 ) and the absolute value function ( @xmath496 ) :    the sign function ( @xmath497 ) may appear explicitly or as an interpretation of _ if - then - else _ blocks in computer programs ( see @xcite for more details ) . a particular abstraction of @xmath498 is as follows : @xmath499 . note that @xmath500 is equal to @xmath501 while the abstraction is multi - valued at zero@xmath502 @xmath503 the absolute value function can be represented ( precisely ) over @xmath504   $ ] in the following way : @xmath505   \\times\\left\\ { -1,1\\right\\ }   \\right\\ }   \\vspace*{-0.25in}%\\ ] ] more on the systematic construction of function abstractions including those related to floating - point , fixed - point , or modulo arithmetic can be found in the report @xcite .",
    "[ of proposition [ ftt2]]note that ( [ softa2a1])@xmath393([softa2a3 ] ) imply that @xmath178 is negative - definite along the trajectories of @xmath186 except possibly for @xmath506 which can be zero when @xmath507 let @xmath508 be any solution of @xmath509 since @xmath178 is uniformly bounded on @xmath4 , we have:@xmath273 @xmath510 now , assume that there exists a sequence @xmath511 of elements from @xmath4 satisfying ( [ softa1 ] ) , but not reaching a terminal state in finite time .",
    "that is , @xmath512 @xmath513 then , it can be verified that if @xmath514 where @xmath248 is given by ( [ bnd on no .",
    "itrn . ] ) , we must have : @xmath515 which contradicts boundedness of @xmath516    [ of theorem [ bddness]]assume that @xmath36 has a solution @xmath517 where @xmath518 and @xmath519 let @xmath520 first , we claim that @xmath521 if @xmath522 we have @xmath523 and @xmath524 if @xmath525",
    "we have @xmath526 and @xmath527 hence the claim .",
    "now , consider the @xmath230 case@xmath103 since @xmath178 is monotonically decreasing along solutions of @xmath186 we must have:@xmath67@xmath528 which contradicts ( [ inf g than sup])@xmath103 note that if @xmath218 and @xmath522 then ( [ inf l than sup ] ) holds as a strict inequality and we can replace ( [ inf g than sup ] ) with its non - strict version .",
    "next , consider case @xmath529 for which ,",
    "@xmath178 need not be monotonic along the trajectories .",
    "partition @xmath42 into two subsets @xmath530 and @xmath531 such that @xmath532 and@xmath67@xmath533 now , assume that @xmath36 has a solution @xmath534 where @xmath535 and @xmath536 since @xmath537  and @xmath188 we have @xmath538 therefore,@xmath202 @xmath539 which contradicts ( [ inf g than sup])@xmath103 next , assume that @xmath36 has a solution @xmath540 where @xmath541 and @xmath542 in this case , regardless of the value of @xmath543 we must have @xmath544 @xmath545 implying that @xmath546 and hence , contradicting ( [ inf g than zero])@xmath103 note that if @xmath254 and either @xmath547 or @xmath548 then ( [ inf g than zero ] ) can be replaced with its non - strict version .",
    "finally , consider case @xmath549 .",
    "due to ( [ sup l than zero ] ) , @xmath178 is strictly monotonically decreasing along the solutions of @xmath509 the rest of the argument is similar to the @xmath230 case .",
    "[ of corollary [ bddness and ftt]]it follows from ( [ three3 ] ) and the definition of @xmath163 that:@xmath550 it then follows from ( [ o69 ] ) and ( [ one1 ] ) that:@xmath551 hence , the first statement of the corollary follows from theorem [ bddness ] .",
    "the upperbound on the number of iterations follows from proposition [ ftt2 ] and the fact that @xmath552    [ of corollary [ safetygraphcor1]]the unreachability property follows directly from theorem [ bddness ] .",
    "the finite time termination property holds because it follows from ( [ arcwiselyap ] ) , ( [ sgc1 ] ) and ( [ multiplicativetheta ] ) along with proposition [ ftt2 ] , that the maximum number of iterations around every simple cycle @xmath11 is finite . the upperbound on the number of iterations is the sum of the maximum number of iterations over every simple cycle .    [ of lemma [ mipl_invariance_lemma]]define @xmath553 where @xmath554   ^{n},$ ] @xmath555 ^{n_{w}},$ ] @xmath556 recall that @xmath557 and that for all @xmath558 satisfying @xmath559 there holds : @xmath560 it follows from proposition [ prop : milmlyap ] that ( [ softa2 ] ) holds if:@xmath561 ^{n+n_{w}},\\text { } l_{4}x_{e}\\in\\left\\ {   -1,1\\right\\ }   ^{n_{v}}.\\vspace * { -0.1in}\\label{milp_1}%\\ ] ] recall from the @xmath36-procedure ( ( [ needs - s - procedure ] ) and ( [ s - procedure - sufficient ] ) ) that the assertion @xmath562 @xmath563   ^{n}$ ] holds if there exists nonnegative constants @xmath564 @xmath565 such that @xmath566where @xmath567 similarly , the assertion @xmath568 holds if there exists a diagonal matrix @xmath204 such that @xmath569 applying these relaxations to ( [ milp_1 ] ) , we obtain sufficient conditions for ( [ milp_1 ] ) to hold:@xmath570 together with @xmath571 the above condition is equivalent to the lmis in lemma [ milp_invariance_lmi ] .",
    "99 r. alur , c. courcoubetis , n. halbwachs , t. a. henzinger , p .- h .",
    "ho x. nicollin , a. oliviero , j. sifakis , and s. yovine . the algorithmic analysis of hybrid systems , _ theoretical computer science _ , vol .",
    "138 , pp . 334 , 1995 .",
    "b. blanchet , p. cousot , r. cousot , j. feret , l. mauborgne , a. min , d. monniaux , and x. rival .",
    "design and implementation of a special - purpose static program analyzer for safety - critical real - time embedded software .",
    "lncs v. 2566 , pp .",
    "85108 , springer - verlag , 2002 .",
    "e. m. clarke , o. grumberg , h. hiraishi , s. jha , d.e .",
    "long , k.l .",
    "mcmillan , and l.a .",
    "verification of the future - bus+cache coherence protocol . in _",
    "formal methods in system design _ , 6(2):217232 , 1995 .",
    "p. cousot , and r. cousot .",
    "abstract interpretation : a unified lattice model for static analysis of programs by construction or approximation of fixpoints . in _",
    "4th acm sigplan - sigact symposium on principles of programming languages _ , pages 238252 , 1977 .",
    "g. naumovich , l. a. clarke , and l. j. osterweil .",
    "verification of communication protocols using data flow analysis . in _ proc .",
    "4-th acm sigsoft symposium on the foundation of software engineering _ ,",
    "pages 93105 , 1996 .",
    "nesterov , h. wolkowicz , and y. ye .",
    "semidefinite programming relaxations of nonconvex quadratic optimization . in _",
    "handbook of semidefinite programming : theory , algorithms , and applications_. dordrecht , kluwer academic press , pp .",
    "361419 , 2000 .",
    "p. a. parrilo .",
    "minimizing polynomial functions . in _",
    "algorithmic and quantitative real algebraic geometry_. dimacs series in discrete mathematics and theoretical computer science , v. 60 , pp .",
    "83 - 100 , 2003 .",
    "m. roozbehani , a. megretski and , e. feron .",
    "optimization of lyapunov invariants in analysis of software systems , available at http://web.mit.edu/mardavij/www/publications.html also available at http://arxive.org      m. roozbehani , a. megretski , e. frazzoli , and e. feron .",
    "distributed lyapunov functions in analysis of graph models of software . in hybrid systems :",
    "computation and control , springer lncs 4981 , pp 443 - 456 , 2008 ."
  ],
  "abstract_text": [
    "<S> the paper proposes a control - theoretic framework for verification of numerical software systems , and puts forward software verification as an important application of control and systems theory . </S>",
    "<S> the idea is to transfer lyapunov functions and the associated computational techniques from control systems analysis and convex optimization to verification of various software safety and performance specifications . </S>",
    "<S> these include but are not limited to absence of overflow , absence of division - by - zero , termination in finite time , presence of dead - code , and certain user - specified assertions . </S>",
    "<S> central to this framework are lyapunov invariants . </S>",
    "<S> these are properly constructed functions of the program variables , and satisfy certain properties****resembling those of lyapunov functions****along the execution trace . </S>",
    "<S> the search for the invariants can be formulated as a convex optimization problem . </S>",
    "<S> if the associated optimization problem is feasible , the result is a certificate for the specification .    </S>",
    "<S> software verification , lyapunov invariants , convex optimization . </S>"
  ]
}