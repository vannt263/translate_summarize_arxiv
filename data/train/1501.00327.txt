{
  "article_text": [
    "a matroid is _ internally @xmath0-connected _ if it is @xmath8-connected and @xmath9 for any @xmath8-separation , @xmath10 . for some time",
    ", we have been engaged in a project to develop a splitter theorem for internally @xmath0-connected  binary matroids @xcite .",
    "this means that we are concerned with understanding what we refer to here as interesting pairs .",
    "if @xmath3 and @xmath2 are matroids , we write @xmath11 to mean that @xmath2 has an @xmath3-minor , and @xmath12 to mean that @xmath2 has a proper @xmath3-minor .",
    "interesting pair _ is a pair @xmath1 , where @xmath2 and @xmath3 are internally @xmath0-connected  binary matroids such that    * @xmath13 ; * @xmath12 ; * if @xmath4 is an internally @xmath0-connected  matroid for which @xmath14 , then @xmath5 .",
    "note that the last condition means that @xmath15 .",
    "we say that an interesting pair , @xmath1 , is a _",
    "fascinating pair _ if @xmath4 is isomorphic to @xmath3 whenever @xmath4 is an internally @xmath0-connected  matroid satisfying @xmath16 .",
    "thus an interesting pair is fascinating if there is no intermediate internally @xmath0-connected  matroid in the minor order .",
    "it has been known for some time ( see , for example , @xcite ) that there are fascinating pairs with @xmath17 arbitrarily large ; indeed , this is true even if we insist that @xmath2 and @xmath3 are graphic matroids , since we can produce a fascinating pair by setting @xmath3 to be the graphic matroid of a cubic planar ladder , and letting @xmath2 be the graphic matroid of a quartic planar ladder on the same number of vertices .",
    "however , our project has shown that only a small number of constructions are needed to build @xmath2 from @xmath3 , whenever @xmath1 is a fascinating pair .",
    "the analysis in our project requires @xmath2 to be a certain size , in particular , @xmath6 . to complement this analysis ,",
    "our results here contain a description of all interesting pairs for which @xmath7 .",
    "our first theorem will describe the fascinating pairs .",
    "up to duality , there are exactly @xmath18 . before that",
    ", we introduce some important matroids and graphs .    for @xmath19 , we denote the _ cubic mbius ladder _ on @xmath20 vertices by @xmath21 .",
    "this graph is obtained from an even cycle on @xmath20 vertices by joining each vertex to the antipodal vertex ( the vertex of distance @xmath22 ) .",
    "similarly , for @xmath23 , the _",
    "quartic mbius ladder _ on @xmath24 vertices is denoted by @xmath25 , and is obtained from an odd cycle with @xmath24 vertices by joining each vertex to the two vertices of distance @xmath22 .",
    "note that @xmath26 is isomorphic to @xmath27 , and @xmath28 is isomorphic to @xmath29 .",
    "the mbius matroids have been discovered in several contexts @xcite . for each positive integer @xmath30 ,",
    "let @xmath31 be the wheel with @xmath32 vertices , and let @xmath33 be the set of spoke edges .",
    "thus @xmath33 is a basis of the rank-@xmath22 binary matroid @xmath34 .",
    "let @xmath35 be the binary matroid obtained from @xmath34 by adding a single element , @xmath36 , so that the fundamental circuit @xmath37 is @xmath38 .",
    "kingan and lemos  @xcite denote @xmath39 by @xmath40 .",
    "observe that @xmath41 is the fano matroid , and @xmath42 .",
    "when @xmath22 is odd , @xmath43 is the _",
    "rank-@xmath44 triadic mbius matroid _",
    ", denoted by @xmath45 .",
    "hence @xmath46 .",
    "moreover , @xmath47 is isomorphic to any single - element deletion of @xmath48 , the rank-@xmath49 binary matroid introduced by kingan @xcite .",
    "we also observe that @xmath50 .    for @xmath51",
    ", we construct the graph @xmath52 by starting with an @xmath22-vertex cycle , @xmath53 , containing adjacent vertices @xmath54 and @xmath55 , and then adding two additional vertices , @xmath56 and @xmath57 , and making both of them adjacent to every vertex in @xmath53 .",
    "we join @xmath56 and @xmath57 with an edge @xmath36 .",
    "note that the planar dual of @xmath58 is @xmath21 .",
    "let @xmath59 be the binary matroid that is obtained from @xmath60 by deleting the element @xmath61 and adding a new element so that it forms a circuit with the elements @xmath62 and @xmath63 .",
    "this new element also forms a circuit with @xmath64 and @xmath65 .",
    "we also define @xmath66 to be @xmath67 .",
    "then @xmath68 is the _",
    "rank-@xmath69 triangular mbius matroid_. observe that @xmath70 .",
    "kingan and lemos  @xcite use @xmath71 to denote @xmath52 , and @xmath72 to denote @xmath59 .",
    "now we give our description of fascinating pairs .",
    "any graphs or matroids which we have not yet defined will be introduced in . for now , we note that @xmath73 is the cube graph ; @xmath74 is the octahedron graph ; @xmath75 , @xmath76 , and @xmath77 are graphs with @xmath78 edges , and , respectively , @xmath49 , @xmath79 , and @xmath80 vertices ; @xmath81 and @xmath82 have @xmath83 edges and , respectively , @xmath80 and @xmath84 vertices ; @xmath85 , @xmath86 , @xmath87 , @xmath88 , and @xmath89 are non - graphic matroids with rank @xmath80 and @xmath83 elements , whereas @xmath90 has rank @xmath79 and @xmath83 elements ; the matroids @xmath91 and @xmath92 have rank @xmath0 and @xmath93 elements ; each matroid of the form @xmath94 or @xmath95 has rank @xmath80 and @xmath96 elements ; both @xmath97 and @xmath98 have rank @xmath99 and @xmath93 elements , while @xmath100 and @xmath101 have rank @xmath84 and @xmath96 elements .",
    "[ maintheorem ] assume that @xmath102 is a fascinating pair and @xmath103 .",
    "then , for some pair , @xmath1 in @xmath104 , one of the following statements holds .    1 .",
    "@xmath2 is one of @xmath105 or @xmath106 , and @xmath3 is @xmath107 ; 2 .",
    "@xmath2 is one of @xmath47 or @xmath108 , and @xmath3 is @xmath109 ; 3 .",
    "@xmath2 is one of @xmath110 , @xmath111 , @xmath112 , or @xmath113 , and @xmath3 is @xmath114 ; 4 .",
    "@xmath2 is one of @xmath115 , @xmath116 , @xmath113 , or @xmath117 , and @xmath3 is @xmath106 ; 5 .",
    "@xmath2 is one of @xmath85 , @xmath86 , @xmath87 , @xmath88 , @xmath89 , @xmath90 , or @xmath118 , and @xmath3 is @xmath119 ; 6 .",
    "@xmath2 is one of @xmath120 , @xmath121 , @xmath122 , @xmath123 , or @xmath124 , and @xmath3 is @xmath91 ; 7 .",
    "@xmath2 is one of @xmath125 , @xmath126 , @xmath127 , or @xmath128 , and @xmath3 is @xmath92 ; 8 .",
    "@xmath129 ; 9 .",
    "@xmath130 ; or 10 .",
    "@xmath131 .    with in hand ,",
    "it is easy to find the pairs that are interesting but not fascinating : there are only three ( up to duality ) .",
    "[ mtheorem2 ] assume that @xmath102 is an interesting pair that is not fascinating and that @xmath103 .",
    "then there is a pair , @xmath1 in @xmath132 , such that @xmath1 is either @xmath133 , @xmath134 , or @xmath135 .",
    "the following table shows the number of interesting pairs ( up to duality ) , where the larger matroid has @xmath136 elements in its ground set , and the smaller has @xmath22 elements . note",
    "that none of the pairs we have listed contains two self - dual matroids , so if we were not taking duality into account , we would just double the numbers in the table .    [ cols=\"^,^,^,^,^,^,^ \" , ]     next we note the specialisation of our theorems to graphic matroids . any graphs",
    "not already defined are described in .",
    "let @xmath137 be a simple , @xmath8-connected graph .",
    "for any partition , @xmath10 , of the edge set , let @xmath138 be the set of vertices incident with edges in both @xmath139 and @xmath140 .",
    "we say that @xmath137 is _ internally @xmath0-connected _ if , whenever @xmath141 we have that @xmath142 , with equality implying that @xmath139 is either a triangle or the set of edges incident with a vertex of degree @xmath8 . in other words , @xmath137 is internally @xmath0-connectedif and only if @xmath143 is an internally @xmath0-connectedmatroid .",
    "[ maingraph ] assume @xmath144 and @xmath145 are internally @xmath0-connected  graphs such that @xmath146 , and @xmath144 has a proper @xmath145-minor .",
    "assume also that if @xmath137 is an internally @xmath0-connected  graph such that @xmath144 has a proper @xmath137-minor , and @xmath137 has a @xmath145-minor , then @xmath147 .",
    "then one of the following statements holds .",
    "* @xmath144 is one of @xmath27 , @xmath73 , @xmath74 , or @xmath148 , and @xmath145 is @xmath149 ; * @xmath144 is one of @xmath75 , @xmath76 , @xmath77 , or @xmath150 , and @xmath145 is @xmath29 ; * @xmath144 is one of @xmath81 , @xmath82 , @xmath150 , or @xmath151 , and @xmath145 is @xmath27 .    in many of the pairs in or",
    ", we encounter structures that are familiar from the analysis in the rest of the project .",
    "these structures lead to operations that we can use to produce a smaller internally @xmath0-connected  matroid from a larger one .",
    "four such operations will be documented in .",
    "in the following results , we explain exactly when it is possible to perform them on our fascinating and interesting pairs .    [ goodmovefirst ]",
    "let the pair @xmath1 be as described in one of the statements  in .",
    "if @xmath1 is not one of @xmath152 , @xmath153 , @xmath154 , @xmath155 , @xmath156 , or @xmath157 , then @xmath3 can be obtained from @xmath2 ( or @xmath158 can be obtained from @xmath159 ) by one of the following four operations :    1 .",
    "trimming a ring of bowties ; 2 .   deleting the central cocircuit of a good augmented @xmath0-wheel ; 3 .   a ladder - compression move ; or 4 .   trimming an open rotor chain .",
    "the next deals with the three interesting pairs identified in .",
    "[ cor2 ] let @xmath1 be @xmath133 , @xmath160 , or @xmath135 .",
    "then there is an internally @xmath0-connected  binary matroid , @xmath161 , such that @xmath162 , and either @xmath161 can be obtained from @xmath2 ( or @xmath163 can be obtained from @xmath159 ) by a ladder - compression move .",
    "we note that some of the exceptional pairs in are dealt with by some of the specific scenarios from our main theorem , which appears in @xcite . in particular , since @xmath164 , we see that if @xmath1 is @xmath154 or @xmath157 , then @xmath2 is a triadic mbius matroid of rank @xmath165 , and @xmath3 is a triangular mbius matroid of rank @xmath69 . if @xmath1 is @xmath166 , then @xmath2 is the cycle matroid of a quartic mbius ladder , and @xmath3 is the cycle matroid of a cubic mbius ladder , and @xmath167 .",
    "thus the only truly exceptional pairs are @xmath153 , @xmath152 , and @xmath155 .",
    "we prove with an exhaustive search , using the matroid functionality of the sage mathematics package , ( version @xmath168 ) @xcite .",
    "all the computations performed in this search were performed on a single desktop computer , and took a total of approximately @xmath169 hours of computation .",
    "the code used in the search is available from http://homepages.ecs.vuw.ac.nz/~mayhew/splittertheorem.shtml . some of the objects created during the search , such as the catalogue of @xmath8-connected binary matroids with at most @xmath96 elements , required a non - trivial amount of computation .",
    "those objects are also available at the same site .",
    "in this section , we describe four different structures that appear naturally when we examine internally @xmath0-connected  binary matroids .",
    "each structure allows us to perform certain deletions and contractions to obtain an internally @xmath0-connected  proper minor .",
    "these operations play an essential role in the statement of our splitter theorem . in",
    ", we analyse the pairs in , and demonstrate that , in many cases , these structures appear there also .",
    "recall that a @xmath8-connected matroid is internally @xmath0-connectedwhen every @xmath8-separation has a triangle or a triad on one side .",
    "a @xmath0-element fan is a set @xmath170 , where @xmath171 is a triangle and @xmath172 is a triad .",
    "a @xmath8-connected matroid , @xmath2 , is _ @xmath173-connected _ if , for every @xmath8-separation , @xmath10 , of @xmath2 , one of @xmath139 and @xmath140 is a triangle , a triad , or a @xmath0-element fan .",
    "a _ bowtie _ consists of a pair of disjoint triangles whose union contains a @xmath0-element cocircuit .",
    "assume @xmath174 , and @xmath175 is a sequence of pairwise disjoint triangles .",
    "let @xmath176 be @xmath177 for @xmath178 .",
    "assume @xmath179 is a cocircuit for @xmath180 , and in addition , @xmath181 is a cocircuit .",
    "then we say that @xmath182 is a _ ring of bowties_. although the matroid @xmath2 we are dealing with need not be graphic , we follow the convention begun in @xcite of using a modified graph diagram to keep track of some of the circuits and cocircuits in @xmath2 .",
    "shows such a modified graph diagram .",
    "each of the cycles in such a graph diagram corresponds to a circuit of @xmath2 while a circled vertex indicates a known cocircuit of @xmath2 .",
    "if @xmath183 , then we say that @xmath4 is obtained from @xmath2 by _ trimming a ring of bowties_.    -wheel .",
    "all displayed elements are distinct . ]",
    "an _ augmented @xmath0-wheel _ is represented by the modified graph diagram in , where the four dashed edges form the _",
    "central cocircuit_. if a matroid @xmath2 contains the structure in and @xmath184 is @xmath173-connected , then we say that the augmented @xmath0-wheel is _",
    "good_. we refer to the operation of deleting the four dashed edges as _ removing the central cocircuit of an augmented @xmath0-wheel_.        our third structure requires a special four - element move .",
    "if @xmath2 contains the structure in , then we say that @xmath185 is obtained from @xmath2 by a _",
    "ladder - compression move_.        finally , we consider the structure in .",
    "note that @xmath22 may be either even or odd .",
    "when there are at least three dashed elements , we refer to the structure in as an _",
    "open rotor chain _ and we refer to the operation of deleting the dashed elements as _ trimming an open rotor chain_.",
    "this section has two purposes .",
    "first , we introduce all the graphs and matroids that feature in , which we now restate .",
    "[ repeat ] assume that @xmath102 is a fascinating pair and @xmath103 .",
    "then , for some pair , @xmath1 in @xmath104 , one of the following statements holds .    1 .",
    "@xmath2 is one of @xmath105 or @xmath106 , and @xmath3 is @xmath107 ; 2 .",
    "@xmath2 is one of @xmath47 or @xmath108 , and @xmath3 is @xmath109 ; 3 .",
    "@xmath2 is one of @xmath110 , @xmath111 , @xmath112 , or @xmath113 , and @xmath3 is @xmath114 ; 4 .",
    "@xmath2 is one of @xmath115 , @xmath116 , @xmath113 , or @xmath117 , and @xmath3 is @xmath106 ; 5 .",
    "@xmath2 is one of @xmath85 , @xmath86 , @xmath87 , @xmath88 , @xmath89 , @xmath90 , or @xmath118 , and @xmath3 is @xmath119 ; 6 .",
    "@xmath2 is one of @xmath120 , @xmath121 , @xmath122 , @xmath123 , or @xmath124 , and @xmath3 is @xmath91 ; 7 .",
    "@xmath2 is one of @xmath125 , @xmath126 , @xmath127 , or @xmath128 , and @xmath3 is @xmath92 ; 8 .",
    "@xmath129 ; 9 .",
    "@xmath130 ; or 10 .",
    "@xmath131 .    in many of the pairs from this theorem ,",
    "it is possible to apply one of the four moves described in .",
    "thus the second purpose of this section is to document these moves , and ultimately prove , which we restate next .",
    "[ goodmove ] let the pair @xmath1 be as described in one of the statements  in . if @xmath1 is not one of @xmath152 , @xmath153 , @xmath154 , @xmath155 , @xmath156 , or @xmath157 , then @xmath3 can be obtained from @xmath2 ( or @xmath158 can be obtained from @xmath159 ) by one of the following four operations :    1 .   trimming a ring of bowties ;",
    "2 .   deleting the central cocircuit of a good augmented @xmath0-wheel",
    "; 3 .   a ladder - compression move ; or 4 .   trimming an open rotor chain .",
    "now we start describing various graphs and matroids , beginning with the graphs @xmath149 , @xmath27 , and @xmath73 , all of which are illustrated in .",
    "the graph @xmath73 is also known as the _ cube graph_. also shows the _ octahedron graph _ , @xmath74 , which is the planar dual of @xmath73 .",
    ", @xmath27 , @xmath73 , and @xmath74 . ]    in lemma  2.3 of @xcite , geelen and zhou describe five internally @xmath0-connected  graphs having @xmath186 as a minor .",
    "one of the five is @xmath187 , which has only @xmath188 edges .",
    "another is isomorphic to @xmath150 .",
    "let the other three graphs be @xmath75 , @xmath76 , and @xmath77 .",
    "these are shown in .    , @xmath76 , @xmath77 , and @xmath150 .",
    "]    [ prop2 ] let @xmath1 be one of the pairs @xmath189 , @xmath190 , or @xmath191",
    ". then @xmath3 is obtained from @xmath2 by trimming a bowtie ring , deleting the central cocircuit from a good augmented @xmath0-wheel , or a ladder - compression move .",
    "note that @xmath192 has the bowtie ring shown in , and trimming this ring yields @xmath193 .",
    "also , @xmath194 has a good augmented @xmath0-wheel whose central cocircuit is the set of edges incident with vertex @xmath49 . deleting this cocircuit yields @xmath193 .",
    "finally , @xmath195 has the ladder segment shown in , where edges @xmath196 correspond to @xmath197 .",
    "if we delete @xmath198 and @xmath199 , and contract @xmath200 and @xmath201 , then we obtain @xmath202 .    .",
    "]    observe that of all the pairs in statements ( 1 ) , ( 2 ) , and ( 3 ) in are either exceptional pairs that appear in , or are dealt with by .",
    "thus we have verified for these pairs .    the graphs @xmath81 and @xmath82 are shown in , along with @xmath151 .    , @xmath82 , and @xmath151 .",
    "]    [ prop3 ] let @xmath1 be one of the pairs @xmath203 , @xmath204 , @xmath205 , or @xmath206",
    ". then @xmath3 is obtained from @xmath2 by trimming a bowtie ring , deleting the central cocircuit from a good augmented @xmath0-wheel , or a ladder - compression move",
    ".    shows a labelling of some of the edges in @xmath81 , along with a good augmented @xmath0-wheel in @xmath207 .",
    "deleting the central cocircuit of this augmented wheel produces @xmath208 . shows the labelling of a bowtie ring in @xmath209 . trimming this ring produces @xmath208 .",
    "similarly , by trimming the bowtie ring shown in , we can obtain @xmath208 from @xmath210 .",
    "finally , it is clear that @xmath211 is obtained from @xmath212 by a ladder - compression move , so in particular this applies to @xmath113 and @xmath213 .     and a good augmented @xmath0-wheel in @xmath207 . ]    .",
    "]    . ]",
    "since verifies for the pairs listed in statement ( 4 ) of , we now move to non - graphic binary matroids .",
    "we shall describe each of these matroids by giving a matrix that is a reduced binary representation for it .",
    "for example , shows a matrix , @xmath214 , which is a reduced representation of @xmath119 . shows a geometric representation of @xmath119 . note that the element @xmath84 corresponds to @xmath36 , so deleting @xmath84 produces a matroid isomorphic to @xmath215 .     and @xmath91 .",
    "]    . ]    the matroids @xmath85 , @xmath86 , @xmath87 , @xmath88 , and @xmath89 have as reduced representations the reduced matrices shown in .",
    "thus each of @xmath85 , @xmath86 , @xmath87 , @xmath88 , and @xmath89 is a rank-@xmath80 binary matroid with @xmath83 elements , and each contains a @xmath0-element independent set whose contraction produces a minor isomorphic to @xmath119 .",
    "the matroid @xmath90 is represented in .",
    "we can produce a @xmath119-minor from @xmath90 by contracting a @xmath8-element independent set and deleting a single element .",
    ", @xmath86 , @xmath87 , @xmath88 , and @xmath89 . ]    . ]",
    "[ prop4 ] let @xmath1 be one of the pairs @xmath216 , @xmath217 , @xmath218 , @xmath219 , @xmath220 , or @xmath221",
    ". then @xmath3 is obtained from @xmath2 by trimming a bowtie ring , trimming an open rotor chain , or deleting the central cocircuit from a good augmented @xmath0-wheel .",
    "we will check that @xmath222 is obtained from each of @xmath223 , and @xmath224 by trimming a bowtie ring . in ,",
    "assume that the matrices inherit the labels on rows and columns from @xmath214 , so that the first four rows of any matrix are labelled @xmath225 , @xmath226 , @xmath227 , @xmath8 , the columns are labelled @xmath0 , @xmath99 , @xmath49 , @xmath79 , @xmath80 , @xmath84 , and the last four rows are labelled @xmath228 , @xmath93 , @xmath188 , and @xmath78 .",
    "now @xmath229 contains a bowtie ring , as in , where @xmath230 , and the labelling puts @xmath231 trimming this ring produces @xmath232 .",
    "similar statements apply to @xmath233 , and @xmath224 . in those cases ,",
    "the bowtie rings , @xmath234 , are    @xmath235    the matroid @xmath236 contains an open rotor chain , as in , where @xmath230 , and we label so that @xmath237 trimming this rotor chain produces @xmath232 .    finally , for @xmath238 , we assume the matrix in inherits the labels from @xmath214 , and we label the extra column @xmath228 , and the extra rows as @xmath239 , and @xmath78 .",
    "then @xmath240 contains an augmented @xmath0-wheel , as in , where we label so that @xmath241 are replaced by @xmath242 .",
    "now @xmath243 is @xmath173-connected , and @xmath244 , so the proof of the is complete .",
    "before we continue , we recall some introductory material . a simple rank-@xmath69 binary matroid , @xmath2 , can be considered as a subset , @xmath245 , of points in the projective geometry @xmath246 .",
    "the _ complement _ of @xmath2 is the binary matroid corresponding to the set of points of @xmath246 not in @xmath245 .",
    "the complement of @xmath2 is well - defined by ( * ? ? ?",
    "* proposition  10.1.7 ) , meaning that it depends only on @xmath2 , and not on the choice of @xmath245 .",
    "in particular , if two simple rank-@xmath69 binary matroids have isomorphic complements , then they are themselves isomorphic .",
    "the complement of @xmath202 in @xmath247 is @xmath248 , and the complement of @xmath119 is @xmath249 .",
    "the complement of @xmath250 in @xmath247 is @xmath251 . from this",
    ", it follows that @xmath250 has a unique simple rank-@xmath0 binary extension on @xmath93 elements .",
    "we denote this extension by @xmath91 , so the complement of @xmath91 is @xmath252 .",
    "the matrix @xmath33 , shown in , represents @xmath91 over @xmath253 .",
    "note that @xmath254 is isomorphic to @xmath250 , and that @xmath228 is in triangles with @xmath255 , @xmath256 , and @xmath257 , where each of these pairs corresponds to a matching in @xmath27 .",
    "the matroids @xmath120 , @xmath121 , @xmath122 , @xmath123 , and @xmath124 are represented by the matrices in .    , @xmath121 , @xmath122 , @xmath123 , and @xmath124 .",
    "]    [ prop5 ] let @xmath1 be one of the pairs @xmath258 , @xmath259 , @xmath260 , @xmath261 , @xmath262",
    ". then @xmath3 is obtained from @xmath2 by trimming a bowtie ring .",
    "we assume that each matrix , @xmath263 , inherits the labels on @xmath33 , and that the extra rows are labelled @xmath93 , @xmath188 , @xmath78 , and @xmath83 . in @xmath264",
    ", there is a bowtie ring , as in , with @xmath230 , where @xmath265 is relabelled as @xmath266 .",
    "similarly , for @xmath267 , @xmath268 , @xmath269 , and @xmath270 , the relevant relabellings are @xmath271 , @xmath272 , @xmath273 , and @xmath274 .",
    "let @xmath92 be the binary matroid represented by the matrix @xmath53 , below .",
    "note that @xmath92 is obtained by extending @xmath119 by the element @xmath228 in such a way that @xmath275 is a triangle .",
    "the complement of @xmath92 in @xmath247 is @xmath276 .",
    "the matroids @xmath125 , @xmath126 , @xmath127 , and @xmath128 are represented by the matrices in .    , @xmath126 , @xmath127 , and @xmath128 .",
    "]    [ prop6 ] let @xmath1 be one of the pairs @xmath277 , @xmath278 , @xmath279 , @xmath280",
    ". then @xmath3 is obtained from @xmath2 by trimming a bowtie ring .",
    "we assume that each matrix @xmath281 inherits the row and column labels from @xmath53 , and the extra rows are labelled @xmath93 , @xmath188 , @xmath78 , and @xmath83 .",
    "we relabel the elements @xmath265 in @xmath282 for @xmath283 , @xmath284 for @xmath285 , @xmath286 for @xmath287 , and @xmath288 for @xmath289 .",
    "verify for the pairs listed in statements ( 5 ) , ( 6 ) , and ( 7 ) in .",
    "there are two matrices in .",
    "the matrix @xmath290 represents the binary matroid @xmath97 .",
    "note that @xmath97 is obtained from @xmath250 by coextending by the element @xmath228 so that @xmath228 is in a triad with two elements that correspond to a @xmath227-edge matching in @xmath27 .",
    "therefore @xmath97 is isomorphic to the matroid obtained from @xmath91 by performing a @xmath291-operation on the triangle @xmath292 .     and @xmath100 . ]    [ prop7 ]",
    "@xmath293 can be obtained from @xmath294 by trimming a bowtie ring .",
    "label the extra rows in @xmath295 that are not in @xmath290 as @xmath93 , @xmath188 , @xmath78 , and @xmath83 .",
    "then @xmath296 is the appropriate bowtie ring .",
    "the matroid @xmath98 is represented by the matrix @xmath245 , and @xmath101 is represented by the matrix shown in .",
    "we can obtain @xmath98 from @xmath119 by coextending by the element @xmath228 so that it is in a triad with @xmath225 and @xmath80 .",
    "thus @xmath98 can also be obtained from @xmath92 by a @xmath291-operation .     and @xmath101 . ]    [ prop8 ]",
    "@xmath297 can be obtained from @xmath298 by trimming a bowtie ring .",
    "label the extra rows in @xmath299 that are not in @xmath245 as @xmath93 , @xmath188 , @xmath78 , and @xmath83 .",
    "then @xmath300 is the appropriate bowtie ring .",
    "recall that the mbius matroids are defined in .",
    "[ prop1 ] when @xmath301 is an even integer , the matroid @xmath302 can be obtained from @xmath303 by a ladder - compression move .",
    "recall that @xmath304 and @xmath305 , where @xmath306 is an extension of the rank-@xmath307 wheel by the element @xmath36 .",
    "assume that the spokes of @xmath308 , in cyclic order , are @xmath309 and that @xmath310 is a triangle of @xmath308 for @xmath311 .",
    "( we interpret subscripts modulo @xmath312 . ) then , for @xmath311 , the set @xmath313 is a cocircuit of @xmath314 .",
    "we obtain @xmath315 from @xmath314 by contracting @xmath316 and @xmath317 , and deleting @xmath318 and @xmath319 , and then relabelling @xmath320 as @xmath319 . to see this , observe that @xmath314 has @xmath321 and @xmath322 as circuits , so their symmetric difference , @xmath323 , is a disjoint union of circuits .",
    "orthogonality with the cocircuits containing @xmath36 implies that @xmath53 is a circuit of @xmath314 .",
    "next we note that @xmath324 is the symmetric difference of @xmath325 and @xmath326 , and is therefore a disjoint union of cocircuits .",
    "this implies that @xmath317 is not in the closure of @xmath53 in @xmath314 .",
    "therefore @xmath327 is a spanning circuit of @xmath328 , and it follows easily that this matroid is @xmath315 , up to relabelling .",
    "now we need only show that this operation is a ladder - compression move .",
    "we note that @xmath314 contains a ladder segment , as depicted in , where the labels @xmath329 , @xmath330 , @xmath331 , @xmath332 , @xmath333 , @xmath334 , @xmath198 , @xmath200 , @xmath335 , @xmath201 , @xmath199 , and @xmath336 are replaced by @xmath337 , @xmath338 , @xmath339 , @xmath340 , @xmath341 , @xmath342 , @xmath318 , @xmath316 , @xmath320 , @xmath317 , @xmath343 , and @xmath344 , respectively . because @xmath301 , these elements are all distinct .",
    "now implies that @xmath108 can be obtained from @xmath345 by a ladder - compression move .",
    "thus we have completed the proof of .",
    "if @xmath1 is @xmath133 , then we can set @xmath161 to be @xmath213 , and @xmath161 can be obtained from @xmath2 by a ladder - compression move . if @xmath1 is @xmath160 or @xmath135 , then we can set @xmath161 to be @xmath47 or @xmath108 , respectively . in either case , by , we can use a ladder - compression move to obtain @xmath163 from @xmath159 ( in the first case ) , or @xmath161 from @xmath2 ( in the second ) .",
    "assume that @xmath1 is a fascinating pair that contradicts the statement of the .",
    "certainly @xmath347 , since @xmath7 , and @xmath1 is a fascinating pair , so @xmath15 .",
    "assume that @xmath348 .",
    "first consider the case that @xmath349 , so that @xmath3 is isomorphic to @xmath107 .",
    "if @xmath2 has a proper minor , @xmath4 , such that @xmath350 , and @xmath4 is internally @xmath0-connected , then @xmath4 has an @xmath107-minor ( * ? ? ?",
    "* corollary  12.2.13 ) , and hence @xmath1 is not a fascinating pair .",
    "therefore @xmath2 has no such minor , so we can apply our chain theorem ( * ? ? ? * theorem  1.3 ) .",
    "since @xmath7 , it follows from that theorem that @xmath2 is the cycle matroid of a planar or mbius quartic ladder , or the dual of such a matroid .",
    "the only planar quartic ladder with fewer than @xmath351 edges is the octahedron , @xmath74 , which is the dual graph of @xmath73 , the cube .",
    "the only mbius quartic ladders with fewer than @xmath351 edges have @xmath83 or @xmath228 edges .",
    "the former has the latter as a minor , and the latter is isomorphic to @xmath27 .",
    "from this we deduce that , up to duality , @xmath1 is @xmath352 or @xmath353 , and that therefore @xmath1 is not a counterexample after all .",
    "hence @xmath354 .",
    "the only internally @xmath0-connected  binary matroids satisfying this constraint are @xmath67 , @xmath193 , and their duals .",
    "( this fact is ( * ? ? ?",
    "* lemma  2.1 ) , and will also be confirmed by the subsequent exhaustive search . )",
    "thus we can assume @xmath3 is @xmath67 or @xmath193 .    from this point",
    ", we use almost exactly the same arguments as in ( * ? ? ?",
    "* lemma  2.3 ) .",
    "assume @xmath3 is @xmath67 , so @xmath355 .",
    "we can use ( * ? ? ?",
    "* corollary  1.2 ) to deduce that @xmath2 is isomorphic to @xmath356 or @xmath357 , so @xmath1 fails to contradict the theorem .",
    "therefore we assume @xmath3 is @xmath193 , and hence @xmath358 .",
    "now we can use ( * ? ? ?",
    "* lemma  2.3 ) .",
    "this lemma defines five graphs , but only four of them have at least @xmath78 edges .",
    "therefore we can deduce that @xmath2 is isomorphic to one of the graphic matroids @xmath110 , @xmath111 , @xmath112 , or @xmath113 .",
    "again this is a contradiction , as it implies that @xmath1 is not a counterexample , so the proof of is complete .    at this point , it is appropriate to verify that the pairs mentioned in the proof of are indeed fascinating .",
    "we do this , and the rest of the search , using the matroid capabilities of sage ( version 6.10 ) .",
    "first we want to allow access to certain special functions of the sage matroids package .",
    ".... def isifc(m ) :      if len(m)<=7 :          return true      elif len(m)==8 or len(m)==9 :          return all ( ( m.rank(x)+               m.rank(m.groundset().symmetric_difference(x))-               m.rank ( ) > 2 ) for x in subsets(m.groundset(),4 ) )      elif len(m)==10 or len(m)==11 :          return all ( ( m.rank(x)+              m.rank(m.groundset().symmetric_difference(x))-              m.rank ( ) > 2 ) for x in subsets(m.groundset(),4 ) )              and all ( ( m.rank(x)+              m.rank(m.groundset().symmetric_difference(x))-              m.rank ( ) > 2 ) for x in subsets(m.groundset(),5 ) )      elif len(m)==12 or len(m)==13 :          return all ( ( m.rank(x)+              m.rank(m.groundset().symmetric_difference(x))-              m.rank ( ) > 2 ) for x in subsets(m.groundset(),4 ) )              and all ( ( m.rank(x)+              m.rank(m.groundset().symmetric_difference(x))-              m.rank ( ) > 2 ) for x in subsets(m.groundset(),5 ) )              and all ( ( m.rank(x)+              m.rank(m.groundset().symmetric_difference(x))-              m.rank ( ) > 2 ) for x in subsets(m.groundset(),6 ) )      elif len(m)==14 or len(m)==15 :          return all ( ( m.rank(x)+              m.rank(m.groundset().symmetric_difference(x))-              m.rank()>2 ) for x in subsets(m.groundset(),4 ) )              and all ( ( m.rank(x)+              m.rank(m.groundset().symmetric_difference(x))-              m.rank ( ) > 2 ) for x in subsets(m.groundset(),5 ) )              and all ( ( m.rank(x)+              m.rank(m.groundset().symmetric_difference(x))-              m.rank ( ) > 2 ) for x in subsets(m.groundset(),6 ) )              and all ( ( m.rank(x)+              m.rank(m.groundset().symmetric_difference(x))-              m.rank ( ) > 2 ) for x in subsets(m.groundset(),7 ) ) ....",
    "this command works for @xmath8-connected matroids with a ground set of size @xmath22 , where @xmath359 . for each such @xmath22 ,",
    "the command considers each subset , @xmath139 , of size between @xmath0 and @xmath360 , and checks that @xmath361 . if this is the case , it returns ` true ` , and otherwise it returns ` false ` .",
    "next we define a function that will test whether a pair @xmath1 is fascinating . in the following code , and elsewhere , note that the command ` range(n ) ` produces the list @xmath362 $ ] , and ` range(m , n ) ` produces @xmath363 $ ] .",
    ".... def fascinating(m , n ) :      rankgap = m.rank()-n.rank ( )      sizegap = len(m)-len(n )      if sizegap>3 and m.has_minor(n ) :          between = false          for r in range(rankgap+1 ) :              if between :                  break              for f in m.flats(r ) :                  if between :                      break                  if len(f)<sizegap and m.contract(f).has_minor(n ) :",
    "if r==0 :                          lower=1                      else :                          lower=0                      deleteset = m.groundset().difference(f )                      for i in range(lower , sizegap - len(f ) ) :                          if between :                              break                          for d in subsets(deleteset , i ) :                              test = m.contract(f).delete(d )                              if test.has_minor(n ) :                                  if test.is_3connected ( )                                      and isifc(test ) :                                         between = true                                         break          return not between      else :          return false ....",
    "first the function tests that @xmath2 has an @xmath3-minor and @xmath15 .",
    "if this is not the case , it returns ` false ` .",
    "otherwise , it considers all flats , @xmath364 , of @xmath2 such that @xmath365 .",
    "if @xmath366 has a proper @xmath3-minor , then it considers subsets , @xmath290 , of @xmath367 .",
    "if @xmath364 is the rank-@xmath225 flat ( which we assume to be empty ) , then @xmath290 is constrained to contain at least one element . in any case , @xmath290 is constrained so that @xmath368 .",
    "thus @xmath290 ranges over all subsets such that @xmath369 .",
    "if @xmath370 is internally @xmath0-connectedand has an @xmath3-minor , then the boolean value ` between ` is set to be ` true ` . at any time , if ` between ` is found to be ` true ` , then the function breaks out of the loop .",
    "finally , it returns the negation of ` between ` .      ....",
    "k4=matroids.completegraphic(4 ) k5=matroids.completegraphic(5 ) q3=matroid(graph = graphs.cubegraph(3 ) ) f7=matroids.named_matroids.fano ( ) upsilon6=matroids.named_matroids.t12().delete('e ' ) k33=matroid(graph = graphs.completebipartitegraph(3,3 ) ) h1=matroid(graph = graph({0:[1,2,4,5],1:[2,3,4,5],2:[3,4 ] ,     3:[4,5],4:[5 ] } ) ) h2=matroid(graph = graph({0:[1,3,5],1:[2,4,6],2:[3,5,6 ] ,     3:[4,6],4:[5,6 ] } ) ) h3=matroid(graph = graph({0:[1,3,7],1:[2,6],2:[3,5,7 ] ,     3:[4],4:[5,7],5:[6],6:[7 ] } ) ) qml7=matroid(graph = graphs.circulantgraph(7,[1,3,4 ] ) ) ....    .... print fascinating(k5,k4 ) print fascinating(q3,k4 ) print fascinating(upsilon6,f7 ) print fascinating(upsilon6.dual(),f7 ) print fascinating(h1,k33 ) print fascinating(h2,k33 ) print fascinating(h3,k33 ) print fascinating(qml7,k33 )      true      true      true      true      true      true      true      true ....        we create an object that will contain the catalogue of all @xmath8-connected binary matroids with ground sets of cardinality between @xmath49 and @xmath96 and rank at most @xmath79 .",
    "this object is a library , containing 10 lists , each indexed by an integer between @xmath49 and @xmath96 .",
    "each list itself contains eight lists , indexed by integers between @xmath225 and @xmath79 .",
    "thus , if @xmath373 , and @xmath374 , then ` catalogue[n][r ] ` is the list indexed by @xmath69 , contained in the list indexed by @xmath22 ; that is , it is the list of all @xmath8-connected binary matroids with rank @xmath69 and a ground set of size @xmath22 .",
    "we initialise by creating empty lists .",
    "every @xmath8-connected binary matroid with at least @xmath49 elements contains an @xmath107-minor ( * ? ? ?",
    "* corollary  12.2.13 ) . we are going to populate our catalogue by starting with this matroid , and enlarging the catalogue through single - element extensions and coextensions . when we extend , we ensure we produce no coloops , no loops , and no parallel pairs .",
    "dually , when we coextend , we create no loops , coloops , or series pairs .",
    "thus we only ever create @xmath8-connected matroids ( * ? ? ? * proposition  8.1.10 ) .",
    "every @xmath8-connected binary matroid can be constructed in this way , with the exception of wheels ( * ? ? ?",
    "* theorem  8.8.4 ) , so we manually input the wheels of rank @xmath8 , @xmath0 , @xmath99 , @xmath49 , and @xmath79 . in this way , we guarantee that our catalogue will contain every @xmath8-connected binary matroid with suitable size and rank .    ....",
    "wheel3=matroid(reduced_matrix = matrix(gf(2),[[1,0,1],[1,1,0 ] ,      [ 0,1,1 ] ] ) ) wheel4=matroid(reduced_matrix = matrix(gf(2),[[1,0,0,1 ] ,      [ 1,1,0,0],[0,1,1,0],[0,0,1,1 ] ] ) ) wheel5=matroid(reduced_matrix = matrix(gf(2),[[1,0,0,0,1 ] ,      [ 1,1,0,0,0],[0,1,1,0,0],[0,0,1,1,0],[0,0,0,1,1 ] ] ) ) wheel6=matroid(reduced_matrix = matrix(gf(2),[[1,0,0,0,0,1 ] ,      [ 1,1,0,0,0,0],[0,1,1,0,0,0],[0,0,1,1,0,0],[0,0,0,1,1,0 ] ,      [ 0,0,0,0,1,1 ] ] ) ) wheel7=matroid(reduced_matrix = matrix(gf(2),[[1,0,0,0,0,0,1 ] ,      [ 1,1,0,0,0,0,0],[0,1,1,0,0,0,0],[0,0,1,1,0,0,0 ] ,      [ 0,0,0,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1 ] ] ) ) ....                now we define the command ` populate ` , which we will use to fill in the entries in our catalogue . on input @xmath22 , the command fills in all entries of the catalogue corresponding to matroids with ground sets of size @xmath22 .",
    "it does this by letting the rank , @xmath69 , range from @xmath225 to @xmath79 , and considering all matroids of rank @xmath69 in the catalogue of matroids with ground sets of size @xmath375 . for each such matroid , @xmath3",
    ", it generates the list of non - isomorphic simple single - element extensions of @xmath3 , using the built - in command ` get_nonisomorphic_matroids ` .",
    "it then adds these extensions to the catalogue of rank-@xmath69 , size-@xmath22 matroids , as long as they are not isomorphic to matroids already appearing there .",
    "if @xmath69 is greater than zero , it then performs the same actions using cosimple single - element coextensions .",
    "finally , it prints the number of matroids it has generated .    .... def populate(n ) :      for r in range(8 ) :          for n in catalogue[n-1][r ] :              list = n.linear_extensions(simple = true , element = len(n ) )              list = get_nonisomorphic_matroids(list )              for m in list :                  if not any(l.is_isomorphic(m ) for                      l in catalogue[n][r ] ) :                      catalogue[n][r].append(m )          if r>0 :              for n in catalogue[n-1][r-1 ] :                  list = n.linear_coextensions(cosimple = true ,                          element = len(n ) )                  list = get_nonisomorphic_matroids(list )                  for m in list :                      if not any(l.is_isomorphic(m ) for                          l in catalogue[n][r ] ) :                          catalogue[n][r].append(m )      print [ len(catalogue[n][r ] ) for r in range(8 ) ] ....                          now we work through our catalogue of all @xmath8-connected binary matroids , and pick out those that are internally @xmath0-connected . as before",
    ", we create an object that will be our catalogue of internally @xmath0-connected  matroids .        .... def populateifc(n ) :      for r in range(8 ) :          for m in catalogue[n][r ] :              if isifc(m ) :                  ifccatalogue[n][r].append(m )      print [ len(ifccatalogue[n][r ] ) for r in range(8 ) ] ....              since @xmath67 and @xmath193 are internally @xmath0-connected , from these commands it follows that , as stated earlier , the only internally @xmath0-connected  binary matroids with seven , eight , or nine elements are @xmath67 , @xmath193 , and their duals .",
    "these computations show that there are exactly @xmath376 internally @xmath0-connected  binary matroids with ground sets of cardinality @xmath228 or @xmath93 .",
    "we put these matroids into a list of possible `` target '' matroids :    .... targets= [ ] targets.extend(ifccatalogue[10][4 ] ) targets.extend(ifccatalogue[10][5 ] ) targets.extend(ifccatalogue[10][6 ] ) targets.extend(ifccatalogue[11][4 ] ) targets.extend(ifccatalogue[11][5 ] ) targets.extend(ifccatalogue[11][6 ] ) targets.extend(ifccatalogue[11][7 ] ) ....    we wish to process each of the internally @xmath0-connectedmatroids in our catalogue with a ground set of cardinality @xmath93 , @xmath188 , @xmath78 , or @xmath83 , and record which of the @xmath376 `` target '' matroids it has as a proper minor .",
    "we start by creating a new list of lists of lists .    ....",
    "targetminors= { } for n in range(11,15 ) :      targetminors[n]= { }      for r in range(8 ) :          targetminors[n][r]= { }          for i in range(len(ifccatalogue[n][r ] ) ) :              targetminors[n][r][i]=[0 for j in range(24 ) ] ....    assume that @xmath22 is in @xmath377 , @xmath69 is in @xmath378 , and @xmath379 indexes an internally @xmath0-connected  matroid in the list ` ifccatalogue[n][r ] ` .",
    "the object ` targetminors[n][r][i ] ` is a list with @xmath376 entries , each equal to @xmath225 or @xmath226 .",
    "the entry ` targetminors[n][r][i][j ] ` will be equal to @xmath226 if and only if matroid number @xmath379 in the list ` ifccatalogue[n][r ] ` contains a proper minor isomorphic to matroid number @xmath380 in the list ` targets ` .",
    ".... % time for n in range(11,15 ) :      for r in range(8 ) :          for i in range(len(ifccatalogue[n][r ] ) ) :              m = ifccatalogue[n][r][i ]              for j in range(24 ) :                  n = targets[j ]                  if len(n)<len(m ) and m.has_minor(n ) :                      targetminors[n][r][i][j]=1      cpu time : 1797.00 s ,   wall time : 1797.06 s ....      .... % time for r in range(8 ) :      for i in range(len(ifccatalogue[15][r ] ) ) :          m = ifccatalogue[15][r][i ]          possibles = set(range(24 ) )          for k in range(24 ) :              if not m.has_minor(targets[k ] ) :                  possibles.discard(k )          for size in range(14,10,-1 ) :              if len(possibles)==0 :                  break              for rank in range(r , max(r-(15-size),0)-1,-1 ) :                  if len(possibles)==0 :                      break                  for j in range(len(ifccatalogue[size][rank ] ) ) :                      test = false                      for k in possibles :                          if targetminors[size][rank][j][k]==1 :                              test = true                              break                      if test :                          if m.has_minor(ifccatalogue[size][rank][j ] ) :                              for k in range(24 ) :                                  if targetminors[size][rank][j][k]==1 :                                      possibles.discard(k )                              if len(possibles)==0 :                                  break          for k in possibles :              print ( 15,r , i , k ) ....    this code lets the variable @xmath69 range between @xmath225 and @xmath79 . for each @xmath69 , the variable @xmath379 indexes a matroid , @xmath2 , contained in the list",
    "` ifccatalogue[15][r ] ` , and @xmath2 ranges over all matroids in this list .",
    "we are trying to determine if there is an fascinating pair , @xmath1 , that acts as a counterexample to the theorem .",
    "recall that implies that @xmath381 is @xmath228 or @xmath93 , and ` targets ` contains a list of the @xmath376 matroids with @xmath228 or @xmath93 elements that could possibly be @xmath3 .",
    "when processing @xmath2 , we set ` possibles ` to initially be @xmath382 .",
    "this set will record the indices of matroids in ` target ` that can possibly be @xmath3 .",
    "if @xmath2 does not contain a minor isomorphic to ` targets[k ] ` , then we discard @xmath307 from ` possibles ` . indeed , throughout the process",
    ", we seek to discard indices from ` possibles ` .",
    "if at any time , there are no indices left in ` possibles ` , then we know that @xmath2 can not be in the fascinating pair we seek , so we move to the next matroid . assuming that ` possibles ` is not empty , we let ` size ` range between @xmath83 and @xmath93 ( starting at @xmath83 ) , and we let ` rank ` range between @xmath69 and @xmath383 .",
    "we seek internally @xmath0-connected  matroids with the parameters ` size ` and ` rank ` that are proper minors of @xmath2 .",
    "( this is why we do not allow ` rank ` to be less than @xmath383 , since no minor of @xmath2 with ground set of cardinality ` size ` can have rank lower than this . )",
    "now we let @xmath380 index a matroid in the list ` ifccatalogue[size][rank ] ` .",
    "let the indexed matroid be @xmath4 . if @xmath4 has no minor isomorphic to ` targets[k ] ` , for any @xmath307 in ` possibles ` , then we will not be able to use @xmath4 to discard any more indices in ` possibles ` .",
    "so if this is the case , we do not consider @xmath4 any further . on the other hand , as soon as we find a @xmath307 in ` possibles ` such that @xmath4 has a minor isomorphic to ` targets[k ] ` , we move to the next stage of the process . in this stage , we first of all test that @xmath2 has an @xmath4-minor . in the case",
    "that it does , we let @xmath307 range through all of the indices in @xmath382 .",
    "if ` targetminors[size][rank][j][k ] ` is @xmath226 , indicating that @xmath4 has a minor isomorphic to ` targets[k ] ` , then we can discard @xmath307 from ` possibles ` , since the matroid @xmath4 means that no fascinating pair can contain @xmath2 and ` targets[k ] ` .",
    "we continue this process until either ` possibles ` is empty , or until we have examined every possible matroid @xmath4 .",
    "if ` possibles ` is not empty at this stage , we know that , for every @xmath307 in ` possibles ` , @xmath384})$ ] is a fascinating pair , so we print out the information ` ( 15,r , i , k ) ` , enabling us to identify the matroids in that pair .      ....",
    "( 15 , 6 , 445 , 5 ) ( 15 , 6 , 589 , 19 ) ( 15 , 6 , 5414 , 16 ) ( 15 , 7 , 0 , 4 ) ( 15 , 7 , 0 , 8) ( 15 , 7 , 34137 , 22 ) ( 15 , 7 , 34466 , 22 ) ( 15 , 7 , 34693 , 22 ) ( 15 , 7 , 34762 , 22 ) ( 15 , 7 , 34769 , 22 ) ( 15 , 7 , 35415 , 23 ) ( 15 , 7 , 35441 , 23 ) ( 15 , 7 , 35445 , 23 ) ( 15 , 7 , 35455 , 23 ) cpu time : 77608.72 s ,   wall time : 77606.78 s ....    we now seek to find the fascinating pairs , @xmath1 , where @xmath385 .",
    "this implies that @xmath386 . since the only matroids in the list ` targets ` with ground sets of cardinality @xmath228 are those with indices in @xmath387 , we change the code",
    "so that ` possibles ` is initially set to @xmath387 .",
    "we also let ` size ` range between @xmath78 and @xmath93 , instead of @xmath83 and @xmath93 .    .... % time for r in range(8 ) :      for i in range(len(ifccatalogue[14][r ] ) ) :          m = ifccatalogue[14][r][i ]          possibles = set(range(6 ) )          for k in range(6 ) :              if not m.has_minor(targets[k ] ) :                  possibles.discard(k )          for size in range(13,10,-1 ) :              if len(possibles)==0 :                  break              for rank in range(r , max(r-(14-size),0)-1,-1 ) :                  if len(possibles)==0 :                      break                  for j in range(len(ifccatalogue[size][rank ] ) ) :                      test = false                      for k in possibles :                          if targetminors[size][rank][j][k]==1 :                              test = true                              break                      if test :                          if m.has_minor(ifccatalogue[size][rank][j ] ) :                              for k in range(6 ) :                                  if targetminors[size][rank][j][k]==1 :                                      possibles.discard(k )                              if len(possibles)==0 :                                  break          for k in possibles :              print ( 14,r , i , k ) ....      .... ( 14 , 6 , 10 , 4 ) ( 14 , 6 , 14 , 4 ) ( 14 , 6 , 27 , 5 ) ( 14 , 6 , 1079 , 4 ) ( 14 , 6 , 1155 , 4 ) ( 14 , 6 , 1169 , 4 ) ( 14 , 6 , 1387 , 1 ) ( 14 , 7 , 3148 , 4 ) ( 14 , 7 , 3291 , 0 ) ( 14 , 7 , 3378 , 5 ) ( 14 , 7 , 3381 , 1 ) cpu time : 1073.44 s ,   wall time : 1072.64 s ....          therefore , amongst fascinating pairs , @xmath1 , with @xmath7 , there are , up to duality , two containing @xmath107 , two containing @xmath67 , and four containing @xmath193 .",
    "the computer search has found an additional @xmath388 pairs .",
    "all we need now do is confirm that these @xmath388 pairs are as described in , and that hence there are no counterexamples to .          ....",
    "q8cross = matroid(graph = graph({0:[1,5,7],1:[2,4],2:[3,6,7 ] ,                                     3:[4,6,7],4:[5],5:[6],6:[7 ] } ) ) y9=matroid(graph = graph({0:[1,3,5,7],1:[2,8],2:[3,6 ] ,                                     3:[4],4:[5,8],5:[6],6:[7],7:[8 ] } ) ) cml10=matroid(graph = graphs.circulantgraph(10,[1,5 ] ) )    print ifccatalogue[14][6][1387].is_isomorphic(qml7 ) print ifccatalogue[14][7][3381].is_isomorphic(q8cross ) print ifccatalogue[14][6][27].is_isomorphic(y9.dual ( ) ) print ifccatalogue[15][6][445].is_isomorphic(cml10.dual ( ) )      true      true      true      true ....      .... a = matrix(gf(2 ) , [ [ 1,0,0,1,1,1 ] , [ 1,1,0,0,1,0 ] , [ 0,1,1,0,1,1 ] , [ 0,0,1,1,1,0 ] ] ) delta4=matroid(reduced_matrix = a ) print targets[0].is_isomorphic(delta4 ) print targets[4].is_isomorphic(delta4.dual ( ) )      true      true ....      .... print ifccatalogue[14][6][10].is_isomorphic (      matroid(reduced_matrix = a.stack(matrix(gf(2 ) , [      [ 1,0,1,0,0,1 ] ,      [ 1,0,0,0,1,0 ] ,      [ 0,1,1,0,1,0 ] ,      [ 0,0,0,1,1,0]]))).dual ( ) ) print ifccatalogue[14][6][1079].is_isomorphic (      matroid(reduced_matrix = a.stack(matrix(gf(2 ) , [      [ 1,0,1,0,0,1 ] ,      [ 1,0,0,0,1,0 ] ,      [ 0,1,0,1,0,0 ] ,      [ 0,1,0,0,1,1]]))).dual ( ) ) print ifccatalogue[14][6][14].is_isomorphic (      matroid(reduced_matrix = a.stack(matrix(gf(2 ) , [      [ 1,0,1,0,0,0 ] ,      [ 1,0,0,0,1,0 ] ,      [ 0,1,0,1,0,1 ] ,      [ 0,0,0,1,1,0]]))).dual ( ) ) print ifccatalogue[14][6][1155].is_isomorphic (      matroid(reduced_matrix = a.stack(matrix(gf(2 ) , [      [ 1,0,1,0,0,0 ] ,      [ 1,0,0,0,1,0 ] ,      [ 0,1,0,1,0,0 ] ,      [ 0,0,0,1,1,0]]))).dual ( ) ) print ifccatalogue[14][6][1169].is_isomorphic (      matroid(reduced_matrix = a.stack(matrix(gf(2 ) , [      [ 1,0,0,0,1,0 ] ,      [ 0,1,1,0,1,0 ] ,      [ 0,1,0,1,0,1 ] ,      [ 0,0,1,1,0,0]]))).dual ( ) )      true      true      true      true      true ....      .... print ifccatalogue[14][7][3291].is_isomorphic (      matroid(reduced_matrix = a.stack(matrix(gf(2 ) , [      [ 1,1,0,0,1,0 ] ,      [ 1,0,0,0,1,0 ] ,      [ 1,0,0,0,0,0]])).augment(vector(gf(2),[1,1,0,0,0,0,1 ] ) ) ) )      true ....    ....",
    "upsilon8=matroid(reduced_matrix = matrix(gf(2 ) , [     [ 1,0,0,0,0,0,1,1 ] ,     [ 1,1,0,0,0,0,0,1 ] ,     [ 0,1,1,0,0,0,0,1 ] ,     [ 0,0,1,1,0,0,0,1 ] ,     [ 0,0,0,1,1,0,0,1 ] ,     [ 0,0,0,0,1,1,0,1 ] ,     [ 0,0,0,0,0,1,1,1]])).dual ( ) ifccatalogue[15][7][0].is_isomorphic(upsilon8.dual ( ) )     true ....          .... print ifccatalogue[15][7][34466].is_isomorphic (      matroid(reduced_matrix = b.stack(matrix(gf(2 ) , [      [ 1,1,0,0,0,0,1 ] ,      [ 1,0,1,1,0,1,0 ] ,      [ 0,1,0,0,0,1,0 ] ,      [ 0,0,0,1,1,0,0]]))).dual ( ) ) print ifccatalogue[15][7][34762].is_isomorphic (      matroid(reduced_matrix = b.stack(matrix(gf(2 ) , [      [ 1,0,1,1,0,1,0 ] ,      [ 1,0,0,1,0,0,1 ] ,      [ 0,1,0,0,0,0,1 ] ,      [ 0,0,0,0,1,1,1]]))).dual ( ) ) print ifccatalogue[15][7][34137].is_isomorphic (      matroid(reduced_matrix = b.stack(matrix(gf(2 ) , [      [ 1,0,1,1,0,1,0 ] ,      [ 1,0,0,0,0,0,1 ] ,      [ 0,1,0,0,1,0,0 ] ,      [ 0,0,1,0,1,0,1]]))).dual ( ) ) print ifccatalogue[15][7][34693].is_isomorphic (      matroid(reduced_matrix = b.stack(matrix(gf(2 ) , [      [ 1,0,1,1,0,1,0 ] ,      [ 0,1,1,0,0,0,1 ] ,      [ 0,1,0,1,0,0,0 ] ,      [ 0,0,0,0,1,0,1]]))).dual ( ) ) print ifccatalogue[15][7][34769].is_isomorphic (      matroid(reduced_matrix = b.stack(matrix(gf(2 ) , [      [ 1,0,1,0,0,0,1 ] ,      [ 1,0,0,1,0,0,1 ] ,      [ 0,1,0,0,0,1,1 ] ,      [ 0,0,0,0,1,1,1]]))).dual ( ) )      true      true      true      true      true ....",
    ".... print ifccatalogue[15][7][35455].is_isomorphic (      matroid(reduced_matrix = c.stack(matrix(gf(2 ) , [      [ 1,1,1,1,0,0,1 ] ,      [ 1,1,1,0,1,0,1 ] ,      [ 0,0,0,1,0,1,0 ] ,      [ 0,0,0,0,1,0,1]]))).dual ( ) ) print ifccatalogue[15][7][35441].is_isomorphic (      matroid(reduced_matrix = c.stack(matrix(gf(2 ) , [      [ 1,1,1,1,0,0,1 ] ,      [ 1,0,0,0,0,1,0 ] ,      [ 0,1,0,0,1,0,0 ] ,      [ 0,0,1,0,1,0,1]]))).dual ( ) ) print ifccatalogue[15][7][35445].is_isomorphic (      matroid(reduced_matrix = c.stack(matrix(gf(2 ) , [      [ 1,1,0,0,1,0,0 ] ,      [ 1,0,0,0,0,1,0 ] ,      [ 0,1,1,1,1,0,1 ] ,      [ 0,0,1,0,1,0,0]]))).dual ( ) ) print ifccatalogue[15][7][35415].is_isomorphic (      matroid(reduced_matrix = c.stack(matrix(gf(2 ) , [      [ 1,0,0,0,1,1,0 ] ,      [ 0,1,0,0,1,0,1 ] ,      [ 0,0,1,0,1,1,1 ] ,      [ 0,0,0,1,1,0,1]]))).dual ( ) )      true      true      true      true ....      .... d = matrix(gf(2 ) , [ [ 1,1,1,0,0,0 ] , [ 1,0,0,1,1,0 ] , [ 0,1,0,1,0,1 ] , [ 0,0,1,0,1,1 ] , [ 1,0,0,0,0,1 ] , ] ) r = matroid(reduced_matrix = d ) print targets[19].is_isomorphic(r.dual ( ) ) print ifccatalogue[15][6][589].is_isomorphic (      matroid(reduced_matrix = d.stack(matrix(gf(2 ) , [      [ 1,1,0,0,0,0 ] ,      [ 0,0,1,0,0,1 ] ,      [ 0,0,0,1,0,1 ] ,      [ 1,0,0,0,1,0]]))).dual ( ) )      true      true ....      .... e = matrix(gf(2 ) , [ [ 1,0,0,1,1,1 ] , [ 1,1,0,0,1,0 ] , [ 0,1,1,0,1,1 ] , [ 0,0,1,1,1,0 ] , [ 1,0,0,1,0,1 ] , ] ) s = matroid(reduced_matrix = e ) print targets[16].is_isomorphic(s.dual ( ) ) print ifccatalogue[15][6][5414].is_isomorphic (      matroid(reduced_matrix = f.stack(matrix(gf(2 ) , [      [ 1,0,0,0,1,0 ] ,      [ 1,0,0,0,0,1 ] ,      [ 0,1,0,1,0,1 ] ,      [ 0,0,1,1,0,0]]))).dual ( ) )      true      true ....          we have characterised all fascinating pairs satisfying @xmath7 . from this characterisation , it is straightforward to find all interesting pairs satisfying the same constraint .",
    "certainly every fascinating pair is an interesting pair .",
    "if @xmath420 is interesting but not fascinating , then there is an internally @xmath0-connected  matroid , @xmath421 , satisfying @xmath422 .",
    "now @xmath423 is an interesting pair , so we can repeat this argument and deduce that either @xmath423 is fascinating , or there is an internally @xmath0-connected  matroid , @xmath424 , satisfying @xmath425 .",
    "continuing in this way , we see that if @xmath420 is interesting but not fascinating , then @xmath426 for some internally @xmath0-connectedmatroid , @xmath3 , such that @xmath1 is a fascinating pair .",
    "this observation gives us our strategy for finding all interesting pairs .",
    "let @xmath1 range over all ( up to duality ) fascinating pairs with @xmath7 .",
    "consider each matroid , @xmath427 , from the catalogue of internally @xmath0-connectedmatroids , that could potentially be a proper minor of @xmath3 . if @xmath3 has a proper @xmath427-minor , then test to see whether any proper minor of @xmath2 produced by deleting and contracting at most three elements is internally @xmath0-connected  with a @xmath427-minor .",
    "if not , then @xmath428 is an interesting pair .",
    "the following code performs exactly such a check .",
    ".... def generateinteresting(m , n ) :      for n in range(6,len(n ) ) :          for r in range(n.rank()-(len(n)-n),n.rank()+1 ) :              for i in range(len(ifccatalogue[n][r ] ) ) :                  t = ifccatalogue[n][r][i ]                  if n.has_minor(t ) :                      between = false                      for p in range(min(m.rank()-t.rank(),3)+1 ) :                          if between :                              break                          for f in m.flats(p ) :                              if between :                                  break                              if len(f)<4 and                                          m.contract(f).has_minor(t ) :                                  if p==0 :                                      lower=1                                  else :                                      lower=0                                  deleteset=                                          m.groundset().difference(f )                                  for q in range(lower,4-len(f ) ) :                                      if between :                                          break                                      for d in subsets(deleteset , q ) :                                          test = m.contract(f).delete(d )                                          if test.has_minor(t ) :                                              if test.is_3connected ( )                                                      and isifc(test ) :                                                  between = true                                                  break                      if not between :                          print ( n , r , i ) ....      .... generateinteresting(k5,k4 ) generateinteresting(q3,k4 ) generateinteresting(upsilon7,f7 ) generateinteresting(upsilon6.dual(),f7 ) generateinteresting(h1,k33 ) generateinteresting(h2,k33 ) generateinteresting(h3,k33 ) generateinteresting(qml7,k33 )      ( 6 , 3 , 0 ) ....      .... generateinteresting(ifccatalogue[15][6][445],targets[5 ] ) generateinteresting(ifccatalogue[15][6][589],targets[19 ] ) generateinteresting(ifccatalogue[15][6][5414],targets[16 ] ) generateinteresting(ifccatalogue[15][7][0],targets[4 ] )      ( 7 , 3 , 0 )      ( 7 , 4 , 0 ) ....          .... generateinteresting(ifccatalogue[15][7][34137],targets[22 ] ) generateinteresting(ifccatalogue[15][7][34466],targets[22 ] ) generateinteresting(ifccatalogue[15][7][34693],targets[22 ] ) generateinteresting(ifccatalogue[15][7][34762],targets[22 ] ) generateinteresting(ifccatalogue[15][7][34769],targets[22 ] ) generateinteresting(ifccatalogue[15][7][35415],targets[23 ] ) generateinteresting(ifccatalogue[15][7][35441],targets[23 ] ) generateinteresting(ifccatalogue[15][7][35445],targets[23 ] ) generateinteresting(ifccatalogue[15][7][35455],targets[23 ] ) generateinteresting(ifccatalogue[14][6][10],targets[4 ] ) generateinteresting(ifccatalogue[14][6][14],targets[4 ] ) generateinteresting(ifccatalogue[14][6][27],targets[5 ] ) generateinteresting(ifccatalogue[14][6][1079],targets[4 ] ) generateinteresting(ifccatalogue[14][6][1155],targets[4 ] ) generateinteresting(ifccatalogue[14][6][1169],targets[4 ] ) generateinteresting(ifccatalogue[14][6][1387],targets[1 ] )      ( 6 , 3 , 0 ) ....      .... generateinteresting(ifccatalogue[14][7][3148],targets[4 ] ) generateinteresting(ifccatalogue[14][7][3291],targets[0 ] ) generateinteresting(ifccatalogue[14][7][3378],targets[5 ] ) generateinteresting(ifccatalogue[14][7][3381],targets[1 ] ) ...."
  ],
  "abstract_text": [
    "<S> our splitter theorem for internally @xmath0-connected binary matroids studies pairs of the form @xmath1 , where @xmath2 and @xmath3 are internally @xmath0-connected binary matroids , @xmath2 has a proper @xmath3-minor , and if @xmath4 is an internally @xmath0-connected matroid such that @xmath2 has a proper @xmath4-minor and @xmath4 has an @xmath3-minor , then @xmath5 . </S>",
    "<S> the analysis in the splitter theorem requires the constraint that @xmath6 . in this article , we complement that analysis by using an exhaustive computer search to find all such pairs for which @xmath7 . </S>"
  ]
}