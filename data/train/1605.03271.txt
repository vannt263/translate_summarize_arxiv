{
  "article_text": [
    "optimal placement of antennas , cameras , and light sources on terrains is important for communication network , security , and architectural design applications .",
    "even a consideration of the problem on 1.5d terrains is useful whenever the domain is a highway , street , or a hallway .",
    "this simpler version plays a role on the complexity analysis and algorithm design for the guarding problem on higher dimensional terrains .",
    "a 1.5d terrain @xmath0 is an @xmath5-monotone polygonal chain consists of @xmath2 vertices @xmath6 , for @xmath7 and @xmath8 edges @xmath9 for @xmath10 .",
    "@xmath0 is called an _ orthogonal terrain _",
    "if all its edges are either horizontal or vertical , and there are no two consecutive horizontal / vertical edges . for two vertices @xmath11",
    ", we say @xmath12 is left of @xmath13 , denoted as @xmath14 , if @xmath15 .",
    "the vertices of @xmath0 are indexed from left to right , so @xmath16 . for @xmath11 , @xmath12 can _ see _ @xmath13 if the line segment @xmath17 is never strictly below the terrain @xmath0 .",
    "given a terrain @xmath0 , a guarding candidate set @xmath18 and a witness set @xmath19 , terrain guarding problem tgp@xmath20 is to find the minimum guarding set @xmath21 such that each point in @xmath22 is seen by at least one point in @xmath23 . for orthogonal terrains ,",
    "we refer to this problem as otgp . here , we focus on solving otgp@xmath24 where both the guarding candidate set and the witness set are the vertices of the terrain , i.e. , @xmath25 .      the terrain guarding problem is closely related to the well known art gallery problem @xcite of finding the minimum set of positions to guard a polygon .",
    "the first result was obtained by chvtal : @xmath26 guards are always sufficient and sometimes necessary to guard a polygon of n vertices .",
    "art gallery problem was shown to be np - hard : on simple polygons @xcite , on simple orthogonal polygons @xcite , and on monotone polygons @xcite .",
    "moreover , it was shown to be apx - hard on simple polygons @xcite .",
    "terrain guarding problem for general 1.5d terrains is shown to be np - hard by a reduction from planar 3sat @xcite .",
    "ben - moshe _ et al_. @xcite gave the first @xmath27-approximation algorithm .",
    "al_. @xcite gave an improvement by showing that lp rounding results in a 4-approximation for tgp@xmath20 if @xmath28 ( a 5-approximation otherwise ) .",
    "a local search based ptas is also proposed for tgp @xcite .    for orthogonal terrains ,",
    "katz and roisman @xcite gave a 2-approximation algorithm that runs in o(@xmath29 ) time , by computing a minimum clique cover in chordal graphs .",
    "recently , durocher _",
    "et al_. @xcite studied the orthogonal terrain guarding problem under _ directed visibility _ where two vertices @xmath30 are considered to see each other only if the interior of the segment @xmath31 is strictly above the terrain . under this restricted definition ,",
    "no reflex vertex of the input terrain @xmath0 can see convex vertices both on its left and right side .",
    "this property simplifies the problem , and leads to a linear time greedy exact algorithm . under standard visibility , durocher _",
    "et al_. @xcite also observed that the hardness result for tgp in @xcite does not apply for orthogonal terrains , leaving the complexity of otgp open .",
    "we assume that the input terrain begins and ends with vertical edges , an assumption for technical convenience to be removed in the appendix .",
    "@xmath32 is split into two disjoint subsets as reflex vertices @xmath33 and convex vertices @xmath34 .",
    "walking along the orthogonal terrain @xmath0 from left to right , a vertex @xmath35 is _",
    "convex(reflex ) _ if we turn left(right ) at @xmath35 .",
    "each subset is further split into two subsets depending on whether a vertex is on the left or on the right side of its incident horizontal edge . specifically , walking along @xmath0 from left to right , a vertex @xmath35 is _",
    "left(right ) _ if we walk from a vertical(horizontal ) edge to a horizontal(vertical ) edge at @xmath35 .",
    "so , @xmath32 is split into four disjoint subsets : left reflex vertices @xmath36 , right reflex vertices @xmath37 , left convex vertices @xmath38 , and right convex vertices @xmath39 , see figure  [ figdefinition ] . the first and the last vertices of @xmath0",
    "can also be labelled simply by considering dummy horizontal edges incident to them .    for each @xmath40 , _",
    "upper vertex _ of @xmath35 , @xmath41 is the reflex vertex that shares a common vertical edge with @xmath35 , see figure  [ figdefinition ] . as @xmath0 begins and ends with vertical edges , @xmath42 for each convex vertex @xmath35",
    "is well defined .    for each @xmath43 ,",
    "_ right horizon _ of @xmath35 , @xmath44 is the rightmost reflex vertex that can see @xmath35 , see figure  [ figdefinition ] .",
    "this definition is similar to that of @xmath45 by durocher _",
    "et al_. @xcite except that a left convex vertex can not be seen by right reflex vertices under directed visibility but it can be seen by them under standard visibility .    following definition by lffler _",
    "et al . _  will also be used .    _",
    "@xcite _ given a reflex vertex @xmath46 and a vertex @xmath47 , the ray with origin @xmath46 and vector @xmath48 is called a _ shadow ray _ if : ( i ) @xmath46 sees @xmath49 ; ( ii ) @xmath46 does not see the points of @xmath0 immediately to the left of @xmath49 .    for each shadow ray @xmath48 , @xmath49 is called the _ obstacle _ of @xmath46 , @xmath50 . by definition",
    ", there may be multiple shadow rays for each vertex @xmath12 , corresponding to different obstacles .",
    "the sweepline algorithm presented in the next section relies on the following definition to identify a unique shadow ray ( and its obstacle ) .",
    "the shadow ray of @xmath12 with respect to the sweep line at event @xmath51 , @xmath52 , is defined as the highest shadow ray of @xmath12 whose obstacle is to the right of the sweep line at event @xmath51 , see figure  [ figshadowray ] . in the following sections , a shadow ray of @xmath12 refers to the shadow ray of @xmath12 with respect to the current sweep line . in our algorithm ,",
    "lower envelope of shadow rays is maintained to extract some essential visibility information efficiently .",
    "the following claim called _ the order claim _ was proved by ben - moshe _ et al_. @xcite , and holds in 1.5d general terrains .    _",
    "let @xmath53 be four points on terrain @xmath0 .",
    "if @xmath12 sees @xmath54 , and @xmath13 sees @xmath55 , then @xmath12 sees @xmath55 .",
    "[ lemmaorder ]    the following claims were proved by katz and roisman @xcite for orthogonal terrains .",
    "let @xmath0 be an orthogonal terrain , @xmath43 and another point @xmath12 on @xmath0 can see @xmath35 , then @xmath56 .",
    "[ lemmaconvex ]    _ @xcite _ if a set @xmath57 of points on orthogonal terrain @xmath0 guards a subset @xmath58 , then there exists a subset @xmath59 , such that @xmath60 guards @xmath61 and @xmath62 .",
    "[ lemmareflexsub ]    _ @xcite _ if @xmath63 guards all the convex vertices of an orthogonal terrain @xmath0 ( i.e. , @xmath57 guards the set @xmath34 ) , then @xmath57 guards all the vertices of @xmath0 .",
    "[ lemmareflexenough ]",
    "given an orthogonal terrain @xmath0 , our algorithm computes a subset of @xmath32 that can guard all vertices of @xmath0 , and we prove that the output of our algorithm is at most twice the size of the optimal solution for otgp@xmath24 .    by lemmas  [ lemmareflexsub ] and  [ lemmareflexenough ] , our problem can be reduced to otgp@xmath64 @xcite .",
    "let @xmath65 be an optimal solution for otgp@xmath64 , @xmath66 can guard all convex vertices .",
    "so , of course , @xmath66 can guard all left convex vertices , i.e. , @xmath66 has at least the same size as the optimal solution for otgp@xmath67 .",
    "the same is true for @xmath39 , the right convex vertices .",
    "our algorithm first computes the optimal solutions for otgp@xmath67 and otgp@xmath68 , then take the union of these two sets .",
    "our solution can guard all convex vertices , and has the size at most twice as @xmath66 , which means it is a 2-approximation .    in the following sections",
    ", we will present a sweep line algorithm that computes the optimal solution for otgp@xmath67 .",
    "the right convex vertices part is symmetric .",
    "our algorithm sweeps the terrain from right to left and put each left convex vertex @xmath69 into an associated list of a unique reflex vertex @xmath35 , called @xmath70 .",
    "when the algorithm terminates , the set of all vertices with non - empty associated lists forms the solution , with each reflex vertex responsible to guard all left convex vertices in its associated list .",
    "in addition to the associated lists , following data structures are used :    \\(1 ) a modified stack @xmath71 to store a set of all reflex vertices each with a non - empty associated list and can potentially guard more left convex vertices beyond the sweep line .",
    "in addition to the standard stack operations ( top , pop , push ) , this modified data structure also supports deletion from any place in the stack given a pointer to that element . along with each vertex in @xmath71",
    ", we also dynamically maintain its obstacle which defines the unique shadow ray with respect to the current sweep line .",
    "\\(2 ) a heap , @xmath72 , to maintain the interior intersections of shadow rays of vertices adjacent in @xmath71 .",
    "\\(3 ) an event queue @xmath73 consists of two components , a list @xmath74 to keep all vertices of @xmath0 , and a pointer @xmath75 for @xmath72 .",
    "next event is the rightmost vertex / intersection from @xmath74 and @xmath75 . after handling an event ,",
    "we delete it from the corresponding component of the queue .",
    "\\(4 ) a standard stack , @xmath76 , to store the upper hull used for computing right horizons @xmath45 .    for each vertex @xmath35 in @xmath71 , we keep two pointers for the shadow ray intersections with its two neighbors .",
    "pointers corresponding to missing neighbors / intersections are set to null .",
    "symmetrically , for each intersection in @xmath72 , we use two pointers to reach the origins of the corresponding shadow rays in @xmath71 .      to compute @xmath45 , the rightmost vertex visible from a left convex vertex @xmath35",
    ", we use the sweep line algorithm for computing the upper hull of a point set .",
    "let @xmath35 be a left convex vertex .",
    "if @xmath35 is the rightmost vertex on terrain @xmath0 , @xmath77 . otherwise , @xmath45 is the vertex right next to @xmath35 on the upper hull of all vertices to the right of @xmath35 together with @xmath35 .",
    "if @xmath35 is the rightmost vertex , it is easy to see that @xmath42 is the rightmost reflex vertex that can see @xmath35 , i.e. , @xmath77 .",
    "otherwise , @xmath35 is always on the upper hull of the considered vertices since it is the leftmost one .",
    "there must be some vertex to the right of @xmath35 on the upper hull , because the rightmost vertex is always on the upper hull .",
    "let @xmath12 be the vertex next to @xmath35 on the upper hull , so @xmath78 is nowhere below the terrain , i.e. , @xmath12 can see @xmath35 . for any vertex @xmath13 to the right of @xmath12 , as the property of upper hull , we have @xmath12 higher than @xmath79 , which means @xmath13 can not see @xmath35 .",
    "so @xmath80 .    with the upper hull of the swept vertices maintained in @xmath76 , @xmath45 of a vertex @xmath35 on the sweep line can be found in constant time . since @xmath0 is x - monotone",
    ", @xmath76 can be maintained in linear time .",
    "our algorithm which sweeps the terrain from right to left is depicted below .",
    "handling of each event consists of updates on the relevant data structures , described below after observation [ limitedvisibility ] which motivates the first step in handling a right reflex vertex event .",
    "initialize @xmath72 , @xmath71 and all @xmath70 to be empty initialize @xmath73 using @xmath0 and @xmath72 let @xmath35 be next event in @xmath81 update @xmath76 [ opupdate ] handle the vertex @xmath35 [ ophandle ] handle the intersection @xmath35 return @xmath82    [ algosweep ]    a right reflex vertex can see at least one left convex vertex which is right below it , and at most two left convex vertices .",
    "[ limitedvisibility ]    1 .   left convex vertex @xmath35 : + \\(i ) repeatedly pop(@xmath71 ) , until top(@xmath71 ) can see @xmath35 or top(@xmath71 ) is to the right of @xmath45 .",
    "+ \\(ii ) if top(@xmath71 ) sees @xmath35 , add @xmath35 to @xmath83(top(@xmath71 ) ) .",
    "otherwise , push @xmath45 to @xmath71 , add @xmath35 to @xmath84 , and set @xmath85 be @xmath35 , see figure  [ figdummyshadowray ] .",
    "@xmath86 is called a _ dummy shadow ray_. 2 .",
    "right convex vertex @xmath35 : the only update is to @xmath76 ( in line  [ opupdate ] ) , so nothing to be done in line  [ ophandle ] .",
    "3 .   left reflex vertex @xmath35 : + \\(i ) repeatedly pop(@xmath71 ) until top(@xmath71 ) can not see @xmath35 .",
    "push back the last popped vertex that can see @xmath35 , and update its obstacle to be @xmath35 , see figure  [ figleftreflex ] .",
    "+ \\(ii ) whenever deleting a vertex from @xmath71 , remove its corresponding intersections from @xmath72 . for the vertex that is pushed to @xmath71 , insert the shadow ray intersection with its neighbor to @xmath72 and set the corresponding pointers .",
    "right reflex vertex @xmath35 : + \\(i ) let @xmath69=top(@xmath71 ) .",
    "iteratively pop(@xmath71 ) if top(@xmath71 ) is lower than @xmath35 .",
    "if @xmath69 is lower than @xmath35 and there is only one vertex @xmath12 in @xmath87 , delete @xmath12 from @xmath87 , add @xmath12 to @xmath70 , and push @xmath35 to @xmath71 , see figure  [ figrightreflex ] . to correctly compute the intersections introduced by the new vertex @xmath35 in @xmath71 , we set @xmath88 one step ahead to be the vertex who shares the same horizontal edge with @xmath35 .",
    "+ \\(ii ) delete all vertices in @xmath71 that can see @xmath35 except for the rightmost one .",
    "+ \\(iii ) update intersections in @xmath72 as in 3(ii ) .",
    "intersection @xmath35 : + \\(i ) if intersection @xmath35 is above terrain @xmath0 , delete all vertices from @xmath71 , whose shadow rays are incident in @xmath35 , except for the rightmost one , see figure  [ figintersection ] .",
    "+ \\(ii ) update the intersections and pointers as in 3(ii )    0.49 : remove reflex vertices from @xmath71 that are to the left of @xmath45 and can not see @xmath35 , and add dummy shadow ray .",
    "( b ) @xmath89 : remove all vertices from @xmath71 that can see @xmath35 except the rightmost one .",
    "( c ) @xmath90 : delete all vertices that are lower than @xmath35 .",
    "if @xmath91 contains only one vertex , push @xmath35 .",
    "( d ) intersection @xmath35 : delete all vertices whose shadow rays are incident in @xmath35 except the rightmost one .",
    ", title=\"fig : \" ]    0.49 : remove reflex vertices from @xmath71 that are to the left of @xmath45 and can not see @xmath35 , and add dummy shadow ray .",
    "( b ) @xmath89 : remove all vertices from @xmath71 that can see @xmath35 except the rightmost one .",
    "( c ) @xmath90 : delete all vertices that are lower than @xmath35 .",
    "if @xmath91 contains only one vertex , push @xmath35 .",
    "( d ) intersection @xmath35 : delete all vertices whose shadow rays are incident in @xmath35 except the rightmost one .",
    ", title=\"fig : \" ]    0.49 : remove reflex vertices from @xmath71 that are to the left of @xmath45 and can not see @xmath35 , and add dummy shadow ray .",
    "( b ) @xmath89 : remove all vertices from @xmath71 that can see @xmath35 except the rightmost one .",
    "( c ) @xmath90 : delete all vertices that are lower than @xmath35 . if @xmath91 contains only one vertex , push @xmath35 .",
    "( d ) intersection @xmath35 : delete all vertices whose shadow rays are incident in @xmath35 except the rightmost one .",
    ", title=\"fig : \" ]    0.49 : remove reflex vertices from @xmath71 that are to the left of @xmath45 and can not see @xmath35 , and add dummy shadow ray .",
    "( b ) @xmath89 : remove all vertices from @xmath71 that can see @xmath35 except the rightmost one .",
    "( c ) @xmath90 : delete all vertices that are lower than @xmath35 .",
    "if @xmath91 contains only one vertex , push @xmath35 .",
    "( d ) intersection @xmath35 : delete all vertices whose shadow rays are incident in @xmath35 except the rightmost one .",
    ", title=\"fig : \" ]      we say a stack satisfies _ left to right order _ if the vertices in the stack from top to bottom are ordered from left to right on the terrain .",
    "we say a stack satisfies _ lower to higher order _ if the vertices in the stack from top to bottom are ordered from lower to higher on the terrain .",
    "if the stack satisfies both left to right order and lower to higher order , we say the stack is _ in order_.    @xmath71 is always in order throughout algorithm  [ algosweep ] .",
    "the slope of each shadow ray is never negative , i.e. , for each vertex @xmath69 in @xmath71 , @xmath92 is never higher than @xmath69 .",
    "( by induction . )",
    "initially , @xmath71 is empty .",
    "so the base case is trivial .",
    "suppose before sweeping to event @xmath35 , @xmath71 is in order and @xmath92 is no higher than @xmath69 for each @xmath69 in @xmath71 .",
    "\\(1 ) if @xmath35 is a left convex vertex , there are two cases .",
    "( i ) if there exists any vertex in @xmath71 that can see @xmath35 , we only pop vertices from @xmath71 , so it is still in order .",
    "( ii ) if no vertex can see @xmath35 , all vertices to the left of @xmath45 are deleted , and @xmath45 is pushed into @xmath71 .",
    "so , the left to right order is maintained .",
    "next , we need to prove that all remaining vertices in @xmath71 are no lower than @xmath45 .",
    "suppose there exists such vertex @xmath69 in @xmath71 that is lower than @xmath45 .",
    "then a walk from @xmath45 to @xmath69 on the terrain must go down a right reflex vertex @xmath51 that is higher than @xmath69 .",
    "it is easy to see that @xmath69 can not see any left convex vertex between @xmath45 and @xmath51 , so it must be pushed before sweeping to @xmath51 .",
    "however , when the sweep line arrives at @xmath51 , @xmath69 is deleted from @xmath71 as it is lower than @xmath51 as we will prove shortly .",
    "it is a contradiction .",
    "so all the other vertices are higher than @xmath45 .",
    "also it is easy to see that the slope of dummy shadow ray @xmath86 is positive .",
    "\\(2 ) if @xmath35 is a right convex vertex , the only operation is updating the upper hull , @xmath71 remains the same .",
    "\\(3 ) if @xmath35 is a left reflex vertex , we delete some vertices from @xmath71 and update the obstacle of a vertex @xmath12 to be @xmath35 . as @xmath12",
    "can see @xmath35 and @xmath35 is a left reflex vertex , @xmath35 is no lower than @xmath12 .",
    "\\(4 ) if @xmath35 is a right reflex vertex , as @xmath71 is in order by induction , step 4(i ) ensures all the vertices that are lower than @xmath35 are deleted .",
    "then if we push @xmath35 back to @xmath71 , it is in order .",
    "our newly introduced shadow ray is horizontal and the remaining operations are deletions .",
    "\\(5 ) if @xmath35 is an intersection , we only delete some vertices from @xmath71 .",
    "other than these events , @xmath71 will not change .",
    "so we can conclude that @xmath71 is always in order and the slope of each shadow ray is never negative .    as a result of this lemma along with the definition of shadow ray",
    ", we can see that the obstacles can only be left reflex vertices except for the dummy shadow rays .    for each vertex @xmath35 in @xmath71 , @xmath35 and @xmath88",
    "correctly define @xmath93 where @xmath51 is the current event .",
    "shadow rays of vertices in @xmath71 have no pairwise interior intersections to the right of @xmath51 , and are ordered from lower to higher corresponding to the order of their origins in @xmath71 , with the lowest shadow ray corresponding to top(@xmath71 ) .",
    "( by induction . )",
    "initially , @xmath71 is empty , hence the base case is trivial .",
    "suppose before dealing with event @xmath51 the claim holds .",
    "\\(1 ) @xmath51 is a left convex vertex : the shadow rays remain the same if the lowest shadow ray can see @xmath51 .",
    "otherwise , the vertices lower than @xmath94 are deleted , and @xmath94 is pushed into @xmath71 with @xmath95 .",
    "let @xmath69 be the vertex next to top(@xmath71 ) . by definition",
    ", @xmath96 should be no lower than @xmath94 .",
    "@xmath69 can not see @xmath51 as it is to the right of @xmath94 , i.e. , @xmath96 is higher than @xmath51 .",
    "so , @xmath96 is higher than @xmath97 and no interior intersection is introduced to the right of @xmath51 .",
    "the lemma holds .",
    "\\(2 ) @xmath51 is a right convex vertex : the shadow rays remain the same .",
    "\\(3 ) @xmath51 is a left reflex vertex : it is the only place we may need to update obstacles to keep the shadow rays correct . as the shadow rays are in order from lower to higher , all the vertices that can see @xmath51 are near the top of @xmath71 and are consecutive .",
    "so , our algorithm correctly finds all shadow rays that need to be updated .",
    "we delete all of them except the highest shadow ray which correspond to the rightmost vertex @xmath35 in @xmath71 that is visible from @xmath51 , then update @xmath93 .",
    "similar to the arguments in case ( 1 ) , @xmath93 is lower than the shadow rays of all vertices in @xmath71 .",
    "\\(4 ) @xmath51 is a right reflex vertex : the only place to push a vertex to @xmath71 is the first step and it can only push @xmath51 .",
    "suppose @xmath51 is pushed into @xmath71 . in the second step ,",
    "if @xmath51 is higher than the shadow ray of @xmath12 to its right in @xmath71 , we will delete @xmath51 from @xmath71 .",
    "otherwise the shadow ray of @xmath51 is also lower than the shadow rays of all the other vertices in @xmath71 .",
    "\\(5 ) @xmath51 is an intersection : under the induction assumption , the rightmost intersection appears between shadow rays of adjacent vertices in @xmath71 .",
    "the way we maintain @xmath72 ensures @xmath51 as the rightmost intersection . all shadow rays incident in @xmath51",
    "are deleted except one , so @xmath51 disappears .",
    "we say a point @xmath98 dominates point @xmath99 , if @xmath12 can see every point @xmath43 to the left of the sweep line that is visible by @xmath13 .",
    "all vertices deleted from @xmath71 are either dominated by some vertex in @xmath71 at the end of current iteration , or can not see any left convex vertex to the left of current sweep line .",
    "[ correctlemma ]    consider five types of event @xmath35 :    \\(1 ) @xmath35 is a left convex vertex : we prove that all deleted vertices are dominated by the vertex whose associated list contains @xmath35 at the end of current iteration .",
    "let this vertex be @xmath12 . as @xmath71 is in order , any deleted",
    "vertex @xmath69 is to the left of @xmath12 and to the right of @xmath35 .",
    "suppose @xmath69 can see @xmath13 to the left of the sweep line .",
    "so we have @xmath100 , @xmath13 can see @xmath69 , and @xmath35 can see @xmath12 . according to lemma  [ lemmaorder ] , @xmath13 can see @xmath12 ; hence , @xmath12 dominates @xmath69 .",
    "\\(2 ) @xmath35 is a right convex vertex : no vertex is deleted .",
    "\\(3 ) @xmath35 is a left reflex vertex : let @xmath12 be the rightmost vertex in @xmath71 that can see @xmath35 .",
    "we prove that all deleted vertices are dominated by @xmath12 .",
    "any deleted vertex @xmath69 must see @xmath35 .",
    "hence , @xmath101 . using a proof similar to case ( 1 ) and",
    "lemma  [ lemmaorder ] , we conclude that @xmath12 dominates @xmath69 .",
    "\\(4 ) @xmath35 is a right reflex vertex : all vertices deleted in the first step are lower than @xmath35 , so they can not see any left convex vertex to the left of the sweep line .",
    "similar to case ( 3 ) , all vertices deleted in the second step are dominated by the rightmost one in @xmath71 that can see @xmath35 .",
    "\\(5 ) @xmath35 is an intersection : we prove that all deleted vertices are dominated by the rightmost vertex @xmath12 in @xmath71 whose shadow ray crosses @xmath35 . as",
    "@xmath71 is in order , any deleted vertex @xmath69 is lower than and to the left of @xmath12 .",
    "suppose @xmath69 can see @xmath13 to the left of the sweep line , i.e. , @xmath102 .",
    "segment @xmath103 is nowhere below the terrain @xmath0 and intersects segment @xmath78 in its interior .",
    "so @xmath104 is nowhere below the terrain @xmath0 , which means @xmath12 can see @xmath13 , see figure  [ figintersectionlemma ] .    :",
    "@xmath69 is dominated by @xmath12 . ]    applying lemma  [ correctlemma ] , we can get the following corollary .    for any @xmath105 ,",
    "if @xmath35 is seen by some vertex in @xmath71 before the sweep line reaches @xmath35 , then @xmath35 is seen by some vertex in @xmath71 when the sweep line arrives at @xmath35 .",
    "[ cor : see ]    let our solution be set @xmath57 , so we have for each @xmath106 , @xmath107 is not empty .    for each left convex vertex @xmath35 , there is a unique @xmath108 such that @xmath109 .",
    "[ lem : outputsize ]    before the sweep reaches @xmath35 , @xmath35 is not added to the list of any vertex .",
    "when the sweep line arrives at @xmath35 , @xmath35 is added to some list @xmath87 .",
    "after that , the only operation that may change the list containing @xmath35 is the first step in handling right reflex vertex .",
    "if @xmath87 contains some vertex other than @xmath35 , @xmath35 will be in @xmath87 till the end of the algorithm .",
    "if @xmath87 contains only @xmath35 , when @xmath69 is popped in the first step of handling right reflex vertex @xmath51 , @xmath35 will be deleted from @xmath87 and added to @xmath110 , then it will never change . in either case ,",
    "when the algorithm terminates , there is a unique @xmath108 such that @xmath109 .",
    "optimality of @xmath57 will be based on the following set definition also appears in @xcite .",
    "let @xmath111 is the first left convex vertex in @xmath107 , for each @xmath112 .",
    "observe that the sizes of the sets of @xmath113 and @xmath57 are the same , i.e. , @xmath114 .",
    "moreover , for any vertex @xmath115 , we know that when the sweep line arrives at @xmath35 , there is no vertex in @xmath71 that can see @xmath35 .    for any two vertices",
    "@xmath116 , there are no reflex vertices that can see both of them .    to prove by contradiction , suppose @xmath51 is a reflex vertex that can see both @xmath117 . without loss of generality ,",
    "let @xmath118 , so we visit @xmath35 first .",
    "then we prove that there exists some vertex in @xmath71 that can see @xmath69 before the sweep line reaches @xmath69 .",
    "case 1 : @xmath51 is a left reflex vertex : we have @xmath119 . by definition of @xmath45 , @xmath120 . using lemma  [ lemmaorder ]",
    ", @xmath45 can see @xmath69 . when we visit @xmath35 , we add @xmath45 to @xmath71 .",
    "case 2 : @xmath51 is a right reflex vertex : @xmath51 should be @xmath42 . it is easy to see that @xmath45 is top(@xmath71 ) when the sweep line arrives at @xmath51 . if @xmath45 is higher than @xmath42 , @xmath121 is nowhere below the terrain @xmath0 , @xmath45 can see @xmath69 .",
    "otherwise , @xmath45 is popped in the first step as it is lower than @xmath51 , and @xmath51 is pushed into @xmath71 as @xmath84 contains only @xmath35 .    in",
    "either case there exists some vertex in @xmath71 that can see @xmath69 before the sweep line reaches @xmath69 . by corollary",
    "[ cor : see ] , there exists some vertex in @xmath71 when the sweep line arrives at @xmath69 , which contradicts that @xmath122 .",
    "lemma [ lem : outputsize ] implies that the optimal solution of otgp@xmath123 has at least @xmath124 reflex vertices .",
    "our solution can see all left convex vertices and has size @xmath125 .",
    "so we have the following result .",
    "algorithm  [ algosweep ] computes the optimal solution for otgp@xmath123 .",
    "symmetrically we can compute the optimal solution for otgp@xmath126 , leading to a 2-approximation algorithm for the otgp@xmath24 .",
    "let @xmath127 be the size of @xmath71 , and @xmath128 be the number of vertices with non - empty lists outside @xmath71 .",
    "it is easy to see that the summation of @xmath127 and @xmath128 never decreases and eventually it will be @xmath3 , where @xmath3 is the output size . as the number of intersections of shadow rays of adjacent vertices in @xmath71 is less than @xmath127 ,",
    "the size of @xmath72 is @xmath129 .",
    "note that @xmath128 is increased by at least 1 when handling each intersection .",
    "thus there are @xmath129 intersection events .",
    "then we analyse the running time associated with each data structure .",
    "\\(1 ) @xmath76 .",
    "maintenance of upper hull takes @xmath130 total time .",
    "\\(2 ) @xmath71 .",
    "the running time is proportional to the cost of stack insertions and deletions .",
    "each deleted vertex when handling right reflex vertex @xmath35 is lower than @xmath35 and all the other deleted vertices are dominated by some vertex in @xmath71 by lemma  [ correctlemma ] .",
    "so the deleted vertices can not be inserted again in future iterations .",
    "each operation takes constant time .",
    "the total running time is @xmath130 .",
    "\\(3 ) @xmath72 and @xmath73 .",
    "there are four cases .",
    "( i ) get the next event . if the next event is from @xmath74 , it takes constant time and there are @xmath2 such events , so it takes @xmath130 time in total ; if next event is from @xmath75 , it takes @xmath131 time and there are @xmath129 intersections , so it takes @xmath132 in total .",
    "( ii ) insert vertices into @xmath71 .",
    "there are @xmath130 insertions and constant number of new intersections with each insertion , so the time complexity is @xmath133 in total .",
    "( iii ) delete vertices from @xmath71 .",
    "similar to case ( ii ) .",
    "( iv ) update obstacles .",
    "we need to update at most one obstacle at any left reflex vertex , along with two deletions and one insertion with @xmath72 .",
    "as there are @xmath130 left reflex vertices , the total running time is @xmath133 .",
    "overall , the running time is @xmath133 .",
    "99    b.  ben - moshe , m.j .",
    "katz , and j.s.b .",
    "mitchell . a constant  factor approximation algorithm for optimal 1.5d terrain guarding .",
    ", 36(6):16311647 , 2007 .",
    "s.  durocher , p.c .",
    "li , and s.  mehrabi .",
    "guarding orthogonal terrains . in _ proc .",
    "of 27th canadian conf . on comp . geometry _ , 220227 , 2015 .",
    "s.  eidenbenz , c.  stamm , and p.  widmayer .",
    "inapproximability results for guarding polygons and terrains . , 31:79113 , 2001 .",
    "k.  elbassioni , e.  krohn , d.  matijevi , j.  mestre , and d.  everdija . improved approximations for guarding 1.5-d terrains .",
    ", 60:451463 , 2011 .",
    "s.  friedrichs , m.  hemmer , and c.  schmidt .",
    "a ptas for the continuous 1.5d terrain guarding problem . in _ proc .  of 26th cccg _ , 367373 , 2014 .",
    "m.  gibson , g.  kanade , e.  krohn , and k.varadarajan .",
    "an approximation scheme for terrain guarding .",
    "approx _ , springer - lncs:5687 , 140148 , 2009 .",
    "m.  j. katz and g.  s. roisman . on guarding the vertices of rectilinear domains .",
    ", 39(3):219  228 , 2008 .    j.  king and e.  krohn .",
    "terrain guarding is np - hard .",
    "40(5):13161339 , 2011 .    e.  a. krohn and b.  j. nilsson .",
    "approximate guarding of monotone and rectilinear polygons .",
    ", 66(3):564594 , 2013 .",
    "d.  lee and a.  lin .",
    "computational complexity of art gallery problems .",
    ", 32(2):276282 , 1986 .",
    "m.  lffler , m.  saumell , and r.  i. silveira . a faster algorithm to compute the visibility map of a 1.5d terrain . in _ proc .  of 30th eurocg _ , 2014 .",
    "j.  orourke . .",
    "oxford univ .  press , new york , ny , usa , 1987 .",
    "d.  schuchardt and h .- d .",
    "two np - hard art - gallery problems for ortho - polygons . , 41(2):261267 , 1995 .",
    "we show how to remove the restriction when both sides are horizontal , and it is easier if only one side is horizontal .    first we extend the terrain by adding two edges .",
    "let the leftmost vertex be @xmath69 , and the rightmost vertex be @xmath35 .",
    "we add two vertical edges @xmath134 and @xmath135 with infinitesimal length to both of them .",
    "the newly added vertex is the upper endpoint of the new edge .",
    "let the extended terrain be @xmath136 .",
    "we have @xmath137 .",
    "the cardinality of the optimal solution for otgp@xmath24 is the same as the cardinality of the optimal solution for otgp@xmath139 , and we can easily transform from the solution of the latter to the solution of the former .",
    "let @xmath57 be an optimal solution for otgp@xmath24 , @xmath60 be an optimal solution for otgp@xmath139 .",
    "suppose @xmath108 can see @xmath69 , @xmath140 can also see @xmath141 , so @xmath141 is seen by @xmath57 .",
    "similarly , @xmath138 is also seen by @xmath57 .",
    "@xmath142 , we have @xmath57 is a solution for otgp@xmath139 . @xmath143 .",
    "if neither of @xmath141 and @xmath138 is in @xmath60 , then @xmath144 and @xmath60 can see @xmath32 , so @xmath60 is a solution for otgp@xmath24 .",
    "if @xmath146 , there are two cases depending on the vertex next to @xmath35 .",
    "if the vertex next to @xmath35 is a left convex vertex as in figure  [ figfirsthorzontala ] .",
    "@xmath138 can only see @xmath12 , @xmath147 and @xmath35 , so we can replace @xmath138 with @xmath147 .",
    "it is easy to see that @xmath147 is not in @xmath60 , otherwise we get a better solution than @xmath60 for otgp@xmath139 , it is a contradiction .",
    "similarly we can find a replacement for @xmath138 when the vertex next to @xmath35 is a reflex vertex , see figure  [ figfirsthorzontalb ] .",
    "we can also find a replacement for @xmath141 if @xmath148 symmetrically .",
    "suppose we get an optimal solution @xmath149 for otgp@xmath139 after replacements .",
    "it is easy to see that @xmath150 and @xmath149 can see @xmath32 , so @xmath149 is an solution for otgp@xmath24 . @xmath151 ."
  ],
  "abstract_text": [
    "<S> terrain guarding problem(tgp ) , which is known to be np - complete , asks to find a smallest set of guard locations on a terrain @xmath0 such that every point on @xmath0 is visible by a guard . here </S>",
    "<S> , we study this problem on 1.5d orthogonal terrains where the edges are bound to be horizontal or vertical . we propose a 2-approximation algorithm that runs in o(@xmath1 ) time , where @xmath2 and @xmath3 are the sizes of input and output , respectively . </S>",
    "<S> this is an improvement over the previous best algorithm , which is a 2-approximation with o(@xmath4 ) running time . </S>"
  ]
}