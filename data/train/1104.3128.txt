{
  "article_text": [
    "facility location problems have been widely studied in the operations research community ( see , e.g. ,  @xcite ) . in its simplest version , _ uncapacitated facility location _ ( ) , we are given a set of facilities with opening costs , and a set of clients , and we want to open some facilities and assign each client to an open facility so as to minimize the sum of the facility - opening and client - assignment costs .",
    "this problem has a wide range of applications .",
    "for example , a company might want to open its warehouses at some locations so that its total cost of opening warehouses and servicing customers is minimized .",
    "we consider the _ lower - bounded facility location _",
    "( ) problem , which is a generalization of where each open facility is required to serve a certain _ minimum _ amount of demand .",
    "more formally , an instance @xmath0 is specified by a set @xmath1 of facilities , and a set @xmath3 of clients . opening facility",
    "@xmath6 incurs a _ facility - opening cost _ @xmath20 , and assigning a client @xmath5 to a facility @xmath6 incurs a _ connection cost _ @xmath7 .",
    "a feasible solution specifies a subset @xmath21 of facilities , and assigns each client @xmath5 to an open facility @xmath9 so that _ each open facility serves at least @xmath10 clients _ , where @xmath10 is an input parameter .",
    "the cost of such a solution is the sum of the facility - opening and connection costs , that is , @xmath11 , and the goal is to find a feasible solution of minimum cost . as is standard in the study of facility location problems , we assume throughout that @xmath7s form a metric .",
    "we use the terms connection cost and assignment cost interchangeably in the sequel .",
    "can be motivated from various perspectives .",
    "this problem was introduced independently by karger and minkoff  @xcite , and guha , meyerson , and munagala ( who called the problem _ load - balanced facility location _ )  @xcite ( see also  @xcite ) , both of whom arrived at as a means of solving their respective buy - at - bulk style network design problems",
    ". arises as a natural subroutine in such settings because obtaining a near - optimal solution to the buy - at - bulk problem often entails aggregating a certain minimum demand at certain hub locations , and then connecting the hubs via links of lower per - unit - demand cost ( and higher fixed cost ) .",
    "also finds direct applications in supply - chain logistics problems , where the lower - bound constraint can be used to model the fact that it is not profitable or feasible to use services unless they satisfy a certain minimum demand . for example",
    "( as noted in  @xcite ) , lim , wang , and xu  @xcite , use to abstract a transportation problem faced by a company that has to determine the allocation of cargo from customers to carriers , who then ship their cargo overseas .",
    "here the lower bound arises because each carrier , if used , is required ( by regulation ) to deliver a minimum amount of cargo .",
    "also , is an interesting special case of _ universal facility location _",
    "( )  @xcite  a generalization of where the facility cost depends on the number of clients served by it  with non - increasing facility - cost functions . with arbitrary non - increasing functions is not a well - understood problem ,    clearly , with @xmath22 is simply , and hence , is _ np_-hard ; consequently , we are interested in designing approximation algorithms for .",
    "the first constant - factor approximation algorithm for was devised by svitkina  @xcite , whose approximation ratio is @xmath12 .",
    "prior to this , the only known approximation guarantees were _",
    "bicriteria guarantees_. @xcite and  @xcite independently devised @xmath23-approximation algorithms via a reduction to : these algorithms return a solution of cost at most @xmath24 times the optimum where each open facility serves at least @xmath15 clients    [ [ our - results - and - techniques . ] ] our results and techniques .",
    "+ + + + + + + + + + + + + + + + + + + + + + + + + + +    we devise an approximation algorithm for that achieves a substantially - improved approximation guarantee of @xmath13 ( theorem  [ mainthm ] ) , thus significantly advancing the state - of - the - art for .",
    "our improvement comes from a combination of ideas in algorithm design and analysis , and yields new insights about the approximability of .",
    "in order to describe the ideas underlying our improvement , we first briefly sketch svitkina s algorithm .",
    "svitkina s algorithm begins by using the reduction in  @xcite to obtain a bicriteria solution for @xmath0 , which is then used to convert @xmath0 into an instance @xmath25 with facility - set @xmath26 having the following structure : ( i ) all clients are aggregated at @xmath14 with each facility @xmath27 having @xmath28 co - located clients ; ( ii ) all facilities in @xmath14 have zero opening costs ; and ( iii ) near - optimal solutions to @xmath25 translate to near - optimal solutions to @xmath0 ( and vice versa ) . the goal now is to identify a subset of @xmath14 to close , such that transferring the clients aggregated at these closed facilities to the remaining ( open ) facilities in @xmath14 ensures that each remaining facility serves at least @xmath10 demand ( and the cost incurred is `` small '' ) .",
    "@xcite shows that one can achieve this by solving a suitable instance .",
    "essentially the idea is that a facility @xmath6 that remains open corresponds to a _ demand point _ in the instance that requires @xmath29 units of demand , and a facility @xmath6 that is closed maps to a _ supply point _ in the instance having @xmath30 units that can be supplied to demand points ( i.e. , open facilities ) . of course , one does not know beforehand which facilities will be closed and which will remain open ; so to encode this correspondence in the instance , we create at every location @xmath27 , a supply point with ( suitable opening cost and ) capacity @xmath10 , and a demand point with demand @xmath29 if @xmath31 ( so the supply point at @xmath6",
    "has @xmath30 residual capacity after satisfying this demand ) .",
    "( assume @xmath31 for simplicity ; facilities with @xmath32 are treated differently . ) finally , @xcite argues that a -solution ( where a supply point may end up sending _ less _ then @xmath30 supply to other demand points ) can be mapped to a solution to @xmath25 without increasing the cost incurred by much ; since admits an @xmath33-approximation algorithm , one obtains an @xmath33-approximate solution to @xmath25 , and hence to the original instance @xmath0 .",
    "our algorithm also proceeds by ( a ) obtaining an instance @xmath25 satisfying properties ( i)(iii ) mentioned above , ( b ) solving @xmath25 , and ( c ) mapping the @xmath25-solution to a solution to @xmath0 , but our implementation of steps ( a ) and ( b ) differs from that in svitkina s algorithm .",
    "these modified implementations , which are independent of each other and yield significant improvements in the overall approximation ratio even when considered in isolation , result in our much - improved approximation ratio .",
    "we detail how we perform step ( a ) later , and focus first on describing how we solve @xmath25 , which is our chief algorithmic contribution .",
    "our key insight is that one can solve the instance @xmath25 by reducing it to a new problem we introduce that we call _ capacity - discounted _ ( ) , which closely resembles and admits an algorithm ( that we devise ) with a much better approximation ratio than .",
    "a -instance has the property that every facility is either uncapacitated ( i.e. , has infinite capacity ) , or has finite capacity and _ zero _ facility cost .",
    "the instance we construct consists of the same supply and demand points as in the reduction of @xmath25 to in  @xcite , except that all supply points with non - zero opening cost are now uncapacitated .",
    "( an interesting consequence is that if all facilities in @xmath25 have @xmath31 , the instance is in fact a -instance ! )    we prove two crucial algorithmic results .",
    "it is not hard to see that the `` standard '' integrality - gap example for the natural lp - relaxation of can be cast as a instance , thus showing that the natural lp - relaxation for has a large integrality gap ( see appendix  [ cduflgap ] ) ; in fact , we are not aware of any lp - relaxation for with constant integrality gap . circumventing this difficulty , we devise a local - search algorithm for based on add , swap , and delete moves that achieves the _ same performance guarantees _ as the corresponding local - search algorithm for  @xcite ( see section  [ cdufl - ls ] ) .",
    "the local - search algorithm yields significant dividends in the overall approximation ratio because not only is its approximation ratio for better than the state - of - the - art for , but also because it yields separate ( asymmetric ) guarantees on the facility - opening and assignment costs , which allows one to perform a tighter analysis .",
    "second , we show that any near - optimal -solution can be mapped to a near - optimal solution to @xmath25 ( see section  [ i2-soln ] ) . as before , it could be that in the -solution , a supply point @xmath6 ( which corresponds to facility @xmath6 being closed down ) sends less than @xmath30 supply to other demand points , so that closing down @xmath6 entails transferring its residual clients to open facilities .",
    "but since some supply points are now uncapacitated , it could also be that @xmath6 sends more than @xmath30 supply to other demand points .",
    "we argue that this artifact can also be handled without increasing the solution cost by much , by opening the facilities in a carefully - chosen subset of @xmath34 and closing down the remaining facilities . for _ every value of @xmath19 _ ( recall that the instance @xmath25 is specified in terms of a parameter @xmath19 ) , the resulting approximation factor for @xmath25 ( theorem  [ i2thm ] ) is better than the guarantee obtained for @xmath25 in svitkina s algorithm ; this in turn translates ( by choosing @xmath19 suitably ) to an improved solution to the original instance .",
    "we now discuss how we implement step ( a ) , that is , how we obtain instance @xmath25 . as in  @xcite",
    ", we arrive at @xmath25 by computing a bicriteria solution to , but we obtain this bicriteria solution in a different fashion ( see section  [ bicriteria ] ) . the reduction from to in  @xcite proceeds by setting the opening cost of facility @xmath6 to @xmath35 , where @xmath36 is the set of @xmath10 clients closest to @xmath6 , solving the resulting instance , and postprocessing using ( single - facility ) delete moves if such a move improves the solution cost .",
    "we modify this reduction subtly by creating a instance , where facility @xmath6 s opening cost is instead set to @xmath37 , where @xmath38 is the distance between @xmath6 and the @xmath15-closest client to it .",
    "as in the case of the earlier reduction , we argue that each open facility @xmath6 in the resulting solution ( obtained by solving and postprocessing ) serves at least @xmath15 clients .",
    "the overall bound we obtain on the total cost now includes various @xmath38 terms . instead of plugging in the ( weak ) bound @xmath39 ( which would yield the same guarantee as that obtained via the earlier reduction )",
    ", we are able to perform a tighter analysis by choosing @xmath19 from a suitable distribution and leveraging the fact that @xmath40 .",
    "( this can easily be derandomized , since there are only @xmath10 combinatorially distinct choices for @xmath19 . )",
    "these simple modifications ( in algorithm - design _ and _ analysis ) yield a surprising amount of improvement in the approximation factor , which is reminiscent of the mileage provided by ( random ) @xmath19-points for various scheduling problems ( see , e.g. ,  @xcite ) and  @xcite . also , we observe that one can obtain further improvements by using the local - search algorithm of  @xcite to solve the above instance : this is because the resulting solution is then already postprocessed , which allows us to exploit the asymmetric bounds on the facility - opening and assignment costs provided by the local - search algorithm via scaling , and improve the approximation ratio .    finally , we remark that the study of may provide useful and interesting insights about . is a special case of that despite its special structure inherits the intractability of with respect to lp - based approximation guarantees .",
    "if one seeks to develop lp - based techniques and algorithms for ( which has been a long - standing and intriguing open question ) , then one needs to understand how one can leverage lp - based techniques for , and it is plausible that lp - based insights developed for may yield similar insights for ( and potentially lp - based approximation guarantees for ) .    [ [ related - work . ] ] related work .",
    "+ + + + + + + + + + + + +    as mentioned earlier , was independently introduced by  @xcite and  @xcite , who used it as a subroutine to solve the ( _ rent - or - buy _ and hence , the ) _ maybecast _ problem , and the _ access network design _ problem respectively .",
    "their ideas , which lead to bicriteria guarantees for , play a preprocessing role both in svitkina s algorithm for  @xcite and ( slightly indirectly ) in our algorithm .",
    "there is a large body of literature that deals with approximation algorithms for ( metric ) , and its variants ; see  @xcite for a survey on .",
    "the first constant approximation guarantee for was obtained by shmoys , tardos , and aardal  @xcite via an lp - rounding algorithm , and the current state - of - the - art is a 1.488-approximation algorithm due to li  @xcite .",
    "local - search techniques have also been utilized to obtain @xmath33-approximation guarantees for  @xcite .",
    "we apply some of the ideas of  @xcite in our algorithm . starting with the work of korupolu , plaxton , and rajaraman  @xcite , various local - search algorithms with constant approximation ratios",
    "have been devised for , with the current - best approximation ratio being @xmath41  @xcite .",
    "local - search approaches are however not known to work for ; in appendix  [ app : lbfllocgap ] , we show that local search based on @xmath42 , @xmath43 , and @xmath44 moves yields poor approximation guarantees . universal facility location ( ) , where the facility cost is a non - decreasing function of the number of clients served by it , was introduced by  @xcite , and  @xcite gave a constant approximation algorithm for this .",
    "we are not aware of any work on with arbitrary non - increasing functions ( which generalizes ) . @xcite give a constant approximation for the case where the cost - functions do not decrease too steeply ( the constant depends on the steepness ) ; notice that does not fall",
    "recall that we have a set @xmath1 of facilities with facility - opening costs @xmath2 , a set @xmath3 of clients , metric connection ( or assignment ) costs @xmath4 specifying the cost of assigning client @xmath5 to facility @xmath6 , and a ( integer ) parameter @xmath10 .",
    "our objective is to open a subset @xmath8 of facilities and assign each client @xmath5 to an open facility @xmath9 , so that at least @xmath10 clients are assigned to each open facility , and the total cost incurred , @xmath11 , is minimized .",
    "we use @xmath0 to denote this instance .",
    "let @xmath45 and @xmath46 denote respectively the facility - opening and assignment cost of an optimal solution to @xmath0 ; we will often refer to this solution as `` the optimal solution '' in the sequel .",
    "we sometimes abuse notation and also use @xmath45 to denote the set of open facilities in this optimal solution .",
    "let @xmath47 denote the total optimal cost .",
    "for a facility @xmath48 , let @xmath36 be the set of @xmath10 clients closest to @xmath6 , and @xmath38 denote the distance between @xmath6 and the @xmath49-closest client to @xmath6 ; that is , if @xmath50 , where @xmath51 , then @xmath52 ( for @xmath53 ) .",
    "let @xmath54 .",
    "observe that each @xmath38 is an increasing function of @xmath19 , @xmath40 , and @xmath55 .",
    "hence , @xmath56 is an increasing function of @xmath19 , @xmath57 , and @xmath58 .",
    "we now give a high - level description of our algorithm using certain building blocks that are supplied in the subsequent sections .",
    "let @xmath0 denote the instance .",
    "( ) = 0.5ex    * obtaining a bicriteria solution .  *",
    "construct a instance with the same set of facilities and clients , and the same assignment costs as @xmath0 , where the opening cost of facility @xmath6 is set to @xmath59 . use the local - search algorithm for in  @xcite or  @xcite with scaling parameter @xmath60 to solve this instance .",
    "( we set @xmath61 suitably to get the desired approximation ; see theorem  [ mainthm ] . )",
    "let @xmath26 be the set of facilities opened in the -solution .",
    "claim  [ bicrit - lb ] and lemma  [ bicrit - perf ]    * transforming to a structured instance .  *",
    "we use the bicriteria solution obtained above to transform @xmath0 into another structured instance @xmath25 as in  @xcite . in the instance @xmath25 , we set the opening cost of each @xmath27 to zero , and we `` move '' to @xmath6 all the @xmath62 clients assigned to it , that is , all these clients are now co - located at @xmath6 .",
    "so @xmath25 consists of only the points in @xmath14 ( which forms both the facility - set and client - set ) .",
    "we will sometimes use the notation @xmath17 to indicate explicitly that @xmath25 s specification depends on the parameter @xmath19 .    solve @xmath25 using the method described in section  [ i2solve ] . obtain a solution to @xmath0 by opening the same facilities and making the same client assignments as in the solution to @xmath25 .",
    "[ [ analysis . ] ] analysis .",
    "+ + + + + + + + +    our main theorem is as follows .",
    "[ mainthm ] for any @xmath63 $ ] and @xmath60 , the above algorithm returns a solution to @xmath0 of cost at most @xmath64\\ ] ] where @xmath65 .",
    "thus , we can compute efficiently a solution to @xmath0 of cost at most :    ( ) = 0ex = 0ex    @xmath66 , by setting @xmath67 ;    @xmath68 , by letting @xmath69 be a suitable ( efficiently - computable ) function of @xmath19 , and choosing @xmath19 randomly from the interval @xmath70 $ ] according to the density function @xmath71 .",
    "the roadmap for proving theorem  [ mainthm ] is as follows .",
    "we first bound the cost of the bicriteria solution obtained in step ( 1 ) in terms of @xmath72 ( lemma  [ bicrit - perf ] ) .",
    "this will allow us to bound the cost of an optimal solution to @xmath25 , and argue that mapping an @xmath25-solution to a solution to @xmath0 does not increase the cost by much ( lemma  [ i2mapping ] ) .",
    "the only missing ingredient is a guarantee on the cost of the solution to @xmath25 found in step ( 3 ) , which we supply in theorem  [ i2thm ] , whose proof appears in section  [ i2solve ] .",
    "the following claim follows from essentially the same arguments as in  @xcite .",
    "[ bicrit - lb ] let @xmath73 be a _",
    "delete - optimal _ solution to the above instance ; that is , the total -cost does not decrease by deleting any open facility of @xmath73 .",
    "then , each facility of @xmath73 serves at least @xmath15 clients .",
    "the local - search algorithms for in  @xcite have the same performance guarantees and both include a delete - move as a local - search operation , so upon termination , we obtain a delete - optimal solution .",
    "observe that opening the same facilities and making the same client assignments as in the optimal solution to @xmath0 yields a solution @xmath74 to the instance constructed in step ( 1 ) of the algorithm with facility cost @xmath75 and assignment cost @xmath76 .",
    "combined with the analysis in  @xcite , this yields the following .",
    "( for simplicity , we assume that all local - search algorithms return a local optimum ; standard arguments show that dropping this assumption increases the approximation by at most a @xmath77 factor . )",
    "[ bicrit - perf ] for a given parameter @xmath60 , executing the local - search algorithm in  @xcite on the above instance returns a solution with facility cost @xmath78 and assignment cost @xmath79 satisfying @xmath80 , where each open facility serves at least @xmath15 clients .",
    "[ i2mapping ] ( i ) the ( assignment ) cost @xmath81 of an optimal solution to @xmath25 is at most @xmath82 .",
    "\\(ii ) any solution to @xmath25 of cost @xmath83 yields a solution to @xmath0 of cost at most @xmath84 .",
    "[ i2thm ] for any @xmath85 , there is a @xmath86-approximation algorithm for @xmath17 , where @xmath87 .",
    "[ i2remk ] our @xmath86-approximation ratio for @xmath17 improves upon the approximation obtained in  @xcite by a factor of roughly 2 _ for all @xmath19_. thus , plugging in our algorithm for solving @xmath25 in the -algorithm in  @xcite ( and choosing a suitable @xmath19 ) , already yields an improved approximation factor of @xmath88 for .",
    "theorem  [ mainthm ] recall that @xmath89 .",
    "note that @xmath90 for all @xmath16 $ ] ; we use this upper bound throughout below .",
    "combining theorem  [ i2thm ] and the bounds in lemmas  [ bicrit - perf ] and  [ i2mapping ] , we obtain a solution to @xmath0 of cost at most @xmath91 @xmath92    part ( i ) follows by plugging in the values of @xmath19 and @xmath69 , and using the bound @xmath58 .",
    "let @xmath93 .",
    "for part ( ii ) , we set @xmath94 , where @xmath95}}/ \\bigl(\\frac{\\int_{\\beta}^1{\\ensuremath{h}}(x)dx}{1-\\beta}\\bigr)\\right)^{\\frac{1}{4}}$ ] .",
    "plugging in this @xmath69 , we see that the cost incurred is at most @xmath96 we now bound the expected cost incurred when one chooses @xmath19 randomly according to the stated density function .",
    "this will also yield an explicit expression for @xmath97 ( as a function of @xmath98 ) , thus showing that @xmath99 ( and hence , @xmath69 ) can be computed efficiently .",
    "we note that @xmath100}}\\leq\\sqrt{{\\ensuremath{{\\textstyle \\operatorname*{e}_{{}}}\\left[x\\right]}}}$ ] and utilize chebyshev s integral inequality ( see  @xcite ) : if @xmath101 and @xmath102 are non - increasing and non - decreasing functions respectively from @xmath103 $ ] to @xmath104 , then @xmath105 .",
    "observe that @xmath106 decreases with @xmath19 .",
    "recall that @xmath93 .",
    "we have the following .",
    "@xmath107 } } & = & { \\ensuremath{c}}_2(\\beta):= \\bigl[\\frac{4}{\\beta}-4 + 8\\sqrt{6}\\bigl(\\pi/4-\\tan^{-1}(\\sqrt{2\\beta-1})\\bigr)+ 2\\ln\\bigl(\\frac{1}{2\\beta-1}\\bigr)+\\ln(1/\\beta)\\bigr]/\\ln(1/\\beta ) \\\\[0.2ex ] { \\ensuremath{{\\textstyle \\operatorname*{e}_{{\\ensuremath{\\alpha}}}}\\left[{\\ensuremath{\\alpha}}mr^*({\\ensuremath{\\alpha}})\\right ] } } & = & m\\bigl(\\int_{\\beta}^1 r^*(x)dx\\bigr)/\\ln(1/\\beta ) \\leq c^*/\\ln(1/\\beta).\\end{aligned}\\ ] ] finally , using chebyshev s inequality , we obtain that @xmath108 } } \\leq   \\bigl[m\\bigl(\\int_{\\beta}^1 r^*(x)dx\\bigr ) \\tfrac{\\int_{\\beta}^1 dx\\sqrt{{\\ensuremath{h}}(x)}}{1-\\beta}\\bigr]/\\ln(1/\\beta )   \\leq \\bigl[c^*\\sqrt{{\\ensuremath{c}}_3(\\beta)}\\bigr]/\\ln(1/\\beta),\\ ] ] where @xmath109/(1-\\beta).\\ ] ] the second inequality follows since @xmath110}}}]{\\sqrt{{\\ensuremath{h}}({\\ensuremath{\\alpha}})}}$ ] .",
    "plugging in these bounds , we get that @xmath111 and the total cost is at most @xmath112\\ ] ]",
    "we now describe our algorithm for solving instance @xmath17 and analyze its performance guarantee , thereby proving theorem  [ i2thm ] .",
    "as mentioned earlier , one of the key differences between our algorithm and the one in  @xcite is that instead of reducing @xmath25 to capacitated facility location ( ) , we solve @xmath25 by reducing it to a new problem that we call _ capacity - discounted _ ( ) . is a special case of where all facilities with non - zero opening cost are uncapacitated ( i.e. , have infinite capacity ) . perhaps surprisingly , despite this special structure , inherits the intractability of with respect to lp - based approximation guarantees : there is no known lp - relaxation for that has constant integrality gap ; appendix  [ cduflgap ] shows that the natural lp - relaxation for has bad integrality gap .",
    "however , as we show in section  [ cdufl - ls ] , we can obtain a simple local - search algorithm for whose approximation ratio is better than the current - best approximation for .",
    "recall that @xmath25 has only the points in @xmath26 , and there are @xmath62 co - located clients at each @xmath27 .",
    "let @xmath113 . to avoid confusion",
    ", we refer to the facilities and clients in the instance as supply points and demand points respectively .",
    "the instance created to solve @xmath25 resembles the instance created in  @xcite ; the difference is that all supply points with non - zero opening costs are now uncapacitated .",
    "more precisely , at each @xmath27 , we create an uncapacitated supply point with opening cost @xmath114 , where @xmath115 is a parameter we fix later . if @xmath32 we create a second supply point at @xmath6 with capacity @xmath116 and zero opening cost .",
    "if @xmath117 , we create a demand point at @xmath6 with demand @xmath29 .",
    "let @xmath118 denote this instance ( see fig .",
    "[ i2toip ] ) .",
    "let @xmath119 denote respectively the set of uncapacitated and capacitated supply points of @xmath118 .",
    "roughly speaking , satisfying a demand point @xmath6 by non - co - located supply points translates to leaving facility @xmath6 open in the @xmath25 solution ; hence , its demand is set to @xmath29 , which is the number of additional clients it needs .",
    "conversely , opening the uncapacitated supply point at @xmath6 and supplying demand points from @xmath6 translates to closing @xmath6 in the @xmath25 solution and transferring its co - located clients to other open facilities .",
    "[ cdufl - cost ] there exists a solution to @xmath118 with facility cost @xmath120 and assignment cost @xmath121 .",
    "[ cdufl - thm ] ( i ) given any instance , one can efficiently compute a solution with facility - opening cost @xmath122 and assignment cost @xmath123 , where @xmath124 and @xmath125 are the facility and assignment costs of an arbitrary solution to the instance .",
    "\\(ii ) thus , lemma  [ cdufl - cost ] implies that one can compute a solution to @xmath118 with facility cost @xmath126 and assignment cost @xmath127 satisfying @xmath128 .",
    "we defer the description of the local - search algorithm for , and the proof of theorem  [ cdufl - thm ] to section  [ cdufl - ls ] .",
    "we first describe how to convert an @xmath118-solution to a solution to @xmath25 with a small increase in cost , and show how this combined with theorem  [ cdufl - thm ] leads to the approximation bound for @xmath25 stated in theorem  [ i2thm ] .",
    "an @xmath118-solution need not directly translate to an @xmath25 solution because an open supply point @xmath6 may not supply ( and hence , transfer ) exactly @xmath30 units of demand ( see , e.g. , @xmath6 and @xmath129 in fig .",
    "[ i2toip](b ) ) .",
    "since we have uncapacitated supply points , we have to consider both the cases where @xmath6 supplies more than @xmath30 demand ( a situation not encountered in  @xcite ) , and less than @xmath30 demand .",
    "suppose that we are given a solution @xmath74 to @xmath118 with facility cost @xmath130 and assignment cost @xmath131 ( see fig .",
    "[ i2toip](b ) ) .",
    "again , we abuse notation and use @xmath130 to also denote the set of supply points that are opened in @xmath74 . let @xmath132 initialized to @xmath30 keep track of the number of clients at location @xmath27 .",
    "our goal is to reassign clients ( using @xmath74 as a template ) so that at the end we have @xmath133 or @xmath134 for each @xmath27 .",
    "observe that once we have determined which facilities in @xmath14 will have @xmath134 ( i.e. , the facilities to open in the @xmath25-solution ) , one can find the best way of ( re)assigning clients by solving a min - cost flow problem . however , for purposes of analysis , it will often be convenient to explicitly specify a ( possibly suboptimal ) reassignment .",
    "we may assume that : ( i ) @xmath135 ; ( ii ) if @xmath74 opens an uncapacitated supply point located at some @xmath27 with @xmath32 , then the demand assigned to the capacitated supply point at @xmath6 equals its capacity @xmath116 ; ( iii ) for each @xmath27 with @xmath31 , if the supply point at @xmath6 is open then it serves the entire demand of the co - located demand point ; and ( iv ) at most one _ uncapacitated _ supply point serves , maybe partially , the demand of any demand point ; we say that this uncapacitated supply point satisfies the demand point .",
    "we reassign clients in three phases .",
    "a    * ( removing capacitated supply points )  * consider any location @xmath27 with @xmath32 .",
    "let @xmath136 and @xmath137 denote respectively the capacitated and uncapacitated supply points located at @xmath6 .",
    "if @xmath136 supplies @xmath138 units to the demand point at location @xmath129 , we transfer @xmath138 clients from location @xmath6 to @xmath129 .",
    "now if @xmath136 has @xmath139 leftover units of capacity in @xmath74 , then we `` move '' @xmath140 clients to @xmath137 ( which is not open in @xmath74 ) .",
    "we update the @xmath132s accordingly . note that this reassignment effectively gets rid of all capacitated supply points .",
    "thus , there is now exactly one uncapacitated supply point and at most one demand point at each location @xmath27 ; we refer to these simply as supply point @xmath6 and demand point @xmath6 below .    *",
    "( taking care of @xmath141 and demand points satisfied by @xmath141 )  * for each @xmath142 , if @xmath6 supplies @xmath138 units to demand point @xmath129 , we move @xmath138 clients from @xmath6 to @xmath129 , and update @xmath143 .",
    "we now have @xmath144 residual clients at each @xmath142 , which we must reduce to 0 , or increase to at least @xmath10 .",
    "we follow the same procedure as in  @xcite , which we sketch below .    for each @xmath142 , we include an edge @xmath145 where @xmath146 is the facility nearest to @xmath6 ( recall that @xmath147 ) .",
    "we use an arbitrary but fixed tie - breaking rule here , so each component of the resulting digraph is a directed tree rooted at either ( i ) a node @xmath148 , or ( ii ) a 2-cycle @xmath149 , where @xmath150 .",
    "we break up each component @xmath151 into a collection of smaller components as follows . essentially , we move the residual clients of supply points in the component bottom - up from the leaves up to the root , cut off the component at the first node @xmath152 that accumulates at least @xmath10 clients , and recurse on the portion of the component not containing @xmath152 .",
    "more precisely , let @xmath153 denote the subtree of @xmath151 rooted at node @xmath154 ( if @xmath152 belongs to a 2-cycle then we do not include the other node of this 2-cycle in @xmath153 ) .    =0ex = 0ex    if @xmath155 , or if @xmath151 is of type ( i ) and all children @xmath152 of the root satisfy @xmath156 , we leave @xmath151 unchanged .",
    "otherwise , let @xmath152 be a deepest ( i.e. , furthest from root ) node in @xmath151 such that @xmath157 .",
    "we delete the arc leaving @xmath152 . if this disconnects @xmath152 from @xmath158 , then we recurse on @xmath158",
    ".    otherwise @xmath152 must belong to the root 2-cycle of @xmath151 .",
    "let @xmath159 be the other node of this 2-cycle .",
    "if @xmath160 , we delete @xmath159 s outgoing arc ( thus splitting @xmath151 into @xmath153 and @xmath161 ) .    after applying the above procedure ( to all components ) , if we are left with a component of type ( ii ) with @xmath162 , we convert it to type ( i ) by arbitrarily deleting one of the arcs of the 2-cycle . thus , at the end of this process , we have two types of components .",
    "( ) = 0ex    a tree @xmath163 rooted at a node @xmath164 : we move the @xmath132 residual clients of each non - root node @xmath165 to @xmath164 .    a type-(ii ) tree @xmath163 with root @xmath166 : we must have @xmath167 .",
    "let @xmath168 be the location nearest to @xmath166 ; we move the @xmath132 residual clients of each @xmath165 to @xmath129 .",
    "update the @xmath132s to reflect the above reassignment .",
    "observe that we now have @xmath133 or @xmath134 for each @xmath142 , and each @xmath169 has @xmath170 , or is a demand point satisfied by a supply point in @xmath171 .",
    "figure  [ transition](a ) shows a snapshot after steps a1 and a2 have been executed on the solution shown in fig .",
    "[ i2toip](b ) . here",
    "@xmath172 has one client left after moving clients to the bottom two facilities , which is then transferred to @xmath173 .    *",
    "( taking care of @xmath171 and demand points satisfied by @xmath171 )  * for @xmath174 , let @xmath175 be the set of demand points @xmath176 satisfied by @xmath6 , and let @xmath177 . note that @xmath178 .",
    "phase a2 may only increase @xmath179 for all @xmath5 in @xmath180 , so @xmath181 for all @xmath182 .",
    "fix @xmath174 .",
    "we reassign clients so that @xmath183 or @xmath184 for all @xmath185 , without decreasing @xmath179 for @xmath186 . applying this procedure to all",
    "supply points in @xmath171 will complete our task .",
    "define @xmath187 ( which is at most @xmath188 ) for @xmath189 .",
    "we consider two cases .",
    "=0ex = 0ex    @xmath190 . for each @xmath189 , if @xmath6 supplies @xmath138 units to @xmath5 , we transfer @xmath138 clients from @xmath6 to @xmath5 .",
    "if @xmath6 is now left with less than @xmath10 residual clients , we move these residual clients to the location in @xmath175 nearest to @xmath6 .",
    "@xmath191 ( see fig .  [ transition ] ) .",
    "let @xmath192 , and @xmath193 , where @xmath194 .",
    "let @xmath195 , so @xmath196 ( and @xmath197 since @xmath198 ) .",
    "note that @xmath199 is the unique index such that @xmath200 .",
    "this enables us to transfer @xmath201 clients to each @xmath202 from the locations @xmath203we do this by transferring all clients of @xmath204 ( where @xmath205 ) before considering @xmath206and be left with at most @xmath10 residual clients in @xmath207 .",
    "we argue that these residual clients are all concentrated at @xmath208 and @xmath209 , with @xmath209 having at most @xmath210 residual clients .",
    "we transfer these residual clients to @xmath211 .",
    "[ i2map ] the above algorithm returns an @xmath25-solution of cost at most @xmath212 .",
    "thus , taking @xmath74 to be the solution mentioned in part ( ii ) of theorem  [ cdufl - thm ] , and @xmath213 , we obtain a solution to @xmath17 satisfying the approximation bound stated in theorem  [ i2thm ] .",
    "let @xmath214 denote the solution computed for @xmath25 .",
    "for a supply point @xmath6 opened in @xmath74 , we use @xmath215 to denote the cost incurred in supplying demand from @xmath6 to the demand points satisfied by @xmath6 ; so @xmath216 . at various steps , we transfer clients between locations according to the assignment in the solution @xmath74 , and the cost incurred in this reassignment can be charged against the @xmath215s of the appropriate supply points .",
    "so the cost of phase a1 is @xmath217 , and the cost of the first step of phase a2 is @xmath218 .    as in  @xcite",
    ", we can bound the remaining cost of phase a2 , incurred in transferring clients according to the tree edges by @xmath219 .",
    "when we move clients up to the root of a component , we move strictly less than @xmath10 clients along any edge @xmath145 in that component , and since @xmath142 , we pay at least @xmath220 opening cost for @xmath6 . the only unaccounted cost now is the cost incurred in step ( b ) of phase a2 , where we have a tree @xmath163 rooted at @xmath166 .",
    "let @xmath168 be the location nearest to @xmath166 , and ( say ) @xmath221 .",
    "note that we have already bounded the cost in transferring clients to @xmath164 , so we only need to bound the cost incurred in transferring at most @xmath10 clients from @xmath164 to @xmath129 .",
    "this is at most @xmath222 , because @xmath166 send @xmath223 units to demand points in @xmath224 , all of which are at distance at least @xmath225 from @xmath166 .",
    "finally , consider phase a3 and some @xmath174 .",
    "if @xmath190 , then the cost incurred is at most @xmath226 ( as @xmath227 ) . now consider the case @xmath191 .",
    "for any @xmath228 and any @xmath229 , we have @xmath230 , so the cost of transferring @xmath231 clients to each @xmath202 is at most @xmath232 . observe that @xmath233 , i.e. , @xmath234 , so after this reassignment , there are less than @xmath10 residual clients in @xmath235 . by our order of transferring clients ,",
    "all these residual clients are at @xmath236 ( otherwise we would have at least @xmath198 residual clients ) with at most @xmath237 of them located at @xmath209 .",
    "the cost of reassigning these residual clients is at most @xmath238 , since @xmath215 is the total cost of supplying at least @xmath239 demand to each @xmath240 .",
    "the latter expression is at most @xmath241 , since @xmath242 , @xmath243 . )",
    "thus , the cost of @xmath214 is at most @xmath244 so if @xmath74 is the solution given by part ( ii ) of theorem  [ cdufl - thm ] , the cost of @xmath214 is at most @xmath245 , and plugging in the value of @xmath115 yields the @xmath87 approximation bound stated in theorem  [ i2thm ] .",
    "we now describe our local - search algorithm for , which leads to the proof of theorem  [ cdufl - thm ] .",
    "let @xmath246 be the facility - set of the instance , where @xmath247 . here , @xmath248 are the uncapacitated facilities with opening costs @xmath249 , and facilities in @xmath250 have ( finite ) capacities @xmath251 and zero opening costs .",
    "let @xmath252 be the set of clients and @xmath253 be the cost of assigning client @xmath5 to facility @xmath6 .",
    "the goal is to open facilities and assign clients to open facilities ( respecting the capacities ) so as to minimize the sum of the facility - opening and client - assignment costs .",
    "we can find the best assignment of clients to open facilities by solving a network flow problem , so we focus on determining the set of facilities to open .",
    "the local - search algorithm consists of three moves : @xmath254 , @xmath255 , @xmath256 , which respectively , add a facility @xmath129 not currently open , delete a facility @xmath6 that is currently open , and swap facility @xmath6 that is open with facility @xmath129 that is not open .",
    "we note that _ all _ previous ( local - search ) algorithms for that work with non - uniform capacities use moves that are more complicated than the moves above ( and involve adding and/or deleting multiple facilities at a time ) .",
    "the algorithm repeatedly executes the best cost - improving move ( if one exists ) until no such move exists .",
    "( as mentioned earlier , to ensure polynomial time , we only consider moves that yield significant improvement and hence terminate at an approximate local optimum ; but this has only a marginal effect on the approximation bound . )",
    "we assume for simplicity that each client has unit demand .",
    "this is without loss of generality because , even with non - unit client - demands , one can compute the best local - search move ( and hence run the algorithm ) , and for the purposes of analysis , one can always treat a client with integer demand @xmath257 as @xmath257 co - located unit - demand clients .",
    "[ [ analysis.-1 ] ] analysis .",
    "+ + + + + + + + +    let @xmath258 denote a local - optimum returned by the algorithm , with facility - opening cost ( and set of open facilities ) @xmath259 and assignment cost @xmath260 .",
    "let @xmath261 be an arbitrary solution , with facility - cost ( and set of open facilities ) @xmath124 and assignment cost @xmath125 .",
    "note that we may assume that @xmath262 . for a facility @xmath6",
    ", we use @xmath263 and @xmath264 to denote respectively the ( possibly empty ) set of clients served by @xmath6 in @xmath258 and @xmath261 . for a client @xmath5 ,",
    "let @xmath265 and @xmath266 be the assignment cost of @xmath5 in @xmath258 and @xmath261 respectively .",
    "we borrow ideas from the analysis of the corresponding local - search algorithm for in  @xcite , but the presence of capacitated facilities means that we need to reassign clients more carefully to analyze the change in assignment cost due to a local - search move . in particular , unlike the analysis in  @xcite , where upon deletion of a facility @xmath267 we reassign only the clients currently assigned to @xmath268 , in our case ( as in the analysis of local - search algorithms for ) , we need to perform a more `` global '' reassignment ( i.e. , even clients not assigned to @xmath268 may get reassigned ) along certain ( possibly long ) paths in a suitable graph .",
    "this also means that we need to construct a suitable mapping between paths instead of the client - mapping considered in  @xcite .",
    "we construct a directed graph @xmath269 with node - set @xmath270 , and arcs from @xmath6 to all clients in @xmath263 and arcs from all clients in @xmath264 to @xmath6 , for every facility @xmath6 . via standard flow - decomposition",
    ", we can decompose @xmath269 into a collection of ( simple ) paths @xmath271 , and cycles @xmath272 , so that ( i ) each facility @xmath6 appears as the starting point of @xmath273 paths , and the ending point of @xmath274 paths , and ( ii ) each client @xmath5 appears on a unique path @xmath275 or on a cycle .",
    "let @xmath276 and @xmath277 denote respectively the collection of paths starting at @xmath268 and ending at @xmath278 , and @xmath279 .",
    "for a path @xmath280 , define @xmath281 , @xmath282 , and @xmath283 .",
    "a _ shift _ along @xmath284 means that we reassign client @xmath285 to @xmath286 for each @xmath287 ( opening @xmath278 if necessary ) .",
    "note that this is feasible , since if @xmath288 , we know that @xmath289 .",
    "let @xmath290 be the increase in assignment cost due to this reassignment , which is an upper bound on the actual increase in assignment cost if @xmath278 is added to @xmath259 .",
    "also , let @xmath291 .",
    "we define a shift along a cycle @xmath292 similarly , letting @xmath293 . by considering a shift operation for every path and cycle in @xmath294 ( i.e. , suitable @xmath42 moves )",
    ", we get the following result .",
    "[ asgncost ] for every @xmath295 and any @xmath296 , we have @xmath297 for every cycle @xmath292 , we have @xmath298 .",
    "thus , we have @xmath123 .    [ [ bounding - the - opening - cost - of - facilities - in - ensuremathwidehat - fensuremathsetminusfensuremathmathrmsol . ] ] bounding the opening cost of facilities in @xmath299 . + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    for this , we only need paths that start at facility in @xmath299 .",
    "note that all facilities in @xmath300 are _ uncapacitated_. to avoid excessive notation , for a facility @xmath301 , we now use @xmath302 to refer to the collection of paths ending in @xmath278 that start in @xmath299 .",
    "( as before , @xmath303 is the set of paths that start at @xmath268 and end at @xmath278 . ) for any @xmath301 , we can obtain a 1 - 1 mapping @xmath304 such that if @xmath305 and @xmath306 , then ( i ) if @xmath307 , we have @xmath308 ; ( ii ) if @xmath309 , then @xmath310 ; and ( iii ) @xmath311 . say that @xmath301 is _ captured _ by @xmath268 if @xmath312 . note that @xmath278 is captured by at most one facility in @xmath259 . call a facility in @xmath299 _ good _ if it does not capture any facility , and _ bad _ otherwise .",
    "[ goodf ] for any good facility @xmath268 , we have @xmath313    consider the move @xmath314 .",
    "we upper bound the increase in reassignment cost as follows .",
    "consider @xmath315 , and let @xmath316 .",
    "( recall that @xmath275 is the unique path containing @xmath5 . ) if @xmath317 , then we perform a shift along @xmath275 .",
    "otherwise , let @xmath318 , where @xmath319 .",
    "we reassign all clients on @xmath275 except @xmath320 as in the shift operation , and reassign @xmath320 to @xmath321 .",
    "let @xmath322 .",
    "since @xmath323 , the increase in cost by reassigning clients on @xmath275 this way is at most @xmath324 .",
    "thus , the actual increase in cost due to this move , which should be nonnegative , is at most @xmath325 .",
    "\\\\[-20pt]\\ ] ]    now consider a bad facility @xmath268 .",
    "let @xmath326 be the facilities captured by @xmath268 , and let @xmath327 be the facility nearest to @xmath268 .",
    "[ badf ] for any bad facility @xmath268 , we have @xmath328    consider the move @xmath329 .",
    "we reassign client @xmath315 as follows .",
    "let @xmath316 .",
    "@xmath330 = 0ex    if @xmath317 , or @xmath331 and @xmath332 , we perform a shift along @xmath275 .",
    "the increase in assignment cost is at most @xmath333 .    otherwise , let @xmath318 .    if @xmath334 ( so @xmath319 ) , we reassign @xmath335 as in the shift operation , and assign @xmath320 to @xmath321 .",
    "as in the proof of lemma  [ goodf ] , the increase in assignment cost is at most @xmath336 .    if @xmath332 ( so @xmath337 ) , we assign @xmath5 to @xmath338 . note that @xmath339 , so the increase in assignment cost is at most @xmath340 .",
    "this gives the inequality @xmath341 \\\\ & + \\sum_{o\\notin{\\ensuremath{\\widehat f } } : o\\neq o_s}\\sum_{p\\in{\\ensuremath{\\mathcal p}}(s , o ) : \\pi(p)=p}{\\ensuremath{\\mathit{cost}}}(p ) .",
    "\\label{swap - ineq } \\end{split}\\ ] ] now consider the operation @xmath342 for all @xmath343 , and apply lemma  [ asgncost ] taking @xmath344 .",
    "this yields the inequality @xmath345 for each @xmath346 . adding these inequalities to , and rearranging proves the lemma .",
    "theorem  [ cdufl - thm ] we prove part ( i ) ; part ( ii ) follows directly from part ( i ) and lemma  [ cdufl - cost ] .",
    "lemma  [ asgncost ] bounds @xmath260 .",
    "consider adding for all good facilities and for all bad facilities , and the vacuous equality @xmath347 for all @xmath348 .",
    "the lhs of the resulting inequality is precisely @xmath259 .",
    "the @xmath349s on the rhs add up to give at most @xmath124 .",
    "we claim that each path @xmath350 contributes at most @xmath351 to the rhs .",
    "thus the rhs is at most @xmath352 , and we obtain that @xmath122 .",
    "each path @xmath284 in @xmath353 appears exactly once , either in or in , and contributes @xmath354 .",
    "now consider a path @xmath355 , and let @xmath306 .",
    "note that @xmath311 . if @xmath356 , then @xmath284 appears twice in our inequality - system : once in the inequality for @xmath268 contributing @xmath354 ( due to @xmath284 ) , and once in the inequality for @xmath321 contributing @xmath357 ( due to @xmath358 ) .",
    "if @xmath359 , then @xmath309 and @xmath268 is a bad facility ; now @xmath284 appears only in ( for @xmath268 ) and contributes either @xmath354 if @xmath331 , or @xmath360 otherwise .",
    "corollary of theorem  [ cdufl - thm ] : there is a @xmath361-approximation algorithm for .",
    "we take @xmath261 in part ( i ) of theorem  [ cdufl - thm ] to be an optimum solution ( with cost @xmath362 ) to the instance , and scale the facility costs by @xmath363 before running the local - search algorithm .",
    "the solution returned has cost @xmath364 . setting @xmath365 yields the result .",
    "10 v.  arya , n.  garg , r.  khandekar , a.  meyerson , k.  munagala , and v.  pandit .",
    "local search heuristics for @xmath366-median and facility location problems . , 33(3):544562 , 2004 .",
    "m.  charikar and s.  guha .",
    "improved combinatorial algorithms for facility location problems .",
    ", 34(4):803824 , 2005 .",
    "s.  guha , a.  meyerson , and k.  munagala . a constant factor approximation for the single sink edge installation problem .",
    ", 38(6):22462442 , 2009 .",
    "s.  guha , a.  meyerson , and k.  munagala .",
    "facility location with demand dependent costs and generalized clustering . , 2000 .",
    "s.  guha , a.  meyerson , and k.  munagala .",
    "hierarchical placement and network design problems . in _ proceedings of the 41st annual ieee symposium on foundations of computer science _ , pages 603612 , 2000 .",
    "m.  hajiaghayi , m.  mahdian , and v.  mirrokni .",
    "the facility location problem with general cost functions .",
    ", 42:4247 , 2003 .",
    "g.  h. hardy , j.  e. littlewood , and g.  plya . .",
    "cambridge university press , 1952 .",
    "d.  r. karger and m.  minkoff .",
    "building steiner trees with incomplete global knowledge . in _ proceedings of the 41st annual ieee symposium on foundations of computer science _ ,",
    "pages 613623 , 2000 .",
    "m.  r. korupolu , c.  g. plaxton , and r.  rajaraman .",
    "analysis of a local search heuristic for facility location problems .",
    ", 37(1):146188 , 2000 .",
    "a 1.488 approximation algorithm for the uncapacitated facility location problem . in _ proceedings of the 38th international colloquium on automata languages and programming _ , pages 7788 , 2011 .",
    "a.  lim , f.  wang , and z.  xu . a transportation problem with minimum quantity commitment .",
    ", 40(1):117129 , 2006 .",
    "m.  mahdian and m.  pl .",
    "universal facility location . in _ proceedings of 11th esa _ ,",
    "pages 409421 , 2003 .",
    "p.  mirchandani and r.  francis , editors . .",
    "john wiley and sons , inc .",
    ", new york , 1990 .",
    "d.  b. shmoys . the design and analysis of approximation algorithms : facility location as a case study . in s.",
    "hosten , j.  lee , and r.  thomas , editors . , pages 8597 , 2004 .",
    "d.  b. shmoys ,  .",
    "tardos , and k.  i. aardal .",
    "approximation algorithms for facility location problems . in _ proceedings of the 29th annual acm symposium on theory of computing _ , pages 265274 , 1997 .",
    "m.  skutella .",
    "list scheduling in order of @xmath19-points on a single machine . in e.",
    "bampis , k.  jansen , and c.  kenyon , editors . , pages 250291 , springer - verlag , berlin , 2006 .",
    "m.  sviridenko .",
    "an improved approximation algorithm for the metric uncapacitated facility location problem . in _ proceedings of 9th",
    "ipco _ , pages 240257 , 2002 .",
    "z.  svitkina .",
    "lower - bounded facility location . , 6(4 ) ,",
    "j.  zhang , b.  chen , and y.  ye .",
    "a multi - exchange local search algorithm for the capacitated facility location problem . , 30:389403 , 2005 .",
    "let @xmath367 be a instance with facility - set @xmath368 ( where @xmath369 for all @xmath370 , and @xmath371 for all @xmath372 ) , and client - set @xmath252 .",
    "we consider the following lp - relaxation .",
    "we use @xmath6 to index facilities , and @xmath5 to index clients . note that we may assume that all facilities in @xmath250 are open .",
    "@xmath373 & & x_{ij } & \\leq y_i & & { \\ensuremath{\\text { for all } } } i\\in{\\ensuremath{{\\textstyle \\widehat{\\mathcal f}^u } } } , j \\\\ & & \\sum_j x_{ij } & \\leq u_i & & { \\ensuremath{\\text { for all } } } i\\in{\\ensuremath{{\\textstyle \\widehat{\\mathcal f}^c}}}\\\\[-1ex ] & & x_{ij},y_i & \\geq 0 & & { \\ensuremath{\\text { for all } } } i , j.\\end{aligned}\\ ] ] here @xmath374 denotes if facility @xmath6 is open , and @xmath375 denotes if client @xmath5 is assigned to facility @xmath6 .",
    "( we assume that each client has unit demand . )",
    "now consider the following simple instance .",
    "we have two facilities @xmath6 and @xmath129 , and @xmath376 clients , all present at the same location .",
    "facility @xmath6 is uncapacitated and has opening cost @xmath101 , and facility @xmath129 has capacity @xmath152 ( and zero opening cost ) .",
    "any solution to must open facility @xmath6 and therefore incur cost at least @xmath101 .",
    "however , there is a feasible solution to of cost @xmath377 : we set @xmath378 , and @xmath379 .",
    "thus , the integrality gap of is at least @xmath376 .",
    "we show that the local - search algorithm based on @xmath42 , @xmath43 , and @xmath44 moves  that is , adding / dropping one facility ( with @xmath42 permitted only if it preserves feasibility ) , or deleting one facility and adding another  has a bad _ locality gap _ , which is the maximum ratio between the cost of a locally - optimal solution and that of an ( globally ) optimal solution .",
    "consider the instance shown below with facility - set @xmath380 , and client - set @xmath381 , where the @xmath382s are disjoint sets of size @xmath10 .",
    "the facility - opening costs are as follows : @xmath383 and @xmath384 for each @xmath385 . for each @xmath386 and each client @xmath387",
    ", we have @xmath388 .",
    "all other distances are defined by taking the metric completion with respect to these @xmath7s .",
    "one can verify that the solution @xmath74 which opens the facilities @xmath389 is a local optimum .",
    "the cost of this solution is @xmath390 .",
    "however , the optimal solution opens facility @xmath391 , and incurs a total cost of @xmath392 .",
    "thus , the locality gap is at least @xmath393 .",
    "we can modify this example to show that the locality gap remains bad , even if aim for a bicriteria solution and consider an @xmath42 move to be permissible if every open facility can be assigned at least @xmath15 clients .",
    "the only change is that each set @xmath382 now has @xmath15 clients : @xmath74 is still a local optimum , and the locality gap is therefore at least @xmath394 .      even in the setting where all facilities have zero opening cost ( as in the @xmath25 instance ) , we can construct bad examples for local - search based on @xmath42 , @xmath43 , and @xmath44 moves . for simplicity , first suppose that @xmath395 .",
    "consider a cycle with @xmath396 nodes , which are labeled @xmath397 .",
    "we have @xmath398 facilities @xmath399 , and @xmath398 clients @xmath400 ( see fig .",
    "[ locgapf0 ] ) .",
    "we define the following distances .",
    "the solution @xmath74 which opens facilities @xmath405 is a local optimum : no @xmath42 move is feasible , and it is easy to see that no @xmath43 move improves the cost . consider a swap move , which we may assume is of the form @xmath406 by symmetry .",
    "the new client - assignment will not necessarily assign the clients @xmath407 and @xmath408 ( which were previously assigned to @xmath409 ) to @xmath410 .",
    "however , the intuition is that the long cycle will lead to a large increase in assignment cost . the optimal way of reassigning clients is to assign @xmath411 to @xmath412 , assign @xmath413 to @xmath414 for @xmath415 ( which is empty if @xmath416 ) , and assign @xmath417 to @xmath414 for @xmath418 ( which is empty if @xmath419 ) .",
    "the cost increase due to this reassignment is @xmath420 .",
    "thus , @xmath74 is a local optimum .",
    "the cost of @xmath74 is @xmath421 .",
    "however , the optimal solution opens facilities @xmath422 , and has a total cost of @xmath398 .",
    "so this instance shows a locality gap of @xmath366 , and since @xmath366 can be made arbitrarily large , this shows an unbounded locality gap .",
    "the above example can be extended to all values of @xmath10 . for each @xmath10 , let @xmath423 be an @xmath10-regular bipartite graph with vertex set @xmath424 with a large girth @xmath163 .",
    "we use @xmath423 to construct the following instance .",
    "the set of facilities is @xmath425 . for each edge",
    "@xmath426 in @xmath423 , we create a client @xmath427 with @xmath428 and @xmath429 . as before",
    ", one can argue that the solution @xmath74 that opens facilities @xmath430 is a local optimum .",
    "the cost of this solution is @xmath431 , whereas the solution that opens facilities @xmath432 has total cost of @xmath433 .",
    "so the locality gap is @xmath163 , which can be made arbitrarily large ."
  ],
  "abstract_text": [
    "<S> we consider the _ lower - bounded facility location _ ( ) problem ( also sometimes called _ load - balanced facility location _ ) , which is a generalization of _ uncapacitated facility location _ </S>",
    "<S> ( ) , where each open facility is required to serve a certain _ minimum _ amount of demand . more formally , an instance @xmath0 of is specified by a set @xmath1 of facilities with facility - opening costs @xmath2 , a set @xmath3 of clients , and connection costs @xmath4 specifying the cost of assigning a client @xmath5 to a facility @xmath6 , where the @xmath7s form a metric . </S>",
    "<S> a feasible solution specifies a subset @xmath8 of facilities to open , and assigns each client @xmath5 to an open facility @xmath9 so that each open facility serves _ at least @xmath10 clients _ , where @xmath10 is an input parameter . </S>",
    "<S> the cost of such a solution is @xmath11 , and the goal is to find a feasible solution of minimum cost .    </S>",
    "<S> the current best approximation ratio for is @xmath12  @xcite . </S>",
    "<S> we substantially advance the state - of - the - art for by devising an approximation algorithm for that achieves a significantly - improved approximation guarantee of @xmath13 .    </S>",
    "<S> our improvement comes from a variety of ideas in algorithm design and analysis , which also yield new insights into . </S>",
    "<S> our chief algorithmic novelty is to present an improved method for solving a more - structured instance obtained from @xmath0 via a bicriteria approximation algorithm for , wherein all clients are aggregated at a subset @xmath14 of facilities , each having at least @xmath15 co - located clients ( for some @xmath16 $ ] ) . </S>",
    "<S> one of our key insights is that one can reduce the resulting instance , denoted @xmath17 , to a problem we introduce , called _ capacity - discounted _ ( ) . is a special case of capacitated facility location ( ) where facilities are either uncapacitated , or have finite capacity and zero opening costs . circumventing the difficulty that inherits the intractability of with respect to lp - based approximation guarantees , we give a simple local - search algorithm for based on add , delete , and swap moves that achieves the same approximation ratio ( of @xmath18 ) as the corresponding local - search algorithm for . </S>",
    "<S> in contrast , the algorithm in  @xcite proceeds by reducing @xmath17 to , whose current - best approximation ratio is worse than that of our local - search algorithm for , and this is one of the reasons behind our algorithm s improved approximation ratio .    </S>",
    "<S> another new ingredient of our -algorithm and analysis is a subtly different method for constructing a bicriteria solution for @xmath0 ( and hence , @xmath17 ) , combined with the more significant change that we now choose a _ random _ </S>",
    "<S> @xmath19 from a suitable distribution . </S>",
    "<S> this leads to a surprising degree of improvement in the approximation factor , which is reminiscent of the mileage provided by random @xmath19-points in scheduling problems . </S>"
  ]
}