{
  "article_text": [
    "bellantoni and cook@xcite introduced a class @xmath0 of functions on finite binary strings .",
    "arguments of each function @xmath1 in the class @xmath0 are divided to _ normal _",
    "arguments @xmath2 and _ safe _",
    "arguments @xmath3 , and denoted @xmath4 .",
    "let @xmath5 denote the empty string , and @xmath6 the concatenated string obtained from the binary string @xmath7 and @xmath8 .",
    "the class @xmath0 is generated from initial functions ( projections , zero , binary successors @xmath9 , the predecessor @xmath10 , @xmath11 , the conditional(parity test ) @xmath12 if @xmath13 , @xmath14 otherwise ) by operating safe composition @xmath15 and predicative recursion on notation @xmath16 and @xmath17 for @xmath8 .",
    "it is shown in @xcite that the polynomial time computable functions are exactly those functions in @xmath0 having no safe arguments .",
    "it seems to me that the class @xmath0 not only characterize the class of the polynomial time computable functions , but also is of foundational importance since each function in @xmath0 is computable _",
    "predicatively_. by computability we mean that each object reaches to a canonical form by some computations",
    ". in a predicatively justifiable computation we can not assume a computation to be a completed process in advance since it involves infinite searches or at least the notion of finite computations ( completed processes ) in general .",
    "for example a substitution of @xmath18 in a normal argument , @xmath19 is hard to justify predicatively since it assumes a hypothetical computation of @xmath18 to be completed . on the other side",
    ", we see that a computation process of each function @xmath4 in @xmath0 can be obtained by imitating the generating process of normal arguments @xmath2 . in the computation process",
    "the safe arguments @xmath3 act only as _ names_. in other words we do nt need to know the values ( canonical forms ) of @xmath3 , but need the values of normal arguments @xmath2 from which we know how the arguments are generated from @xmath5 by rules @xmath20 . in this sense",
    "the predicative recursion on notation is justifiable predicatively .",
    "this observation was implicit in our joint work@xcite with g. moser to design a path order pop for computations in @xmath0 .",
    "we now ask how to define predicatively justifiable computations on _ sets _ ?",
    "contrary to binary strings , there seem no canonical forms of sets even for hereditarily finite sets unless we assume , e.g. , the axiom of constructibility .",
    "let us approach modestly .",
    "first pick some functions on safe arguments to generate sets such as pairing and unions . then applying safe composition and a safe set recursion @xmath21 to get a class of functions on sets .",
    "each set is inductively generated , i.e. , the epsilon relation @xmath22 is well founded .",
    "safe set recursion is close to the idea of predicatively computable functions since we do nt need to know the values of intermediate terms @xmath23 to continue the computations of @xmath24 .",
    "thus a class pcsf of predicatively computable set functions is obtained in section [ sec : pcsf ] .",
    "the class pcsf is a subclass of the class srsf of safe recursive set functions due to a. beckmann , s. buss and s. friedman @xcite .",
    "their joint work motivates ours , and is reported in section [ sec : bbf ] .    in section [ sec : string ]",
    "it is shown that each polynomial time computable function on finite binary strings is in the class pcsf , cf .",
    "lemma [ lem : ptimepcsf ] . in section [ sec : hf ] the size of pcsf function @xmath4 is seen to be bounded by a polynomial in the sizes of normal arguments @xmath2 , and to depend linearly on the safe arguments @xmath3 , cf .",
    "theorem [ th : size ] . from this",
    "we see readily that each pcsf function @xmath25 on finite binary strings is polynomial time computable , cf .",
    "corollary [ th : main ] .",
    "a. beckmann , s. buss and s. friedman @xcite introduced a class srsf of _ safe recursive set functions_. the class srsf is obtained from gandy - jensen rudimentary set functions on _ safe arguments _ by safe composition scheme and predicative set ( primitive ) recursion scheme a l bellantoni - cook .    (",
    "projection ) : :    @xmath26 ( difference ) : :    @xmath27 ( pair ) : :    @xmath28 ( bounded union ) : :    @xmath29 ( safe composition ) : :    @xmath30 ( predicative set recursion ) : :    @xmath31    they investigate definability and complexity of safe recursive functions .    1",
    ".   for each @xmath32 there exists a polynomial function @xmath33 on ordinals such that @xmath34 .",
    "2 .   a set - theoretic function @xmath25 on infinite ranks",
    "@xmath2 is in srsf iff it is @xmath35-definable on @xmath36 for an @xmath37 , where for ordinals @xmath38 and sets @xmath39 @xmath40 denotes the @xmath41-hierarchy relativized to @xmath39 , and @xmath42 the transitive closure of @xmath39 .",
    "3 .   for each @xmath32 there exists a polynomial function @xmath43 such that @xmath44 , where @xmath45 denotes the cardinality of sets @xmath39 .",
    "4 .   under a natural encoding of finite binary strings ,",
    "@xmath32 on finite strings are exactly the functions computed by alternating turing machines running in exponential time with polynomially many alternations .",
    "it seems to me that it is hard to justify the class srsf predicatively .",
    "the problem lies in * ( bounded union ) * since it requires us to know _ all _ of the elements @xmath46 in the set @xmath47 in safe argument .",
    "however we do nt know its _ value _ , but only know its _ name _ of @xmath47 . therefore collecting all the elements of sets in safe argument",
    "might not be in the idea of predicatively justifiable computations .",
    "let me propose a subclass pcsf of _ predicatively _ computable set functions .",
    "first a subclass @xmath48 of pcsf is introduced .",
    "each function @xmath1 in the subclass @xmath48 has no normal arguments @xmath49 .",
    "initial functions in @xmath48 are * ( projection ) * on safe arguments , @xmath50 , * ( pair ) * , * ( null ) * , * ( union ) * , and * ( conditional@xmath51)*.    ( null ) : :    @xmath52 ( union ) : :    @xmath53 ( conditional@xmath51 ) : :    @xmath54    the class @xmath48 is closed under composition @xmath55 , and * ( safe separation)*.    ( safe separation ) : :    @xmath56    the class pcsf is then obtained from @xmath48 and * ( projection ) * @xmath57 by operating * ( safe composition ) * and * ( predicative set recursion)*.    a relation @xmath58 is in pcsf if its characteristic function @xmath59 is in the class .",
    "( @xmath60 if @xmath58 , @xmath61 otherwise . )",
    "+ * remark*. it is open , but unlikely the case that the class pcsf is closed under the following safe separation scheme . @xmath62    recall that a function @xmath1 is said to be _ simple _ iff @xmath63 is @xmath64 for any @xmath64-relations @xmath65 . as in @xcite",
    "we see the following proposition .",
    "[ prp : simple ] each @xmath66 is a simple function .",
    "hence @xmath1 is a @xmath64-function in the sense that its graph is @xmath64 .    as in @xcite",
    "we see the following proposition .",
    "proposition [ prp : rathjen22].[prp : rathjen22.2a ] tells us that a relation is in @xmath48 iff it is rudimentary .    as in set - theoretic literature , @xmath67 , which is the unique element @xmath68 such that @xmath69 if such a @xmath68 exists , and @xmath70 .",
    "[ prp : rathjen22 ]    1 .",
    "[ prp : rathjen22.-1 ] @xmath71 is in @xmath48 .",
    "[ prp : rathjen22.0 ] if @xmath72 is in pcsf , then so is @xmath1 , where @xmath73 .",
    "[ prp : rathjen22.1 ] if @xmath74 are in pcsf , then so is @xmath1 , where if @xmath58 , then @xmath75 else @xmath76 .",
    "[ prp : rathjen22.2 ] the class of relations in pcsf is closed under boolean operations .",
    "[ prp : rathjen22.2a ] + a relation @xmath77 is @xmath64 iff its characteristic function @xmath78 is in @xmath48 .",
    "[ prp : rathjen22.2b ] @xmath79 is in @xmath48 for the @xmath64-relation @xmath80 where @xmath81 .",
    "[ prp : rathjen22.4 ] if @xmath82 is in pcsf , then so is @xmath83",
    "[ prp : rathjen22.3](cf . *",
    "( bounded union)*. ) + if @xmath82 is in pcsf , then so is @xmath1 , where @xmath84 .",
    "[ prp : rathjen22.5 ] if @xmath85 are in pcsf , then so are @xmath86 , where @xmath87 and @xmath88 . 10 .",
    "[ prp : rathjen22.2c ] @xmath89 and @xmath90 are in @xmath91",
    "[ prp : rathjen22.7 ] the transitive closure @xmath92 and the rank @xmath93 are in pcsf . 12 .",
    "[ prp : rathjen22.4a ] if @xmath82 is in pcsf , then so is + ( predicative function recursion ) : :    @xmath94 + where @xmath95 .",
    "+ conversely any pcsf - function is generated from @xmath48-functions and * ( projection ) * by * ( safe composition ) * and * ( predicative function recursion)*. 13 .",
    "[ prp : rathjen22.10 ] let @xmath65 be a @xmath64-relation .",
    "assume that @xmath96 $ ] .",
    "let @xmath97 iff @xmath98 .",
    "then @xmath1 is in pcsf .    _",
    "proof_. [ prp : rathjen22].[prp : rathjen22.-1 ] . @xmath99 by * ( safe separation)*. + [ prp : rathjen22].[prp : rathjen22.2a ] . if @xmath100 , then @xmath101 is a @xmath64-relation by proposition [ prp : simple ] .    conversely consider a relation @xmath102 with a @xmath64-relation @xmath103 .",
    "then @xmath104 is in @xmath48 .",
    "hence so is @xmath105 . for disjunctions @xmath106 use the finite union @xmath107 , and for negations @xmath77 use the conditional @xmath108 .",
    "+ [ prp : rathjen22].[prp : rathjen22.3 ] .",
    "let @xmath109 if @xmath22 .",
    "@xmath110 otherwise , where @xmath22 is in pcsf by * ( conditional@xmath51 ) * and proposition [ prp : rathjen22].[prp : rathjen22.0 ] .",
    "let @xmath111 .",
    "then @xmath112 [ prp : rathjen22].[prp : rathjen22.5 ] . by proposition",
    "[ prp : rathjen22].[prp : rathjen22.3 ] @xmath113 is in pcsf .",
    "then so is @xmath114 .",
    "+ [ prp : rathjen22].[prp : rathjen22.2c ] . by propositions",
    "[ prp : rathjen22].[prp : rathjen22.2b ] and [ prp : rathjen22].[prp : rathjen22.5 ] both @xmath89 and @xmath115 are in @xmath91 .",
    "+ [ prp : rathjen22].[prp : rathjen22.7 ] .",
    "let @xmath116 for @xmath117 .",
    "then @xmath118 and @xmath119 since @xmath120 is transitive , i.e. , @xmath121 . + [ prp : rathjen22].[prp : rathjen22.4a ] . let @xmath122 where @xmath123 .",
    "then @xmath124 is in pcsf by propostions [ prp : rathjen22].[prp : rathjen22.4 ] , [ prp : rathjen22].[prp : rathjen22.5 ] and [ prp : rathjen22].[prp : rathjen22.2c ] .",
    "suppose @xmath125 then we have for @xmath126 and @xmath22 , @xmath127 .",
    "hence @xmath128 is in pcsf .",
    "it remains to show ( [ eq : rathjen22.4a ] ) by induction on @xmath39 . by ih(=induction hypothesis ) we have @xmath129 .",
    "hence by the definition of @xmath1 we have @xmath130 .",
    "this shows ( [ eq : rathjen22.4a ] ) , and pcsf is closed under * ( predicative function recursion)*.    conversely if @xmath1 is defined from @xmath82 by * ( predicative set recursion ) * , @xmath21 , then @xmath131 .",
    "@xmath132 is in pcsf by proposition [ prp : rathjen22].[prp : rathjen22.2c ] @xmath1 is defined from @xmath133 by * ( predicative function recursion)*. + [ prp : rathjen22].[prp : rathjen22.10 ] . by propositions [ prp : rathjen22].[prp : rathjen22.2 ] and [ prp : rathjen22].[prp :",
    "rathjen22.2a ] , @xmath64-relation @xmath134 defines a relation @xmath135 in pcsf .",
    "so is @xmath136 by proposition [ prp : rathjen22].[prp : rathjen22.5 ] .",
    "let @xmath138 denote the set of all _ hereditarily finite sets_. let us encode finite ( binary ) strings by hereditarily finite sets , @xmath139 slightly modified from @xcite .",
    "@xmath140 ( @xmath5 is the empty string . ) @xmath141 .",
    "@xmath142 . for example , @xmath143 .",
    "[ lem : ptimepcsf ] for each polynomial time computable function @xmath144 there exists a function @xmath145 in pcsf such that for any finite strings @xmath146 @xmath147    _ proof_. let @xmath0 denote the class of safe recursive functions on binary finite strings in @xcite .",
    "we show inductively for each @xmath148 there exists a function @xmath145 in pcsf such that for any finite strings @xmath149 , @xmath150 .    for the binary successor @xmath9 , @xmath151 does the job .    for the predecessor @xmath10 , @xmath11",
    ", first let by propositions [ prp : rathjen22].[prp : rathjen22.1 ] and [ prp : rathjen22].[prp : rathjen22.2a ] @xmath152 \\\\ 0 & \\mbox{{\\rm otherwise } } \\end{array } \\right.\\ ] ] namely @xmath153",
    ". then let @xmath154 by proposition [ prp : rathjen22].[prp : rathjen22.-1 ] .",
    "we have @xmath155 since @xmath156 .",
    "next consider conditional(parity test ) @xmath12 if @xmath13 , @xmath14 otherwise .",
    "since @xmath157 and @xmath158 , @xmath159 enjoys @xmath160 .",
    "the case when @xmath161 is defined from @xmath162 by predicative composition is seen from ih .",
    "finally consider predicative recursion on notation . @xmath16 and @xmath17 for @xmath8 .",
    "let @xmath163 and @xmath164 be functions in pcsf for @xmath165 and @xmath166 , resp .",
    "define @xmath145 as follows .",
    "@xmath167 . let @xmath8 .",
    "suppose @xmath169 , @xmath170 , and @xmath171 .",
    "then let + @xmath172 .",
    "@xmath173 for @xmath174 .",
    "@xmath175 . otherwise @xmath176 .",
    "then we compute for @xmath8 , if @xmath177 , + @xmath178 , and @xmath179 .",
    "@xmath137 + * remark*. lemma [ lem : ptimepcsf ] holds also for a subclass @xmath180 .",
    "the initial functions in the subclass are projections @xmath57 , @xmath181 , @xmath182 , @xmath183 in the proof of lemma [ lem : ptimepcsf ] , @xmath184 and @xmath185 .",
    "the class @xmath180 is closed under * ( safe composition ) * and the scheme @xmath83 , cf .",
    "proposition [ prp : rathjen22].[prp : rathjen22.4 ] .",
    "moreover * ( safe separation ) * is needed only in defining @xmath186 , @xmath187 ( proposition [ prp : rathjen22].[prp : rathjen22.2b ] ) and @xmath183 for lemma [ lem : ptimepcsf ] .",
    "namely the separation @xmath188 , @xmath189 , @xmath190\\}$ ] and @xmath191 .",
    "let us restrict our attention to hereditarily finite sets @xmath138 .",
    "@xmath192 denote hereditarily finite sets .",
    "each function @xmath1 in pcsf is a function on @xmath138 when it is restricted to @xmath138 .",
    "the size of @xmath4 is seen to be bounded by a polynomial in the sizes of normal arguments @xmath2 , and depend _ linearly _ on the safe arguments @xmath3 , cf .",
    "theorem [ th : size ] .",
    "this readily yields the converse of lemma [ lem : ptimepcsf ] , cf .",
    "corollary [ th : main ] .",
    "let us introduce some abbreviations to state and shorten the proof of the following lemma .",
    "for hereditarily finite sets @xmath213 , let us denote @xmath196 , @xmath214 , @xmath215 , @xmath216 , and @xmath217 .",
    "let @xmath218 , and @xmath219 . for sequences",
    "@xmath220 , @xmath221 of natural numbers @xmath222 , let @xmath223 .",
    "let @xmath224 be sequences for lists @xmath225 of functions @xmath226 .",
    "each @xmath227 is a sequence of natural numbers in length @xmath228 .",
    "also let @xmath229 be lists of hereditarily finite sets .",
    "+ then let @xmath230 and @xmath231 . let @xmath232 furthermore for lists @xmath233 of ( definitions of ) functions @xmath234 , let @xmath235      for any list @xmath214 of hereditarily finite sets @xmath238 , any list of functions @xmath239 of @xmath240 , any list @xmath201 of @xmath241 , any hereditarily finite set @xmath0 , any sequences @xmath224 for functions @xmath242 and any sequences @xmath243 for functions @xmath244 the following holds :      lemma [ prp : coverp ] yields theorem [ th : size ] as follows . for @xmath246 with the list @xmath247 , @xmath248 , i.e. , the projection @xmath249 , and @xmath250",
    ", we have a polynomial @xmath251 such that for any lists of hereditarily finite sets @xmath252 , @xmath201 , @xmath253 .",
    ". then @xmath255 and @xmath256 for @xmath257 .",
    "+ _ proof _ of lemma [ prp : coverp ] .",
    "let us define a natural number @xmath258 for each function @xmath246 as follows .",
    "first @xmath259 if @xmath1 is one of null , pair , projections @xmath57 , union , @xmath260 and functions defined by * ( safe separation)*. second @xmath261 if @xmath1 is defined by * ( safe composition ) * from @xmath262 , @xmath263 .",
    "third @xmath264 if @xmath1 is defined by * ( predicative set recursion ) * from @xmath82 . finally for lists @xmath233 of functions , let @xmath265 .",
    "let @xmath270 and @xmath271 .",
    "by ih we have a polynomial @xmath272 for the list @xmath273 . + * ( null ) * if @xmath1 is @xmath274 , then @xmath275 .",
    "+ * ( projection ) * + if @xmath1 is a projection @xmath276 , then @xmath277 is one of @xmath278 and @xmath279 . in the former case @xmath280 , while in the latter case @xmath275 . + * ( pair ) * + if @xmath1 is the pair @xmath281 , then @xmath282 .",
    "+ * ( union ) * + if @xmath1 is the union @xmath283 , then @xmath275 .",
    "+ * ( conditional@xmath51 ) * + if @xmath1 is the conditional @xmath284 , then @xmath275 .",
    "+ * ( safe separation ) * + if @xmath1 is defined from @xmath82 by * ( safe separation ) * @xmath285 , then @xmath275 . + * ( safe composition ) * + consider the case when @xmath1 is defined from @xmath82 , @xmath286 and @xmath287 by * ( safe composition ) * , + @xmath288 , where each @xmath289 is a pcsf - function .",
    "let @xmath299 for @xmath300 , and @xmath301 , where @xmath302 is substituted for each variable @xmath303 in the list @xmath304 , @xmath305\\leq \\prod_{i } ct(z_{i})$ ] , and @xmath306 .",
    "then @xmath307 * ( predicative set recursion ) * + consider the case when @xmath1 is defined from @xmath82 by * ( predicative set recursion ) * , @xmath308 . by proposition",
    "[ prp : rathjen22].[prp : rathjen22.5 ] there exists a pcsf - function @xmath309 .",
    "now we show that any function @xmath246 is polynomial time computable when we restrict @xmath1 to @xmath138 . to be specific ,",
    "let us encode hereditarily finite sets first by dags(directed acyclic graphs ) , and then encode dag s by natural numbers .        in what follows a dag with root",
    "is simply said to be a dag .",
    "@xmath339 designates that there is an edge from @xmath340 to @xmath47 . from the condition ( [ df : dag2 ] ) in definition [ df : dag ] we see that @xmath163 is acyclic . for a dag @xmath331",
    "we write @xmath341 , @xmath342 and @xmath343 .    for nodes",
    "@xmath344 , @xmath345 denotes a dag @xmath346 defined by @xmath347 , and for @xmath348 , @xmath349 iff there exists a path from @xmath340 to @xmath47 in @xmath163 , i.e. , there is a sequence @xmath350 such that @xmath351 , @xmath352 and @xmath353 .",
    "the _ rank _ @xmath354 of nodes @xmath340 in @xmath163 is defined by @xmath355 , where @xmath356 .",
    "then the rank of @xmath163 is defined by @xmath357 . while the _ length _ @xmath358 of the longest path from @xmath335 to @xmath340 is defined by @xmath359 .        1 .",
    "each node @xmath344 encodes a hereditarily finite set @xmath361 defined by recursion on ranks @xmath354 : @xmath362 dag @xmath163 encodes a hereditarily finite set @xmath363 .",
    "@xmath344 and @xmath364 are _ bisimilar _ ( with respect to @xmath365 ) , denoted @xmath366 or simply @xmath367 iff @xmath368 .",
    "+ @xmath163 and @xmath369 are _ _ bisimilar _ _ , denoted @xmath370 iff @xmath371 , i.e. , @xmath372 .",
    "@xmath163 is _ fully collapsed _",
    "iff for any nodes @xmath373 in @xmath163 , if @xmath374 then @xmath375 .",
    "we assume a feasible encoding of finite sequences of natural numbers .",
    "@xmath377 denotes the code of sequence @xmath378 of natural numbers @xmath379 .",
    "@xmath380 denotes the code of dag @xmath331 .",
    "specifically @xmath381 , where for nodes @xmath382 , its code @xmath383 , and for edges @xmath384 , @xmath385 , where @xmath386 and @xmath387 .",
    "it is plain to see that to be a code of a dag is polynomial time decidable , and ranks @xmath354 and lengths @xmath358 of nodes @xmath340 in @xmath163 are polynomial time computable from @xmath388 and @xmath340 .",
    "moreover given a code @xmath389 of dag and a node @xmath390 , one can compute the code @xmath391 in polynomial time .",
    "therefore let us identify dag @xmath163 with its code @xmath389 , and , e.g. , say that @xmath345 is polynomial time computable .          1 .",
    "[ prp : bisimilarfullcollapsed1 ] bisimilarity in dag s is polynomial time decidable .",
    "[ prp : bisimilarfullcollapsed15 ] there is a polynomial time function @xmath65 such that for any given dag @xmath163 , @xmath398 and @xmath163 are bisimilar and @xmath398 is balanced with @xmath399 .",
    "moreover if @xmath163 is fully collapsed , then so is @xmath398 .",
    "[ prp : bisimilarfullcollapsed2 ] there is a polynomial time function @xmath46 such that for any given dag s @xmath400 , @xmath401 is a fully collapsed dag such that @xmath402    _ proof_. [ prp : bisimilarfullcollapsed].[prp : bisimilarfullcollapsed1 ] .",
    "let @xmath403 iff there exists an edge @xmath404 .",
    "then @xmath370 iff @xmath405 .",
    "a bisimilarity test is performed at most @xmath406 times .",
    "+ [ prp : bisimilarfullcollapsed].[prp : bisimilarfullcollapsed2 ] .",
    "we can assume that sets @xmath407 are disjoint , for otherwise replace @xmath408 by @xmath409 , where @xmath410 and @xmath411 for the bijective pairing @xmath412 .",
    "note that @xmath413 .",
    "let @xmath414 , and @xmath163 be the joined dag .",
    "@xmath415 , @xmath416 and @xmath417 .",
    "clearly @xmath418 .    by recursion on ranks",
    "define dag s @xmath419 so that each @xmath420 and any bisimilar pair @xmath421 has ranks larger than @xmath422 , @xmath423 , as follows . let @xmath424 .",
    "assume that @xmath425 has been defined .",
    "consider @xmath426 of rank @xmath422 and its bisimilar class @xmath427 , and let us share nodes in @xmath428 .",
    "note that for @xmath429 and any @xmath68 , @xmath430 by the construction .",
    "let @xmath431 .",
    "delete every nodes in @xmath428 except @xmath379 , and each edge @xmath432 for @xmath433 is switched to a new edge @xmath434 , where @xmath435 .",
    "the switchings are performed for each @xmath426 of rank @xmath422 .",
    "the resulting dag @xmath164 is bisimilar to @xmath425 , and @xmath436 .",
    "[ lem : hfptime ] for each @xmath246 , there is a polynomial time computable function @xmath145 such that for any balanced and fully collapsed dag s @xmath438 , @xmath439 , @xmath440 is a code @xmath441 of a balanced and fully collapsed dag @xmath442 such that @xmath443 .        * ( union ) * for dag @xmath163 , a dag @xmath369 such that @xmath444 is obtained by @xmath445 , @xmath446 and for @xmath447 , @xmath448 iff either @xmath404 or there is a @xmath449 such that @xmath450 and @xmath451 .      next consider * ( safe composition ) * @xmath452 if all of @xmath82 , @xmath286 and @xmath287 are polynomial time computable on dag s , then so is @xmath1 . finally consider * ( predicative set recursion ) * @xmath453 assume that @xmath454 are hereditarily finite sets @xmath455 for fully collapsed dag s @xmath456 .",
    "let us describe informally a polynomial time computation of a fully collapsed dag @xmath41 such that @xmath457 .",
    "by recursion on ranks @xmath354 of nodes @xmath340 in ` circuit ' @xmath163 , assign a dag @xmath458 such that @xmath459 to @xmath340 as follows .",
    "if @xmath340 is the leaf , i.e. , the node of outdegree zero , then @xmath458 is a fully collapsed dag such that @xmath460 .",
    "next consider the case when @xmath340 is not a leaf , and let @xmath461 be the sons of @xmath340 in @xmath163 : @xmath462 .",
    "assume that for each son @xmath463 a fully collapsed dag @xmath464 is attached to @xmath463 so that @xmath465 .",
    "then by proposition [ prp : bisimilarfullcollapsed].[prp : bisimilarfullcollapsed2 ] compute a fully collapsed dag @xmath466 , and then let @xmath458 be a fully collapsed dag such that @xmath467 .",
    "let us estimate roughly the number of computation steps .",
    "the number of computations of the function @xmath82 is @xmath468 . by theorem [ th : size ]",
    "we have a polynomial @xmath43 such that @xmath469 since all dag s are balanced and fully collapsed , we have for a polynomial @xmath470 @xmath471 hence each computation of @xmath82 is performed in the number of steps bounded by a polynomial of @xmath397 , @xmath472 and @xmath473 .",
    "moreover the number of computations of @xmath466 is @xmath396 , and each computation of @xmath474 is also performed polynomially in @xmath397 , @xmath472 and @xmath473 . hence the number of computation steps for @xmath41 is bounded by a polynomial of @xmath397 , @xmath472 and @xmath473 .",
    "@xmath137    [ th : main ] suppose a set theoretic function @xmath475 is a function on binary finite strings when we restrict to finite strings : @xmath476 . if @xmath477 , then the function @xmath478 is polynomial time computable .    _",
    "proof_. assume @xmath479 , and let @xmath480 .",
    "then @xmath145 is a polynomial time function on @xmath138 in the sense of theorem [ lem : hfptime ] .",
    "since the function @xmath481 and its inverse @xmath482 are polynomial time computable , so is @xmath1 . @xmath137 + * remark*. let @xmath145 be a polynomial time computable function for @xmath246 in theorem [ lem : hfptime ]",
    ". then @xmath145 has to be an ` extensional ' function on dag s .",
    "this means that for any balanced and fully collapsed dag s @xmath438 , @xmath439 @xmath483    1",
    ".   it seems to us that the converse holds .",
    "namely let @xmath145 be a polynomial time computable function such that @xmath484 is a code of balanced and fully collapsed dag for any balanced and fully collapsed dag s @xmath438 , and @xmath145 is extensional in the above sense .",
    "then the set - theoretic function @xmath1 on @xmath138 is defined by @xmath485 where @xmath486 and @xmath487 for some ( any ) balanced and fully collapsed dag s @xmath438 and @xmath369 .",
    "+ an affirmative answer to the following problem would show a stronger statement than lemma [ lem : ptimepcsf ] since there are polynomial computable functions mapping binary strings @xmath7 to dag s ( balanced and fully collapsed ) representing @xmath488 , and vice versa . + * problem*. show that the @xmath1 is a restriction of a function in the class pcsf on @xmath138 .",
    "2 .   let @xmath489 be a choice function which chooses an element @xmath490 from non - empty sets @xmath340 .",
    "let us set @xmath491 .",
    "it is unlikely the case that there is such a @xmath46 in the class pcsf , nor @xmath46 on @xmath138 is ( extensionally ) polynomial time computable in the sense of theorem [ lem : hfptime ] .",
    "obviously there exists an intensional function @xmath474 which depends on codes .",
    "given dag s @xmath163 , if @xmath492 , then let @xmath493 .",
    "then @xmath494 , and @xmath495 is polynomial time computable , and so is the function @xmath496 .",
    "however @xmath474 is not extensional .",
    "arai , t and moser , g. : proofs of termination of rewrite systems for polytime functions . in : ramanujam ,",
    "r. sen , sandeep(eds . )",
    "fsttcs 2005 : foundations of software technology and theoretical computer science , pp.529 - 540 .",
    "lectute notes in compt .",
    "3821 , springer , berlin ( 2005 )"
  ],
  "abstract_text": [
    "<S> inspired from a joint work by a. beckmann , s. buss and s. friedman , we propose a class of set - theoretic functions , predicatively computable set functions . </S>",
    "<S> each function in this class is polynomial time computable when we restrict to finite binary strings .    </S>",
    "<S> [ section ] [ theorem]definition [ theorem]proposition [ theorem]lemma [ theorem]corollary </S>"
  ]
}