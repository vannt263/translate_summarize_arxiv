{
  "article_text": [
    "bounded arithmetic theories constitute a class of weak subtheories of peano arithmetic with close ties to computational complexity theory .",
    "prominent among them is theory pv defined by cook @xcite as an equational theory and later reformulated as a universal first order theory in @xcite .",
    "theory pv or its mild extensions seem to formalize most of contemporary complexity theory ( cf . @xcite and references therein ) .",
    "for instance , it is known that the pcp theorem can be formalized and proved in pv @xcite .",
    "it is thus of interest to understand , given an established conjecture , whether it is provable in one of these theories or at least consistent with them .",
    "an unprovability statement can be understood as a result illustrating the inadequacy of methods available in the respective theory .",
    "this is studied in complexity theory as the so called barriers ( cf .",
    "@xcite ) , often formulated using ad hoc concepts hard to compare with each other .",
    "the unprovability results on the other hand are in the tradition how mathematical logic captured ( and answered ) similar questions in other parts of mathematics .    the latter direction ,",
    "to show the consistency of the conjecture in question with pv or with stronger theories , is at least as interesting as showing its unprovability .",
    "such a consistency result says that , although we do not know if the conjecture is true ( meaning true in the standard model of natural numbers ) , we know that it is true in a non - standard model of a theory so strong that complexity theory looks in it almost indistinguishable from the standard one .    in this work we study the provability of circuit upper bounds ( or equivalently , the consistency of lower bounds ) .",
    "circuit lower bounds were considered in bounded arithmetic by razborov @xcite in a particular formalism .",
    "we use the somewhat more intrinsic formalism of @xcite and followed in @xcite .",
    "it has been proved in @xcite , assuming that @xmath3  co@xmath4 or that the polynomial time hierarchy does not collapse to the boolean hierarchy , that it is consistent with pv that @xmath5poly . here",
    "we prove _ unconditionally _ that for every @xmath0 there is a language @xmath1 such that it is consistent with cook s theory pv that @xmath2 , where @xmath6 denotes the class of languages decided by _ non - uniform _ boolean circuits of size at most @xmath7 .",
    "we refer to the statement of theorem [ t : main ] below for a precise formulation of the result .",
    "we do not know how to extend our result to buss s theory @xmath8 from @xcite ( results from @xcite were extended there to @xmath8 ) or how to show that one can take sat for @xmath9 for all @xmath0 . perhaps the most accessible problem is to extend our result to pv augmented by the dual weak pigeonhole principle for polynomial time functions , a theory denoted apc@xmath10 by some authors .",
    "the language of pv has function symbols for all polynomial time algorithms as generated by cobham s limited recursion on notation @xcite .",
    "all axioms of pv are universal formulas codifying how particular algorithms are defined from each other .",
    "the details of the definition of pv are fairly technical , but such details are needed only for establishing links between pv and propositional proof systems ( cf .",
    "we use a form of herbrand s theorem ( see below ) , and for that it only matters that the axioms are universal formulas . in fact , we could add to pv any set of true universal sentences as additional axioms , and our unprovability result would still hold",
    ".    we will talk about polynomial time algorithms in the theory meaning that they are represented by the corresponding function symbols .",
    "we shall claim on a few occasions that some algorithm @xmath11 constructed in a particular way from another algorithm @xmath12 can be defined in pv ; this means that pv proves that @xmath11 behaves as described in the definition . in all cases",
    "this is straightforward but tedious , and presupposes a certain amount of bootstrapping of pv which is part of standard background in bounded arithmetic ( see e.g.@xmath13 in @xcite how this is done ) .",
    "the details are not necessary for understanding our argument and can be found in @xcite .",
    "for a unary pv function symbol @xmath14 and integers @xmath15 , denote by @xmath16 the sentence @xmath17 which asserts that the ( polynomial time ) language defined by @xmath14 admits a ( non - uniform ) sequence of circuits of size at most @xmath18 . to denote the number of gates in @xmath19 , while @xmath20 refers to the length of @xmath21 in the usual sense .",
    "also , the symbol @xmath22 abbreviates the universal quantification over strings of the form @xmath23 , i.e. , strings consisting of a sequence of ones . ]",
    "( we refer to @xcite for more information about the formalization of circuit complexity in bounded arithmetic . )",
    "[ t : main ] for every @xmath0 there is a unary pv function symbol @xmath24 such that for no constant @xmath25 pv proves the sentence _ @xmath26_.",
    "the high level idea of the proof is : ( _ i _ ) the provability of ( [ 6a ] ) implies a certain uniformity of the family of circuits , and ( _ ii _ ) we can adapt the proof by santhanam and williams from @xcite that @xmath27 has no uniform sequences of circuits of size @xmath7 , for any fixed @xmath0 .",
    "complications arise as the uniformity given by ( _ i _ ) is more general than the one employed in ( _ ii _ ) .",
    "in particular , it is not clear how to establish theorem [ t : main ] using only the soundness of pv and ( extensions of ) the santhanam - williams theorem .    to get around this difficulty we argue roughly as follows .",
    "either a candidate sentence @xmath28 that we start with is not provable in pv ( and we are done ) , or we extract from any proof of this sentence a finite number of languages in @xmath27 such that pv can not prove that all of them admit circuits of size @xmath7 .",
    "we remark that the non - constructive aspect of the result comes from the fact that the hard language and its deterministic time complexity may depend on a ( possibly non - existent ) proof of the initial sentence .",
    "in order to implement this approach we use that pv is a universal theory for polynomial time computations , a formalization of the main ideas employed in the uniform circuit lower bound from @xcite , the kpt theorem from bounded arithmetic ( theorem [ t : kpt ] below ) , and a finite number of recursive applications of herbrand s theorem .",
    "the argument has a few subtle points , and we make some additional observations after we present the proof of theorem [ t : main ] in section [ s : proof ] .",
    "an alternative and equally natural formalization of circuit upper bounds can be obtained via a single formula _",
    "@xmath29 _ that existentially quantifies over parameter @xmath30 .",
    "this leads however to a sentence of higher quantifier complexity . while kpt witnessing _ _ ( _ _ stated as theorem _ [ t : kpt ] _ in section _",
    "[ s : proof ] ) _ can be generalized in this direction , the information it then offers does not seem to yield the polynomial time algorithms our technique needs . in particular , we leave the unprovability of the modified version as an open problem .    theorem [ t : main ] and a standard compactness argument",
    "imply the following result .",
    "[ c : model ] for every @xmath31 there exists a unary pv function symbol @xmath24 and a model @xmath32 of pv such that for every @xmath33 we have @xmath34    in other words , from the point of view of @xmath32 there are languages in p that require non - uniform circuits of size @xmath35 .",
    "in this section we adapt a proof by santhanam and williams @xcite that @xmath27 is not included in @xmath36-@xmath37-@xmath6 . here",
    "@xmath36-@xmath37-@xmath6 is the class of languages recognizable by a polynomial time uniform family of circuits of size at most @xmath7 .",
    "that is , there is a polynomial time algorithm @xmath14 that on input @xmath38 computes a description of a size @xmath39 circuit @xmath19 , where @xmath25 is a fixed constant .",
    "following @xcite we take as the description the set of all 4-tuples @xmath40 where @xmath41 are names of nodes ( @xmath42 bits each ) such that there is a wire from @xmath43 to @xmath44 , and @xmath45 is the information about the type of the gate at @xmath44 or about the input at @xmath44 if @xmath44 is an input node ( @xmath46 bits ) .",
    "we assume that a special tuple indicates the output node of @xmath19 .",
    "the language consisting of all 4-tuples ( [ 1 ] ) for all @xmath47 is called @xmath48 , the direct connection language of @xmath49 .",
    "the following standard definitions play an important role in the argument .",
    "we use @xmath50 to denote the class of languages recognizable by a time @xmath51 algorithm with an advice of size @xmath52 .",
    "we say that a language @xmath9 is infinitely often in a complexity class @xmath53 if @xmath9 agrees on infinitely many input lengths with some language @xmath54 .",
    "the next lemma formalizes the deterministic time hierarchy theorem with a bounded amount of advice .",
    "[ 5 ] for every @xmath55 there is @xmath56 , represented by algorithm @xmath57 computing its characteristic function , such that for every time @xmath51",
    "algorithm @xmath24 working with advice @xmath52 there is @xmath58 such that @xmath59 proves _ _ : _ _ @xmath60    the separation is reported as a folklore result in ( * ? ? ?",
    "* proposition 2.1 ) .",
    "we simply check that its proof formalizes in pv .",
    "define a time @xmath61 algorithm @xmath57 that operates as follows . on an input @xmath21 of length @xmath62 :    * it interprets the first @xmath63 bits of @xmath21 as a description of a time @xmath64 algorithm @xmath24 , and the next @xmath52 bits as advice @xmath65 , * runs @xmath24 on @xmath21 with advice @xmath65 , * outputs @xmath66 if and only if the simulation ends with a non - zero value .",
    "the constant @xmath67 is chosen so that @xmath68 bits suffice to describe the particular @xmath24 .",
    "observe that in order for the sentence to hold for every large enough @xmath69 it is important that the parts of the input corresponding to the description of the algorithm and the advice are disjoint .",
    "take now @xmath49 a @xmath27-uniform sequence of size @xmath39 circuits and let @xmath14 be the generating polynomial time algorithm .",
    "that is , on input @xmath38 @xmath14 produces the list of 4-tuples as in ( [ 1 ] ) .",
    "following @xcite we compress each such 4-tuple into the 5-tuple @xmath70 where @xmath71 is the dyadic numeral for @xmath69 ( of length @xmath72 bits ) and @xmath73 is chosen to pad the length of the 5-tuple to exactly @xmath74 bits , as soon as @xmath69 is sufficiently large ( parameter @xmath73 is not present in @xcite ) .",
    "the language of all such 5-tuples obtained from @xmath48 is the language @xmath75 , the succinct version of @xmath48 .",
    "it is polynomial time and an algorithm @xmath76 recognizing it can be easily defined from @xmath14 and , in particular , in pv .",
    "let @xmath77 be the polynomial time algorithm evaluating circuit @xmath78 on input @xmath21 .    [ 6 ] let @xmath14 , @xmath49 , and @xmath76 be as above , and assume that for some @xmath79 @xmath80 let @xmath81 for a fixed integer @xmath82 be the function guaranteed to exist by lemma _",
    "[ 5]_. then there exists @xmath83 such that pv proves @xmath84 where @xmath85 abbreviates @xmath86 .",
    "our argument will follow the proof of ( * ? ? ?",
    "* theorem 1.1 ) and is done in pv . assuming ( [ 4 ] ) fails we describe an explicit polynomial time algorithm @xmath24 that will certify that @xmath87 is ( infinitely often ) in @xmath88 .",
    "this contradicts the sentence from lemma [ 5 ] .",
    "algorithm @xmath24 operates as follows . by the assumption ( [ 3 ] ) there are circuits @xmath89 recognizing @xmath75 on @xmath90-bit inputs , where @xmath91 , as defined above . upon receiving @xmath21 , @xmath62 , and advice string @xmath65 , @xmath92 , describing a candidate circuit @xmath89",
    ", @xmath24 tries all possible 3-tuples @xmath93 ( among no more than @xmath94 possibilities ) and for each of them uses @xmath89 to check if the corresponding 5-tuple as in ( [ 2 ] ) is in @xmath75 . since for large enough @xmath69 the corresponding circuit @xmath89 has size @xmath95 , this requires time @xmath96 for each 5-tuple .",
    "there are @xmath94 such simulations so the total time this part takes is @xmath97 .    after this stage",
    "@xmath24 knows the description of @xmath19 , a circuit of size at most @xmath39 , and uses it to compute a candidate value for @xmath98 in time @xmath99 . under our initial assumption ,",
    "the algorithm is correct on infinitely many input lengths , which is contradictory if @xmath82 .",
    "[ 7 ] let @xmath14 , @xmath87 , @xmath100 , @xmath49 , and @xmath76 be as above , and assume that _ ( [ 3 ] ) _ holds .",
    "there is @xmath83 and a polynomial time algorithm @xmath101 such that pv proves latexmath:[\\[\\forall 1^{(n ) } ( n \\geq { { { c_f}}}),\\     that is , @xmath101 provably produces witnesses to _",
    "( [ 4])_.    this follows from lemma [ 6 ] using herbrand s theorem , as ( [ 4 ] ) is a @xmath103-formula and pv is a universal theory .",
    "we will need the following standard witnessing result from bounded arithmetic ( the so called kpt theorem ) , stated below for convenience of the reader .",
    "[ t : kpt ] let @xmath104 be a universal theory with vocabulary @xmath105 , @xmath106 be an open @xmath105-formula , and suppose that @xmath107 then there exist a constant @xmath0 and a finite sequence @xmath108 of @xmath105-terms such that @xmath109 where the notation @xmath110 indicates that these are the only variables occurring in @xmath111 .",
    "continuing with the proof of theorem [ t : main ] , assume @xmath112 where @xmath113 and @xmath25 is arbitrary .",
    "observe that @xmath114 is a sentence of the form @xmath115 , where @xmath106 is an open formula in the language of pv . by theorem [ t : kpt ]",
    "there are polynomial time algorithms @xmath116 where @xmath117 is a fixed constant such that pv proves the universal closure of the following disjunction with @xmath117 disjuncts : @xmath118\\ \\vee\\ ] ] @xmath119\\ \\vee\\ ] ] @xmath120\\ .\\ ] ] we shall complete the proof of the theorem by induction on @xmath117 .",
    "the case @xmath121 and the induction step from @xmath122 to @xmath117 are analogous , and we describe only the latter .",
    "our induction assumption is that for no polynomial time functions @xmath123 is the disjunction of the form above but with only @xmath122 disjuncts and @xmath69 large enough provable in pv .",
    "assume without loss of generality that @xmath82 .",
    "by lemma [ 7 ] applied to @xmath124 and an arbitrary but fixed @xmath125 , i.e. , using the extra hypothesis @xmath126 there is a constant @xmath127 and a polynomial time algorithm @xmath128 such that for @xmath129 @xmath130 substitute @xmath131 in the disjunction above .",
    "that gives for large enough @xmath69 a valid disjunction of the same form ( for different polynomial time functions in place of the @xmath132 s ) , but with @xmath122 disjuncts : @xmath133\\ \\vee\\ ] ] @xmath134\\ .\\ ] ] this violates the induction assumption , and completes the induction step .    in the proof",
    "we have used the hypotheses that pv proves @xmath135 for some @xmath25 , @xmath136 for some @xmath125 , @xmath137 for @xmath138 , etc .",
    ", all together @xmath139 such assumptions .",
    "hence one of them must fail .",
    "this completes the proof of theorem [ t : main ] .    making the informal exposition from section [ s : statement ] a bit more precise ,",
    "observe that we do not obtain a hard language directly from a proof of @xmath28 .",
    "this is done via a iterative process that depends on the provability of additional sentences .    for the reader familiar with the argument in (",
    "* theorem 1.1 ) , notice that we crucially used that the second application of their initial assumption does not require the uniformity condition . roughly speaking",
    ", this would lead to the consideration of the provability in pv of a sentence expressing a uniform circuit upper bound , while here we are concerned with non - uniform circuit complexity .",
    "finally , regarding extending theorem [ t : main ] to stronger theories , we remark that in buss s theory @xmath8 the analogue of theorem [ t : kpt ] requires a number @xmath117 of disjuncts that may depend on @xmath69 , and our induction on parameter @xmath117 could lead to ( composed ) functions of super - polynomial complexity ."
  ],
  "abstract_text": [
    "<S> we establish unconditionally that for every integer @xmath0 there is a language @xmath1 such that it is consistent with cook s theory pv that @xmath2 . </S>",
    "<S> our argument is non - constructive and does not provide an explicit description of this language . </S>"
  ]
}