{
  "article_text": [
    "wireless multi - hop networks , e.g. , wireless mesh networks , wireless sensor networks , have attracted much interests in recent years . in this paper , we propose coded relay , abbreviated as _",
    "crelay _ in the following , which exploits two fundamental properties of transmissions over the wireless medium , namely the existence of partial packets and the overhearing capability .",
    "that is , partial packets are often received by wireless nodes that are not completely correct but still contain a significant amount of correct information . also , because the medium is shared ,",
    "when a node transmits a packet to second node , a third node may overhear this packet .",
    "the core idea of crelay is simple and can be explained as follows .",
    "basically , nodes relay _ coded _ messages to the next hop node depending on the amount of information that has already been overheard , where a coded message is constructed according to an forward error correction ( fec ) code . as a simple example , suppose a path is @xmath0 , while @xmath1 wishes to send a packet @xmath2 to @xmath3 .",
    "@xmath1 first transmits @xmath2 , after which @xmath4 gets @xmath2 while @xmath3 gets a partial packet with some errors .",
    "@xmath3 estimates the number of errors using an error ratio estimator , and asks @xmath4 to send just enough number of parity bytes correct these errors , instead of sending the entire packet .",
    "thus , fewer bytes are transmitted and a better efficiency is achieved . by sending fec - coded messages , crelay opens up new possibilities for packet forwarding in multi - hop wireless networks .",
    "although the idea is simple , the design of crelay faces the following challenges .",
    "first , a protocol should be designed for control message exchange that facilitates packet forwarding at low overhead and low delay .",
    "the control message should allow an upstream node to be informed about the receiving status of a packet to determine whether the packet should be transmitted and if so , the number of parity bytes needed .",
    "note that a packet transmission may reach a far node on the path due to a lucky overhearing , and the bypassed nodes should be exempted from the duty of forwarding because their transmissions are pointless at this moment .",
    "also , the upstream node should be aware of the number of errors in a received packet such that it can send just enough number of parity bytes to correct the errors . avoiding pointless transmission",
    "is the classic challenge facing all opportunistic routing protocols .",
    "existing approaches include structured forwarder coordination @xcite which may discourage spatial reuse @xcite , or randomized network coding @xcite which cleverly eliminates the need of feedback but can not be used in crelay because crelay needs the feedback to determine the number of parity bytes . to this end",
    ", we give a novel , simple solution , based on two key observations : ( 1 ) _ packets usually experience queuing delays at the nodes _ , specially under high load when throughput should be optimized ; ( 2 ) _ the lucky overhearing usually bypasses a small number of nodes on the path _ such that it is possible to propagate the status of an overheard packet to the upstream in a timely manner .",
    "therefore , with a good feedback mechanism , a node can often obtain the receiving status of a packet from its downstream nodes before starting to serve this packet , because it has to serve other packets first .",
    "we design an efficient feedback mechanism for crelay which scavenges all overheard useful information and adopts two tricks we call the _ ack triggered record _ and _ ack propagation_. the overhead is low because all feedback information is piggybacked with data packets whenever possible , not necessarily the packets belonging to the same flow .",
    "second , an algorithm is needed to calculate the best path in crelay .",
    "the routing problem is interesting because a sub - path of an optimal path may not be optimal , due to partial packets and overhearing .",
    "we study the routing problem and propose a practical heuristic algorithm for finding the paths .",
    "third , an estimator is needed to find the number of errors in a received packet , because the receiving node actually does not know the number of errors .",
    "we propose an error ratio estimator , referred to as _",
    "amps _ , which is based on the optimal maximum a posteriori ( map ) estimation .",
    "amps adds only 8 bytes per - frame as overhead and computes the estimate with a constant time table lookup .",
    "our simulations also show that for per - packet level estimation , amps is more accurate than eec @xcite , a recently proposed error ratio estimator , at much less overhead .",
    "our experiments show that amps can achieve good accuracy , e.g. , for more than 58% of the time , its estimation error is no more than 3 bytes among typically 150 transmitted bytes .",
    "we implement crelay within the click modular router @xcite , and test its performance in an 11-node testbed .",
    "the results show that crelay achieves a significantly better performance than the traditional single path routing scheme as well as more @xcite which the state - of - art opportunistic routing protocol without physical layer hint .",
    "for example , the average throughput gain of crelay over more is 36% in our experiments .",
    "the rest of the paper is organized as follows .",
    "section [ relworks ] discusses the related works .",
    "section [ protocol ] describes the crelay protocol .",
    "section [ algorithm ] discusses the problem of finding paths .",
    "section [ errorest ] describes the amps error ratio estimator .",
    "section [ evaluation ] gives the experimental results .",
    "section [ conclusions ] concludes the paper .",
    "partial packets and overhearing opportunities have been realized and studied extensively in recent years , see , for example , @xcite .",
    "compared to other opportunistic routing protocols , crelay operates more like a traditional routing protocol , in that ( 1 ) crelay forwards packets in a per - packet basis while exor @xcite , more @xcite , and mixit @xcite require a batch of packets to be assembled before the transmission , ( 2 ) crelay maintains per - neighbor buffer while exor , more , and mixit maintain per - flow buffer hence have higher protocol complexity .",
    "in addition , network - coding - based solutions such as more and mixit need to solve linear equations to recover every packet , which poses high requirements on the computational capabilities as well as power capabilities .",
    "another core difference between crelay and mixit is that crelay does not rely on physical layer hints to handle partial packets , hence can be used in a wider range of application scenarios because physical layer hints are not always available @xcite .",
    "crelay uses fec code in a network , however it is different from network coding .",
    "wireless network coding combines multiple packets into a coded packet , usually through a linear transformation , and broadcast the coded packet @xcite .",
    "crelay does not mix multiple packets and does not incur the associated computational cost .    introducing relaying",
    "nodes has been proposed for cellular phone networks .",
    "for example , lte base stations may employ relaying devices in a cell which can significantly improve the throughput @xcite .",
    "the idea of crelay was actually originated from _ corporative relaying _ , where itself is still an active research area in the signal processing community @xcite .",
    "existing research on corporative relaying considers forwarding messages in a two - hop scenario ; however , crelay focuses on multi - hop networks , where the routing problem is much more challenging .",
    "recently , error estimation coding ( eec ) @xcite was proposed for estimating the error ratios .",
    "eec focuses on the average error ratio of a link , while apms focuses on the individual error ratio of the packets .",
    "eec , with non - trivial probability , may output 0 as the estimated number of errors for partial packets , which is tolerable for link - level estimation after taking the average ; however , it can not be applied directly to crelay which needs accurate , per - packet estimation .",
    "we make a more detailed comparison between eec and amps in section [ compeec ] , where we show that for per - packet estimation , amps outperforms eec with lower overhead .",
    "we describe the crelay protocol in this section .      crelay is basically a link state protocol where nodes learn and propagate the quality of the links .",
    "a link is measured by two values , namely the _ erasure ratio _ and the _ error ratio _",
    ", where the former is the fraction of frames that are unaware of by the receiver and the latter is the fraction of the erroneous bytes in a received frame .",
    "a _ path _ is an ordered list of nodes that will participate in relaying the packet .",
    "all nodes appearing earlier than a node in the list are the _ upstream nodes _ , and all nodes appear later the _",
    "downstream nodes_. nodes determine the packet forwarding paths based on the link states , and every node should find the same path for a particular pair of source and destination .",
    "when received a packet from the upper layer , the source node inject the packet into the network whenever it gets the opportunity and nodes in the forwarding path will collaborate in relaying it , bypassing some nodes sometimes , until it reaches the destination .",
    "a node maintains a queue for each neighbor , and buffers a packet in the queue for neighbor @xmath1 if the next hop of the packet is @xmath1 .",
    "packets in the a queue are first - come - first - served ; different queues are served according to round - robin .",
    "crelay can work with any error correction code .",
    "the current implementation uses the reed - solomon ( rs ) code , because of its strong error correction capability and the availability of software implementations @xcite . using the rs code ,",
    "if there are @xmath5 erroneous bytes in the received data belonging to a codeword , with _ any _ additional @xmath6 bytes in the codeword , all errors can be corrected .",
    "a node does not have to receive all bytes in the codeword ; the part that are not transmitted can be treated as _ erasures _ @xcite .",
    "errors in the packets may occur in bursts , which is not desirable because it may result in one codeword handling too many errors , thus exceeding the decoding capability , while others handling too few . to cope with this",
    ", crelay adopts _ interleaving_. basically , before transmission , bytes in the data field of a frame are mapped to random locations according to a random permutation , and at the receiver , the reverse of the random permutation is applied before handing the packet for processing .",
    "the effect of this is that errors are relocated to random locations such that they are spread evenly in the packet .",
    "the four main concepts in crelay with regarding to packet forwarding are _ block _ , _ codeword _ , _ segment _ , and _ record _ :    * block : a data packet from the upper layer is divided into a number of blocks of equal size , padded if necessary . *",
    "codeword : a block is encoded according to the rs code into a codeword , which is basically the data bytes followed by the generated parity bytes .",
    "* segment : a continuous segment of bytes in a codeword , represented by an interval of integers . * record : the received segment(s ) in a codeword .",
    "the segment(s ) may be scattered in the codeword .",
    "they usually do not overlap ; in case of overlap , for the overlapping part , the one with less errors is used .    in our current implementation",
    ", each block is 150 data bytes , and each codeword is 255 bytes according to the ( 255 , 150 ) rs code .",
    "when transmitting a packet , for simplicity , a node transmits the same segment in all codewords .",
    "we say a record is _ decodable _ if the original data block can be recovered from it .",
    "if a block has been recovered from the record , we also say it is decoded .",
    "if all blocks in a packet are decoded , we say the packet is decoded .",
    "a node always monitors the channel . when receives a data packet , if it is on the forwarding path of this packet , found based on the source and destination i d , it checks whether it is on the downstream of the packet sender .",
    "if yes , it adds the newly received segments to its records of this packet .",
    "it then runs amps to estimate the number of errors . as the number of errors in the transmitted segments may vary",
    ", it estimates the maximum number of errors in a segment among all segments , and uses it as the estimate for all segments .",
    "it then estimates whether the records are decodable .",
    "if no , when gets access to the medium , it announces the receiving status of the packet , which includes the start location , end location , and estimated number of errors of each segment that has been overheard .",
    "after receives another segment , a node may attempt to decode .",
    "if the decoding is successful , it sends an ack ; otherwise it announces the new receiving status and waits for the next segment until all records are decoded or a timeout .",
    "it could happen that the decoding fails only at certain records ; in this case the node announces a mask of the decoded records , and the upstream node will transmit segments only for the undecoded records .",
    "the sender , when transmitting for a packet , chooses a minimum size segment such that the next hop node should be able to decode the records .",
    "the receiving status of nodes further downstream are not considered because they may be better served by nodes closer to them . basically , it runs a linear search at selected locations and estimates the number of bytes needed if the segment starts at this location , and picks the one that needs the minimum .",
    "the list of locations include the start and end of each segment that has been overheard , plus the first byte of the codeword .",
    "[ fig : crexample ] is a simple example for the illustration of the concepts .",
    "the data packet from the upper layer is assumed to be 16 bytes , and is organized into 2 blocks .",
    "each block is encoded into a codeword with 4 parity bytes .",
    "the first transmission is segment ( 0,7 ) , i.e. , the data bytes , for both blocks .",
    "the channel corrupted 1 byte in the transmitted segment for block 0 .",
    "the receiving node estimates the maximum number of errors among the two transmitted segments to be 1 , and announces ( 0,7,1 ) as the receiving status .",
    "the sending node , seeing that there is 1 error , transmits segment ( 8,9 ) , because the 2 parity bytes should correct the error .",
    "the channel actually corrupts 1 byte in the transmitted segment for block 1 .",
    "the receiving node estimates that there is no error in the received segments , which is an incorrect estimation , and believes that it has two segments in its record : ( 0,7,1 ) and ( 8,9,0 ) . as 2 parity bytes should correct 1 error , it attempts to decode the records and luckily decoded both .     +     +      after the mac header , a crelay frame consists of three main sections , the header , the announcements , and the data packets , as shown in fig .",
    "[ fig : crformat ] .",
    "the header contains information such as the frame sequence number , the sender s i d , amps samples , etc , and is protected by an fec code .",
    "the announcements section contains acks , packet receiving status , and headers of the data packets in this frame , also protected by an fec code .",
    "the ack contains simply the source and destination i d and the packet sequence number .",
    "the packet receiving status contains the source and destination i d , the packet sequence number , the number of blocks in the packet , the mask of decoded blocks , and the list of received segments .",
    "the data packet header contains the source and destination i d , the packet sequence number , the number of blocks , and the transmitted segment .",
    "the data packets section contains the data .",
    "a frame may have multiple data packets , because one may be a fresh packet and the other may be the parity bytes for another packet .    the overhead of the crelay protocol is mainly the crelay header and the announcement section .",
    "the crelay header is fixed 28 bytes .",
    "the length of the announcement section may vary depending on the number of acks , packet receiving status , and data packets , and is usually no more than 60 bytes .",
    "our experiments show that crelay is able to achieve improved performance over other protocols at this overhead .",
    "we now discuss how crelay meets the main design challenges .",
    "crelay should first ensure that a node sends the correct amount of parity bytes to the next hop node .",
    "denote a node as @xmath7 and its next hop as @xmath8 .",
    "this requires @xmath8 to get a good estimate of the number of errors , addressed by amps to be discussed later ; also , @xmath7 should wait for the receiving status of @xmath8 before sending the packet .",
    "crelay therefore classifies packets into three states , s0 , s1 , and s2 : ( 1 ) in state s0 , some information has been overheard about this packet , but it still not decodable ; ( 2 ) in state s1 , the packet has been successfully decoded , but the receiving status of the packet at the next hop is not known ; ( 3 ) in state s2 , the packet has been successfully decoded , and the receiving status of the next hop is known . only packets in state s2 can be transmitted .",
    "if @xmath8 overhears the packet , @xmath8 should be able to announce the receiving status when it gets access to the medium .",
    "the challenge is that @xmath8 may not have overheard it hence never announces the receiving status , and @xmath7 may hold the packet in state s1 forever .",
    "crelay solves this problem with a simple trick called `` ack triggered record . ''",
    "that is , it let nodes create an empty record of a packet once overheard an ack for this packet , even when no data is overheard .",
    "the empty record will prompt @xmath8 to announce an empty receiving status , which will allow @xmath7 to promote the packet into state s2 .",
    "the rationale behinds this is that @xmath7 will send an ack once it decoded the packet , and most likely , this ack can be overheard by @xmath8 because they are neighbors on the path who should share a relatively good link . as nodes should follow a fair mac protocol to access the channel , after @xmath7 sends the ack , @xmath8 is likely to get the channel and be able to announce the receiving status . thus this solution does not increase much of the delay . in the case that @xmath8 did not overhear the data packet and the ack , crelay relies on timeout and allows a packet to be promoted to state s2 if it has been in state s1 for longer than a threshold .",
    "crelay should also ensure that the `` good forwarders '' forward the packet to reduce pointless transmissions .",
    "that is , suppose a path is @xmath9 .",
    "after @xmath10 gets the packet due to a lucky overhearing , @xmath11 should not transmit if @xmath12 . to achieve this",
    ", crelay adopts a simple strategy based on `` ack propagation . ''",
    "basically , an ack will be propagated from the downstream to the upstream whenever needed , helping the upstream nodes to remove packets that no longer need to be transmitted .    to be more specific , in crelay",
    ", a node sends ack in three cases : ( 1 ) when it decoded the packet , ( 2 ) when it removed the packet recently because received an ack from a downstream node but heard an upstream node sending it again , and ( 3 ) when it overheard an ack or the data packet from a downstream node while it has not decoded the packet itself . any node who gets an ack for a packet from a downstream node will delete the packet . case",
    "( 1 ) is obvious and case ( 2 ) is because if the upstream node is still sending the packet , it did not get an ack from any of its downstream nodes and the downstream node should send ack again .",
    "case ( 3 ) guarantees that if a node sends an ack or sends the packet itself , both can be regarded as a valid ack , this ack will be propagated and eventually known to the upstream nodes that are waiting for acks .",
    "the propagation could take time , and it might be a concern that a node may make an unnecessary transmission before the ack is propagated to it .",
    "however , as discussed earlier , the packet queuing delay usually prevents this from happening .",
    "also , in most cases , this lucky overhearing bypasses a small number of links so the propagation delay is usually small .",
    "in this section , we discuss the routing problem in crelay . routing in crelay",
    "is interesting because a sub - path of an optimal path may no longer be optimal .",
    "for example , consider the simple network shown in fig .",
    "[ fig : routex ] . the number besides a link is the _ receiving ratio _ , defined as the number of bytes that can be decoded if the sender sends one byte .",
    "it represents the quality of the link and is determined by the error ratio and the fec code adopted .",
    "the best path from @xmath13 to @xmath14 is clearly @xmath15 , but the best path from @xmath13 to @xmath16 is @xmath17 , due to the overhearing link from @xmath18 to @xmath16 .",
    "+      we use the _ expected transmission byte ( etb ) _ as the metric of a path , which is the expected of bytes needed to be sent in total such that the destination can receive one byte of data .",
    "it can be calculated based on the erasure ratio and error ratio of the links on the path .    to be more specific ,",
    "denote a path as @xmath19 .",
    "let @xmath20 $ ] denote the expected load of @xmath21 , defined as the expected number of bytes @xmath21 should send .",
    "the metric of path @xmath22 is clearly @xmath23 = \\sum_{i=0}^{n-1 } { l}[{v}_i ] .",
    "$ ] @xmath20 $ ] is determined by the quality of the link between @xmath24 and @xmath25 , as well as the amount of bytes that @xmath25 has overheard from @xmath26 .",
    "the more it has overheard , the less @xmath24 has to send .",
    "let the erasure ratio and error ratio of link @xmath27 be @xmath28 and @xmath29 , respectively . with the rs code , the receiving ratio is @xmath30 we maintain the expected number of bytes that are overheard so far at each node , denoted it as @xmath31 $ ] for node @xmath21 , which is initially 0 .",
    "assuming transmissions are independent , @xmath20 $ ] can be computed iteratively , starting from @xmath32 , shown in algorithm 1 .",
    "set @xmath31 \\leftarrow 0 $ ] and @xmath20 \\leftarrow 0 $ ] for all @xmath33 .",
    "@xmath20 \\leftarrow \\frac{1-{h}[{v}_{i+1}]}{{d}_{i , i+1 } { d}_{i+1,i}}$ ] [ algline : calload ] [ algline : invalid ] invalid @xmath34 \\leftarrow { h}[{v}_{j } ] + { l}[{v}_i ] { d}_{i , j}$ ] @xmath35 $ ]    note that line [ algline : calload ] calculates the expected number of bytes @xmath21 should send to @xmath25 , where @xmath36 $ ] is the number of bytes still missing at @xmath25 , and @xmath37 is the expected number of bytes that @xmath21 has to transmit to _ make sure _ that @xmath25 receives one byte .",
    "the reverse link quality @xmath38 is considered because @xmath21 will be expecting the ack from @xmath25 and will transmit again if the ack is lost .",
    "the check in line [ algline : invalid ] makes sure that the path is valid , because if the condition is true , the path does not have to visit @xmath25 ; otherwise , @xmath34 $ ] is increased by an amount of @xmath20 { d}_{i , j}$ ] due to overhearing . with two levels of loops ,",
    "algorithm 1 s complexity is @xmath39 .",
    "we adopt a greedy algorithm described in algorithm [ alg : routing ] which is similar to the dijkstra s algorithm .",
    "same as dijkstra , a set @xmath40 is maintained which keeps the nodes whose paths to the source node have been determined . in each iteration",
    ", a node not in @xmath40 is selected that has the shortest path to the source node visiting only nodes in @xmath40 .",
    "different from dijkstra , each node has up to @xmath41 candidate paths . in each iteration",
    ", the candidate paths will be updated when a new node is added to @xmath40 .",
    "the algorithm returns the best candidate path for each node when terminates .",
    "the source node is denoted as @xmath32 and the @xmath42 candidate path from @xmath32 to @xmath21 is denoted as @xmath43 where @xmath44 .",
    "the complexity is @xmath45 where @xmath46 is the number of nodes in the network .",
    "@xmath48 \\leftarrow \\frac{1}{{d}_{0,i } { d}_{i,0},}$ ] for all @xmath21 @xmath49 \\leftarrow \\infty$ ] for all @xmath21 and @xmath50 where @xmath51 .",
    "let @xmath52 be the node not in @xmath40 with the best candidate path .",
    "@xmath53 @xmath54 .",
    "let @xmath55 be the candidate path with largest metric .",
    "replace @xmath55 with @xmath56 if @xmath57 > { m}[p]$ ] .",
    "a key component of crelay is error estimation .",
    "a node must know the number of error bytes in a partial packet to be able to ask for the correct number of parity bytes from its upstream node .",
    "our error estimator is referred to as _",
    "amps _ , because it is based on the idea of _ amplified sampling_. a naive sampling method would be taking samples of the data bytes and use the ratio of erroneous sampled bytes as an estimate of the error ratio .",
    "however , because the raw byte error ratio is usually within [ 0 , 0.2 ] and is often very small , e.g. , 0.01 , the naive method may result in high estimation error as it may never sample any erroneous byte .",
    "amps computes a _ sample _ with multiple bytes which , in effect , amplifies the raw byte error ratio into a much larger sample error ratio , and achieves better estimation accuracy .",
    ".list of notations for amps [ cols=\"^,^\",options=\"header \" , ]     [ table : notation ]    we first assume a frame contains only one data packet with @xmath58 bytes into @xmath59 segments of equal size .",
    "the sender randomly samples @xmath60 data bytes , allowing repeat , and computes their parity bit .",
    "each parity bit is a sample . clearly , the probability that the sample s parity is flipped is much larger than the probability that a byte has errors .",
    "for example , if data byte error ratio is 0.01 and @xmath61 , the probability that the sample s parity is flipped is @xmath62 , assuming the values of the errors are random .",
    "a total of @xmath63 samples are calculated in this manner , and the samples are transmitted in the crelay frame header , protected by error correction code . when the receiver receives the frame , it calculates samples in exactly the same way based on the received data bytes .",
    "as some bytes may have been corrupted , the samples it calculates may be different from the samples in the frame header .",
    "we call a mismatching sample an _ error sample _ , and denote the number of error samples as @xmath64 .",
    "@xmath64 carries information about the error conditions in the frame and is used by amps as input to calculate the estimate . from a high level , amps first finds the maximum a posteriori ( map ) estimation of @xmath65 , the number of error data bytes in the packet .",
    "it then finds an estimation of @xmath66 , the maximum number of errors in a segment among all transmitted segments , such that the probability that @xmath66 is greater than its estimate is below a threshold .",
    "table 1 lists the main notations related to amps .",
    "the estimation involves three main steps .",
    "_ step 1 . the conditional probability @xmath67 .",
    "_ note that after interleaving , the error bytes are randomly distributed in the packet . also , we assume the error bytes take random values .",
    "therefore , the probability that a sample is an error sample when there are @xmath68 error bytes , denoted as @xmath69 , is @xmath70 / 2 \\nonumber \\label{eqpsme}\\ ] ] for simplicity , we treat the samples as independent . in this case",
    ", the probability that there are @xmath71 error samples follows the binomial distribution : @xmath72    _ step 2 .",
    "the map estimation of @xmath65 .",
    "_ @xmath73 can be calculated according to the bayesian formula : @xmath74 and the map estimation @xmath75 is the one that maximizes @xmath73 . note that this requires the prior distribution of @xmath76 , which will be discussed shortly .",
    "_ step 3 . the conditional probability @xmath77 .",
    "_ it can be calculated iteratively on the number of segments . to be more specific , we use @xmath78 to denote the probability that @xmath79 when there are @xmath80 segments . by definition , @xmath81 .",
    "first , when there is only one segment , clearly , @xmath82 for notational simplicity , we use @xmath83 to denote the probability that among the @xmath68 error bytes , @xmath84 bytes are in one particular segment when there are @xmath80 segments . because the error bytes are randomly distributed , @xmath85 given @xmath78 , @xmath86 can be found by conditioning on the number of error bytes in a tagged segment .",
    "that is , we single out one segment , called the tagged segment , and check the number of error bytes in this segment .",
    "the event that @xmath79 occurs when ( 1 ) the tagged segment has less than @xmath87 errors while the maximum number of errors in a segment among the remaining segment is exactly @xmath87 , or ( 2 ) the tagged segment has exactly @xmath87 errors while the maximum number of errors in a segment among the remaining segments is no more than @xmath87 .",
    "therefore , @xmath88    after getting @xmath77 as well as @xmath75 , amps outputs @xmath89 such that @xmath90 is greater than a threshold , set to be 0.95 in our implementation .",
    "finally , if there are multiple data packets in the frame , amps first estimates the total number of errors in the whole frame and divides it into each packet proportional to the packet sizes , then estimates of maximum number of errors in a segment for each packet .        for the estimation of @xmath65",
    ", we introduce amps with multiple resolutions , because a particular @xmath60 will always be best for one range of error ratios , but may over - amplify or under - amplify others .",
    "we use three types of samples with @xmath91 , @xmath92 , and @xmath93 , referred to as the type-0 , type-1 , and type-2 samples , respectively .",
    "the type-0 , type-1 , and type-2 samples are responsible for data error ratios in the range of @xmath94 $ ] , @xmath95 $ ] , and @xmath96 $ ] , respectively . assuming the error values are random",
    ", they amplify the data error ratios roughly into sample error ratios of @xmath97 $ ] , @xmath98 $ ] , and @xmath99 $ ] , respectively , such that every range is sufficiently amplified to allow enough number of error samples to be drawn .",
    "the number of samples for type-0 , type-1 , and type-2 samples are 8 , 16 , and 40 , respectively , which are determined by considering the required number of outputs in each range .",
    "the number of errors in a typical packet with error ratio range of @xmath94 $ ] , @xmath95 $ ] , and @xmath96 $ ] are below 20 bytes , 60 bytes , and 400 bytes , respectively , and being able to output respectively 9 , 17 , and 41 different values should suffice .",
    "we basically let each estimator run in parallel . in cases",
    "when the three estimators give different estimates , we take a conservative approach and pick the largest estimate .",
    "note that the total number of samples is 64 , or only 8 bytes .      to reduce the computation complexity",
    ", amps obtains the estimation with a constant time , simple table lookup after @xmath64 is computed .",
    "note that @xmath77 can be precomputed such that the estimation of @xmath66 can be found by a table lookup given the map estimation of @xmath65 .",
    "because @xmath67 can be precomputed , the map estimation of @xmath65 can also be obtained by a table lookup given the value of @xmath64 , if the distribution of @xmath65 is fixed .",
    "however , in practice , the distribution of @xmath65 can vary depending on the wireless channel condition .",
    "we cope with it by computing tables for 100 representative distributions . as the size of the frame and the number of segments may vary",
    ", we also choose representative sizes of the frame and segment and compute corresponding tables .",
    "for any received frame under any channel condition , the table that is closest to its parameters is chosen .",
    "all such tables are computed for each value of @xmath60 .",
    "the total size of the tables used by amps is about 1.5 mb in the current implementation and can be further reduced after relaxing the accuracy requirements .",
    "amps requires the prior @xmath76 , which should be estimated and selected among the representative distributions .",
    "we tested the cisco aironet 802.11a / b / g wireless cardbus adapter @xcite and found that , interestingly , the byte error ratio distribution can be fitted very well in many cases by the truncated pareto distribution : @xmath100 where @xmath101 and @xmath102 are the lower limit and the upper limit of @xmath103 , respectively , and @xmath104 controls the heaviness of the tail @xcite .",
    "this may be due to the heavy tailed nature of the error burst in the received packets .",
    "therefore , the distribution can be described by only one parameter @xmath104 , as @xmath101 and @xmath102 are known in practice , i.e. , @xmath101 is a very small number and @xmath102 is a number close to 1 .",
    "as 100 distributions are needed , we precompute tables for @xmath104 from 0.02 to 2 at a step of 0.02 , while @xmath105 , @xmath106 .    to select a distribution , @xmath104 should be estimated .",
    "we implemented the estimation method in @xcite , where we record the error ratios of the received frames , denoted as @xmath107 for frame @xmath80 .",
    "suppose there are @xmath108 recent samples . according to equation ( 4 ) in @xcite , the estimation ,",
    "denoted as @xmath109 , should satisfy @xmath110 given the set of error ratio values , we find @xmath109 that results in a left side of the above equation closest to the measured @xmath111 on the right side of the equation .",
    "the other error ratio estimator we are aware of is eec @xcite , which also uses the parity bit of multiple bits as a sample and uses multiple levels of samples .",
    "we independently arrived at a similar idea used in amps . besides that , the approaches of amps and eec profoundly differ .",
    "amps is designed according to the standard procedure in estimation theory , namely the map estimation , which is optimal for minimizing the average estimation error required by our application .",
    "eec is based on a simple algorithm without using the knowledge of the prior distribution of error ratios .",
    "we note that the prior distribution can usually be measured at the receiver .",
    "both amps and eec have low computational overhead .",
    "however , for 1500-byte packets , the overhead of amps and eec are 8 bytes and 36 bytes , respectively .",
    "to compare the per - packet level estimation performance , we implemented eec and ran simulations . as amps and eec estimate byte and bit errors , respectively , we injected random byte and bit errors into 1500-byte and 1500-bit packet for them where the error ratio ranged from 0.01 to 0.2 at a step of 0.01 . for each ratio the simulation ran for 10,000 times .",
    "as eec assumes no prior knowledge , for a fair comparison , amps was also not given the prior , and ran based on the distribution of error ratio with the heaviest tail in which case amps approximates a maximum likelihood estimator .",
    "the performance is measured by the difference between the estimated and the real number of injected error bytes / bits .",
    "[ fig : ampseec ] suggests the that amps outperforms eec significantly .",
    "we believe the reason is that eec may discard certain samples while such samples still carry much information .",
    "on the other hand , without the prior distribution , the maximum likelihood estimator is the optimal estimator .",
    "we show in section [ evaluation ] the performance of amps in real - life experiments when the prior knowledge is available .",
    "we conducted experiments to evaluate the performance of crelay .",
    "the compared schemes include    * _ more _ : the benchmark opportunistic routing protocol , * _ srcr _ : the benchmark traditional routing protocol , where nodes use the shortest path according to the etx metric to forward packet hop - by - hop without exploiting partial packets and overhearing .",
    "we used the original implementation at @xcite for more and used our own implementation for srcr .",
    "we implemented a prototype of the crelay protocol in around 5,000 lines of c++ code within the click modular router @xcite as a user space daemon .",
    "packets are transmitted in broadcast frames , same as more @xcite .",
    "the main addition to the crelay protocol discussed in section [ protocol ] is a simple mechanism to cope with interference .",
    "basically , we allow a node @xmath1 to send a polling message to another node @xmath4 , if @xmath1 has not heard any message from @xmath4 for longer than a threshold , while @xmath1 has many packets in state @xmath112 for @xmath4 or has many packets in state @xmath113 for @xmath4 that have been transmitted but have not been acked .",
    "once heard the polling message , @xmath4 transmits while others backoff for a time .",
    "the reason is that @xmath4 s transmission could be lost in collisions due to hidden terminal problems .",
    "this approach is adopted because rts / cts is not designed for broadcast packets in 802.11 .",
    "we also made two optimizations .",
    "first , we allow nodes to send parity bytes preemptively , i.e. , parity bytes are sent along with data bytes in the first transmission attempt , if the link has non - zero error ratio . as a result",
    ", many packets with errors can be decoded at the receiver without requiring the overhead of feedback . in our current implementation , if the error ratio is @xmath114 , a node transmits bytes that can correct @xmath115 fractions of errors for the bytes it sends .",
    "second , in amps , we set the minimum number of estimated errors in a segment to be 3 , as this does not increase much overhead but can reduce the underestimation probability .",
    "we employed an 11-node wireless testbed .",
    "the wireless nodes are laptop computers with cisco aironet 802.11a / b / g cardbus adapter . in our experiments ,",
    "the wireless cards ran on 802.11b / g channel 3 ( 2.427ghz ) when there was little traffic ( less than 3 beacon packets / sec ) during the experiments .",
    "the transmission power was set to be 1dbm ; in addition , aluminum foil was wrapped around the card to reduce the transmission / reception power to allow the experiments to be carried out within the confinements . the testbed setup , as well as two of machines used in the experiments , are shown in fig .",
    "[ fig : testbed ] . with this set up",
    ", we were able to get 46 links where we consider a link exists if the erasure ratios of both directions are lower than 0.8 . among the links , the average rssi was 6.98db , the average erasure ratio was 0.271 , and the average error ratio was 2% .",
    "we ran the madwifi @xcite driver in the monitor mode , which allows us to receive raw data frames for exploiting partial packets .",
    "the mtu was set to be 2200 bytes and the data rate 1mbps .",
    "we selected 72 pairs of nodes in the network , between which crelay found the path to be more than one hop .",
    "this selection was made because we are interested in the performance of multi - hop paths .",
    "each pair is a flow , and we ran the experiment when only one flow was active . in each experiment",
    ", nodes first learn the link states by sending hello packets in the first 9 seconds at random intervals , where a node sends around 50 packets in total . in the next 9 seconds ,",
    "similar to more @xcite , the link state is propagated with the help of a central node using wired links . at time",
    "18 second , the topology learning phase ends and nodes begin to send data packets .",
    "the source node generates packets of size 1500 bytes every 10ms and the experiment runs for another 10 seconds .",
    "we first show in fig .",
    "[ fig : throughput ] the cumulative distribution of the throughput of crelay , more , and srcr measured in the number of received packets by the destination per second .",
    "we can see that crelay has a significantly higher throughput than both more and srcr .",
    "[ fig : singlef ] reveals more interesting details , which shows the scattered plots of crelay v.s .",
    "more and crelay v.s .",
    "srcr for each flow . in the scattered plot , a point the 45-degree line represents a flow in which two compared schemes have the same throughput .",
    "[ fig : singlef ] shows that crelay outperforms more in most flows and outperforms srcr in almost all the flows . as a quantitative measure , for each flow",
    ", we define the throughput gain of scheme a over scheme b as @xmath116 , where @xmath117 and @xmath118 are the throughput of scheme a and scheme b , respectively .",
    "we found that average throughput gain of crelay over more is 36% and the average throughput gain of crelay over srcr is 52% .",
    "+      +    one of the gains of crelay is from exploiting partial packets .",
    "[ fig : ppct ] shows the relation of gain and partial packet ratio for each flow , where the @xmath103 axis is the percentage of partial packets received by the nodes on the packet forwarding path when running crelay , and @xmath119 axis is the throughput gain of crelay over more .",
    "we can see that there is a positive correlation between the gain and the percentage of the partial packets .",
    "[ fig : gainplen ] shows the average throughput gain of crelay over more for paths of different lengths , where the path length is based on the path used by crelay .",
    "the number of paths are 34 , 26 , 10 and 2 for path lengths of 2 , 3 , 4 , and greater than 4 , respectively .",
    "we can see that the gain is usually higher for longer paths , which may be because such paths usually have weaker channels and more opportunities to exploit partial packets .",
    "+     +     +    the performance of crelay is largely dependent on amps . with our current choices of parameters",
    ", we found that for 23.7% of the times , amps underestimates the number of errors and more parity bytes have to be transmitted .",
    "however , even in such cases , usually most of the blocks are decoded and only a few blocks need more transmissions , because the numbers of errors in the records are different . for 3.89% of the time , amps underestimates the number of errors , but the available parity bytes , sent preemptively , are actually sufficient for correcting all the errors . for the rest of the cases",
    "amps overestimates , and fig.[fig : ampsovere ] shows the probability density function of the number of overestimation .",
    "we can see that if overestimated , for more than 80.1% of the times , amps overestimates by no more than 3 bytes per codeword .",
    "it is possible to tune the parameters to achieve other underestimation / overestimation tradeoff .",
    "in this paper , we proposed coded relay ( crelay ) for multi - hop wireless networks . with crelay , nodes can exploit partial packets and overhearing for packet forwarding .",
    "one feature of crelay is that nodes can often send some parity bytes to the next hop to recover the packet , which is significantly smaller than the size of the packet .",
    "we proposed and implemented the crelay protocol in software .",
    "we studied the routing problem with crelay and proposed a greedy algorithm for finding paths .",
    "we also designed an error ratio estimator , called amps , that can estimate the number of errors in a packet with good accuracy at very low overhead .",
    "we tested crelay on an 11-node testbed , and the results show that crelay is capable of achieving significant gain over existing protocols .",
    "i. b. aban , m. m. meerschaert and a. k. panorska , `` parameter estimation for the truncated pareto distribution , '' _ journal of the american statistical association _ ,",
    "vol . 101 , no .",
    "270 - 277 , march 2006 ."
  ],
  "abstract_text": [
    "<S> in this paper , we study coded relay ( crelay ) in multi - hop wireless networks . </S>",
    "<S> crelay exploits both partial packets and overhearing capabilities of the wireless nodes , and uses forward error correction code in packet forwarding . </S>",
    "<S> when a node overhears a partial packet from an upstream node , it informs the upstream node about the number of parity bytes needed to correct the errors , such that the upstream node need only send a small amount of parity bytes instead of the complete packet , hence improving the network efficiency . </S>",
    "<S> our main contributions include the following . </S>",
    "<S> first , we propose an efficient network protocol that can exploit partial packets and overhearing . </S>",
    "<S> second , we study the routing problem in networks with crelay and propose a greedy algorithm for finding the paths . </S>",
    "<S> third , we propose an error ratio estimator , called amps , that can estimate the number of byte errors in a received frame with good accuracy at a low overhead of only 8 bytes per frame , where the estimator is needed for a node to find the number of needed parity bytes . </S>",
    "<S> fourth , we implement the proposed protocol and algorithm within the click modular router , and our experiments show that crelay can significantly improve the performance of wireless networks . </S>"
  ]
}