{
  "article_text": [
    "centrality metrics play an important role to successfully detect the central nodes in various types of networks such as social networks  @xcite , biological networks  @xcite , power networks  @xcite , covert networks  @xcite and decision / action networks  @xcite . among these metrics , _ betweenness",
    "_ has always been an intriguing one and it has been implemented in several tools which are widely used in practice for analyzing networks and graphs  @xcite . in short ,",
    "the betweenness centrality  ( bc ) score of a node is the sum of the fractions of shortest paths between node pairs that pass through the node of interest  @xcite .",
    "hence , it is a measure for the contribution / load / influence / effectiveness of a node while disseminating information through a network .",
    "although betweenness centrality has been proved to be successful for network analysis , computing betweenness centrality scores of all the nodes in a network is expensive .",
    "the first trivial algorithms for bc have @xmath0 and @xmath1 time and space complexity , respectively , where @xmath2 is the number of nodes in the network . considering the size of today s networks ,",
    "these algorithms are not practical .",
    "brandes proposed a faster algorithm which has @xmath3 and @xmath4 time complexity for unweighted and weighted networks , respectively , where @xmath5 is the number of node - node interactions in the network  @xcite .",
    "since the networks in real life are usually _ sparse _",
    ", @xmath6 for a small @xmath7 , @xmath3 is much better than @xmath8 . brandes",
    "algorithm also has a better , @xmath9 , space complexity and currently , it is the best algorithm for bc computations .",
    "yet , it is not fast enough to handle almost 1 billion users of facebook or 150 million users of twitter .",
    "several techniques have been proposed to alleviate the complexity of bc computation for large networks .",
    "a set of works propose using estimated values instead of exact bc scores  @xcite , and others parallelize bc computations on distributed memory architectures  @xcite , multicore cpus  @xcite , and gpus  @xcite .    in this work ,",
    "we propose a set of techniques which compress a network and break it into pieces such that the bc scores of two nodes in two different pieces can be computed independently , and hence , in a more efficient manner . although we designed and tuned these techniques for standard , shortest - path vertex - betweenness centrality , they can be modified for other path - based centrality metrics such as _ closeness _ or other bc variants such as _ edge betweenness _ and _ group betweenness _  @xcite .",
    "similarly , although we are interested in unweighted undirected networks in this paper , our shattering techniques are valid also for weighted directed networks .",
    "experimental results show that proposed techniques are very effective and they can be a great arsenal to reduce the computation in practice .",
    "the rest of the paper is organized as follows : in section  [ sec : bac ] , an algorithmic background for betweenness centrality is given .",
    "the proposed shattering and compression techniques are explained in section  [ sec : sha ] .",
    "section  [ sec : exp ] gives experimental results on various kinds of networks , and section  [ sec : con ] concludes the paper .",
    "let @xmath10 be a network modeled as a graph with @xmath2 vertices and @xmath5 edges where each node in the network is represented by a vertex in @xmath11 , and an interaction between two nodes is represented by an edge in @xmath12 .",
    "we assume that @xmath13 for any @xmath14 , i.e. , @xmath15 is _ loop _ free .",
    "let @xmath16 be the set of vertices which are connected to @xmath17 .",
    "a graph @xmath18 is a _ subgraph _ of @xmath15 if @xmath19 and @xmath20 .",
    "a _ path _ is a vertex sequence such that there exists an edge between consecutive vertices . a path between two vertices @xmath21 and @xmath22",
    "is denoted by @xmath23 .",
    "two vertices @xmath24 and @xmath17 in @xmath11 are _ connected _ if there is a path from @xmath24 to @xmath17 .",
    "if @xmath24 and @xmath17 are connected for all @xmath25 we say @xmath15 is _",
    "connected_. if @xmath15 is not connected , then it is _ disconnected _ and each maximal connected subgraph of @xmath15 is a _ connected component _ , or a component , of @xmath15 .    given a graph @xmath10",
    ", an edge @xmath26 is a _ bridge _ if @xmath27 has more connected components than @xmath15 where @xmath27 is obtained by removing @xmath28 from @xmath12 .",
    "similarly , a vertex @xmath14 is called an _ articulation vertex _ if @xmath29 has more connected components than @xmath15 where @xmath29 is obtained by removing @xmath17 and its edges from @xmath11 and @xmath12 , respectively .",
    "if @xmath15 is connected and it does not contain an articulation vertex we say @xmath15 is _ biconnected_. a maximal biconnected subgraph of @xmath15 is a _",
    "biconnected component_. hence , if @xmath15 is biconnected it has only one biconnected component which is @xmath15 itself .",
    "@xmath10 is a _ clique _ if and only if @xmath30 . the subgraph",
    "induced by _ a subset of vertices @xmath31 is @xmath32 .",
    "a vertex @xmath33 is a _ side vertex _ of @xmath15 if and only if the subgraph of @xmath15 induced by @xmath16 is a clique .",
    "two vertices @xmath24 and @xmath17 are _ identical _ if and only if @xmath34 .",
    "@xmath17 is a _",
    "vertex if and only if @xmath35 .",
    "the betweenness metric is first defined by freeman in sociology to quantify a person s importance on other people s communication in a social network  @xcite . given a graph @xmath15 ,",
    "let @xmath36 be the number of shortest paths from a source @xmath37 to a target @xmath38 .",
    "let @xmath39 be the number of such @xmath23 paths passing through a vertex @xmath40 .",
    "let the _ pair dependency _ of @xmath17 to @xmath41 pair be the fraction @xmath42 .",
    "the betweenness centrality of @xmath17 is defined as @xmath43 } = \\sum_{s \\neq v \\neq t \\in v } \\delta_{st}(v ) .",
    "\\label{eq : first}\\ ] ]    since there are @xmath44 pairs in @xmath11 , one needs @xmath8 operations to compute @xmath45}$ ] for all @xmath14 by using  ( [ eq : first ] ) .",
    "brandes reduced this complexity and proposed an @xmath46 algorithm for unweighted networks  @xcite .",
    "the algorithm is based on the accumulation of pair dependencies over target vertices .",
    "after accumulation , the dependency of @xmath17 to @xmath37 is @xmath47    let @xmath48 be the set of @xmath24 s predecessors on the shortest paths from @xmath21 to all vertices in @xmath11 .",
    "that is , @xmath49 where @xmath50 and @xmath51 are the shortest distances from @xmath21 to @xmath24 and @xmath17 , respectively .",
    "@xmath52 defines the _",
    "shortest paths graph _ rooted in @xmath21 .",
    "brandes observed that the accumulated dependency values can be computed recursively as @xmath53    to compute @xmath54 for all @xmath55 , brandes algorithm uses a two - phase approach .",
    "first , to compute @xmath56 and @xmath57 for each @xmath17 , a breadth first search  ( bfs ) is initiated from @xmath21 . then in a _ back propagation _",
    "phase , @xmath54 is computed for all @xmath14 in a bottom - up manner by using  ( [ eq : recursion ] ) .",
    "each phase takes a linear time , and hence this process takes @xmath58 time .",
    "since there are @xmath2 source vertices and the phases are repeated for each source vertex , the total complexity of the algorithm is @xmath46 .",
    "the pseudo - code of brandes betweenness centrality algorithm is given in algorithm  [ alg : brandes ] .",
    "@xmath45 } \\leftarrow 0 , \\forall v \\in v$ ]",
    "let us start with a simple example : let @xmath10 be a binary tree with @xmath2 vertices hence @xmath59 . if brandes algorithm is used the complexity of computing the bc scores is @xmath44 .",
    "however , by using a structural property of @xmath15 , one can do much better : there is exactly one path between each vertex pair in @xmath11 .",
    "hence for a vertex @xmath14 , @xmath45}$ ] is the number of ( ordered ) pairs communicating via @xmath17 , i.e. , @xmath43 } = 2 \\times \\left((l_vr_v ) + ( n - l_v - r_v - 1 ) ( l_v + r_v)\\right)\\ ] ] where @xmath60 and @xmath61 are the number of vertices in the left and the right subtrees of @xmath17 , respectively . since @xmath60 and @xmath61 can be computed in linear time for all @xmath14 , this approach , which can be easily extended to an arbitrary tree , takes only @xmath62 time .    as mentioned in section  [ sec : int ] , computing bc scores is an expensive task .",
    "however , as the above example shows , some structural properties of the networks can be effectively used to reduce the complexity .",
    "unfortunately , an @xmath2-fold improvement on the execution time is usually not possible since real - life networks rarely have a tree - like from .",
    "however , as we will show , it is still possible to reduce the execution time by using a set of special vertices and edges .",
    "consider the toy graph @xmath15 of a social network given in figure  [ fig : social].(a ) .",
    "arthur is an articulation vertex in @xmath15 and he is responsible from all inter - communications among three ( biconnected ) components as shown in figure  [ fig : social].(b ) .",
    "let @xmath21 and @xmath22 be two vertices which lie in different components . for all such @xmath41 pairs , the pair dependency of arthur is @xmath63 . since shattering the graph at arthur removes all @xmath64 paths , one needs to keep some information to correctly update the bc scores of the vertices inside each component , and this can be achieved creating local copies of arthur in each component .",
    "in addition to shattering a graph @xmath15 into pieces , we investigated three compression techniques using degree-1 vertices , side vertices , and identical vertices .",
    "these vertices have special properties : all degree-1 and side vertices always have a zero bc score since they can not be on a shortest path unless they are one of the endpoints .",
    "furthermore , @xmath65}$ ] is equal to @xmath45}$ ] for two identical vertices @xmath24 and @xmath17 . by using these observations",
    ", we will formally analyze the proposed shattering and compression techniques and provide formulas to compute the bc scores correctly .",
    "we apply our techniques in a preprocessing phase as follows : let @xmath66 be the initial graph , and @xmath67 be the graph after the @xmath68th shattering / compression operation . without loss of generality , we assume that the initial graph @xmath15 is connected .",
    "the @xmath69th operation modifies a single connected component of @xmath67 and generates @xmath70 .",
    "the preprocessing phase then checks if @xmath70 is amenable to further modification , and if this is the case , it continues .",
    "otherwise , it terminates and the final bc computation begins .      to correctly compute the bc scores after shattering a graph , we assign a @xmath71 attribute to each vertex .",
    "let @xmath10 .",
    "let @xmath72 be a vertex in the shattered graph @xmath73 and @xmath74 be its component .",
    "then @xmath75}$ ] is the number of vertices of @xmath15 which are represented by @xmath72 in @xmath74 .",
    "for instance in figure  [ fig : social].(b ) , @xmath76}$ ] is 6 since amy , john , may , sue , jack , and arthur have the same shortest path graphs in the right component . at the beginning",
    ", we set @xmath77 } = 1 $ ] for all @xmath14 .",
    "let @xmath78 be an articulation vertex detected in a connected component @xmath79 after the @xmath68th operation of the preprocessing phase .",
    "we first shatter @xmath80 into @xmath7 ( connected ) components @xmath81 for @xmath82 by removing @xmath78 from @xmath67 and adding a local copy @xmath83 of @xmath78 to each component by connecting it to the same vertices @xmath24 was connected .",
    "the @xmath71 values for each local copy is set as @xmath84 } = \\sum_{v ' \\in c \\setminus c_i}{{{\\tt reach}[v ' ] } } \\label{eq : art : update}\\ ] ] for @xmath82 .",
    "we will use @xmath85 to denote the mapping from @xmath86 to @xmath11 , which maps a local copy @xmath87 to the corresponding original copy in @xmath11 .    for each component @xmath80 , formed at any time of the preprocessing phase ,",
    "a vertex @xmath37 has exactly one _ representative _ @xmath88 such that @xmath89}$ ] is incremented by one due to @xmath21 .",
    "this vertex is denoted as @xmath90 .",
    "note that each copy is a representative of its original . and",
    "if @xmath91 and @xmath92 is another vertex in @xmath80 then @xmath93 is on all @xmath94 paths in @xmath15 .",
    "@xmath95 } \\leftarrow 0 , \\forall v \\in v'$ ]    algorithm  [ algo : bcwg ] computes the bc scores of the vertices in a shattered graph .",
    "note that the only difference w.r.t .",
    "@xmath96 are lines  [ ln : middle ] and  [ ln : source ] . furthermore , if @xmath77 } = 1 $ ] for all @xmath14 the algorithms are equivalent .",
    "hence the worst case complexity of @xmath97 is also @xmath46 for a graph with @xmath2 vertices and @xmath5 edges .",
    "let @xmath10 be the initial graph with @xmath2 vertices and @xmath98 be the shattered graph after preprocessing .",
    "let @xmath99 and @xmath100 be the bc scores computed by @xmath101 and @xmath102 , respectively .",
    "we will prove that @xmath43 } = \\sum_{v ' \\in v ' | { \\bf org}(v ' ) = v}{\\tt bc}'[v ' ] , \\label{eq : toprove}\\ ] ] when the graph is shattered at articulation vertices .",
    "that is , @xmath45}$ ] is distributed to @xmath103}$]s where @xmath72 is an arbitrary copy of @xmath17 .",
    "let us start with two lemmas .",
    "[ lem : one ] let @xmath104 be vertices such that all @xmath105 paths contain @xmath24 .",
    "then , @xmath106    for any target vertex @xmath22 ,",
    "if @xmath39 is positive then @xmath107 since all @xmath64 paths are passing through @xmath24 .",
    "according to  , @xmath108 .",
    "[ lem : two ] for any vertex pair @xmath109 , there exists exactly one component @xmath80 of @xmath73 which contains a copy of @xmath22 which is not the same vertex as the representative of @xmath21 in @xmath80 .",
    "given @xmath109 , the statement is true for the initial ( connected ) graph @xmath15 since it contains one copy of each vertex .",
    "assume that it is also true after @xmath68th shattering and let @xmath80 be this component .",
    "when @xmath80 is further shattered via @xmath22 s copy , all but one newly formed ( sub)components contains a copy of @xmath22 as the representative of @xmath21 . for the remaining component @xmath74 , @xmath110 which is not a copy of @xmath22 .    for all components other than @xmath80 , which contain a copy @xmath111 of @xmath22 , the representative of @xmath21",
    "is @xmath111 by the inductive assumption .",
    "when such components are further shattered , the representative of @xmath21 will be again a copy of @xmath22 . hence the statement is true for @xmath112 , and by induction , also for @xmath73 .",
    "[ thm : art ] eq .  [ eq : toprove ] is correct after shattering @xmath15 with articulation vertices .",
    "let @xmath80 be a component of @xmath73 , @xmath113 be two vertices in @xmath80 , and @xmath114 be the corresponding original vertices in @xmath11 , respectively . note that @xmath75 } - 1 $ ] is the number of vertices @xmath115 such that @xmath22 does not have a copy in @xmath80 and @xmath17 lies on all @xmath23 paths in @xmath15 .",
    "for all such vertices , @xmath116 , and the total dependency of @xmath72 to all such @xmath22 is @xmath75 } - 1 $ ] . when the bfs is started from @xmath117 , line  [ ln : middle ] of @xmath97 initiates @xmath118}$ ] with this value and computes the final @xmath118 } = \\delta_{s'}(v')$ ] .",
    "this is exactly the same dependency @xmath119 computed by @xmath96 .",
    "let @xmath80 be a component of @xmath73 , @xmath78 and @xmath72 be two vertices in @xmath80 , and @xmath120 , @xmath121 . according to the above paragraph , , @xmath122 where @xmath123 and @xmath124 are the dependencies computed by @xmath96 and @xmath97 , respectively .",
    "let @xmath37 be a vertex , s.t .",
    "@xmath125 . according to lemma  [ lem : one ] , @xmath126 .",
    "since there are @xmath89}$ ] vertices represented by @xmath78 in @xmath80 , the contribution of the bfs from @xmath78 to the bc score of @xmath72 is @xmath89 } \\times \\delta_{u'}(v')$ ] as shown in line  [ ln : source ] of @xmath97 . furthermore , according to lemma  [ lem : two ] , @xmath127 will be added to exactly one copy @xmath72 of @xmath17 .",
    "hence ,   is correct .",
    "although the existence of a bridge implies the existence of an articulation vertex , handling bridges are easier and only requires the removal of the bridge .",
    "we embed this operation to the preprocessing phase as follows : let @xmath67 be the shattered graph obtained after @xmath68 operations , and let @xmath128 be a bridge in a component @xmath80 of @xmath67 .",
    "hence , @xmath78 and @xmath72 are both articulation vertices .",
    "let @xmath129 and @xmath121 .",
    "a bridge removal operation is similar to a shattering via an articulation vertex , however , no new copies of @xmath24 or @xmath17 are created .",
    "instead , we let @xmath78 and @xmath72 act as a copy of @xmath17 and @xmath24 .",
    "let @xmath130 and @xmath131 be the components formed after removing edge @xmath128 which contain @xmath78 and @xmath72 , respectively . similar to  ,",
    "we add @xmath132}}\\notag \\mbox{\\ \\ \\ \\ and\\ \\ \\ \\ } \\sum_{w    \\in c_u}{{{\\tt reach}[w]}}\\label{eq : bri : update}\\ ] ] to @xmath89}$ ] and @xmath75}$ ] , respectively , to make @xmath78  ( @xmath72 ) as the representative of all vertices in @xmath130  ( @xmath131 ) . after removing the bridge and updating the @xmath71 array , lemma  [ lem : two ] is not true : there can not be a component which contain a representative of @xmath24  ( @xmath17 ) and a copy of @xmath17  ( @xmath24 ) anymore .",
    "hence , @xmath133 and @xmath123 will not be added to any copy of @xmath24 and @xmath17 , respectively , by @xmath97 . to alleviate this , we add @xmath134}}\\right )",
    "- 1\\right)\\sum_{w \\in c_v}{{{\\tt reach}[w]}}\\notag,\\\\ \\delta_{u'}(v ' ) & = \\left(\\left(\\sum_{w \\in c_v}{{{\\tt reach}[w]}}\\right ) - 1\\right)\\sum_{w \\in c_u}{{{\\tt reach}[w]}}\\notag\\end{aligned}\\ ] ] to @xmath135 $ ] and @xmath136 $ ] , respectively .",
    "note that lemma  [ lem : two ] is true for all other vertex pairs .",
    "[ eq : toprove ] is correct after shattering @xmath15 with articulation vertices and bridges .",
    "although , the compression techniques do not reduce the number of connected components , they reduce the number of vertices and edges in a graph .",
    "since the complexity of brandes algorithm is @xmath46 , a reduction on @xmath5 and/or @xmath2 will help to reduce the execution time of the algorithm .",
    "let @xmath67 be the graph after @xmath68 shattering operations , and let @xmath88 be a degree-1 vertex in a component @xmath80 of @xmath67 which is only connected to @xmath72 . removing a degree-1 vertex from a graph is the same as removing the bridge @xmath128 from @xmath67 . but this time , we reduce the number of vertices and the graph is compressed . hence , we handle this case separately and set @xmath137 .",
    "the updates are the same with the bridge removal .",
    "that is , we add @xmath89}$ ] to @xmath75}$ ] and increase @xmath135 $ ] and @xmath136 $ ] , respectively , with @xmath138 } - 1\\right)\\sum_{w \\in c   \\setminus \\{u'\\}}{{{\\tt reach}[w]}},\\notag\\\\ \\delta_{u'}(v ' ) & = \\left(\\left(\\sum_{w \\in c   \\setminus \\{u'\\}}{{{\\tt reach}[w]}}\\right ) - 1\\right ) { { \\tt reach}[u']}.\\notag\\end{aligned}\\ ] ]    eq",
    ".  [ eq : toprove ] is correct after shattering @xmath15 with articulation vertices and bridges , and compressing it with degree-1 vertices .",
    "let @xmath67 be the graph after @xmath68 shattering and compression operations , and let @xmath78 be a side vertex in a component @xmath80 of @xmath67 . since @xmath139 is a clique , there is no shortest path passing through @xmath78 .",
    "that is , @xmath78 is always on the sideways .",
    "hence , we can remove @xmath78 from @xmath67 by only compensating the effect of the shortest @xmath140 paths where @xmath78 is either @xmath117 or @xmath111 . to alleviate this ,",
    "we initiate a bfs from @xmath78 as given in algorithm  [ alg : bcalgside ] , which is similar to the ones in @xmath97 . the only difference between @xmath141 and a bfs of @xmath97",
    "is an additional line  [ ln : bcadd ] .",
    "@xmath142 @xmath143 } \\leftarrow { { \\tt reach}[v ] } - 1 , \\forall v \\in v_\\ell$ ] [ alg : bcalgside ]    removing @xmath78 affects three types of dependencies :    1 .",
    "let @xmath37 be a vertex s.t .",
    "@xmath91 and let @xmath72 be a vertex in @xmath80 where @xmath121 .",
    "due to lemma  [ lem : two ] , when we remove @xmath78 from @xmath80 , @xmath144 can not be added anymore to any copy of @xmath17 .",
    "line  [ ln : bcaddorg ] of @xmath141 solves this problem and adds the necessary values to @xmath145 .",
    "2 .   let @xmath37 be a vertex s.t .",
    "if we remove @xmath78 from @xmath80 , due to lemma  [ lem : two ] , @xmath147 will not be added to any copy of @xmath24 . since",
    ", @xmath78 is a side vertex , @xmath148 } - 1 $ ] .",
    "since there are @xmath149}}$ ] vertices which are represented by a vertex in @xmath150 , we add @xmath151 } - 1)\\sum_{v ' \\in c - u'}{{{\\tt reach}[v']}}\\ ] ] to @xmath152 $ ] after removing @xmath78 from @xmath80 .",
    "3 .   let @xmath153 be two vertices in @xmath80 different than @xmath78 , and @xmath154 be the corresponding original vertices .",
    "although both vertices will keep existing in @xmath150 , since @xmath78 will be removed , @xmath155 will be @xmath89}\\times \\delta_{v'u'}(w')$ ] less than it should be .",
    "for all such @xmath72 , the aggregated dependency will be @xmath156 } - 1),\\ ] ] since none of the @xmath157 } - 1 $ ] vertices represented by @xmath158 lies on a @xmath159 path and @xmath160 .",
    "the same dependency appears for all vertices represented by @xmath78 .",
    "line  [ ln : bcadd ] of @xmath141 takes into account all these dependencies .",
    ".  [ eq : toprove ] is correct after shattering @xmath15 with articulation vertices and bridges , and compressing it with degree-1 and side vertices .      when two vertices in @xmath15 are identical , all of their pair dependencies , source dependencies , and bc scores are the same .",
    "hence , it is possible to combine these vertices and avoid extra computation .",
    "we distinguish 2 different types of identical vertices .",
    "vertices @xmath24 and @xmath17 are type - i identical if and only if @xmath161 .",
    "vertices @xmath24 and @xmath17 are type - ii identical if and only if @xmath162 .    to handle this , we assign @xmath163 attribute to each vertex .",
    "@xmath164 denotes the number of vertices in @xmath15 that are identical to @xmath72 in @xmath73 .",
    "initially , @xmath165}$ ] is set to @xmath63 for all @xmath14 .",
    "let @xmath166 be a set of identical vertices .",
    "we remove all vertices @xmath167 from @xmath15 except one of them .",
    "let @xmath72 be this remaining vertex .",
    "we increase @xmath165}$ ] by @xmath168 , and keep a list of @xmath169 s associated with @xmath72 .",
    "when constructing the bfs graph , the number of paths @xmath170}$ ] is updated incorrectly for an edge @xmath171 when @xmath17 is not the source .",
    "the edge leads to @xmath172}$ ] paths : @xmath170 } \\leftarrow { { \\sigma}[w ] } + ( { { \\sigma}[v ] } * { { \\tt ident}[v]})$ ] if @xmath173 .",
    "the propagation of the dependencies @xmath174}$ ] along the edge @xmath171 should be accounted multiple times as in @xmath143 } \\leftarrow { { \\delta}[v ] } + \\frac { { { \\sigma}[v ] } } { { { \\sigma}[w ] } } { { \\tt ident}[w ] } ( { { \\delta}[w ] } + 1)$ ] .    finally , for a given source @xmath21 , there are @xmath175}$ ] similar shortest path graphs , and the accumulation of the bc value is @xmath176 } \\leftarrow { { \\tt bc}'[w ] } + { { \\tt ident}[s ] } { { \\delta}[w]}$ ]",
    ".    the only path that are ignored in this computation of bc are the paths between @xmath177 and @xmath178 .",
    "if @xmath179 is a type - ii identical set , then this path are direct and the computation of bc is correct .",
    "however , if @xmath179 is a type - i identical set , these paths have some impact .",
    "fortunately , it only impacts the direct neighboor of @xmath179 .",
    "there are exactly @xmath180 paths whose impact is equally distributed among the neighbors of @xmath179 .",
    "the technique presented in this section has been presented without taking @xmath71 into account .",
    "both techniques can be applied simultaneously but the details are not presented here due to space limitation .",
    "[ eq : toprove ] is correct after shattering @xmath15 with articulation vertices and bridges , and compressing it with degree-1 , side , and identical vertices .",
    "there exist linear time algorithms for detecting articulation vertices and bridges  @xcite . in our implementation of the preprocessing phase , after detecting all articulation vertices with  @xcite , the graph is decomposed into its biconnected components at once .",
    "note that the final decomposition is the same when the graph is iteratively shattered one articulation point at a time as described above .",
    "but decomposing the graph into its biconnected components is much faster .",
    "a similar approach works for bridges and removes all of them at once .",
    "since the detection algorithms are linear time , each cumulative shattering operation takes @xmath181 time .    for compression techniques ,",
    "detecting recursively all degree-1 vertices takes @xmath62 time . detecting identical vertices",
    "is expected to take a linear time provided a good hash function to compute the hash of the neighborhood of each vertex . in our implementation , for all @xmath182 , we use @xmath183 . upon collision of hash values ,",
    "the neighborhood of the two vertices are explicitly compared .    to detect side vertices of degree @xmath7",
    ", we use a simple algorithm which for each vertex @xmath17 of degree @xmath7 , verifies if the graph induced by @xmath184 is a clique . in practice ,",
    "our implementation does not search for cliques of more than @xmath185 vertices since our preliminary experiments show that searching these cliques is expensive .",
    "similar to shattering , after detecting all vertices from a certain type , we apply a cumulative compression operation to remove all the detected vertices at once .     and @xmath186 are identical vertices with neighbors @xmath187 . when one of the identical vertices is removed , the remaining one is an articulation point .",
    ", scaledwidth=50.0% ]    the preprocessing phase is implemented as a loop where a single iteration consecutively tries to shatter / compress the graph by using the above mentioned five operations .",
    "the loop continues as long as improvement are made .",
    "indeed , a single iteration of this loop may not be sufficient since each operation can make the graph amenable to another one .",
    "for example , in our toy graph given in figure  [ fig : social].(a ) , removing the degree-1 vertex martin makes wayne and henry identical . furthermore , when diana is also removed as a side vertex , henry and wayne both become side vertices . or as figure  [ fig : idvart ] shows , removing identical vertices can form an articulation vertex .",
    "we implemented the original and modified bc algorithms , and the proposed optimization techniques in c++ .",
    "the code is compiled with icc v12.0 and optimization flags -o2 -dndebug .",
    "the graph is kept in memory in the compressed row storage  ( crs ) format using @xmath188-bit data types .",
    "the experiments are run on a node with two intel xeon e@xmath189 cpu clocked at @xmath190ghz and equipped with @xmath191 gb of main memory . despite the machine is equipped with @xmath186 cores , all the experiments are run sequentially .    for the experiments , we used @xmath192 real - life networks from the dataset of dimacs graph partitioning and graph clustering challenge .",
    "the graphs and their properties are summarized in table  [ tab : graph_prop ] .",
    "they are classified into four categories .",
    "the first one , _ social _ , contains @xmath193 social networks .",
    "the second one , _ structural _ , contains @xmath194 structural engineering graphs .",
    "the third one , _ geographical _ , contains @xmath185 redistricting graphs and one road graph .",
    "the last one , _ misc _ , contains graphs from various applications such as autonomous systems , protein - protein interaction , and power grids .",
    "application & name & # vertices & # edges & org .",
    "& best +   + social & condmat & 16,726 & 47,594 & 21.1 & 9.1 + & condmat03 & 27,519 & 116,181 & 102.0 & 52.3 + & hep - th & 8,361 & 15,751 & 3.2 & 1.6 + & condmat05 & 40,421 & 175,691 & 209.0 & 107.0 + & pgpgiant & 10,680 & 24,316 & 10.7 & 3.7 + & astro - ph & 16,706 & 121,251 & 40.3 & 22.2 +   + auto & bcsstk29 & 13,992 & 302,748 & 68.3 & 26.4 + & bcsstk30 & 28,924 & 1,007,284 & 399.0 & 41.4 + & bcsstk31 & 35,588 & 572,914 & 363.0 & 106.0 + & bcsstk32 & 44,609 & 985,046 & 737.0 & 77.3 + & bcsstk33 & 8,738 & 291,583 & 37.0 & 11.1 +   + redistricting & ak2010 & 45,292 & 108,549 & 178.0 & 114.0 + & ct2010 & 67,578 & 168,176 & 514.0 & 369.0 + & de2010 & 24,115 & 58,028 & 61.4 & 40.6 + & hi2010 & 25,016 & 62,063 & 18.4 & 12.9 + road & luxembourg & 114,599 & 119,666 & 632.0 & 390.0 +",
    "+ router & as-22july06 & 22,963 & 48,436 & 39.9 & 15.5 + power & power & 4,941 & 6,594 & 1.3 & 0.7 + biology & protint & 9,673 & 37,081 & 11.2 & 8.1 + semi- & add32 & 4,960 & 9,462 & 1.4 & 0.3 + conductor & memplus & 17,758 & 54,196 & 17.6 & 11.2 + & 47.4 & 19.6 +      as most of the graph - based kernels in data mining , the order of the vertices and edges accessed by brandes algorithm is important . in today",
    "s hardware , cache is one of the fastest and one of the most scarce resources . when the graphs are big , they do not fit in the cache , and the number of cache misses along with the number of memory accesses increases .",
    "if two vertices in a graph are close , a bfs will access them almost at the same time .",
    "hence , if we put close vertices in @xmath15 to close locations in memory , the number of cache misses will probably decrease . following this reasoning",
    ", we initiated a bfs from a random vertex in @xmath15 and use the queue order of the vertices as their ordering in @xmath15 .",
    "further benefits of bfs ordering on the execution time of a graph - based kernel are explained in  @xcite .",
    "for each graph in our set , figure  [ fig : bfs_ord ] shows the time taken by both the bfs ordering and @xmath96 relative to the original @xmath96 execution time with the natural vertex ordering . for @xmath195 of @xmath192 matrices using a bfs ordering improved the performance .",
    "overall , it reduced the time to approximately @xmath196 of the original time on average . hence compared with bfs ordering , the natural order of a real - life network has usually a detrimental effect on the execution time of bc .      for each graph",
    ", we tested @xmath197 different combinations of the improvements proposed in this paper : they are denoted with * o * , * od * , * odb * , * odba * , * odbas * , * odbai * , and * odbasi * , where * o * denotes the bfs * o*rdering , * d * denotes * d*egree-1 vertices , * b * denotes * b*ridge , * a * denotes * a*rticulation vertices , * s * denotes * s*ide vertices , and * i * denotes * i*dentical vertices .",
    "the ordering of the letters denotes the order of application of the respective improvements .",
    "given a graph @xmath15 , we measure the time spent for preprocessing @xmath15 by a combination to obtain @xmath73 , computing the bc scores of the vertices in @xmath73 , and using these scores computing the bc scores of the vertices in @xmath15 .",
    "for each category , we have two kind of plots : the first plot shows the numbers of edges in each component of @xmath73 .",
    "different components of @xmath73 are represented by different colors .",
    "the second plot shows the normalized execution times for all @xmath197 combinations .",
    "the times for the second chart are normalized w.r.t . the first combination : the time spent by @xmath96 after a bfs ordering .",
    "for each graph in the category , each plot has @xmath197 stacked bars representing a different combination in the order described above .",
    "as figure  [ fig : allgraph ] shows , there is a direct correlation between the remaining edges in @xmath73 and the execution time .",
    "this proves that our rationale behind investigating shattering and compression techniques is valid . however , the figures on the left show that these graphs do not contain good articulation vertices and bridges which shatter a graph approximately half .",
    "since , red is almost always the dominating color , we can argue that such vertices and edges do not exist in real life graphs .    for _ social _ graphs ,",
    "each added shattering and compression technique provides a significant improvement for almost all of the cases .",
    "that is , the best combination is * odbasi * for @xmath194 out of @xmath193 graphs , and the normalized execution time is continuously decreasing when a combination is enhanced with a new technique .",
    "according to the original and best execution times in table  [ tab : graph_prop ] , for _ social _ graphs , the techniques , including ordering , provide @xmath198 improvement in total . for _ structural _ graphs , although the only working technique is identical vertices , the improvement is of @xmath199 on the average . for the redistricting graphs in _",
    "geographical _ , the techniques are not very useful . however , with the help of bfs ordering , we obtain @xmath200 improvement on average . for the graph _ luxembourg _ , degree-1 and bridge removal techniques have the most significant impact .",
    "since the graph is obtained from a road network , this is expected  ( roads have bridges ) .",
    "hence , if the structure of the graph is known to some extent , the techniques can be specialized .",
    "for example , it is a well known fact that biological networks usually have a lot of degree-1 vertices but a few articulation vertex .",
    "and our results on the graph _ protint _ confirms this fact since the only significant improvement is obtained with the combination * od*. in our experiments , the most interesting graph is _",
    "add32 _ since the combinations * odbas * and * odbasi * completely shatters it .",
    "note that on the left , there is no bar since there is no remaining edge in @xmath73 and on the right , all the bar is blue which is the color of preprocessing .",
    "when all techniques are combined , we obtain a @xmath201 improvement on average over all graphs .",
    "please note that the implementation uses @xmath185 different kernels depending on whether @xmath71 and @xmath163 are used .",
    "each new attribute brings an increase in runtime which can be seen on _",
    "condmat03 _ when going from * o * to * od * and on _ luxembourg _ when going from * odba * to * odbai*.    the combinations are compared with each other using a performance profile graph presented in figure  [ fig : perf_profile ] .",
    "a point @xmath202 in the profile means that with @xmath203 probability , the time of the corresponding combination on a graph @xmath15 is at most @xmath204 times worse than the best time obtained for that @xmath15 .",
    "hence , the closer to the y - axis is the better .",
    "not using graph shattering techniques ( * o * ) has the worse performance profile .",
    "it is never optimal .",
    "according to the graph , using all possible techniques is the best idea .",
    "this strategy is the optimal one with more than @xmath205 probability .",
    "clearly , one always wants to use graph shattering techniques .",
    "if little information is available * odbasi * should be the default choice . however , if one believes that identical vertices will barely appear in the graph , then * odbas * might lead to better performances .",
    "betweenness is a very popular centrality metric in practice and proved to be successful in many fields such as graph mining .",
    "but , computing bc scores of the vertices in a graph is a time consuming task . in this work ,",
    "we investigate shattering and compression of networks to reduce the execution time of bc computations .",
    "the shattering techniques break graphs into smaller components while keeping the information to recompute the pair and source dependencies which are the building blocks of bc scores . on the other hand , the compression techniques do not change the number of components but reduces the number of vertices and/or edges . an experimental evaluation with various networks",
    "shows that the proposed techniques are highly effective in practice and they can be a great arsenal to reduce the execution time while computing bc scores .",
    "we also noticed that the natural order of a real - life network has usually a detrimental effect on the execution time of bc . in our experiments , even with a simple and cheap bfs ordering , we managed to obtain @xmath206 improvement on average .",
    "unfortunately , we are aware of several works , which do not even consider a simple ordering while tackling a graph - based computation .",
    "so one rule of thumb : `` order your graphs '' .    as a future work",
    ", we are planning to extend our techniques to other centrality measures such as closeness and group - betweenness .",
    "some of our techniques can readily be extended for weighted and directed graphs , but for some , a complete modification may be required .",
    "we will investigate these modifications .",
    "in addition , we are planning to adapt our techniques for parallel and/or approximate bc computations .",
    "s.  jin , z.  huang , y.  chen , d.  chavarria - miranda , j.  feo , and p.  c. wong , `` a novel application of parallel betweenness centrality to power grid contingency analysis , '' in _",
    "ipdps10 _ , april 2010 , pp .",
    "1 7 .",
    "a.  lugowski , d.  alber , a.  bulu , j.  gilbert , s.  reinhardt , y.  teng , and a.  waranis , `` a flexible open - source toolbox for scalable complex graph analysis , '' in _ siam conference on data mining ( sdm ) _ , 2012 .",
    "k.  madduri , d.  ediger , k.  jiang , d.  a. bader , and d.  g. chavarria - miranda , `` a faster parallel algorithm and efficient multithreaded implementations for evaluating betweenness centrality on massive datasets , '' in _ ipdps09 _ , 2009 .",
    "y.  jia , v.  lu , j.  hoberock , m.  garland , and j.  c. hart , `` edge vs. node parallelism for graph centrality metrics , '' in _ gpu computing gems : jade edition _ ,",
    "w. hwu , ed.1em plus 0.5em minus 0.4emmorgan kaufmann , 2011 , pp ."
  ],
  "abstract_text": [
    "<S> who is more important in a network ? who controls the flow between the nodes or whose contribution is significant for connections ? </S>",
    "<S> centrality metrics play an important role while answering these questions . </S>",
    "<S> the betweenness metric is useful for network analysis and implemented in various tools . </S>",
    "<S> since it is one of the most computationally expensive kernels in graph mining , several techniques have been proposed for fast computation of betweenness centrality . in this work , </S>",
    "<S> we propose and investigate techniques which compress a network and shatter it into pieces so that the rest of the computation can be handled independently for each piece . </S>",
    "<S> although we designed and tuned the shattering process for betweenness , it can be adapted for other centrality metrics in a straightforward manner . </S>",
    "<S> experimental results show that the proposed techniques can be a great arsenal to reduce the centrality computation time for various types of networks . + </S>",
    "<S> * keywords : * betweenness centrality ; network analysis ; graph mining ; connected components    ( previously submitted to icdm on june 18 , 2012 ) </S>"
  ]
}