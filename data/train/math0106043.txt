{
  "article_text": [
    "let @xmath0 be a @xmath6-polytope , i.e. , a @xmath6-dimensional bounded convex polyhedron .",
    "it is well - known that the set @xmath9 of its faces ( including  @xmath10 and  @xmath0 itself ) , ordered by inclusion , is a graded , atomic , and coatomic lattice : the _ face lattice _ of @xmath0 . in particular ,",
    "each face can be identified with its set of vertices or the set of facets it is contained in . in this paper , a face is usually identified with its vertex set .",
    "we define @xmath11 and denote by @xmath12 the hasse diagram ( as an abstract graph ) of the face lattice .",
    "hence , @xmath12 is a directed rooted acyclic graph whose nodes correspond to the elements of @xmath9 .",
    "if @xmath13 are nodes in @xmath12 and @xmath14 are the corresponding faces of  @xmath0 , then there is an arc  @xmath15 in @xmath12 if and only if @xmath16 and @xmath17 .",
    "the _ combinatorial face lattice enumeration problem _ is the following : given a vertex - facet incidence matrix of @xmath0 ( see section  [ sec : algo ] for a definition ) , construct the hasse diagram @xmath12 of the face lattice . by definition",
    ", @xmath12 is unlabeled .",
    "nevertheless , it might be desired to label each node of @xmath12 corresponding to a face  @xmath18 with the set of ( indices of ) vertices contained in  @xmath18 , the set of ( indices of ) facets containing  @xmath18 , or with the dimension of  @xmath18 .",
    "fukuda and rosta @xcite gave an algorithm for the combinatorial face lattice enumeration problem for @xmath6-polytopes  @xmath0 which runs in  @xmath19 time , where @xmath3 is the number of facets and @xmath2 is the number of vertices of  @xmath0 .",
    "since @xmath5 can be exponential in @xmath2 and @xmath3 ( consider the @xmath6-simplex , for instance ) it is desirable to have an algorithm whose running time depends only linearly on  @xmath5 ( and polynomially on  @xmath2 and  @xmath3 ) .",
    "the main result of this paper is such an algorithm .    for the _ geometric face lattice enumeration problem _ , which asks for the face lattice of a polytope that is given by an inequality description , there are algorithms satisfying this requirement on the running time , e.g. , by fukuda , liebling , and margot  @xcite",
    "however , in our context no geometric data are available .    ganter  @xcite described an algorithm which , given the incidences of atoms and coatoms of a general atomic and coatomic lattice , enumerates all elements of the lattice in lexicographic order , where each element is identified with the set of atoms below it ( which are ordered arbitrarily ) .",
    "specialized to our situation , one obtains an algorithm that computes all vertex sets of faces of  @xmath0 in @xmath20 steps , where @xmath4 is the number of vertex - facet incidences of  @xmath0 .",
    "note that @xmath21 , in particular , @xmath4 is bounded polynomially in  @xmath2 and  @xmath3 .",
    "this algorithm , however , does not compute the inclusion relations between the faces , i.e. , the edges of the hasse diagram of the face lattice .",
    "of course , once all ( vertex sets of ) faces are computed , one may construct the hasse diagram in an obvious way afterwards , but this would require a number of steps which is quadratic in the total number  @xmath5 of faces .",
    "inspired by ganter s algorithm , we developed the ( quite different ) algorithm presented below , which computes the entire hasse diagram in the same running time of @xmath22 , see theorem  [ thm : alg1 ] .",
    "it requires @xmath23 memory ( without output storage ) . in our algorithm ,",
    "the vertex set of each face or the set of facets it is contained in , as well as its dimension , is readily available ( or can be computed without increasing the asymptotic running time ) .",
    "of course , this may increase the ( output ) storage requirements significantly .",
    "fukuda and rosta  @xcite also considered the combinatorial face lattice enumeration problem for the special case of simple or simplicial polytopes .",
    "they presented an algorithm that computes the face lattice of a simple polytope in @xmath24 steps , provided that in addition to the vertex - facet incidences an acyclic orientation of the graph of the polytope is given that induces precisely one sink on every non - empty face .",
    "such an orientation is called a _ good orientation _ or an _ abstract objective function orientation_. unfortunately , no polynomial time algorithm is known that computes a good orientation of a simple polytope  @xmath0  neither if  @xmath0 is given by its vertex - facet incidences nor if it is specified by its whole face lattice .    for simple or simplicial polytopes , our algorithm can be specialized such that it computes the hasse diagram of the face lattice in @xmath25 steps from the vertex - facet incidences , where no good orientation is required ( see section  [ subsec : simp ] ) .",
    "in section [ subsec : skel ] we give a rough sketch of the algorithm , which is followed by a more detailed description in sections  [ subsec : clos ] , [ subsec : min ] , and [ subsec : locate ] . in section [ subsec : analysis ] we analyze the algorithm .",
    "we present the specialization of the algorithm for simple or simplicial polytopes in section  [ subsec : simp ] and a variant that computes the @xmath26-skeleton in section  [ subsec : kskel ] .",
    "furthermore , in section  [ subsec : hasse ] a version that needs significantly less memory is described which enumerates just the faces together with their dimensions ( i.e. , without the edges of the hasse diagram ) . finally , a modification that computes the face lattice of an oriented matroid from its cocircuits ( section  [ subsec : om ] ) is explained .",
    "for the basic properties of polytopes that are important in our context , we refer to ziegler s book  @xcite .",
    "the few concepts from the theory of algorithms and data structures that play a role in the paper can be found in any corresponding textbook ( e.g. in the one by cormen , leiserson , rivest , and stein  @xcite ) .",
    "our running time estimates refer to the uniform time measure ( i.e. , every arithmetic operation / comparison takes one unit of time ) , while our statements on memory requirements refer to the bit model .",
    "define @xmath3 to be the number of facets and @xmath2 the number of vertices of the @xmath6-polytope  @xmath0 .",
    "let @xmath27 be a _",
    "vertex - facet incidence matrix _ of  @xmath0 .",
    "hence the facets of  @xmath0 can be identified with @xmath28 and its vertices can be identified with @xmath29 , such that @xmath30 if facet  @xmath31 contains vertex @xmath32 , and @xmath33 otherwise .",
    "denote by @xmath4 the number of vertex - facet incidences , i.e. , the number of ones in @xmath34 . for @xmath35 , define @xmath36 for all @xmath37 , the set of facets containing all vertices of @xmath38 . for @xmath39 , define @xmath40 for all @xmath41 , the set of vertices contained in all facets of @xmath42 .    for @xmath35",
    ", the set @xmath43 is the ( vertex set of ) the smallest face of @xmath0 containing @xmath38 ( in lattice theoretic terms , the _",
    "join _ of the elements in  @xmath38 ) .",
    "one can check easily that this defines a _ closure map _ on the subsets of  @xmath44 , i.e. , for all @xmath45 we have : @xmath46 the faces of @xmath0 correspond exactly to the _ closed sets _ of @xmath44 with respect to this closure map ( i.e. , sets @xmath47 with @xmath48 ) .",
    "our algorithm crucially relies on the fact that closures can be computed fast ( see section  [ subsec : clos ] ) .      the strategy is to build up the hasse diagram  @xmath12 of the face lattice from bottom ( @xmath10 ) to top ( @xmath0 ) .",
    "consequently , @xmath12 is initialized with the single face  @xmath10 and then enlarged iteratively by adding out - neighbors of nodes that have already been constructed .",
    "we will say that a face has been _ seen _ , once its corresponding node in  @xmath12 has been constructed .    during the algorithm ,",
    "we keep a set @xmath49 containing those faces that we have seen so far , but for which we have not yet inserted their out - arcs into the hasse diagram . at each major step",
    ", we remove a face @xmath50 from the set  @xmath49 and construct the set  @xmath51 of all faces @xmath52 with @xmath53 and @xmath54 . for each face",
    "@xmath55 we check whether it has already been seen .",
    "if this is not the case , then a new node in  @xmath12 representing  @xmath52 is constructed , and  @xmath52 is added to  @xmath49 . in any case , an arc from the node corresponding to  @xmath50 to the node corresponding to  @xmath52 is inserted into  @xmath12 .    in order to compute the set  @xmath51 , we exploit the fact that  @xmath51 consists of the inclusion minimal faces among the ones that properly contain  @xmath50 .",
    "since the face lattice of a polytope is atomic , each face @xmath55 must be of the form @xmath56 for some vertex ( atom )  @xmath32 ; in particular , the hasse diagram has at most @xmath57 arcs .",
    "thus , we first construct the collection  @xmath58 of all sets @xmath59 , @xmath60 , and then compute  @xmath51 as the set of inclusion minimal sets of  @xmath58 .",
    "computing @xmath59 for some @xmath61 requires determining a closure . in section  [ subsec : clos ] , we describe a method to perform this task in @xmath62 steps . determining the inclusion minimal sets in the collection  @xmath58 clearly could be done in @xmath63 steps by pairwise comparisons , since @xmath58 has at most @xmath2 elements , each of size at most  @xmath2 . in section  [ subsec : min ] we show that this can even be performed in @xmath64 time .",
    "another crucial ingredient is a data structure , described in section  [ subsec : locate ] , that allows us to locate the node in  @xmath12 representing a given face  @xmath52 or to assert that  @xmath52 has not yet been seen .",
    "this can be performed in @xmath62 steps .",
    "a summary of the analysis of the time complexity of the algorithm , along with a pseudo - code description of it , is given in section  [ subsec : analysis ] .      in order to be able to compute closures fast ,",
    "we store the incidence matrix  @xmath34 in a _ sorted sparse format _ both in a row and column based way . for each vertex @xmath65",
    ", the elements in @xmath66 are stored increasingly in a list .",
    "similarly , for each facet @xmath67 , we store the sorted set @xmath68 in a list .",
    "this preprocessing can be performed in @xmath69 time ( which is dominated by @xmath70 and thus does not influence the estimate of the asymptotic running time in proposition  [ prop : alg1 ] below ) .",
    "the sorted sparse format uses @xmath71 storage .",
    "whenever we want to compute the closure of a set @xmath35 , the first step is to compute @xmath72 , i.e. , the intersection of the lists @xmath73 , @xmath74 .",
    "since the intersection of two sorted lists can be computed in time proportional to the sum of the lengths of the two lists and because the intersection of two lists is at most as long as the shorter one , @xmath72 can be computed in time @xmath75 .",
    "similarly , @xmath76 can be computed in time @xmath62 for a set @xmath39 .",
    "[ lem : clos ] the closure @xmath77 of a set @xmath35 can be computed in @xmath62 steps ( provided that the vertex - facet incidence matrix is given in the sorted sparse format ) .",
    "suppose that @xmath78 is a face of  @xmath0 and  @xmath58 is the collection of all faces @xmath79 , @xmath80 .",
    "our procedure to identify the set  @xmath51 of minimal sets in the collection  @xmath58 starts by assigning a label _ candidate _ to each vertex in @xmath81 .",
    "subsequently , the label _ candidate _ of each vertex will either be removed or replaced by a label _",
    "minimal_. we keep the following three invariants : for each vertex @xmath32 that is labeled _ minimal _ we have @xmath82 ; if two different vertices  @xmath32 and  @xmath83 both are labeled _ minimal _ , then we have @xmath84 ; @xmath51 is contained in the set of all @xmath59 for which @xmath32 is labeled _ minimal _ or _",
    "candidate_. clearly , if no vertex is labeled _ candidate _ anymore , the set of vertices labeled _ minimal _ is in one - to - one correspondence to  @xmath51 via @xmath85 .",
    "suppose there is still some @xmath32 labeled _ candidate _ available .",
    "if @xmath86 contains some vertex  @xmath83 , then we have @xmath87 , because @xmath88 is the intersection of all faces containing  @xmath50 and  @xmath83 , and one of these faces is @xmath59 .",
    "hence , if @xmath83 is labeled _ minimal _ or _ candidate _",
    ", we remove the label _ candidate _ from  @xmath32 ; otherwise we label  @xmath32 _",
    "minimal_.    it follows by induction that the three invariants are satisfied throughout the procedure .",
    "moreover , at each major step ( choosing a _ candidate _",
    "@xmath32 ) the number of _ candidate _ labels decreases by one . since each such step takes @xmath89 time , the entire procedure has complexity @xmath64 .",
    "[ lem : min ] the set  @xmath51 of inclusion minimal sets in  @xmath90 can be identified in @xmath64 steps .      during the algorithm",
    ", we have to keep track of the faces that we have seen so far and their corresponding nodes in  @xmath12 . to this end",
    ", we maintain a special data structure , the _ face tree_. in this data structure , a face ( with @xmath91 ) is represented by the lexicographically smallest set @xmath92 that generates  @xmath38 , i.e. , @xmath93 .",
    "we call  @xmath94 the _ canonical spanning set _ of the face @xmath38 .",
    "the map @xmath95 is one - to - one ; its inverse map is the closure map .",
    "the set @xmath94 can be computed efficiently as follows . for @xmath96",
    "set  @xmath97 . for @xmath98 , @xmath94",
    "is computed iteratively : initialize @xmath94 with the set @xmath99 ; at each iteration extend @xmath94 by the smallest @xmath100 such that @xmath101 . note that @xmath102 . recall that we stored the vertex - facet incidences in the sorted sparse format ( see section  [ subsec : clos ] ) . similarly to the method for computing closures , this computation can be performed in @xmath62 steps , since just the intersections @xmath103 , @xmath104 , have to be computed iteratively .",
    "then , @xmath94 is obtained as the set of those @xmath100 for which the intersection becomes smaller .",
    "we now explain the structure of the face tree .",
    "its arcs are directed away from the root .",
    "they are labeled with vertex numbers , such that no two arcs leaving the same node have the same label and on every directed path in the tree the labels are increasing . via the sets of labels on the paths from the root",
    ", the nodes of the tree correspond to the sorted sets @xmath94 for the faces  @xmath35 that have been seen so far .",
    "in particular , the root node represents the face @xmath10 .",
    "each node has a pointer to the corresponding node of @xmath12 . by construction ,",
    "the depth of the tree is bounded by @xmath105 .",
    "suppose we want to find the node @xmath106 corresponding to some face @xmath47 in the part of  @xmath12 that we have already constructed or to assert that this face has not yet been seen .",
    "we first sort  @xmath38 ( a subset of @xmath107 ) increasingly in  @xmath89 steps ( by counting or bucket sort , see  ( * ? ? ?",
    "8) ) and compute  @xmath94 in @xmath62 steps . then ,",
    "starting from the root , we proceed ( as long as possible ) downwards in the face tree along arcs labeled by the successive elements of @xmath94 .",
    "either we find an existing node in the tree which corresponds to  @xmath38 , or we have to introduce new labeled arcs ( and nodes ) into the tree until we have constructed a node representing  @xmath38 .    in the latter case , it might be necessary to construct an entire new path in the tree .",
    "the definition of the canonical spanning sets @xmath94 ensures that all `` intermediate nodes '' on that path will correspond to canonical spanning sets of faces as well .",
    "hence , the number of nodes in the face tree always will be bounded by  @xmath5 , the total number of faces of the polytope .",
    "the faces represented by intermediate nodes will be seen later in the algorithm .",
    "consequently , the corresponding pointers to  @xmath12 are set to ` nil ` for the meantime . later in the algorithm",
    ", when we are searching for the face represented by such a tree - node for the first time , the ` nil`-pointer will indicate that this face is not yet represented in  @xmath12 .",
    "the ` nil`-pointer is then replaced by a pointer to a newly created node representing the face in  @xmath12 .    in any case , since the face tree has depth at most @xmath105 and the out - degree of each node is at most @xmath2 , we need a total time of @xmath108 to either locate or create the tree - node representing a certain face .    [",
    "lem : locate ] using the face tree , it is possible to locate or create the node in  @xmath12 representing a face in @xmath62 steps ( provided the vertex - facet incidence matrix is stored in the sorted sparse format ) .    in the description given above , we have assumed that for each node in the face tree the out - arcs are stored in a list which is searched linearly for a certain label when walking down the tree .",
    "of course , one can store the set of out - arcs in a balanced search tree ( see , e.g. , ( * ? ? ? * chap .  13 ) ) , allowing to perform the search for a certain label in logarithmic time .",
    "after computing  @xmath94 for a face  @xmath38 ( in @xmath62 time ) , this allows to locate or create the node corresponding to  @xmath38 in the face tree in @xmath109 steps .",
    "the total running time remains @xmath62 ; nevertheless this might speed up the algorithm in practice .    instead of using the face tree , one can also store the faces in a balanced search tree .",
    "again , the faces are represented by their canonical spanning sets , which are ordered lexicographically . once @xmath94 is computed for a face  @xmath38 ,",
    "searching  @xmath38 can be performed in @xmath110 steps ( since @xmath111 ) .",
    "this yields the same total asymptotic running time , but searching the tree takes more ( or the same ) time compared to the variant of the face tree with balanced search trees at its nodes , since @xmath112 .",
    "we summarize the algorithm in pseudo - code ( algorithm  [ algo : enumeration ] ) :    * input : * incidence matrix of a polytope  @xmath0 * output : * hasse diagram  @xmath12 of the face lattice of  @xmath0 [ line : init1 ] initialize @xmath12 and a face tree with @xmath113 corresponding to the empty face [ line : init2 ] initialize a set  @xmath114nodes of @xmath115subsets of @xmath116 by @xmath117 [ line : choose ] choose some @xmath118 and remove it from  @xmath49 [ line : h ] compute the collection  @xmath58 of all @xmath59 , @xmath119 [ line : g ] compute the set  @xmath51 of minimal sets in  @xmath58 [ line : locateg ] locate / create the node  @xmath120 corresponding to  @xmath52 in  @xmath12 add  @xmath121 to  @xmath49 add the arc @xmath122 to  @xmath12    [ prop : alg1 ] algorithm  [ algo : enumeration ] computes the hasse diagram of the face lattice of a polytope  @xmath0 from its vertex - facet incidences in @xmath123 time .",
    "it can be implemented such that its space requirements ( without output space ) are bounded by  @xmath124 .",
    "algorithm [ algo : enumeration ] works correctly by the discussion above .",
    "step  [ line : h ] can be performed in @xmath125 steps by lemma  [ lem : clos ] .",
    "lemma  [ lem : min ] shows that we can execute step  [ line : g ] in  @xmath126 time .",
    "hence , steps  [ line : h ] and  [ line : g ] in total contribute at most @xmath123 to the running time ( since the while - loop is executed once per face ) .",
    "the body of the for - loop has to be executed for each of the @xmath127 arcs in the hasse diagram @xmath12 .",
    "lemma  [ lem : locate ] implies that each execution of the body of the for - loop can be performed in @xmath62 steps .",
    "thus , the claim on the running time follows .    since each node of the face tree corresponds to a face of @xmath0 , the face tree has @xmath128 nodes .",
    "each label on an edge of the face tree needs at most  @xmath129 bits , and we can estimate the space requirements of any of the ( internal and external ) pointers by @xmath130 .",
    "hence , the face tree needs no more than @xmath23 bits .",
    "the space required for the storage of  @xmath49 is bounded by @xmath124 , if for each pair @xmath131 the set  @xmath50 is stored as a _ bit set _ ,",
    "i.e. , the characteristic vector of @xmath132 is stored bit by bit .    if @xmath133 , then it is more efficient to apply algorithm [ algo : enumeration ] to the incidences of the dual polytope , i.e. , to the transpose of the incidence matrix",
    "of course , after the computations the roles of vertices and facets have to be exchanged again .",
    "this yields the main result of the paper .",
    "[ thm : alg1 ] the hasse diagram of the face lattice of a polytope  @xmath0 can be computed from the vertex - facet incidences of  @xmath0 in @xmath20 time , where  @xmath2 is the number of vertices , @xmath3 is the number of facets , @xmath4 is the number of vertex - facet incidences , and  @xmath5 is the total number of faces of  @xmath0",
    ". the space requirements of the algorithm ( without output space ) can be bounded by  @xmath23 .",
    "whenever a new node representing a face  @xmath52 in the hasse diagram  @xmath12 is constructed , we can label that node with the vertex set of  @xmath52 , the set of facets containing  @xmath52 , or with the dimension of  @xmath52 without ( asymptotically ) increasing the running time of the algorithm .",
    "the output , however , might become much larger with such labelings .",
    "for instance , labeling the hasse diagram of the @xmath6-cube by vertex labels requires @xmath134 output storage space , while the hasse diagram with facet labels needs only @xmath135 space .    in practice",
    ", the computation can be speeded up by exploiting that every vertex that is contained in a face  @xmath52 with @xmath53 and @xmath136 must be contained in some facet which contains  @xmath50 .",
    "thus , it suffices to consider only the sets @xmath59 , @xmath137 in step  [ line : h ] .",
    "for a simple @xmath6-polytope  @xmath0 with  @xmath2 vertices , the above procedure can be implemented to run more efficiently .",
    "we have @xmath138 in this case . from the incidences ( stored in the sorted sparse format ) , the graph @xmath139 of  @xmath0 ( i.e. , all one - dimensional faces ) can be computed in time @xmath140 , since a pair of vertices forms an edge if and only if it is contained in @xmath141 common facets .",
    "after initialization with the vertices instead of @xmath10 ( in steps [ line : init1 ] and [ line : init2 ] ) , steps  [ line : h ] and  [ line : g ] can now be simplified .",
    "consider an arbitrary vertex  @xmath142 .",
    "for each neighbor @xmath143 of @xmath83 in @xmath139 , @xmath59 yields the other end node of an arc in the hasse diagram ; and each out - arc of @xmath50 is produced this way .",
    "thus , we can avoid constructing non - minimal faces in step  [ line : h ] .",
    "hence , step  [ line : g ] can be skipped .",
    "the total running time for simple @xmath6-polytopes decreases to  @xmath144 ( since the body of the for - loop is executed at most @xmath145 times ) .",
    "the space complexity stays @xmath124 ( see proposition  [ prop : alg1 ] ) .",
    "it can , however , be reduced to @xmath146 ( we have @xmath147 for simple polytopes ) : instead of storing pairs @xmath148 in the set  @xmath49 , we store the pairs @xmath149 , since  @xmath150 . converting between @xmath50 and @xmath151 can be performed in  @xmath62 steps and hence does not increase the asymptotic total running time .    by duality",
    ", the same running times and space requirements can be achieved for simplicial polytopes .",
    "similarly to the situation with general polytopes , for both simple and simplicial polytopes we can also output for each face its vertices , the facets containing it , or its dimension without ( asymptotically ) increasing the running time .",
    "a variant of algorithm  [ algo : enumeration ] computes the hasse diagram of the @xmath26-skeleton ( all faces of dimension at most @xmath26 ) of a polytope @xmath0 .",
    "one simply prevents the computation of faces of dimensions larger than  @xmath26 by not inserting any @xmath152-face into the list  @xmath49 .",
    "this leads to an @xmath153 time algorithm , where @xmath154 is the number of faces of  @xmath0 of dimension at most @xmath26 .",
    "if we only want to compute the faces of @xmath0 together with their descriptions and dimensions ( i.e. , the `` hasse diagram without edges '' ) , there exists a variant of algorithm  [ algo : enumeration ] with the same asymptotic running time , but significantly reduced space requirements .",
    "the difference is that no face tree is used , and the set @xmath49 is organized as a stack , i.e. , the faces are investigated in a depth - first search manner . at each step , we take a face @xmath50 from the stack , output it , and compute the set @xmath51 of @xmath155-faces containing @xmath50 , like in steps [ line : h ] and [ line : g ] of algorithm  [ algo : enumeration ] .",
    "this needs time @xmath156 for each @xmath50 .",
    "the for - loop beginning at step [ line : locateg ] , including the search in the face tree , is replaced by an efficient way to decide which of the faces in @xmath51 is put onto the stack @xmath49 , such that every face appears exactly once on the stack during the algorithm . for this , we compute for each face @xmath157 a unique canonical facet @xmath158 of it .",
    "we put  @xmath52 onto the stack if and only if @xmath159 .",
    "this ensures that each face is picked exactly once .",
    "we take @xmath158 as the closure of a set @xmath160 , which is computed similar to the set @xmath161 of section [ subsec : locate ] , except that we reject vertices which would produce @xmath52 .",
    "more precisely , let @xmath162 , with @xmath163 . initialize @xmath160 with @xmath10 and in each iteration extend @xmath160 by the smallest  @xmath164 such that @xmath165 and @xmath166 .",
    "after the computation , @xmath158 , the closure of @xmath160 , clearly is a proper face of @xmath52 .",
    "moreover , it is a facet of  @xmath52 , since otherwise there exists a vertex @xmath167 , such that @xmath168 .",
    "but then @xmath169 would have been included into  @xmath160 when it was considered .",
    "hence , @xmath160 is the lexicographically smallest subset of @xmath52 which spans a facet of  @xmath52 .",
    "it can be computed in time @xmath62 , and hence , checking for all faces @xmath55 whether  @xmath50 is the canonical facet @xmath160 of @xmath52 can be performed in @xmath156 time .",
    "altogether , this leads to an @xmath123 time algorithm ( see the proof of proposition  [ prop : alg1 ] ) .",
    "the algorithm needs @xmath170 space for  @xmath49 ; since the depth of @xmath49 is at most @xmath105 , there are never more than @xmath171 sets on the stack , each of size at most  @xmath2 .",
    "additionally , we need @xmath71 space for storing the incidences in the sorted sparse format . applying this method to the dual polytope , if necessary",
    ", we obtain an @xmath172 time algorithm .      algorithm  [ algo : enumeration ] can be used for the enumeration of the elements of any atomic lattice provided a subroutine is available that computes the join of a set of atoms .",
    "for instance , this holds for every atomic and coatomic lattice if the atom - coatom incidences are given , because in this case one can compute the joins of atoms similarly to the case of face lattices of polytopes .    in the following ,",
    "we describe such an application of our algorithm to oriented matroids .",
    "the set of covectors of an oriented matroid with ground set @xmath173 is a subset of @xmath174 that satisfies certain axioms .",
    "we refer to bjrner , las  vergnas , sturmfels , white , and ziegler ( * ? ? ?",
    "4 ) for the definitions and concepts that are relevant in the following . a specific , but illustrative , example arises from any finite set @xmath175 of points in  @xmath176 as follows . for every linear functional @xmath177 denote by @xmath178 the vector whose component corresponding to @xmath179 encodes the sign of  @xmath180 .",
    "then  @xmath181 is the set of covectors of an oriented matroid  @xmath182 .",
    "for @xmath183 the _ separation set _ of  @xmath184 and  @xmath185 contains all indices  @xmath186 such that one of @xmath187 , @xmath188 is  @xmath189 , and the other one is  @xmath190 . the _ composition _",
    "@xmath191 of  @xmath184 and  @xmath185 is defined by @xmath192 if @xmath193 and @xmath194 otherwise .",
    "we define a partial order  @xmath195 on @xmath174 , where @xmath196 holds if and only if for all  @xmath186 we have @xmath197 or @xmath198 .",
    "the @xmath195-minimal elements among the nonzero covectors of an oriented matroid are called its _ cocircuits_.",
    "if one adjoins an artificial maximal element  @xmath199 to the poset formed by the covectors of an oriented matroid ( ordered by  @xmath195 ) , then one obtains its ( _ big _ ) _ face lattice_.    if , in the above example , @xmath175 is the vertex set of a polytope  @xmath200 , then the faces of  @xmath0 correspond to the _ positive covectors _",
    "( i.e. , the covectors with no component equal to @xmath190 ) of @xmath182 . the facets of  @xmath0 correspond to the positive cocircuits of @xmath182 .",
    "the face lattice of  @xmath0 is anti - isomorphic to a sublattice of the face lattice of @xmath182 .",
    "the face lattice of an oriented matroid is atomic and coatomic ; its atoms are the cocircuits , and its coatoms are called _",
    "topes_. hence , we can compute its hasse diagram from the abstract atom - coatom incidences as above .    however , this is not the usual way to encode an oriented matroid .",
    "it is more common to specify an oriented matroid by its cocircuits .",
    "the join of two covectors simply is their composition , if their separation set is empty , or @xmath199 otherwise .",
    "such a composition can be computed in @xmath201 steps , which enables us to compute the face lattice ( efficiently ) from its cocircuits by a variant of algorithm  [ algo : enumeration ] .    in step  [ line : choose ] , @xmath50 now is a face of the oriented matroid , i.e. , a covector . in step  [ line : h ] , one has to compute the joins of  @xmath50 with every cocircuit  @xmath202 .",
    "thus , step  [ line : h ] can be performed in @xmath203 steps altogether ( where  @xmath5 is the total number of covectors and  @xmath2 is the number of cocircuits ) .",
    "we do not know any method to perform step  [ line : g ] faster than by pairwise comparisons , which take @xmath204 time in total .",
    "the face tree is organized similarly to the description in section  [ subsec : locate ] .",
    "one fixes an ordering  @xmath205 of the cocircuits . for a covector",
    "@xmath206 let @xmath207 ( @xmath208 ) be the index set of cocircuits @xmath209 .",
    "then we iteratively form the joins of @xmath210 , and let @xmath211 consist of all those indices for which the `` joins change . ''",
    "computing @xmath211 from  @xmath206 takes @xmath212 steps .",
    "note that  @xmath213 .    using this modified face tree",
    ", a given covector  @xmath206 can now be searched in the same way as in the case of face lattices of polytopes .",
    "the depth of the face tree is bounded by  @xmath26 .",
    "hence , location / creation of a covector can be performed in @xmath212 time .",
    "the rest of the analysis is similar to the proof of proposition  [ prop : alg1 ] .",
    "thus , by this variant of algorithm  [ algo : enumeration ] , the hasse diagram of the face lattice of an oriented matroid can be computed in @xmath214 steps , requiring @xmath215 working space ( since @xmath216 ) .",
    "finschi  @xcite describes a different algorithm that computes the covectors of an oriented matroid from its cocircuits in @xmath217 time .",
    "his algorithm , however , does not produce the edges of the hasse diagram .",
    "the case where the topes ( i.e. , the @xmath195-maximal covectors ) of an oriented matroid are given is a bit different . here , the number of faces is bounded by @xmath218 , where @xmath3 is the number of topes . hence , the size of the face lattice is polynomial in @xmath3 .",
    "fukuda , saito , and tamura @xcite give an @xmath219 time algorithm for constructing the face lattice from the maximal covectors .",
    "we are indepted to michael joswig and jrg rambau for stimulating discussions as well as to gnter m.  ziegler for valuable comments on the paper .",
    "we also thank the two referees for their helpful comments ."
  ],
  "abstract_text": [
    "<S> we give an algorithm that constructs the hasse diagram of the face lattice of a convex polytope  @xmath0 from its vertex - facet incidences in time  @xmath1 , where  @xmath2 is the number of vertices , @xmath3 is the number of facets , @xmath4 is the number of vertex - facet incidences , and  @xmath5 is the total number of faces of  @xmath0 . </S>",
    "<S> this improves results of fukuda and rosta  @xcite , who described an algorithm for enumerating all faces of a @xmath6-polytope in  @xmath7 steps . for simple or simplicial @xmath6-polytopes </S>",
    "<S> our algorithm can be specialized to run in time @xmath8 . </S>",
    "<S> furthermore , applications of the algorithm to other atomic lattices are discussed , e.g. , to face lattices of oriented matroids .    </S>",
    "<S> * keywords : * polytope , face lattice , enumeration , vertex - facet incidences , algorithm , oriented matroid    * msc 2000 : * 68r05 68u05 52b11 68q25 52c40 </S>"
  ]
}