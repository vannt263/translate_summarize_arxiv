{
  "article_text": [
    "the problem of random number generation dates back to von neumann @xcite who considered the problem of simulating an unbiased coin by using a biased coin with unknown probability .",
    "he observed that when one focuses on a pair of coin tosses , the events @xmath0 and @xmath1 have the same probability ( @xmath2 is for ` head ' and @xmath3 is for ` tail ' ) ; hence , @xmath0 produces the output symbol @xmath4 and @xmath1 produces the output symbol @xmath5 .",
    "the other two possible events , namely , @xmath6 and @xmath7 , are ignored , namely , they do not produce any output symbols .",
    "more efficient algorithms for generating random bits from a biased coin were proposed by hoeffding and simons @xcite , elias @xcite , stout and warren @xcite and peres @xcite .",
    "elias @xcite was the first to devise an optimal procedure in terms of the information efficiency , namely , the expected number of unbiased random bits generated per coin toss is asymptotically equal to the entropy of the biased coin .",
    "in addition , knuth and yao @xcite presented a simple procedure for generating sequences with arbitrary probability distributions from an unbiased coin ( the probability of @xmath2 and @xmath3 is @xmath8 ) .",
    "han and hoshi @xcite generalized this approach and considered the case where the given coin has an arbitrary known bias .    in this paper",
    ", we study the problem of generating random bits from an arbitrary and unknown finite markov chain ( the transition matrix is unknown ) .",
    "the input to our problem is a sequence of symbols that represent a random trajectory through the states of the markov chain - given this input sequence our algorithm generates an independent unbiased binary sequence called the output sequence .",
    "this problem was first studied by samuelson @xcite . his approach was to focus on a single state ( ignoring the other states ) treat the transitions out of this state as the input process , hence , reducing the problem of correlated sources to the problem of a single ` independent ' random source ; obviously , this method is not efficient .",
    "elias @xcite suggested to utilize the sequences related to all states : producing an ` independent ' output sequence from the transitions out of every state and then pasting ( concatenating ) the collection of output sequences to generate a long output sequence .",
    "however , neither samuelson nor elias proved that their methods work for arbitrary markov chains , namely , they did not prove that the transitions out of each state are independent .",
    "in fact , blum @xcite probably realized it , as he mentioned that : ( i )  elias s algorithm is excellent , but certain difficulties arise in trying to use it ( or the original von neumann scheme ) to generate bits in expected linear time from a markov chain \" , and ( ii )  elias has suggested a way to use all the symbols produced by a mc ( markov chain ) .",
    "his algorithm approaches the maximum possible efficiency for a one - state mc . for a multi - state mc ,",
    "his algorithm produces arbitrarily long finite sequences .",
    "he does not , however , show how to paste these finite sequences together to produce _ infinitely _ long independent unbiased sequences . \"",
    "blum @xcite derived a beautiful algorithm to generate random bits from a degree-2 markov chain _ in expected linear time _ by utilizing the von neumann scheme for generating random bits from biased coin flips . while his approach can be extended to arbitrary out - degrees ( the general markov chain model used in this paper ) , the information - efficiency is still far from being optimal due to the low information - efficiency of the von neumann scheme .    in this paper , we generalize blum s algorithm to arbitrary degree finite markov chains and combine it with existing methods for efficient generation of unbiased bits from biased coins , such as elias s method .",
    "as a result , we provide the first known algorithm that generates unbiased random bits from arbitrary finite markov chains , operates in expected linear time and achieves the information - theoretic upper bound on efficiency .",
    "specifically , we propose an algorithm ( that we call algorithm @xmath9 ) , that is a simple modification of elias s suggestion to generate random bits , it operates on finite sequences and its efficiency can asymptotically reach the information - theoretic upper bound for long input sequences .",
    "in addition , we propose a second algorithm , called algorithm @xmath10 , that is a combination of blum s and elias s algorithms , it generates infinitely long sequences of random bits in expected linear time .",
    "one of our key ideas for generating random bits is that we explore equal - probability sequences of the same length .",
    "hence , a natural question is : can we improve the efficiency by utilizing as many as possible equal - probability sequences ?",
    "we provide a positive answer to this question and describe algorithm @xmath11 , that is the first known polynomial - time and optimal algorithm ( it is optimal in terms of information - efficiency for an arbitrary input length ) for random bits generation from finite markov chains .    in this paper , we use the following notations : @xmath12 & : & \\textrm{same as $ x_a$ , the $ a^{th}$ element of $ x$}\\\\ x[a : b ] & : & \\textrm{subsequence of $ x$ from the $ a^{th}$ to $ b^{th}$ element}\\\\ x^a & : &   x[1:a]\\\\ x*y & : & \\textrm{the concatenation of $ x$ and $ y$}\\\\ & & e.g. \\quad s_1s_2*s_2s_1=s_1s_2s_2s_1\\\\ y \\pmu x & : & y \\textrm { is a permutation of } x \\\\ & & e.g. \\quad s_1s_2s_2s_3\\pmu s_3s_2s_2s_1\\\\ y \\tmu x & : & y \\textrm { is a permutation of } x \\textrm { and } y_{|y|}=x_{|x|}\\\\ & & \\textrm{namely the last element is fixed}\\\\ & & e.g. \\quad s_1s_2s_2s_3\\tmu s_2s_2s_1s_3 \\textrm { where } s_3 \\textrm { is fixed}\\\\ \\end{array}\\ ] ]    the remainder of this paper is organized as follows .",
    "section [ section_biasedcoin ] reviews existing schemes for generating random bits from arbitrarily biased coins .",
    "section [ section_mainlemma ] discusses the challenge in generating random bits from arbitrary finite markov chains and presents our main lemma - this lemma characterizes the exit sequences of markov chains .",
    "algorithm @xmath9 is presented and analyzed in section [ section_finite ] , it is related to elias s ideas for generating random bits from markov chains",
    ". algorithm @xmath10 is presented in section [ section_infinite ] , it is a generalization of blum s algorithm .",
    "an optimal algorithm , called algorithm @xmath11 , is described in section [ section_optimal ] .",
    "finally , section [ section_experiment ] provides numerical evaluations of our algorithms .",
    "consider a sequence of length @xmath13 generated by a biased n - face coin @xmath14 such that the probability to get @xmath15 is @xmath16 , and @xmath17 . while we are given a sequence @xmath18 the probabilities that @xmath19 are unknown",
    ", the question is : how can we efficiently generate an independent and unbiased sequence of @xmath4 s and @xmath5 s from @xmath18 ?",
    "the efficiency ( information - efficiency ) of a generation algorithm is defined as the ratio between the expected length of the output sequence and the length of the input sequence , namely , the expected number of random bits generated per input symbol . in this section",
    "we describe three existing solutions for the problem of random bits generation from biased coins .      in 1951 , von neumann @xcite considered this question for biased coins and described a simple procedure for generating an independent unbiased binary sequence @xmath20 from the input sequence @xmath21 . in his original procedure , the coin is binary , however , it can be simply generalized for the case of an @xmath22-face coin : for an input sequence , we can divide it into pairs @xmath23 and use the following mapping for each pair @xmath24 where @xmath25 denotes the empty sequence . as a result , by concatenating the outputs of all the pairs , we can get a binary sequence which is independent and unbiased .",
    "the von neumann scheme is computationally ( very ) efficient , however , its information - efficiency is far from being optimal .",
    "for example , when the input sequence is binary , the probability for a pair of input bits to generate an output bit ( not a @xmath25 ) is @xmath26 , hence the efficiency is @xmath27 , which is @xmath28 at @xmath29 and less elsewhere .      in 1972 ,",
    "elias @xcite proposed an optimal ( in terms of efficiency ) algorithm as a generalization of the von neumann scheme ; for the sake of completeness we describe it here .",
    "elias s method is based on the following idea : the possible @xmath30 input sequences of length @xmath13 can be partitioned into classes such that all the sequences in the same class have the same number of @xmath31 s with @xmath32 .",
    "note that for every class , the members of the class have the same probability to be generated .",
    "for example , let @xmath33 and @xmath34 , we can divide the possible @xmath35 input sequences into 5 classes : @xmath36    now , our goal is to assign a string of bits ( the output ) to each possible input sequence , such that any two output sequences @xmath37 and @xmath38 with the same length ( say @xmath39 ) , have the same probability to be generated , namely @xmath40 for some @xmath41 .",
    "the idea is that for any given class we partition the members of the class to groups of sizes that are a power of 2 , for a group with @xmath42 members ( for some @xmath43 ) we assign binary strings of length @xmath43 .",
    "note that when the class size is odd we have to exclude one member of this class .",
    "we now demonstrate the idea by continuing the example above .",
    "note that in the example above , we can not assign any bits to the sequence in @xmath44 , so if the input sequence is @xmath45 , the output sequence should be @xmath25 ( denotes the empty sequence ) .",
    "there are @xmath46 sequences in @xmath47 and we assign the binary strings as follows : @xmath48 @xmath49 similarly , for @xmath50 , there are @xmath51 sequences that can be divided into a group of @xmath46 and a group of @xmath52 : @xmath53 @xmath54 @xmath55    in general , for a class with @xmath56 members that were not assigned yet , assign @xmath57 possible output binary sequences of length @xmath58 to @xmath57 distinct unassigned members , where @xmath59 .",
    "repeat the procedure above for the rest of the members that were not assigned .",
    "note that when a class has an odd number of members , there will be one and only one member assigned to @xmath25 .",
    "given an input sequence @xmath18 of length @xmath13 , using the method above , the output sequence can be written as a function of @xmath18 , denoted by @xmath60 , called the elias function . in @xcite ,",
    "ryabko and matchikina showed that the elias function of an input sequence of length @xmath13 ( that is generated by a biased coin with two faces ) is computable in @xmath61 time .",
    "we can prove that their conclusion is valid in the general case of a coin with @xmath22 faces with @xmath62 .",
    "in 1992 , peres @xcite demonstrated that iterating the original von neumann scheme on the discarded information can asymptotically achieve optimal efficiency .",
    "let s define the function related to the von neumann scheme as @xmath63 .",
    "then the iterated procedures @xmath64 with @xmath65 are defined inductively .",
    "given input sequence @xmath66 , let @xmath67 denote all the indices @xmath68 for which @xmath69 , then @xmath64 is defined as @xmath70    note that on the righthand side of the equation above , the first term corresponds to the random bits generated with the von neumann scheme , the second and third terms relate to the symmetric information discarded by the von neumann scheme .",
    "finally , we can define @xmath64 for sequences of odd length by @xmath71    surprisingly , this simple iterative procedure achieves the optimal efficiency asymptotically .",
    "the computational complexity and memory requirements of this scheme are substantially smaller than those of the elias scheme .",
    "however , a drawback of this scheme is that its generalization to the case of an @xmath22-face coin with @xmath62 is not obvious .",
    "let s denote @xmath72 as a scheme that generates independent unbiased sequences from any biased coins ( with unknown probabilities ) .",
    "such @xmath73 can be the von neumann scheme , the elias scheme , the peres scheme or any other scheme .",
    "let @xmath18 be a sequence generated from an arbitrary biased coin , with length @xmath13 , then a property of @xmath73 is that for any @xmath74 and @xmath75 with @xmath76 , we have @xmath77=p[\\psi(x)=y']\\ ] ] namely , two output sequences of equal length have equal probability .    that leads to the following property for @xmath73 .",
    "it says that given the number of @xmath15 s for all @xmath43 with @xmath78 , the number of such sequences to yield a binary sequence @xmath37 equals to that of sequences to yield @xmath38 if @xmath37 and @xmath38 have the same length .",
    "it further implies that given the condition of knowing the number of @xmath15 s for all @xmath43 with @xmath78 , the output sequence of @xmath73 is still independent and unbiased .",
    "this property is due to the linear independence of probability functions of the sequences with different numbers of the @xmath15 s",
    ".    let @xmath79 be a subset in @xmath80 such that it includes all the sequences with the same number of @xmath15 s for all @xmath43 with @xmath78 , namely , @xmath81 .",
    "let @xmath82 denote the set @xmath83 .",
    "then for any @xmath74 and @xmath75 with @xmath76 , we have @xmath84 .",
    "[ lemma_coin ]    in @xmath79 , the number of @xmath15 s in each sequence is @xmath85 for all @xmath78 , then we can get that @xmath77=\\sum_s |s\\bigcap b_y|\\prod_{i=1}^n \\beta(s)\\ ] ] where @xmath86    since @xmath87=p[\\psi(x)=y']$ ] , we have @xmath88    the set of polynomials @xmath89 is linearly independent in the vector space of functions on @xmath90 $ ] , so we can conclude that @xmath84 .    [ cols=\"^,<,^,^\",options=\"header \" , ]      varies with the value of window size @xmath91 for different state number @xmath22 , where we assume that the transition probability @xmath92 for all @xmath93.,width=345 ]    in the second calculation , we want to test the influence of window size @xmath91 ( assume @xmath94 for @xmath78 ) on the efficiency of algorithm @xmath10 . since the efficiency depends on the transition matrix of the markov chain we decided to evaluate of the efficiency related to the uniform transition matrix , namely all the entries are @xmath95 , where @xmath22 is the number of states .",
    "we assume that @xmath22 is infinitely large . in this case , the stationary distribution of the markov chain is @xmath96 .",
    "[ fig_effiency ] shows that when @xmath97 ( blum s algorithm ) , the limiting efficiencies for @xmath98 are @xmath99 , respectively .",
    "when @xmath100 , their corresponding efficiencies are @xmath101 .",
    "so if the input sequence is long enough , by changing @xmath91 from @xmath52 to @xmath102 , the efficiency can increase @xmath103 for @xmath33 , @xmath104 for @xmath105 and @xmath106 for @xmath107 .",
    "when @xmath91 is small , we can increase the efficiency of algorithm @xmath10 significantly by increasing the window size @xmath91 .",
    "when @xmath91 becomes larger , the efficiency of algorithm @xmath10 will converge to the information - theoretical upper bound , namely , @xmath108 .",
    "note that @xmath109 is not a good value for the window size in the algorithm .",
    "that is because the elias function is not very efficient when the length of the input sequence is @xmath109 .",
    "let s consider a biased coin with two states @xmath110 .",
    "if the input sequence is @xmath111 or @xmath112 , the elias function will generate nothing .",
    "for all other cases , it has only @xmath113 chance to generate one bit and @xmath114 chance to generate nothing . as a result ,",
    "the efficiency is even worse than the efficiency when the length of the input sequence equals to @xmath52 .",
    "we considered the classical problem of generating independent unbiased bits from an arbitrary markov chain with unknown transition probabilities .",
    "our main contribution is the first known algorithm that has expected linear time complexity and achieves the information - theoretic upper bound on efficiency .",
    "our work is related to a number of interesting results in both computer science and information theory . in computer science ,",
    "the attention has focused on extracting randomness from a general weak source ( introduced by zuckerman @xcite ) .",
    "hence , the concept of an extractor was introduced - it converts weak random sequences to ` random - looking ' sequences , using an additional small number of truly random bits . during the past two decades , extractors and their applications",
    "have been studied extensively , see @xcite@xcite for surveys on the topic . while our algorithms generate truly random bits ( given a prefect markov chain as a source ) the goal of extractors is to generate ` random - looking ' sequences which are asymptotically close to random bits .    in information theory , it was discovered that optimal source codes can be used as universal random bits generators from arbitrary stationary ergodic random sources @xcite@xcite . when the input sequence is generated from a stationary ergodic process and it is",
    "long enough one can obtain an output sequence that behaves like truly random bits in the sense of normalized divergence .",
    "however , in some cases , the definition of normalized divergence is not strong enough .",
    "for example , suppose @xmath37 is a sequence of unbiased random bits in the sense of normalized divergence , and @xmath115 is @xmath37 with a @xmath5 concatenated at the beginning .",
    "if the sequence @xmath37 is long enough the sequence @xmath115 is a sequence of unbiased random bits in the sense of normalized divergence .",
    "however the sequence @xmath115 might not be useful in applications that are sensitive to the randomness of the first bit .",
    "* lemma 4 * ( main lemma : feasibility and equivalence of exit sequences ) . _ given a starting state @xmath116 and two collections of sequences @xmath117 $ ] and @xmath118 $ ] such that @xmath119 ( tail - fixed permutation ) for all @xmath78 .",
    "then @xmath120 is feasible if and only if @xmath121 is feasible . _    in the rest of the appendix we will prove the main lemma . to illustrate the claim in the lemma , we express @xmath116 and @xmath122 by a directed graph that has labels on the vertices and edges , we call this graph a _ sequence graph_. for example , when @xmath123 and @xmath124 $ ] , we have the directed graph in fig . [ fig_ordertransform ] .",
    "let @xmath125 denote the vertex set , then @xmath126 and the edge set is @xmath127)\\ } \\bigcup \\{(s_0 , s_\\alpha)\\}\\ ] ] for each edge @xmath128)$ ] , the label of this edge is @xmath39 . for the edge @xmath129 , the label is @xmath5 .",
    "namely , the label set of the outgoing edges of each state is @xmath130 .      given the labeling of the directed graph as defined above , we say that it contains a _ complete walk _ if there is a path in the graph that visits all the edges , without visiting an edge twice , in the following way : ( 1 ) start from @xmath131 .",
    "( 2 ) at each vertex , we choose an unvisited edge with the minimal label to follow .",
    "obviously , the labeling corresponding to @xmath120 is a _",
    "complete walk _ if and only if @xmath120 is feasible . in this case , for short , we also say that @xmath120 is a complete walk . before continuing to prove the main lemma , we first give lemma [ lemma_graphtransform ] and lemma [ lemma_graphtransform2 ] .",
    "assume @xmath132 with @xmath133 $ ] is a a complete walk , which ends at state @xmath134 .",
    "then @xmath135 with @xmath136 $ ] is also a complete walk ending at @xmath134 , if @xmath137 ( permutation ) .",
    "[ lemma_graphtransform ]    @xmath132 and @xmath135 correspond to different labelings on the same directed graph @xmath138 , denoted by @xmath139 and @xmath140 .",
    "since @xmath139 is a complete walk , it can travel all the edges in @xmath138 one by one , denoted as @xmath141 where @xmath142 and @xmath143 .",
    "we call @xmath144 as the indexes of the edges .    based on @xmath140 ,",
    "let s have a walk on @xmath138 starting from @xmath131 until there is no unvisited outgoing edges to select",
    ". in this walk , assume the following edges have been visited : @xmath145 where @xmath146 are distinct indexes chosen from @xmath144 and @xmath147 . in order to prove that @xmath140 is a complete walk , we need to show that ( 1 ) @xmath148 and ( 2 ) @xmath149",
    ".    first , let s prove that @xmath148 . in @xmath138 , let @xmath150 denote the number of outgoing edges of @xmath15 and let @xmath151 denote the number of incoming edges of @xmath15 , then we have that @xmath152 based on these relations , we know that once we have a walk starting from @xmath131 in @xmath138 , this walk will finally end at state @xmath134 . that is because we can always get out of @xmath15 due to @xmath153 if @xmath154 .",
    "now , we prove that @xmath149 .",
    "this can be proved by contradiction .",
    "assume @xmath155 , then we define @xmath156 @xmath157 where @xmath125 corresponds to the visited edges based on @xmath140 and @xmath158 corresponds to the unvisited edges based on @xmath140 .",
    "let @xmath159 , then @xmath160 is the unvisited edge with the minimal index .",
    "let @xmath161 , then @xmath160 is an outgoing edge of @xmath162 . here",
    "@xmath163 , because all the outgoing edges of @xmath134 have been visited .",
    "assume the number of visited incoming edges of @xmath164 is @xmath165 and the number of visited outgoing edges of @xmath164 is @xmath166 , then @xmath167 see fig .",
    "[ fig_example3 ] as an example .",
    "note that the labels of the outgoing edges of @xmath164 are the same for @xmath139 and @xmath140 , since @xmath168 . therefore , based on @xmath139 , before visiting edge @xmath160 , there must be @xmath166 outgoing edges of @xmath164 have been visited . as a result , based on @xmath139 , there must be @xmath169 incoming edges of @xmath164 have been visited before visiting @xmath160 .",
    "among all these @xmath170 incoming edges , there exists at least one edge @xmath171 such that @xmath172 , since only @xmath165 incoming edges of @xmath164 have been visited based on @xmath140 .    according to our assumption",
    ", both @xmath173 and @xmath174 is the minimal one , so @xmath175 . on the other hand , we know that @xmath171 is visited before @xmath160 based on @xmath139 , so @xmath176 . here , the contradiction happens .",
    "therefore , @xmath149 .      here",
    ", let s give an example of the lemma above . we know that , when @xmath177 $ ] , @xmath120 is feasible",
    "the labeling on a directed graph corresponding to @xmath120 is given in fig .",
    "[ fig_ordertransform ] , which is a complete walk starting at state @xmath131 and ending at state @xmath178 .",
    "the path of the walk is @xmath179    by permutating the labels of the outgoing edges of @xmath178 , we can have the graph as shown in fig .",
    "[ fig_ordertransform2 ] .",
    "the new labeling on @xmath138 is also a complete walk ending at state @xmath178 , and its path is @xmath180        given a starting state @xmath116 and two collections of sequences @xmath181 $ ] and @xmath182 $ ] such that @xmath183 ( tail - fixed permutation ) .",
    "then @xmath120 and @xmath121 have the same feasibility . [ lemma_graphtransform2 ]",
    "we prove that if @xmath120 is feasible , then @xmath121 is also feasible .",
    "if @xmath120 is feasible , there exists a sequence @xmath18 such that @xmath184 and @xmath185 .",
    "suppose its last element is @xmath186 .      when @xmath188 , we assume that @xmath189 .",
    "let s consider the subsequence @xmath190 of @xmath18 .",
    "then @xmath191 and the last element of @xmath192 is @xmath31 . according to lemma [ lemma_graphtransform ] , we can get that : there exists a sequence @xmath193 with @xmath194 and @xmath195 such that @xmath196\\ ] ] since @xmath197 .",
    "let @xmath198 , i.e. , concatenating @xmath199 to the end of @xmath200 , we can generate a sequence @xmath201 such that its exit sequence of state @xmath31 is @xmath202 and its exit sequence of state @xmath15 with @xmath203 is @xmath204 .      according to the lemma above ,",
    "we know that @xmath205)$ ] and @xmath206)$ ] have the same feasibility , @xmath206)$ ] and @xmath207)$ ] have the same feasibility , ... , @xmath208)$ ] and @xmath209)$ ] have the same feasibility , so the statement in the main lemma is true ."
  ],
  "abstract_text": [
    "<S> the problem of random number generation from an uncorrelated random source ( of unknown probability distribution ) dates back to von neumann s 1951 work . elias ( 1972 ) generalized von neumann s scheme and showed how to achieve optimal efficiency in unbiased random bits generation . </S>",
    "<S> hence , a natural question is what if the sources are correlated ? </S>",
    "<S> both elias and samuelson proposed methods for generating unbiased random bits in the case of correlated sources ( of unknown probability distribution ) , specifically , they considered finite markov chains . however , their proposed methods are not efficient or have implementation difficulties . </S>",
    "<S> blum ( 1986 ) devised an algorithm for efficiently generating random bits from degree-2 finite markov chains in expected linear time , however , his beautiful method is still far from optimality on information - efficiency . in this paper , we generalize blum s algorithm to arbitrary degree finite markov chains and combine it with elias s method for efficient generation of unbiased bits . as a result </S>",
    "<S> , we provide the first known algorithm that generates unbiased random bits from an arbitrary finite markov chain , operates _ in expected linear time _ and achieves the information - theoretic upper bound on efficiency .    random sequence , random bits generation , markov chain . </S>"
  ]
}