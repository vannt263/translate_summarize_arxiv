{
  "article_text": [
    "theoretical models for wireless sensor networks have received great attention over the past few years .",
    "recently , angluin et al . @xcite proposed the _ population protocol _ ( _ pp _ ) model .",
    "their aim was to model sensor networks consisting of tiny computational devices with sensing capabilities that follow some unpredictable and uncontrollable mobility pattern . due to the minimalistic nature of their model ,",
    "the class of computable predicates was proven to be fairly small : it is the class of _ semilinear predicates _",
    ", thus , not including multiplication of variables , exponentiations , and many other important operations on input variables .",
    "moreover , delporte - gallet et al .",
    "@xcite showed that pps can tolerate only @xmath5 crash failures and not even a single byzantine agent .    the work of angluin et al .",
    "shed light and opened the way towards a brand new and very promising direction .",
    "the lack of control over the interaction pattern , as well as its inherent nondeterminism , gave rise to a variety of new theoretical models for wsns .",
    "those models draw most of their beauty precisely from their inability to organize interactions in a convenient and predetermined way .",
    "in fact , the population protocol model was the minimalistic starting - point of this area of research .",
    "most efforts are now towards strengthening the model of angluin et al . with extra realistic and implementable assumptions , in order to gain more computational power and/or speed - up the time to convergence and/or improve fault - tolerance .    the _ mediated population protocol _ ( _ mpp _ ) model of @xcite was based on the assumption that the agents can read and write pairwise information on some global storage , like e.g. a base station .",
    "each ordered pair of agents that is permitted to interact occupies a memory slot of fixed length .",
    "the mpp model is strictly stronger than the pp model , since it can handle multiplication of variables , and _ mp _ , which is the class of symmetric predicates stably computable by mpp ,",
    "is contained in @xmath6 , where @xmath7 denotes the number of edges of the communication graph .",
    "unfortunately , as partly indicated by @xcite and @xcite , our knowledge of this model is quite restricted yet .",
    "guerraoui and ruppert @xcite made another natural assumption : they equipped the agents with read - only unique identifiers picked from an infinite set of ids .",
    "they named their model the _ community protocol _ model .",
    "each agent has its own unique i d and can store up to a constant number of other agents ids . in this model , agents are only allowed to compare ids , that is , no other operation on ids is permitted .",
    "it was proven that the corresponding class consists of all symmetric predicates in @xmath4 , where @xmath0 is the community size .",
    "the proof was based on a simulation of a modified version of nondeterministic sch \" onhage s _ storage modification machine _",
    "( _ nsmm _ ) .",
    "it was additionally shown that if faults can not alter the unique ids and if some necessary preconditions are satisfied , then community protocols can tolerate @xmath5 byzantine agents .    in this work , we think of each agent as being a turing machine whose memory is logarithmic in the population size . based on this realistic and implementable assumption , we propose a new theoretical model for passively mobile sensor networks , called the _ paloma _ model . to be more precise , it is a model of passively mobile machines ( that we keep calling agents ) with sensing capabilities , equipped with two - way communication , and each having a memory of size logarithmic in the population size @xmath0 .",
    "the reason for studying such an extension is that having _ logarithmic communicating machines",
    "_ seems to be more natural than communicating automata of constant memory .",
    "first of all , the _ communicating machines _ assumption is perfectly consistent with current technology ( cellphones , ipods , pdas , and so on ) .",
    "moreover , _",
    "logarithmic _ is , in fact , _",
    "extremely small_. for a convincing example , it suffices to mention that for a population consisting of @xmath8 agents , which is a number greater than the number of atoms in the observable universe , we only require each agent to have @xmath9 cells of memory ( while small - sized flash memory cards nowadays exceed @xmath10 gb of storage capacity ) ! interestingly , as we shall see , it turns out that the agents are able to organize themselves into a distributed nondeterministic tm that makes full use of the agents memories !",
    "the tm draws its nondeterminism by the nondeterminism inherent in the interaction pattern .",
    "much work concerning the population protocol model has been devoted to establishing that the class of computable predicates is precisely the class of _ semilinear predicates _ @xcite .",
    "moreover , in @xcite , the _ probabilistic population protocol _",
    "model was proposed , in which the scheduler selects randomly and uniformly the next pair to interact . some recent work has concentrated on performance , supported by this random scheduling assumption ( see e.g. @xcite ) .",
    "@xcite proposed a generic definition of probabilistic schedulers and a collection of new fair schedulers , and revealed the need for the protocols to adapt when natural modifications of the mobility pattern occur .",
    "@xcite considered a huge population hypothesis ( population going to infinity ) , and studied the dynamics , stability and computational power of probabilistic population protocols by exploiting the tools of continuous nonlinear dynamics . moreover ,",
    "several extensions of the basic model have been proposed in order to more accurately reflect the requirements of practical systems . in @xcite ,",
    "angluin et al . studied what properties of restricted communication graphs are stably computable , gave protocols for some of them , and proposed an extension of the model with _ stabilizing inputs_. in @xcite , mpp s ability to decide graph properties was studied and it was proven that connectivity is undecidable . unfortunately , the class of decidable graph languages by mpp remains open .",
    "some other works incorporated agent failures @xcite and gave to some agents slightly increased computational power @xcite ( heterogeneous systems ) .",
    "recently , bournez et al .",
    "@xcite investigated the possibility of studying population protocols via game - theoretic approaches .",
    "for an excellent introduction to the subject of population protocols see @xcite and for some recent advances mainly concerning mediated population protocols see @xcite .",
    "in section [ sec : mod ] , we begin with a formal definition of the paloma model .",
    "the section proceeds with a thorough description of the systems functionality and then provides definitions of _ configurations _ and _ fair executions_. in section [ sec : pred ] , _ stable computation _ of _ symmetric predicates on input assignments _ is defined .",
    "then the complexity classes @xmath11 , @xmath12 ( symmetric predicates in @xmath13 and @xmath14 , respectively ) , and @xmath1 ( stably computable predicates by the paloma model ) are defined , and the section concludes with two examples of stably computable predicates ( subsection [ subsec : mult ] ) .",
    "both those predicates are non - semilinear , establishing that the paloma model is computationally stronger than the population protocol model .",
    "we next study more systematically the computational power of the new model , seeking for an exact characterization for the class @xmath1 .",
    "we first study the ppaloma model , a generalization of the paloma model that additionally knows the population size @xmath0 ( see section [ sec : pops ] ) .",
    "then , in section [ sec : uids ] we focus on another generalization of the paloma model , called the ipaloma model , in which the agents not only know the population size but additionally have already been assigned the unique consecutive ids @xmath15 .",
    "we define the corresponding class of stably computable predicates that we call @xmath16 .",
    "we begin by studying the relationship between @xmath16 and @xmath1 .",
    "unexpectedly , it turns out that @xmath17 ( theorem [ the : iplm ] ) !",
    "the reason is that the paloma model can inform the agents of the population size and assign unique consecutive ids to the agents via an _ iterative reinitiation process_. we next prove that @xmath18 is a subset of @xmath16 , by showing that in the ipaloma model the agents can easily organize themselves into a deterministic turing machine of @xmath2 space .",
    "thus , the inclusions @xmath19 @xmath20 provide us with a first lower bound for @xmath1 . in section [ sec : imlowplm ] , @xmath1 s lower bound is improved to @xmath21 . in particular , it is proven that the paloma model simulates guerraoui s and ruppert s community protocol model @xcite .",
    "unfortunately , the proof of the lower bound on the computational power of the community protocol model in @xcite entirely depends on the simulation of a tm by a storage modification machine , and this dependence is carried to our result . in order to avoid this , in subsection [ subsec : ntm ]",
    "we go one step further and , by exploiting the techniques of theorem [ the : iplm ] ( section [ sec : uids ] ) , we show that the paloma model can directly simulate a nondeterministic tm of @xmath2 space .",
    "moreover , in section [ sec : exact ] we show that @xmath21 is an exact characterization for @xmath1 , by proving that the corresponding language of any predicate that is stably computable by the paloma model can be decided by a nondeterministic tm of @xmath2 space . to summarize , the main result of this work is that @xmath1 is equal to @xmath21 .",
    "finally , in section [ sec : conc ] we conclude and discuss some future research directions .",
    "in this section , we formally define the paloma model and describe its functionality . in what follows ,",
    "we denote by @xmath22 the ( directed ) communication graph : @xmath23 is the set of agents , or _ population _ , and @xmath24 is the set of permissible ordered pairwise interactions between these agents .",
    "we provide definitions for general communication graphs , although in this work we deal with complete communication graphs only .",
    "we generally denote by @xmath0 the population size ( i.e. @xmath25 ) .",
    "a _ paloma _ protocol @xmath26 is a 7-tuple @xmath27 where @xmath28 , @xmath29 , @xmath30 and @xmath31 are all finite sets and    1 .",
    "@xmath28 is the _ input alphabet _",
    ", where @xmath32 , 2 .",
    "@xmath33 is the _ set of input strings _ , 3 .",
    "@xmath30 is the _ tape alphabet _ , where @xmath34 and @xmath35 , 4 .",
    "@xmath31 is the set of _ states _ , 5 .",
    "@xmath36 is the _ internal transition function _ ,",
    "@xmath37 is the _ external transition function _ ( or _ interaction transition function _ ) , and 7 .",
    "@xmath38 is the _",
    "initial state_.    each agent is equipped with the following :    * a _ sensor _ in order to sense its environment and receive a piece of the input ( which is an input string from @xmath29 ) . *",
    "a _ tape _ ( memory ) consisting of @xmath39 cells .",
    "the tape is partitioned into three parts each consisting of @xmath39 cells : the leftmost part is the _ working tape _ , the middle part is the _ output tape _ , and the rightmost part is the _ message tape _ ( we call the parts `` tapes '' because such a partition is equivalent to a 3-tape machine ) .",
    "the last cell of each part contains permanently the symbol @xmath40 ( we assume that the machine never alters it ) ; it is the symbol used to separate the three tapes and to mark the end of the overall tape .",
    "* a _ control unit _ that contains the state of the agent and applies the transition functions .",
    "* a _ head _ that reads from and writes to the cells and can move one step at a time , either to the left or to the right . *",
    "a binary _ working flag _ either set to @xmath41 meaning that the agent is _ working _ internally or to @xmath42 meaning that the agent is _ ready _ for interaction .",
    "initially , all agents are in state @xmath43 and all their cells contain the _ blank symbol _",
    "@xmath44 except for the last cell of the working , output , and message tapes that contain the _ separator _ @xmath40 .",
    "we assume that all agents concurrently receive their sensed input ( different agents may sense different data ) as a response to a global start signal .",
    "the input is a string from @xmath29 and after reception ( or , alternatively , during reception , in an online fashion ) it is written symbol by symbol on their working tape beginning from the leftmost cell . during this process",
    "the working flag is set to 1 and remains to 1 when this process ends ( the agent may set it to 0 in future steps ) .",
    "when its working flag is set to 1 we can think of the agent working as a usual turing machine ( but it additionally writes the working flag ) .",
    "in particular , whenever the working flag is set to 1 the internal transition function @xmath45 is applied , the control unit reads the symbol under the head and its own state and updates its state and the symbol under the head , moves the head one step to the left or to the right and sets the working flag to 0 or 1 , according to the internal transition function .",
    "we assume that the set of states @xmath31 and the tape alphabet @xmath30 , are both sets whose size is fixed and independent of the population size ( i.e. @xmath46 ) , thus , there is , clearly , enough room in the memory of an agent to store both the internal and the external transition functions .    as it is common in the population protocol literature , a _",
    "fair adversary scheduler _ selects ordered pairs of agents ( edges from @xmath24 ) to interact .",
    "assume now that two agents @xmath47 and @xmath48 are about to interact with @xmath47 being the _ initiator _ of the interaction and @xmath48 being the _ responder_. let @xmath49 be a function returning the current value of each agent s working flag .",
    "if at least one of @xmath50 and @xmath51 is equal to @xmath41 , then nothing happens , because at least one agent is still working internally .",
    "otherwise ( @xmath52 ) , both agents are ready and an _ interaction _ is established . in the latter case ,",
    "the external transition function @xmath53 is applied , the states of the agents are updated accordingly , the message of the initiator is copied to the message tape of the responder ( replacing its contents ) and vice versa ( the real mechanism would require that each receives the other s message and then copies it to its memory , because instant replacement would make them lose their own message , but this can be easily implemented with @xmath39 extra cells of memory , so it is not an issue ) , and finally the working flags of both agents are again set to 1 .",
    "note that the assumption that the internal transition function @xmath45 is only applied when the working flag is set to 1 is weak .",
    "in fact , an equivalent way to model this is to assume that @xmath45 is of the form @xmath54 , that it is always applied , and that for all @xmath55 and @xmath56 , @xmath57 is satisfied , where @xmath58 means that the head `` stays put '' .",
    "the same holds for the assumptions that @xmath53 is not applied if at least one of the interacting agents is working internally and that the working flags are set to @xmath41 when some established interaction comes to an end ; it is equivalent to an extended @xmath53 of the form @xmath59 , that is applied in every interaction , and for which @xmath60 if @xmath61 or @xmath62 , and @xmath63 if @xmath64 , hold for all @xmath65 , and we could also have further extended @xmath53 to handle the exchange of messages , but for sake of simplicity we have decided to leave such details out of the model .",
    "since each agent is a tm ( of logarithmic memory ) , we use the notion of a configuration to capture its `` state '' .",
    "an _ agent configuration _ is a quadruple @xmath66 , where @xmath55 , @xmath67 , and @xmath68 .",
    "@xmath69 is the state of the control unit , @xmath70 is the string to the left of the head ( including the symbol scanned ) , @xmath71 is the string to the right of the head , and @xmath72 is the working flag indicating whether the agent is ready to interact ( @xmath73 ) or carrying out some internal computation ( @xmath74 ) . let @xmath75 be the set of all agent configurations . given two agent configurations @xmath76 , we say that @xmath77 _ yields _ @xmath78 if @xmath78 follows @xmath77 by a single application of @xmath45 .",
    "a _ population configuration _ is a mapping @xmath79 , specifying the agent configuration of each agent in the population .",
    "let @xmath80 , @xmath81 be population configurations and let @xmath82 .",
    "we say that @xmath80 _ yields _ @xmath81 via _ agent transition _ @xmath47 , denoted @xmath83 , if @xmath84 yields @xmath85 and @xmath86 , @xmath87 .",
    "let @xmath88 denote the state of an agent configuration @xmath77 , @xmath89 its string to the left of the head including the symbol under the head , @xmath90 its string to the right of the head , and @xmath91 its working flag . given two population configurations @xmath80 and @xmath81",
    ", we say that @xmath80 _ yields _ @xmath81 via _ encounter _",
    "@xmath92 , denoted @xmath93 , if one of the following two cases holds : + case 1 :    * @xmath94 which guarantees that both agents @xmath47 and @xmath48 are ready for interaction under the population configuration @xmath80 . *",
    "@xmath95 and @xmath96 are precisely the message strings of @xmath47 and @xmath48 , respectively ( this is a simplifying assumption stating that when an agent is ready to interact its head is over the last @xmath40 symbol , just before the message tape ) , * @xmath97 , * @xmath98 , and * @xmath86 , @xmath99 .",
    "case 2 :    * @xmath100 or @xmath101 , which means that at least one agent between @xmath47 and @xmath48 is working internally under the population configuration @xmath80 , and * @xmath102 , @xmath103 . in this case",
    "no effective interaction takes place , thus the population configuration remains the same .",
    "generally , we say that @xmath80 _ yields _ ( or _ can go in one step to _ ) @xmath81 , and write @xmath104 , if @xmath93 for some @xmath105 ( via encounter ) or @xmath106 for some @xmath82 ( via agent transition ) , or both .",
    "we say that @xmath81 is _ reachable _ from @xmath80 , and write @xmath107 if there is a sequence of population configurations @xmath108 such that @xmath109 holds for all @xmath110 .",
    "an _ execution _ is a finite or infinite sequence of population configurations @xmath111 , so that @xmath109 .",
    "an infinite execution is _ fair _ if for all population configurations @xmath80 ,",
    "@xmath81 such that @xmath104 , if @xmath80 appears infinitely often then so does @xmath81 .",
    "computation _ is an infinite fair execution .",
    "note that the paloma model _ preserves uniformity _ , because @xmath29 , @xmath30 and @xmath31 are all finite sets whose cardinality is independent of the population size .",
    "thus , protocol descriptions have also no dependence on the population size .",
    "moreover , paloma protocols are _ anonymous _ , since initially all agents are identical and have no unique identifiers .",
    "the predicates that we consider here are of the following form .",
    "the input to each agent is simply some string @xmath112 .",
    "an _ input assignment _",
    "@xmath113 is a mapping from @xmath23 to @xmath29 assigning an input string to each agent of the population .",
    "let @xmath114 be the set of all input assignments .",
    "any mapping @xmath115 is a _ predicate on input assignments_. a predicate on input assignments @xmath116 is called _ symmetric _ if for every @xmath117 and any @xmath118 which is a permutation of @xmath113 s components , it holds that @xmath119 ( in words , permuting the input strings does not affect the predicate s outcome ) .",
    "a population configuration @xmath80 is called _ output stable _ if for every configuration @xmath81 that is reachable from @xmath80 it holds that @xmath120 for all @xmath82 , where @xmath121 denotes the contents of the output tape of agent @xmath47 under configuration @xmath80 ( i.e. a string ) . in simple words ,",
    "no agent changes its output in any subsequent step and no matter how the computation proceeds . a predicate on input assignments",
    "@xmath116 is said to be _ stably computable _ by a paloma protocol @xmath26 if , for any input assignment @xmath113 , any computation of @xmath26 contains an output stable configuration in which all agents have @xmath122 written on their output tape .",
    "we say that a predicate on input assignments @xmath116 belongs to @xmath13 ( @xmath14 ) if there exists some deterministic ( nondeterministic , resp . ) tm that gets @xmath123 as input ( e.g. as a @xmath0-vector of input strings ) , if @xmath124 accepts and if @xmath125 rejects by using @xmath126 space .",
    "all agents are identical and do not initially have unique ids , thus , stably computable predicates by the paloma model on complete communication graphs have to be symmetric .",
    "let @xmath11 and @xmath12 be @xmath13 s and @xmath127 @xmath128 s restrictions to symmetric predicates , respectively .",
    "let @xmath1 denote the class of all symmetric predicates that are stably computable by the paloma model .",
    "our main result in this paper is the following exact characterization for @xmath1 : @xmath1 is equal to @xmath21 .",
    "we show here that there exist paloma protocols that stably compute the predicates @xmath129 ( @xmath130 denotes the number of agents with input @xmath69 ) and @xmath131 , where @xmath132 .",
    "+   + we begin by presenting a paloma protocol that stably computes the predicate @xmath129 ( on the complete communication graph of @xmath0 nodes ) that is , all agents eventually decide whether the number of @xmath133s in the input assignment is the product of the number of @xmath134s and the number of @xmath135s .",
    "we give a high - level description of the protocol .",
    "initially , all agents have one of @xmath134 , @xmath135 and @xmath133 written on the first cell of their working memory ( according to their sensed value ) .",
    "that is , the set of input strings is @xmath136 .",
    "each agent that receives input @xmath134 goes to state @xmath134 and becomes ready for interaction ( sets its working flag to 0 ) .",
    "agents in state @xmath134 and @xmath135 both do nothing when interacting with agents in state @xmath134 and agents in state @xmath135 .",
    "an agent in @xmath133 initially creates in its working memory three binary counters , the @xmath134-counter that counts the number of @xmath134s , the @xmath135-counter , and the @xmath133-counter , initializes the @xmath134 and @xmath135 counters to 0 , the @xmath133-counter to 1 , and becomes ready .",
    "when an agent in state @xmath134 interacts with an agent in state @xmath133 , @xmath134 becomes @xmath137 to indicate that the agent is now sleeping , and @xmath133 does the following ( in fact , we assume that @xmath133 goes to a special state @xmath138 in which it knows that it has seen an @xmath134 , and that all the following are done internally , after the interaction ; finally the agent restores its state to @xmath133 and becomes again ready for interaction ) : it increases its @xmath134-counter by one ( in binary ) , multiplies its @xmath134 and @xmath135 counters , which can be done in binary in logarithmic space ( binary multiplication is in @xmath139 ) , compares the result with the @xmath133-counter , copies the result of the comparison to its output tape , that is , 1 if they are equal and 0 otherwise , and finally it copies the comparison result and its three counters to the message tape and becomes ready for interaction .",
    "similar things happen when a @xmath135 meets a @xmath133 ( interchange the roles of @xmath134 and @xmath135 in the above discussion ) .",
    "when a @xmath133 meets a @xmath133 , the responder becomes @xmath140 and copies to its output tape the output bit contained in the initiator s message .",
    "the initiator remains to @xmath133 , adds the @xmath134-counter contained in the responder s message to its @xmath134-counter , the @xmath135 and @xmath133 counters of the message to its @xmath135 and @xmath133 counters , respectively , multiplies again the updated @xmath134 and @xmath135 counters , compares the result to its updated @xmath133 counter , stores the comparison result to its output and message tapes , copies its counters to its message tape and becomes ready again .",
    "when a @xmath137 , @xmath141 or @xmath140 meets a @xmath133 they only copy to their output tape the output bit contained in @xmath133 s message and become ready again ( eg @xmath137 remains @xmath137 ) , while @xmath133 does nothing .",
    "note that the number of @xmath133s is at most @xmath0 which means that the @xmath133-counter will become at most @xmath142 bits long , and the same holds for the @xmath134 and @xmath135 counters , so there is enough room in the tape of an agent to store them .",
    "the above paloma protocol stably computes the predicate @xmath129 .",
    "given a fair execution , eventually only one agent in state @xmath133 will remain , its @xmath134-counter will contain the total number of @xmath134s , its @xmath135-counter the total number of @xmath135s , and its @xmath133-counter the total number of @xmath133s . by executing the multiplication of the @xmath134 and @xmath135 counters and comparing the result to its @xmath133-counter",
    "it will correctly determine whether @xmath129 holds and it will store the correct result ( 0 or 1 ) to its output and message tapes .",
    "at that point all other agents will be in one of the states @xmath137 , @xmath141 , and @xmath140 .",
    "all these , again due to fairness , will eventually meet the unique agent in state @xmath133 and copy its correct output bit ( which they will find in the message they get from @xmath133 ) to their output tapes .",
    "thus , eventually all agents will output the correct value of the predicate .",
    "the paloma model is strictly stronger than the population protocol model .",
    "paloma simulates pp and stably computes @xmath129 which is non - semilinear .",
    "+   + we now present a paloma protocol that stably computes the predicate @xmath131 , where @xmath132 , on the complete communication graph of @xmath0 nodes , that is , all agents eventually decide whether the number of @xmath41s in the input assignment is a power of 2 .",
    "the set of input strings is @xmath143 .",
    "all agents that receive 1 create a binary @xmath41-counter to their working tape and initialize it to @xmath41 .",
    "moreover , they create a binary @xmath144 block and set it to @xmath145 .",
    "finally , they write 1 ( which is interpreted as `` true '' ) to their output tape , and copy the @xmath41-counter and the output bit to their message tape before going to state 1 and becoming ready .",
    "agents that receive input 0 write 0 ( which is interpreted as `` false '' ) to their output tape , go to state 0 , and become ready .",
    "agents in state 0 do nothing when interacting with each other . when an agent in state 0 interacts with an agent in state 1 , then 0 simply copies the output bit of 1 .",
    "when two agents in state 1 interact , then the following happen : the initiator sets its @xmath41-counter to the sum of the responder s @xmath41-counter and its own @xmath41-counter and compares its updated value to @xmath144 .",
    "if it is less than @xmath144 then it writes 0 to the output tape .",
    "if it is equal to @xmath144 it sets @xmath144 to @xmath146 and sets its output bit ( in the output tape ) to 1 .",
    "if it is greater than @xmath144 , then it starts doubling @xmath144 until @xmath41-counter @xmath147 is satisfied .",
    "if it is satisfied by equality , then it doubles @xmath144 one more time and writes 1 to the output tape . otherwise , it simply writes 0 to the output tape .",
    "another implementation would be to additionally send @xmath144 blocks via messages and make the initiator set @xmath144 to the maximum of its own and the responder s @xmath144 blocks . in this case at most one doubling would be required . finally , in both implementations , the initiator copies the output bit and the @xmath41-counter to its message tape ( in the second implementation it would also copy @xmath144 to the message tape ) , remains in state @xmath41 , and becomes ready .",
    "the responder simply goes to state @xmath148 and becomes ready .",
    "an agent in state @xmath148 does nothing when interacting with an agent in state 0 and vice versa . when an agent in state @xmath148 interacts with an agent in state 1 , then @xmath148 simply copies the output bit of 1 .",
    "note that @xmath144 can become at most 2 times the number of @xmath41s in the input assignment , and the latter is at most @xmath0 .",
    "thus , it requires at most @xmath149 bits of memory .",
    "either way , we can delay the multiplication until another 1 appears , in which case we need at most @xmath142 bits of memory for storing @xmath144 ( the last unnecessary multiplication will never be done ) .      the _ multiplicative integer input convention _",
    "assumes that upon initialization , each agent receives a value and a mark .",
    "an integer @xmath150 is retrieved by calculating the product @xmath151 of the @xmath152 values stored at different agents marked as @xmath113 . under this assumption",
    ", there is a simple way to compute the predicate @xmath153 .",
    "because the input convention matches the predicate operator , it is equivalent to compute the predicate @xmath154 instead .    upon initialization each agents",
    "is marked as either @xmath134 or @xmath135 and is assigned a value ( @xmath155 or @xmath156 ) .",
    "moreover , each agent maintains a @xmath157 variable indicating the correctness of the predicate .",
    "initially , @xmath158 for each agent .",
    "interactions between agents have the following effects :    @xmath159 : :    then @xmath160 and    @xmath161 . if after    this update @xmath162 then    @xmath163 .",
    "otherwise ,    @xmath164 @xmath165 : :    if either @xmath157 is set to @xmath166 then both    flags are set to @xmath166 .",
    "@xmath154 iff for each configuration @xmath80 there exist @xmath167 , @xmath168 such that @xmath169 or @xmath170    @xmath171 : :    assume on the contrary that there is no such pair and that there    exists a @xmath172 .",
    "then , @xmath173 ,    @xmath174 , @xmath175 are coprimes .",
    "there is a theorem    stating that if @xmath134 , @xmath176 are coprimes and    @xmath177 are coprimes , then @xmath178    are coprimes . applying this theorem inductively",
    "we can prove that    @xmath179 and @xmath175 are coprimes .",
    "then    @xmath180 is a multiple of @xmath175 , while    @xmath179 is not , thus @xmath179 and @xmath180    ca nt be equal .",
    "@xmath181 : :    if there exist @xmath167 , @xmath168 such that    @xmath169 or    @xmath170 , then we have successfully divided    @xmath179 , @xmath180 with the same divisor    @xmath182    until @xmath170 .",
    "the new integers    represented by the diffused @xmath41s are    @xmath183 , and since @xmath184 ,    we conclude that @xmath154 .",
    "@xmath154 iff eventually for each agent @xmath185 , @xmath186    if @xmath154 , then by the previous lemma @xmath169 or @xmath170 . in the second case",
    "there is nothing to prove . in the first case ,",
    "observe that each time @xmath169 a division takes place that will cut its operands at least in half .",
    "in discrete context , this sequence of divisions must end when @xmath170 .    if for each agent @xmath185 , @xmath186 then we have successfully divided @xmath179 , @xmath180 with the same divisor @xmath182 until @xmath170 .",
    "the new integers represented by the diffused @xmath41s are @xmath183 , and since @xmath184 , we conclude that @xmath154 .",
    "if @xmath154 , eventually each agent @xmath185 will set @xmath187 to @xmath188    if @xmath154 then by the previous lemma each agent @xmath185 will have @xmath186 . in that case , the @xmath189 between two values will always be @xmath41 , thus interactions between @xmath134s and @xmath135s will only generate @xmath188 values .",
    "due to fairness , during the execution a sequence of interactions will occur in which any @xmath190 or @xmath191 interaction that would generate @xmath166 values can be delayed so that the participant @xmath185 will first interact with an agent @xmath192 .",
    "this interaction will force @xmath193 to @xmath188 thus when the @xmath194 interaction eventually takes place no @xmath166 values are present",
    "so no @xmath166 values are generated .    if @xmath195 , eventually each agent @xmath185 will set @xmath187 to @xmath166    by a previous lemma we know that if @xmath195 then there exists an agent @xmath175 that its value will get permanent and different from @xmath41 .",
    "due to fairness , at some point all @xmath167 agents will consecutively interact with @xmath175 and set their flags to @xmath166 .",
    "then it is easy to observe that in any interaction that will follow , no @xmath188 value will be assigned to any @xmath157 .",
    "this protocol is quite inefficient as convergence is guaranteed only when a specific sequence of @xmath0 interactions takes place .",
    "we can probably optimize it but that would make it more complex . finally , notice the absence of memory assumptions .",
    "indeed , the interactions are so straightforward that this protocol is applicable even to the pp model .",
    "we prove now that if the agents know the population size @xmath0 then any symmetric predicate in @xmath3 is stably computable by the paloma model when the communication graph is directed and complete .",
    "[ lem : ids ] if a paloma protocol knows the population size @xmath0 then it can assign to the agents the unique ids @xmath196 and , moreover , all agents will eventually know that the process has terminated .",
    "note that @xmath0 can be stored with @xmath142 bits , thus we assume w.l.o.g . that it is already stored in some block of the agents working memories ( e.g. we can assume that @xmath197 and @xmath198 , where @xmath199 denotes the binary string representation of @xmath0 , thus all agents get @xmath199 as their input ) .",
    "all agents initialize an i d to 0 in their working memory , copy it to their message memory , remain to state @xmath43 , and become ready .",
    "when two agents interact , the external transition function alters their states in order to inform the initiator that it was the initiator and the responder that it was the responder ( e.g. the rule @xmath200 suffices ) . after the interaction ,",
    "the initiator compares its i d to the received i d ( that of the responder ) , and if they are equal it increases its own i d by one . if its updated i d is less than @xmath201 , it copies it in the message tape , goes to @xmath43 again and becomes ready .",
    "if it is equal to @xmath201 it goes to @xmath202 and becomes ready .",
    "@xmath202 is then eventually propagated to the whole population because @xmath203 and @xmath204 holds , and all agents are informed that the process has been competed successfully .",
    "the responder simply restores its message tape to contain again only its own i d ( if we assume that its own message is not lost then this step is not necessary , but both ways are equivalent ) goes again to @xmath43 and becomes ready .",
    "we claim that the above process is correct .",
    "each agent s i d can only be incremented .",
    "moreover , an i d that has appeared in the population can never be completely eliminated ( it is only incremented when sure that it also exists in another agent ) . as long as i d",
    "@xmath201 has not appeared , by the pigeonhole principle , there will be at least two agents with the same i d .",
    "thus , eventually ( in a finite number of steps ) , two such agents will interact and one of them will increase its counter by one . clearly , the above process must end in a finite number of steps with an agent having i d @xmath201 .",
    "when this happens , the agents are assigned the unique ids @xmath196 .",
    "if not , then at least one i d @xmath205 is missing from the population .",
    "but @xmath185 should have appeared because then @xmath201 could not have been reached .",
    "but this is a contradiction , because once an i d appears then it can never be completely eliminated .",
    "let _ ppaloma _ ( ` p ' standing for `` population size '' ) be the extension of paloma in which each agent knows the population size ( it can read it from a read - only block of its memory ) .",
    "let @xmath206 denote the class of all symmetric predicates that are stably computable by some ppaloma protocol .",
    "[ the : psize ] @xmath18 is a subset of @xmath206 .",
    "let @xmath207 be any predicate in @xmath18 and @xmath208 be the deterministic tm that decides @xmath116 by using @xmath2 space .",
    "we construct a ppaloma protocol @xmath26 that stably computes @xmath116 by exploiting its knowledge of the population size .",
    "let @xmath113 be any input assignment in @xmath209 .",
    "each agent receives its input string according to @xmath113 ( e.g. @xmath47 receives string @xmath210 ) .",
    "now the agents obtain unique ids according to the protocol presented in the proof of lemma [ lem : ids ] .",
    "the agent that has obtained the unique i d @xmath201 starts simulating @xmath208 .",
    "if at some point the transition function of @xmath208 moves the head to the right , but the agent s working memory has no other symbol to read ( e.g. it reads @xmath44 ) , then it writes @xmath211 and @xmath208 s current state to its message tape and becomes ready . when the unique agent with i d @xmath211 interacts with an agent that has @xmath211 in its message tape , it starts simulating @xmath208 by putting the head over the first symbol in its working tape and assuming that the state of @xmath208 is the state that it found written on the message it received . generally , whenever an agent with i d @xmath212 can not continue simulating @xmath208 to the right it passes control to the agent with i d @xmath213 .",
    "additionally , if an agent with i d @xmath214 that simulates @xmath208 ever reaches its leftmost cell and the transition function of @xmath208 wants to move the head left , then it informs agent with i d @xmath215 to continue the simulation ( when they , eventually , interact ) .",
    "note now , that at some point @xmath208 may want to use its ( initially ) blank cells to write symbols .",
    "this is handled by @xmath26 in the following manner . @xmath26",
    "first starts using the blank cells of the agent with i d 0 .",
    "if more are needed , it goes to agent @xmath201 , writes a separator to the first blank cell ( naturally we can assume that the separator is already there from @xmath26 s initialization step , because also @xmath208 uses separators , like  , s , between the different inputs of the symmetric predicate ) and starts using those blank cells .",
    "then it can use those of @xmath216 and so on until the last blank cell of agent with i d @xmath41 .",
    "in fact , in this approach the distributed memory of @xmath208 can be read by beginning from agent @xmath201 and reading all blocks ( the parts of the working memories that are used for the simulation ) before the separators until agent @xmath41 .",
    "then we read the whole simulation block of agent 0 , proceed with the simulation block after the separator of agent @xmath201 and continue with those blocks ( after the separator ) of all agents until agent with i d 1 .",
    "thus , the memory is read in a cyclic fashion .",
    "another approach would be , to initially transfer ( shift ) the concatenation of all agents inputs ( separated by some symbol , e.g. ` , ' ) to agents @xmath217 .",
    "now , the first @xmath218 agents will contain input data , agent with i d @xmath219 will probably also have some blank cells and the remaining agents will contain only blank cells . in this case , simulation starts from agent @xmath42 and @xmath208 s tape can be read sequentially from agent @xmath42 to agent @xmath201 .",
    "whenever , during the simulation , @xmath208 accepts , then @xmath26 also accepts ; that is , the agent that detects @xmath208 s acceptance , writes 1 to its output tape and informs all agents to accept .",
    "if @xmath208 rejects , it also rejects . finally , note that @xmath26 simulates",
    "@xmath208 not necessarily on input @xmath220 but on some @xmath118 which is a permutation of @xmath113 . the crucial remark that completes the proof is that @xmath208 accepts @xmath113 if and only if it accepts @xmath118 , because @xmath116 is symmetric .",
    "in this section , we first prove that paloma protocols can assume the existence of unique consecutive ids and knowledge of the population size .",
    "in particular , in theorem [ the : iplm ] we prove that any paloma protocol that assumes the existence of unique consecutive ids and knows the population size , can be composed with a paloma protocol that correctly assigns these unique ids to the agents and informs them of the correct population size , without assuming any initial knowledge of none of them .",
    "we then exploit this result to obtain a first lower bound for @xmath1 .",
    "let _ ipaloma _ ( ` i ' standing for `` ids '' ) be the extension of paloma in which the agents have additionally the read - only unique ids @xmath221 and in which each agent knows the population size ( it can read it from a read - only block of its memory ) .",
    "let @xmath16 denote the class of all symmetric predicates that are stably computable by the ipaloma model .",
    "[ the : iplm ] @xmath17",
    ".    _ intuitive proof argument_. to simplify reading the formal proof that follows , we first give an intuitive description .",
    "the hard part is @xmath222 .",
    "the idea is to show that there exists a paloma protocol @xmath223 that assigns unique consecutive ids and informs all agents of the correct population size , although initially all agents have the same i d and know the same , wrong , population size , which are both equal to zero .",
    "then any ipaloma protocol @xmath26 , running as a subroutine , can use those data provided by @xmath223 in order to be correctly executed .",
    "@xmath223 operates as follows .",
    "whenever two agents with the same i d interact , one of them increases its i d by one and the other keeps its i d .",
    "moreover , they now both think that the correct population size is equal to the updated i d plus one . by using some arguments similar to those in lemma [ lem : ids ] , it is not so hard to show that this process correctly assigns the unique ids @xmath15 ( in a finite number of steps , and due to fairness ) .",
    "in fact , it always first assigns the ids @xmath224 and the last interaction that modifies some i d will always be between some agents @xmath47 and @xmath48 that both have the i d @xmath211 .",
    "these now obtain the ids @xmath201 and @xmath211 , respectively , and are the only agents that know the correct population size .    of course , @xmath223 can not detect termination of the id - assignment process , because , otherwise , it is easy to show that it would wrongly detect termination in some component with @xmath225 agents that does not interact with the rest population for a long period of time ( it would be possible that the ids @xmath226 would have been assigned in this component and then those agents would have committed an erroneous termination ) .",
    "to overcome this fact , we do not wait for some termination criterion to be satisfied before executing @xmath26 .",
    "@xmath223 allows @xmath26 to be executed even while the ids are still totaly wrong .",
    "the trick is that , whenever some i d is incremented , @xmath223 knows that @xmath26 was running up to this point without unique ids , and with a wrong population size . by exploiting this knowledge ,",
    "we make @xmath223 at this point reinitialize all agents ( restores the input and erases all data produced by @xmath26 , without altering the ids ) and inform them of the new population size with the hope that now the id - assignment process has come to an end .",
    "note that the reinitialization process will be executed @xmath227 times , until the ids stabilize , because this is the number of times that some i d is incremented .",
    "but when the last id - modification takes place , all agents have the correct unique consecutive ids and two agents @xmath47 , @xmath48 know the correct population size .",
    "thus , if @xmath223 does the above correctly , the population size will be now propagated to all agents and all of them will start executing @xmath26 from the beginning . since @xmath26 now reads the correct ids and the correct population size , it will run correctly , like if the id - assignment process had never taken place , and although it was several times running in a wrong manner .",
    "we will also have to guarantee that @xmath223 does not allow reinitialized agents to have some effective interaction ( subroutine @xmath26 gets executed ) with agents that have not yet been reinitialized , because , otherwise , possibly outdated data of @xmath26 would get mixed with those of the restored correct execution . finally , we always execute @xmath26 for a constant number of steps , because in previous wrong rounds it is possible that conflict of inconsistent data takes place ( e.g. two agents have consecutive ids but have obtained them in different components ) , and this could make some machine fall into some infinite loop , and , thus , stop interacting ( always busy ) .",
    "@xmath228 holds trivially ( ipaloma is paloma with extra capabilities ) , so it suffices to show that @xmath222 .",
    "the rest of the proof is structured in four technical lemmata , which follow , each with its own proof .",
    "we do this for sake of clarity and readability .",
    "pick any @xmath229 .",
    "let @xmath26 be the ipaloma protocol that stably computes it .",
    "we present a paloma protocol @xmath75 that stably computes @xmath116 .",
    "@xmath75 consists of a procedure @xmath223 containing protocol @xmath26 as a subroutine ( see protocol [ prot : ids ] ) .",
    "@xmath223 is always executed and its job is to assign unique ids to the agents , to inform them of the correct population size and to control @xmath26 s execution ( e.g. restarts its execution if needed ) .",
    "@xmath26 , when @xmath223 allows its execution and for as many steps as it allows , simply reads the unique ids and the population size provided by @xmath223 and executes itself normally .",
    "we first describe @xmath223 s functionality and then prove that it eventually correctly assigns unique ids and correctly informs the agents of the population size , and that when this process comes to a successful end , it restarts @xmath26 s execution in all agents without allowing non - reinitialized agents to communicate with the reinitialized ones .",
    "thus , at some point , @xmath26 will begin its execution reading the correct unique ids and the correct population size ( provided by @xmath223 ) , thus , it will get correctly executed and will stably compute @xmath116 .",
    "we begin by describing @xmath223 s variables .",
    "@xmath230 is the variable storing the i d of the agent ( from which @xmath26 reads the agents ids ) , @xmath231 the variable storing the @xmath230 that an agent writes in the message tape in order to send it , and @xmath232 the variable storing the @xmath230 that an agent receives via interaction . in order to simplify code",
    "we make a convention .",
    "we assume that all variables used for sending information , like @xmath231 , preserve their value in future interactions unless altered by the agent .",
    "initially , @xmath233 for all agents .",
    "all agents have an input backup variable @xmath234 which they initially set to their input string and make it read - only .",
    "thus , each agent has always available its input via @xmath234 even if the computation has proceeded .",
    "@xmath235 represents the block of the working tape that @xmath26 uses for its computation and @xmath236 represents the contents of the output tape .",
    "@xmath237 is a binary flag that after every interaction becomes true if the agent was the initiator of the interaction and false otherwise ( this is easily implemented by exploiting the external transition function ) .",
    "@xmath238 is the variable storing the population size , @xmath239 the one used to put it in a message , and @xmath240 the received one .",
    "initially , @xmath241 .",
    "@xmath242 contains the i d that the agent is searching for to interact with , and @xmath243 , @xmath244 are defined similarly as before .",
    "@xmath242 and @xmath243 are initially equal to @xmath245 which means _ not searching _ ; the value @xmath246 is interpreted as _",
    "waiting_.    @xmath247 , @xmath248 @xmath249 , @xmath250 @xmath251 , @xmath252 @xmath253 , @xmath254 @xmath255 , @xmath252 @xmath256 , @xmath257 @xmath256 , @xmath257 @xmath258 , @xmath259 @xmath26 for @xmath260 steps ignoring the received data @xmath261 , @xmath262 @xmath263 , @xmath252 @xmath26 for @xmath260 steps @xmath264 , @xmath265 @xmath26 for @xmath260 steps ignoring the received data @xmath26 for @xmath260 steps @xmath26 for @xmath260 steps    [ lem : ids1 ] ( i ) @xmath223 assigns the ids @xmath15 in a finite number of steps .",
    "( ii ) the id - assignment process ends with an interaction @xmath266 of two agents @xmath47 and @xmath48 that both have the i d @xmath211 .",
    "( iii ) this is the last interaction that modifies some agent s i d .",
    "( iv ) when this interaction happens , @xmath47 and @xmath48 know @xmath0 and all other agents know a population size that is strictly smaller than @xmath0 .",
    "\\(i ) initially , all agents have the i d @xmath42",
    ". each agent s i d can only be incremented .",
    "moreover , an i d that has appeared in the population can never be completely eliminated ( it is only incremented when sure that it also exists in another agent ) . as long as i d",
    "@xmath201 has not appeared , by the pigeonhole principle , there will be at least two agents with the same i d .",
    "thus , eventually ( in a finite number of steps ) , due to fairness , two such agents will interact and one of them will increase its i d by one .",
    "clearly , the above process must end in a finite number of steps with an agent having i d @xmath201 .",
    "when this happens , the agents are assigned the unique ids @xmath15 .",
    "if not , then at least one i d @xmath205 is missing from the population .",
    "but @xmath185 should have appeared because then @xmath201 could not have been reached .",
    "but this is a contradiction , because once an i d appears then it can never be completely eliminated .",
    "\\(ii ) assume not .",
    "then it must end by some interaction between two agents @xmath47 and @xmath48 that both have the same i d @xmath267 .",
    "after the interaction , @xmath47 has the i d @xmath268 , @xmath48 the i d @xmath185 , and the agents in general have the uids @xmath15 .",
    "this implies that i d @xmath268 did not exist in the population just before this interaction .",
    "but for @xmath201 to exist it must be the case that @xmath269 had appeared at some point .",
    "but then it could have never been completely eliminated , which is a contradiction .",
    "\\(iii ) just after the unique consecutive ids @xmath15 have been assigned , no agents have the same i d .",
    "ids are only modified when two agents with the same i d interact .",
    "thus , no agent will again change its i d in all subsequent steps .",
    "\\(iv ) @xmath47 and @xmath48 obviously know @xmath0 after their interaction ( that terminates the id - assignment process ) , because @xmath47 , that sets @xmath270 , sets @xmath238 equal to @xmath271 , and @xmath48 that keeps its i d ( that is , it still has @xmath272 ) , sets @xmath273 . at the same time , for all other agents @xmath274 , it holds that their @xmath238 variables contain a value less than @xmath0 , because , if not , then there should be an agent other than @xmath47 with i d @xmath201 which is impossible ( due to the correctness of the id - assignment process ) .",
    "[ lem : ids2 ] after the last id - modification has taken place ( via interaction @xmath266 ) , all agents , one after the other , get informed of the correct population size . the propagation of the population size is done clockwise on the virtual ring @xmath275 .",
    "whenever , after the unique consecutive ids have been correctly assigned , some agent @xmath185 propagates the population size to agent @xmath268 , @xmath185 becomes reinitialized and can not become reinitialized again in the future .    during the last id - modification",
    ", @xmath47 increases its i d to @xmath201 while , on the other hand , the responder @xmath48 keeps its i d to @xmath211 .",
    "now , all agents have been assigned the correct unique ids @xmath15 and , according to lemma [ lem : ids1 ] , no agent can again alter the value of its @xmath230 variable .",
    "we can , thus , from now on call the agents by their ids .",
    "agent @xmath201 ( which is agent @xmath47 , with i d @xmath201 ) sets both variables @xmath242 and @xmath243 to @xmath42 meaning that it may now only interact with agent @xmath42 ; all other interactions that may happen until it meets agent @xmath42 , simply have no effect .",
    "agent @xmath211 ( that is , @xmath48 ) sets those variables to @xmath246 , that is , it is _ waiting _ for a specific interaction ( which will be explained later on )",
    ". finally , both set @xmath238 and @xmath239 to the correct population size @xmath0 , restore @xmath26 s working blocks to the respective input strings ( by executing @xmath256 ) , and clear their output tapes ( denoted by @xmath257 in the code ) .",
    "moreover , from now on , an agent with i d @xmath218 other than @xmath201 and @xmath211 can only set @xmath238 to @xmath0 if it interacts with agent @xmath219 ( if @xmath276 , @xmath219 is defined to be @xmath201 ) and if @xmath219 already knows that the population size is @xmath0 .",
    "as we have already shown in lemma [ lem : ids1 ] , only agents @xmath211 and @xmath201 know that the population size is @xmath0 . all interactions between agent @xmath211 and some other agent @xmath277 have no effect , except for the case in which @xmath277 s i d is @xmath278 and it has already obtained @xmath0 .",
    "thus , @xmath211 can not inform any agent of the population size and @xmath0 can not be propagated _",
    "counterclockwise_. moreover , agent @xmath201 can only propagate @xmath0 to agent @xmath42 , @xmath42 to @xmath41 , and so on , which implies that the agents can only learn @xmath0 via _ clockwise _ propagation .",
    "we next show that this is what eventually happens .",
    "eventually , in a fair execution , agent @xmath201 will interact with agent @xmath42 .",
    "when this happens , agent @xmath201 has just found the agent that it was searching for , thus it sets @xmath242 and @xmath243 to @xmath245 meaning that from now on it is not searching for any agent and executes @xmath26 for @xmath260 steps while ignoring any received data .",
    "the reason for executing @xmath26 for a fixed number of steps will be explained in the sequel .",
    "what is of interest here , is that @xmath223 now , in fact , has correctly reinitialized @xmath26 s execution on agent @xmath201 , as if the whole id - assignment process had never been executed .",
    "the reason is that @xmath26 can now read the correct @xmath230 and the correct population size , the working block simply contains the agent s input string , the output tape is empty , and all received data during the interaction have been ignored .",
    "now , agent @xmath42 realizes that the other agent was searching for it ( i.e. @xmath279 is _ true _ )",
    "so it _ resets itself _ ( executes @xmath256 and @xmath257 ) and , since @xmath280 is _ true _ ( because , as we have already shown , all agents except for @xmath211 and @xmath201 still know a population size that is strictly smaller than @xmath0 ) , it sets @xmath242 and @xmath243 to @xmath41 ( now searching for agent @xmath41 to forward its knowledge ) .",
    "finally , it sets @xmath238 and @xmath239 to the correct population size , received from agent s @xmath201 message .",
    "it is easy to see that this process is continued until agent @xmath211 interacts with agent @xmath278 and the latter knows the correct population size . at this point , both set @xmath242 and @xmath243 to @xmath245 and both execute @xmath26 for @xmath260 steps while ignoring any received data , thus now all agents have been correctly reinitialized .",
    "finally , it is easy to see that no agent may be reinitialized again in future steps .",
    "the reason is that ids wo nt change and , moreover , no agent will alter its @xmath242 variable ( all agents will forever keep it to @xmath245 ) , thus , the code lines that reset @xmath26 s data can not be executed again in the future .    in the following lemma",
    ", we call an interaction _ effective _ if protocol @xmath26 is executed in at least one of the participating agents .",
    "[ lem : ids3 ] after the unique consecutive ids @xmath15 have been assigned , agents that have reinitialized themselves can only have _ effective interactions _ with each other , that is , when they interact with each other @xmath26 is executed , while , on the other hand , their interactions with non - reinitialized agents have no effect w.r.t . to @xmath26 s execution .",
    "after the unique ids have been successfully assigned , it is like the population is partitioned in two non - communicating classes , the class @xmath281 of _ reinitialized _ agents and @xmath282 of the _ non - reinitialized _ ones .",
    "initially ( just after the unique ids have been successfully assigned ) , @xmath283 and @xmath284 , that is , all agents are considered as non - reinitialized .",
    "an agent @xmath285 moves from @xmath282 to @xmath281 iff it interacts with the next agent @xmath268 on the virtual ring @xmath275 and @xmath185 already knows the correct population size @xmath0 ; the only agents that initially know the correct population size are @xmath211 and @xmath201 . @xmath278 and @xmath211 will be the last agents to move from @xmath282 to @xmath281 as we have already shown in the proof of lemma [ lem : ids2 ] , and from that point on it will hold that @xmath286 and @xmath287 .",
    "now , for any intermediate step , let @xmath288 and @xmath289 , where @xmath290 and @xmath291 be the interacting agents .",
    "there are three cases :    1 .",
    "@xmath292 ( for @xmath293 , @xmath185 is 0 ) : due to the clockwise propagation of the reinitializations this can only happen if @xmath294 and @xmath295 .",
    "but @xmath296 implies that @xmath211 is still waiting ( to interact with @xmath278 which is still in @xmath282 ) , thus , this interaction has no effect .",
    "2 .   @xmath297 ( for @xmath298 , @xmath185 is @xmath201 ) : @xmath288 implies that @xmath299 already knows the correct population size .",
    "but since @xmath289 , @xmath299 is still searching for @xmath215 to propagate its knowledge , implying that this interaction has also no effect .",
    "@xmath300 and @xmath301 : assume that an effective interaction takes place .",
    "this implies ( line @xmath302 in protocol [ prot : ids ] ) that both know the same population size and both have @xmath303 .",
    "but @xmath288 which implies that they both know that the population size is @xmath0 . since @xmath299 is non - reinitialized but knows the correct population size , either it is agent @xmath211 , in which case it has @xmath304 , or it has @xmath305 (",
    "because , due to the clockwise propagation of the population size , it has learned the correct population size from @xmath306 but has not yet found @xmath215 to propagate it ) . in both cases",
    "we have a contradiction because @xmath299 should have @xmath303 according to our assumption .",
    "thus , again here , no effective interaction can take place .",
    "obviously , @xmath26 is always executed when two agents in @xmath281 interact , because they both have @xmath303 and know the same , correct , population size ( to get convinced , inspect @xmath223 s code ) .",
    "[ lem : ids4 ] no agent ever falls into some infinite loop .",
    "it is easy to see that @xmath223 , except for calling @xmath26 , only performs some variable assignments , which can not lead into some infinite loop .",
    "but while the correct ids have not yet been assigned to the agents , some interacting agents may contain inconsistent data , which could make subroutine @xmath26 fall into some infinite loop . by always executing @xmath26 for a constant number of steps we guarantee that it wo nt . in fact ,",
    "we guarantee that no agent can become busy for an infinite number of steps , because this would disable @xmath223 s capability to reinitialize it , if needed .",
    "we can now conclude by combining the above lemmata .",
    "we have shown that @xmath75 , by using @xmath223 , correctly assigns the unique consecutive ids @xmath15 to the agents ( lemma [ lem : ids1 ] ) and informs them of the correct population size ( lemma [ lem : ids2 ] ) .",
    "then each agent that propagates the population size , to the next one in the clockwise direction , becomes reinitialized , in the sense that it starts executing @xmath26 from the beginning and can not get reinitialized again in future steps ( lemma [ lem : ids2 ] ) . during this propagation process",
    ", @xmath75 does not allow non - reinitialized agents , that possibly contain outdated information , to have some effective interaction with reinitialized agents ( lemma [ lem : ids3 ] ) . finally , due to the intermittent execution of @xmath26 ,",
    "no agent could have ever become busy for an infinite number of steps , thus , it is guaranteed that the reinitializations can always be applied ( lemma [ lem : ids4 ] ) .",
    "since @xmath26 stably computes @xmath116 , the same holds for @xmath75 , that correctly simulates @xmath26 , and the theorem follows .",
    "we now show that any symmetric predicate in @xmath3 also belongs to @xmath16 .",
    "[ the : lowiplm ] @xmath18 is a subset of @xmath16 .    _ proof sketch_. the ipaloma model simulates a deterministic tm @xmath208 of @xmath2 space . initially the agents shift all the non - blank contents ( input strings ) to the left in the agent chain @xmath221 , until their collective memory looks like that of @xmath208 ( input symbols to the left and blank cells to the right in the chain ) .",
    "then , agent 0 starts simulating @xmath208 and when it has no other memory to read to the right it passes @xmath208 s control to agent 1 , and so on . whenever @xmath208 accepts ( or rejects ) , output @xmath41 ( @xmath42 resp . )",
    "is propagated to all agents .",
    "let @xmath207 be any predicate in @xmath18 and @xmath208 be the deterministic tm that decides @xmath116 by using @xmath2 space .",
    "we construct an ipaloma protocol @xmath26 that stably computes @xmath116 .",
    "let @xmath113 be any input assignment in @xmath209 .",
    "each agent receives its input string according to @xmath113 ( e.g. @xmath47 receives string @xmath210 ) .",
    "the agents have the unique ids @xmath15 and know the population size @xmath0 .",
    "the agent that has the unique i d @xmath42 starts simulating @xmath208 .",
    "if at some point the transition function of @xmath208 moves the head to the right , but the agent s working memory has no other symbol to read ( e.g. it reads @xmath44 ) , then it writes @xmath41 and @xmath208 s current state to its message tape and becomes ready . when the unique agent with i d @xmath41 interacts with an agent that has @xmath41 written in its message tape , it starts simulating @xmath208 by putting the head over the first symbol in its working tape and assuming that the state of @xmath208 is the state that it found written on the message it received .",
    "generally , whenever an agent with i d @xmath307 can not continue simulating @xmath208 to the right , it passes control to the agent with i d @xmath268 .",
    "additionally , if an agent with i d @xmath308 that simulates @xmath208 ever reaches its leftmost cell and the transition function of @xmath208 wants to move the head left , then it informs agent with i d @xmath306 to continue the simulation from its last non - blank cell ( when they , eventually , interact ) .",
    "note now , that at some point @xmath208 may want to use its ( initially ) blank cells to write symbols .",
    "this is handled by @xmath26 in the following manner . @xmath26",
    "first starts using the blank cells of the agent with i d @xmath201 .",
    "if more are needed , it goes to agent @xmath42 , writes a separator to the first blank cell ( naturally we can assume that the separator is already there from @xmath26 s initialization step , because also @xmath208 uses separators , like  , s , between the different inputs of the symmetric predicate ) and starts using those blank cells .",
    "then it can use those of @xmath309 and so on until the last blank cell of agent with i d @xmath211 .",
    "in fact , in this approach the distributed memory of @xmath208 can be read by beginning from agent @xmath42 and reading all blocks ( the parts of the working memories that are used for the simulation ) before the separators until agent @xmath211 .",
    "then we read the whole simulation block of agent @xmath201 , proceed with the simulation block after the separator of agent @xmath42 and continue with those blocks ( after the separator ) of all agents until agent with i d @xmath211 .",
    "thus , the memory is read in a cyclic fashion .",
    "another approach would be , to initially transfer ( shift ) the concatenation of all agents inputs ( separated by some symbol , e.g. ` , ' ) to agents @xmath217 .",
    "now , the first @xmath218 agents will contain input data , agent with i d @xmath219 will probably also have some blank cells and the remaining agents will contain only blank cells . in this case , the simulation starts again from agent @xmath42 , but now @xmath208 s tape can be read sequentially from agent @xmath42 to agent @xmath201 .",
    "whenever , during the simulation , @xmath208 accepts , then @xmath26 also accepts ; that is , the agent that detects @xmath208 s acceptance , writes 1 to its output tape and informs all agents to accept .",
    "if @xmath208 rejects , it also rejects . finally , note that @xmath26 simulates",
    "@xmath208 not necessarily on input @xmath310 but on some @xmath118 which is a permutation of @xmath113 .",
    "the reason is that agent with i d @xmath185 does not necessarily obtain @xmath311 as its input .",
    "the crucial remark that completes the proof is that @xmath208 accepts @xmath113 if and only if it accepts @xmath118 , because @xmath116 is symmetric .",
    "[ the : spnlogn ] @xmath18 is a subset of @xmath1",
    ".    follows from @xmath19 @xmath16 @xmath312 .",
    "( moreover , by savitch s theorem @xcite , we have that @xmath313 is a subset of @xmath1 . )",
    "here , we show that the paloma model simulates the community protocol model .",
    "this establishes that @xmath21 is a lower bound for @xmath1 , thus , improving that of theorem [ the : spnlogn ] .",
    "let @xmath314 denote the class of all symmetric predicates that are stably computable by the community protocol model .",
    "it was shown in @xcite that @xmath314 is equal to @xmath21 .",
    "let @xmath315 denote the class of all symmetric predicates that are stably computable by a restricted version of the community protocol model in which the agents can only have the unique ids @xmath15 .",
    "we first show that the community protocol model that is restricted in the above fashion is equivalent to the community protocol model .",
    "@xmath316 .",
    "@xmath317 holds trivially .",
    "it remains to show that @xmath318 .",
    "since the community protocol model can only perform comparisons on ids , it follows that if we replace any vector of unique ids @xmath319 indexed by agents , where @xmath320 , by the unique ids @xmath321 ( thus preserving the ordering of the agents w.r.t .",
    "their ids ) then the resulting computations in both cases must be identical .    @xmath315 is a subset of @xmath16 .",
    "paloma protocols that already have the unique ids @xmath15 and know the population size can do whatever community protocols that have the same unique ids can , and additionally can perform operations on ids ( they can store them in the agents memories and perform some internal computation on them ) .",
    "since , according to theorem [ the : iplm ] , @xmath16 is equal to @xmath1 , we have arrived to the following result .    [",
    "the : cp - plm ] @xmath314 is a subset of @xmath1",
    ".    follows from @xmath322 .",
    "[ the : comm ] @xmath21 is a subset of @xmath1 .",
    "@xmath21 is a subset of @xmath314 @xcite and then we take into account theorem [ the : cp - plm ] .      note",
    "that the proof of theorem [ the : comm ] depends on the following result of @xcite : a storage modification machine can simulate a turing machine .",
    "the reason is that @xcite provided an indirect proof of the fact that @xmath21 is a subset of @xmath314 . in particular",
    ", it was proven that community protocols can simulate a storage modification machine and then the result of @xcite was used to establish that community protocols can simulate a nondeterministic tm . here , and",
    "in order to avoid this dependence , we generalize the ideas used in the proof of theorem [ the : iplm ] and provide a direct simulation of a nondeterministic tm of @xmath2 space by the paloma model , thus , providing an alternative proof for theorem [ the : comm ] .",
    "[ the : lowplm ] @xmath21 is a subset of @xmath1 .    by considering theorem [ the : iplm ] , it suffices to show that @xmath21 is a subset of @xmath16 .",
    "we have already shown that @xmath323 can simulate a deterministic tm @xmath208 of @xmath2 space ( theorem [ the : lowiplm ] ) .",
    "we now present some modifications that will allow us to simulate a nondeterministic tm @xmath324 of the same memory size .",
    "keep in mind that @xmath324 is a decider for some predicate in @xmath21 , thus , it always halts .",
    "upon initialization , each agent enters a reject state ( writes @xmath42 to its output tape ) and the simulation is carried out as in the case of @xmath208 .",
    "whenever a nondeterministic choice has to be made , the corresponding agent gets ready and waits for participating in an interaction .",
    "the i d of the other participant will provide the nondeterministic choice to be made .",
    "one possible implementation of this idea is the following .",
    "since there is a fixed upper bound on the number of nondeterministic choices ( independent of the population size ) , the agents can store them in their memories .",
    "any time a nondeterministic choice has to be made between @xmath218 candidates the agent assigns the numbers @xmath325 to those candidates and becomes ready for interaction . assume that the next interaction is with an agent whose i d is @xmath185 .",
    "then the nondeterministic choice selected by the agent is the one that has been assigned the number @xmath326 .",
    "fairness guarantees that , in this manner , all possible paths in the tree representing @xmath324 s nondeterministic computation will eventually be followed .",
    "any time the simulation reaches an accept state , all agents change their output to 1 and the simulation halts . moreover , any time the simulation reaches a reject state , it is being re - initiated .",
    "the correctness of the above procedure is captured by the following two cases .    1 .   _",
    "if @xmath324 rejects then every agent s output stabilizes to @xmath42_. upon initialization , each agent s output is @xmath42 and can only change if @xmath324 reaches an accept state . but all branches of @xmath324 s computation reject , thus , no accept state is ever reached , and every agent s output forever remains to @xmath42 .",
    "if @xmath324 accepts then every agent s output stabilizes to @xmath41_. since @xmath324 accepts , there is a sequence of configurations @xmath58 , starting from the initial configuration @xmath80 that leads to a configuration @xmath81 in which each agent s output is set to @xmath41 ( by simulating directly the branch of @xmath324 that accepts ) .",
    "notice that when an agent sets its output to @xmath41 it never alters its output tape again , so it suffices to show that the simulation will eventually reach @xmath81 .",
    "assume on the contrary that it does nt .",
    "since @xmath324 always halts the simulation will be at the initial configuration @xmath80 infinitely many times .",
    "due to fairness , by an easy induction on the configurations of @xmath58 , @xmath81 will also appear infinitely many times , which leads to a contradiction .",
    "thus the simulation will eventually reach @xmath81 and the output will stabilize to @xmath41 .    note , also , that we have just provided an alternative way to prove theorem [ the : cp - plm ] .",
    "it is known @xcite that a nondeterministic tm of space @xmath2 can simulate the community protocol model .",
    "but , according to theorem [ the : lowplm ] , the paloma model can simulate such a tm , thus , it can indirectly simulate the community protocol model .",
    "+   + here , we generalize the preceding ideas to nondeterministic _ recognizers _ of @xmath2 space .",
    "there is a way to stably compute predicates in @xmath18 even when the corresponding tm @xmath282 might loop , by carrying out an approach similar to the one given above .",
    "however , since neither an accept nor a reject state may be reached , the simulation is nondeterministically re - initiated at any point that is not in such a state .",
    "this choice is also obtained by the nondeterministic interactions .",
    "for example , whenever the agent that carries out the simulation interacts with an agent that has an i d that is even , the simulation remains unchanged , otherwise it is re - initiated .",
    "notice however that during the simulation , any agent having i d @xmath185 may need to interact with those having neighboring ids , so those must not be able to cause a re - initiation in the simulation .",
    "correctness of the above procedure is captured by similar arguments to those in the proof of theorem [ the : lowplm ] .",
    "if @xmath324 never accepts , then no output tape will ever contain a @xmath41 , so the simulation stabilizes to @xmath42 .",
    "if @xmath324 accepts there is a sequence of configurations @xmath58 , starting from the initial configuration @xmath80 that leads to a configuration @xmath81 in which each agent s output is set to @xmath41 .",
    "observe that this is a `` good '' sequence , meaning that no re - initiations take place , and , due to fairness , it will eventually occur .",
    "we first give an upper bound on @xmath1 .",
    "[ the : upplm ] all predicates in @xmath1 are in the class @xmath4    _ proof sketch_. the proof is similar to those that achieve the upper bounds of mpp @xcite and community protocol @xcite . in particular , it suffices to show that the language corresponding to any predicate stably computable by the paloma model can be decided by a nondeterministic tm of @xmath2 space .",
    "the tm guesses the next configuration and checks whether it has reached one that is output - stable .",
    "note that @xmath2 space suffices , because a population configuration consists of @xmath0 agent configurations each of size @xmath39 .",
    "let @xmath26 be a paloma protocol that stably computes such a predicate @xmath116 .",
    "a population configuration can be represented as an @xmath327place vector storing an agent configuration per place , and thus uses @xmath2 space in total .",
    "the language @xmath328 derived from @xmath116 is the set of such strings that , when each agent receives a single string element , @xmath116 holds , that is , @xmath329 .",
    "we will now present a nondeterministic turing machine @xmath330 that decides @xmath328 in @xmath2 space . to accept the input ( assignment ) @xmath113 , @xmath330 must verify two conditions : that there exists a configuration @xmath80 reachable from the initial configuration corresponding to @xmath113 in which the output tape of each agent indicates that @xmath116 holds , and that there is no configuration @xmath81 reachable from @xmath80 under which @xmath116 is violated for some agent .",
    "the first condition is verified by guessing and checking a sequence of configurations .",
    "starting from the initial configuration , each time @xmath330 guesses configuration @xmath331 and verifies that @xmath332 yields @xmath331 .",
    "this can be caused either by an agent transition @xmath47 , or an encounter @xmath333 . in the first case ,",
    "the verification can be carried out as follows : @xmath330 guesses an agent @xmath47 so that @xmath332 and @xmath331 differ in the configuration of @xmath47 , and that @xmath334 yields @xmath335 .",
    "it then verifies that @xmath332 and @xmath331 differ in no other agent configurations .",
    "similarly , in the second case @xmath330 nondeterministically chooses agents @xmath47 , @xmath336 and verifies that encounter @xmath333 leads to @xmath81 by ensuring that : ( a ) both agents have their working flags cleared in @xmath80 , ( b ) the tape exchange takes place in @xmath81 , ( c ) both agents update their states according to @xmath53 and set their working flags to @xmath41 in @xmath81 and ( d ) that @xmath332 and @xmath331 differ in no other agent configurations . in each case",
    ", the space needed is @xmath2 for storing @xmath332 , @xmath331 , plus @xmath39 extra capacity for ensuring the validity of each agent configuration in @xmath331 .",
    "if the above hold , @xmath330 replaces @xmath332 with @xmath331 and repeats this step .",
    "otherwise , @xmath330 drops @xmath331 .",
    "any time a configuration @xmath80 is reached in which @xmath116 holds , @xmath330 computes the complement of a similar reachability problem : it verifies that there exists no configuration reachable from @xmath80 in which @xmath116 is violated .",
    "since @xmath337 is closed under complement for all space functions @xmath338 ( see immerman - szelepcsnyi theorem , @xcite , pages @xmath339 ) , this condition can also be verified in @xmath2 space .",
    "thus , @xmath328 can be decided in @xmath2 space by some nondeterministic turing machine , so @xmath340 .",
    "@xmath1 is equal to @xmath21",
    ".    follows from theorems [ the : comm ] ( or , equivalently , theorem [ the : lowplm ] ) , which establishes that @xmath341 @xmath342 , and [ the : upplm ] , which establishes that @xmath343 ; but for all @xmath344 , @xmath116 is symmetric , thus , @xmath345 .",
    "we proposed the paloma model , an extension of the pp model @xcite , in which the agents are communicating tms of memory whose size is logarithmic in the population size .",
    "we focused on studying the computational power of the new model .",
    "although the model preserves uniformity and anonymity , interestingly , we have been able to prove that the agents can _ organize themselves into a nondeterministic tm _ that makes full use of the agents total memory ( i.e. of @xmath2 space ) .",
    "the agents are initially identical , but by executing an _ iterative reinitiation process _",
    "they are able to assign _ unique consecutive ids _ to themselves and get informed of the population size . in this manner , we showed that @xmath1 , which is the class of predicates stably computable by the paloma model , contains all symmetric predicates in @xmath4 .",
    "finally , by upper bounding @xmath1 , we concluded that it is precisely equal to the class consisting of all symmetric predicates in @xmath4 .",
    "many interesting questions remain open .",
    "is the paloma model _ fault - tolerant _ ?",
    "what preconditions are needed in order to achieve satisfactory fault - tolerance ? is it possible for the paloma model to simulate the mpp model @xcite ? to prove the latter , it would suffice to show that @xmath127 @xmath346 is an upper bound for @xmath347 ( the class of computable predicates by mpp ) .",
    "but we do not expect this to be easy , because it would require to prove that we can _ encode _ the @xmath348 sized configurations of mpp by new configurations of @xmath2 size whose transition graph is , in some sense , _ isomorphic _ to the old one ( e.g. the new configurations reach the same stable outputs ) .",
    "finally , @xmath39 memory per agent seems to behave as a",
    "_ threshold_. is there some sort of impossibility result showing that with @xmath126 memory , where @xmath349 is asymptotically smaller than @xmath350 , the class of stably computable predicates is strictly smaller than @xmath351 ? at a first glance , it seems that the agents are unable to store uids and get informed of the population size .",
    "d. angluin , j. aspnes , m. chan , m. j. fischer , h. jiang , and r. peralta .",
    "stably computable properties of network graphs . in _ proc .",
    "distributed computing in sensor systems : 1st ieee int .",
    "_ , pages 63 - 74 , 2005 .",
    "j. aspnes and e. ruppert .",
    "an introduction to population protocols .",
    "_ bulletin of the european association for theoretical computer science _ , 93:98 - 117 , oct . 2007 .",
    "col . : _ distributed computing _ , editor : m. mavronicolas .",
    "o. bournez , p. chassaing , j. cohen , l. gerin , and x. koegler . on the convergence of population protocols when population goes to infinity . in",
    "_ applied mathematics and computation _ , 215(4):1340 - 1350 , 2009 .",
    "i. chatzigiannakis , s. dolev , s. p. fekete , o. michail , and p. g. spirakis .",
    "not all fair probabilistic schedulers are equivalent . in _",
    "13th international conference on principles of distributed systems ( opodis ) _ , pages 33 - 47 , nimes , france , december 15 - 18 , 2009 .",
    "i. chatzigiannakis , o. michail , and p. g. spirakis .",
    "decidable graph languages by mediated population protocols . in _",
    "23rd international symposium on distributed computing ( disc ) _ , elche , spain , sept .",
    "i. chatzigiannakis , o. michail , and p. g. spirakis .",
    "mediated population protocols . in _",
    "36th international colloquium on automata , languages and programming ( icalp ) _",
    ", pages 363 - 374 , rhodes , greece , 2009 .",
    "i. chatzigiannakis and p. g. spirakis .",
    "the dynamics of probabilistic population protocols . in _ distributed computing _ , _ 22nd international symposium _ , _ disc _ , volume 5218 of _ lncs _ , pages 498 - 499 , 2008 .    c. delporte - gallet , h. fauconnier , r. guerraoui , and e. ruppert . when birds die : making population protocols fault - tolerant . in _ proc .",
    "2nd ieee international conference on distributed computing in sensor systems _ , pages 51 - 66 , 2006 .",
    "r. guerraoui and e. ruppert .",
    "names trump malice : tiny mobile agents can tolerate byzantine failures . in _ 36th international colloquium on automata , languages and programming ( icalp ) _ , pages 484 - 495 , greece , 2009 ."
  ],
  "abstract_text": [
    "<S> we propose a new theoretical model for passively mobile wireless sensor networks . </S>",
    "<S> we call it the _ paloma _ model , standing for passively mobile logarithmic space machines . the main modification w.r.t . the population protocol model </S>",
    "<S> @xcite is that agents now , instead of being automata , are turing machines whose memory is logarithmic in the population size @xmath0 . </S>",
    "<S> note that the new model is still _ easily implementable _ with current technology . </S>",
    "<S> we focus on _ complete communication graphs_. we define the complexity class @xmath1 , consisting of all symmetric predicates on input assignments that are stably computable by the paloma model . </S>",
    "<S> we assume that the agents are initially _ </S>",
    "<S> surprisingly , it turns out that the paloma model _ can assign unique consecutive ids to the agents and inform them of the population size _ ! </S>",
    "<S> this allows us to give a direct simulation of a _ </S>",
    "<S> deterministic _ </S>",
    "<S> turing machine of @xmath2 space , thus , establishing that any symmetric predicate in @xmath3 also belongs to @xmath1 . </S>",
    "<S> we next prove that the paloma model can simulate the community protocol model @xcite , thus , improving the previous lower bound to all symmetric predicates in @xmath4 . </S>",
    "<S> going one step further , we generalize the simulation of the deterministic tm to prove that the paloma model can simulate a _ nondeterministic _ </S>",
    "<S> tm of @xmath2 space . </S>",
    "<S> although providing the same lower bound , the important remark here is that the bound is now obtained in a _ direct manner _ , in the sense that _ it does not depend on the simulation of a tm by a pointer machine_. finally , by showing that a nondeterministic tm of @xmath2 space decides any language stably computable by the paloma model , we end up with an exact characterization for @xmath1 : _ it is precisely the class of all symmetric predicates in _ @xmath4 . </S>"
  ]
}