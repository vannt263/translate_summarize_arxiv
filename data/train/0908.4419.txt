{
  "article_text": [
    "wireless sensor networks consist of small devices ( nodes ) with limited cpu , bandwidth , and power .",
    "they can be deployed in isolated , tragedy , and obscured fields to monitor objects , detect fires , temperature , flood , and other disaster incidents .",
    "they can also be used in areas difficult to reach or where it is danger for a human being to be involved .",
    "there has been extensive research work on sensor networks to improve their services , power , and operations  @xcite .",
    "they have taken much attention recently due to their varieties of applications .",
    "assume a wireless sensor network @xmath5 with @xmath0 nodes thrown in a field to detect fires or to measure temperatures .",
    "those sensors are distributed randomly and can not maintain routing tables or network topology .",
    "some nodes might disappear from the network due to failure or battery depletion .",
    "one needs to design storage strategies to collect sensed data from those sensors before they disappear suddenly from the network .",
    "such problem and their solutions have been considered in  @xcite",
    ".    distributed network storage codes such as fountain codes have been used along with random walks to distribute data from a set of sources @xmath6 to a set of storage nodes @xmath7 , see  @xcite .",
    "the authors in  @xcite studied a model for distributed network storage algorithms for wireless sensor networks where @xmath6 sensor nodes ( sources ) want to disseminate their data to @xmath0 storage nodes with minimum computational complexity .",
    "fountain codes and random walks in graphs are used to solve this problem , in case of the total number of sensor and storage nodes may or may not be known . in this paper we assume a model where all @xmath0 nodes in @xmath5 can sense and store data .",
    "each sensor has a buffer of total size @xmath8 .",
    "furthermore , every sensor can divide its buffer into @xmath9 slots ( small buffers ) , each of size @xmath10 , i.e. @xmath11 .    in this paper we propose a distinct model for a wireless sensor network , wherein all nodes serve as sensors / sources as well as storage / receiver nodes .",
    "the main advantages of the proposed algorithms are as follows :    using analysis and simulation , we show that the encoding operations , of a node to disseminate its data , take less computational time in comparison to the previous work .",
    "one does not need to query all nodes in the network in order to retrieve information about all @xmath0 nodes .",
    "only @xmath12 of the total nodes can be queried .",
    "one can query only one arbitrary node @xmath13 in a certain region in the network to obtain an information about this region .",
    "in this section we present the network model and problem definition . consider a wireless sensor network @xmath5 with @xmath0 sensor nodes that are uniformly distributed at random in a region @xmath14 ^ 2 $ ] for some integer @xmath15 .",
    "the network model @xmath5 can be presented by a graph @xmath16 with a set of nodes @xmath17 and a set of edges @xmath18 .",
    "the set @xmath17 represents the sensors @xmath19 that will measure information about a specific field .",
    "also , @xmath18 represents a set of connections ( links ) between the sensors @xmath20 .",
    "two arbitrary sensors @xmath21 and @xmath22 are connected if they are in each other s transmission range .",
    "we ensure that the network is dense , meaning with high probability there are no isolated nodes .",
    "let @xmath23 be a fraction .",
    "we say that two nodes @xmath13 and @xmath24 in @xmath17 are connected in @xmath25 if and only if the distance between them is bounded by the design parameter @xmath26 , i.e. @xmath27 .     nodes arbitrary and randomly distributed in a field . a node",
    "@xmath21 determines its degree @xmath28 by sending a flooding message to the neighboring nodes . ]",
    "given @xmath29 , we say @xmath13 and @xmath24 are _ adjacent _ ( or @xmath13 is adjacent to @xmath24 , and vice versa ) if there exists a link between @xmath13 and @xmath24 , i.e. , @xmath30 . in this case , we also say that @xmath13 and @xmath24 are _",
    "neighbors_. denote by @xmath31 the set of neighbors of a node @xmath13 .",
    "the number of neighbors , with a direct connection , of a node @xmath13 is called the _ node degree _ of @xmath13 , and denoted by @xmath32 , i.e. , @xmath33 .",
    "the _ mean degree _ of a graph @xmath25 is given by @xmath34 where @xmath35 is the total number of nodes in @xmath25 .",
    "the ideal soliton distribution @xmath36 for @xmath6 source blocks is given by  @xcite @xmath37 we will use this probability distribution in the algorithms developed in the next section .",
    "we have the following assumptions about the network model @xmath5 :    let @xmath38 be a set of sensing nodes that are distributed randomly and uniformly in a field .",
    "each sensor acts as both a sensing and storage node .",
    "thus , this assumption differentiate between our work and the problems considered in  @xcite .",
    "every node does not maintain routing or geographic tables , and the network topology is not known .",
    "every node @xmath21 can send a flooding message to the neighboring nodes .",
    "also , every node @xmath21 can detect the total number of neighbors by broadcasting a simple query message , and whoever replies to this message will be a neighbor of this node .",
    "therefore , our work is more general and different from the work done in  @xcite .",
    "the degree @xmath32 of this node is the total number of neighbors with a direct connection .",
    "every node has a buffer of size @xmath8 and",
    "this buffer can be divided into smaller slots , each of size @xmath10 , such that @xmath39 .",
    "hence , all nodes have the same number of slots .",
    "also , the first slot of a node @xmath13 is reserved for its own sensing data .",
    "every node @xmath21 prepares a packet @xmath40 with its @xmath41 , sensed data @xmath42 , counter @xmath43 , and a flag that is set to zero or one .",
    "every node draws a degree @xmath44 from a degree distribution @xmath45 .",
    "if a node decided to accept a packet , it will also decide on which buffer it will be stored .",
    "in this section we will present a networked distributed storage algorithm for wireless sensor networks , where all nodes act as sensing and storage nodes , and study its encoding and decoding operations .",
    "we present a distributed storage algorithm ( dsa - i ) for wireless sensor networks .",
    "i algorithm consists of three main phases : initialization , encoding / flooding , and storage phases . each phase can be described as follows .",
    "generate @xmath46 according to @xmath36 ( or @xmath47 and a set of neighbors @xmath48 using flooding . ; generate header of @xmath42 and @xmath49 set counter @xmath50 flood @xmath42 to all @xmath51 uniformly at random , send @xmath42 to @xmath52 with probability 1 , @xmath53 = @xmath54 put @xmath42 into @xmath13 s forward queue @xmath55    choose @xmath56 uniformly at random send packet @xmath42 in @xmath13 s forward queue to @xmath24    coin = rand(1 )     @xmath57 = @xmath58 put @xmath42 into @xmath24 s forward queue @xmath55     put @xmath42 into @xmath24 s forward queue",
    "@xmath55     +      every node @xmath21 in @xmath20 has an @xmath41 and sensed data @xmath42 .",
    "the node @xmath21 in the initialization phase prepares a @xmath40 with these values .",
    "also , the packet contains a hop count field , @xmath43 , and a flag indicating whether the data is new or an update of a previous value .",
    "each node will have a different hop count value depending on the number of its neighbors @xmath28 .",
    "such that if a node @xmath21 has a few neighbors , then @xmath43 will be large . also , a node with large number of neighbors will choose a small counter @xmath43 .",
    "this means that every node will decide its own counter .",
    "@xmath59    the node @xmath21 broadcasts this packet to all neighboring nodes @xmath60 .",
    "* after the flooding phase , every node @xmath13 receiving the @xmath40 will check @xmath41 , accept the data @xmath42 with probability one , and will add this data to its buffer slots @xmath61 .",
    "@xmath62 this is because the node @xmath13 is a direct neighbor of @xmath21 .",
    "the data @xmath42 is disseminated rapidly to all neighbors of @xmath63 .",
    "* the node @xmath13 will decrease the counter by one as @xmath64 the node @xmath13 will select a set of neighbors that did not receiver the message @xmath42 and it will unicast this message to them . * for an arbitrary node @xmath24 that receives the message from @xmath13 , it will check if the @xmath42 has been received before , if yes , then it will discard it . if not , then it will decide whether to accept or reject it based on a random value drawn from @xmath36 .",
    "if accepted , then it will add the data to one of its buffer slots @xmath65 and will decrease the counter @xmath66 * the node @xmath24 will check if the counter is zero , otherwise it will decrease it and send this message to the neighboring nodes that did not receive it .      every node will maintain its own buffer by storing a copy of its data and other nodes data . also , a node will store a list of nodes i d s of the packets that reached it .",
    "after all nodes receive , send , and store their own and neighboring data . therefore , each node will have some information about itself and other nodes in the network .",
    "the stored data can be recovered by querying a number of nodes from the network .",
    "let @xmath0 be the total number of alive nodes ; assume that every node has @xmath9 buffer slots such that @xmath11 , where @xmath10 is a small buffer size , and @xmath8 is the total buffer size in a node . in the next section , we show that the data collector needs to query at least @xmath67 nodes in order to retrieve the information about the @xmath0 variables .",
    "this is much better than previous approaches  @xcite that require querying large number of sources .",
    "we shall provide analysis for the dsa - i algorithm shown in the previous section .",
    "the main idea is to utilize flooding and the node degree of each node to disseminate the sensed data from sensors throughout the network .",
    "we note that nodes with large degree will have smaller counters in their packets such that their packets will travel for minimal number of neighbors . also , nodes with smaller degree will have larger counters such that their packets will be disseminated to many neighbors as possible .",
    "the following lemma establishes the number of hobs ( steps ) that every packet will travel in the network .",
    "[ lem : onepacket ] on average , with a high probability , the total number of steps for one packet originated by a node @xmath13 in one branch in dsa - i is @xmath68 .",
    "let @xmath13 be a node originating a packet @xmath69 with degree @xmath32 .",
    "for any arbitrary node @xmath24 , the packet @xmath69 will be forwarded only if it is the first time to visit @xmath24 or the counter @xmath70 .",
    "we know that every packet originated from a node @xmath13 has a counter given by @xmath71 let @xmath3 be the mean degree of the graph representing the network @xmath5 . on average ,",
    "assuming every packet will be sent to @xmath3 neighboring nodes , approximating the mean degree of the graph to the degree of any arbitrary node @xmath13 , the result follows .",
    "if the total number of nodes is not known , one can use the method developed in  @xcite to estimate @xmath0 .",
    "in other words , a random walk initiated by the node @xmath13 can be run to estimate the total number of nodes .",
    "[ lem : totaltransmissions ] let @xmath5 be an instance model of a wireless sensor network with @xmath0 sensor nodes .",
    "the total number of transmissions required to disseminate the information from any arbitrary node throughout the network is @xmath72 .",
    "let @xmath28 be the degree of a sensor node @xmath21 .",
    "on average @xmath3 is the mean degree of the set of sensors @xmath20 approximated by @xmath73 .",
    "every node does flooding that takes @xmath74 running time to @xmath28 neighbors . in order to disseminate information from a sensor @xmath21 ,",
    "at least @xmath75 steps are needed using lemma  [ lem : onepacket ] .",
    "also , every sensor @xmath21 needs to send @xmath3 messages on average to the neighbors .",
    "hence the result follows .",
    "note that this is much better than previous results shown in  @xcite that take @xmath76 , where @xmath0 is the number of sources .",
    "the encoding operations of dsa - i algorithm are the total number of transmissions required to disseminate information sensed by all nodes that is @xmath77 .",
    "in algorithm dsa - i we assumed that the total number of nodes are known in advance for each sensing / storing node in the network .",
    "this might not be the case since arbitrary nodes might join and leave the network at various times due to the fact that they have limited cpu and short life time .",
    "therefore , one needs to design a network storage algorithm that does not depend on the value of the total number of nodes .",
    "we extend dsa - i to obtain a distributed storage algorithm ( dsa - ii ) that is totally distributed without knowing global information .",
    "the idea is that each node @xmath13 will estimate a value for its counter @xmath78 , the hop count , without knowing @xmath0 . in dsa - ii",
    "each node @xmath13 will first perform an inference phase that will calculate value of the counter @xmath78 .",
    "this can be achieved using the degree of @xmath13 and the degrees of the neighboring nodes @xmath48 .",
    "we also assume a parameter @xmath79 that will depend on the network condition and node s degree .",
    "* inference phase : * let @xmath13 be an arbitrary node in a distributed network @xmath5 . in the inference phase , each node @xmath13 will dynamically determine value of the counter @xmath78 .",
    "the node @xmath13 knows its neighbors @xmath48 .",
    "this is achieved in the flooding phase .",
    "furthermore , the node @xmath24 in @xmath48 knows the degrees of its neighbors .    the inference phase is done dynamically in the sense that every node in the network will independently decide a value for its counter .",
    "nodes with large degrees will have a high chance of forwarding their data throughout the network to a large number of nodes .",
    "let @xmath24 be a node connected to a source node @xmath13 .",
    "let @xmath80 be the degree of a node @xmath24 without adding nodes in @xmath81 .",
    "we can approximate the counter @xmath78 as @xmath82 once the hop counts @xmath78 is approximated at each node @xmath13 , the encoding operations of dsa - ii algorithm are similar to encoding operations of dsa - i algorithm .    [",
    "lem : totaltransmissions2 ] let @xmath5 be a sensor network with @xmath0 sensor nodes uniformly distributed .",
    "the total number of transmissions required to disseminate the information from any arbitrary node throughout the network for the dsa - ii is given by @xmath83 where @xmath84 be the average node density  @xcite .",
    "in this section we shall provide evaluation and comparison analysis between dsa - i and dsa - ii algorithms and related work in distributed storage algorithms .",
    "previous work focused on utilizing random walks and fountain codes to disseminate data sensed by a set of sensors throughout the network . also , global and geographical information such as knowing total number of nodes , routing tables , and node locations are used .    in this work ,",
    "we disseminate data throughout the network using data flooding once at every sensor node , then adding some redundancy at other neighboring nodes using random walks and packet trapping .",
    "every storage node will keep track of other node s i d s , from which it will accept / reject packets .",
    "the main advantages of the proposed algorithms are as follows    one does not need to query all nodes in the network in order to retrieve information about all @xmath0 nodes .",
    "only @xmath12 of the total nodes can be queried .",
    "one can query only one arbitrary node @xmath13 in a certain region in the network to obtain an information about this region .",
    "the dsa - i and dsa - ii algorithms proposed in this paper are superior in comparison to the cdsa- and cdsa - ii storage algorithms based on fountain and raptor codes proposed in  @xcite .",
    "the later utilize random walks to disseminate the information from a set of sources to a set of storage nodes .",
    "the proposed algorithms work also in the case of data update . assume a node @xmath13 sensed data @xmath85 and it has been disseminated throughout the network using flooding as shown in dsa - i and dsa - ii algorithms .",
    "in this case the flag value is set to zero ; and a packet from the node @xmath13 is originated as follows : @xmath86 we notice that every node @xmath24 stores a copy from this data @xmath85 will also maintain a list of i d s including @xmath87 .",
    "assume @xmath88 be the new sensed data from the node @xmath13 .",
    "the node @xmath13 will send update message setting the flag to one .",
    "@xmath89 the new and old data are xored in this packet .",
    "every storage node will check the flag , whether it is an update or initial packet .",
    "also , the node @xmath24 will check if @xmath87 is in its own list .",
    "once a node @xmath24 accepts the coming update packet , it will update its target buffer as @xmath90     nodes arbitrary and randomly distributed in a field .",
    "the successful decoding ratio is shown for various values of n=50 , 100 , 150 with the dsa - i algorithm . ]",
    "in this section we simulate the distributed storage algorithms , dsa - i , presented in section  [ sec : algdsa - i ] .",
    "the main performance metric we investigate is the successful decoding probability versus the decoding ratio .",
    "we define the successful decoding probability @xmath91 as percentage of @xmath92 successful trials for recovering all @xmath0 variables ( symbols ) to the total number of trails .",
    "we define @xmath93 to be the total number of queries needed to recover those @xmath0 variables .",
    "also , we can define the decoding ratio as the total queried nodes divided by @xmath0 , i.e. @xmath94 .",
    "we ran the experiment over a network with area @xmath95 ^ 2 $ ] grid and with different node densities .",
    "we evaluated the performance with various decoding ratios depending on the total number of nodes inside the network with incremental @xmath96 .",
    "[ fig : dsa - i-2x2 ] shows the decoding performance of dsa - i algorithm with ideal soliton distribution with small number of nodes.we ran the experiment over a network with area @xmath97 ^ 2 $ ] grid , and evaluated the performance with various decoding ratios @xmath98 . from these results",
    "we can see that the successful decoding probability increases with the gradual increases of the decoding ratio @xmath99 and reached it upper bound when @xmath100 .",
    "[ fig : dsa - i-5x5 ] shows the decoding performance of dsa - i algorithm with ideal soliton distribution with large number of nodes .",
    "the network is deployed in @xmath101 ^ 2 $ ] . from the simulation results we can see that the decoding ratio increases with the increase of @xmath84 and approaches to 1 for @xmath102 .",
    "therefore the proposed algorithms perform well for large - scale wireless sensor networks .",
    "nodes arbitrary and randomly distributed in a field .",
    "the successful decoding ratio is shown for various values of n= 200 , 400 , 600 with the dsa - i algorithm . ]",
    "we presented two distributed storage algorithms for large - scale wireless sensor networks .",
    "given @xmath0 storage / senseing nodes , we developed schemes to disseminate sensed data throughout the network with a lesser computational overhead .",
    "the algorithms results and performance demonstrated that it is required to query only @xmath103 of the network nodes in order to retrieve the data collected by the @xmath0 sensing nodes , when the buffer size is @xmath104 of the network size",
    ". our future work will include practical and implementation aspects of these algorithms ."
  ],
  "abstract_text": [
    "<S> in this paper we propose distributed storage algorithms for large - scale wireless sensor networks . assume a wireless sensor network with @xmath0 nodes that have limited power , memory , and bandwidth . </S>",
    "<S> each node is capable of both sensing and storing data . </S>",
    "<S> such sensor nodes might disappear from the network due to failures or battery depletion . </S>",
    "<S> hence it is desired to design efficient schemes to collect data from these @xmath0 nodes . </S>",
    "<S> we propose two distributed storage algorithms ( dsa s ) that utilize network flooding to solve this problem . in the first algorithm , dsa - i </S>",
    "<S> , we assume that every node utilizes network flooding to disseminate its data throughout the network using a mixing time of approximately @xmath1 . </S>",
    "<S> we show that this algorithm is efficient in terms of the encoding and decoding operations . in the second algorithm , dsa - ii , </S>",
    "<S> we assume that the total number of nodes is not known to every sensor ; hence dissemination of the data does not depend on @xmath0 . </S>",
    "<S> the encoding operations in this case take @xmath2 , where @xmath3 is the mean degree of the network graph and @xmath4 is a system parameter . </S>",
    "<S> we evaluate the performance of the proposed algorithms through analysis and simulation , and show that their performance matches the derived theoretical results . </S>"
  ]
}