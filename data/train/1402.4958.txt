{
  "article_text": [
    "[ [ background . ] ] background .",
    "+ + + + + + + + + + +    _ erasure coding _ is a key technology that saves space and retains robustness against faults in distributed storage systems . in short ,",
    "an erasure code splits a large data object into @xmath1 fragments such that from any @xmath0 of them the input value can be reconstructed .",
    "the utility of erasure coding is demonstrated by large - scale erasure - coding storage systems that have been deployed today  @xcite .",
    "these distributed storage systems offer large capacity , high throughput , and resilience to faults .    whereas the storage systems in production use today only tolerate component crashes or outages , storage systems in the _ byzantine failure model _ survive also more severe faults , ranging from arbitrary state corruption to malicious attacks on components . in this paper",
    ", we consider a model where _ clients _ directly access a storage service provided by distributed servers , called _ nodes _  a fraction of the nodesmay be byzantine , whereas clients may fail as well , but only by crashing .",
    "although byzantine - fault tolerant ( bft ) erasure - coded distributed storage systems have received some attention in the literature  @xcite , our understanding of their properties lies behind that of replicated storage .",
    "in fact , most existing bft erasure - coded storage approaches have drawbacks that prevented their wide - spread use .",
    "for example , they relied on the nodesstoring an unbounded number of values  @xcite , required the nodesto communicate with each other  @xcite , used public - key cryptography  @xcite , or might have blocked clients due to concurrent operations of other clients  @xcite .",
    "we consider an abstract _ wait - free _ storage register with _",
    "semantics  @xcite , accessed concurrently by multiple readers and writers ( mrmw ) .",
    "wait - free termination means that any client operation terminates irrespective of the behavior of the byzantine nodesand of other clients .",
    "this is not easy to achieve with byzantine nodes  @xcite even in systems that replicate the data .",
    "therefore , previous works have often used a weaker notion of liveness called _ finite - write ( fw ) termination _ , which ensures that read operations progress only in executions with a finite number of writes .",
    "[ [ contribution . ] ] contribution .",
    "+ + + + + + + + + + + + +    this paper introduces awe , the _ first _ asynchronous , wait - free distributed bft erasure - coded storage protocol with optimal resilience . as in previous work",
    ", we assume there are @xmath1 nodesand up to @xmath3 of them may exhibit non - responsive ( nr-)arbitrary faults , that is , byzantine corruptions .",
    "the best resilience that has been achieved so far is @xmath5 , which is optimal for byzantine storage  @xcite .",
    "however , our protocol features a separation of metadata and erasure coded fragments ; with this approach our protocol may reduce the number of _ data nodes _",
    ", i.e. , those that store a fragment , to lower values than @xmath1 for @xmath6 .",
    "in particular , our protocol takes only @xmath2 data nodes ; this idea saves resources , as in the separation of agreement and execution for bft services  @xcite . for implementing the metadata service , @xmath7 nodesare still needed .",
    "our protocol employs simple , passive data nodes ; they can not execute code and they only support read and write operations , such as the key - value stores ( kvs ) provided by popular cloud storage services .",
    "the metadata service itself is an atomic snapshot object , which has only weak semantics and may be implemented in a replicated asynchronous system from simple read / write registers  @xcite .",
    "the protocol is also _ amnesic _",
    "@xcite , i.e. , the nodesstore a bounded number of values and may erase obsolete data .",
    "the protocol uses only simple cryptographic hash functions but no ( expensive ) public - key operations .    in summary , protocol awe , introduced in section  [ sec : protocol ] , is the first erasure - coded distributed implementation of a mrmw storage object that is , at the same time : ( 1 ) asynchronous , ( 2 ) wait - free , ( 3 ) atomic , ( 4 ) amnesic , ( 5 ) tolerates the optimal number of byzantine nodes , and ( 6 ) does not use public - key cryptography .",
    "furthermore , awecan be implemented from non - programmable nodes(kvs ) that only support reads and writes ( in the vein of disk paxos  @xcite ) . in practice ,",
    "the kvs interface is offered by commodity cloud storage services , which could be used as awedata nodesto reduce the cost of awedeployment and ownership .",
    "while some of these desirable properties have been achieved in different combinations so far , they have never been achieved together with erasure - coded storage , as explained later . combining these properties",
    "has been a longstanding open problem  @xcite .",
    "[ [ related - work . ] ] related work .",
    "+ + + + + + + + + + + + +    we provide a brief overview of the most relevant literature on the subject .",
    "table  [ tab : comparison ] summarizes this section .",
    "earlier designs for erasure - coded distributed storage have suffered from potential aborts due to contention  @xcite or from the need to maintain an unbounded number of fragments at data nodes  @xcite . in the crash - failure model ,",
    "orcas  @xcite and casgc  @xcite achieve optimal resilience @xmath8 and low communication overhead , combined with wait - free ( orcas ) and fw - termination ( casgc ) , respectively .    in the model with byzantine nodes , cachin and tessaro ( ct )",
    "@xcite introduced the first wait - free protocol with atomic semantics and optimal resilience @xmath7 .",
    "ct uses a verifiable information dispersal protocol but needs node - to - nodecommunication , which lies outside our model .",
    "hendricks et al .",
    "( hgr )  @xcite present an optimally resilient protocol that comes closest to our protocol among the existing solutions .",
    "it offers many desirable features , that is , it has as low communication cost , works asynchronously , achieves optimal resilience , atomicity , and is amnesic . compared to our work , it uses public - key cryptography , achieves only fw - termination instead of wait - freedom , and requires _ processing _ by the nodes , i.e. , the ability to execute complex operations beyond simple reads and writes .",
    "to be fair , much of the ( cryptographic ) overhead inherent in the ct and hgr protocols defends against poisonous writes from byzantine clients , i.e. , malicious client behavior that leaves the nodesin an inconsistent state .",
    "we do not consider byzantine clients in this work , since permitting arbitrary client behavior is problematic .",
    "such a client might write garbage to the storage system at any time and wipe out the stored value .",
    "furthermore , the standard formal correctness notions such as linearizability fail when clients misbehave ( apart from crashing ) .",
    "hendricks  @xcite discusses correctness notions in the presence of byzantine clients .",
    "however , even without the steps that protect against poisonous writes , hgr still requires processing by the nodesand is not wait - free .",
    "the m - powerstore protocol  @xcite employs a cryptographic `` proof of writing '' for wait - free atomic erasure - coded distributed storage .",
    "it is the first wait - free bft solution without node - to - nodecommunication .",
    "similar to other protocols , m - powerstore uses nodeswith processing capabilities and is not amnesic .",
    "several systems have recently addressed how to store erasure - coded data on multiple redundant cloud services but only few of them focus on wait - free concurrent access .",
    "hail  @xcite , for instance , uses byzantine - tolerant erasure coding and provides data integrity through proofs of retrievability ; however , it does not address concurrent operations by different clients .",
    "depsky  @xcite achieves regular semantics and uses lock - based concurrency control ; therefore , one client may block operations of other clients .    a key aspect of awelies in the differentiation of ( small ) metadata from ( large ) bulk data : this enables a modular protocol design and an architectural separation for implementations .",
    "the farsite system  @xcite first introduced such a separation for replicated storage ; their data nodesand their metadata abstractions require processing , however , in contrast to  awe .",
    "non - explicit ways of separating metadata from data can already be found in several previous erasure coding - based protocols .",
    "for instance , the cross checksum , a vector with the hashes of all @xmath1 fragments , has been replicated on the data nodes to ensure consistency  @xcite .    finally , a recent protocol called mdstore  @xcite has shown that separating metadata from bulk data permits to reduce the number of data nodesin asynchronous wait - free bft distributed storage implementations to only  @xmath9 . when protocol  aweis reduced to use replication with the trivial erasure code ( @xmath10 )",
    ", it uses as few nodesas mdstore to achieve the same wait - free atomic semantics ; unlike awe , however , mdstore is not amnesic and uses processing nodes .",
    ".comparison of erasure - coded distributed storage solutions . an asterisk ( @xmath11 )",
    "denotes optimal properties .",
    "the column labeled _ type _ states the computation requirements on nodes : _ proc .",
    "_  denotes processing ; _ msg .",
    "_  means sending messages to other nodes , in addition to processing ; _ r / w _ means a register object supporting only read and write .",
    "[ cols=\"<,^,^,^,^,^,^\",options=\"header \" , ]     table  [ tab : complexity ] shows the communication and storage costs of protocol aweand the related protocols .",
    "we use the wait - free semantics achieved by aweand others as the base case ; in casgc  @xcite and hgr  @xcite , a read operation concurrent with an unbounded number of writes may not terminate , hence we state their cost as  @xmath12 .",
    "in contrast to awe , depsky  @xcite is neither wait - free nor amnesic and m - powerstore  @xcite is not amnesic .",
    "it is easy to see that aweperforms better than most storage solutions in terms communication complexity .",
    "in this section we prove that protocol awe , given by algorithms  [ alg : client-1][alg : datareplica ] , emulates an atomic read / write register and is wait - free .",
    "whenever the metadata directory _ dir _ contains an entry @xmath13.{\\textit{frozenptrlist}}[p].{\\textit{ts}}$ ] we say that timestamp  _ ts _ is _ frozen by @xmath14 for @xmath15_. if _ ts _ is frozen by some @xmath14 for any  @xmath15 , then _",
    "ts _ is simply _",
    "frozen_. furthermore , considering the state of writer  @xmath14 , a timestamp  _ ts _ is said to be _ retained by @xmath14 for @xmath15 _ when either @xmath16.{\\textit{ts } } = { \\textit{ts}}$ ] ( this includes that _ ts _ is frozen by @xmath14 for @xmath15 ) or when @xmath17.{\\textit{ts } } = { \\textit{ts}}$ ] ( which means that _ ts _ is reserved by @xmath14 for @xmath15 ) . a timestamp is _ retained _ by @xmath14 when it is retained by @xmath14 for some  @xmath15 .",
    "we call the timestamp @xmath18.{\\textit{writeptr}}.{\\textit{ts}}$ ] the _ written _ timestamp of @xmath14 .",
    "[ lem : timestamps ] at any time the timestamps that a client has frozen are no larger than its written timestamp .",
    "more precisely , for all @xmath19 , @xmath20.{\\textit{writeptr}}.{\\textit{ts } }        \\ > \\ m[c].{\\textit{frozenptrlist}}[p].{\\textit{ts}}.\\ ] ] moreover , during any _ dir_-_update _ operation of  @xmath14 , the timestamp @xmath18.{\\textit{writeptr}}.{\\textit{ts}}$ ] and all timestamps @xmath18.{\\textit{frozenptrlist}}[p].{\\textit{ts}}$ ] may only increase .    from algorithm  [ alg : client-1 ]",
    "it follows that for any client @xmath14 , the timestamps stored in @xmath18.{\\textit{writeptr}}.{\\textit{ts}}$ ] in successive",
    "_ r_-_write _ operations of @xmath14 increase . from the same algorithm ,",
    "it is clear that @xmath18.{\\textit{frozenptrlist}}[p].{\\textit{ts}}$ ] is only updated through a _",
    "r_-_write _ operation of @xmath14 , and is set to the written timestamp of the preceding _",
    "r_-_write _ operation of @xmath14 , which is strictly smaller than the written timestamp stored in @xmath18.{\\textit{writptr}}.{\\textit{ts}}$ ] .",
    "the second inequality follows analogously .",
    "thus , the values stored in @xmath18.{\\textit{frozenptrlist}}[p].{\\textit{ts}}$ ] only increase .",
    "we define the _ timestamp of a register operation @xmath21 _ as follows : ( i ) for an _ r_-_write _",
    "operation , the timestamp of @xmath21is the value assigned to variable  _ writeptr_._ts _ during  @xmath21 ; ( ii ) when @xmath21is an _",
    "r_-_read _ operation , then its timestamp is the value assigned to variable  _ readptr_._ts _ by _ highestread_. note that the timestamp of an _ r_-_read _",
    "operation is @xmath22 if and only if @xmath21returns  @xmath23 .",
    "furthermore , we say that a value @xmath24 is _ associated _ to a timestamp _ ts _ whenever the timestamp of the register operation that writes @xmath24 is _",
    "ts_.    according to _ highestread _ , the timestamp in the returned pointer may be frozen ( taken from the _ frozenptrlist _ field of @xmath25 ) or written ( taken from the _ writeptr _ field of @xmath25 ) , but not both .",
    "[ lem : readfrozen ] if the timestamp _ ts _ of a _ r_-_read",
    "_ operation  @xmath26 by client  @xmath14 has been frozen for @xmath14 by a client  @xmath27 , then @xmath27 executes two _ r_-_write _ operations concurrently to  @xmath26 , where the _",
    "dir_-_scan _ operation of the former _",
    "r_-_write _ operation  @xmath28 and the _ dir_-_update _ operation of the latter _",
    "r_-_write _ operation  @xmath29 occur between _",
    "dir_-_update _ and _ dir_-_scan _ operations of  @xmath26 . moreover , the timestamp of the _ r_-_read _ operation  @xmath26 is _ ts _ , the one associated with the value written by  @xmath28 .    from algorithm  [ alg : client-2 ]",
    "it follows that for _ highestread _ within @xmath26 to return a frozen timestamp , then , if @xmath25 is the metadata snapshot returned by the _ dir_-_scan _ operation during  @xmath26 , it holds @xmath30.{\\textit{frozenindex}}[c ] =    { \\textit{readindex}}$ ] .",
    "this means that @xmath27 invoked _",
    "dir_-_update _ with the most recent value of _ readindex _ before the _ dir_-_scan _ during  @xmath26 . to do that",
    ", @xmath27 must have detected the change of the _ readindex _ entry in @xmath18 $ ] caused by @xmath26 through the _ dir_-_scan _ operation invoked during  @xmath28 . from algorithm  [ alg : client-1 ] , this can only be the operation through which @xmath27 wrote the value associated to  _",
    "ts_.    [ lem : partorder ] let @xmath21and @xmath31be two distinct operations on register  _ r _ with timestamps  @xmath32and @xmath33 , respectively , such that @xmath21 precedes @xmath31 .",
    "then @xmath34 .",
    "furthermore , if @xmath31 is of type _ r_-_write _ , then @xmath35 .",
    "we distinguish between two cases , depending on the type of  @xmath21 .",
    "case 1 : : :    if @xmath21is of type _ r_-_write _ , the claim follows directly    from lemma  [ lem : timestamps ] and from the algorithm of the writer . in    particular ,",
    "if @xmath31is of type _ r_-_read _ , then , if there    is no concurrent _",
    "r_-_write _ operation of the same client    @xmath27 as @xmath21 , @xmath32 is    returned as written timestamp by the _ readfrom _",
    "function when called    for @xmath27 and reader of @xmath31 . in addition , if    @xmath31runs concurrently with a",
    "_ r_-_write _ of    @xmath27 , then one of the two hold : ( i )    @xmath32 ( or a higher timestamp if many _ r_-_write _    operations have intervened ) is frozen for @xmath31 and is    returned by the _ readfrom _",
    "operation invoked by _ highestread _ in    @xmath31for @xmath27 , ( ii )    @xmath32(or a higher timestamp if many _ r_-_write _",
    "operations have intervened ) has not yet been frozen by    @xmath27 , in which case a written timestamp greater or equal to    @xmath32 ( by lemma  [ lem : timestamps ] ) is returned by    the _ readfrom _ operation invoked by _ highestread _ in",
    "@xmath31for @xmath27 .",
    "case  2 : : :    if @xmath21is of type _ r_-_read _ , then let    @xmath36 be the maximum value of the timestamp    field  _ ts _ in a _ writeptr _ at the time when the _",
    "dir_-_scan _ operation    invoked by @xmath21returns .",
    "note that _ highestread _ obtains    @xmath32 as this maximum or as a frozen timestamp .",
    "lemma  [ lem : timestamps ] implies now that    @xmath37 .",
    "+    we now show that    @xmath38    by distinguishing two cases .",
    "first , if @xmath31is of type    _ r_-_write _ , the writer calls _ dir_-_scan _ after @xmath21    completes and determines the maximum value of the  _ ts _ field in any    _",
    "writeptr_. then it increments that timestamp to obtain    @xmath33 .",
    "this ensures that    @xmath39 ,    as claimed .",
    "+    second , if @xmath31is of type _ r_-_read _ , then    @xmath33may either have been a written timestamp    or a frozen timestamp ( at the time when the client obtained the    response of its _",
    "dir_-_scan _ ) .",
    "if @xmath33has been    written , then @xmath33is the maximum value of    the  _ ts _ field in any _ writeptr _ , which is at least as large as    @xmath36 by lemma  [ lem : timestamps ] and by the    atomicity of  _",
    "dir_.    +    alternatively , if @xmath33has been frozen by    writer  @xmath27 , then lemma  [ lem : readfrozen ] applies and shows    that there exist two _",
    "operations by @xmath27 that    are concurrent to @xmath31 , of which the first writes the    value associated to @xmath33 . as such , if    @xmath40 is the timestamp returned by the _ readfrom _    function invoked by any _ r_-_read _ operation @xmath21 that    precedes @xmath31 and for writer @xmath27 , then    @xmath41 .",
    "since this can be extended to all writers , it holds that    @xmath34 .",
    "[ lem : unqwrites ] if @xmath21and @xmath31are two distinct operations of type _ r_-_write _ with timestamps @xmath32and @xmath33 , respectively , then @xmath42 .",
    "if @xmath21and @xmath31are executed by different clients , then the two timestamps differ in their second component . if @xmath21and @xmath31are executed by the same client , then the client executed them sequentially . by lemma",
    "[ lem : partorder ] , it holds @xmath43 .",
    "[ lem : integr ] let @xmath26 be an operation of type _",
    "r_-_read _ with timestamp @xmath44 that returns a value @xmath45",
    ". then there is a unique operation @xmath46 of type _",
    "r_-_write _ that writes @xmath24 with timestamp  @xmath47 .",
    "operation  @xmath26 by client  @xmath14 returns  @xmath24 and is , thus , complete .",
    "this means that the client has processed @xmath0 events of type @xmath48-_readresp _ from distinct nodesin a set @xmath49 ; according to the protocol , the client has verified that the response from every @xmath50 contains a timestamp  @xmath51 and a fragment  @xmath52 such that @xmath53 and @xmath54 $ ] .    according to the code , the value _ readptr _ is computed from a _ writeptr _ or a @xmath55 $ ] entry stored in the metadata directory  _",
    "dir_. this pointer must have been computed during the write operation with timestamp  @xmath56 and was later stored in _",
    "dir_by the same client .",
    "note that by lemma  [ lem : unqwrites ] , no other write has timestamp @xmath56 . from the algorithm of the writer",
    ", it follows that the entries in _ readhash _ were generated as hash values of the fragments , i.e. , @xmath57 =    h(\\bar{v}_i)$ ] , where @xmath58 for @xmath59 represent the erasure - coded fragments of some value  @xmath60 .",
    "based on the check by the reader and the security property of the hash function , this means that @xmath61 for all @xmath62 .",
    "the completeness of the erasure code now implies that the reconstruction yields @xmath63 , the value associated to  @xmath56 and written by @xmath46 .",
    "[ lem : concurrent ] consider an operation  @xmath26 of type _",
    "r_-_read _ invoked by a reader  @xmath14 , with timestamp @xmath44 . at the time when @xmath14 determines  @xmath44 ( by _ highestread _ ) , there are at least @xmath0 distinct correct data nodesthat store a data fragment ( different from  @xmath23 ) under timestamp  @xmath44 and they do not free this fragment before @xmath14 completes  @xmath26 .",
    "suppose that @xmath64 and the writer is client  @xmath27 .",
    "consider a sequence @xmath65 of _",
    "r_-_write _ operations executed by @xmath27 with respective timestamps @xmath66 , of which some are concurrent to  @xmath26 .",
    "now consider the linearization of _ dir_and let @xmath67 be the last one among these _",
    "r_-_write _ operations whose _ dir_-_update _ ( denoted by _",
    "dir_-@xmath68 ) precedes the _ dir_-_update _ operation of the reader during  @xmath26 ( denoted by _",
    "dir_-@xmath69 ) .",
    "let _ readindex _",
    "denote the reader s index at the time when  @xmath14 invokes _",
    "dir_-@xmath69 .",
    "w.l.o.g .",
    "suppose that _ dir_-@xmath69follows at least one _ dir_-_update _ operation that is triggered by an",
    "_ r_-_write _ operation of  @xmath27 ; furthermore , suppose that @xmath27 executes at least one more _",
    "r_-_write _ operation _ dir_-@xmath70 after _ dir_-@xmath68 .",
    "we claim that @xmath71 . to show this , we distinguish four cases , considering the linearization of operations on  _",
    "dir_. let _",
    "dir_-@xmath72 denote the second invocation of _ dir_-_scan _ during @xmath67 , the one from which the writer takes  _",
    "readindex_.    case  1 : : :    suppose that _",
    "dir_-@xmath69precedes    _ dir_-@xmath72 ; this means that    @xmath27 detects the concurrent read  @xmath26 during    @xmath67 , in the sense that  @xmath27 updates its    variable @xmath73 $ ] to _",
    "+    ( case  1.a ) if the _",
    "dir_-_scan _ operation of the reader  @xmath14    during  @xmath26 , denoted by    _ dir_-@xmath74 , precedes    _ dir_-@xmath70 , then @xmath14    obtains @xmath75 as the    highest timestamp stored in  @xmath25 by the algorithm .",
    "+    ( case  1.b ) otherwise , _ dir_-@xmath74follows    _ dir_-@xmath70 ; then the    reader  @xmath14 obtains @xmath25 such that    @xmath30.{\\textit{frozenindex}}[c]$ ] is equal to  _ readindex _    and @xmath76.{\\textit{frozenptrlist}}[c].{\\textit{ts } } = { \\textit{ts}}_{w , i}$ ] ,    according to _ readfrom _ in the protocol and because    @xmath30.{\\textit{frozenindex}}[c]$ ] is equal to  _ readindex_. case  2 : : :    suppose that",
    "_ dir_-@xmath69follows    _ dir_-@xmath72 .",
    "this means that    _ dir_-@xmath69 takes place between    _ dir_-@xmath72 and    _ dir_-@xmath70 and @xmath27    detects the concurrent read  @xmath26 only during    @xmath77 , after executing    _ dir_-@xmath78 .",
    "the same two sub - cases    may occur now .    +    ( case  2.a ) if _ dir_-@xmath74precedes    _ dir_-@xmath70 , then    @xmath79 , analogous to case  1.a .",
    "+    ( case  2.b ) otherwise , _ dir_-@xmath74follows    _ dir_-@xmath70 and the reader obtains    @xmath80 . to see this",
    ",    suppose that ( case  2.b.i )    _ dir_-@xmath74precedes the    _ dir_-@xmath81 in the subsequent    _ r_-_write _ operation of  @xmath27 or there is no such    _ r_-_write _ ; then , the value _ readindex _ of @xmath14 remains    greater than @xmath30.{\\textit{frozenindex}}[c]$ ] and thus    @xmath14 sets    @xmath80 .",
    "alternatively    ( case  2.b.ii ) , suppose that    _ dir_-@xmath74follows    _ dir_-@xmath81 ; then , according to the    protocol , the writer has already set    @xmath30.{\\textit{frozenindex}}[c ] =        { \\textit{readindex}}$ ] during    _ dir_-@xmath81 and @xmath14 sets    @xmath82 analogous to case  1.b .",
    "suppose the reader determines that @xmath83 ; then the correct nodesin @xmath84 store a fragment of the associated value because at least @xmath85 nodesin _ readptr_._set _ have sent a _ @xmath48_-_writeack _ for  @xmath44 to the writer . accounting for the up to @xmath3 faulty nodes",
    ", at least @xmath0 correct nodeshave once stored a fragment in @xmath86 $ ] .",
    "it remains to argue why these nodesdo not free this fragment before @xmath14 completes  @xmath26 .    in case  1.a",
    ", the writer detects the concurrent read during @xmath67 and therefore excludes the data fragments associated to @xmath44 from garbage collection for  @xmath14 , by setting @xmath87.{\\textit{ts}}$ ] to @xmath44 in its state . according to the logic of the protocol",
    ", @xmath44 remains frozen and the corresponding fragments are retained at least until @xmath14 invokes a subsequent read operation . in case  2.a ,",
    "almost the same happens during @xmath77 , when the writer detects the concurrent read .",
    "the writer sets @xmath88.{\\textit{ts}}$ ] to @xmath44 in its state . again according to the protocol",
    ", @xmath44 remains reserved and the writer retains the corresponding fragments at least until @xmath14 invokes a subsequent read .    intuitively ,",
    "cases  1.a and 2.a demonstrate why @xmath27 retains two values during a write ( the one being written and the one written before ) : @xmath27 does not know which one of the two the reader is about to access .    in case  2.b.i , if the writer detects the concurrent read during @xmath89 , then it reserves and retains  @xmath44 and the claim follows analogously to case  2.a .    in cases  1.b and 2.b.ii",
    ", the reader accesses a frozen value . again , according to the protocol , @xmath44 remains frozen and is retained at least until @xmath14 invokes a subsequent read operation .",
    "the lemma follows .",
    "[ thm : atomic ] given a atomic snapshot object _ dir _",
    ", protocol aweemulates an atomic mrmw register  _",
    "r_.    we show that every execution @xmath90 of the protocol is linearizable with respect to an mrmw register . by lemma  [ lem : integr ] , the timestamp of a _",
    "r_-_read _ either has been written by some _",
    "r_-_write _ operation or _",
    "r_-@xmath91 returns  @xmath23 .",
    "we first construct an execution  @xmath92 from @xmath90 by completing all operations of type _",
    "r_-_write _ for those values  @xmath24 that have been returned by some _",
    "r_-_read _ operation .",
    "then we obtain a sequential permutation  @xmath93 from @xmath92 as follows : ( 1 ) order all operations according to their timestamps ; ( 2 ) among the operations with the same timestamp , place the _",
    "r_-_read _ operations immediately after the unique _",
    "r_-_write _ with this timestamp ; and ( 3 ) arrange all non - concurrent operations in the same order as in  @xmath92 .",
    "note that concurrent _",
    "r_-_read _ operations with the same timestamp may appear in arbitrary order .    for proving that @xmath93 is a view of @xmath92 at a client  @xmath14 w.r.t .",
    "a register , we must show that every _",
    "r_-_read _ operation returns the value written by the latest preceding _",
    "r_-_write _ that appears before in @xmath93 or @xmath23 if there is no such operation .",
    "let @xmath26 be an operation of type _",
    "r_-@xmath91with timestamp  @xmath44 that returns a value  @xmath24 .",
    "if @xmath94 , then by construction @xmath26 is ordered before any write operation in  @xmath93 . otherwise , it holds @xmath45 and according to lemma  [ lem : integr ] , there exists an _",
    "operation @xmath46 that writes @xmath24 with the same timestamp . in this case",
    ", @xmath46 is placed in @xmath93 before @xmath26 by construction .",
    "r_-_write _ operation appears between @xmath46 and @xmath26 because all other write operations have a different timestamp and therefore appear in @xmath93 either before  @xmath46 or after  @xmath26 .",
    "it remains to show that @xmath93 preserves the real - time order of  @xmath90 .",
    "consider two operations  @xmath21and @xmath31 in @xmath92 with timestamps @xmath95 and @xmath96 , respectively , such that @xmath21precedes  @xmath31 . from lemma  [ lem : partorder",
    "] , we have @xmath97 . if @xmath98 then @xmath31appears after @xmath21 in @xmath93 by construction .",
    "otherwise @xmath99 and @xmath31must be an operation of type _",
    "r_-_read_. if @xmath21 is of type _",
    "r_-_write _ , then @xmath31appears after @xmath21since we placed each _ r_-_read _ after the _",
    "r_-_write _ with the same timestamp .",
    "otherwise , @xmath21is a _ r_-_read _ and the two _ r_-_read _",
    "operations appear in @xmath93 in the same order as in  @xmath92 by construction .    0    consider an r - read operation by client  @xmath14 with timestamp @xmath100 / pointer @xmath101 ; then at least distinct @xmath102 data nodesthat store a data fragment such that @xmath103 etc . matches   and they do not `` free '' these before @xmath14 invokes its subsequent r - read op .",
    "adapt from below    [ lem : concwr ] let @xmath26 be an operation of type _",
    "r_-_read _ with timestamp @xmath44 invoked by a reader @xmath104 , and @xmath105 be operations of type _",
    "r_-_write _ invoked by the only writer @xmath106 , and @xmath107 their respective timestamps .",
    "we further assume that some of the _ r_-_write _ operations are concurrent with @xmath26 .",
    "now , let @xmath67 be the most recent _",
    "r_-_write _ operation whose",
    "_ dir_-_update _ ( we call the latter",
    "_ dir_-@xmath68 ) completes before the _ dir_-_update _ of the @xmath26 ( we call the latter _ dir_-@xmath69 ) .",
    "then , @xmath75 or @xmath80 .",
    "+ [ [ ] ] ( 1 ) if there is no",
    "_ dir_-@xmath68 call that has completed before _ dir_-@xmath69 , then @xmath108 or @xmath109 .",
    "( 2 ) if @xmath110 , then @xmath111 .",
    "+ furthermore , these two values are _ frozen _ ,",
    "i.e. , excluded from garbage collection by @xmath106 until @xmath26 * * completes**.    we distinguish between the two cases :    * _ dir_-@xmath69 precedes _ dir_-@xmath72 : here , the writer @xmath106 detects the ongoing @xmath26 , and updates its local _ frozenindex _ variable accordingly .",
    "if _ dir_-@xmath74 precedes _",
    "dir_-@xmath70 , then @xmath75 . otherwise , if _",
    "dir_-@xmath74 is invoked at any point after _",
    "dir_-@xmath70 , @xmath26 forces @xmath75 ; the latter is because from this point onwards _ readindex _ within @xmath26 is equal to @xmath112.{\\textit{frozenindex}}[c_r]$ ] .",
    "* _ dir_-@xmath69 does not precede _",
    "dir_-@xmath72 : in this case _",
    "dir_-@xmath69 is invoked between _ dir_-@xmath72 and _ dir_-@xmath70 , and the writer @xmath106",
    "detects the ongoing @xmath26 via _ dir_-@xmath78 . as before ,",
    "if _ dir_-@xmath74is invoked before _",
    "dir_-@xmath70 , @xmath75 .",
    "dir_-@xmath74 is invoked at any point after _",
    "dir_-@xmath70 , then @xmath80 .",
    "in particular , if _ dir_-@xmath74occurs before _ dir_-@xmath81 ( assuming that @xmath113 ) , _ readindex _ within @xmath26 remains greater than @xmath112.{\\textit{frozenindex}}[c_r]$ ] , and thus reads sets @xmath80 .",
    "otherwise , _ readindex _",
    "dir_-@xmath74occurs equals to @xmath112.{\\textit{frozenindex}}[c_r]$ ] , and @xmath26 forces @xmath80 . clearly , if @xmath114 , @xmath26 sets @xmath115 .",
    "it is easy to see , that if @xmath116 , then @xmath26 sets @xmath115 .",
    "similarly , if @xmath117 , i.e. , _ dir_-@xmath69 takes place before _",
    "dir_-@xmath118 , then if _ dir_-@xmath74is invoked before _ dir_-@xmath118 , @xmath26 sets @xmath119 , while if _ dir_-@xmath74is invoked after _",
    "dir_-@xmath118 , @xmath26 sets @xmath120 .",
    "in addition , it is easy to see that in both cases , @xmath44 is frozen by @xmath106 . [ [ ] ]",
    "[ lem : concmwr ] let @xmath26 be an operation of type _ r_-_read _ with timestamp @xmath44 invoked by a reader @xmath104 , and @xmath121 be operations of type _",
    "r_-_write _ invoked by each writer @xmath122 , and @xmath107 their respective timestamps .",
    "we further assume that some of the _ r_-_write _ operations are concurrent with @xmath26 , while _",
    "r_-_write _ operations of different clients can also be concurrent with each other and/or with @xmath26 .",
    "now , assume that for each writer @xmath122 , @xmath123 denotes the the most recent _ r_-_write _ operation of @xmath106 whose",
    "_ dir_-_update _ ( we call the latter @xmath124 ) completes before the _ dir_-_update _ of the @xmath26 ( we call the latter _ dir_-@xmath69 ) .",
    "then , @xmath125    it derives directly from lemma  [ lem : concwr ] .",
    "+ [ [ ] ] +    [ thm : waitfree ] given an atomic snapshot object _",
    "dir_and assuming that @xmath126 , protocol aweis wait - free .    as the atomic snapshot _",
    "dir_operates correctly , all its operations eventually complete independently of other processes .",
    "it remains to show that no _ r_-_write _ and no _ r_-_read _ operation blocks .",
    "operation , the client needs to receive @xmath127 _",
    "@xmath48_-_writeack _ events from distinct data nodes before completing .",
    "as there are @xmath1 nodesand up to @xmath3 may be faulty , the assumption @xmath128 implies this .    during a _ r_-_read _",
    "operation , the reader needs to obtain @xmath0 valid fragments , i.e. , fragments that pass the verification of their hash value . according to lemma  [ lem : concurrent ] ,",
    "there are at least @xmath0 correct data nodesdesignated by _",
    "readptr_._set _ that store a fragment under timestamp  @xmath44 until the operation completes .",
    "as the reader contacts these nodesand waits for @xmath0 fragments , these fragments eventually arrive and can be reconstructed to the value written by the writer by the completeness of the erasure code .",
    "this paper has presented awe , the first _ erasure - coded _ distributed implementation of a multi - writer multi - reader read / write storage object that is , at the same time : ( 1 ) asynchronous , ( 2 ) wait - free , ( 3 ) atomic , ( 4 ) amnesic , ( i.e. , with data nodesstoring a bounded number of values ) and ( 5 ) byzantine fault - tolerant ( bft ) using the optimal number of nodes .",
    "aweis efficient since it does not use public - key cryptography and requires data nodesthat support only reads and writes , further reducing the cost of deployment and ownership of a distributed storage solution .",
    "notably , awestores metadata separately from @xmath0-out - of-@xmath1 erasure - coded fragments .",
    "this enables aweto be the first bft protocol that uses as few as @xmath2 data nodesto tolerate @xmath3 byzantine nodes , for any @xmath4 .",
    "future work should address how to optimize protocol aweand to reduce the storage consumption for practical systems ; this could be done at the cost of increasing its conceptual complexity and losing some of its ideal properties .",
    "for instance , when the metadata service is moved from a storage abstraction to a service with processing , it is conceivable that fewer values have to be retained at the nodes .",
    "we thank alessandro sorniotti , nikola kneevi , and radu banabic for inspiring discussions during the early stages of this work .",
    "this work is supported in part by the eu cloudspaces ( fp7 - 317555 ) and seccrit ( fp7 - 312758 ) projects .",
    "10    i.  abraham , g.  chockler , i.  keidar , and d.  malkhi .",
    "byzantine disk paxos : optimal resilience with byzantine shared memory . , 18(5):387408 , 2006 .",
    "a.  adya , w.  j. bolosky , m.  castro , g.  cermak , r.  chaiken , j.  r. douceur , j.  howell , j.  r. lorch , m.  theimer , and r.  p. wattenhofer . : federated , available , and reliable storage for an incompletely trusted environment . in _ proc .",
    "5th symp .",
    "operating systems design and implementation ( osdi ) _ , 2002 .",
    "y.  afek , h.  attiya , d.  dolev , e.  gafni , m.  merritt , and n.  shavit .",
    "atomic snapshots of shared memory . , 40(4):873890 , 1993 .",
    "a.  bessani , m.  correia , b.  quaresma , f.  andr , and p.  sousa . : dependable and secure storage in a cloud - of - clouds . in _ proc .",
    "6th european conference on computer systems ( eurosys ) _ , pages 3146 , 2011 .",
    "k.  d. bowers , a.  juels , and a.  oprea . : a high - availability and integrity layer for cloud storage . in _ proc .",
    "16th acm conference on computer and communications security ( ccs ) _ , pages 187198 , 2009 .    c.  cachin , d.  dobre , and m.  vukoli .",
    "storage with @xmath9 data replicas .",
    "report arxiv:1305.4868 , corr , 2013 .    c.  cachin , r.  guerraoui , and l.  rodrigues . .",
    "springer , 2011 .    c.  cachin , b.  junker , and a.  sorniotti . on limitations of using cloud storage for data replication .",
    "wraits , 2012 .    c.  cachin and s.  tessaro .",
    "optimal resilience for erasure - coded byzantine distributed storage . in _ proc .",
    "international conference on dependable systems and networks ( dsn - dccs ) _ , pages 115124 , 2006 .    v.  r. cadambe , n.  lynch , m.  medard , and p.  musial . coded",
    "atomic shared memory emulation for message passing architectures .",
    "csail technical report mit - csail - tr-2013 - 016 , mit , 2013 .",
    "g.  chockler , r.  guerraoui , and i.  keidar .",
    "amnesic distributed storage . in g.",
    "taubenfeld , editor , _ proc .",
    "21th international conference on distributed computing ( disc ) _ , volume 4731 of _ lecture notes in computer science _ , pages 139151 .",
    "springer , 2007 .",
    "d.  dobre , g.  karame , w.  li , m.  majuntke , n.  suri , and m.  vukoli . : proofs of writing for efficient and robust storage . in _ proc .",
    "acm conference on computer and communications security ( ccs ) _",
    ", 2013 .",
    "d.  dobre , m.  majuntke , and n.  suri . on the time - complexity of robust and amnesic storage . in t.",
    "p. baker , a.  bui , and s.  tixeuil , editors , _ proc .",
    "12th conference on principles of distributed systems ( opodis ) _ , volume 5401 of _ lecture notes in computer science _ , pages 197216 .",
    "springer , 2008 .",
    "p.  dutta , r.  guerraoui , and r.  r. levy .",
    "optimistic erasure - coded distributed storage . in g.",
    "taubenfeld , editor , _ proc .",
    "22th international conference on distributed computing ( disc ) _ , volume 5218 of _ lecture notes in computer science _ , pages 182196 .",
    "springer , 2008 .",
    "s.  frlund , a.  merchant , y.  saito , s.  spence , and a.  veitch . a decentralized algorithm for erasure - coded virtual disks . in _ proc .",
    "international conference on dependable systems and networks ( dsn - dccs ) _ , pages 125134 , 2004 .",
    "g.  r. goodson , j.  j. wylie , g.  r. ganger , and m.  k. reiter .",
    "efficient byzantine - tolerant erasure - coded storage . in _ proc .",
    "international conference on dependable systems and networks ( dsn - dccs ) _ , pages 135144 , 2004 .",
    "r.  guerraoui , r.  r. levy , and m.  vukoli .",
    "lucky read / write access to robust atomic storage . in _ proc .",
    "international conference on dependable systems and networks ( dsn - dccs ) _ , pages 125136 , 2006 .",
    "j.  hendricks . .",
    "phd thesis , school of computer science , carnegie mellon university , july 2009 .",
    "j.  hendricks , g.  r. ganger , and m.  k. reiter . low - overhead byzantine fault - tolerant storage . in _ proc .",
    "21st acm symposium on operating systems principles ( sosp ) _ , 2007 .",
    "m.  herlihy .",
    "wait - free synchronization .",
    ", 11(1):124149 , jan . 1991 .",
    "m.  p. herlihy and j.  m. wing .",
    "linearizability : a correctness condition for concurrent objects . , 12(3):463492 , july 1990 .",
    "c.  huang , h.  simitci , y.  xu , a.  ogus , b.  calder , p.  gopalan , et  al .",
    "erasure coding in windows azure storage . in _ proc .",
    "usenix annual technical conference _ , 2012 .",
    "n.  a. lynch . .",
    "morgan kaufmann , san francisco , 1996 .",
    "martin , l.  alvisi , and m.  dahlin . minimal byzantine storage . in d.",
    "malkhi , editor , _ proc .",
    "16th international conference on distributed computing ( disc ) _ , volume 2508 of _ lecture notes in computer science _ , pages 311325 .",
    "springer , 2002 .",
    "j.  s. plank .",
    "erasure codes for storage applications .",
    "tutorial , presented at the usenix conference on file and storage technologies ( fast ) , 2005 .",
    "m.  o. rabin .",
    "efficient dispersal of information for security , load balancing , and fault tolerance .",
    "36(2):335348 , 1989 .    w.  wong .",
    "cleversafe grows along with customers data storage needs .",
    "chicago tribune , nov .",
    "j.  yin , j .-",
    "martin , a.  v.  l. alvisi , and m.  dahlin . separating agreement from execution in byzantine fault - tolerant services . in _ proc .",
    "19th acm symposium on operating systems principles ( sosp ) _ , pages 253268 , 2003 ."
  ],
  "abstract_text": [
    "<S> although many distributed storage protocols have been introduced , a solution that combines the strongest properties in terms of availability , consistency , fault - tolerance , storage complexity and the supported level of concurrency , has been elusive for a long time . combining these properties is difficult , especially if the resulting solution is required to be efficient and incur low cost .    </S>",
    "<S> we present awe , the first _ erasure - coded _ distributed implementation of a multi - writer multi - reader read / write storage object that is , at the same time : ( 1 ) asynchronous , ( 2 ) wait - free , ( 3 ) atomic , ( 4 ) amnesic , ( i.e. , with data nodesstoring a bounded number of values ) and ( 5 ) byzantine fault - tolerant ( bft ) using the optimal number of nodes . </S>",
    "<S> furthermore , aweis efficient since it does not use public - key cryptography and requires data nodesthat support only reads and writes , further reducing the cost of deployment and ownership of a distributed storage solution . </S>",
    "<S> notably , awestores metadata separately from @xmath0-out - of-@xmath1 erasure - coded fragments . </S>",
    "<S> this enables aweto be the first bft protocol that uses as few as @xmath2 data nodesto tolerate @xmath3 byzantine nodes , for any @xmath4 . </S>"
  ]
}