{
  "article_text": [
    "polar codes , introduced in @xcite , were proved to achieve the symmetric capacity for bdmcs .",
    "the original construction in @xcite is defined for block length values that are a power of @xmath1 . in this paper",
    ", we consider  subset polar codes \" which are constructed by puncturing a subset of coded bits from a polar code . for construction of subset polar codes",
    ", we start with a low rate polar code , and greedily puncture output bits ( similar to @xcite ) to create a code of higher rate _ without re - optimizing _ the set of information bits . for supporting h - arq ,",
    "it is important that the set of information bits for subset polar code is same as the original polar code .",
    "this is because re - optimizing the set of information bits changes the code structure which makes it difficult for the receiver to jointly decode multiple transmissions .",
    "we use the notation @xmath2 to denote a subset polar code of block length @xmath3 constructed from an @xmath4 polar code by puncturing @xmath5 coded bits .",
    "we call the @xmath4 polar code as a mother polar code . in this paper",
    ", we propose a construction for subset polar codes , and its use for h - arq .",
    "the main simulation results regarding subset polar code constructions and h - arq are in which show :    * two @xmath6 subset polar codes , decoded _ individually _ , perform within @xmath7 db ( at @xmath0 bler ) of a @xmath8 polar code . * two @xmath6 subset polar codes , decoded _",
    "jointly _ , perform @xmath9 db better ( at @xmath0 bler ) than a @xmath8 polar code and achieve , by construction , performance of the @xmath10 mother polar code that they were constructed from .    throughout this paper ,",
    "the following assumptions are used : ( i ) code construction in @xcite based on evaluation of bhattacharya bounds is used . under this construction , optimized value ( for @xmath0 bler ) of @xmath11",
    "is used for ( mother ) polar code construction which corresponds to @xmath12 for the @xmath10 polar code and @xmath13 for the @xmath8 polar code ; ( ii ) for decoding , simplified llr based , crc - aided ( 16 bit ) , list decoding ( @xmath14 ) algorithm is used @xcite .",
    "polar code is 0.1 db worse than reported in @xcite possibly due to sub - optimal code construction and/or llr based receiver which uses the ` hardware - friendly ' ( see @xcite ) update equations for large values of llr .",
    "c and matlab implementations are provided in @xcite . ]        the rest of the paper is organized as follows : notation is discussed in .",
    "discusses subset polar code construction . in",
    ", we provide a h - arq extension for subset polar codes . in ,",
    "we discuss relation with prior work , and finally in , we prove some results regarding subset polar codes that justify constructions proposed in this paper .",
    "* @xmath15 : block length of mother polar code ( @xmath16 ) ; * @xmath3 : block length of a subset polar code ( @xmath17 ) ; * @xmath18 : number of information bits ; * @xmath19 denotes a puncturing pattern of distinct indexes that specifies a subset polar code by removing coded bits with indexes @xmath20 from a @xmath4 mother polar code ; * @xmath21 denotes a subset polar code by using coded bits with distinct indexes @xmath22 from a @xmath4 mother polar code ; * @xmath23 denotes binary representation of @xmath24 where @xmath25 ; * let @xmath26 be integers , define @xmath27 if @xmath28 where @xmath29 are binary representations of @xmath30 respectively , and @xmath31 denotes the binary xor operation ; * @xmath32 is the bec parameter used for code construction .",
    "for construction of subset polar codes , we start with a low rate mother polar code . polar code construction in @xcite based on evaluation of bhattacharya parameter bounds",
    "the set of information and crc bits is optimized for @xmath32 parameter that gives the best performance for the mother polar code .",
    "a subset polar code is constructed by puncturing coded bits from the mother polar code .",
    "the puncturing algorithm is a greedy algorithm that selects a coded bit to puncture at each step by estimating the bler after puncturing that coded bit in addition to already punctured coded bits .",
    "the algorithm additionally adaptively changes the design @xmath32 to keep the estimated bler at a given target bler .",
    "the proposed algorithm is similar to the ppa algorithm in @xcite with the exception of update of the design @xmath32 .",
    "the update of the design @xmath32 appears to improve performance by keeping the union bound tight for estimating bler ( see results in ) .",
    "the above description is provided in the form of a pseudo - code in and . the algorithm for estimating bler",
    "is omitted .",
    "bler is estimated the union bound , which uses the sum of bhattacharya bounds for the polarized channels corresponding to information and crc bits of the mother polar code .",
    "the performance of the scheme was evaluated for codes with @xmath33 by starting with a @xmath10 code and constructing subset polar codes with smaller block length .",
    "shows the comparison of subset polar code and a code designed directly for @xmath34 .",
    "we see that the subset code is less than @xmath7 db away at @xmath35 block error rate .",
    "we that some performance loss is expected since the set of information bits for the subset polar code is optimized for the mother polar code ( @xmath36 ) . as we will see in that this loss can be recovered when considered in context of h - arq .",
    "[ proc : puncture ] @xmath37",
    "@xmath38 @xmath39 @xmath40 ` continue ` @xmath41 = \\textsc{estimate bler}(p \\cup \\{l\\ } , \\epsilon)$ ] @xmath42 @xmath43 * return *",
    "@xmath44    @xmath45 @xmath46 @xmath47 * return * @xmath32",
    "we study the problem of supporting h - arq with polar codes ( called polar h - arq ) motivated by wireless system design . as background ,",
    "note that in lte ( see e.g. @xcite ) , h - arq is supported for turbo codes by arranging the coded bits in a circular buffer , and redundancy versions ( rv ) are specified by an offset within the circular buffer . here , we look at the problem of constructing rvs for polar codes .",
    "we consider the following two to be desirable principles of rv design for a wireless system :    1 .",
    "_ individually _ decoding each rv has good performance 2 .   _",
    "jointly  _ decoding multiple rvs has good performance    the first principle is motivated by the fact that in a wireless system , different transmissions may experience different channel fades , and hence the performance at the receiver may be dominated by a ( re)-transmission that experiences a good channel fade .",
    "this is especially important in case of limited feedback system ( e.g. only ack / nack feedback from the receiver rather than complete channel state information ) .",
    "this motivates the principle that each rv has good decoding performance when individually decoded .",
    "the second principle is targeting coding gain from multiple transmissions .",
    "one approach for polar h - arq is to take ordering given by a subset polar code , and write it in a circular buffer similar to lte .",
    "however , it is unclear what offsets , if any , provide good performance for other rvs .",
    "for example , it is unclear if complement of a subset polar code is a good subset polar code .",
    "simulation results suggest that it is not a good subset polar code .",
    "hence , we propose an alternate way to generate redundancy versions which is discussed next .      we define a notion of equivalent subset polar codes as :    [ def1 ] let @xmath48 and @xmath49 be two @xmath2 subset polar codes .",
    "we say @xmath50 is equivalent to @xmath51 if @xmath52 , @xmath53 for some integer @xmath54 , where @xmath25 .    the operation @xmath55 is defined for integers in . with some abuse of notation , we use @xmath56 to denote this relation between subsets , puncturing patterns or subset codes @xmath50 and @xmath51 .",
    "next , we define equivalence of channels :    let @xmath57 and @xmath58 be two binary input channels with output alphabets @xmath59 and @xmath60 respectively .",
    "we define the two channels are equivalent , @xmath61 , if there exists an invertible function @xmath62 such that @xmath63 .",
    "we now relate the two notions of equivalence through the following theorem .",
    "let @xmath50 be a @xmath2 subset polar code and @xmath64 be a symmetric b - dmc .",
    "let @xmath65 denote polarized bit - channels corresponding to the polarization transform for @xmath3 i.i.d .",
    "realizations of channel @xmath64 for indexes in @xmath50 , and @xmath5 realizations of an erasure channel for indexes not in @xmath50 ( defined formally in ) .",
    "[ thm1 ] if @xmath66 are equivalent subset polar codes , then channels @xmath65 and @xmath67 are equivalent for each @xmath68 .",
    "proof is given in .",
    "we note that the notion of equivalent subset polar codes is similar to the equivalent shorterning patterns discussed in @xcite to reduce complexity of subset code construction .",
    "equivalent subsets will be considered equivalent patterns as per definition in @xcite .",
    "we give an explicit construction ( as per definition 1 ) , and a general proof for this construction .",
    "proof in @xcite is for equality of the error probability estimate via gaussian approximation for the awgn channel .",
    "finally , we propose to support polar h - arq by starting with an initial subset polar code , and creating multiple rvs by selecting an appropriate value @xmath54 for each rv , and using the construction given by .",
    "however , we discuss a modification of in order to improve performance of polar h - arq under this proposal .      the proposal to create multiple rvs by selecting @xmath54 satisfies principle 1 but not necessarily principle 2 .",
    "one reason for this is that two equivalent subsets @xmath50 and @xmath51 may have significant overlap , and hence @xmath69 may not be a good code . to solve this problem , we modify the construction of the initial subset polar code to take into account @xmath54 while designing the initial pattern @xmath44 . in particular , pattern @xmath44 is defined while making sure that @xmath44 and @xmath70 are disjoint as long as @xmath71 .",
    "this is a small modification to , and is shown in below as  symmetric greedy construction \" .",
    "@xmath37 @xmath72 @xmath40    ` continue ` @xmath41 = \\textsc{estimate bler}(p \\cup \\{l\\ } , \\epsilon)$ ] @xmath42 @xmath43 * return * @xmath44    shows the performance comparison .",
    "the symmetric greedy construction curve is denoted by s - subset polar code ( ) and can be seen to almost overlap with the greedy construction ( ) . the loss of with respect to is less than @xmath73 db .",
    "the gain of for polar h - arq is significant as seen in the next section .",
    "polar h - arq is supported by creating a subset polar code , @xmath50 , as per .",
    "we use value of @xmath74 .",
    "we get two @xmath6 subset polar codes , @xmath50 and @xmath75 , which are used as the two rvs .",
    "we note that more than two rvs can be generated by using this basic construction of equivalent subset codes @xmath50 and @xmath75 .",
    "for example , two additional rvs can be generated as @xmath76 and @xmath77 .",
    "the polar h - arq performance is demonstrated in . it shows ( i ) two rvs , when decoded individually",
    ", have the same performance , and the performance is within @xmath7 db ( at @xmath0 bler ) of a @xmath8 polar code , and ( ii ) two rvs when decoded jointly , achieve performance of @xmath10 mother polar code , which is about @xmath9 db better than the @xmath8 polar code .",
    "the original polar construction in @xcite used block length values that are powers of 2 . following @xcite ,",
    "there has been significant work to extend the construction to other block length values .",
    "there are two different types of extensions : ( i ) for example @xcite extends polar constructions using an @xmath78 kernel ; ( ii ) @xcite , @xcite , @xcite extend polar constructions by puncturing coded bits from an original polar code . here , we limit the discussion to works related to the second approach , and more specifically to constructions that do not re - optimize the set of information bits . in addition , we discuss work related to h - arq with polar codes .",
    "proposed is a small variation of the ppa algorithm proposed in @xcite - the variation being update of the design @xmath32 .",
    "the algorithm in @xcite also uses gaussian approximation of density evolution for code construction . here",
    ", we use the simplified approach of using bounds on the bhattacharya parameters which is numerically faster ( see results in @xcite that suggest that these two approaches have similar performance ) . in other work , @xcite considered similar approach for code construction and proposed multiple algorithms . in particular , algorithm 4 in @xcite is based on selecting coded bits that when punctured lead to zero capacity for the lowest capacity bit channels for the mother polar code which are frozen by code construction .",
    "a simulation comparison is shown in the below .",
    "the results demonstrate that , for the parameters considered here , the proposed algorithm does about 0.25 and 0.75  db better than algorithm with fixed @xmath32 and algorithm based on frozen bits respectively .",
    "one reason for worse performance of fixed @xmath32 algorithm is that the union bound is not tight for high code rate when evaluated for high value of @xmath32 .",
    "scheme for subset polar code construction , we also tried using a low value of @xmath32 ( or equivalently high value of snr ) for code design .",
    "this helps to keep the union bound tight , but the starting code itself has a significantly worse performance for the regime of interest ( @xmath79 bler ) . ]",
    "the work in @xcite proposes a h - arq extension of the ppa algorithm by using the coded bits not transmitted during the first transmission .",
    "this proposal will have a similar performance when jointly decoding rvs , but it is unclear if each rv individually will have a good performance .",
    "this , for example , is important for a wireless system where the first transmission can experience a deep fade .",
    "in addition to the traditional h - arq approach discussed in this paper ( and in @xcite ) , another approach is proposed for polar h - arq in @xcite , @xcite , @xcite , @xcite . at a high level ,",
    "the motivation for these works is to be able to optimize code for each re - transmission by re - selecting the set of information bits .",
    "this improves performance of each transmission .",
    "however , since each transmission is effectively a different code , it is harder for the receiver to combine multiple transmissions .",
    "for example , the puncturing pattern in @xcite will lead to the @xmath6 code to have the same performance as @xmath8 code by re - optimizing the set of information bits .",
    "when jointly decoding multiple transmissions , the performance will be worse than performance of the base @xmath10 polar code ( e.g. see results in @xcite ) .",
    "here , we prove . we start with a generalized notion of polarization , and then prove two lemmas regarding the generalization before proving .",
    "we generalize the notion of polarization in @xcite to define polarization of two channels that are independent but not necessarily identically distributed ( same as the definition of  compound polar channels \" in @xcite ) .",
    "let @xmath57 and @xmath58 be two binary input channels with output alphabets @xmath59 and @xmath60 respectively .",
    "we say a pair of binary input channels @xmath80 and @xmath81 are obtained by single - step polarization transformation @xmath82 if : @xmath83 we denote the polarization as @xmath84 .",
    "one special case is when one of the channels is  punctured \" .",
    "we define puncturing by use of an erasure channel , @xmath85 , that leads to an erasure with probability @xmath86 .",
    "for example , for n = 2 , if @xmath87 , the polarization transform for a subset polar code would involve @xmath88 .",
    "that is , the second realization of the channel @xmath64 is replaced by channel @xmath85 .",
    "we use this construction recursively to define channels @xmath65 starting with @xmath15 independent realizations of channel @xmath64 but replacing the realizations for indexes not in @xmath50 with @xmath85 .          to prove @xmath93 ,",
    "we use function @xmath94 to be @xmath95 . the equivalence can be verified by writing out the transition probabilities directly . to prove @xmath96 , we use function @xmath97 to be @xmath98 . here",
    ", @xmath99 denotes @xmath100 where @xmath101 is identity permutation and @xmath102 is the permutation such that ( i ) @xmath103 and ( ii ) @xmath104 which exists as the per the definition of a symmetric b - dmc .",
    "we use the same notation to denote the different permutations for alphabets @xmath59 and @xmath60 .",
    "the function @xmath105 shows equivalence of @xmath106 and @xmath107 as follows : @xmath108 we note that some steps in the equation above use the result from @xcite that @xmath109 .",
    "also , it can be checked that @xmath110 and @xmath105 are invertible functions .",
    "[ lem2 ] let @xmath57 and @xmath58 be two independent symmetric b - dmcs , and let @xmath84 .",
    "let @xmath111 and @xmath112 be two independent symmetric b - dmcs , and let @xmath113 .",
    "if @xmath114 , and @xmath115 , then @xmath116 and @xmath117 .          for @xmath126 ( @xmath127 ) ,",
    "the only two non - trivial and equivalent subsets are @xmath87 and @xmath128 .",
    "the polarization transform would involve @xmath88 and @xmath129 .",
    "the equivalence of these channels follows from by using @xmath130 and @xmath131 .",
    "we prove for @xmath133 ( or @xmath134 ) .",
    "let @xmath50 and @xmath51 be the two equivalent subsets for @xmath135 .",
    "we know that @xmath136 .",
    "let @xmath137 be the binary representation of @xmath138 , and let @xmath23 be the binary representation on @xmath139 . to reduce the problem to @xmath132 ,",
    "we define : @xmath140 depending on the value of msb of @xmath141 , @xmath142 , and using the induction assumption , we have : @xmath143 we next use and with the following parameters : @xmath144 to complete the proof , we note that @xmath145 , and @xmath146 .",
    "further , as per , the order of parameters does not matter for polarization , and as per the induction step either ( i ) @xmath147 or ( ii ) @xmath148.therefore , using we conclude that @xmath149 and @xmath150 .",
    "e.  arikan , _ `` channel polarization : a method for constructing capacity - achieving codes for symmetric binary - input memoryless channels '' _ , ieee transactions on information theory , vol .",
    "3051 - 3073 , july 2009 .    m.  el - khamy , h.  lin , j.  lee , i.  kang , h.  mahdavifar , _",
    "`` harq rate - compatible polar codes for wireless communications '' _ , ieee globecom conference ( globecom ) , december 2015 , available at http://arxiv.org/pdf/1508.07698v1.pdf .",
    "a.  balatsoukas - stimming , m.  bastani parizi and a.  burg , _ `` llr - based successive cancellation list decoding of polar codes '' _",
    ", 2014 ieee international conference on acoustics , speech and signal processing ( icassp ) , florence , 2014 , pp . 3903 - 3907 .",
    "s. b. korada , e. sasoglu and r. urbanke , _",
    "`` polar codes : characterization of exponent , bounds , and constructions , '' _ in ieee transactions on information theory , vol .",
    "6253 - 6264 , dec . 2010"
  ],
  "abstract_text": [
    "<S> we consider the problem of supporting h - arq with polar codes . for supporting h - arq , we propose to create redundancy versions based on different , but equivalent , subsets of a polar code . </S>",
    "<S> the equivalent subsets are created from an initial subset of a polar code using an inherent symmetry in polar code construction . </S>",
    "<S> a greedy construction is used to create the initial subset of a polar code .    </S>",
    "<S> we demonstrate performance of proposed constructions via simulations for binary input awgn channel . </S>",
    "<S> we demonstrate that a ( 4096 , 1024 ) polar code can be divided into two disjoint ( 2048 , 1024 ) subset polar codes , which when decoded individually are within 0.2 db ( at @xmath0 bler ) of a ( 2048 , 1024 ) polar code , and achieve performance of a ( 4096 , 1024 ) polar code when decoded jointly . </S>"
  ]
}