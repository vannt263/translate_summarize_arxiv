{
  "article_text": [
    "since its introduction in 1992 , the density matrix renormalisation group@xcite ( dmrg ) algorithm has been extremely successful at the solution of one - dimensional quantum mechanical problems.@xcite following the connection@xcite between the original dmrg algorithm and the variational class of matrix product states ( mps ) , a series of second - generation dmrg algorithms has been developed@xcite which explicitly build on the underlying tensor structure . in these second - generation algorithms , both the current variational state as well as the hamiltonian operator",
    "are represented as tensor networks , namely mps and matrix product operators ( mpo ) .",
    "as such , the correct construction of the mpo representation of the hamiltonian at hand is the starting point of any dmrg calculation .",
    "this construction can be done fairly easily by hand for short - range hamiltonians , if necessary with the help of a finite - state machine@xcite which generates the required terms in the mpo .",
    "however , these finite - state machines can very quickly become extremely complicated ( see e.g.  ref .",
    "fig .  7 ,",
    "9 and 10 for automata to generate interactions on a two - dimensional cylinder ) .",
    "other analytical approaches@xcite to construct the mpo representation of in particular quantum chemistry hamiltonians require individual treatment of each system and type of interaction by hand .    in this paper , we will present a generic method to construct arbitrary mpos based solely on a ) the definition of appropriate single - site operators ( such as @xmath0 or @xmath1 ) and b ) the implementation of a model - independent mpo arithmetic .",
    "we will show that using these two ingredients , it is possible to efficiently construct the optimal representations of small powers of one - dimensional hamiltonians and of medium - range hamiltonians on two - dimensional cylinders .",
    "we further provide a proof - of - principle that the constructive approach is also able to generate the optimal representation for the four - body quantum chemistry hamiltonian with long - range interactions .",
    "the outline of the paper is as follows : in section [ sec : mpodef ] we define mpos as widely used in the literature .",
    "sections [ sec : sso ] and [ sec : arithmetic ] summarise and supplement the existing works on the construction of fundamental single - site operators such as @xmath2 in mpo form as well as the addition and multiplication of arbitrary mpos .",
    "after such an addition or multiplication , compression using one of the three compression methods specifically adapted to mpos as laid out in section [ sec : trunc ] brings the operator representation back into its most efficient form .",
    "we give examples of the resulting mpos in section [ sec : example ] for a spin - chain with nearest - neighbor interactions , the fermi - hubbard model on a cylinder in hybrid real- and momentum space and the full quantum chemistry hamiltonian .",
    "section [ sec : variance ] details an algorithm to reduce numerical errors while calculating the variance @xmath3 of a mpo  of particular interest here is the hamiltonian @xmath4 represented as a mpo .",
    "finally , we conclude in section [ sec : conclusions ] .",
    "for a detailed introduction to the density matrix renormalization group ( dmrg ) and in particular the second - generation algorithms based on matrix product states ( mps ) and matrix product operators ( mpos ) , we refer to an existing review@xcite as well as a dmrg - centered overview of the implementation.@xcite here , we will only define the basic structure of matrix product operators .    ( wi ) [ draw ] at ( 0,0)@xmath5 ; ( wi ) ",
    "node[near end , left]@xmath6(-0.5,0 ) ; ( wi ) ",
    "node[near end , right]@xmath7(0.5,0 ) ; ( wi ) ",
    "node[near end , above]@xmath8(0,0.5 ) ; ( wi ) ",
    "node[near end , below]@xmath9(0,-0.5 ) ;    ( w1 ) [ draw ] at ( 2.5,0)@xmath10 ; ( w2 ) [ draw ] at ( 3.5,0)@xmath11 ; ( w3 ) [ draw ] at ( 4.5,0)@xmath12 ; ( w4 ) [ draw ] at ( 5.5,0)@xmath13 ;    ( w1 ) ",
    "node[near end , above]@xmath14 + ( 0,0.5 ) ; ( w1 )  node[near end , below]@xmath15 + ( 0,-0.5 ) ; ( w2 )  node[near end , above]@xmath16 + ( 0,0.5 ) ; ( w2 )  node[near end , below]@xmath17 + ( 0,-0.5 ) ; ( w3 )  node[near end , above]@xmath18 + ( 0,0.5 ) ; ( w3 )  node[near end , below]@xmath19 + ( 0,-0.5 ) ; ( w4 )  node[near end , above]@xmath20 + ( 0,0.5 ) ; ( w4 )  node[near end , below]@xmath21 + ( 0,-0.5 ) ;    ( w1 ) ",
    "node[near end , left]@xmath22 + ( -0.5,0 ) ; ( w1 ) ",
    "( w2 ) ; ( w2 ) ",
    "( w3 ) ; ( w3 )  ( w4 ) ; ( w4 )  node[near end , right]@xmath23 + ( 0.5,0 ) ;    given a set of @xmath24 local hilbert spaces @xmath25 $ ] of dimension @xmath26 each and an operator @xmath4 which acts on the tensor product space @xmath27 , we can write the operator @xmath4 as    @xmath28    where @xmath29 enumerates the ( product ) basis states of @xmath30 and @xmath31 enumerates the basis states of the dual space of @xmath30 . we can decompose each basis vector @xmath29 as the tensor product of basis vectors on the individual local spaces as    @xmath32    which leads to    @xmath33    this form is still entirely generic.@xcite the coefficient @xmath34 may now be decomposed as a set of _ matrix products_. that is , on each site @xmath35 and for every combination of local states @xmath36 , we introduce a set of matrices @xmath37 with the property that their matrix - matrix product equals a specific element of the @xmath38 tensor :    @xmath39    the tensor @xmath5 is then a rank-4 tensor with two _ physical indices _ @xmath9 and @xmath8 while the two matrix indices above are now called _",
    "mpo bond indices _ and will be labelled @xmath6 and @xmath40 . in order for the above product of matrices to result in a scalar value for a given set of @xmath41 and @xmath42 , we need @xmath22 and @xmath23 to be 1-dimensional dummy indices .",
    "each tensor @xmath5 can be represented graphically by a square with four legs , cf .",
    "[ fig : mpo ] .",
    "connecting legs of two tensors corresponds to a tensor contraction over the associated indices .",
    "the relevant insight is that for a large class of operators , including all hamiltonians with short - range interactions in one dimension , the required _ mpo bond dimension _ ,",
    "i.e.  the size of matrices @xmath43 in eq .  ,",
    "to reproduce the original tensor @xmath38 , is both small ( @xmath44 ) and constant in the size @xmath24 of the system . for long - range interactions ,",
    "the size of the matrices usually only grows polynomially in the range of the interaction .",
    "constructing the set of tensors @xmath5 which faithfully reproduce the desired operator @xmath4 at minimal mpo bond dimensions @xmath7 will be discussed in this paper .",
    "at ( -1.2,0 ) @xmath45 : ; ( i1 ) [ draw ] at ( 0,0)@xmath46 ; ( i1 )  node[near end , left]0(-0.5,0 ) ; ( i1 )  node[near end , right](i1r)0(0.5,0 ) ; ( i1 )  node[near end , above]@xmath47(0,0.5 ) ; ( i1 )  node[near end , below]@xmath47(0,-0.5 ) ;    ( i2 ) [ draw ] at ( 2,0)@xmath46 ; ( i2 )  node[near end , left](i2l)0(1.5,0 ) ; ( i2 )  node[near end , right](i2r)0(2.5,0 ) ; ( i2 )  node[near end , above]@xmath47(2,0.5 ) ; ( i2 )  node[near end , below]@xmath47(2,-0.5 ) ;    ( i1r )  ( i2l ) ;    ( z3 ) [ draw ] at ( 4,0)@xmath48 ; ( z3 ) ",
    "node[near end , left](z3l)0(3.5,0 ) ; ( z3 ) ",
    "node[near end , right](z3r)0(4.5,0 ) ; ( z3 ) ",
    "node[near end , above]@xmath47(4,0.5 ) ; ( z3 ) ",
    "node[near end , below]@xmath47(4,-0.5 ) ;    ( z3l ) ",
    "( i2r ) ;    ( i4 ) [ draw ] at ( 6,0)@xmath46 ; ( i4 )  node[near end , left](i4l)0(5.5,0 ) ; ( i4 )  node[near end , right]0(6.5,0 ) ; ( i4 )  node[near end , above]@xmath47(6,0.5 ) ; ( i4 )  node[near end , below]@xmath47(6,-0.5 ) ;    ( z3r )  ( i4l ) ;    at ( -1.2,-2 ) @xmath49 : ; ( i1 ) [ draw ] at ( 0,-2)@xmath46 ; ( i1 )  node[near end , left]1(-0.5,-2 ) ; ( i1 )  node[near end , right](i1r)1(0.5,-2 ) ; ( i1 )  node[near end , above]@xmath47(0,-1.5 ) ; ( i1 )  node[near end , below]@xmath47(0,-2.5 ) ;    ( z2 ) [ draw ] at ( 2,-2)@xmath50 ; ( z2 ) ",
    "node[near end , left](z2l)1(1.5,-2 ) ; ( z2 ) ",
    "node[near end , right](z2r)0(2.5,-2 ) ; ( z2 ) ",
    "node[near end , above]@xmath51(2,-1.5 ) ; ( z2 ) ",
    "node[near end , below]@xmath47(2,-2.5 ) ;    ( i1r ) ",
    "( z2l ) ;    ( i3 ) [ draw ] at ( 4,-2)@xmath46 ; ( i3 )  node[near end , left](i3l)0(3.5,-2 ) ; ( i3 )  node[near end , right](i3r)0(4.5,-2 ) ; ( i3 )  node[near end , above]@xmath47(4,-1.5 ) ; ( i3 )  node[near end , below]@xmath47(4,-2.5 ) ;    ( z2r )  ( i3l ) ;    ( i4 ) [ draw ] at ( 6,-2)@xmath46 ; ( i4 )  node[near end , left](i4l)0(5.5,-2 ) ; ( i4 )  node[near end , right]0(6.5,-2 ) ; ( i4 )  node[near end , above]@xmath47(6,-1.5 ) ; ( i4 )  node[near end , below]@xmath47(6,-2.5 ) ;    ( i3r )  ( i4l ) ;    the representation of single - site operators as mpos is relatively straightforward in general and mostly already widely known . in this section we summarise the existing , though not necessarily published , results in this area .    to construct the mpo representation of a single - site operator , we will first focus on a homogeneous @xmath52 spin chain .",
    "subsection  [ sec : sso - ferm ] contains the transformation of fermionic operators using a jordan - wigner string . in subsection",
    "[ sec : sso - nonh ] we explain how to handle non - homogeneous systems , such as chains of alternating of @xmath52 spins with @xmath53 spins at the ends or mixed fermion - boson systems .",
    "let us start with the construction of @xmath54 for a @xmath52 spin chain .",
    "the first ingredient is the representation of @xmath55 as a matrix on a local hilbert space .",
    "this is straightforwardly given as @xmath56 .",
    "secondly , we need the matrix representation @xmath57 of the identity operator @xmath58 on this local hilbert space .    for a given fixed @xmath35 ,",
    "the explicit form of the single - site operator as @xmath59 ( that is , the identity operator acting on sites @xmath46 through @xmath60 and @xmath61 through @xmath24 ) then corresponds closely to the mpo representation of @xmath54 as    @xmath62    where the mpo bond indices are 1-dimensional dummy indices and do not affect the shape of the tensors .",
    "the mpo representation of @xmath45 is graphically given in fig .",
    "[ fig : sso : qnum ] . for trivially transforming operators , such as @xmath55 or @xmath63 which do not change the quantum numbers of the state , it is entirely sufficient to store the identity mpo component @xmath64 and the local representation ( e.g.  @xmath48 ) of the operator in question ( e.g.@xmath55 ) as rank-4 tensors of size @xmath65 .",
    "one can then construct the mpo representation on - the - fly .",
    "operators which do change a quantum number , such as @xmath66 or @xmath67 , are more complicated .",
    "since each tensor has to locally preserve symmetries and hence quantum numbers , the additional quantum number must be carried from the active site @xmath35 to the left edge of the system . in turn , the chain of identity operators to the left of the active site must allow for this quantum number on their mpo bond indices , while those on the right of the active site only carry the vacuum quantum numbers ( cf.fig .",
    "[ fig : sso : qnum ] ) .",
    "therefore , it is necessary to store different identity operator tensor representations for the left and right half of the system .",
    "it is advisable to simply always store left and right identities together with the active site tensor , as the memory requirements of these small tensors are negligible and there is no need for logic differentiating trivially - transforming and non - trivially - transforming operators .",
    "note that the case where no quantum numbers are used ( either because they are not preserved by the system or not supported by the implementation ) is identical to each operator and state transforming trivially and each leg only carrying a single , appropriately - sized vacuum sector . in this case ,",
    "the left and right identity operator tensor representations are again identical .      at ( -1.4,0 )",
    "@xmath68 : ; ( p1 ) [ draw ] at ( 0,0)@xmath69 ; ( p1 ) ",
    "node[near end , left]1(-0.7,0 ) ; ( p1 ) ",
    "node[near end , right](p1r)1(0.7,0 ) ; ( p1 ) ",
    "node[near end , above]@xmath70(0,0.5 ) ; ( p1 ) ",
    "node[near end , below]@xmath70(0,-0.5 ) ;    ( p2 ) [ draw ] at ( 2,0)@xmath69 ; ( p2 ) ",
    "node[near end , left](p2l)1(1.3,0 ) ; ( p2 ) ",
    "node[near end , right](p2r)1(2.7,0 ) ; ( p2 ) ",
    "node[near end , above]@xmath70(2,0.5 ) ; ( p2 ) ",
    "node[near end , below]@xmath70(2,-0.5 ) ;    ( p1r ) ",
    "( p2l ) ;    ( c3 ) [ draw ] at ( 4,0)@xmath71 ; ( c3 ) ",
    "node[near end , left](c3l)1(3.5,0 ) ; ( c3 ) ",
    "node[near end , right](c3r)0(4.5,0 ) ; ( c3 ) ",
    "node[near end , above]@xmath72(4,0.5 ) ; ( c3 ) ",
    "node[near end , below]@xmath70(4,-0.5 ) ;    ( c3l ) ",
    "( p2r ) ;    ( i4 ) [ draw ] at ( 6,0)@xmath46 ; ( i4 )  node[near end , left](i4l)0(5.5,0 ) ; ( i4 )  node[near end , right]0(6.5,0 ) ; ( i4 )  node[near end , above]@xmath70(6,0.5 ) ; ( i4 )  node[near end , below]@xmath70(6,-0.5 ) ;    ( c3r )  ( i4l ) ;    the implementation of anti - commutation relations for fermionic operators can also occur at the level of mpo representations of single - site operators.@xcite proper anti - commutation _ within _ the local state space of a single site , @xmath73 , is contained in the correct definition of the local site tensor .",
    "non - local anti - commutation between operators on different sites requires a defined ordering of all fermionic operators .",
    "there is a natural ordering of operators along the mpo chain from the left to the right .",
    "it then suffices to replace the identities in the previous section either to the left or to the right of the active site by parity operators which give a phase of @xmath74 if there is an odd number of fermions on the respective sites .    as an example , consider a product state @xmath75 | \\mathrm{vacuum } \\rangle$ ] .",
    "an operator @xmath76 applied to @xmath77 has to be commuted past all operators with @xmath78 . for each @xmath79 , it picks up a minus sign .",
    "each of these signs can be implemented as the application of the local parity operator @xmath80 .",
    "the mpo is then constructed as a chain of parity tensors @xmath69 , the active site tensor @xmath81 and then a chain of right mpo identity components @xmath64 , graphically represented in fig .",
    "[ fig : sso - ferm : par ] .",
    "constructed in such a way , fermionic mpos can be treated exactly the same as bosonic mpos in all applications that follow .      at ( -1.2,0 )",
    "@xmath82 : ; ( i1 ) [ draw ] at ( 0,0)@xmath83 ; ( i1 )  node[near end , left]@xmath84(-0.5,0 ) ; ( i1 )  node[near end , right](i1r)@xmath84(0.5,0 ) ; ( i1 )  node[near end , above]@xmath85(0,0.5 ) ; ( i1 )  node[near end , below]@xmath85(0,-0.5 ) ;    ( p2 ) [ draw ] at ( 2,0)@xmath86 ; ( p2 ) ",
    "node[near end , left](p2l)@xmath84(1.5,0 ) ; ( p2 ) ",
    "node[near end , right](p2r)@xmath84(2.5,0 ) ; ( p2 ) ",
    "node[near end , above]@xmath87(2,0.5 ) ; ( p2 ) ",
    "node[near end , below]@xmath87(2,-0.5 ) ;    ( i1r )  ( p2l ) ;    ( i3 ) [ draw ] at ( 4,0)@xmath83 ; ( i3 )  node[near end , left](i3l)@xmath84(3.5,0 ) ; ( i3 )  node[near end , right](i3r)@xmath84(4.5,0 ) ; ( i3 )  node[near end , above]@xmath85(4,0.5 ) ; ( i3 )  node[near end , below]@xmath85(4,-0.5 ) ;    ( p2r )  ( i3l ) ;    ( c4 ) [ draw ] at ( 6,0)@xmath71 ; ( c4 ) ",
    "node[near end , left](c4l)@xmath84(5.5,0 ) ; ( c4 ) ",
    "node[near end , right](c4r)@xmath88(6.5,0 ) ; ( c4 ) ",
    "node[near end , above]@xmath89(6,0.5 ) ; ( c4 ) ",
    "node[near end , below]@xmath87(6,-0.5 ) ;    ( i3r )  ( c4l ) ;    at ( -1.2,-2 ) @xmath90 : ; ( i1 ) [ draw ] at ( 0,-2)@xmath83 ; ( i1 )  node[near end , left]@xmath91 + ( -0.5,0 ) ; ( i1 ) ",
    "node[near end , right](i1r)@xmath91 + ( 0.5,0 ) ; ( i1 ) ",
    "node[near end , above]@xmath85 + ( 0,0.5 ) ; ( i1 ) ",
    "node[near end , below]@xmath85 + ( 0,-0.5 ) ;    ( i2 ) [ draw ] at ( 2,-2)@xmath92 ; ( i2 )  node[near end , left](i2l)@xmath91 + ( -0.5,0 ) ; ( i2 ) ",
    "node[near end , right](i2r)@xmath91 + ( 0.5,0 ) ; ( i2 ) ",
    "node[near end , above]@xmath87 + ( 0,0.5 ) ; ( i2 ) ",
    "node[near end , below]@xmath87 + ( 0,-0.5 ) ;    ( i1r )  ( i2l ) ;    ( c3 ) [ draw ] at ( 4,-2)@xmath93 ; ( c3 ) ",
    "node[near end , left](c3l)@xmath91 + ( -0.5,0 ) ; ( c3 ) ",
    "node[near end , right](c3r)@xmath88 + ( 0.5,0 ) ; ( c3 ) ",
    "node[near end , above]@xmath94 + ( 0,0.5 ) ; ( c3 ) ",
    "node[near end , below]@xmath85 + ( 0,-0.5 ) ;    ( i2r )  ( c3l ) ;    ( i4 ) [ draw ] at ( 6,-2)@xmath92 ; ( i4 )  node[near end , left](i4l)@xmath88 + ( -0.5,0 ) ; ( i4 ) ",
    "node[near end , right]@xmath88 + ( 0.5,0 ) ; ( i4 ) ",
    "node[near end , above]@xmath87 + ( 0,0.5 ) ; ( i4 ) ",
    "node[near end , below]@xmath87 + ( 0,-0.5 ) ;    ( c3r ) ",
    "( i4l ) ;    it is possible to simulate non - homogeneous systems using mps and mpo .",
    "such a non - homogeneity could be different spin sizes in a spin chain or the presence of both fermionic and bosonic sites in the system ( the case of non - homogeneous hopping between otherwise identical sites will be handled later in section  [ sec : arithmetic ] ) .",
    "the former case of non - homogeneity can be used to represent some experimental systems with alternating @xmath52 and @xmath95 spins as well as reduce finite - size effects in @xmath52 spin chains by placing @xmath95 spins at the two edges .",
    "the latter case might be helpful in simulating physical systems with bosonic and fermionic species , as they commonly occur in experiments with ultracold atoms .",
    "suppose we have two types of sites in our system .",
    "even sites may contain zero , one or two fermions , while odd sites may contain up to a certain number of bosons .",
    "if we then wish to construct the fermionic creation operator @xmath96 , we have to ensure that the identities used to its left and right match the corresponding physical basis on those sites .",
    "further , if we use @xmath97 quantum numbers for fermion and boson number conservation , the identities to the left need mpo bond indices transforming as @xmath98 .",
    "in contrast , if we apply a bosonic creation operator @xmath99 , the bond indices of those identities have to transform as @xmath100 .",
    "equal to zero and call the bosonic creators @xmath101 . for spin systems , it is however entirely reasonable to have @xmath55 both on @xmath95 sites ( at the edge ) and @xmath52 sites ( in the bulk ) of the system .",
    "[ fig : sso : nonh : ops ] gives examples of those creation operators .",
    "this has two implications .",
    "first , for every type @xmath102 of sites in the system , we need to define an appropriate active tensor representing ( say ) @xmath93 acting on a site of this type @xmath102 .",
    "second , for every active site type @xmath102 on which the operator acts , we also need to store an appropriate left and right identity tensor for all types of sites .    thus , if we have @xmath103 different types of sites in our system , we need to store up to @xmath104 rank-4 tensors per single - site operator .",
    "however , since these tensors are still only of size @xmath105 , and the number of different types @xmath103 is typically also small , this is not a concern in practice .",
    "consider the example of a spin chain with @xmath52 spins in the bulk and two @xmath95 spins at the boundaries . to construct @xmath106 on the fly ,",
    "we need to store ten rank-4 tensors : first , we need to store two tensors representing @xmath106 acting on sites with @xmath52 and @xmath95 .",
    "second , for each of these two , we need to store two left - identities which we place on sites with @xmath52 and @xmath95 respectively to the left of site @xmath35 .",
    "similarly , we need a total of four right - identities to be placed on sites to the right of site @xmath35 with @xmath52 and @xmath95 respectively for a total of ten tensors of size @xmath107 ; in this specific case requiring the storage of 55 scalar values in total . for @xmath95 sites , requiring 4 numbers each .",
    "the other five are of size @xmath108 for @xmath52 sites with 9 scalar entries .",
    "we hence need to store @xmath109 scalar values to represent @xmath106 on any site @xmath35 . ]",
    "the implementation of arithmetic operations with mpos is well - known already@xcite and is entirely independent of the specific form of the operands .",
    "in particular , the implementation can handle single - site operators as constructed in the previous section and mpos resulting from earlier arithmetic operations on equal footing .",
    "\\(r ) [ draw ] at ( -1.7,0)@xmath110 ; ( r ) ",
    "+ + ( 0,0.5 ) ; ( r )  + + ( 0,-0.5 ) ; ( r ) ",
    "+ + ( 0.6,0 ) ; ( r )  + + ( -0.6,0 ) ; at ( -0.8,0 ) @xmath111 ;    \\(a ) [ draw ] at ( 1,0.5)@xmath112 ; ( b ) [ draw ] at ( 1,-0.5)@xmath113 ; ( a )  + + ( 0,0.5 ) ; ( b )  + + ( 0,-0.5 ) ;    ( 0,0 ) circle ( 3pt ) node ( l ) ; ( 2,0 ) circle ( 3pt ) node ( rm ) ;    \\(a )  ( b ) ;    \\(b ) -| ( l ) ; ( a ) -| ( l ) ; ( l )  ( -0.4,0 ) ;    ( rm ) |- ( b ) ; ( rm ) |- ( a ) ; ( 2.4,0 )  ( rm ) ;    given two operators @xmath114 , @xmath115 and their mpo representation tensors @xmath116 and @xmath117 , the product @xmath118 ( read from right - to - left , @xmath115 is applied first ) can be built on each site individually .",
    "it is graphically represented in fig .",
    "[ fig : arithmetic : prod ] . the lower physical index of each @xmath112 is contracted with the upper physical index of the corresponding @xmath113 .",
    "the left and right mpo indices of the tensors are merged into one fat index .",
    "this procedure results in a mpo with bond dimensions @xmath119 .",
    "specifically , the product of two single - site operators ( mpo bond dimension 1 ) is again a mpo with bond dimension 1 .",
    "the scalar products of operators occuring during the implementation of non - abelian symmetries in tensor networks can similarly be implemented independently of the operator at hand .",
    "the sum of two operators @xmath120 , represented by mpo components @xmath121 and @xmath122 can also be constructed .",
    "considering only the mpo bond indices , i.e.  treating @xmath116 as _ matrices _ of operators , the components of the resulting mpo are built as follows : @xmath123 for the example of a @xmath124 mpo , it is easy to verify that this results in the desired form representing @xmath125 .",
    "the sum of two mpos has a bond dimension @xmath126 .",
    "when constructing the mpo representation of a single - site operator as described in section [ sec : sso ] , the resulting operator will have bond dimension 1 and will be in its most efficient representation",
    ". products of such single - site operators ( such as @xmath127 ) will keep the bond dimension at 1 .",
    "however , the bond dimension will grow linearly in the number of such terms that are added together .",
    "naively , a four - term interaction mpo representing @xmath128 will have a maximal bond dimensions @xmath129 .",
    "the leading term in the computational cost of dmrg typically scales linearly in the maximal @xmath7 and linearly in @xmath24 , but there are sub - leading terms of quadratic order in @xmath7 .",
    "hence , some way to avoid this quintic or even decic scaling is absolutely necessary .    _ compressing _ a mpo will in general reduce its bond dimension to the bare minimum . for example , the sum of two identical mpos will have a doubled bond dimension which is obviously not necessary  a prefactor of @xmath130 multiplied into the first tensor would correspond to the same operator .",
    "similarly , two addends with long strings of identities to the left and right of the active sites , such as @xmath131 can easily `` share '' these strings such that the most efficient mpo has bond dimension 1 everywhere but on bond @xmath132 , where 2 is the minimum required .",
    "the compression methods presented here for mpos are based on the same idea as those for mps : given a mpo which has components @xmath5 and @xmath133 on sites @xmath35 and @xmath61 , it is possible to rewrite @xmath134 without changing the mpo itself . for some mpo components ,",
    "it is possible to find matrices @xmath135 with @xmath136 .",
    "the new tensors @xmath137 then have a smaller bond dimension @xmath138 while representing the same original mpo , as only the matrix product of @xmath5 and @xmath133 or @xmath139 and @xmath140 is relevant for the operator .",
    "this is entirely analogous to mps , which also offer this gauge freedom and where it is also possible to use it in order to compress the size of the mps .",
    "it must be stressed that the compression methods presented here work iteratively on a bond - by - bond basis and can not find a globally different ( but better ) mpo representation .",
    "however , for mpos investigated here , we are still able to recover the optimal representation in most cases and a near - optimal representation even for extremely difficult problems . for the latter , it would be possible to combine the compression methods here with others , such as an iterative fitting method.@xcite      the singular value decomposition of mpos has been proposed before@xcite and in infinite - precision arithmetic it would work exactly the same as for mps : given a tensor @xmath141 , the indices @xmath142 and @xmath8 are combined into a larger index @xmath143 , yielding the matrix @xmath144 .",
    "this matrix is decomposed via svd as @xmath145 .",
    "columns of @xmath146 and rows of @xmath147 which correspond to negligible singular values in @xmath148 are removed .",
    "@xmath146 is reshaped into the compressed tensor @xmath149 .",
    "the product @xmath150 acts as a transfer matrix and is multiplied into the next tensor on the right , compressing the dimension of the mpo on bond @xmath151 .",
    "sweeping left - to - right and right - to - left through the mpo compresses all bonds .    unfortunately , a straightforward svd yields extremely large singular values . the issue can be observed in fig .  [",
    "fig : examples : svd ] ( labels `` standard '' ) . given an uncompressed fermi - hubbard hamiltonian with some finite range interaction on systems of length @xmath24 equal to 20 , 40 and 80 ,",
    "we compress the left and right halves and then calculate the singular value spectrum in the centre of the system . with increasing system size , we observe singular values growing as large as @xmath152 . at the same time",
    ", the numerical noise , singular values normally discarded , grows as large as @xmath153 !",
    "the magnitude of the singular values is linked to the fact that while we can always rescale a mps to have frobenius norm 1 , an operator will in principle have a system - size dependent frobenius norm .",
    "normalising all tensors but one , as is common for svd , implies that only this one tensor will carry the full norm of the operator .",
    "this leads to two problems : first , there is difficulty in decididing which singular values should be kept , as even the singular values strictly associated to numerical noise become extremely large .",
    "second , compared to the normalised tensors to its left and right , the entries of the singular value tensor will have a grossly different order of magnitude , resulting in great precision loss during subsequent operations .",
    "to avoid such large singular values , we can _ rescale _ the singular value tensor @xmath154 by a scalar value . while this destroys the ortho__normality _ _ of the resulting mpo bond basis , it preserves the ortho__gonality__. further , since all basis vectors are still of the same length , compression can proceed as usual , either based on a sharp cut - off or on a dynamic detection of the drop - off in magnitude of singular values ( cf .",
    "[ fig : examples : svd ] ) .",
    "lastly , properly chosen , such a rescaling can most often ensure that the norm of the operator is evenly distributed throughout its length , rather than concentrated in a single place .    in practice",
    ", we found it helpful to calculate the arithmetic average @xmath155 of the singular values in the tensor @xmath154 and rescale @xmath156 such that this average is of order one .",
    "the tensor @xmath139 is multiplied with the inverse of the scaling factor to preserve the overall norm . to minimize numerical instabilities , it is advisable to choose the power of two closest to @xmath155 as the scaling factor , since such multiplications are exact with ieee-754 floating point numbers .    with this rescaling after each svd during the compression sweeps , we observe singular values of magnitudes between 1 and 100 independent of the system length and numerical noise clearly recognisable as such of magnitude @xmath157 or smaller .    however , there are still caveats and counterindications against using svd in specific cases , primarily concerning mpo representations of projectors or sums of operators involving projectors . first , when attempting to compress a suboptimal representation of a projector , svd even with rescaling often struggles to properly distribute the norm throughout the system .",
    "for example , given the projector @xmath158 on the @xmath95 heisenberg chain of lenght @xmath24 , a svd compression will lead to exponentially large terms in the first and last tensor , with the ( otherwise properly compressed ) terms in the bulk all carrying a prefactor @xmath159 .",
    "second , when attempting to evaluate sums of operators with greatly varying frobenius norms , svd will often entirely discard the smaller operator .",
    "this is not a concern for most hamiltonians , as they are built from few - body interaction terms all with roughly the same order of magnitude .",
    "however , when evaluating @xmath160 in the above system , the result from svd is simply @xmath58 .",
    "this can be understood since @xmath161 while @xmath162 . in a similar fashion ,",
    "if svd were tasked with the compression of the sum of two mps , one of norm @xmath163 and the other of norm 1 , the result would also simply be the larger of the two states , as soon as the difference in the two is lost in the numerical noise of order @xmath164 .",
    "both problems can be detected reliably : for the first , it is sufficient to compare e.g.  the norm of each mpo component : if one or two ( i.e.  at the edges of the system ) is much greater than in the bulk , svd failed to properly distribute the norm .    for the second , it is sufficient to compare the frobenius norms of addends before operator addition , if in doubt . as a rule of thumb ,",
    "the frobenius norm is exponential in the number of identity mpo components .",
    "it is hence possible to sum few - body interaction terms together ( as they typically occur in hamiltonians or correlators ) or _ alternatively _ sum `` few - identity '' terms ( such as projectors ) together .",
    "however , this rule only applies to sums of mpos , not products of mpos .",
    "special care must be taken in those cases and it must be checked carefully whether the errors introduced by svd are acceptable relative to the problem at hand .",
    "the svd method has the disadvantage that it destroys the extreme sparsity of the usual mpo tensors and relies on a robust and small window of singular values encountered in the mpo .",
    "employing quantum number labels reduces this destruction of sparsity to the scope of individual blocks , which will often be implemented as dense tensors in any case . however , in particular for simple homogenous operators , it is desirable to keep the sparse , natural structures of mpo .",
    "it is furthermore sometimes also necessary to compress mpos with greatly varying singular values .",
    "the much simpler deparallelisation method avoids both issues entirely : sparsity is largely conserved and the compression does not rely on singular values .",
    "it furthermore does not rescale most elements of the tensor , keeping the norm distributed in the same way as before .",
    "it was first presented in ref .   and can be considered a slight generalisation from the _ fork - merge _ method presented in ref .  , from `` forking '' and `` merging '' only identity operators to arbitrary strings of operators .",
    "the algorithm is presented in detail in appendix [ app : depara ] .",
    "the basic idea is again to re - shape each site tensor @xmath165 into a matrix @xmath166 .",
    "then , columns of @xmath167 which are entirely parallel to any previous column are removed , with the respective proportionality factor stored in the transfer matrix to be multiplied into the next site tensor .",
    "this procedure results in a mpo that is often optimal for spatially homogeneous operators and retains the advantageous structure of analytically - constructed mpo tensors . for more difficult hamiltonians",
    ", it often results in suboptimal representations .",
    "the delinearisation method aims to combine the advantages of the svd and the deparallelisation .",
    "it is suitable to compress any mpo , including the previously - mentioned sums of projectors and hamiltonians as well as complicated hamiltonians . in most cases , it results in an optimal mpo dimension . for extremely large mpos ,",
    "the resulting bond dimensions tend to be slightly larger than with svd compression . however , the original sparsity of the mpo is largely preserved , even in the dense sub - blocks , is the most relevant scaling dimension .",
    "] labelled by quantum numbers . wherever possible , it attempts to ensure that no spurious small terms can occur in the hamiltonian .",
    "the algorithm is presented in full detail in appendix [ app : delin ] .",
    "similar to the deparallelisation , we attempt to remove columns from the @xmath166 matrix , but now allow for linear combinations of previously - kept columns to replace the column in question , whenever possible under the constraint that no cancellation to exactly - zero can occur ( this avoids the spurious small terms ) .",
    "we will present three examples of mpo generation using the above construction method .",
    "first , we show that it works well for the simple example of nearest - neighbour interactions on spin chains and even for small powers of the hamiltonian .",
    "second , we explain that it is very easy to generate the hamiltonian for the fermi - hubbard model on a cylinder in hybrid real- and momentum space .",
    "third , we present data that the construction method also correctly sums up partial terms in a toy model for the full quantum chemistry hamiltonian .",
    ", @xmath168 , @xmath169 and @xmath170 to illustrate the generic case .",
    "the leftmost and rightmost bonds have dimension four , whereas the bulk bond dimension is five as in the analytical solution . ]",
    "we consider the hamiltonian with nearest - neighbour interactions on a spin chain @xmath171 we can construct analytically an optimal representation of this hamiltonian,@xcite which has mpo bond dimension 5 . in comparison , we can plot the dimension of each bond of the numerically constructed representation for various system sizes ( cf .  fig .",
    "[ fig : example : spin : w ] ) . as is clearly visible , the bond dimension quickly saturates at five and stays constant @xmath172 independent of the system length .",
    "the algorithm even finds an improvement over the usual analytic solution , as only one @xmath173 term is necessary at the boundary . in the bulk",
    ", it completely reproduces the analytic solution , here at the example of @xmath174 : @xmath175    further , we can construct powers of the hamiltonian @xmath4 , here specifically with coefficients @xmath176 , @xmath168 , @xmath177 , @xmath170 .",
    "the procedure is to first generate @xmath4 using only deparallelisation , which leads to the near - analytic solution at bond dimension 5 .",
    "we then multiply the mpo with itself to generate @xmath178 and compress the operator using svd or delinearisation . multiplying with @xmath4 repeatedly",
    ", we construct up to the seventh power of @xmath4 and compare the bond dimensions with those resulting from an iterative fitting procedure ( cf .",
    "table [ tab : example : spinchain ] ) .    for small powers @xmath70 ,",
    "the resulting bond dimensions from the three compression methods coincide . for higher powers , the svd method results in somewhat lower bond dimensions",
    ". this could be both due to numerical inaccuracies in either method ( e.g.  erroneously discarding small but relevant singular values ) or the fitting approach getting stuck in a local minimum .",
    "to numerical accuracy , the error resulting from the svd compression is zero , however .    in comparison",
    ", the delinearisation method encounters cyclic linear dependencies it can not break when attempting to compress the higher power mpo representations .",
    "this results in a larger bond dimension .",
    "however , the original sparsity of the mpo , calculated as the relative number of exactly - zero entries in the dense sub - blocks of the mpo , is largely preserved at over 80% zero entries while no such entries where found after svd compression .",
    ".[tab : example : spinchain]bond dimensions @xmath179 in the center of a @xmath180 chain of powers of the nearest - neighbour spinchain hamiltonian with svd and delinearisation compression",
    ". relative sparsity of the resulting mpo is included for the delinearisation method ( svd does not preserve sparsity at all ) .",
    "we compare with the results of frwis et .",
    "@xcite for the xxz hamiltonian constructed with an iterative fitting procedure , which could also be combined with our construction method for mpos . [ cols=\"<,^,^,^,^,^,^,^\",options=\"header \" , ]     c.  hubig acknowledges funding through the exqm graduate school and the nanosystems initiative munich .",
    "i.  mcculloch acknowledges support from the australian research council ( arc ) centre of excellence for engineered quantum systems , grant ce110001013 . and the arc future fellowships scheme , ft140100625 .",
    "mpo compression of an arbitrary operator should occur in three stages :    1 .   performing one full sweep using the deparallelisation method 2 .   performing sweeps using the strict delinearisation method until bond dimensions stay constant 3 .   performing sweeps using the relaxed delinearisation method until bond dimensions stay constant",
    "the motivation for this sequence is to firstly reduce the bond dimension as much as possible with the fairly cheap deparallelisation , then move on to the more costly delinearisation and finally , if a cyclic dependency occurs which can not be broken without allowing cancellation to zero , use the relaxed delinearisation .",
    "note that if the mpo is already optimal , the last step will not introduce such small terms .",
    "independent of the compression method , each full sweep iterates twice over the full system , once from left to right and then from right to left . on each site @xmath35",
    ", the local tensor @xmath181 is re - shaped into a matrix @xmath144 @xmath182 during left - to - right ( right - to - left ) sweeps .",
    "the matrix @xmath167 is then decomposed as @xmath183 .",
    "@xmath184 is re - shaped into the new site tensor @xmath185 @xmath186 with the transfer matrix @xmath103 being multiplied into the next site tensor @xmath133 ( @xmath187 ) during left - to - right ( right - to - left ) sweeps .",
    "the decomposition @xmath188 is described in the following sections for the deparallelisation and delinearisation methods .",
    "_ input _ : matrix @xmath189    _ output _ : matrices @xmath190 , @xmath191 s.t.@xmath192 and @xmath193 has at most as many columns as @xmath167 and no two columns which are parallel to each other .",
    "_ procedure _ :",
    "1 .   let @xmath194 be the set of kept columns , empty initially 2 .",
    "let @xmath103 be the dynamically - resized transfer matrix 3 .   for every column index @xmath195 $ ]",
    ": 1 .   for every kept index",
    "@xmath196 $ ] : 1 .",
    "if the @xmath197-th column @xmath198 is parallel to column @xmath199 : 1 .   set @xmath200 to the prefactor between the two columns 2 .",
    "otherwise : 1 .   add @xmath198 to @xmath194 , set @xmath201 .",
    "4 .   construct @xmath193 by horizontally concatenating the columns stored in @xmath194 .",
    "return @xmath193 and @xmath103    the check for parallelicity is ideally done on an element - wise basis by finding the first non - zero element of either column , calculating the factor between it and the corresponding element of the other column and then ensuring that all other elements agree on that prefactor .",
    "zero columns should be removed with a corresponding zero column stored in @xmath103 .",
    "_ input _ : matrix @xmath189 , threshold matrix @xmath202    _ output _ : matrices @xmath190 , @xmath191 s.t.@xmath192 and @xmath193 has at most as many columns as @xmath167 and all columns in @xmath193 are linearly independent .    _",
    "remark _ : initially , the threshold matrix @xmath202 is constructed from @xmath203 as @xmath204 , i.e.  each element is the 1-norm of the original operator to which it belongs multiplied by a small threshold .",
    "_ procedure _ :    1 .",
    "[ alg : dln : relaxed ] if relaxed delinearisation : set all elements @xmath205 to @xmath206 .",
    "[ alg : dln : inner : start ] deparallelise the rows of @xmath207 : @xmath208 where the elements of @xmath209 are chosen as the smallest elements in that column from non - zero rows which were parallel to the kept row .",
    "[ alg : dln : permutation ] sort the columns of @xmath210 according to the following criteria , resulting in @xmath211 , @xmath212 and a permutation matrix @xmath213 .",
    "sorting criteria are : 1 .   the number of exactly - zero values in the column 2 .   if tied , the number of exactly - zero thresholds in the same column of @xmath209 3 .   if tied , the number of exactly - zero values from the bottom of the column 4 .   if tied , the number of exactly - zero thresholds from the bottom of the same column of @xmath209 4 .   for every column @xmath214 and associated threshold column @xmath215 in @xmath211 and @xmath212 1 .",
    "attempt to solve @xmath216 where @xmath217 is the matrix from eligible previously - kept columns .",
    "a column is eligible for inclusion in @xmath217 if it has no non - zero entry in a row where @xmath215 is exactly zero .",
    "+ the coefficients @xmath218 are found via qr decomposition with column scaling ( by their respective norms ) .",
    "rows of @xmath219 and @xmath220 are scaled s.t .",
    "the right - hand side is either 1 or 0 prior to solution by backwards substitution .",
    "if any coefficients in @xmath218 have absolute value less than @xmath221 , remove the associated column from the eligible set to build @xmath217 and repeat .",
    "3 .   if any coefficients in @xmath218 are close to @xmath222 , replace them by @xmath222 .",
    "if each element @xmath223 of the residual is smaller than @xmath224 : 1 .   store the coefficients @xmath218 5 .   else , 1 .   add the column to the set of kept columns and store a coefficient of 1 in the appropriate place .",
    "5 .   collect all kept columns into @xmath225 , associated columns from @xmath212 into @xmath226 and construct the transfer matrix @xmath227 from the stored coefficients times the permutation matrix @xmath213 .",
    "[ alg : dln : inner : end ] multiply the row - deparallelisation transfer matrix @xmath219 back into @xmath225 and @xmath226 , yielding @xmath228 and @xmath229 .",
    "[ alg : dln : reset ] if the number of columns in @xmath228 is equal to the number of columns in @xmath167 , replace @xmath230 , @xmath231 , @xmath232 . 8 .",
    "[ alg : dln : rows ] repeat steps [ alg : dln : inner : start ] through [ alg : dln : inner : end ] for @xmath233 and @xmath234 ( i.e. delinearise the _ rows _ of @xmath228 ) : @xmath235 9 .   [",
    "alg : dln : reset2 ] if neither @xmath236 nor @xmath228 have fewer columns than @xmath167 1 .",
    "return @xmath237 and @xmath238 .",
    "[ alg : dln : rows2 ] else - if @xmath236 has fewer columns than @xmath228 , 1 .",
    "return @xmath239 , @xmath240 , 11 .",
    "else , 1 .",
    "return @xmath241 , @xmath242    _ remark _ : during matrix - matrix products @xmath243 , it is helpful and often necessary to set elements of @xmath219 for which @xmath244 is true to zero .",
    "this ensures that where we allow cancellation to zero , we do not introduce additional terms whenever possible .",
    "step [ alg : dln : relaxed ] removes the requirement that we can not allow cancellation to zero .",
    "step [ alg : dln : inner : start ] usually halves the number of rows of @xmath167 , as there are often many zero rows or rows parallel to previous ones , making the subsequent qr decompositions both faster and more accurate .",
    "step [ alg : dln : permutation ] sorts columns such that those with few non - zero entries are considered first while attempting to keep an upper - triangular form .",
    "the former helps to find optimal non - cancelling linear superpositions , while the latter attempts to restore the usually - preferred triangular form whenever possible . steps [ alg : dln : reset ] and [ alg : dln : reset2 ] reduce numerical errors by reverting to the input matrix if no improvements have been found .",
    "finally , steps [ alg : dln : rows ] and [ alg : dln : rows2 ] often help to break cyclic dependencies and achieve optimal compression .",
    "the relevant three threshold values are , with the machine precision @xmath245 :    * @xmath206 : during delinearisation , a new column has to be equal to the original one to within this value , relative to operator norms . in practice , we found @xmath246 to be a suitable value , as columns are usually either completely dependent ( with very small error ) or differ substantially ( with very large error ) .",
    "too small a threshold will lead to failure to optimise in some cases , as numerical noise may become relatively large during a long calculation .",
    "* @xmath247 : the delinearisation method is able to work with operators of very different orders of magnitude in the same mpo . in turn , this means that small terms are not automatically discarded as with svd .",
    "this implies that during the various matrix - matrix products encountered during mpo compression , special care has to be taken to avoid introducing artifical small terms . in practice",
    ", we found @xmath248 to work . *",
    "@xmath221 : this threshold serves to avoid small coefficients in the transfer matrix , which would lead to valid small coefficients in the next tensor . for most sensible operators ,",
    "coefficients should be of order one and if this is not possible , it may well be desired to keep the components separate rather than conflating them into a single column .",
    "our implementation uses a value of @xmath249 here .",
    "26ifxundefined [ 1 ] ifx#1 ifnum [ 1 ] # 1firstoftwo secondoftwo ifx [ 1 ] # 1firstoftwo secondoftwo `` `` # 1''''@noop [ 0]secondoftwosanitize@url [ 0 ] ",
    "+ 12$12  & 12#1212_12%12@startlink[1]@endlink[0]@bib@innerbibempty link:\\doibase 10.1103/physrevlett.69.2863 [ * * ,   ( ) ] link:\\doibase 10.1103/revmodphys.77.259 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevlett.75.3537 [ * * ,   ( ) ] link:\\doibase 10.1088/1742 - 5468/2007/10/p10014 [ * * ,   ( ) ] http://stacks.iop.org/1367-2630/12/i=2/a=025012 [ * * , ( ) ] link:\\doibase 10.1016/j.aop.2010.09.012 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevb.72.180403 [ * * , ( ) ] link:\\doibase    10.1103/physrevlett.109.020604 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevb.87.155137 [ * * , ( ) ] link:\\doibase 10.1103/physreva.81.062337 [ * * ,   ( ) ] link:\\doibase 10.1103/physrevb.78.035116 [ * * , ( ) ] link:\\doibase 10.1103/physrevb.93.155139 [ * * ,   ( ) ] \\doibase    http://dx.doi.org/10.1063/1.4939000 [ * * ,   ( ) , http://dx.doi.org/10.1063/1.4939000 ] @noop ( ) ,",
    "link:\\doibase 10.1103/physrevb.91.155115 [ * * ,   ( ) ] \\doibase    http://dx.doi.org/10.1016/j.cpc.2014.08.019 [ * * ,   ( ) ] http://stacks.iop.org/1367-2630/12/i=5/a=055026 [ * * ,   ( ) ] link:\\doibase 10.1146/annurev - conmatphys-020911 - 125018 [ * * ,   ( ) ] @noop _ _ ,  ed .",
    "( ,  ,  )  p.   @noop `` , ''   ( ) ,   @noop `` , ''   ( ) ,   @noop `` , ''"
  ],
  "abstract_text": [
    "<S> matrix product operators ( mpos ) are at the heart of the second - generation density matrix renormalisation group ( dmrg ) algorithm formulated in matrix product state language . </S>",
    "<S> we first summarise the widely known facts on mpo arithmetic and representations of single - site operators . </S>",
    "<S> second , we introduce three compression methods ( rescaled svd , deparallelisation and delinearisation ) for mpos and show that it is possible to construct efficient representations of arbitrary operators using mpo arithmetic and compression . as examples , </S>",
    "<S> we construct powers of a short - ranged spin - chain hamiltonian , a complicated hamiltonian of a two - dimensional system and , as proof of principle , the long - range four - body hamiltonian from quantum chemistry . </S>"
  ]
}