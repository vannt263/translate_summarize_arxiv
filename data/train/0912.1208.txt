{
  "article_text": [
    "a cycle basis of a graph is a set of cycles that gives a compact representation of the set of all the cycles in the graph .",
    "such a representation is not only of theoretical interest but has also found practical use in a number of fields .",
    "one of the earliest applications is in electrical circuit theory and dates back to the work of kirchhoff  @xcite in @xmath8 .",
    "knuth  @xcite used them in the analysis of algorithms .",
    "cycle bases also play an important role in chemical and biological pathways , periodic scheduling , and graph drawing  @xcite .",
    "see also  @xcite .    in many of the above applications ,",
    "it is desirable to have a cycle basis of minimum total length or , more generally , of minimum total weight if edges of the graph are assigned weights .",
    "the minimum cycle basis problem , formally defined below , is the problem of finding such a cycle basis . for a survey of applications and the history of this problem ,",
    "see  @xcite .",
    "let us define cycle bases and minimum cycle bases .",
    "let @xmath9 be an undirected graph .",
    "to each simple cycle @xmath7 in @xmath0 , we associate a vector @xmath10 indexed on @xmath11 , where @xmath12 if @xmath13 belongs to @xmath7 and @xmath14 otherwise . a set of simple cycles of @xmath0 is said to be _ independent _ if their associated vectors are independent over @xmath15 .",
    "the vector space over this field generated by these vectors is the _ cycle space _ of @xmath0 and a maximal independent set of simple cycles of @xmath0 is called a _ cycle basis _ of @xmath0 .",
    "any cycle basis of @xmath0 consists of @xmath16 cycles , where @xmath17 is the number of edges , @xmath2 the number of vertices , and @xmath18 is the number of connected components of @xmath0  @xcite .",
    "assume that the edges of @xmath0 have real weights .",
    "then a _ minimum cycle basis _ ( mcb ) of @xmath0 is a cycle basis such that the sum of weights of edges of the cycles in this basis is minimized .",
    "the mcb problem ( mcbp ) is the problem of finding an mcb of @xmath0 .",
    "the mcbp is np - hard if negative weights are allowed  @xcite .",
    "the first polynomial time algorithm for graphs with non - negative edge weights was due to horton  @xcite .",
    "his idea was to first compute a polynomial size set of cycles guaranteed to contain an mcb .",
    "in a subsequent step , such a basis is then extracted from this set using a greedy algorithm .",
    "running time is @xmath19 .",
    "this was improved in a sequence of papers  @xcite to @xmath20 , where @xmath21 is the exponent of matrix multiplication .    for planar graphs with non - negative edge weights ,",
    "an @xmath22 algorithm was presented in  @xcite .",
    "this was recently improved to @xmath1  @xcite .",
    "the quadratic time bound also holds for the following problem for planar graphs since it was shown to be dual equivalent to the mcbp for such graphs  @xcite ( meaning that one problem can be transformed into the other in linear time ) : find a minimal collection of cuts such that for any pair of vertices @xmath23 and @xmath24 , this collection contains a minimum @xmath23-@xmath24 cut .",
    "we refer to this problem as the _ all - pairs min cut problem _ ( apmcp ) .",
    "we prove that quadratic running time for the two problems is optimal by presenting a family of graphs of arbitrarily large size for which the total length ( number of edges ) of all cycles in any mcb is @xmath25 .",
    "we then present an algorithm with @xmath3 running time and @xmath4 space requirement that computes an mcb of a planar graph _",
    "implicitly_. from this result , we get an output - sensitive algorithm with @xmath5 time and @xmath6 space requirement , where @xmath7 is the total size of cycles in the mcb that the algorithm returns . for unweighted planar graphs , these bounds simplify to @xmath3 and @xmath4 , respectively .",
    "since the mcbp and the apmcp are dual equivalent for planar graphs , we get similar bounds for the latter problem .",
    "the _ weight vector _ of a weighted graph @xmath0 is a vector containing the weights of cycles of an mcb in order of non - decreasing weight .",
    "finding such a vector has applications in chemistry and biology  @xcite . from our implicit representation of an mcb , we obtain an @xmath3 time and @xmath4 space algorithm for finding the weight vector of a planar graph .",
    "the best previous bound was @xmath1 , obtained by applying the algorithm in  @xcite .    a _ gomory - hu tree _ , introduced by gomory and hu in @xmath26  @xcite ,",
    "is a compact representation of minimum weight cuts between all pairs of vertices of a graph .",
    "formally , a gomory - hu tree of a weighted connected graph @xmath0 is a tree @xmath27 with weighted edges spanning the vertices of @xmath0 such that :    1 .   for any pair of vertices @xmath23 and @xmath24 , the weight of the minimum @xmath23-@xmath24 cut is the same in @xmath0 and in @xmath27 , and 2 .   for each edge @xmath13 in @xmath27 , the weight of @xmath13 equals the weight of the cut in @xmath0 , defined by the sets of vertices corresponding to the two connected components in @xmath28 .",
    "such a tree @xmath27 is very useful for finding a minimum @xmath23-@xmath24 cut in @xmath0 since we only need to consider the cuts of @xmath0 encoded by the edges on the simple path between @xmath23 and @xmath24 in @xmath27 .",
    "gomory - hu trees have also been applied to solve the minimum @xmath29-cut problem  @xcite .    for planar graphs ,",
    "quadratic time and space is the best known bound for finding such a tree .",
    "the bound can easily be obtained with the algorithm in  @xcite . from our mcb algorithm",
    ", we obtain an algorithm that constructs a gomory - hu tree in only @xmath3 time and @xmath4 space .",
    "an important corollary of the latter result is that with @xmath3 time and @xmath4 space for preprocessing , a query for the weight of a min cut ( or max flow ) between two given vertices of a planar undirected graph with non - negative edge weights can be answered in constant time .",
    "previously , quadratic preprocessing time and space was required to obtain such an oracle .",
    "the actual cut can be reported in time proportional to its size .",
    "the organization of the paper is as follows . in section",
    "[ sec : defsnotres ] , we give some definitions and notation and state some basic results . we give the quadratic lower bound for an explicit representation of an mcb of a planar graph in section  [ sec : lowerbound ] . in section  [ sec : greedyalgo ] , we mention the greedy algorithm which has been applied in previous papers to find an mcb . based on it , we present our algorithm in section  [ sec : divideconquer ] and bound its time and space requirements .",
    "the corollaries of our result are presented in section  [ sec : corollaries ] . in order for our ideas to work ,",
    "we need shortest paths to be unique .",
    "we show how to ensure this in section  [ sec : lexshort ] .",
    "finally , we give some concluding remarks in section  [ sec : conclrem ] .",
    "in the following , @xmath30 denotes an @xmath2-vertex plane , straight - line embedded , undirected graph .",
    "this embedding partitions the plane into maximal open connected sets which we refer to as the _ elementary faces _",
    "( of @xmath0 ) .",
    "exactly one of the elementary faces is unbounded and we call it the _ external elementary face _ ( of @xmath0 ) .",
    "all other elementary faces are called _",
    "internal_.    a jordan curve @xmath31 partitions the plane into an open bounded set and an open unbounded set . we denote them by @xmath32 and @xmath33 , respectively .",
    "we refer to the closure of these sets as @xmath34 and @xmath35 , respectively .",
    "we say that a pair of elementary faces of @xmath0 are _ separated _ by a simple cycle @xmath7 in @xmath0 if one face is contained in @xmath36 and the other face is contained in @xmath37 .",
    "a set of simple cycles of @xmath0 is called _ nested _ if , for any two distinct cycles @xmath7 and @xmath38 in that set , either @xmath39 , @xmath40 , or @xmath41 . a simple cycle @xmath7 is said to _ cross _ another simple cycle @xmath38 if @xmath42 is not nested .    for cycles",
    "@xmath7 and @xmath38 in a nested set @xmath43 , we say that @xmath7 is a _ child _ of @xmath38 and @xmath38 is the _ parent _ of @xmath7 ( w.r.t .",
    "@xmath43 ) if @xmath39 .",
    "we also define ancestors and descendants in the obvious way .",
    "we can represent these relationships in a forest where each tree vertex corresponds to a cycle of @xmath43 .    for any cycle @xmath44 , we define _ internal region _ @xmath45 as the subset @xmath46 of the plane , where @xmath47 are the children ( if any ) of @xmath7 , see figure  [ fig : regions](a ) .",
    "the _ external region _",
    "@xmath48 is defined as the set @xmath49 , where @xmath47 are the cycles associated with roots of trees in the forest defined above .",
    "collectively , we refer to the internal regions and the external region as _",
    "regions_.    with @xmath47 defined as above for a region @xmath50 ( internal or external ) , we refer to the internal regions @xmath51 as the _ children _ of @xmath50 and we call @xmath50 the _ parent _ of these regions .",
    "again , we can define ancestors and descendants in the obvious way .",
    "note that the external region is the ancestor of all other regions .",
    "we can thus represent the relationships in a tree where each vertex corresponds to a region .",
    "we call it the _ region tree _ of @xmath43 and denote it by @xmath52 , see figure  [ fig : regions](b ) .    note that for two cycles @xmath7 and @xmath38 in @xmath43 , @xmath7 is a child of @xmath38 if and only if @xmath45 is a child of @xmath53 .",
    "hence , the region tree @xmath52 also describes the parent / child relationships between cycles of @xmath43 .",
    "the elementary faces of @xmath0 belonging to a region @xmath50 are the _ elementary faces _ of @xmath50 . for each child @xmath54 of @xmath50",
    ", @xmath55 is called a _ non - elementary face _ of @xmath50 .",
    "if @xmath50 is an internal region @xmath45 , the _ external face _ of @xmath50 is the subset @xmath37 of the plane and we classify it as a non - elementary face of @xmath50 .",
    "collectively , we refer to the elementary and non - elementary faces of @xmath50 as its _ faces_.    a cycle @xmath7 in @xmath0",
    "is said to be _ isometric _ if for any two vertices @xmath56 , there is a shortest path between @xmath57 and @xmath58 contained in @xmath7 .",
    "a set of cycles is said to be isometric if all cycles in the set are isometric .",
    "the _ dual _ @xmath59 of @xmath0 is the multigraph having a vertex for each elementary face of @xmath0 and having an edge @xmath60 between two dual vertices for every edge @xmath13 of @xmath0 shared by the elementary faces corresponding to the two dual vertices .",
    "the weight of @xmath60 in @xmath59 is equal to the weight of @xmath13 in @xmath0 .",
    "we identify elementary faces of @xmath0 with vertices of @xmath59 and since there is a one - to - one correspondence between edges of @xmath0 and edges of @xmath59 , we identify an edge of @xmath0 with the corresponding edge in @xmath59 .",
    "assume in the following that @xmath0 is connected .",
    "given a vertex @xmath61 , we let @xmath62 denote a shortest path tree in @xmath0 with source @xmath57 .",
    "the _ dual _ of @xmath62 is the subgraph of @xmath59 defined by the edges not in @xmath62 .",
    "it is well - known that this subgraph is a spanning tree in @xmath59 and we denote it by @xmath63 .",
    "the following lemma will prove useful .",
    "[ lem : subtreedual ] assume that for any two vertices in @xmath0 , there is a unique shortest path between them in @xmath0 .",
    "let @xmath7 be an isometric cycle in @xmath0 and let @xmath61 .",
    "if @xmath64 resp .",
    "@xmath65 then the elementary faces of @xmath0 in @xmath36 resp .  in @xmath37 are spanned by a subtree of @xmath63 .",
    "if @xmath66 , i.e. , @xmath67 , then these two subtrees are obtained by removing the single edge of @xmath63 having one end vertex in @xmath36 and one end vertex in @xmath37 .",
    "suppose that @xmath64 , see figure  [ fig : defs ] .",
    "the subgraph of shortest path tree @xmath62 contained in @xmath36 is a forest .",
    "since @xmath7 is isometric and since shortest paths are unique , each tree in this forest contains exactly one vertex of @xmath7 .",
    "this implies that the edges of @xmath0 belonging to @xmath36 and not to this forest define a connected component in the dual of @xmath0 .",
    "since all these edges belong to @xmath63 , it follows that the elementary faces of @xmath0 in @xmath36 are spanned by a subtree of @xmath63 , as desired .",
    "a similar argument shows that if @xmath65 then the elementary faces of @xmath0 in @xmath37 are spanned by a subtree of @xmath63 .",
    "finally , assume that @xmath67 .",
    "there is at least one edge in @xmath63 with one end vertex in @xmath36 and one end vertex in @xmath37 since otherwise , @xmath63 would be disconnected .",
    "there can not be more than one such edge since that would contradict the first part of the lemma .",
    "this shows the second part .",
    "horton cycle _ of @xmath0 is a cycle obtained by adding a single edge @xmath13 to a shortest path tree in @xmath0 rooted at some vertex @xmath68 .",
    "we denote this cycle by @xmath69 . for a subset @xmath70 of @xmath71 , we let @xmath72 denote the set of horton cycles of @xmath0 obtained from shortest path trees rooted at vertices of @xmath70 .    for any graph @xmath73 , we let @xmath74 and @xmath75 denote its vertex and edge set , respectively . if @xmath76 is a weight function on the edges of @xmath0 , we say that a subgraph @xmath73 of @xmath0 has _ weight _",
    "@xmath77 if @xmath78 .",
    "in this section , we show that there are planar graphs of arbitrarily large size for which the total length of cycles in any mcb is quadratic .",
    "this implies that the algorithm in  @xcite is optimal since it runs in @xmath1 time .",
    "the instance @xmath79 containing @xmath2 vertices is defined as follows .",
    "let @xmath80 be the vertices of @xmath79 . for @xmath81",
    ", there is an edge @xmath82 of weight @xmath83 . for @xmath84",
    ", there is an edge @xmath85 of weight @xmath86 .    since @xmath79 has @xmath87 edges , any mcb of @xmath79 consists of @xmath88 cycles .",
    "in such a basis , every cycle must contain at least one of the edges @xmath89 , @xmath84 .",
    "hence , the cycles in any mcb of @xmath79 have total weight at least @xmath90 .    for @xmath84 ,",
    "let @xmath54 be the cycle containing edges @xmath91 in that order .",
    "it is easy to see that the set of these cycles is a cycle basis of @xmath0 .",
    "furthermore , their total weight is @xmath90 so by the above , they must constitute an mcb of @xmath79 .",
    "in fact , it is the unique mcb of @xmath79 since in any other cycle basis , some cycle must contain at least two weight @xmath86 edges , implying that the total weight is at least @xmath92",
    ".    the cycles in the unique mcb of @xmath79 clearly have quadratic total length .",
    "this gives the following result .",
    "there are instances of planar graphs of arbitrarily large size @xmath2 for which the cycles in any mcb for such an instance have total length @xmath93 .    in section  [ sec : divideconquer ]",
    ", we show how to break the quadratic time bound by computing an implicit rather than an explicit representation of an mcb .",
    "in the following , @xmath30 denotes an @xmath2-vertex plane , straight - line embedded , undirected graph with non - negative edge weights .",
    "we may assume that @xmath0 is connected since otherwise , we can consider each connected component separately .",
    "we require that there is a unique shortest path in @xmath0 between any two vertices . in section  [ sec : lexshort ] , we show how to avoid this restriction .",
    "the algorithm in figure  [ fig : pseudocodegreedy ] will find an mcb of @xmath0 ( see  @xcite ) .",
    "initialize @xmath94 + 2 . for each simple cycle @xmath7 of @xmath0 in order of non - decreasing weight , + 3 .",
    "if there is a pair of elementary faces of @xmath0 separated by @xmath7 and not by + any cycle in @xmath43 , + 4 .",
    "add @xmath7 to @xmath43 + 5 .",
    "output @xmath43",
    "we call this algorithm the _ generic greedy algorithm _ and we call the mcb obtained this way a _ greedy mcb _ ( gmcb ) ( of @xmath0 ) .",
    "we assume that ties in the ordering in line @xmath95 are resolved in some deterministic way so that we may refer to the cycle basis output in line @xmath96 as _ the _ gmcb of @xmath0 .",
    "the following two results are from  @xcite .",
    "[ lem : gmcbisonested ] the gmcb is isometric and nested and consists of horton cycles .",
    "[ lem : facesep ] for every pair of elementary faces of a plane undirected graph @xmath73 with non - negative edge weights , the gmcb of @xmath73 contains a minimum - weight cycle @xmath7 in @xmath73 that separates those two faces .",
    "cycle @xmath7 is the first such cycle considered when applying the generic greedy algorithm to @xmath73 .",
    "our algorithm is essentially the generic greedy algorithm except that we consider a smaller family of cycles in line @xmath95 .",
    "the main difficulty in giving an efficient implementation of the greedy algorithm is testing the condition in line @xmath97 . describing how to do this constitutes the main part of the paper .",
    "the family of cycles that we pick in line @xmath95 of the generic greedy algorithm is obtained with the divide - and - conquer paradigm .    to separate our problem ,",
    "we apply the cycle separator theorem of miller  @xcite to @xmath0 .",
    "this gives in linear time a jordan curve @xmath31 intersecting @xmath98 vertices and no edges of @xmath0 such that the subgraph @xmath99 of @xmath0 in @xmath34 and the subgraph @xmath100 of @xmath0 in @xmath35 each contain at most @xmath101 vertices .",
    "we let @xmath102 denote the set of vertices on @xmath31 and refer to them as _ boundary vertices _ of @xmath0 .    as in @xmath0",
    ", we assume that shortest paths in @xmath99 and @xmath100 are unique . in section  [ sec : lexshort ]",
    ", we show how to avoid this assumption .    for @xmath103 ,",
    "let @xmath104 be the gmcb of @xmath105 .",
    "let @xmath106 be the subset of cycles of @xmath104 containing no vertices of @xmath102 .",
    "[ lem : divideconquer ] with the above definitions , @xmath107 contains the gmcb of @xmath0 .",
    "let @xmath43 be the gmcb of @xmath0 and let @xmath7 be a cycle of @xmath0 not belonging to @xmath107 .",
    "we need to show that @xmath108 .    by lemma  [ lem : gmcbisonested ]",
    ", we may assume that @xmath7 is isometric .",
    "furthermore , we may assume that it does not belong to @xmath109 ( since otherwise , it would belong to @xmath110 and hence to @xmath111 since it is isometric and since shortest paths are unique ) .",
    "since @xmath112 , @xmath7 does not contain any vertices of @xmath102 so it belongs to @xmath105 , where @xmath113 .",
    "in particular , it is considered by the generic greedy algorithm in the construction of @xmath104 .    since @xmath114 , lemma  [ lem : facesep ] implies that every pair of elementary faces @xmath115 of @xmath105 , where @xmath116 and @xmath117 , must be separated by some cycle of @xmath104 having smaller weight than @xmath7 ( or a cycle having the same weight as @xmath7 but considered earlier in the generic greedy algorithm ) .",
    "we claim that this statement also holds when replacing @xmath104 by @xmath43 and @xmath105 by @xmath0 .",
    "if we can show this , it will imply that @xmath7 is not added to @xmath43 by the generic greedy algorithm .",
    "so let @xmath115 be a pair of elementary faces of @xmath0 with @xmath116 and @xmath117 .",
    "either @xmath118 or @xmath119 is an elementary face of @xmath105 since either @xmath120 or @xmath121 .",
    "assume w.l.o.g .",
    "that @xmath118 is an elementary face of @xmath105 .",
    "if @xmath119 is also an elementary face of @xmath105 belonging to the same connected component @xmath122 of @xmath105 as @xmath118 , the above implies that @xmath118 and @xmath119 are separated by some cycle @xmath123 having smaller weight than @xmath7 .",
    "since @xmath38 is also considered by the generic greedy algorithm when constructing @xmath43 , it follows that @xmath118 and @xmath119 are separated by a cycle in @xmath43 having weight smaller than that of @xmath7 , as desired .",
    "conversely , if @xmath119 is not an elementary face of @xmath105 belonging to @xmath122 , @xmath119 must be contained in the external elementary face @xmath124 of @xmath122 . by lemma  [ lem : facesep ] ,",
    "there is a cycle of @xmath104 which is shorter than @xmath7 and which separates @xmath118 and @xmath124 .",
    "this cycle also separates @xmath118 and @xmath119 and it follows that @xmath118 and @xmath119 are separated by a cycle in @xmath43 having weight smaller that that of @xmath7 .",
    "the above shows that @xmath108 , completing the proof of the lemma .",
    "lemma  [ lem : divideconquer ] suggests the following divide - and - conquer algorithm for our problem : recursively compute gmcb s @xmath125 and @xmath126 of @xmath99 and @xmath100 , compute @xmath111 , and extract from @xmath107 the gmcb of @xmath0 by applying the generic greedy algorithm to this smaller set of cycles .",
    "pseudocode of this algorithm is shown in figure  [ fig : pseudocoderec ] ( it is assumed that a brute - force algorithm is applied to find the gmcb of @xmath0 when @xmath0 has constant size ) .",
    "we call it the _ recursive greedy algorithm_.    ddd============1 .",
    "recursively compute gmcb s @xmath125 and @xmath126 of @xmath99 and @xmath100 , respectively + 2 .",
    "initialize @xmath94 + 3 .",
    "for each cycle @xmath127 in order of non - decreasing weight , + 4 . if there is a pair of elementary faces of @xmath0 separated by @xmath7 and not by + any cycle in @xmath43 , + 5 .",
    "add @xmath7 to @xmath43 + 6 .",
    "output @xmath43",
    "we will show how to implement the top - level of the recursion in @xmath3 time and @xmath4 space . since each step of the recursion partitions the graph into two subgraphs of ( almost ) the same size  @xcite",
    ", it will follow that these bounds hold for the entire algorithm .    since the algorithm constructs the gmcb",
    ", @xmath43 is isometric and nested at all times .",
    "thus , @xmath43 represents a set of regions that change during the course of the algorithm .",
    "more specifically , when the algorithm starts , @xmath94 and there is only one region , namely the external region @xmath48 . whenever a cycle @xmath7 is added to @xmath43 in line @xmath96 , the region @xmath50 containing @xmath7 is replaced by two new regions , one , @xmath128 , contained in @xmath36 and one , @xmath129 , contained in @xmath37 .",
    "we say that @xmath7 _ splits _",
    "@xmath50 into @xmath128 and @xmath129 .",
    "we call @xmath128 the _ internal region _ and @xmath129 the _ external region _ ( w.r.t",
    ".  @xmath50 and @xmath7 ) .",
    "figure  [ fig : regionsplit ] gives an illustration .",
    "the following lemma relates the test in line @xmath130 to the two regions generated by the split .",
    "[ lem : splittest ] the condition in line @xmath130 in the recursive greedy algorithm is satisfied if and only if @xmath7 splits a region into two each of which contains at least one elementary face .",
    "let @xmath50 be the region containing @xmath7 and suppose that @xmath7 splits @xmath50 into @xmath128 and @xmath129 .",
    "consider two elementary faces of @xmath0 separated by @xmath7 .",
    "no cycle of @xmath43 separates them if and only if the two faces belong to the same region .",
    "hence , the condition in line @xmath130 is satisfied if and only if @xmath7 separates a pair of elementary faces both belonging to @xmath50 .",
    "the latter is equivalent to the condition that there is an elementary face in @xmath128 and an elementary face in @xmath129 .",
    "lemma  [ lem : splittest ] shows that if we can keep track of the number of elementary faces of @xmath0 in regions during the course of the algorithm , then testing the condition in line @xmath130 is easy : it holds if and only if the number of elementary faces of @xmath0 in each of the two regions obtained by inserting @xmath7 is at least one . in the following ,",
    "we introduce so called contracted dual trees and pruned dual trees that will help us keep track of the necessary information .",
    "first , we need the following lemma .",
    "[ lem : nocross ] let @xmath73 be a plane graph with non - negative edge weights and assume that shortest paths in @xmath73 are unique .",
    "let @xmath7 be an isometric cycle in @xmath73 and let @xmath131 be a shortest path in @xmath73 between vertices @xmath57 and @xmath58 .",
    "if both @xmath57 and @xmath58 belong to @xmath36 then @xmath131 is contained in @xmath36 .",
    "if both @xmath57 and @xmath58 belong to @xmath37 then @xmath131 is contained in @xmath37 .",
    "suppose that @xmath132 and assume for the sake of contradiction that @xmath131 is not contained in @xmath36 .",
    "then there is a subpath @xmath133 of @xmath131 between a vertex @xmath134 and a vertex @xmath135 with all interior vertices belonging to @xmath136 . since @xmath7 is isometric",
    ", there is a shortest path @xmath137 contained in @xmath7 between @xmath138 and @xmath139 .",
    "but @xmath133 is also a shortest path between @xmath138 and @xmath139 .",
    "since @xmath140 , this contradicts the uniqueness of shortest paths in @xmath73 .",
    "a similar proof holds when @xmath141 .    for a region @xmath50 and a boundary vertex @xmath58 belonging to @xmath50 , the _ contracted dual tree",
    "@xmath142 is the tree obtained from dual tree @xmath143 by contracting each edge @xmath144 , where @xmath57 and @xmath138 are elementary faces in @xmath0 both contained in the same non - elementary face of @xmath50 , see figure  [ fig : contracteddualtree ] .",
    "an important observation is that there is a one - to - one correspondence between the vertices of @xmath142 and the faces of @xmath50 .",
    "we assign the colour white resp .",
    "black to those vertices of @xmath142 corresponding to elementary resp .",
    "non - elementary faces of @xmath50 , see figure  [ fig : contracteddualtree ] .",
    "we identify each edge in @xmath142 with the corresponding edge in @xmath143 .    to ease the presentation of our ideas , we assume for now that only cycles from @xmath111 are encountered in line @xmath97 of the recursive greedy algorithm . in section  [ subsec : reccycles ] , we show how to handle cycles from @xmath145 as well .",
    "so consider some iteration of the algorithm where a cycle @xmath146 has just been picked in line @xmath97 and assume that all cycles added to @xmath43 so far all belong to @xmath111 .",
    "cycle @xmath7 should be added to @xmath43 only if @xmath147 is nested .",
    "we will now show how to detect whether this is the case using the contracted dual trees .",
    "if there is a region @xmath50 containing @xmath58 such that @xmath142 contains @xmath13 then @xmath13 ( in @xmath0 ) belongs to @xmath50 ( since otherwise , @xmath13 would have been contracted in @xmath142 ) . since each cycle in @xmath43 is isometric and since shortest paths are unique , lemma  [ lem : nocross ] implies that @xmath147 is nested . and the converse is also true : if @xmath147 is nested then there is a region @xmath50 containing @xmath7 .",
    "in particular , @xmath50 contains @xmath13 so this edge must belong to @xmath142 .",
    "it follows that detecting whether @xmath147 is nested amounts to checking whether @xmath13 is present in @xmath142 for some region @xmath50 .",
    "now , assume that @xmath147 is nested ( otherwise , we can discard @xmath7 ) and let us see how the contracted dual trees can help us check the condition in line @xmath130 of the recursive greedy algorithm .",
    "define @xmath50 to be the region containing @xmath7 .",
    "since @xmath13 belongs to @xmath50 , this edge belongs to the contracted dual tree @xmath142 .",
    "let @xmath148 and @xmath149 be the end vertices of @xmath13 in @xmath142 .",
    "removing @xmath13 from @xmath142 splits this tree into two subtrees , one , @xmath150 , attached to @xmath148 and one , @xmath151 , attached to @xmath149 . by lemma  [ lem : splittest ] ,",
    "the condition in line @xmath130 is satisfied if and only if @xmath150 and @xmath151 each contain at least one white vertex .",
    "unfortunately , both of these two subtrees may contain many black vertices so for performance reasons , a simple search in these trees to determine whether they contain white vertices is infeasible .",
    "we therefore introduce _ pruned ( contracted ) dual tree _",
    "@xmath152 , defined as the subtree of @xmath142 obtained by removing a black degree one vertex and repeating this procedure on the resulting tree until all degree one vertices are white , see figure  [ fig : contracteddualtree ] .",
    "we refer to this as the _ pruning procedure_.    [ lem : whitevertcond ] with the above definitions , @xmath153 if and only if @xmath150 and @xmath151 both contain white vertices .",
    "if @xmath150 contains only black vertices then the pruning procedure will remove all vertices in @xmath150 .",
    "in particular , the procedure removes @xmath148 .",
    "similarly , if @xmath151 contains only black vertices then @xmath149 is removed . in both cases , @xmath13 is removed so @xmath154 .",
    "conversely , if both @xmath150 and @xmath151 contain white vertices then the pruning procedure does not remove all vertices from @xmath150 and does not remove all vertices from @xmath151 .",
    "hence , neither @xmath148 nor @xmath149 is removed so @xmath153 .",
    "lemma  [ lem : whitevertcond ] shows that once @xmath152 is given , it is easy to determine whether both @xmath150 and @xmath151 contain white vertices and hence whether the condition in line @xmath130 is satisfied : simply check whether @xmath153 .    note that if line @xmath130 is satisfied , @xmath153 and hence @xmath155 . by the above",
    ", this implies that @xmath147 is nested .",
    "this shows that we only need @xmath152 to test the condition in line @xmath130 .      in the previous section , we introduced contracted and pruned dual trees and showed how the latter can be used to test the condition in line @xmath130 of the recursive greedy algorithm for cycles in @xmath156 . in the following ,",
    "we show how to maintain regions and contracted and pruned dual trees when such cycles are added to @xmath43 in line @xmath96 .    initially , @xmath94 so the contracted and pruned dual trees are simply the dual trees @xmath143 for each boundary vertex @xmath157 .",
    "and there is only one region , namely the external region @xmath48 .    now , suppose @xmath158 has just been inserted into @xmath43 in line @xmath96 , see figure  [ fig : twodualsubtrees ] .",
    "let @xmath50 be the region such that @xmath7 splits @xmath50 into internal region @xmath128 and external region @xmath129 .",
    "we need to identify the faces of @xmath50 belonging to @xmath128 and to @xmath129 .",
    "this can be done with two searches in contracted dual tree @xmath142 .",
    "one search starts in the end vertex of @xmath13 belonging to @xmath36 and avoids @xmath13 ( visiting the gray vertices in figure  [ fig : twodualsubtrees ] ) .",
    "the other search starts in the end vertex of @xmath13 belonging to @xmath37 and also avoids @xmath13 ( visiting the white vertices in figure  [ fig : twodualsubtrees ] ) .",
    "it follows from lemma  [ lem : subtreedual ] and from the definition of contracted dual trees that the first search identifies the faces of @xmath50 that should belong to @xmath128 and the second search identifies those that should belong to @xmath129 .",
    "we also need to form one new face for @xmath128 , namely the face defined by @xmath37 .",
    "we denote this face by @xmath159 .",
    "similarly , we need to form a new face for @xmath129 , defined by @xmath36 , and we denote this face by @xmath160 .",
    "next , we update contracted dual trees .",
    "the only ones affected are those of the form @xmath161 , where @xmath162 .",
    "there are three cases to consider : @xmath163 , @xmath164 , and @xmath67 .",
    "[ [ case-1 ] ] case @xmath86 : + + + + + + + + + + + + + + + + + + + + +    consider first a contracted dual tree @xmath161 with @xmath163 .",
    "then @xmath165 so we need to discard @xmath161 and construct @xmath166 .",
    "we obtain the latter from the former by contracting all edges of @xmath161 having both end vertices in @xmath37 to a single vertex ( this is possible by lemma  [ lem : subtreedual ] ) .",
    "we identify this new vertex with the new face @xmath159 of @xmath128 .",
    "[ [ case-2 ] ] case @xmath95 : + + + + + + + + + + + + + + + + + + + + +    now , assume that @xmath164 .",
    "then @xmath167 so @xmath161 should be replaced by @xmath168 .",
    "we do this by contracting all edges of @xmath161 having both end vertices in @xmath36 to a single vertex ( again , we make use of lemma  [ lem : subtreedual ] ) and we identify this vertex with the new face @xmath160 of @xmath129 .",
    "[ [ case-3 ] ] case @xmath97 : + + + + + + + + + + + + + + + + + + + + +    finally , assume that @xmath67 .",
    "now , @xmath57 belongs to both @xmath128 and @xmath129 so we need to discard @xmath161 and construct @xmath166 and @xmath168 . to do this , we first identify the edge @xmath169 in @xmath161 having one end vertex @xmath170 in @xmath36 and one end vertex @xmath171 in @xmath37 .",
    "then we construct the two trees @xmath172 and @xmath173 formed by removing @xmath169 from @xmath161 with @xmath174 and @xmath175 .",
    "we let @xmath176 be @xmath172 augmented with the edge from @xmath170 to @xmath159 and let @xmath177 be @xmath173 augmented with the edge from @xmath171 to @xmath160 .",
    "it follows from lemma  [ lem : subtreedual ] that @xmath176 is the contracted dual tree @xmath166 for @xmath128 and that @xmath177 is the contracted dual tree @xmath168 for @xmath129 .",
    "we have described how to update contracted dual trees when @xmath7 is added to @xmath43 .",
    "we apply the same method to update pruned dual trees .",
    "the only difference is that the pruning procedure needs to be applied whenever a change is made to a pruned dual tree .",
    "above , we gave an overall description of the algorithm when only cycles of @xmath111 are considered .",
    "we now go into more details and show how to give an efficient implementation of this algorithm .",
    "we start by describing the data structures that our algorithm makes use of .",
    "the main objects involved are regions , contracted dual trees , and pruned dual trees and we consider them in the following .",
    "associated with a region @xmath50 is a _ face list _",
    "@xmath178 which is a linked list containing the faces of @xmath50 .",
    "an entry of @xmath178 corresponding to a face @xmath179 is assigned the colour white resp .",
    "black if @xmath179 is elementary resp .",
    "non - elementary .",
    "if it is black , it has a bidirected pointer to the child of @xmath50 contained in @xmath179 .",
    "this gives a representation of the region tree @xmath52 .",
    "if the entry is white , it points to the corresponding elementary face of @xmath0 .",
    "the entry also points to the entire data structure for @xmath50 .",
    "associated with the @xmath179-entry of @xmath178 is also an array @xmath180 with an entry for each boundary vertex in @xmath181 .",
    "the entry of @xmath180 for a boundary vertex @xmath58 belonging to @xmath50 has a bidirected pointer to vertex @xmath179 in contracted dual tree @xmath142 , see figure  [ fig : datastruct ] .",
    "it also has a bidirected pointer to vertex @xmath179 in pruned dual tree @xmath152 if that vertex has not been deleted by the pruning procedure .",
    "all other entries of @xmath180 point to null .      associated with a contracted dual tree @xmath142 is a _ vertex list _",
    "@xmath182 which is a linked list with an entry for each vertex of @xmath142 .",
    "the entry for a vertex @xmath57 points to the entry of @xmath178 for the face of @xmath50 corresponding to @xmath57 . associated with the @xmath57-entry of @xmath182 is also an _ edge adjacency list _ @xmath183 , a linked list representing the edges adjacent to @xmath57 in @xmath142 .",
    "each list entry contains a pointer to the @xmath57-entry of vertex list @xmath182 ( allowing us to find the head of @xmath183 in constant time ) as well as a bidirected pointer to an _ edge data structure_. the edge data structure thus contains two pointers , one for each of its end vertices .",
    "furthermore , it contains a bidirected pointer to the corresponding edge in dual tree @xmath143 , see figure  [ fig : datastruct ] .",
    "we keep a similar data structure for pruned dual tree @xmath152 .",
    "both data structures need to support edge contractions , edge insertions , and edge deletions and the data structure for @xmath152 also needs to support the pruning procedure .",
    "we describe how to do this in the following .",
    "[ [ edge - contraction ] ] edge contraction : + + + + + + + + + + + + + + + + +    we only describe edge contractions for contracted dual trees since pruned dual trees can be dealt with in a similar way .",
    "assume we have a set @xmath184 of edges ( or edge data structures ) in @xmath142 to be contracted to a single new vertex @xmath185 and that these edges span a subtree of @xmath142 .",
    "we assume that we have a pointer to the entry of @xmath178 corresponding to @xmath185 .    to contract an edge @xmath186 , we first remove the pointer to the edge of dual tree @xmath143 corresponding to @xmath13 . traversing the two pointers associated with @xmath13",
    ", we find an entry in @xmath187 and an entry in @xmath188 , where @xmath170 and @xmath171 are the end vertices of @xmath13 in @xmath142 .",
    "we remove those two entries in lists @xmath189 and @xmath190 and then merge @xmath191 and @xmath192 to one list @xmath193 since the new vertex is adjacent to edges adjacent to @xmath170 and @xmath171 except @xmath13 . if @xmath191 is appended to the tail of @xmath192 , we make every entry in @xmath191 point to the @xmath171-entry in vertex list @xmath182 .",
    "otherwise , we make every entry in @xmath192 point to the @xmath170-entry in that list . for performance reasons ,",
    "we append the shorter of the two lists to the tail of the other .",
    "we repeat the above for each edge of @xmath184 and we end up with a single entry in @xmath182 representing the new vertex @xmath185 .",
    "we make this entry point to the entry of @xmath178 corresponding to @xmath185 and we update the pointer to the @xmath58-entry in the associated array .    how long does it take to contract edges ? we will need the following lemma in our analysis ( the proof can be found in the appendix ) .    [",
    "lem : merge ] consider a set of objects , each assigned a positive integer weight .",
    "let @xmath194 be an operation that replaces two objects @xmath195 and @xmath196 by a new object whose weight is the sum of the weights of @xmath195 and @xmath196 .",
    "assume that the time to execute @xmath194 is bounded by the smaller weight of objects @xmath195 and @xmath196 .",
    "then repeating the @xmath197-operation on pairs of objects in any order until at most one object remains takes @xmath198 time where @xmath199 is the total weight of the original objects .",
    "fix a @xmath200 and consider the set of contracted dual trees of the form @xmath142 generated during the course of the algorithm . each time a cycle from @xmath156 is added to @xmath43 , at most two new edges are inserted into trees of this form ( case @xmath97 in section  [ sec : insertcycle ] ) .",
    "hence , there are @xmath201 edges in total .",
    "it then follows easily from lemma  [ lem : merge ] and from the way we concatenate lists during edge contractions that the total time spent on edge contractions in all contracted dual trees of the form @xmath142 is @xmath202 .",
    "since the number of choices of @xmath58 is @xmath98 , we get a bound of @xmath3 time for all edge contractions performed by the algorithm .    [ [ edge - deletion ] ] edge deletion : + + + + + + + + + + + + + +    we also describe this only for contracted dual trees .",
    "so suppose we are to delete an edge @xmath203 from @xmath142 .",
    "we need to form two new trees , @xmath172 and @xmath173 .",
    "let @xmath172 be the tree containing @xmath170 and let @xmath173 be the tree containing @xmath171 . for @xmath103 , a simple search ( say , depth - first ) in @xmath142 starting in @xmath204 and avoiding",
    "@xmath13 finds the vertices of @xmath205 in time proportional to the size of this tree . by alternating between these two searches ( i.e. , essentially performing them in parallel )",
    ", we can find the vertices of the smaller of the two trees in time proportional to the size of that tree .",
    "suppose that , say , @xmath172 is the smaller tree .",
    "then we can form the two data structures for @xmath172 and @xmath173 in time proportional to the size of @xmath172 : extract the entries of vertex list @xmath182 that should belong to @xmath172 and form a new vertex list containing these entries .",
    "the old data structure for @xmath142 now becomes the new data structure for @xmath173 after the entries have been removed .",
    "we also need to remove the pointer between @xmath13 and the corresponding edge in dual tree @xmath143 and remove @xmath13 from the edge adjacency lists but this can be done in constant time .",
    "the following lemma , which is similar to lemma  [ lem : merge ] , immediately implies that the total time for edge deletions is @xmath3 ( the proof of the lemma is in the appendix ) .",
    "[ lem : split ] consider an object @xmath195 with a positive integer weight @xmath199 .",
    "let @xmath206 be an operation that splits an object of weight at least two into two new objects of positive integer weights such that the sum of weights of the two equals the weight of the original object .",
    "assume that @xmath206 runs in time proportional to the smaller weight of the two new objects . then repeating the @xmath206-operation in any order , starting with object @xmath195",
    ", takes @xmath198 time .",
    "[ [ edge - insertion ] ] edge insertion : + + + + + + + + + + + + + + +    the only situation where edge insertions are needed is in case @xmath97 of section  [ sec : insertcycle ] . with our data structure , this can clearly be done in constant time per insertion .",
    "[ [ pruning - procedure ] ] pruning procedure : + + + + + + + + + + + + + + + + + +    finally , let us describe how to implement the pruning procedure for pruned dual trees . recall that this procedure repeatedly removes black degree one vertices until no such vertices exist .",
    "we only need to apply the pruning procedure after an edge contraction and after an edge deletion ( edge insertions are not needed in pruned dual trees since these edges will be removed by the pruning procedure ) .",
    "let us only consider edge deletions since edge contractions are similar .",
    "consider a pruned dual tree @xmath152 and suppose the algorithm removes an edge @xmath203 from this tree .",
    "this forms two new trees @xmath172 and @xmath173 , containing @xmath170 and @xmath171 , respectively . in @xmath172 , only @xmath170 can be a black degree one vertex since in @xmath152 , no vertices had this property . checking whether @xmath170 should be removed takes constant time . if it is removed , we repeat the procedure on the vertex that was adjacent to @xmath170 .",
    "we apply the same strategy in @xmath173 , starting in @xmath171 .",
    "the total time spent in the pruning procedure is proportional to the number of vertices removed . since the number of vertices only decreases and since the initial number of vertices in all pruned dual trees is @xmath4 , the total time spent by the pruning procedure is @xmath4 .",
    "having described the data structures involved and how they can support the basic operations that we need , let us show how to give an efficient implementation of our algorithm .",
    "still , we only consider cycles from @xmath156 in the for - loop .",
    "[ [ initialization ] ] initialization : + + + + + + + + + + + + + + +    first , we consider the initialization step .",
    "applying the separator theorem of miller gives us @xmath31 and @xmath102 in linear time .",
    "for each boundary vertex @xmath58 , we need to compute shortest path tree @xmath207 and shortest path distances from @xmath58 in @xmath0 .",
    "this can be done in @xmath202 time with dijkstra s algorithm for a total of @xmath3 time ( in fact , a shortest path tree can be computed in linear time  @xcite but this will not improve the overall running time of our algorithm ) .",
    "we also need to compute dual trees @xmath143 and this can easily be done in @xmath4 additional time .",
    "these dual trees are also the initial contracted and pruned dual trees . since we need all three types of trees during the course of the algorithm , three copies of each dual tree are initialized .",
    "the algorithm then recursively computes @xmath125 and @xmath126 .",
    "it is assumed that the recursive calls also return the weights of cycles in these sets .",
    "our algorithm needs to extract @xmath208 and @xmath209 from these sets .",
    "this is done as follows . for every shortest path tree @xmath207 that has been computed in recursive calls ( we assume that these trees are kept in memory ) , we mark vertices of @xmath207 belonging to @xmath102",
    ". then we mark all descendants of these vertices in @xmath207 as well .",
    "now , a horton cycle @xmath210 obtained by adding @xmath13 to @xmath207 contains a vertex of @xmath102 if and only if at least one of the end vertices of @xmath13 is marked . since the total size of all recursively computed shortest path trees",
    "is bounded by the total space requirement which is @xmath4 , it follows that @xmath208 and @xmath209 can be extracted from @xmath125 and @xmath126 in @xmath4 time .",
    "the cycles in @xmath107 need to be sorted in order of non - decreasing weight .",
    "we are given the weights of cycles in @xmath145 from the recursive calls and we can compute the weights of cycles in @xmath111 in a total of @xmath4 time using the shortest path distances computed above . hence , sorting the cycles in @xmath107 can be done in @xmath3 time .    [",
    "[ testing - condition - in - line-4 ] ] testing condition in line @xmath130 : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    next , we consider the for - loop of the algorithm for some cycle @xmath146 . as we saw in section  [ subsec : contracteddualtrees ] , testing the condition in line @xmath130 amounts to testing whether dual edge @xmath13 in @xmath143 is present in some pruned dual tree .",
    "recall that we keep pointers between edges of dual trees and pruned dual trees .",
    "since we remove a bidirected pointer between an edge data structure and the corresponding edge in a dual tree whenever it is contracted or deleted in a pruned dual tree , we can thus execute line @xmath130 in constant time .    [ [ inserting - a - cycle ] ] inserting a cycle : + + + + + + + + + + + + + + + + + +    line @xmath96 requires more work and we deal with it in the following .",
    "suppose we are about to add the above cycle @xmath7 to @xmath43 in line @xmath96 . with the pointer associated with @xmath13",
    ", we find the corresponding edge data structure in a contracted dual tree @xmath142 . traversing pointers from this data structure , we find the data structure for @xmath50 in constant time .",
    "this region should be split into two new regions @xmath128 and @xmath129 , where @xmath128 is the internal and @xmath129 the external region w.r.t .",
    "@xmath50 and @xmath7 .",
    "we need to identify the boundary vertices and the of faces in @xmath50 that belong to @xmath128 and @xmath129 , respectively .    [",
    "[ identifying - boundary - vertices - in - r_1-and - r_2 ] ] identifying boundary vertices in @xmath128 and @xmath129 : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    we first identify the set @xmath211 of boundary vertices of @xmath102 belonging to @xmath50 by traversing any one of the arrays @xmath180 associated with an entry of @xmath178 and picking the vertices not having null - pointers .",
    "this takes @xmath98 time .",
    "since the total number of times we add a cycle to @xmath43 is @xmath201 , total time for this during the course of the algorithm is @xmath4 .",
    "we will extract three subsets from @xmath211 : the subset @xmath212 of vertices belonging to @xmath213 , the subset @xmath214 belonging to @xmath136 , and the subset @xmath215 belonging to @xmath7 .",
    "if we can find these three subsets , we also obtain sets @xmath216 and @xmath217 of boundary vertices for @xmath128 and @xmath129 , respectively , since @xmath218 and @xmath219 .",
    "the following lemma bounds the time to find the three subsets .",
    "the proof is somewhat long and can be found in the appendix .",
    "[ lem : deltasets ] with the above definitions , we can find in @xmath98 time the sets @xmath212 , @xmath214 , and @xmath215 with @xmath3 time and @xmath4 space for preprocessing .",
    "lemma  [ lem : deltasets ] implies that the total time spent on computing sets of boundary vertices over all regions generated by the algorithm is @xmath4 ( plus @xmath3 time for preprocessing ) .",
    "[ [ identifying - faces - of - r_1-and - r_2 ] ] identifying faces of @xmath128 and @xmath129 : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    having found the boundary vertices belonging to @xmath128 and @xmath129 , we next focus on the problem of identifying the faces of @xmath50 belonging to each of the two new regions .",
    "as previously observed ( see figure  [ fig : twodualsubtrees ] ) , we can identify the faces of @xmath128 resp .",
    "@xmath129 with , say , a depth - first search in @xmath142 starting in the end vertex of @xmath13 belonging to @xmath36 resp .",
    "@xmath37 and avoiding @xmath13 .",
    "we use the edge adjacency lists to do this . by alternating between the two searches",
    ", we can identify the smaller set of faces in time proportional to the size of this set .",
    "let us assume that internal region @xmath128 contains this smaller set ( the case where external region @xmath129 contains the set is similar ) .",
    "the search in @xmath142 visited the entries of @xmath182 corresponding to faces in @xmath128 . since each such entry points to the corresponding entry in @xmath178",
    ", we can thus identify the faces in this face list that should belong to @xmath220 .",
    "we can extract these faces in time proportional to their number and thus form the face lists @xmath220 and @xmath221 in this amount of time . by reusing the arrays associated with entries of @xmath178",
    ", we do not need to form new arrays for @xmath220 and @xmath221 .",
    "however , we need to set the pointers of some entries of these arrays to null . for @xmath128 ,",
    "the new null - pointers are those corresponding to boundary vertices of @xmath214 since these are the boundary vertices of @xmath50 not belonging to @xmath128 . and for @xmath129 , the new null - pointers are those corresponding to boundary vertices of @xmath212 .",
    "since we index the arrays by boundary vertices , we can identify pointers to be set to null in constant time per pointer .",
    "pointers that are set to null remain in this state so we can charge this part of the algorithm s time to the total number of pointers which is @xmath4 .",
    "we also need to associate a new face with the data structure for @xmath128 and for @xmath129 ( i.e. , faces @xmath159 and @xmath160 in section  [ sec : insertcycle ] ) .",
    "and we need to initialize an array for each of these two faces .",
    "this takes @xmath98 time which is @xmath4 over all regions .",
    "[ [ contracted - and - pruned - dual - trees - for - r_1-and - r_2 ] ] contracted and pruned dual trees for @xmath128 and @xmath129 : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    what remains is to construct contracted and pruned dual trees for @xmath128 and @xmath129 . due to symmetry",
    ", we shall only consider contracted dual trees . we have already given an overall description of how to do this in section  [ sec : insertcycle ] . as we showed ,    1 .   for each @xmath222",
    ", we obtain @xmath166 from @xmath161 by contracting all edges belonging to @xmath37 , 2 .   for each @xmath223",
    ", we obtain @xmath168 from @xmath161 by contracting all edges belonging to @xmath36 , and 3 .   for each @xmath224",
    ", we obtain @xmath166 and @xmath168 from @xmath161 by removing the unique edge in @xmath161 having one end vertex in @xmath36 and one end vertex in @xmath37 .    in section  [ subsubsec : pruneddualtrees ]",
    ", we described how to support edge contraction , edge deletion , and edge insertion such that the total time is @xmath3 .",
    "the only detail missing is how to efficiently find the edges to be contracted or removed in the three cases above .",
    "we consider these cases separately in the following .",
    "[ [ case-1 - 1 ] ] case 1 : + + + + + + +    assume that @xmath225 and let @xmath222 .    with a depth - first search in @xmath142 as described above , we can identify all faces of @xmath50 belonging to @xmath37 in time proportional to the number of such faces .",
    "we can charge this time to the number of edges in @xmath161 that are to be contracted .",
    "for each such face @xmath179 , we can mark the corresponding vertex in @xmath161 by traversing the pointer associated with entry @xmath57 of array @xmath180 .",
    "again , we can charge the time for this to the number of edges to be contracted .",
    "now , we need to contract all edges of @xmath226 whose end vertices are both marked . in order to do this efficiently , we need to make a small modification to the contracted dual tree data structure in section  [ subsubsec : pruneddualtrees ] .",
    "more precisely , we make the contracted dual trees rooted at some vertex .",
    "the choice of root is not important and may change during the course of the algorithm .",
    "what is important is that each non - root vertex now has a parent . by checking , for each marked non - root vertex whether its parent is also marked",
    ", we can identify the edges to be contracted in time proportional to the number of such edges .",
    "of course this only works if the parent of a vertex can be obtained in constant time .",
    "let us show how the contracted dual tree data structure can be adapted to support this .    recall that each vertex of a contracted dual tree @xmath142 is associated with an edge - adjacency list @xmath183 containing the edges adjacent to @xmath57 in @xmath142 .",
    "we now require the edge from @xmath58 to its parent ( if defined ) to be the located at the first entry of this list .",
    "this allows us to find parents in constant time .",
    "how do we ensure that the parent edge is always located at the head of the list ?",
    "this is not difficult after an edge insertion or deletion so let us focus on edge contractions . when an edge @xmath203 is contracted , either @xmath170 is the parent of @xmath171 or @xmath171 is the parent of @xmath170 .",
    "assume , say , the former .",
    "then the parent of @xmath170 becomes the parent of the new vertex obtained by contracting @xmath13 .",
    "when the two edge adjacency lists are merged , one of the two heads of the two old lists should thus be the head of the new list .",
    "this can easily be done in constant time .",
    "[ [ case-2 - 1 ] ] case 2 : + + + + + + +    this case is similar to case @xmath86 .    [",
    "[ case-3 - 1 ] ] case 3 : + + + + + + +    we need an efficient way of finding the unique edge @xmath13 in @xmath161 having one end vertex in @xmath36 and one end vertex in @xmath37 .",
    "we do as follows : first we mark the entries in @xmath178 corresponding to the set of faces of @xmath50 belonging to @xmath36 or the set of faces of @xmath50 belonging to @xmath37 .",
    "the set we choose to mark is the smaller of the two .",
    "we do this with `` parallel '' searches in @xmath142 as described above , using time proportional to the number of marked faces .",
    "we mark the corresponding vertices of @xmath161 ( using pointers from the arrays associated with entries of @xmath178 ) . by lemma  [ lem : subtreedual ] , these form a subtree of @xmath161 so we can find @xmath13 by starting a search in any marked vertex of @xmath161 and stopping once we encounter a vertex which is not marked",
    ". then @xmath13 is the last edge encountered in the search .",
    "this search also takes time proportional to the number of marked faces .",
    "hence , constructing the contracted and pruned dual trees for @xmath128 and @xmath129 takes time proportional to the number of marked faces . lemma  [",
    "lem : split ] then implies that the total time for this during the course of the algorithm is @xmath3 .",
    "having constructed the contracted and pruned dual trees for @xmath128 and @xmath129 , what remains before adding @xmath7 to @xmath43 is to add bidirected pointers between entries of the array associated with the new face in @xmath220 resp .",
    "@xmath227 and the new vertex in the contracted / pruned dual tree for @xmath128 resp .",
    "since the size of the array is @xmath98 , this can clearly be done in a total of @xmath4 time .",
    "this concludes the description of the implementation of our algorithm . we have shown that it runs in @xmath3 time and requires @xmath4 space .",
    "so far , we have assumed that only cycles from @xmath111 are encountered in line @xmath97 of the recursive greedy algorithm .",
    "now , we show how to deal with cycles from @xmath145 . in the following ,",
    "we only consider @xmath208 since dealing with @xmath209 is symmetric .",
    "the overall idea is the following . when a cycle @xmath228 is added to @xmath43 , all cycles of @xmath208 that cross @xmath7 are marked . if in the for - loop , a cycle @xmath229 is picked , it is skipped if it is marked since the gmcb is nested by lemma  [ lem : gmcbisonested ] .",
    "otherwise , @xmath7 must be fully contained in some region of the form @xmath53 , @xmath230 .",
    "then @xmath7 is added to @xmath43 if and only if @xmath7 separates a pair of elementary faces of @xmath53 .",
    "we will assume that the recursive invocation of the algorithm in @xmath99 returns region tree @xmath231 in addition to @xmath125 .    by applying lemma  [ lem : facesep ]",
    ", we see that every pair of elementary faces of @xmath99 is separated by some cycle of @xmath125 .",
    "hence , each region associated with a vertex @xmath57 of @xmath231 contains exactly one elementary face of @xmath99 and we assume that the recursive call has associated this face with @xmath57 .",
    "we let @xmath232 denote the region containing elementary face @xmath179 .",
    "we use the conditions in the following lemma to identify those cycles of @xmath208 that should be marked whenever a cycle of @xmath111 is added to @xmath43 .",
    "[ lem : crossingcycles ] let @xmath146 .",
    "if @xmath13 does not belong to @xmath99 then @xmath7 does not cross any cycle of @xmath208 .",
    "otherwise , let @xmath118 and @xmath119 be the elementary faces of @xmath99 adjacent to @xmath13 and let @xmath233 be the elementary face of @xmath99 containing @xmath31 .",
    "then the set of cycles @xmath234 that @xmath7 crosses are precisely those which satisfy one of the following two conditions :    1 .",
    "@xmath235 is not an ancestor of @xmath236 and is an ancestor of both @xmath237 and @xmath238 in @xmath231 ( figure  [ fig : crossingcycles](a ) ) , 2 .",
    "@xmath235 is an ancestor of @xmath236 and is an ancestor of neither @xmath237 nor @xmath238 in @xmath231 ( figure  [ fig : crossingcycles](b ) ) .",
    "the proof can be found in the appendix .",
    "the next lemma will simplify the test in line @xmath130 of the recursive greedy algorithm for @xmath229 .",
    "again , the proof is in the appendix .",
    "[ lem : reccyclessimpleadd ] suppose that in the recursive greedy algorithm , @xmath229 is the cycle currently considered and assume that it does not cross any cycle of the partially constructed gmcb @xmath43 of @xmath0 . if @xmath239 then all descendants of @xmath7 in region tree @xmath231 belong to the gmcb of @xmath0 .",
    "if @xmath240 then all cycles of non - descendants of @xmath7 in @xmath231 belong to the gmcb of @xmath0 .",
    "now , we are ready to describe how the algorithm deals with cycles from @xmath208 .",
    "each cycle in this set is in one of three states : _ active _ , _ passive _ , or _ cross _ state .",
    "initially , all cycles in @xmath208 are active .",
    "when a cycle from @xmath111 is added to @xmath43 , lemma  [ lem : crossingcycles ] is applied to identify all cycles from @xmath208 that cross this cycle .",
    "these cycles have their state set to the cross state .",
    "when the algorithm encounters a cycle @xmath229 in the for - loop , @xmath7 is skipped if it is in the cross state .",
    "if @xmath7 is active , it is completely contained in some region @xmath50 .",
    "there are two cases to consider : @xmath239 and @xmath240 .",
    "we assume that @xmath239 since the case @xmath240 is similar .",
    "we need to determine whether @xmath7 should be added to @xmath43 . by lemma  [ lem : splittest ] , this amounts to checking whether there are two elementary faces of @xmath50 which are separated by @xmath7 . by lemma  [ lem : reccyclessimpleadd ] , we know that the elementary faces of @xmath50 belonging to @xmath36 are exactly the elementary faces of the region @xmath241 in @xmath36 that was generated when @xmath7 was added to @xmath125 during the recursive call for @xmath99 .    hence",
    ", we add @xmath7 to @xmath43 if and only if the number of elementary faces in @xmath50 is strictly larger than the number of elementary faces in @xmath241 .",
    "if @xmath7 is added to @xmath43 , region @xmath50 is split into two smaller regions .",
    "let @xmath128 be the internal region and let @xmath129 be the external region .",
    "since @xmath239 , lemma  [ lem : reccyclessimpleadd ] implies that the cycles belonging to @xmath36 that are added to @xmath43 during the course of the algorithm are exactly @xmath7 and its descendants in @xmath231 .",
    "we therefore do not need to maintain @xmath128 or any regions contained in @xmath36 .    instead",
    ", we make all descendants of @xmath7 in @xmath231 passive .",
    "when a passive cycle is encountered by the algorithm , there is no need to update regions or contracted or pruned dual trees and the cycle is simply added to @xmath43 .",
    "now , let us consider @xmath129 .",
    "in order to obtain this region , we replace all faces of @xmath50 belonging to @xmath36 with a single new face defined by @xmath36 .",
    "and we contract all edges in @xmath36 to a single black vertex in all contracted and pruned dual trees for @xmath50 .",
    "this completes the description of the extension of our algorithm that deals with cycles from @xmath145 .",
    "let us show how to give an efficient implementation of the above algorithm for cycles from @xmath145 .",
    "due to symmetry , we may restrict our attention to @xmath208 in the following .",
    "[ [ identifying - cross - state - cycles ] ] identifying cross state cycles : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    the first problem is to identify the cycles of @xmath208 that should be in the cross state when a cycle @xmath146 is added to @xmath43 .    to solve this problem",
    ", we apply lemma  [ lem : crossingcycles ] .",
    "checking whether @xmath13 belongs to @xmath99 takes constant time .",
    "if @xmath13 is not an edge of @xmath99 then no new cycles will be in the cross state .",
    "otherwise , we obtain elementary faces @xmath118 and @xmath119 in constant time since these are the end vertices of @xmath13 in the dual of @xmath99 .",
    "we assume that we can compute lowest common ancestors in @xmath231 efficiently .",
    "we can use the data structure of harel and tarjan  @xcite for this .",
    "let @xmath242 be the lowest common ancestor of @xmath237 and @xmath238 in @xmath231 , see figure  [ fig : ancestorcrossstate ] .",
    "let @xmath243 be the lowest common ancestor of @xmath237 and @xmath236 .",
    "let @xmath244 be the lowest common ancestor of @xmath238 and @xmath236 .",
    "finally , let @xmath131 be the path in @xmath231 containing @xmath236 and its ancestors .    a cycle @xmath234 satisfies the first condition in lemma  [ lem : crossingcycles ] if and only if it is not associated with a vertex on @xmath131 and if it is associated with @xmath242 or an ancestor of @xmath242 ( figure  [ fig : ancestorcrossstate](a ) ) .",
    "and it satisfies the second condition if and only if it is associated with a vertex on @xmath131 and not with @xmath243 , @xmath244 , or an ancestor of either of these two vertices ( figure  [ fig : ancestorcrossstate](b ) ) .    to identify cycles that satisfy the first condition , we start at @xmath242 and walk upwards in @xmath231 , marking cycles as we go along .",
    "the process stops when a vertex on @xmath131 is reached .    to identify cycles satisfying the second condition , we instead move upwards in @xmath231 along @xmath131 , starting in @xmath236 .",
    "we stop when the root of @xmath231 or when @xmath243 or @xmath244 is reached .",
    "although this strategy works , it is slow since the same cycles may be considered several times during the algorithm . to remedy this , we first observe that when identifying cycles associated with vertices from @xmath242 to @xmath131 , we may stop if we encounter a cycle that is already in the cross state since then all its ancestors which are not on @xmath131 must also be in this state .",
    "next , we observe that when identifying cycles associated with vertices on @xmath131 , we always consider them from bottom to top . hence , by keeping track of the bottommost @xmath245 vertex on @xmath131 whose associated cycle is not in the cross state , we can start the next traversal of @xmath131 from @xmath245 . if the cycle associated with @xmath243 or with @xmath244 is already in the cross state , we need not consider any vertices . otherwise , we walk upwards in @xmath131 from @xmath245 , changing the state of cycles to the cross state and stop if @xmath243 or @xmath244 is reached .",
    "it follows that we can identify cycles satisfying one of the two conditions and change their state in time proportional to the number of cycles whose state changes as a result of this .",
    "hence , the total time for this is bounded by the size of @xmath231 which is linear .    [",
    "[ testing - condition - in - line-4 - 1 ] ] testing condition in line @xmath130 : + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +    in the following , let @xmath7 be an active or passive cycle in @xmath208 just encountered by our algorithm .",
    "we will assume that @xmath239 .",
    "the case @xmath240 is similar .",
    "we first need to determine whether @xmath7 should be added to @xmath43 .",
    "this is trivial if @xmath7 is passive since passive cycles should always be added . and as noted in section  [ subsec : reccycles ] , no pruned dual trees need to be updated after the insertion of a passive cycle .",
    "so assume that @xmath7 is active .",
    "let @xmath50 be the region containing @xmath7 and let @xmath241 be the region in @xmath36 that was generated when @xmath7 was added to @xmath125 during the construction of the gmcb of @xmath99 . as we showed above , determining whether @xmath7 should be added to @xmath43 amounts to checking whether the number of elementary faces in @xmath50 is strictly larger than the number of elementary faces in @xmath241 .",
    "we can easily extend our region data structure to keep track of the number of elementary faces in each region without increasing the time and space bounds of our algorithm . by recording this information for @xmath241 during the recursive call for @xmath99",
    ", it follows that we can determine in constant time whether @xmath50 contains more elementary faces than @xmath241 .",
    "of course , this only works if we can quickly identify @xmath50 and @xmath241 .",
    "identifying @xmath241 is simple since this region is associated with the vertex @xmath246 of region tree @xmath231 associated with @xmath7 .    to identify @xmath50 ,",
    "let @xmath247 be the region associated with @xmath246 in @xmath231 .",
    "since @xmath125 is the gmcb of @xmath99 , each pair of elementary faces of @xmath99 is separated by some cycle of @xmath125 .",
    "it follows that @xmath247 contains exactly one elementary face @xmath248 of @xmath99 .",
    "we may assume that this face was associated with @xmath246 during the construction of @xmath125 so that we can obtain this face in constant time from @xmath246 .",
    "face @xmath248 is also an elementary face in @xmath0 and it belongs to @xmath50 . recall from section  [ subsubsec : regions ] that there is a bidirected pointer between @xmath50 and each elementary face of @xmath0 belonging to @xmath50 .",
    "hence , we can obtain @xmath50 from @xmath248 in constant time    it follows from the above that we can check if @xmath7 should be added to @xmath43 in constant time .    [ [ inserting - a - cycle-1 ] ] inserting a cycle : + + + + + + + + + + + + + + + + + +    now , suppose @xmath7 should be inserted into @xmath43 .",
    "we first make cycles of @xmath208 passive according to lemma  [ lem : reccyclessimpleadd ] .",
    "this can be done with , say , a depth - first search in @xmath231 starting in vertex @xmath246 of @xmath231 and visiting descendants of this vertex .",
    "the search stops when a vertex associated with a passive cycle is encountered .",
    "each search identifies the vertices of @xmath231 that are associated with cycles whose state changes from non - passive to passive . and since we stop a search when a passive cycle is encountered , all searches take total time proportional to the size of @xmath231 which is @xmath201 .",
    "next , we need to update regions and contracted and pruned dual trees .",
    "let @xmath128 be the internal region and let @xmath129 be the external region w.r.t .",
    "@xmath50 and @xmath7 .",
    "as we showed in the overall description of the algorithm , the only problem that we need to consider is how to construct @xmath129 and its contracted and pruned dual trees .",
    "we showed that this amounts to replacing all faces of @xmath50 belonging to @xmath36 with a single new face defined by @xmath36 and to contract all edges in @xmath36 to a single black vertex in all contracted and pruned dual trees for @xmath50 .",
    "we will show how to find the faces of @xmath50 belonging to @xmath36 in time proportional to their number . applying the charging schemes introduced in section  [ subsubsec : algorithm ]",
    ", this will suffice to prove the desired time and space bounds for the entire algorithm .",
    "consider an active cycle @xmath38 associated with a descendant @xmath57 of @xmath246 in @xmath231 .",
    "if @xmath38 was previously considered in the for - loop of our algorithm , it must have been added to @xmath43 ( by lemma  [ lem : reccyclessimpleadd ] ) .",
    "this implies that @xmath249 must be a non - elementary face of @xmath50 since otherwise , @xmath38 would be passive , see figure  [ fig : reccycleadd ] .",
    "the converse holds as well : any non - elementary face of @xmath50 belonging to @xmath36 is realized by @xmath249 for such a cycle @xmath38 previously considered in the for - loop .",
    "it follows that we can find all non - elementary faces of @xmath50 belonging to @xmath36 by identifying the active descendants of @xmath7 in @xmath231 that have already been considered in the for - loop .",
    "since all active cycles associated with descendants of @xmath7 are to become passive , we can charge the time for finding these faces to the number of cycles whose state changes from active to passive .",
    "what remains is to find the elementary faces of @xmath50 belonging to @xmath36 .",
    "recall that we have associated with each vertex @xmath57 of @xmath231 the unique elementary face of @xmath99 contained in the region associated with @xmath57 .",
    "vertex @xmath246 and its descendants in @xmath231 are thus associated with exactly the elementary faces of @xmath99 belonging to @xmath36 .",
    "these faces are also elementary faces in @xmath0 .",
    "it follows that the elementary faces of @xmath50 belonging to @xmath36 are associated with exactly the descendants of @xmath7 corresponding to active cycles not already considered by the algorithm . using the same charging scheme as above",
    ", we can also identify these faces within the required time and space bounds .",
    "we have shown how to implement the entire recursive greedy algorithm to run in @xmath3 time and @xmath4 space and we can conclude this section with the main result of our paper .",
    "[ thm : mainres ] given an @xmath2-vertex planar , undirected graph @xmath30 with non - negative edge weights , the following implicit representation of the gmcb @xmath43 of @xmath0 can be computed in @xmath3 time and @xmath4 space :    1 .",
    "a set of trees @xmath250 in @xmath0 rooted at vertices @xmath251 , respectively , 2 .",
    "a set of triples @xmath252 representing the cycles in @xmath43 , where @xmath253 , @xmath254 , and @xmath255 , where @xmath57 and @xmath58 are vertices in @xmath205 .",
    "the pair @xmath256 represents the cycle in @xmath43 formed by concatenating @xmath13 and the two paths in @xmath205 from @xmath257 to @xmath57 and from @xmath257 to @xmath58 , respectively .",
    "the value of @xmath258 is the weight of this cycle , 3 .",
    "the region tree @xmath52 where each vertex points to the associated region , 4 .   a set of regions .",
    "each region is associated with the unique elementary face of @xmath0 contained in that region .",
    "each internal region @xmath45 is associated with the triple representing @xmath7 .",
    "in this section , we present results all of which follow from theorem  [ thm : mainres ] . the first is an output - sensitive sensitive algorithm for computing an mcb .",
    "[ cor : outputsensitivealgo ] a minimum cycle basis of an @xmath2-vertex planar , undirected graph with non - negative edge weights can be computed in @xmath5 time and @xmath6 space , where @xmath7 is the total length of all cycles in the basis",
    ".    follows immediately from theorem  [ thm : mainres ] .",
    "a stronger result holds when the graph is unweighted :    [ cor : mcbunweighted ] a minimum cycle basis of an @xmath2-vertex planar undirected , unweighted graph can be computed in @xmath3 time and @xmath4 space .",
    "let @xmath0 be an @xmath2-vertex planar , undirected , unweighted graph .",
    "the internal elementary faces of @xmath0 define a cycle basis of of @xmath0 of total length @xmath201 .",
    "hence , since @xmath0 is unweighted , an mcb of @xmath0 has total length @xmath201 .",
    "the result now follows from corollary  [ cor : outputsensitivealgo ] .",
    "since the all - pairs min cut problem is dual equivalent to the mcb problem for planar graphs , we also get the following two results .",
    "[ cor : apmcweighted ] all - pairs min cuts of an @xmath2-vertex planar , undirected graph with non - negative edge weights can be computed in @xmath5 time and @xmath6 space , where @xmath7 is the total length of the cuts .",
    "let @xmath0 be an @xmath2-vertex planar , undirected graph with non - negative edge weights .",
    "as shown in  @xcite , if @xmath0 is connected , we can solve the apmcp for @xmath0 by solving the mcbp for the dual @xmath59 of @xmath0 .",
    "we may assume that @xmath0 is connected since otherwise , we can consider each connected component separately .",
    "we can not immediately solve the mcbp for @xmath59 since this is a multigraph .",
    "but we can avoid an edge of the form @xmath259 by splitting it into two edges @xmath260 and @xmath261 whose sum of weights equal the weight of @xmath259 . and we can avoid multi - edges in a similar way . let @xmath262 be the resulting planar graph .",
    "it is easy to see that @xmath262 has size @xmath201 .",
    "furthermore , an mcb @xmath43 of @xmath262 can be transformed into an mcb of @xmath59 in time proportional to the total size of cycles in @xmath43 .",
    "the result now follows from corollary  [ cor : outputsensitivealgo ] .",
    "all - pairs min cuts of an @xmath2-vertex planar , undirected , unweighted graph can be computed in @xmath3 time and @xmath4 space .",
    "this result is easily obtained by combining the proofs of corollary  [ cor : mcbunweighted ] and corollary  [ cor : apmcweighted ] .",
    "next , we present our subquadratic time and space algorithm for finding the weight vector of a planar graph .",
    "the weight vector of an @xmath2-vertex planar , undirected graph with non - negative edge weights can be computed in @xmath3 time and @xmath4 space .    from theorem  [ thm : mainres ]",
    ", we obtain an implicit representation of the gmcb @xmath43 for the input graph .",
    "we then compute the weights of all cycles in @xmath43 using linear time and space . sorting them",
    "takes @xmath202 time .",
    "this gives the weight vector of the input graph in a total of @xmath3 time and @xmath4 space .    from theorem  [ thm : mainres ]",
    ", we also obtain a faster algorithm for computing a gomory - hu tree of a planar graph .",
    "[ cor : gomoryhu ] a gomory - hu tree of an @xmath2-vertex connected , planar , undirected graph with non - negative edge weights can be computed in @xmath3 time and @xmath4 space .",
    "the following algorithm constructs a gomory - hu tree for @xmath0  @xcite : a tree @xmath27 spanning a collection of vertex sets @xmath263 is maintained , starting with @xmath264 . at each step , a set @xmath265 is picked such that @xmath266 and any two distinct vertices @xmath267 are chosen .",
    "set @xmath265 is then regarded as the root of @xmath27 and each subtree of @xmath27 , i.e. , each tree in @xmath268 , is collapsed into a single supernode . a min @xmath57-@xmath58 cut in the resulting graph",
    "is found , partitioning @xmath71 into two subsets , @xmath269 and @xmath270 , where @xmath271 and @xmath272 .",
    "tree @xmath27 is then modified by splitting @xmath265 into two vertices , @xmath273 and @xmath274 , where @xmath275 and @xmath276 .",
    "the two vertices are connected by a new edge whose weight equals the size of the min cut found . finally , each subtree of the old @xmath27 is connected to @xmath273 if the corresponding supernode was in the same partition as @xmath57 in the cut .",
    "otherwise , the subtree is connected to @xmath274 .",
    "let us show how to implement this algorithm to obtain the desired time and space bounds .",
    "we first apply theorem  [ thm : mainres ] to the dual @xmath277 of @xmath0 , giving an implicit representation of the gmcb of @xmath59 . by lemma  [ lem : facesep ] , each cycle @xmath7 in this basis is a minimum - weight cycle that separates some pair of faces @xmath118 and @xmath119 in @xmath59 .",
    "let @xmath170 and @xmath171 be the vertices of @xmath0 corresponding to @xmath118 and @xmath119 , respectively . by duality of the gmcbp and the apmcp  @xcite , the edges of @xmath7 are the edges of a min @xmath170-@xmath148 cut in @xmath0 of weight equal to the weight of @xmath7 .",
    "now , pick any @xmath7 cycle in the gmcb of @xmath59 . as the initial min cut in the gomory - hu tree algorithm",
    ", we pick the one corresponding to @xmath7 .",
    "this separates the initial set @xmath278 into two sets @xmath273 and @xmath274 , where @xmath273 is the set of vertices of @xmath0 corresponding to faces of @xmath277 in @xmath36 and @xmath274 is the set of vertices of @xmath0 corresponding to faces of @xmath277 in @xmath37 .",
    "now , @xmath27 consists of vertices @xmath273 and @xmath274 and an edge @xmath279 .",
    "the weight of this edge is equal to the weight of @xmath7 . since we are given the weight of @xmath7 from theorem  [ thm : mainres ]",
    ", we can this obtain the weight of edge @xmath279 in constant time .",
    "note that for each pair of vertices @xmath57 and @xmath58 in @xmath273 , there is a min @xmath57-@xmath58 cut defined by a cycle of @xmath43 which is a descendant of @xmath7 in @xmath52 .",
    "and for each pair of vertices @xmath57 and @xmath58 in @xmath274 , there is a min @xmath57-@xmath58 cut defined by a cycle of @xmath43 which is a non - descendant of @xmath7 in @xmath52 .",
    "hence , we have separated our problem in two and we can recursively compute the gomory - hu tree for @xmath0 by splitting region tree @xmath52 in two at each recursive step .",
    "the recursion stops when we obtain a set @xmath265 of size one . at this point , we obtain the elementary face @xmath179 of @xmath277 correponding to the vertex in @xmath265 using part four of theorem  [ thm : mainres ] .",
    "the vertex of @xmath0 corresponding to @xmath179 in @xmath277 is then the unique vertex in @xmath265 .",
    "let us analyze the running time of this algorithm . applying theorem  [ thm : mainres ] takes @xmath3 time and @xmath4 space .",
    "note that in the algorithm above , we do not need to compute the vertices in the @xmath265-sets until they have size one .",
    "so each step of the algorithm , where the current @xmath265-set has size greater than one , can be implemented to run in constant time . and we can also execute a step where @xmath280 in constant time using the fourth part of theorem  [ thm : mainres ] to find the vertex in @xmath265 .    since the gmcb of @xmath277 contains @xmath201 cycles , it follows that the algorithm runs in linear time and space , in addition to the time and space in theorem  [ thm : mainres ] .",
    "finally , we present our oracle for answering min cut queries .",
    "[ cor : mincutoracle ] let @xmath0 be an @xmath2-vertex planar , undirected graph with non - negative edge weights . with @xmath3 time and @xmath4 space for preprocessing ,",
    "the weight of a min cut between any two given vertices of @xmath0 can be reported in constant time .",
    "the cut itself can be reported in time proportional to its size .",
    "we may assume that @xmath0 is connected since otherwise , we can consider each connected component separately .",
    "we first construct a gomory - hu tree @xmath27 of @xmath0 . by corollary  [ cor : gomoryhu ] , this can be done in @xmath3 time and @xmath4 space . by definition of gomory - hu trees ,",
    "answering the query for the weight of a min cut between two vertices @xmath57 and @xmath58 of @xmath0 reduces to answering the query for the minimum weight of an edge on the simple path between @xmath57 and @xmath58 in @xmath27 .",
    "it is well - known that any tree with @xmath17 vertices has a vertex @xmath58 such that the tree can be split into two subtrees , each rooted at @xmath58 and each containing between @xmath281 and @xmath282 vertices .",
    "furthermore , this separator can be found in linear time .",
    "we find such a separator in @xmath27 and recurse on the two subtrees .",
    "we stop the recursion at level @xmath283 .",
    "the total time for this is @xmath202 .",
    "let @xmath284 be the subtrees at level @xmath283 .",
    "we observe that these trees are edge - disjoint and their union is @xmath27 .",
    "furthermore , @xmath285 and each subtree has size @xmath98 .",
    "the _ boundary vertices _ of a subtree @xmath286 are the vertices that @xmath287 shares with other subtrees in @xmath284 .",
    "vertices of @xmath287 that are not boundary vertices are called _ interior vertices _ of @xmath287 .",
    "we let @xmath288 be the set of boundary vertices over all subtrees in @xmath284 .",
    "it is easy to see that @xmath289 .",
    "for each boundary vertex @xmath290 , we associate an array with an entry for each vertex of @xmath27 .",
    "the entry corresponding to a vertex @xmath291 contains the edge of minimum weight on the simple path in @xmath27 between @xmath245 and @xmath58 .    since @xmath289",
    ", it follows easily that we can construct all these arrays and fill in their entries in a total of @xmath4 time and space .",
    "this allows us to answer queries in @xmath27 in constant time when one of the two vertices belongs to @xmath288 .",
    "we associate each vertex @xmath58 of @xmath27 not belonging to @xmath288 with the unique subtree @xmath292 in @xmath284 containing @xmath58 as an interior vertex .",
    "associated with @xmath58 is also an array with an entry for each @xmath293 .",
    "this entry contains the vertex @xmath245 of @xmath288 belonging to @xmath292 such that any path from @xmath58 to @xmath287 contains @xmath245 .",
    "note that for any other vertex @xmath139 of @xmath292 , any path from @xmath139 to @xmath287 also contains @xmath245 . from this observation and from the fact that @xmath285 , it follows that we can compute the arrays associated with interior vertices in all subtrees using a total of @xmath4 time and space .",
    "finally , we associate with @xmath58 an array with an entry for each vertex @xmath139 of @xmath292 .",
    "this entry contains the edge of minimum weight on the simple path in @xmath292 from @xmath58 to @xmath139 .",
    "since @xmath292 has size @xmath98 , the entries in this array can be computed in @xmath98 time . over all interior vertices of all subtrees of @xmath284 ,",
    "this is @xmath4 time .",
    "now , let us describe how to answer a query for vertices @xmath57 and @xmath58 in @xmath27 .",
    "in constant time , we find the subtrees @xmath294 such that @xmath295 and @xmath296 . if @xmath297 or if @xmath57 or @xmath58 belongs to @xmath288 , we can answer the query in constant time with the above precomputations .",
    "now , assume that @xmath298 and that @xmath57 and @xmath58 are interior vertices .",
    "we find the boundary vertex @xmath245 of @xmath299 such that any path from @xmath57 to @xmath300 contains @xmath245 .",
    "let @xmath301 be the simple path in @xmath299 from @xmath57 to @xmath245 and let @xmath302 be the simple path in @xmath27 from @xmath245 to @xmath58",
    ". for @xmath103 , the above precomputations allow us to find the least - weight edge @xmath303 on @xmath304 in constant time .",
    "let @xmath13 be the edge of smaller weight among @xmath305 and @xmath306 .",
    "returning the weight of @xmath13 then answers the query in constant time .    to show the last part of the corollary ,",
    "observe that when the weight of edge @xmath13 is output by the above algorithm , the set of edges in the corresponding cut is defined by a cycle @xmath307 in the gmcb @xmath43 of @xmath59 . during the construction of gomory - hu tree @xmath27",
    "( see corollary  [ cor : gomoryhu ] ) , we can associate @xmath13 with the implicit representation of @xmath307 from theorem  [ thm : mainres ] .",
    "hence , given @xmath13 , we can output @xmath307 in time proportional to its size .",
    "this completes the proof .",
    "let @xmath76 be the weight function on the edges of @xmath0 . in section  [ sec : greedyalgo ] , we assumed uniqueness of shortest path in @xmath0 between any two vertices w.r.t .",
    "we now show how to avoid this assumption .",
    "we assume in the following that the vertices of @xmath0 are given indices from @xmath86 to @xmath2 .    by results in  @xcite , there is another weight function @xmath308 on the edges of @xmath0 such that for any pair of vertices in @xmath0 , there is a unique shortest path between them w.r.t .",
    "@xmath308 and this path is also a shortest path w.r.t .  @xmath258 . furthermore , for two paths @xmath131 and @xmath133 between the same pair of vertices in @xmath0 , @xmath309 exactly when one of the following three conditions is satisfied :    1 .",
    "@xmath131 is strictly shorter than @xmath133 w.r.t .",
    "@xmath258 , 2 .",
    "@xmath131 and @xmath133 have the same weight w.r.t .",
    "@xmath258 and @xmath131 contains fewer edges than @xmath133 , 3 .",
    "@xmath131 and @xmath133 have the same weight w.r.t .",
    "@xmath258 and the same number of edges and the smallest index of vertices in @xmath310 is smaller than the smallest index of vertices in @xmath311 .",
    "a shortest path w.r.t .",
    "@xmath308 is called a _",
    "lex - shortest path _ and a shortest path tree w.r.t .",
    "@xmath308 is called a _",
    "lex - shortest path tree_.    as shown in  @xcite , lex - shortest paths between all pairs of vertices in @xmath0 can be computed in @xmath22 time .",
    "we need something faster . in the following",
    ", we show a stronger result , namely how to compute a lex - shortest path tree in @xmath202 time .",
    "since we only need to compute shortest paths from @xmath98 boundary vertices , this will give a total time bound of @xmath3 .",
    "we also need to find lex - shortest path trees in subgraphs of @xmath0 when recursing and we need to compute them w.r.t .  the same weight function @xmath308 .",
    "by the above , this can be achieved simply by keeping the same indices for vertices in all recursive calls .",
    "now , let @xmath312 be given and let us show how to compute the lex - shortest path tree in @xmath0 with source @xmath23 in @xmath202 time .",
    "we first use a small trick from  @xcite : for function @xmath258 , a sufficiently small @xmath313 is added to the weight of every edge .",
    "this allows us to disregard the second condition above .",
    "when comparing weights of paths , we may treat @xmath314 symbolically so we do not need to worry about precision issues",
    ".    we will apply dijkstra s algorithm with a few additions which we describe in the following .",
    "we keep a queue of distance estimates w.r.t .",
    "@xmath258 as in the standard implementation .",
    "now , consider any point in the algorithm .",
    "let @xmath315 be the distance estimate function .",
    "consider an unvisited vertex @xmath58 with current distance estimate @xmath316 < \\infty$ ] and predecessor vertex @xmath317 .",
    "suppose that at this point , the algorithm extracts a vertex @xmath318 from @xmath319 which is adjacent to @xmath58 in @xmath0 and suppose that @xmath320 + w(p',v ) = d[v]$ ] .",
    "the central problem is to decide whether @xmath58 should keep @xmath317 or get @xmath318 as its new predecessor . in the following ,",
    "we show how to decide this in @xmath321 time .",
    "this will suffice to give an @xmath202 time algorithm that computes the lex - shortest path tree in @xmath0 with source @xmath23 .",
    "let @xmath131 be the path in the partially constructed lex - shortest path tree @xmath27 from @xmath23 to @xmath317 followed by edge @xmath322 .",
    "let @xmath133 be the path in @xmath27 from @xmath23 to @xmath318 followed by edge @xmath323 .",
    "note that @xmath131 and @xmath133 both have weight @xmath316 $ ] w.r.t .",
    "@xmath258 . hence , @xmath131 is shorter than @xmath133 w.r.t .",
    "@xmath308 if and only if the third condition above is satisfied .",
    "in other words , @xmath58 should keep @xmath317 as its predecessor if and only if this condition is satisfied .",
    "let @xmath324 be the lowest common ancestor of @xmath317 and @xmath318 in @xmath27 .",
    "paths @xmath131 and @xmath133 share vertices from @xmath23 to @xmath324 .",
    "then they split up and do not meet before @xmath58 .",
    "let @xmath319 be the subpath of @xmath131 from the successor of @xmath324 to @xmath317 .",
    "let @xmath325 be the subpath of @xmath133 from the successor of @xmath324 to @xmath318 . testing the third condition above is equivalent to deciding whether the smallest vertex index in @xmath326 is smaller than the smallest vertex index in @xmath327 .",
    "we assume that for each vertex @xmath57 in @xmath27 , we have pointers @xmath328,\\ldots , p_{k_u}[u]$ ] and values @xmath329,\\ldots , m_{k_u}[u]\\in\\{1,\\ldots , n\\}$ ] . for @xmath330 , @xmath331 $ ] points to the ancestor @xmath332 of @xmath57 in @xmath27 for which the number of edges from @xmath332 to @xmath57 is @xmath333 .",
    "and @xmath334 $ ] is the smallest vertex index on the path in @xmath27 from @xmath332 to @xmath57 .",
    "the value of @xmath335 is defined as the largest @xmath336 such that @xmath331 $ ] is defined .",
    "note that @xmath337 .",
    "since @xmath131 and @xmath133 have the same number of edges , the same holds for @xmath319 and @xmath325 . from this observation , it follows that we can apply binary search on the pointers defined above to find lowest common ancestor @xmath324 in @xmath321 time . and with these pointers and the @xmath338-values , we can partition @xmath319 and @xmath325 into @xmath321 intervals in @xmath321 time and find the smallest index in each interval in constant time per interval .",
    "hence , we can decide whether the smallest vertex index in @xmath326 is smaller than the smallest vertex index in @xmath327 in logarithmic time , which gives the desired .",
    "the only problem that remains is how to compute pointers and @xmath338-values during the course of the algorithm .",
    "whenever the partially constructed lex - shortest path tree is extended with a new vertex @xmath57 , we need to compute @xmath328,\\ldots , p_{k_u}[u]$ ] and @xmath329,\\ldots , m_{k_u}[u]\\in\\{1,\\ldots , n\\}$ ] . but",
    "this can easily be done in @xmath321 time using the @xmath339-pointers and @xmath338-values for the ancestors of @xmath57 in @xmath27 .",
    "we can now conclude this section with the following theorem . since we did not make use of planarity in this section , we get a more general result , which we believe to be of independent interest .",
    "a lex - shortest path tree in an undirected graph with @xmath17 edges and @xmath2 vertices can be computed in @xmath340 time",
    ".    follows by combining the above with a standard implementation of dijkstra s algorithm .",
    "we showed that finding a minimum cycle basis of an @xmath2-vertex planar , undirected , connected graph with non - negative edge weights requires @xmath93 time , implying that a recent algorithm by amaldi et al .",
    "is optimal .",
    "we then presented an algorithm with @xmath3 time and @xmath4 space requirement that computes such a basis implicitly .    from this result",
    ", we obtained an output - sensitive algorithm requiring @xmath5 time and @xmath6 space , where @xmath7 is the total length of cycles in the basis that the algorithm outputs . for unweighted graphs , we obtained @xmath3 time and @xmath4 space bounds .",
    "similar results were obtained for the all - pairs min cut problem for planar graphs since for planar graphs , this problem is known to be dual equivalent to the minimum cycle basis problem .    as corollaries , we obtained algorithms that compute the weight vector and a gomory - hu tree of a planar @xmath2-vertex graph in @xmath3 time and @xmath4 space .",
    "the previous best bound was quadratic .    from the gomory - hu tree algorithm , we derived an oracle for answering queries for the weight of a min cut between any two given vertices .",
    "preprocessing time is @xmath3 and space is @xmath4 .",
    "quadratic time and space was previously the best bound for constructing such an oracle .",
    "our algorithm can output the actual cut in time proportional to its size .",
    "i thank sergio cabello for some interesting comments and for introducing me to gomory - hu trees .",
    "99 e. amaldi , c. iuliano , t. jurkiewicz , k. mehlhorn , and r. rizzi . breaking the @xmath341 barrier for minimum cycle bases .",
    "a. fiat and p. sanders ( eds . ) : esa @xmath342 , lncs @xmath343 , pp .",
    "@xmath344@xmath345 , @xmath342 .",
    "f. berger , p. gritzmann , and s. de vries .",
    "minimum cycle bases for network graphs .",
    "algorithmica , @xmath346 ( @xmath86 ) : @xmath347@xmath348 , @xmath349 . f. berger , p. gritzmann , and s. de vries . minimum cycle bases and their applications .",
    "algorithmics , lncs @xmath350 , pp .",
    "@xmath351@xmath352 , @xmath342 .",
    "d. w. cribb , r. d. ringeisen , and d. r. shier . on cycle bases of a graph .",
    "numer . , @xmath353 ( @xmath354 ) , pp .",
    "d. cvetkovic , i. gutman , and n. trinajstic .",
    "graph theory and molecular orbitals vii : the role of resonance structures . j. chemical physics , @xmath357 ( @xmath358 ) , pp .",
    "n. deo , g. m. prabhu , and m. s. krishnamoorthy .",
    "algorithms for generating fundamental cycles in a graph .",
    "acm trans .",
    "software , @xmath361 ( @xmath362 ) , pp .",
    "j. c. de pina .",
    "applications of shortest path methods .",
    "phd thesis , university of amsterdam , the netherlands , @xmath365 .",
    "e. t. dixon and s. e. goodman .",
    "an algorithm for the longest cycle problem .",
    "networks , @xmath366 ( @xmath367 ) , pp .",
    "a. golynski and j. d. horton . a polynomial time algorithm to find the minimum cycle basis of a regular matroid . in swat @xmath370 : proceedings of the @xmath361th scandinavian workshop on algorithm theory , pages @xmath371@xmath372 , @xmath370 .",
    "r. gomory and t. c. hu .",
    "multi - terminal network flows .",
    "j. siam , @xmath373 ( @xmath26 ) , pp .",
    "d. harel and r. e. tarjan .",
    "fast algorithms for finding nearest common ancestors .",
    "siam j. comput .",
    "volume @xmath376 , issue @xmath95 , pp .",
    "@xmath377@xmath378 ( @xmath379 ) .",
    "d. hartvigsen and r. mardon .",
    "the all - pairs min cut problem and the minimum cycle basis problem on planar graphs .",
    "siam j. discrete math . volume @xmath380 , issue @xmath97 , pp .",
    "@xmath381@xmath382 ( may @xmath383 ) .",
    "m. r. henzinger , p. klein , s. rao , and s. subramanian .",
    "faster shortest - path algorithms for planar graphs .",
    "journal of computer and system sciences volume @xmath384 , issue @xmath86 , august @xmath385 , pages @xmath97@xmath386 . j. d. horton . a polynomial time algorithm to find the shortest cycle basis of a graph .",
    "siam j. comput . , @xmath387 ( @xmath388 ) , pp .",
    "t. kavitha , c. liebchen , k. mehlhorn , d. michail , r. rizzi , t. ueckerdt , and k. zweig .",
    "cycle bases in graphs : characterization , algorithms , complexity , and applications .",
    "@xmath391 pages , submitted for publication , march @xmath342 .",
    "t. kavitha , k. mehlhorn , d. michail , and k. e. paluch .",
    "an @xmath392 algorithm for minimum cycle basis of graphs .",
    "algorithmica , @xmath393 ( @xmath97 ) : @xmath394@xmath395 , @xmath396 . a preliminary version of this paper appeared in icalp @xmath349 , volume @xmath397 , pages @xmath398@xmath399 . g. kirchhofff .",
    "ueber die auflsung der gleichungen , auf welche man bei der untersuchung der linearen vertheilung galvanischer strme gefhrt wird .",
    "poggendorf ann .",
    "physik @xmath400 ( @xmath8 ) , pp .",
    "@xmath401@xmath402 ( english transl . in trans .",
    "radio engrs . , ct-@xmath96 ( @xmath403 ) , pp .",
    "@xmath130@xmath380 ) .",
    "d. e. knuth .",
    "the art of computer programming , vol .",
    "addison - wesley , reading , ma , @xmath404 .",
    "e. lawler .",
    "combinatorial optimization .",
    "holt , rinehart and winston , new york , @xmath367 .",
    "p. matei and n. deo . on algorithms for enumerating all circuits of a graph .",
    "siam j. comput . , @xmath96 ( @xmath367 ) , pp .",
    "k. mehlhorn and d. michail .",
    "minimum cycle bases : faster and simpler . accepted for publication in acm transactions on algorithms , @xmath407 . g. l. miller . finding small simple cycle separators for @xmath95-connected planar graphs .",
    "j. comput .",
    "@xmath353:@xmath408@xmath409 , @xmath410 . m. randic .",
    "resonance energy of very large benzenoid hydrocarbons .",
    "j. quantum chemistry , xvii ( @xmath411 ) , pp .",
    "h. saran and v. v. vazirani . finding @xmath29-cuts within twice the optimal .",
    "siam journal on computing , @xmath414:@xmath415@xmath416 , @xmath365 .",
    "n. trinajstic . chemical graph theory .",
    "crc press , boca raton , fl , vol .",
    "@xmath95 , @xmath417 . v. v. vazirani . approximation algorithms .",
    "springer - verlag , @xmath418 .",
    "consider running the algorithm backwards : starting with one object of weight @xmath199 , repeatedly apply an operation @xmath206 that splits an object of weight at least two into two new objects of positive integer weights such that the sum of weights of the two equals the weight of the original object .",
    "assume that @xmath206 runs in time proportional to the smaller weight of the two new objects .",
    "if we can give a bound of @xmath198 for this algorithm , we also get a bound on the algorithm stated in the theorem .",
    "the running time for the new algorithm satisfies : @xmath419 for integer @xmath420 and constant @xmath421 .",
    "it is easy to see that the right - hand side is maximized when @xmath422 .",
    "this gives @xmath423 , as desired .",
    "first , observe that since @xmath7 is completely contained in @xmath50 , @xmath215 is the subset of all boundary vertices belonging to @xmath7 .",
    "hence , this subset does not depend on @xmath50 .",
    "we will thus refer to it as @xmath424 in the following .",
    "let @xmath425 be the boundary vertices encountered in that order in a simple , say clockwise , walk of @xmath31 and let @xmath426 be a decomposition of @xmath31 into smaller curves where @xmath427 starts in @xmath257 and ends in @xmath428 , @xmath429 .",
    "each curve @xmath427 is completely contained in an elementary face of @xmath0 and we let @xmath430 denote this face .          [ cor : deltaintersection ] let @xmath432 be defined as above .",
    "let @xmath433 and assume that single - source shortest path distances in @xmath0 with sources @xmath58 and @xmath258 have been precomputed .",
    "then determining whether @xmath258 belongs to @xmath7 can be done in constant time .",
    "let @xmath170 and @xmath171 be the end vertices of @xmath13 and let @xmath301 resp .",
    "@xmath302 be the shortest paths in @xmath0 from @xmath58 to @xmath170 resp .",
    "since @xmath7 is isometric , both @xmath301 and @xmath302 belong to @xmath7 and the union of their vertices is exactly the vertices of @xmath7 .",
    "hence , determining whether @xmath258 belongs to @xmath7 is equivalent to determining whether @xmath258 belongs to @xmath301 or to @xmath302 .",
    "the result now follows from lemma  [ lem : deltaintersection ] .",
    "we will assume that single - source shortest path distances in @xmath0 with each boundary vertex as source have been precomputed . as observed earlier ,",
    "this can be done in @xmath3 time and @xmath4 space .",
    "corollary  [ cor : deltaintersection ] then allows us to find the set @xmath424 of boundary vertices belonging to @xmath7 in @xmath434 time .",
    "we may assume that we have the boundary vertices on @xmath7 cyclically ordered according to how they occur on @xmath31 in a clockwise walk of that curve .    in the following ,",
    "let @xmath435 ( so @xmath436 ) .",
    "consider two consecutive vertices @xmath437 and @xmath438 of @xmath424 in this cyclic ordering .",
    "we assume that @xmath439 since the case @xmath440 can be handled in a similar way .",
    "there are two possible cases :          lemma  [ lem : faceininterior ] below shows how we can check whether @xmath443 belongs to @xmath36 .",
    "first , let @xmath57 and @xmath58 be the end vertices of @xmath13 and let @xmath444 and @xmath445 be the shortest paths from @xmath257 to @xmath57 and @xmath58 , respectively .",
    "suppose w.l.o.g .  that @xmath438 belongs to @xmath444 ,",
    "see figure  [ fig : deltasets ] .",
    "let @xmath138 be the predecessor of @xmath438 on @xmath444 .",
    "this is well - defined since @xmath439 . if @xmath446 , let @xmath447 be the successor of @xmath438 on @xmath444",
    "otherwise , let @xmath448 ( so @xmath447 is the vertex @xmath449 adjacent to @xmath438 on @xmath7 ) .",
    "let @xmath139 resp .",
    "@xmath450 be the predecessor resp .",
    "successor of @xmath438 in a clockwise walk of @xmath443 .        1 .",
    "@xmath444 is part of a clockwise walk of @xmath7 ( when directed from @xmath257 to @xmath57 ) and @xmath454 contains @xmath455 ( figure  [ fig : deltasets](a ) ) , 2 .",
    "@xmath444 is part of a counter - clockwise walk of @xmath7 ( when directed from @xmath257 to @xmath57 ) and @xmath456 contains @xmath455 ( figure  [ fig : deltasets](b ) ) .",
    "assume first that @xmath444 is part of a clockwise walk of @xmath7 , see figure  [ fig : deltasets](a ) .",
    "then @xmath36 is to the right of the directed path @xmath457 .",
    "since @xmath0 is straight - line embedded , @xmath453 belongs to @xmath36 if and only if @xmath454 contains @xmath455 .",
    "now , assume that @xmath444 is part of a counter - clockwise walk of @xmath7 , see figure  [ fig : deltasets](b ) .",
    "then @xmath36 is to the right of the directed path @xmath458 .",
    "thus , @xmath453 belongs to @xmath36 if and only if @xmath456 contains @xmath455 .",
    "lemma  [ lem : faceininterior ] and the above discussion show that to efficiently determine whether the boundary vertices between @xmath437 and @xmath438 belong to @xmath36 or to @xmath37 , we need to quickly find @xmath138 , @xmath447 , @xmath139 , and @xmath450 and determine whether @xmath444 is part of a clockwise or counter - clockwise walk of @xmath7 .    by keeping a clockwise ordering of vertices of all elementary faces ,",
    "we can find @xmath139 and @xmath450 in constant time .",
    "for each shortest path tree in @xmath0 rooted at a boundary vertex , we assume that each non - root vertex is associated with its parent in the tree .",
    "this allows us to find also @xmath138 in constant time .",
    "as for @xmath447 , suppose we have precomputed , for each boundary vertex @xmath459 and each @xmath460 , the successor of @xmath459 on the path from @xmath459 to @xmath258 in shortest path tree @xmath461 .",
    "depth - first searches in each shortest path tree allow us to make these precomputations in @xmath4 time and space .",
    "now , since shortest paths are unique , the subpath of @xmath444 from @xmath438 to @xmath57 is a path in shortest path tree @xmath462 and @xmath447 is the successor of @xmath438 on this path . with the above precomputations",
    ", we can thus find @xmath447 in constant time .",
    "finally , to determine whether @xmath444 is part of a clockwise walk of @xmath7 , we do as follows . we first find the elementary faces adjacent to @xmath13 in @xmath0 .",
    "they can be obtained from dual tree @xmath463 in constant time .",
    "we can also determine in constant time which of the two elementary faces belongs to @xmath36 since that elementary face is a child of the other in @xmath463 .",
    "let @xmath464 be the elementary face in the interior of @xmath7 .",
    "we check if the edge directed from @xmath57 to @xmath58 is part of a clockwise or counter - clockwise walk of @xmath464 . again",
    ", this takes constant time .",
    "if it is part of a clockwise walk of @xmath464 then @xmath444 is part of a clockwise walk of @xmath7 ( figure  [ fig : deltasets](a ) ) and otherwise , @xmath444 is part of a counter - clockwise walk of @xmath7 ( figure  [ fig : deltasets](b ) ) .",
    "assume first that @xmath13 is not an edge of @xmath99 .",
    "let @xmath301 and @xmath302 be the two shortest paths in @xmath0 from @xmath58 to the end vertices of @xmath13 , respectively . since @xmath13 is not in @xmath99 , it must belong to @xmath100 .",
    "hence , the intersection between @xmath7 and @xmath99 is the union of paths @xmath319 , where @xmath319 is a subpath of either @xmath301 or @xmath302 with both its end vertices in @xmath102 .",
    "each such path @xmath319 is a shortest path in @xmath99 .",
    "it then follows from lemma  [ lem : nocross ] that @xmath7 does not cross any cycle of @xmath208 .",
    "it follows that if @xmath7 does not cross @xmath38 then @xmath13 is contained in @xmath249 .",
    "the converse is also true . for",
    "if @xmath13 is contained in @xmath249 then by lemma  [ lem : nocross ] , both @xmath301 and @xmath302 are contained in @xmath249 , implying that @xmath7 does not cross @xmath38 .",
    "thus , @xmath7 crosses @xmath38 if and only if @xmath13 is not in @xmath249 , i.e. , if and only if @xmath118 and @xmath119 are both contained in @xmath468 .",
    "the latter is equivalent to the condition that @xmath235 is an ancestor of neither @xmath237 nor @xmath238 in @xmath231 .",
    "hence , @xmath7 crosses @xmath38 if and only if the second condition of the lemma is satisfied .    now , assume that @xmath466 .",
    "then @xmath235 is not an ancestor of @xmath236 .",
    "again , lemma  [ lem : nocross ] shows that @xmath7 crosses @xmath38 if and only if @xmath13 is not in @xmath468 , i.e. , if and only if @xmath118 and @xmath119 are both contained in @xmath249 .",
    "this holds if and only if @xmath235 is an ancestor of both @xmath237 and @xmath238 in @xmath231 .",
    "it follows that @xmath7 crosses @xmath38 if and only if the first condition of the lemma is satisfied .",
    "assume first that @xmath239 and let @xmath38 be a descendant of @xmath7 in @xmath231 .",
    "we need to show that @xmath38 is added to @xmath43 . since @xmath469 , there is a pair of elementary faces @xmath118 and @xmath119 in @xmath99 which are separated by @xmath38 and not by any other cycle in @xmath125 .",
    "let @xmath118 be contained in @xmath249 and let @xmath119 be contained in @xmath468 .",
    "note that @xmath119 is contained in @xmath36 since otherwise , @xmath7 would separate @xmath118 and @xmath119 .",
    "since @xmath239 and since no cycle of @xmath43 crosses @xmath7 , all cycles of @xmath470 belong to @xmath37 . hence , no cycle of @xmath471 separates @xmath118 and @xmath119 . since the set of cycles in the gmcb of @xmath0 is a subset of @xmath472 by lemma  [ lem : divideconquer ] and",
    "since @xmath234 , it follows that @xmath38 is added to @xmath43 .",
    "now assume that @xmath240 .",
    "since no cycle of @xmath43 crosses @xmath7 , all cycles of @xmath470 belong to @xmath36 .",
    "a similar argument as the above then shows that all cycles of @xmath125 belonging to @xmath37 must be part of the gmcb of @xmath0 .",
    "these cycles are exactly the those that are not descendants of @xmath7 in @xmath231 ."
  ],
  "abstract_text": [
    "<S> a minimum cycle basis of a weighted undirected graph @xmath0 is a basis of the cycle space of @xmath0 such that the total weight of the cycles in this basis is minimized . </S>",
    "<S> if @xmath0 is a planar graph with non - negative edge weights , such a basis can be found in @xmath1 time and space , where @xmath2 is the size of @xmath0 . </S>",
    "<S> we show that this is optimal if an explicit representation of the basis is required . </S>",
    "<S> we then present an @xmath3 time and @xmath4 space algorithm that computes a minimum cycle basis _ </S>",
    "<S> implicitly_. from this result , we obtain an output - sensitive algorithm that explicitly computes a minimum cycle basis in @xmath5 time and @xmath6 space , where @xmath7 is the total size ( number of edges and vertices ) of the cycles in the basis . </S>",
    "<S> these bounds reduce to @xmath3 and @xmath4 , respectively , when @xmath0 is unweighted . </S>",
    "<S> we get similar results for the all - pairs min cut problem since it is dual equivalent to the minimum cycle basis problem for planar graphs . </S>",
    "<S> we also obtain @xmath3 time and @xmath4 space algorithms for finding , respectively , the weight vector and a gomory - hu tree of @xmath0 . </S>",
    "<S> the previous best time and space bound for these two problems was quadratic . from our gomory - hu tree algorithm </S>",
    "<S> , we obtain the following result : with @xmath3 time and @xmath4 space for preprocessing , the weight of a min cut between any two given vertices of @xmath0 can be reported in constant time . </S>",
    "<S> previously , such an oracle required quadratic time and space for preprocessing . the oracle can also be extended to report the actual cut in time proportional to its size . </S>"
  ]
}