{
  "article_text": [
    "peg solitaire is one of the earliest known puzzles , with a 300 year history .",
    "the puzzle consists of a game board together with a number of pegs , or more commonly marbles .",
    "the board contains a grid of holes in which these pegs or marbles are placed .",
    "figure  [ fig1 ] shows the two most common shapes for a peg solitaire board , the 33-hole cross - shaped board , and the 15-hole triangular board .",
    "the game is played by jumping one peg over another into an empty hole , removing the peg that was jumped over . on the cross - shaped board of figure  [ fig1]a ,",
    "these jumps must be made along columns or rows , whereas on the triangular board of figure  [ fig1]c , jumps are allowed along any of the six directions parallel to the sides of the board . the goal is to finish with one peg , a more advanced variation is to finish with one peg at a specified hole .",
    "the basic game begins from a full board with one peg removed , as in figure  [ fig1]a or c. starting from figure  [ fig1]a and ending with one peg in the center of the board is known as the  central game \" @xcite . in figure  [ fig1]b or d",
    "we show starting configurations to be referred to later .    only relatively recently in the history of the game",
    "have computers been used as an interface to play the game , as well as solve the game .",
    "there are now dozens of versions of the game available for playing on your computer or even your cell phone .",
    "a computer version of the game is in many ways less satisfying than a physical game .",
    "however , there are some definite advantages to playing the game on a computer",
    ". the board can be reset instantly , and you wo nt be chasing marbles that fall off the board ! you can take back a move , all the way back to the beginning if desired .",
    "this tends to make the game easier as you can more easily backtrack from dead ends .",
    "the sequence of moves leading to a solution can be recorded and played back .",
    "the computer can also be programmed to tell the user if the jump they are considering leads to a dead end or not . adding this ability to a computer version of the game is tricky , and most versions do not have this ability .",
    "it is the goal of this paper to describe efficient techniques to enable a computer to point out all good and bad jumps from the current board position .",
    "we label the holes in the 33-hole board using cartesian coordinates ( figure  [ fig2]a ) , but with @xmath0 _ increasing _ downward . for the triangular boards , we use  skew - coordinates \" as shown in figure  [ fig2]b . by adding 1 to each coordinate , and converting the first to a letter",
    ", we obtain the standard board labellings used by beasley @xcite and bell @xcite ( for example the central hole @xmath1 in figure  [ fig2]a becomes  d4 \" ) .",
    "the 33-hole board has square symmetry .",
    "there are eight symmetry transformations of the board , given by the identity , rotations of @xmath2 , @xmath3 and @xmath4 , and a reflection of the board followed by these 4 rotations @xcite ( the dihedral group @xmath5 ) .",
    "the triangular boards have 6-fold symmetry , with 3 possible rotations of @xmath6 , @xmath7 or @xmath8 , plus a reflection followed by a rotation ( the dihedral group @xmath9 ) .    to store a particular board position on a computer , we convert it to an integer by taking one bit per hole",
    ". the most obvious way to do this is to take the board , row by row , top to bottom , as in figure  [ fig2]c .",
    "we will use @xmath10 to denote the total number of holes on the board , so each board position is represented by an @xmath10 bit integer . if @xmath11 is a board position we ll denote this integer representation by @xmath12 .",
    "most computer languages use a 32-bit integer , so we have one bit too many for storing the 33-hole board .",
    "beasley @xcite gives a technique for storing a board position on the 33-hole board using 4 fewer bits .",
    "the additional complexity is often not worth it , and computer memory is cheap these days . for boards with more than 32 holes ,",
    "we usually split @xmath12 into several 4-byte integers .",
    "the * complement * of a board position @xmath11 is obtained by replacing every peg by a hole ( i.e. removing it ) , and replacing every hole by a peg .",
    "the complement of @xmath11 will be denoted as @xmath13 .",
    "we note that @xmath14 , where @xmath15 is the board position where every hole contains a peg , @xmath16 .",
    "the starting position for the  central game \" in figure  [ fig1]a therefore has code @xmath17 .",
    "two board positions are symmetry equivalent if one can be converted to the other by a symmetry transformation .",
    "this equivalence relation introduces a set of _ equivalence classes _ of board positions , which we will call * symmetry classes*. the symmetry class of a board position does not change after it is rotated or reflected .",
    "one way to choose a representative from each symmetry class is to take the one with the smallest code .",
    "we use the notation @xmath18 to denote this operation .",
    "for example , the board position @xmath11 in figure  [ fig1]d has code @xmath19 , and the other 5 codes obtained by symmetry transformation are : @xmath20 , @xmath21 , @xmath22 , @xmath23 and @xmath24 , so @xmath25 .",
    "we also have @xmath26 .",
    "a peg solitaire problem which begins with one peg missing , with the goal to finish with one peg , will be called a * single vacancy to single survivor * problem , abbreviated svss . when the starting hole @xmath27 and finishing hole @xmath28 are the same , the svss problem is called a * complement problem * , because the starting and ending board positions are complements of each other .",
    "a simple parity argument gives a necessary condition for solvability of a svss problem ( * ? ? ?",
    "* chapter 4 ) . on a square lattice ( like the standard 33-hole board ) , the requirement is that @xmath29 and @xmath30 must differ by a multiple of 3 , or that @xmath31 , and @xmath32 . starting and ending board positions satisfying the above conditions",
    "are said to be in the same * position class*. the main result is that _ the position class does not change as the game is played_. on a triangular lattice , the requirement is weaker : @xmath33 . ] .",
    "we will not go into the theory of position classes , the reader should see beasley ( * ? ? ?",
    "* chapter 4 ) or bell @xcite for triangular peg solitaire .",
    "it is interesting to see what happens to the position class after the board is rotated or reflected .",
    "for the central game on the 33-hole board ( figure  [ fig1]a ) , the position class is not changed by rotations or reflections of the board .",
    "if we begin with @xmath1 vacant we can finish at @xmath1 , or the rotationally equivalent holes @xmath34 , @xmath35 .",
    "any board position which begins from any of these five holes is in the position class of one peg in the center .",
    "moreover , if we reflect and/or rotate the board at any time during the game , it remains in the same position class .",
    "thus , this set of holes forms a set of svss problems of the same * type * whose general solutions are all interconnected , shown in figure  [ fig3]a .",
    "more commonly , the position class does change after the board is rotated or reflected .",
    "problems of this type are shown in figure  [ fig3]b . in this case when we rotate the board , the position class changes , but only among the 4 with single peg representatives in the holes shown in figure  [ fig3]b .",
    "another way to look at figure  [ fig3]b is that we can begin with @xmath27 at any  3 \" or  4 \" , and finish at any  3 \" or  4 \" , if we allow peg solitaire jumps plus rotations and reflections of the board . the third type of problem on this board is given in figure  [ fig3]c .",
    "the three problem types are in a sense completely separate  it is never possible to move from a svss problem of one type to another , even if you are allowed to rotate or reflect the board .",
    "wiegleb s board ( figure  [ fig4 ] ) is an extension of the standard 33-hole board and has 45 holes @xcite .",
    "figure  [ fig4 ] shows that this board also has three types of svss problems , but there are more of them ( 36 in all , see @xcite ) .",
    "figure  [ fig5 ] shows that the @xmath36 square board also has three problem types .    in triangular peg",
    "solitaire the situation is somewhat different . on the triangular board of side @xmath37 ,",
    "if @xmath38 , the board is not null - class and no complement problem can be solved ( see bell @xcite ) .",
    "the only svss problem on the 10-hole triangular board that is solvable is of the form : vacate @xmath39 finish at @xmath40 .",
    "this gives only one type of problem that is solvable ( see figure  [ fig6]a ) , and any problem starting from an unmarked hole in figure  [ fig6]a can not be solved to one peg ( even if you are allowed to rotate and flip the board ) .",
    "the 15-hole triangular board is null - class ( figure  [ fig6]b ) .",
    "here there are 4 different starting locations , the  standard starting holes \" for each of the 4 are shaded .",
    "the fact that there is only one type indicates that all problems on this board are all interrelated .",
    "the 21-hole triangular board is also null - class ( figure  [ fig6]c ) , and contains 5 different starting locations . on this board",
    "it is possible to start with any peg missing , and finish at any hole using peg solitaire jumps , _ plus _ rotating and flipping the board .    here",
    "are several peg solitaire problems we are interested in solving :    the * complement problem * : from a starting vacancy @xmath27 , execute an arbitrary number of jumps , then determine if the board position can be reduced to one peg at @xmath27 .",
    "the * general ( svss ) problem * : from a starting vacancy @xmath27 , execute an arbitrary number of jumps , then determine if the board position can be reduced to one peg ( anywhere on the board ) .",
    "the * general problem * : from a given board position , determine if it can be reduced to one peg ( anywhere on the board ) .",
    "we will consider primarily the first two problems in this paper .",
    "we also want to solve these problems quickly  ideally within a web browser . in determining if a jump leads to a dead end or",
    "not , a delay of one second is unacceptable .",
    "it is important to realize that problems # 2 and # 3 are different .",
    "for example , on the 33-hole board , a popular problem to solve is  cross \" ( figure  [ fig1]b ) .",
    "this board position can never appear during the solution to any svss problem .",
    "how do we know this ? because the complement of this board position can not be reduced to a single peg .",
    "see bell @xcite to clarify why a board position during a svss problem must have this property .",
    "a fair question is , why not go for the most general and difficult problem # 3 ?",
    "the reason is that the complement problem # 1 and general svss problem # 2 are significantly easier , because we can take advantage of special properties of their solutions .",
    "the simplest technique for solving a peg solitaire problem on a computer is to store the sequence of jumps , together with the current board position .",
    "one then performs a depth - first search by jump ( extending the jump sequence and backtracking when no further move is possible ) .",
    "the 15-hole triangular board can be easily solved using this technique , but it is much slower on the 33-hole board .",
    "the reason is that there are a large number of jump sequences that result in the same board position , so there is a tremendous amount of duplicated work .",
    "this difficulty can be removed by storing board positions seen previously in a hash table or binary tree .",
    "a better technique is to stop recording the jump sequence entirely , and look at the whole problem as a sequence of board positions .",
    "given a set of board positions @xmath41 , we denote by @xmath42 the set of board positions that can be obtained by performing every possible jump to every element of @xmath41 .",
    "we call @xmath42 the * descendants * of @xmath41 . as a programming task calculating @xmath42",
    "is straightforward .",
    "for example the set @xmath41 can be stored on the disk as a sequence of integer codes , we read each code and convert it to a board position .",
    "from this board position we execute every possible jump , resulting in a large number of board positions which are stored in a binary tree ( or hash table ) to remove duplicates .",
    "this binary tree is then dumped to a file as a sequence of codes , the set @xmath42 .",
    "the problem that eventually occurs is that the binary tree becomes too large to fit into memory . at this point",
    "the problem is easily split into @xmath43 smaller pieces that are calculated separately .",
    "it is best if @xmath43 is a prime number , chosen so as to reduce the problem size so that it fits in memory .",
    "we now go through the board positions in @xmath41 as before , but instead of storing each board position @xmath11 in a binary tree , we convert it to a code and write that code into a temporary file numbered @xmath44 . here",
    "% \" operator represents the remainder upon division by @xmath43 ( as in c ) .",
    "after all board positions in @xmath41 have been considered , we now go back through each of the @xmath43 temporary files , filling a binary tree for each @xmath43 to remove duplicates and finally writing the unique board positions to the disk ( in @xmath43 separate files ) .",
    "in most cases we do not want to store two board positions that are in the same symmetry class . for example , for the central game ( figure  [ fig1]a , there are four first jumps , but these result in identical board positions which are rotations of one another .",
    "a nice way to select a single representative from the symmetry class is to use the one with the smallest code . in the above algorithms",
    ", we use @xmath18 in place of @xmath12 .    for a set of board positions @xmath41 , we denote by @xmath45 the number of elements in the set .",
    "@xmath46 is the set of complemented board positions . in other words",
    "@xmath47 if and only if @xmath48 .",
    "we note that @xmath46 is not a set complement in the traditional sense ( i.e. @xmath47 if and only if @xmath49 ) , but rather _ a set of complemented board positions_.    let @xmath50 be the initial board position with one peg missing .",
    "let @xmath51 be the final board position with one peg .",
    "let @xmath52 and @xmath53 .",
    "we then define the set of board positions that can be reached from @xmath50 by : @xmath54 note that every element of @xmath55 has exactly @xmath37 pegs .",
    "this produces a  playing forward \" sequence of sets @xmath56 where the number of elements in each set increases exponentially , at least initially .",
    "we are calculating the nodes in the  game tree \" , but have lost all information about the links connecting them ( however , this link information is easily recovered ) .",
    "the problem has a solution if and only if @xmath57 .",
    "a sequence of sets can also be obtained from the finishing board position @xmath51 by  playing backwards \" , which in our notation we write as : @xmath58 again , every element of @xmath59 has exactly @xmath37 pegs , and the problem has a solution if and only if @xmath60 .",
    "it is worth noting that the sets @xmath59 contain _ every _ board position which can be reduced to @xmath51 .",
    "thus , the sets @xmath59 can be used to solve any problem # 3 ( p. 6 ) which finishes at @xmath51 , or symmetric equivalents .",
    "if we calculate @xmath59 over all possible one peg finishes , we can solve any problem # 3 .",
    "the set of  winning board positions \" with @xmath37 pegs is defined as @xmath61 if we have _ any solution _ , and play this solution until reaching board @xmath11 with @xmath37 pegs , then it must be that @xmath62 .",
    "the sets @xmath63 are usually much smaller than the @xmath55 and @xmath59 , these are the nuggets of gold that we seek , because they enable us to quickly recognize any winning board position .    as a practical matter , to find @xmath63 it is not necessary to calculate every @xmath55 and @xmath59 for each @xmath37 between @xmath64 and @xmath65 and perform their intersection ( intersecting two sets with potentially billions of elements is not a trivial computation ) .",
    "suppose we can calculate the forward sets to @xmath66 , and the backward sets to @xmath67 for some @xmath68 between @xmath65 and @xmath64 . if the problem has a solution , then @xmath69 is not empty .",
    "we then compute @xmath70 recursively using @xmath71 and @xmath72 using @xmath73 to calculate using equation ( [ eq : wdown ] ) , we take each element of @xmath74 , complement it , calculate all descendants and complement each .",
    "this yields the set @xmath75 , and we now save each element which is in common with @xmath55 , giving us @xmath63 . the recursive calculations ( [ eq : wup ] ) and ( [ eq : wdown ] ) are much easier than calculating all @xmath55 and @xmath59 because the sets @xmath63 tend to be orders of magnitude smaller .",
    "the determination of @xmath63 using ( [ eq : wup ] ) and ( [ eq : wdown ] ) is considerably faster than the initial task of calculating the sets @xmath66 and @xmath67 .",
    "finally , we note that the sets @xmath55 , @xmath59 and @xmath63 can be defined in two subtly different ways .",
    "first , they can simply be sets of board positions .",
    "if @xmath76 is the starting position for the central game ( figure  [ fig1]a ) , then @xmath77 , and @xmath78 has 4 elements which are rotations of one another",
    ". we will sometimes refer to these sets as",
    " raw @xmath55 \" .",
    "in most cases , however , we will consider @xmath55 , @xmath59 and @xmath63 as sets of symmetry classes . now",
    "the set @xmath78 only has a single element , which can be taken as any representative of this symmetry class , and generally we choose the one with the smallest @xmath79 .",
    "these sets are called  symmetry reduced \" @xmath55 .",
    "if we refer to an unqualified @xmath55 or @xmath63 it can be assumed to be symmetry reduced .",
    "for a complement problem , we have @xmath80 , which implies @xmath81 @xmath82 @xmath83    equation ( [ eq : w ] ) states that _ the sets of winning board positions are complements of one another_. this is a remarkable result , and tells us that for a complement problem , we only need to store half the winning board positions . in order to calculate @xmath63",
    "the work is halved as well , for we need only calculate the forward sets @xmath55 down to @xmath84 . after performing the intersection ( [ eq : wcalc ] ) , the remaining @xmath63 are then calculated using equation ( [ eq : wup ] ) or equivalently ( [ eq : wdown ] ) .    is storing winning board positions the most efficient technique ? during the start of a game , it does not seem so , because all board positions that can be reached are winning .",
    "perhaps it is better to store  losing board positions \" , or positions from which a one peg finish at the starting hole can not be reached ?",
    "we could define the set of  losing board positions \" with @xmath37 pegs as those elements of @xmath55 which are not in @xmath63 .",
    "a more efficient technique is to store _ only _ those losing board positions which are one jump away from a winning board position .",
    "thus , we define @xmath85 table  [ table1 ] shows the sizes of @xmath55 , @xmath63 and @xmath86 for the 15- and 21-hole triangular boards . all winning board positions for any corner complement problem can be identified by storing just @xmath87 board positions ( 15-hole board ) or @xmath88 board positions ( 21-hole board ) .",
    "if we store losing board positions as defined by equation ( [ ldef ] ) , we need to store more than four times as many board positions .",
    ".size of @xmath55 , @xmath63 and @xmath86 for the corner complement problem on the 15 and 21-hole triangular boards .",
    "@xmath89 only half of the @xmath63 need to be stored , due to equation  ( [ eq : w ] ) .",
    "[ cols=\"^ , > , > , > , > , > , > , > \" , ]     for example , since @xmath90 in binary , then @xmath91 contains all @xmath37-peg positions that are common to problems 1 , 2 and 3 .",
    "we note the since problem 4 is unsolvable as a complement problem @xcite , @xmath92 and all sets @xmath93 with @xmath94 between @xmath95 and @xmath96 are also empty .",
    "a trickier question is how to resolve the degeneracy at the @xmath97 starting location .",
    "the sets @xmath98 can not be symmetry reduced , yet @xmath99 and @xmath100 are symmetry reduced , and @xmath92 .",
    "we see from figure  [ fig7 ] that @xmath98 contains code @xmath101 , while @xmath99 contains mincode @xmath102 , a board position in the same symmetry class . the solution is to use an algorithm which keeps all codes in @xmath98 but removes all symmetry equivalents in the intersecting sets .",
    "this is the reason that the degenerate starting locations are indexed first .",
    "table  [ table5 ] summarizes the number of board positions by @xmath94 and number of pegs @xmath37 .",
    "the total number of board positions over all sets is @xmath103 , which is only @xmath104 more than are needed to solve the general svss problem by itself .",
    "we can infer that there are @xmath104 board positions among the @xmath103 that are duplicated ",
    "these must be @xmath104 pairs of board positions in @xmath98 that are in the same symmetry class .",
    "figure  [ fig8 ] shows representative 5-peg board positions in @xmath105 for values of the _ index _ 0 to 7 .",
    "let us interpret two of the board positions in this diagram .",
    "the board position with code @xmath106 is in _ index _ 0 , meaning that this board position can not appear in any complement problem .",
    "this board position has a mincode of @xmath107 .",
    "we can finish with one peg from this board position at @xmath108 or @xmath97 , but we can not start from either of these holes and reach this board position .",
    "but it must be possible to reach this board position from some start , and it turns out this start is @xmath109 .    the board position with _ index",
    "_ 6 is @xmath110 , which is the mincode .",
    "we can play from this board position to finish at @xmath108 , @xmath97 or @xmath109 , and we can reach this board position from @xmath108 or @xmath109 . therefore , this board position can be reached during the solution to the @xmath108 or @xmath109 complements , so is in _ index _ 6 .",
    "we now present pseudocode for identification of winning board positions for either the complement problem ( # 1 ) or the general svss problem ( # 2 ) :    .... w[5][1 ] = { 16,64,1,8 } ! w^1 , index=0,1 , ... 15 , for the 15-hole triangular board end[5][1 ] = { 1,2,3,3,4,4,4,4,4,4,4,4,4,4,4,4 }",
    "! ends of each index 0 - 15 ... see triangle??winning.txt ... !",
    "board is the current board position !",
    "side is the triangular board side ( 4,5 , or 6 ) !",
    "i is the number of this svss problem !",
    "ksym is the symmetry code of the starting board position !",
    "comp is true for complement problems , otherwise any finish is assumed boardissolvable(board , side , i , ksym , comp ) {    int code[6 ]      totholes = side*(side+1)/2      if ( side==4 ) { ! 10-hole triangular board      topindex = 1      degen = 0    }    if ( side==5 ) { ! 15-hole triangular board      topindex = 2 ^ 4 ! power set of 4 problems      degen = 1 !",
    "number of degenerate problems    }    if ( side==6 ) { ! 21-hole triangular board      topindex = 2 ^ 5 ! power set of 5 problems      degen = 2 ! number of degenerate problems    }      n = countpegs(board )    if ( n > tot/2 ) then {      code[0 ] = 2^tot - 1 - code(board )      n = tot - countpegs(board )    }    else code[0 ] = code(board )      ! get the 6 symmetry codes , code[0 ] to code[5 ]    code[1 ] = rotatecode(code[0 ] )    code[2 ] = rotatecode(code[1 ] )    code[3 ] = reflectcode(code[2 ] )    code[4 ] = rotatecode(code[3 ] )    code[5 ] = rotatecode(code[4 ] )      if ( comp ) { ! complement problem      kstart = 0      kend = 6      if ( i<=degen ) {        kstart = ksym        kend = ksym + 1      }      for ( index=1 ; index < topindex ; index++ ) {        if ( ( 1<<i ) & index ) { !",
    "true if the i'th bit of index is set          for ( j = end[side][n][index-1 ] ; j < end[side][n][index ] ; j++ ) {            for ( k = kstart ; k < kend ; k++ ) if ( code[k]==w[side][n][j ] ) return true          }        }      }    }    else { ! comp = false , finish anywhere      for ( j=0 ; j < end[side][n][topindex ] ; j++ ) {         for ( k=0 ; k<6 ; k++ ) if ( code[k]==w[side][n][j ] ) return true      }    }      return false } ....",
    "i have created a javascript game @xcite for playing peg solitaire on the 10 , 15 and 21-hole triangular boards .",
    "this game can begin from any starting vacancy , and the program will point out all jumps which lead to winning or losing board positions .",
    "the game can be specified as either a complement problem ( the user must finish with one peg at the location of the original hole ) , or the general problem with a one peg finish anywhere on the board . the algorithm used to identify",
    "winning and losing board positions is the algorithm ` boardissolvable ( ) ` in this paper converted to javascript .",
    "* ` triangle10winning.txt `  a text file of the board positions @xmath111 , given in table  [ table4 ] .",
    "note : each file ` triangle??winning.txt ` contains two versions of the solution sets @xmath111 .",
    "first , a version for identifying winning board positions in the  finish anywhere \" problem ( # 2 ) using the algorithm ` problemissolvable ( ) ` .",
    "second , an _ indexed _ version as described in section 6 , which is slightly larger due to the symmetry degeneracy .",
    "these sets can be used to identify winning board positions for any complement problem ( # 1 ) as well as the  finish anywhere \" problem ( # 2 ) using the more complex algorithm ` boardissolvable ( ) ` .",
    "each set is sorted by index ( if present ) , then by code . on this 10 hole board",
    "the two versions are identical so the same sets appear twice . * ` triangle15winning.txt `  a text file of the board positions @xmath111 for the 15-hole triangular board .",
    "this is given as a single set subdivided by index .",
    "the array ` end[index ] ` ( summarized by table  [ table5 ] ) shows where the end of the codes for each index occurs .",
    "the function ` boardissolvable ( ) ` shows how this information is used .",
    "+ the sets for the corner complement problem ( problem @xmath112 ) : + @xmath1131@xmath114 , @xmath11510@xmath114 , @xmath11628 , 112@xmath114 , @xmath11723 , 58 , 85 , 120 , 1108 , 1616 , 2076 , 2210 , 2272@xmath114 , @xmath11831 , 93 , 115 , 601 , 1054 , 1138 , 1140 , 1562 , 1648 , 2183 , 2218 , 2245 , 2280 , 2348 , 2472 , 2616 , 2728 , 2819@xmath114 , @xmath119125 , 633 , 1086 , 1111 , 1594 , 1621 , 2191 , 2253 , 2275 , 2289 , 2343 , 2467 , 2589 , 2723 , 2785 , 2841 , 2889 , 3126 , 3250 , 3298 , 3428 , 3634 , 3845 , 4220 , 4270 , 4282 , 4691 , 4728 , 4817@xmath114 , @xmath1201567 , 1651 , 2235 , 2365 , 2413 , 2537 , 2731 , 2793 , 3159 , 3196 , 3320 , 3374 , 3388 , 3607 , 3642 , 3667 , 3669 , 3704 , 3859 , 3921 , 4215 , 4339 , 4341 , 4469 , 4701 , 4849 , 5302 , 5350 , 5746 , 5810 , 6881 , 6985 , 10053 , 10065 , 12065@xmath114 * ` triangle21winning.txt `  a text file of the board positions @xmath111 for the 21-hole triangular board . * ` english33winning_n.bin `  16 binary files of @xmath37-peg winning board positions @xmath98 for the central game on the 33-hole cross - shaped board .",
    "although 33 bit integers are needed to store a general board position , all ( symmetry reduced ) board positions in @xmath98 can be stored as 32 bit ( 4 byte ) integers .",
    "the data format is _ unsigned _ 4 byte integer .",
    "we give the beginning and end of each set below as a check that they are being interpreted correctly .",
    "table  [ table2 ] gives the sizes of each of these sets .",
    "+ @xmath121 , @xmath122,@xmath123,@xmath124153 , 1680 , 16688 , 17928 , 66432 , 82976 , 147984 , 352256@xmath114,@xmath125158 , 692 , 793 , @xmath126 , 4554760 , 6684688 , 8601616@xmath114,@xmath127691 , 729 , 798 , @xmath126 , 137626128 , 138674576 , 138690824@xmath114,@xmath128734 , 1213 , 1459 , @xmath126 , 184696868 , 234962962 , 270942217@xmath114,@xmath129957 , 1786 , 1853 , @xmath126 , 287589385 , 305203236 , 305528850@xmath114,@xmath1301789 , 2941 , 3038 , @xmath126 , 409747465 , 439631908 , 439746596@xmath114,@xmath1316909 , 18174 , 19326 , @xmath126 , 1208836146 , 1208836241 , 1510760466@xmath114,@xmath13221502 , 22398 , 23294 , @xmath126 , 1552443410 , 2416730291 , 2418878546@xmath114,@xmath13324062 , 24555 , 27615 , @xmath126 , 2452121690 , 2452123930 , 2484693018@xmath114,@xmath13454271 , 55167 , 56063 , @xmath126 , 2586714211 , 2588438678 , 2592630883@xmath114,@xmath13553247 , 56831 , 57279 , @xmath126 , 2651879594 , 2655805539 , 3098292302@xmath114,@xmath136127999 , 128895 , 129791 , @xmath126 , 3793449102 , 3793531059 , 3793629859@xmath114,@xmath137126975 , 130559 , 229359 , @xmath126 , 3864553651 , 3928764638 , 3929805043@xmath114 .",
    "* ` triang.zip` a folder of javascript programs which can identify all winning positions on the 10 , 15 , and 21-hole triangular boards ( source files for @xcite ) ."
  ],
  "abstract_text": [
    "<S> we consider the one - person game of peg solitaire played on a computer . </S>",
    "<S> two popular board shapes are the 33-hole cross - shaped board , and the 15-hole triangular board  we use them as examples throughout . </S>",
    "<S> the basic game begins from a full board with one peg missing and finishes at a board position with one peg . </S>",
    "<S> first , we discuss ways to solve the basic game on a computer . </S>",
    "<S> then we consider the problem of quickly distinguishing boards positions that can be reduced to one peg (  winning \" board positions ) from those that can not be solved to one peg (  losing \" board positions ) . </S>",
    "<S> this enables a computer to alert the player if a jump under consideration leads to a dead end . </S>",
    "<S> on the 15-hole triangular board , it is possible to identify all winning board positions ( from any single vacancy start ) by storing a key set of 437 board positions . for the  central game \" on the 33-hole cross - shaped board </S>",
    "<S> , we can identify all winning board positions by storing 839,536 board positions .     </S>",
    "<S> + gibell@comcast.net +    .2 in </S>"
  ]
}