{
  "article_text": [
    "caching is a natural data management strategy when communication has a bursty characteristic . during off - peak time",
    ", local cache can be filled with data that is anticipated to be useful later to reduce the delay when the communication resources become scarce during peak time .    in a recent work @xcite , maddah - ali and niesen provided a formal information theoretic formulation for the caching problem . in this formulation , there are @xmath0 files , each of @xmath1 bits , and @xmath2 users .",
    "each user has a local cache memory of capacity @xmath3 ( measured in multiples of @xmath1 ) . in the caching phase",
    ", the users can fill their caches with contents from the central server without the knowledge of the precise requests . in the delivery phase , each user will request one file from the central server , and the central server must multicast certain common ( and possibly coded ) information to all the users in order to accommodate these requests ; an example case is given in fig [ fig : system ] . since in the caching phase , the requests at the later phase are unknown , the cached contents must be strategically prepared at all the users .",
    "the goal is to minimize the amount of multicast information which has rate @xmath4 ( also measured in multiples of @xmath1 ) , under the constraint on cache memory @xmath3 .",
    "it was shown in @xcite that coding can be rather beneficial in this setting , while uncoded solutions suffer a significant loss .",
    "subsequent works extended it also to decentralized caching placements @xcite , caching with nonuniform demands @xcite , online caching placements @xcite , and hierarchical coded caching @xcite ; the caching methods have also found their applications in device - to - device communication systems @xcite .",
    "files and @xmath5 users . in this instance",
    "the users request files @xmath6 , respectively , and thus the transmitted common information is written as @xmath7.[fig : system],width=377 ]    the scheme given in @xcite utilizes uncoded caching and coded transmission .",
    "a close inspection of the performance of the scheme reveals that when @xmath8 , many individual tradeoff points achieved by the scheme in @xcite are not on the lower convex envelope , and thus an effective scheme is lacking for this case , particularly when the cache capacity is small .",
    "though the scheme in @xcite was shown to be within a constant factor of the optimum , the loss of efficiency can be relatively significant when either @xmath0 or @xmath2 is small .",
    "particularly , for more sophisticated caching scenarios , usually either files or users need to be classified into smaller groups ( see _ e.g. _ @xcite ) , and such loss of efficiency may be magnified .",
    "recently chen _ et al .",
    "_ @xcite extended a special scheme given in @xcite for the case of @xmath9 to the case @xmath8 , and showed that the tradeoff pair @xmath10 is achievable , which is in fact one of the optimal tradeoff points .    in this work",
    ", we propose a new coded caching scheme when @xmath8 that caches linear combinations of the file segments .",
    "when files are not being requested by a user , their segments in the cached linear combinations can be considered as interferences by this user .",
    "our scheme strategically eliminates these interferences by utilizing a combination of rank metric codes and maximum distance separable codes ; the transmission also simultaneously serves the role of content delivery to other users .",
    "we show that the proposed scheme provides new tradeoff points outside the known achievable tradeoff inner bound in the literature . in fact , in certain cases , it can achieve points on the optimal tradeoff function .",
    "in contrast to previous schemes in the literature , the proposed codes are not binary , but in larger finite fields . one disadvantage of utilizing rank metric codes is the large field size that the codes require , however we show that by directly considering the underlying rank constraints and utilizing generic linear codes , a smaller field size is sufficient for such codes to exist .    in the rest of the paper , we shall first give the main theorem in section [ sec : maintheorem ] , then introduce some preliminaries in section [ sec : pre ] . before presenting the new codes",
    ", we provide three examples to illustrate the design principles in section [ sec : examples ] .",
    "the coding scheme , the corresponding proofs of correctness and analysis are given in section [ sec : scheme ] and section [ sec : proof ] , respectively .",
    "we conclude the paper in section [ sec : conclusion ] , and relegate some more technical proofs to the appendix .",
    "the main result of this paper is summarized below , where @xmath11 used to denote the set of natural numbers .    for @xmath12 files and @xmath13 users each with a cache of size @xmath3 , where @xmath8 , [ theorem : main ] the following @xmath14 pair is achievable @xmath15}{k(k-1)},\\frac{n(k - t)}{k}\\right ) , \\qquad t=0,1,\\ldots , k.\\end{aligned}\\ ] ]    with @xmath16 the tradeoff point degenerates to the trivial one @xmath17 , _",
    "i.e. , _ no cache ; when @xmath18 , it gives the same tradeoff pair as given in @xcite ; when @xmath19 , we obtain another trivial point of @xmath20 , _",
    "i.e. , _ no delivery transmission . together with the result in @xcite , which is replicated in the next section ( see theorem [ theorem : aliniesen ] )",
    ", we have the following corollary .    .",
    "the new inner bound matches the computation - based outer bound when @xmath21\\cup[2/3,2]$ ] .",
    "the pair @xmath22 can be achieved by the scheme given in @xcite , but it is not on the convex envelope of the known inner bound.[fig : case2_4],width=377 ]    for any @xmath12 and @xmath13 where @xmath8 , the lower convex envelope of the points in theorem [ theorem : main ] and those in theorem [ theorem : aliniesen ] for @xmath23 is achievable .",
    "[ corollary : combined ]    the new tradeoff inner bound is illustrated for the case @xmath24 in fig .",
    "[ fig : case2_4 ] .",
    "it can be seen that the scheme strictly improves upon the inner bound given in @xcite . for reference ,",
    "the cut - set based outer bound @xcite is also shown , together with a computation - based outer bound established in a separate work ( see @xcite ) using a method developed in @xcite .",
    "the new scheme gives the left three corner points on the solid black line ( labeled with diamonds ) .",
    "the first two are previously known , being the trivial case with no cache , and the point given in @xcite , respectively .",
    "the third point is previously unknown to be achievable , and it is explained in detail in section [ sec : examples ] . here all three points given by the new code are in fact on the optimal tradeoff function .    in the proposed scheme , for demands where not all files are requested , the scheme can be viewed as degenerate cases of the scheme for certain enhanced demands , where all files are being requested .",
    "although the scheme for such demands can be viewed as degenerate , this does not imply the tradeoff points achieved by the proposed scheme is only effective when @xmath25 , for which non - trivial codes are required only for the demands that all files are requested .",
    "an example is given for the case of @xmath26 to illustrate the different tradeoff points achieved by the proposed scheme and those achieved by the scheme given in @xcite .",
    "the lower convex hull specified in corollary [ corollary : combined ] consists of three regimes : the low memory regime where the proposed scheme dominates , a transition regime ( red solid line ) which is achieved by space sharing between the proposed scheme and the scheme in @xcite , and a high memory regime where the scheme in @xcite dominates .",
    "the point @xmath27 in on the lower convex hull , and it can be seen that the transmission rate is less than @xmath28 here .",
    ".[fig : case4_20],width=377 ]",
    "in this section we review some existing results on the caching problem , and then provide some necessary background information on maximum distance separable ( mds ) codes and rank metric codes .      for @xmath12 files and @xmath13 users each with a cache of size @xmath29 , [ theorem : aliniesen ]",
    "@xmath30 is achievable . for general @xmath23 ,",
    "the lower convex envelope of these @xmath14 points is achievable .    the first term in the minimization is achieved by the scheme of uncoded caching together with coded transmission @xcite , while the latter term is by simple uncoded caching and uncoded transmission . though this theorem is indeed correct",
    ", it can be slightly misleading since it may give the impression that the simple uncoded caching and uncoded transmission scheme can be effective in certain regime when @xmath31 .",
    "a close examination reveals that this trivial scheme only provides one operating point of @xmath32 in the convex hull when @xmath8 , as illustrated in fig .",
    "[ fig : case2_4 ] .",
    "thus a good caching strategy for the low memory case is still lacking .    as mentioned early , in a recent work @xcite , chen _ et al .",
    "_ extended a special scheme for the case @xmath9 discussed in @xcite to the general case @xmath8 , and showed that the tradeoff pair @xmath10 is achievable .",
    "it should be noted that the scheme given in @xcite uses uncoded caching with coded transmission , while the scheme in @xcite uses coded caching and coded transmission .",
    "both schemes use only binary coding , in contrast to the codes we propose in this work .      a linear code of length @xmath33 and dimension @xmath34 is called an @xmath35 code .",
    "the singleton bound ( see _ e.g. _ , @xcite ) is a well known upper bound on the minimum distance for any @xmath35 code , given as @xmath36    an @xmath35 code that satisfies the singleton bound with equality is called a maximum distance separable ( mds ) code .",
    "a key property of an mds code is that it can correct any @xmath37 or fewer erasures @xcite . for any @xmath35 pairs",
    "where @xmath38 , mds codes exist in any finite field @xmath39 when @xmath40 .      in order to handle the competing coding requirements in the caching problem",
    ", we use rank metric codes based on linearized polynomials ( see @xcite ) , for which the following lemma is particularly relevant ; see ,",
    "_ e.g. , _ @xcite .",
    "[ lem : useful ] a linearized polynomial in finite field @xmath41 @xmath42 can be uniquely identified from evaluations at any @xmath43 points @xmath44 , @xmath45 , that are linearly independent over @xmath39 .",
    "another relevant property of linearized polynomials is that they satisfy the following condition @xmath46 which is the reason that they are called linearized .",
    "this property implies the following lemma .",
    "[ lemma : fullrank ] let @xmath47 be a linearized polynomial in @xmath41 as given in ( [ eqn : linearized ] ) , and let @xmath48 , @xmath49 , be linearly independent over @xmath39 .",
    "let @xmath50 be a @xmath51 full rank ( rank @xmath43 ) matrix with entries in @xmath39 , then @xmath47 can be uniquely identified from @xmath52\\cdot g. \\end{aligned}\\ ] ]    we slightly abuse the notation by allowing the function @xmath47 to take vector input in @xmath53 , and define the output as the vector obtained by concatenating the output of @xmath47 on each input component",
    ". then by the linearized property , @xmath52\\cdot g = & [ f(\\theta_1,\\theta_2,\\ldots,\\theta_{p_o})]\\cdot g\\\\ = & f[(\\theta_1,\\theta_2,\\ldots,\\theta_{p_o})\\cdot g].\\end{aligned}\\ ] ] recall when each @xmath54 is viewed as a vector in @xmath55 , the @xmath56 vectors are linearly independent . since @xmath50 has rank @xmath43 , @xmath57 has rank @xmath43 in @xmath39 , _",
    "i.e. _ , we have @xmath43 evaluations of @xmath47 at @xmath43 linearly independent values , and thus by lemma [ lem : useful ] , @xmath47 can be uniquely identified .    with a fixed set of @xmath48 , @xmath49 , which are linear independent",
    ", we can view @xmath58 as information symbols to be encoded , and the evaluations @xmath59 as the coded symbols .",
    "this is a @xmath60 mds code in terms of rank metric .",
    "more importantly , the above lemma says any full rank ( rank @xmath43 ) @xmath39 linear combinations of the coded symbols are sufficient to decode all the information symbols .",
    "this linear - transform - invariant property had been utilized previously in other coding problems such as network coding with errors and erasures @xcite , locally repairable codes with regeneration @xcite , and layered regenerating codes @xcite .",
    "the codes thus obtained are not systematic , but they can be converted to systematic codes by viewing the information symbols @xmath61 as the first @xmath43 evaluations @xmath62 $ ] , which can be used to find the coefficients of the linearized polynomial @xmath58 , and then the additional parity symbols can be generated by evaluating this linearized polynomial at the remaining points @xmath63 .",
    "systematic rank - metric codes are instrumental in our construction .",
    "in this section , we provide three examples to illustrate the caching and transmission mechanism and discuss several critical observations .",
    "these observations provide important intuitions , which are used to design the caching and transmission strategy for the general case .    [",
    "cols=\"^,^,^,^,^\",options=\"header \" , ]     the three nodes cache the contents as shown in table . [",
    "tab : newcode33 ] . only the following three types of requests need to be considered due to symmetry :    * for the case @xmath64 , the transmissions are as follows : @xmath65,\\mathcal{l}[a;\\{\\{1,4\\},\\{2,4\\}\\};1].\\end{aligned}\\ ] ] * for the case @xmath66 , the transmissions are as follows : @xmath67,\\mathcal{l}[a;\\{\\{1,4\\},\\{2,4\\}\\};1];\\\\ \\text{step $ 4 $ : } & b_{1,3},b_{2,3},c_{1,2}.\\end{aligned}\\ ] ] * for the case @xmath68 , the transmissions are as follows : @xmath69,\\mathcal{l}[a;\\{\\{1,4\\},\\{2,4\\}\\};1];\\\\ \\text{step $ 4 $ : } & a_{1,2},a_{1,4},b_{2,4}.\\end{aligned}\\ ] ]    it can be verified that these transmissions indeed fulfill all the demands by counting the rank reduction for the purpose of interference elimination , as discussed in the first example .",
    "next let us make a few more observations in this solution .",
    "the transmission for the first case follows the strategy we have identified in the first example , but the other two cases require additional attention .",
    "for those two cases , the first two steps are still in line with our previous example for @xmath24 , but there is an additional step 4 , where uncoded transmissions are used .",
    "in fact , the transmissions in the first two steps for the latter two cases are precisely those in the first two steps for the first case , except that the transmissions involving files not being requested are omitted . in the transmissions of step 4 , instead of transmitting the segments of the file",
    "not being requested , the corresponding file segments from another file are transmitted , with a few exceptions when those substituted segments have already been transmitted ; if this occurs , the corresponding segments from the file not being requested are in fact transmitted .",
    "we can view the transmissions in the latter two cases as a variation from that in the first case .",
    "let us focus on the case @xmath66 : the only difference from the case @xmath64 is that user 4 is requesting file @xmath70 instead of @xmath71 .",
    "a closer examination of the case @xmath64 reveals that all transmissions involving file @xmath71 are uncoded . now",
    "to build the transmissions for the case @xmath66 from the transmissions for the case @xmath64 , we replace these uncoded transmissions with the matching transmissions of segments of file @xmath70 , however , only when there is no redundancy in such transmissions .",
    "for example , the last symbol to be transmitted should have been @xmath72 with such a straightforward substitution , but since we have already transmitted @xmath72 , retransmitting it is unnecessary and wasteful ; instead the file segment @xmath73 is transmitted . in this case",
    "although no user is requesting file @xmath71 , the last transmission does not cause any essential loss . in summary , a case when only a subset of files are requested can be viewed as degenerate , for which the transmission strategy can be deduced from some other case when all files are requested .",
    "before presenting the general coding scheme , we first clarify the notation that will be used in the sequel .",
    "the set of integers @xmath74 is written as @xmath75 , and the cardinality of a set @xmath76 is written as @xmath77 .",
    "denote the @xmath0 files as @xmath78 . fix an integer parameter @xmath79 in the proposed scheme , then each file in our scheme is partitioned into @xmath80 segments of equal size . each segment @xmath81 , where @xmath82 and @xmath83 with @xmath84 , is assumed to be a symbol in @xmath41 for some @xmath85 and @xmath86 sufficiently large .",
    "the parameters of @xmath85 and @xmath86 will be specified later .",
    "we reserve the calligraphic letter @xmath87 for the purpose of enumerating some of the subsets of @xmath88 of cardinality @xmath89 , without explicitly writing these conditions for notational simplicity .",
    "to present the general scheme , a few additional coding components are required .",
    "we first need a set of generic systematic linear mds codes whose generator matrix has entries in @xmath39 with parameters @xmath90 , for all @xmath91 and @xmath92 ; such codes can be found for any sufficiently large @xmath85 , for example , using cauchy matrix .",
    "we also allow the information symbols and coded symbols to be in @xmath41 , by taking the natural @xmath41 finite field operation ; this essentially boils down to writing the symbols as vectors length-@xmath86 in @xmath55 .",
    "furthermore , fix the parameter @xmath93 in the linearized polynomial and also fix @xmath94 values @xmath48 , @xmath95 , which are linearly independent in @xmath55 .",
    "this polynomial can be used to construct a @xmath60 systematic rank metric code as discussed in section [ subsec : pre ] ; we shall refer to this code as @xmath96 .",
    "we are now ready to present the general caching strategy .",
    "the caching strategy of the proposed can be described as follows . for user @xmath34 ,",
    "collect the file segment symbols : @xmath97 and encode it using the systematic rank metric code @xmath96 ; the parity symbols are then placed in the cache of user @xmath34 .      fix a parameter @xmath98 , let us first consider the case when all the files are being requested ; the cases @xmath16 or @xmath19 are omitted for which the scheme is trivial . for a given set of file requests from all the users , we define @xmath99}\\triangleq \\{k\\in i_k : \\text{user $ k$ requests file } w_n\\},\\nonumber\\\\ & \\qquad\\qquad\\qquad\\qquad\\qquad\\quad n=1,2,\\ldots , n,\\end{aligned}\\ ] ] and @xmath100}|\\geq 1 $ ] , @xmath101 .",
    "furthermore , define the complementary set @xmath102}\\triangleq i_k\\setminus i^{[n]}$ ] .    for each file @xmath103",
    ", we classify its segments @xmath81 by its intersection with @xmath102}$ ] , and address them differently .",
    "more precisely , there are three steps of transmissions :    * step 1 : all the file segments in the set @xmath104}\\}$ ] are transmitted uncoded directly ; * step 2 : for each subset @xmath105}$ ] , where @xmath106 , we encode the set of file segments @xmath107}=\\mathcal{a}\\}\\end{aligned}\\ ] ] using a @xmath108 systematic mds code ( whose coding coefficients are in @xmath109 ) , and then transmit all the parity symbols ; here we take the convention of @xmath110 when @xmath111 . *",
    "step 3 : encode all the file segments in the set @xmath112}\\}$ ] using a @xmath113 systematic mds code ( whose coding coefficients are in @xmath109 ) , and then transmit all the parity symbols",
    ".    in fact we can even merge all the three steps by taking certain convention on degenerate mds codes , however we keep them separate to facilitate understanding and analysis in the next section .",
    "for the required mds codes to exist , a trivially sufficient finite field size is @xmath114 . for the required rank metric codes to exist , we can choose any @xmath115 .",
    "it is clear that each file segment @xmath81 either belongs to a singleton set @xmath116 when @xmath117}$ ] , or one of the sets @xmath118 for some @xmath119}$ ] ; in other words , for each @xmath33 , the transmission strategy provides a partition of all the subset @xmath87 for @xmath120 and @xmath84 ( and also induces a partition of all the file segments @xmath81 ) . for each @xmath33",
    ", we denote the mapping from a subset @xmath87 to the corresponding subset that specifics the partition it belongs to as @xmath121}}(\\mathcal{s})$ ] , _",
    "i.e. , _ @xmath122}}(\\mathcal{s})}$ ] .      again fix a parameter @xmath98 , and consider the case when @xmath123 files are requested . without loss of generality , let us assume that the first @xmath124 files are being requested , and @xmath125}$ ] , @xmath126 and @xmath102}$ ] are defined similarly as in the last subsection , but only for @xmath127 . to describe the transmission strategy",
    ", we first find another set of enhanced demands , parametrized by @xmath128},\\dot{i}^{[2]},\\ldots,\\dot{i}^{[n]}$ ] , where all files are being requested ; _",
    "i.e. , _ @xmath129}|\\geq 1 $ ] for @xmath101 . additionally , these enhanced demands must satisfy the following properties :    * @xmath129}|=1 $ ] for @xmath130 ; * for any @xmath131 , if @xmath132}$ ] , then either @xmath133}$ ] , or @xmath134}$ ] , for some @xmath135 ; for the latter case , denote the mapping from @xmath136 to @xmath33 as @xmath137 , and denote the mapping from @xmath136 to @xmath34 as @xmath138 .",
    "we also write @xmath129}|=\\dot{m}_n$ ] for simplicity .",
    "the enhancement replaces some users requests with requests for files that originally are not being requested , and each of these files is now being requested by only one user in the enhanced version .",
    "note that this enhancement can always be found under the condition @xmath8 .",
    "a set of counters need to be initialized before presenting the transmission strategy , which is given as @xmath139}.\\end{aligned}\\ ] ] note that the set @xmath76 can be @xmath140 , and in fact in the proposed scheme we only need to consider the sets @xmath76 where @xmath141 , though the definition is still valid for other cases , by taking the convention @xmath142 if @xmath143 .",
    "the transmission strategy is as follows :    * for each file @xmath103 , @xmath127 , transmit as described step 1 - 3 for the * enhanced demands * ; * step 4 : for each @xmath33 , @xmath130 , perform the following operations . for each @xmath87 , where @xmath144 , reduce the counter @xmath145}}(\\mathcal{s})}$ ] by 1 , and then transmit @xmath146}}(\\mathcal{s})}\\geq 0\\\\ w_{n,\\mathcal{s } } , & \\mbox{otherwise } \\end{array}\\right .. \\end{aligned}\\ ] ]      let us revisit the example code for the @xmath147 case within the context of the general caching scheme",
    "the two indexing methods now have the following mapping @xmath148 and similarly for file segments of file @xmath70 .",
    "the scheme presented earlier is for @xmath149 .",
    "though we did not utilize rank metric codes for this example , we can still derive the parameters @xmath150 and @xmath151 , and thus @xmath152 symbols are generated and cached at each user .",
    "now consider requests @xmath153 , for which @xmath154 and @xmath155 .",
    "it is clear that the uncoded transmission in the general scheme matches exactly what we have presented .",
    "next consider the transmission in step 2 for @xmath156 , @xmath157 for which we have @xmath158 and the parities of a @xmath159 mds code are transmitted , which is exactly as that given previously , _",
    "i.e. _ , the symbols @xmath160 . in step 3",
    ", we have the following segments @xmath161 and the parity symbol of a @xmath162 mds code is transmitted , which is exactly as that given previously , _",
    "i.e. _ , the symbol @xmath163 . for file @xmath164",
    ", we can only take @xmath165 in step 2 since @xmath166 , however in this case , a @xmath167 mds code does not have any parity symbols , and thus no transmission of file @xmath70 is required in step 2 ; there is also no transmission of file @xmath70 in step 3 .",
    "we can similarly walk through the example for @xmath168 using the general transmission strategy ; this simple exercise is left to interested readers .",
    "we establish the correctness and the performance of the caching scheme in three propositions , and theorem [ theorem : main ] follows directly from them .",
    "two related issues are then discussed , regarding the format of the cached linear combinations and the required field size of the code .",
    "recall that we use @xmath87 to enumerate file subsets @xmath83 and @xmath84 .",
    "[ prop : correctness ] for any @xmath169 , the afore - given caching strategy can be used to satisfy any demands that request all files with the afore - given transmission strategy .    to show that any demands that request all @xmath0 files can be satisfied , we need consider any single user . without loss of generality",
    ", we can consider the first user and assume it requests file @xmath170 .",
    "let us count the number of linear combinations he receives which consist of interference symbols in his cache in the first two transmission steps",
    ".    in step 1 , user 1 can collect all uncoded symbols for file @xmath103 , @xmath171 in the form of @xmath172}\\},\\end{aligned}\\ ] ] and there are a total of @xmath173 such symbols , where we have taken the convention @xmath142 when @xmath174 .    in step 2 ,",
    "user 1 collects linear combinations of @xmath103 , @xmath175 , however only those in the following form . for each such @xmath33 , and each subset @xmath105}$ ] such that @xmath176 and moreover @xmath177 , user 1 collects the parity symbols of encoding @xmath118 using the systematic mds code .",
    "thus user 1 collects a total of @xmath178 such symbols .",
    "user 1 now has collected @xmath179 useful symbols , and has in his cache @xmath180 symbols of the same basis .",
    "observe for the summands in @xmath181 and @xmath182 , we have @xmath183 because the left hand side is simply all the possible ways of choosing @xmath184 balls in a total of @xmath185 balls , however counted when these balls are partitioned into two groups of size @xmath186 and @xmath187 , respectively .",
    "it follows @xmath188 these @xmath43 linear combinations , which can be represented as the product of the length-@xmath189 output ( both systematic and parity symbols ) of the rank metric code @xmath96 and a matrix @xmath50 of size @xmath51 .",
    "recall the systematic rank metric code we used to encode the @xmath43 file segments in user 1 s cache , and by lemma [ lemma : fullrank ] , as long as the matrix @xmath50 is full rank , all the @xmath43 segments can be recovered .",
    "this fact is proved in the appendix , but an outline of the proof is given here .",
    "we recognize that if the columns and rows of the matrix @xmath50 are rearranged to    * group the file segments @xmath190 in user 1 s cache together ; * for each @xmath175 , group the segments of @xmath191}\\}$ ] together ; * for each @xmath175 , and for each subset @xmath105}$ ] such that @xmath176 and moreover @xmath177 , group the segments of @xmath118 together ,    then the resulting matrix is block diagonal , and each block is either of size @xmath192 with entry @xmath193 or full rank because they are columns of generator matrices of mds codes .",
    "thus the matrix @xmath50 is indeed full rank .",
    "thus user 1 can eliminate the interferences in its cached contents , and recover all the file segments of @xmath190 that are already present in its cache .",
    "it remains to show that all the file segments @xmath190 that are not present in his cache can also be recovered .",
    "first , observe that in step 1 , user 1 can collect all uncoded @xmath170 file segments that are not in the cache of any users @xmath194}$ ] , _",
    "i.e. , _ @xmath195}\\}$ ] .",
    "as mentioned earlier , in step 2 after eliminating the interference , user 1 can recover all @xmath190 for @xmath87 such that @xmath196 .",
    "furthermore , for each subset @xmath197}$ ] such that @xmath198 , user 1 can collect the parity symbols of encoding @xmath199 using the @xmath200 systematic mds code .",
    "since user 1 has in its cache @xmath201 of the total @xmath202 symbols of @xmath199 , together with the collected parity symbols , he can recover all @xmath202 symbols in this set .",
    "thus after step 2 , user 1 can also recover all file segments @xmath190 where @xmath87 has elements in both @xmath203}$ ] and @xmath204}$ ] .",
    "the only missing segments are some in the set @xmath205}\\}$ ] . however , step 3 transmits the parities of a @xmath206 mds code that encodes all @xmath207}\\}$ ] , and since user 1 already has @xmath208 elements , he can thus also recover the rest of the symbols in this set . at this point , we can conclude that user 1 can recover all file segments of @xmath170 , which completes the proof .",
    "[ prop : correctnessenhanced ] for any @xmath169 , the afore - given caching strategy can be used to satisfy any demands that request a strict subset of all the files with the afore - given transmission strategy .",
    "the proof of this proposition can be intuitively explained as follows .",
    "when we replace a file demand @xmath209 in the enhanced demands with a demand @xmath210 , the effect of the not transmitting the file segments involving @xmath209 in the first three steps needs to compensated . in order to do so ,",
    "let us examine the roles that these @xmath209 transmissions play : firstly , they are used to eliminate the interferences by @xmath209 at certain other users , and secondly , they are used to provide the missing segments to the single user that was requesting @xmath209 in the enhanced demands . our strategy is to transmit the corresponding segments from @xmath210 instead of sending the segments from @xmath209 . with such substituted transmissions ,",
    "the first role can be fulfilled as long as it is not a redundant transmission , and we rely on the counter @xmath211 to avoid any such redundancy .",
    "the second role can clearly also be fulfilled by any such non redundant transmissions . when a transmission of the file segment from @xmath210 is indeed redundant",
    ", we can safely conclude that the second role has already been fulfilled by previous transmissions , and thus transmitting this segment of @xmath209 is now sufficient to serve the first role alone .",
    "the proof below makes this intuition more rigorous .    without loss of generality",
    ", we only need to consider the first user and assume his request is for file @xmath170 .",
    "two cases need to be examined : the first case is when in the enhanced demands , the first user was also requesting file @xmath170 ; the second case is when in the enhanced demands , the first user was requesting @xmath212 , _",
    "@xmath213 and @xmath214 , for some @xmath215 .",
    "let us consider the proof for the first case , which is similar to the proof for the proposition [ prop : correctness ] . in step 1",
    ", user 1 collects all uncoded symbols for file @xmath103 , @xmath216 in the form of @xmath217}\\},\\end{aligned}\\ ] ] and there are a total of @xmath218 such symbols .    in step 2 ,",
    "user 1 collects linear combinations of @xmath103 , @xmath219 , however only those in the following form . for each such @xmath33 , and each subset @xmath220}$ ] such that @xmath221 and moreover @xmath177 , user 1 collects the parity symbols of encoding @xmath118 using the systematic mds code .",
    "thus user 1 collects a total of @xmath222 such symbols .    in step 4 ,",
    "user 1 collects for each @xmath130 , for any @xmath220}$ ] where @xmath223 and @xmath224 , either @xmath225 or @xmath226 , whichever was transmitted in step 4 .",
    "note that in this case @xmath227 for any @xmath130 , which implies that @xmath228 .",
    "thus user 1 collects another total of @xmath229 uncoded symbols .",
    "user 1 now has collected @xmath230 useful symbols , and has in his cache @xmath180 symbols of the same basis .",
    "it is seen that @xmath231 these @xmath43 linear combinations , which can again be represented as the product of the length-@xmath189 output ( both systematic and parity symbols ) of the rank metric code @xmath96 and a matrix @xmath232 of size @xmath51 .",
    "as long as the matrix @xmath232 is full rank , user 1 can recover all the file segments @xmath190 where @xmath233 , and the rest of file segments from @xmath170 can be recovered as in the case of proposition [ prop : correctness ] . the fact of the matrix @xmath232 being full rank is obvious for the similar reason that the @xmath50 matrix is full rank under the enhanced demands ; in fact , since the transmissions in step 4 are all uncoded , the full - rank property directly follows from the full - rank property of the corresponding matrix with the enhanced demands .",
    "now let us now consider the second case , where user 1 is demanding @xmath170 , but in the enhanced demands , he was requesting file @xmath212 for some @xmath234 . by a similar argument as above , user 1 can recover all segments @xmath190 present in his cache , _",
    "i.e. , _ for @xmath190 where @xmath196 , by eliminating the interferences .",
    "more precisely , in step 1 , user 1 collects all uncoded symbols for file @xmath103 , @xmath235 in the form of @xmath217}\\},\\end{aligned}\\ ] ] and there are a total of @xmath236 such symbols . in step 2 ,",
    "user 1 collects linear combinations of @xmath103 , @xmath127 , however only those in the following form . for each such @xmath33 , and each subset @xmath220}$ ] such that @xmath221 and moreover @xmath177 , user 1 collects the parity symbols of encoding @xmath118 using the systematic mds code .",
    "thus user 1 collects a total of @xmath237 such symbols . in step 4 ,",
    "user 1 collects for each @xmath238 , for any @xmath220}$ ] where @xmath223 and @xmath224 , either @xmath225 or @xmath226 , whichever was transmitted in step 4 .",
    "thus user 1 collects another total of @xmath239 uncoded symbols .",
    "user 1 now has collected @xmath230 useful symbols , and has in his cache @xmath180 symbols of the same basis .",
    "it is seen that @xmath240    it only remains to show that for the second case , the transmissions in step 4 suffice to provide any missing segments of @xmath170 in user 1 s cache , possibly jointly with transmissions from @xmath170 in the first three steps .",
    "this is rather straightforward , since all file segments @xmath190 s with @xmath241 are transmitted uncoded in step 4 , unless @xmath242}}(\\mathcal{s})}<0 $ ] ; when the latter scenario occurs , a total of @xmath243}}(\\mathcal{s})|-1}$ ] uncoded symbols have already been transmitted in the set @xmath244}}(\\mathcal{s})}$ ] , and together with the @xmath245}}(\\mathcal{s})|}$ ] parity symbols encoding the set @xmath244}}(\\mathcal{s})}$ ] which were transmitted in the first three steps , user 1 can indeed recover all @xmath246}}(\\mathcal{s})|}$ ] symbols in @xmath244}}(\\mathcal{s})}$ ] .",
    "thus user 1 is able to recover all segments of @xmath247 , and the proof is complete .",
    "[ prop : degenerate ] for any @xmath248 , the afore - given caching strategy and transmission strategy achieve the memory - transmission pair @xmath249}{k(k-1)},\\frac{n(k - t)}{k}\\right).\\end{aligned}\\ ] ]    recall each file of unit size is partition into @xmath80 segment symbols , and each user caches @xmath180 symbols , and thus the memory usage is straightforwardly to calculate .",
    "it remains to calculate the total number of transmitted symbols .",
    "we only need to consider the first three steps of transmission when all files are being requested , since for the other cases where only a subset of files are requested , each transmission in step 4 corresponds to exactly one transmission in step 3 for the enhanced demands , and thus the rate remains the same as for the case of the enhanced demands .    clearly , in step 1 , the total number of transmitted uncoded symbols of file @xmath103 is @xmath250 in step 2 , the total number of transmitted linear combinations of file @xmath103 is given as @xmath251 in step 3 , the total number of transmitted linear combinations of file @xmath103 is given as @xmath252 note that @xmath253 because it is all the ways of choosing @xmath89 balls in a total of @xmath254 balls .",
    "thus the total transmissions amount to @xmath255 symbols .",
    "the proof can now be completed with a simple normalization by the number of segments in each file .",
    "the general caching strategy we provide does not enforce any special structure on the linear combinations , unlike the code given in the @xmath147 example .",
    "however , even for general parameters @xmath256 and the same range of parameter @xmath89 , we can indeed choose to use the semi - systematic format .",
    "more precisely , the first @xmath257 semi - systematic symbols in the cache of user @xmath34 are @xmath258 where the addition is in finite field @xmath41 .",
    "moreover , we use the same parameter @xmath43 , but choose @xmath259 and construct a @xmath260 systematic rank metric code , which is denoted as @xmath261 .",
    "the local parity symbols stored in user @xmath34 s cache are the parity symbols when encoding the set of file segment symbols @xmath262 using @xmath261 .",
    "the transmission strategy remains the same .    in order to prove the correctness of this caching variant , we only need to show that the corresponding matrix @xmath263 , similarly as in the proof of proposition [ prop : correctness ] , is also full rank",
    "this is again rather immediate . since the only difference is the columns corresponding to the semi - systematic symbols in the cache .",
    "however , it is easily seen that although the matrix @xmath263 is no longer block diagonal after the rearrangement of columns and rows , the new columns has non - zero entries on rows corresponding to @xmath190 ( in fact it has an identity matrix if we restrict it to these columns and rows with proper row and column indexing ) , while no other columns in @xmath263 have non - zero entries on these rows",
    ". thus indeed this variant of caching strategy is also valid ; a more precise proof is given in the appendix .",
    "we choose to present the general construction in the last section instead of this variant directly in order to emphasize the fact that the semi - systematic format is not fundamentally important in our construction .",
    "note that in the semi - systematic variant , the bound on the parameter @xmath86 can be made smaller , since the parameters of the rank metric code are reduced : choosing @xmath264 suffices here .      in the proposed code construction ,",
    "we rely on rank metric codes to guarantee certain full rank properties , and the overall code design problem essentially reduces to a rank counting problem on the proper basis . however , one obvious disadvantage of using rank metric codes in the construction is that the size of the field @xmath265 needs to be quite large . we can in fact replace the rank metric code with a generic systematic linear code , and directly require the full rank properties to hold . in this section ,",
    "we provide such a simple argument and show that a reduced field size is sufficient .",
    "let us consider the cache encoding for the @xmath34-th user .",
    "a total of @xmath43 symbols are present at this user , and a total of @xmath180 parity symbols are generated during the encoding . in this subsection , we shall assume that the entries of this @xmath266 encoding matrix are from @xmath39 , _",
    "i.e. , _ the same finite field as the set of mds codes . denote this matrix as @xmath267 , and its entry on the @xmath268-th row and @xmath269-th column as @xmath270 , which are to be determined ; note that this code is not necessarily a rank - metric code any longer .",
    "consider a specific set of demands @xmath271 , ( _ i.e. _ , the @xmath34-th user demands file @xmath272 ) , where all files are requested . in the delivery phase , the symbols user-@xmath34 collects during step 1 and step 2 are linear combinations of all the symbols present at this user .",
    "this can be represented also by a @xmath273 encoding matrix @xmath274 .",
    "the full rank condition in the proof of proposition [ prop : correctness ] essentially requires that the @xmath275 matrix @xmath276 $ ] being full rank .",
    "the determinant of the matrix @xmath276 $ ] can be expressed as a function of the coefficients @xmath270 s , _ i.e. _ @xmath277    by the proof of proposition [ prop : degenerate ] , the full rank condition for demands where only a subset of the files are requested is implied by the full rank condition for the enhanced demands . thus as long as the following polynomial has a non - zero solution , then the choice of coefficients @xmath278 is valid @xmath279    we can now invoke the following lemma .",
    "@xcite [ lem : nullstellansatz ] ( _ combinatorial nullstellansatz _ )",
    "let @xmath280 be a field , and let @xmath281 be a polynomial in @xmath282 $ ] .",
    "suppose the degree @xmath283 of @xmath284 is expressible in the form @xmath285 , where each @xmath286 is a non - negative integer and suppose that the coefficient of the monomial term @xmath287 is nonzero .",
    "then if @xmath288 are subsets of @xmath280 with sizes @xmath289 satisfying @xmath290 , then there exist elements @xmath291 such that @xmath292 .    in this lemma above , the condition that the coefficient of the monomial term @xmath287 is nonzero is equivalent to requiring @xmath281 to be not identically zero .",
    "we note that @xmath293 is indeed not identically zero , because the code construction previously given provides a non - zero assignment .",
    "since the degree of any indeterminate in each of @xmath294 is @xmath193 , the maximum among the degrees of a single indeterminate of the polynomial ( [ eqn : largepoly ] ) is upper bounded by the total number of demands where all files are requested , which is given by @xmath295 . here",
    "@xmath296 is the sterling number of the second kind @xcite , which counts the number of ways to partition a set of @xmath2 objects into @xmath0 non - empty subsets .",
    "hence by lemma  [ lem : nullstellansatz ] , it is possible to find a suitable assignment for @xmath297 , if the entries are picked from a finite field @xmath39 with @xmath298 .",
    "alternatively , we can simply count the total number of demands , instead those where all files are requested , and this leads to a looser bound @xmath299 on the field size .",
    "we suspect that this bound can be further reduced through a more careful analysis of the matrix structure , though so far our effort toward this goal does not bear much fruit .",
    "moreover , by allowing a larger number of cached symbols per user , codes in even smaller finite fields may be possible .",
    "we proposed a new coding scheme for the caching problem when @xmath8 , based on a combination of rank metric codes and mds codes .",
    "the performance of the scheme has a particularly simple form , and it provides new tradeoff points beyond known what are known in the literature . compared to known coded caching schemes , the proposed scheme uses coding for both caching and delivery , as well as larger finite field instead of finite field of cardinality 2 .",
    "an immediate variation of the proposed scheme is its decentralized counterpart , motivated by the investigation of the decentralized caching scheme @xcite , which is a variation of the centralized caching scheme in @xcite .",
    "we suspect that our scheme can also be extended to decentralized scenarios where certain random linear combinations of the file segments are cached , however it remains to be seen whether the performance such attained is still competitive .",
    "the key to the proof is to express the matrix @xmath50 of size @xmath51 in a more structured manner . for this purpose ,",
    "let us again consider the cache and decoding process at user 1 .",
    "first rearrange the systematic and parity symbols of the code @xmath96 , such that the @xmath180 cached symbol are indexed in the set @xmath300 ; similarly we arrange the columns the @xmath50 such that its first @xmath180 columns correspond to these cached symbols .",
    "the next rows and columns correspond to the symbols that user 1 collected during the step 1 transmission @xmath301}\\},\\quad n=2,3,\\ldots , n , \\end{aligned}\\ ] ] and there are a total of @xmath302 such symbols .    the next rows and columns correspond to a fixed @xmath303 and a fixed subset @xmath105}$ ] where @xmath176 and moreover @xmath177 .",
    "denote the parity check portion of generator matrix of the @xmath304 systematic mds as @xmath305 , which has dimension @xmath306 $ ] , and it is full rank since it is part of a generator matrix of an mds code and it has less columns than rows .",
    "now the matrix @xmath50 can be written in the following form @xmath307 where the identity matrix at the top - left has dimension @xmath308 , and we have enumerated the aforementioned matrix @xmath76 s for each @xmath33 by using the subscript as @xmath309 , and @xmath310 is the total number of such subsets @xmath76 when @xmath311 .",
    "it is now clear that the matrix @xmath50 is block diagonal and each block is full rank , and thus @xmath50 indeed has full rank .    for the semi - systematic variant of the caching scheme , the matrix @xmath263 is slightly different .",
    "first index the symbols @xmath312 using the set @xmath313 , and rearrange the columns and rows of @xmath263 such that they correspond to the top @xmath314 submatrix using the same order .",
    "next rearrange the systematic and parity symbols of the code @xmath261 , such that the @xmath315 cached symbol correspond to the next @xmath315 columns and rows .",
    "the rest of the @xmath263 matrix is arranged exactly as for the case @xmath50 .",
    "it is now clear that the matrix @xmath263 has the following form @xmath316 where the identity matrix @xmath317 is of dimension @xmath314 , and the identity matrix @xmath318 is of dimension @xmath319 , and the @xmath320 matrices have some nonzero entries but their exact forms are not important here ; the other off block - diagonal entries are all zeros .",
    "it is now clear that the matrix @xmath263 also has full rank ."
  ],
  "abstract_text": [
    "<S> we propose a new caching scheme where linear combinations of the file segments are cached at the users , for the cases where the number of files is no greater than the number of users . </S>",
    "<S> when a user requests a certain file in the delivery phase , the other file segments in the cached linear combinations can be viewed as interferences . </S>",
    "<S> the proposed scheme combines rank metric codes and maximum distance separable codes to facilitate the decoding and elimination of these interferences , and also to simultaneously deliver useful contents to the intended users </S>",
    "<S> . the performance of the proposed scheme can be explicitly evaluated , and we show that the tradeoff points achieved by this scheme can strictly improve known tradeoff inner bounds in the literature ; for certain special cases , the new tradeoff points can be shown to be optimal . </S>"
  ]
}