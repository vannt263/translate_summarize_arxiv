{
  "article_text": [
    "lorel was originally designed for querying semistructured data and has now been extended to xml data ; it was conceived and implemented at stanford university ( s. abiteboul , d. quass , j. mchugh , j. widom , j. wiener ) and its prototype is at http://www-db.stanford.edu/lore .",
    "it is a user - friendly language in the sql@xmath0oql style , it includes a strong mechanism for type coercion and permits very powerful path expressions , extremely useful when the structure of a document is not known in advance @xcite .",
    "xml - ql was designed at at&t labs ( a. deutsch , m. fernandez , d. florescu , a. levy , d. suciu ) ; its prototype is reachable at the url : http://www.research.att.com/sw/tools/xmlql as part of the strudel project .",
    "the xml - ql language extends sql with an explicit construct clause for building the document resulting from the query and uses the _ element patterns _ ( patterns built on top of xml syntax ) to match data in an xml document .",
    "xml - ql can express queries as well as transformations , for integrating xml data from different sources @xcite .",
    "xml - gl is a graphical query language , relying on a graphical representation of xml documents and dtds by means of labelled _ xml graphs_. it was designed at politecnico di milano ( s. ceri , s. comai , e. damiani , p. fraternali , s. paraboschi and l. tanca ) ; an implementation is ongoing .",
    "all the elements of xml - gl are displayed visually ; therefore , xml - gl is suitable for supporting a user - friendly interface ( similar to qbe ) @xcite .",
    "the extensible stylesheet language ( xsl ) has facilities that could serve as a basis for an xml query language .",
    "an xsl program consists of a collection of template rules ; each template rule has two parts : a pattern which is matched against nodes in the source tree and a template which is instantiated to form part of the result tree .",
    "xsl makes use of the expression language defined by xpath @xcite for selecting elements for processing , for conditional processing and for generating text .",
    "it was designed by the w3c xsl working group ( j. clark editor ) @xcite .",
    "xql is a notation for selecting and filtering the elements and text of xml documents .",
    "xql can be considered a natural extension to the xsl pattern syntax ; it is designed with the goal of being syntactically very simple and compact ( a query could be part of a url ) , with a reduced expressive power .",
    "it was designed by j. robie , texcel inc . , j. lapp , webmethods , inc . , and d. schach , microsoft corporation @xcite .",
    "several other languages for xml have been proposed , including xmas @xcite and xquery @xcite .",
    "the paper is organized as follows : in section  [ features ] , we describe how the languages support various orthogonal features ; in section  [ examples ] , we give some comparative examples of queries in the five languages ; in light of these discussions , section  [ qualities ] summarizes the desired qualities of the languages , and the concluding section  [ conclusions ] proposes a language taxonomy which shows , in a synthetic and effective way , a comparison of the expressive power of the five languages .",
    "in the following , we examine how the considered languages support the various features of database query languages .      1 .   _ specific data model . _",
    "the designers of lorel , xml - ql , xml - gl and xsl have felt the need of introducing their own data model explicitly , while xql relies on the data modeling features of xml . + .... lorel : yes     xml - ql : yes     xml - gl : yes     xsl : yes        xql : no .... + in the lorel data model , an xml element is a pair @xmath1 , where @xmath2 is a unique _ element identifier _ , and _ value _ is either an atomic text string or a complex value containing a string - valued _ tag _ , followed by a ( possibly empty ) ordered list of pairs of attribute names and atomic values ( representing xml attributes ) , followed by a ( possibly empty ) ordered list of pairs @xmath1 called _ crosslink subelements _ ( representing xml idref attributes ) , followed by a ( possibly empty ) ordered list of pairs @xmath1 called _ normal subelements _ ( representing the xml containment relationship ) . a graph representation of the data model is provided ; nodes correspond to the xml data elements and edges are designed as either _ crosslink edges _ or _ normal edges _ ; edges are labeled .",
    "each xml graph has one or more node designed as _",
    "entry points_. + in xml - ql , an xml document is modeled by an _ xml graph _ ; each node is associated to an _ object identifier _ ( oid ) ; edges are labeled with element tag identifiers , intermediate nodes are labeled with sets of attribute - value pairs representing attributes , leaves are labeled with values ( e.g. , cdata or pcdata ) ; each graph has a distinguished node called the _",
    "root_. + in xml - gl , an _",
    "xml graphical data model ( xml - gdm ) _ is used to represent both xml dtds and actual documents ; xml - gdm is also used for formulating queries .",
    "xml elements are represented as rectangles and properties as circles ; these include attributes ( as pairs of label and value ) as well as printable values cdata or pcdata ( with value but no label ) ; idrefs are denoted by black circles .",
    "edges between nodes represent containment or reference relationships .",
    "+ xsl operates on source , result and stylesheet documents using the same data model , defined in the xpath specification .",
    "an xml document is modeled as a tree that contains seven types of nodes ( root nodes , element nodes , text nodes , attribute nodes , namespace nodes , processing instruction nodes and comment nodes ) . for every type of node",
    ", there is a way of determining a _ string value _ for it , that is either part of the node or computed from the string - values of its descendants",
    ". some types of node also have an expanded name , which is a pair consisting of a local part and a namespace uri . + xql designers assume the `` xml implied data model '' , highlighting that each node has a type and either content or a value , and that semantic relationships between nodes can be hierachical ( parent / child , ancestor / descendant ) , positional ( absolute , relative , range ) and sequential ( precedes , immediately precedes ) @xcite . + all of the data models introduced in lorel , xml - ql",
    ", xml - gl and xsl may consider the elements in a given xml document as either unordered or ordered ; however , only xml - ql is able to query the ordering of the underlying data model , as discussed in point g.3 .",
    "+ the data models of lorel , xml - ql , and xml - gl are substantially equivalent ; the only significant difference concerns the management of idrefs , which is discussed next .",
    "xsl data model is a tree rather than a graph , so it can not be considered equivalent to the previous ones .",
    "2 .   _ differential management of idrefs . _ to support element sharing , xml reserves an attribute of type i d , which associates an unique key to the element .",
    "an attribute of type idref allows an element to refer to another element with the designed key .",
    "thus , idrefs are particular strings that can be interpreted as references between elements .",
    "with such an interpretation , it is possible to navigate from one element to another ; the data model supports _ object references _ , possibly cyclic .",
    "however , if idrefs are interpreted as strings , then nodes are connected only by containment relationships , and the data model does not support object references .",
    "these two interpretations of idrefs may lead to two different interpretations of the same query .",
    "we indicate this property as differential management of idrefs . +",
    ".... lorel : yes     xml - ql : no     xml - gl : no     xsl : no        xql : no .... + in lorel , there are two modes of viewing the data model : _ semantic _ and _ literal_. in the semantic mode , the database is viewed as an interconnected graph ; in the literal mode , the database is viewed as an xml tree , and idrefs are represented as textual strings .      1",
    ".   _ document selection . _ given a document and a query on the document , the document selection is the result of the application of the query to the document , picking up the elements , specified in the select expression of the query , that satisfy the query condition .",
    "+ .... lorel : yes     xml - ql : yes     xml - gl : yes     xsl : yes       xql : yes .... + of course this feature is supported by all the languages .",
    "we next introduce simplified descriptions of the syntax of the five languages .",
    "+ a query in lorel is structured according to the following , simplified grammar ( for full details , the reader can refer the @xcite paper ) : denotes alternatives . ] + .... ` select ' { select_expr } [ ` from ' { from_expr } ] [ ` where ' { where_expr } ] .... + select expressions , from expressions , and where expressions , as in oql , can in turn contain queries . +",
    "a simplified syntax for defining a query in xml - ql is : + .... query : : = ` where ' { predicate }            ` construct ' { ` { ` query ' } ' } .... + the result specified in the construct clause is a piece of xml document , fully specified in terms of tag names and content ; content is typically constructed from the object bindings which are determined by the predicate evaluation ( for full details on the xml - ql syntax , see @xcite ) .",
    "+ an xml - gl query consists of two sets of directed acyclic graphs displayed side by side and separated by a vertical line , where the lhs express the query sources ( which documents are selected ) and predicate ( which condition must be satisfied ) , while the rhs represents the construction ( which document is produced as result ) ; explicit connections or implicit homonims , where unambiguous , indicate the bindings between the lhs and rhs .",
    "+ in xsl , a template rule is specified within the xsl : template tags .",
    "the match attribute is a pattern that identifies the source node or nodes to which the rule applies .",
    "if it is omitted , the template rule is matched against all the nodes of the document .",
    "the following is the approximate skeleton of a template rule ( see @xcite for complete information ) : + .... ` < xsl : template '   [ ` match= ' pattern_expr ] ` > '      { ` < xsl : directive > ' }      { ` < result - elements > ' }     ` <",
    "/xsl : template > '   .... + where pattern@xmath3expr represents an expression written in the xpath language ( see section c.1 for more details ) , result - elements are the new elements tags produced in the result and xsl : directive is one of the following ( for a complete list , refer to @xcite ) : + .... ` < xsl : apply - templates'[`select= ' pattern_expr ] ` > ' ` < xsl : for - each ' ` select= ' pattern_expr ` > '         ` < xsl : value - of ' [ ` select= ' pattern_expr ] ` > ' ` < xsl : copy - of '    ` select= ' pattern_expr ` > ' .... + where the select attribute is used to process nodes selected by an expression instead of all the children of the current node .",
    "the xsl : apply - templates directive invokes the application of templates which are separately defined ; the xsl : for - each directive iterates on other directives which are statically nested within it ; the xsl : value - of directive extracts information from a pattern expression and converts it into a string ; the xsl : copy - of directive extracts information from a pattern expression and puts it into the result , with its original format .",
    "+ the basic xql syntax mimics the uri directory navigation syntax , but instead of specifying navigation through a physical structure , the navigation is through elements in the xml tree .",
    "a simplified syntax for xql is ( see @xcite for the complete syntax ) : + .... query : : = [ ` ./ ' | ` / ' | ` // ' | ` .// ' ]             element [ ` [ ' predicate ` ] ' ] [ path ] path   : : = [ ` / ' | ` // ' ] element             [ ` [ ' predicate ` ] ' ] [ path ] .... + therefore , a query is specified along a specific hierarchical path within the document ; predicates ( filters in xql terminology ) typically apply to the elements being accessed during the navigation along the path , although syntactically they may reach elements which are quite distant in the hierarchical structure .",
    "2 .   _ joins .",
    "_ a join condition compares two or more xml attributes or data belonging to the same document or to two different documents .",
    "the typical comparison ( equality ) is called equi - join . + .... lorel : yes     xml - ql : yes     xml - gl : yes     xsl : no        xql : no .... + in lorel , join conditions are fully supported , within the same document and among several documents .",
    "they are written in a sql - like form , by explicitly specifying the variables involved in the joins .",
    "+ in xml - ql , joins are implicitly expressed by means of the equality on variable names , which must match their value .",
    "they can range on the same document or on several different documents , defining arbitrary join conditions ( e.g. , @xmath4-way joins correspond to associating the same variable name to @xmath4 labels in the query ) . + in xml - gl , join conditions are expressed by connecting , by means of a comparison operator , two node leaves of xml documents , representing arbitrary attributes or data ; equi - joins are represented by edges pointing to the same node , possibly with two labels ( in many cases joined nodes have the same label ) .",
    "+ xsl does not allow neither joins nor semi - joins : each template rule currently addresses a single document and no connection conditions can be built within the same document or among several documents .",
    "+ xql allows semi - joins , i.e. , joins of data which is reachable along a path with other data which may be present in the same document ; it does not allow joins among different documents .",
    "for instance , it is possible to ask for all books whose author is the same as the author of moby dick within a given document : + .... book[author=//book[title=`moby dick']/author ] .... 3 .",
    "_ semantics of the query result . _",
    "the result of a query can be defined in terms of the current content of the database ( i.e. , by pointing to object identifiers of nodes in the document base ) or as a new document , which can be then queried and possibly updated independently . in general",
    ", we expect that all languages can adapt to either solutions .",
    "we anyway indicate the default solution adopted by the five languages .",
    "+ .... lorel : setofoids    xml - ql : xmldoc    xml - gl : xmldoc   xsl : xmldoc   xql : xmldoc   .... + in lorel , the result of a query is a set of object identifiers pointed by a new element .",
    "therefore , the standard interpretation is that the current state of objects being selected is the one present in the database , and subsequent accesses to the query result may give different documents .",
    "in lorel it is also possible to define views ( with clause ) , and in such case the query returns a document with all the nodes which are specified by the with clause . in the standard interpretations , xml - ql , xml - gl , xsl and xql",
    "return new documents , whose content is then independent on subsequent database manipulations .      1 .   _ partially specified path expressions .",
    "_ when querying semistructured data , especially when the exact structure is not known , it is convenient to use a form of `` navigational '' query based on path expressions .",
    "the most powerful form of path expression does not need to list all the elements of the path , as it uses wildcards and regular expressions : we denote it as a partially specified path expression .",
    "all languages support partially specified path expression and actually consider this feature as one of the most important in the language .",
    "+ .... lorel : yes     xml - ql : yes    xml - gl : partially    xsl :",
    "yes       xql : yes .... + in lorel , path expressions are very powerful and flexible ; they admit several _ unix - like wildcards_. each path expression must have a context ( the root element of the document ) .",
    "+ in xml - ql , path expressions are admitted within the tag specification and they permit the alternation , concatenation and kleene - star operators , similar to those used in regular expressions .",
    "xml - ql path expressions have the same expressive power as those of lorel . + in xml - gl ,",
    "the only path expressions supported are arbitrary containment , by means of a wildcard * as edge label ; this allows traversing the xml - gl graph reaching an element at any level of depth .",
    "+ in both xsl ( xpath language ) and xql , path expressions define relative and absolute locations .",
    "a relative location path consists of one or more location steps ( xml nodes ) separated by the child ` / ' operator or by the descendant ` // '",
    "an absolute location path has a ` / ' or ` // '",
    "optionally followed by a relative location path .",
    "admitted wildcards are both alternation and kleene - star closure operator .",
    "matching of partially specified expressions with cyclic data .",
    "_ partially specified expressions may be the source of infinite computations in the case of cyclic instances .",
    "therefore , it is common practice to specify halt conditions in the matching algorithm that binds object instances to path expressions when the same object binding is associated to the same query node more than once .",
    "+ .... lorel : yes   xml - ql : undefined   xml - gl : yes     xsl : no      xql : undefined .... + some systems do not mention the halt condition as part of the query language semantics ( we expect it to be part of the implementation ) . + in xsl , xsl : apply - templates are used to process only nodes that are descendants of the current node , and this can not result in non - terminating processing loops .",
    "however , non - terminating loops may arise when xsl : apply - templates is used to process elements that are not descendants of the current node . for example , the template rule : + .... < xsl : template    match=\"foo \" >    < xsl : apply - templates     select=\".\"/ > <",
    "/xsl : template > .... + matches the ` < foo > ` elements at all levels of nesting , including the level on which the matching occurs , yielding to a possible infinite call sequence .",
    "implementations may be able to detect such loops in some cases , but a stylesheet may enter a non - terminating loop , depending on the matching algorithm .      1 .",
    "_ existential quantification . _",
    "an existential predicate over a set of instances ( e.g. , bound to a variable ) is satisfied if at least one of the instances satisfies the predicate .",
    "+ .... lorel : yes     xml - ql : yes     xml - gl : yes    xsl : yes    xql : yes .... + in all languages , predicates are assumed as existentially quantified .",
    "2 .   _ universal quantification . _",
    "an universal predicate over a set of instances ( e.g. , bound to a variable ) is satisfied if all the instances satisfies the predicate .",
    "+ .... lorel : yes     xml - ql : no     xml - gl : no     xsl : no       xql : yes .... + in lorel , a variable can be universally quantified with the sql - like predicate for all .",
    "similarly , in xql universal quantification is obtained by prefixing a predicate expression with the keyword @xmath5 . in xml - ql and xml - gl universal quantification can not be expressed . in the xsl pattern language ,",
    "conditions can not be universally quantified .",
    "_ negation .",
    "_ the negation of a predicate over a set of instances is satisfied if none of the instances satisfies the predicate .",
    "+ .... lorel : yes     xml - ql : no     xml - gl : yes     xsl : yes       xql : yes .... + in lorel , a predicate is negated with the key - word not . in xml - gl , the negation is expressed graphically by a dashed edge ( see figure  [ exnot ] , where all professors without a name element are selected ) . in xql",
    ", the boolean operator @xmath6 negates the value of an expression within a filter , e.g. : + .... professor[$not$ name ] .... + its meaning is to select all the instances of the context associated with the filter with a negation predicate where the expression is false or not valuable ( e.g. , the name attribute is missing ) .",
    "xml - ql does not support negation ( it supports the unequal comparison operator in simple predicate expressions ) . in the xsl pattern language ,",
    "negation is expressed by means of the boolean function not that operates on a boolean value and returns a boolean ( before using the not function , a number , a string , a node set and an object must be first converted to their boolean value by applying the boolean function to them ) .",
    "reduction . _ given a document and a query on this document , the reduction prunes from the document those elements specified in the selection part of the query that satisfy its condition .",
    "+ .... lorel : no     xml - ql : no     xml - gl : no     xsl : no       xql : no .... + in lorel , xml - ql , xml - gl and xsl document reduction is not supported , also if it could be obtained through a construction which includes only the elements that should remain .",
    "this is feasible only when the underlying dtd of the document is known in advance . in xql",
    "no construction can be expressed , and therefore this approach is not feasible .      1 .",
    "_ building new elements_. a new xml element can be created through the query s construction mechanism .",
    "+ .... lorel : yes     xml - ql : yes     xml - gl : yes     xsl : yes       xql : no .... + in lorel , a new xml element is built by invoking the xml ( ) function with three parameters ( the first two not mandatory ) : the type , the label and the value(s ) , explicitly given through the oid or implicitly given specifying the query that generate it . + in xml - ql , restructuring is specified in the construct clause , which contains the new tags , constants , and variables ( bound from the xml - ql predicate evaluation ) of the new document , arbitrarily named . + in xml - gl , a new element is constructed through a new element box arbitrarily named .",
    "new elements can be added and arbitrarily named .",
    "+ in xsl , the new elements of the query result are specified through their tag names within the template rule . + in xql , no new element can be added to the existing ones , because no construction mechanism is provided .",
    "grouping_. elements of the result can be aggregated or reorganized as specified by means of special functions , such as group by . +",
    ".... lorel : yes     xml - ql : no     xml - gl : yes     xsl : no        xql : no .... + in lorel , the group by clause is that inherited from the oql language .",
    "objects extracted in xml - gl can be grouped according to the distinct values of one of their attributes or pcdata ; each class is associated to an element instance carrying the representative value of the class and then the rest of the xml tree as sub - element .",
    "apparently , a group - by clause is missing from the current descriptions of xml - ql , xsl and xql .",
    "oid invention with a skolem function . _ a skolem function associates to a given value a unique , generated oid ; the skolem function applied to the same value produces the same oid .",
    "skolem functions are needed for integrating existing documents into one .",
    "+ .... lorel : yes     xml - ql : yes     xml - gl : partially     xsl : no        xql : no .... + in lorel , xml - ql and xml - gl the skolem function takes as input a list of variables as argument and returns one unique element for every binding of elements and@xmath0or attributes to the argument . in lorel and xml - ql , the skolem function associates to each element a unique object identifier , that can be referenced by means of variables ; xml - gl , instead",
    ", does not provide the possibility of explicitly referencing the object identifiers . in xsl and xql ,",
    "the skolem functions are not used .      1 .",
    "_ aggregates . _",
    "aggregate functions compute a scalar value out of a multi - set of values .",
    "classical aggregates , supported by sql , are min , max , sum , count , avg .",
    "+ .... lorel : yes    xml - ql : no   xml - gl : yes   xsl : partially   xql : partially   .... + in lorel , the aggregate functions are present and fully implemented . in xml - ql , as of the current date they are not supported , but they are indicated as to be supported in the next version . in xml - gl ,",
    "aggregates are represented graphically . in xsl and xql",
    ", we found the method count ( ) that evaluates to the number of reference nodes that appear in the associated set .",
    "we are not aware of further aggregate functions . 2 .",
    "_ nesting of queries .",
    "_ as in sql , a query can be composed of nested subqueries .",
    "+ .... lorel : yes     xml - ql : yes     xml - gl : no     xsl : yes       xql : no .... + in lorel and in xml - ql , both inspired to the sql paradigm , queries can be nested at an arbitrary level . in xml - gl and xql",
    "nesting is not supported . in xsl , templates can be nested .",
    "3 .   _ set operations . _ as in sql , a query can be binary , composed of the union , intersection , or difference of subqueries .",
    "+ .... lorel : yes    xml - ql : partially    xml - gl : yes    xsl : yes      xql : yes .... + lorel supports union , difference , and intersection .",
    "xml - ql supports union and intersection but has no difference . in xml - gl , queries allow multiple graphs in the left side of the query ; this gives the expressive power of union .",
    "negation gives to xml - gl the expressive power of a difference , and intersection can be built by repeatedly applying negation .",
    "xsl admits union and negation in the pattern language ; there is not explicit intersection .",
    "xql supports union and intersection ; negation gives to xql the expressive power of a difference .      1 .",
    "_ ordering the result .",
    "_ consists of ordering the element instances according to the ascending or descending values of some data of the result , as performed by the order by clause in sql .",
    "+ .... lorel : yes     xml - ql : yes     xml - gl : yes     xsl : yes       xql : no .... + lorel and xml - ql may order the result is gained through the order by clause . in xml - gl , a leaf node can be labelled with asc , desc order and the elements extracted are in ascending or descending order with respect to that node ; multiple labelings are possible . in xsl , sorting is specified by adding xsl : sort elements as children of xsl : apply - templates or xsl : for - each .",
    "each xsl : sort specifies a sort key : the elements are ordered according to the specified sort keys , instead of being ordered on the basis of the document order ( default ) . in xql , ( as from available documentation ) there are no clauses concerning the order of the result .",
    "order - preserving result .",
    "_ consists of ordering the elements in the result in the same way as the original document .",
    "+ .... lorel : yes     xml - ql : yes     xml - gl : yes     xsl : yes       xql : yes .... + in lorel , the order by document order means that the retrieved elements are ordered in the same way as the original document , and the new ones are placed at the end of the document with an unspecified order among them ; otherwise , the order of elements in the result is left unspecified .",
    "xml - ql , xsl and xql produce ordered xml , therefore the order can be specified to be the same as the source document ( but such an order must be known ) .",
    "xml - gl produces an ordered xml element when one of the edges is marked ( then , the elements are produced in counterclockwise order w.r.t .",
    "the marked edge ) .",
    "3 .   _ querying the schema order .",
    "_ consists of asking for xml elements and@xmath0or attributes in a given order relationship , as they are specified in the schema .",
    "+ .... lorel : no     xml - ql : yes     xml - gl : no     xsl : no       xql : no .... + in xml - ql it is possible to query about the relative position of tags within documents ( asking if a tag precedes or follows another tag ) ; this is not supported by the other languages .",
    "_ querying the instance order .",
    "_ consists of asking for xml elements and@xmath0or attributes in a given order relationship , as they are appear in the instance of the document .",
    "this is accomplished adding to the language the range qualifier operator , that enables the selection of a single number ( or of a set of numbers ) instances .",
    "+ .... lorel : yes     xml - ql : no     xml - gl : no     xsl : yes       xql : yes .... + in lorel , the operator `` [ @xmath7range@xmath8 '' is introduced into both the query and update language and it is applied against both a path expression or variable . in xml - ql and xml - gl , it seems that there is no range selection . in xsl pattern language and in xql ,",
    "a specific node within a set of nodes is extracted simply enclosing the index ordinal within square brackets in the pattern .      1",
    ".   _ support of abstract data types .",
    "_ this feature concerns the necessity of embedding inside an xml query language specialized operations , i.e for selecting different kinds of multimedia content .",
    "+ .... lorel : yes     xml - ql : no     xml - gl : no     xsl : no        xql : no .... + lorel supports audio , video , images , and specialized data types such as jpeg , gif , and ps .",
    "2 .   _ type coercion . _",
    "this feature concerns the ability of implicit data casting among different types , as well as the ability to compare values represented with different type constructors ( e.g. , scalars , singleton sets , and lists with one only element ) . because of the nature of semistructured data ,",
    "the type coercion provided by an xml query language should be much more flexible than that of a database query language .",
    "+ .... lorel : yes     xml - ql : no     xml - gl : no     xsl : no        xql : partially .... + in lorel , comparison between objects and@xmath0or values is forced to do `` the most intuitive thing '' when comparing objects and values of different types .",
    "coercion rules are provided for the various atomic types and the corresponding predicates or functions .",
    "furthermore , a comparison between atomic objects , complex objects , and sets of objects is accepted when there is an obvious interpretation .",
    "+ in xql , two values are comparable only after explicit casting of them , as happens in a traditional programming language .",
    "the other languages do not mention type coercion .      1",
    ".   _ support of rdf and/or xml schemas .",
    "_ rdf and xml schemas are emerging standards for representation of metadata regarding xml documents and it may be desiderable to embed them into the query language . + .... lorel : no     xml - ql : no     xml - gl : no     xsl : no       xql : no .... 2 .   _",
    "support of xpointer and xlink_. intra - document and inter - document linking could influence the evolution of the xml query language ; a query should be able to give as result not only xml data , but also xml pointers and links .",
    "+ .... lorel : no     xml - ql : no     xml - gl : no     xsl : no       xql : no .... 3",
    ".   _ support of tag variables .",
    "_ this feature concerns the possibility of explicitly querying the tag name rather than the tag content .",
    "+ .... lorel : yes     xml - ql : yes     xml - gl : no     xsl : no        xql : no .... + in lorel , path expressions return into variables of a special _ path _ type the fully specified names of all paths that are reachable from the path expressions themselves .",
    "such names can be used for building the names of the query result using the unquote ( ) function . in xml - ql , variables can be associated to tags and then used to generate the tags of the result .      1 .",
    "_ support for insert , delete , and update of elements .",
    "_ + .... lorel : yes      xml - ql : no     xml - gl : yes     xsl : no         xql : no .... + lorel has an update language .",
    "it is possible to create and delete object names , create a new atomic or complex object , and modify the value of an existing object .",
    "update operations in xml - gl are graphically indicated as arrows labelled with i , d , u. each primitive ( except for delete that does not need the rhs ) has a lhs element and a rhs graph : the lhs is the target element of the operation and the rhs graph represents the values to be inserted or replaced by the primitive . in xml - ql ,",
    "xsl and xql there is no update language .",
    "in the following , we present a comparison of lorel , xml - ql , xml - gl and xql on the basis of the query examples originally proposed by david maier in a position paper `` database desiderata for an xml query language '' @xcite ; a preliminary version of the xml - ql examples were originally presented by peter fankhauser in a message to the xml query language mailing list ( message of dec 22 , 1998 ) .",
    "the underlying case study is that of a car dealer office , with documents from different auto dealers and brokers .",
    "the manufacturer documents list the manufacturer s name , year , and models with their names , front rating , side rating , and rank ; the vehicle documents list the vendor , make , year , color and price .",
    "we consider xml data of the form :    .... < manufacturer > < mn_name > mercury</mn_name >",
    "< year>1999</year > < model >   < mo_name > sable lt</mo_name > < front_rating>3.84</front_rating > < side_rating>2.14</side_rating > < rank>9</rank >",
    "< /model > .... < /manufacturer",
    ">    < vehicle > < vendor > scott thomason</vendor >",
    "< make > mercury</make > < model > sable lt</model > < year>1999</year >",
    "< color > metallic blue</color > .... < price>26800</price > < /vehicle > ....      _ we want to select and extract @xmath10 elements where some @xmath11 has @xmath12 less or equal to 10 .",
    "_    * 1a .",
    "lorel *    .... select m from nhsc.manufacturer m where m.model.rank < = 10 ....    * 1b .",
    "xml - ql *    .... where < manufacturer >         < model >           < rank>$r</rank >         < /model",
    ">        < /manufacturer >",
    "element_as $ m in               www.nhsc\\manufacturers.xml ,        $ r<=10 construct $ m ....    * 1c .",
    "xml - gl * see figure  [ query1 ] :    * 1d .",
    "xsl *    .... < xsl : template    match=\"/ \" >      < xsl : for each    select=\"manufacturer[model / rank<=10 ] \" >            < xsl : value - of     / >      < /xsl : for each > < /xsl : template > ....    * 1e .",
    "xql *    .... manufacturer[model / rank<=10 ] ....    * comments *    * in lorel , the result is a collection of manufacturer object identifiers . * in xml - ql",
    ", the query applies to the xml document www.nsch/manufacturers.xml .",
    "it matches every @xmath10 in the xml document that has at least one @xmath11 , whose @xmath12 is less or equal to 10 .",
    "the presentation of the result is a piece of xml document whose exact structure appears not to be defined in the references currently available .",
    "* in xml - gl , the query applies to the xml document www.nsch/manufacturers.xml ; it extracts all the occurrences of the manufacturer elements satisfying the conditions stated in the lhs side .",
    "the elements used in the rhs to construct the result are exactly those manufacturer objects retrieved in the lhs with all the sub - elements as appearing in the input xml documents ( but without including the elements pointed by idrefs links ) .",
    "the result is a new xml document enclosed within the standard element result . * in xsl",
    ", the rule applies to the root node and the xsl : for - each directive is instantiated for each manufacturer node having at least one model whose rank is less or equal to 10 . through the xsl : value - of instruction a text node",
    "is included in the result tree for each selected manufacturer element .",
    "* xql does the job pretty concisely , having a navigation pattern with a filter condition on the @xmath12 .",
    "the filter is existentially quantified .",
    "the result is conventionally enclosed within a standard element named xql : result . *",
    "summary : all languages cover the proposed example .",
    "_ from the @xmath10 elements , we want to drop those @xmath11 sub - elements whose @xmath12 is greater than 10",
    ". we also want to elide the @xmath13 and @xmath14 elements from the remaining models .",
    "_    * 2a .",
    "lorel *    .... select z.mn_name , z.year ,       ( select z.model.mo_name , z.model.rank        where   z.model.rank < = 10 ) from nhsc.manufacturer z ....    * 2b .",
    "xml - ql *    .... where < manufacturer >         < mn_name>$mn</mn_name >         < year>$y</year >        <",
    "/manufacturer > content_as",
    "$ m in               www.nhsc\\manufacturers.xml construct         < manufacturer >           < mn_name>$mn</mn_name >           < year>$y</year >           {   where < model >                      < mo_name>$mon</mo_name >                      < rank>$r</rank >",
    "< /model > in $ m ,                    $ r<=10              construct < model >                         < mo_name>$mon</mo_name >                         < rank>$r</rank >                       < /model",
    ">           }        < /manufacturer > ....    * 2c .",
    "xml - gl * see figure  [ query2 ] :    * 2d .",
    "xsl *    .... < xsl : template    match=\"manufacturer[model / rank<=10 ] \" >     < model >        < xsl : value - of    select=\"mo - name\"/ >        < xsl : value - of    select=\"rank\"/ >     < /model > < /xsl : template >      ....    * 2e .",
    "xql *    .... can not be expressed . ....",
    "* comments *    * in lorel the query consists of two nested subqueries one inside the other ; both are existentially quantified .",
    "* also in xml - ql , the job is performed by nesting two subqueries ; nesting occurs within the construct clause of the first query . *",
    "xml - gl has no nesting , so the query selects first the elements of @xmath10 that do not have a @xmath11 sub - element and puts them in the result ; then , it selects those elements having at least one @xmath11 element with suitable @xmath12 value and inserts them in the result , by including only the selected models . * in xsl",
    ", the template rule matches the manufacturer elements satisfying the condition and , then , constructs the new model elements with the subelements mo - name and rank . * in xql",
    ", the query can not be expressed neither as reduction nor as construction , because xql does not allow restructuring , nested queries or joins .",
    "* summary : this example indicates that current query languages lack of one relevant feature : reduction .",
    "all languages must resort to a solution based on the construction of the `` remainder '' of the document , rather than eliding some elements .",
    "this is possible only if the dtd of the document is known .",
    "xql does not support construction , so it can not use this solution .",
    "_ we want our query to generate pairs of @xmath10 and @xmath15 elements where @xmath16 = @xmath17 , @xmath18 = @xmath11 and @xmath19 = @xmath19 .",
    "_    * 3a .",
    "lorel *    .... temp:= select ( m , v ) as pair         from nhsc.manufacturer m , nhs.vehicle v         where m.mn_name = v. make         and    m.model.mo_name = v.model         and    m.year = v.year ....    * 3b .",
    "xml - ql *    .... where < manufacturer >         <",
    "mn_name>$mn</mn_name >",
    "< year>$y</year >         < model >             < mo_name>$mon</mo_name >         < /model",
    "> content_as $ mo        <",
    "/manufacturer > content_as",
    "$ m in               www.nhsc\\manufacturers.xml        < vehicle >           < model>$mon</model >           < year>$y</year >",
    "< make>$mn</make >        < /vehicle",
    "> content_as $ v in www.nhsc\\vehicles.xml       construct        < manufacturer >           < mn_name>$mn</mn_name >           < year>$y</year >           <",
    "vehiclemodel >              $ mo,$v           < /vehiclemodel",
    ">        < /manufacturer > ....    * 3c .",
    "xml - gl * see figure  [ query3 ] :    * 3d .",
    "xsl *    .... can not be expressed .",
    "....    * 3e .",
    "xql *    .... can not be expressed .",
    "....    * comments *    * in lorel , the join builds pairs of oids of the relevant documents after their joins . the joined elements are accessed creating a new entry point @xmath20 . * in xml - ql , a new piece of xml document is created and wrapped into the tags @xmath21 , with the content of the @xmath11 and @xmath15 elements that match on join conditions . * in xml - gl , the pairs from @xmath11 and @xmath15 are extracted and made the sub - elements of a new element named @xmath21 , which is placed inside the @xmath10 element . * in xsl , joins can not be expressed . * xql does not support joins . *",
    "summary : join is supported well by lorel , xml - ql and xml - gl ; xsl and xql lack the possibility of joining two documents .",
    "_ we want our query to collect @xmath22 elements listing their make , model , vendor , rank , and price , in this order .",
    "_    * 4a .",
    "lorel *    .... select xml(car : ( select x.vehicle.make , x.vehicle.model ,                   x.vehicle.vendor , x.manufacturer.rank ,                   x.vehicle.price                    from temp.pair x ) ) ....    * 4b .",
    "xml - ql *    .... where < manufacturer >         < mn_name>$mn</mn_name >         < vehiclemodel >            < model >                      < mo_name>$mon</mo_name >            < rank>$r</rank >            < /model",
    ">             < vehicle >            < price>$y</price >",
    "< vendor>$mn</vendor >            < /vehicle",
    ">          < /vehiclemodel",
    "/manufacturer > in www.nhsc\\queryresult3.xml construct        < car >           < make>$mn</make >",
    "< mo_name>$mon</mo_name >           < vendor>$v</vendor >           < rank>$r</rank >           <",
    "price>$p</price >        < /car > ....    * 4c .",
    "xml - gl * see figure  [ query4 ] :    * 4d .",
    "xsl *    .... < xsl : template    match=\"manufacturer \" >     < car >        < xsl : value - of   select=\"vehiclemodel / vehicle / make\"/ >        < xsl : value - of   select=\"vehiclemodel / model / mo - name\"/ >        < xsl : value - of   select=\"vehiclemodel / vehicle / vendor\"/ >        < xsl : value - of   select=\"vehiclemodel / model / rank\"/ >             < xsl : value - of   select=\"vehiclemodel / vehicle / price\"/ >         < /car",
    "> < /xsl : template > ....    * 4e .",
    "xql *    .... can not be expressed .",
    "....    * comments *    * in lorel , the elements are extracted in the order in which they appear in the query .",
    "the query result is associated with an element named @xmath23 by invoking the function @xmath24 . * xml - ql deals with the ordering of the result explicitly in the construct clause .",
    "* in xml - gl , a new @xmath22 element is introduced in the result and enriched with the corresponding sub - elements , which are ordered counterclock - wise by means of the graphic notation of marking one of the edges . * in xsl , the template rule matches the manufacturer elements and constructs in the result , the new car tags filled with the appropriate sub - elements . * in xql ,",
    "the query can not be written , as it includes a join . *",
    "summary : this is a less interesting query , again it shows that join and ordering are feasible with lorel , xml - ql , xml - gl , while joins are unfeasible with xsl and xql .",
    "besides the comparative review of features , summarized in table [ table1 ] , we can briefly discuss the desired qualities of query languages , and propose a relative ranking of the five languages .",
    "* _ declarativeness . _",
    "a query language is declarative when the specification of the query defines the content of the result rather than a strategy to compute it .",
    "according to the above definition , all the five query languages are declarative .",
    "lorel resembles oql and therefore a calculus - based language .",
    "xml - ql has variable unification as one of its ingredients and as such recalls a logic language , although with a very peculiar xml style .",
    "xml - gl recalls qbe .",
    "both xsl and xql make use of url - like patterns extensively . *",
    "_ expressive power .",
    "_ indicates how powerful is the language in expressing queries . from this perspective ,",
    "xml - ql and lorel are the two most powerful languages . according to the features that we have listed",
    ", lorel is more powerful for what concerns the differential management of idrefs , universal quantification , negation , aggregate management , abstract data types , type coercion , and updates ; xml - ql enables predicates on tag ordering that are lacking in lorel .",
    "both languages lack of a reduction operation and of support for rdf , xpointers , and xlinks , other emerging w3c standards .",
    "however , it appears that the missing features could be easily added to both languages so as to make them equally expressive .",
    "then , the two languages would have comparable semantics embedded within quite different syntaxes , as lorel is oql - like , while xml - ql queries resamble xml documents ; we may say that xml - ql is xml - like . + xml - gl is less powerful than both the above languages , mainly because of the limitations in supporting nested queries , certain specified path expressions , and skolem functions",
    ". however , the language supports what is naturally specified in a graphical formalism , and can be considered as a qbe - equivalent of the other two languages , in the sense that also qbe is less expressive than sql in the relational world , however capturing the essential expressive power of relational languages .",
    "+ xsl and xql are quite comparable in their expressive power , and less expressive than the other languages .",
    "+ xsl is a stylesheet language enabling a single document query language with transformation capabilities .",
    "it lacks joins , update operations and skolem functions .",
    "but it allows , with respect to xql , restructuring of documents .",
    "+ finally , xql captures a restricted class of queries ; its major limitations are the lack of support of joins and result construction .",
    "the class of queries supported by xql are those relative to a single document being tested and projected out when the test is satisfied .",
    "+ a visualization of the expressive power of languages is given in figure  [ lack ] .",
    "* _ ease of use .",
    "_ this property indicates how easy it is to write and/or to understand a query for an xml query programmer . from this perspective , xml - gl is easy to read and to understand , as it is associated to a graphic interface , while xql is also simple and easy , but much less powerful ; these two languages are the easiest to use . with respect to xql , xsl is less readable because of the instruction tags and of the template rules .",
    "lorel and xml - ql are comparable with respect to the ease of formulation , although database experts will be probably more familiar with the lorel style , and xml experts will probably be more familiar with xml - ql .",
    "one should also notice , e.g. , from the examples of section 3 , that xml - ql queries are rather verbose if compared with lorel queries .",
    "the five reviewed languages can be organized in a taxonomy , where :    * lorel and xml - ql are the oql - like and xml - like representatives of * class 2 of expressive query languages for xml * , playing the same role as high - level sql standards and languages ( e.g. , sql2 ) in the relational world .",
    "our study indicates that they need certain additions in order to become equivalent in power , in which case it would be possible to translate between them .",
    "currently , a major portion of the queries that they accept can be translated from any language to another . *",
    "xsl and xql are representative of * class 1 of single - document query languages * , playing the same role as core sql standards and languages ( e.g. , the sql supported by odbc ) in the relational world ; as a major limitation , we recall that they can not join two different documents .",
    "their expressive power is included within the expressive power of class 2 languages .",
    "their rationale is to extract information from a single document , to be expressed as a single string and passed as one of the url parameters .",
    "* xml - gl can be considered as a * graphical query interface to xml * , playing the same role as graphical query interfaces ( e.g. , qbe ) in the relational world .",
    "the queries being supported by xml - gl are the most relevant queries supported by class 2 languages .",
    "when the common features ( as initially identified in this paper ) will become fully understood , it will be possible to envision a collection of translators between languages of the same class , and/or between languages of different classes , and/or from the graphic language xml - gl to the programmative languages of classes 1 and 2 . in this way",
    ", query languages for xml will constitute a language hierarchy similar to the one existing for relational and object - relational databases .",
    "& yes & yes & yes & yes & no + & yes & no & no & no & no + & yes & yes & yes & yes & yes + & yes & yes & yes & no & no + & set of oids & xml doc & xml doc & xml doc & xml doc + & yes & yes & partially & yes & yes + & yes & undefined & yes & no & undefined + & yes & yes & yes & yes & yes + & yes & no & no & no & yes + & yes & no & yes & yes & yes + & no & no & no & no & no + & yes & yes & yes & yes & no + & yes & no & yes & no & no + & yes & yes & partially & no & no + & yes & no & yes & partially & partially + & yes & yes & no & yes & no + & yes & partially & yes & yes & yes + & yes & yes & yes & yes & no + & yes & yes & yes & yes & yes + & no & yes & no & no & no + & yes & no & no & yes & yes + & yes & no & no & no & no + & yes & no & no & no & partially + & no & no & no & no & no + & no & no & no & no & no + & yes & yes & no & no & no + & yes & no & yes & no & no +",
    "we like to acknowledge the suggestions and criticisms of serge abiteboul , sara comai , jason mchugh , yannis papakonstantinou , dan suciu , letizia tanca and jennifer widom to an early presentation of this survey .",
    "we are particularly grateful to jennifer and jason for their extensive advices and significant contributions .",
    "s. ceri , s. comai , e. damiani , p. fraternali , s. paraboschi and l. tanca .",
    "xml - gl : a graphical language for querying and restructuring www data . in _ proc . of 8th int .",
    "world wide web conference _ , www8 , toronto , canada , may 1999 , http://www8.org/fullpaper.html .",
    "s. j. derose .",
    "xquery : a unified syntax for linking and querying general xml . in _ proc . of the query languages workshop ( ql98 )",
    "_ , cambridge , mass . ,",
    "dec.98 , http://www.w3.org/tands/ql/ ql98/pp / xquery.html .",
    "a. deutsch , m. fernandez , d. florescu , alon levy and d.suciu .",
    "xml - ql : a query language for xml . in _ proc . of the query languages",
    "workshop(ql98 ) _ , cambridge , mass . , december 1998 , http://www.w3.org / tr/1998/note - xml - ql-19980819/.        r. goldman , j. mchugh , and j. widom . from semistructured data to xml : migrating the lore data model and query language . in _ proc . of the 2nd international workshop on the web and databases _ ( webdb 99 ) , philadelphia , pennsylvania , june 1999 .",
    "b. ludscher , y. papakonstantinou , p. velikhov and v. vianu .",
    "view definition and dtd inference for xml . in _",
    "post - icdt workshop on query processing for semistructured data and non - standard data formats _ , jerusalem , 1999 , http://www-rodin.inria.fr/external/ssd99/workshop.html .",
    "w3c xsl working group .",
    "the query language position paper of the xsl working group . in _ proc . of the query languages workshop _ , cambridge , mass.,dec.1998 , http://www.w3.org/tands/ql/ ql98/pp / xsl - wg - position.html ."
  ],
  "abstract_text": [
    "<S> xml is becoming the most relevant new standard for data representation and exchange on the www . </S>",
    "<S> novel languages for extracting and restructuring the xml content have been proposed , some in the tradition of database query languages ( i.e. sql , oql ) , others more closely inspired by xml . </S>",
    "<S> no standard for xml query language has yet been decided , but the discussion is ongoing within the world wide web consortium and within many academic institutions and internet - related major companies . </S>",
    "<S> we present a comparison of five , representative query languages for xml , highlighting their common features and differences .    </S>",
    "<S> [ section ] [ theorem]definition [ theorem]criterion [ theorem]lemma [ theorem]property [ theorem]corollary [ theorem]algorithm [ theorem]example </S>"
  ]
}