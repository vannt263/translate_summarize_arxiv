{
  "article_text": [
    "to start students thinking of functions as column vector - like objects , it is very useful to introduce them to plotting and integrating functions in the matlab environment . interestingly enough",
    ", the plot command in matlab takes vectors as its basic input element .",
    "as shown in program 1 below , to plot a function @xmath26 in matlab , we first generate two vectors : a vector of @xmath27 values and a vector of @xmath28 values where @xmath29 . the command @xmath30 then generates a plot window containing the points @xmath31 displayed as red points ( @xmath32 ) . having specified both @xmath27 and @xmath28 , to evaluate the definite integral @xmath33 , we need only sum all the @xmath28 values and multiply by @xmath34",
    ".    .... % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * % program 1 : numerical integration and plotting using matlab % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * n=1000000 ;                % no . of points l=500 ;                    % range of x : from -l to l x = linspace(-l , l , n ) ' ;      % generate column vector with n                           % x values ranging from -l to l dx = x(2)-x(1 ) ;             % distance between adjacent points    % alternative trial functions : % to select one , take out the comment command % at the beginning .",
    "% y = exp(-x.^2/16 ) ;                  % gaussian centered at x=0 % y=((2/pi)^0.5)*exp(-2*(x-1).^2 ) ; % normed gaussian at x=1 % y=(1-x.^2).^-1 ;             % symmetric fcn which blows up at x=1 % y=(cos(pi*x)).^2 ;           % cosine fcn % y = exp(i*pi*x ) ;              % complex exponential % y = sin(pi*x / l).*cos(pi*x / l);% product of sinx times cosx % y = sin(pi*x / l).*sin(pi*x / l);% product of sin(nx ) times sin(mx ) % a=100 ; y = sin(x*a)./(pi*x ) ; % rep . of delta fcn a=20",
    "; y=(sin(x*a).^2)./(pi*(a*x.^2));% another rep . of delta fcn",
    "% observe : numerically a function y(x ) is represented by a vector !",
    "% plot a vector / function plot(x , y ) ;                              % plots vector y vs. x % plot(x , real(y),'r ' , x , imag(y ) , ' b ' ) ; % plots real&imag y vs. x axis([-2 2 0 7 ] ) ;     % optimized axis parameters for sinx^2/pix^2 % axis([-2 2 -8 40 ] ) ; % optimized axis parameters for sinx / pix    % numerical integration sum(y)*dx         % simple numerical integral of y trapz(y)*dx       % integration using trapezoidal rule ....",
    "just as @xmath26 is represented by a column vector @xmath35 in the computer , for numerical purposes a differential operator @xmath36 acting on @xmath26 is reresented by a matrix @xmath37 that acts on @xmath35 . as illustrated in program 2 , matlab provides many useful , intuitive , well - documented commands for generating matrices @xmath37 that correspond to a given @xmath38.@xcite two examples are the commands @xmath39 and @xmath40 .",
    "the command @xmath41 generates an @xmath42 matrix of ones . the command @xmath43 generates a matrix with the elements of the vector @xmath4 placed along the @xmath44 diagonal and zeros everywhere else .",
    "the central diagonal corresponds to @xmath45 , the diagonal above the center one corresponds to @xmath46 , etc ... ) .",
    "an exercise we suggest is for students to verify that the derivative matrix is not hermitian while the derivative matrix times the imaginary number @xmath47 is .",
    "this can be very valuable for promoting student understanding if done in conjunction with the proof usually given for the differential operator .",
    ".... % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * % program 2 : calculate first and second derivative numerically % showing how to write differential operator as a matrix % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * % parameters for solving problem in the interval 0",
    "< x < l l = 2*pi ;                    % interval length n = 100 ;                     % no . of coordinate points x = linspace(0,l , n ) ' ;        % coordinate vector dx = x(2 ) - x(1 ) ;            % coordinate step    % two - point finite - difference representation of derivative d=(diag(ones((n-1),1),1)-diag(ones((n-1),1),-1))/(2*dx ) ; % next modify d so that it is consistent with f(0 ) = f(l ) = 0 d(1,1 ) = 0 ; d(1,2 ) = 0 ; d(2,1 ) = 0 ; % so that f(0 ) = 0 d(n , n-1 ) = 0 ; d(n-1,n ) = 0 ; d(n , n ) = 0 ; % so that f(l ) = 0    % three - point finite - difference representation of laplacian lap = ( -2*diag(ones(n,1),0 ) + diag(ones((n-1),1),1 ) ...                             + diag(ones((n-1),1),-1))/(dx^2 ) ; % next modify lap so that it is consistent with f(0 ) = f(l ) = 0 lap(1,1 ) = 0 ; lap(1,2 ) = 0 ; lap(2,1 ) = 0 ;     %",
    "so that f(0 ) = 0 lap(n , n-1 ) = 0 ; lap(n-1,n ) = 0 ; lap(n , n ) = 0;% so that f(l ) = 0    % to verify that d*f corresponds to taking the derivative of f % and lap*f corresponds to taking a second derviative of f , % define",
    "f = sin(x ) or choose your own f",
    "f = sin(x ) ; % and try the following : df = d*f ; lapf = lap*f ; plot(x , f,'b',x , df,'r ' , x , lapf,'g ' ) ; axis([0 5 -1.1 1.1 ] ) ;            % optimized axis parameters    % to display the matrix d on screen , simply type d and return ... d    % displays the matrix d in the workspace lap      % displays the matrix lap ....",
    "when solving eq .  ( [ eq : one ] ) , the method of separation of variables entails that as an intermediate step we look for the separable solutions @xmath48 where @xmath49 satisfies the time - independent schrodinger equation @xmath50 in solving eq .",
    "( [ eq : five ] ) we are solving for the eigenvalues @xmath51 and eigenvectors @xmath49 of @xmath25 . in matlab ,",
    "the command @xmath52=eig(h)$ ] does precisely this : it generates two matrices .",
    "the first matrix @xmath53 has as its columns the eigenvectors @xmath49 .",
    "the second matrix @xmath51 is a diagonal matrix with the eigenvalues @xmath54 corresponding to the eigenvectors @xmath55 placed along the central diagonal .",
    "we can use the command @xmath56 to convert this matrix into a column vector . in program 3 , we solve for the eigenfunctions and eigenvalues for the infinite square well hamiltonian . for brevity ,",
    "we omit the commands setting the parameters @xmath57 and @xmath34 .    .... % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * % program 3 : matrix representation of differential operators , % solving for eigenvectors & eigenvalues of infinite square well % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * % for brevity we omit the commands setting the parameters l , n ,   % x and dx ; we also omit the commands defining the matrix lap .",
    "% these would be the same as in program 2 above .",
    "% total hamiltonian where hbar=1 and m=1 hbar = 1 ; m = 1 ; h = -(1/2)*(hbar^2/m)*lap ; % solve for eigenvector matrix v and eigenvalue matrix e of h [ v , e ] = eig(h ) ;    % plot lowest 3 eigenfunctions plot(x , v(:,3),'r',x , v(:,4),'b',x , v(:,5),'k ' ) ; shg ; e        % display eigenvalue matrix diag(e )      % display a vector containing the eigenvalues ....",
    "note that in the matlab syntax the object @xmath58 specifies the column vector consisting of all the elements in column 3 of matrix @xmath53 .",
    "similarly @xmath59 is the row vector consisting of all elements in row 2 of @xmath53 ; @xmath60 is the element at row 3 , column 1 of @xmath53 ; and @xmath61 is a row vector consisting of elements @xmath62 , @xmath63 and @xmath64 .",
    "numerical solution of eq .",
    "( [ eq : one ] ) is not limited to any particular potential .",
    "program 4 gives example matlab codes solving the time independent schrodinger equation for finite square well potentials , the harmonic oscillator potential and even for potentials that can only solved numerically such as the quartic potential @xmath65 . in order to minimize the amount of ram required",
    ", the codes shown make use of sparse matrices , where only the non - zero elements of the matrices are stored .",
    "the commands for sparse matrices are very similar to those for non - sparse matrices .",
    "for example , the command @xmath52=eigs ( h , nmodes .. )$ ] provides the @xmath66 lowest energy eigenvectors @xmath53 of of the sparse matrix @xmath25 .",
    ".... % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * % program 4 : find several lowest eigenmodes v(x ) and   % eigenenergies e of 1d schrodinger equation %          -1/2*hbar^2/m(d2/dx2)v(x ) + u(x)v(x ) = ev(x )   % for arbitrary potentials u(x ) % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * % parameters for solving problem in the interval -l < x < l % parameters : l = 5 ;                       % interval length n = 1000 ;                    % no of points x = linspace(-l , l , n ) ' ;       % coordinate vector dx = x(2 ) - x(1 ) ;            % coordinate step    % potential , choose one or make your own u = 1/2 * 100*x.^(2 ) ;     % quadratic harmonic oscillator potential % u = 1/2*x.^(4 ) ;        % quartic potential    % finite square well of width 2w and depth given % w = l/50 ; % u = -500*(heaviside(x+w)-heaviside(x - w ) ) ;    % two finite square wells of width 2w and distance 2a apart % w = l/50 ; a=3*w ; % u = -200*(heaviside(x+w - a ) - heaviside(x - w - a ) ...",
    "%               + heaviside(x+w+a ) - heaviside(x - w+a ) ) ;    % three - point finite - difference representation of laplacian   % using sparse matrices , where you save memory by only   % storing non - zero matrix elements e = ones(n,1 ) ; lap = spdiags([e -2*e e],[-1 0 1],n , n)/dx^2 ;    % total hamiltonian hbar = 1 ; m = 1 ;       % constants for hamiltonian h = -1/2*(hbar^2/m)*lap + spdiags(u,0,n , n ) ;       % find lowest nmodes eigenvectors and eigenvalues of sparse matrix nmodes = 3 ; options.disp = 0 ; [ v , e ] = eigs(h , nmodes,'sa',options ) ;    % find eigs   [ e , ind ] = sort(diag(e));% convert e to vector and sort low to high v = v(:,ind ) ;            % rearrange corresponding eigenvectors    % generate plot of lowest energy eigenvectors v(x ) and u(x )   usc = u*max(abs(v(:)))/max(abs(u ) ) ;        % rescale u for plotting plot(x , v , x , usc,'--k ' ) ;           % plot v(x ) and rescaled u(x ) % add legend showing energy of plotted v(x )   lgnd_str = [ repmat('e = ' , nmodes,1),num2str(e ) ] ;   legend(lgnd_str )                 % place lengend string on plot   shg ....    fig .",
    "[ fig1 ] shows the plot obtained from program 4 for the potential @xmath67 .",
    "note that the 3 lowest energies displayed in the figure are just as expected due to the analytic formula @xmath68 with @xmath69 and @xmath70 rad / s .    0.1 cm   _ _ a__nd a scaled version of the potential @xmath71 .",
    "the corresponding energies displayed within the figure legend , 4.99969 , 14.9984 and 24.9959 , are , within rounding error , precisely those expected from eq .",
    "( [ eq : harmonic ] ) for the three lowest - energy modes .",
    "[ fig1 ] , title=\"fig:\",width=302 ] 0.1 cm",
    "when doing numerical calculations , it is important to minimize the effect of rounding errors by choosing units such that the variables used in the simulation are of the order of unity . in the programs presented here , our focus being undergraduate physics students , we wanted to avoid unnecessarily complicating matters . to make the equations more familiar to the students , we explicitly left constants such as @xmath72 in the formulas and chose units such that @xmath73 and @xmath74 . we recognize that others may have other opinions on how to address this issue . an alternative approach used in research",
    "is to recast the equations in terms of dimensionless variables , for example by rescaling the energy to make it dimensionless by expressing it in terms of some characteristic energy in the problem .",
    "in a more advanced course for graduate students or in a course in numerical methods , such is an approach which would be preferable .",
    "the separable solutions @xmath75 are only a subset of all possible solutions of eq .",
    "( [ eq : one ] ) .",
    "fortunately , they are complete set so that we can construct the general solution _ via _ the linear superposition @xmath76 where @xmath77 are constants and the sum is over all possible values of @xmath51 . the important difference between the separable solutions ( [ eq : four ] ) and",
    "the general solution ( [ eq : six ] ) is that the probability densities derived from the general solutions are time - dependent whereas those derived from the separable solutions are not .",
    "a very apt demonstration of this is provided in the program 5 which calculates the time - dependent probability density @xmath78 for a particle trapped in a a pair of finite - square wells whose initial state @xmath79 is set equal to the the equally - weighted superposition @xmath80 of the ground state @xmath81 and first excited state @xmath82 of the double well system . as snapshots of the program output show in fig .",
    "[ fig2 ] , the particle is initially completely localized in the rightmost well . however , due to @xmath83 , the probability density @xmath84   \\label{eq : osc}\\end{aligned}\\ ] ] is time - dependent , oscillating between the @xmath85 that corresponds to the particle being entirely in the right well @xmath86 and @xmath85 for the particle being entirely in the left well @xmath87 by observing the period with which @xmath88 oscillates in the simulation output shown in fig .",
    "[ fig2 ] students can verify that it is the same as the period of oscillation @xmath89 expected from eq .",
    "( [ eq : osc ] ) .    0.1 cm    .... % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * % program 5 : calculate probability density as a function of time % for a particle trapped in a double - well potential % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *    % potential due to two square wells of width 2w   % and a distance 2a apart w = l/50 ; a = 3*w ; u = -100 * ( heaviside(x+w - a ) - heaviside(x - w - a ) ...",
    "+ heaviside(x+w+a ) - heaviside(x - w+a ) ) ;    % finite - difference representation of laplacian and hamiltonian , % where hbar = m = 1 .",
    "e = ones(n,1 ) ; lap = spdiags([e -2*e e],[-1 0 1],n , n)/dx^2 ; h = -(1/2)*lap + spdiags(u,0,n , n ) ;    % find and sort lowest nmodes eigenvectors and eigenvalues of h nmodes = 2 ; options.disp = 0 ; [ v , e ] = eigs(h , nmodes,'sa',options ) ;   [ e , ind ] = sort(diag(e));% convert e to vector and sort low to high v = v(:,ind ) ;            % rearrange coresponding eigenvectors % rescale eigenvectors so that they are always   % positive at the center of the right well     for c = 1:nmodes         v(:,c ) = v(:,c)/sign(v((3*n/4),c ) ) ;     end    % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * % compute and display normalized prob .",
    "density rho(x , t ) % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * % parameters for solving the problem in the interval 0 < t < tf tf = 10 ;                   % length of time interval nt = 100 ;                  % no . of time points t = linspace(0,tf , nt ) ;     % time vector    % compute probability normalisation constant ( at t=0 )    psi_o = 0.5*v(:,1)+0.5*v(:,2 ) ;     % wavefunction at t=0    sq_norm = psi_o'*psi_o*dx ;         % square norm = |<ff|ff>|^2    usc = u*max(abs(v(:)))/max(abs(u ) ) ;    % rescale u for plotting     % compute and display rho(x , t ) for each time t for t=1:nt ;     % time index parameter for stepping through loop    % compute wavefunction psi(x , t ) and rho(x , t ) at t = t(t )    psi = 0.5*v(:,1)*exp(-i*e(1)*t(t ) ) ...",
    "+ 0.5*v(:,2)*exp(-i*e(2)*t(t ) ) ;    rho = conj(psi).*psi / sq_norm ;    % normalized probability density      % plot rho(x , t ) and rescaled potential energy usc    plot(x , rho,'o - k ' , x , usc,'.-b ' ) ; axis([-l/8 l/8 -1 6 ] ) ;    lgnd_str = [ repmat('t = ' , 1,1),num2str(t ) ] ;     text(-0.12,5.5,lgnd_str , ' fontsize ' , 18 ) ;    xlabel('x [ m ] ' , ' fontsize ' , 24 ) ;     ylabel('probability density [ 1/m]','fontsize ' , 24 ) ;         pause(0.05 ) ;                     % wait 0.05 seconds end ....",
    "wavepackets are another time - dependent phenomenon encountered in undergraduate quantum mechanics for which numerical solution techniques have been typically advocated in the hopes of promoting intuitive acceptance and understanding of approximations necessarily invoked in more formal , analytic treatments .",
    "program 6 calculates and displays the time evolution of a wavepacket for one of two possible potentials , either @xmath90 or a step potential @xmath91 .",
    "the initial wavepacket is generated as the fast fourier transform of a gaussian momentum distribution centered on a particular value of the wavevector @xmath92 . because the wavepacket is composed of a distribution of different @xmath93s , different parts of the wavepacket move with different speeds , which leads to the wave packet spreading out in space as it moves .    while there is a distribution of velocities within the wavepacket , two velocities",
    "in particular are useful in characterizing it .",
    "the phase velocity @xmath94 is the velocity of the plane wave component which has wavevector @xmath92 .",
    "the group velocity @xmath95 is the velocity with which the expectation value @xmath96 moves and is the same as the classical particle velocity associated with the momentum @xmath97 .",
    "choosing @xmath90 , students can modify this program to plot @xmath96 vs @xmath98 .",
    "they can extract the group velocity from their numerical simulation and observe that indeed @xmath99 for a typical wave packet .",
    "students can also observe that , while @xmath100 matches the particle speed from classical mechanics , the wavepacket spreads out as time elapses .",
    ".... % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * % program 6 : wavepacket propagation using exponential of h % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * % parameters for solving the problem in the interval 0 < x < l l = 100 ;                         % interval length n = 400 ;                         % no of points x = linspace(0,l , n ) ' ;            % coordinate vector dx = x(2 ) - x(1 ) ;                % coordinate step    % parameters for making intial momentum space wavefunction phi(k ) ko = 2 ;                       % peak momentum a = 20 ;                       % momentum width parameter dk = 2*pi / l ;                  % momentum step km = n*dk ;                      % momentum limit k = linspace(0,+km , n ) ' ;         % momentum vector    % make psi(x,0 ) from gaussian kspace wavefunction phi(k ) using   % fast fourier transform :   phi = exp(-a*(k - ko).^2).*exp(-i*6*k.^2 ) ; % unnormalized phi(k ) psi = ifft(phi ) ; % multiplies phi by expikx and integrates vs. x psi = psi / sqrt(psi'*psi*dx ) ;             % normalize the psi(x,0 )    % expectation value of energy ; e.g. for the parameters   % chosen above < e > = 2.062 .",
    "avge = phi'*0.5*diag(k.^2,0)*phi*dk/(phi'*phi*dk ) ;     % choose potential u(x ) : either u = 0 or   % u = step potential of height avge that is located at x = l/2   % u = 0*heaviside(x-(l/2 ) ) ;   % free particle wave packet evolution u = avge*heaviside(x-(l/2 ) ) ;     % scattering off step potential    % finite - difference representation of laplacian and hamiltonian e = ones(n,1 ) ; lap = spdiags([e -2*e e],[-1 0 1],n , n)/dx^2 ; h = -(1/2)*lap + spdiags(u,0,n , n ) ;    % parameters for computing psi(x , t ) at different times 0 < t <",
    "tf nt = 200 ;            % no . of time",
    "steps tf = 29 ; t = linspace(0,tf , nt ) ; % time vector dt = t(2)-t(1 ) ;          % time step hbar = 1 ;    % time displacement operator e = exp(-ihdt / hbar ) e = expm(-i*full(h)*dt / hbar ) ;    % time desplacement operator    % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * % simulate rho(x , t ) and plot for each t % * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * for t = 1:nt ;          % time index for loop      % calculate probability density rho(x , t )      psi = e*psi ;             % calculate new psi from old psi      rho = conj(psi).*psi ;    % rho(x , t )        plot(x , rho,'k ' ) ;      % plot rho(x , t ) vs. x      axis([0 l 0 0.15 ] ) ;   % set x , y axis parameters for plotting      xlabel('x [ m ] ' , ' fontsize ' , 24 ) ;       ylabel('probability density [ 1/m]','fontsize ' , 24 ) ;        pause(0.05 ) ;          % pause between each frame displayed end    % calculate reflection probability r=0 ; for a=1:n/2 ;      r = r+rho(a ) ; end r = r*dx ....    in program 6 , we propagate the wave function forward _ via _ the formal solution @xmath101 where the hamiltonian matrix @xmath25 is in the exponential .",
    "this solution is equivalent to eq .",
    "( [ eq : five ] ) , as as can be shown by simple substitution . moreover , matlab has no trouble exponentiating the matrix that numerically representing the hamiltonian operator as long as the matrix is small enough to fit in the available computer memory .",
    "even more interestingly , students can use this method to investigate scattering of wavepackets from various potentials , including the step potential @xmath102 . in fig .",
    "[ fig3 ] , we show the results of what happens as the wavepacket impinges on the potential barrier .",
    "the parameters characterizing the initial wavepacket have been deliberately chosen so that the wings do not fall outside the simulation area and initially also do not overlap the barrier on the right . if @xmath103 , the wavepacket is completely reflected from the barrier . if @xmath104 , a portion of the wave is is reflected and a portion is transmitted through . if @xmath105 , almost all of the wave is transmitted .",
    "0.05 cm    0.1 cm   _ vs. _ @xmath106 .",
    "the dashed line is simply eq .",
    "( [ eq : eight ] ) where we subsitute @xmath107 , the solid line is eq .",
    "( [ eq : eight ] ) averaged over the energy distribution in the incident wavepacket , and the points are numerical results obtained using program 6 , where the horizontal distance between points is @xmath108 where @xmath109 is the standard deviation of the energy distribution in the wavepacket .",
    "[ fig4 ] , title=\"fig:\",width=321 ] 0.1 cm    in fig .",
    "[ fig4 ] we compare the reflection probability @xmath110 calculated numerically using program 6 with @xmath110 calculated by averaging the single - mode @xcite expression @xmath111 over the distribution of energies in the initial wavepacket . while the numerically and analytically estimated @xmath110 are found to agree for large and small @xmath112 , there is a noticeable discrepancy due to the shortcomings of the numerical simulation for @xmath113 .",
    "this discrepancy can be reduced significantly by increasing the number of points in the simulation to 1600 but only at the cost of significantly slowing down the speed of the computation . for our purposes ,",
    "the importance comparing the analytical and numerical calculations is that it gives student a baseline from which to form an opinion or intuition regarding the accuracy of eq .",
    "( [ eq : eight ] ) .",
    "one benefit of incorporating numerical simulation into the teaching of quantum mechanics , as we have mentioned , is the development of student intuition .",
    "another is showing students that non - ideal , real - world problems can be solved using the concepts they learn in the classroom .",
    "however , our experimentation incorporating these simulations in quantum physics at wpi during the past year has shown us that the most important benefit is a type of side - effect to doing numerical simulation : the acceptance on an intuitive level by the student that functions are like vectors and differential operators are like matrices . while in the present paper , we have only had sufficient space to present the most illustrative matlab codes , our goal is to eventualy make available a more complete set of polished codes is available for downloading either from the authors or directly from the file exchange at matlab central.@xcite            h. gould , `` computational physics and the undergraduate curriculum , '' _ comput .",
    "commun . _ * 127 * , 610 ( 2000 ) ; j. tobochnik and h. gould , `` teaching computational physics to undergraduates , '' in _ ann .",
    "compu . phys .",
    "ix _ , edited by d. stauffer ( world scientific , singapore , 2001 ) , p. 275 ; h. gould , j. tobochnik , w. christian , _ an introduction to computer simulation methods : applications to physical systems _ , ( benjamin cummings , upper saddle river , nj , 2006 ) 3rd ed .."
  ],
  "abstract_text": [
    "<S> among the ideas to be conveyed to students in an introductory quantum course , we have the pivotal idea championed by dirac that functions correspond to column vectors ( kets ) and that differential operators correspond to matrices ( ket - bras ) acting on those vectors . </S>",
    "<S> the matlab ( matrix - laboratory ) programming environment is especially useful in conveying these concepts to students because it is geared towards the type of matrix manipulations useful in solving introductory quantum physics problems . in this article </S>",
    "<S> , we share matlab codes which have been developed at wpi , focusing on 1d problems , to be used in conjunction with griffiths introductory text .    </S>",
    "<S> two key concepts underpinning quantum physics are the schrodinger equation and the born probability equation . in 1930 </S>",
    "<S> dirac introduced bra - ket notation for state vectors and operators.@xcite this notation emphasized and clarified the role of inner products and linear function spaces in these two equations and is fundamental to our modern understanding of quantum mechanics . </S>",
    "<S> the schrodinger equation tells us how the state @xmath0 of a particle evolves in time . in bra - ket notation </S>",
    "<S> , it reads @xmath1 where @xmath2 is the hamiltonian operator and @xmath3 is a ket or column vector representing the quantum state of the particle . </S>",
    "<S> when a measurement of a physical quantity @xmath4 is made on a particle initially in the state @xmath0 , the born equation provides a way to calculate the probability @xmath5 that a particular result @xmath6 is obtained from the measurement . in bra - ket notation </S>",
    "<S> , it reads @xcite @xmath7 where if @xmath8 is the state vector corresponding to the particular result @xmath6 having been measured , @xmath9 is the corresponding bra or row vector and @xmath10 is thus the inner product between @xmath8 and @xmath11 . in the dirac formalism , the correspondence between the wavefunction @xmath12 and the ket @xmath3 is set by the relation @xmath13 , where @xmath14 is the state vector corresponding to the particle being located at @xmath15 . </S>",
    "<S> thus we regard @xmath16 as a component of a state vector @xmath17 , just as we usually @xcite regard @xmath18 @xmath19 as a component of @xmath20 along the direction  . </S>",
    "<S> similarly , we think of the hamiltonian operator as a matrix @xmath21 acting on the space of kets .    while an expert will necessarily regard eqs.(1 - 3 ) as a great simplification when thinking of the content of quantum physics , the novice often understandably reels under the weight of the immense abstraction . </S>",
    "<S> we learn much about student thinking from from the answers given by our best students . </S>",
    "<S> for example , we find a common error when studying 1d quantum mechanics is a student treating @xmath22 and @xmath11 interchangeably , ignoring the fact that the first is a scalar but the ket corresponds to a column vector . for example , they may write incorrectly @xmath23 or some similar abberation . to avoid these types of misconceptions , a number of educators and textbook authors have stressed incorporating a numerical calculation aspect to quantum courses.@xcite the motive is simple . </S>",
    "<S> anyone who has done numerical calculations ca nt help but regard a ket @xmath11 as a column vector , a bra @xmath24 as a row vector and an operator @xmath25 as a matrix because that is how they concretely represented in the computer . </S>",
    "<S> introducing a computational aspect to the course provides one further benefit : it gives the beginning quantum student the sense that he or she is being empowered to solve real problems that may not have simple , analytic solutions .    with these motivations in mind , </S>",
    "<S> we have developed matlab codes @xcite for solving typical 1 d problems found in the first part of a junior level quantum course based on griffith s book.@xcite we chose matlab for our programming environment because the matlab syntax is especially simple for the typical matrix operations used in 1d quantum mechanics problems and because of the ease of plotting functions . while some matlab numerical recipes have previously been published by others,@xcite the exercises we share here are special because they emphasize simplicity and quantum pedagogy , not numerical efficiency . </S>",
    "<S> our point has been to provide exercises which show students how to numerically solve 1 d problems in such a way that emphasizes the column vector aspect of kets , the row vector aspect of bras and the matrix aspect of operators . </S>",
    "<S> exercises using more efficient matlab ode solvers or finite - element techniques are omitted because they do not serve this immediate purpose . in part </S>",
    "<S> ii of this article , we hope to share matlab codes which can be used in conjunction with teaching topics pertaining to angular momentum and non - commuting observables . </S>"
  ]
}